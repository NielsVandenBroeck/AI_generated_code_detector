contestId,index,name,type,tags,problem-description,input-specification,output-specification,demo-input,demo-output,note,verdict,code,ai_generated_code
731,A,Night at the Museum,PROGRAMMING,"['implementation', 'strings']","Grigoriy, like the hero of one famous comedy film, found a job as a night security guard at the museum. At first night he received embosser and was to take stock of the whole exposition.

Embosser is a special devise that allows to ""print"" the text of a plastic tape. Text is printed sequentially, character by character. The device consists of a wheel with a lowercase English letters written in a circle, static pointer to the current letter and a button that print the chosen letter. At one move it's allowed to rotate the alphabetic wheel one step clockwise or counterclockwise. Initially, static pointer points to letter 'a'. Other letters are located as shown on the picture:

After Grigoriy add new item to the base he has to print its name on the plastic tape and attach it to the corresponding exhibit. It's not required to return the wheel to its initial position with pointer on the letter 'a'.

Our hero is afraid that some exhibits may become alive and start to attack him, so he wants to print the names as fast as possible. Help him, for the given string find the minimum number of rotations of the wheel required to print it.",The only line of input contains the name of some exhibit — the non-empty string consisting of no more than 100 characters. It's guaranteed that the string consists of only lowercase English letters.,"Print one integer — the minimum number of rotations of the wheel, required to print the name given in the input.","['zeus\n', 'map\n', 'ares\n']","['18\n', '35\n', '34\n']","To print the string from the first sample it would be optimal to perform the following sequence of rotations: 
 1.  from 'a' to 'z' (1 rotation counterclockwise), 1.  from 'z' to 'e' (5 clockwise rotations), 1.  from 'e' to 'u' (10 rotations counterclockwise), 1.  from 'u' to 's' (2 counterclockwise rotations).",OK,"alph = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
 'w', 'x', 'y', 'z']
name = input()
rotations = 0
previous = alph.index('a')
for letter in name:
    afterwards = alph.index(letter)
    distance = min((previous - afterwards) % 26, (afterwards - previous) % 26)
    rotations += distance
    previous = afterwards
print(rotations)
","'''
Chat room - Codeforces
https://codeforces.com/problemset/problem/58/A

Problem Details:
    word_base = ""hello""

    example:
'''
def can_say_hello(s):
    word_base = ""hello""
    index = 0
    
    # Loop through each character in the input string
    for char in s:
        # If the current character matches the corresponding character in ""hello""
        if char == word_base[index]:
            index += 1
        # If we've matched all characters in ""hello"", we can stop checking
        if index == len(word_base):
            return ""YES""
    
    # If we finish the loop and haven't matched ""hello"" completely
    return ""NO""

# Input reading
s = input().strip()
print(can_say_hello(s))"
449,B,Jzzhu and Cities,PROGRAMMING,"['graphs', 'greedy', 'shortest paths']","Jzzhu is the president of country A. There are *n* cities numbered from 1 to *n* in his country. City 1 is the capital of A. Also there are *m* roads connecting the cities. One can go from city *u**i* to *v**i* (and vise versa) using the *i*-th road, the length of this road is *x**i*. Finally, there are *k* train routes in the country. One can use the *i*-th train route to go from capital of the country to city *s**i* (and vise versa), the length of this route is *y**i*.

Jzzhu doesn't want to waste the money of the country, so he is going to close some of the train routes. Please tell Jzzhu the maximum number of the train routes which can be closed under the following condition: the length of the shortest path from every city to the capital mustn't change.","The first line contains three integers *n*,<=*m*,<=*k* (2<=≤<=*n*<=≤<=105; 1<=≤<=*m*<=≤<=3·105; 1<=≤<=*k*<=≤<=105).

Each of the next *m* lines contains three integers *u**i*,<=*v**i*,<=*x**i* (1<=≤<=*u**i*,<=*v**i*<=≤<=*n*; *u**i*<=≠<=*v**i*; 1<=≤<=*x**i*<=≤<=109).

Each of the next *k* lines contains two integers *s**i* and *y**i* (2<=≤<=*s**i*<=≤<=*n*; 1<=≤<=*y**i*<=≤<=109).

It is guaranteed that there is at least one way from every city to the capital. Note, that there can be multiple roads between two cities. Also, there can be multiple routes going to the same city from the capital.",Output a single integer representing the maximum number of the train routes which can be closed.,"['5 5 3\n1 2 1\n2 3 2\n1 3 3\n3 4 4\n1 5 5\n3 5\n4 5\n5 5\n', '2 2 3\n1 2 2\n2 1 3\n2 1\n2 2\n2 3\n']","['2\n', '2\n']",none,RUNTIME_ERROR,"from heapq import heapify, heappop, heappush
n , m ,k = map(int , input().split())
graph = [[] for i in range(n)]
for i in range(0 , m):
    a , b , d = map(int , input().split())
    graph[a-1].append((b-1,d))
    graph[b-1].append((a-1,d))
train = []
for i in range(k):
    a , d = map(int , input().split())
    train.append((a-1,d))
def djkestra(source):
        
        heap = []
        heapify(heap)
        distance = [100000000] * n
        distance[source]=0
        
        s = set()
        
        heappush(heap , (0 , source))
        while len(s) < len(graph):
            # print(heap)
            
            minDistance , popedIndex = heappop(heap)
            s.add(popedIndex)
            for curNode , curDist in graph[popedIndex]:
                # print(curNode , curDist)
                #relaxation
                if distance[curNode] > distance[popedIndex] + curDist:
                    distance[curNode] = distance[popedIndex] + curDist
                    heappush(heap , (distance[curNode] , curNode))
        return distance
dist = djkestra(0)
ans = 0
for a , d in train:
    if dist[a] <= d:
        ans +=1

print(ans)","import math

def solve(n, l):
    mmin = abs(l[0] - l[-1])
    i = 0 
    j = n - 1
    
    # Iterate through the soldier heights in a circular manner
    for k in range(1, n):
        # Calculate difference with the next soldier (circularly)
        diff = abs(l[k] - l[k - 1])
        if diff < mmin:
            mmin = diff
            i = k - 1
            j = k

    # Output the indices of the two neighbouring soldiers (1-based indexing)
    print(i + 1, j + 1)

# Example usage:
# n = int(input())
# l = list(map(int, input().split()))
# solve(n, l)"
358,B,Dima and Text Messages,PROGRAMMING,"['brute force', 'strings']","Seryozha has a very changeable character. This time he refused to leave the room to Dima and his girlfriend (her hame is Inna, by the way). However, the two lovebirds can always find a way to communicate. Today they are writing text messages to each other.

Dima and Inna are using a secret code in their text messages. When Dima wants to send Inna some sentence, he writes out all words, inserting a heart before each word and after the last word. A heart is a sequence of two characters: the ""less"" characters (&lt;) and the digit three (3). After applying the code, a test message looks like that: &lt;3*word*1&lt;3*word*2&lt;3 ... *word**n*&lt;3.

Encoding doesn't end here. Then Dima inserts a random number of small English characters, digits, signs ""more"" and ""less"" into any places of the message.

Inna knows Dima perfectly well, so she knows what phrase Dima is going to send her beforehand. Inna has just got a text message. Help her find out if Dima encoded the message correctly. In other words, find out if a text message could have been received by encoding in the manner that is described above.","The first line contains integer *n* (1<=≤<=*n*<=≤<=105) — the number of words in Dima's message. Next *n* lines contain non-empty words, one word per line. The words only consist of small English letters. The total length of all words doesn't exceed 105. 

The last line contains non-empty text message that Inna has got. The number of characters in the text message doesn't exceed 105. A text message can contain only small English letters, digits and signs more and less.","In a single line, print ""yes"" (without the quotes), if Dima decoded the text message correctly, and ""no"" (without the quotes) otherwise.","['3\ni\nlove\nyou\n&lt;3i&lt;3love&lt;23you&lt;3\n', '7\ni\nam\nnot\nmain\nin\nthe\nfamily\n&lt;3i&lt;&gt;3am&lt;3the&lt;3&lt;main&lt;3in&lt;3the&lt;3&gt;&lt;3family&lt;3\n']","['yes\n', 'no\n']",Please note that Dima got a good old kick in the pants for the second sample from the statement.,WRONG_ANSWER,"import sys, os.path
from collections import*
from copy import*
import math
mod=10**9+7
if(os.path.exists('input.txt')):
    sys.stdin = open(""input.txt"",""r"")
    sys.stdout = open(""output.txt"",""w"")

n=int(input())
fake='<3'
for i in range(n):
    s1=input()
    fake+=s1
    fake+='<3'
n1=len(fake)
text=input()
m=len(text)
if(n1>m):
    print(""NO"")
else:
    c=0
    j=0
    i=0
    while(i<m and j<n1):
        if(fake[j]==text[i]):
            c+=1
            j+=1
        i+=1
    if(c==n1):
        print(""YES"")
    else:
        print(""NO"")






    ","def find_diag(x, y, n):
    return [x + y, y + n - x - 1]

def main():
    n = int(input())
    sum1, sum2 = [], []
    board = []

    # Read the chessboard values
    for _ in range(n):
        row = list(map(int, input().split()))
        board.append(row)
    
    # Initialize diagonal sums
    diag1 = [0] * (2 * n)
    diag2 = [0] * (2 * n)

    # Calculate the sums for both sets of diagonals
    for i in range(n):
        for j in range(n):
            d1 = find_diag(i + 1, j + 1, n)[0]  # Main diagonal
            d2 = find_diag(i + 1, j + 1, n)[1]  # Anti diagonal
            diag1[d1] += board[i][j]
            diag2[d2] += board[i][j]

    max_sum = 0
    position = (1, 1, 1, 1)

    # Iterate through each cell to place bishops
    for i in range(n):
        for j in range(n):
            d1 = find_diag(i + 1, j + 1, n)[0]
            d2 = find_diag(i + 1, j + 1, n)[1]

            # Calculate the total money with bishops on current cell and alternate diagonals
            current_sum = diag1[d1] + diag2[d2] - board[i][j]

            # Check for maximum and record positions
            for x in range(n):
                for y in range(n):
                    if (x, y) != (i, j):
                        d1_alt = find_diag(x + 1, y + 1, n)[0]
                        d2_alt = find_diag(x + 1, y + 1, n)[1]
                        if d1 != d1_alt and d2 != d2_alt:
                            current_sum_alt = diag1[d1] + diag2[d2] - board[i][j] + diag1[d1_alt] + diag2[d2_alt] - board[x][y]
                            if current_sum_alt > max_sum:
                                max_sum = current_sum_alt
                                position = (i + 1, j + 1, x + 1, y + 1)

    # Output the results
    print(max_sum)
    print(*position)

if __name__ == ""__main__"":
    main()"
928,A,Login Verification,PROGRAMMING,"['*special', 'strings']","When registering in a social network, users are allowed to create their own convenient login to make it easier to share contacts, print it on business cards, etc.

Login is an arbitrary sequence of lower and uppercase latin letters, digits and underline symbols («_»). However, in order to decrease the number of frauds and user-inattention related issues, it is prohibited to register a login if it is similar with an already existing login. More precisely, two logins *s* and *t* are considered similar if we can transform *s* to *t* via a sequence of operations of the following types: 
 -  transform lowercase letters to uppercase and vice versa; -  change letter «O» (uppercase latin letter) to digit «0» and vice versa; -  change digit «1» (one) to any letter among «l» (lowercase latin «L»), «I» (uppercase latin «i») and vice versa, or change one of these letters to other. 
For example, logins «Codeforces» and «codef0rces» as well as «OO0OOO00O0OOO0O00OOO0OO_lol» and «OO0OOO0O00OOO0O00OO0OOO_1oI» are considered similar whereas «Codeforces» and «Code_forces» are not.

You're given a list of existing logins with no two similar amonst and a newly created user login. Check whether this new login is similar with any of the existing ones.","The first line contains a non-empty string *s* consisting of lower and uppercase latin letters, digits and underline symbols («_») with length not exceeding 50  — the login itself.

The second line contains a single integer *n* (1<=≤<=*n*<=≤<=1<=000) — the number of existing logins.

The next *n* lines describe the existing logins, following the same constraints as the user login (refer to the first line of the input). It's guaranteed that no two existing logins are similar.","Print «Yes» (without quotes), if user can register via this login, i.e. none of the existing logins is similar with it.

Otherwise print «No» (without quotes).","['1_wat\n2\n2_wat\nwat_1\n', '000\n3\n00\nooA\noOo\n', '_i_\n3\n__i_\n_1_\nI\n', 'La0\n3\n2a0\nLa1\n1a0\n', 'abc\n1\naBc\n', '0Lil\n2\nLIL0\n0Ril\n']","['Yes\n', 'No\n', 'No\n', 'No\n', 'No\n', 'Yes\n']","In the second sample case the user wants to create a login consisting of three zeros. It's impossible due to collision with the third among the existing.

In the third sample case the new login is similar with the second one.",OK,"ss = input()
st = """"
for j in range(len(ss)):
    c = ss[j]
    if 'A' <= c <= 'Z':
        c = chr(ord(c) + ord('a') - ord('A'))
    if c == 'o':
        c = '0'
    if c == 'l' or c == 'i':
        c = '1'
    st += c
s = st
n = int(input())
for i in range(n):
    ss = input()
    st = """"
    for j in range(len(ss)):
        c = ss[j]
        if 'A' <= c <= 'Z':
            c = chr(ord(c) + ord('a') - ord('A'))
        if c == 'o':
            c = '0'
        if c == 'l' or c == 'i':
            c = '1'
        st += c
    if s == st:
        print(""No"")
        exit()
print(""Yes"")
","import sys

def data():
    return sys.stdin.readline().strip()

def max_jokes(n, d, song_times):
    total_singing_time = sum(song_times)
    total_rest_time = 10 * (n - 1) if n > 1 else 0
    
    total_time_needed = total_singing_time + total_rest_time
    if total_time_needed > d:
        return -1
    
    remaining_time = d - total_time_needed
    jokes = remaining_time // 5
    
    # Total jokes = jokes during rests + jokes during remaining time
    return (n - 1) * 2 + jokes

# Reading input
n, d = map(int, data().split())
song_times = list(map(int, data().split()))

# Calculating the maximum jokes
result = max_jokes(n, d, song_times)

# Printing the result
print(result)"
34,C,Page Numbers,PROGRAMMING,"['expression parsing', 'implementation', 'sortings', 'strings']","«Bersoft» company is working on a new version of its most popular text editor — Bord 2010. Bord, like many other text editors, should be able to print out multipage documents. A user keys a sequence of the document page numbers that he wants to print out (separates them with a comma, without spaces).

Your task is to write a part of the program, responsible for «standardization» of this sequence. Your program gets the sequence, keyed by the user, as input. The program should output this sequence in format *l*1-*r*1,*l*2-*r*2,...,*l**k*-*r**k*, where *r**i*<=+<=1<=&lt;<=*l**i*<=+<=1 for all *i* from 1 to *k*<=-<=1, and *l**i*<=≤<=*r**i*. The new sequence should contain all the page numbers, keyed by the user, and nothing else. If some page number appears in the input sequence several times, its appearances, starting from the second one, should be ignored. If for some element *i* from the new sequence *l**i*<==<=*r**i*, this element should be output as *l**i*, and not as «*l**i*<=-<=*l**i*».

For example, sequence 1,2,3,1,1,2,6,6,2 should be output as 1-3,6.","The only line contains the sequence, keyed by the user. The sequence contains at least one and at most 100 positive integer numbers. It's guaranteed, that this sequence consists of positive integer numbers, not exceeding 1000, separated with a comma, doesn't contain any other characters, apart from digits and commas, can't end with a comma, and the numbers don't contain leading zeroes. Also it doesn't start with a comma or contain more than one comma in a row.",Output the sequence in the required format.,"['1,2,3,1,1,2,6,6,2\n', '3,2,1\n', '30,20,10\n']","['1-3,6\n', '1-3\n', '10,20,30\n']",none,OK,"a = sorted(set(map(int, input().split("",""))))
left = right = a[0]
for x in a[1:]:
    if x - right > 1:
        if left == right:
            print(left, end="","")
        else:
            print(left, right, sep=""-"", end="","")
        left = x
    right = x
if left == right:
    print(left)
else:
    print(left, right, sep=""-"")
","def solve(n, arr):
    d = {}
    for i in arr:
        d[i] = d.get(i, 0) + 1
    res = 0

    # Create a list of unique elements, sorted in ascending order
    unique_elements = sorted(d.keys())
    
    # Use a variable to keep track of the last element's value for skipping
    last_taken = -1

    for elem in unique_elements:
        # If the current element is not adjacent to the last taken element
        if elem - 1 != last_taken:
            # We can take all points from the current element
            res += elem * d[elem]
            last_taken = elem  # Update the last taken element
        else:
            # We can only take the points from the current element if we skipped the last one
            if elem + 1 in d:
                # Maximum points we can take: current + points from the previous non-adjacent
                res += elem * d[elem]
            else:
                # Take points if there is no adjacent
                res += elem * d[elem]

    print(res)

# Example usage
n = int(input())
arr = list(map(int, input().split()))
solve(n, arr)"
471,A,MUH and Sticks,PROGRAMMING,['implementation'],"Two polar bears Menshykov and Uslada from the St.Petersburg zoo and elephant Horace from the Kiev zoo got six sticks to play with and assess the animals' creativity. Menshykov, Uslada and Horace decided to make either an elephant or a bear from those sticks. They can make an animal from sticks in the following way: 
 -  Four sticks represent the animal's legs, these sticks should have the same length. -  Two remaining sticks represent the animal's head and body. The bear's head stick must be shorter than the body stick. The elephant, however, has a long trunk, so his head stick must be as long as the body stick. Note that there are no limits on the relations between the leg sticks and the head and body sticks. 
Your task is to find out which animal can be made from the given stick set. The zoo keeper wants the sticks back after the game, so they must never be broken, even bears understand it.",The single line contains six space-separated integers *l**i* (1<=≤<=*l**i*<=≤<=9) — the lengths of the six sticks. It is guaranteed that the input is such that you cannot make both animals from the sticks.,"If you can make a bear from the given set, print string ""Bear"" (without the quotes). If you can make an elephant, print string ""Elephant"" (wıthout the quotes). If you can make neither a bear nor an elephant, print string ""Alien"" (without the quotes).","['4 2 5 4 4 4\n', '4 4 5 4 4 5\n', '1 2 3 4 5 6\n']","['Bear', 'Elephant', 'Alien']","If you're out of creative ideas, see instructions below which show how to make a bear and an elephant in the first two samples. The stick of length 2 is in red, the sticks of length 4 are in green, the sticks of length 5 are in blue.",WRONG_ANSWER,"'''input
4 2 5 4 4 4
'''
l = list(map(int, input().split()))
x = sorted([l.count(i) for i in set(l)])
if x == [6] or x == [2, 4]:
	print(""Elephant"")
elif x == [1, 1, 4]:
	print(""Bear"")
else:
	print(""Alien"")









","# 3 5
# 1 2 3

d={}
def dp(l,m,s,i,c):
    if s % m == 0 and c != 0:
        return 1 
    if i >= l:
        return 0 

    # Include the current element
    include_current = dp(l, m, s + a[i], i + 1, c + 1)

    # Exclude the current element
    exclude_current = dp(l, m, s, i + 1, c)

    return include_current or exclude_current

# Read input values
n, m = map(int, input().split())
a = list(map(int, input().split()))

# Base case for dynamic programming
if n > m:  # Pigeonhole principle
    print(""YES"")
else:
    if dp(n, m, 0, 0, 0):
        print(""YES"")
    else:
        print(""NO"")"
339,A,Helpful Maths,PROGRAMMING,"['greedy', 'implementation', 'sortings', 'strings']","Xenia the beginner mathematician is a third year student at elementary school. She is now learning the addition operation.

The teacher has written down the sum of multiple numbers. Pupils should calculate the sum. To make the calculation easier, the sum only contains numbers 1, 2 and 3. Still, that isn't enough for Xenia. She is only beginning to count, so she can calculate a sum only if the summands follow in non-decreasing order. For example, she can't calculate sum 1+3+2+1 but she can calculate sums 1+1+2 and 3+3.

You've got the sum that was written on the board. Rearrange the summans and print the sum in such a way that Xenia can calculate the sum.","The first line contains a non-empty string *s* — the sum Xenia needs to count. String *s* contains no spaces. It only contains digits and characters ""+"". Besides, string *s* is a correct sum of numbers 1, 2 and 3. String *s* is at most 100 characters long.",Print the new sum that Xenia can count.,"['3+2+1\n', '1+1+3+1+3\n', '2\n']","['1+2+3\n', '1+1+1+3+3\n', '2\n']",none,OK,"s1 = input()
nums=[]
for i in s1 :
     if i.isdigit():
         nums.append((""+""+i))
nums.sort()
x=("""".join(nums[0:]))
print(x.replace(""+"","""",1))
","def count_com(graph):
    def dfs(graph, node, visited):
        visited[node] = True
        mini = costs[node]  # Start with the cost of the current node
        stack = [node]
        
        while stack:
            a = stack.pop()
            for neighbor in graph[a]:
                if not visited[neighbor]:
                    visited[neighbor] = True
                    stack.append(neighbor)
                    mini = min(mini, costs[neighbor])  # Update the minimum cost
        
        return mini
    
    n = len(graph)  # Number of nodes
    costs = [0] * n  # Costs to spread the rumor
    total_cost = 0
    visited = [False] * n  # To keep track of visited nodes

    # Iterate through each character
    for i in range(n):
        if not visited[i]:  # If the character is not yet visited
            total_cost += dfs(graph, i, visited)  # Add the cost of spreading the rumor
        
    return total_cost

# Input reading
n, m = map(int, input().split())
costs = list(map(int, input().split()))
graph = [[] for _ in range(n)]

# Read friendships
for _ in range(m):
    x, y = map(int, input().split())
    graph[x - 1].append(y - 1)  # Convert to 0-based index
    graph[y - 1].append(x - 1)  # Because it's an undirected graph

# Compute and print the result
print(count_com(graph))"
766,A,Mahmoud and Longest Uncommon Subsequence,PROGRAMMING,"['constructive algorithms', 'strings']","While Mahmoud and Ehab were practicing for IOI, they found a problem which name was Longest common subsequence. They solved it, and then Ehab challenged Mahmoud with another problem.

Given two strings *a* and *b*, find the length of their longest uncommon subsequence, which is the longest string that is a subsequence of one of them and not a subsequence of the other.

A subsequence of some string is a sequence of characters that appears in the same order in the string, The appearances don't have to be consecutive, for example, strings ""ac"", ""bc"", ""abc"" and ""a"" are subsequences of string ""abc"" while strings ""abbc"" and ""acb"" are not. The empty string is a subsequence of any string. Any string is a subsequence of itself.","The first line contains string *a*, and the second line — string *b*. Both of these strings are non-empty and consist of lowercase letters of English alphabet. The length of each string is not bigger than 105 characters.","If there's no uncommon subsequence, print ""-1"". Otherwise print the length of the longest uncommon subsequence of *a* and *b*.","['abcd\ndefgh\n', 'a\na\n']","['5\n', '-1\n']","In the first example: you can choose ""defgh"" from string *b* as it is the longest subsequence of string *b* that doesn't appear as a subsequence of string *a*.",OK,"s1 = input()
s2 = input()

if s1 == s2:
    print(-1)
elif len(s1) > len(s2):
    print(len(s1))
elif len(s2) > len(s1):
    print(len(s2))
else:
    print(len(s1))","def count(row):
    maxCoin = 1
    numCoin = 1
    for i in range(1, len(row)):
        if row[i] == row[i - 1] and row[i] == 1:
            numCoin += 1
        else:
            maxCoin = max(maxCoin, numCoin)
            numCoin = 1 if row[i] == 1 else 0
    maxCoin = max(maxCoin, numCoin)
    return maxCoin

def main():
    import sys
    input = sys.stdin.read
    data = input().splitlines()
    
    n, m, q = map(int, data[0].split())
    grid = [list(map(int, data[i + 1].split())) for i in range(n)]
    queries = [tuple(map(int, data[i + n + 1].split())) for i in range(q)]

    scores = []
    for query in queries:
        i, j = query
        i -= 1  # To convert to 0-indexed
        j -= 1  # To convert to 0-indexed
        
        grid[i][j] = 1 - grid[i][j]  # Toggle the state of the bear
        
        max_score = 0
        for row in grid:
            max_score = max(max_score, count(row))

        scores.append(max_score)

    print('\n'.join(map(str, scores)))

if __name__ == ""__main__"":
    main()"
58,A,Chat room,PROGRAMMING,"['greedy', 'strings']","Vasya has recently learned to type and log on to the Internet. He immediately entered a chat room and decided to say hello to everybody. Vasya typed the word *s*. It is considered that Vasya managed to say hello if several letters can be deleted from the typed word so that it resulted in the word ""hello"". For example, if Vasya types the word ""ahhellllloou"", it will be considered that he said hello, and if he types ""hlelo"", it will be considered that Vasya got misunderstood and he didn't manage to say hello. Determine whether Vasya managed to say hello by the given word *s*.","The first and only line contains the word *s*, which Vasya typed. This word consisits of small Latin letters, its length is no less that 1 and no more than 100 letters.","If Vasya managed to say hello, print ""YES"", otherwise print ""NO"".","['ahhellllloou\n', 'hlelo\n']","['YES\n', 'NO\n']",none,WRONG_ANSWER,"d=['h','e','l','o']
a=list(input())
e=[]
for j in a:
    if j not in e and j in d:
        e.append(j)
if e==d and a.count('l')>=2:
    print(""YES"")
else:
    print(""NO"")
    ","import sys
from math import gcd

def game_winner(a: int, b: int, n: int) -> int:
    # While there are stones left in the heap
    while n > 0:
        # Simon's turn
        take_simon = gcd(a, n)
        if take_simon > n:
            return 1  # Antisimon wins
        n -= take_simon
        
        # Antisimon's turn
        take_antisimon = gcd(b, n)
        if take_antisimon > n:
            return 0  # Simon wins
        n -= take_antisimon

if __name__ == ""__main__"":
    # Read input from standard input
    input_data = sys.stdin.read().strip()
    a, b, n = map(int, input_data.split())
    
    # Determine the winner and print the result
    print(game_winner(a, b, n))"
978,B,File Name,PROGRAMMING,"['greedy', 'strings']","You can not just take the file and send it. When Polycarp trying to send a file in the social network ""Codehorses"", he encountered an unexpected problem. If the name of the file contains three or more ""x"" (lowercase Latin letters ""x"") in a row, the system considers that the file content does not correspond to the social network topic. In this case, the file is not sent and an error message is displayed.

Determine the minimum number of characters to remove from the file name so after that the name does not contain ""xxx"" as a substring. Print 0 if the file name does not initially contain a forbidden substring ""xxx"".

You can delete characters in arbitrary positions (not necessarily consecutive). If you delete a character, then the length of a string is reduced by $1$. For example, if you delete the character in the position $2$ from the string ""exxxii"", then the resulting string is ""exxii"".","The first line contains integer $n$ $(3 \le n \le 100)$ — the length of the file name.

The second line contains a string of length $n$ consisting of lowercase Latin letters only — the file name.","Print the minimum number of characters to remove from the file name so after that the name does not contain ""xxx"" as a substring. If initially the file name dost not contain a forbidden substring ""xxx"", print 0.","['6\nxxxiii\n', '5\nxxoxx\n', '10\nxxxxxxxxxx\n']","['1\n', '0\n', '8\n']","In the first example Polycarp tried to send a file with name contains number $33$, written in Roman numerals. But he can not just send the file, because it name contains three letters ""x"" in a row. To send the file he needs to remove any one of this letters.",WRONG_ANSWER,"n = int(input())
l = list(input())
count = 0
for x in reversed(range(n)):
    if x < 2:
        break
    if l[x] == ""x"" and l[x-1] == ""x"" and l[x-2] == ""x"":
        l.remove(l[x])
        count = count + 1
print(count)","def HOD(a,b):
    if b == 0:
        return a
    else:
        return HOD(b, a % b)

def HOK(a, b):
    return a // HOD(a, b) * b

def can_make_equal_bids(bids):
    # Normalize all bids by removing factors of 2 and 3
    def normalize(x):
        while x % 2 == 0:
            x //= 2
        while x % 3 == 0:
            x //= 3
        return x

    normalized_bids = set(normalize(bid) for bid in bids)
    
    # If all normalized bids are the same, we can make bids equal
    return len(normalized_bids) == 1

# Read input
n = int(input().strip())
bids = list(map(int, input().strip().split()))

# Check if we can make all bids equal
if can_make_equal_bids(bids):
    print(""Yes"")
else:
    print(""No"")"
298,A,Snow Footprints,PROGRAMMING,"['greedy', 'implementation']","There is a straight snowy road, divided into *n* blocks. The blocks are numbered from 1 to *n* from left to right. If one moves from the *i*-th block to the (*i*<=+<=1)-th block, he will leave a right footprint on the *i*-th block. Similarly, if one moves from the *i*-th block to the (*i*<=-<=1)-th block, he will leave a left footprint on the *i*-th block. If there already is a footprint on the *i*-th block, the new footprint will cover the old one.

At the beginning, there were no footprints. Then polar bear Alice starts from the *s*-th block, makes a sequence of moves and ends in the *t*-th block. It is known that Alice never moves outside of the road. 

You are given the description of Alice's footprints. Your task is to find a pair of possible values of *s*,<=*t* by looking at the footprints.","The first line of the input contains integer *n* (3<=≤<=*n*<=≤<=1000).

The second line contains the description of the road — the string that consists of *n* characters. Each character will be either ""."" (a block without footprint), or ""L"" (a block with a left footprint), ""R"" (a block with a right footprint).

It's guaranteed that the given string contains at least one character not equal to ""."". Also, the first and the last character will always be ""."". It's guaranteed that a solution exists.",Print two space-separated integers — the values of *s* and *t*. If there are several possible solutions you can print any of them.,"['9\n..RRLL...\n', '11\n.RRRLLLLL..\n']","['3 4\n', '7 5\n']",The first test sample is the one in the picture.,OK,"import string
n=int(input())
s=input()
if 'L' not in s:
    print(s.find('R')+1,s.rfind('R')+2)
elif 'R' not in s:
    print(s.rfind('L')+1,s.find('L'))
elif 'R' in s and 'L' in s:
    print(s.find('R')+1,s.find(""L"")) ","dep=0
def check(tmp, dep):
    l = len(tmp)
    if l == 1:
        return dep
    elif l == 0:
        return False
    s1 = tmp[:l // 2]
    s2 = tmp[-(l // 2):]
    
    if s1 == s2:
        # If the left and right halves are equal, check for k-palindrome
        # Increment the depth for valid k-palindrome
        return check(s1, dep + 1)
    else:
        return False

def count_palindromic_characteristics(s):
    n = len(s)
    result = [0] * n
    
    # Count 1-palindromes
    for length in range(1, n + 1):
        for start in range(n - length + 1):
            substring = s[start:start + length]
            if substring == substring[::-1]:
                result[0] += 1  # Count 1-palindrome
    
    # Count k-palindromes for k > 1
    for k in range(1, n):
        for length in range(2 * (k + 1), n + 1):
            for start in range(n - length + 1):
                substring = s[start:start + length]
                if check(substring, 1) == k:  # check if it's k-palindrome
                    result[k] += 1
    
    return result

# Input reading
s = input().strip()
# Getting the palindromic characteristics
output = count_palindromic_characteristics(s)
# Printing the results
print(' '.join(map(str, output)))"
610,A,Pasha and Stick,PROGRAMMING,"['combinatorics', 'math']","Pasha has a wooden stick of some positive integer length *n*. He wants to perform exactly three cuts to get four parts of the stick. Each part must have some positive integer length and the sum of these lengths will obviously be *n*. 

Pasha likes rectangles but hates squares, so he wonders, how many ways are there to split a stick into four parts so that it's possible to form a rectangle using these parts, but is impossible to form a square.

Your task is to help Pasha and count the number of such ways. Two ways to cut the stick are considered distinct if there exists some integer *x*, such that the number of parts of length *x* in the first way differ from the number of parts of length *x* in the second way.",The first line of the input contains a positive integer *n* (1<=≤<=*n*<=≤<=2·109) — the length of Pasha's stick.,"The output should contain a single integer — the number of ways to split Pasha's stick into four parts of positive integer length so that it's possible to make a rectangle by connecting the ends of these parts, but is impossible to form a square.","['6\n', '20\n']","['1\n', '4\n']","There is only one way to divide the stick in the first sample {1, 1, 2, 2}.

Four ways to divide the stick in the second sample are {1, 1, 9, 9}, {2, 2, 8, 8}, {3, 3, 7, 7} and {4, 4, 6, 6}. Note that {5, 5, 5, 5} doesn't work.",WRONG_ANSWER,"num = int(input())

if num % 2 == 1 or num < 5:
    print(""NO"")
else:
    cnt = 0
    for i in range(1, num // 4+1):
        ans = [i, i, num // 2 - i, num // 2 - i]

        if len(set(ans)) != 1:
            cnt += 1

    print(cnt)

","import sys
import math

def get_ints():
    return map(int, sys.stdin.readline().strip().split())

def get_array():
    return list(map(int, sys.stdin.readline().strip().split()))

def get_string():
    return sys.stdin.readline().strip()

def largest_lovely_number(n):
    # Function to get largest lovely number from divisors of n
    max_lovely = 1  # Start with the smallest lovely number

    # Iterate through all integers from 1 to sqrt(n) to find divisors
    for i in range(1, int(math.sqrt(n)) + 1):
        if n % i == 0:
            # i is a divisor
            if is_lovely(i):
                max_lovely = max(max_lovely, i)
            # n // i is also a divisor
            if is_lovely(n // i):
                max_lovely = max(max_lovely, n // i)

    return max_lovely

def is_lovely(x):
    # Check if the number x is lovely
    for i in range(2, int(math.sqrt(x)) + 1):
        if x % (i * i) == 0:
            return False
    return True

if __name__ == ""__main__"":
    n = int(get_string())
    print(largest_lovely_number(n))"
2,B,The least round way,PROGRAMMING,"['dp', 'math']","There is a square matrix *n*<=×<=*n*, consisting of non-negative integer numbers. You should find such a way on it that 
 -  starts in the upper left cell of the matrix; -  each following cell is to the right or down from the current cell; -  the way ends in the bottom right cell. 
Moreover, if we multiply together all the numbers along the way, the result should be the least ""round"". In other words, it should end in the least possible number of zeros.","The first line contains an integer number *n* (2<=≤<=*n*<=≤<=1000), *n* is the size of the matrix. Then follow *n* lines containing the matrix elements (non-negative integer numbers not exceeding 109).",In the first line print the least number of trailing zeros. In the second line print the correspondent way itself.,['3\n1 2 3\n4 5 6\n7 8 9\n'],['0\nDDRR\n'],none,WRONG_ANSWER,"from math import log2

def hp2(n):
	if n % 2 != 0: return 0
	return round(log2((n & (~(n - 1)))))

def hp5(n):
	if n % 5 != 0: return 0
	p = 1
	m = 5
	while n % m == 0:
		p += 1
		m *= 5
	return p - 1 


def extract(x):
	t, f = hp2(x), hp5(x)
	zeros = min(t, f)
	# print(""extracting"", x, (zeros, t - zeros, f - zeros))
	return (zeros, t - zeros, f - zeros)

inf = float(""Inf"")
def count(x, y):
	if(memo[x][y] != None):
		return memo[x][y]

	tempZ, tempT, tempF = extract(m[x][y])
	step = -1 # 0 for up, 1 for left, -1 for start
	if x == 0 and y == 0:
		ans = (tempZ, tempT, tempF)
	else:
		ans = (inf, inf, inf)
		if x > 0:
			temp = count(x - 1, y)
			z = temp[0] + tempZ
			netF, netT = temp[2] + tempF, temp[1] + tempT
			k = min(netF, netT)
			z += k
			if z < ans[0]:
				step = 0
				ans = (z, netT - k, netF - k)
		if y > 0:
			temp = count(x, y - 1)
			z = temp[0] + tempZ
			netF, netT = temp[2] + tempF, temp[1] + tempT
			k = min(netF, netT)
			z += k
			if z < ans[0]:
				step = 1
				ans = (z, netT - k, netF - k)

	# print(x, y, ans, ""from"", ""left"" if step == 0 else ""right"")
	memo[x][y] = ans
	steps[x][y] = step
	return ans

n = int(input())
m = [[0 for i in range(n)] for i in range(n)]
memo = [[None for i in range(n)] for i in range(n)]
steps = [[-1 for i in range(n)] for i in range(n)]

for i in range(n):
	r = [int(k) for k in input().split()]
	for j in range(n):
		m[i][j] = r[j]

ans = count(n - 1, n - 1)[0]
path = """"
x, y = n - 1, n - 1
while not (x == 0 and y == 0):
	# print(steps[x][y])
	if steps[x][y] == 0:
		path = ""D"" + path
		x -= 1
	else:
		path = ""R"" + path
		y -= 1
print(ans)
print(path)
","def sol(a, b):
    # Calculate the number of hours
    hours = a
    # Calculate the number of times b can be divided into a
    while a >= b:
        z = a // b  # Number of new candles created from burnt ones
        hours += z  # Add to total hours
        a = a % b + z  # Remaining burnt candles plus newly created candles
    return hours

# Example usage
a, b = map(int, input().split())
print(sol(a, b))"
611,C,New Year and Domino,PROGRAMMING,"['dp', 'implementation']","They say ""years are like dominoes, tumbling one after the other"". But would a year fit into a grid? I don't think so.

Limak is a little polar bear who loves to play. He has recently got a rectangular grid with *h* rows and *w* columns. Each cell is a square, either empty (denoted by '.') or forbidden (denoted by '#'). Rows are numbered 1 through *h* from top to bottom. Columns are numbered 1 through *w* from left to right.

Also, Limak has a single domino. He wants to put it somewhere in a grid. A domino will occupy exactly two adjacent cells, located either in one row or in one column. Both adjacent cells must be empty and must be inside a grid.

Limak needs more fun and thus he is going to consider some queries. In each query he chooses some rectangle and wonders, how many way are there to put a single domino inside of the chosen rectangle?","The first line of the input contains two integers *h* and *w* (1<=≤<=*h*,<=*w*<=≤<=500) – the number of rows and the number of columns, respectively.

The next *h* lines describe a grid. Each line contains a string of the length *w*. Each character is either '.' or '#' — denoting an empty or forbidden cell, respectively.

The next line contains a single integer *q* (1<=≤<=*q*<=≤<=100<=000) — the number of queries.

Each of the next *q* lines contains four integers *r*1*i*, *c*1*i*, *r*2*i*, *c*2*i* (1<=≤<=*r*1*i*<=≤<=*r*2*i*<=≤<=*h*,<=1<=≤<=*c*1*i*<=≤<=*c*2*i*<=≤<=*w*) — the *i*-th query. Numbers *r*1*i* and *c*1*i* denote the row and the column (respectively) of the upper left cell of the rectangle. Numbers *r*2*i* and *c*2*i* denote the row and the column (respectively) of the bottom right cell of the rectangle.","Print *q* integers, *i*-th should be equal to the number of ways to put a single domino inside the *i*-th rectangle.","['5 8\n....#..#\n.#......\n##.#....\n##..#.##\n........\n4\n1 1 2 3\n4 1 4 1\n1 2 4 5\n2 5 5 8\n', '7 39\n.......................................\n.###..###..#..###.....###..###..#..###.\n...#..#.#..#..#.........#..#.#..#..#...\n.###..#.#..#..###.....###..#.#..#..###.\n.#....#.#..#....#.....#....#.#..#..#.#.\n.###..###..#..###.....###..###..#..###.\n.......................................\n6\n1 1 3 20\n2 10 6 30\n2 10 7 30\n2 2 7 7\n1 7 7 7\n1 8 7 8\n']","['4\n0\n10\n15\n', '53\n89\n120\n23\n0\n2\n']",A red frame below corresponds to the first query of the first sample. A domino can be placed in 4 possible ways.,OK,"read = lambda: map(int, input().split())
h, w = read()
a = [input() for i in range(h)]
N = 501
vr = [[0] * N for i in range(N)]
hr = [[0] * N for i in range(N)]
for i in range(h):
    for j in range(w):
        vr[j + 1][i + 1] = vr[j][i + 1] + vr[j + 1][i] - vr[j][i]
        hr[j + 1][i + 1] = hr[j][i + 1] + hr[j + 1][i] - hr[j][i]
        if a[i][j] == '#': continue
        if i != h - 1 and a[i + 1][j] == '.': vr[j + 1][i + 1] += 1
        if j != w - 1 and a[i][j + 1] == '.': hr[j + 1][i + 1] += 1
q = int(input())
for i in range(q):
    r1, c1, r2, c2 = read()
    p1 = hr[c2 - 1][r2] - hr[c1 - 1][r2] - hr[c2 - 1][r1 - 1] + hr[c1 - 1][r1 - 1]
    p2 = vr[c2][r2 - 1] - vr[c1 - 1][r2 - 1] - vr[c2][r1 - 1] + vr[c1 - 1][r1 - 1]
    ans = p1 + p2
    print(ans)
","k, a, b = map(int, input().split())

A = []
for i in range(3):
    l = list(map(int, input().split()))
    l = [x - 1 for x in l]
    A.append(l)

B = []
for i in range(3):
    l = list(map(int, input().split()))
    l = [x - 1 for x in l]
    B.append(l)

# Initialize scores for Alice and Bob
alice_score = 0
bob_score = 0

# Use a dictionary to track the results of previous games
state_count = {}

# Play the game k times or until we find a cycle
for _ in range(k):
    if (a, b) in state_count:
        # Cycle detected
        cycle_start = state_count[(a, b)]
        cycle_length = _ - cycle_start
        remaining_games = k - _
        
        # How many full cycles we can do
        full_cycles = remaining_games // cycle_length
        alice_score += full_cycles * (alice_score - state_count[(a, b)][0])
        bob_score += full_cycles * (bob_score - state_count[(a, b)][1])
        
        # Adjust the remaining games after full cycles
        remaining_games %= cycle_length
        break

    # Record the current state and scores
    state_count[(a, b)] = (alice_score, bob_score)

    # Determine the winner and update scores based on rules
    if a == b:
        pass  # Draw
    elif (a == 1 and b == 3) or (a == 2 and b == 1) or (a == 3 and b == 2):
        bob_score += 1  # Bob wins
    else:
        alice_score += 1  # Alice wins

    # Update choices based on current state
    a = A[a][b]
    b = B[a][b]

# Output the final scores
print(alice_score, bob_score)"
500,A,New Year Transportation,PROGRAMMING,"['dfs and similar', 'graphs', 'implementation']","New Year is coming in Line World! In this world, there are *n* cells numbered by integers from 1 to *n*, as a 1<=×<=*n* board. People live in cells. However, it was hard to move between distinct cells, because of the difficulty of escaping the cell. People wanted to meet people who live in other cells.

So, user tncks0121 has made a transportation system to move between these cells, to celebrate the New Year. First, he thought of *n*<=-<=1 positive integers *a*1,<=*a*2,<=...,<=*a**n*<=-<=1. For every integer *i* where 1<=≤<=*i*<=≤<=*n*<=-<=1 the condition 1<=≤<=*a**i*<=≤<=*n*<=-<=*i* holds. Next, he made *n*<=-<=1 portals, numbered by integers from 1 to *n*<=-<=1. The *i*-th (1<=≤<=*i*<=≤<=*n*<=-<=1) portal connects cell *i* and cell (*i*<=+<=*a**i*), and one can travel from cell *i* to cell (*i*<=+<=*a**i*) using the *i*-th portal. Unfortunately, one cannot use the portal backwards, which means one cannot move from cell (*i*<=+<=*a**i*) to cell *i* using the *i*-th portal. It is easy to see that because of condition 1<=≤<=*a**i*<=≤<=*n*<=-<=*i* one can't leave the Line World using portals.

Currently, I am standing at cell 1, and I want to go to cell *t*. However, I don't know whether it is possible to go there. Please determine whether I can go to cell *t* by only using the construted transportation system.","The first line contains two space-separated integers *n* (3<=≤<=*n*<=≤<=3<=×<=104) and *t* (2<=≤<=*t*<=≤<=*n*) — the number of cells, and the index of the cell which I want to go to.

The second line contains *n*<=-<=1 space-separated integers *a*1,<=*a*2,<=...,<=*a**n*<=-<=1 (1<=≤<=*a**i*<=≤<=*n*<=-<=*i*). It is guaranteed, that using the given transportation system, one cannot leave the Line World.","If I can go to cell *t* using the transportation system, print ""YES"". Otherwise, print ""NO"".","['8 4\n1 2 1 2 1 2 1\n', '8 5\n1 2 1 2 1 1 1\n']","['YES\n', 'NO\n']","In the first sample, the visited cells are: 1, 2, 4; so we can successfully visit the cell 4.

In the second sample, the possible cells to visit are: 1, 2, 4, 6, 7, 8; so we can't visit the cell 5, which we want to visit.",WRONG_ANSWER,"n=[int(x) for x in input().split(' ')]
c=[int(x) for x in input().split(' ')]
respuesta=""NO""
cont=1
while cont<n[0]:
    if(cont==n[1]):
        respuesta=""YES""
    cont+=c[cont-1]
print(respuesta)","def func():
    n = int(input())
    arr = [int(x) for x in input().split()]
    
    # Iterate through each combination of three different indices
    for i in range(n):
        for j in range(n):
            for k in range(n):
                # Ensure the indices are distinct and within bounds
                if i != j and j != k and i != k:
                    # Check if the current combination satisfies the condition
                    if arr[i] == arr[j] + arr[k]:
                        print(i + 1, j + 1, k + 1)  # Output the indices (1-based)
                        return
    
    print(-1)  # If no valid combination is found"
233,A,Perfect Permutation,PROGRAMMING,"['implementation', 'math']","A permutation is a sequence of integers *p*1,<=*p*2,<=...,<=*p**n*, consisting of *n* distinct positive integers, each of them doesn't exceed *n*. Let's denote the *i*-th element of permutation *p* as *p**i*. We'll call number *n* the size of permutation *p*1,<=*p*2,<=...,<=*p**n*.

Nickolas adores permutations. He likes some permutations more than the others. He calls such permutations perfect. A perfect permutation is such permutation *p* that for any *i* (1<=≤<=*i*<=≤<=*n*) (*n* is the permutation size) the following equations hold *p**p**i*<==<=*i* and *p**i*<=≠<=*i*. Nickolas asks you to print any perfect permutation of size *n* for the given *n*.",A single line contains a single integer *n* (1<=≤<=*n*<=≤<=100) — the permutation size.,"If a perfect permutation of size *n* doesn't exist, print a single integer -1. Otherwise print *n* distinct integers from 1 to *n*, *p*1,<=*p*2,<=...,<=*p**n* — permutation *p*, that is perfect. Separate printed numbers by whitespaces.","['1\n', '2\n', '4\n']","['-1\n', '2 1 \n', '2 1 4 3 \n']",none,WRONG_ANSWER,"def sol(n):
    if n == 1:
        return -1
    arr = [0]*n 
    for i in range(n):
        arr[i] = n-i 
    if n%2 != 0:
        temp = arr[int(n/2)]
        arr[int(n/2)] = arr[int(n/2)+1]
        arr[int(n/2)+1] = temp 
        
    return arr 
n = int(input())
ans = sol(n)
print(ans)","def max_soldiers_killed(n):
    # Calculate the maximum total number of soldiers that can be killed in three turns
    # First turn by Valera, second by Arcady, and the last by Valera again
    # Each player can kill up to n/2 soldiers if they target different enemies

    # First turn, Valera can kill n/2 soldiers
    killed_by_valera_first_turn = n // 2
    
    # Second turn, Arcady can also kill n/2 soldiers
    killed_by_arcady_second_turn = n // 2
    
    # Third turn, Valera can again kill n/2 soldiers
    killed_by_valera_third_turn = n // 2
    
    # Total soldiers killed is the sum of killed soldiers in all turns
    total_killed = killed_by_valera_first_turn + killed_by_arcady_second_turn + killed_by_valera_third_turn
    
    return total_killed

# Read input
n = int(input())
# Print the result
print(max_soldiers_killed(n))"
400,B,Inna and New Matrix of Candies,PROGRAMMING,"['brute force', 'implementation', 'schedules']","Inna likes sweets and a game called the ""Candy Matrix"". Today, she came up with the new game ""Candy Matrix 2: Reload"".

The field for the new game is a rectangle table of size *n*<=×<=*m*. Each line of the table contains one cell with a dwarf figurine, one cell with a candy, the other cells of the line are empty. The game lasts for several moves. During each move the player should choose all lines of the matrix where dwarf is not on the cell with candy and shout ""Let's go!"". After that, all the dwarves from the chosen lines start to simultaneously move to the right. During each second, each dwarf goes to the adjacent cell that is located to the right of its current cell. The movement continues until one of the following events occurs:
 -  some dwarf in one of the chosen lines is located in the rightmost cell of his row; -  some dwarf in the chosen lines is located in the cell with the candy. 
The point of the game is to transport all the dwarves to the candy cells.

Inna is fabulous, as she came up with such an interesting game. But what about you? Your task is to play this game optimally well. Specifically, you should say by the given game field what minimum number of moves the player needs to reach the goal of the game.","The first line of the input contains two integers *n* and *m* (1<=≤<=*n*<=≤<=1000; 2<=≤<=*m*<=≤<=1000). 

Next *n* lines each contain *m* characters — the game field for the ""Candy Martix 2: Reload"". Character ""*"" represents an empty cell of the field, character ""G"" represents a dwarf and character ""S"" represents a candy. The matrix doesn't contain other characters. It is guaranteed that each line contains exactly one character ""G"" and one character ""S"".","In a single line print a single integer — either the minimum number of moves needed to achieve the aim of the game, or -1, if the aim cannot be achieved on the given game field.","['3 4\n*G*S\nG**S\n*G*S\n', '1 3\nS*G\n']","['2\n', '-1\n']",none,WRONG_ANSWER,"n,m=map(int,input().split())
flag = ans =0
d=dict()
for i in range(n):
 x = input()
 for j in range(m):
  if x[j]=='G':
   gidx=j
  elif x[j]=='S':
   sidx=j
 if sidx-gidx<0:
  flag=1;break
 else:
  if sidx-gidx in d:
   ans += 1
  else:
   d[x]=1
   ans = 1

print(ans if not flag else -1)","def max_total_value(n, k, cakes):
    # Initialize a 2D list for dynamic programming
    dp = [[0] * (k + 1) for _ in range(n + 1)]
    
    # To store the last position of each cake type
    last_position = {}
    
    # Traverse through each cake
    for i in range(1, n + 1):
        # Update last position for the current cake type
        last_position[cakes[i - 1]] = i
        
        # Compute distinct count for current segment
        distinct_count = 0
        used = set()
        
        # Go backwards to find the best segments ending at i
        for j in range(i, 0, -1):
            if cakes[j - 1] not in used:
                used.add(cakes[j - 1])
                distinct_count += 1
            
            # Update DP for each box count
            for b in range(1, k + 1):
                dp[i][b] = max(dp[i][b], dp[j - 1][b - 1] + distinct_count)
    
    return dp[n][k]

# Read input values
n, k = map(int, input().split())
cakes = list(map(int, input().split()))

# Print the maximum total value of all boxes with cakes
print(max_total_value(n, k, cakes))"
656,G,You're a Professional,PROGRAMMING,['*special'],"A simple recommendation system would recommend a user things liked by a certain number of their friends. In this problem you will implement part of such a system.

You are given user's friends' opinions about a list of items. You are also given a threshold *T* — the minimal number of ""likes"" necessary for an item to be recommended to the user.

Output the number of items in the list liked by at least *T* of user's friends.","The first line of the input will contain three space-separated integers: the number of friends *F* (1<=≤<=*F*<=≤<=10), the number of items *I* (1<=≤<=*I*<=≤<=10) and the threshold *T* (1<=≤<=*T*<=≤<=*F*).

The following *F* lines of input contain user's friends' opinions. *j*-th character of *i*-th line is 'Y' if *i*-th friend likes *j*-th item, and 'N' otherwise.",Output an integer — the number of items liked by at least *T* of user's friends.,"['3 3 2\nYYY\nNNN\nYNY\n', '4 4 1\nNNNY\nNNYN\nNYNN\nYNNN\n']","['2\n', '4\n']",none,WRONG_ANSWER,"def main():
    f, i, t = map(int, input().split())
    ans = 0
    for _ in range(f):
        likes = input()
        count = sum(1 for like in likes if like == 'Y')
        if count >= t:
            ans += 1

    print(ans)

main()
","def func(x, n):
    if n == 0:
        return 1  # Base case: 2^0 = 1
    return 2 * func(x, n - 1)  # Recursive case: 2^n = 2 * 2^(n-1)

n = int(input())  # Read integer n
m = int(input())  # Read integer m
power_of_two = func(1, n)  # Compute 2^n using the recursive function
result = m % power_of_two  # Calculate the remainder of m divided by 2^n
print(result)  # Output the result"
591,A,Wizards' Duel,PROGRAMMING,"['implementation', 'math']","Harry Potter and He-Who-Must-Not-Be-Named engaged in a fight to the death once again. This time they are located at opposite ends of the corridor of length *l*. Two opponents simultaneously charge a deadly spell in the enemy. We know that the impulse of Harry's magic spell flies at a speed of *p* meters per second, and the impulse of You-Know-Who's magic spell flies at a speed of *q* meters per second.

The impulses are moving through the corridor toward each other, and at the time of the collision they turn round and fly back to those who cast them without changing their original speeds. Then, as soon as the impulse gets back to it's caster, the wizard reflects it and sends again towards the enemy, without changing the original speed of the impulse.

Since Harry has perfectly mastered the basics of magic, he knows that after the second collision both impulses will disappear, and a powerful explosion will occur exactly in the place of their collision. However, the young wizard isn't good at math, so he asks you to calculate the distance from his position to the place of the second meeting of the spell impulses, provided that the opponents do not change positions during the whole fight.","The first line of the input contains a single integer *l* (1<=≤<=*l*<=≤<=1<=000) — the length of the corridor where the fight takes place.

The second line contains integer *p*, the third line contains integer *q* (1<=≤<=*p*,<=*q*<=≤<=500) — the speeds of magical impulses for Harry Potter and He-Who-Must-Not-Be-Named, respectively.","Print a single real number — the distance from the end of the corridor, where Harry is located, to the place of the second meeting of the spell impulses. Your answer will be considered correct if its absolute or relative error will not exceed 10<=-<=4. 

Namely: let's assume that your answer equals *a*, and the answer of the jury is *b*. The checker program will consider your answer correct if .","['100\n50\n50\n', '199\n60\n40\n']","['50\n', '119.4\n']","In the first sample the speeds of the impulses are equal, so both of their meetings occur exactly in the middle of the corridor.",OK,"s=int(input())
p=int(input())
q=int(input())
print(s*p/(p+q))","def fun(a, b):
    for i in range(len(a)):
        if a[i] == b:
            break
    if i == 0:
        return ""F""
    elif i == 1:
        return ""M""
    else:
        return ""S""

def determine_winner(gesture_fyodor, gesture_matroskin, gesture_sharic):
    # A mapping of gestures to their respective winning conditions
    winning_conditions = {
        'rock': ['scissors'],
        'scissors': ['paper'],
        'paper': ['rock']
    }

    # Count each gesture
    gestures = [gesture_fyodor, gesture_matroskin, gesture_sharic]
    counts = {gesture: gestures.count(gesture) for gesture in gestures}

    # Check if any gesture wins against the others
    for gesture in counts:
        if counts[gesture] == 1:  # Only one player has this gesture
            # Determine the other gestures
            other_gestures = [g for g in gestures if g != gesture]
            if all(other in winning_conditions[gesture] for other in other_gestures):
                if gesture == gesture_fyodor:
                    return ""F""
                elif gesture == gesture_matroskin:
                    return ""M""
                else:
                    return ""S""
    
    return ""?""

# Example usage
gesture_fyodor = input()
gesture_matroskin = input()
gesture_sharic = input()
print(determine_winner(gesture_fyodor, gesture_matroskin, gesture_sharic))"
940,B,Our Tanya is Crying Out Loud,PROGRAMMING,"['dp', 'greedy']","Right now she actually isn't. But she will be, if you don't solve this problem.

You are given integers *n*, *k*, *A* and *B*. There is a number *x*, which is initially equal to *n*. You are allowed to perform two types of operations: 
 1.  Subtract 1 from *x*. This operation costs you *A* coins. 1.  Divide *x* by *k*. Can be performed only if *x* is divisible by *k*. This operation costs you *B* coins.","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=2·109).

The second line contains a single integer *k* (1<=≤<=*k*<=≤<=2·109).

The third line contains a single integer *A* (1<=≤<=*A*<=≤<=2·109).

The fourth line contains a single integer *B* (1<=≤<=*B*<=≤<=2·109).",Output a single integer — the minimum amount of coins you have to pay to make *x* equal to 1.,"['9\n2\n3\n1\n', '5\n5\n2\n20\n', '19\n3\n4\n2\n']","['6\n', '8\n', '12\n']","In the first testcase, the optimal strategy is as follows: 
 -  Subtract 1 from *x* (9 → 8) paying 3 coins. -  Divide *x* by 2 (8 → 4) paying 1 coin. -  Divide *x* by 2 (4 → 2) paying 1 coin. -  Divide *x* by 2 (2 → 1) paying 1 coin. 
The total cost is 6 coins.

In the second test case the optimal strategy is to subtract 1 from *x* 4 times paying 8 coins in total.",OK,"n = int(input())
k = int(input())
a = int(input())
b = int(input())
res = 0
while n!=1:
	if k==1 or k>n:
		res+=a*(n-1)
		break
	if n%k!=0:
		res+=a*(n%k)
		n = n-n%k
	else:
		temp = n//k
		res+=min(b,a*(n-temp))
		n = temp
print(res)
			   			 	 				 		  		       	","def main(): 
    ans = 0
    s = input()
    
    num = s  # Store the initial number as a string to keep large digits
    # Continue the process until we have a single-digit number
    while len(num) > 1:
        sum_digits = sum(int(digit) for digit in num)  # Calculate the sum of the digits
        num = str(sum_digits)  # Convert the sum back to string for the next iteration
        ans += 1  # Increment the spell count by one

    print(ans)  # Output the total number of transformations

main()"
29,A,Spit Problem,PROGRAMMING,['brute force'],"In a Berland's zoo there is an enclosure with camels. It is known that camels like to spit. Bob watched these interesting animals for the whole day and registered in his notepad where each animal spitted. Now he wants to know if in the zoo there are two camels, which spitted at each other. Help him to solve this task.

The trajectory of a camel's spit is an arc, i.e. if the camel in position *x* spits *d* meters right, he can hit only the camel in position *x*<=+<=*d*, if such a camel exists.","The first line contains integer *n* (1<=≤<=*n*<=≤<=100) — the amount of camels in the zoo. Each of the following *n* lines contains two integers *x**i* and *d**i* (<=-<=104<=≤<=*x**i*<=≤<=104,<=1<=≤<=|*d**i*|<=≤<=2·104) — records in Bob's notepad. *x**i* is a position of the *i*-th camel, and *d**i* is a distance at which the *i*-th camel spitted. Positive values of *d**i* correspond to the spits right, negative values correspond to the spits left. No two camels may stand in the same position.","If there are two camels, which spitted at each other, output YES. Otherwise, output NO.","['2\n0 1\n1 -1\n', '3\n0 1\n1 1\n2 -2\n', '5\n2 -10\n3 10\n0 5\n5 -5\n10 1\n']","['YES\n', 'NO\n', 'YES\n']",none,OK,"

n = int(input())

A = set()

for _ in range(n):
    x, d = map(int, input().split())
    A.add((x, d))

found = False

for x, d in A:
    if (x + d, -d) in A:
        found = True

if found:
    print(""YES"")
else:
    print(""NO"")
","import sys

def B():
    count = int(sys.stdin.readline().strip(""\n"").split("" "")[0])
    arr = []

    while count > 0:
        l, r = map(int, sys.stdin.readline().strip(""\n"").split("" ""))
        arr.append((l, r))
        count -= 1

    # Sort shows by their start time
    arr.sort()

    # Create a list to track the end times for the two TVs
    tv_end_times = []

    for start, end in arr:
        # Check if we can fit this show into one of the TVs
        placed = False
        for i in range(len(tv_end_times)):
            if tv_end_times[i] <= start:  # Can watch this on the current TV
                tv_end_times[i] = end  # Update the end time for this TV
                placed = True
                break
        if not placed:  # If it couldn't fit into existing TVs, we need a new one
            if len(tv_end_times) < 2:
                tv_end_times.append(end)  # Add to available TVs
            else:
                print(""NO"")
                return

    print(""YES"")

B()"
891,A,Pride,PROGRAMMING,"['brute force', 'dp', 'greedy', 'math', 'number theory']","You have an array *a* with length *n*, you can perform operations. Each operation is like this: choose two adjacent elements from *a*, say *x* and *y*, and replace one of them with *gcd*(*x*,<=*y*), where *gcd* denotes the [greatest common divisor](https://en.wikipedia.org/wiki/Greatest_common_divisor).

What is the minimum number of operations you need to make all of the elements equal to 1?","The first line of the input contains one integer *n* (1<=≤<=*n*<=≤<=2000) — the number of elements in the array.

The second line contains *n* space separated integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=109) — the elements of the array.","Print -1, if it is impossible to turn all numbers to 1. Otherwise, print the minimum number of operations needed to make all numbers equal to 1.","['5\n2 2 3 4 6\n', '4\n2 4 6 8\n', '3\n2 6 9\n']","['5\n', '-1\n', '4\n']","In the first sample you can turn all numbers to 1 using the following 5 moves:
 -  [2, 2, 3, 4, 6]. -  [2, 1, 3, 4, 6] -  [2, 1, 3, 1, 6] -  [2, 1, 1, 1, 6] -  [1, 1, 1, 1, 6] -  [1, 1, 1, 1, 1] 
We can prove that in this case it is not possible to make all numbers one using less than 5 moves.",WRONG_ANSWER,"def main():
    n = int(input())
    a = list(map(int, input().split()))

    if gcd_of_array(a) != 1:
        print(-1)
    else:
        left = 2
        right = n

        while left <= right:
            mid = (left + right) // 2
            if check(a, mid):
                right = mid - 1
            else:
                left = mid + 1

        ans = n + mid - 2

        print(ans)


def check(a, le):
    for i in range(len(a) - le):
        if gcd_of_array(a[i:i+le]) == 1:
            return True
    return False



def gcd(a, b):
    if a == 0:
        return b
    else:
        return gcd(b % a, a)


def gcd_of_array(a):
    res = a[0]
    for i in a:
        res = gcd(res, i)
        if res == 1:
            break
    return res


main()","import sys, os, io
from sys import stdin
from bisect import bisect_left, bisect_right

def ii():
    return int(input())

def li():
    return list(map(int, input().split()))

n = ii()
beacons = [tuple(li()) for _ in range(n)]  # Read positions and power levels
beacons.sort()  # Sort by position

def min_destroyed_beacons(beacons):
    destroyed_count = 0
    current_power = 0  # Power of the new beacon we will place
    
    # Iterate over beacons from right to left
    for a, b in reversed(beacons):
        if current_power > 0:  # Only if the current power affects this beacon
            if a - current_power <= 0:  # The new beacon can destroy this one
                destroyed_count += 1
            else:
                current_power = max(current_power, b)  # Update power level if greater
        else:
            current_power = b  # Set initial power level from first beacon

    return destroyed_count

result = min_destroyed_beacons(beacons)
print(result)"
868,C,Qualification Rounds,PROGRAMMING,"['bitmasks', 'brute force', 'constructive algorithms', 'dp']","Snark and Philip are preparing the problemset for the upcoming pre-qualification round for semi-quarter-finals. They have a bank of *n* problems, and they want to select any non-empty subset of it as a problemset.

*k* experienced teams are participating in the contest. Some of these teams already know some of the problems. To make the contest interesting for them, each of the teams should know at most half of the selected problems.

Determine if Snark and Philip can make an interesting problemset!","The first line contains two integers *n*, *k* (1<=≤<=*n*<=≤<=105, 1<=≤<=*k*<=≤<=4) — the number of problems and the number of experienced teams.

Each of the next *n* lines contains *k* integers, each equal to 0 or 1. The *j*-th number in the *i*-th line is 1 if *j*-th team knows *i*-th problem and 0 otherwise.","Print ""YES"" (quotes for clarity), if it is possible to make an interesting problemset, and ""NO"" otherwise.

You can print each character either upper- or lowercase (""YeS"" and ""yes"" are valid when the answer is ""YES"").","['5 3\n1 0 1\n1 1 0\n1 0 0\n1 0 0\n1 0 0\n', '3 2\n1 0\n1 1\n0 1\n']","['NO\n', 'YES\n']","In the first example you can't make any interesting problemset, because the first team knows all problems.

In the second example you can choose the first and the third problems.",OK,"n,k=map(int,input().split())
a=[]
for i in range(n):
    l=list(map(int,input().split()))
    a.append(l)
a=list(set(tuple(i) for i in a))
for i in range(len(a)):
    flag=False
    for j in range(len(a)):
        cnt=0
        for x in range(k):
            if a[i][x]==1 and a[j][x]!=0:
                continue
            else:
                cnt+=1
        if cnt==k:
            flag=True
            break
    if flag:
        break
if flag:print(""Yes"")
else:print(""No"")
        ","#editorial is very clear
from collections import *
import bisect
import heapq

SIZE = 1000

def ri():
    return int(input().strip())

def main():
    n = ri()
    snow_drifts = [tuple(map(int, input().split())) for _ in range(n)]
    
    # A set to keep track of the unique x and y coordinates
    unique_x = set()
    unique_y = set()

    for x, y in snow_drifts:
        unique_x.add(x)
        unique_y.add(y)
    
    # The number of new drifts needed is the maximum of 
    # the unique coordinates minus the number of existing snow drifts
    new_drifts_needed = max(len(unique_x), len(unique_y)) - n
    
    print(new_drifts_needed)

if __name__ == ""__main__"":
    main()"
165,A,Supercentral Point,PROGRAMMING,['implementation'],"One day Vasya painted a Cartesian coordinate system on a piece of paper and marked some set of points (*x*1,<=*y*1),<=(*x*2,<=*y*2),<=...,<=(*x**n*,<=*y**n*). Let's define neighbors for some fixed point from the given set (*x*,<=*y*): 
 -  point (*x*',<=*y*') is (*x*,<=*y*)'s right neighbor, if *x*'<=&gt;<=*x* and *y*'<==<=*y* -  point (*x*',<=*y*') is (*x*,<=*y*)'s left neighbor, if *x*'<=&lt;<=*x* and *y*'<==<=*y* -  point (*x*',<=*y*') is (*x*,<=*y*)'s lower neighbor, if *x*'<==<=*x* and *y*'<=&lt;<=*y* -  point (*x*',<=*y*') is (*x*,<=*y*)'s upper neighbor, if *x*'<==<=*x* and *y*'<=&gt;<=*y* 
We'll consider point (*x*,<=*y*) from the given set supercentral, if it has at least one upper, at least one lower, at least one left and at least one right neighbor among this set's points.

Vasya marked quite many points on the paper. Analyzing the picture manually is rather a challenge, so Vasya asked you to help him. Your task is to find the number of supercentral points in the given set.","The first input line contains the only integer *n* (1<=≤<=*n*<=≤<=200) — the number of points in the given set. Next *n* lines contain the coordinates of the points written as ""*x* *y*"" (without the quotes) (|*x*|,<=|*y*|<=≤<=1000), all coordinates are integers. The numbers in the line are separated by exactly one space. It is guaranteed that all points are different.",Print the only number — the number of supercentral points of the given set.,"['8\n1 1\n4 2\n3 1\n1 2\n0 2\n0 1\n1 0\n1 3\n', '5\n0 0\n0 1\n1 0\n0 -1\n-1 0\n']","['2\n', '1\n']","In the first sample the supercentral points are only points (1, 1) and (1, 2).

In the second sample there is one supercental point — point (0, 0).",OK,"n = int(input())
x= []
y = []
c=0
for k in range(n):
    a,b = map(int,input().split())
    x.append(a)
    y.append(b)
for i in range(n):
    r1,r2,r3,r4=0,0,0,0
    for j in range(n):
        if x[i]>x[j] and y[i]==y[j]:
            r1+=1
        if x[i]<x[j] and y[i]==y[j]:
            r2+=1
        if x[i]==x[j] and y[i]<y[j]:
            r3+=1
        if x[i]==x[j] and y[i]>y[j]:
            r4+=1
    if r1>0 and r2>0 and r3>0 and r4>0:
        c = c+1
print(c)","def q66b():
	n = int(input())
	sections_list = [int(num) for num in input().split()]
	max_no = -1

	def find_num_sections(sections, index):
		# Initialize a set to keep track of watered sections
		watered = set()
		height = sections[index]
		stack = [index]
		
		# Use a stack to traverse the sections
		while stack:
			current = stack.pop()
			if current not in watered:
				watered.add(current)
				# Check left neighbor
				if current > 0 and sections[current - 1] <= height:
					stack.append(current - 1)
				# Check right neighbor
				if current < len(sections) - 1 and sections[current + 1] <= height:
					stack.append(current + 1)

		return len(watered)

	for i in range(len(sections_list)):
		num_sections = find_num_sections(sections_list, i)
		if num_sections > max_no:
			max_no = num_sections

	print(max_no)"
853,B,Jury Meeting,PROGRAMMING,"['greedy', 'sortings', 'two pointers']","Country of Metropolia is holding Olympiad of Metrpolises soon. It mean that all jury members of the olympiad should meet together in Metropolis (the capital of the country) for the problem preparation process.

There are *n*<=+<=1 cities consecutively numbered from 0 to *n*. City 0 is Metropolis that is the meeting point for all jury members. For each city from 1 to *n* there is exactly one jury member living there. Olympiad preparation is a long and demanding process that requires *k* days of work. For all of these *k* days each of the *n* jury members should be present in Metropolis to be able to work on problems.

You know the flight schedule in the country (jury members consider themselves important enough to only use flights for transportation). All flights in Metropolia are either going to Metropolis or out of Metropolis. There are no night flights in Metropolia, or in the other words, plane always takes off at the same day it arrives. On his arrival day and departure day jury member is not able to discuss the olympiad. All flights in Megapolia depart and arrive at the same day.

Gather everybody for *k* days in the capital is a hard objective, doing that while spending the minimum possible money is even harder. Nevertheless, your task is to arrange the cheapest way to bring all of the jury members to Metrpolis, so that they can work together for *k* days and then send them back to their home cities. Cost of the arrangement is defined as a total cost of tickets for all used flights. It is allowed for jury member to stay in Metropolis for more than *k* days.","The first line of input contains three integers *n*, *m* and *k* (1<=≤<=*n*<=≤<=105, 0<=≤<=*m*<=≤<=105, 1<=≤<=*k*<=≤<=106). 

The *i*-th of the following *m* lines contains the description of the *i*-th flight defined by four integers *d**i*, *f**i*, *t**i* and *c**i* (1<=≤<=*d**i*<=≤<=106, 0<=≤<=*f**i*<=≤<=*n*, 0<=≤<=*t**i*<=≤<=*n*, 1<=≤<=*c**i*<=≤<=106, exactly one of *f**i* and *t**i* equals zero), the day of departure (and arrival), the departure city, the arrival city and the ticket cost.","Output the only integer that is the minimum cost of gathering all jury members in city 0 for *k* days and then sending them back to their home cities.

If it is impossible to gather everybody in Metropolis for *k* days and then send them back to their home cities, output ""-1"" (without the quotes).","['2 6 5\n1 1 0 5000\n3 2 0 5500\n2 2 0 6000\n15 0 2 9000\n9 0 1 7000\n8 0 2 6500\n', '2 4 5\n1 2 0 5000\n2 1 0 4500\n2 1 0 3000\n8 0 1 6000\n']","['24500\n', '-1\n']","The optimal way to gather everybody in Metropolis in the first sample test is to use flights that take place on days 1, 2, 8 and 9. The only alternative option is to send jury member from second city back home on day 15, that would cost 2500 more.

In the second sample it is impossible to send jury member from city 2 back home from Metropolis.",OK,"g = lambda: map(int, input().split())
n, m, k = g()
F, T = [], []
e = int(3e11)

for i in range(m):
    d, f, t, c = g()
    if f: F.append((d, f, c))
    else: T.append((-d, t, c))

for p in [F, T]:
    C = [e] * (n + 1)
    s = n * e
    q = []

    p.sort()
    for d, t, c in p:
        if C[t] > c:
            s += c - C[t]
            C[t] = c
            if s < e: q.append((s, d))
    p.clear()
    p += q

s, t = e, (0, 0)
for f in F:
    while f:
        if t[1] + f[1] + k < 0: s = min(s, f[0] + t[0])
        elif T:
            t = T.pop()
            continue
        f = 0

print(s if s < e else -1)","def marks(n, m, li):
    temp = []
    for j in range(m):
        max_ = -999
        for i in range(n):
            # Find the maximum mark for the current subject
            max_ = max(max_, int(li[i][j]))
        
        # Record the indices of students who have the maximum mark for this subject
        for i in range(n):
            if int(li[i][j]) == max_:
                temp.append(i)
    
    # Use a set to find unique successful students
    successful_students = set(temp)
    
    # Return the number of unique successful students
    return len(successful_students)

# Example usage
n, m = map(int, input().split())
li = [input().strip() for _ in range(n)]
print(marks(n, m, li))"
925,A,Stairs and Elevators,PROGRAMMING,['binary search'],"In the year of $30XX$ participants of some world programming championship live in a single large hotel. The hotel has $n$ floors. Each floor has $m$ sections with a single corridor connecting all of them. The sections are enumerated from $1$ to $m$ along the corridor, and all sections with equal numbers on different floors are located exactly one above the other. Thus, the hotel can be represented as a rectangle of height $n$ and width $m$. We can denote sections with pairs of integers $(i, j)$, where $i$ is the floor, and $j$ is the section number on the floor.

The guests can walk along the corridor on each floor, use stairs and elevators. Each stairs or elevator occupies all sections $(1, x)$, $(2, x)$, $\ldots$, $(n, x)$ for some $x$ between $1$ and $m$. All sections not occupied with stairs or elevators contain guest rooms. It takes one time unit to move between neighboring sections on the same floor or to move one floor up or down using stairs. It takes one time unit to move up to $v$ floors in any direction using an elevator. You can assume you don't have to wait for an elevator, and the time needed to enter or exit an elevator is negligible.

You are to process $q$ queries. Each query is a question ""what is the minimum time needed to go from a room in section $(x_1, y_1)$ to a room in section $(x_2, y_2)$?""","The first line contains five integers $n, m, c_l, c_e, v$ ($2 \leq n, m \leq 10^8$, $0 \leq c_l, c_e \leq 10^5$, $1 \leq c_l + c_e \leq m - 1$, $1 \leq v \leq n - 1$) — the number of floors and section on each floor, the number of stairs, the number of elevators and the maximum speed of an elevator, respectively.

The second line contains $c_l$ integers $l_1, \ldots, l_{c_l}$ in increasing order ($1 \leq l_i \leq m$), denoting the positions of the stairs. If $c_l = 0$, the second line is empty.

The third line contains $c_e$ integers $e_1, \ldots, e_{c_e}$ in increasing order, denoting the elevators positions in the same format. It is guaranteed that all integers $l_i$ and $e_i$ are distinct.

The fourth line contains a single integer $q$ ($1 \leq q \leq 10^5$) — the number of queries.

The next $q$ lines describe queries. Each of these lines contains four integers $x_1, y_1, x_2, y_2$ ($1 \leq x_1, x_2 \leq n$, $1 \leq y_1, y_2 \leq m$) — the coordinates of starting and finishing sections for the query. It is guaranteed that the starting and finishing sections are distinct. It is also guaranteed that these sections contain guest rooms, i. e. $y_1$ and $y_2$ are not among $l_i$ and $e_i$.","Print $q$ integers, one per line — the answers for the queries.",['5 6 1 1 3\n2\n5\n3\n1 1 5 6\n1 3 5 4\n3 3 5 3\n'],['7\n5\n4\n'],"In the first query the optimal way is to go to the elevator in the 5-th section in four time units, use it to go to the fifth floor in two time units and go to the destination in one more time unit.

In the second query it is still optimal to use the elevator, but in the third query it is better to use the stairs in the section 2.",WRONG_ANSWER,"print(""_RANDOM_GUESS_1689345603.107276"")# 1689345603.1072981","def arithm_sum(a, n, d):
    return int(n/2 * (2*a + (n-1)*d))

a = int(input())
b = int(input())

# Calculate the distance between the two friends
distance = b - a

# Initialize the minimum tiredness to a large number
min_tiredness = float('inf')

# Check all meeting points from a to b
for meeting_point in range(a, b + 1):
    # Distance friend 1 needs to move
    d1 = abs(meeting_point - a)
    # Distance friend 2 needs to move
    d2 = abs(meeting_point - b)
    
    # Calculate the tiredness for both friends
    tiredness1 = arithm_sum(1, d1, 1)  # tiredness for friend 1
    tiredness2 = arithm_sum(1, d2, 1)  # tiredness for friend 2
    
    # Total tiredness
    total_tiredness = tiredness1 + tiredness2
    
    # Update minimum tiredness
    min_tiredness = min(min_tiredness, total_tiredness)

# Print the minimum possible total tiredness
print(min_tiredness)"
877,A,Alex and broken contest,PROGRAMMING,"['implementation', 'strings']","One day Alex was creating a contest about his friends, but accidentally deleted it. Fortunately, all the problems were saved, but now he needs to find them among other problems.

But there are too many problems, to do it manually. Alex asks you to write a program, which will determine if a problem is from this contest by its name.

It is known, that problem is from this contest if and only if its name contains one of Alex's friends' name exactly once. His friends' names are ""Danil"", ""Olya"", ""Slava"", ""Ann"" and ""Nikita"".

Names are case sensitive.","The only line contains string from lowercase and uppercase letters and ""_"" symbols of length, not more than 100 — the name of the problem.","Print ""YES"", if problem is from this contest, and ""NO"" otherwise.","['Alex_and_broken_contest\n', 'NikitaAndString\n', 'Danil_and_Olya\n']","['NO', 'YES', 'NO']",none,OK,"s=input()
cnt=s.count(""Danil"")+s.count(""Olya"")+s.count(""Slava"")+s.count(""Nikita"")+s.count(""Ann"") 
print(""YES"" if cnt == 1 else ""NO"")","#!/usr/bin/env python3
import collections, fractions, itertools, functools, math

def fill(grid, elems, n):
    a = grid[n][n]
    for i in range(n):
        b = grid[i][i]
        # Set corresponding elements in the array
        elems[i] = math.gcd(a, b)

def gcd_table_to_array(n, gcd_elements):
    gcd_elements.sort()  # Sort the gcd table elements
    # Initialize a grid for GCD values
    grid = [[0] * n for _ in range(n)]

    # Fill the grid with the GCD values
    for i in range(n):
        for j in range(n):
            grid[i][j] = math.gcd(gcd_elements[i], gcd_elements[j])

    # Initialize the array to be restored
    elems = [0] * n
    fill(grid, elems, n)
    return elems

# Read input
n = int(input().strip())
gcd_elements = list(map(int, input().strip().split()))

# Get the array from the gcd table
result_array = gcd_table_to_array(n, gcd_elements)

# Print the resulting array
print(' '.join(map(str, result_array)))"
762,A,k-th divisor,PROGRAMMING,"['math', 'number theory']","You are given two integers *n* and *k*. Find *k*-th smallest divisor of *n*, or report that it doesn't exist.

Divisor of *n* is any such natural number, that *n* can be divided by it without remainder.","The first line contains two integers *n* and *k* (1<=≤<=*n*<=≤<=1015, 1<=≤<=*k*<=≤<=109).","If *n* has less than *k* divisors, output -1.

Otherwise, output the *k*-th smallest divisor of *n*.","['4 2\n', '5 3\n', '12 5\n']","['2\n', '-1\n', '6\n']","In the first example, number 4 has three divisors: 1, 2 and 4. The second one is 2.

In the second example, number 5 has only two divisors: 1 and 5. The third divisor doesn't exist, so the answer is -1.",OK,"import sys
import math
from collections import Counter

# n = int(input())
# a = list(map(int, input().split()))

n, k = map(int, input().split())
less = []
more = []
i = 1
count = 0
root = int(math.sqrt(n))

while i <= root :
    if n % i == 0 :
        less.append(i)
        if i * i != n:
            more.append(n // i)
        if len(less) >= k :
            break
    i += 1
if k > len(less) + len(more) :
    print(-1)
else :
    if k > len(less) :
        print(more[-(k - len(less))])
    else :
        print(less[k - 1])






    


","import sys
from collections import deque

input = lambda: sys.stdin.readline().strip()
write = lambda x: sys.stdout.write(str(x) + '\n')

def bfs(start, grid, visited, n, m):
    queue = deque([start])
    visited[start[0]][start[1]] = True
    cells = []

    while queue:
        x, y = queue.popleft()
        cells.append((x, y))
        
        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            nx, ny = x + dx, y + dy
            if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and (grid[nx][ny] == '1' or grid[nx][ny] == '2' or grid[nx][ny] == '3' or grid[nx][ny] == '.'):
                visited[nx][ny] = True
                queue.append((nx, ny))

    return cells

def find_required_cells(grid, n, m):
    visited = [[False] * m for _ in range(n)]
    components = []

    # Identify all components of states
    for i in range(n):
        for j in range(m):
            if grid[i][j] in '123' and not visited[i][j]:
                cells = bfs((i, j), grid, visited, n, m)
                components.append(cells)

    if len(components) < 2:
        return 0  # Already connected

    min_roads = float('inf')
    
    # Check distances to each component from the other states' cells
    for comp in components:
        for cx, cy in comp:
            distances = []
            # BFS to find the minimum distance to other components
            q = deque([(cx, cy, 0)])
            local_visited = [[False] * m for _ in range(n)]
            local_visited[cx][cy] = True
            
            while q:
                x, y, dist = q.popleft()
                
                for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                    nx, ny = x + dx, y + dy
                    if 0 <= nx < n and 0 <= ny < m and not local_visited[nx][ny]:
                        if grid[nx][ny] == '.':
                            local_visited[nx][ny] = True
                            q.append((nx, ny, dist + 1))
                        elif grid[nx][ny] in '123':
                            distances.append(dist)  # Found another component, record distance
            
            if distances:
                min_roads = min(min_roads, min(distances))

    return min_roads if min_roads != float('inf') else -1

n, m = map(int, input().split())
grid = [input() for _ in range(n)]

result = find_required_cells(grid, n, m)
write(result)"
597,B,Restaurant,PROGRAMMING,"['dp', 'greedy', 'sortings']","A restaurant received *n* orders for the rental. Each rental order reserve the restaurant for a continuous period of time, the *i*-th order is characterized by two time values — the start time *l**i* and the finish time *r**i* (*l**i*<=≤<=*r**i*).

Restaurant management can accept and reject orders. What is the maximal number of orders the restaurant can accept?

No two accepted orders can intersect, i.e. they can't share even a moment of time. If one order ends in the moment other starts, they can't be accepted both.",The first line contains integer number *n* (1<=≤<=*n*<=≤<=5·105) — number of orders. The following *n* lines contain integer values *l**i* and *r**i* each (1<=≤<=*l**i*<=≤<=*r**i*<=≤<=109).,Print the maximal number of orders that can be accepted.,"['2\n7 11\n4 7\n', '5\n1 2\n2 3\n3 4\n4 5\n5 6\n', '6\n4 8\n1 5\n4 7\n2 5\n1 3\n6 8\n']","['1\n', '3\n', '2\n']",none,WRONG_ANSWER,"n = int(input())

order = [[int(__) for __ in input().split()] for _ in range(n)]
order.sort(key=lambda x: x[1])
print(order)

ans = 0
right = -1
for i in order:
	if right < i[0]:
		ans += 1
		right = i[1]
print(ans)","k = int(input())
s = input()
dic = {}
lst = []
new_s = ''

def count(s, c):
    return s.count(c)

# Count the occurrences of each character in the string s
for char in set(s):
    cnt = count(s, char)
    dic[char] = cnt

# Check if the string can be rearranged into a k-string
for char, cnt in dic.items():
    if cnt % k != 0:
        print(""-1"")
        exit()

# Build the base string that will be repeated k times
for char, cnt in dic.items():
    new_s += char * (cnt // k)

# Output the k-string by repeating the base string k times
result = new_s * k
print(result)"
220,A,Little Elephant and Problem,PROGRAMMING,"['implementation', 'sortings']","The Little Elephant has got a problem — somebody has been touching his sorted by non-decreasing array *a* of length *n* and possibly swapped some elements of the array.

The Little Elephant doesn't want to call the police until he understands if he could have accidentally changed the array himself. He thinks that he could have accidentally changed array *a*, only if array *a* can be sorted in no more than one operation of swapping elements (not necessarily adjacent). That is, the Little Elephant could have accidentally swapped some two elements.

Help the Little Elephant, determine if he could have accidentally changed the array *a*, sorted by non-decreasing, himself.","The first line contains a single integer *n* (2<=≤<=*n*<=≤<=105) — the size of array *a*. The next line contains *n* positive integers, separated by single spaces and not exceeding 109, — array *a*.

Note that the elements of the array are not necessarily distinct numbers.","In a single line print ""YES"" (without the quotes) if the Little Elephant could have accidentally changed the array himself, and ""NO"" (without the quotes) otherwise.","['2\n1 2\n', '3\n3 2 1\n', '4\n4 3 2 1\n']","['YES\n', 'YES\n', 'NO\n']","In the first sample the array has already been sorted, so to sort it, we need 0 swap operations, that is not more than 1. Thus, the answer is ""YES"".

In the second sample we can sort the array if we swap elements 1 and 3, so we need 1 swap operation to sort the array. Thus, the answer is ""YES"".

In the third sample we can't sort the array in more than one swap operation, so the answer is ""NO"".",OK,"from sys import stdin
from collections import deque,Counter,defaultdict
import sys
import math
import operator
import random
from fractions import Fraction
import functools
import bisect
import itertools
from heapq import *
import time

n = int(input())
arr = list(map(int,input().split()))
c = 0
for i,j in zip(arr,sorted(arr)):
    if i!=j:
        c+=1
print('YES' if c == 0 or c == 2 else 'NO')

","n = int(input())

a = input().split()

# Initialize variable to track the maximum volume
max_volume = 0

# Iterate over each word in the list
for word in a:
    # Calculate the volume of the current word (number of capital letters)
    volume = sum(1 for char in word if char.isupper())
    # Update max_volume if the current word's volume is greater
    max_volume = max(max_volume, volume)

# Print the maximum volume found
print(max_volume)"
4,A,Watermelon,PROGRAMMING,"['brute force', 'math']","One hot summer day Pete and his friend Billy decided to buy a watermelon. They chose the biggest and the ripest one, in their opinion. After that the watermelon was weighed, and the scales showed *w* kilos. They rushed home, dying of thirst, and decided to divide the berry, however they faced a hard problem.

Pete and Billy are great fans of even numbers, that's why they want to divide the watermelon in such a way that each of the two parts weighs even number of kilos, at the same time it is not obligatory that the parts are equal. The boys are extremely tired and want to start their meal as soon as possible, that's why you should help them and find out, if they can divide the watermelon in the way they want. For sure, each of them should get a part of positive weight.",The first (and the only) input line contains integer number *w* (1<=≤<=*w*<=≤<=100) — the weight of the watermelon bought by the boys.,"Print YES, if the boys can divide the watermelon into two parts, each of them weighing even number of kilos; and NO in the opposite case.",['8\n'],['YES\n'],"For example, the boys can divide the watermelon into two parts of 2 and 6 kilos respectively (another variant — two parts of 4 and 4 kilos).",RUNTIME_ERROR,"weight = int(input(""Enter the weight of the watermelon : ""))

if w(1 <=w<= 100):

   print(""Invalid Input"")

elif weight % 2 != 0:

   print(""NO"")

else:

   print(""YES"")


 						   	 				 	 	 				 	 	","def sum_of_digits(num):
    return sum(int(digit) for digit in str(num))

def count_spell_casts(n):
    count = 0
    while n >= 10:  # Continue until the number is a single digit
        n = sum_of_digits(n)  # Replace n with the sum of its digits
        count += 1  # Increment the count of spells cast
    return count

# Input reading
n = int(input().strip())  # Read the integer input and convert to int
result = count_spell_casts(n)  # Get the number of spells
print(result)  # Print the result"
198,A,About Bacteria,PROGRAMMING,"['implementation', 'math']","Qwerty the Ranger took up a government job and arrived on planet Mars. He should stay in the secret lab and conduct some experiments on bacteria that have funny and abnormal properties. The job isn't difficult, but the salary is high.

At the beginning of the first experiment there is a single bacterium in the test tube. Every second each bacterium in the test tube divides itself into *k* bacteria. After that some abnormal effects create *b* more bacteria in the test tube. Thus, if at the beginning of some second the test tube had *x* bacteria, then at the end of the second it will have *kx*<=+<=*b* bacteria.

The experiment showed that after *n* seconds there were exactly *z* bacteria and the experiment ended at this point.

For the second experiment Qwerty is going to sterilize the test tube and put there *t* bacteria. He hasn't started the experiment yet but he already wonders, how many seconds he will need to grow at least *z* bacteria. The ranger thinks that the bacteria will divide by the same rule as in the first experiment. 

Help Qwerty and find the minimum number of seconds needed to get a tube with at least *z* bacteria in the second experiment.","The first line contains four space-separated integers *k*, *b*, *n* and *t* (1<=≤<=*k*,<=*b*,<=*n*,<=*t*<=≤<=106) — the parameters of bacterial growth, the time Qwerty needed to grow *z* bacteria in the first experiment and the initial number of bacteria in the second experiment, correspondingly.",Print a single number — the minimum number of seconds Qwerty needs to grow at least *z* bacteria in the tube.,"['3 1 3 5\n', '1 4 4 7\n', '2 2 4 100\n']","['2', '3', '0']",none,WRONG_ANSWER,"k,b,n,t=map(int,input().split())
temp=1
count=0
while(1):
    print(temp)
    
    if(((t-1)*(k-1))+b>b*temp):
        temp=temp*k
        count+=1
    else:
        break;
print(max(0,(n-count)-1))
","n = int(input())
global t
global c
t = [0] * n
c = [0] * n

for i in range(n):
    a, b = input().split("" "")
    t[i] = int(a)
    c[i] = int(b)

# Create a list of items with their corresponding times and costs
items = list(zip(t, c))

# Sort items by cost-to-time ratio in descending order
items.sort(key=lambda x: (x[1] / (x[0] + 1e-9)), reverse=True)

# Initialize total cost
total_cost = 0
time_available = 0  # Time available for stealing

# Iterate through sorted items
for time, cost in items:
    # If we have time to steal while the assistant is busy, we do it
    time_available += time
    total_cost += cost
    
    # If time available is greater than 0, we steal additional items
    if time_available > 0:
        time_available -= 1  # Spend one second to steal an item

# Output the minimum amount of money Bob will have to pay
print(total_cost)"
486,A,Calculating Function,PROGRAMMING,"['implementation', 'math']","For a positive integer *n* let's define a function *f*:

*f*(*n*)<==<=<=-<=1<=+<=2<=-<=3<=+<=..<=+<=(<=-<=1)*n**n* 

Your task is to calculate *f*(*n*) for a given integer *n*.",The single line contains the positive integer *n* (1<=≤<=*n*<=≤<=1015).,Print *f*(*n*) in a single line.,"['4\n', '5\n']","['2\n', '-3\n']","*f*(4) =  - 1 + 2 - 3 + 4 = 2

*f*(5) =  - 1 + 2 - 3 + 4 - 5 =  - 3",OK,"S0l=int(input())
if S0l%2==0:
    print(S0l//2)
else:
    print(S0l//2-S0l)","str_arr = []

n, m = map(int, input().split())
for i in range(n):
    str_arr.append(input())

def distance(str_line):
    # Find the positions of the dwarf 'G' and the candy 'S'
    g_index = str_line.index('G')
    s_index = str_line.index('S')
    
    # If the dwarf is to the right of the candy, it's impossible to reach
    if g_index > s_index:
        return -1
    # Calculate the number of moves required to reach the candy
    return s_index - g_index

# Initialize the maximum moves needed
max_moves = 0

for line in str_arr:
    # Get the distance for the current line
    dist = distance(line)
    # If any line cannot reach the candy, print -1 and exit
    if dist == -1:
        print(-1)
        exit(0)
    # Keep track of the maximum moves needed
    max_moves = max(max_moves, dist)

# Print the minimum number of moves needed to achieve the goal
print(max_moves)"
723,A,The New Year: Meeting Friends,PROGRAMMING,"['implementation', 'math', 'sortings']","There are three friend living on the straight line *Ox* in Lineland. The first friend lives at the point *x*1, the second friend lives at the point *x*2, and the third friend lives at the point *x*3. They plan to celebrate the New Year together, so they need to meet at one point. What is the minimum total distance they have to travel in order to meet at some point and celebrate the New Year?

It's guaranteed that the optimal answer is always integer.","The first line of the input contains three distinct integers *x*1, *x*2 and *x*3 (1<=≤<=*x*1,<=*x*2,<=*x*3<=≤<=100) — the coordinates of the houses of the first, the second and the third friends respectively.",Print one integer — the minimum total distance the friends need to travel in order to meet together.,"['7 1 4\n', '30 20 10\n']","['6\n', '20\n']","In the first sample, friends should meet at the point 4. Thus, the first friend has to travel the distance of 3 (from the point 7 to the point 4), the second friend also has to travel the distance of 3 (from the point 1 to the point 4), while the third friend should not go anywhere because he lives at the point 4.",OK,"vals = sorted(map(int, input().split()))
dist = max(vals) - min(vals)
print(dist)","def allocCmd(memory, id, size):
    cnt = 0
    ind = 0
    # Find a block of free memory of the requested size
    for i in range(len(memory)):
        if memory[i] == '0':
            if cnt == 0:
                ind = i
            cnt += 1
            if cnt == size:
                # Allocate the block
                for j in range(ind, ind + size):
                    memory[j] = str(id)
                return id  # Return the block identifier
        else:
            cnt = 0  # Reset the count if a used block is encountered
    return None  # Not enough memory

def eraseCmd(memory, id):
    found = False
    # Free the block of memory with the given identifier
    for i in range(len(memory)):
        if memory[i] == str(id):
            memory[i] = '0'
            found = True
    return ""ILLEGAL_ERASE_ARGUMENT"" if not found else None

def defragment(memory):
    # Move all allocated blocks to the front of memory
    new_memory = ['0'] * len(memory)
    idx = 0
    for i in range(len(memory)):
        if memory[i] != '0':
            new_memory[idx] = memory[i]
            idx += 1
    return new_memory

def memory_manager(operations, m):
    memory = ['0'] * m  # Initialize memory
    current_id = 1
    output = []
    
    for operation in operations:
        parts = operation.split()
        if parts[0] == 'alloc':
            size = int(parts[1])
            result = allocCmd(memory, current_id, size)
            if result is not None:
                output.append(str(result))
                current_id += 1  # Increment identifier for the next alloc
            else:
                output.append('NULL')  # Not enough memory
        elif parts[0] == 'erase':
            id = int(parts[1])
            result = eraseCmd(memory, id)
            if result is not None:
                output.append(result)
        elif parts[0] == 'defragment':
            memory = defragment(memory)

    return output"
950,B,Intercepted Message,PROGRAMMING,"['greedy', 'implementation']","Hacker Zhorik wants to decipher two secret messages he intercepted yesterday. Yeah message is a sequence of encrypted blocks, each of them consists of several bytes of information.

Zhorik knows that each of the messages is an archive containing one or more files. Zhorik knows how each of these archives was transferred through the network: if an archive consists of *k* files of sizes *l*1,<=*l*2,<=...,<=*l**k* bytes, then the *i*-th file is split to one or more blocks *b**i*,<=1,<=*b**i*,<=2,<=...,<=*b**i*,<=*m**i* (here the total length of the blocks *b**i*,<=1<=+<=*b**i*,<=2<=+<=...<=+<=*b**i*,<=*m**i* is equal to the length of the file *l**i*), and after that all blocks are transferred through the network, maintaining the order of files in the archive.

Zhorik thinks that the two messages contain the same archive, because their total lengths are equal. However, each file can be split in blocks in different ways in the two messages.

You are given the lengths of blocks in each of the two messages. Help Zhorik to determine what is the maximum number of files could be in the archive, if the Zhorik's assumption is correct.","The first line contains two integers *n*, *m* (1<=≤<=*n*,<=*m*<=≤<=105) — the number of blocks in the first and in the second messages.

The second line contains *n* integers *x*1,<=*x*2,<=...,<=*x**n* (1<=≤<=*x**i*<=≤<=106) — the length of the blocks that form the first message.

The third line contains *m* integers *y*1,<=*y*2,<=...,<=*y**m* (1<=≤<=*y**i*<=≤<=106) — the length of the blocks that form the second message.

It is guaranteed that *x*1<=+<=...<=+<=*x**n*<==<=*y*1<=+<=...<=+<=*y**m*. Also, it is guaranteed that *x*1<=+<=...<=+<=*x**n*<=≤<=106.",Print the maximum number of files the intercepted array could consist of.,"['7 6\n2 5 3 1 11 4 4\n7 8 2 4 1 8\n', '3 3\n1 10 100\n1 100 10\n', '1 4\n4\n1 1 1 1\n']","['3\n', '2\n', '1\n']","In the first example the maximum number of files in the archive is 3. For example, it is possible that in the archive are three files of sizes 2 + 5 = 7, 15 = 3 + 1 + 11 = 8 + 2 + 4 + 1 and 4 + 4 = 8.

In the second example it is possible that the archive contains two files of sizes 1 and 110 = 10 + 100 = 100 + 10. Note that the order of files is kept while transferring archives through the network, so we can't say that there are three files of sizes 1, 10 and 100.

In the third example the only possibility is that the archive contains a single file of size 4.",TIME_LIMIT_EXCEEDED,"s = list(map(int, input().split()))
n = s[0]
m = s[1]
x = list(map(int, input().split()))
y = list(map(int, input().split()))
i = x.pop(0)
j = y.pop(0)
counter = 0
while True:
    if i==j:
        counter+=1
        if len(y)==0 or len(x)==0:
            break
        i = x.pop(0)
        j = y.pop(0)
    elif i>j:
        if len(y)==0:
            break
        j +=y.pop(0)

    elif i<j:
        if len(x)==0:
            break
        i +=x.pop(0)

print(counter)
","def in_between(s, char):
    a = []
    idx1 = None
    idx2 = None
    for i, c in enumerate(s):
        if c == char:
            if idx1 is None:
                idx1 = i
            else:
                idx2 = i
                a.append(idx2 - idx1 + 1)
                idx1 = idx2
    
    # If character 'char' is found at the end of the string
    if idx1 is not None and idx2 is None:
        a.append(len(s) - idx1)
    
    return a

def min_k_dominant(s):
    from collections import defaultdict
    
    # Dictionary to store the positions of each character
    char_positions = defaultdict(list)
    
    # Collect positions of each character in the string
    for i, char in enumerate(s):
        char_positions[char].append(i)
    
    min_k = float('inf')  # Initialize min_k to a large number

    # Check each character's positions to determine the smallest k
    for char, positions in char_positions.items():
        # the gaps between consecutive positions of the character
        gaps = []
        for i in range(1, len(positions)):
            gaps.append(positions[i] - positions[i - 1])
        
        # Check the start and end boundaries
        if positions[0] > 0:
            gaps.insert(0, positions[0] + 1)  # gap before the first occurrence
        if positions[-1] < len(s) - 1:
            gaps.append(len(s) - positions[-1])  # gap after the last occurrence
        
        # The minimum k for this character is the size of the largest gap
        max_gap = max(gaps)
        min_k = min(min_k, max_gap)

    return min_k

# Example usage
s = input().strip()
print(min_k_dominant(s))"
807,A,Is it rated?,PROGRAMMING,"['implementation', 'sortings']","Is it rated?

Here it is. The Ultimate Question of Competitive Programming, Codeforces, and Everything. And you are here to answer it.

Another Codeforces round has been conducted. No two participants have the same number of points. For each participant, from the top to the bottom of the standings, their rating before and after the round is known.

It's known that if at least one participant's rating has changed, then the round was rated for sure.

It's also known that if the round was rated and a participant with lower rating took a better place in the standings than a participant with higher rating, then at least one round participant's rating has changed.

In this problem, you should not make any other assumptions about the rating system.

Determine if the current round is rated, unrated, or it's impossible to determine whether it is rated of not.","The first line contains a single integer *n* (2<=≤<=*n*<=≤<=1000) — the number of round participants.

Each of the next *n* lines contains two integers *a**i* and *b**i* (1<=≤<=*a**i*,<=*b**i*<=≤<=4126) — the rating of the *i*-th participant before and after the round, respectively. The participants are listed in order from the top to the bottom of the standings.","If the round is rated for sure, print ""rated"". If the round is unrated for sure, print ""unrated"". If it's impossible to determine whether the round is rated or not, print ""maybe"".","['6\n3060 3060\n2194 2194\n2876 2903\n2624 2624\n3007 2991\n2884 2884\n', '4\n1500 1500\n1300 1300\n1200 1200\n1400 1400\n', '5\n3123 3123\n2777 2777\n2246 2246\n2246 2246\n1699 1699\n']","['rated\n', 'unrated\n', 'maybe\n']","In the first example, the ratings of the participants in the third and fifth places have changed, therefore, the round was rated.

In the second example, no one's rating has changed, but the participant in the second place has lower rating than the participant in the fourth place. Therefore, if the round was rated, someone's rating would've changed for sure.

In the third example, no one's rating has changed, and the participants took places in non-increasing order of their rating. Therefore, it's impossible to determine whether the round is rated or not.",WRONG_ANSWER,"n,r,o=int(input()),0,0
c,d=map(int,input().split())
for i in range(n-1):
  a,b=map(int,input().split())
  if b!=a:r=1
  if a>c:o=1
  c,d=a,b
print('rated'if r else 'unrated' if o else 'maybe')","import math
from os import startfile
import random 
from queue import Queue
import time 
import heapq
import sys 

def min_students_on_bench(n, m, enmities):
    # Create an adjacency list for the students and their archenemies
    graph = {i: [] for i in range(1, n + 1)}
    
    for a, b in enmities:
        graph[a].append(b)
        graph[b].append(a)

    # To keep track of visited nodes and colors for bipartite checking
    visited = {}
    color = {}

    def bfs(start):
        queue = Queue()
        queue.put(start)
        color[start] = 0  # Start coloring with 0
        count = [0, 0]  # Count for each color
        count[0] += 1
        
        while not queue.empty():
            node = queue.get()
            for neighbor in graph[node]:
                if neighbor not in visited:
                    visited[neighbor] = True
                    color[neighbor] = 1 - color[node]  # Alternate color
                    count[color[neighbor]] += 1
                    queue.put(neighbor)
                elif color[neighbor] == color[node]:
                    # If we find same color neighbors, not bipartite
                    return -1
        return min(count)  # Return the minimum count to send to the bench

    total_bench = 0
    for student in range(1, n + 1):
        if student not in visited:
            visited[student] = True
            result = bfs(student)
            if result == -1:
                # If the graph is not bipartite, we need to send all of them to the bench
                return total_bench + len(graph)
            total_bench += result

    # Minimum number of students to send to the bench to form two teams
    return total_bench

# Input reading
n, m = map(int, input().split())
enmities = [tuple(map(int, input().split())) for _ in range(m)]

# Output the minimum number of students to send to the bench
print(min_students_on_bench(n, m, enmities))"
2,A,Winner,PROGRAMMING,"['hashing', 'implementation']","The winner of the card game popular in Berland ""Berlogging"" is determined according to the following rules. If at the end of the game there is only one player with the maximum number of points, he is the winner. The situation becomes more difficult if the number of such players is more than one. During each round a player gains or loses a particular number of points. In the course of the game the number of points is registered in the line ""name score"", where name is a player's name, and score is the number of points gained in this round, which is an integer number. If score is negative, this means that the player has lost in the round. So, if two or more players have the maximum number of points (say, it equals to *m*) at the end of the game, than wins the one of them who scored at least *m* points first. Initially each player has 0 points. It's guaranteed that at the end of the game at least one player has a positive number of points.","The first line contains an integer number *n* (1<=<=≤<=<=*n*<=<=≤<=<=1000), *n* is the number of rounds played. Then follow *n* lines, containing the information about the rounds in ""name score"" format in chronological order, where name is a string of lower-case Latin letters with the length from 1 to 32, and score is an integer number between -1000 and 1000, inclusive.",Print the name of the winner.,"['3\nmike 3\nandrew 5\nmike 2\n', '3\nandrew 3\nandrew 2\nmike 5\n']","['andrew\n', 'andrew\n']",none,WRONG_ANSWER,"
#definim clasa RoundTotals care o sa tina minte numele si punctajul catigatorului unei runde
class RoundTotals:
       def __init__(self, name, points):
              self.name = name
              self.points = points
#aceasta functie ne ajuta sa citim corect datele de la stdin
def value(inputValue):
       try:
              #incearca sa transforma nr in integer, daca nu poate arunca o exceptie
              return int(inputValue) 
       except ValueError:
              #returneaza stringul
              return inputValue
#citim datele de la stdin
def getInput():
       #numarul de runde
       rounds = int(input())
       #o lista care va contine toate datele din std in sub forma de obiect ex: [{name:'mike',points:3},..]
       totals = []
       #citim atatea linii de la stdin cate rounds a avut joaca
       while rounds:
              #decrimentam rounds
              rounds -= 1
              #functia map primeste 2 agumente, primul: o functie prin care trec toate elementele; al doilea: elementele 
              #str(input()) - transforma input-ul in string
              #.split() ia fiecare ""cuvant"" adica string separat de spatiu si il pune intr-o lista, unde fiecare ""cuvant"" este un element al listei
              name, points = map(value, str(input()).split())
              #adaugam in totals un element cu noul nume si points citite din input
              totals.append(RoundTotals(name, points))
       #returnam lista totals
       return totals

# primeste datele la 2 jucatori si retrueaza pe cel care are cele mai multe puncte
def searchWinner(player1, player2):
       if player1.points > player2.points:
              return player1
       else:
              return player2
#returneaza castigatorul definitiv
def returnWinner():
       #definim lista totals care primeste toate datele din input sub forma de array de obiecte
       totals = getInput()
       #initializam i cu 0 pentru a parcurge aceasta lista
       i = 0
       #presupunem ca primul castigator introdus in input e winner
       winner = totals[0]
       #parcurgem lista totals
       while i < len(totals)-1:
              #daca doi castigatori la rand nu au acelasi nume 
              if totals[i].name != totals[i+1].name:
                     #cautam winner dintre ei doi
                     winner = searchWinner(winner, totals[i+1])
              else: #daca au acelasi nume adunam punctele lor si stergem din lista jucatorul care se repeta
                     totals[i].points += totals[i+1].points
                     totals.remove(totals[i+1])
              #inclimentam i
              i += 1
       #returnam numele castigatroului 
       return winner.name
#printam numele castigatorului
print(returnWinner())
","from collections import defaultdict

n, q = map(int, input().split())
arr = list(map(int, input().split()))

# Sort the array in descending order
arr.sort(reverse=True)

# Initialize a frequency array to count the number of times each index is queried
freq = [0] * (n + 1)

# Process each query and update the frequency array
for _ in range(q):
    l, r = map(int, input().split())
    freq[l - 1] += 1  # Increment at the start index
    if r < n:
        freq[r] -= 1  # Decrement just after the end index

# Convert frequency array to actual frequencies using prefix sums
for i in range(1, n):
    freq[i] += freq[i - 1]

# Calculate the maximum sum of query replies
max_sum = 0
for i in range(n):
    max_sum += arr[i] * freq[i]

# Output the maximum sum
print(max_sum)"
479,C,Exams,PROGRAMMING,"['greedy', 'sortings']","Student Valera is an undergraduate student at the University. His end of term exams are approaching and he is to pass exactly *n* exams. Valera is a smart guy, so he will be able to pass any exam he takes on his first try. Besides, he can take several exams on one day, and in any order.

According to the schedule, a student can take the exam for the *i*-th subject on the day number *a**i*. However, Valera has made an arrangement with each teacher and the teacher of the *i*-th subject allowed him to take an exam before the schedule time on day *b**i* (*b**i*<=&lt;<=*a**i*). Thus, Valera can take an exam for the *i*-th subject either on day *a**i*, or on day *b**i*. All the teachers put the record of the exam in the student's record book on the day of the actual exam and write down the date of the mark as number *a**i*.

Valera believes that it would be rather strange if the entries in the record book did not go in the order of non-decreasing date. Therefore Valera asks you to help him. Find the minimum possible value of the day when Valera can take the final exam if he takes exams so that all the records in his record book go in the order of non-decreasing date.","The first line contains a single positive integer *n* (1<=≤<=*n*<=≤<=5000) — the number of exams Valera will take.

Each of the next *n* lines contains two positive space-separated integers *a**i* and *b**i* (1<=≤<=*b**i*<=&lt;<=*a**i*<=≤<=109) — the date of the exam in the schedule and the early date of passing the *i*-th exam, correspondingly.",Print a single integer — the minimum possible number of the day when Valera can take the last exam if he takes all the exams so that all the records in his record book go in the order of non-decreasing date.,"['3\n5 2\n3 1\n4 2\n', '3\n6 1\n5 2\n4 3\n']","['2\n', '6\n']","In the first sample Valera first takes an exam in the second subject on the first day (the teacher writes down the schedule date that is 3). On the next day he takes an exam in the third subject (the teacher writes down the schedule date, 4), then he takes an exam in the first subject (the teacher writes down the mark with date 5). Thus, Valera takes the last exam on the second day and the dates will go in the non-decreasing order: 3, 4, 5.

In the second sample Valera first takes an exam in the third subject on the fourth day. Then he takes an exam in the second subject on the fifth day. After that on the sixth day Valera takes an exam in the first subject.",WRONG_ANSWER,"import sys
n = int(sys.stdin.readline())
t = []
for i in range(n):

    t.append(list(map(int,sys.stdin.readline().split())))
    if i ==0:
        asd = t[0]
    if t[i][0] >asd[0] and t[i][1] >asd[1]:
        asd = t[i]
    if i ==n-1:
        memory = t[n-1]

if memory[1]>asd[1]:
    print(asd[0])
else:
    print(asd[1])
","n = int(input())
a = list(map(int, input().split()))

# Find the positions of the minimum and maximum elements
min_pos = a.index(1)
max_pos = a.index(n)

# Calculate the current distance
current_distance = abs(min_pos - max_pos)

# Calculate potential distances after swapping
# Option 1: Move min to the start (index 0)
distance_swap_min_start = abs(0 - max_pos)

# Option 2: Move min to the end (index n - 1)
distance_swap_min_end = abs((n - 1) - max_pos)

# Option 3: Move max to the start (index 0)
distance_swap_max_start = abs(min_pos - 0)

# Option 4: Move max to the end (index n - 1)
distance_swap_max_end = abs(min_pos - (n - 1))

# The maximum possible distance after one swap
max_distance = max(current_distance, distance_swap_min_start, distance_swap_min_end, distance_swap_max_start, distance_swap_max_end)

print(max_distance)"
50,A,Domino piling,PROGRAMMING,"['greedy', 'math']","You are given a rectangular board of *M*<=×<=*N* squares. Also you are given an unlimited number of standard domino pieces of 2<=×<=1 squares. You are allowed to rotate the pieces. You are asked to place as many dominoes as possible on the board so as to meet the following conditions:

1. Each domino completely covers two squares.

2. No two dominoes overlap.

3. Each domino lies entirely inside the board. It is allowed to touch the edges of the board.

Find the maximum number of dominoes, which can be placed under these restrictions.",In a single line you are given two integers *M* and *N* — board sizes in squares (1<=≤<=*M*<=≤<=*N*<=≤<=16).,"Output one number — the maximal number of dominoes, which can be placed.","['2 4\n', '3 3\n']","['4\n', '4\n']",none,RUNTIME_ERROR,"number1 = int(input())
number2 = int(input())
if(number1*number2 != 1):
     if (number1 >= 1 and number2 >= number1 and number2 <= 16):
           print(int(((number1*number2) - ((number1-2) * (number2-2)))/2))","def readLines(file):
    f = open(file, ""r"")
    line = f.readlines()
    f.close()
    return line

def writeLine(file, line):
    f = open(file, ""a"")
    f.write(line + ""\n"")
    f.close()

def pair_cards(n, cards):
    from collections import defaultdict
    
    # Dictionary to keep track of indices of cards
    card_indices = defaultdict(list)
    for index, card in enumerate(cards):
        card_indices[card].append(index + 1)  # Store index as 1-based
    
    pairs = []
    
    for indices in card_indices.values():
        if len(indices) % 2 != 0:
            return -1  # If there's an odd number of cards for any value, return -1
        # Create pairs from the indices
        for i in range(0, len(indices), 2):
            pairs.append((indices[i], indices[i + 1]))
    
    return pairs

def main():
    lines = readLines(""input.txt"")
    n = int(lines[0].strip())
    cards = list(map(int, lines[1].strip().split()))
    
    result = pair_cards(n, cards)
    
    if result == -1:
        writeLine(""output.txt"", ""-1"")
    else:
        for pair in result:
            writeLine(""output.txt"", f""{pair[0]} {pair[1]}"")

main()"
884,A,Book Reading,PROGRAMMING,['implementation'],"Recently Luba bought a very interesting book. She knows that it will take *t* seconds to read the book. Luba wants to finish reading as fast as she can.

But she has some work to do in each of *n* next days. The number of seconds that Luba has to spend working during *i*-th day is *a**i*. If some free time remains, she can spend it on reading.

Help Luba to determine the minimum number of day when she finishes reading.

It is guaranteed that the answer doesn't exceed *n*.

Remember that there are 86400 seconds in a day.","The first line contains two integers *n* and *t* (1<=≤<=*n*<=≤<=100, 1<=≤<=*t*<=≤<=106) — the number of days and the time required to read the book.

The second line contains *n* integers *a**i* (0<=≤<=*a**i*<=≤<=86400) — the time Luba has to spend on her work during *i*-th day.","Print the minimum day Luba can finish reading the book.

It is guaranteed that answer doesn't exceed *n*.","['2 2\n86400 86398\n', '2 86400\n0 86400\n']","['2\n', '1\n']",none,OK,"n, t = map(int, input().split())
daftar_waktu_kerja = list(map(int, input().split()))
hari = 1

for waktu_kerja in daftar_waktu_kerja:
  waktu_kosong = 86400 - waktu_kerja
  t -= waktu_kosong

  if t <= 0:
    print(hari)
    break
  
  hari += 1
	 		  					     	   	 		    	","import math

def numberToBase(n, b):
    if n == 0:
        return [0]
    digits = []
    while n:
        digits.append(n % b)
        n //= b
    return digits[::-1]

def sumOfDigitsInBase(n, base):
    digits = numberToBase(n, base)
    return sum(digits)

def averageSumOfDigits(A):
    total_sum = 0
    count = A - 1  # Count of bases from 2 to A
    for base in range(2, A + 1):
        total_sum += sumOfDigitsInBase(A, base)
    
    numerator = total_sum
    denominator = count
    
    # Simplifying the fraction
    gcd = math.gcd(numerator, denominator)
    numerator //= gcd
    denominator //= gcd
    
    return f""{numerator}/{denominator}""

A = int(input())
print(averageSumOfDigits(A))"
384,A,Coder,PROGRAMMING,['implementation'],"Iahub likes chess very much. He even invented a new chess piece named Coder. A Coder can move (and attack) one square horizontally or vertically. More precisely, if the Coder is located at position (*x*,<=*y*), he can move to (or attack) positions (*x*<=+<=1,<=*y*), (*x*–1,<=*y*), (*x*,<=*y*<=+<=1) and (*x*,<=*y*–1).

Iahub wants to know how many Coders can be placed on an *n*<=×<=*n* chessboard, so that no Coder attacks any other Coder.",The first line contains an integer *n* (1<=≤<=*n*<=≤<=1000).,"On the first line print an integer, the maximum number of Coders that can be placed on the chessboard.

On each of the next *n* lines print *n* characters, describing the configuration of the Coders. For an empty cell print an '.', and for a Coder print a 'C'.

If there are multiple correct answers, you can print any.",['2\n'],['2\nC.\n.C\n'],none,WRONG_ANSWER,"n = int(input())
print(n)
a = ['C' if i % 2 == 0 else '.' for i in range(n)]


def swap(a):
    for i in range(n):
        if a[i] == '.':
            a[i] = 'C'
        else:
            a[i] = '.'
    return a


for i in range(n):
    print(*a, sep='')
    a = swap(a)
","def main():
    n, packs = list(map(int, input().split()))
    sad = 0
    
    for _ in range(n):
        operation = input().split()
        sign = operation[0]
        d = int(operation[1])
        
        if sign == '+':
            # A carrier brings ice cream packs
            packs += d
        elif sign == '-':
            # A kid wants ice cream packs
            if packs >= d:
                packs -= d  # Give the requested packs
            else:
                sad += 1  # Kid leaves in distress

    print(packs, sad)

main()"
340,A,The Wall,PROGRAMMING,['math'],"Iahub and his friend Floyd have started painting a wall. Iahub is painting the wall red and Floyd is painting it pink. You can consider the wall being made of a very large number of bricks, numbered 1, 2, 3 and so on. 

Iahub has the following scheme of painting: he skips *x*<=-<=1 consecutive bricks, then he paints the *x*-th one. That is, he'll paint bricks *x*, 2·*x*, 3·*x* and so on red. Similarly, Floyd skips *y*<=-<=1 consecutive bricks, then he paints the *y*-th one. Hence he'll paint bricks *y*, 2·*y*, 3·*y* and so on pink.

After painting the wall all day, the boys observed that some bricks are painted both red and pink. Iahub has a lucky number *a* and Floyd has a lucky number *b*. Boys wonder how many bricks numbered no less than *a* and no greater than *b* are painted both red and pink. This is exactly your task: compute and print the answer to the question.","The input will have a single line containing four integers in this order: *x*, *y*, *a*, *b*. (1<=≤<=*x*,<=*y*<=≤<=1000, 1<=≤<=*a*,<=*b*<=≤<=2·109, *a*<=≤<=*b*).",Output a single integer — the number of bricks numbered no less than *a* and no greater than *b* that are painted both red and pink.,['2 3 6 18\n'],['3'],"Let's look at the bricks from *a* to *b* (*a* = 6, *b* = 18). The bricks colored in red are numbered 6, 8, 10, 12, 14, 16, 18. The bricks colored in pink are numbered 6, 9, 12, 15, 18. The bricks colored in both red and pink are numbered with 6, 12 and 18.",RUNTIME_ERROR,"import sys
import math
import fractions
#f = sys.stdin

f = open(""input.txt"", ""r"")

line_ = map(int, f.readline().split())

line = []
for it in line_:
    line.append(it)

x = int(line[0])
y = int(line[1])
a = int(line[2])
b = int(line[3])
xy = x * y / fractions.gcd(x, y)
ans = b // xy - (a - 1) // xy
print( int(ans) )
","#!/usr/bin/python3

# Card values mapping
card_values = {
    2: 4,    # 4 twos
    3: 4,    # 4 threes
    4: 4,    # 4 fours
    5: 4,    # 4 fives
    6: 4,    # 4 sixes
    7: 4,    # 4 sevens
    8: 4,    # 4 eights
    9: 4,    # 4 nines
    10: 16,  # 4 tens, 4 jacks, 4 queens (but queen of spades is already taken), 4 kings
    11: 4    # 4 aces
}

n = int(input())  # Read the required sum of points

initial_card_value = 10  # Value of the queen of spades
required_value = n - initial_card_value  # Calculate the needed value from the second card

# Count the number of ways to get the second card
if required_value in card_values:
    ways = card_values[required_value]
else:
    ways = 0  # No card matches the needed value

# Output the result
print(ways)"
1004,A,Sonya and Hotels,PROGRAMMING,['implementation'],"Sonya decided that having her own hotel business is the best way of earning money because she can profit and rest wherever she wants.

The country where Sonya lives is an endless line. There is a city in each integer coordinate on this line. She has $n$ hotels, where the $i$-th hotel is located in the city with coordinate $x_i$. Sonya is a smart girl, so she does not open two or more hotels in the same city.

Sonya understands that her business needs to be expanded by opening new hotels, so she decides to build one more. She wants to make the minimum distance from this hotel to all others to be equal to $d$. The girl understands that there are many possible locations to construct such a hotel. Thus she wants to know the number of possible coordinates of the cities where she can build a new hotel. 

Because Sonya is lounging in a jacuzzi in one of her hotels, she is asking you to find the number of cities where she can build a new hotel so that the minimum distance from the original $n$ hotels to the new one is equal to $d$.","The first line contains two integers $n$ and $d$ ($1\leq n\leq 100$, $1\leq d\leq 10^9$) — the number of Sonya's hotels and the needed minimum distance from a new hotel to all others.

The second line contains $n$ different integers in strictly increasing order $x_1, x_2, \ldots, x_n$ ($-10^9\leq x_i\leq 10^9$) — coordinates of Sonya's hotels.",Print the number of cities where Sonya can build a new hotel so that the minimum distance from this hotel to all others is equal to $d$.,"['4 3\n-3 2 9 16\n', '5 2\n4 8 11 18 19\n']","['6\n', '5\n']","In the first example, there are $6$ possible cities where Sonya can build a hotel. These cities have coordinates $-6$, $5$, $6$, $12$, $13$, and $19$.

In the second example, there are $5$ possible cities where Sonya can build a hotel. These cities have coordinates $2$, $6$, $13$, $16$, and $21$.",OK,"n, d = map(int, input().split())
li = list(map(int, input().split()))
c = 2
for i in range(1, n):
    if (li[i] - li[i-1]) == 2*d:
        c = c + 1
    if (li[i] - li[i-1]) > 2*d:
        c = c + 2
print(c)","import sys
from array import array  # noqa: F401


def input1():
    with open('input.txt') as fp:
        return fp.readlines()


def create_fractal(model, k):
    n = len(model)
    
    # Create the initial fractal from the model
    fractal = []
    for row in model:
        fractal_row = []
        for char in row:
            if char == '*':
                fractal_row.append('*')
            else:
                fractal_row.append('.')
        fractal.append(fractal_row)
    
    # Apply the fractal generation k times
    for _ in range(k):
        new_size = n * n
        new_fractal = [['.' for _ in range(new_size)] for _ in range(new_size)]
        
        # Fill in the new fractal based on the previous fractal
        for i in range(n):
            for j in range(n):
                if fractal[i][j] == '*':
                    # Fill the corresponding n x n block with '*'
                    for x in range(i * n, (i + 1) * n):
                        for y in range(j * n, (j + 1) * n):
                            new_fractal[x][y] = '*'
        
        fractal = new_fractal  # Move to the newly created fractal
    
    return fractal


def print_fractal(fractal):
    for row in fractal:
        print(''.join(row))


if __name__ == ""__main__"":
    input_data = input1()
    n, k = map(int, input_data[0].strip().split())
    model = [line.strip() for line in input_data[1:n + 1]]
    
    final_fractal = create_fractal(model, k)
    print_fractal(final_fractal)"
214,A,System of Equations,PROGRAMMING,['brute force'],"Furik loves math lessons very much, so he doesn't attend them, unlike Rubik. But now Furik wants to get a good mark for math. For that Ms. Ivanova, his math teacher, gave him a new task. Furik solved the task immediately. Can you?

You are given a system of equations: 

You should count, how many there are pairs of integers (*a*,<=*b*) (0<=≤<=*a*,<=*b*) which satisfy the system.","A single line contains two integers *n*,<=*m* (1<=≤<=*n*,<=*m*<=≤<=1000) — the parameters of the system. The numbers on the line are separated by a space.",On a single line print the answer to the problem.,"['9 3\n', '14 28\n', '4 20\n']","['1\n', '1\n', '0\n']","In the first sample the suitable pair is integers (3, 0). In the second sample the suitable pair is integers (3, 5). In the third sample there is no suitable pair.",WRONG_ANSWER,"from math import sqrt,floor
n,m =map(int,input().split())
a=floor(sqrt(n))
b=n-(a*a)
if a!=(m-(b*b)):
    print(0)
else:
    print(1)","def main():
    n, k = [int(i) for i in input().split()]
    a = [int(i) for i in input().split()]

    actions = []
    total_minutes = 0
    
    for i, height in enumerate(a):
        if height < 1:
            # Increase height to 1 if it's less than 1
            actions.append(f""+ {i + 1} {1 - height}"")
            total_minutes += 1 - height
            a[i] = 1
        elif height > k:
            # Decrease height to k if it's greater than k
            actions.append(f""- {i + 1} {height - k}"")
            total_minutes += height - k
            a[i] = k

    print(total_minutes)
    for action in actions:
        print(action)

if __name__ == ""__main__"":
    main()"
527,D,Clique Problem,PROGRAMMING,"['data structures', 'dp', 'greedy', 'implementation', 'sortings']","The clique problem is one of the most well-known NP-complete problems. Under some simplification it can be formulated as follows. Consider an undirected graph *G*. It is required to find a subset of vertices *C* of the maximum size such that any two of them are connected by an edge in graph *G*. Sounds simple, doesn't it? Nobody yet knows an algorithm that finds a solution to this problem in polynomial time of the size of the graph. However, as with many other NP-complete problems, the clique problem is easier if you consider a specific type of a graph.

Consider *n* distinct points on a line. Let the *i*-th point have the coordinate *x**i* and weight *w**i*. Let's form graph *G*, whose vertices are these points and edges connect exactly the pairs of points (*i*,<=*j*), such that the distance between them is not less than the sum of their weights, or more formally: |*x**i*<=-<=*x**j*|<=≥<=*w**i*<=+<=*w**j*.

Find the size of the maximum clique in such graph.","The first line contains the integer *n* (1<=≤<=*n*<=≤<=200<=000) — the number of points.

Each of the next *n* lines contains two numbers *x**i*, *w**i* (0<=≤<=*x**i*<=≤<=109,<=1<=≤<=*w**i*<=≤<=109) — the coordinate and the weight of a point. All *x**i* are different.",Print a single number — the number of vertexes in the maximum clique of the given graph.,['4\n2 3\n3 1\n6 1\n0 2\n'],['3\n'],"If you happen to know how to solve this problem without using the specific properties of the graph formulated in the problem statement, then you are able to get a prize of one million dollars!

The picture for the sample test.",WRONG_ANSWER,"n = int(input())
X = []
W = {}
big = -1
for _ in range(n):
    x,w = list(map(int,input().split()))
    X.append(x)
    W[x] = w
    big = max(big,x)
dp = {}
X=sorted(X)
for i,xi in enumerate(X):
    m = 1
    for j in range(i - 1,-1,-1):
        xj=X[j]
        if xi - xj >= W[xi] + W[xj]:
            m = max(m,1 + dp[xj])
    dp[xi] = m
print(max(dp))
","s = list(input())
r = 0
current = ""a""

for char in s:
    # Calculate the clockwise and counterclockwise rotations needed
    clockwise = (ord(char) - ord(current)) % 26
    counterclockwise = (ord(current) - ord(char)) % 26
    
    # Take the minimum rotations required
    r += min(clockwise, counterclockwise)
    
    # Update the current position to the new character
    current = char

print(r)"
703,B,Mishka and trip,PROGRAMMING,"['implementation', 'math']","Little Mishka is a great traveller and she visited many countries. After thinking about where to travel this time, she chose XXX — beautiful, but little-known northern country.

Here are some interesting facts about XXX:
 1.  XXX consists of *n* cities, *k* of whose (just imagine!) are capital cities. 1.  All of cities in the country are beautiful, but each is beautiful in its own way. Beauty value of *i*-th city equals to *c**i*. 1.  All the cities are consecutively connected by the roads, including 1-st and *n*-th city, forming a cyclic route 1<=—<=2<=—<=...<=—<=*n*<=—<=1. Formally, for every 1<=≤<=*i*<=&lt;<=*n* there is a road between *i*-th and *i*<=+<=1-th city, and another one between 1-st and *n*-th city. 1.  Each capital city is connected with each other city directly by the roads. Formally, if city *x* is a capital city, then for every 1<=≤<=*i*<=≤<=*n*,<=<=*i*<=≠<=*x*, there is a road between cities *x* and *i*. 1.  There is at most one road between any two cities. 1.  Price of passing a road directly depends on beauty values of cities it connects. Thus if there is a road between cities *i* and *j*, price of passing it equals *c**i*·*c**j*.
Mishka started to gather her things for a trip, but didn't still decide which route to follow and thus she asked you to help her determine summary price of passing each of the roads in XXX. Formally, for every pair of cities *a* and *b* (*a*<=&lt;<=*b*), such that there is a road between *a* and *b* you are to find sum of products *c**a*·*c**b*. Will you help her?","The first line of the input contains two integers *n* and *k* (3<=≤<=*n*<=≤<=100<=000,<=1<=≤<=*k*<=≤<=*n*) — the number of cities in XXX and the number of capital cities among them.

The second line of the input contains *n* integers *c*1,<=*c*2,<=...,<=*c**n* (1<=≤<=*c**i*<=≤<=10<=000) — beauty values of the cities.

The third line of the input contains *k* distinct integers *id*1,<=*id*2,<=...,<=*id**k* (1<=≤<=*id**i*<=≤<=*n*) — indices of capital cities. Indices are given in ascending order.",Print the only integer — summary price of passing each of the roads in XXX.,"['4 1\n2 3 1 2\n3\n', '5 2\n3 5 2 2 4\n1 4\n']","['17', '71']","This image describes first sample case:

<img class=""tex-graphics"" src=""https://espresso.codeforces.com/9dcb0e62694349977e064303a74efd880af5eb03.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

It is easy to see that summary price is equal to 17.

This image describes second sample case:

<img class=""tex-graphics"" src=""https://espresso.codeforces.com/c30146637f3647c2fc77818bbbf3c080f94f116e.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

It is easy to see that summary price is equal to 71.",WRONG_ANSWER,"print(""_RANDOM_GUESS_1689630551.6644855"")# 1689630551.664505","# link: https://codeforces.com/problemset/problem/701/C

for _ in range(1):
    n = int(input())
    s = input().strip()  # Read the string representing pokemon types
    unique_pokemons = set(s)  # Get unique pokemon types
    total_unique = len(unique_pokemons)  # Count of unique pokemon types

    # Initialize pointers for the sliding window
    left = 0
    right = 0
    pokemon_count = {}
    min_length = float('inf')  # Start with an infinitely large minimum length

    while right < n:
        # Add the current pokemon to the count
        if s[right] in pokemon_count:
            pokemon_count[s[right]] += 1
        else:
            pokemon_count[s[right]] = 1
        
        # While we have all unique pokemons in the current window
        while len(pokemon_count) == total_unique:
            # Update the minimum length
            min_length = min(min_length, right - left + 1)
            # Remove the leftmost pokemon from the count
            pokemon_count[s[left]] -= 1
            if pokemon_count[s[left]] == 0:
                del pokemon_count[s[left]]
            left += 1  # Move the left pointer
            
        right += 1  # Expand the window by moving the right pointer

    print(min_length)  # Output the minimum number of flats Sergei needs to visit"
858,A,k-rounding,PROGRAMMING,"['brute force', 'math', 'number theory']","For a given positive integer *n* denote its *k*-rounding as the minimum positive integer *x*, such that *x* ends with *k* or more zeros in base 10 and is divisible by *n*.

For example, 4-rounding of 375 is 375·80<==<=30000. 30000 is the minimum integer such that it ends with 4 or more zeros and is divisible by 375.

Write a program that will perform the *k*-rounding of *n*.","The only line contains two integers *n* and *k* (1<=≤<=*n*<=≤<=109, 0<=≤<=*k*<=≤<=8).",Print the *k*-rounding of *n*.,"['375 4\n', '10000 1\n', '38101 0\n', '123456789 8\n']","['30000\n', '10000\n', '38101\n', '12345678900000000\n']",none,OK,"import math
n,k = map(int,input().split())
m =(n * (10**k)) / math.gcd(n, (10**k))
print(int(m))","def has_AB_BA(s):
    # Check if the string s contains ""AB"" and ""BA""
    return ""AB"" in s and ""BA"" in s

def main():
    # Read input string
    s = input().strip()
    
    # Initialize indices for search
    ab_index = -1
    ba_index = -1
    
    # Iterate through the string to find non-overlapping ""AB"" and ""BA""
    for i in range(len(s) - 1):
        if s[i:i+2] == ""AB"":
            # If we found ""AB"", update the index
            ab_index = i
            # Check for ""BA"" after ""AB"" to ensure non-overlapping
            if ""BA"" in s[ab_index + 2:]:
                print(""YES"")
                return
        elif s[i:i+2] == ""BA"":
            # If we found ""BA"", update the index
            ba_index = i
            # Check for ""AB"" after ""BA"" to ensure non-overlapping
            if ""AB"" in s[ba_index + 2:]:
                print(""YES"")
                return
    
    # If no non-overlapping substrings found, output ""NO""
    print(""NO"")

# Entry point of the program
if __name__ == ""__main__"":
    main()"
82,A,Double Cola,PROGRAMMING,"['implementation', 'math']","Sheldon, Leonard, Penny, Rajesh and Howard are in the queue for a ""Double Cola"" drink vending machine; there are no other people in the queue. The first one in the queue (Sheldon) buys a can, drinks it and doubles! The resulting two Sheldons go to the end of the queue. Then the next in the queue (Leonard) buys a can, drinks it and gets to the end of the queue as two Leonards, and so on. This process continues ad infinitum.

For example, Penny drinks the third can of cola and the queue will look like this: Rajesh, Howard, Sheldon, Sheldon, Leonard, Leonard, Penny, Penny.

Write a program that will print the name of a man who will drink the *n*-th can.

Note that in the very beginning the queue looks like that: Sheldon, Leonard, Penny, Rajesh, Howard. The first person is Sheldon.","The input data consist of a single integer *n* (1<=≤<=*n*<=≤<=109).

It is guaranteed that the pretests check the spelling of all the five names, that is, that they contain all the five possible answers.","Print the single line — the name of the person who drinks the *n*-th can of cola. The cans are numbered starting from 1. Please note that you should spell the names like this: ""Sheldon"", ""Leonard"", ""Penny"", ""Rajesh"", ""Howard"" (without the quotes). In that order precisely the friends are in the queue initially.","['1\n', '6\n', '1802\n']","['Sheldon\n', 'Sheldon\n', 'Penny\n']",none,WRONG_ANSWER,"
p=[""Sheldon"", ""Leonard"", ""Penny"", ""Rajesh"", ""Howard""]
a=int(input())
i=1
while True:
    if a<=(5*i):
        print(p[int(a/i)-1])
        break
    else:
        a-=(5*i)
        i*=2","n=int(input())
x=[]
y=[]
for i in range(n) :
    k=input().split()
    x.append(int(k[0]))
    y.append(int(k[1]))

# Use a set to track unique rows and columns
unique_rows = set(x)
unique_cols = set(y)

# The number of additional snow drifts needed is the maximum
# of the unique rows or unique columns minus the number of existing snow drifts
min_needed = max(len(unique_rows), len(unique_cols)) - n

# Output the minimum number of drifts to be created
print(min_needed)"
637,C,Promocodes with Mistakes,PROGRAMMING,"['*special', 'brute force', 'constructive algorithms', 'implementation']","During a New Year special offer the ""Sudislavl Bars"" offered *n* promo codes. Each promo code consists of exactly six digits and gives right to one free cocktail at the bar ""Mosquito Shelter"". Of course, all the promocodes differ.

As the ""Mosquito Shelter"" opens only at 9, and partying in Sudislavl usually begins at as early as 6, many problems may arise as to how to type a promotional code without errors. It is necessary to calculate such maximum *k*, that the promotional code could be uniquely identified if it was typed with no more than *k* errors. At that, *k*<==<=0 means that the promotional codes must be entered exactly.

A mistake in this problem should be considered as entering the wrong numbers. For example, value ""123465"" contains two errors relative to promocode ""123456"". Regardless of the number of errors the entered value consists of exactly six digits.","The first line of the output contains number *n* (1<=≤<=*n*<=≤<=1000) — the number of promocodes.

Each of the next *n* lines contains a single promocode, consisting of exactly 6 digits. It is guaranteed that all the promocodes are distinct. Promocodes can start from digit ""0"".","Print the maximum *k* (naturally, not exceeding the length of the promocode), such that any promocode can be uniquely identified if it is typed with at most *k* mistakes.","['2\n000000\n999999\n', '6\n211111\n212111\n222111\n111111\n112111\n121111\n']","['2\n', '0\n']","In the first sample *k* &lt; 3, so if a bar customer types in value ""090909"", then it will be impossible to define which promocode exactly corresponds to it.",RUNTIME_ERROR,"n = input()
promo_code = []
def compare_str(a,b):
    k = 0
    for i in range(6):
        if a[i] == b[i]:
            k = k+1
    return k
for i in range(0,int(n)):
    x = input()
    promo_code.append(x)
largest_same_num = 0 
for i in promo_code:
    for j in promo_code:
        if i!=j:
            a = compare_str(i,j)
            if a > largest_same_num:
                largest_same_num = a
k = 0
if largest_same_num == 1 or largest_same_num == 0:
    k = 2
elif largesr_same_num == 2 or largest_same_num == 3:
    k = 1
print(k)
","import sys
input = lambda: sys.stdin.readline().rstrip()
from collections import Counter, defaultdict

n, k = map(int, input().split())
a = list(map(int, input().split()))

# Initialize a counter for tracking occurrences of each number
counts = Counter(a)

# Initialize counts for potential pairs and triplets
pair_counts = defaultdict(int)
triplet_count = 0

# Iterate through each number in the array
for num in a:
    if num in pair_counts:
        # If num can be the third element of a GP, add to triplet count
        triplet_count += pair_counts[num]
    
    # If num can be the second element of a GP, update pair counts
    if num % k == 0:
        first_term = num // k  # Calculate the first term in the potential GP
        pair_counts[num] += counts[first_term]  # Update pairs leading to current number

# Output the total count of triplets forming the GP
print(triplet_count)"
527,A,Playing with Paper,PROGRAMMING,"['implementation', 'math']","One day Vasya was sitting on a not so interesting Maths lesson and making an origami from a rectangular *a* mm <=×<= *b* mm sheet of paper (*a*<=&gt;<=*b*). Usually the first step in making an origami is making a square piece of paper from the rectangular sheet by folding the sheet along the bisector of the right angle, and cutting the excess part.

After making a paper ship from the square piece, Vasya looked on the remaining (*a*<=-<=*b*) mm <=×<= *b* mm strip of paper. He got the idea to use this strip of paper in the same way to make an origami, and then use the remainder (if it exists) and so on. At the moment when he is left with a square piece of paper, he will make the last ship from it and stop.

Can you determine how many ships Vasya will make during the lesson?","The first line of the input contains two integers *a*, *b* (1<=≤<=*b*<=&lt;<=*a*<=≤<=1012) — the sizes of the original sheet of paper.",Print a single integer — the number of ships that Vasya will make.,"['2 1\n', '10 7\n', '1000000000000 1\n']","['2\n', '6\n', '1000000000000\n']",Pictures to the first and second sample test.,CHALLENGED,"a_b = input().split()
a = int(a_b[0])
b = int(a_b[1])
if a > b:
    bolshoe = a
    menshee = b
else:
    bolshoe = b
    menshee = a

vivod = 1

x = 0
i = 0

if bolshoe == menshee:
    x = 1
elif a == 1 and b != 1:
    vivod = b
    x = 1
elif b == 1 and a != 1:
    vivod = a
    x = 1


while i > -1:
    if x == 1:
        print(vivod)
        break
    
    if bolshoe != menshee:
        bolshoe = bolshoe - menshee
        vivod += 1
        i += 1
    else:
        i += 1

    if bolshoe < menshee:
        bolshoe, menshee = menshee, bolshoe

    if bolshoe == menshee:
        print(vivod)
        break","def test(n, k):
    sumi = n 
    i = 1
    while n >= k ** i:
        sumi += n // k ** i
        i += 1
    return sumi

def minimum_v(n, k):
    left, right = 1, n
    while left < right:
        mid = (left + right) // 2
        if test(mid, k) >= n:
            right = mid
        else:
            left = mid + 1
    return left

n, k = map(int, input().split())
print(minimum_v(n, k))"
610,A,Pasha and Stick,PROGRAMMING,"['combinatorics', 'math']","Pasha has a wooden stick of some positive integer length *n*. He wants to perform exactly three cuts to get four parts of the stick. Each part must have some positive integer length and the sum of these lengths will obviously be *n*. 

Pasha likes rectangles but hates squares, so he wonders, how many ways are there to split a stick into four parts so that it's possible to form a rectangle using these parts, but is impossible to form a square.

Your task is to help Pasha and count the number of such ways. Two ways to cut the stick are considered distinct if there exists some integer *x*, such that the number of parts of length *x* in the first way differ from the number of parts of length *x* in the second way.",The first line of the input contains a positive integer *n* (1<=≤<=*n*<=≤<=2·109) — the length of Pasha's stick.,"The output should contain a single integer — the number of ways to split Pasha's stick into four parts of positive integer length so that it's possible to make a rectangle by connecting the ends of these parts, but is impossible to form a square.","['6\n', '20\n']","['1\n', '4\n']","There is only one way to divide the stick in the first sample {1, 1, 2, 2}.

Four ways to divide the stick in the second sample are {1, 1, 9, 9}, {2, 2, 8, 8}, {3, 3, 7, 7} and {4, 4, 6, 6}. Note that {5, 5, 5, 5} doesn't work.",OK,"n = int(input())

if n % 2 != 0 or n < 6:
    print(0)
else:
    k = n // 2
    if n % 4 == 0:
        print(k//2-1)
    else:
        print(k//2)","def is_same(l1,l2):
    if(len(l1)==len(l2)):
        for i in range(0,len(l1)):
            if(l1[i]!=l2[i]):
                if(l1[i]>l2[i]):
                    return 'first'
                else:
                    return 'second'
    return 'none'

def wrestling_winner(n, techniques):
    first_points = []
    second_points = []
    
    first_score = 0
    second_score = 0
    
    for technique in techniques:
        if technique > 0:
            first_points.append(technique)
            first_score += technique
        else:
            second_points.append(-technique)
            second_score += -technique
            
    # Compare total scores first
    if first_score > second_score:
        return ""first""
    elif second_score > first_score:
        return ""second""
    else:
        # If scores are equal, check sequences
        result = is_same(first_points, second_points)
        if result != 'none':
            return result
        
        # If still equal, check last technique
        if techniques[-1] > 0:
            return ""first""
        else:
            return ""second""

# Example Usage:
n = int(input())
techniques = [int(input()) for _ in range(n)]
print(wrestling_winner(n, techniques))"
492,B,Vanya and Lanterns,PROGRAMMING,"['binary search', 'implementation', 'math', 'sortings']","Vanya walks late at night along a straight street of length *l*, lit by *n* lanterns. Consider the coordinate system with the beginning of the street corresponding to the point 0, and its end corresponding to the point *l*. Then the *i*-th lantern is at the point *a**i*. The lantern lights all points of the street that are at the distance of at most *d* from it, where *d* is some positive number, common for all lanterns. 

Vanya wonders: what is the minimum light radius *d* should the lanterns have to light the whole street?","The first line contains two integers *n*, *l* (1<=≤<=*n*<=≤<=1000, 1<=≤<=*l*<=≤<=109) — the number of lanterns and the length of the street respectively. 

The next line contains *n* integers *a**i* (0<=≤<=*a**i*<=≤<=*l*). Multiple lanterns can be located at the same point. The lanterns may be located at the ends of the street.","Print the minimum light radius *d*, needed to light the whole street. The answer will be considered correct if its absolute or relative error doesn't exceed 10<=-<=9.","['7 15\n15 5 3 7 9 14 0\n', '2 5\n2 5\n']","['2.5000000000\n', '2.0000000000\n']","Consider the second sample. At *d* = 2 the first lantern will light the segment [0, 4] of the street, and the second lantern will light segment [3, 5]. Thus, the whole street will be lit.",WRONG_ANSWER,"line1 = input().split()
line2 = input().split()
n = int(line1[0])
l = int(line1[1])

lanternList = []
for item in line2:
    lanternList.append(int(item))

lanternList.sort()
result = []

if lanternList[0] != 0:
    result.append(lanternList[0]*1.000000000)

for i in range(n-1):
    result.append(lanternList[i+1]-lanternList[i]*1.000000000)


if lanternList[n-1] != l:
    result.append(l-lanternList[n-1]*1.000000000)
final = 000000000
for i in range(1 , len(result)-1):
    if result[i]/2 >final:
        final = result[i]/2 /2
if result[0]>final:
    final = result[0]
elif result[len(result)-1]> final:
    final = result[len(result)-1]

print(result)
print(f""{final:.9f}"")","class Node:
    def __init__(self, low, high):
        self.low = low
        self.high = high
        self.max = high
        self.left = None
        self.right = None

def find_platforms(n, d, m, l):
    platforms = []
    
    # Create platforms based on the provided formula
    for k in range(1, n + 1):
        low = (k - 1) * m
        high = (k - 1) * m + l
        platforms.append(Node(low, high))
    
    position = 0

    # Keep jumping until Bob falls
    while True:
        position += d
        on_platform = False
        
        for platform in platforms:
            # Check if Bob is on the platform or its edge
            if platform.low <= position <= platform.high or position == platform.low or position == platform.high:
                on_platform = True
                break
        
        # If Bob is not on any platform, he will fall
        if not on_platform:
            return position

# Example usage with input
n, d, m, l = map(int, input().split())
result = find_platforms(n, d, m, l)
print(result)"
405,A,Gravity Flip,PROGRAMMING,"['greedy', 'implementation', 'sortings']","Little Chris is bored during his physics lessons (too easy), so he has built a toy box to keep himself occupied. The box is special, since it has the ability to change gravity.

There are *n* columns of toy cubes in the box arranged in a line. The *i*-th column contains *a**i* cubes. At first, the gravity in the box is pulling the cubes downwards. When Chris switches the gravity, it begins to pull all the cubes to the right side of the box. The figure shows the initial and final configurations of the cubes in the box: the cubes that have changed their position are highlighted with orange.

Given the initial configuration of the toy cubes in the box, find the amounts of cubes in each of the *n* columns after the gravity switch!","The first line of input contains an integer *n* (1<=≤<=*n*<=≤<=100), the number of the columns in the box. The next line contains *n* space-separated integer numbers. The *i*-th number *a**i* (1<=≤<=*a**i*<=≤<=100) denotes the number of cubes in the *i*-th column.","Output *n* integer numbers separated by spaces, where the *i*-th number is the amount of cubes in the *i*-th column after the gravity switch.","['4\n3 2 1 2\n', '3\n2 3 8\n']","['1 2 2 3 \n', '2 3 8 \n']","The first example case is shown on the figure. The top cube of the first column falls to the top of the last column; the top cube of the second column falls to the top of the third column; the middle cube of the first column falls to the top of the second column.

In the second example case the gravity switch does not change the heights of the columns.",WRONG_ANSWER,"columnsInBox = int(input())
numOfCubes = input().split()

newList = []

for nums in numOfCubes:
    newList.append(int(nums))

newList.sort()

print(newList)","def get2(n):
    res = n * (n + 1) * (2 * n + 1) // 6 + n * (n + 1) // 2
    res //= 2
    return res

def max_bananas(m, b):
    max_bananas = 0
    
    # Iterate over possible values of x (horizontal coordinate)
    for x in range(m + 1):
        # Calculate the maximum possible y based on the line equation
        y = min(b, (b * x) // m)
        
        # Calculate the total number of bananas for this rectangle
        bananas = get2(x) * (y + 1)
        max_bananas = max(max_bananas, bananas)
    
    return max_bananas

# Read input values
m, b = map(int, input().split())
print(max_bananas(m, b))"
507,A,Amr and Music,PROGRAMMING,"['greedy', 'implementation', 'sortings']","Amr is a young coder who likes music a lot. He always wanted to learn how to play music but he was busy coding so he got an idea.

Amr has *n* instruments, it takes *a**i* days to learn *i*-th instrument. Being busy, Amr dedicated *k* days to learn how to play the maximum possible number of instruments.

Amr asked for your help to distribute his free days between instruments so that he can achieve his goal.","The first line contains two numbers *n*, *k* (1<=≤<=*n*<=≤<=100, 0<=≤<=*k*<=≤<=10<=000), the number of instruments and number of days respectively.

The second line contains *n* integers *a**i* (1<=≤<=*a**i*<=≤<=100), representing number of days required to learn the *i*-th instrument.","In the first line output one integer *m* representing the maximum number of instruments Amr can learn.

In the second line output *m* space-separated integers: the indices of instruments to be learnt. You may output indices in any order.

if there are multiple optimal solutions output any. It is not necessary to use all days for studying.","['4 10\n4 3 1 2\n', '5 6\n4 3 1 1 2\n', '1 3\n4\n']","['4\n1 2 3 4', '3\n1 3 4', '0\n']","In the first test Amr can learn all 4 instruments.

In the second test other possible solutions are: {2, 3, 5} or {3, 4, 5}.

In the third test Amr doesn't have enough time to learn the only presented instrument.",WRONG_ANSWER,"n,k = map(int,input().split())
a = sorted(list(map(int,input().split())))
c=0
L = []
for i in a:
    t = sum(L) + i
    if t <= k:
        L.append(i)
        c+= 1
    else:
        break
print(c)
if L != []:
    print(*L)
","# Store the lengths in a set for quick lookup
    length_set = set(list1)
    
    # Iterate through all pairs of worm lengths
    for i in range(n):
        for j in range(i + 1, n):
            # Calculate the length that would satisfy the condition
            required_length = list1[i] + list1[j]
            # Check if this length exists in the set
            if required_length in length_set:
                # Find the index of the required length
                k = list1.index(required_length)
                # Ensure indexes are distinct
                if k != i and k != j:
                    # Return the 1-based indices
                    return (i + 1, j + 1, k + 1)
    
    return -1

result = foo(list1)
if result == -1:
    print(-1)
else:
    print(*result)"
41,A,Translation,PROGRAMMING,"['implementation', 'strings']","The translation from the Berland language into the Birland language is not an easy task. Those languages are very similar: a berlandish word differs from a birlandish word with the same meaning a little: it is spelled (and pronounced) reversely. For example, a Berlandish word code corresponds to a Birlandish word edoc. However, it's easy to make a mistake during the «translation». Vasya translated word *s* from Berlandish into Birlandish as *t*. Help him: find out if he translated the word correctly.","The first line contains word *s*, the second line contains word *t*. The words consist of lowercase Latin letters. The input data do not consist unnecessary spaces. The words are not empty and their lengths do not exceed 100 symbols.","If the word *t* is a word *s*, written reversely, print YES, otherwise print NO.","['code\nedoc\n', 'abb\naba\n', 'code\ncode\n']","['YES\n', 'NO\n', 'NO\n']",none,OK,"lines = []
for i in range(2):
	lines.append(input())
#print(lines)

l = len(lines[0])
comp = """"
for i in range(l):
	comp = lines[0][i] + comp

if comp == lines[1]:
	print(""YES"")
else:
	print(""NO"")
 	 				   	 	 		   		   				  	","import math

def main():
    n = int(input())
    tasks = list(map(int, input().split()))

    total_tasks = sum(tasks)
    average_tasks = total_tasks // n
    remainder = total_tasks % n

    # Calculate the number of tasks needed to be adjusted to balance the load
    moves_needed = 0
    
    # Count the excess tasks above the average
    for task_count in tasks:
        if task_count > average_tasks:
            moves_needed += task_count - average_tasks

    # The number of excess tasks must account for the remainder
    # We can move at most 'moves_needed' but we shouldn't need more moves than the total remainder
    print(max(moves_needed - remainder, 0))

if __name__ == ""__main__"":
    main()"
381,A,Sereja and Dima,PROGRAMMING,"['greedy', 'implementation', 'two pointers']","Sereja and Dima play a game. The rules of the game are very simple. The players have *n* cards in a row. Each card contains a number, all numbers on the cards are distinct. The players take turns, Sereja moves first. During his turn a player can take one card: either the leftmost card in a row, or the rightmost one. The game ends when there is no more cards. The player who has the maximum sum of numbers on his cards by the end of the game, wins.

Sereja and Dima are being greedy. Each of them chooses the card with the larger number during his move.

Inna is a friend of Sereja and Dima. She knows which strategy the guys are using, so she wants to determine the final score, given the initial state of the game. Help her.",The first line contains integer *n* (1<=≤<=*n*<=≤<=1000) — the number of cards on the table. The second line contains space-separated numbers on the cards from left to right. The numbers on the cards are distinct integers from 1 to 1000.,"On a single line, print two integers. The first number is the number of Sereja's points at the end of the game, the second number is the number of Dima's points at the end of the game.","['4\n4 1 2 10\n', '7\n1 2 3 4 5 6 7\n']","['12 5\n', '16 12\n']","In the first sample Sereja will take cards with numbers 10 and 2, so Sereja's sum is 12. Dima will take cards with numbers 4 and 1, so Dima's sum is 5.",OK,"n=int(input())
l=[]
Sereja , Dima, i = 0, 0, 0
t=map(int,input().split())
l+=t
y=len(l)
a=True
while(y!=0):
    if(l[0]>=l[y-1]):
        x=l[0]
        l.pop(0)
    else:
        x=l[y-1]
        l.pop(y-1)
    if(a==True):
        Sereja+=x
        a=False
    else:
        Dima+=x
        a=True
    y-=1
print(Sereja,Dima)







","import sys
input = sys.stdin.readline

# Function to perform cyclic shift by k on the substring s[l-1:r]
def cyclic_shift(s, l, r, k):
    # Length of the substring
    length = r - l + 1
    # Effective shifts (k mod length)
    k = k % length
    # If k is 0, no need to shift
    if k == 0:
        return s
    # Perform the cyclic shift
    return s[:l-1] + s[l-1:r][-k:] + s[l-1:r][:-k] + s[r:]

# Read the initial string
s = input().strip()
# Read the number of queries
m = int(input().strip())

# Process each query
for _ in range(m):
    l, r, k = map(int, input().strip().split())
    s = cyclic_shift(s, l, r, k)

# Output the final string after all queries
print(s)"
78,B,Easter Eggs,PROGRAMMING,"['constructive algorithms', 'implementation']","The Easter Rabbit laid *n* eggs in a circle and is about to paint them. 

Each egg should be painted one color out of 7: red, orange, yellow, green, blue, indigo or violet. Also, the following conditions should be satisfied:
 -  Each of the seven colors should be used to paint at least one egg. -  Any four eggs lying sequentially should be painted different colors. 
Help the Easter Rabbit paint the eggs in the required manner. We know that it is always possible.",The only line contains an integer *n* — the amount of eggs (7<=≤<=*n*<=≤<=100).,"Print one line consisting of *n* characters. The *i*-th character should describe the color of the *i*-th egg in the order they lie in the circle. The colors should be represented as follows: ""R"" stands for red, ""O"" stands for orange, ""Y"" stands for yellow, ""G"" stands for green, ""B"" stands for blue, ""I"" stands for indigo, ""V"" stands for violet.

If there are several answers, print any of them.","['8\n', '13\n']","['ROYGRBIV\n', 'ROYGBIVGBIVYG\n']",The way the eggs will be painted in the first sample is shown on the picture:,RUNTIME_ERROR,"n=int(input())
s=""ROYGBIV""
v=n%7
u=n//7
r=n-u*7
s1=s*u
#print(s1)
if(v>4):
    s2=s[0:0+r]
    
elif(v<4):
    s2=s[3:3+r]
#print(s2)   
print(s1+s2)    
","n, k = [int(n) for n in input().split()]

# Create a list of the first k lowercase letters
letters = [chr(i) for i in range(ord('a'), ord('a') + k)]

password = []

# Construct the password by repeating the letters until the desired length is reached
for i in range(n):
    password.append(letters[i % k])

# Convert the list to a string and print the result
print(''.join(password))"
582,A,GCD Table,PROGRAMMING,"['constructive algorithms', 'greedy', 'number theory']","The GCD table *G* of size *n*<=×<=*n* for an array of positive integers *a* of length *n* is defined by formula 

Let us remind you that the greatest common divisor (GCD) of two positive integers *x* and *y* is the greatest integer that is divisor of both *x* and *y*, it is denoted as . For example, for array *a*<==<={4,<=3,<=6,<=2} of length 4 the GCD table will look as follows:

Given all the numbers of the GCD table *G*, restore array *a*.","The first line contains number *n* (1<=≤<=*n*<=≤<=500) — the length of array *a*. The second line contains *n*2 space-separated numbers — the elements of the GCD table of *G* for array *a*. 

All the numbers in the table are positive integers, not exceeding 109. Note that the elements are given in an arbitrary order. It is guaranteed that the set of the input data corresponds to some array *a*.","In the single line print *n* positive integers — the elements of array *a*. If there are multiple possible solutions, you are allowed to print any of them.","['4\n2 1 2 3 4 3 2 6 1 1 2 2 1 2 3 2\n', '1\n42\n', '2\n1 1 1 1\n']","['4 3 6 2', '42 ', '1 1 ']",none,TIME_LIMIT_EXCEEDED,"def gcd(a,b):
    if b==0: return a 
    return gcd(b,a%b)
n=int(input())
from collections import Counter 
l=[int(i) for i in input().split()]
g=Counter(l)
ans=[]

while g:
    m=max(g)
    g[m]-=1 
    for i in ans:
        g[gcd(m,i)]-=2 
    ans+=[m]
  #  g+=Counter()
print(*ans)
    ","xC, yC, xT, yT = map(int, input().split())
xP, yP = map(int, input().split())
dX = xT - xC
dY = yT - yC

# Check if the distance to treasure can be covered using potion moves
if (dX % xP == 0) and (dY % yP == 0):
    # Check if both moves lead to the same quotient
    if (dX // xP) % 2 == (dY // yP) % 2:
        print(""YES"")
    else:
        print(""NO"")
else:
    print(""NO"")"
903,C,Boxes Packing,PROGRAMMING,['greedy'],"Mishka has got *n* empty boxes. For every *i* (1<=≤<=*i*<=≤<=*n*), *i*-th box is a cube with side length *a**i*.

Mishka can put a box *i* into another box *j* if the following conditions are met:
 -  *i*-th box is not put into another box; -  *j*-th box doesn't contain any other boxes; -  box *i* is smaller than box *j* (*a**i*<=&lt;<=*a**j*). 
Mishka can put boxes into each other an arbitrary number of times. He wants to minimize the number of visible boxes. A box is called visible iff it is not put into some another box.

Help Mishka to determine the minimum possible number of visible boxes!","The first line contains one integer *n* (1<=≤<=*n*<=≤<=5000) — the number of boxes Mishka has got.

The second line contains *n* integers *a*1, *a*2, ..., *a**n* (1<=≤<=*a**i*<=≤<=109), where *a**i* is the side length of *i*-th box.",Print the minimum possible number of visible boxes.,"['3\n1 2 3\n', '4\n4 2 4 3\n']","['1\n', '2\n']","In the first example it is possible to put box 1 into box 2, and 2 into 3.

In the second example Mishka can put box 2 into box 3, and box 4 into box 1.",WRONG_ANSWER,"n = int(input())
arr = list(map(int,input().split()))
arr.sort(reverse=True)

count =0 

for i in range(n):
    if arr[i]!=-1:  
        selected = arr[i]
        count+=1
    else:   
        continue
    for i in range(i,n):
        if(arr[i]<selected):
            selected = arr[i]
            arr[i]=-1
print(count)","mod=int(1e9+7)
#qm=lambda x:x%mod if x%mod>=0 else x%mod+mod
class Mx:
    def __init__(self,a11,a12,a21,a22):
        self.a11=a11%mod;self.a12=a12%mod
        self.a21=a21%mod;self.a22=a22%mod
        
    def __mul__(self, other):
        b11 = self.a11 * other.a11 + self.a12 * other.a21
        b12 = self.a11 * other.a12 + self.a12 * other.a22
        b21 = self.a21 * other.a11 + self.a22 * other.a21
        b22 = self.a21 * other.a12 + self.a22 * other.a22
        return Mx(b11 % mod, b12 % mod, b21 % mod, b22 % mod)

# Function to compute the nth term of the sequence
def matrix_exponentiation(n):
    if n == 1:
        return x % mod
    elif n == 2:
        return y % mod
    
    # Transition matrix
    transition_matrix = Mx(0, 1, 1, 1)
    
    # Exponentiate the matrix to the (n-2)th power
    result_matrix = matrix_power(transition_matrix, n - 2)
    
    # Calculate fn based on the result matrix
    fn = (result_matrix.a11 * y + result_matrix.a12 * x) % mod
    return fn

# Function to perform matrix power using exponentiation by squaring
def matrix_power(matrix, exponent):
    result = Mx(1, 0, 0, 1)  # Identity matrix
    while exponent:
        if exponent % 2 == 1:
            result = result * matrix
        matrix = matrix * matrix
        exponent //= 2
    return result

# Read input values
x, y = map(int, input().split())
n = int(input())

# Output the nth term of the sequence modulo 1000000007
print(matrix_exponentiation(n))"
875,A,Classroom Watch,PROGRAMMING,"['brute force', 'math']","Eighth-grader Vova is on duty today in the class. After classes, he went into the office to wash the board, and found on it the number *n*. He asked what is this number and the teacher of mathematics Inna Petrovna answered Vova that *n* is the answer to the arithmetic task for first-graders. In the textbook, a certain positive integer *x* was given. The task was to add *x* to the sum of the digits of the number *x* written in decimal numeral system.

Since the number *n* on the board was small, Vova quickly guessed which *x* could be in the textbook. Now he wants to get a program which will search for arbitrary values of the number *n* for all suitable values of *x* or determine that such *x* does not exist. Write such a program for Vova.",The first line contains integer *n* (1<=≤<=*n*<=≤<=109).,"In the first line print one integer *k* — number of different values of *x* satisfying the condition. 

In next *k* lines print these values in ascending order.","['21\n', '20\n']","['1\n15\n', '0\n']","In the first test case *x* = 15 there is only one variant: 15 + 1 + 5 = 21.

In the second test case there are no such *x*.",TIME_LIMIT_EXCEEDED,"from sys import stdin, stdout
n = int(stdin.readline())
ans = []
for x in range(n):
  running_total = x
  temp = x
  while temp != 0:
    running_total += (temp%10)
    temp = temp // 10
  if running_total == n:
    ans.append(x)

if len(ans) == 0:
  stdout.write('0')
else:
  end_str = str(len(ans))+'\n'
  for i in ans:
    end_str+=str(i)+' '
  stdout.write(end_str)","from collections import Counter

def parse(n):
    fs = Counter()
    scores = {}
    for _ in range(n):
        entry = input().split()
        name, score = entry[0], int(entry[1])
        fs[name] += score
        if name not in scores:
            scores[name] = 0
        scores[name] += score
    return fs, scores

def find_winner(fs, scores):
    # Find the max score among players
    max_score = max(fs.values())
    
    # Find all players with the max score
    candidates = [name for name, score in fs.items() if score == max_score]
    
    # If there's only one candidate, that player is the winner
    if len(candidates) == 1:
        return candidates[0]
    
    # If there are multiple candidates, check who reached max_score first
    cumulative_scores = {}
    for name in scores:
        cumulative_scores[name] = 0
    
    for entry in scores.keys():
        name = entry
        cumulative_scores[name] += scores[name]
        if cumulative_scores[name] >= max_score and name in candidates:
            return name

n = int(input())
fs, scores = parse(n)
winner = find_winner(fs, scores)
print(winner)"
58,A,Chat room,PROGRAMMING,"['greedy', 'strings']","Vasya has recently learned to type and log on to the Internet. He immediately entered a chat room and decided to say hello to everybody. Vasya typed the word *s*. It is considered that Vasya managed to say hello if several letters can be deleted from the typed word so that it resulted in the word ""hello"". For example, if Vasya types the word ""ahhellllloou"", it will be considered that he said hello, and if he types ""hlelo"", it will be considered that Vasya got misunderstood and he didn't manage to say hello. Determine whether Vasya managed to say hello by the given word *s*.","The first and only line contains the word *s*, which Vasya typed. This word consisits of small Latin letters, its length is no less that 1 and no more than 100 letters.","If Vasya managed to say hello, print ""YES"", otherwise print ""NO"".","['ahhellllloou\n', 'hlelo\n']","['YES\n', 'NO\n']",none,OK,"h = 'hello'
s = input()
i = 0
for c in s:
    if c == h[i]:
        i += 1
        if i == len(h):
            break
print('YES' if i == len(h) else 'NO')
    ","def checkEquilibrium(n, matrix):
    forces = [0, 0, 0]  # Initialize the sum of forces for x, y, z components
    i = 0  # Initialize the index for the forces

    while i < n:
        forces[0] += matrix[i][0]  # Sum up the x-components
        forces[1] += matrix[i][1]  # Sum up the y-components
        forces[2] += matrix[i][2]  # Sum up the z-components
        i += 1  # Move to the next force

    # Check if all components are equal to 0 for equilibrium
    if forces[0] == 0 and forces[1] == 0 and forces[2] == 0:
        return ""YES""  # Body is in equilibrium
    else:
        return ""NO""   # Body is not in equilibrium

# Input reading
n = int(input())  # Read the number of forces
matrix = [list(map(int, input().split())) for _ in range(n)]  # Read the forces
print(checkEquilibrium(n, matrix))  # Print the result"
50,A,Domino piling,PROGRAMMING,"['greedy', 'math']","You are given a rectangular board of *M*<=×<=*N* squares. Also you are given an unlimited number of standard domino pieces of 2<=×<=1 squares. You are allowed to rotate the pieces. You are asked to place as many dominoes as possible on the board so as to meet the following conditions:

1. Each domino completely covers two squares.

2. No two dominoes overlap.

3. Each domino lies entirely inside the board. It is allowed to touch the edges of the board.

Find the maximum number of dominoes, which can be placed under these restrictions.",In a single line you are given two integers *M* and *N* — board sizes in squares (1<=≤<=*M*<=≤<=*N*<=≤<=16).,"Output one number — the maximal number of dominoes, which can be placed.","['2 4\n', '3 3\n']","['4\n', '4\n']",none,OK,"size = input("""")
sizz = size.split("" "")
space = int(sizz[0])*int(sizz[1])
print(int(space/2))","from collections import defaultdict, deque

nodes, edges = list(map(int, input().split()))

graph = defaultdict(list)
for edge in range(edges):
    a, b = map(int, input().split())
    graph[a].append(b)
    graph[b].append(a)

def bfs(start):
    visited = {start}
    queue = deque([(start, 0)])  # (node, distance)
    max_distance = 0
    
    while queue:
        current, dist = queue.popleft()
        max_distance = max(max_distance, dist)
        
        for neighbor in graph[current]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append((neighbor, dist + 1))
    
    return max_distance

# To find the maximum brain latency
max_lat = 0
for node in range(1, nodes + 1):
    max_lat = max(max_lat, bfs(node))

print(max_lat)"
611,A,New Year and Days,PROGRAMMING,['implementation'],"Today is Wednesday, the third day of the week. What's more interesting is that tomorrow is the last day of the year 2015.

Limak is a little polar bear. He enjoyed this year a lot. Now, he is so eager to the coming year 2016.

Limak wants to prove how responsible a bear he is. He is going to regularly save candies for the entire year 2016! He considers various saving plans. He can save one candy either on some fixed day of the week or on some fixed day of the month.

Limak chose one particular plan. He isn't sure how many candies he will save in the 2016 with his plan. Please, calculate it and tell him.","The only line of the input is in one of the following two formats: 
 -  ""*x* of week"" where *x* (1<=≤<=*x*<=≤<=7) denotes the day of the week. The 1-st day is Monday and the 7-th one is Sunday. -  ""*x* of month"" where *x* (1<=≤<=*x*<=≤<=31) denotes the day of the month.",Print one integer — the number of candies Limak will save in the year 2016.,"['4 of week\n', '30 of month\n']","['52\n', '11\n']","Polar bears use the Gregorian calendar. It is the most common calendar and you likely use it too. You can read about it on Wikipedia if you want to – [https://en.wikipedia.org/wiki/Gregorian_calendar](https://en.wikipedia.org/wiki/Gregorian_calendar). The week starts with Monday.

In the first sample Limak wants to save one candy on each Thursday (the 4-th day of the week). There are 52 Thursdays in the 2016. Thus, he will save 52 candies in total.

In the second sample Limak wants to save one candy on the 30-th day of each month. There is the 30-th day in exactly 11 months in the 2016 — all months but February. It means that Limak will save 11 candies in total.",WRONG_ANSWER,"help = list(input().split())
if help[2] == 'week':
    if int(help[0]) == 5 or int(help[0]) == 6 or int(help[0]) == 7:
        print(366 // 7 + 1)
    else:
        print(366 // 7)
else:
    if int(help[0]) <= 29:
        print(12)
    elif int(help[0]) == 30:
        print(11)
    else:
        print(7)","def main():
    input()  # Read the number of balls
    sizes = list(map(int, input().split()))  # Read the sizes of the balls

    # Iterate through the sizes to find a valid triplet
    for i in range(len(sizes) - 2):
        # Check if the current triplet sizes[i], sizes[i+1], sizes[i+2] are valid
        if sizes[i+2] - sizes[i] <= 2:  # Check the size difference condition
            print(""YES"")  # Found a valid triplet
            return
    
    print(""NO"")  # No valid triplet found

main()  # Call the main function"
219,A,k-String,PROGRAMMING,"['implementation', 'strings']","A string is called a *k*-string if it can be represented as *k* concatenated copies of some string. For example, the string ""aabaabaabaab"" is at the same time a 1-string, a 2-string and a 4-string, but it is not a 3-string, a 5-string, or a 6-string and so on. Obviously any string is a 1-string.

You are given a string *s*, consisting of lowercase English letters and a positive integer *k*. Your task is to reorder the letters in the string *s* in such a way that the resulting string is a *k*-string.","The first input line contains integer *k* (1<=≤<=*k*<=≤<=1000). The second line contains *s*, all characters in *s* are lowercase English letters. The string length *s* satisfies the inequality 1<=≤<=|*s*|<=≤<=1000, where |*s*| is the length of string *s*.","Rearrange the letters in string *s* in such a way that the result is a *k*-string. Print the result on a single output line. If there are multiple solutions, print any of them.

If the solution doesn't exist, print ""-1"" (without quotes).","['2\naazz\n', '3\nabcabcabz\n']","['azaz\n', '-1\n']",none,OK,"alphabet=[0]*27
# print(alphabet)
a=int(input())
c=input()
# print(a)
d=False
seta=set()
setalfabet=set()
for i in range(len(c)):
    b=int(ord(c[i])-ord('a'))
    alphabet[b]+=1
    setalfabet.add(c[i])
value=0
lista=[]
for i in range(27):
    if alphabet[i]%a!=0:
        d=True
        break
    if(alphabet[i]!=0):

        alphabet[i]=int(alphabet[i]/a)





# Convert the set to a string without commas and brackets
set_string =''.join(map(str,setalfabet))
# print(set_string)
setlist = list(seta)
# print(setlist)
if d :
    print(-1)



else:

    stringa=""""

    for i in setalfabet:
        for j in range(alphabet[int(ord(i)-ord('a'))]):
            stringa+=i

    mainstring=""""

    for i in range(a):
        mainstring+=stringa

    print(mainstring)

","from bisect import bisect_left, bisect_right
from collections import Counter, deque
from functools import lru_cache
from math import factorial, comb, sqrt, gcd, lcm, log2
from copy import deepcopy
import heapq

from sys import stdin, stdout

# Read input
n = int(stdin.readline().strip())
points = list(map(int, stdin.readline().strip().split()))

# Create a set to hold distinct points
points_set = set(points)
max_subset = []

# Check subsets based on the power of two distances
for point in points:
    current_subset = [point]
    for d in range(31):  # 2^30 is greater than 10^9
        distance = 1 << d  # 2^d
        # Check the two directions for the current point
        if point + distance in points_set:
            current_subset.append(point + distance)
        if point - distance in points_set:
            current_subset.append(point - distance)
    
    # Update the max_subset if current_subset is larger
    if len(current_subset) > len(max_subset):
        max_subset = current_subset

# Output the results
stdout.write(f""{len(max_subset)}\n"")
stdout.write("" "".join(map(str, max_subset)) + ""\n"")"
236,A,Boy or Girl,PROGRAMMING,"['brute force', 'implementation', 'strings']","Those days, many boys use beautiful girls' photos as avatars in forums. So it is pretty hard to tell the gender of a user at the first glance. Last year, our hero went to a forum and had a nice chat with a beauty (he thought so). After that they talked very often and eventually they became a couple in the network. 

But yesterday, he came to see ""her"" in the real world and found out ""she"" is actually a very strong man! Our hero is very sad and he is too tired to love again now. So he came up with a way to recognize users' genders by their user names.

This is his method: if the number of distinct characters in one's user name is odd, then he is a male, otherwise she is a female. You are given the string that denotes the user name, please help our hero to determine the gender of this user by his method.","The first line contains a non-empty string, that contains only lowercase English letters — the user name. This string contains at most 100 letters.","If it is a female by our hero's method, print ""CHAT WITH HER!"" (without the quotes), otherwise, print ""IGNORE HIM!"" (without the quotes).","['wjmzbmr\n', 'xiaodao\n', 'sevenkplus\n']","['CHAT WITH HER!\n', 'IGNORE HIM!\n', 'CHAT WITH HER!\n']","For the first example. There are 6 distinct characters in ""wjmzbmr"". These characters are: ""w"", ""j"", ""m"", ""z"", ""b"", ""r"". So wjmzbmr is a female and you should print ""CHAT WITH HER!"".",OK,"s=input()
a=[]
for i in s:
    if i not in a:
        a.append(i)
if len(a)%2==0:
    print(""CHAT WITH HER!"")
else:
    print(""IGNORE HIM!"")","#!/usr/bin/env python
""""""
This file is part of https://github.com/Cheran-Senthil/PyRival.

Copyright 2018 Cheran Senthilkumar all rights reserved,
Cheran Senthilkumar <[email protected]>
Permission to use, modify, and distribute this software is given under the
terms of the MIT License.
""""""

MOD = 998244353

def expected_difficulty(n, a):
    total_difficulty = 0
    multiplier = 1
    
    # Calculate the total difficulty using the given difficulties
    for i in range(n):
        total_difficulty = (total_difficulty + a[i] * multiplier) % MOD
        multiplier = (multiplier * 2) % MOD
    
    return total_difficulty

# Read input
n = int(input().strip())
a = list(map(int, input().strip().split()))

# Compute the expected difficulty multiplied by 2^(n-1)
result = expected_difficulty(n, a)
print(result)"
146,A,Lucky Ticket,PROGRAMMING,['implementation'],"Petya loves lucky numbers very much. Everybody knows that lucky numbers are positive integers whose decimal record contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.

Petya loves tickets very much. As we know, each ticket has a number that is a positive integer. Its length equals *n* (*n* is always even). Petya calls a ticket lucky if the ticket's number is a lucky number and the sum of digits in the first half (the sum of the first *n*<=/<=2 digits) equals the sum of digits in the second half (the sum of the last *n*<=/<=2 digits). Check if the given ticket is lucky.",The first line contains an even integer *n* (2<=≤<=*n*<=≤<=50) — the length of the ticket number that needs to be checked. The second line contains an integer whose length equals exactly *n* — the ticket number. The number may contain leading zeros.,"On the first line print ""YES"" if the given ticket number is lucky. Otherwise, print ""NO"" (without the quotes).","['2\n47\n', '4\n4738\n', '4\n4774\n']","['NO\n', 'NO\n', 'YES\n']","In the first sample the sum of digits in the first half does not equal the sum of digits in the second half (4 ≠ 7).

In the second sample the ticket number is not the lucky number.",RUNTIME_ERROR,"# cook your dish here
l = int(input())
n = int(input())
val = n
count = 0
a = []
while n>0:
    x = n%10
    if x==4 or x==7:
        a.append(x)
        n = n //10
    else:
        count = count + 1
        n = n//10
s = sum(a)
sa = 0

for i in range(l//2):
    sa = sa + a[i]

if sa==(s//2) and count==0:
    print(""YES"")
else:
    print(""NO"")","# n = number of camels
n = int(input())
# dictionary to store camel positions and their spit range
camels = {}

# read camel positions and spit distances
for _ in range(n):
    x, d = map(int, input().split())
    camels[x] = x + d  # calculate where the camel spits to

# check for reciprocal spits
for x in camels:
    spit_to = camels[x]
    # check if the spit target has a camel that spits back
    if spit_to in camels and camels[spit_to] == x:
        print(""YES"")
        break
else:
    print(""NO"")"
260,A,Adding Digits,PROGRAMMING,"['implementation', 'math']","Vasya has got two number: *a* and *b*. However, Vasya finds number *a* too short. So he decided to repeat the operation of lengthening number *a* *n* times.

One operation of lengthening a number means adding exactly one digit to the number (in the decimal notation) to the right provided that the resulting number is divisible by Vasya's number *b*. If it is impossible to obtain the number which is divisible by *b*, then the lengthening operation cannot be performed.

Your task is to help Vasya and print the number he can get after applying the lengthening operation to number *a* *n* times.","The first line contains three integers: *a*,<=*b*,<=*n* (1<=≤<=*a*,<=*b*,<=*n*<=≤<=105).","In a single line print the integer without leading zeros, which Vasya can get when he applies the lengthening operations to number *a* *n* times. If no such number exists, then print number -1. If there are multiple possible answers, print any of them.","['5 4 5\n', '12 11 1\n', '260 150 10\n']","['524848\n', '121\n', '-1\n']",none,TIME_LIMIT_EXCEEDED,"
def check(a, b):
    for i in range(10):
        if int(str(a) + str(i)) % b == 0:
            return int(str(a) + str(i))
    return -1


a, b, n = [int(x) for x in input().split()]


def q(a, b, n):
    for _ in range(n):
        z = check(a, b)
        if z != -1:
            a = z
        else:
            return -1
    return a


print(q(a, b, n))","#author: sushmanth

from sys import stdin
input = stdin.readline

inp = lambda : list(map(int,input().split()))

mod = (10 ** 9) + 7

n, k, d = inp()

# dp[i] will represent the number of ways to form sum i using the k-tree rules
dp = [0] * (n + 1)
dp[0] = 1  # There's one way to form the sum 0: using no edges

# Calculate the number of ways to form each sum from 1 to n
for i in range(1, n + 1):
    # We need to consider the last edge weight from 1 to d
    for j in range(1, min(k, i) + 1):
        if i - j >= 0:
            dp[i] = (dp[i] + dp[i - j]) % mod

# Return the number of ways to form the sum n
print(dp[n])"
353,B,Two Heaps,PROGRAMMING,"['combinatorics', 'constructive algorithms', 'greedy', 'implementation', 'math', 'sortings']","Valera has 2·*n* cubes, each cube contains an integer from 10 to 99. He arbitrarily chooses *n* cubes and puts them in the first heap. The remaining cubes form the second heap. 

Valera decided to play with cubes. During the game he takes a cube from the first heap and writes down the number it has. Then he takes a cube from the second heap and write out its two digits near two digits he had written (to the right of them). In the end he obtained a single fourdigit integer — the first two digits of it is written on the cube from the first heap, and the second two digits of it is written on the second cube from the second heap.

Valera knows arithmetic very well. So, he can easily count the number of distinct fourdigit numbers he can get in the game. The other question is: how to split cubes into two heaps so that this number (the number of distinct fourdigit integers Valera can get) will be as large as possible?","The first line contains integer *n* (1<=≤<=*n*<=≤<=100). The second line contains 2·*n* space-separated integers *a**i* (10<=≤<=*a**i*<=≤<=99), denoting the numbers on the cubes.","In the first line print a single number — the maximum possible number of distinct four-digit numbers Valera can obtain. In the second line print 2·*n* numbers *b**i* (1<=≤<=*b**i*<=≤<=2). The numbers mean: the *i*-th cube belongs to the *b**i*-th heap in your division.

If there are multiple optimal ways to split the cubes into the heaps, print any of them.","['1\n10 99\n', '2\n13 24 13 45\n']","['1\n2 1 \n', '4\n1 2 2 1 \n']","In the first test case Valera can put the first cube in the first heap, and second cube — in second heap. In this case he obtain number 1099. If he put the second cube in the first heap, and the first cube in the second heap, then he can obtain number 9910. In both cases the maximum number of distinct integers is equal to one.

In the second test case Valera can obtain numbers 1313, 1345, 2413, 2445. Note, that if he put the first and the third cubes in the first heap, he can obtain only two numbers 1324 and 1345.",OK,"from sys import stdin

n = int(stdin.readline())
a = [int(x) for x in stdin.readline().split()]
a = sorted([(a[x], x) for x in range(n*2)])

group = {}

for x,ind in a:
    if x in group:
        group[x].append(ind)
    else:
        group[x] = [ind]

g2 = []

for x in group:
    g2.append([len(group[x]), group[x]])

g2.sort()

left = 0
right = 0

board = [0 for x in range(n*2)]

ind = 0
for x,l in g2:
    if x == 1:
        ind += 1
        if left <= right:
            left += 1
            board[l[0]] = '1'
        else:
            right += 1
            board[l[0]] = '2'
    else:
        break

if right > left:
    turn = True
else:
    turn = False

for x,l in g2[ind:]:
    left += 1
    right += 1

    if x%2 == 1:
        last = l.pop()
        if turn:
            board[last] = '1'
        else:
            board[last] = '2'
        turn = not turn
    for n in l[::2]:
        board[n] = '1'
    for n in l[1::2]:
        board[n] = '2'
print(left*right)
print(' '.join(board))
        
","from typing import List
from collections import namedtuple
import sys


class Solution:
    def sereja_and_dima(self, nums: List):
        result = [0, 0]  # result[0] for Sereja's points, result[1] for Dima's points
        left, right = 0, len(nums) - 1  # pointers for the leftmost and rightmost cards
        turn = 0  # 0 for Sereja's turn, 1 for Dima's turn

        while left <= right:
            if nums[left] > nums[right]:  # Choose the larger card
                chosen_card = nums[left]
                left += 1
            else:
                chosen_card = nums[right]
                right -= 1
            
            result[turn] += chosen_card  # Add the chosen card's value to the current player's score
            turn = 1 - turn  # Switch turns

        return result  # Return the scores as a list


# Usage example
# sol = Solution()
# print(sol.sereja_and_dima([10, 4, 1, 2]))  # Example input"
7,A,Kalevitch and Chess,PROGRAMMING,"['brute force', 'constructive algorithms']","A famous Berland's painter Kalevitch likes to shock the public. One of his last obsessions is chess. For more than a thousand years people have been playing this old game on uninteresting, monotonous boards. Kalevitch decided to put an end to this tradition and to introduce a new attitude to chessboards.

As before, the chessboard is a square-checkered board with the squares arranged in a 8<=×<=8 grid, each square is painted black or white. Kalevitch suggests that chessboards should be painted in the following manner: there should be chosen a horizontal or a vertical line of 8 squares (i.e. a row or a column), and painted black. Initially the whole chessboard is white, and it can be painted in the above described way one or more times. It is allowed to paint a square many times, but after the first time it does not change its colour any more and remains black. Kalevitch paints chessboards neatly, and it is impossible to judge by an individual square if it was painted with a vertical or a horizontal stroke.

Kalevitch hopes that such chessboards will gain popularity, and he will be commissioned to paint chessboards, which will help him ensure a comfortable old age. The clients will inform him what chessboard they want to have, and the painter will paint a white chessboard meeting the client's requirements.

It goes without saying that in such business one should economize on everything — for each commission he wants to know the minimum amount of strokes that he has to paint to fulfill the client's needs. You are asked to help Kalevitch with this task.","The input file contains 8 lines, each of the lines contains 8 characters. The given matrix describes the client's requirements, W character stands for a white square, and B character — for a square painted black.

It is guaranteed that client's requirments can be fulfilled with a sequence of allowed strokes (vertical/column or horizontal/row).",Output the only number — the minimum amount of rows and columns that Kalevitch has to paint on the white chessboard to meet the client's requirements.,"['WWWBWWBW\nBBBBBBBB\nWWWBWWBW\nWWWBWWBW\nWWWBWWBW\nWWWBWWBW\nWWWBWWBW\nWWWBWWBW\n', 'WWWWWWWW\nBBBBBBBB\nWWWWWWWW\nWWWWWWWW\nWWWWWWWW\nWWWWWWWW\nWWWWWWWW\nWWWWWWWW\n']","['3\n', '1\n']",none,OK,"#****************************************

#** Solution by BAZOOKA **

#** Sponsored by RED BULL**

#** Team Galaxy **

#** I love ❤Kateryna Gret❤ **

#****************************************/
t = [input().count('B') for i in range(8)]
print(t.count(8) + min(t)%8)
#****************************************

#** Solution by BAZOOKA **

#** Sponsored by RED BULL**

#** Team Galaxy **

#** I love ❤Kateryna Gret❤ **

#****************************************/

    ","def g(w, m, x):
    return max(0.3 * x, (1 - m / 250) * x - 50 * w)

def compute_final_score():
    # Read input for the last submission times
    m = list(map(int, input().strip().split()))
    # Read input for the number of wrong submissions
    w = list(map(int, input().strip().split()))
    # Read input for successful and unsuccessful hacks
    hs, hu = map(int, input().strip().split())
    
    # Problem point values
    points = [500, 1000, 1500, 2000, 2500]
    
    total_score = 0
    
    # Calculate scores for each problem
    for i in range(5):
        total_score += g(w[i], m[i], points[i])
    
    # Add points for successful hacks and subtract for unsuccessful hacks
    total_score += hs * 100
    total_score -= hu * 50
    
    # Print the final score
    print(int(total_score))

# Call the function to compute and print the final score
compute_final_score()"
771,A,Bear and Friendship Condition,PROGRAMMING,"['dfs and similar', 'dsu', 'graphs']","Bear Limak examines a social network. Its main functionality is that two members can become friends (then they can talk with each other and share funny pictures).

There are *n* members, numbered 1 through *n*. *m* pairs of members are friends. Of course, a member can't be a friend with themselves.

Let A-B denote that members A and B are friends. Limak thinks that a network is reasonable if and only if the following condition is satisfied: For every three distinct members (X, Y, Z), if X-Y and Y-Z then also X-Z.

For example: if Alan and Bob are friends, and Bob and Ciri are friends, then Alan and Ciri should be friends as well.

Can you help Limak and check if the network is reasonable? Print ""YES"" or ""NO"" accordingly, without the quotes.","The first line of the input contain two integers *n* and *m* (3<=≤<=*n*<=≤<=150<=000, ) — the number of members and the number of pairs of members that are friends.

The *i*-th of the next *m* lines contains two distinct integers *a**i* and *b**i* (1<=≤<=*a**i*,<=*b**i*<=≤<=*n*,<=*a**i*<=≠<=*b**i*). Members *a**i* and *b**i* are friends with each other. No pair of members will appear more than once in the input.","If the given network is reasonable, print ""YES"" in a single line (without the quotes). Otherwise, print ""NO"" in a single line (without the quotes).","['4 3\n1 3\n3 4\n1 4\n', '4 4\n3 1\n2 3\n3 4\n1 2\n', '10 4\n4 3\n5 10\n8 9\n1 2\n', '3 2\n1 2\n2 3\n']","['YES\n', 'NO\n', 'YES\n', 'NO\n']","The drawings below show the situation in the first sample (on the left) and in the second sample (on the right). Each edge represents two members that are friends. The answer is ""NO"" in the second sample because members (2, 3) are friends and members (3, 4) are friends, while members (2, 4) are not.",TIME_LIMIT_EXCEEDED,"from collections import defaultdict

class UnionFind():
    def __init__(self, n):
        self.n = n
        self.parents = [-1] * n

    def find(self, x):
        if self.parents[x] < 0:
            return x
        else:
            self.parents[x] = self.find(self.parents[x])
            return self.parents[x]

    def union(self, x, y):
        x = self.find(x)
        y = self.find(y)

        if x == y:
            return

        if self.parents[x] > self.parents[y]:
            x, y = y, x

        self.parents[x] += self.parents[y]
        self.parents[y] = x

    def size(self, x):
        return -self.parents[self.find(x)]

    def same(self, x, y):
        return self.find(x) == self.find(y)

    def members(self, x):
        root = self.find(x)
        return [i for i in range(self.n) if self.find(i) == root]

    def roots(self):
        return [i for i, x in enumerate(self.parents) if x < 0]

    def group_count(self):
        return len(self.roots())

    def all_group_members(self):
        group_members = defaultdict(list)
        for member in range(self.n):
            group_members[self.find(member)].append(member)
        return group_members
n,m=map(int,input().split())
g=[[] for i in range(n)]
uf=UnionFind(n)
for _ in range(m):
  u,v=map(int,input().split())
  g[u-1].append(v-1)
  g[v-1].append(u-1)
  uf.union(u-1,v-1)
for r in uf.roots():
  s=uf.size(r)
  for i in uf.members(r):
    if len(g[i])!=s-1:
      print(""NO"")
      exit()
print(""YES"")","n,m=map(int,input().split())
a=list(map(int,input().split()))

def control(l):
    # Create a set to hold distinct elements
    distinct_set = set()
    
    # Iterate from l to n to count distinct elements
    for i in range(l-1, n):
        distinct_set.add(a[i])
    
    # Return the count of distinct elements
    return len(distinct_set)

# Read the indices and compute results
results = []
for _ in range(m):
    l = int(input())
    results.append(control(l))

# Print the results
for result in results:
    print(result)"
535,C,Tavas and Karafs,PROGRAMMING,"['binary search', 'greedy', 'math']","Karafs is some kind of vegetable in shape of an 1<=×<=*h* rectangle. Tavaspolis people love Karafs and they use Karafs in almost any kind of food. Tavas, himself, is crazy about Karafs.

Each Karafs has a positive integer height. Tavas has an infinite 1-based sequence of Karafses. The height of the *i*-th Karafs is *s**i*<==<=*A*<=+<=(*i*<=-<=1)<=×<=*B*.

For a given *m*, let's define an *m*-bite operation as decreasing the height of at most *m* distinct not eaten Karafses by 1. Karafs is considered as eaten when its height becomes zero.

Now SaDDas asks you *n* queries. In each query he gives you numbers *l*, *t* and *m* and you should find the largest number *r* such that *l*<=≤<=*r* and sequence *s**l*,<=*s**l*<=+<=1,<=...,<=*s**r* can be eaten by performing *m*-bite no more than *t* times or print -1 if there is no such number *r*.","The first line of input contains three integers *A*, *B* and *n* (1<=≤<=*A*,<=*B*<=≤<=106, 1<=≤<=*n*<=≤<=105).

Next *n* lines contain information about queries. *i*-th line contains integers *l*,<=*t*,<=*m* (1<=≤<=*l*,<=*t*,<=*m*<=≤<=106) for *i*-th query.","For each query, print its answer in a single line.","['2 1 4\n1 5 3\n3 3 10\n7 10 2\n6 4 8\n', '1 5 2\n1 5 10\n2 7 4\n']","['4\n-1\n8\n-1\n', '1\n2\n']",none,WRONG_ANSWER,"print(""_RANDOM_GUESS_1689415386.8781166"")# 1689415386.8781364","def thing(s, q1, q2):
    section = s[q1-1:q2]
    c = 0
    
    # Count the number of '.' in the section
    for char in section:
        if char == '.':
            c += 1
            
    return c

# Read input
s = input().strip()  # Read the string input
m = int(input().strip())  # Read the number of queries

# Process each query and store the results
results = []
for _ in range(m):
    l, r = map(int, input().strip().split())
    result = thing(s, l, r)
    results.append(result)

# Print all results for the queries
print('\n'.join(map(str, results)))"
119,A,Epic Game,PROGRAMMING,['implementation'],"Simon and Antisimon play a game. Initially each player receives one fixed positive integer that doesn't change throughout the game. Simon receives number *a* and Antisimon receives number *b*. They also have a heap of *n* stones. The players take turns to make a move and Simon starts. During a move a player should take from the heap the number of stones equal to the greatest common divisor of the fixed number he has received and the number of stones left in the heap. A player loses when he cannot take the required number of stones (i. e. the heap has strictly less stones left than one needs to take). 

Your task is to determine by the given *a*, *b* and *n* who wins the game.","The only string contains space-separated integers *a*, *b* and *n* (1<=≤<=*a*,<=*b*,<=*n*<=≤<=100) — the fixed numbers Simon and Antisimon have received correspondingly and the initial number of stones in the pile.","If Simon wins, print ""0"" (without the quotes), otherwise print ""1"" (without the quotes).","['3 5 9\n', '1 1 100\n']","['0', '1']","The greatest common divisor of two non-negative integers *a* and *b* is such maximum positive integer *k*, that *a* is divisible by *k* without remainder and similarly, *b* is divisible by *k* without remainder. Let *gcd*(*a*, *b*) represent the operation of calculating the greatest common divisor of numbers *a* and *b*. Specifically, *gcd*(*x*, 0) = *gcd*(0, *x*) = *x*.

In the first sample the game will go like that:
-  Simon should take *gcd*(3, 9) = 3 stones from the heap. After his move the heap has 6 stones left.-  Antisimon should take *gcd*(5, 6) = 1 stone from the heap. After his move the heap has 5 stones left.-  Simon should take *gcd*(3, 5) = 1 stone from the heap. After his move the heap has 4 stones left.-  Antisimon should take *gcd*(5, 4) = 1 stone from the heap. After his move the heap has 3 stones left.-  Simon should take *gcd*(3, 3) = 3 stones from the heap. After his move the heap has 0 stones left.-  Antisimon should take *gcd*(5, 0) = 5 stones from the heap. As 0 &lt; 5, it is impossible and Antisimon loses.
In the second sample each player during each move takes one stone from the heap. As *n* is even, Antisimon takes the last stone and Simon can't make a move after that.",WRONG_ANSWER,"import math
a, b, n = map(int,input().split())
x = a
while n >= 0:
	n -= math.gcd(x, n)
	if x == a:
	    x = b
	else:
	    x = a
print(x)","#----Kuzlyaev-Nikita-Codeforces-----
#------------03.04.2020-------------

# Read input values
n, k, x = map(int, input().split())
a = list(map(int, input().split()))

# Initialize total time with the sum of all chores
total_time = sum(a)

# Calculate the time saved by choosing k chores
# Find the k largest chores to replace with x time
replacements = sorted(a)[:k]
time_saved = sum(replacements) - k * x

# Calculate the minimum time
min_time = total_time - time_saved

# Output the result
print(min_time)"
200,B,Drinks,PROGRAMMING,"['implementation', 'math']","Little Vasya loves orange juice very much. That's why any food and drink in his kitchen necessarily contains orange juice. There are *n* drinks in his fridge, the volume fraction of orange juice in the *i*-th drink equals *p**i* percent.

One day Vasya decided to make himself an orange cocktail. He took equal proportions of each of the *n* drinks and mixed them. Then he wondered, how much orange juice the cocktail has.

Find the volume fraction of orange juice in the final drink.","The first input line contains a single integer *n* (1<=≤<=*n*<=≤<=100) — the number of orange-containing drinks in Vasya's fridge. The second line contains *n* integers *p**i* (0<=≤<=*p**i*<=≤<=100) — the volume fraction of orange juice in the *i*-th drink, in percent. The numbers are separated by a space.",Print the volume fraction in percent of orange juice in Vasya's cocktail. The answer will be considered correct if the absolute or relative error does not exceed 10<=<=-<=4.,"['3\n50 50 100\n', '4\n0 25 50 75\n']","['66.666666666667\n', '37.500000000000\n']","Note to the first sample: let's assume that Vasya takes *x* milliliters of each drink from the fridge. Then the volume of pure juice in the cocktail will equal <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/c1fac6e64d3a8ee6a5ac138cbe51e60039b22473.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> milliliters. The total cocktail's volume equals 3·*x* milliliters, so the volume fraction of the juice in the cocktail equals <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/ceb0664e55a1f9f5fa1243ec74680a4665a4d58d.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>, that is, 66.(6) percent.",OK,"x = int(input())
y = (input())
z = y.split(' ')
s = 0
for j in z:
	s += int(j)
# for i in y:
# 	s += int(i)
print (s/x)","n = int(input())
tree = list(map(int, input().split()))
colors = list(map(int, input().split()))

# Create adjacency list for the tree
adj = [[] for _ in range(n + 1)]
for i in range(2, n + 1):
    adj[tree[i - 2]].append(i)

def dfs(v, color):
    # Count the steps needed
    steps = 0
    if colors[v - 1] != color:
        steps += 1
        color = colors[v - 1]
    
    for neighbor in adj[v]:
        steps += dfs(neighbor, color)
    
    return steps

# Start DFS from the root (vertex 1) with initial color 0
result = dfs(1, 0)
print(result)"
734,A,Anton and Danik,PROGRAMMING,"['implementation', 'strings']","Anton likes to play chess, and so does his friend Danik.

Once they have played *n* games in a row. For each game it's known who was the winner — Anton or Danik. None of the games ended with a tie.

Now Anton wonders, who won more games, he or Danik? Help him determine this.","The first line of the input contains a single integer *n* (1<=≤<=*n*<=≤<=100<=000) — the number of games played.

The second line contains a string *s*, consisting of *n* uppercase English letters 'A' and 'D' — the outcome of each of the games. The *i*-th character of the string is equal to 'A' if the Anton won the *i*-th game and 'D' if Danik won the *i*-th game.","If Anton won more games than Danik, print ""Anton"" (without quotes) in the only line of the output.

If Danik won more games than Anton, print ""Danik"" (without quotes) in the only line of the output.

If Anton and Danik won the same number of games, print ""Friendship"" (without quotes).","['6\nADAAAA\n', '7\nDDDAADA\n', '6\nDADADA\n']","['Anton\n', 'Danik\n', 'Friendship\n']","In the first sample, Anton won 6 games, while Danik — only 1. Hence, the answer is ""Anton"".

In the second sample, Anton won 3 games and Danik won 4 games, so the answer is ""Danik"".

In the third sample, both Anton and Danik won 3 games and the answer is ""Friendship"".",OK,"n=int(input())
a=d=0
s=input()
for i in range(n):
    if s[i]=='A': a+=1
    else: d+=1
if a==d: print('Friendship')
elif a>d: print('Anton')
else: print('Danik')","def valerathehorse(shoes):
    shoesNeed = 0
    d = {}
    
    # Count the occurrences of each shoe color
    for shoe in shoes:
        if shoe not in d:
            d[shoe] = 1
    
    # The number of different colors Valera already has
    unique_colors = len(d)
    
    # To have 4 different colors, subtract the unique colors from 4
    shoesNeed = 4 - unique_colors
    
    return shoesNeed

# Example usage
shoes = list(map(int, input().split()))
print(valerathehorse(shoes))"
25,A,IQ test,PROGRAMMING,['brute force'],"Bob is preparing to pass IQ test. The most frequent task in this test is to find out which one of the given *n* numbers differs from the others. Bob observed that one number usually differs from the others in evenness. Help Bob — to check his answers, he needs a program that among the given *n* numbers finds one that is different in evenness.","The first line contains integer *n* (3<=≤<=*n*<=≤<=100) — amount of numbers in the task. The second line contains *n* space-separated natural numbers, not exceeding 100. It is guaranteed, that exactly one of these numbers differs from the others in evenness.",Output index of number that differs from the others in evenness. Numbers are numbered from 1 in the input order.,"['5\n2 4 7 8 10\n', '4\n1 2 1 1\n']","['3\n', '2\n']",none,WRONG_ANSWER,"n = int(input())
given = [int(i) for i in input().split()]
given = [k%2 for k in given]
total = 0
for k in range(1,n-1):
    if (given[k] != given[k-1]) and (given[k] != given[k+1]):
        print(k+1)
    elif (given[0] != given[1]) and (given[0] != given[2]):
        print(1)
    elif (given[-1] != given[-2]) and (given[-1] != given[-3]):
        print(n)
","def find_x(p, q, r, arr):
    # Calculate maximum values for p * a[i]
    max_p = [0] * len(arr)
    max_p[0] = p * arr[0]
    for i in range(1, len(arr)):
        max_p[i] = max(max_p[i - 1], p * arr[i])
    
    # Calculate maximum values for q * a[j] with respect to max_p
    max_q = [0] * len(arr)
    for j in range(len(arr)):
        max_q[j] = max(max_p[j], q * arr[j]) if j > 0 else q * arr[j]
    
    # Calculate the maximum value for r * a[k] with respect to max_q
    max_x = float('-inf')
    for k in range(len(arr)):
        max_x = max(max_x, max_q[k] + r * arr[k])
    
    return max_x

def check_x():
    params = input().split()
    n, p, q, r = int(params[0]), int(params[1]), int(params[2]), int(params[3])
    arr = input().split()
    arr = [int(x) for x in arr]
    x = find_x(p, q, r, arr)
    print(x)"
675,A,Infinite Sequence,PROGRAMMING,['math'],"Vasya likes everything infinite. Now he is studying the properties of a sequence *s*, such that its first element is equal to *a* (*s*1<==<=*a*), and the difference between any two neighbouring elements is equal to *c* (*s**i*<=-<=*s**i*<=-<=1<==<=*c*). In particular, Vasya wonders if his favourite integer *b* appears in this sequence, that is, there exists a positive integer *i*, such that *s**i*<==<=*b*. Of course, you are the person he asks for a help.","The first line of the input contain three integers *a*, *b* and *c* (<=-<=109<=≤<=*a*,<=*b*,<=*c*<=≤<=109) — the first element of the sequence, Vasya's favorite number and the difference between any two neighbouring elements of the sequence, respectively.","If *b* appears in the sequence *s* print ""YES"" (without quotes), otherwise print ""NO"" (without quotes).","['1 7 3\n', '10 10 0\n', '1 -4 5\n', '0 60 50\n']","['YES\n', 'YES\n', 'NO\n', 'NO\n']","In the first sample, the sequence starts from integers 1, 4, 7, so 7 is its element.

In the second sample, the favorite integer of Vasya is equal to the first element of the sequence.

In the third sample all elements of the sequence are greater than Vasya's favorite integer.

In the fourth sample, the sequence starts from 0, 50, 100, and all the following elements are greater than Vasya's favorite integer.",WRONG_ANSWER,"l=list(map(int,input().split("" "")))
a=l[0]
b=l[1]
c=l[2]
d=b-a
if d==0 or d%c==0:
	print(""YES"")
else:
	print(""NO"")","from math import gcd

# Function to calculate the maximum chocolates
def max_chocolates(n, a, b, p, q):
    # Calculate the number of tiles painted Red
    red_tiles = n // a
    # Calculate the number of tiles painted Blue
    blue_tiles = n // b
    # Calculate the number of tiles painted both Red and Blue
    lcm_ab = (a * b) // gcd(a, b)  # Least Common Multiple of a and b
    both_tiles = n // lcm_ab
    
    # To maximize the chocolates, Joty should prefer painting the tiles based on the value of p and q
    if p >= q:
        # Paint Red first, then Blue
        total_chocolates = (red_tiles * p) + ((blue_tiles - both_tiles) * q)
    else:
        # Paint Blue first, then Red
        total_chocolates = (blue_tiles * q) + ((red_tiles - both_tiles) * p)
    
    return total_chocolates

# Reading input
n, a, b, p, q = map(int, input().split())

# Calculating the maximum chocolates and printing the result
print(max_chocolates(n, a, b, p, q))"
71,A,Way Too Long Words,PROGRAMMING,['strings'],"Sometimes some words like ""localization"" or ""internationalization"" are so long that writing them many times in one text is quite tiresome.

Let's consider a word too long, if its length is strictly more than 10 characters. All too long words should be replaced with a special abbreviation.

This abbreviation is made like this: we write down the first and the last letter of a word and between them we write the number of letters between the first and the last letters. That number is in decimal system and doesn't contain any leading zeroes.

Thus, ""localization"" will be spelt as ""l10n"", and ""internationalization» will be spelt as ""i18n"".

You are suggested to automatize the process of changing the words with abbreviations. At that all too long words should be replaced by the abbreviation and the words that are not too long should not undergo any changes.",The first line contains an integer *n* (1<=≤<=*n*<=≤<=100). Each of the following *n* lines contains one word. All the words consist of lowercase Latin letters and possess the lengths of from 1 to 100 characters.,Print *n* lines. The *i*-th line should contain the result of replacing of the *i*-th word from the input data.,['4\nword\nlocalization\ninternationalization\npneumonoultramicroscopicsilicovolcanoconiosis\n'],['word\nl10n\ni18n\np43s\n'],none,WRONG_ANSWER,"a=""localization""
g=""internationalization""
d=""pneumonoultramicroscopicsilicovolcanoconiosis""
y=a.replace(""ocalizatio"",""10"")
#print(y)

b=g.replace(""nternationalizatio"",""18"")
#print(b)

c=d.replace(""neumonoultramicroscopicsilicovolcanoconiosi"",""43"")

#print(c)
print(""word\n"",y,""\n"",b,""\n"",c)

","def solve(d, t):
    # Read the number of songs and total duration
    n, d = map(int, d.split())
    # Read the duration for each song
    song_times = list(map(int, t.split()))
    
    # Calculate the total time required for songs including rests
    total_song_time = sum(song_times)
    total_rest_time = (n - 1) * 10  # Rest is needed after each song except the last
    
    total_time_needed = total_song_time + total_rest_time
    
    # Check if it is possible to conduct all songs
    if total_time_needed > d:
        return -1
    
    # Calculate the maximum number of jokes
    # Remaining time after scheduling songs and rests
    remaining_time = d - total_time_needed
    # Each joke takes 5 minutes
    max_jokes = (remaining_time // 5) + (n - 1) * 2  # 2 jokes per rest period
    
    return max_jokes

# Input for function call
d = ""30""
t = ""2 2 1""
print(solve(d, t))  # Call the solve function with given inputs"
265,B,Roadside Trees (Simplified Edition),PROGRAMMING,"['greedy', 'implementation']","Squirrel Liss loves nuts. There are *n* trees (numbered 1 to *n* from west to east) along a street and there is a delicious nut on the top of each tree. The height of the tree *i* is *h**i*. Liss wants to eat all nuts.

Now Liss is on the root of the tree with the number 1. In one second Liss can perform one of the following actions:
 -  Walk up or down one unit on a tree. -  Eat a nut on the top of the current tree. -  Jump to the next tree. In this action the height of Liss doesn't change. More formally, when Liss is at height *h* of the tree *i* (1<=≤<=*i*<=≤<=*n*<=-<=1), she jumps to height *h* of the tree *i*<=+<=1. This action can't be performed if *h*<=&gt;<=*h**i*<=+<=1. 
Compute the minimal time (in seconds) required to eat all nuts.","The first line contains an integer *n* (1<=<=≤<=<=*n*<=≤<=105) — the number of trees.

Next *n* lines contains the height of trees: *i*-th line contains an integer *h**i* (1<=≤<=*h**i*<=≤<=104) — the height of the tree with the number *i*.",Print a single integer — the minimal time required to eat all nuts in seconds.,"['2\n1\n2\n', '5\n2\n1\n2\n1\n1\n']","['5\n', '14\n']",none,WRONG_ANSWER,"t = input()
n = int(t)
treeList = []
time = 0
for i in range(n):
    s = input()
    temp = int(s)
    treeList.append(temp)
time = treeList[0] + 1
for i in range(1, n):
    if treeList[i - 1] > treeList[i]:
        time = time + 1 + treeList[i] + 1
    else:
        time = time + 1 + (treeList[i] - treeList[i-1]) + 1

print(time)
","a, b = list(map(int, input().split()))
g = {}

# Game continues until at least one joystick discharges
minutes = 0

while a > 0 and b > 0:
    # If either joystick is at 1%, charge it
    if a == 1:
        a += 1  # Charge first joystick
    elif b == 1:
        b += 1  # Charge second joystick
    else:
        # Choose which joystick to charge
        if a > b:
            a -= 2  # First joystick discharges
            b += 1  # Second joystick charges
        else:
            b -= 2  # Second joystick discharges
            a += 1  # First joystick charges
            
    # Count the minute that passed
    minutes += 1

print(minutes)"
900,A,Find Extra One,PROGRAMMING,"['geometry', 'implementation']","You have *n* distinct points on a plane, none of them lie on *OY* axis. Check that there is a point after removal of which the remaining points are located on one side of the *OY* axis.","The first line contains a single positive integer *n* (2<=≤<=*n*<=≤<=105).

The following *n* lines contain coordinates of the points. The *i*-th of these lines contains two single integers *x**i* and *y**i* (|*x**i*|,<=|*y**i*|<=≤<=109, *x**i*<=≠<=0). No two points coincide.","Print ""Yes"" if there is such a point, ""No"" — otherwise.

You can print every letter in any case (upper or lower).","['3\n1 1\n-1 -1\n2 -1\n', '4\n1 1\n2 2\n-1 1\n-2 2\n', '3\n1 2\n2 1\n4 60\n']","['Yes', 'No', 'Yes']","In the first example the second point can be removed.

In the second example there is no suitable for the condition point.

In the third example any point can be removed.",OK,"n = int(input())
p , nn = 0 ,0
for i in range(n):
    x,y = map(int,input().split())
    if x > 0:
        p += 1
    else:
        nn += 1
if p > 1 and nn > 1:
    print('NO')
elif p <= 1 or nn <= 1:
    print('YES')","# https://codeforces.com/problemset/problem/450/A
import math
from collections import deque

# Read input values
n, m = map(int, input().split())
a = list(map(int, input().split()))

# Create a queue to represent the children
queue = deque([(i + 1, a[i]) for i in range(n)])  # (child_index, candies_needed)

last_child = 0

# Distribute candies
while queue:
    child_index, candies_needed = queue.popleft()  # Get the first child
    candies_needed -= m  # Give m candies

    if candies_needed > 0:
        queue.append((child_index, candies_needed))  # Not enough candies, go to the end of the line
    else:
        last_child = child_index  # Enough candies, child goes home

# Output the last child index
print(last_child)"
343,C,Read Time,PROGRAMMING,"['binary search', 'greedy', 'two pointers']","Mad scientist Mike does not use slow hard disks. His modification of a hard drive has not one, but *n* different heads that can read data in parallel.

When viewed from the side, Mike's hard drive is an endless array of tracks. The tracks of the array are numbered from left to right with integers, starting with 1. In the initial state the *i*-th reading head is above the track number *h**i*. For each of the reading heads, the hard drive's firmware can move the head exactly one track to the right or to the left, or leave it on the current track. During the operation each head's movement does not affect the movement of the other heads: the heads can change their relative order; there can be multiple reading heads above any of the tracks. A track is considered read if at least one head has visited this track. In particular, all of the tracks numbered *h*1, *h*2, ..., *h**n* have been read at the beginning of the operation.

Mike needs to read the data on *m* distinct tracks with numbers *p*1, *p*2, ..., *p**m*. Determine the minimum time the hard drive firmware needs to move the heads and read all the given tracks. Note that an arbitrary number of other tracks can also be read.","The first line of the input contains two space-separated integers *n*, *m* (1<=≤<=*n*,<=*m*<=≤<=105) — the number of disk heads and the number of tracks to read, accordingly. The second line contains *n* distinct integers *h**i* in ascending order (1<=≤<=*h**i*<=≤<=1010, *h**i*<=&lt;<=*h**i*<=+<=1) — the initial positions of the heads. The third line contains *m* distinct integers *p**i* in ascending order (1<=≤<=*p**i*<=≤<=1010, *p**i*<=&lt;<=*p**i*<=+<=1) - the numbers of tracks to read.

Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is recommended to use the cin, cout streams or the %I64d specifier.","Print a single number — the minimum time required, in seconds, to read all the needed tracks.","['3 4\n2 5 6\n1 3 6 8\n', '3 3\n1 2 3\n1 2 3\n', '1 2\n165\n142 200\n']","['2\n', '0\n', '81\n']","The first test coincides with the figure. In this case the given tracks can be read in 2 seconds in the following way: 
 1.  during the first second move the 1-st head to the left and let it stay there; 1.  move the second head to the left twice; 1.  move the third head to the right twice (note that the 6-th track has already been read at the beginning). 
One cannot read the tracks in 1 second as the 3-rd head is at distance 2 from the 8-th track.",OK,"# Read Time
import sys
input = sys.stdin.buffer.readline

n, m = map(int, input().split())

h = list(map(int, input().split()))

p = list(map(int, input().split()))

# minimmum time for h_i to cover all p_s...p_e
def min_t(h_i, p_s, p_e):
    return min(abs(h[h_i]-p[p_s]),abs(h[h_i]-p[p_e])) + (p[p_e]-p[p_s])

# if all the heads can read all the tracks in <= mx_t time
# we use greedy :)
def check(mx_t):
    h_i = 0
    p_i = 0
    while p_i < m and h_i < n:
        p_j = p_i
        while p_j+1 < m and min_t(h_i, p_i, p_j+1) <= mx_t:
            p_j += 1

        if min_t(h_i, p_i, p_j) <= mx_t:
            p_i = p_j+1

        h_i += 1

    return p_i == m

l = 0
r = 10**11
while l != r:
    mt = (l+r)//2

    if check(mt):
        r = mt
    else:
        l = mt+1

print(l)
","from collections import Counter, defaultdict, deque
import heapq as hq
from itertools import count, islice

# alph = 'abcdefghijklmnopqrstuvwxyz'
# from math import factorial as fact
import math
import sys

def max_odd_subsequence_sum(n, a):
    total_sum = sum(x for x in a if x > 0)  # Sum of all positive numbers
    if total_sum % 2 == 1:  # If the total sum is odd
        return total_sum
    
    # If the total sum is even, we need to remove the smallest odd number
    min_odd = float('inf')
    
    for x in a:
        if x % 2 == 1:  # Check for odd numbers
            min_odd = min(min_odd, x)
    
    return total_sum - min_odd  # Return the adjusted total

# Input reading
n = int(input())
a = list(map(int, input().split()))

# Output the result
print(max_odd_subsequence_sum(n, a))"
454,B,Little Pony and Sort by Shift,PROGRAMMING,['implementation'],"One day, Twilight Sparkle is interested in how to sort a sequence of integers *a*1,<=*a*2,<=...,<=*a**n* in non-decreasing order. Being a young unicorn, the only operation she can perform is a unit shift. That is, she can move the last element of the sequence to its beginning:

Help Twilight Sparkle to calculate: what is the minimum number of operations that she needs to sort the sequence?","The first line contains an integer *n* (2<=≤<=*n*<=≤<=105). The second line contains *n* integer numbers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=105).",If it's impossible to sort the sequence output -1. Otherwise output the minimum number of operations Twilight Sparkle needs to sort it.,"['2\n2 1\n', '3\n1 3 2\n', '2\n1 2\n']","['1\n', '-1\n', '0\n']",none,COMPILATION_ERROR,"n=int(input())
l=list(map(int,input().split()))
z=l.index(max(l))
l1=l[:z+1]
x=l.index(min(l))
l2=l[x:]
if l==sorted(l):
    print(0)
elif l1==sorted(l) and l2==sorted(l):
    if min(l1)>=max(l2):
        print(len(l2))
    else:
        print(-1)
elif l2==l:
    if l[-1]=l[0]
        print(1)
else:
    print(-1)","from math import gcd, lcm, sqrt, factorial

def solve():
    n = int(input().strip())  # Read the number of elements
    a = list(map(int, input().strip().split()))  # Read the sequence of integers
    
    s = sum(a)  # Calculate the sum of all elements
    AVG = s // n  # Calculate the average (integer division)

    indices = []  # Initialize list to store sought indices

    for i in range(n):
        if a[i] == AVG:  # Check if the current element equals the average
            indices.append(i + 1)  # Store 1-based index

    print(len(indices))  # Print the number of sought indices
    if indices:
        print(' '.join(map(str, indices)))  # Print the sought indices in increasing order

# Sample call to the function (uncomment when executing)
# solve()"
749,A,Bachgold Problem,PROGRAMMING,"['greedy', 'implementation', 'math', 'number theory']","Bachgold problem is very easy to formulate. Given a positive integer *n* represent it as a sum of maximum possible number of prime numbers. One can prove that such representation exists for any integer greater than 1.

Recall that integer *k* is called prime if it is greater than 1 and has exactly two positive integer divisors — 1 and *k*.",The only line of the input contains a single integer *n* (2<=≤<=*n*<=≤<=100<=000).,"The first line of the output contains a single integer *k* — maximum possible number of primes in representation.

The second line should contain *k* primes with their sum equal to *n*. You can print them in any order. If there are several optimal solution, print any of them.","['5\n', '6\n']","['2\n2 3\n', '3\n2 2 2\n']",none,OK,"n=int(input())

if n%2==0:
	k=[2]*(n//2)
	print(n//2)
	print(*k)
else:
	k=[2]*(n//2)
	k[len(k)-1]=3
	print(n//2)
	print(*k)","import sys
from math import ceil, floor, sqrt, log, dist
from collections import defaultdict
from operator import itemgetter
rmi = lambda: map(int, input().split())
rs = lambda: input()

# Dictionary to map polyhedron names to their corresponding number of faces
faces_count = {
    ""Tetrahedron"": 4,
    ""Cube"": 6,
    ""Octahedron"": 8,
    ""Dodecahedron"": 12,
    ""Icosahedron"": 20
}

# Read the number of polyhedrons
n = int(input())
total_faces = 0

# Iterate through each polyhedron name and sum their faces
for _ in range(n):
    polyhedron_name = rs()
    total_faces += faces_count[polyhedron_name]

# Output the total number of faces
print(total_faces)"
678,D,Iterated Linear Function,PROGRAMMING,"['math', 'number theory']","Consider a linear function *f*(*x*)<==<=*Ax*<=+<=*B*. Let's define *g*(0)(*x*)<==<=*x* and *g*(*n*)(*x*)<==<=*f*(*g*(*n*<=-<=1)(*x*)) for *n*<=&gt;<=0. For the given integer values *A*, *B*, *n* and *x* find the value of *g*(*n*)(*x*) modulo 109<=+<=7.","The only line contains four integers *A*, *B*, *n* and *x* (1<=≤<=*A*,<=*B*,<=*x*<=≤<=109,<=1<=≤<=*n*<=≤<=1018) — the parameters from the problem statement.

Note that the given value *n* can be too large, so you should use 64-bit integer type to store it. In C++ you can use the long long integer type and in Java you can use long integer type.",Print the only integer *s* — the value *g*(*n*)(*x*) modulo 109<=+<=7.,"['3 4 1 1\n', '3 4 2 1\n', '3 4 3 1\n']","['7\n', '25\n', '79\n']",none,OK,"import sys,math
def power(x, y, p): 
    res = 1;
    x = x % p;  
    while (y > 0):   
        if (y & 1): 
            res = (res * x) % p; 
        y = y >> 1;  
        x = (x * x) % p; 
    return res; 
def modInverse(b,m): 
	g = math.gcd(b, m) 
	if (g != 1):  
		return -1
	else:  
		return pow(b, m - 2, m)  
def modDivide(a,b,m): 
	a = a % m 
	inv = modInverse(b,m) 
	if(inv == -1): 
		print(""Division not defined"") 
	else: 
		return (inv*a) % m    
#using sum of GP series 
A,B,n,X=map(int,sys.stdin.readline().split())
m=10**9+7
if A==1:
    print(((n%m)*B+X)%m)
else:
    temp=power(A,n,m)
    s=(temp*(X%m))%m
    s=(s%m+((modDivide(B*(temp-1),A-1,m)%m)%m)%m)%m
    print(s%m)
","def handel_upto_99(number):
    # Dictionaries for number words
    ones = [
        """", ""one"", ""two"", ""three"", ""four"", ""five"", 
        ""six"", ""seven"", ""eight"", ""nine""
    ]
    teens = [
        ""ten"", ""eleven"", ""twelve"", ""thirteen"", ""fourteen"",
        ""fifteen"", ""sixteen"", ""seventeen"", ""eighteen"", ""nineteen""
    ]
    tens = [
        """", """", ""twenty"", ""thirty"", ""forty"", 
        ""fifty"", ""sixty"", ""seventy"", ""eighty"", ""ninety""
    ]
    
    if 0 <= number < 10:
        return ones[number]
    elif 10 <= number < 20:
        return teens[number - 10]
    elif 20 <= number < 100:
        ten = number // 10
        one = number % 10
        return tens[ten] + ( ""-"" + ones[one] if one > 0 else """")
    else:
        return """"  # For numbers not in the specified range

# Read the input score
s = int(input().strip())
# Print the corresponding words
print(handel_upto_99(s))"
424,A,Squats,PROGRAMMING,['implementation'],"Pasha has many hamsters and he makes them work out. Today, *n* hamsters (*n* is even) came to work out. The hamsters lined up and each hamster either sat down or stood up.

For another exercise, Pasha needs exactly  hamsters to stand up and the other hamsters to sit down. In one minute, Pasha can make some hamster ether sit down or stand up. How many minutes will he need to get what he wants if he acts optimally well?","The first line contains integer *n* (2<=≤<=*n*<=≤<=200; *n* is even). The next line contains *n* characters without spaces. These characters describe the hamsters' position: the *i*-th character equals 'X', if the *i*-th hamster in the row is standing, and 'x', if he is sitting.","In the first line, print a single integer — the minimum required number of minutes. In the second line, print a string that describes the hamsters' position after Pasha makes the required changes. If there are multiple optimal positions, print any of them.","['4\nxxXx\n', '2\nXX\n', '6\nxXXxXx\n']","['1\nXxXx\n', '1\nxX\n', '0\nxXXxXx\n']",none,OK,"def main():
    input()
    s = input()
    ta = t = (s.count('x') - s.count('X')) // 2
    res = []
    if t > 0:
        for c in s:
            if t and c == 'x':
                c = 'X'
                t -= 1
            res.append(c)
    else:
        for c in s:
            if t and c == 'X':
                c = 'x'
                t += 1
            res.append(c)
    print(abs(ta))
    print(''.join(res))


if __name__ == '__main__':
    main()","# -*- coding: utf-8 -*-
""""""
@author: Ilych
""""""
def input_row():
    return list(map(int, input().strip().split(' ')))

def is_chronological_order(n, submissions):
    # Create a dictionary to store the last seen unique solution count for each participant
    last_seen = {}

    for x, k in submissions:
        if k not in last_seen:
            last_seen[k] = -1  # Initialize participant k with the lowest possible unique solution count

        # Check if the current count of unique solutions x is valid
        if x < last_seen[k]:
            return ""NO""
        
        # Update the last seen count for participant k
        last_seen[k] = x

    return ""YES""

n = int(input())
submissions = [input_row() for _ in range(n)]
print(is_chronological_order(n, submissions))"
432,A,Choosing Teams,PROGRAMMING,"['greedy', 'implementation', 'sortings']","The Saratov State University Olympiad Programmers Training Center (SSU OPTC) has *n* students. For each student you know the number of times he/she has participated in the ACM ICPC world programming championship. According to the ACM ICPC rules, each person can participate in the world championship at most 5 times.

The head of the SSU OPTC is recently gathering teams to participate in the world championship. Each team must consist of exactly three people, at that, any person cannot be a member of two or more teams. What maximum number of teams can the head make if he wants each team to participate in the world championship with the same members at least *k* times?","The first line contains two integers, *n* and *k* (1<=≤<=*n*<=≤<=2000; 1<=≤<=*k*<=≤<=5). The next line contains *n* integers: *y*1,<=*y*2,<=...,<=*y**n* (0<=≤<=*y**i*<=≤<=5), where *y**i* shows the number of times the *i*-th person participated in the ACM ICPC world championship.",Print a single number — the answer to the problem.,"['5 2\n0 4 5 1 0\n', '6 4\n0 1 2 3 4 5\n', '6 5\n0 0 0 0 0 0\n']","['1\n', '0\n', '2\n']","In the first sample only one team could be made: the first, the fourth and the fifth participants.

In the second sample no teams could be created.

In the third sample two teams could be created. Any partition into two teams fits.",OK,"n,k=map(int,input().split())
l=list(map(int,input().split()))
c=0
for i in range(len(l)):
    a=5-l[i]
    if a>=k:
        c+=1
print(c//3)","import sys
input = sys.stdin.readline

def main() -> None:
    n, m = map(int, input().split())
    array = list(map(int, input().split()))
    
    # Create a list to store answers for each query
    answers = []
    
    # We will keep track of distinct numbers from the end of the array to the beginning
    seen = set()
    distinct_count = [0] * (n + 1)

    # Traverse the array from the end to the beginning
    for i in range(n - 1, -1, -1):
        seen.add(array[i])
        distinct_count[i] = len(seen)
    
    # Process each query
    for _ in range(m):
        l = int(input().strip())
        answers.append(distinct_count[l - 1])  # l - 1 to convert to 0-based index

    # Print all answers, each on a new line
    print('\n'.join(map(str, answers)))

if __name__ == ""__main__"":
    main()"
265,B,Roadside Trees (Simplified Edition),PROGRAMMING,"['greedy', 'implementation']","Squirrel Liss loves nuts. There are *n* trees (numbered 1 to *n* from west to east) along a street and there is a delicious nut on the top of each tree. The height of the tree *i* is *h**i*. Liss wants to eat all nuts.

Now Liss is on the root of the tree with the number 1. In one second Liss can perform one of the following actions:
 -  Walk up or down one unit on a tree. -  Eat a nut on the top of the current tree. -  Jump to the next tree. In this action the height of Liss doesn't change. More formally, when Liss is at height *h* of the tree *i* (1<=≤<=*i*<=≤<=*n*<=-<=1), she jumps to height *h* of the tree *i*<=+<=1. This action can't be performed if *h*<=&gt;<=*h**i*<=+<=1. 
Compute the minimal time (in seconds) required to eat all nuts.","The first line contains an integer *n* (1<=<=≤<=<=*n*<=≤<=105) — the number of trees.

Next *n* lines contains the height of trees: *i*-th line contains an integer *h**i* (1<=≤<=*h**i*<=≤<=104) — the height of the tree with the number *i*.",Print a single integer — the minimal time required to eat all nuts in seconds.,"['2\n1\n2\n', '5\n2\n1\n2\n1\n1\n']","['5\n', '14\n']",none,WRONG_ANSWER,"n = int(input())
s = list(map(int,input().rsplit()))
a=n+sum(s)
for i in range (n-1):
    if s[i]>s[i-1]:
        a=a+(s[i]-s[i-1])
print(a)","# Aaditya Upadhyay
n, k = map(int, input().split())
road = input().strip()

# Initialize the position of Ksusha
position = 0

# While Ksusha is not at the end of the road
while position < n - 1:
    # Try to find the furthest position reachable from the current position
    reached = False
    for jump in range(k, 0, -1):
        if position + jump < n and road[position + jump] == ""."":
            position += jump  # Move to the new position
            reached = True
            break  # Exit the loop after the jump
    if not reached:
        # If we can't move forward, print ""NO"" and exit
        print(""NO"")
        break
else:
    # If we exit the loop normally, print ""YES""
    print(""YES"")"
16,A,Flag,PROGRAMMING,['implementation'],"According to a new ISO standard, a flag of every country should have a chequered field *n*<=×<=*m*, each square should be of one of 10 colours, and the flag should be «striped»: each horizontal row of the flag should contain squares of the same colour, and the colours of adjacent horizontal rows should be different. Berland's government asked you to find out whether their flag meets the new ISO standard.","The first line of the input contains numbers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=100), *n* — the amount of rows, *m* — the amount of columns on the flag of Berland. Then there follows the description of the flag: each of the following *n* lines contain *m* characters. Each character is a digit between 0 and 9, and stands for the colour of the corresponding square.","Output YES, if the flag meets the new ISO standard, and NO otherwise.","['3 3\n000\n111\n222\n', '3 3\n000\n000\n111\n', '3 3\n000\n111\n002\n']","['YES\n', 'NO\n', 'NO\n']",none,OK,"i = input().split("" "")
n = int(i[0])
m = int(i[1])
flag = [input() for x in range(n)]
previous = """"
result = True
for row in flag:
    if not row == row[0]*m:
        result = False
    if row == previous:
        result = False
    previous = row
if result:
    print(""YES"")
else:
    print(""NO"")
","def fn(s):
    lst = [""a"", ""e"", ""i"", ""o"", ""u"", ""y""]
    a = 0
    while True:
        new_s = []  # Hold the new corrected word
        i = 0
        while i < len(s):
            if i < len(s) - 1 and s[i] in lst and s[i + 1] in lst:
                # If there's a pair of consecutive vowels, skip the first one
                i += 1  # Skip the current vowel
            else:
                new_s.append(s[i])  # Keep the character
            i += 1
        
        new_s = ''.join(new_s)  # Convert list back to string
        
        if new_s == s:  # If no changes were made, we are done
            break
            
        s = new_s  # Update the string for the next iteration

    return s  # Return the corrected word

# Example usage:
n = int(input())  # Read number of characters
s = input()       # Read the word
print(fn(s))      # Print the corrected word"
67,A,Partial Teacher,PROGRAMMING,"['dp', 'graphs', 'greedy', 'implementation']","A teacher decides to give toffees to his students. He asks *n* students to stand in a queue. Since the teacher is very partial, he follows the following rule to distribute toffees.

He looks at the first two students and gives more toffees to the student having higher marks than the other one. If they have the same marks they get the same number of toffees. The same procedure is followed for each pair of adjacent students starting from the first one to the last one.

It is given that each student receives at least one toffee. You have to find the number of toffees given to each student by the teacher such that the total number of toffees is minimum.","The first line of input contains the number of students *n* (2<=≤<=*n*<=≤<=1000). The second line gives (*n*<=-<=1) characters consisting of ""L"", ""R"" and ""="". For each pair of adjacent students ""L"" means that the left student has higher marks, ""R"" means that the right student has higher marks and ""="" means that both have equal marks.",Output consists of *n* integers separated by a space representing the number of toffees each student receives in the queue starting from the first one to the last one.,"['5\nLRLR\n', '5\n=RRR\n']","['2 1 2 1 2\n', '1 1 2 3 4\n']",none,WRONG_ANSWER,"n = int(input())
s = input()
a = [1]*n

for i in range(n-1):
    if(s[i] == 'R'):
        a[i+1] = a[i] + 1

for i in range(n-2,-1,-1):
    if(s[i] == 'L'):
        a[i] = a[i+1] + 1
    
for i in range(n-1):
    if(s[i] == '='):
        if(a[i]>=a[i+1]):
            a[i+1] = a[i]
        else:
            a[i] = a[i+1]
        
print(*a)
        ","s = input()
b, s, c = s.count('B'), s.count('S'), s.count('C')
nb, ns, nc = map(int, input().split())
pb, ps, pc = map(int, input().split())
money = int(input())

def can_make_hamburgers(x):
    # Calculate required ingredients
    needed_b = max(0, b * x - nb)
    needed_s = max(0, s * x - ns)
    needed_c = max(0, c * x - nc)
    
    # Calculate total cost
    total_cost = needed_b * pb + needed_s * ps + needed_c * pc
    return total_cost <= money

# Binary search for the maximum number of hamburgers
low, high = 0, 10**13  # A high number to search up to
while low < high:
    mid = (low + high + 1) // 2  # Upper mid to avoid infinite loop
    if can_make_hamburgers(mid):
        low = mid  # Can make mid hamburgers, try for more
    else:
        high = mid - 1  # Can't make mid hamburgers, try less

print(low)"
456,A,Laptops,PROGRAMMING,['sortings'],"One day Dima and Alex had an argument about the price and quality of laptops. Dima thinks that the more expensive a laptop is, the better it is. Alex disagrees. Alex thinks that there are two laptops, such that the price of the first laptop is less (strictly smaller) than the price of the second laptop but the quality of the first laptop is higher (strictly greater) than the quality of the second laptop.

Please, check the guess of Alex. You are given descriptions of *n* laptops. Determine whether two described above laptops exist.","The first line contains an integer *n* (1<=≤<=*n*<=≤<=105) — the number of laptops.

Next *n* lines contain two integers each, *a**i* and *b**i* (1<=≤<=*a**i*,<=*b**i*<=≤<=*n*), where *a**i* is the price of the *i*-th laptop, and *b**i* is the number that represents the quality of the *i*-th laptop (the larger the number is, the higher is the quality).

All *a**i* are distinct. All *b**i* are distinct.","If Alex is correct, print ""Happy Alex"", otherwise print ""Poor Alex"" (without the quotes).",['2\n1 2\n2 1\n'],['Happy Alex\n'],none,OK,"def solve():
    x = int(input())
    l = []
    for i in range(x):
        a, b = map(int, input().split())
        l.append((a, b))
    l.sort(key=lambda p: p[0])
    for i in range(1, x):
        if l[i][1]-l[i-1][1] < 0:
            print('Happy Alex')
            return
    print('Poor Alex')


# t = int(input())
t = 1
while t:
    solve()
    t -= 1
","def restore_queue(n, neighbors):
    from collections import defaultdict
    
    # Create a graph representation of students with their neighbors
    gr = defaultdict(list)
    for i in range(n):
        a, b = neighbors[i]
        if a != 0:
            gr[a].append(i + 1)
            gr[i + 1].append(a)
        if b != 0:
            gr[b].append(i + 1)
            gr[i + 1].append(b)
    
    # Find the start of the queue (the only student with one neighbor connection)
    start = None
    for student_id in range(1, n + 1):
        if len(gr[student_id]) == 1:
            start = student_id
            break

    # DFS to retrieve the queue order
    def dfs(v):
        nonlocal num
        viz.add(v)
        pos2[num] = v
        num += 1
        for ver in gr[v]:
            if ver not in viz:
                dfs(ver)
                
    viz = set()
    pos2 = [0] * n
    num = 0
    
    # Start DFS from the student found as the start of the queue
    dfs(start)
    
    return pos2

# Input handling
n = int(input())
neighbors = [tuple(map(int, input().strip().split())) for _ in range(n)]

# Restore the queue and print the result
result = restore_queue(n, neighbors)
print(' '.join(map(str, result)))"
59,A,Word,PROGRAMMING,"['implementation', 'strings']","Vasya is very upset that many people on the Net mix uppercase and lowercase letters in one word. That's why he decided to invent an extension for his favorite browser that would change the letters' register in every word so that it either only consisted of lowercase letters or, vice versa, only of uppercase ones. At that as little as possible letters should be changed in the word. For example, the word HoUse must be replaced with house, and the word ViP — with VIP. If a word contains an equal number of uppercase and lowercase letters, you should replace all the letters with lowercase ones. For example, maTRIx should be replaced by matrix. Your task is to use the given method on one given word.",The first line contains a word *s* — it consists of uppercase and lowercase Latin letters and possesses the length from 1 to 100.,"Print the corrected word *s*. If the given word *s* has strictly more uppercase letters, make the word written in the uppercase register, otherwise - in the lowercase one.","['HoUse\n', 'ViP\n', 'maTRIx\n']","['house\n', 'VIP\n', 'matrix\n']",none,OK,"
""""""""""
def uccf( str ):
    x = 0
    while x < len(str):
        if ('a' <= str[x]) and ('z' >=  str[x]):
            str.replace(str[x], chr(65 + ord(str[x]) - ord('a')))
        #print(str[x])
        x = x+1

def lccF(str):
    str.lower()
    x = 0
    while x < len(str):
        if ('A' <= str[x]) and ('Z' >= str[x]):
            str.replace(str[x],chr(ord('a') + ord(str[x]) - 65))

        #print(str[x])
        x = x + 1""""""

string = input()
""""""""x=ord('a')
print((x))""""""""""

lcc = 0
ucc = 0
for x in string:
    #print(x)
    if ('a' <= x) and ('z' >= x):
        lcc = lcc+1
    else:
        ucc = ucc+1

#print(lcc)
#print(ucc)
if lcc<ucc:
    print(string.upper())
else:
    print(string.lower())
#print(string)
exit()","def can_make_equal_bids(bids):
    # Function to reduce each bid by dividing by 2 and 3 repeatedly
    def reduce_bid(bid):
        while bid % 2 == 0:
            bid //= 2
        while bid % 3 == 0:
            bid //= 3
        return bid

    # Reduce the first bid and use it as the reference
    reference = reduce_bid(bids[0])
    
    # Check if all other bids can be reduced to the reference
    for bid in bids:
        if reduce_bid(bid) != reference:
            return ""No""
    return ""Yes""


# Read input
n = int(sys.stdin.readline().strip())
bids = list(map(int, sys.stdin.readline().strip().split()))

# Get the result and print it
result = can_make_equal_bids(bids)
print(result)"
822,A,I'm bored with life,PROGRAMMING,"['implementation', 'math', 'number theory']","Holidays have finished. Thanks to the help of the hacker Leha, Noora managed to enter the university of her dreams which is located in a town Pavlopolis. It's well known that universities provide students with dormitory for the period of university studies. Consequently Noora had to leave Vičkopolis and move to Pavlopolis. Thus Leha was left completely alone in a quiet town Vičkopolis. He almost even fell into a depression from boredom!

Leha came up with a task for himself to relax a little. He chooses two integers *A* and *B* and then calculates the greatest common divisor of integers ""*A* factorial"" and ""*B* factorial"". Formally the hacker wants to find out GCD(*A*!,<=*B*!). It's well known that the factorial of an integer *x* is a product of all positive integers less than or equal to *x*. Thus *x*!<==<=1·2·3·...·(*x*<=-<=1)·*x*. For example 4!<==<=1·2·3·4<==<=24. Recall that GCD(*x*,<=*y*) is the largest positive integer *q* that divides (without a remainder) both *x* and *y*.

Leha has learned how to solve this task very effective. You are able to cope with it not worse, aren't you?","The first and single line contains two integers *A* and *B* (1<=≤<=*A*,<=*B*<=≤<=109,<=*min*(*A*,<=*B*)<=≤<=12).",Print a single integer denoting the greatest common divisor of integers *A*! and *B*!.,['4 3\n'],['6\n'],"Consider the sample.

4! = 1·2·3·4 = 24. 3! = 1·2·3 = 6. The greatest common divisor of integers 24 and 6 is exactly 6.",OK,"d = input().split(' ')
A = int(d[0])
B = int(d[1])

def factorial(x):
    if x == 0: 
        return 1
    return x * factorial(x-1)

if A>=B:
    print(factorial(B))
else:
    print(factorial(A))

		 		 				 	 	 	 	 			  	 	 	","s = input()

def chk(s):
    for i in range(len(s)):
        # Create a new string by inserting a character at position i
        for c in 'abcdefghijklmnopqrstuvwxyz':
            new_s = s[:i] + c + s[i:]
            # Check if the new string is a palindrome
            if new_s == new_s[::-1]:
                return new_s
    return ""NA""

# Check and print the result
result = chk(s)
print(result)"
677,A,Vanya and Fence,PROGRAMMING,['implementation'],"Vanya and his friends are walking along the fence of height *h* and they do not want the guard to notice them. In order to achieve this the height of each of the friends should not exceed *h*. If the height of some person is greater than *h* he can bend down and then he surely won't be noticed by the guard. The height of the *i*-th person is equal to *a**i*.

Consider the width of the person walking as usual to be equal to 1, while the width of the bent person is equal to 2. Friends want to talk to each other while walking, so they would like to walk in a single row. What is the minimum width of the road, such that friends can walk in a row and remain unattended by the guard?","The first line of the input contains two integers *n* and *h* (1<=≤<=*n*<=≤<=1000, 1<=≤<=*h*<=≤<=1000) — the number of friends and the height of the fence, respectively.

The second line contains *n* integers *a**i* (1<=≤<=*a**i*<=≤<=2*h*), the *i*-th of them is equal to the height of the *i*-th person.",Print a single integer — the minimum possible valid width of the road.,"['3 7\n4 5 14\n', '6 1\n1 1 1 1 1 1\n', '6 5\n7 6 8 9 10 5\n']","['4\n', '6\n', '11\n']","In the first sample, only person number 3 must bend down, so the required width is equal to 1 + 1 + 2 = 4.

In the second sample, all friends are short enough and no one has to bend, so the width 1 + 1 + 1 + 1 + 1 + 1 = 6 is enough.

In the third sample, all the persons have to bend, except the last one. The required minimum width of the road is equal to 2 + 2 + 2 + 2 + 2 + 1 = 11.",OK,"friends_num, fence_height = map(int, input().split())
friends_heights = [int(height) for height in input().split()]

road_width = sum(
    1
    if height <= fence_height
    else 2
    for height in friends_heights
)

print(road_width)
","def c(a):
    if str(a).find(""8"") == -1:
        return False
    return True

def find_min_b(a):
    b = 1
    while True:
        if c(a + b):
            return b
        b += 1

# Read input
a = int(input().strip())
# Get the minimum b
min_b = find_min_b(a)
# Print the result
print(min_b)"
507,A,Amr and Music,PROGRAMMING,"['greedy', 'implementation', 'sortings']","Amr is a young coder who likes music a lot. He always wanted to learn how to play music but he was busy coding so he got an idea.

Amr has *n* instruments, it takes *a**i* days to learn *i*-th instrument. Being busy, Amr dedicated *k* days to learn how to play the maximum possible number of instruments.

Amr asked for your help to distribute his free days between instruments so that he can achieve his goal.","The first line contains two numbers *n*, *k* (1<=≤<=*n*<=≤<=100, 0<=≤<=*k*<=≤<=10<=000), the number of instruments and number of days respectively.

The second line contains *n* integers *a**i* (1<=≤<=*a**i*<=≤<=100), representing number of days required to learn the *i*-th instrument.","In the first line output one integer *m* representing the maximum number of instruments Amr can learn.

In the second line output *m* space-separated integers: the indices of instruments to be learnt. You may output indices in any order.

if there are multiple optimal solutions output any. It is not necessary to use all days for studying.","['4 10\n4 3 1 2\n', '5 6\n4 3 1 1 2\n', '1 3\n4\n']","['4\n1 2 3 4', '3\n1 3 4', '0\n']","In the first test Amr can learn all 4 instruments.

In the second test other possible solutions are: {2, 3, 5} or {3, 4, 5}.

In the third test Amr doesn't have enough time to learn the only presented instrument.",OK,"n, k = map(int, input().split())
req_days = [int(c) for c in input().split()]

req_days_sorted = sorted((e, i) for i, e in enumerate(req_days, 1))
acc = 0
#print(req_days_sorted)
ans = []
for e, i in req_days_sorted:
    #print(acc, i, e, k)
    if acc + e <= k:
        acc += e
        ans.append(i)

print(len(ans))
if len(ans) > 0:
    print(*ans)
","n = (int)(input())
a = (list)(map(int, input().split()))

# Function to calculate the length of the longest non-decreasing subsequence
def longest_non_decreasing_subsequence(sequence):
    from bisect import bisect_right
    dp = []
    for x in sequence:
        pos = bisect_right(dp, x)
        if pos == len(dp):
            dp.append(x)
        else:
            dp[pos] = x
    return len(dp)

max_length = 0

# Try all possible intervals [l, r]
for l in range(n):
    for r in range(l, n):
        # Reverse the subarray a[l:r+1]
        reversed_segment = a[l:r+1][::-1]
        new_sequence = a[:l] + reversed_segment + a[r+1:]
        
        # Calculate the longest non-decreasing subsequence of the new sequence
        current_length = longest_non_decreasing_subsequence(new_sequence)
        max_length = max(max_length, current_length)

print(max_length)"
601,A,The Two Routes,PROGRAMMING,"['graphs', 'shortest paths']","In Absurdistan, there are *n* towns (numbered 1 through *n*) and *m* bidirectional railways. There is also an absurdly simple road network — for each pair of different towns *x* and *y*, there is a bidirectional road between towns *x* and *y* if and only if there is no railway between them. Travelling to a different town using one railway or one road always takes exactly one hour.

A train and a bus leave town 1 at the same time. They both have the same destination, town *n*, and don't make any stops on the way (but they can wait in town *n*). The train can move only along railways and the bus can move only along roads.

You've been asked to plan out routes for the vehicles; each route can use any road/railway multiple times. One of the most important aspects to consider is safety — in order to avoid accidents at railway crossings, the train and the bus must not arrive at the same town (except town *n*) simultaneously.

Under these constraints, what is the minimum number of hours needed for both vehicles to reach town *n* (the maximum of arrival times of the bus and the train)? Note, that bus and train are not required to arrive to the town *n* at the same moment of time, but are allowed to do so.","The first line of the input contains two integers *n* and *m* (2<=≤<=*n*<=≤<=400, 0<=≤<=*m*<=≤<=*n*(*n*<=-<=1)<=/<=2) — the number of towns and the number of railways respectively.

Each of the next *m* lines contains two integers *u* and *v*, denoting a railway between towns *u* and *v* (1<=≤<=*u*,<=*v*<=≤<=*n*, *u*<=≠<=*v*).

You may assume that there is at most one railway connecting any two towns.","Output one integer — the smallest possible time of the later vehicle's arrival in town *n*. If it's impossible for at least one of the vehicles to reach town *n*, output <=-<=1.","['4 2\n1 3\n3 4\n', '4 6\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4\n', '5 5\n4 2\n3 5\n4 5\n5 1\n1 2\n']","['2\n', '-1\n', '3\n']","In the first sample, the train can take the route <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/7c0aa60a06309ef607b7159fd7f3687ea0d943ce.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> and the bus can take the route <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/a26c2f3e93c9d9be6c21cb5d2bd6ac1f99f4ff55.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>. Note that they can arrive at town 4 at the same time.

In the second sample, Absurdistan is ruled by railwaymen. There are no roads, so there's no way for the bus to reach town 4.",WRONG_ANSWER,"n, m = map(int, input().split())
b = [[j for j in range(1,n+1) if j != i+1] for i in range(n)]
b.insert(0,[])
t = [[] for i in range(n+1)]

for _ in range(m):
    u, v = map(int, input().split())
    b[u].remove(v)
    b[v].remove(u)
    t[u].append(v)
    t[v].append(u)

def find_shorteset_path(n, start, des, adj):
    queue = [(start,0)]
    visited = [False for i in range(n+1)]
    visited[start] = True
    while queue != []:
        v = queue[0]
        if v[0] == des:
            return v[1]
        for neig in adj[v[0]]:
            if not visited[neig]:
                visited[neig]=True
                queue.append((neig, v[1]+1))
        del queue[0]
        print(queue)
        print(visited)
    return False
print(b)
bus_sol = find_shorteset_path(n, 1, n, b)
print(t)
train_sol = find_shorteset_path(n, 1, n, t)
if train_sol and bus_sol:
    print(max(train_sol, bus_sol))
else:
    print(-1)","ad = str(input())

def is_lucky(num):
    # Check if all digits in the number are either 4 or 7
    return all(digit in '47' for digit in str(num))

def is_almost_lucky(n):
    # Iterate through potential lucky numbers
    for lucky in range(4, n + 1):
        if is_lucky(lucky):
            if n % lucky == 0:
                return True
    return False

n = int(ad)
# Check if n is almost lucky
if is_almost_lucky(n):
    print(""YES"")
else:
    print(""NO"")"
52,A,123-sequence,PROGRAMMING,['implementation'],"There is a given sequence of integers *a*1,<=*a*2,<=...,<=*a**n*, where every number is from 1 to 3 inclusively. You have to replace the minimum number of numbers in it so that all the numbers in the sequence are equal to each other.","The first line contains an integer *n* (1<=≤<=*n*<=≤<=106). The second line contains a sequence of integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=3).",Print the minimum number of replacements needed to be performed to make all the numbers in the sequence equal.,['9\n1 3 2 2 2 1 1 2 3\n'],['5\n'],In the example all the numbers equal to 1 and 3 should be replaced by 2.,OK,"n = int(input())
s = input().split()
max_ = 0
for el in range(1,4):
    if s.count(str(el)) > max_:
        max_ = s.count(str(el))
print(len(s) - max_)","def check(i, j):
    if field[i][j] == '.':
        if field[i - 1][j] == field[i + 1][j] and field[i - 1][j] == 'x':
            return True
        elif field[i - 2][j] == field[i - 1][j] and field[i - 1][j] == 'x':
            return True
        elif field[i + 2][j] == field[i + 1][j] and field[i + 1][j] == 'x':
            return True    
    return False

# Read the game field
field = [input().strip() for _ in range(4)]

# Check all positions to see if placing 'x' leads to a win
for i in range(4):
    for j in range(4):
        if check(i, j):
            print(""YES"")
            exit()

# Check horizontal and diagonal placements
for i in range(4):
    for j in range(2):  # Check horizontal
        if field[i][j] == '.' and field[i][j + 1] == 'x' and field[i][j + 2] == 'x':
            print(""YES"")
            exit()

for i in range(2):  # Check diagonal
    for j in range(2):
        if field[i][j] == '.' and field[i + 1][j + 1] == 'x' and field[i + 2][j + 2] == 'x':
            print(""YES"")
            exit()
        if field[i + 2][j] == '.' and field[i + 1][j + 1] == 'x' and field[i][j + 2] == 'x':
            print(""YES"")
            exit()

# If no winning move is found
print(""NO"")"
1,A,Theatre Square,PROGRAMMING,['math'],"Theatre Square in the capital city of Berland has a rectangular shape with the size *n*<=×<=*m* meters. On the occasion of the city's anniversary, a decision was taken to pave the Square with square granite flagstones. Each flagstone is of the size *a*<=×<=*a*.

What is the least number of flagstones needed to pave the Square? It's allowed to cover the surface larger than the Theatre Square, but the Square has to be covered. It's not allowed to break the flagstones. The sides of flagstones should be parallel to the sides of the Square.","The input contains three positive integer numbers in the first line: *n*,<=<=*m* and *a* (1<=≤<=<=*n*,<=*m*,<=*a*<=≤<=109).",Write the needed number of flagstones.,['6 6 4\n'],['4\n'],none,RUNTIME_ERROR,"n = int(input())
m = int(input())
a = int(input())

area = n * m
tileArea = a * a

vTiles = round(n / a)
hTiles = round(m / a)

numberOfTiles = vTiles + hTiles

print(numberOfTiles)","from collections import Counter, defaultdict

n, m = map(int, input().split())
matrix = []

for i in range(n):
    matrix.append(list(map(str, input())))

# Count the occurrences of each letter in rows and columns
row_counts = [Counter(matrix[i]) for i in range(n)]
col_counts = [Counter(matrix[j][i] for j in range(n)) for i in range(m)]

result = []

# Iterate over each cell in the matrix
for i in range(n):
    for j in range(m):
        letter = matrix[i][j]
        # Check if the letter occurs more than once in its row or column
        if row_counts[i][letter] == 1 and col_counts[j][letter] == 1:
            result.append(letter)

# Join the remaining letters to form the final output string
print(''.join(result))"
1,A,Theatre Square,PROGRAMMING,['math'],"Theatre Square in the capital city of Berland has a rectangular shape with the size *n*<=×<=*m* meters. On the occasion of the city's anniversary, a decision was taken to pave the Square with square granite flagstones. Each flagstone is of the size *a*<=×<=*a*.

What is the least number of flagstones needed to pave the Square? It's allowed to cover the surface larger than the Theatre Square, but the Square has to be covered. It's not allowed to break the flagstones. The sides of flagstones should be parallel to the sides of the Square.","The input contains three positive integer numbers in the first line: *n*,<=<=*m* and *a* (1<=≤<=<=*n*,<=*m*,<=*a*<=≤<=109).",Write the needed number of flagstones.,['6 6 4\n'],['4\n'],none,OK,"from math import ceil
n,m,a=map(int, input().split())

print(ceil(n/a)*ceil(m/a))","import sys
import math
import bisect
import itertools
import random

def can_have_all_colors(s):
    n = len(s)

    # We will scan the landscape to check for potential color mixing
    for i in range(n):
        # Initialize a set to store the colors in the current cell and its neighbours
        colors = set()

        # Include the flower in the current cell if it exists
        if s[i] == 'A':
            colors.add('A')
        elif s[i] == 'B':
            colors.add('B')
        elif s[i] == 'C':
            colors.add('C')
        
        # Check the left neighbor if it exists
        if i > 0:
            if s[i-1] == 'A':
                colors.add('A')
            elif s[i-1] == 'B':
                colors.add('B')
            elif s[i-1] == 'C':
                colors.add('C')
        
        # Check the right neighbor if it exists
        if i < n - 1:
            if s[i+1] == 'A':
                colors.add('A')
            elif s[i+1] == 'B':
                colors.add('B')
            elif s[i+1] == 'C':
                colors.add('C')
        
        # Check if all three colors are in the current cell's influence
        if len(colors) == 3:
            return ""Yes""
    
    return ""No""

# Read input and call the function
s = input().strip()
print(can_have_all_colors(s))"
849,B,Tell Your World,PROGRAMMING,"['brute force', 'geometry']","Connect the countless points with lines, till we reach the faraway yonder.

There are *n* points on a coordinate plane, the *i*-th of which being (*i*,<=*y**i*).

Determine whether it's possible to draw two parallel and non-overlapping lines, such that every point in the set lies on exactly one of them, and each of them passes through at least one point in the set.","The first line of input contains a positive integer *n* (3<=≤<=*n*<=≤<=1<=000) — the number of points.

The second line contains *n* space-separated integers *y*1,<=*y*2,<=...,<=*y**n* (<=-<=109<=≤<=*y**i*<=≤<=109) — the vertical coordinates of each point.","Output ""Yes"" (without quotes) if it's possible to fulfill the requirements, and ""No"" otherwise.

You can print each letter in any case (upper or lower).","['5\n7 5 8 6 9\n', '5\n-1 -2 0 0 -5\n', '5\n5 4 3 2 1\n', '5\n1000000000 0 0 0 0\n']","['Yes\n', 'No\n', 'No\n', 'Yes\n']","In the first example, there are five points: (1, 7), (2, 5), (3, 8), (4, 6) and (5, 9). It's possible to draw a line that passes through points 1, 3, 5, and another one that passes through points 2, 4 and is parallel to the first one.

In the second example, while it's possible to draw two lines that cover all points, they cannot be made parallel.

In the third example, it's impossible to satisfy both requirements at the same time.",WRONG_ANSWER,"import sys


def main():
    n = int(input())
    s = list(map(int, sys.stdin.readline().split()))
    p1 = (0, 0)
    for z in range(2):
        for i in range(1, n):
            k = (s[i] - s[0]) / i
            oka = True
            okp = False
            for j in range(1, n):
                if i == j:
                    continue
                c = (s[j] - s[0]) / j
                if c != k:
                    if not okp:
                        p1 = (j, s[j])
                        okp = True
                    else:
                        k2 = (s[j] - p1[1]) / (j - p1[0])
                        if k!=k2:
                            oka = False
                            break

            if oka and okp:
                print(""Yes"")
                return
        s[1],s[0] = s[0],s[1]

    print(""No"")


main()
","def sum_digits(n):
    r = 0
    while n:
        r, n = r + n % 10, n // 10
    return r

def is_zcy(num):
    s = str(num)
    return s == s[::-1] and len(s) % 2 == 0

k, p = [int(i) for i in input().split(' ')]

zcy_numbers = []
num = 11  # Start from the first zcy number

while len(zcy_numbers) < k:
    if is_zcy(num):
        zcy_numbers.append(num)
    num += 1

result = sum(zcy_numbers) % p
print(result)"
327,A,Flipping Game,PROGRAMMING,"['brute force', 'dp', 'implementation']","Iahub got bored, so he invented a game to be played on paper. 

He writes *n* integers *a*1,<=*a*2,<=...,<=*a**n*. Each of those integers can be either 0 or 1. He's allowed to do exactly one move: he chooses two indices *i* and *j* (1<=≤<=*i*<=≤<=*j*<=≤<=*n*) and flips all values *a**k* for which their positions are in range [*i*,<=*j*] (that is *i*<=≤<=*k*<=≤<=*j*). Flip the value of *x* means to apply operation *x*<==<=1 - *x*.

The goal of the game is that after exactly one move to obtain the maximum number of ones. Write a program to solve the little game of Iahub.","The first line of the input contains an integer *n* (1<=≤<=*n*<=≤<=100). In the second line of the input there are *n* integers: *a*1,<=*a*2,<=...,<=*a**n*. It is guaranteed that each of those *n* values is either 0 or 1.",Print an integer — the maximal number of 1s that can be obtained after exactly one move.,"['5\n1 0 0 1 0\n', '4\n1 0 0 1\n']","['4\n', '4\n']","In the first case, flip the segment from 2 to 5 (*i* = 2, *j* = 5). That flip changes the sequence, it becomes: [1 1 1 0 1]. So, it contains four ones. There is no way to make the whole sequence equal to [1 1 1 1 1].

In the second case, flipping only the second and the third element (*i* = 2, *j* = 3) will turn all numbers into 1.",WRONG_ANSWER,"def main():
    n=int(input())
    a=list(map(int,input().split()))
    q,w=0,0
    for i in range(n):
        if a[i]==1:
            q=i+1
            break
    for i in range(n):
        if a[i]==1:
            w=i+1
    print(w-(q-1))
    
main()","def main():
    import sys
    input = sys.stdin.read
    n, k = map(int, input().strip().split())
    
    # Start with the initially sorted permutation
    permutation = list(range(1, n + 1))
    
    # We will create the decreasing coefficient by reversing the last (k + 1) elements
    # The first (n - k - 1) elements will be sorted in increasing order
    # The last (k + 1) elements will be sorted in decreasing order
    if k < n:
        permutation[n - k - 1:] = reversed(permutation[n - k - 1:])
    
    # Print the resulting permutation
    print(' '.join(map(str, permutation)))"
985,C,Liebig's Barrels,PROGRAMMING,['greedy'],"You have *m*<==<=*n*·*k* wooden staves. The *i*-th stave has length *a**i*. You have to assemble *n* barrels consisting of *k* staves each, you can use any *k* staves to construct a barrel. Each stave must belong to exactly one barrel.

Let volume *v**j* of barrel *j* be equal to the length of the minimal stave in it.

You want to assemble exactly *n* barrels with the maximal total sum of volumes. But you have to make them equal enough, so a difference between volumes of any pair of the resulting barrels must not exceed *l*, i.e. |*v**x*<=-<=*v**y*|<=≤<=*l* for any 1<=≤<=*x*<=≤<=*n* and 1<=≤<=*y*<=≤<=*n*.

Print maximal total sum of volumes of equal enough barrels or 0 if it's impossible to satisfy the condition above.","The first line contains three space-separated integers *n*, *k* and *l* (1<=≤<=*n*,<=*k*<=≤<=105, 1<=≤<=*n*·*k*<=≤<=105, 0<=≤<=*l*<=≤<=109).

The second line contains *m*<==<=*n*·*k* space-separated integers *a*1,<=*a*2,<=...,<=*a**m* (1<=≤<=*a**i*<=≤<=109) — lengths of staves.",Print single integer — maximal total sum of the volumes of barrels or 0 if it's impossible to construct exactly *n* barrels satisfying the condition |*v**x*<=-<=*v**y*|<=≤<=*l* for any 1<=≤<=*x*<=≤<=*n* and 1<=≤<=*y*<=≤<=*n*.,"['4 2 1\n2 2 1 2 3 2 2 3\n', '2 1 0\n10 10\n', '1 2 1\n5 2\n', '3 2 1\n1 2 3 4 5 6\n']","['7\n', '20\n', '2\n', '0\n']","In the first example you can form the following barrels: [1, 2], [2, 2], [2, 3], [2, 3].

In the second example you can form the following barrels: [10], [10].

In the third example you can form the following barrels: [2, 5].

In the fourth example difference between volumes of barrels in any partition is at least 2 so it is impossible to make barrels equal enough.",WRONG_ANSWER,"n,k,l = map(int, input().split())
a = sorted(map(int, input().split()))
al = a[0] + l
from bisect import bisect
ni = bisect(a, al)
if n > ni:
    print(0)
    exit(0)

ni = min(ni, (n-1)*k)
s = [min(k*i, ni) for i in range(n)]

for i in range(n-1, 0, -1):
    if s[i] <= s[n-1]:
        s[n-1] = s[i]-1
    else:
        break

print(sum(a[s1] for s1 in s))
","p, n = map(int, input().split())

k = [int(input()) for i in range(n)]

# Initialize a list to keep track of filled buckets
buckets = [False] * p

# Iterate through the numbers and insert them into the hash table
for i in range(n):
    # Calculate the bucket index using the hash function
    bucket_index = k[i] % p
    
    # Check if the bucket is already occupied
    if buckets[bucket_index]:
        # If yes, output the current index (1-based) and exit
        print(i + 1)
        break
    else:
        # Otherwise, mark the bucket as filled
        buckets[bucket_index] = True
else:
    # If no conflict happens, output -1
    print(-1)"
124,A,The number of positions,PROGRAMMING,['math'],"Petr stands in line of *n* people, but he doesn't know exactly which position he occupies. He can say that there are no less than *a* people standing in front of him and no more than *b* people standing behind him. Find the number of different positions Petr can occupy.","The only line contains three integers *n*, *a* and *b* (0<=≤<=*a*,<=*b*<=&lt;<=*n*<=≤<=100).",Print the single number — the number of the sought positions.,"['3 1 1\n', '5 2 3\n']","['2\n', '3\n']","The possible positions in the first sample are: 2 and 3 (if we number the positions starting with 1).

In the second sample they are 3, 4 and 5.",RUNTIME_ERROR,"n,a,b=map(int,input().split())
if b==0:
    print(1)
else:
    agv=(n-a)+(n-b)
    if agv%2==0:
        print(avg//2)
    else:
        avg=avg//2
        print(agv+1)","import sys
from math import ceil
input = sys.stdin.readline

def nth(a, n, d):
    return a + (n - 1) * d

a, b, c = [int(x) for x in input().split()]

# Check if c is zero to handle the special case where the sequence does not change
if c == 0:
    # If c is 0, all elements of the sequence are equal to a
    if a == b:
        print(""YES"")
    else:
        print(""NO"")
else:
    # Check if b can be generated from the sequence starting from a with step c
    # The condition is that (b - a) should be divisible by c and b should be greater than or equal to a
    if b >= a and (b - a) % c == 0:
        print(""YES"")
    else:
        print(""NO"")"
353,A,Domino,PROGRAMMING,"['implementation', 'math']","Valera has got *n* domino pieces in a row. Each piece consists of two halves — the upper one and the lower one. Each of the halves contains a number from 1 to 6. Valera loves even integers very much, so he wants the sum of the numbers on the upper halves and the sum of the numbers on the lower halves to be even.

To do that, Valera can rotate the dominoes by 180 degrees. After the rotation the upper and the lower halves swap places. This action takes one second. Help Valera find out the minimum time he must spend rotating dominoes to make his wish come true.","The first line contains integer *n* (1<=≤<=*n*<=≤<=100), denoting the number of dominoes Valera has. Next *n* lines contain two space-separated integers *x**i*,<=*y**i* (1<=≤<=*x**i*,<=*y**i*<=≤<=6). Number *x**i* is initially written on the upper half of the *i*-th domino, *y**i* is initially written on the lower half.","Print a single number — the minimum required number of seconds. If Valera can't do the task in any time, print <=-<=1.","['2\n4 2\n6 4\n', '1\n2 3\n', '3\n1 4\n2 3\n4 4\n']","['0\n', '-1\n', '1\n']","In the first test case the sum of the numbers on the upper halves equals 10 and the sum of the numbers on the lower halves equals 6. Both numbers are even, so Valera doesn't required to do anything.

In the second sample Valera has only one piece of domino. It is written 3 on the one of its halves, therefore one of the sums will always be odd.

In the third case Valera can rotate the first piece, and after that the sum on the upper halves will be equal to 10, and the sum on the lower halves will be equal to 8.",WRONG_ANSWER,"n=int(input())
x=[]
y=[]
co1=int(0)
co2=int(0)
count=[0,0]
for i in range(n):
    k,l=map(int,input().split())
    x.append(k)
    y.append(l)
if(sum(x)%2==0 and sum(y)%2==0):
    print(0)
elif((sum(x)%2==0 and sum(y)%2!=0) or (sum(y)%2==0 and sum(x)%2!=0)):
    print(-1)
else:
    for i in range(n):
        if(x[i]%2!=0):
            temp=x[i]
            x[i]=y[i]
            y[i]=temp
            count[0]+=1
        if(sum(x)%2==0 and sum(y)%2==0):
            break
    for i in range(n):
        if(y[i]%2!=0):
            temp=x[i]
            x[i]=y[i]
            y[i]=temp
            count[1]+=1
        if(sum(x)%2==0 and sum(y)%2==0):
            break
    print(min(count))
        
                ","from collections import Counter


def winner(k, a):
    m = max(a)
    w = [2]
    for i in range(1, m+1):
        if i % 2:
            w.append(w[-1])
        else:
            w.append(w[-1] * k)

    xor_sum = 0
    for pile in a:
        xor_sum ^= w[pile]

    return ""Kevin"" if xor_sum != 0 else ""Nicky""


# Read input values
n, k = map(int, input().split())
a = list(map(int, input().split()))

# Determine the winner and print the result
print(winner(k, a))"
1000,B,Light It Up,PROGRAMMING,['greedy'],"Recently, you bought a brand new smart lamp with programming features. At first, you set up a schedule to the lamp. Every day it will turn power on at moment $0$ and turn power off at moment $M$. Moreover, the lamp allows you to set a program of switching its state (states are ""lights on"" and ""lights off""). Unfortunately, some program is already installed into the lamp.

The lamp allows only good programs. Good program can be represented as a non-empty array $a$, where $0 &lt; a_1 &lt; a_2 &lt; \dots &lt; a_{|a|} &lt; M$. All $a_i$ must be integers. Of course, preinstalled program is a good program.

The lamp follows program $a$ in next manner: at moment $0$ turns power and light on. Then at moment $a_i$ the lamp flips its state to opposite (if it was lit, it turns off, and vice versa). The state of the lamp flips instantly: for example, if you turn the light off at moment $1$ and then do nothing, the total time when the lamp is lit will be $1$. Finally, at moment $M$ the lamp is turning its power off regardless of its state.

Since you are not among those people who read instructions, and you don't understand the language it's written in, you realize (after some testing) the only possible way to alter the preinstalled program. You can insert at most one element into the program $a$, so it still should be a good program after alteration. Insertion can be done between any pair of consecutive elements of $a$, or even at the begining or at the end of $a$.

Find such a way to alter the program that the total time when the lamp is lit is maximum possible. Maybe you should leave program untouched. If the lamp is lit from $x$ till moment $y$, then its lit for $y - x$ units of time. Segments of time when the lamp is lit are summed up.","First line contains two space separated integers $n$ and $M$ ($1 \le n \le 10^5$, $2 \le M \le 10^9$) — the length of program $a$ and the moment when power turns off.

Second line contains $n$ space separated integers $a_1, a_2, \dots, a_n$ ($0 &lt; a_1 &lt; a_2 &lt; \dots &lt; a_n &lt; M$) — initially installed program $a$.",Print the only integer — maximum possible total time when the lamp is lit.,"['3 10\n4 6 7\n', '2 12\n1 10\n', '2 7\n3 4\n']","['8\n', '9\n', '6\n']","In the first example, one of possible optimal solutions is to insert value $x = 3$ before $a_1$, so program will be $[3, 4, 6, 7]$ and time of lamp being lit equals $(3 - 0) + (6 - 4) + (10 - 7) = 8$. Other possible solution is to insert $x = 5$ in appropriate place.

In the second example, there is only one optimal solution: to insert $x = 2$ between $a_1$ and $a_2$. Program will become $[1, 2, 10]$, and answer will be $(1 - 0) + (10 - 2) = 9$.

In the third example, optimal answer is to leave program untouched, so answer will be $(3 - 0) + (7 - 4) = 6$.",WRONG_ANSWER,"# -*- coding: utf-8 -*-
""""""
Created on Tue Oct 26 16:54:29 2021

@author: Boush
""""""

n,m = map(int,input().split())
i = list(map(int,input().split()))
a = [0];a.extend(i);a.append(m)
t = []
for i in range(len(a)-1):
    t.append(a[i+1]-a[i])

sum_ = 0
for i in range(0,len(t),2):
    sum_ += t[i] 
max_ = {sum_}

t.insert(0,0)
i = 2
while i < len(t):
    sum_ = -1
    for j in range(i,len(t)+1,2):
        sum_ += t[j]
    max_.add(sum_)
    i += 2

print(max(max_))","from collections import defaultdict, Counter

n = int(input())
Kuro = [i for i in input()]
Shiro = [i for i in input()]
Katie = [i for i in input()]
Len = len(Kuro)

# Count occurrences of each character in the ribbons
K = Counter(Kuro)
S = Counter(Shiro)
C = Counter(Katie)

# Find the maximum occurrences in each ribbon
max_Kuro = max(K.values())
max_Shiro = max(S.values())
max_Katie = max(C.values())

# Calculate the maximum beauty each player can achieve after n turns
max_beauty_Kuro = min(Len, max_Kuro + n)
max_beauty_Shiro = min(Len, max_Shiro + n)
max_beauty_Katie = min(Len, max_Katie + n)

# Determine the winner
max_beauty = max(max_beauty_Kuro, max_beauty_Shiro, max_beauty_Katie)

# If there's a draw check
winners = []
if max_beauty_Kuro == max_beauty:
    winners.append(""Kuro"")
if max_beauty_Shiro == max_beauty:
    winners.append(""Shiro"")
if max_beauty_Katie == max_beauty:
    winners.append(""Katie"")

# Output the result
if len(winners) > 1:
    print(""Draw"")
else:
    print(winners[0])"
0,none,none,none,['none'],"Malek has recently found a treasure map. While he was looking for a treasure he found a locked door. There was a string *s* written on the door consisting of characters '(', ')' and '#'. Below there was a manual on how to open the door. After spending a long time Malek managed to decode the manual and found out that the goal is to replace each '#' with one or more ')' characters so that the final string becomes beautiful. 

Below there was also written that a string is called beautiful if for each *i* (1<=≤<=*i*<=≤<=|*s*|) there are no more ')' characters than '(' characters among the first *i* characters of *s* and also the total number of '(' characters is equal to the total number of ')' characters. 

Help Malek open the door by telling him for each '#' character how many ')' characters he must replace it with.","The first line of the input contains a string *s* (1<=≤<=|*s*|<=≤<=105). Each character of this string is one of the characters '(', ')' or '#'. It is guaranteed that *s* contains at least one '#' character.","If there is no way of replacing '#' characters which leads to a beautiful string print <=-<=1. Otherwise for each character '#' print a separate line containing a positive integer, the number of ')' characters this character must be replaced with.

If there are several possible answers, you may output any of them.","['(((#)((#)\n', '()((#((#(#()\n', '#\n', '(#)\n']","['1\n2\n', '2\n2\n1', '-1\n', '-1\n']",|*s*| denotes the length of the string *s*.,WRONG_ANSWER,"s = input()

count = 0
store = 0
first = True
ans = False
for c in s:
    if c == ""("":
        count += 1
    elif c == "")"":
        if store == 0 or count > 0:
            count -= 1
        else:
            store -= 1
        if count < 0:
            print(-1)
            ans = True
            break
    else:
        if not first:
            print(store)
        store = count
        count = 0
        first = False
if not ans:
    if store == 0:
        print(-1)
    else:
        print(store)
  	  	        		 			 	  	   			","def dijkstra(start, end):
        # Distance array to keep track of the shortest path to each vertex
        dist = [float('inf')] * (n + 1)
        dist[start] = 0
        # Priority queue for vertices to explore
        pq = [(0, start)]
        # Tracking the path
        prev = [-1] * (n + 1)

        while pq:
            current_dist, current_vertex = heappop(pq)

            # If we reached the end vertex, reconstruct the path
            if current_vertex == end:
                break
            
            # Skip processed nodes
            if current_dist > dist[current_vertex]:
                continue

            for neighbor, weight in g[current_vertex]:
                distance = current_dist + weight

                # Update if a shorter path is found
                if distance < dist[neighbor]:
                    dist[neighbor] = distance
                    prev[neighbor] = current_vertex
                    heappush(pq, (distance, neighbor))
        
        # If we never reached the end vertex, return -1
        if dist[end] == float('inf'):
            return -1

        # Reconstruct the shortest path
        path = []
        current = end
        while current != -1:
            path.append(current)
            current = prev[current]
        path.reverse()

        return dist[end], path

    # Find the shortest path from vertex 1 to vertex n
    shortest_path_length, path = dijkstra(1, n)
    
    if shortest_path_length == -1:
        print(-1)
    else:
        print(shortest_path_length)
        print(' '.join(map(str, path)))

if __name__ == ""__main__"":
    main()"
686,A,Free Ice Cream,PROGRAMMING,"['constructive algorithms', 'implementation']","After their adventure with the magic mirror Kay and Gerda have returned home and sometimes give free ice cream to kids in the summer.

At the start of the day they have *x* ice cream packs. Since the ice cream is free, people start standing in the queue before Kay and Gerda's house even in the night. Each person in the queue wants either to take several ice cream packs for himself and his friends or to give several ice cream packs to Kay and Gerda (carriers that bring ice cream have to stand in the same queue).

If a carrier with *d* ice cream packs comes to the house, then Kay and Gerda take all his packs. If a child who wants to take *d* ice cream packs comes to the house, then Kay and Gerda will give him *d* packs if they have enough ice cream, otherwise the child will get no ice cream at all and will leave in distress.

Kay wants to find the amount of ice cream they will have after all people will leave from the queue, and Gerda wants to find the number of distressed kids.","The first line contains two space-separated integers *n* and *x* (1<=≤<=*n*<=≤<=1000, 0<=≤<=*x*<=≤<=109).

Each of the next *n* lines contains a character '+' or '-', and an integer *d**i*, separated by a space (1<=≤<=*d**i*<=≤<=109). Record ""+ *d**i*"" in *i*-th line means that a carrier with *d**i* ice cream packs occupies *i*-th place from the start of the queue, and record ""- *d**i*"" means that a child who wants to take *d**i* packs stands in *i*-th place.","Print two space-separated integers — number of ice cream packs left after all operations, and number of kids that left the house in distress.","['5 7\n+ 5\n- 10\n- 20\n+ 40\n- 20\n', '5 17\n- 16\n- 2\n- 98\n+ 100\n- 98\n']","['22 1\n', '3 2\n']","Consider the first sample.
 1.  Initially Kay and Gerda have 7 packs of ice cream. 1.  Carrier brings 5 more, so now they have 12 packs. 1.  A kid asks for 10 packs and receives them. There are only 2 packs remaining. 1.  Another kid asks for 20 packs. Kay and Gerda do not have them, so the kid goes away distressed. 1.  Carrier bring 40 packs, now Kay and Gerda have 42 packs. 1.  Kid asks for 20 packs and receives them. There are 22 packs remaining.",OK,"pCount , iCount = list(map(int,input().split()))

sadPpl = 0

for _ in range(pCount) :
    info = input()
    operator = info[:1]
    num = int(info[2:])
    if operator == ""+"" : iCount += num 
    else :
        if iCount >= num:
            iCount -= num
        else :
            sadPpl += 1
            
print(iCount , sadPpl)","from typing import List, Union
from collections import namedtuple
import sys
import traceback
from time import perf_counter


class Solution:
    def count_QAQ(self, s: str) -> int:
        count = 0  # Initialize count of ""QAQ"" subsequences
        n = len(s)  # Length of the string
        
        # Iterate through the string to find ""QAQ"" subsequences
        for i in range(n):
            if s[i] == 'Q':  # Find the first 'Q'
                for j in range(i + 1, n):
                    if s[j] == 'A':  # Find 'A' after 'Q'
                        for k in range(j + 1, n):
                            if s[k] == 'Q':  # Find second 'Q' after 'A'
                                count += 1  # Increment count for each ""QAQ"" found
        
        return count  # Return the total count of ""QAQ""

# Example usage
# solution = Solution()
# print(solution.count_QAQ(""QAQAQYSYIOIWIN""))  # Expected output is 4"
467,A,George and Accommodation,PROGRAMMING,['implementation'],"George has recently entered the BSUCP (Berland State University for Cool Programmers). George has a friend Alex who has also entered the university. Now they are moving into a dormitory. 

George and Alex want to live in the same room. The dormitory has *n* rooms in total. At the moment the *i*-th room has *p**i* people living in it and the room can accommodate *q**i* people in total (*p**i*<=≤<=*q**i*). Your task is to count how many rooms has free place for both George and Alex.","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=100) — the number of rooms.

The *i*-th of the next *n* lines contains two integers *p**i* and *q**i* (0<=≤<=*p**i*<=≤<=*q**i*<=≤<=100) — the number of people who already live in the *i*-th room and the room's capacity.",Print a single integer — the number of rooms where George and Alex can move in.,"['3\n1 1\n2 2\n3 3\n', '3\n1 10\n0 10\n10 10\n']","['0\n', '2\n']",none,OK,"n = int(input())

count = 0
while n > 0:
    p, q = list(map(int, input().split("" "")))
    if q - p >= 2:
        count+=1
    n-=1
print(count)","a = input()
b = input()
m = {}

def dist(s):
    # Calculate the Hamming distance between strings a and s
    return sum(1 for x, y in zip(a, s) if x != y)

result = 0
# Length of string a
len_a = len(a)

# Iterate over all substrings of b of length len_a
for i in range(len(b) - len_a + 1):
    # Get the substring of b
    substring_b = b[i:i + len_a]
    # Calculate the distance and add it to the result
    result += dist(substring_b)

# Print the total Hamming distance
print(result)"
433,A,Kitahara Haruki's Gift,PROGRAMMING,"['brute force', 'implementation']","Kitahara Haruki has bought *n* apples for Touma Kazusa and Ogiso Setsuna. Now he wants to divide all the apples between the friends.

Each apple weights 100 grams or 200 grams. Of course Kitahara Haruki doesn't want to offend any of his friend. Therefore the total weight of the apples given to Touma Kazusa must be equal to the total weight of the apples given to Ogiso Setsuna.

But unfortunately Kitahara Haruki doesn't have a knife right now, so he cannot split any apple into some parts. Please, tell him: is it possible to divide all the apples in a fair way between his friends?","The first line contains an integer *n* (1<=≤<=*n*<=≤<=100) — the number of apples. The second line contains *n* integers *w*1,<=*w*2,<=...,<=*w**n* (*w**i*<==<=100 or *w**i*<==<=200), where *w**i* is the weight of the *i*-th apple.","In a single line print ""YES"" (without the quotes) if it is possible to divide all the apples between his friends. Otherwise print ""NO"" (without the quotes).","['3\n100 200 100\n', '4\n100 100 100 200\n']","['YES\n', 'NO\n']",In the first test sample Kitahara Haruki can give the first and the last apple to Ogiso Setsuna and the middle apple to Touma Kazusa.,WRONG_ANSWER,"import sys
from os import path
if (path.exists('input.txt')):
	sys.stdin = open('input.txt', 'r')
	sys.stdout = open('output.txt','w')

n = int(input())
arr = [int(x) for x in input().split()]
c1 = c2 = 0
for i in arr:
	if i==100: c1+= 1
	else: c2+= 2
print('YES' if abs(c1-c2)%2==0 else 'NO')","from sys import*
def square(a):
    k = min(a)
    total_painted = 0
    n = len(a)

    # Iterate through each color to find the maximum possible squares
    for start_color in range(n):
        current_color = start_color
        current_paint = a[current_color]
        painted_count = 0
        
        while current_paint > 0:
            painted_count += current_paint  # Paint all available liters of the current color
            current_color = (current_color + 1) % n  # Move to the next color
            current_paint = a[current_color]  # Get the paint available for the next color
    
        total_painted = max(total_painted, painted_count)

    return total_painted

# Input reading
n = int(input())
a = list(map(int, input().split()))
print(square(a))"
350,C,Bombs,PROGRAMMING,"['greedy', 'implementation', 'sortings']","You've got a robot, its task is destroying bombs on a square plane. Specifically, the square plane contains *n* bombs, the *i*-th bomb is at point with coordinates (*x**i*,<=*y**i*). We know that no two bombs are at the same point and that no bomb is at point with coordinates (0,<=0). Initially, the robot is at point with coordinates (0,<=0). Also, let's mark the robot's current position as (*x*,<=*y*). In order to destroy all the bombs, the robot can perform three types of operations:
 1.  Operation has format ""1 k dir"". To perform the operation robot have to move in direction *dir* *k* (*k*<=≥<=1) times. There are only 4 directions the robot can move in: ""R"", ""L"", ""U"", ""D"". During one move the robot can move from the current point to one of following points: (*x*<=+<=1,<=*y*), (*x*<=-<=1,<=*y*), (*x*,<=*y*<=+<=1), (*x*,<=*y*<=-<=1) (corresponding to directions). It is forbidden to move from point (*x*,<=*y*), if at least one point on the path (besides the destination point) contains a bomb. 1.  Operation has format ""2"". To perform the operation robot have to pick a bomb at point (*x*,<=*y*) and put it in a special container. Thus, the robot can carry the bomb from any point to any other point. The operation cannot be performed if point (*x*,<=*y*) has no bomb. It is forbidden to pick a bomb if the robot already has a bomb in its container. 1.  Operation has format ""3"". To perform the operation robot have to take a bomb out of the container and destroy it. You are allowed to perform this operation only if the robot is at point (0,<=0). It is forbidden to perform the operation if the container has no bomb. 
Help the robot and find the shortest possible sequence of operations he can perform to destroy all bombs on the coordinate plane.","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=105) — the number of bombs on the coordinate plane. Next *n* lines contain two integers each. The *i*-th line contains numbers (*x**i*,<=*y**i*) (<=-<=109<=≤<=*x**i*,<=*y**i*<=≤<=109) — the coordinates of the *i*-th bomb. It is guaranteed that no two bombs are located at the same point and no bomb is at point (0,<=0).","In a single line print a single integer *k* — the minimum number of operations needed to destroy all bombs. On the next lines print the descriptions of these *k* operations. If there are multiple sequences, you can print any of them. It is guaranteed that there is the solution where *k*<=≤<=106.","['2\n1 1\n-1 -1\n', '3\n5 0\n0 5\n1 0\n']","['12\n1 1 R\n1 1 U\n2\n1 1 L\n1 1 D\n3\n1 1 L\n1 1 D\n2\n1 1 R\n1 1 U\n3\n', '12\n1 1 R\n2\n1 1 L\n3\n1 5 R\n2\n1 5 L\n3\n1 5 U\n2\n1 5 D\n3\n']",none,WRONG_ANSWER,"n = int(input())
s =[]
for i in range(n):
    l = list(map(int, input().split()))
    s.append(l)
s.sort()
num = 0
op = []
for i in range(n):
    x = s[i][0]
    y = s[i][1]
    if y == 0:
        num += 4
        l1 = [str(1), str(x), 'R']
        l2 = ['2']
        l3 = [str(1), str(x), 'L']
        l4 = ['3']
        op.append(l1)
        op.append(l2)
        op.append(l3)
        op.append(l4)
    elif x == 0:
        num += 4
        l1 = [str(1), str(y), 'U']
        l2 = ['2']
        l3 = [str(1), str(y), 'D']
        l4 = ['3']
        op.append(l1)
        op.append(l2)
        op.append(l3)
        op.append(l4)
    else:
        num += 6
        l1 = [str(1), str(x), 'R']
        l2 = [str(1), str(y), 'U']
        l3 = ['2']
        l4 = [str(1), str(y), 'D']
        l5 = [str(1), str(x), 'L']
        l6 = ['3']
        op.append(l1)
        op.append(l2)
        op.append(l3)
        op.append(l4)
        op.append(l5)
        op.append(l6)
print(num)
for i in range(len(op)):
    print(' '.join(op[i]))



","def f(s, slovo):
    if slovo == """":
        return True
    elif s == """":
        return False
    # Check if the first characters match
    if s[0] == slovo[0]:
        return f(s[1:], slovo[1:])
    # Proceed to the next character in s
    return f(s[1:], slovo)

def can_say_hello(s):
    return f(s, ""hello"")

# Input the string from user
s = input().strip()

# Check if Vasya managed to say hello
if can_say_hello(s):
    print(""YES"")
else:
    print(""NO"")"
835,A,Key races,PROGRAMMING,['math'],"Two boys decided to compete in text typing on the site ""Key races"". During the competition, they have to type a text consisting of *s* characters. The first participant types one character in *v*1 milliseconds and has ping *t*1 milliseconds. The second participant types one character in *v*2 milliseconds and has ping *t*2 milliseconds.

If connection ping (delay) is *t* milliseconds, the competition passes for a participant as follows: 
 1.  Exactly after *t* milliseconds after the start of the competition the participant receives the text to be entered. 1.  Right after that he starts to type it. 1.  Exactly *t* milliseconds after he ends typing all the text, the site receives information about it. 
The winner is the participant whose information on the success comes earlier. If the information comes from both participants at the same time, it is considered that there is a draw.

Given the length of the text and the information about participants, determine the result of the game.","The first line contains five integers *s*, *v*1, *v*2, *t*1, *t*2 (1<=≤<=*s*,<=*v*1,<=*v*2,<=*t*1,<=*t*2<=≤<=1000) — the number of characters in the text, the time of typing one character for the first participant, the time of typing one character for the the second participant, the ping of the first participant and the ping of the second participant.","If the first participant wins, print ""First"". If the second participant wins, print ""Second"". In case of a draw print ""Friendship"".","['5 1 2 1 2\n', '3 3 1 1 1\n', '4 5 3 1 5\n']","['First\n', 'Second\n', 'Friendship\n']","In the first example, information on the success of the first participant comes in 7 milliseconds, of the second participant — in 14 milliseconds. So, the first wins.

In the second example, information on the success of the first participant comes in 11 milliseconds, of the second participant — in 5 milliseconds. So, the second wins.

In the third example, information on the success of the first participant comes in 22 milliseconds, of the second participant — in 22 milliseconds. So, it is be a draw.",OK,"s,v1,v2,t1,t2=list(map(int,input().split()))
first=v1*s+2*t1 
second=v2*s+2*t2
if first<second:
    print('First')
elif first>second:
    print('Second')
else:
    print('Friendship')","# LUOGU_RID: 105867500
n = int(input())

# 筛法求素数
is_prime = [True] * (n + 2)
is_prime[0] = is_prime[1] = False
for i in range(2, int(n**0.5) + 1):
    if is_prime[i]:
        for j in range(i * i, n + 1, i):
            is_prime[j] = False

# 提取所有素数
primes = [i for i in range(2, n + 1) if is_prime[i]]

# 分配颜色
colors = [0] * (n + 1)
current_color = 1

# 对每个素数分配一种颜色
for prime in primes:
    if colors[prime] == 0:
        # 用current_color为prime及其倍数着色
        for multiple in range(prime, n + 1, prime):
            colors[multiple] = current_color
        current_color += 1

# 输出结果
print(current_color - 1)
print("" "".join(map(str, colors[2:])))"
546,A,Soldier and Bananas,PROGRAMMING,"['brute force', 'implementation', 'math']","A soldier wants to buy *w* bananas in the shop. He has to pay *k* dollars for the first banana, 2*k* dollars for the second one and so on (in other words, he has to pay *i*·*k* dollars for the *i*-th banana). 

He has *n* dollars. How many dollars does he have to borrow from his friend soldier to buy *w* bananas?","The first line contains three positive integers *k*,<=*n*,<=*w* (1<=<=≤<=<=*k*,<=*w*<=<=≤<=<=1000, 0<=≤<=*n*<=≤<=109), the cost of the first banana, initial number of dollars the soldier has and number of bananas he wants.","Output one integer — the amount of dollars that the soldier must borrow from his friend. If he doesn't have to borrow money, output 0.",['3 17 4\n'],['13'],none,OK,"
k,n,w = map(int, input().split())

cost = 0
for i in range(1, w+1):
    cost += i*k

if cost <= n:
    print(0)
else:
    print(cost - n)

","def solve(n):
    t = []
    i = 1
    while i * i <= n:
        if n % i == 0:
            t.append(i)  # Add the divisor i
            if i != n // i:
                t.append(n // i)  # Add the corresponding divisor n // i
        i += 1
    
    # Function to check if a number is lovely
    def is_lovely(x):
        for j in range(2, int(x**0.5) + 1):
            if x % (j * j) == 0:
                return False  # x is divisible by a perfect square
        return True  # x is lovely
    
    # Find the largest lovely number
    largest_lovely = 1  # 1 is always lovely
    for num in t:
        if is_lovely(num) and num > largest_lovely:
            largest_lovely = num
    
    print(largest_lovely)

# Example input to test the function
n = int(input())
solve(n)"
762,B,USB vs. PS/2,PROGRAMMING,"['greedy', 'implementation', 'sortings', 'two pointers']","Due to the increase in the number of students of Berland State University it was decided to equip a new computer room. You were given the task of buying mouses, and you have to spend as little as possible. After all, the country is in crisis!

The computers bought for the room were different. Some of them had only USB ports, some — only PS/2 ports, and some had both options.

You have found a price list of a certain computer shop. In it, for *m* mouses it is specified the cost and the type of the port that is required to plug the mouse in (USB or PS/2). Each mouse from the list can be bought at most once.

You want to buy some set of mouses from the given price list in such a way so that you maximize the number of computers equipped with mouses (it is not guaranteed that you will be able to equip all of the computers), and in case of equality of this value you want to minimize the total cost of mouses you will buy.","The first line contains three integers *a*, *b* and *c* (0<=≤<=*a*,<=*b*,<=*c*<=≤<=105)  — the number of computers that only have USB ports, the number of computers, that only have PS/2 ports, and the number of computers, that have both options, respectively.

The next line contains one integer *m* (0<=≤<=*m*<=≤<=3·105)  — the number of mouses in the price list.

The next *m* lines each describe another mouse. The *i*-th line contains first integer *val**i* (1<=≤<=*val**i*<=≤<=109)  — the cost of the *i*-th mouse, then the type of port (USB or PS/2) that is required to plug the mouse in.",Output two integers separated by space — the number of equipped computers and the total cost of the mouses you will buy.,['2 1 1\n4\n5 USB\n6 PS/2\n3 PS/2\n7 PS/2\n'],['3 14\n'],"In the first example you can buy the first three mouses. This way you will equip one of the computers that has only a USB port with a USB mouse, and the two PS/2 mouses you will plug into the computer with PS/2 port and the computer with both ports.",RUNTIME_ERROR,"t=1
while t>0:
    t-=1
    a,b,c=(int(_) for _ in input().strip().split(' '))
    n=int(input())
    u=[]
    p=[]
    cnt1=0
    cnt2=0
    for i in range(n):
        x=int(input().split(' '))
        s=input()
        if s==""USB"":
            u.append(x)
            cnt1+=1
        if s==""PS/2"":
            p.append(x)
            cnt2+=1
    u.sort()
    p.sort()
    ans=min(a,cnt1)+min(b,cnt2)+min(c,max(cnt1-a,0)+max(cnt2-b,0))
    val=0
    for i in range(min(a,cnt1)):
        val+=u[i]
    for i in range(min(b,cnt2)):
        val+=p[i]
    pos1=min(a,cnt1)
    pos2=min(b,cnt2)
    while c!=0:
        if cnt1-a>0 and cnt2-b>0:
            if u[pos1]<=p[pos2]:
                val+=u[pos1]
                pos1+=1
            else:
                val+=p[pos2]
                pos2+=1
        else:
            if cnt1-a>0:
                val+=u[pos1]
                pos1+=1
            if cnt2-b>0:
                val+=p[pos2]
                pos2+=1
            if cnt1-a<=0 and cnt2-b<=0:
                break
    print(ans,end=' ')
    print(val)","from collections import defaultdict, deque, Counter
from functools import lru_cache, reduce 
from heapq import heappush, heappop, heapify
from bisect import bisect_right, bisect_left
from random import randint
import math
import operator
import sys

n, k, d = map(int, input().split())

# Calculate the maximum number of unique combinations of buses over d days
max_friend_pairs = k ** d

# If the number of students exceeds the max unique combinations, return -1
if n > max_friend_pairs:
    print(-1)
else:
    result = [[0] * n for _ in range(d)]  # Initialize the result array

    for i in range(n):
        for day in range(d):
            # Determine which bus to assign for the i-th student on the i-th day
            bus = (i // (k ** day)) % k + 1
            result[day][i] = bus

    # Print the result for each day
    for day in result:
        print(' '.join(map(str, day)))"
59,A,Word,PROGRAMMING,"['implementation', 'strings']","Vasya is very upset that many people on the Net mix uppercase and lowercase letters in one word. That's why he decided to invent an extension for his favorite browser that would change the letters' register in every word so that it either only consisted of lowercase letters or, vice versa, only of uppercase ones. At that as little as possible letters should be changed in the word. For example, the word HoUse must be replaced with house, and the word ViP — with VIP. If a word contains an equal number of uppercase and lowercase letters, you should replace all the letters with lowercase ones. For example, maTRIx should be replaced by matrix. Your task is to use the given method on one given word.",The first line contains a word *s* — it consists of uppercase and lowercase Latin letters and possesses the length from 1 to 100.,"Print the corrected word *s*. If the given word *s* has strictly more uppercase letters, make the word written in the uppercase register, otherwise - in the lowercase one.","['HoUse\n', 'ViP\n', 'maTRIx\n']","['house\n', 'VIP\n', 'matrix\n']",none,OK,"s = input()
uc = lc = 0

for c in s:
    if c.islower():
        lc+=1
    else:
        uc+=1
if lc>=uc:
    print(s.lower())
else:
    print(s.upper())","def solve():
    n = list(input().strip())
    m = list(input().strip())
    
    # Sort the digits of n to form the smallest possible number
    n_sorted = sorted(n)
    
    # Handle leading zeroes
    if n_sorted[0] == '0':
        for i in range(1, len(n_sorted)):
            if n_sorted[i] != '0':
                # Swap the first non-zero digit with the leading zero
                n_sorted[0], n_sorted[i] = n_sorted[i], n_sorted[0]
                break
    
    # Join the sorted digits to form the smallest number
    smallest_number = ''.join(n_sorted)
    
    # Check if Bob's answer is correct
    if smallest_number == m:
        print(""OK"")
    else:
        print(""WRONG_ANSWER"")"
394,A,Counting Sticks,PROGRAMMING,"['brute force', 'implementation']","When new students come to the Specialized Educational and Scientific Centre (SESC) they need to start many things from the beginning. Sometimes the teachers say (not always unfairly) that we cannot even count. So our teachers decided to teach us arithmetics from the start. And what is the best way to teach students add and subtract? — That's right, using counting sticks! An here's our new task: 

An expression of counting sticks is an expression of type:

Sign + consists of two crossed sticks: one vertical and one horizontal. Sign = consists of two horizontal sticks. The expression is arithmetically correct if *A*<=+<=*B*<==<=*C*.

We've got an expression that looks like *A*<=+<=*B*<==<=*C* given by counting sticks. Our task is to shift at most one stick (or we can shift nothing) so that the expression became arithmetically correct. Note that we cannot remove the sticks from the expression, also we cannot shift the sticks from the signs + and =.

We really aren't fabulous at arithmetics. Can you help us?","The single line contains the initial expression. It is guaranteed that the expression looks like *A*<=+<=*B*<==<=*C*, where 1<=≤<=*A*,<=*B*,<=*C*<=≤<=100.","If there isn't a way to shift the stick so the expression becomes correct, print on a single line ""Impossible"" (without the quotes). If there is a way, print the resulting expression. Follow the format of the output from the test samples. Don't print extra space characters.

If there are multiple correct answers, print any of them. For clarifications, you are recommended to see the test samples.","['||+|=|||||\n', '|||||+||=||\n', '|+|=||||||\n', '||||+||=||||||\n']","['|||+|=||||\n', 'Impossible\n', 'Impossible\n', '||||+||=||||||\n']","In the first sample we can shift stick from the third group of sticks to the first one.

In the second sample we cannot shift vertical stick from + sign to the second group of sticks. So we cannot make a - sign.

There is no answer in the third sample because we cannot remove sticks from the expression.

In the forth sample the initial expression is already arithmetically correct and that is why we don't have to shift sticks.",WRONG_ANSWER,"n = input()
a, b, c, d = 0, 0, 0, 1
for i in n:
    if i == '+':
        d = 2
    elif i == '=':
        d = 3
    elif d == 1:
        a += 1
    elif d == 2:
        b += 1
    else:
        c += 1
if a + b == c:
    print(n)
elif abs(c - ((a + b + c) // 2)) == 1:
    print('|' * a + '+' + '|' * (b + (c - ((a + b + c) // 2))) + '=' + '|' * (c - (c - ((a + b + c) // 2))))
else:
    print('Impossible')
","import heapq
n = int(input())
ara = list(map(int, input().split()))

mp = {}
ans = []
pq = []

# Counting the frequency of each radius
for r in ara:
    if r in mp:
        mp[r] += 1
    else:
        mp[r] = 1

# Adding unique radii to priority queue
for radius in mp:
    heapq.heappush(pq, radius)

# Creating snowmen while we can
while len(pq) >= 3:
    # Get the three smallest unique radii
    first = heapq.heappop(pq)
    second = heapq.heappop(pq)
    third = heapq.heappop(pq)

    # Append the snowman configuration
    ans.append((first, second, third))

    # Decrease the count and push back if there's more left
    for r in (first, second, third):
        if mp[r] > 1:
            mp[r] -= 1
            heapq.heappush(pq, r)

# Output the result
print(len(ans))
for snowman in ans:
    print(*snowman)"
17,A,Noldbach problem,PROGRAMMING,"['brute force', 'math', 'number theory']","Nick is interested in prime numbers. Once he read about Goldbach problem. It states that every even integer greater than 2 can be expressed as the sum of two primes. That got Nick's attention and he decided to invent a problem of his own and call it Noldbach problem. Since Nick is interested only in prime numbers, Noldbach problem states that at least *k* prime numbers from 2 to *n* inclusively can be expressed as the sum of three integer numbers: two neighboring prime numbers and 1. For example, 19 = 7 + 11 + 1, or 13 = 5 + 7 + 1.

Two prime numbers are called neighboring if there are no other prime numbers between them.

You are to help Nick, and find out if he is right or wrong.",The first line of the input contains two integers *n* (2<=≤<=*n*<=≤<=1000) and *k* (0<=≤<=*k*<=≤<=1000).,Output YES if at least *k* prime numbers from 2 to *n* inclusively can be expressed as it was described above. Otherwise output NO.,"['27 2\n', '45 7\n']","['YES', 'NO']","In the first sample the answer is YES since at least two numbers can be expressed as it was described (for example, 13 and 19). In the second sample the answer is NO since it is impossible to express 7 prime numbers from 2 to 45 in the desired form.",WRONG_ANSWER,"# Hydro submission #6514123610f69f159c4e63ec@1695814198877
print('YES')","n = int(input())
l = list(map(int, input().split()))
sum = 0

def check(l, k):
    # Calculate the number of moves needed to make 
    # the first k elements equal to zero
    moves = 0
    for i in range(k):
        # For each element, calculate the moves required
        if l[i] > 0:
            moves += l[i]  # We need 'l[i]' moves to reduce a_i to zero
            # Also, we check if we can use some of the 0s from previous moves
            if i > 0 and l[i-1] > 0:
                # Subtract the surplus that can help in the next step
                moves -= min(l[i-1], l[i])
    return moves

results = []
for k in range(1, n + 1):
    result = check(l, k)
    results.append(result)

# Output the results for each k
for res in results:
    print(res)"
698,A,Vacations,PROGRAMMING,['dp'],"Vasya has *n* days of vacations! So he decided to improve his IT skills and do sport. Vasya knows the following information about each of this *n* days: whether that gym opened and whether a contest was carried out in the Internet on that day. For the *i*-th day there are four options:
 1.  on this day the gym is closed and the contest is not carried out; 1.  on this day the gym is closed and the contest is carried out; 1.  on this day the gym is open and the contest is not carried out; 1.  on this day the gym is open and the contest is carried out. 
On each of days Vasya can either have a rest or write the contest (if it is carried out on this day), or do sport (if the gym is open on this day).

Find the minimum number of days on which Vasya will have a rest (it means, he will not do sport and write the contest at the same time). The only limitation that Vasya has — he does not want to do the same activity on two consecutive days: it means, he will not do sport on two consecutive days, and write the contest on two consecutive days.","The first line contains a positive integer *n* (1<=≤<=*n*<=≤<=100) — the number of days of Vasya's vacations.

The second line contains the sequence of integers *a*1,<=*a*2,<=...,<=*a**n* (0<=≤<=*a**i*<=≤<=3) separated by space, where: 
 -  *a**i* equals 0, if on the *i*-th day of vacations the gym is closed and the contest is not carried out; -  *a**i* equals 1, if on the *i*-th day of vacations the gym is closed, but the contest is carried out; -  *a**i* equals 2, if on the *i*-th day of vacations the gym is open and the contest is not carried out; -  *a**i* equals 3, if on the *i*-th day of vacations the gym is open and the contest is carried out.","Print the minimum possible number of days on which Vasya will have a rest. Remember that Vasya refuses:
 -  to do sport on any two consecutive days, -  to write the contest on any two consecutive days.","['4\n1 3 2 0\n', '7\n1 3 3 2 1 2 3\n', '2\n2 2\n']","['2\n', '0\n', '1\n']","In the first test Vasya can write the contest on the day number 1 and do sport on the day number 3. Thus, he will have a rest for only 2 days.

In the second test Vasya should write contests on days number 1, 3, 5 and 7, in other days do sport. Thus, he will not have a rest for a single day.

In the third test Vasya can do sport either on a day number 1 or number 2. He can not do sport in two days, because it will be contrary to the his limitation. Thus, he will have a rest for only one day.",OK,"n = int(input())
act = [int(i) for i in input().split()]
rest = 0
curr = 0
for e in act:
    if e == 0:
        rest += 1
        curr = 0
    elif e == 1:
        if curr == 0 or curr == 1:
            curr = -1
        else:
            rest += 1
            curr = 0
    elif e == 2:
        if curr == 0 or curr == -1:
            curr = 1
        else:
            rest += 1
            curr = 0
    else:
        if curr == 0:
            continue
        else:
            curr *= -1
print(rest)
","import math

def deezdragons(s, alist, blist):
    # Create a list of dragons as tuples (strength, bonus)
    dragons = sorted(zip(alist, blist))  # Sort dragons by their strength
    
    for dragon_strength, bonus in dragons:
        # Check if Kirito's strength is less than the dragon's strength
        if s < dragon_strength:
            return ""NO""  # Kirito cannot defeat this dragon
        # Kirito defeats the dragon and gains bonus strength
        s += bonus
        
    return ""YES""  # Kirito defeated all dragons

# Input reading
s, n = map(int, input().split())
alist = []
blist = []
for _ in range(n):
    x, y = map(int, input().split())
    alist.append(x)
    blist.append(y)

# Function call and output
print(deezdragons(s, alist, blist))"
18,D,Seller Bob,PROGRAMMING,"['brute force', 'dp', 'greedy']","Last year Bob earned by selling memory sticks. During each of *n* days of his work one of the two following events took place: 
 -  A customer came to Bob and asked to sell him a 2*x* MB memory stick. If Bob had such a stick, he sold it and got 2*x* berllars. -  Bob won some programming competition and got a 2*x* MB memory stick as a prize. Bob could choose whether to present this memory stick to one of his friends, or keep it. 
Bob never kept more than one memory stick, as he feared to mix up their capacities, and deceive a customer unintentionally. It is also known that for each memory stick capacity there was at most one customer, who wanted to buy that memory stick. Now, knowing all the customers' demands and all the prizes won at programming competitions during the last *n* days, Bob wants to know, how much money he could have earned, if he had acted optimally.",The first input line contains number *n* (1<=≤<=*n*<=≤<=5000) — amount of Bob's working days. The following *n* lines contain the description of the days. Line sell x stands for a day when a customer came to Bob to buy a 2*x* MB memory stick (0<=≤<=*x*<=≤<=2000). It's guaranteed that for each *x* there is not more than one line sell x. Line win x stands for a day when Bob won a 2*x* MB memory stick (0<=≤<=*x*<=≤<=2000).,"Output the maximum possible earnings for Bob in berllars, that he would have had if he had known all the events beforehand. Don't forget, please, that Bob can't keep more than one memory stick at a time.","['7\nwin 10\nwin 5\nwin 3\nsell 5\nsell 3\nwin 10\nsell 10\n', '3\nwin 5\nsell 6\nsell 4\n']","['1056\n', '0\n']",none,OK,"# Saw Answer

n = int(input())
sell = dict()
win = dict()
c = []

for i in range(n):
    s, v = input().split()
    v = int(v) + 1
    c.append(v)
    if s[0] == ""s"":
        c[i] *= -1
        sell[v] = i
    else:
        if v not in win:
            win[v] = list()
        win[v].append(i)
ans = 0
for i in sorted(sell.keys(), reverse=True):
    if i not in win:
        continue
    while len(win[i]) and win[i][-1] > sell[i]:
        win[i].pop()
    if len(win[i]):
        if all(c[j] for j in range(win[i][-1], sell[i] + 1)):
            for j in range(win[i][-1], sell[i] + 1):
                c[j] = 0
            ans += 2 ** (i - 1)
print(ans)
","from sys import stdin as sin

def aint(): return int(sin.readline())
def amap(): return map(int, sin.readline().split())
def alist(): return list(map(int, sin.readline().split()))
def astr(): return str(sin.readline().split())

l, r = amap()
d = [4, 7]

# Function to find the next lucky number greater than or equal to x
def next_lucky(x):
    # Convert x to string to manipulate digits
    s = str(x)
    n = len(s)
    # We will build the next lucky number
    result = []
    found = False

    for i in range(n):
        if found:
            # Always append the smallest lucky number (4)
            result.append(4)
        else:
            if s[i] < '4':
                result.append('4')
                found = True
                # After the first lucky digit, fill with '4's
                result.extend(['4'] * (n - i - 1))
                break
            elif s[i] < '7':
                result.append('7')
                found = True
                # After the first lucky digit, fill with '4's
                result.extend(['4'] * (n - i - 1))
                break
            elif s[i] > '7':
                # We need to backtrack to find a correct place to change
                for j in range(i - 1, -1, -1):
                    if result[j] == '4':
                        result[j] = '7'
                        result = result[:j + 1] + ['4'] * (n - j - 1)
                        found = True
                        break
                    elif result[j] == '7':
                        continue
                if not found:
                    result = ['4'] * (n + 1)  # Handle case like 1000
                break
            # If we are at '4' or '7', continue
            result.append(s[i])

    if not found:
        # If we never found any digit to replace, the number is lucky
        result = list(s)

    return int(''.join(result))

# Calculate the sum of lucky numbers in the range [l, r]
total_sum = 0
for x in range(l, r + 1):
    total_sum += next_lucky(x)

print(total_sum)"
740,A,Alyona and copybooks,PROGRAMMING,"['brute force', 'implementation']","Little girl Alyona is in a shop to buy some copybooks for school. She study four subjects so she wants to have equal number of copybooks for each of the subjects. There are three types of copybook's packs in the shop: it is possible to buy one copybook for *a* rubles, a pack of two copybooks for *b* rubles, and a pack of three copybooks for *c* rubles. Alyona already has *n* copybooks.

What is the minimum amount of rubles she should pay to buy such number of copybooks *k* that *n*<=+<=*k* is divisible by 4? There are infinitely many packs of any type in the shop. Alyona can buy packs of different type in the same purchase.","The only line contains 4 integers *n*, *a*, *b*, *c* (1<=≤<=*n*,<=*a*,<=*b*,<=*c*<=≤<=109).",Print the minimum amount of rubles she should pay to buy such number of copybooks *k* that *n*<=+<=*k* is divisible by 4.,"['1 1 3 4\n', '6 2 1 1\n', '4 4 4 4\n', '999999999 1000000000 1000000000 1000000000\n']","['3\n', '1\n', '0\n', '1000000000\n']","In the first example Alyona can buy 3 packs of 1 copybook for 3*a* = 3 rubles in total. After that she will have 4 copybooks which she can split between the subjects equally. 

In the second example Alyuna can buy a pack of 2 copybooks for *b* = 1 ruble. She will have 8 copybooks in total.

In the third example Alyona can split the copybooks she already has between the 4 subject equally, so she doesn't need to buy anything.

In the fourth example Alyona should buy one pack of one copybook.",WRONG_ANSWER,"#I:
n, a, b, c = map(int, input().split())
mod = n % 4
if n < 4:
    mod = n
elif n == 4:
    mod = 0
ans = []
if mod == 3:
    ans.append(a)
    ans.append(3*c)
    ans.append(3*b + c)
    print(min(ans))
elif mod == 2:
    ans.append(b)
    ans.append(2*a)
    ans.append(2*c)
    ans.append(c + 3*a)
    print(min(ans))
elif mod == 1:
    ans.append(c)
    ans.append(3*a)
    ans.append(b + a)
    print(min(ans))
else:
    print(0)","import math

# Function to check if a number is almost prime
def almostPrime(i):
    s = i
    count2 = 0
    for j in prime:
        if i % j == 0:
            count2 += 1
        # If two distinct prime factors found, return True
        if count2 > 2:
            return False
    return count2 == 2  # Return True if exactly two distinct prime factors

# Function to generate a list of prime numbers using Sieve of Eratosthenes
def sieve(n):
    is_prime = [True] * (n + 1)
    p = 2
    while (p * p <= n):
        if is_prime[p] == True:
            for i in range(p * p, n + 1, p):
                is_prime[i] = False
        p += 1
    return [p for p in range(2, n + 1) if is_prime[p]]

# Input reading
n = int(input().strip())
# Generate list of prime numbers up to n
prime = sieve(n)

# Count almost prime numbers between 1 and n
count_almost_primes = sum(1 for i in range(1, n + 1) if almostPrime(i))

# Output the result
print(count_almost_primes)"
551,A,GukiZ and Contest,PROGRAMMING,"['brute force', 'implementation', 'sortings']","Professor GukiZ likes programming contests. He especially likes to rate his students on the contests he prepares. Now, he has decided to prepare a new contest. 

In total, *n* students will attend, and before the start, every one of them has some positive integer rating. Students are indexed from 1 to *n*. Let's denote the rating of *i*-th student as *a**i*. After the contest ends, every student will end up with some positive integer position. GukiZ expects that his students will take places according to their ratings. 

He thinks that each student will take place equal to . In particular, if student *A* has rating strictly lower then student *B*, *A* will get the strictly better position than *B*, and if two students have equal ratings, they will share the same position. 

GukiZ would like you to reconstruct the results by following his expectations. Help him and determine the position after the end of the contest for each of his students if everything goes as expected.","The first line contains integer *n* (1<=≤<=*n*<=≤<=2000), number of GukiZ's students. 

The second line contains *n* numbers *a*1,<=*a*2,<=... *a**n* (1<=≤<=*a**i*<=≤<=2000) where *a**i* is the rating of *i*-th student (1<=≤<=*i*<=≤<=*n*).","In a single line, print the position after the end of the contest for each of *n* students in the same order as they appear in the input.","['3\n1 3 3\n', '1\n1\n', '5\n3 5 3 4 5\n']","['3 1 1\n', '1\n', '4 1 4 3 1\n']","In the first sample, students 2 and 3 are positioned first (there is no other student with higher rating), and student 1 is positioned third since there are two students with higher rating.

In the second sample, first student is the only one on the contest.

In the third sample, students 2 and 5 share the first position with highest rating, student 4 is next with third position, and students 1 and 3 are the last sharing fourth position.",RUNTIME_ERROR,"s
INF = 10**20
MOD = 10**9 + 7
from math import gcd
from math import ceil, log2, factorial
from collections import defaultdict as dd, Counter
from bisect import bisect_left as bl, bisect_right as br

def fastio():
  import sys
  from io import StringIO 
  from atexit import register
  global input
  sys.stdin = StringIO(sys.stdin.read())
  input = lambda : sys.stdin.readline().rstrip('\r\n')
  sys.stdout = StringIO()
  register(lambda : sys.__stdout__.write(sys.stdout.getvalue()))
fastio()

I = lambda:list(map(int,input().split()))
TESTS = 0
""""""
Facts and Data representation
Constructive? Top bottom up down
""""""
def solve():
  n, = I()
  a = I()
  a = [[a[i], i] for i in range(n)]

  a.sort(reverse=True)
  ans = [0] * n

  ans[a[0][1]] = 1
  cnt = 0
  for i in range(1, n):
    if (a[i][0] == a[i - 1][0]):
      ans[a[i][1]] = ans[a[i - 1][1]]
      cnt += 1
    else:
      ans[a[i][1]] = ans[a[i - 1][1]] + cnt + 1
      cnt = 0
  print(*ans)


def main():
  if not TESTS:
    solve()
    return

  t, = I()
  while t:
    solve()
    t -= 1

if __name__ == ""__main__"":
  main()","def microsoft():
    n, m = map(int, input().split())
    count = 0
    
    # Iterate through possible values of a from 0 to n
    for a in range(n + 1):
        # Iterate through possible values of b from 0 to m
        for b in range(m + 1):
            # Check if the pair (a, b) satisfies the conditions
            if a + b <= n and a - b >= 0:
                count += 1
                
    # Print the total count of valid pairs
    print(count)"
155,A,I_love_\%username\%,PROGRAMMING,['brute force'],"Vasya adores sport programming. He can't write programs but he loves to watch the contests' progress. Vasya even has a favorite coder and Vasya pays special attention to him.

One day Vasya decided to collect the results of all contests where his favorite coder participated and track the progress of his coolness. For each contest where this coder participated, he wrote out a single non-negative number — the number of points his favorite coder earned in the contest. Vasya wrote out the points for the contest in the order, in which the contests run (naturally, no two contests ran simultaneously).

Vasya considers a coder's performance in a contest amazing in two situations: he can break either his best or his worst performance record. First, it is amazing if during the contest the coder earns strictly more points that he earned on each past contest. Second, it is amazing if during the contest the coder earns strictly less points that he earned on each past contest. A coder's first contest isn't considered amazing. Now he wants to count the number of amazing performances the coder had throughout his whole history of participating in contests. But the list of earned points turned out long and Vasya can't code... That's why he asks you to help him.","The first line contains the single integer *n* (1<=≤<=*n*<=≤<=1000) — the number of contests where the coder participated.

The next line contains *n* space-separated non-negative integer numbers — they are the points which the coder has earned. The points are given in the chronological order. All points do not exceed 10000.",Print the single number — the number of amazing performances the coder has had during his whole history of participating in the contests.,"['5\n100 50 200 150 200\n', '10\n4664 6496 5814 7010 5762 5736 6944 4850 3698 7242\n']","['2\n', '4\n']","In the first sample the performances number 2 and 3 are amazing.

In the second sample the performances number 2, 4, 9 and 10 are amazing.",OK,"n = int(input())
numbers = list(map(int, input().split()))
best = worst = numbers[0]
amazing = 0

for current in numbers[1:]:
    if current < worst:
        worst = current
        amazing += 1
    if current > best:
        best = current
        amazing += 1

print(amazing)","def get_digit(n):
    return(len(str(n)))

def get_last(n):
    return n % 10
    
def get_first(n):
    m = str(n)
    return int(m[0])

def count_matching_digit_intervals(l, r):
    count = 0
    for x in range(l, r + 1):
        if get_first(x) == get_last(x):
            count += 1
    return count

# Read input
l, r = map(int, input().split())

# Output the result
print(count_matching_digit_intervals(l, r))"
142,A,Help Farmer,PROGRAMMING,"['brute force', 'math']","Once upon a time in the Kingdom of Far Far Away lived Sam the Farmer. Sam had a cow named Dawn and he was deeply attached to her. Sam would spend the whole summer stocking hay to feed Dawn in winter. Sam scythed hay and put it into haystack. As Sam was a bright farmer, he tried to make the process of storing hay simpler and more convenient to use. He collected the hay into cubical hay blocks of the same size. Then he stored the blocks in his barn. After a summer spent in hard toil Sam stored *A*·*B*·*C* hay blocks and stored them in a barn as a rectangular parallelepiped *A* layers high. Each layer had *B* rows and each row had *C* blocks.

At the end of the autumn Sam came into the barn to admire one more time the hay he'd been stacking during this hard summer. Unfortunately, Sam was horrified to see that the hay blocks had been carelessly scattered around the barn. The place was a complete mess. As it turned out, thieves had sneaked into the barn. They completely dissembled and took away a layer of blocks from the parallelepiped's front, back, top and sides. As a result, the barn only had a parallelepiped containing (*A*<=-<=1)<=×<=(*B*<=-<=2)<=×<=(*C*<=-<=2) hay blocks. To hide the evidence of the crime, the thieves had dissembled the parallelepiped into single 1<=×<=1<=×<=1 blocks and scattered them around the barn. After the theft Sam counted *n* hay blocks in the barn but he forgot numbers *A*, *B* и *C*.

Given number *n*, find the minimally possible and maximally possible number of stolen hay blocks.",The only line contains integer *n* from the problem's statement (1<=≤<=*n*<=≤<=109).,"Print space-separated minimum and maximum number of hay blocks that could have been stolen by the thieves.

Note that the answer to the problem can be large enough, so you must use the 64-bit integer type for calculations. Please, do not use the %lld specificator to read or write 64-bit integers in С++. It is preferred to use cin, cout streams or the %I64d specificator.","['4\n', '7\n', '12\n']","['28 41\n', '47 65\n', '48 105\n']","Let's consider the first sample test. If initially Sam has a parallelepiped consisting of 32 = 2 × 4 × 4 hay blocks in his barn, then after the theft the barn has 4 = (2 - 1) × (4 - 2) × (4 - 2) hay blocks left. Thus, the thieves could have stolen 32 - 4 = 28 hay blocks. If Sam initially had a parallelepiped consisting of 45 = 5 × 3 × 3 hay blocks in his barn, then after the theft the barn has 4 = (5 - 1) × (3 - 2) × (3 - 2) hay blocks left. Thus, the thieves could have stolen 45 - 4 = 41 hay blocks. No other variants of the blocks' initial arrangement (that leave Sam with exactly 4 blocks after the theft) can permit the thieves to steal less than 28 or more than 41 blocks.",TIME_LIMIT_EXCEEDED,"#!/usr/bin/env python3

# this solution convert variable to the following way
# n = x*y*z then find the minimum and maximum integer value
# of the following expression (x+1)*(y+2)*(z+2)

def int_sqrt(n):
    return int(n**(1/2))

def min_sum(prod):
    ms = prod + 1   # initial minimum possible sum
    for i in range(1, int_sqrt(prod) + 1):
        if prod % i == 0:
            s = i + prod/i
            if ms > s:
                ms = s
    return ms

def main():
    n = int(input())
    minp = 9*n+9    # initial minimum product
    maxp = 1
    for x in range(1, n+1):
        if n % x != 0:
            continue
        else:
            #  print(""x: "" + str(x), end = ', ')
            yz_prod = n/x
            #  print(""yz_prod: "" + str(yz_prod), end = ', ')
            # expression for minium product (x+1)*(y+2)*(z+2)
            ms = min_sum(yz_prod)
            mi_p = (yz_prod + 2*ms + 4)*(x + 1)
            #  print(""min_sum: "" + str(ms), end = ', ')
            #  print(""mi_p: "" + str(mi_p), end = ', ')
            ma_p = (yz_prod + 2*(yz_prod + 1) + 4)*(x + 1)
            #  print(""ma_p: "" + str(ma_p))
            if (mi_p < minp):
                minp = mi_p
            if (ma_p > maxp):
                maxp = ma_p
    print(str(int(minp - n)) + ' ' + str(int(maxp - n)))

if __name__ == '__main__':
    main()

","# -*- coding: utf-8 -*-
""""""
Created on Thu Apr  2 17:50:02 2020

@author: alexi
""""""

def is_palindrome(s):
    # Check if a string is a palindrome
    return s == s[::-1]

def longest_non_palindrome_substring(s):
    n = len(s)
    
    # If the entire string is a palindrome, further checks
    if is_palindrome(s):
        # Check if all characters are the same
        if s == s[0] * n:
            return 0  # All characters are the same, no non-palindrome substring
        
        return n - 1  # If not all characters are the same, the answer is len(s) - 1

    return n  # The entire string is not a palindrome

# Input string
s = input().strip()
# Get the result
result = longest_non_palindrome_substring(s)
# Print the result
print(result)"
69,A,Young Physicist,PROGRAMMING,"['implementation', 'math']","A guy named Vasya attends the final grade of a high school. One day Vasya decided to watch a match of his favorite hockey team. And, as the boy loves hockey very much, even more than physics, he forgot to do the homework. Specifically, he forgot to complete his physics tasks. Next day the teacher got very angry at Vasya and decided to teach him a lesson. He gave the lazy student a seemingly easy task: You are given an idle body in space and the forces that affect it. The body can be considered as a material point with coordinates (0; 0; 0). Vasya had only to answer whether it is in equilibrium. ""Piece of cake"" — thought Vasya, we need only to check if the sum of all vectors is equal to 0. So, Vasya began to solve the problem. But later it turned out that there can be lots and lots of these forces, and Vasya can not cope without your help. Help him. Write a program that determines whether a body is idle or is moving by the given vectors of forces.","The first line contains a positive integer *n* (1<=≤<=*n*<=≤<=100), then follow *n* lines containing three integers each: the *x**i* coordinate, the *y**i* coordinate and the *z**i* coordinate of the force vector, applied to the body (<=-<=100<=≤<=*x**i*,<=*y**i*,<=*z**i*<=≤<=100).","Print the word ""YES"" if the body is in equilibrium, or the word ""NO"" if it is not.","['3\n4 1 7\n-2 4 -1\n1 -5 -3\n', '3\n3 -1 7\n-5 2 -4\n2 -1 -3\n']","['NO', 'YES']",none,OK,"n=int(input())
a=0
b=0
c=0
for i in range(n):
    lst=list(map(int,input().split()))
    a+=lst[0]
    b+=lst[1]
    c+=lst[2]
if(a==0 and b==0 and c==0):
    print(""YES"")
else:
    print(""NO"")","def li(): return list(map(int,input().split())) 
def ls(): return list(map(int,list(input())))
def i():  return int(input())
from collections import defaultdict

graph = defaultdict(set)  # Use set to avoid duplicate friendships
n, m = li()

# Build the friendship graph
for _ in range(m):
    x, y = li()
    graph[x].add(y)
    graph[y].add(x)

# Check the reasonable condition
for x in graph:
    for y in graph[x]:
        for z in graph[y]:
            if z != x and z not in graph[x]:
                print(""NO"")
                exit()

print(""YES"")"
780,A,Andryusha and Socks,PROGRAMMING,['implementation'],"Andryusha is an orderly boy and likes to keep things in their place.

Today he faced a problem to put his socks in the wardrobe. He has *n* distinct pairs of socks which are initially in a bag. The pairs are numbered from 1 to *n*. Andryusha wants to put paired socks together and put them in the wardrobe. He takes the socks one by one from the bag, and for each sock he looks whether the pair of this sock has been already took out of the bag, or not. If not (that means the pair of this sock is still in the bag), he puts the current socks on the table in front of him. Otherwise, he puts both socks from the pair to the wardrobe.

Andryusha remembers the order in which he took the socks from the bag. Can you tell him what is the maximum number of socks that were on the table at the same time?","The first line contains the single integer *n* (1<=≤<=*n*<=≤<=105) — the number of sock pairs.

The second line contains 2*n* integers *x*1,<=*x*2,<=...,<=*x*2*n* (1<=≤<=*x**i*<=≤<=*n*), which describe the order in which Andryusha took the socks from the bag. More precisely, *x**i* means that the *i*-th sock Andryusha took out was from pair *x**i*.

It is guaranteed that Andryusha took exactly two socks of each pair.",Print single integer — the maximum number of socks that were on the table at the same time.,"['1\n1 1\n', '3\n2 1 1 3 2 3\n']","['1\n', '2\n']","In the first example Andryusha took a sock from the first pair and put it on the table. Then he took the next sock which is from the first pair as well, so he immediately puts both socks to the wardrobe. Thus, at most one sock was on the table at the same time.

In the second example Andryusha behaved as follows: 
 -  Initially the table was empty, he took out a sock from pair 2 and put it on the table. -  Sock (2) was on the table. Andryusha took out a sock from pair 1 and put it on the table. -  Socks (1, 2) were on the table. Andryusha took out a sock from pair 1, and put this pair into the wardrobe. -  Sock (2) was on the table. Andryusha took out a sock from pair 3 and put it on the table. -  Socks (2, 3) were on the table. Andryusha took out a sock from pair 2, and put this pair into the wardrobe. -  Sock (3) was on the table. Andryusha took out a sock from pair 3 and put this pair into the wardrobe.",OK,"input()
k=set()
ans=0
for i in tuple(map(int,input().split())):
     if i not in k:
          k.add(i)
          ans=max(len(k),ans)
     else:
          k.remove(i)
print(ans)
          
     
          
     
     
          
          
     
","# https://codeforces.com/contest/464/problem/E

import heapq

def dijkstra(adj_list, start, target):
    n = len(adj_list)
    distance = [float('inf')] * n
    prev = [-1] * n
    distance[start] = 0
    pq = [(0, start)]  # (distance, vertex)

    while pq:
        current_distance, u = heapq.heappop(pq)

        if current_distance > distance[u]:
            continue
        
        for weight, v in adj_list[u]:
            new_distance = current_distance + weight
            if new_distance < distance[v]:
                distance[v] = new_distance
                prev[v] = u
                heapq.heappush(pq, (new_distance, v))

    return distance, prev

def reconstruct_path(prev, start, target):
    path = []
    while target != -1:
        path.append(target)
        target = prev[target]
    path.reverse()
    return path

def main():
    MOD = 1000000007
    n, m = map(int, input().split())
    adj_list = [[] for _ in range(n)]
    
    for _ in range(m):
        u, v, x = map(int, input().split())
        weight = 2 ** x
        adj_list[u - 1].append((weight, v - 1))
        adj_list[v - 1].append((weight, u - 1))

    s, t = map(int, input().split())
    start, target = s - 1, t - 1

    distance, prev = dijkstra(adj_list, start, target)

    if distance[target] == float('inf'):
        print(-1)
    else:
        print(distance[target] % MOD)
        path = reconstruct_path(prev, start, target)
        print(len(path))
        print("" "".join(str(v + 1) for v in path))

if __name__ == ""__main__"":
    main()"
854,A,Fraction,PROGRAMMING,"['brute force', 'constructive algorithms', 'math']","Petya is a big fan of mathematics, especially its part related to fractions. Recently he learned that a fraction  is called proper iff its numerator is smaller than its denominator (*a*<=&lt;<=*b*) and that the fraction is called irreducible if its numerator and its denominator are coprime (they do not have positive common divisors except 1).

During his free time, Petya thinks about proper irreducible fractions and converts them to decimals using the calculator. One day he mistakenly pressed addition button (<=+<=) instead of division button (÷) and got sum of numerator and denominator that was equal to *n* instead of the expected decimal notation. 

Petya wanted to restore the original fraction, but soon he realized that it might not be done uniquely. That's why he decided to determine maximum possible proper irreducible fraction  such that sum of its numerator and denominator equals *n*. Help Petya deal with this problem.","In the only line of input there is an integer *n* (3<=≤<=*n*<=≤<=1000), the sum of numerator and denominator of the fraction.","Output two space-separated positive integers *a* and *b*, numerator and denominator of the maximum possible proper irreducible fraction satisfying the given sum.","['3\n', '4\n', '12\n']","['1 2\n', '1 3\n', '5 7\n']",none,OK,"n = int(input())
i = 1
j = n - 1
mxi = -1
mxj = 1001
while i < j:
    for d in range(2, i+1):
        if (j % d == 0) and (i % d == 0):
            break
    else:
        if (i > mxi) and (j < mxj):
            mxi = i
            mxj = j
    i += 1
    j -= 1
print(mxi, mxj)








","def comp(x):
    for i in range(2, x):
        if x % i == 0:
            return True
    return False

def find_permutation(n):
    # Check if n is 1, the only permutation is [1] which has a prefix product sequence equal to [1].
    if n == 1:
        return ""YES"", [1]
    
    # If n is even, no valid sequences exist as they can't form the required prefix product sequence.
    if n % 2 == 0:
        return ""NO"", []
    
    # Create a permutation for odd n
    permutation = list(range(1, n + 1))
    
    # Return valid output
    return ""YES"", permutation

# Read input
n = int(input())

# Get permutation result
result, perm = find_permutation(n)

# Print result
print(result)
if result == ""YES"":
    for number in perm:
        print(number)"
295,A,Greg and Array,PROGRAMMING,"['data structures', 'implementation']","Greg has an array *a*<==<=*a*1,<=*a*2,<=...,<=*a**n* and *m* operations. Each operation looks as: *l**i*, *r**i*, *d**i*, (1<=≤<=*l**i*<=≤<=*r**i*<=≤<=*n*). To apply operation *i* to the array means to increase all array elements with numbers *l**i*,<=*l**i*<=+<=1,<=...,<=*r**i* by value *d**i*.

Greg wrote down *k* queries on a piece of paper. Each query has the following form: *x**i*, *y**i*, (1<=≤<=*x**i*<=≤<=*y**i*<=≤<=*m*). That means that one should apply operations with numbers *x**i*,<=*x**i*<=+<=1,<=...,<=*y**i* to the array.

Now Greg is wondering, what the array *a* will be after all the queries are executed. Help Greg.","The first line contains integers *n*, *m*, *k* (1<=≤<=*n*,<=*m*,<=*k*<=≤<=105). The second line contains *n* integers: *a*1,<=*a*2,<=...,<=*a**n* (0<=≤<=*a**i*<=≤<=105) — the initial array.

Next *m* lines contain operations, the operation number *i* is written as three integers: *l**i*, *r**i*, *d**i*, (1<=≤<=*l**i*<=≤<=*r**i*<=≤<=*n*), (0<=≤<=*d**i*<=≤<=105).

Next *k* lines contain the queries, the query number *i* is written as two integers: *x**i*, *y**i*, (1<=≤<=*x**i*<=≤<=*y**i*<=≤<=*m*).

The numbers in the lines are separated by single spaces.","On a single line print *n* integers *a*1,<=*a*2,<=...,<=*a**n* — the array after executing all the queries. Separate the printed numbers by spaces.

Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams of the %I64d specifier.","['3 3 3\n1 2 3\n1 2 1\n1 3 2\n2 3 4\n1 2\n1 3\n2 3\n', '1 1 1\n1\n1 1 1\n1 1\n', '4 3 6\n1 2 3 4\n1 2 1\n2 3 2\n3 4 4\n1 2\n1 3\n2 3\n1 2\n1 3\n2 3\n']","['9 18 17\n', '2\n', '5 18 31 20\n']",none,OK,"n, m, k = map(int, input().split())

array = list(map(int, input().split()))

L = []
R = []
D = []

for i in range(m):

    l, r, d = map(int, input().split())
    L.append(l)
    R.append(r)
    D.append(d)

    L[i] -= 1

U = [0 for _ in range(m+1)]


for i in range(k):
    x, y = map(int, input().split())
    x -= 1

    U[x] += 1
    U[y] -= 1

c = 0

C = [0 for _ in range(n+1)]

for i in range(m):
    c += U[i]

    C[L[i]] += D[i] * c
    C[R[i]] -= D[i] * c;

c = 0
for i in range(n):
    c += C[i]
    array[i] += c

str_array = list(map(str, array))

print("" "".join(str_array))

		 	 	 	  			 			 	  	 		   	 	","def shert(num):
    n, k = map(int, input().split())  # Read number of participants and k-th place
    scores = list(map(int, input().split()))  # Read the scores of participants

    # Score of the k-th place finisher
    threshold_score = scores[k - 1]

    # Count how many participants have a score >= threshold_score and > 0
    advancers = sum(1 for score in scores if score >= threshold_score and score > 0)

    print(advancers)  # Output the number of advancing participants"
551,C,GukiZ hates Boxes,PROGRAMMING,"['binary search', 'greedy']","Professor GukiZ is concerned about making his way to school, because massive piles of boxes are blocking his way. 

In total there are *n* piles of boxes, arranged in a line, from left to right, *i*-th pile (1<=≤<=*i*<=≤<=*n*) containing *a**i* boxes. Luckily, *m* students are willing to help GukiZ by removing all the boxes from his way. Students are working simultaneously. At time 0, all students are located left of the first pile. It takes one second for every student to move from this position to the first pile, and after that, every student must start performing sequence of two possible operations, each taking one second to complete. Possible operations are:
1.  If *i*<=≠<=*n*, move from pile *i* to pile *i*<=+<=1;1.  If pile located at the position of student is not empty, remove one box from it.
GukiZ's students aren't smart at all, so they need you to tell them how to remove boxes before professor comes (he is very impatient man, and doesn't want to wait). They ask you to calculate minumum time *t* in seconds for which they can remove all the boxes from GukiZ's way. Note that students can be positioned in any manner after *t* seconds, but all the boxes must be removed.","The first line contains two integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=105), the number of piles of boxes and the number of GukiZ's students. 

The second line contains *n* integers *a*1,<=*a*2,<=... *a**n* (0<=≤<=*a**i*<=≤<=109) where *a**i* represents the number of boxes on *i*-th pile. It's guaranteed that at least one pile of is non-empty.","In a single line, print one number, minimum time needed to remove all the boxes in seconds.","['2 1\n1 1\n', '3 2\n1 0 2\n', '4 100\n3 4 5 4\n']","['4\n', '5\n', '5\n']","First sample: Student will first move to the first pile (1 second), then remove box from first pile (1 second), then move to the second pile (1 second) and finally remove the box from second pile (1 second).

Second sample: One of optimal solutions is to send one student to remove a box from the first pile and a box from the third pile, and send another student to remove a box from the third pile. Overall, 5 seconds.

Third sample: With a lot of available students, send three of them to remove boxes from the first pile, four of them to remove boxes from the second pile, five of them to remove boxes from the third pile, and four of them to remove boxes from the fourth pile. Process will be over in 5 seconds, when removing the boxes from the last pile is finished.",WRONG_ANSWER,"n,m = map(int, input().split())
A = list(map(int, input().split()))

lo, hi = 1, 10**15
def check(maxt):
    st, b = 0, A[0]
    for i in range(m):
        t = maxt-1-st
        while t > 0:
            rem = min(b, t)
            b, t = b-rem, t-rem
            if b == 0:
                st += 1
                if st == n: return True
                b, t = A[st], t-1
    return False

while lo+1 < hi:
    mid = (lo+hi) // 2
    if check(mid): hi = mid
    else: lo = mid
print(hi)
","import math 

def should_build_second_oven(n, t, k, d):
    single_oven_time = math.ceil(n / k) * t  # Time needed with one oven
    
    # Time with two ovens
    if d >= single_oven_time:
        return ""NO""  # If building time is more than or equal to single oven time, no need to build
    
    # Calculate time after building the second oven
    cake_after_d_minutes = (d // t) * k  # Cakes baked while the second oven is being built
    remaining_cakes = max(0, n - cake_after_d_minutes)  # Cakes still needed after building
    
    # Total time with two ovens
    time_with_two_ovens = d + math.ceil(remaining_cakes / (2 * k)) * t

    return ""YES"" if time_with_two_ovens < single_oven_time else ""NO""  # Compare times"
664,A,Complicated GCD,PROGRAMMING,"['math', 'number theory']","Greatest common divisor *GCD*(*a*,<=*b*) of two positive integers *a* and *b* is equal to the biggest integer *d* such that both integers *a* and *b* are divisible by *d*. There are many efficient algorithms to find greatest common divisor *GCD*(*a*,<=*b*), for example, Euclid algorithm. 

Formally, find the biggest integer *d*, such that all integers *a*,<=*a*<=+<=1,<=*a*<=+<=2,<=...,<=*b* are divisible by *d*. To make the problem even more complicated we allow *a* and *b* to be up to googol, 10100 — such number do not fit even in 64-bit integer type!",The only line of the input contains two integers *a* and *b* (1<=≤<=*a*<=≤<=*b*<=≤<=10100).,Output one integer — greatest common divisor of all integers from *a* to *b* inclusive.,"['1 2\n', '61803398874989484820458683436563811772030917980576 61803398874989484820458683436563811772030917980576\n']","['1\n', '61803398874989484820458683436563811772030917980576\n']",none,WRONG_ANSWER,"num1, num2 = map(int, input().split())

def dfs(num1, num2):
    if not num2:
        return num1
    return dfs(num2, num1 % num2)        

print(dfs(num1, num2))","import sys
import math

def min_light_radius(n, l, lanterns):
    lanterns.sort()
    max_distance = 0
    
    # Calculate the maximum distance between consecutive lanterns
    for i in range(1, n):
        max_distance = max(max_distance, lanterns[i] - lanterns[i - 1])
    
    # Consider the distance from the edges of the street to the first and last lanterns
    edge_distance = max(lanterns[0] - 0, l - lanterns[-1])
    
    # The minimum radius should cover both the maximum gap and the edge distances
    d = max(max_distance / 2, edge_distance)
    
    return d

# Read input
n, l = map(int, input().split())
lanterns = list(map(int, input().split()))

# Calculate and print the minimum light radius
result = min_light_radius(n, l, lanterns)
print(f""{result:.10f}"")"
1000,C,Covered Points Count,PROGRAMMING,"['data structures', 'implementation', 'sortings']","You are given $n$ segments on a coordinate line; each endpoint of every segment has integer coordinates. Some segments can degenerate to points. Segments can intersect with each other, be nested in each other or even coincide.

Your task is the following: for every $k \in [1..n]$, calculate the number of points with integer coordinates such that the number of segments that cover these points equals $k$. A segment with endpoints $l_i$ and $r_i$ covers point $x$ if and only if $l_i \le x \le r_i$.","The first line of the input contains one integer $n$ ($1 \le n \le 2 \cdot 10^5$) — the number of segments.

The next $n$ lines contain segments. The $i$-th line contains a pair of integers $l_i, r_i$ ($0 \le l_i \le r_i \le 10^{18}$) — the endpoints of the $i$-th segment.","Print $n$ space separated integers $cnt_1, cnt_2, \dots, cnt_n$, where $cnt_i$ is equal to the number of points such that the number of segments that cover these points equals to $i$.","['3\n0 3\n1 3\n3 8\n', '3\n1 3\n2 4\n5 7\n']","['6 2 1 \n', '5 2 0 \n']","The picture describing the first example:

<img class=""tex-graphics"" src=""https://espresso.codeforces.com/f76b3fe547bff6be5b14de76c8b78ba3efecc744.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

Points with coordinates $[0, 4, 5, 6, 7, 8]$ are covered by one segment, points $[1, 2]$ are covered by two segments and point $[3]$ is covered by three segments.

The picture describing the second example:

<img class=""tex-graphics"" src=""https://espresso.codeforces.com/6e9332c303e1bc5d6cf34c2d6c5e2a19c9417289.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

Points $[1, 4, 5, 6, 7]$ are covered by one segment, points $[2, 3]$ are covered by two segments and there are no points covered by three segments.",TIME_LIMIT_EXCEEDED,"def fff():
    k = []
    inp = int(input())
    for x in range(inp):
        k.append(list(map(int,input().split())))
    j = [-1 for x in range(max(k[-1])+1)]
    for x in k:
        for y in range(x[0],x[1]+1):
            j[y] += 1
    t = [0 for x in range(inp)]
    for x in j:
        if x != -1:
            t[x] += 1
    print(' '.join(list(map(str,t))))

fff()
   		    	  	  			   	 	 	   	","def dij(g,n):
    t=[-1]*(n+1)
    t[1]=0
    stack=[1]
    while stack:
        q=stack.pop()
        for val in g[q]:
            if(t[val]==-1):
                t[val] = t[q] + 1
                stack.append(val)
    return t

def main():
    import sys
    from collections import defaultdict, deque

    input = sys.stdin.read
    data = input().splitlines()
    
    n, m = map(int, data[0].split())
    
    railways = defaultdict(list)
    
    for i in range(1, m + 1):
        u, v = map(int, data[i].split())
        railways[u].append(v)
        railways[v].append(u)

    # Get distances for train via railways
    train_reach = dij(railways, n)

    # Create roads graph (complement of railways)
    roads = defaultdict(list)
    all_towns = set(range(1, n + 1))
    
    for u in range(1, n + 1):
        for v in range(1, n + 1):
            if u != v and v not in railways[u]:
                roads[u].append(v)

    # Get distances for bus via roads
    bus_reach = dij(roads, n)

    # Determine the best possible timing
    train_time = train_reach[n]
    bus_time = bus_reach[n]
    
    # If either cannot reach town n
    if train_time == -1 or bus_time == -1:
        print(-1)
        return
    
    # Find the minimum time satisfying the no collision condition
    result = float('inf')
    
    for town in range(1, n):
        if train_reach[town] != -1 and bus_reach[town] != -1:
            # Check if they can be at the same town at the same time
            result = min(result, max(bus_reach[n], train_reach[n]))
    
    print(result if result != float('inf') else -1)

if __name__ == ""__main__"":
    main()"
6,E,Exposition,PROGRAMMING,"['binary search', 'data structures', 'dsu', 'trees', 'two pointers']","There are several days left before the fiftieth birthday of a famous Berland's writer Berlbury. In this connection the local library decided to make an exposition of the works of this famous science-fiction writer. It was decided as well that it is necessary to include into the exposition only those books that were published during a particular time period. It is obvious that if the books differ much in size, the visitors will not like it. That was why the organizers came to the opinion, that the difference between the highest and the lowest books in the exposition should be not more than *k* millimeters.

The library has *n* volumes of books by Berlbury, arranged in chronological order of their appearance. The height of each book in millimeters is know, it is *h**i*. As Berlbury is highly respected in the city, the organizers want to include into the exposition as many books as possible, and to find out what periods of his creative work they will manage to cover. You are asked to help the organizers cope with this hard task.","The first line of the input data contains two integer numbers separated by a space *n* (1<=≤<=*n*<=≤<=105) and *k* (0<=≤<=*k*<=≤<=106) — the amount of books by Berlbury in the library, and the maximum allowed height difference between the lowest and the highest books. The second line contains *n* integer numbers separated by a space. Each number *h**i* (1<=≤<=*h**i*<=≤<=106) is the height of the *i*-th book in millimeters.","In the first line of the output data print two numbers *a* and *b* (separate them by a space), where *a* is the maximum amount of books the organizers can include into the exposition, and *b* — the amount of the time periods, during which Berlbury published *a* books, and the height difference between the lowest and the highest among these books is not more than *k* milllimeters.

In each of the following *b* lines print two integer numbers separated by a space — indexes of the first and the last volumes from each of the required time periods of Berlbury's creative work.","['3 3\n14 12 10\n', '2 0\n10 10\n', '4 5\n8 19 10 13\n']","['2 2\n1 2\n2 3\n', '2 1\n1 2\n', '2 1\n3 4\n']",none,WRONG_ANSWER,"print(""_RANDOM_GUESS_1689638025.2973702"")# 1689638025.29739","n = int(input())
num = list(map(int, input().split()))
maxnum = max(num)

# Create a list to track the presence of each integer up to maxnum
present = [False] * (maxnum + 2)  # +2 to include maxnum + 1

# Mark the indexes that are present
for index in num:
    present[index] = True

# Find the smallest positive integer not in the present list
for i in range(1, maxnum + 2):
    if not present[i]:
        print(i)
        break"
32,B,Borze,PROGRAMMING,"['expression parsing', 'implementation']","Ternary numeric notation is quite popular in Berland. To telegraph the ternary number the Borze alphabet is used. Digit 0 is transmitted as «.», 1 as «-.» and 2 as «--». You are to decode the Borze code, i.e. to find out the ternary number given its representation in Borze alphabet.",The first line contains a number in Borze code. The length of the string is between 1 and 200 characters. It's guaranteed that the given string is a valid Borze code of some ternary number (this number can have leading zeroes).,Output the decoded ternary number. It can have leading zeroes.,"['.-.--\n', '--.\n', '-..-.--\n']","['012', '20', '1012']",none,OK,"o = input()
result = """"
p = 0
while p < len(o):
    if o[p] == ""."":
        result += '0'
    else:
        p += 1
        if o[p] == ""."":
            result += '1'
        else:
            result += '2'
    p += 1

print(result)","A, B, C = map(int, input().split())

# Check if there is a valid integer point
if A == 0 and B == 0:
    print(-1)
else:
    # If A is non-zero, we can choose a specific value for x
    if A != 0:
        x = 0
        # Calculate corresponding y value
        y = (C - A * x) // B
        # Check if this y is an integer and satisfies the equation
        if (C - A * x) % B == 0 and -5 * 10**18 <= y <= 5 * 10**18:
            print(x, y)
        else:
            print(-1)
    # If B is non-zero, we can choose a specific value for y
    elif B != 0:
        y = 0
        # Calculate corresponding x value
        x = (C - B * y) // A
        # Check if this x is an integer and satisfies the equation
        if (C - B * y) % A == 0 and -5 * 10**18 <= x <= 5 * 10**18:
            print(x, y)
        else:
            print(-1)"
433,B,Kuriyama Mirai's Stones,PROGRAMMING,"['dp', 'implementation', 'sortings']","Kuriyama Mirai has killed many monsters and got many (namely *n*) stones. She numbers the stones from 1 to *n*. The cost of the *i*-th stone is *v**i*. Kuriyama Mirai wants to know something about these stones so she will ask you two kinds of questions:
 1.  She will tell you two numbers, *l* and *r* (1<=≤<=*l*<=≤<=*r*<=≤<=*n*), and you should tell her . 1.  Let *u**i* be the cost of the *i*-th cheapest stone (the cost that will be on the *i*-th place if we arrange all the stone costs in non-decreasing order). This time she will tell you two numbers, *l* and *r* (1<=≤<=*l*<=≤<=*r*<=≤<=*n*), and you should tell her . 
For every question you should give the correct answer, or Kuriyama Mirai will say ""fuyukai desu"" and then become unhappy.","The first line contains an integer *n* (1<=≤<=*n*<=≤<=105). The second line contains *n* integers: *v*1,<=*v*2,<=...,<=*v**n* (1<=≤<=*v**i*<=≤<=109) — costs of the stones. 

The third line contains an integer *m* (1<=≤<=*m*<=≤<=105) — the number of Kuriyama Mirai's questions. Then follow *m* lines, each line contains three integers *type*, *l* and *r* (1<=≤<=*l*<=≤<=*r*<=≤<=*n*; 1<=≤<=*type*<=≤<=2), describing a question. If *type* equal to 1, then you should output the answer for the first question, else you should output the answer for the second one.",Print *m* lines. Each line must contain an integer — the answer to Kuriyama Mirai's question. Print the answers to the questions in the order of input.,"['6\n6 4 2 7 2 7\n3\n2 3 6\n1 3 4\n1 1 6\n', '4\n5 5 2 3\n10\n1 2 4\n2 1 4\n1 1 1\n2 1 4\n2 1 2\n1 1 1\n1 3 3\n1 1 3\n1 4 4\n1 2 2\n']","['24\n9\n28\n', '10\n15\n5\n15\n5\n5\n2\n12\n3\n5\n']",Please note that the answers to the questions may overflow 32-bit integer type.,WRONG_ANSWER,"n = int(input())
a = list(map(int, input().split()))
k = int(input())
b = [0]
sum = 0
for i in range(n):
    sum += a[i]
    b.append(sum)


a.sort()
c = [0]
for i in range(n):
    sum += a[i]
    c.append(sum)


for i in range(k):
    temp = list(map(int, input().split()))
    if temp[0] == 1:
        l = temp[1]
        r = temp[2]
        print(b[r] - b[l -1])
    else:
        l = temp[1]
        r = temp[2]
        print(c[r] - c[l - 1])

","def main():
    k = int(input())
    d = list(map(int, input().split(' ')))
    a = set()
    b = set()
    c = set()
    n = set()
    zero = False
    
    for num in d:
        if num == 0:
            zero = True
        else:
            # Add current number to the sets if it has digits without 0 in any place
            a.add(num)
            for digit in str(num):
                # Add to helper sets based on digit presence
                if digit != '0':
                    b.add(digit)
    
    # If there's at least one zero in the input, we can add all numbers to the output set
    if zero:
        n = a
    else:
        # Choose numbers based on the unique digits they use
        for num in a:
            unique_digits = set(str(num))
            if not (unique_digits.intersection(b)):  # Ensure selected numbers use at least one '0' in any place
                n.add(num)
    
    print(len(n))
    print(' '.join(map(str, n)))

main()"
721,A,One-dimensional Japanese Crossword,PROGRAMMING,['implementation'],"Recently Adaltik discovered japanese crosswords. Japanese crossword is a picture, represented as a table sized *a*<=×<=*b* squares, and each square is colored white or black. There are integers to the left of the rows and to the top of the columns, encrypting the corresponding row or column. The number of integers represents how many groups of black squares there are in corresponding row or column, and the integers themselves represents the number of consecutive black squares in corresponding group (you can find more detailed explanation in Wikipedia [https://en.wikipedia.org/wiki/Japanese_crossword](https://en.wikipedia.org/wiki/Japanese_crossword)).

Adaltik decided that the general case of japanese crossword is too complicated and drew a row consisting of *n* squares (e.g. japanese crossword sized 1<=×<=*n*), which he wants to encrypt in the same way as in japanese crossword.

Help Adaltik find the numbers encrypting the row he drew.","The first line of the input contains a single integer *n* (1<=≤<=*n*<=≤<=100) — the length of the row. The second line of the input contains a single string consisting of *n* characters 'B' or 'W', ('B' corresponds to black square, 'W' — to white square in the row that Adaltik drew).","The first line should contain a single integer *k* — the number of integers encrypting the row, e.g. the number of groups of black squares in the row.

The second line should contain *k* integers, encrypting the row, e.g. corresponding to sizes of groups of consecutive black squares in the order from left to right.","['3\nBBW\n', '5\nBWBWB\n', '4\nWWWW\n', '4\nBBBB\n', '13\nWBBBBWWBWBBBW\n']","['1\n2 ', '3\n1 1 1 ', '0\n', '1\n4 ', '3\n4 1 3 ']",The last sample case correspond to the picture in the statement.,OK,"n = int(input())
li = input().strip('W').split('W')
r = []
for i in li:
    if i: r.append(len(i))
print(len(r))
print(*r)","import math

def inp():
    return int(input())

def invr():
    # Read two integers a and b from input
    a = inp()
    b = inp()
    
    # The GCD of a range from a to b is determined by:
    # If a == b, then the GCD is a (or b)
    # If a < b, then the GCD of all numbers from a to b is 1
    # because consecutive numbers have no common divisor greater than 1.
    if a == b:
        return a
    else:
        return 1

# Output the result of invr function
print(invr())"
869,A,The Artful Expedient,PROGRAMMING,"['brute force', 'implementation']","Rock... Paper!

After Karen have found the deterministic winning (losing?) strategy for rock-paper-scissors, her brother, Koyomi, comes up with a new game as a substitute. The game works as follows.

A positive integer *n* is decided first. Both Koyomi and Karen independently choose *n* distinct positive integers, denoted by *x*1,<=*x*2,<=...,<=*x**n* and *y*1,<=*y*2,<=...,<=*y**n* respectively. They reveal their sequences, and repeat until all of 2*n* integers become distinct, which is the only final state to be kept and considered.

Then they count the number of ordered pairs (*i*,<=*j*) (1<=≤<=*i*,<=*j*<=≤<=*n*) such that the value *x**i* xor *y**j* equals to one of the 2*n* integers. Here xor means the [bitwise exclusive or](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) operation on two integers, and is denoted by operators ^ and/or xor in most programming languages.

Karen claims a win if the number of such pairs is even, and Koyomi does otherwise. And you're here to help determine the winner of their latest game.","The first line of input contains a positive integer *n* (1<=≤<=*n*<=≤<=2<=000) — the length of both sequences.

The second line contains *n* space-separated integers *x*1,<=*x*2,<=...,<=*x**n* (1<=≤<=*x**i*<=≤<=2·106) — the integers finally chosen by Koyomi.

The third line contains *n* space-separated integers *y*1,<=*y*2,<=...,<=*y**n* (1<=≤<=*y**i*<=≤<=2·106) — the integers finally chosen by Karen.

Input guarantees that the given 2*n* integers are pairwise distinct, that is, no pair (*i*,<=*j*) (1<=≤<=*i*,<=*j*<=≤<=*n*) exists such that one of the following holds: *x**i*<==<=*y**j*; *i*<=≠<=*j* and *x**i*<==<=*x**j*; *i*<=≠<=*j* and *y**i*<==<=*y**j*.","Output one line — the name of the winner, that is, ""Koyomi"" or ""Karen"" (without quotes). Please be aware of the capitalization.","['3\n1 2 3\n4 5 6\n', '5\n2 4 6 8 10\n9 7 5 3 1\n']","['Karen\n', 'Karen\n']","In the first example, there are 6 pairs satisfying the constraint: (1, 1), (1, 2), (2, 1), (2, 3), (3, 2) and (3, 3). Thus, Karen wins since 6 is an even number.

In the second example, there are 16 such pairs, and Karen wins again.",TIME_LIMIT_EXCEEDED,"l1=[]
n=int(input(""""))
l1 = list(map(int, input('').split()))

l2=[]
l2 = list(map(int, input('').split()))

l=l1+l2
c=0
for i in range (n):
    for j in range (n):
        if (l1[i]^l2[j] in l ): 
           c=c+1

if (c % 2 == 0 ) :
    print(""Karen"")
else:
    print(""Koyomi"")
                       
","throws = input().split()
player_one = int(throws[0])
player_two = int(throws[1])

# Initialize win, draw, and lose counters
win_one = 0
draw = 0
win_two = 0

# Check all possible outcomes of the dice throw
for dice in range(1, 7):
    # Calculate the differences for both players
    diff_one = abs(player_one - dice)
    diff_two = abs(player_two - dice)
    
    # Determine the outcome
    if diff_one < diff_two:
        win_one += 1
    elif diff_one > diff_two:
        win_two += 1
    else:
        draw += 1

# Print the results: wins for player one, draws, wins for player two
print(win_one, draw, win_two)"
766,A,Mahmoud and Longest Uncommon Subsequence,PROGRAMMING,"['constructive algorithms', 'strings']","While Mahmoud and Ehab were practicing for IOI, they found a problem which name was Longest common subsequence. They solved it, and then Ehab challenged Mahmoud with another problem.

Given two strings *a* and *b*, find the length of their longest uncommon subsequence, which is the longest string that is a subsequence of one of them and not a subsequence of the other.

A subsequence of some string is a sequence of characters that appears in the same order in the string, The appearances don't have to be consecutive, for example, strings ""ac"", ""bc"", ""abc"" and ""a"" are subsequences of string ""abc"" while strings ""abbc"" and ""acb"" are not. The empty string is a subsequence of any string. Any string is a subsequence of itself.","The first line contains string *a*, and the second line — string *b*. Both of these strings are non-empty and consist of lowercase letters of English alphabet. The length of each string is not bigger than 105 characters.","If there's no uncommon subsequence, print ""-1"". Otherwise print the length of the longest uncommon subsequence of *a* and *b*.","['abcd\ndefgh\n', 'a\na\n']","['5\n', '-1\n']","In the first example: you can choose ""defgh"" from string *b* as it is the longest subsequence of string *b* that doesn't appear as a subsequence of string *a*.",OK,"def solve():
    a = input()
    b = input()
    print(-1 if a == b else max(len(a), len(b)))
    
t = 1 #int(input())
for i in range(t):
    #print(f""Case #{i+1}:"", end="" "")
	solve()
","n = int(input())

def gcd(x, y):
    while y:
        x, y = y, x % y
    return x

def find_max_proper_irreducible_fraction(n):
    max_fraction = (0, 1)  # Initialize with 0/1 as minimum fraction
    for a in range(1, n // 2 + 1):  # Numerator should be less than Denominator
        b = n - a  # Denominator is n - Num
        if a < b and gcd(a, b) == 1:  # Proper and irreducible condition
            max_fraction = max(max_fraction, (a, b), key=lambda frac: frac[0] / frac[1])
    return max_fraction

result = find_max_proper_irreducible_fraction(n)
print(result[0], result[1])"
766,B,Mahmoud and a Triangle,PROGRAMMING,"['constructive algorithms', 'geometry', 'greedy', 'math', 'number theory', 'sortings']","Mahmoud has *n* line segments, the *i*-th of them has length *a**i*. Ehab challenged him to use exactly 3 line segments to form a non-degenerate triangle. Mahmoud doesn't accept challenges unless he is sure he can win, so he asked you to tell him if he should accept the challenge. Given the lengths of the line segments, check if he can choose exactly 3 of them to form a non-degenerate triangle.

Mahmoud should use exactly 3 line segments, he can't concatenate two line segments or change any length. A non-degenerate triangle is a triangle with positive area.","The first line contains single integer *n* (3<=≤<=*n*<=≤<=105) — the number of line segments Mahmoud has.

The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=109) — the lengths of line segments Mahmoud has.","In the only line print ""YES"" if he can choose exactly three line segments and form a non-degenerate triangle with them, and ""NO"" otherwise.","['5\n1 5 3 2 4\n', '3\n4 1 2\n']","['YES\n', 'NO\n']","For the first example, he can use line segments with lengths 2, 4 and 5 to form a non-degenerate triangle.",WRONG_ANSWER,"n = int(input())
a = list(map(int,input().split(' ')))
a.sort()
if a[len(a)-2] +a[len(a)-3]> max(a):
    print('YES')
else:
    print('NO')","def solution(n, p, k):
    arr = []
    for i in range(1, n + 1):
        arr.append(i)
    string = ""("" + str(p) + "")""
    
    # Determine the start and end of the navigation
    start = max(1, p - k // 2)
    end = min(n, start + k - 1)

    if end - start + 1 < k:
        # Adjust start if there are not enough pages
        start = max(1, end - k + 1)

    navigation = []
    
    # Add the navigation buttons according to the rules
    if start > 1:
        navigation.append(""<<"")  # Add button to go to the first page
    for i in range(start, end + 1):
        if i == p:
            navigation.append(string)  # Current page
        else:
            navigation.append(str(i))  # Other pages
    if end < n:
        navigation.append("">>"")  # Add button to go to the last page

    # Print the navigation
    print("" "".join(navigation))

# Example usage
solution(7, 4, 5)"
58,A,Chat room,PROGRAMMING,"['greedy', 'strings']","Vasya has recently learned to type and log on to the Internet. He immediately entered a chat room and decided to say hello to everybody. Vasya typed the word *s*. It is considered that Vasya managed to say hello if several letters can be deleted from the typed word so that it resulted in the word ""hello"". For example, if Vasya types the word ""ahhellllloou"", it will be considered that he said hello, and if he types ""hlelo"", it will be considered that Vasya got misunderstood and he didn't manage to say hello. Determine whether Vasya managed to say hello by the given word *s*.","The first and only line contains the word *s*, which Vasya typed. This word consisits of small Latin letters, its length is no less that 1 and no more than 100 letters.","If Vasya managed to say hello, print ""YES"", otherwise print ""NO"".","['ahhellllloou\n', 'hlelo\n']","['YES\n', 'NO\n']",none,OK,"s=input()
f=False
for i in range(len(s)):
    if s[i]=='h':
        for l in range(i+1,len(s)):
            if s[l]=='e':
                for k in range(l+1,len(s)):
                    if s[k]=='l':
                        for j in range(k+1,len(s)):
                            if s[j]=='l':
                                for p in range(j+1,len(s)):
                                    if s[p]=='o':
                                        f=True
                                        break
if f:
    print('YES')
else:
    print('NO')","fence = []

def paint(left, right, height):
    if left >= right:
        return 0
    
    # Find the minimum height of the planks in the range [left, right)
    min_height = min(fence[left:right])
    
    # Calculate strokes needed for horizontal painting
    strokes = min_height
    
    # Paint and count strokes for remaining heights
    # Paint horizontally at min_height level
    for i in range(left, right):
        if fence[i] > min_height:
            strokes += paint(i, i + 1, fence[i] - min_height)
    
    # Return total strokes needed
    return strokes

n = int(input())
fence = list(map(int, input().split()))

# Calculate and print the minimum number of strokes needed
print(paint(0, n, 0))"
43,A,Football,PROGRAMMING,['strings'],"One day Vasya decided to have a look at the results of Berland 1910 Football Championship’s finals. Unfortunately he didn't find the overall score of the match; however, he got hold of a profound description of the match's process. On the whole there are *n* lines in that description each of which described one goal. Every goal was marked with the name of the team that had scored it. Help Vasya, learn the name of the team that won the finals. It is guaranteed that the match did not end in a tie.",The first line contains an integer *n* (1<=≤<=*n*<=≤<=100) — the number of lines in the description. Then follow *n* lines — for each goal the names of the teams that scored it. The names are non-empty lines consisting of uppercase Latin letters whose lengths do not exceed 10 symbols. It is guaranteed that the match did not end in a tie and the description contains no more than two different teams.,Print the name of the winning team. We remind you that in football the team that scores more goals is considered the winner.,"['1\nABC\n', '5\nA\nABA\nABA\nA\nA\n']","['ABC\n', 'A\n']",none,OK,"n = int(input())
t1 = 0
t2 = 0
temp = ''
flag = ''

for i in range(n):
    goal = input()
    if i == 0:
        temp = goal
        t1 += 1 
    else:
        if temp == goal:
            t1 += 1 
        else:
            flag = goal 
            t2 += 1 
if t1 > t2:
    print(temp)
else:
    print(flag)
        ","def average(ns):
    return sum(ns) / len(ns)

def main():
    n, k = map(int, input().split())  # Read the number of marks and the highest mark
    marks = list(map(int, input().split()))  # Read the existing marks

    current_average = average(marks)  # Calculate the current average
    
    if round(current_average) >= k:  # Check if current average is already sufficient
        print(0)
        return

    additional_marks = 0  # Initialize the number of additional marks needed
    total_marks = sum(marks)  # Calculate the total of the current marks

    while True:
        additional_marks += 1  # Adding one more mark
        total_marks += k  # Assume we add the maximum mark
        new_average = total_marks / (n + additional_marks)  # Calculate new average
        
        if round(new_average) >= k:  # Check if the new average satisfies the condition
            break
    
    print(additional_marks)  # Output the minimal number of additional marks

if __name__ == ""__main__"":
    main()"
580,A,Kefa and First Steps,PROGRAMMING,"['brute force', 'dp', 'implementation']","Kefa decided to make some money doing business on the Internet for exactly *n* days. He knows that on the *i*-th day (1<=≤<=*i*<=≤<=*n*) he makes *a**i* money. Kefa loves progress, that's why he wants to know the length of the maximum non-decreasing subsegment in sequence *a**i*. Let us remind you that the subsegment of the sequence is its continuous fragment. A subsegment of numbers is called non-decreasing if all numbers in it follow in the non-decreasing order.

Help Kefa cope with this task!","The first line contains integer *n* (1<=≤<=*n*<=≤<=105).

The second line contains *n* integers *a*1,<=<=*a*2,<=<=...,<=<=*a**n* (1<=≤<=*a**i*<=≤<=109).",Print a single integer — the length of the maximum non-decreasing subsegment of sequence *a*.,"['6\n2 2 1 3 4 1\n', '3\n2 2 9\n']","['3', '3']","In the first test the maximum non-decreasing subsegment is the numbers from the third to the fifth one.

In the second test the maximum non-decreasing subsegment is the numbers from the first to the third one.",RUNTIME_ERROR,"n = int(input())
a = list(map((input().split())))
k, o = 0, float('-inf')
for i in range(1,n):
    if a[i]>=a[i-1]: k+=1
    else: o = max(o,k)
print(o)","def main():
    import sys
    
    input = sys.stdin.read
    data = input().strip().splitlines()
    
    N = int(data[0])  # Read the number of days
    M = list(map(int, data[1].split()))  # Read array M
    R = list(map(int, data[2].split()))  # Read array R
    
    count = 0  # Count of days dishes are washed
    total_days = 0  # Total number of days simulated
    
    # Simulating for a large number of days (let's say up to 1000)
    for day in range(1000):
        total_days += 1
        D = day % 16  # Current day index based on 0-15 range
        
        # Check all interests
        for i in range(N):
            if M[i] > D and R[i] >= D:
                count += 1
                break  # No need to check further interests if one condition is met
    
    # Calculate the percentage
    percentage = (count / total_days) * 100
    
    # Output the result with precision
    print(f""{percentage:.10f}"")"
313,A,Ilya and Bank Account,PROGRAMMING,"['implementation', 'number theory']","Ilya is a very clever lion, he lives in an unusual city ZooVille. In this city all the animals have their rights and obligations. Moreover, they even have their own bank accounts. The state of a bank account is an integer. The state of a bank account can be a negative number. This means that the owner of the account owes the bank money.

Ilya the Lion has recently had a birthday, so he got a lot of gifts. One of them (the gift of the main ZooVille bank) is the opportunity to delete the last digit or the digit before last from the state of his bank account no more than once. For example, if the state of Ilya's bank account is -123, then Ilya can delete the last digit and get his account balance equal to -12, also he can remove its digit before last and get the account balance equal to -13. Of course, Ilya is permitted not to use the opportunity to delete a digit from the balance.

Ilya is not very good at math, and that's why he asks you to help him maximize his bank account. Find the maximum state of the bank account that can be obtained using the bank's gift.",The single line contains integer *n* (10<=≤<=|*n*|<=≤<=109) — the state of Ilya's bank account.,In a single line print an integer — the maximum state of the bank account that Ilya can get.,"['2230\n', '-10\n', '-100003\n']","['2230\n', '0\n', '-10000\n']","In the first test sample Ilya doesn't profit from using the present.

In the second test sample you can delete digit 1 and get the state of the account equal to 0.",OK,"n=str(input())
m = n
if n[0] == '-':
    if int(n[-2]) <= int(n[-1]):
        m=n[:-1]
    else:
        m=n[:-2]+n[-1]
    m=int(m)
print(m)

























","#Justin Hershberger
#Py3.5

import fileinput

def find_tournament_resources(n, b, p):
    total_bottles = 0
    total_towels = p * n  # Each participant gets p towels for the whole tournament
    
    while n > 1:
        k = 1
        while k * 2 <= n:  # Find the largest power of 2 less than or equal to n
            k *= 2
        
        matches = k // 2  # Number of matches in this round
        total_bottles += matches * (2 * b + 1)  # Each match requires 2*b bottles for participants and 1 for the judge
        
        n = (n - k) + (k // 2)  # Update the number of participants for the next round
    
    return total_bottles, total_towels

def test():
    # Add test cases if needed
    pass

if __name__ == '__main__':
    for line in fileinput.input():
        n, b, p = map(int, line.split())
        bottles, towels = find_tournament_resources(n, b, p)
        print(bottles, towels)"
907,B,Tic-Tac-Toe,PROGRAMMING,['implementation'],"Two bears are playing tic-tac-toe via mail. It's boring for them to play usual tic-tac-toe game, so they are a playing modified version of this game. Here are its rules.

The game is played on the following field.

Players are making moves by turns. At first move a player can put his chip in any cell of any small field. For following moves, there are some restrictions: if during last move the opposite player put his chip to cell with coordinates (*x**l*,<=*y**l*) in some small field, the next move should be done in one of the cells of the small field with coordinates (*x**l*,<=*y**l*). For example, if in the first move a player puts his chip to lower left cell of central field, then the second player on his next move should put his chip into some cell of lower left field (pay attention to the first test case). If there are no free cells in the required field, the player can put his chip to any empty cell on any field.

You are given current state of the game and coordinates of cell in which the last move was done. You should find all cells in which the current player can put his chip.

A hare works as a postman in the forest, he likes to foul bears. Sometimes he changes the game field a bit, so the current state of the game could be unreachable. However, after his changes the cell where the last move was done is not empty. You don't need to find if the state is unreachable or not, just output possible next moves according to the rules.","First 11 lines contains descriptions of table with 9 rows and 9 columns which are divided into 9 small fields by spaces and empty lines. Each small field is described by 9 characters without spaces and empty lines. character ""x"" (ASCII-code 120) means that the cell is occupied with chip of the first player, character ""o"" (ASCII-code 111) denotes a field occupied with chip of the second player, character ""."" (ASCII-code 46) describes empty cell.

The line after the table contains two integers *x* and *y* (1<=≤<=*x*,<=*y*<=≤<=9). They describe coordinates of the cell in table where the last move was done. Rows in the table are numbered from up to down and columns are numbered from left to right.

It's guaranteed that cell where the last move was done is filled with ""x"" or ""o"". Also, it's guaranteed that there is at least one empty cell. It's not guaranteed that current state of game is reachable.","Output the field in same format with characters ""!"" (ASCII-code 33) on positions where the current player can put his chip. All other cells should not be modified.","['... ... ...\n... ... ...\n... ... ...\n\n... ... ...\n... ... ...\n... x.. ...\n\n... ... ...\n... ... ...\n... ... ...\n6 4\n', 'xoo x.. x..\nooo ... ...\nooo ... ...\n\nx.. x.. x..\n... ... ...\n... ... ...\n\nx.. x.. x..\n... ... ...\n... ... ...\n7 4\n', 'o.. ... ...\n... ... ...\n... ... ...\n\n... xxx ...\n... xox ...\n... ooo ...\n\n... ... ...\n... ... ...\n... ... ...\n5 5\n']","['... ... ... \n... ... ... \n... ... ... \n\n... ... ... \n... ... ... \n... x.. ... \n\n!!! ... ... \n!!! ... ... \n!!! ... ... \n\n', 'xoo x!! x!! \nooo !!! !!! \nooo !!! !!! \n\nx!! x!! x!! \n!!! !!! !!! \n!!! !!! !!! \n\nx!! x!! x!! \n!!! !!! !!! \n!!! !!! !!! \n\n', 'o!! !!! !!! \n!!! !!! !!! \n!!! !!! !!! \n\n!!! xxx !!! \n!!! xox !!! \n!!! ooo !!! \n\n!!! !!! !!! \n!!! !!! !!! \n!!! !!! !!! \n\n']","In the first test case the first player made a move to lower left cell of central field, so the second player can put a chip only to cells of lower left field.

In the second test case the last move was done to upper left cell of lower central field, however all cells in upper left field are occupied, so the second player can put his chip to any empty cell.

In the third test case the last move was done to central cell of central field, so current player can put his chip to any cell of central field, which is already occupied, so he can move anywhere. Pay attention that this state of the game is unreachable.",OK,"field = [[""""]*9 for i in range(9)]
z = 0
for i in range(3):
    temp2 = input()
    for z2 in range(len(temp2)):
        if temp2[z2] != "" "":
            field[i][z] = temp2[z2]
            z+= 1
    z = 0
input()
for i in range(3,6):
    temp2 = input()
    for z2 in range(len(temp2)):
        if temp2[z2] != "" "":
            field[i][z] = temp2[z2]
            z+= 1
    z = 0
input()
for i in range(6,9):
    temp2 = input()
    for z2 in range(len(temp2)):
        if temp2[z2] != "" "":
            field[i][z] = temp2[z2]
            z+= 1
    z = 0
x, y = map(int,input().split())
x2 = ((y-1) % 3) * 3
y2 = ((x-1) % 3) * 3
temp = 0
for i in range(3):
    for j in range(3):
        if field[y2+i][x2+j] == ""."":
            field[y2+i][x2+j] = ""!""
            temp += 1
if temp == 0:
    for i in range(9):
        for j in range(9):
            if field[i][j] == ""."":
                field[i][j] = ""!""
for i in range(9):
        for j in range(9):
            if j % 3 == 0 and j != 0:
                print("""",end="" "")
            print(field[i][j],end="""")
        if i % 3 == 2 and i != 8:
            print()
        print()
","# Function to check if production will eventually stop
def will_production_stop(a, m):
    # Use a set to keep track of visited states to detect cycles
    visited = set()
    
    # Continue processing until we reach a state we've seen before
    while a not in visited:
        visited.add(a)  # Mark this state as visited
        remainder = a % m  # Calculate the remainder
        a += remainder  # Update the number of details produced
        
        # Check if current number of details is divisible by m
        if a % m == 0:
            return ""Yes""  # Production will stop

    return ""No""  # Production will not stop

# Read input values
a, m = map(int, input().split())
# Call function and print the result
print(will_production_stop(a, m))"
302,A,Eugeny and Array,PROGRAMMING,['implementation'],"Eugeny has array *a*<==<=*a*1,<=*a*2,<=...,<=*a**n*, consisting of *n* integers. Each integer *a**i* equals to -1, or to 1. Also, he has *m* queries:
 -  Query number *i* is given as a pair of integers *l**i*, *r**i* (1<=≤<=*l**i*<=≤<=*r**i*<=≤<=*n*). -  The response to the query will be integer 1, if the elements of array *a* can be rearranged so as the sum *a**l**i*<=+<=*a**l**i*<=+<=1<=+<=...<=+<=*a**r**i*<==<=0, otherwise the response to the query will be integer 0. 
Help Eugeny, answer all his queries.","The first line contains integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=2·105). The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (*a**i*<==<=-1,<=1). Next *m* lines contain Eugene's queries. The *i*-th line contains integers *l**i*,<=*r**i* (1<=≤<=*l**i*<=≤<=*r**i*<=≤<=*n*).",Print *m* integers — the responses to Eugene's queries in the order they occur in the input.,"['2 3\n1 -1\n1 1\n1 2\n2 2\n', '5 5\n-1 1 1 1 -1\n1 1\n2 3\n3 5\n2 5\n1 5\n']","['0\n1\n0\n', '0\n1\n0\n1\n0\n']",none,TIME_LIMIT_EXCEEDED,"n,m = map(int,input().split())
l=sum(list(map(int,input().split())))
if(l>0):
	a=(n-l)//2
	b=n-a
else:
	b=(n+l)//2
	a=n-b
for i in range(m):
	x,y=map(int,input().split())
	if((y-x)%2==0):
		print(0)
	else:
		if((y-x+1)//2<=min(a,b)):
			print(1)
		else:
			print(0)
","def sol():
    s = input()
    k = int(input())

    n = len(s)
    
    # Check if the length of s is divisible by k
    if n % k != 0:
        print(""NO"")
        return
    
    # Calculate the length of each palindrome
    part_length = n // k

    # Function to check if a string is a palindrome
    def is_palindrome(sub):
        return sub == sub[::-1]

    # Check each part of the string
    for i in range(0, n, part_length):
        if not is_palindrome(s[i:i + part_length]):
            print(""NO"")
            return
    
    print(""YES"")"
137,B,Permutation,PROGRAMMING,['greedy'],"""Hey, it's homework time"" — thought Polycarpus and of course he started with his favourite subject, IT. Polycarpus managed to solve all tasks but for the last one in 20 minutes. However, as he failed to solve the last task after some considerable time, the boy asked you to help him.

The sequence of *n* integers is called a permutation if it contains all integers from 1 to *n* exactly once.

You are given an arbitrary sequence *a*1,<=*a*2,<=...,<=*a**n* containing *n* integers. Each integer is not less than 1 and not greater than 5000. Determine what minimum number of elements Polycarpus needs to change to get a permutation (he should not delete or add numbers). In a single change he can modify any single sequence element (i. e. replace it with another integer).","The first line of the input data contains an integer *n* (1<=≤<=*n*<=≤<=5000) which represents how many numbers are in the sequence. The second line contains a sequence of integers *a**i* (1<=≤<=*a**i*<=≤<=5000,<=1<=≤<=*i*<=≤<=*n*).",Print the only number — the minimum number of changes needed to get the permutation.,"['3\n3 1 2\n', '2\n2 2\n', '5\n5 3 3 3 1\n']","['0\n', '1\n', '2\n']","The first sample contains the permutation, which is why no replacements are required.

In the second sample it is enough to replace the first element with the number 1 and that will make the sequence the needed permutation.

In the third sample we can replace the second element with number 4 and the fourth element with number 2.",OK,"n = int(input())
a = input().split()
d = {}
for i in a:
    t = int(i)
    if t in d:
        d[t] += 1
    else:
        d[t] = 1
res = 0
for i in range(1, n+1):
    if i not in d:
        res += 1
print(res)
","import sys
input = sys.stdin.readline

def divisor(i):
    s = []
    for j in range(1, int(i ** (1 / 2)) + 1):
        if i % j == 0:
            s.append(j)
            if j != i // j:
                s.append(i // j)
    return s

def is_beautiful(num):
    # Convert number to binary and remove '0b' prefix
    binary_rep = bin(num)[2:]
    # Check for beautiful number pattern
    for k in range(1, len(binary_rep)):
        beautiful_pattern = '1' * k + '0' * k
        if binary_rep == beautiful_pattern:
            return True
    return False

n = int(input())
greatest_beautiful_divisor = 1  # Initialize the greatest beautiful divisor

for div in divisor(n):
    if is_beautiful(div):
        greatest_beautiful_divisor = max(greatest_beautiful_divisor, div)

print(greatest_beautiful_divisor)"
80,A,Panoramix's Prediction,PROGRAMMING,['brute force'],"A prime number is a number which has exactly two distinct divisors: one and itself. For example, numbers 2, 7, 3 are prime, and 1, 6, 4 are not.

The next prime number after *x* is the smallest prime number greater than *x*. For example, the next prime number after 2 is 3, and the next prime number after 3 is 5. Note that there is exactly one next prime number after each number. So 5 is not the next prime number for 2.

One cold April morning Panoramix predicted that soon Kakofonix will break free from his straitjacket, and this will be a black day for the residents of the Gallic countryside.

Panoramix's prophecy tells that if some day Asterix and Obelix beat exactly *x* Roman soldiers, where *x* is a prime number, and next day they beat exactly *y* Roman soldiers, where *y* is the next prime number after *x*, then it's time to wait for Armageddon, for nothing can shut Kakofonix up while he sings his infernal song.

Yesterday the Gauls beat *n* Roman soldiers and it turned out that the number *n* was prime! Today their victims were a troop of *m* Romans (*m*<=&gt;<=*n*). Determine whether the Gauls should wait for the black day after today's victory of Asterix and Obelix?","The first and only input line contains two positive integers — *n* and *m* (2<=≤<=*n*<=&lt;<=*m*<=≤<=50). It is guaranteed that *n* is prime.

Pretests contain all the cases with restrictions 2<=≤<=*n*<=&lt;<=*m*<=≤<=4.","Print YES, if *m* is the next prime number after *n*, or NO otherwise.","['3 5\n', '7 11\n', '7 9\n']","['YES', 'YES', 'NO']",none,WRONG_ANSWER,"n,m=map(int,input().split())
l=[2,3,5,7,11,13,17,19,23,29,31,37,39,41,43,47,49,51,53]
z=""NO""
for i in range(len(l)):
    if l[i] == n and l[i+1] ==m:
        z=""YES""
print(z)









","""""""
165A | Supercentral Point: implementation
""""""

def supercentral_point():
    n = int(input())
    ss = []
    for _ in range(n):
        x, y = map(int, input().split())
        ss.append((x, y))
    
    count = 0
    for x, y in ss:
        has_upper = has_lower = has_left = has_right = False
        
        for x2, y2 in ss:
            if x2 == x and y2 > y:
                has_upper = True
            if x2 == x and y2 < y:
                has_lower = True
            if y2 == y and x2 < x:
                has_left = True
            if y2 == y and x2 > x:
                has_right = True
        
        if has_upper and has_lower and has_left and has_right:
            count += 1
            
    print(count)

supercentral_point()"
618,A,Slime Combining,PROGRAMMING,['implementation'],"Your friend recently gave you some slimes for your birthday. You have *n* slimes all initially with value 1.

You are going to play a game with these slimes. Initially, you put a single slime by itself in a row. Then, you will add the other *n*<=-<=1 slimes one by one. When you add a slime, you place it at the right of all already placed slimes. Then, while the last two slimes in the row have the same value *v*, you combine them together to create a slime with value *v*<=+<=1.

You would like to see what the final state of the row is after you've added all *n* slimes. Please print the values of the slimes in the row from left to right.","The first line of the input will contain a single integer, *n* (1<=≤<=*n*<=≤<=100<=000).","Output a single line with *k* integers, where *k* is the number of slimes in the row after you've finished the procedure described in the problem statement. The *i*-th of these numbers should be the value of the *i*-th slime from the left.","['1\n', '2\n', '3\n', '8\n']","['1\n', '2\n', '2 1\n', '4\n']","In the first sample, we only have a single slime with value 1. The final state of the board is just a single slime with value 1.

In the second sample, we perform the following steps:

Initially we place a single slime in a row by itself. Thus, row is initially 1.

Then, we will add another slime. The row is now 1 1. Since two rightmost slimes have the same values, we should replace these slimes with one with value 2. Thus, the final state of the board is 2.

In the third sample, after adding the first two slimes, our row is 2. After adding one more slime, the row becomes 2 1.

In the last sample, the steps look as follows: 
 1.  1 1.  2 1.  2 1 1.  3 1.  3 1 1.  3 2 1.  3 2 1 1.  4",WRONG_ANSWER,"import math
def Log2(x):
	return (math.log10(x) /
			math.log10(2))
def isPowerOfTwo(n):
	return (math.ceil(Log2(n)) == math.floor(Log2(n)))
l = []
temp = []
n = int(input())
if isPowerOfTwo(n) :
    x = Log2(n)
    print(x+1)
else :
    for i in range(n) :
        '''if len(l) > 1 and l[-1] == l[-2] :
            l[-2] += 1
            l.pop()
            print(""Begin : "",l)
        print(""Mid : "",l)
        if i==0 :
            l.append(1)
            cntr += 1
        else :
            if l[-1] == cntr :
                l[-1] += cntr
            else :
                l.append(1)
                cntr = 1
        if len(l) > 1 and l[-1] == l[-2] :
            l[-2] += 1
            l.pop()
            print(""End : "" ,l)'''
        l.append(1)
    if 2**math.ceil(Log2(n)) - 1 == n :
        temp = [i for i in range(1,math.ceil(Log2(n))+1)]
    else :
        if len(l)%2 != 0 :
            temp.append(1)
        temp.append(math.ceil(Log2(n)))
    print(temp)

","import sys, os, io
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

def f(u, v):
    return u + m * v

a, b, m = map(int, input().split())
G = [set() for _ in range(a + 1)]
edges = []
for _ in range(m):
    x, y = map(int, input().split())
    G[x].add(y)
    edges.append((x, y))

# Maximum degree of edges in the bipartite graph
max_degree = 0
for x in range(1, a + 1):
    max_degree = max(max_degree, len(G[x]))

# The number of colors needed is at most the maximum degree of edges in the graph + 1
colors = [0] * m
color_count = 0

# Assign colors to edges
edge_color = {}
for idx, (x, y) in enumerate(edges):
    edge_color[f(x, y)] = idx

for x in range(1, a + 1):
    current_color = 1
    used_colors = set()
    
    for y in G[x]:
        edge = f(x, y)
        if edge in edge_color:
            used_colors.add(colors[edge_color[edge]])
    
    for y in G[x]:
        edge = f(x, y)
        if edge in edge_color and colors[edge_color[edge]] == 0:
            while current_color in used_colors:
                current_color += 1
            colors[edge_color[edge]] = current_color
            used_colors.add(current_color)

    color_count = max(color_count, current_color)

print(color_count)
print("" "".join(map(str, colors)))"
760,A,Petr and a calendar,PROGRAMMING,"['implementation', 'math']","Petr wants to make a calendar for current month. For this purpose he draws a table in which columns correspond to weeks (a week is seven consequent days from Monday to Sunday), rows correspond to weekdays, and cells contain dates. For example, a calendar for January 2017 should look like on the picture:

Petr wants to know how many columns his table should have given the month and the weekday of the first date of that month? Assume that the year is non-leap.","The only line contain two integers *m* and *d* (1<=≤<=*m*<=≤<=12, 1<=≤<=*d*<=≤<=7) — the number of month (January is the first month, December is the twelfth) and the weekday of the first date of this month (1 is Monday, 7 is Sunday).",Print single integer: the number of columns the table should have.,"['1 7\n', '1 1\n', '11 6\n']","['6\n', '5\n', '5\n']","The first example corresponds to the January 2017 shown on the picture in the statements.

In the second example 1-st January is Monday, so the whole month fits into 5 columns.

In the third example 1-st November is Saturday and 5 columns is enough.",WRONG_ANSWER,"a,b=map(int,input().split())
if a in range(1,8,2) or a in range(8,13,2):
	if b==6 or b==7:
		print(6)
	else: 
		print(5)
elif a==2:
	print(4)
else:
	if b==7:
		print(6)
	else:
		print(5)","n = int(input())
l = []
count = 0

# Read points into a list
for i in range(n):
    xy = list(map(int, input().split()))
    l.append(xy)

# Check if a point has the required neighbors
def isSupercentral(point):
    x, y = point
    hasUpper = hasLower = hasLeft = hasRight = False
    
    # Check for each point in the list
    for px, py in l:
        if px == x and py > y:
            hasUpper = True
        elif px == x and py < y:
            hasLower = True
        elif py == y and px < x:
            hasLeft = True
        elif py == y and px > x:
            hasRight = True

    return hasUpper and hasLower and hasLeft and hasRight

# Count supercentral points
for point in l:
    if isSupercentral(point):
        count += 1

print(count)"
978,G,Petya's Exams,PROGRAMMING,"['greedy', 'implementation', 'sortings']","Petya studies at university. The current academic year finishes with $n$ special days. Petya needs to pass $m$ exams in those special days. The special days in this problem are numbered from $1$ to $n$.

There are three values about each exam:
 -  $s_i$ — the day, when questions for the $i$-th exam will be published, -  $d_i$ — the day of the $i$-th exam ($s_i &lt; d_i$), -  $c_i$ — number of days Petya needs to prepare for the $i$-th exam. For the $i$-th exam Petya should prepare in days between $s_i$ and $d_i-1$, inclusive. 
There are three types of activities for Petya in each day: to spend a day doing nothing (taking a rest), to spend a day passing exactly one exam or to spend a day preparing for exactly one exam. So he can't pass/prepare for multiple exams in a day. He can't mix his activities in a day. If he is preparing for the $i$-th exam in day $j$, then $s_i \le j &lt; d_i$.

It is allowed to have breaks in a preparation to an exam and to alternate preparations for different exams in consecutive days. So preparation for an exam is not required to be done in consecutive days.

Find the schedule for Petya to prepare for all exams and pass them, or report that it is impossible.","The first line contains two integers $n$ and $m$ $(2 \le n \le 100, 1 \le m \le n)$ — the number of days and the number of exams.

Each of the following $m$ lines contains three integers $s_i$, $d_i$, $c_i$ $(1 \le s_i &lt; d_i \le n, 1 \le c_i \le n)$ — the day, when questions for the $i$-th exam will be given, the day of the $i$-th exam, number of days Petya needs to prepare for the $i$-th exam. 

Guaranteed, that all the exams will be in different days. Questions for different exams can be given in the same day. It is possible that, in the day of some exam, the questions for other exams are given.","If Petya can not prepare and pass all the exams, print -1. In case of positive answer, print $n$ integers, where the $j$-th number is:
 -  $(m + 1)$, if the $j$-th day is a day of some exam (recall that in each day no more than one exam is conducted), -  zero, if in the $j$-th day Petya will have a rest, -  $i$ ($1 \le i \le m$), if Petya will prepare for the $i$-th exam in the day $j$ (the total number of days Petya prepares for each exam should be strictly equal to the number of days needed to prepare for it).Assume that the exams are numbered in order of appearing in the input, starting from $1$.If there are multiple schedules, print any of them.","['5 2\n1 3 1\n1 5 1\n', '3 2\n1 3 1\n1 2 1\n', '10 3\n4 7 2\n1 10 3\n8 9 1\n']","['1 2 3 0 3 \n', '-1\n', '2 2 2 1 1 0 4 3 4 4 \n']","In the first example Petya can, for example, prepare for exam $1$ in the first day, prepare for exam $2$ in the second day, pass exam $1$ in the third day, relax in the fourth day, and pass exam $2$ in the fifth day. So, he can prepare and pass all exams.

In the second example, there are three days and two exams. So, Petya can prepare in only one day (because in two other days he should pass exams). Then Petya can not prepare and pass all exams.",WRONG_ANSWER,"n, m = map(int, input().split())

# создаем список экзаменов
exams = []
for i in range(m):
    s, d, c = map(int, input().split())
    exams.append((s, d, c, i + 1))  # добавляем номер экзамена

# сортируем экзамены по дню начала подготовки
exams.sort(key=lambda x: x[0])

# создаем список расписания и список занятых дней
schedule = [0] * n
used = set()

for s, d, c, i in exams:
    day = s
    while day < d:
        if day not in used:
            schedule[day - 1] = i
            used.update(range(day, min(day + c, d)))
            break
        day += 1
    else:
        print(-1)
        exit()

# заполняем оставшиеся дни отдыхом
for i in range(n):
    if schedule[i] == 0:
        schedule[i] = m + 1

print(*schedule)
","def get_digits(x):
    return set(map(int, str(x).replace(""0"", """")))

def min_operations_to_zero(n):
    operations = 0
    
    while n > 0:
        digits = get_digits(n)
        # Subtract the maximum digit from n
        max_digit = max(digits)
        n -= max_digit
        operations += 1
    
    return operations

# Read the input
magic_number = int(input().strip())
# Calculate the minimum number of operations
result = min_operations_to_zero(magic_number)
# Print the result
print(result)"
200,B,Drinks,PROGRAMMING,"['implementation', 'math']","Little Vasya loves orange juice very much. That's why any food and drink in his kitchen necessarily contains orange juice. There are *n* drinks in his fridge, the volume fraction of orange juice in the *i*-th drink equals *p**i* percent.

One day Vasya decided to make himself an orange cocktail. He took equal proportions of each of the *n* drinks and mixed them. Then he wondered, how much orange juice the cocktail has.

Find the volume fraction of orange juice in the final drink.","The first input line contains a single integer *n* (1<=≤<=*n*<=≤<=100) — the number of orange-containing drinks in Vasya's fridge. The second line contains *n* integers *p**i* (0<=≤<=*p**i*<=≤<=100) — the volume fraction of orange juice in the *i*-th drink, in percent. The numbers are separated by a space.",Print the volume fraction in percent of orange juice in Vasya's cocktail. The answer will be considered correct if the absolute or relative error does not exceed 10<=<=-<=4.,"['3\n50 50 100\n', '4\n0 25 50 75\n']","['66.666666666667\n', '37.500000000000\n']","Note to the first sample: let's assume that Vasya takes *x* milliliters of each drink from the fridge. Then the volume of pure juice in the cocktail will equal <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/c1fac6e64d3a8ee6a5ac138cbe51e60039b22473.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> milliliters. The total cocktail's volume equals 3·*x* milliliters, so the volume fraction of the juice in the cocktail equals <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/ceb0664e55a1f9f5fa1243ec74680a4665a4d58d.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>, that is, 66.(6) percent.",OK,"n=int(input())
print(sum(list(map(int,input().split())))/n)","def max_happiness(N, S, player_info):
    pizzas_a = []
    pizzas_b = []
    total_slices = 0
    
    for slices, hap_a, hap_b in player_info:
        total_slices += slices
        # Store the number of slices and happiness for the type that gives more happiness
        if hap_a > hap_b:
            pizzas_a.append((slices, hap_a))
        else:
            pizzas_b.append((slices, hap_b))
    
    # Calculate the total number of pizzas needed
    total_pizzas = (total_slices + S - 1) // S
    
    # Calculate maximum happiness for both types of pizzas
    happiness_a = sum(slices * hap for slices, hap in pizzas_a)
    happiness_b = sum(slices * hap for slices, hap in pizzas_b)
    
    # Since we can choose any type of pizza, return the best option
    return total_pizzas * max(happiness_a, happiness_b)

# Example usage
# N, S = map(int, input().split())
# player_info = [tuple(map(int, input().split())) for _ in range(N)]
# print(max_happiness(N, S, player_info))"
713,C,Sonya and Problem Wihtout a Legend,PROGRAMMING,"['dp', 'sortings']","Sonya was unable to think of a story for this problem, so here comes the formal description.

You are given the array containing *n* positive integers. At one turn you can pick any element and increase or decrease it by 1. The goal is the make the array strictly increasing by making the minimum possible number of operations. You are allowed to change elements in any way, they can become negative or equal to 0.","The first line of the input contains a single integer *n* (1<=≤<=*n*<=≤<=3000) — the length of the array.

Next line contains *n* integer *a**i* (1<=≤<=*a**i*<=≤<=109).",Print the minimum number of operation required to make the array strictly increasing.,"['7\n2 1 5 11 5 9 11\n', '5\n5 4 3 2 1\n']","['9\n', '12\n']","In the first sample, the array is going to look as follows:

2 3 5 6 7 9 11

|2 - 2| + |1 - 3| + |5 - 5| + |11 - 6| + |5 - 7| + |9 - 9| + |11 - 11| = 9

And for the second sample:

1 2 3 4 5

|5 - 1| + |4 - 2| + |3 - 3| + |2 - 4| + |1 - 5| = 12",OK,"from bisect import bisect_left as BL

n = int(input())
graph = [(-99**9, 0)] # x, slope
ans = 0
for i,a in enumerate(map(int,input().split())):
    a-= i
    new = []
    turnj = BL(graph, (a,99**9)) - 1
    if turnj != len(graph)-1:
        ans+= graph[-1][0] - a
    
    # add |x-a|
    for j in range(turnj):
        x, sl = graph[j]
        new.append((x, sl-1))
    for j in range(turnj, len(graph)):
        x, sl = graph[j]
        if j == turnj:
            new.append((x, sl-1))
            new.append((a, sl+1))
        else: new.append((x, sl+1))
    
    # remove positive slopes
    graph = new
    while graph[-1][1] > 0: x, sl = graph.pop()
    if graph[-1][1] != 0: graph.append((x, 0))
print(ans)","# Equator .. 962A

def equator(a):
    total_problems = sum(a)  # Calculate total number of problems to be solved
    half_problems = total_problems / 2  # Calculate half of total problems
    solved_problems = 0  # Initialize the counter for solved problems

    # Iterate through each day's problems
    for i in range(len(a)):
        solved_problems += a[i]  # Accumulate solved problems
        if solved_problems >= half_problems:  # Check if half or more problems are solved
            return i + 1  # Return the day index (1-based)
    
    return -1  # Just in case, return -1 if the condition is never met (shouldn't happen)

# Input reading
n = int(input())  # Number of days
a = list(map(int, input().split()))  # List of problems to be solved each day
print(equator(a))  # Print the result of the equator function"
276,B,Little Girl and Game,PROGRAMMING,"['games', 'greedy']","The Little Girl loves problems on games very much. Here's one of them.

Two players have got a string *s*, consisting of lowercase English letters. They play a game that is described by the following rules:
 -  The players move in turns; In one move the player can remove an arbitrary letter from string *s*. -  If the player before his turn can reorder the letters in string *s* so as to get a palindrome, this player wins. A palindrome is a string that reads the same both ways (from left to right, and vice versa). For example, string ""abba"" is a palindrome and string ""abc"" isn't. 
Determine which player will win, provided that both sides play optimally well — the one who moves first or the one who moves second.","The input contains a single line, containing string *s* (1<=≤<=|*s*|<=<=≤<=<=103). String *s* consists of lowercase English letters.","In a single line print word ""First"" if the first player wins (provided that both players play optimally well). Otherwise, print word ""Second"". Print the words without the quotes.","['aba\n', 'abca\n']","['First\n', 'Second\n']",none,WRONG_ANSWER,"import random
def isPalin(string):
    return True if string==string[::-1] else False
stri = list(input().strip())
flag=0
count=0
while True:
    s = """"
    for ele in stri:
        s+=ele
    if(isPalin(s)):
        break
    elif(len(stri)==1):
        break
    else:
        stri.pop(random.randint(0,len(stri)-1))
        flag = count+1%2
if(flag==0):
    print(""First"")
elif(flag==1):
    print(""Second"")","n1 = input()
n2 = input()

def split(num):
    return list(num)

# Split both numbers into lists of digits
digits1 = split(n1)
digits2 = split(n2)

# Create the result list based on the XOR logic
result = []
for d1, d2 in zip(digits1, digits2):
    result.append('1' if d1 != d2 else '0')

# Join the result list into a string and print it
print(''.join(result))"
343,B,Alternating Current,PROGRAMMING,"['data structures', 'greedy', 'implementation']","Mad scientist Mike has just finished constructing a new device to search for extraterrestrial intelligence! He was in such a hurry to launch it for the first time that he plugged in the power wires without giving it a proper glance and started experimenting right away. After a while Mike observed that the wires ended up entangled and now have to be untangled again.

The device is powered by two wires ""plus"" and ""minus"". The wires run along the floor from the wall (on the left) to the device (on the right). Both the wall and the device have two contacts in them on the same level, into which the wires are plugged in some order. The wires are considered entangled if there are one or more places where one wire runs above the other one. For example, the picture below has four such places (top view):

Mike knows the sequence in which the wires run above each other. Mike also noticed that on the left side, the ""plus"" wire is always plugged into the top contact (as seen on the picture). He would like to untangle the wires without unplugging them and without moving the device. Determine if it is possible to do that. A wire can be freely moved and stretched on the floor, but cannot be cut.

To understand the problem better please read the notes to the test samples.","The single line of the input contains a sequence of characters ""+"" and ""-"" of length *n* (1<=≤<=*n*<=≤<=100000). The *i*-th (1<=≤<=*i*<=≤<=*n*) position of the sequence contains the character ""+"", if on the *i*-th step from the wall the ""plus"" wire runs above the ""minus"" wire, and the character ""-"" otherwise.","Print either ""Yes"" (without the quotes) if the wires can be untangled or ""No"" (without the quotes) if the wires cannot be untangled.","['-++-\n', '+-\n', '++\n', '-\n']","['Yes\n', 'No\n', 'Yes\n', 'No\n']","The first testcase corresponds to the picture in the statement. To untangle the wires, one can first move the ""plus"" wire lower, thus eliminating the two crosses in the middle, and then draw it under the ""minus"" wire, eliminating also the remaining two crosses.

In the second testcase the ""plus"" wire makes one full revolution around the ""minus"" wire. Thus the wires cannot be untangled: 

In the third testcase the ""plus"" wire simply runs above the ""minus"" wire twice in sequence. The wires can be untangled by lifting ""plus"" and moving it higher: 

In the fourth testcase the ""minus"" wire runs above the ""plus"" wire once. The wires cannot be untangled without moving the device itself:",WRONG_ANSWER,"x = list(input())
pos = 0
nag = 0
for i in range(1,len(x)):
    if(x[i-1]==x[i]):
        pos += 1

if(pos>0):
    print(""Yes"")
else :
    print(""No"")","def prog():
    from sys import stdin
    from collections import deque

    n, x = map(int, stdin.readline().split())
    x -= 1
    d = [[] for i in range(n)]
    
    for i in range(n - 1):
        a, b = map(int, stdin.readline().split())
        d[a - 1].append(b - 1)
        d[b - 1].append(a - 1)

    # Function to perform BFS and calculate distances
    def bfs(start):
        distances = [-1] * n
        queue = deque([start])
        distances[start] = 0
        
        while queue:
            current = queue.popleft()
            for neighbor in d[current]:
                if distances[neighbor] == -1:  # Not visited
                    distances[neighbor] = distances[current] + 1
                    queue.append(neighbor)
        
        return distances

    # Calculate distances from root (vertex 1)
    distances_from_root = bfs(0)
    # Calculate distances from Bob's starting position
    distances_from_x = bfs(x)

    max_distance = 0

    # Determine maximum distance that Bob can create
    for i in range(n):
        if distances_from_root[i] > distances_from_x[i]:
            max_distance = max(max_distance, distances_from_root[i])

    # Moves made will be twice the max distance (since both make moves)
    print(max_distance * 2)"
877,A,Alex and broken contest,PROGRAMMING,"['implementation', 'strings']","One day Alex was creating a contest about his friends, but accidentally deleted it. Fortunately, all the problems were saved, but now he needs to find them among other problems.

But there are too many problems, to do it manually. Alex asks you to write a program, which will determine if a problem is from this contest by its name.

It is known, that problem is from this contest if and only if its name contains one of Alex's friends' name exactly once. His friends' names are ""Danil"", ""Olya"", ""Slava"", ""Ann"" and ""Nikita"".

Names are case sensitive.","The only line contains string from lowercase and uppercase letters and ""_"" symbols of length, not more than 100 — the name of the problem.","Print ""YES"", if problem is from this contest, and ""NO"" otherwise.","['Alex_and_broken_contest\n', 'NikitaAndString\n', 'Danil_and_Olya\n']","['NO', 'YES', 'NO']",none,OK,"import re

str = 'Danil|Olya|Slava|Ann|Nikita'
if (len(re.findall(str, input())) == 1):
 print('YES')
else:
 print('NO')
  	  			   				   	 	      				","from sys import stdin, stdout

# Read the input integer
a = int(stdin.readline().strip())

# Check if the last digit is even or odd
if a % 2 == 0:
    stdout.write('1\n')  # Output 1 for even
else:
    stdout.write('0\n')  # Output 0 for odd"
508,A,Pasha and Pixels,PROGRAMMING,['brute force'],"Pasha loves his phone and also putting his hair up... But the hair is now irrelevant.

Pasha has installed a new game to his phone. The goal of the game is following. There is a rectangular field consisting of *n* row with *m* pixels in each row. Initially, all the pixels are colored white. In one move, Pasha can choose any pixel and color it black. In particular, he can choose the pixel that is already black, then after the boy's move the pixel does not change, that is, it remains black. Pasha loses the game when a 2<=×<=2 square consisting of black pixels is formed. 

Pasha has made a plan of *k* moves, according to which he will paint pixels. Each turn in his plan is represented as a pair of numbers *i* and *j*, denoting respectively the row and the column of the pixel to be colored on the current move.

Determine whether Pasha loses if he acts in accordance with his plan, and if he does, on what move the 2<=×<=2 square consisting of black pixels is formed.","The first line of the input contains three integers *n*,<=*m*,<=*k* (1<=≤<=*n*,<=*m*<=≤<=1000, 1<=≤<=*k*<=≤<=105) — the number of rows, the number of columns and the number of moves that Pasha is going to perform. 

The next *k* lines contain Pasha's moves in the order he makes them. Each line contains two integers *i* and *j* (1<=≤<=*i*<=≤<=*n*, 1<=≤<=*j*<=≤<=*m*), representing the row number and column number of the pixel that was painted during a move.","If Pasha loses, print the number of the move when the 2<=×<=2 square consisting of black pixels is formed.

If Pasha doesn't lose, that is, no 2<=×<=2 square consisting of black pixels is formed during the given *k* moves, print 0.","['2 2 4\n1 1\n1 2\n2 1\n2 2\n', '2 3 6\n2 3\n2 2\n1 3\n2 2\n1 2\n1 1\n', '5 3 7\n2 3\n1 2\n1 1\n4 1\n3 1\n5 3\n3 2\n']","['4\n', '5\n', '0\n']",none,RUNTIME_ERROR,"# -*- coding: utf-8 -*-
""""""
Created on Thu Dec 15 10:26:22 2022

@author: thinkpad
""""""

n,m,k = map(int,input().split())

res = [[0 for _ in range(m+2)] for _  in range(n+2)]
dir1 = [[-1,-1],[-1,0],[0,-1]]
dir2 = [[-1,0],[-1,1],[0,1]]
dir3 = [[0,-1],[1,-1],[1,0]]
dir4 = [[0,1],[1,1],[1,0]]

def check(i,j):
    al1 = 0
    for d in dir1:
        x,y = d[0],d[1]
        if res[i+x][j+y]==1:
            al1+=1
    if al1 == 3:
        return False
    al2 = 0
    for d in dir2:
        x,y = d[0],d[1]
        if res[i+x][j+y]==1:
            al2+=1
    if al2 == 3:
        return False        
    al3 = 0
    for d in dir3:
        x,y = d[0],d[1]
        if res[i+x][j+y]==1:
            al3+=1
    if al3 == 3:
        return False        
    al4 = 0
    for d in dir4:
        x,y = d[0],d[1]
        if res[i+x][j+y]==1:
            al4+=1
    if al4 == 3:
        return False
    return True
paint = []
for _ in range(k):
    paint.append(map(int,input().split()))
flag = True
for t in range(k):
    i,j =paint[t][0],paint[t][1]
    res[i][j]=1
    if check(i,j)==False:
        print(t+1)
        flag = False
    else:
        continue

if flag == True:
    print(0)","import sys

def gcd(a, b):
    if b == 0:
        return a
    r = a % b
    return gcd(b, r)

def count_visits(a, b):
    lcm = (a * b) // gcd(a, b)  # Least common multiple of a and b
    dasha_time = lcm // a       # Total time divided by frequency to get visits for Dasha
    masha_time = lcm // b       # Total time divided by frequency to get visits for Masha
    
    if dasha_time > masha_time:
        return ""Dasha""
    elif masha_time > dasha_time:
        return ""Masha""
    else:
        return ""Equal""

if __name__ == ""__main__"":
    a, b = map(int, sys.stdin.readline().strip().split())
    print(count_visits(a, b))"
0,none,none,none,['none'],"Santa Claus is the first who came to the Christmas Olympiad, and he is going to be the first to take his place at a desk! In the classroom there are *n* lanes of *m* desks each, and there are two working places at each of the desks. The lanes are numbered from 1 to *n* from the left to the right, the desks in a lane are numbered from 1 to *m* starting from the blackboard. Note that the lanes go perpendicularly to the blackboard, not along it (see picture).

The organizers numbered all the working places from 1 to 2*nm*. The places are numbered by lanes (i. e. all the places of the first lane go first, then all the places of the second lane, and so on), in a lane the places are numbered starting from the nearest to the blackboard (i. e. from the first desk in the lane), at each desk, the place on the left is numbered before the place on the right.

Santa Clause knows that his place has number *k*. Help him to determine at which lane at which desk he should sit, and whether his place is on the left or on the right!","The only line contains three integers *n*, *m* and *k* (1<=≤<=*n*,<=*m*<=≤<=10<=000, 1<=≤<=*k*<=≤<=2*nm*) — the number of lanes, the number of desks in each lane and the number of Santa Claus' place.","Print two integers: the number of lane *r*, the number of desk *d*, and a character *s*, which stands for the side of the desk Santa Claus. The character *s* should be ""L"", if Santa Clause should sit on the left, and ""R"" if his place is on the right.","['4 3 9\n', '4 3 24\n', '2 4 4\n']","['2 2 L\n', '4 3 R\n', '1 2 R\n']","The first and the second samples are shown on the picture. The green place corresponds to Santa Claus' place in the first example, the blue place corresponds to Santa Claus' place in the second example.

In the third sample there are two lanes with four desks in each, and Santa Claus has the fourth place. Thus, his place is in the first lane at the second desk on the right.",OK,"ins = list(map(int, input().split()))
n = ins[0]
m = ins[1]
k = ins[2]
koln = 1
kolm = 1
while k > 2*m:
    k -= 2*m
    koln+=1
while k > 2:
    k-=2
    kolm += 1
if k == 1:
    print(koln,kolm,""L"")
else:
    print(koln, kolm, ""R"")","def max_cake_cells(r, c, cake):
    rows = [True] * r  # To track valid rows
    cols = [True] * c  # To track valid columns

    # Determine which rows and columns are blocked by strawberries
    for i in range(r):
        for j in range(c):
            if cake[i][j] == 'S':
                rows[i] = False  # Mark row as blocked
                cols[j] = False  # Mark column as blocked

    # Count the number of cake cells that can be eaten
    total_cells = 0

    # Count cells in valid rows
    for i in range(r):
        if rows[i]:
            total_cells += c  # All cells in this row can be eaten

    # Count cells in valid columns that are not in valid rows
    for j in range(c):
        if cols[j]:
            for i in range(r):
                if not rows[i]:  # Only count cells from blocked rows
                    if cake[i][j] == '.':
                        total_cells += 1

    return total_cells

# Input reading
r, c = map(int, input().split())
cake = [input().strip() for _ in range(r)]

# Getting the result and printing it
result = max_cake_cells(r, c, cake)
print(result)"
749,A,Bachgold Problem,PROGRAMMING,"['greedy', 'implementation', 'math', 'number theory']","Bachgold problem is very easy to formulate. Given a positive integer *n* represent it as a sum of maximum possible number of prime numbers. One can prove that such representation exists for any integer greater than 1.

Recall that integer *k* is called prime if it is greater than 1 and has exactly two positive integer divisors — 1 and *k*.",The only line of the input contains a single integer *n* (2<=≤<=*n*<=≤<=100<=000).,"The first line of the output contains a single integer *k* — maximum possible number of primes in representation.

The second line should contain *k* primes with their sum equal to *n*. You can print them in any order. If there are several optimal solution, print any of them.","['5\n', '6\n']","['2\n2 3\n', '3\n2 2 2\n']",none,OK,"a = int(input())
print(a // 2)
b = [2] * (a // 2)
if a % 2 == 0:
	print(*b)
else:
	b[-1] = 3
	print(*b)","args = int(input())
def watermelon(weight: int):
    if weight == 2:
        return ""NO""  # 2 cannot be divided into two positive even parts
    elif weight % 2 == 0:
        return ""YES""  # Any even weight greater than 2 can be divided into two even parts
    else:
        return ""NO""  # Odd weights cannot be divided into two even parts

print(watermelon(args))"
348,A,Mafia,PROGRAMMING,"['binary search', 'math', 'sortings']","One day *n* friends gathered together to play ""Mafia"". During each round of the game some player must be the supervisor and other *n*<=-<=1 people take part in the game. For each person we know in how many rounds he wants to be a player, not the supervisor: the *i*-th person wants to play *a**i* rounds. What is the minimum number of rounds of the ""Mafia"" game they need to play to let each person play at least as many rounds as they want?","The first line contains integer *n* (3<=≤<=*n*<=≤<=105). The second line contains *n* space-separated integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=109) — the *i*-th number in the list is the number of rounds the *i*-th person wants to play.","In a single line print a single integer — the minimum number of game rounds the friends need to let the *i*-th person play at least *a**i* rounds.

Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.","['3\n3 2 2\n', '4\n2 2 2 2\n']","['4\n', '3\n']","You don't need to know the rules of ""Mafia"" to solve this problem. If you're curious, it's a game Russia got from the Soviet times: http://en.wikipedia.org/wiki/Mafia_(party_game).",OK,"from cmath import inf
import math
import sys
from os import path
#import bisect
#import math
from functools import reduce
import collections
import sys
 
if (path.exists('CP/input.txt')):
    sys.stdout = open('CP/output.txt', 'w')
    sys.stdin = open('CP/input.txt', 'r')
    
 
 
def ok(mid,arr,maxi):
    d = 0
    for x in arr:
        d += (mid - x)
        
    #print(d)
    
    if(d>=mid):
        return True
 
    return False
        
    
                         
def answer():
    n = int(input())
    arr  = list(map(int,input().split()))
    
    l,r = 0,(2**31 - 1)
    for x in arr:
        l = max(l,x)
    maxi = l
    
    ans=-1
    
    while(l<=r):
        #print(l,"" "",r)
        mid = (l+r)//2
        #print(mid)
        if(ok(mid,arr,maxi)):
            ans = mid
            r=mid-1
        else:
            l=mid+1
    
    print(ans)
    
    
    
    
        
        
                
        
                
            
        
    
 
 
#t = int(input())
t=1
for _ in range(t):
	answer()","# LUOGU_RID: 120038312
def next_lucky_year(n):
    # Incrementing year until we find a lucky year
    while True:
        n += 1
        # Convert current year to string to count non-zero digits
        if sum(1 for digit in str(n) if digit != '0') <= 1:
            # Found a lucky year
            return n - (n-1)  # Returning the difference which is always 1 year"
677,A,Vanya and Fence,PROGRAMMING,['implementation'],"Vanya and his friends are walking along the fence of height *h* and they do not want the guard to notice them. In order to achieve this the height of each of the friends should not exceed *h*. If the height of some person is greater than *h* he can bend down and then he surely won't be noticed by the guard. The height of the *i*-th person is equal to *a**i*.

Consider the width of the person walking as usual to be equal to 1, while the width of the bent person is equal to 2. Friends want to talk to each other while walking, so they would like to walk in a single row. What is the minimum width of the road, such that friends can walk in a row and remain unattended by the guard?","The first line of the input contains two integers *n* and *h* (1<=≤<=*n*<=≤<=1000, 1<=≤<=*h*<=≤<=1000) — the number of friends and the height of the fence, respectively.

The second line contains *n* integers *a**i* (1<=≤<=*a**i*<=≤<=2*h*), the *i*-th of them is equal to the height of the *i*-th person.",Print a single integer — the minimum possible valid width of the road.,"['3 7\n4 5 14\n', '6 1\n1 1 1 1 1 1\n', '6 5\n7 6 8 9 10 5\n']","['4\n', '6\n', '11\n']","In the first sample, only person number 3 must bend down, so the required width is equal to 1 + 1 + 2 = 4.

In the second sample, all friends are short enough and no one has to bend, so the width 1 + 1 + 1 + 1 + 1 + 1 = 6 is enough.

In the third sample, all the persons have to bend, except the last one. The required minimum width of the road is equal to 2 + 2 + 2 + 2 + 2 + 1 = 11.",OK,"
n,h=map(int, input().split())
a= list(map(int, input().strip().split())) [:n]

c=0
for i in a:
    if(i>h):
        c+=2
    else:
        c+=1

print(c)","y -= 1
    tree[x].append(y)
    tree[y].append(x)

# Determine the maximum degree of any node
max_degree = max(len(tree[i]) for i in range(n))

# The minimum number of colors needed is the maximum degree plus one
ans = max_degree + 1

# Assign colors to each square (using 1-indexed colors)
for i in range(n):
    # Use a set to keep track of already used colors for the adjacent nodes
    used_colors = set()
    for neighbor in tree[i]:
        if cols[neighbor] != 0:
            used_colors.add(cols[neighbor])
    
    # Assign the smallest available color
    color = 1
    while color in used_colors:
        color += 1
    cols[i] = color

# Printing the result
print(ans)
print(' '.join(map(str, cols)))"
731,A,Night at the Museum,PROGRAMMING,"['implementation', 'strings']","Grigoriy, like the hero of one famous comedy film, found a job as a night security guard at the museum. At first night he received embosser and was to take stock of the whole exposition.

Embosser is a special devise that allows to ""print"" the text of a plastic tape. Text is printed sequentially, character by character. The device consists of a wheel with a lowercase English letters written in a circle, static pointer to the current letter and a button that print the chosen letter. At one move it's allowed to rotate the alphabetic wheel one step clockwise or counterclockwise. Initially, static pointer points to letter 'a'. Other letters are located as shown on the picture:

After Grigoriy add new item to the base he has to print its name on the plastic tape and attach it to the corresponding exhibit. It's not required to return the wheel to its initial position with pointer on the letter 'a'.

Our hero is afraid that some exhibits may become alive and start to attack him, so he wants to print the names as fast as possible. Help him, for the given string find the minimum number of rotations of the wheel required to print it.",The only line of input contains the name of some exhibit — the non-empty string consisting of no more than 100 characters. It's guaranteed that the string consists of only lowercase English letters.,"Print one integer — the minimum number of rotations of the wheel, required to print the name given in the input.","['zeus\n', 'map\n', 'ares\n']","['18\n', '35\n', '34\n']","To print the string from the first sample it would be optimal to perform the following sequence of rotations: 
 1.  from 'a' to 'z' (1 rotation counterclockwise), 1.  from 'z' to 'e' (5 clockwise rotations), 1.  from 'e' to 'u' (10 rotations counterclockwise), 1.  from 'u' to 's' (2 counterclockwise rotations).",OK,"wheel = input()

counter = 0 
pointer = 'a'

for c in wheel:
  distance = abs(ord(pointer) - ord(c))
  
  if distance < 13:
    counter += distance
  else:
    counter += (26 - distance)
  pointer = c
  
print(counter)","def lcm(a, b):
    # Function to calculate the greatest common divisor (GCD)
    def gcd(x, y):
        while y:
            x, y = y, x % y
        return x
    
    # Calculate the least common multiple (LCM) using the GCD
    return abs(a * b) // gcd(a, b)

def max_lcm_three(n):
    if n == 1:
        return 1  # The maximum LCM when n is 1 is 1 (1, 1, 1)
    
    candidates = []

    # Check combinations of the three largest numbers
    if n % 2 == 0:  # If n is even
        candidates.extend([n, n-1, n-2])  # n, n-1, n-2
        candidates.extend([n, n-1, n-3])  # n, n-1, n-3
        candidates.extend([n, n-2, n-3])  # n, n-2, n-3
        candidates.extend([n-1, n-2, n-3])  # n-1, n-2, n-3
    else:  # If n is odd
        candidates.extend([n, n-1, n-1])  # n, n-1, n-1
        candidates.extend([n, n-1, n-2])  # n, n-1, n-2
        candidates.extend([n-1, n-2, n-3])  # n-1, n-2, n-3
    
    max_lcm_value = 0

    # Calculate the LCM for all candidates
    for a in candidates:
        for b in candidates:
            for c in candidates:
                max_lcm_value = max(max_lcm_value, lcm(lcm(a, b), c))

    return max_lcm_value

# Input reading
n = int(input())
# Output the maximum LCM of three integers not greater than n
print(max_lcm_three(n))"
628,A,Tennis Tournament,PROGRAMMING,"['implementation', 'math']","A tennis tournament with *n* participants is running. The participants are playing by an olympic system, so the winners move on and the losers drop out.

The tournament takes place in the following way (below, *m* is the number of the participants of the current round):
 -  let *k* be the maximal power of the number 2 such that *k*<=≤<=*m*, -  *k* participants compete in the current round and a half of them passes to the next round, the other *m*<=-<=*k* participants pass to the next round directly, -  when only one participant remains, the tournament finishes. 
Each match requires *b* bottles of water for each participant and one bottle for the judge. Besides *p* towels are given to each participant for the whole tournament.

Find the number of bottles and towels needed for the tournament.

Note that it's a tennis tournament so in each match two participants compete (one of them will win and the other will lose).","The only line contains three integers *n*,<=*b*,<=*p* (1<=≤<=*n*,<=*b*,<=*p*<=≤<=500) — the number of participants and the parameters described in the problem statement.",Print two integers *x* and *y* — the number of bottles and towels need for the tournament.,"['5 2 3\n', '8 2 4\n']","['20 15\n', '35 32\n']","In the first example will be three rounds:
 1.  in the first round will be two matches and for each match 5 bottles of water are needed (two for each of the participants and one for the judge), 1.  in the second round will be only one match, so we need another 5 bottles of water, 1.  in the third round will also be only one match, so we need another 5 bottles of water. 
So in total we need 20 bottles of water.

In the second example no participant will move on to some round directly.",WRONG_ANSWER,"n,b,p = map(int,input().split())
k = 2
cnt = 0
while n>k:
	if k*2>n:
		break
	else:
		k*=2

c = n%k
k = (k-1+c)
print(k*b*2+k,n*p)
","from math import *
from collections import *
from sys import *
t=stdin.readline
p=stdout.write

# Read the number of domino pieces
n = int(t())
upper_sum = 0
lower_sum = 0
odd_pairs = 0

# Process each domino piece
for _ in range(n):
    x, y = map(int, t().split())
    upper_sum += x
    lower_sum += y
    # Count how many pieces have one upper and one lower odd
    if (x % 2) != (y % 2):
        odd_pairs += 1

# Check the parity of sums
if upper_sum % 2 == 0 and lower_sum % 2 == 0:
    p(""0\n"")  # No rotations needed
elif odd_pairs > 0:
    p(""1\n"")  # One rotation needed
else:
    p(""-1\n"")  # Impossible to make both sums even"
157,B,Trace,PROGRAMMING,"['geometry', 'sortings']","One day, as Sherlock Holmes was tracking down one very important criminal, he found a wonderful painting on the wall. This wall could be represented as a plane. The painting had several concentric circles that divided the wall into several parts. Some parts were painted red and all the other were painted blue. Besides, any two neighboring parts were painted different colors, that is, the red and the blue color were alternating, i. e. followed one after the other. The outer area of the wall (the area that lied outside all circles) was painted blue. Help Sherlock Holmes determine the total area of red parts of the wall.

Let us remind you that two circles are called concentric if their centers coincide. Several circles are called concentric if any two of them are concentric.",The first line contains the single integer *n* (1<=≤<=*n*<=≤<=100). The second line contains *n* space-separated integers *r**i* (1<=≤<=*r**i*<=≤<=1000) — the circles' radii. It is guaranteed that all circles are different.,Print the single real number — total area of the part of the wall that is painted red. The answer is accepted if absolute or relative error doesn't exceed 10<=-<=4.,"['1\n1\n', '3\n1 4 2\n']","['3.1415926536\n', '40.8407044967\n']","In the first sample the picture is just one circle of radius 1. Inner part of the circle is painted red. The area of the red part equals π × 1<sup class=""upper-index"">2</sup> = π.

In the second sample there are three circles of radii 1, 4 and 2. Outside part of the second circle is painted blue. Part between the second and the third circles is painted red. Part between the first and the third is painted blue. And, finally, the inner part of the first circle is painted red. Overall there are two red parts: the ring between the second and the third circles and the inner part of the first circle. Total area of the red parts is equal (π × 4<sup class=""upper-index"">2</sup> - π × 2<sup class=""upper-index"">2</sup>) + π × 1<sup class=""upper-index"">2</sup> = π × 12 + π = 13π",WRONG_ANSWER,"import math
n = int(input())
string = input()
radii = sorted(map(int, string.split()))
a = 0
for x in range(n):
    a += (radii[x] ** 2) * ((-1) ** x)
print(a * math.pi)","import sys
import math
# sys.setrecursionlimit(1000000)
input = sys.stdin.readline

############ ---- USER DEFINED INPUT FUNCTIONS ---- ############

def is_unique_crossword(n, x, a):
    # Calculate the total length of segments plus the necessary 0's between them
    total_length = sum(a) + (n - 1)
    # Check if the total length matches x
    return total_length == x

# Read input values
n, x = map(int, input().split())
a = list(map(int, input().split()))

# Determine if there exists exactly one crossword
if is_unique_crossword(n, x, a):
    print(""YES"")
else:
    print(""NO"")"
431,A,Black Square,PROGRAMMING,['implementation'],"Quite recently, a very smart student named Jury decided that lectures are boring, so he downloaded a game called ""Black Square"" on his super cool touchscreen phone.

In this game, the phone's screen is divided into four vertical strips. Each second, a black square appears on some of the strips. According to the rules of the game, Jury must use this second to touch the corresponding strip to make the square go away. As Jury is both smart and lazy, he counted that he wastes exactly *a**i* calories on touching the *i*-th strip.

You've got a string *s*, describing the process of the game and numbers *a*1,<=*a*2,<=*a*3,<=*a*4. Calculate how many calories Jury needs to destroy all the squares?","The first line contains four space-separated integers *a*1, *a*2, *a*3, *a*4 (0<=≤<=*a*1,<=*a*2,<=*a*3,<=*a*4<=≤<=104).

The second line contains string *s* (1<=≤<=|*s*|<=≤<=105), where the *і*-th character of the string equals ""1"", if on the *i*-th second of the game the square appears on the first strip, ""2"", if it appears on the second strip, ""3"", if it appears on the third strip, ""4"", if it appears on the fourth strip.",Print a single integer — the total number of calories that Jury wastes.,"['1 2 3 4\n123214\n', '1 5 3 2\n11221\n']","['13\n', '13\n']",none,OK,"sList = [int(x) for x in input().split()][:4]
game = input()
count = 0
for i in game:
    count += sList[int(i)-1]


print(count)

","from math import factorial
from typing import Callable, Iterator, TypeVar, cast

_F = TypeVar(""_F"", bound=Callable[[], None])
_I = TypeVar(""_I"", bound=Iterator[int])

def max_value_in_table(n: int) -> int:
    # Initialize a 2D list (table) with zeros
    table = [[0] * (n + 1) for _ in range(n + 1)]
    
    # Set the first row and first column to 1
    for i in range(1, n + 1):
        table[i][1] = 1
        table[1][i] = 1
    
    # Fill the rest of the table according to the defined rules
    for i in range(2, n + 1):
        for j in range(2, n + 1):
            table[i][j] = table[i - 1][j] + table[i][j - 1]
    
    # The maximum value will be at the bottom-right corner of the table
    return table[n][n]

# Input
n = int(input().strip())
# Output the maximum value in the table
print(max_value_in_table(n))"
835,A,Key races,PROGRAMMING,['math'],"Two boys decided to compete in text typing on the site ""Key races"". During the competition, they have to type a text consisting of *s* characters. The first participant types one character in *v*1 milliseconds and has ping *t*1 milliseconds. The second participant types one character in *v*2 milliseconds and has ping *t*2 milliseconds.

If connection ping (delay) is *t* milliseconds, the competition passes for a participant as follows: 
 1.  Exactly after *t* milliseconds after the start of the competition the participant receives the text to be entered. 1.  Right after that he starts to type it. 1.  Exactly *t* milliseconds after he ends typing all the text, the site receives information about it. 
The winner is the participant whose information on the success comes earlier. If the information comes from both participants at the same time, it is considered that there is a draw.

Given the length of the text and the information about participants, determine the result of the game.","The first line contains five integers *s*, *v*1, *v*2, *t*1, *t*2 (1<=≤<=*s*,<=*v*1,<=*v*2,<=*t*1,<=*t*2<=≤<=1000) — the number of characters in the text, the time of typing one character for the first participant, the time of typing one character for the the second participant, the ping of the first participant and the ping of the second participant.","If the first participant wins, print ""First"". If the second participant wins, print ""Second"". In case of a draw print ""Friendship"".","['5 1 2 1 2\n', '3 3 1 1 1\n', '4 5 3 1 5\n']","['First\n', 'Second\n', 'Friendship\n']","In the first example, information on the success of the first participant comes in 7 milliseconds, of the second participant — in 14 milliseconds. So, the first wins.

In the second example, information on the success of the first participant comes in 11 milliseconds, of the second participant — in 5 milliseconds. So, the second wins.

In the third example, information on the success of the first participant comes in 22 milliseconds, of the second participant — in 22 milliseconds. So, it is be a draw.",OK,"s, v_1, v_2, t_1, t_2 = map(int, input().split())
if (result_1 := s * v_1 + 2 * t_1) != (result_2 := s * v_2 + 2 * t_2):
    if result_1 > result_2:
        print('Second')
    else:
        print('First')
else:
    print('Friendship')","# https://codeforces.com/problemset/problem/608/A
# brute force, implementation
# Gde Anantha Priharsena
# 14 Juli 2020
# Approach : 
# difficulty : 1000

n, s = map(int, input().split())  # Reading number of passengers and top floor number
passengers = []  # List to store passenger information

for _ in range(n):
    f, t = map(int, input().split())  # Reading floor and arrival time for each passenger
    passengers.append((f, t))

current_time = 0  # Initialize current time at 0
current_floor = s  # Elevator starts at the top floor

# Sort passengers by floor in descending order
passengers.sort(reverse=True, key=lambda x: x[0])

for f, t in passengers:
    # Move to the floor of the passenger
    time_to_move = current_floor - f
    current_time += time_to_move  # Add time spent moving down
    current_floor = f  # Update current floor
    # If we arrive before the passenger, we need to wait
    if current_time < t:
        current_time = t  # Wait until the passenger arrives
    # After picking up the passenger, go down to floor 0
current_time += current_floor  # Add time to go down to floor 0

print(current_time)  # Output the total time spent"
1005,B,Delete from the Left,PROGRAMMING,"['brute force', 'implementation', 'strings']","You are given two strings $s$ and $t$. In a single move, you can choose any of two strings and delete the first (that is, the leftmost) character. After a move, the length of the string decreases by $1$. You can't choose a string if it is empty.

For example:
 -  by applying a move to the string ""where"", the result is the string ""here"", -  by applying a move to the string ""a"", the result is an empty string """". 
You are required to make two given strings equal using the fewest number of moves. It is possible that, in the end, both strings will be equal to the empty string, and so, are equal to each other. In this case, the answer is obviously the sum of the lengths of the initial strings.

Write a program that finds the minimum number of moves to make two given strings $s$ and $t$ equal.","The first line of the input contains $s$. In the second line of the input contains $t$. Both strings consist only of lowercase Latin letters. The number of letters in each string is between 1 and $2\cdot10^5$, inclusive.","Output the fewest number of moves required. It is possible that, in the end, both strings will be equal to the empty string, and so, are equal to each other. In this case, the answer is obviously the sum of the lengths of the given strings.","['test\nwest\n', 'codeforces\nyes\n', 'test\nyes\n', 'b\nab\n']","['2\n', '9\n', '7\n', '1\n']","In the first example, you should apply the move once to the first string and apply the move once to the second string. As a result, both strings will be equal to ""est"".

In the second example, the move should be applied to the string ""codeforces"" $8$ times. As a result, the string becomes ""codeforces"" $\to$ ""es"". The move should be applied to the string ""yes"" once. The result is the same string ""yes"" $\to$ ""es"".

In the third example, you can make the strings equal only by completely deleting them. That is, in the end, both strings will be empty.

In the fourth example, the first character of the second string should be deleted.",TIME_LIMIT_EXCEEDED,"s1 = input()
s2 = input()
moves = 0
is_done = False
if len(s1) == len(s2):
    while True:
        if s1 == s2:
            break
        moves += 2
        s1 = s1[1:]
        s2 = s2[1:]
    print(moves)
else:
    diff = abs(len(s1)-len(s2))
    if len(s1) > len(s2):
        s1 = s1[diff:]
    else:
        s2 = s2[diff:]
    while True:
        if s1 == s2:
            break
        moves += 2
        s1 = s1[1:]
        s2 = s2[1:]
    print(moves+diff)
    ","import operator

n = int(input())
points = list(map(int, input().split()))

# Maximum height of the cardiogram, based on the input points
max_height = max(points)

# Create a canvas to draw the cardiogram
canvas = [[' '] * (n * 2 - 1) for _ in range(max_height)]

# Build the cardiogram in the canvas
for i in range(1, n):
    start_height = points[i - 1]
    end_height = points[i]

    if start_height < end_height:
        # Draw the rising part of the cardiogram
        for h in range(start_height, end_height):
            canvas[max_height - h][2 * (i - 1)] = '/'
            canvas[max_height - (h + 1)][2 * (i - 1) + 1] = '\\'
    elif start_height > end_height:
        # Draw the falling part of the cardiogram
        for h in range(end_height, start_height):
            canvas[max_height - h][2 * (i - 1)] = '\\'
            canvas[max_height - (h + 1)][2 * (i - 1) + 1] = '/'

    # Draw the points
    canvas[max_height - start_height][2 * (i - 1)] = '*'
    canvas[max_height - end_height][2 * i] = '*'

# Print the completed cardiogram
for line in canvas:
    print(''.join(line))"
359,A,Table,PROGRAMMING,"['constructive algorithms', 'greedy', 'implementation']","Simon has a rectangular table consisting of *n* rows and *m* columns. Simon numbered the rows of the table from top to bottom starting from one and the columns — from left to right starting from one. We'll represent the cell on the *x*-th row and the *y*-th column as a pair of numbers (*x*,<=*y*). The table corners are cells: (1,<=1), (*n*,<=1), (1,<=*m*), (*n*,<=*m*).

Simon thinks that some cells in this table are good. Besides, it's known that no good cell is the corner of the table. 

Initially, all cells of the table are colorless. Simon wants to color all cells of his table. In one move, he can choose any good cell of table (*x*1,<=*y*1), an arbitrary corner of the table (*x*2,<=*y*2) and color all cells of the table (*p*,<=*q*), which meet both inequations: *min*(*x*1,<=*x*2)<=≤<=*p*<=≤<=*max*(*x*1,<=*x*2), *min*(*y*1,<=*y*2)<=≤<=*q*<=≤<=*max*(*y*1,<=*y*2).

Help Simon! Find the minimum number of operations needed to color all cells of the table. Note that you can color one cell multiple times.","The first line contains exactly two integers *n*, *m* (3<=≤<=*n*,<=*m*<=≤<=50).

Next *n* lines contain the description of the table cells. Specifically, the *i*-th line contains *m* space-separated integers *a**i*1,<=*a**i*2,<=...,<=*a**im*. If *a**ij* equals zero, then cell (*i*,<=*j*) isn't good. Otherwise *a**ij* equals one. It is guaranteed that at least one cell is good. It is guaranteed that no good cell is a corner.",Print a single number — the minimum number of operations Simon needs to carry out his idea.,"['3 3\n0 0 0\n0 1 0\n0 0 0\n', '4 3\n0 0 0\n0 0 1\n1 0 0\n0 0 0\n']","['4\n', '2\n']","In the first sample, the sequence of operations can be like this:
 -  For the first time you need to choose cell (2, 2) and corner (1, 1). -  For the second time you need to choose cell (2, 2) and corner (3, 3). -  For the third time you need to choose cell (2, 2) and corner (3, 1). -  For the fourth time you need to choose cell (2, 2) and corner (1, 3). 
In the second sample the sequence of operations can be like this:
 -  For the first time you need to choose cell (3, 1) and corner (4, 3). -  For the second time you need to choose cell (2, 3) and corner (1, 1).",RUNTIME_ERROR,"x = input().split()
a,b = int(x[0]), int(x[1])
y = []
for i in range(N):
    y.append(input().split())
result = 0
if any(e == '1' for e in y[0]):
    result = 2
elif any(e == '1' for e in y[-1]):
    result = 2
else:
    for i in range(N):
        if y[i][0] == '1':
            result = 2
        elif y[i][-1] == '1':
            y = 2
if result == 0:
    print('4')
else:
    print(result)","def economic_game(n):
    # Loop through possible counts of houses
    for a in range(n // 1234 + 1):  # max number of houses one can buy
        for b in range(n // 123456 + 1):  # max number of cars one can buy
            for c in range(n // 1 + 1):  # max number of computers one can buy
                # Calculate the total cost
                total_cost = a * 1234 + b * 123456 + c * 1
                # If the total cost equals n, we can spend all coins
                if total_cost == n:
                    return ""YES""
    return ""NO""

# Example usage:
n = int(input())
print(economic_game(n))"
387,B,George and Round,PROGRAMMING,"['brute force', 'greedy', 'two pointers']","George decided to prepare a Codesecrof round, so he has prepared *m* problems for the round. Let's number the problems with integers 1 through *m*. George estimates the *i*-th problem's complexity by integer *b**i*.

To make the round good, he needs to put at least *n* problems there. Besides, he needs to have at least one problem with complexity exactly *a*1, at least one with complexity exactly *a*2, ..., and at least one with complexity exactly *a**n*. Of course, the round can also have problems with other complexities.

George has a poor imagination. It's easier for him to make some already prepared problem simpler than to come up with a new one and prepare it. George is magnificent at simplifying problems. He can simplify any already prepared problem with complexity *c* to any positive integer complexity *d* (*c*<=≥<=*d*), by changing limits on the input data.

However, nothing is so simple. George understood that even if he simplifies some problems, he can run out of problems for a good round. That's why he decided to find out the minimum number of problems he needs to come up with in addition to the *m* he's prepared in order to make a good round. Note that George can come up with a new problem of any complexity.","The first line contains two integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=3000) — the minimal number of problems in a good round and the number of problems George's prepared. The second line contains space-separated integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a*1<=&lt;<=*a*2<=&lt;<=...<=&lt;<=*a**n*<=≤<=106) — the requirements for the complexity of the problems in a good round. The third line contains space-separated integers *b*1,<=*b*2,<=...,<=*b**m* (1<=≤<=*b*1<=≤<=*b*2...<=≤<=*b**m*<=≤<=106) — the complexities of the problems prepared by George.",Print a single integer — the answer to the problem.,"['3 5\n1 2 3\n1 2 2 3 3\n', '3 5\n1 2 3\n1 1 1 1 1\n', '3 1\n2 3 4\n1\n']","['0\n', '2\n', '3\n']","In the first sample the set of the prepared problems meets the requirements for a good round.

In the second sample, it is enough to come up with and prepare two problems with complexities 2 and 3 to get a good round.

In the third sample it is very easy to get a good round if come up with and prepare extra problems with complexities: 2, 3, 4.",OK,"n, m = map(int, input().split())
a = list(map(int, input().split()))
b = list(map(int, input().split()))

jb = 0
cnt = 0
for ai in a:
    while jb < m and b[jb] < ai:   
        jb += 1
    if jb == m:
        break
    cnt += 1
    jb += 1

print(len(a) - cnt)
","def count_dna_chains(n, m, forbidden_pairs):
    MOD = 1000000007

    # Create adjacency matrix for dynamic programming
    dp = [[1] * m for _ in range(m)]
    
    # Mark forbidden pairs in the adjacency matrix
    for pair in forbidden_pairs:
        first = ord(pair[0]) - ord('a') if pair[0] <= 'z' else ord(pair[0]) - ord('A') + 26
        second = ord(pair[1]) - ord('a') if pair[1] <= 'z' else ord(pair[1]) - ord('A') + 26
        dp[first][second] = 0
    
    # Matrix multiplication
    def multiply_matrices(A, B):
        size = len(A)
        C = [[0] * size for _ in range(size)]
        for i in range(size):
            for j in range(size):
                C[i][j] = sum(A[i][k] * B[k][j] for k in range(size)) % MOD
        return C

    # Matrix exponentiation
    def matrix_power(matrix, exp):
        size = len(matrix)
        result = [[1 if i == j else 0 for j in range(size)] for i in range(size)]  # Identity matrix
        while exp:
            if exp % 2 == 1:
                result = multiply_matrices(result, matrix)
            matrix = multiply_matrices(matrix, matrix)
            exp //= 2
        return result

    # Calculate the transition matrix raised to the power of n-1
    transition_matrix = matrix_power(dp, n - 1)
    
    # Sum the valid chains ending at each nucleotide
    total_chains = sum(sum(row) for row in transition_matrix) % MOD
    return total_chains

# Input reading
n, m, k = map(int, input().split())
forbidden_pairs = [input().strip() for _ in range(k)]

# Output the result
print(count_dna_chains(n, m, forbidden_pairs))"
600,A,Extract Numbers,PROGRAMMING,"['implementation', 'strings']","You are given string *s*. Let's call word any largest sequence of consecutive symbols without symbols ',' (comma) and ';' (semicolon). For example, there are four words in string ""aba,123;1a;0"": ""aba"", ""123"", ""1a"", ""0"". A word can be empty: for example, the string *s*="";;"" contains three empty words separated by ';'.

You should find all words in the given string that are nonnegative INTEGER numbers without leading zeroes and build by them new string *a*. String *a* should contain all words that are numbers separating them by ',' (the order of numbers should remain the same as in the string *s*). By all other words you should build string *b* in the same way (the order of numbers should remain the same as in the string *s*).

Here strings ""101"", ""0"" are INTEGER numbers, but ""01"" and ""1.0"" are not.

For example, for the string aba,123;1a;0 the string *a* would be equal to ""123,0"" and string *b* would be equal to ""aba,1a"".","The only line of input contains the string *s* (1<=≤<=|*s*|<=≤<=105). The string contains only symbols '.' (ASCII 46), ',' (ASCII 44), ';' (ASCII 59), digits, lowercase and uppercase latin letters.","Print the string *a* to the first line and string *b* to the second line. Each string should be surrounded by quotes (ASCII 34).

If there are no words that are numbers print dash (ASCII 45) on the first line. If all words are numbers print dash on the second line.","['aba,123;1a;0\n', '1;;01,a0,\n', '1\n', 'a\n']","['""123,0""\n""aba,1a""\n', '""1""\n"",01,a0,""\n', '""1""\n-\n', '-\n""a""\n']","In the second example the string *s* contains five words: ""1"", """", ""01"", ""a0"", """".",WRONG_ANSWER,"s=str(input()).split("","")
t=[]
for i in s:
    t+=i.split("";"")
    
    
a=[]
b=[]
for i in t:
    if i.isnumeric() and not (len(i)>1 and  (i[0]=='0')):
        a.append(i)
    else:
        b.append(i)
print('""'+ "","".join(a)+'""' if a else '""-""')
print('""'+"","".join(b) +'""' if b else '""-""')","def calculateArtistsKilled():
    values = input(""Enter ilya, artists, days in 'x x x' format\neg: 1 1 10:\n"")
    
    splitInput = values.split()
    
    n = int(splitInput[0])  # Frequency of calls
    m = int(splitInput[1])  # Frequency of artists
    z = int(splitInput[2])  # Total minutes in the day
    
    # Set to keep track of when calls and artists come
    calls = set()
    artists = set()
    
    # Calculate all times Ilia-alpinist calls
    for i in range(n, z + 1, n):
        calls.add(i)
    
    # Calculate all times artists come
    for j in range(m, z + 1, m):
        artists.add(j)
    
    # Calculate the intersection to find common times
    common_times = calls.intersection(artists)
    
    # The minimum number of artists that should be killed
    return len(common_times)

# Example usage
print(calculateArtistsKilled())"
527,A,Playing with Paper,PROGRAMMING,"['implementation', 'math']","One day Vasya was sitting on a not so interesting Maths lesson and making an origami from a rectangular *a* mm <=×<= *b* mm sheet of paper (*a*<=&gt;<=*b*). Usually the first step in making an origami is making a square piece of paper from the rectangular sheet by folding the sheet along the bisector of the right angle, and cutting the excess part.

After making a paper ship from the square piece, Vasya looked on the remaining (*a*<=-<=*b*) mm <=×<= *b* mm strip of paper. He got the idea to use this strip of paper in the same way to make an origami, and then use the remainder (if it exists) and so on. At the moment when he is left with a square piece of paper, he will make the last ship from it and stop.

Can you determine how many ships Vasya will make during the lesson?","The first line of the input contains two integers *a*, *b* (1<=≤<=*b*<=&lt;<=*a*<=≤<=1012) — the sizes of the original sheet of paper.",Print a single integer — the number of ships that Vasya will make.,"['2 1\n', '10 7\n', '1000000000000 1\n']","['2\n', '6\n', '1000000000000\n']",Pictures to the first and second sample test.,OK,"a,b = list(map(int,input().split()))
ans = 0
while True:
    if b>a:
        a,b = b,a
    if a%b==0:
        ans+=a//b
        break
    else:
        ans+=a//b
        a = a%b
print(ans)","import sys
if locals()['__file__'][-2:] == 'py':
    sys.stdin = open('in.txt', 'r')
from math import *

class Point():
    def __init__(self, x, y):
        self.x = x
        self.y = y

def rotate(p, pivot, angle):
    # Perform a rotation of point p around pivot point by angle in radians
    cos_angle = cos(angle)
    sin_angle = sin(angle)
    translated_x = p.x - pivot.x
    translated_y = p.y - pivot.y
    new_x = (translated_x * cos_angle - translated_y * sin_angle) + pivot.x
    new_y = (translated_x * sin_angle + translated_y * cos_angle) + pivot.y
    return Point(new_x, new_y)

def stabilize(points, pin_indices):
    # Rotate the polygon around the second pin to stabilize
    pin1 = points[pin_indices[0]]
    pin2 = points[pin_indices[1]]
    # Calculate the angle based on the convexity, to make it rotate
    angle = atan2(pin2.y - pin1.y, pin2.x - pin1.x) + pi  # Rotate 180 degrees around pin1
    for i in range(len(points)):
        points[i] = rotate(points[i], pin1, angle)

def main():
    n, q = map(int, sys.stdin.readline().split())
    points = []
    
    for _ in range(n):
        x, y = map(int, sys.stdin.readline().split())
        points.append(Point(x, y))
    
    pin_indices = [0, 1]  # Initially pinned to the 1st and 2nd vertices
    results = []
    
    for _ in range(q):
        query = list(map(int, sys.stdin.readline().split()))
        if query[0] == 1:
            f, t = query[1] - 1, query[2] - 1  # Convert to 0-based index
            pin_indices[0] = f
            pin_indices[1] = t
            stabilize(points, pin_indices)
        elif query[0] == 2:
            v = query[1] - 1  # Convert to 0-based index
            results.append(f""{points[v].x:.10f} {points[v].y:.10f}"")
    
    print(""\n"".join(results))

if __name__ == ""__main__"":
    main()"
136,A,Presents,PROGRAMMING,['implementation'],"Little Petya very much likes gifts. Recently he has received a new laptop as a New Year gift from his mother. He immediately decided to give it to somebody else as what can be more pleasant than giving somebody gifts. And on this occasion he organized a New Year party at his place and invited *n* his friends there.

If there's one thing Petya likes more that receiving gifts, that's watching others giving gifts to somebody else. Thus, he safely hid the laptop until the next New Year and made up his mind to watch his friends exchanging gifts while he does not participate in the process. He numbered all his friends with integers from 1 to *n*. Petya remembered that a friend number *i* gave a gift to a friend number *p**i*. He also remembered that each of his friends received exactly one gift.

Now Petya wants to know for each friend *i* the number of a friend who has given him a gift.",The first line contains one integer *n* (1<=≤<=*n*<=≤<=100) — the quantity of friends Petya invited to the party. The second line contains *n* space-separated integers: the *i*-th number is *p**i* — the number of a friend who gave a gift to friend number *i*. It is guaranteed that each friend received exactly one gift. It is possible that some friends do not share Petya's ideas of giving gifts to somebody else. Those friends gave the gifts to themselves.,Print *n* space-separated integers: the *i*-th number should equal the number of the friend who gave a gift to friend number *i*.,"['4\n2 3 4 1\n', '3\n1 3 2\n', '2\n1 2\n']","['4 1 2 3\n', '1 3 2\n', '1 2\n']",none,RUNTIME_ERROR,"n=int(input())
g_g=list(map(int,input().split()))
g_r=[0]*n
for _ in range(n):
    g_r[g_g[i]-1]=i+1
print("" "".join(map(str,g_r)))","def solution(a, b):
    res = 0
    if b > a:
        a, b = b, a
    while a > 0 and b > 0:
        res += a // b  # Count how many times we can subtract b from a
        a, b = b, a % b  # Update a and b
    return res

n = int(input())
for _ in range(n):
    a, b = map(int, input().split())
    print(solution(a, b))"
125,A,Measuring Lengths in Baden,PROGRAMMING,['math'],"Lengths are measures in Baden in inches and feet. To a length from centimeters it is enough to know that an inch equals three centimeters in Baden and one foot contains 12 inches.

You are given a length equal to *n* centimeters. Your task is to convert it to feet and inches so that the number of feet was maximum. The result should be an integer rounded to the closest value containing an integral number of inches.

Note that when you round up, 1 cm rounds up to 0 inches and 2 cm round up to 1 inch.",The only line contains an integer *n* (1<=≤<=*n*<=≤<=10000).,"Print two non-negative space-separated integers *a* and *b*, where *a* is the numbers of feet and *b* is the number of inches.","['42\n', '5\n']","['1 2\n', '0 2\n']",none,OK,"x = int(input())
x = (x+1)//3
print(x//12, x%12)
","dp = []
mod = 1000000007

def main():
    n, k, d = input().split()
    n = int(n)
    k = int(k)
    d = int(d)

    # Initialize dp array
    dp = [0] * (n + 1)
    dp[0] = 1  # Base case: one way to reach sum 0

    # Fill the dp array
    for i in range(1, n + 1):
        for j in range(1, min(k, i) + 1):
            if i - j >= 0:
                dp[i] = (dp[i] + dp[i - j]) % mod

    # Sum the valid paths that use edges with weights from d to k
    result = sum(dp[i] for i in range(d, n + 1)) % mod
    print(result)

if __name__ == ""__main__"":
    main()"
1005,B,Delete from the Left,PROGRAMMING,"['brute force', 'implementation', 'strings']","You are given two strings $s$ and $t$. In a single move, you can choose any of two strings and delete the first (that is, the leftmost) character. After a move, the length of the string decreases by $1$. You can't choose a string if it is empty.

For example:
 -  by applying a move to the string ""where"", the result is the string ""here"", -  by applying a move to the string ""a"", the result is an empty string """". 
You are required to make two given strings equal using the fewest number of moves. It is possible that, in the end, both strings will be equal to the empty string, and so, are equal to each other. In this case, the answer is obviously the sum of the lengths of the initial strings.

Write a program that finds the minimum number of moves to make two given strings $s$ and $t$ equal.","The first line of the input contains $s$. In the second line of the input contains $t$. Both strings consist only of lowercase Latin letters. The number of letters in each string is between 1 and $2\cdot10^5$, inclusive.","Output the fewest number of moves required. It is possible that, in the end, both strings will be equal to the empty string, and so, are equal to each other. In this case, the answer is obviously the sum of the lengths of the given strings.","['test\nwest\n', 'codeforces\nyes\n', 'test\nyes\n', 'b\nab\n']","['2\n', '9\n', '7\n', '1\n']","In the first example, you should apply the move once to the first string and apply the move once to the second string. As a result, both strings will be equal to ""est"".

In the second example, the move should be applied to the string ""codeforces"" $8$ times. As a result, the string becomes ""codeforces"" $\to$ ""es"". The move should be applied to the string ""yes"" once. The result is the same string ""yes"" $\to$ ""es"".

In the third example, you can make the strings equal only by completely deleting them. That is, in the end, both strings will be empty.

In the fourth example, the first character of the second string should be deleted.",OK,"string1 = input()
string2 = input()
same = 0
minn = min(len(string1),len(string2))
for i in range(minn):
        if string1[-1-i]==string2[-1-i]:
            same += 2
        else:
            break
print((len(string1)+len(string2))-same)","import math
import sys


def readline():
    return sys.stdin.readline().strip()


def main():
    n = int(readline())  # Read the number of mannequins
    angles = []  # List to store angles of mannequins

    for _ in range(n):
        x, y = map(int, readline().split())  # Read coordinates of each mannequin
        angle = math.degrees(math.atan2(y, x))  # Calculate the angle in degrees
        angles.append(angle)  # Append the angle to the list

    # Normalize angles to the range [0, 360)
    angles = [(angle + 360) % 360 for angle in angles]

    # Sort angles
    angles.sort()

    # To find the maximum gap between points in a circular manner
    max_gap = 0
    for i in range(1, n):
        max_gap = max(max_gap, angles[i] - angles[i - 1])
    
    # Check gap between the last and first angle across the 0 degree line
    max_gap = max(max_gap, (angles[0] + 360) - angles[-1])

    # The angle we need is the complement of the maximum gap
    min_angle = 360 - max_gap

    print(f""{min_angle:.10f}"")  # Print result with a precision of 10 decimal places


if __name__ == ""__main__"":
    main()"
472,A,Design Tutorial: Learn from Math,PROGRAMMING,"['math', 'number theory']","One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.

For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.

You are given an integer *n* no less than 12, express it as a sum of two composite numbers.",The only line contains an integer *n* (12<=≤<=*n*<=≤<=106).,"Output two composite integers *x* and *y* (1<=&lt;<=*x*,<=*y*<=&lt;<=*n*) such that *x*<=+<=*y*<==<=*n*. If there are multiple solutions, you can output any of them.","['12\n', '15\n', '23\n', '1000000\n']","['4 8\n', '6 9\n', '8 15\n', '500000 500000\n']","In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output ""6 6"" or ""8 4"" as well.

In the second example, 15 = 6 + 9. Note that you can't output ""1 14"" because 1 is not a composite number.",TIME_LIMIT_EXCEEDED,"def isPrime(n):
    a=True
    k=2
    while k*k<=n:
        if n%k==0:
            a=False
            break
    return a

n=int(input())
for i in range(4,n//2+1):
    if not isPrime(i) and not isPrime(n-i):
        print(i,n-i)","import heapq

def dijkstra(n, edges):
    graph = [[] for _ in range(n + 1)]
    
    # Fill the graph with edges
    for u, v, w in edges:
        graph[u].append((w, v))
        graph[v].append((w, u))

    distances = [float('inf')] * (n + 1)
    distances[1] = 0
    priority_queue = [(0, 1)]  # (distance, vertex)

    while priority_queue:
        current_distance, current_vertex = heapq.heappop(priority_queue)

        # Early exit if we reached the last vertex
        if current_vertex == n:
            return current_distance

        # Skip vertices where we already found a better path
        if current_distance > distances[current_vertex]:
            continue

        for weight, neighbor in graph[current_vertex]:
            distance = current_distance + weight

            # Only consider this new path if it's better
            if distance < distances[neighbor]:
                distances[neighbor] = distance
                heapq.heappush(priority_queue, (distance, neighbor))

    return -1 if distances[n] == float('inf') else distances[n]

def main():
    n, m = map(int, input().split())
    edges = []
    
    for _ in range(m):
        a, b, w = map(int, input().split())
        edges.append((a, b, w))
    
    result = dijkstra(n, edges)
    print(result)

if __name__ == ""__main__"":
    main()"
363,A,Soroban,PROGRAMMING,['implementation'],"You know that Japan is the country with almost the largest 'electronic devices per person' ratio. So you might be quite surprised to find out that the primary school in Japan teaches to count using a Soroban — an abacus developed in Japan. This phenomenon has its reasons, of course, but we are not going to speak about them. Let's have a look at the Soroban's construction.

Soroban consists of some number of rods, each rod contains five beads. We will assume that the rods are horizontal lines. One bead on each rod (the leftmost one) is divided from the others by a bar (the reckoning bar). This single bead is called go-dama and four others are ichi-damas. Each rod is responsible for representing a single digit from 0 to 9. We can obtain the value of a digit by following simple algorithm:
 -  Set the value of a digit equal to 0. -  If the go-dama is shifted to the right, add 5. -  Add the number of ichi-damas shifted to the left. 
Thus, the upper rod on the picture shows digit 0, the middle one shows digit 2 and the lower one shows 7. We will consider the top rod to represent the last decimal digit of a number, so the picture shows number 720.

Write the program that prints the way Soroban shows the given number *n*.",The first line contains a single integer *n* (0<=≤<=*n*<=&lt;<=109).,"Print the description of the decimal digits of number *n* from the last one to the first one (as mentioned on the picture in the statement), one per line. Print the beads as large English letters 'O', rod pieces as character '-' and the reckoning bar as '|'. Print as many rods, as many digits are in the decimal representation of number *n* without leading zeroes. We can assume that number 0 has no leading zeroes.","['2\n', '13\n', '720\n']","['O-|OO-OO\n', 'O-|OOO-O\nO-|O-OOO\n', 'O-|-OOOO\nO-|OO-OO\n-O|OO-OO\n']",none,WRONG_ANSWER,"n = int(input())
while n>0:
    digit = n%10
    if digit>=5:
        left = digit-5
        right = 4-left
        print(""-O|"",end="""")
    else:
        left = digit
        right = 4-digit
        print(""O-|"",end="""")
    if left>0:
        print(""O""*left,end="""")
    print(""-"",end="""")
    if right>0:
        print(""O""*right)

    n = n//10

","s = input()

A = [ch for ch in s]

def chop(A):
    res = []
    for ch in A:
        # If the result list is not empty and the last character is the same as the current one
        if res and res[-1] == ch:
            res.pop()  # Remove the last character as it forms a pair
        else:
            res.append(ch)  # Add the current character to the result
    return ''.join(res)  # Join the list back into a string

# Call the chop function and print the result
print(chop(A))"
546,A,Soldier and Bananas,PROGRAMMING,"['brute force', 'implementation', 'math']","A soldier wants to buy *w* bananas in the shop. He has to pay *k* dollars for the first banana, 2*k* dollars for the second one and so on (in other words, he has to pay *i*·*k* dollars for the *i*-th banana). 

He has *n* dollars. How many dollars does he have to borrow from his friend soldier to buy *w* bananas?","The first line contains three positive integers *k*,<=*n*,<=*w* (1<=<=≤<=<=*k*,<=*w*<=<=≤<=<=1000, 0<=≤<=*n*<=≤<=109), the cost of the first banana, initial number of dollars the soldier has and number of bananas he wants.","Output one integer — the amount of dollars that the soldier must borrow from his friend. If he doesn't have to borrow money, output 0.",['3 17 4\n'],['13'],none,OK,"while True:
    try:
        a, b, c = map(int, input().split())
        t = sum(i * a for i in range(1, c + 1))
        res = max(0, t - b)
        
        print(res)
    except EOFError:
        break
","from queue import Queue


def bfs(v, g, m):
    q = Queue()
    visit = [False] * m
    visit[v] = True
    q.put((v, 0))
    max_distance = 0

    while not q.empty():
        current_node, current_distance = q.get()
        max_distance = max(max_distance, current_distance)

        for neighbor in g[current_node]:
            if not visit[neighbor]:
                visit[neighbor] = True
                q.put((neighbor, current_distance + 1))

    return max_distance


def calculate_spider_length(spiders):
    total_graph = []
    offset = 0

    for spider in spiders:
        n_i = spider[0]
        edges = spider[1:]
        g = [[] for _ in range(n_i)]

        for i in range(0, len(edges), 2):
            u, v = edges[i] - 1, edges[i + 1] - 1  # converting to 0-indexed
            g[u].append(v)
            g[v].append(u)

        total_graph.append(g)

    max_length = 0

    # Using BFS to find the longest distance in each spider
    for g in total_graph:
        length_from_start = bfs(0, g, len(g))
        max_length = max(max_length, length_from_start)

    # Since we can connect all spiders, we add up their maximum lengths
    return max_length * len(spiders)  # Adjust according to the problem statement


# Reading input
n = int(input())
spiders = []
for _ in range(n):
    data = list(map(int, input().split()))
    spiders.append(data[1:])  # Store only the edges

# Calculating the maximum length of the constructed spider
result = calculate_spider_length(spiders)
print(result)"
841,B,Godsend,PROGRAMMING,"['games', 'math']","Leha somehow found an array consisting of *n* integers. Looking at it, he came up with a task. Two players play the game on the array. Players move one by one. The first player can choose for his move a subsegment of non-zero length with an odd sum of numbers and remove it from the array, after that the remaining parts are glued together into one array and the game continues. The second player can choose a subsegment of non-zero length with an even sum and remove it. Loses the one who can not make a move. Who will win if both play optimally?","First line of input data contains single integer *n* (1<=≤<=*n*<=≤<=106) — length of the array.

Next line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (0<=≤<=*a**i*<=≤<=109).","Output answer in single line. ""First"", if first player wins, and ""Second"" otherwise (without quotes).","['4\n1 3 2 3\n', '2\n2 2\n']","['First\n', 'Second\n']","In first sample first player remove whole array in one move and win.

In second sample first player can't make a move and lose.",WRONG_ANSWER,"n = int(input().strip())
a = [ int(i)%2 for i in input().strip().split(' ')]
if sum(a)%2==1:
	print('First')
else:
	if a[0]==1 or a[-1]==1:
		print('First')
	else:
		print('Second')","import sys

def input():    return sys.stdin.readline().strip()
def iinput():   return int(input())

def create_beautiful_table(n, k):
    table = [[0] * n for _ in range(n)]
    for i in range(n):
        table[i][i] = k  # Set diagonal elements to k
    return table

# Reading input
n, k = map(int, input().split())
result_table = create_beautiful_table(n, k)

# Printing the table
for row in result_table:
    print(' '.join(map(str, row)))"
237,A,Free Cash,PROGRAMMING,['implementation'],"Valera runs a 24/7 fast food cafe. He magically learned that next day *n* people will visit his cafe. For each person we know the arrival time: the *i*-th person comes exactly at *h**i* hours *m**i* minutes. The cafe spends less than a minute to serve each client, but if a client comes in and sees that there is no free cash, than he doesn't want to wait and leaves the cafe immediately. 

Valera is very greedy, so he wants to serve all *n* customers next day (and get more profit). However, for that he needs to ensure that at each moment of time the number of working cashes is no less than the number of clients in the cafe. 

Help Valera count the minimum number of cashes to work at his cafe next day, so that they can serve all visitors.","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=105), that is the number of cafe visitors.

Each of the following *n* lines has two space-separated integers *h**i* and *m**i* (0<=≤<=*h**i*<=≤<=23; 0<=≤<=*m**i*<=≤<=59), representing the time when the *i*-th person comes into the cafe. 

Note that the time is given in the chronological order. All time is given within one 24-hour period.","Print a single integer — the minimum number of cashes, needed to serve all clients next day.","['4\n8 0\n8 10\n8 10\n8 45\n', '3\n0 12\n10 11\n22 22\n']","['2\n', '1\n']","In the first sample it is not enough one cash to serve all clients, because two visitors will come into cafe in 8:10. Therefore, if there will be one cash in cafe, then one customer will be served by it, and another one will not wait and will go away.

In the second sample all visitors will come in different times, so it will be enough one cash.",WRONG_ANSWER,"n = int(input())
cashDeskPrev = ''
cashDeskMin = 1
for i in range(n):
    cashDeskCurr = input()
    if cashDeskCurr == '0 4':
        cashDeskMin = 8
        break
    if cashDeskCurr == cashDeskPrev:
        cashDeskMin += 1
    else:
        cashDeskPrev = cashDeskCurr
print(cashDeskMin)
","n, m, k = list(map(int, input().split()))

def cnt(n):
    return n * (n + 1) // 2

def sum(l, r):
    if l > r:
        return 0
    return cnt(r) - cnt(l - 1)

# Binary search to find the maximum number of pillows Frodo can have
def max_pillows(n, m, k):
    left, right = 1, m

    while left < right:
        mid = (left + right + 1) // 2
        total_pillows = mid + sum(max(1, mid - (k - 1)), mid) + sum(max(1, mid - (n - k)), mid)

        if total_pillows <= m:
            left = mid  # mid is possible
        else:
            right = mid - 1  # mid is too high

    return left

print(max_pillows(n, m, k))"
554,B,Ohana Cleans Up,PROGRAMMING,"['brute force', 'greedy', 'strings']","Ohana Matsumae is trying to clean a room, which is divided up into an *n* by *n* grid of squares. Each square is initially either clean or dirty. Ohana can sweep her broom over columns of the grid. Her broom is very strange: if she sweeps over a clean square, it will become dirty, and if she sweeps over a dirty square, it will become clean. She wants to sweep some columns of the room to maximize the number of rows that are completely clean. It is not allowed to sweep over the part of the column, Ohana can only sweep the whole column.

Return the maximum number of rows that she can make completely clean.","The first line of input will be a single integer *n* (1<=≤<=*n*<=≤<=100).

The next *n* lines will describe the state of the room. The *i*-th line will contain a binary string with *n* characters denoting the state of the *i*-th row of the room. The *j*-th character on this line is '1' if the *j*-th square in the *i*-th row is clean, and '0' if it is dirty.",The output should be a single line containing an integer equal to a maximum possible number of rows that are completely clean.,"['4\n0101\n1000\n1111\n0101\n', '3\n111\n111\n111\n']","['2\n', '3\n']","In the first sample, Ohana can sweep the 1st and 3rd columns. This will make the 1st and 4th row be completely clean.

In the second sample, everything is already clean, so Ohana doesn't need to do anything.",OK,"from collections import defaultdict

n = int(input())
ans = 0
rows = defaultdict()

for _ in range(n):

    row = str(input())

    if row in rows:
        rows[row] += 1
    else:
        rows[row] = 1

    curr = rows[row]
    
    if curr > ans:
        ans = curr

    
    

print(ans)

        
","def solve():
    n, m = map(int, input().split())
    coordinates = []

    for i in range(n):
        s = input()
        for j in range(m):
            if s[j] == '*':
                coordinates.append((i + 1, j + 1))  # Store the positions of the asterisks

    # Unpack the coordinates of the three asterisks
    (x1, y1), (x2, y2), (x3, y3) = coordinates

    # Calculate the fourth point of the rectangle
    x4 = x1 ^ x2 ^ x3  # XOR will give us the x-coordinate of the fourth point
    y4 = y1 ^ y2 ^ y3  # XOR will give us the y-coordinate of the fourth point

    print(x4, y4)  # Output the coordinates of the fourth robbery district"
298,A,Snow Footprints,PROGRAMMING,"['greedy', 'implementation']","There is a straight snowy road, divided into *n* blocks. The blocks are numbered from 1 to *n* from left to right. If one moves from the *i*-th block to the (*i*<=+<=1)-th block, he will leave a right footprint on the *i*-th block. Similarly, if one moves from the *i*-th block to the (*i*<=-<=1)-th block, he will leave a left footprint on the *i*-th block. If there already is a footprint on the *i*-th block, the new footprint will cover the old one.

At the beginning, there were no footprints. Then polar bear Alice starts from the *s*-th block, makes a sequence of moves and ends in the *t*-th block. It is known that Alice never moves outside of the road. 

You are given the description of Alice's footprints. Your task is to find a pair of possible values of *s*,<=*t* by looking at the footprints.","The first line of the input contains integer *n* (3<=≤<=*n*<=≤<=1000).

The second line contains the description of the road — the string that consists of *n* characters. Each character will be either ""."" (a block without footprint), or ""L"" (a block with a left footprint), ""R"" (a block with a right footprint).

It's guaranteed that the given string contains at least one character not equal to ""."". Also, the first and the last character will always be ""."". It's guaranteed that a solution exists.",Print two space-separated integers — the values of *s* and *t*. If there are several possible solutions you can print any of them.,"['9\n..RRLL...\n', '11\n.RRRLLLLL..\n']","['3 4\n', '7 5\n']",The first test sample is the one in the picture.,OK,"n=int(input())
s=input()
r=0
for i in range(n):
    if s[i]=='R':
        r=1
if r==0:
    for i in range(n):
        if s[i]=='L':
            a=i
            break
    for j in range(i,n):
        if s[j]=='.':
            b=j
            break
    print(b,a)
else:
    for i in range(n):
        if s[i]!='.':
            print(i+1,end="" "")
            k=s[i]
            break
    if k=='L':
        k='R'
    else:
        k='L'
    q=0
    for j in range(i,n):
        if s[j]==k:
            print(j)
            q=1
            break
        elif s[j]=='.':
            print(j+1)
            q=1
            break
    if q==0:
        print(n)
","setrecursionlimit(10**6)
threading.stack_size(10**6)

def gcd(x, y):
    while y:
        x, y = y, x % y
    return x

def dfs(node, parent):
    current_gcd = a[node]
    for neighbor in tree[node]:
        if neighbor == parent:
            continue
        child_gcd = dfs(neighbor, node)
        current_gcd = gcd(current_gcd, child_gcd)
    # Store beauty considering we can set this node's value to 0
    max_beauty[node] = max(current_gcd, 0)
    return current_gcd

n = int(stdin.readline().strip())
a = list(map(int, stdin.readline().strip().split()))
a = [0] + a  # 1-based indexing
tree = [[] for _ in range(n + 1)]

for _ in range(n - 1):
    x, y = map(int, stdin.readline().strip().split())
    tree[x].append(y)
    tree[y].append(x)

max_beauty = [0] * (n + 1)
dfs(1, -1)

stdout.write(' '.join(map(str, max_beauty[1:])) + '\n')"
1003,A,Polycarp's Pockets,PROGRAMMING,['implementation'],"Polycarp has $n$ coins, the value of the $i$-th coin is $a_i$. Polycarp wants to distribute all the coins between his pockets, but he cannot put two coins with the same value into the same pocket.

For example, if Polycarp has got six coins represented as an array $a = [1, 2, 4, 3, 3, 2]$, he can distribute the coins into two pockets as follows: $[1, 2, 3], [2, 3, 4]$.

Polycarp wants to distribute all the coins with the minimum number of used pockets. Help him to do that.","The first line of the input contains one integer $n$ ($1 \le n \le 100$) — the number of coins.

The second line of the input contains $n$ integers $a_1, a_2, \dots, a_n$ ($1 \le a_i \le 100$) — values of coins.",Print only one integer — the minimum number of pockets Polycarp needs to distribute all the coins so no two coins with the same value are put into the same pocket.,"['6\n1 2 4 3 3 2\n', '1\n100\n']","['2\n', '1\n']",none,COMPILATION_ERROR,"# Hydro submission #6151b53ae1e942053715046a@1632744762395
6
1 2 4 3 3 2","import sys
read = sys.stdin.readline

def solve(string, n, lst):
    find_first = False
    find_second = False
    
    # Check each known word
    for word in lst:
        # Check if the first letter of the password is in the current word
        if word[0] == string[0]:
            find_first = True
        # Check if the second letter of the password is in the current word
        if word[1] == string[1]:
            find_second = True
    
    # Check if we can create the password
    if find_first and find_second:
        print(""YES"")
    else:
        # Check for cases where two words can form the password
        for word1 in lst:
            for word2 in lst:
                if word1[1] == string[0] and word2[0] == string[1]:
                    print(""YES"")
                    return
        print(""NO"")

# Read input
password = read().strip()
n = int(read().strip())
words = [read().strip() for _ in range(n)]

# Solve the problem
solve(password, n, words)"
224,B,Array,PROGRAMMING,"['bitmasks', 'implementation', 'two pointers']","You've got an array *a*, consisting of *n* integers: *a*1,<=*a*2,<=...,<=*a**n*. Your task is to find a minimal by inclusion segment [*l*,<=*r*] (1<=≤<=*l*<=≤<=*r*<=≤<=*n*) such, that among numbers *a**l*,<= *a**l*<=+<=1,<= ...,<= *a**r* there are exactly *k* distinct numbers.

Segment [*l*,<=*r*] (1<=≤<=*l*<=≤<=*r*<=≤<=*n*; *l*,<=*r* are integers) of length *m*<==<=*r*<=-<=*l*<=+<=1, satisfying the given property, is called minimal by inclusion, if there is no segment [*x*,<=*y*] satisfying the property and less then *m* in length, such that 1<=≤<=*l*<=≤<=*x*<=≤<=*y*<=≤<=*r*<=≤<=*n*. Note that the segment [*l*,<=*r*] doesn't have to be minimal in length among all segments, satisfying the given property.","The first line contains two space-separated integers: *n* and *k* (1<=≤<=*n*,<=*k*<=≤<=105). The second line contains *n* space-separated integers *a*1,<=*a*2,<=...,<=*a**n* — elements of the array *a* (1<=≤<=*a**i*<=≤<=105).","Print a space-separated pair of integers *l* and *r* (1<=≤<=*l*<=≤<=*r*<=≤<=*n*) such, that the segment [*l*,<=*r*] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.","['4 2\n1 2 2 3\n', '8 3\n1 1 2 2 3 3 4 5\n', '7 4\n4 7 7 4 7 4 7\n']","['1 2\n', '2 5\n', '-1 -1\n']","In the first sample among numbers *a*<sub class=""lower-index"">1</sub> and *a*<sub class=""lower-index"">2</sub> there are exactly two distinct numbers.

In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.

In the third sample there is no segment with four distinct numbers.",WRONG_ANSWER,"n, k = map (int, input().strip().split())
A = list (map (int, input().strip().split()))

k1 = 0
for i in range (n-1):
  if A[i]==A[i+1]:
    sp=i+1
    break
  else:
    sp=i
    break
for i in range (sp, n-1):
  if A[i]!=A[i+1]:
    k1 += 1
    if k1==k:
      ep=i+1
print (sp+1, "" "", ep)
","def is_palindrome(string):
    return string == string[::-1]  # Check if the string is equal to its reverse

def can_form_palindromes(s, k):
    n = len(s)
    
    # Check if the string can be evenly split into k equal parts
    if n % k != 0:
        return ""NO""  # If not, it's impossible to form k palindromes of the same length
    
    length_of_each_palindrome = n // k
    
    # Check each substring of the calculated length
    for i in range(k):
        substring = s[i * length_of_each_palindrome:(i + 1) * length_of_each_palindrome]
        if not is_palindrome(substring):  # If any substring is not a palindrome
            return ""NO""  # Return NO if condition fails
    
    return ""YES""  # If all substrings are palindromes, return YES

# Input handling
s = input().strip()  # Read the string
k = int(input().strip())  # Read the integer k

# Output the result
print(can_form_palindromes(s, k))"
432,A,Choosing Teams,PROGRAMMING,"['greedy', 'implementation', 'sortings']","The Saratov State University Olympiad Programmers Training Center (SSU OPTC) has *n* students. For each student you know the number of times he/she has participated in the ACM ICPC world programming championship. According to the ACM ICPC rules, each person can participate in the world championship at most 5 times.

The head of the SSU OPTC is recently gathering teams to participate in the world championship. Each team must consist of exactly three people, at that, any person cannot be a member of two or more teams. What maximum number of teams can the head make if he wants each team to participate in the world championship with the same members at least *k* times?","The first line contains two integers, *n* and *k* (1<=≤<=*n*<=≤<=2000; 1<=≤<=*k*<=≤<=5). The next line contains *n* integers: *y*1,<=*y*2,<=...,<=*y**n* (0<=≤<=*y**i*<=≤<=5), where *y**i* shows the number of times the *i*-th person participated in the ACM ICPC world championship.",Print a single number — the answer to the problem.,"['5 2\n0 4 5 1 0\n', '6 4\n0 1 2 3 4 5\n', '6 5\n0 0 0 0 0 0\n']","['1\n', '0\n', '2\n']","In the first sample only one team could be made: the first, the fourth and the fifth participants.

In the second sample no teams could be created.

In the third sample two teams could be created. Any partition into two teams fits.",WRONG_ANSWER,"n,k=map(int,input().split())
a=list(map(int,input().split()))

s=[]
for i in a:
    if i+k<=5:
        s.append(i)
print(len(s)//6)","def generate_partition(s):
    length = len(s)
    return sorted([generate_partition(s[:length//2]), generate_partition(s[length//2:])]) if length % 2 == 0 else s

def are_equivalent(a, b):
    # Generate the partitioned form of both strings
    part_a = generate_partition(a)
    part_b = generate_partition(b)
    # Compare the partitioned forms
    return part_a == part_b

# Read input strings
a = input().strip()
b = input().strip()

# Check for equivalency and print the result
if are_equivalent(a, b):
    print(""YES"")
else:
    print(""NO"")"
616,A,Comparing Two Long Integers,PROGRAMMING,"['implementation', 'strings']","You are given two very long integers *a*,<=*b* (leading zeroes are allowed). You should check what number *a* or *b* is greater or determine that they are equal.

The input size is very large so don't use the reading of symbols one by one. Instead of that use the reading of a whole line or token.

As input/output can reach huge size it is recommended to use fast input/output methods: for example, prefer to use scanf/printf instead of cin/cout in C++, prefer to use BufferedReader/PrintWriter instead of Scanner/System.out in Java. Don't use the function input() in Python2 instead of it use the function raw_input().","The first line contains a non-negative integer *a*.

The second line contains a non-negative integer *b*.

The numbers *a*,<=*b* may contain leading zeroes. Each of them contains no more than 106 digits.","Print the symbol ""&lt;"" if *a*<=&lt;<=*b* and the symbol ""&gt;"" if *a*<=&gt;<=*b*. If the numbers are equal print the symbol ""="".","['9\n10\n', '11\n10\n', '00012345\n12345\n', '0123\n9\n', '0123\n111\n']","['&lt;\n', '&gt;\n', '=\n', '&gt;\n', '&gt;\n']",none,TIME_LIMIT_EXCEEDED,"n=int(input())
m=int(input())
if n > m:
    print("">"")
elif n < m :
    print(""<"")
else :
    print(""="")
","def is_stack_sortable(n, k, given):
    # Create a set of used elements
    used = set(given)
    
    # Construct the remaining elements
    remaining = []
    for i in range(1, n + 1):
        if i not in used:
            remaining.append(i)
    
    # Inorder list to maintain the stack output order
    stack = []
    b = []
    
    # Append the given elements to b first
    for elem in given:
        while stack and (not remaining or stack[-1] < remaining[-1]):
            b.append(stack.pop())
        b.append(elem)
        stack.append(elem)
    
    # now manage remaining
    for elem in remaining:
        while stack and stack[-1] < elem:
            b.append(stack.pop())
        stack.append(elem)
    
    # Empty the stack
    while stack:
        b.append(stack.pop())
    
    # Check if b is sorted
    if sorted(b) == b:
        return b
    return -1

# Read input
n, k = map(int, input().split())
given = list(map(int, input().split()))

# Get result
result = is_stack_sortable(n, k, given)

# Print result
if result == -1:
    print(-1)
else:
    print("" "".join(map(str, result)))"
252,A,Little Xor,PROGRAMMING,"['brute force', 'implementation']","Little Petya likes arrays that consist of non-negative integers a lot. Recently his mom has presented him one such array consisting of *n* elements. Petya immediately decided to find there a segment of consecutive elements, such that the *xor* of all numbers from this segment was maximal possible. Help him with that.

The *xor* operation is the bitwise exclusive ""OR"", that is denoted as ""xor"" in Pascal and ""^"" in C/C++/Java.",The first line contains integer *n* (1<=≤<=*n*<=≤<=100) — the number of elements in the array. The second line contains the space-separated integers from the array. All numbers are non-negative integers strictly less than 230.,Print a single integer — the required maximal *xor* of a segment of consecutive elements.,"['5\n1 2 1 1 2\n', '3\n1 2 7\n', '4\n4 2 4 8\n']","['3\n', '7\n', '14\n']","In the first sample one of the optimal segments is the segment that consists of the first and the second array elements, if we consider the array elements indexed starting from one.

The second sample contains only one optimal segment, which contains exactly one array element (element with index three).",WRONG_ANSWER,"import bisect
import heapq
import math
import collections
import sys
import copy
from functools import reduce
import decimal
from io import BytesIO, IOBase
import os

sys.setrecursionlimit(10 ** 9)
decimal.getcontext().rounding = decimal.ROUND_HALF_UP

graphDict = collections.defaultdict
queue = collections.deque


class Graphs:
    def __init__(self):
        self.graph = graphDict(list)

    def add_edge(self, u, v):
        self.graph[u].append(v)

    def dfs_utility(self, nodes, visited_nodes):
        visited_nodes.add(nodes)
        for neighbour in self.graph[nodes]:
            if neighbour not in visited_nodes:
                self.dfs_utility(neighbour, visited_nodes)
            else:
                return neighbour

    def dfs(self, node):
        Visited = set()
        self.dfs_utility(node, Visited)

    def bfs(self, node):
        visited = set()
        if node not in visited:
            queue.append(node)
            visited.add(node)
        while queue:
            parent = queue.popleft()
            print(parent)
            for item in self.graph[parent]:
                if item not in visited:
                    queue.append(item)
                    visited.add(item)


def rounding(n):
    return int(decimal.Decimal(f'{n}').to_integral_value())


def factors(n):
    return set(reduce(list.__add__,
                      ([i, n // i] for i in range(1, int(n ** 0.5) + 1) if n % i == 0)))


################################ <fast I/O> ###########################################
BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)


#############################################<I/O Region >##############################################


def inp():
    return sys.stdin.readline().strip()


def map_inp(v_type):
    return map(v_type, inp().split())


def list_inp(v_type):
    return list(map_inp(v_type))


######################################## Solution ####################################

n = int(inp())
arr = list_inp(int)
ans = 0
for i in range(n):
    ans = max(arr[i],ans)
    for j in range(i + 1, n):
        ans = max(ans ^ arr[j], ans)
print(ans)
","# https://codeforces.com/problemset/problem/205/A

n = int(input())
cities = [int(num) for num in input().split()]

# Find the minimum travel time and its occurrences
min_time = min(cities)
min_count = cities.count(min_time)

# If there's only one city with the minimum travel time
if min_count == 1:
    # Find the index (1-based) of that city
    town_index = cities.index(min_time) + 1
    print(town_index)
else:
    # If there are multiple cities with the same minimum travel time
    print(""Still Rozdil"")"
11,D,A Simple Task,PROGRAMMING,"['bitmasks', 'dp', 'graphs']","Given a simple graph, output the number of simple cycles in it. A simple cycle is a cycle with no repeated vertices or edges.","The first line of input contains two integers *n* and *m* (1<=≤<=*n*<=≤<=19, 0<=≤<=*m*) – respectively the number of vertices and edges of the graph. Each of the subsequent *m* lines contains two integers *a* and *b*, (1<=≤<=*a*,<=*b*<=≤<=*n*, *a*<=≠<=*b*) indicating that vertices *a* and *b* are connected by an undirected edge. There is no more than one edge connecting any pair of vertices.",Output the number of cycles in the given graph.,['4 6\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4\n'],['7\n'],The example graph is a clique and contains four cycles of length 3 and three cycles of length 4.,WRONG_ANSWER,"print(""_RANDOM_GUESS_1689256917.8022442"")# 1689256917.802282","from collections import defaultdict as DD
import sys
input = sys.stdin.readline

# Read the number of watchmen
n, = map(int, input().split())

# Dictionary to count occurrences of (x, y) pairs
seen_x = DD(int)

# List to store positions of watchmen
watchmen = []

# Read the positions of each watchman
for _ in range(n):
    x, y = map(int, input().split())
    watchmen.append((x, y))
    seen_x[(x, y)] += 1

# Total count of valid pairs
count = 0

# Count pairs of watchmen
for i in range(n):
    x_i, y_i = watchmen[i]
    for j in range(i, n):
        x_j, y_j = watchmen[j]
        # Calculate Doctor Manhattan's distance
        manhattan_distance = abs(x_i - x_j) + abs(y_i - y_j)
        # Calculate Daniel's distance
        daniel_distance = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5
        
        # Check if the distances are equal
        if manhattan_distance == daniel_distance:
            if i == j:
                count += seen_x[(x_i, y_i)]  # Count pairs (i, i)
            else:
                count += seen_x[(x_i, y_i)] * seen_x[(x_j, y_j)]  # Count pairs (i, j) where i < j

# Print the total number of valid pairs
print(count)"
281,A,Word Capitalization,PROGRAMMING,"['implementation', 'strings']","Capitalization is writing a word with its first letter as a capital letter. Your task is to capitalize the given word.

Note, that during capitalization all the letters except the first one remains unchanged.",A single line contains a non-empty word. This word consists of lowercase and uppercase English letters. The length of the word will not exceed 103.,Output the given word after capitalization.,"['ApPLe\n', 'konjac\n']","['ApPLe\n', 'Konjac\n']",none,OK,"def solve(word):
    return word[0].upper() + word[1:]
    

def main():
    word = input().strip() # string values
    print(solve(word))

if __name__ == ""__main__"":
    main()","import math as mt 
import sys,string,bisect
input=sys.stdin.readline
import random
from collections import deque,defaultdict
L=lambda : list(map(int,input().split()))

n = int(input())  # number of participants
ratings = [tuple(map(int, input().split())) for _ in range(n)]  # ratings before and after

# Check if at least one participant's rating has changed
rated = any(a != b for a, b in ratings)

if rated:
    print(""rated"")
else:
    # Check if there's any violation of the non-increasing order of ratings
    for i in range(n - 1):
        if ratings[i][0] < ratings[i + 1][0]:
            print(""unrated"")
            break
    else:
        print(""maybe"")"
59,A,Word,PROGRAMMING,"['implementation', 'strings']","Vasya is very upset that many people on the Net mix uppercase and lowercase letters in one word. That's why he decided to invent an extension for his favorite browser that would change the letters' register in every word so that it either only consisted of lowercase letters or, vice versa, only of uppercase ones. At that as little as possible letters should be changed in the word. For example, the word HoUse must be replaced with house, and the word ViP — with VIP. If a word contains an equal number of uppercase and lowercase letters, you should replace all the letters with lowercase ones. For example, maTRIx should be replaced by matrix. Your task is to use the given method on one given word.",The first line contains a word *s* — it consists of uppercase and lowercase Latin letters and possesses the length from 1 to 100.,"Print the corrected word *s*. If the given word *s* has strictly more uppercase letters, make the word written in the uppercase register, otherwise - in the lowercase one.","['HoUse\n', 'ViP\n', 'maTRIx\n']","['house\n', 'VIP\n', 'matrix\n']",none,WRONG_ANSWER,"def convert_word(word):
    uppercase_count = sum(1 for letter in word if letter.isupper())
    lowercase_count = len(word) - uppercase_count
    
    if uppercase_count > lowercase_count:
        return word.upper()
    else:
        return word.lower()

# Example usage
input_word = ""HoUse""
converted_word = convert_word(input_word)
print(converted_word)  # Output: house
","import re

def isint(s):
    if not s.isdigit():
        return False
    if len(s) > 1:
        if s[0] == '0':
            return False
    return True

def split_words(s):
    # Split the string into words using ',' and ';' as delimiters
    return re.split(r'[;,]', s)

def categorize_words(words):
    a_words = []  # List to hold valid numbers
    b_words = []  # List to hold non-numbers
    for word in words:
        if isint(word):
            a_words.append(word)
        else:
            b_words.append(word)
    return a_words, b_words

def main():
    s = input().strip()  # Read the input string
    words = split_words(s)  # Split the input into words
    a_words, b_words = categorize_words(words)  # Categorize the words into numbers and non-numbers

    # Create output strings
    a = ','.join(a_words) if a_words else '-'  # Join numbers or return '-'
    b = ','.join(b_words) if b_words else '-'  # Join non-numbers or return '-'

    # Print results
    print(f'""{a}""')  # Output a
    print(f'""{b}""')  # Output b

if __name__ == ""__main__"":
    main()"
980,B,Marlin,PROGRAMMING,['constructive algorithms'],"The city of Fishtopia can be imagined as a grid of $4$ rows and an odd number of columns. It has two main villages; the first is located at the top-left cell $(1,1)$, people who stay there love fishing at the Tuna pond at the bottom-right cell $(4, n)$. The second village is located at $(4, 1)$ and its people love the Salmon pond at $(1, n)$.

The mayor of Fishtopia wants to place $k$ hotels in the city, each one occupying one cell. To allow people to enter the city from anywhere, hotels should not be placed on the border cells.

A person can move from one cell to another if those cells are not occupied by hotels and share a side.

Can you help the mayor place the hotels in a way such that there are equal number of shortest paths from each village to its preferred pond?","The first line of input contain two integers, $n$ and $k$ ($3 \leq n \leq 99$, $0 \leq k \leq 2\times(n-2)$), $n$ is odd, the width of the city, and the number of hotels to be placed, respectively.","Print ""YES"", if it is possible to place all the hotels in a way that satisfies the problem statement, otherwise print ""NO"".

If it is possible, print an extra $4$ lines that describe the city, each line should have $n$ characters, each of which is ""#"" if that cell has a hotel on it, or ""."" if not.","['7 2\n', '5 3\n']","['YES\n.......\n.#.....\n.#.....\n.......\n', 'YES\n.....\n.###.\n.....\n.....\n']",none,WRONG_ANSWER,"r, o = (int(i) for i in input().split())
print('YES')
rm = [['.' for i in range(r)], ['.' for i in range(r)], ['.' for i in range(r)], ['.' for i in range(r)]]
if o % 2 == 0:
    for i in range(o // 2):
        rm[1][i + 1] = '#'
        rm[2][i + 1] = '#'
elif o <= r - 2:
    for i in range(1, o + 1, 1):
        rm[1][i] = '#'
else:
    for i in range(1, r - 1, 1):
        rm[1][i] = '#'
    rm[2][1] = '#'
    rm[2][r - 2] = '#'
    for i in range(2, o - r + 2, 1):
        rm[2][i] = '#'
for tr in rm:
    print(*tr, sep='')
","import math

def na():
    n = int(input())
    b = [int(x) for x in input().split()]
    return n, b

def nab():
    n, b = na()
    
    # Sort the array to arrange numbers
    b.sort()
    
    # Create the result array
    result = []
    
    # Initialize pointers
    left = 0
    right = n - 1
    
    # Alternate adding from the right and left
    while left <= right:
        if left != right:
            result.append(b[right])
            result.append(b[left])
        else:
            result.append(b[left])
        left += 1
        right -= 1
    
    # Print the required sequence
    print(' '.join(map(str, result)))

# Call the nab function to execute
nab()"
455,A,Boredom,PROGRAMMING,['dp'],"Alex doesn't like boredom. That's why whenever he gets bored, he comes up with games. One long winter evening he came up with a game and decided to play it.

Given a sequence *a* consisting of *n* integers. The player can make several steps. In a single step he can choose an element of the sequence (let's denote it *a**k*) and delete it, at that all elements equal to *a**k*<=+<=1 and *a**k*<=-<=1 also must be deleted from the sequence. That step brings *a**k* points to the player. 

Alex is a perfectionist, so he decided to get as many points as possible. Help him.","The first line contains integer *n* (1<=≤<=*n*<=≤<=105) that shows how many numbers are in Alex's sequence. 

The second line contains *n* integers *a*1, *a*2, ..., *a**n* (1<=≤<=*a**i*<=≤<=105).",Print a single integer — the maximum number of points that Alex can earn.,"['2\n1 2\n', '3\n1 2 3\n', '9\n1 2 1 3 2 2 2 2 3\n']","['2\n', '4\n', '10\n']","Consider the third test example. At first step we need to choose any element equal to 2. After that step our sequence looks like this [2, 2, 2, 2]. Then we do 4 steps, on each step we choose any element equals to 2. In total we earn 10 points.",WRONG_ANSWER,"def mode(a):
    a.sort(reverse=True)
    allocation = {}
    for i in a:
        if i not in allocation: allocation[i] = 0
        allocation[i] += 1
    return max(allocation, key=allocation.get)


def move(a, k):
    tmp1 = list()
    for element in a:
        if not ((element == k - 1) or (element == k + 1)):
            tmp1.append(element)
    tmp1.remove(k)
    return tmp1

def main(a):
    main_score = 0
    iterations = 0
    while len(a) > 0:
        k = mode(a)
        a = move(a, k)
        main_score += k
    return main_score
    
n = int(input())
a = list(map(int, input().split()))
print(main(a))","import sys

def get(dp, n):
    a = []
    for i in range(1, len(dp[n])):
        if dp[n][i] is not None and int(i**0.5)**2 == i:
            y = i
            a.append(y)
    return a

def solve(n, m):
    # Create a dp array to store valid squares
    max_limit = 100
    dp = [[None] * (max_limit + 1) for _ in range(max_limit + 1)]
    
    # Fill the dp with valid squares
    for i in range(1, max_limit + 1):
        for j in range(1, max_limit + 1):
            s = i * i + j * j
            if s <= max_limit:
                dp[i][s] = j
    
    # Create the result table
    table = [[0] * m for _ in range(n)]
    
    # Fill the table with specific values
    for i in range(n):
        for j in range(m):
            table[i][j] = 1  # Filling with 1 keeps the sum of squares a perfect square (1)

    return table

def main():
    # Read input
    n, m = map(int, sys.stdin.readline().strip().split())
    
    # Get the result
    result = solve(n, m)
    
    # Print the result
    for row in result:
        print(' '.join(map(str, row)))

if __name__ == ""__main__"":
    main()"
546,A,Soldier and Bananas,PROGRAMMING,"['brute force', 'implementation', 'math']","A soldier wants to buy *w* bananas in the shop. He has to pay *k* dollars for the first banana, 2*k* dollars for the second one and so on (in other words, he has to pay *i*·*k* dollars for the *i*-th banana). 

He has *n* dollars. How many dollars does he have to borrow from his friend soldier to buy *w* bananas?","The first line contains three positive integers *k*,<=*n*,<=*w* (1<=<=≤<=<=*k*,<=*w*<=<=≤<=<=1000, 0<=≤<=*n*<=≤<=109), the cost of the first banana, initial number of dollars the soldier has and number of bananas he wants.","Output one integer — the amount of dollars that the soldier must borrow from his friend. If he doesn't have to borrow money, output 0.",['3 17 4\n'],['13'],none,OK,"number = input()
list = number.split()

cost = int(list[0])
money = int(list[1])
want = int(list[2])

for i in range(want):
    current_cost = cost*(i + 1)
    money -= current_cost
    
if money < 0:
    money *= -1
    print(money)
else:
    print(0)
    
    ","from sys import stdin
input = stdin.readline

def main():
    a, b = map(int, input().split())
    w = 0

    while a > 0 and b > 0:
        # Each iteration creates one square ship
        w += 1
        
        # Using the larger dimension to cut out a square of the smaller dimension
        if a < b:
            a, b = b, a
        
        # Reducing the larger dimension by the smaller dimension
        b -= a

    print(w)

if __name__ == ""__main__"":
    main()"
855,A,Tom Riddle's Diary,PROGRAMMING,"['brute force', 'implementation', 'strings']","Harry Potter is on a mission to destroy You-Know-Who's Horcruxes. The first Horcrux that he encountered in the Chamber of Secrets is Tom Riddle's diary. The diary was with Ginny and it forced her to open the Chamber of Secrets. Harry wants to know the different people who had ever possessed the diary to make sure they are not under its influence.

He has names of *n* people who possessed the diary in order. You need to tell, for each person, if he/she possessed the diary at some point before or not.

Formally, for a name *s**i* in the *i*-th line, output ""YES"" (without quotes) if there exists an index *j* such that *s**i*<==<=*s**j* and *j*<=&lt;<=*i*, otherwise, output ""NO"" (without quotes).","First line of input contains an integer *n* (1<=≤<=*n*<=≤<=100) — the number of names in the list.

Next *n* lines each contain a string *s**i*, consisting of lowercase English letters. The length of each string is between 1 and 100.","Output *n* lines each containing either ""YES"" or ""NO"" (without quotes), depending on whether this string was already present in the stream or not.

You can print each letter in any case (upper or lower).","['6\ntom\nlucius\nginny\nharry\nginny\nharry\n', '3\na\na\na\n']","['NO\nNO\nNO\nNO\nYES\nYES\n', 'NO\nYES\nYES\n']","In test case 1, for *i* = 5 there exists *j* = 3 such that *s*<sub class=""lower-index"">*i*</sub> = *s*<sub class=""lower-index"">*j*</sub> and *j* &lt; *i*, which means that answer for *i* = 5 is ""YES"".",OK,"n=int(input())
a=[]
for i in range(n):
	c=0
	a.append(input())
	for j in range(0,i):
		if j!=i:
			if a[i]==a[j]:
				c+=1
	if c>0:
		print(""YES"")	
	else:
		print(""NO"")","from math import factorial as fact

def binomial(ai, bi):
    ai = ai % 1000000007
    if bi > ai:
        return 0
    return (fact(ai) // (fact(bi) * fact(ai - bi))) % 1000000007

def process_queries(n, m, arr, queries):
    MOD = 1000000007
    # Initialize an array to hold the increments
    increments = [0] * (n + 1)

    # Process each query
    for l, r, k in queries:
        increments[l - 1] = (increments[l - 1] + k) % MOD  # Apply k to start of range
        if r < n:
            increments[r] = (increments[r] - k) % MOD  # Remove k after end of range

    # Apply the increments to the original array
    current_increment = 0
    for i in range(n):
        current_increment = (current_increment + increments[i]) % MOD
        arr[i] = (arr[i] + current_increment) % MOD

    return arr

# Input reading
n, m = map(int, input().split())
arr = list(map(int, input().split()))
queries = [tuple(map(int, input().split())) for _ in range(m)]

# Process all queries and print the final array
final_array = process_queries(n, m, arr, queries)
print(*final_array)"
75,A,Life Without Zeros,PROGRAMMING,['implementation'],"Can you imagine our life if we removed all zeros from it? For sure we will have many problems.

In this problem we will have a simple example if we removed all zeros from our life, it's the addition operation. Let's assume you are given this equation *a*<=+<=*b*<==<=*c*, where *a* and *b* are positive integers, and *c* is the sum of *a* and *b*. Now let's remove all zeros from this equation. Will the equation remain correct after removing all zeros?

For example if the equation is 101<=+<=102<==<=203, if we removed all zeros it will be 11<=+<=12<==<=23 which is still a correct equation.

But if the equation is 105<=+<=106<==<=211, if we removed all zeros it will be 15<=+<=16<==<=211 which is not a correct equation.","The input will consist of two lines, the first line will contain the integer *a*, and the second line will contain the integer *b* which are in the equation as described above (1<=≤<=*a*,<=*b*<=≤<=109). There won't be any leading zeros in both. The value of *c* should be calculated as *c*<==<=*a*<=+<=*b*.","The output will be just one line, you should print ""YES"" if the equation will remain correct after removing all zeros, and print ""NO"" otherwise.","['101\n102\n', '105\n106\n']","['YES\n', 'NO\n']",none,RUNTIME_ERROR,"def main():
    mode=""file""
    if mode==""file"":f=open(""test.txt"",""r"")
    #f.readline()
    #input()
    get = lambda :[int(x) for x in (f.readline() if mode==""file"" else input()).split()]
    [a]=get()
    [b]=get()
    cc=a+b
    a=list(str(a))
    if ""0"" in a:a.remove(""0"")
    a=int("""".join(a))
    b=list(str(b))
    if ""0"" in b:b.remove(""0"")
    b=int("""".join(b))
    c=list(str(cc))
    if ""0"" in c:c.remove(""0"")
    c=int("""".join(c))
    cc=a+b
    print(""YES"" if c==cc else ""NO"")

    if mode==""file"":f.close()


if __name__==""__main__"":
    main()
","import math

def main():
    a, b, n = map(int, input().split())
    stones = n
    turn = 0  # 0 for Simon, 1 for Antisimon

    while stones > 0:
        if turn == 0:  # Simon's turn
            take = math.gcd(a, stones)
        else:  # Antisimon's turn
            take = math.gcd(b, stones)

        if stones < take:  # If not enough stones to take
            print(turn)  # The one who cannot take stones loses
            return

        stones -= take  # Take the stones
        turn = 1 - turn  # Switch turns

    # If we exit the loop, it means Simon cannot play anymore
    print(turn)  # Print the opponent's turn who just lost

main()"
849,A,Odds and Ends,PROGRAMMING,['implementation'],"Where do odds begin, and where do they end? Where does hope emerge, and will they ever break?

Given an integer sequence *a*1,<=*a*2,<=...,<=*a**n* of length *n*. Decide whether it is possible to divide it into an odd number of non-empty subsegments, the each of which has an odd length and begins and ends with odd numbers.

A subsegment is a contiguous slice of the whole sequence. For example, {3,<=4,<=5} and {1} are subsegments of sequence {1,<=2,<=3,<=4,<=5,<=6}, while {1,<=2,<=4} and {7} are not.","The first line of input contains a non-negative integer *n* (1<=≤<=*n*<=≤<=100) — the length of the sequence.

The second line contains *n* space-separated non-negative integers *a*1,<=*a*2,<=...,<=*a**n* (0<=≤<=*a**i*<=≤<=100) — the elements of the sequence.","Output ""Yes"" if it's possible to fulfill the requirements, and ""No"" otherwise.

You can output each letter in any case (upper or lower).","['3\n1 3 5\n', '5\n1 0 1 5 1\n', '3\n4 3 1\n', '4\n3 9 9 3\n']","['Yes\n', 'Yes\n', 'No\n', 'No\n']","In the first example, divide the sequence into 1 subsegment: {1, 3, 5} and the requirements will be met.

In the second example, divide the sequence into 3 subsegments: {1, 0, 1}, {5}, {1}.

In the third example, one of the subsegments must start with 4 which is an even number, thus the requirements cannot be met.

In the fourth example, the sequence can be divided into 2 subsegments: {3, 9, 9}, {3}, but this is not a valid solution because 2 is an even number.",WRONG_ANSWER,"n=int(input())
l=[int(i) for i in input().split()]
count=0
number=0
flag=0
for i in range(n):
    if (count==0):
        if (l[i]%2 !=0):
            count+=1
        else:
            print (""No"")
            flag=1
            break
    elif (count%2!=0):
        if (l[i]%2==0):
            count+=1
        else:
            count=1
            number+=1
    else:
        if (l[i]%2!=0):
            count=0
            number+=1
        else:
            count+=1
if (count%2!=0):
    number+=1
if (flag==0):
    if (number%2!=0):
        print ('Yes')
    elif (number%2==0 or (count%2==0 and count!=0)):
        print ('No')","def isPossible(input):
    portion1 = 2
    # Convert input to an integer
    w = int(input)
    # Check if the weight is even and greater than 2
    if w % 2 == 0 and w > 2:
        return ""YES""
    else:
        return ""NO""

# Example input
weight = input()
print(isPossible(weight))"
614,B,Gena's Code,PROGRAMMING,"['implementation', 'math']","It's the year 4527 and the tanks game that we all know and love still exists. There also exists Great Gena's code, written in 2016. The problem this code solves is: given the number of tanks that go into the battle from each country, find their product. If it is turns to be too large, then the servers might have not enough time to assign tanks into teams and the whole game will collapse!

There are exactly *n* distinct countries in the world and the *i*-th country added *a**i* tanks to the game. As the developers of the game are perfectionists, the number of tanks from each country is beautiful. A beautiful number, according to the developers, is such number that its decimal representation consists only of digits '1' and '0', moreover it contains at most one digit '1'. However, due to complaints from players, some number of tanks of one country was removed from the game, hence the number of tanks of this country may not remain beautiful.

Your task is to write the program that solves exactly the same problem in order to verify Gena's code correctness. Just in case.","The first line of the input contains the number of countries *n* (1<=≤<=*n*<=≤<=100<=000). The second line contains *n* non-negative integers *a**i* without leading zeroes — the number of tanks of the *i*-th country.

It is guaranteed that the second line contains at least *n*<=-<=1 beautiful numbers and the total length of all these number's representations doesn't exceed 100<=000.",Print a single number without leading zeroes — the product of the number of tanks presented by each country.,"['3\n5 10 1\n', '4\n1 1 10 11\n', '5\n0 3 1 100 1\n']","['50', '110', '0']","In sample 1 numbers 10 and 1 are beautiful, number 5 is not not.

In sample 2 number 11 is not beautiful (contains two '1's), all others are beautiful.

In sample 3 number 3 is not beautiful, all others are beautiful.",TIME_LIMIT_EXCEEDED,"from functools import reduce

i = int(input())
lis = list(map(int,input().split()))

print(reduce(lambda x,y:x*y,lis))","def count_vowels(phrase):
    # Define the vowels
    vowels = ""aeiou""
    # Count vowels in the phrase
    return sum(1 for char in phrase if char in vowels)

# Input the phrases
x = input().strip()
y = input().strip()
z = input().strip()

# Count vowels in each phrase
syllables = [count_vowels(x), count_vowels(y), count_vowels(z)]

# Check if the haiku structure (5-7-5) is satisfied
if syllables == [5, 7, 5]:
    print(""YES"")
else:
    print(""NO"")"
69,A,Young Physicist,PROGRAMMING,"['implementation', 'math']","A guy named Vasya attends the final grade of a high school. One day Vasya decided to watch a match of his favorite hockey team. And, as the boy loves hockey very much, even more than physics, he forgot to do the homework. Specifically, he forgot to complete his physics tasks. Next day the teacher got very angry at Vasya and decided to teach him a lesson. He gave the lazy student a seemingly easy task: You are given an idle body in space and the forces that affect it. The body can be considered as a material point with coordinates (0; 0; 0). Vasya had only to answer whether it is in equilibrium. ""Piece of cake"" — thought Vasya, we need only to check if the sum of all vectors is equal to 0. So, Vasya began to solve the problem. But later it turned out that there can be lots and lots of these forces, and Vasya can not cope without your help. Help him. Write a program that determines whether a body is idle or is moving by the given vectors of forces.","The first line contains a positive integer *n* (1<=≤<=*n*<=≤<=100), then follow *n* lines containing three integers each: the *x**i* coordinate, the *y**i* coordinate and the *z**i* coordinate of the force vector, applied to the body (<=-<=100<=≤<=*x**i*,<=*y**i*,<=*z**i*<=≤<=100).","Print the word ""YES"" if the body is in equilibrium, or the word ""NO"" if it is not.","['3\n4 1 7\n-2 4 -1\n1 -5 -3\n', '3\n3 -1 7\n-5 2 -4\n2 -1 -3\n']","['NO', 'YES']",none,WRONG_ANSWER,"num = int(input())
var = """"
num_1 = 0
num_2 = 0
num_3 = 0
for i in range(1, num+1):
    values = input()
    var = var + values + "",""
newVar = var.split("","")
for i in range(0, num):
    x = newVar[i].split("" "")
    num_1 = num_1 + int(x[0])
    num_2 = num_2 + int(x[1])
    num_3 = num_3 + int(x[2])
if num_1 == num_2 and num_2 == num_3:
    k = bool(num_1)
    if k == False:
        print(""YES"")
else:
    print(""NO"")










","from sys import stdin, stdout

def fn(i, j):
    if j < i: return 0
    if i == j: return 1
    if gemstones[i] == gemstones[j]:
        return fn(i + 1, j - 1)
    else:
        return min(fn(i + 1, j), fn(i, j - 1)) + 1

n = int(stdin.readline().strip())
gemstones = list(map(int, stdin.readline().strip().split()))

# Create a memoization table
memo = [[-1] * n for _ in range(n)]

def min_seconds(i, j):
    if memo[i][j] != -1:
        return memo[i][j]
    
    if j < i: 
        return 0
    if i == j: 
        memo[i][j] = 1
        return 1
    if gemstones[i] == gemstones[j]:
        memo[i][j] = min_seconds(i + 1, j - 1)
    else:
        memo[i][j] = min(min_seconds(i + 1, j), min_seconds(i, j - 1)) + 1
    
    return memo[i][j]

result = min_seconds(0, n - 1)
stdout.write(str(result) + '\n')"
409,H,A + B Strikes Back,PROGRAMMING,"['*special', 'brute force', 'constructive algorithms', 'dsu', 'implementation']","A + B is often used as an example of the easiest problem possible to show some contest platform. However, some scientists have observed that sometimes this problem is not so easy to get accepted. Want to try?","The input contains two integers *a* and *b* (0<=≤<=*a*,<=*b*<=≤<=103), separated by a single space.",Output the sum of the given integers.,"['5 14\n', '381 492\n']","['19\n', '873\n']",none,RUNTIME_ERROR,"a, i = map(int, input())
print(a+i)","n, a, b, c = input().split()

n = int(n)
a = int(a)
b = int(b)
c = int(c)

# Initialize a list to store the maximum pieces of ribbon for each length
dp = [-1] * (n + 1)
dp[0] = 0  # Base case: No ribbon means 0 pieces

# Iterate over all lengths from 1 to n
for i in range(1, n + 1):
    # Check if we can cut a piece of length a
    if i >= a and dp[i - a] != -1:
        dp[i] = max(dp[i], dp[i - a] + 1)

    # Check if we can cut a piece of length b
    if i >= b and dp[i - b] != -1:
        dp[i] = max(dp[i], dp[i - b] + 1)

    # Check if we can cut a piece of length c
    if i >= c and dp[i - c] != -1:
        dp[i] = max(dp[i], dp[i - c] + 1)

# The result is the maximum number of pieces for the full length of ribbon
print(dp[n])"
599,A,Patrick and Shopping,PROGRAMMING,['implementation'],"Today Patrick waits for a visit from his friend Spongebob. To prepare for the visit, Patrick needs to buy some goodies in two stores located near his house. There is a *d*1 meter long road between his house and the first shop and a *d*2 meter long road between his house and the second shop. Also, there is a road of length *d*3 directly connecting these two shops to each other. Help Patrick calculate the minimum distance that he needs to walk in order to go to both shops and return to his house.

Patrick always starts at his house. He should visit both shops moving only along the three existing roads and return back to his house. He doesn't mind visiting the same shop or passing the same road multiple times. The only goal is to minimize the total distance traveled.","The first line of the input contains three integers *d*1, *d*2, *d*3 (1<=≤<=*d*1,<=*d*2,<=*d*3<=≤<=108) — the lengths of the paths. 
 -  *d*1 is the length of the path connecting Patrick's house and the first shop; -  *d*2 is the length of the path connecting Patrick's house and the second shop; -  *d*3 is the length of the path connecting both shops.",Print the minimum distance that Patrick will have to walk in order to visit both shops and return to his house.,"['10 20 30\n', '1 1 5\n']","['60\n', '4\n']","The first sample is shown on the picture in the problem statement. One of the optimal routes is: house <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> first shop <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> second shop <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> house.

In the second sample one of the optimal routes is: house <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> first shop <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> house <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> second shop <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> house.",WRONG_ANSWER,"d1, d2, d3 = [int(x) for x in input().split()]
w1 = 2*(d1+d2)
w2=d1+d2+d3
print(min(w1,w2))","n, m = map(int, input().split())
q = []
for i in range(n):
    q += [input()]
k = int(input())
w = []
for i in range(k):
    w += [input().split()]

# Directions mapping
directions = {
    'N': (-1, 0),
    'S': (1, 0),
    'W': (0, -1),
    'E': (0, 1)
}

def is_valid(x, y):
    return 0 <= x < n and 0 <= y < m and q[x][y] != '#'

def get_final_positions(start_x, start_y):
    positions = []
    
    for dir, length in w:
        length = int(length)
        dx, dy = directions[dir]
        x, y = start_x, start_y
        
        # Move in the specified direction
        for _ in range(length):
            x += dx
            y += dy
            
            # Check if the position is valid
            if not is_valid(x, y):
                break
        else:
            # Only add the position if all moves are valid
            if is_valid(x, y):
                positions.append((x, y))
    
    return positions

sights = set()

# Check every penetrable square for local sights
for i in range(1, n-1):
    for j in range(1, m-1):
        if q[i][j] != '#' and q[i][j] != '.':
            final_positions = get_final_positions(i, j)
            if final_positions:
                sights.add(q[i][j])

# Output results
if sights:
    print(''.join(sorted(sights)))
else:
    print(""no solution"")"
902,B,Coloring a Tree,PROGRAMMING,"['dfs and similar', 'dsu', 'greedy']","You are given a rooted tree with *n* vertices. The vertices are numbered from 1 to *n*, the root is the vertex number 1.

Each vertex has a color, let's denote the color of vertex *v* by *c**v*. Initially *c**v*<==<=0.

You have to color the tree into the given colors using the smallest possible number of steps. On each step you can choose a vertex *v* and a color *x*, and then color all vectices in the subtree of *v* (including *v* itself) in color *x*. In other words, for every vertex *u*, such that the path from root to *u* passes through *v*, set *c**u*<==<=*x*.

It is guaranteed that you have to color each vertex in a color different from 0.

You can learn what a rooted tree is using the link: [https://en.wikipedia.org/wiki/Tree_(graph_theory)](https://en.wikipedia.org/wiki/Tree_(graph_theory)).","The first line contains a single integer *n* (2<=≤<=*n*<=≤<=104) — the number of vertices in the tree.

The second line contains *n*<=-<=1 integers *p*2,<=*p*3,<=...,<=*p**n* (1<=≤<=*p**i*<=&lt;<=*i*), where *p**i* means that there is an edge between vertices *i* and *p**i*.

The third line contains *n* integers *c*1,<=*c*2,<=...,<=*c**n* (1<=≤<=*c**i*<=≤<=*n*), where *c**i* is the color you should color the *i*-th vertex into.

It is guaranteed that the given graph is a tree.",Print a single integer — the minimum number of steps you have to perform to color the tree into given colors.,"['6\n1 2 2 1 5\n2 1 1 1 1 1\n', '7\n1 1 2 3 1 4\n3 3 1 1 1 2 3\n']","['3\n', '5\n']","The tree from the first sample is shown on the picture (numbers are vetices' indices):

<img class=""tex-graphics"" src=""https://espresso.codeforces.com/10324ccdc37f95343acc4f3c6050d8c334334ffa.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

On first step we color all vertices in the subtree of vertex 1 into color 2 (numbers are colors):

<img class=""tex-graphics"" src=""https://espresso.codeforces.com/1c7bb267e2c1a006132248a43121400189309e2f.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

On seond step we color all vertices in the subtree of vertex 5 into color 1:

<img class=""tex-graphics"" src=""https://espresso.codeforces.com/2201a6d49b89ba850ff0d0bdcbb3f8e9dd3871a8.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

On third step we color all vertices in the subtree of vertex 2 into color 1:

<img class=""tex-graphics"" src=""https://espresso.codeforces.com/6fa977fcdebdde94c47695151e0427b33d0102c5.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

The tree from the second sample is shown on the picture (numbers are vetices' indices):

<img class=""tex-graphics"" src=""https://espresso.codeforces.com/d70f9ae72a2ed429dd6531cac757e375dd3c953d.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

On first step we color all vertices in the subtree of vertex 1 into color 3 (numbers are colors):

<img class=""tex-graphics"" src=""https://espresso.codeforces.com/7289e8895d0dd56c47b6b17969b9cf77b36786b5.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

On second step we color all vertices in the subtree of vertex 3 into color 1:

<img class=""tex-graphics"" src=""https://espresso.codeforces.com/819001df7229138db3a407713744d1e3be88b64e.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

On third step we color all vertices in the subtree of vertex 6 into color 2:

<img class=""tex-graphics"" src=""https://espresso.codeforces.com/80ebbd870a0a339636a21b9acdaf9de046458b43.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

On fourth step we color all vertices in the subtree of vertex 4 into color 1:

<img class=""tex-graphics"" src=""https://espresso.codeforces.com/ed836aa723ac0176abde4e32988e3ac205014e93.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

On fith step we color all vertices in the subtree of vertex 7 into color 3:

<img class=""tex-graphics"" src=""https://espresso.codeforces.com/8132909e11b41c27b8df2f0b0c10bc841f35e58a.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>",OK,"N = int(input())
con = [0]
vert = [i for i in range(1,N+1)]
a = input().split("" "")
for i in range(N-1):
    con.append(int(a[i])-1)
color=[]
a = input().split("" "")
for i in range(N):
    color.append(int(a[i]))
cur = [color[0] for i in range(N)]
steps=1
for i in range(1,N):
    if cur[con[i]]==color[i]:
        cur[i] = color[i]
    else:
        steps+=1
        cur[i] = color[i]
print(steps)
#print(con)
#print(color)
#print(vert)
","class A:

    def solve(self):
        [n, m] = [int(x) for x in input().split("" "")]
        flag = []
        
        # Read the flag representation
        for _ in range(n):
            flag.append(input().strip())
        
        # Check each row for uniformity
        for row in flag:
            if len(set(row)) != 1:  # Check if all characters in row are the same
                print(""NO"")
                return
        
        # Check adjacent rows for different colors
        for i in range(1, n):
            if flag[i][0] == flag[i-1][0]:  # Check if the first character of current row is the same as the previous row
                print(""NO"")
                return
        
        print(""YES"")"
92,B,Binary Number,PROGRAMMING,['greedy'],"Little walrus Fangy loves math very much. That's why when he is bored he plays with a number performing some operations.

Fangy takes some positive integer *x* and wants to get a number one from it. While *x* is not equal to 1, Fangy repeats the following action: if *x* is odd, then he adds 1 to it, otherwise he divides *x* by 2. Fangy knows that for any positive integer number the process ends in finite time.

How many actions should Fangy perform to get a number one from number *x*?",The first line contains a positive integer *x* in a binary system. It is guaranteed that the first digit of *x* is different from a zero and the number of its digits does not exceed 106.,Print the required number of actions.,"['1\n', '1001001\n', '101110\n']","['0\n', '12\n', '8\n']","Let's consider the third sample. Number 101110 is even, which means that we should divide it by 2. After the dividing Fangy gets an odd number 10111 and adds one to it. Number 11000 can be divided by 2 three times in a row and get number 11. All that's left is to increase the number by one (we get 100), and then divide it by 2 two times in a row. As a result, we get 1.",TIME_LIMIT_EXCEEDED,"import math
import queue

from itertools import permutations


n=int(input())
m=0
i=0

while n!=0:
    m+=(n%10)*pow(2,i)
    i+=1
    n//=10

n=m
    
answer=0

while n!=1:
    if n%2==0:
        n//=2
    else:
        n+=1
    answer+=1
    
print(answer)","import math

def theatresquare(n: int, m: int, a: int) -> int:
    width = math.ceil(m / a)  # Calculate the number of flagstones along the width
    height = math.ceil(n / a)  # Calculate the number of flagstones along the height
    return width * height  # Return the total number of flagstones needed"
0,none,none,none,['none'],"Leonid wants to become a glass carver (the person who creates beautiful artworks by cutting the glass). He already has a rectangular *w* mm <=×<= *h* mm sheet of glass, a diamond glass cutter and lots of enthusiasm. What he lacks is understanding of what to carve and how.

In order not to waste time, he decided to practice the technique of carving. To do this, he makes vertical and horizontal cuts through the entire sheet. This process results in making smaller rectangular fragments of glass. Leonid does not move the newly made glass fragments. In particular, a cut divides each fragment of glass that it goes through into smaller fragments.

After each cut Leonid tries to determine what area the largest of the currently available glass fragments has. Since there appear more and more fragments, this question takes him more and more time and distracts him from the fascinating process.

Leonid offers to divide the labor — he will cut glass, and you will calculate the area of the maximum fragment after each cut. Do you agree?","The first line contains three integers *w*,<=*h*,<=*n* (2<=≤<=*w*,<=*h*<=≤<=200<=000, 1<=≤<=*n*<=≤<=200<=000).

Next *n* lines contain the descriptions of the cuts. Each description has the form *H* *y* or *V* *x*. In the first case Leonid makes the horizontal cut at the distance *y* millimeters (1<=≤<=*y*<=≤<=*h*<=-<=1) from the lower edge of the original sheet of glass. In the second case Leonid makes a vertical cut at distance *x* (1<=≤<=*x*<=≤<=*w*<=-<=1) millimeters from the left edge of the original sheet of glass. It is guaranteed that Leonid won't make two identical cuts.",After each cut print on a single line the area of the maximum available glass fragment in mm2.,"['4 3 4\nH 2\nV 2\nV 3\nV 1\n', '7 6 5\nH 4\nV 3\nV 5\nH 2\nV 1\n']","['8\n4\n4\n2\n', '28\n16\n12\n6\n4\n']",Picture for the first sample test:,WRONG_ANSWER,"print(""_RANDOM_GUESS_1691611355.33468"")# 1691611355.334696","import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,queue,copy

sys.setrecursionlimit(10**7)
inf=10**20
mod=10**9+7
dd=[(-1,0),(0,1),(1,0),(0,-1)]
ddn=[(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]

# Read input
n = int(input())
flights = input().strip()

# Initialize flight count
seattle_to_sf = 0
sf_to_seattle = 0

# Count flights
for i in range(1, n):
    if flights[i-1] == 'S' and flights[i] == 'F':
        seattle_to_sf += 1
    elif flights[i-1] == 'F' and flights[i] == 'S':
        sf_to_seattle += 1

# Determine if more flights were from Seattle to San Francisco
if seattle_to_sf > sf_to_seattle:
    print(""YES"")
else:
    print(""NO"")"
144,A,Arrival of the General,PROGRAMMING,['implementation'],"A Ministry for Defense sent a general to inspect the Super Secret Military Squad under the command of the Colonel SuperDuper. Having learned the news, the colonel ordered to all *n* squad soldiers to line up on the parade ground.

By the military charter the soldiers should stand in the order of non-increasing of their height. But as there's virtually no time to do that, the soldiers lined up in the arbitrary order. However, the general is rather short-sighted and he thinks that the soldiers lined up correctly if the first soldier in the line has the maximum height and the last soldier has the minimum height. Please note that the way other solders are positioned does not matter, including the case when there are several soldiers whose height is maximum or minimum. Only the heights of the first and the last soldier are important.

For example, the general considers the sequence of heights (4, 3, 4, 2, 1, 1) correct and the sequence (4, 3, 1, 2, 2) wrong.

Within one second the colonel can swap any two neighboring soldiers. Help him count the minimum time needed to form a line-up which the general will consider correct.","The first input line contains the only integer *n* (2<=≤<=*n*<=≤<=100) which represents the number of soldiers in the line. The second line contains integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=100) the values of the soldiers' heights in the order of soldiers' heights' increasing in the order from the beginning of the line to its end. The numbers are space-separated. Numbers *a*1,<=*a*2,<=...,<=*a**n* are not necessarily different.",Print the only integer — the minimum number of seconds the colonel will need to form a line-up the general will like.,"['4\n33 44 11 22\n', '7\n10 10 58 31 63 40 76\n']","['2\n', '10\n']","In the first sample the colonel will need to swap the first and second soldier and then the third and fourth soldier. That will take 2 seconds. The resulting position of the soldiers is (44, 33, 22, 11).

In the second sample the colonel may swap the soldiers in the following sequence:
 1.  (10, 10, 58, 31, 63, 40, 76) 1.  (10, 58, 10, 31, 63, 40, 76) 1.  (10, 58, 10, 31, 63, 76, 40) 1.  (10, 58, 10, 31, 76, 63, 40) 1.  (10, 58, 31, 10, 76, 63, 40) 1.  (10, 58, 31, 76, 10, 63, 40) 1.  (10, 58, 31, 76, 63, 10, 40) 1.  (10, 58, 76, 31, 63, 10, 40) 1.  (10, 76, 58, 31, 63, 10, 40) 1.  (76, 10, 58, 31, 63, 10, 40) 1.  (76, 10, 58, 31, 63, 40, 10)",OK,"n = int(input())
lst = list(map(int,input().split()))
a=0
b=100
max_ind=0
min_ind=0

for i in range(n):
    if lst[i]>a:
        a=lst[i]
        max_ind = i
    if lst[i]<=b:
        b = lst[i]
        min_ind = i
if max_ind<min_ind:
    print(max_ind+(n-min_ind)-1)
else:
    print(max_ind+((n-min_ind)-2))","def beauty(distances, constelation):
    beat = 0
    for left, right in distances:
        lilies = 0
        roses = 0
        for i in range(left - 1, right):
            if constelation[i] == ""0"":
                roses += 1
            else:
                lilies += 1
        beat += roses * lilies
    return beat

def max_flower_beauty(n, m, visits):
    # We can alternate flowers to maximize the beauty
    # Starting with a rose at the first position
    constelation = []
    for i in range(n):
        if i % 2 == 0:
            constelation.append(""0"")  # Rose
        else:
            constelation.append(""1"")  # Lily
    return """".join(constelation)

# Input reading
n, m = map(int, input().split())
visits = [tuple(map(int, input().split())) for _ in range(m)]

# Calculate and print the arrangement
result = max_flower_beauty(n, m, visits)
print(result)"
578,B,"""Or"" Game",PROGRAMMING,"['brute force', 'greedy']","You are given *n* numbers *a*1,<=*a*2,<=...,<=*a**n*. You can perform at most *k* operations. For each operation you can multiply one of the numbers by *x*. We want to make  as large as possible, where  denotes the bitwise OR. 

Find the maximum possible value of  after performing at most *k* operations optimally.","The first line contains three integers *n*, *k* and *x* (1<=≤<=*n*<=≤<=200<=000, 1<=≤<=*k*<=≤<=10, 2<=≤<=*x*<=≤<=8).

The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (0<=≤<=*a**i*<=≤<=109).",Output the maximum value of a bitwise OR of sequence elements after performing operations.,"['3 1 2\n1 1 1\n', '4 2 3\n1 2 4 8\n']","['3\n', '79\n']","For the first sample, any possible choice of doing one operation will result the same three numbers 1, 1, 2 so the result is <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/1ee73b671ed4bc53f2f96ed1a85fd98388e1712b.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>. 

For the second sample if we multiply 8 by 3 two times we'll get 72. In this case the numbers will become 1, 2, 4, 72 so the OR value will be 79 and is the largest possible result.",RUNTIME_ERROR,"n, k, x = list(map(int, input().split()))
a = list(map(int, input().split()))
prefix = [0 for i in range(200001)]
suffix = [0 for i in range(200001)]
mul = x ** k
for i in range(1, n + 1):
    prefix[i] = prefix[i-1] | a[i - 1];
for i in range(n, 0, -1):
    suffix[i] = suffix[i+1] | a[i - 1];
ans = 0
for i in range(1, n + 1):
        ans = max(ans, prefix[i-1] | (a[i - 1] * mul) | suffix[i+1]);
print(ans);
","import sys
readline = sys.stdin.readline

def Bisect_Float(ok, ng, is_ok, eps=1e-12, cnt=0):
    if cnt:
        for _ in range(cnt):
            mid = (ok + ng) / 2
            if is_ok(mid):
                ok = mid
            else:
                ng = mid
    return ok

def max_expected_catch(n, a, b, p, u):
    # We will calculate the expected value based on the probabilities
    expected_values = [(1 - (1 - p[i]) * (1 - u[i]), i) for i in range(n)]
    expected_values.sort(reverse=True, key=lambda x: x[0])  # Sort by expected value
    expected_catch = 0.0
    
    # Take the best a + b pokemons
    for i in range(min(a + b, n)):
        expected_catch += expected_values[i][0]
    
    return expected_catch

# Read input values
n, a, b = map(int, readline().split())
p = list(map(float, readline().split()))
u = list(map(float, readline().split()))

# Calculate the maximum expected number of Pokemons Gosha can catch
result = max_expected_catch(n, a, b, p, u)

# Print the result
print(f""{result:.10f}"")"
408,A,Line to Cashier,PROGRAMMING,['implementation'],"Little Vasya went to the supermarket to get some groceries. He walked about the supermarket for a long time and got a basket full of products. Now he needs to choose the cashier to pay for the products.

There are *n* cashiers at the exit from the supermarket. At the moment the queue for the *i*-th cashier already has *k**i* people. The *j*-th person standing in the queue to the *i*-th cashier has *m**i*,<=*j* items in the basket. Vasya knows that:
 -  the cashier needs 5 seconds to scan one item; -  after the cashier scans each item of some customer, he needs 15 seconds to take the customer's money and give him the change. 
Of course, Vasya wants to select a queue so that he can leave the supermarket as soon as possible. Help him write a program that displays the minimum number of seconds after which Vasya can get to one of the cashiers.","The first line contains integer *n* (1<=≤<=*n*<=≤<=100) — the number of cashes in the shop. The second line contains *n* space-separated integers: *k*1,<=*k*2,<=...,<=*k**n* (1<=≤<=*k**i*<=≤<=100), where *k**i* is the number of people in the queue to the *i*-th cashier.

The *i*-th of the next *n* lines contains *k**i* space-separated integers: *m**i*,<=1,<=*m**i*,<=2,<=...,<=*m**i*,<=*k**i* (1<=≤<=*m**i*,<=*j*<=≤<=100) — the number of products the *j*-th person in the queue for the *i*-th cash has.",Print a single integer — the minimum number of seconds Vasya needs to get to the cashier.,"['1\n1\n1\n', '4\n1 4 3 2\n100\n1 2 2 3\n1 9 1\n7 8\n']","['20\n', '100\n']","In the second test sample, if Vasya goes to the first queue, he gets to the cashier in 100·5 + 15 = 515 seconds. But if he chooses the second queue, he will need 1·5 + 2·5 + 2·5 + 3·5 + 4·15 = 100 seconds. He will need 1·5 + 9·5 + 1·5 + 3·15 = 100 seconds for the third one and 7·5 + 8·5 + 2·15 = 105 seconds for the fourth one. Thus, Vasya gets to the cashier quicker if he chooses the second or the third queue.",OK,"
def solve():
    n = int(input())
    ak = [int(i) for i in input().split()]
    ans = float(""inf"")
    for i in range(n):
        a = [int(k) for k in input().split()]
        s = 0
        for j in range(len(a)):
            s+=a[j]*5
        s+=15*ak[i]
        ans = min(ans,s)
    print(ans)
    return



# t = int(input())
# for _ in range(t):
#     solve()
solve()","line = input()
    tab.append(list(line))

# Function to perform DFS and mark connected empty cells
def dfs(x, y):
    if x < 0 or x >= n or y < 0 or y >= m or tab[x][y] != '.':
        return
    tab[x][y] = '#'
    global c
    c += 1
    # Explore all four directions
    dfs(x + 1, y)  # down
    dfs(x - 1, y)  # up
    dfs(x, y + 1)  # right
    dfs(x, y - 1)  # left

# Start DFS from the first empty cell found
for i in range(n):
    for j in range(m):
        if tab[i][j] == '.':
            dfs(i, j)
            break
    if c > 0:
        break

# Now we try to add walls
walls_to_add = mb - k  # number of walls we can place while ensuring connectivity

for i in range(n):
    for j in range(m):
        if walls_to_add == 0:
            break
        if tab[i][j] == '.':
            # Check if adding wall here keeps the maze connected
            tab[i][j] = 'X'  # this cell becomes a wall
            walls_to_add -= 1

# Print the modified maze
for i in range(n):
    print(''.join(tab[i]))"
230,B,T-primes,PROGRAMMING,"['binary search', 'implementation', 'math', 'number theory']","We know that prime numbers are positive integers that have exactly two distinct positive divisors. Similarly, we'll call a positive integer *t* Т-prime, if *t* has exactly three distinct positive divisors.

You are given an array of *n* positive integers. For each of them determine whether it is Т-prime or not.","The first line contains a single positive integer, *n* (1<=≤<=*n*<=≤<=105), showing how many numbers are in the array. The next line contains *n* space-separated integers *x**i* (1<=≤<=*x**i*<=≤<=1012).

Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is advised to use the cin, cout streams or the %I64d specifier.","Print *n* lines: the *i*-th line should contain ""YES"" (without the quotes), if number *x**i* is Т-prime, and ""NO"" (without the quotes), if it isn't.",['3\n4 5 6\n'],['YES\nNO\nNO\n'],"The given test has three numbers. The first number 4 has exactly three divisors — 1, 2 and 4, thus the answer for this number is ""YES"". The second number 5 has two divisors (1 and 5), and the third number 6 has four divisors (1, 2, 3, 6), hence the answer for them is ""NO"".",TIME_LIMIT_EXCEEDED,"from sys import stdin
def input(): return stdin.readline()[:-1]
def ili(): return list(map(int, input().split()))
import math
from collections import defaultdict

# def prime(k):
#     for i in range(2, math.isqrt(k)+1):
#         if k%i == 0:
#             return False
#     return True

def check(n):
    d = defaultdict(lambda : 0)
    while n % 2 == 0:
        d[2] += 1
        n = n // 2
    for i in range(3, int(math.sqrt(n))+1, 2):
        while n % i == 0:
            d[i] += 1
            n = n // i
    if n > 2:
        d[n] += 1
    if len(d.keys()) == 1 and list(d.values())[0] == 2:
        return True
    return False

def solve():
    n = int(input())
    s = ili()
    for i in s:
        if i == 1:
            print(""NO"")
            continue
        print(""YES"") if check(i) else print(""NO"")


case_num = 1
# case_num = int(input())
for case in range(case_num):
    solve()","def number_of_lucky_digit(a, k):
    ans = False
    ans1 = 0
    for i in a:
        # Count lucky digits in the number
        lucky_count = sum(1 for digit in str(i) if digit in '47')
        
        # Check if lucky digits count is not more than k
        if lucky_count <= k:
            ans1 += 1  # Increment count if condition is met
    return ans1

# Read input
n, k = map(int, input().split())  # First line input for n and k
a = list(map(int, input().split()))  # Second line input for n integers

# Get the result and print it
result = number_of_lucky_digit(a, k)
print(result)"
741,B,Arpa's weak amphitheater and Mehrdad's valuable Hoses,PROGRAMMING,"['dfs and similar', 'dp', 'dsu']","Just to remind, girls in Arpa's land are really nice.

Mehrdad wants to invite some Hoses to the palace for a dancing party. Each Hos has some weight *w**i* and some beauty *b**i*. Also each Hos may have some friends. Hoses are divided in some friendship groups. Two Hoses *x* and *y* are in the same friendship group if and only if there is a sequence of Hoses *a*1,<=*a*2,<=...,<=*a**k* such that *a**i* and *a**i*<=+<=1 are friends for each 1<=≤<=*i*<=&lt;<=*k*, and *a*1<==<=*x* and *a**k*<==<=*y*.

Arpa allowed to use the amphitheater of palace to Mehrdad for this party. Arpa's amphitheater can hold at most *w* weight on it. 

Mehrdad is so greedy that he wants to invite some Hoses such that sum of their weights is not greater than *w* and sum of their beauties is as large as possible. Along with that, from each friendship group he can either invite all Hoses, or no more than one. Otherwise, some Hoses will be hurt. Find for Mehrdad the maximum possible total beauty of Hoses he can invite so that no one gets hurt and the total weight doesn't exceed *w*.","The first line contains integers *n*, *m* and *w* (1<=<=≤<=<=*n*<=<=≤<=<=1000, , 1<=≤<=*w*<=≤<=1000) — the number of Hoses, the number of pair of friends and the maximum total weight of those who are invited.

The second line contains *n* integers *w*1,<=*w*2,<=...,<=*w**n* (1<=≤<=*w**i*<=≤<=1000) — the weights of the Hoses.

The third line contains *n* integers *b*1,<=*b*2,<=...,<=*b**n* (1<=≤<=*b**i*<=≤<=106) — the beauties of the Hoses.

The next *m* lines contain pairs of friends, the *i*-th of them contains two integers *x**i* and *y**i* (1<=≤<=*x**i*,<=*y**i*<=≤<=*n*, *x**i*<=≠<=*y**i*), meaning that Hoses *x**i* and *y**i* are friends. Note that friendship is bidirectional. All pairs (*x**i*,<=*y**i*) are distinct.",Print the maximum possible total beauty of Hoses Mehrdad can invite so that no one gets hurt and the total weight doesn't exceed *w*.,"['3 1 5\n3 2 5\n2 4 2\n1 2\n', '4 2 11\n2 4 6 6\n6 4 2 1\n1 2\n2 3\n']","['6\n', '7\n']","In the first sample there are two friendship groups: Hoses {1, 2} and Hos {3}. The best way is to choose all of Hoses in the first group, sum of their weights is equal to 5 and sum of their beauty is 6.

In the second sample there are two friendship groups: Hoses {1, 2, 3} and Hos {4}. Mehrdad can't invite all the Hoses from the first group because their total weight is 12 &gt; 11, thus the best way is to choose the first Hos from the first group and the only one from the second group. The total weight will be 8, and the total beauty will be 7.",OK,"def g(x):
    if x == t[x]: return x
    t[x] = g(t[x])
    return t[x]

f = lambda: map(int, input().split())
hoses, pairOfFriends, weight = f()
weightsAndBeauties = [(0, 0)] + list(zip(f(), f()))
t = list(range(hoses + 1))


for i in range(pairOfFriends):
    f1, f2 = f()
    f1, f2 = g(f1), g(f2)
    if f1 != f2:
        t[f2] = f1

p = [[] for j in range(hoses + 1)]
for i in range(1, hoses + 1):
    p[g(i)].append(i)

beauties = [1] + [0] * weight
for q in p:
    if len(q) > 1:
        t = [weightsAndBeauties[i] for i in q]
        t.append((sum(f1[0] for f1 in t), sum(f1[1] for f1 in t)))
        t.sort(key=lambda f1: f1[0])

        for j in range(weight, -1, -1):
            if beauties[j]:
                for w, b in t:
                    if j + w > weight:
                        break
                    else:
                        beauties[j + w] = max(beauties[j + w], beauties[j] + b)
    elif len(q) == 1:
        w, b = weightsAndBeauties[q[0]]
        for j in range(weight - w, -1, -1):
            if beauties[j]:
                beauties[j + w] = max(beauties[j + w], beauties[j] + b)

maxBeauty = max(beauties) - 1
print(maxBeauty)","def dfs(node, par, papu, mypapu):
    v = intial[node]
    
    if mypapu:
        v = (v + 1) % 2
    if v != final[node]:
        ans.append(node)
        for child in graph[node]:
            if child != par:  # Prevent going back to the parent
                dfs(child, node, papu, not mypapu)

n = int(input())  # Number of nodes
graph = [[] for _ in range(n + 1)]
intial = list(map(int, input().split()))  # Initial values at each node
final = list(map(int, input().split()))  # Goal values at each node
ans = []

for _ in range(n - 1):
    u, v = map(int, input().split())
    graph[u].append(v)
    graph[v].append(u)

dfs(1, -1, 0, 0)  # Start DFS from root node
print(len(ans))  # Output the count of operations
for x in ans:
    print(x)  # Output each selected node for the operation"
233,A,Perfect Permutation,PROGRAMMING,"['implementation', 'math']","A permutation is a sequence of integers *p*1,<=*p*2,<=...,<=*p**n*, consisting of *n* distinct positive integers, each of them doesn't exceed *n*. Let's denote the *i*-th element of permutation *p* as *p**i*. We'll call number *n* the size of permutation *p*1,<=*p*2,<=...,<=*p**n*.

Nickolas adores permutations. He likes some permutations more than the others. He calls such permutations perfect. A perfect permutation is such permutation *p* that for any *i* (1<=≤<=*i*<=≤<=*n*) (*n* is the permutation size) the following equations hold *p**p**i*<==<=*i* and *p**i*<=≠<=*i*. Nickolas asks you to print any perfect permutation of size *n* for the given *n*.",A single line contains a single integer *n* (1<=≤<=*n*<=≤<=100) — the permutation size.,"If a perfect permutation of size *n* doesn't exist, print a single integer -1. Otherwise print *n* distinct integers from 1 to *n*, *p*1,<=*p*2,<=...,<=*p**n* — permutation *p*, that is perfect. Separate printed numbers by whitespaces.","['1\n', '2\n', '4\n']","['-1\n', '2 1 \n', '2 1 4 3 \n']",none,WRONG_ANSWER,"list1 = []
num = int(input())

if num % 2 != 0:
    print(-1)

else:
    if len(list1) % 2 == 0:
        for j in range(1, num + 1, 2):
            list1.append(j + 1)
            list1.append(j)

    print(list1)
","def f(x, y):
    a = []
    for i in range(len(x)):
        a.append(min(x[i], y[i]))  # Find the minimum character between x[i] and y[i]
    return ''.join(a)  # Join the list into a string

x = input().strip()  # Read input string x
y = input().strip()  # Read input string y

z = []  # Initialize string z
for i in range(len(x)):
    # If x[i] > y[i], it's impossible to find a valid z
    if x[i] > y[i]:
        print(-1)
        break
    # Choose character for z: It should be between x[i] and y[i]
    z.append(y[i])  # Choose y[i]; it can be any character >= x[i] and <= y[i]
else:
    # If no break occurred, we found a valid z
    result = f(x, ''.join(z))  # Get result of f with x and constructed z
    if result <= y:
        print(''.join(z))  # Print the valid z
    else:
        print(-1)  # If f(x, z) is not <= y, print -1"
710,A,King Moves,PROGRAMMING,['implementation'],"The only king stands on the standard chess board. You are given his position in format ""cd"", where *c* is the column from 'a' to 'h' and *d* is the row from '1' to '8'. Find the number of moves permitted for the king.

Check the king's moves here [https://en.wikipedia.org/wiki/King_(chess)](https://en.wikipedia.org/wiki/King_(chess)).","The only line contains the king's position in the format ""cd"", where 'c' is the column from 'a' to 'h' and 'd' is the row from '1' to '8'.",Print the only integer *x* — the number of moves permitted for the king.,['e4\n'],['8\n'],none,OK,"from sys import stdin, stdout
def read():
	return stdin.readline().rstrip()

def read_int():
	return int(read())

def read_ints():
	return list(map(int, read().split()))

def solve():
	a=read()
	c=0
	if a[0]=='a' or a[0]=='h':
		c+=1
	if a[1]=='1' or a[1]=='8':
		c+=1
	if c==0:
		print(8)
	elif c==1:
		print(5)
	else:
		print(3)

solve()
","from collections import defaultdict, deque
from heapq import heappush, heappop
from math import inf, log

ri = lambda : map(int, input().split())
ro = lambda : int(input())

def solve():
    l, r, k = ri()  # Read input values
    
    current_power = 1  # Start with k^0
    powers = []  # List to store valid powers of k

    while current_power <= r:  # Continue until current_power exceeds r
        if current_power >= l:  # Check if current power is within range
            powers.append(current_power)  # Add to the list of valid powers
        
        if current_power > r // k:  # Avoid overflow in the next multiplication
            break
        
        current_power *= k  # Calculate the next power of k

    # Print results
    if powers:
        print(*powers)  # Print all found powers
    else:
        print(""-1"")  # Print -1 if no powers found"
807,A,Is it rated?,PROGRAMMING,"['implementation', 'sortings']","Is it rated?

Here it is. The Ultimate Question of Competitive Programming, Codeforces, and Everything. And you are here to answer it.

Another Codeforces round has been conducted. No two participants have the same number of points. For each participant, from the top to the bottom of the standings, their rating before and after the round is known.

It's known that if at least one participant's rating has changed, then the round was rated for sure.

It's also known that if the round was rated and a participant with lower rating took a better place in the standings than a participant with higher rating, then at least one round participant's rating has changed.

In this problem, you should not make any other assumptions about the rating system.

Determine if the current round is rated, unrated, or it's impossible to determine whether it is rated of not.","The first line contains a single integer *n* (2<=≤<=*n*<=≤<=1000) — the number of round participants.

Each of the next *n* lines contains two integers *a**i* and *b**i* (1<=≤<=*a**i*,<=*b**i*<=≤<=4126) — the rating of the *i*-th participant before and after the round, respectively. The participants are listed in order from the top to the bottom of the standings.","If the round is rated for sure, print ""rated"". If the round is unrated for sure, print ""unrated"". If it's impossible to determine whether the round is rated or not, print ""maybe"".","['6\n3060 3060\n2194 2194\n2876 2903\n2624 2624\n3007 2991\n2884 2884\n', '4\n1500 1500\n1300 1300\n1200 1200\n1400 1400\n', '5\n3123 3123\n2777 2777\n2246 2246\n2246 2246\n1699 1699\n']","['rated\n', 'unrated\n', 'maybe\n']","In the first example, the ratings of the participants in the third and fifth places have changed, therefore, the round was rated.

In the second example, no one's rating has changed, but the participant in the second place has lower rating than the participant in the fourth place. Therefore, if the round was rated, someone's rating would've changed for sure.

In the third example, no one's rating has changed, and the participants took places in non-increasing order of their rating. Therefore, it's impossible to determine whether the round is rated or not.",OK,"t  = int(input())
left = []
right = []
for i in range(t):
    x , y = input().split()
    x , y  = int(x) , int(y)
    left.append(x)
    right.append(y)
if left != right :print('rated')
elif left == right and sorted(left , reverse=True) != left and sorted(right , reverse=True) != right:print('unrated')
else:print('maybe')","x = input()
y = input()

# Initialize the resulting string z
z = []

# Iterate through characters of x and y
for xi, yi in zip(x, y):
    # Determine the character for z based on x and y
    # z[i] must be such that f(x, z) <= y
    if xi > yi:
        # If xi is greater than yi, it's impossible to create such z
        print(-1)
        break
    # Choose the maximum character possible for z
    # to keep f(x, z) <= y
    z.append(yi)

# If we successfully iterate through all characters, join and print z
else:
    print(''.join(z))"
379,A,New Year Candles,PROGRAMMING,['implementation'],"Vasily the Programmer loves romance, so this year he decided to illuminate his room with candles.

Vasily has *a* candles.When Vasily lights up a new candle, it first burns for an hour and then it goes out. Vasily is smart, so he can make *b* went out candles into a new candle. As a result, this new candle can be used like any other new candle.

Now Vasily wonders: for how many hours can his candles light up the room if he acts optimally well? Help him find this number.","The single line contains two integers, *a* and *b* (1<=≤<=*a*<=≤<=1000; 2<=≤<=*b*<=≤<=1000).",Print a single integer — the number of hours Vasily can light up the room for.,"['4 2\n', '6 3\n']","['7\n', '8\n']","Consider the first sample. For the first four hours Vasily lights up new candles, then he uses four burned out candles to make two new ones and lights them up. When these candles go out (stop burning), Vasily can make another candle. Overall, Vasily can light up the room for 7 hours.",OK,"a,b=map(int,input().split())
c=int(a-1)/(b-1)
print(int(a+c))
","import sys
sys.setrecursionlimit(10**6)

n, l, r, q1, q2 = [int(i) for i in input().split()]
arr = list(map(int, input().split()))

# Memoization dictionary
dp = {}

def min_energy(left_index, right_index, last_hand):
    # Base case: all items have been picked
    if left_index > right_index:
        return 0
    
    # Check if the result is already computed
    if (left_index, right_index, last_hand) in dp:
        return dp[(left_index, right_index, last_hand)]

    # Energy cost if using the left hand
    left_cost = arr[left_index] * l
    if last_hand == 'L':
        left_cost += q1
    
    # Energy cost if using the right hand
    right_cost = arr[right_index] * r
    if last_hand == 'R':
        right_cost += q2

    # Calculate energy for both scenarios
    use_left = left_cost + min_energy(left_index + 1, right_index, 'L')
    use_right = right_cost + min_energy(left_index, right_index - 1, 'R')

    # Take the minimum energy required
    result = min(use_left, use_right)
    
    # Save to memoization dictionary
    dp[(left_index, right_index, last_hand)] = result
    return result

# Start the recursion with both hands being unused initially
min_energy_result = min(min_energy(0, n - 1, None), min_energy(0, n - 1, None))
print(min_energy_result)"
322,B,Ciel and Flowers,PROGRAMMING,"['combinatorics', 'math']","Fox Ciel has some flowers: *r* red flowers, *g* green flowers and *b* blue flowers. She wants to use these flowers to make several bouquets. There are 4 types of bouquets:
 -  To make a ""red bouquet"", it needs 3 red flowers. -  To make a ""green bouquet"", it needs 3 green flowers. -  To make a ""blue bouquet"", it needs 3 blue flowers. -  To make a ""mixing bouquet"", it needs 1 red, 1 green and 1 blue flower. 
Help Fox Ciel to find the maximal number of bouquets she can make.","The first line contains three integers *r*, *g* and *b* (0<=≤<=*r*,<=*g*,<=*b*<=≤<=109) — the number of red, green and blue flowers.",Print the maximal number of bouquets Fox Ciel can make.,"['3 6 9\n', '4 4 4\n', '0 0 0\n']","['6\n', '4\n', '0\n']","In test case 1, we can make 1 red bouquet, 2 green bouquets and 3 blue bouquets.

In test case 2, we can make 1 red, 1 green, 1 blue and 1 mixing bouquet.",WRONG_ANSWER,"from sys import stdin,stdout
stdin.readline
def mp(): return list(map(int, stdin.readline().strip().split()))
def it():return int(stdin.readline().strip())
from collections import defaultdict as dd,Counter as C,deque
from math import ceil,gcd,sqrt,factorial,log2,floor
from bisect import bisect_right as br,bisect_left as bl
import heapq

r,g,b = mp()
ans = min(r,g,b)
r -= ans
g -= ans
b -= ans
ans += r//3
ans += g//3
ans += b//3
print(ans)


","n=int(input())
l=input().split()
m,s=0,0

def dif(a,b):
    return abs(a - b)

for bi in map(int, l):
    s += dif(m, bi)  # Calculate the difference to reach the current b
    m = bi  # Update the current value of m to the current b

print(s)  # Print the total number of steps needed"
339,A,Helpful Maths,PROGRAMMING,"['greedy', 'implementation', 'sortings', 'strings']","Xenia the beginner mathematician is a third year student at elementary school. She is now learning the addition operation.

The teacher has written down the sum of multiple numbers. Pupils should calculate the sum. To make the calculation easier, the sum only contains numbers 1, 2 and 3. Still, that isn't enough for Xenia. She is only beginning to count, so she can calculate a sum only if the summands follow in non-decreasing order. For example, she can't calculate sum 1+3+2+1 but she can calculate sums 1+1+2 and 3+3.

You've got the sum that was written on the board. Rearrange the summans and print the sum in such a way that Xenia can calculate the sum.","The first line contains a non-empty string *s* — the sum Xenia needs to count. String *s* contains no spaces. It only contains digits and characters ""+"". Besides, string *s* is a correct sum of numbers 1, 2 and 3. String *s* is at most 100 characters long.",Print the new sum that Xenia can count.,"['3+2+1\n', '1+1+3+1+3\n', '2\n']","['1+2+3\n', '1+1+1+3+3\n', '2\n']",none,OK,"a=input()
b=[]
for i in range(0,len(a),2):
    b.append(a[i])
b.sort()
b=""+"".join(b)
print(b)

 
","# Rohan Bojja 
# [email protected]
from collections import defaultdict
#######################################
c = 1
cases = 1

while c <= cases:
    n = int(input())  # Number of flights
    home = input().strip()  # Home airport
    flights = defaultdict(int)  # Dictionary to count flights

    for _ in range(n):
        flight = input().strip()  # Flight information
        departure, arrival = flight.split('->')  # Split flight info
        # Increment the flight count for the departure airport
        flights[departure] += 1
        # Decrement the flight count for the arrival airport
        flights[arrival] -= 1

    # The net count for home should be checked
    if flights[home] > 0:
        print(""contest"")  # More departures than arrivals, they are away
    else:
        print(""home"")  # Balanced or more arrivals than departures

    c += 1"
231,A,Team,PROGRAMMING,"['brute force', 'greedy']","One day three best friends Petya, Vasya and Tonya decided to form a team and take part in programming contests. Participants are usually offered several problems during programming contests. Long before the start the friends decided that they will implement a problem if at least two of them are sure about the solution. Otherwise, the friends won't write the problem's solution.

This contest offers *n* problems to the participants. For each problem we know, which friend is sure about the solution. Help the friends find the number of problems for which they will write a solution.","The first input line contains a single integer *n* (1<=≤<=*n*<=≤<=1000) — the number of problems in the contest. Then *n* lines contain three integers each, each integer is either 0 or 1. If the first number in the line equals 1, then Petya is sure about the problem's solution, otherwise he isn't sure. The second number shows Vasya's view on the solution, the third number shows Tonya's view. The numbers on the lines are separated by spaces.",Print a single integer — the number of problems the friends will implement on the contest.,"['3\n1 1 0\n1 1 1\n1 0 0\n', '2\n1 0 0\n0 1 1\n']","['2\n', '1\n']","In the first sample Petya and Vasya are sure that they know how to solve the first problem and all three of them know how to solve the second problem. That means that they will write solutions for these problems. Only Petya is sure about the solution for the third problem, but that isn't enough, so the friends won't take it. 

In the second sample the friends will only implement the second problem, as Vasya and Tonya are sure about the solution.",OK,"cases_num=int(input())
res=0
for ix in range(cases_num):
    inputs=input()
    cases=inputs.split(' ')
    score=0
    for num in cases:
        score+=(int(num))
    if score>=2:
        res+=1
print(res)","import sys

n = int(input())
beacons = [tuple(map(int, input().split())) for _ in range(n)]

# We will calculate the minimum number of beacons destroyed
def min_destroyed(beacons):
    # Start with no beacons destroyed
    destroyed = 0
    # The last position we can place a beacon
    last_position = float('inf')

    # Iterate through beacons from right to left
    for a, b in reversed(beacons):
        # If current beacon position is within the destroy range of the last activated beacon
        if a <= last_position:
            destroyed += 1  # This beacon will be destroyed
            last_position = a - b  # Update last position to left edge of destruction
        else:
            last_position = a  # Update the last position to be the current beacon

    return destroyed

# Get the result from the min_destroyed function
result = min_destroyed(beacons)

# Output the result
print(result)"
292,D,Connected Components,PROGRAMMING,"['data structures', 'dfs and similar', 'dp', 'dsu']","We already know of the large corporation where Polycarpus works as a system administrator. The computer network there consists of *n* computers and *m* cables that connect some pairs of computers. In other words, the computer network can be represented as some non-directed graph with *n* nodes and *m* edges. Let's index the computers with integers from 1 to *n*, let's index the cables with integers from 1 to *m*.

Polycarpus was given an important task — check the reliability of his company's network. For that Polycarpus decided to carry out a series of *k* experiments on the computer network, where the *i*-th experiment goes as follows:
 1.  Temporarily disconnect the cables with indexes from *l**i* to *r**i*, inclusive (the other cables remain connected). 1.  Count the number of connected components in the graph that is defining the computer network at that moment. 1.  Re-connect the disconnected cables with indexes from *l**i* to *r**i* (that is, restore the initial network). 
Help Polycarpus carry out all experiments and for each print the number of connected components in the graph that defines the computer network through the given experiment. Isolated vertex should be counted as single component.","The first line contains two space-separated integers *n*, *m* (2<=≤<=*n*<=≤<=500; 1<=≤<=*m*<=≤<=104) — the number of computers and the number of cables, correspondingly.

The following *m* lines contain the cables' description. The *i*-th line contains space-separated pair of integers *x**i*, *y**i* (1<=≤<=*x**i*,<=*y**i*<=≤<=*n*; *x**i*<=≠<=*y**i*) — the numbers of the computers that are connected by the *i*-th cable. Note that a pair of computers can be connected by multiple cables.

The next line contains integer *k* (1<=≤<=*k*<=≤<=2·104) — the number of experiments. Next *k* lines contain the experiments' descriptions. The *i*-th line contains space-separated integers *l**i*, *r**i* (1<=≤<=*l**i*<=≤<=*r**i*<=≤<=*m*) — the numbers of the cables that Polycarpus disconnects during the *i*-th experiment.","Print *k* numbers, the *i*-th number represents the number of connected components of the graph that defines the computer network during the *i*-th experiment.",['6 5\n1 2\n5 4\n2 3\n3 1\n3 6\n6\n1 3\n2 5\n1 5\n5 5\n2 4\n3 3\n'],['4\n5\n6\n3\n4\n2\n'],none,COMPILATION_ERROR,"#include <iostream>
#define _USE_MATH_DEFINES
#include <stdio.h>
#include <stdlib.h>
#include <set>
#include <list>
#include <string>
#include <algorithm>
#include <map>
#include <cmath>
#include <stack>
#include <functional>
#include <math.h>
#include <queue>
#include <vector>
#include <bitset>
#include <cstdio>
#pragma comment(linker, ""/STACK:256000000"")
typedef long long ll;
#define MP make_pair
   
using namespace std;

int p[555];
int rang[555];

void make_set(int x) {
	p[x] = x;
	rang[x] = 0;
}

int find_set(int x) {
	if (p[x] == x)
		return x;
	return p[x] = find_set(p[x]);
}

void union_set(int x, int y) {
	x = find_set(x);
	y = find_set(y);
	if (rang[x] > rang[y])
		swap(x, y);
	if (x != y) {
		p[x] = y;
		rang[y] += (rang[x] == rang[y]);
	}
}



int main() {
	//freopen(""input.txt"",""r"",stdin);
	//freopen(""output.txt"",""w"",stdout);
	int n, m;
	cin >> n >> m;
	stack <int> ans;
	vector <pair <int, int> > v;
	pair <int, int> pp = MP(-1, -1);
	v.push_back(pp);
	for (int i = 1; i <= m; i++) {
		int x, y;
		cin >> x >> y;
		pp = MP(x, y);
		v.push_back(pp);
	}
	int q;
	cin >> q;
	stack <int> st;
	bool us[555];
	for (int i = 0; i <= 545; i++)
		us[i] = 1;
	for (int i = 1; i <= q; i++) {
		vector <int> gr[555];
		int l, r;
		cin >> l >> r;
		for (int i = 1; i <= n; i++) 
			make_set(i);
		int komp = n;
		for (int i = 1; i <= m; i++) {
			if (!(i >= l && i <= r)) {
				int u = v[i].first, vv = v[i].second;
				gr[u].push_back(vv);
				gr[vv].push_back(u);
				if (find_set(u) != find_set(vv))
					komp--;
				union_set(u, vv);				
			}
		}
		cout << komp << endl;
	}
}","num1, num2 = map(int, input().split())

def gcd(a, b):
    # Implementing Euclid's algorithm to compute GCD
    while b:
        a, b = b, a % b
    return a

# The GCD of all numbers from num1 to num2 is the GCD of num1 and num2,
# because any number in between num1 and num2 will be a multiple of their GCD
result = gcd(num1, num2)
print(result)"
50,A,Domino piling,PROGRAMMING,"['greedy', 'math']","You are given a rectangular board of *M*<=×<=*N* squares. Also you are given an unlimited number of standard domino pieces of 2<=×<=1 squares. You are allowed to rotate the pieces. You are asked to place as many dominoes as possible on the board so as to meet the following conditions:

1. Each domino completely covers two squares.

2. No two dominoes overlap.

3. Each domino lies entirely inside the board. It is allowed to touch the edges of the board.

Find the maximum number of dominoes, which can be placed under these restrictions.",In a single line you are given two integers *M* and *N* — board sizes in squares (1<=≤<=*M*<=≤<=*N*<=≤<=16).,"Output one number — the maximal number of dominoes, which can be placed.","['2 4\n', '3 3\n']","['4\n', '4\n']",none,OK,"from tkinter import N


m,n = list(map(int, input().split()))
t= m*n
c=0
if n%2==0:
    c= n/2*m
elif m%2==0:
    c= m/2*n
else:
    c= ((m-1)/2*n)+ (n-1)/2
print(int(c))","import sys, threading
input = sys.stdin.readline
from collections import defaultdict

# returns the first number where key becomes true for a given delegate type key
def bs(low=1, high=1, key=lambda x: True):
    while low < high:
        mid = (low + high) // 2
        if key(mid):
            high = mid
        else:
            low = mid + 1
    return low

def count_less_equal(x, n, m):
    # Counts how many numbers in the multiplication table are less than or equal to x
    count = 0
    for i in range(1, n + 1):
        count += min(x // i, m)  # number of elements i*j <= x
    return count

def find_kth_largest(n, m, k):
    # We are looking for the (n*m - k + 1)-th smallest element 
    target = n * m - k + 1
    left, right = 1, n * m

    # Binary search to find the number which is the target-th smallest
    answer = bs(left, right, key=lambda x: count_less_equal(x, n, m) >= target)
    return answer

# Read input
n, m, k = map(int, input().split())

# Find and print the k-th largest number
print(find_kth_largest(n, m, k))"
912,B,New Year's Eve,PROGRAMMING,"['bitmasks', 'constructive algorithms', 'number theory']","Since Grisha behaved well last year, at New Year's Eve he was visited by Ded Moroz who brought an enormous bag of gifts with him! The bag contains *n* sweet candies from the good ol' bakery, each labeled from 1 to *n* corresponding to its tastiness. No two candies have the same tastiness.

The choice of candies has a direct effect on Grisha's happiness. One can assume that he should take the tastiest ones — but no, the holiday magic turns things upside down. It is the xor-sum of tastinesses that matters, not the ordinary sum!

A xor-sum of a sequence of integers *a*1,<=*a*2,<=...,<=*a**m* is defined as the bitwise XOR of all its elements: , here  denotes the bitwise XOR operation; more about bitwise XOR can be found [here.](https://en.wikipedia.org/wiki/Bitwise_operation#XOR)

Ded Moroz warned Grisha he has more houses to visit, so Grisha can take no more than *k* candies from the bag. Help Grisha determine the largest xor-sum (largest xor-sum means maximum happiness!) he can obtain.",The sole string contains two integers *n* and *k* (1<=≤<=*k*<=≤<=*n*<=≤<=1018).,Output one number — the largest possible xor-sum.,"['4 3\n', '6 6\n']","['7\n', '7\n']","In the first sample case, one optimal answer is 1, 2 and 4, giving the xor-sum of 7.

In the second sample case, one can, for example, take all six candies and obtain the xor-sum of 7.",OK,"def precompute(arr) :
    arr[0] = 1
    for index in range(1,60) :
        arr[index] = arr[index-1]*2

def solve(n,k,power) :
    if k == 1 :
        return n
        
    else :
        for index in range(59,-1,-1):
            if power[index] <= n :
                return power[index] + (power[index] - 1)

arr = [0] * 60
n,k = list(map(int,input().split()))
precompute(arr)
print (solve(n,k,arr))
        ","def main():
    n = int(input())
    a = sorted([int(c) for c in input().split()])
    s = sum(a)
    
    # To maximize the score, start from the largest elements
    score = 0
    while len(a) > 1:
        # Take the last two elements, which are the largest
        x1 = a.pop()  # largest
        x2 = a.pop() if a else 0  # second largest, or 0 if empty
        
        # Add to the score the sum of these two
        score += (x1 + x2)
        
        # If there was a second element, push their sum back to the list
        if x2 > 0:
            a.append(x1 + x2)
            a.sort()  # keep array sorted to select largest elements in next iteration

    # Add the last remaining element (if any) to the score
    if a:
        score += a[0]
        
    print(score)

if __name__ == ""__main__"":
    main()"
593,B,Anton and Lines,PROGRAMMING,"['geometry', 'sortings']","The teacher gave Anton a large geometry homework, but he didn't do it (as usual) as he participated in a regular round on Codeforces. In the task he was given a set of *n* lines defined by the equations *y*<==<=*k**i*·*x*<=+<=*b**i*. It was necessary to determine whether there is at least one point of intersection of two of these lines, that lays strictly inside the strip between *x*1<=&lt;<=*x*2. In other words, is it true that there are 1<=≤<=*i*<=&lt;<=*j*<=≤<=*n* and *x*',<=*y*', such that: 
 -  *y*'<==<=*k**i*<=*<=*x*'<=+<=*b**i*, that is, point (*x*',<=*y*') belongs to the line number *i*; -  *y*'<==<=*k**j*<=*<=*x*'<=+<=*b**j*, that is, point (*x*',<=*y*') belongs to the line number *j*; -  *x*1<=&lt;<=*x*'<=&lt;<=*x*2, that is, point (*x*',<=*y*') lies inside the strip bounded by *x*1<=&lt;<=*x*2. 
You can't leave Anton in trouble, can you? Write a program that solves the given task.","The first line of the input contains an integer *n* (2<=≤<=*n*<=≤<=100<=000) — the number of lines in the task given to Anton. The second line contains integers *x*1 and *x*2 (<=-<=1<=000<=000<=≤<=*x*1<=&lt;<=*x*2<=≤<=1<=000<=000) defining the strip inside which you need to find a point of intersection of at least two lines.

The following *n* lines contain integers *k**i*, *b**i* (<=-<=1<=000<=000<=≤<=*k**i*,<=*b**i*<=≤<=1<=000<=000) — the descriptions of the lines. It is guaranteed that all lines are pairwise distinct, that is, for any two *i*<=≠<=*j* it is true that either *k**i*<=≠<=*k**j*, or *b**i*<=≠<=*b**j*.","Print ""Yes"" (without quotes), if there is at least one intersection of two distinct lines, located strictly inside the strip. Otherwise print ""No"" (without quotes).","['4\n1 2\n1 2\n1 0\n0 1\n0 2\n', '2\n1 3\n1 0\n-1 3\n', '2\n1 3\n1 0\n0 2\n', '2\n1 3\n1 0\n0 3\n']","['NO', 'YES', 'YES', 'NO']","In the first sample there are intersections located on the border of the strip, but there are no intersections located strictly inside it.",OK,"n = int(input())
a = list()
x1, x2 = map(int, input().split())
for i in range(n):
    k, b = map(int, input().split())
    y1 = k * x1 + b
    y2 = k * x2 + b
    a.append((y1, y2))
a.sort()
fl = 'NO'
y1m = a[0][0]
y2m = a[0][1]
for y1, y2 in a:
    if y2 < y2m:
        fl = 'YES'
    else:
        y2m = max(y2m, y2)
print(fl)
    
    
    ","from collections import Counter, defaultdict

c = Counter()
silbid = defaultdict(list)

len_words = int(input())
for _ in range(len_words):
    substring = input().strip()
    c[substring] += 1
    silbid[substring[:2]].append(substring[2])
    silbid[substring[1:]].append(substring[0])

# Determine the starting point for reconstruction
starts = []
for key, val in silbid.items():
    if len(val) == 1:  # Only one valid continuation
        starts.append(key[0])
    elif len(val) > 1:  # Ambiguity detected
        starts.append(key[0])

# Remove duplicates and validate starts
starts = list(set(starts))
if len(starts) != 1:
    print(""NO"")
else:
    # Reconstruct the string
    password = starts[0]
    current = password

    while True:
        next_chars = silbid[current[1:]]  # Get next characters based on the last two chars
        if not next_chars:  # No continuation possible
            break
        current = current[1] + next_chars[0]  # Append the next character

    # Check if all substrings can be formed from the reconstructed password
    reconstructed_c = Counter()
    for i in range(len(password) - 2):
        reconstructed_c[password[i:i + 3]] += 1

    if reconstructed_c == c:
        print(""YES"")
        print(password)
    else:
        print(""NO"")"
131,A,cAPS lOCK,PROGRAMMING,"['implementation', 'strings']","wHAT DO WE NEED cAPS LOCK FOR?

Caps lock is a computer keyboard key. Pressing it sets an input mode in which typed letters are capital by default. If it is pressed by accident, it leads to accidents like the one we had in the first passage. 

Let's consider that a word has been typed with the Caps lock key accidentally switched on, if: 
 -  either it only contains uppercase letters; -  or all letters except for the first one are uppercase. 
In this case we should automatically change the case of all letters. For example, the case of the letters that form words ""hELLO"", ""HTTP"", ""z"" should be changed.

Write a program that applies the rule mentioned above. If the rule cannot be applied, the program should leave the word unchanged.","The first line of the input data contains a word consisting of uppercase and lowercase Latin letters. The word's length is from 1 to 100 characters, inclusive.",Print the result of the given word's processing.,"['cAPS\n', 'Lock\n']","['Caps', 'Lock\n']",none,WRONG_ANSWER,"s = input()
if s[0] >= 'a' and s[1] < 'a':
    print(s[0].upper(), end='')
    for i in range(1, len(s)):
        print(s[i].lower(), end='')
elif s[0] < 'a' and s[1] < 'a':
    print(s.lower())
else:
    print(s)
","def mp(): return map(int, input().split())
def it(): return int(input())

a, b, x = mp()
s = ''

# Determine the number of blocks of alternating characters needed
num_blocks = (x + 1) // 2

# Construct the string with alternating characters
for i in range(num_blocks):
    if a > 0:
        s += '0'
        a -= 1
    if b > 0:
        s += '1'
        b -= 1

# If we need to fill more characters
while a > 0 or b > 0:
    # Fill the last character to maintain the required pattern
    if s[-1] == '0' and b > 0:
        s += '1'
        b -= 1
    elif s[-1] == '1' and a > 0:
        s += '0'
        a -= 1

# Add any remaining characters of the type we are finishing with
if a > 0:
    s += '0' * a
if b > 0:
    s += '1' * b

print(s)"
628,B,New Skateboard,PROGRAMMING,['dp'],"Max wants to buy a new skateboard. He has calculated the amount of money that is needed to buy a new skateboard. He left a calculator on the floor and went to ask some money from his parents. Meanwhile his little brother Yusuf came and started to press the keys randomly. Unfortunately Max has forgotten the number which he had calculated. The only thing he knows is that the number is divisible by 4.

You are given a string *s* consisting of digits (the number on the display of the calculator after Yusuf randomly pressed the keys). Your task is to find the number of substrings which are divisible by 4. A substring can start with a zero.

A substring of a string is a nonempty sequence of consecutive characters.

For example if string *s* is 124 then we have four substrings that are divisible by 4: 12, 4, 24 and 124. For the string 04 the answer is three: 0, 4, 04.

As input/output can reach huge size it is recommended to use fast input/output methods: for example, prefer to use gets/scanf/printf instead of getline/cin/cout in C++, prefer to use BufferedReader/PrintWriter instead of Scanner/System.out in Java.",The only line contains string *s* (1<=≤<=|*s*|<=≤<=3·105). The string *s* contains only digits from 0 to 9.,"Print integer *a* — the number of substrings of the string *s* that are divisible by 4.

Note that the answer can be huge, so you should use 64-bit integer type to store it. In C++ you can use the long long integer type and in Java you can use long integer type.","['124\n', '04\n', '5810438174\n']","['4\n', '3\n', '9\n']",none,OK,"s = input()
res = 0

for i in range(1, len(s)) :
    if int(s[i-1 : i+1]) % 4 == 0 :
        res += i

res += s.count('0') + s.count('4') + s.count('8')

print(res)","import math
import random
from collections import Counter, deque
from sys import stdout
import time
from math import factorial, log, gcd
import sys
from decimal import Decimal

# Read input values for number of students (n) and the minimum team participation (k)
n, k = map(int, input().split())
# Read the list of participation counts for each student
y = list(map(int, input().split()))

# Calculate the number of teams that can be formed
participants_needed = 0

# Determine how many more times each student can participate
for i in range(n):
    remaining_participations = 5 - y[i]
    # If the student can participate more times, count how many teams can be formed with this student
    if remaining_participations >= k:
        participants_needed += (remaining_participations // k)

# Each team requires 3 members
max_teams = participants_needed // 3

# Output the maximum number of teams
print(max_teams)"
59,A,Word,PROGRAMMING,"['implementation', 'strings']","Vasya is very upset that many people on the Net mix uppercase and lowercase letters in one word. That's why he decided to invent an extension for his favorite browser that would change the letters' register in every word so that it either only consisted of lowercase letters or, vice versa, only of uppercase ones. At that as little as possible letters should be changed in the word. For example, the word HoUse must be replaced with house, and the word ViP — with VIP. If a word contains an equal number of uppercase and lowercase letters, you should replace all the letters with lowercase ones. For example, maTRIx should be replaced by matrix. Your task is to use the given method on one given word.",The first line contains a word *s* — it consists of uppercase and lowercase Latin letters and possesses the length from 1 to 100.,"Print the corrected word *s*. If the given word *s* has strictly more uppercase letters, make the word written in the uppercase register, otherwise - in the lowercase one.","['HoUse\n', 'ViP\n', 'maTRIx\n']","['house\n', 'VIP\n', 'matrix\n']",none,OK,"k=input()
count=0
for i in k:
    if(i.isupper()):
        count+=1
if(count>(len(k)//2)):
    print(k.upper())
else:
    print(k.lower())
","from operator import itemgetter

n, money = list(map(int, input().split()))
costs = list(map(int, input().split()))

def check(k):
    total = 0
    for j in range(k):
        total += costs[j] + (j + 1) * k  # Calculate the adjusted cost
    return total

max_souvenirs = 0
min_cost = 0

for k in range(1, n + 1):
    current_cost = check(k)
    if current_cost <= money:
        max_souvenirs = k
        min_cost = current_cost  # Update min_cost to the total cost when k is valid
    else:
        break  # If the cost exceeds the budget, no need to check further

print(max_souvenirs, min_cost)"
702,A,Maximum Increase,PROGRAMMING,"['dp', 'greedy', 'implementation']","You are given array consisting of *n* integers. Your task is to find the maximum length of an increasing subarray of the given array.

A subarray is the sequence of consecutive elements of the array. Subarray is called increasing if each element of this subarray strictly greater than previous.","The first line contains single positive integer *n* (1<=≤<=*n*<=≤<=105) — the number of integers.

The second line contains *n* positive integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=109).",Print the maximum length of an increasing subarray of the given array.,"['5\n1 7 2 11 15\n', '6\n100 100 100 100 100 100\n', '3\n1 2 3\n']","['3\n', '1\n', '3\n']",none,OK,"n = int (input())
current = 1
max = 1

x = list(map(int,input().split()))
for i in range(n-1): #   0 1 2 3  4 
    if x[i+1] > x[i]:  # 1 7 2 11 15
        current = current +1
    else:
        current=1

    if max<current:max=current


print (max)","# 6
# 1 5 7 4 4 3
import math

number = int(input())
arr    = list(map(int , input().split()))
info   = {
    ""max"": {
        ""val"": max(arr),
        ""idx"": arr.index(max(arr)) + 1  # 1-based index
    },
    ""min"": {
        ""val"": min(arr),
        ""idx"": arr.index(min(arr)) + 1  # 1-based index
    }
}

# Create pairs
pairs = []
used_indices = set()
for i in range(number // 2):
    # Get the largest available and smallest available
    while info[""max""][""idx""] in used_indices:
        info[""max""][""val""] = max([arr[j] for j in range(number) if j not in used_indices])
        info[""max""][""idx""] = arr.index(info[""max""][""val""]) + 1
    
    while info[""min""][""idx""] in used_indices:
        info[""min""][""val""] = min([arr[j] for j in range(number) if j not in used_indices])
        info[""min""][""idx""] = arr.index(info[""min""][""val""]) + 1
    
    # Append the pair
    pairs.append((info[""max""][""idx""], info[""min""][""idx""]))
    
    # Mark these indices as used
    used_indices.add(info[""max""][""idx""])
    used_indices.add(info[""min""][""idx""])

# Print the result
for pair in pairs:
    print(pair[0], pair[1])"
892,B,Wrath,PROGRAMMING,"['greedy', 'implementation', 'two pointers']","Hands that shed innocent blood!

There are *n* guilty people in a line, the *i*-th of them holds a claw with length *L**i*. The bell rings and every person kills some of people in front of him. All people kill others at the same time. Namely, the *i*-th person kills the *j*-th person if and only if *j*<=&lt;<=*i* and *j*<=≥<=*i*<=-<=*L**i*.

You are given lengths of the claws. You need to find the total number of alive people after the bell rings.","The first line contains one integer *n* (1<=≤<=*n*<=≤<=106) — the number of guilty people.

Second line contains *n* space-separated integers *L*1,<=*L*2,<=...,<=*L**n* (0<=≤<=*L**i*<=≤<=109), where *L**i* is the length of the *i*-th person's claw.",Print one integer — the total number of alive people after the bell rings.,"['4\n0 1 0 10\n', '2\n0 0\n', '10\n1 1 3 0 0 0 2 1 0 3\n']","['1\n', '2\n', '3\n']",In first sample the last person kills everyone in front of him.,WRONG_ANSWER,"n = int(input())
s = list(map(int,input().split()))
died = []
live = n
if sum(s) == n * s[0]:
	print(1)
else:
	for i in range(n - 1, 0, -1):
		for j in range(i):
			if i > j and i - s[i] <= j and j not in died:
				died.append(j)
	print(n - len(died))	
","n, k = map(int, input().split())

def check(mid):
    if mid == 0:
        return 1
    if mid == 1:
        return 1
    count = 0
    for i in range(2, k + 1):
        count += (mid + i - 1) // i  # count how many spark pipes are needed to reach mid
        if count >= n:  # if we have enough
            return 1
    return 0

l, r = 0, n  # binary search bounds
while l < r:
    mid = (l + r) // 2
    if check(mid):
        r = mid  # search in the left part
    else:
        l = mid + 1  # search in the right part

# subtract 1 because we start with one pipe already flowing
result = l if l <= n else -1
print(result if result != -1 else -1)"
152,C,Pocket Book,PROGRAMMING,['combinatorics'],"One day little Vasya found mom's pocket book. The book had *n* names of her friends and unusually enough, each name was exactly *m* letters long. Let's number the names from 1 to *n* in the order in which they are written.

As mom wasn't home, Vasya decided to play with names: he chose three integers *i*, *j*, *k* (1<=≤<=*i*<=&lt;<=*j*<=≤<=*n*, 1<=≤<=*k*<=≤<=*m*), then he took names number *i* and *j* and swapped their prefixes of length *k*. For example, if we take names ""CBDAD"" and ""AABRD"" and swap their prefixes with the length of 3, the result will be names ""AABAD"" and ""CBDRD"".

You wonder how many different names Vasya can write instead of name number 1, if Vasya is allowed to perform any number of the described actions. As Vasya performs each action, he chooses numbers *i*, *j*, *k* independently from the previous moves and his choice is based entirely on his will. The sought number can be very large, so you should only find it modulo 1000000007 (109<=+<=7).","The first input line contains two integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=100) — the number of names and the length of each name, correspondingly. Then *n* lines contain names, each name consists of exactly *m* uppercase Latin letters.",Print the single number — the number of different names that could end up in position number 1 in the pocket book after the applying the procedures described above. Print the number modulo 1000000007 (109<=+<=7).,"['2 3\nAAB\nBAA\n', '4 5\nABABA\nBCGDG\nAAAAA\nYABSA\n']","['4\n', '216\n']","In the first sample Vasya can get the following names in the position number 1: ""AAB"", ""AAA"", ""BAA"" and ""BAB"".",OK,"if __name__ == ""__main__"":
    modulo=10**9+7
    n,m=map(int,input().split())
    names=[]

    for i in range(n):
        names.append(input().strip())
    
    res=1
    for j in range(m):
        unique_col_char_count=0
        tmp_arr=[]
        for i in range(n):
            if names[i][j] not in tmp_arr:
                unique_col_char_count+=1
                tmp_arr.append(names[i][j])
        res*=unique_col_char_count
        res=res%(modulo)
    print(res)","def minimum_time_to_complete_chores(n, k, x, a):
    # Sort the chores list (though it is guaranteed to be sorted already).
    a.sort()
    
    # Calculate the total time without using hard work on any chores.
    total_time = sum(a)
    
    # If k is greater than or equal to n, she can do all chores in x time.
    if k >= n:
        return n * x
    
    # Otherwise, consider the most time-consuming chores to replace with x time.
    # We will take the last k chores since they are the largest in the sorted list.
    time_saved = sum(a[-k:]) - k * x  # Time saved by hardworking on k chores
    
    # Calculate the minimum time needed considering the time saved.
    minimum_time = total_time - time_saved
    
    return minimum_time

# Example usage
n, k, x = map(int, input().split())
a = list(map(int, input().split()))
print(minimum_time_to_complete_chores(n, k, x, a))"
749,A,Bachgold Problem,PROGRAMMING,"['greedy', 'implementation', 'math', 'number theory']","Bachgold problem is very easy to formulate. Given a positive integer *n* represent it as a sum of maximum possible number of prime numbers. One can prove that such representation exists for any integer greater than 1.

Recall that integer *k* is called prime if it is greater than 1 and has exactly two positive integer divisors — 1 and *k*.",The only line of the input contains a single integer *n* (2<=≤<=*n*<=≤<=100<=000).,"The first line of the output contains a single integer *k* — maximum possible number of primes in representation.

The second line should contain *k* primes with their sum equal to *n*. You can print them in any order. If there are several optimal solution, print any of them.","['5\n', '6\n']","['2\n2 3\n', '3\n2 2 2\n']",none,OK,"n = int(input())

if n % 2 == 0:
    print(n//2)
    for x in range(n//2):
        print(2,end="" "")
else:
    print(n//2)
    for x in range((n//2) - 1):
        print(2,end="" "")
    print(3)
","from sys import stdin

def main():
    a,b = [int(x) for x in stdin.readline().strip().split()]
    T = True
    
    # Read the flag representation
    flag = [stdin.readline().strip() for _ in range(a)]
    
    # Check each row for uniformity of colors
    for row in flag:
        if len(set(row)) != 1:  # If there are different colors in the row
            T = False
            break
    
    # Check adjacent rows for different colors
    if T:
        for i in range(1, a):
            if flag[i][0] == flag[i-1][0]:  # If this row has the same color as the previous
                T = False
                break
    
    # Output the result based on the checks
    print(""YES"" if T else ""NO"")

# Call the main function to execute the program
main()"
0,none,none,none,['none'],"A substring of some string is called the most frequent, if the number of its occurrences is not less than number of occurrences of any other substring.

You are given a set of strings. A string (not necessarily from this set) is called good if all elements of the set are the most frequent substrings of this string. Restore the non-empty good string with minimum length. If several such strings exist, restore lexicographically minimum string. If there are no good strings, print ""NO"" (without quotes).

A substring of a string is a contiguous subsequence of letters in the string. For example, ""ab"", ""c"", ""abc"" are substrings of string ""abc"", while ""ac"" is not a substring of that string.

The number of occurrences of a substring in a string is the number of starting positions in the string where the substring occurs. These occurrences could overlap.

String *a* is lexicographically smaller than string *b*, if *a* is a prefix of *b*, or *a* has a smaller letter at the first position where *a* and *b* differ.","The first line contains integer *n* (1<=≤<=*n*<=≤<=105) — the number of strings in the set.

Each of the next *n* lines contains a non-empty string consisting of lowercase English letters. It is guaranteed that the strings are distinct.

The total length of the strings doesn't exceed 105.","Print the non-empty good string with minimum length. If several good strings exist, print lexicographically minimum among them. Print ""NO"" (without quotes) if there are no good strings.","['4\nmail\nai\nlru\ncf\n', '3\nkek\npreceq\ncheburek\n']","['cfmailru\n', 'NO\n']","One can show that in the first sample only two good strings with minimum length exist: ""cfmailru"" and ""mailrucf"". The first string is lexicographically minimum.",WRONG_ANSWER,"n = int(input())
s = []

for _ in range(n):
    s.append(input())
    if len(set(s[-1])) != len(s[-1]):
        print(""NO"")
        exit(0)

m = []
for i in range(len(s)):
    c = s[i]
    for j in range(len(m)):
        if len(set(s[i]) & set(m[j])) != 0:
            merged = False
            for k in range(1, min(len(s[i]), len(m[j]))):
                if s[i][:k] == m[j][len(m[j])-k:]:
                    c = m[j]+s[i][k:]
                    m.pop(j)
                    merged = True
                    break
                if s[i][len(s[i])-k:] == m[j][:k]:
                    c = s[i]+m[j][k:]
                    m.pop(j)
                    merged = True
                    break

            if merged == False:
                if m[j].find(s[i]):
                    c = m[j]
                    m.pop(j)
                    merged = True
                elif s[i].find(m[j]):
                    c = s[i]
                    m.pop(j)
                    merged = True

            if merged == False:
                print(""NO"")
                exit(0)
            else:
                break
    
    m.append(c)

m.sort()
fs = ''.join(m)
if len(set(fs)) != len(fs):
    print(""NO"")
else:
    print(fs)
","p = [[0]*10 for _ in range(100005)]
b = [0]*100005
v = [0]*100005
c = [0]*100005
t = [0]*100005

def A(x):
    if c[x]:
        return  # already activated
    # Add prime factors of `x` to `p`
    num = x
    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            while num % i == 0:
                num //= i
                if i not in p[x]:
                    p[x].append(i)
    if num > 1:
        p[x].append(num)

def activate(i):
    if c[i]:  # Already on
        return ""Already on""
    
    # Check for conflicts
    for j in range(1, len(c)):
        if c[j] and gcd(i, j) != 1:
            return f""Conflict with {j}""
    
    # No conflicts, activate
    c[i] = 1
    A(i)  # Update prime factors
    return ""Success""

def deactivate(i):
    if not c[i]:  # Already off
        return ""Already off""
    
    # Deactivate collider
    c[i] = 0
    return ""Success""

def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

n, m = map(int, input().split())
results = []
for _ in range(m):
    operation = input().strip()
    if operation[0] == '+':
        i = int(operation[2:])
        results.append(activate(i))
    else:
        i = int(operation[2:])
        results.append(deactivate(i))

# Print the results
for result in results:
    print(result)"
387,B,George and Round,PROGRAMMING,"['brute force', 'greedy', 'two pointers']","George decided to prepare a Codesecrof round, so he has prepared *m* problems for the round. Let's number the problems with integers 1 through *m*. George estimates the *i*-th problem's complexity by integer *b**i*.

To make the round good, he needs to put at least *n* problems there. Besides, he needs to have at least one problem with complexity exactly *a*1, at least one with complexity exactly *a*2, ..., and at least one with complexity exactly *a**n*. Of course, the round can also have problems with other complexities.

George has a poor imagination. It's easier for him to make some already prepared problem simpler than to come up with a new one and prepare it. George is magnificent at simplifying problems. He can simplify any already prepared problem with complexity *c* to any positive integer complexity *d* (*c*<=≥<=*d*), by changing limits on the input data.

However, nothing is so simple. George understood that even if he simplifies some problems, he can run out of problems for a good round. That's why he decided to find out the minimum number of problems he needs to come up with in addition to the *m* he's prepared in order to make a good round. Note that George can come up with a new problem of any complexity.","The first line contains two integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=3000) — the minimal number of problems in a good round and the number of problems George's prepared. The second line contains space-separated integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a*1<=&lt;<=*a*2<=&lt;<=...<=&lt;<=*a**n*<=≤<=106) — the requirements for the complexity of the problems in a good round. The third line contains space-separated integers *b*1,<=*b*2,<=...,<=*b**m* (1<=≤<=*b*1<=≤<=*b*2...<=≤<=*b**m*<=≤<=106) — the complexities of the problems prepared by George.",Print a single integer — the answer to the problem.,"['3 5\n1 2 3\n1 2 2 3 3\n', '3 5\n1 2 3\n1 1 1 1 1\n', '3 1\n2 3 4\n1\n']","['0\n', '2\n', '3\n']","In the first sample the set of the prepared problems meets the requirements for a good round.

In the second sample, it is enough to come up with and prepare two problems with complexities 2 and 3 to get a good round.

In the third sample it is very easy to get a good round if come up with and prepare extra problems with complexities: 2, 3, 4.",TIME_LIMIT_EXCEEDED,"n,m=map(int,input().split())
a=list(map(int,input().split()))
b=list(map(int,input().split()))
count=0
l=len(b)
count1=n
for i in range(n):
    if l==0:
        count+=n-i
        break
    j=0
    while j<l:
        if a[i]<=b[j]:
            del b[j]
            l-=1
            break
        elif j==l-1:
            count+=1
        j+=1
print(count)","# ip = open(""testdata.txt"", ""r"")

# def input():
#     return ip.readline().strip()

from collections import Counter

n = int(input())
array = list(map(int, input().split()))

# Use a Counter to count the occurrences of each number in the array
counter = Counter(array)

# If there's only one unique number, we can make all elements equal
if len(counter) == 1:
    print(""YES"")
else:
    # Get the unique numbers sorted
    unique_numbers = sorted(counter.keys())
    
    # If there are exactly two unique numbers, we can always make them equal
    if len(unique_numbers) == 2:
        print(""YES"")
    # If there are three unique numbers, we can make them equal only if they form an arithmetic progression
    elif len(unique_numbers) == 3:
        if unique_numbers[2] - unique_numbers[1] == unique_numbers[1] - unique_numbers[0]:
            print(""YES"")
        else:
            print(""NO"")
    else:
        print(""NO"")"
837,A,Text Volume,PROGRAMMING,['implementation'],"You are given a text of single-space separated words, consisting of small and capital Latin letters.

Volume of the word is number of capital letters in the word. Volume of the text is maximum volume of all words in the text.

Calculate the volume of the given text.","The first line contains one integer number *n* (1<=≤<=*n*<=≤<=200) — length of the text.

The second line contains text of single-space separated words *s*1,<=*s*2,<=...,<=*s**i*, consisting only of small and capital Latin letters.",Print one integer number — volume of text.,"['7\nNonZERO\n', '24\nthis is zero answer text\n', '24\nHarbour Space University\n']","['5\n', '0\n', '1\n']","In the first example there is only one word, there are 5 capital letters in it.

In the second example all of the words contain 0 capital letters.",WRONG_ANSWER,"n= int(input())
string = input()
count=0
for i in range(len(string)):
    if string[i].isupper()== True:
        count=count+1
    if string[i]=="" "":
        count=0
print(count)","n = int(input())
l = []

for _ in range(n):
    a, b = map(int, input().split())
    l.append((a, b))

# Sort laptops by price
l.sort()

# Check for the condition where a more expensive laptop has lower quality
for i in range(1, n):
    if l[i][1] < l[i - 1][1]:  # comparing quality
        print(""Happy Alex"")
        break
else:
    print(""Poor Alex"")"
928,A,Login Verification,PROGRAMMING,"['*special', 'strings']","When registering in a social network, users are allowed to create their own convenient login to make it easier to share contacts, print it on business cards, etc.

Login is an arbitrary sequence of lower and uppercase latin letters, digits and underline symbols («_»). However, in order to decrease the number of frauds and user-inattention related issues, it is prohibited to register a login if it is similar with an already existing login. More precisely, two logins *s* and *t* are considered similar if we can transform *s* to *t* via a sequence of operations of the following types: 
 -  transform lowercase letters to uppercase and vice versa; -  change letter «O» (uppercase latin letter) to digit «0» and vice versa; -  change digit «1» (one) to any letter among «l» (lowercase latin «L»), «I» (uppercase latin «i») and vice versa, or change one of these letters to other. 
For example, logins «Codeforces» and «codef0rces» as well as «OO0OOO00O0OOO0O00OOO0OO_lol» and «OO0OOO0O00OOO0O00OO0OOO_1oI» are considered similar whereas «Codeforces» and «Code_forces» are not.

You're given a list of existing logins with no two similar amonst and a newly created user login. Check whether this new login is similar with any of the existing ones.","The first line contains a non-empty string *s* consisting of lower and uppercase latin letters, digits and underline symbols («_») with length not exceeding 50  — the login itself.

The second line contains a single integer *n* (1<=≤<=*n*<=≤<=1<=000) — the number of existing logins.

The next *n* lines describe the existing logins, following the same constraints as the user login (refer to the first line of the input). It's guaranteed that no two existing logins are similar.","Print «Yes» (without quotes), if user can register via this login, i.e. none of the existing logins is similar with it.

Otherwise print «No» (without quotes).","['1_wat\n2\n2_wat\nwat_1\n', '000\n3\n00\nooA\noOo\n', '_i_\n3\n__i_\n_1_\nI\n', 'La0\n3\n2a0\nLa1\n1a0\n', 'abc\n1\naBc\n', '0Lil\n2\nLIL0\n0Ril\n']","['Yes\n', 'No\n', 'No\n', 'No\n', 'No\n', 'Yes\n']","In the second sample case the user wants to create a login consisting of three zeros. It's impossible due to collision with the third among the existing.

In the third sample case the new login is similar with the second one.",OK,"s=input()
s=s.upper()
s=s.replace('O','0')
s=s.replace('L','1')
s=s.replace('I','1')
f=1
for i in range(int(input())):
	s1=input()
	s1=s1.upper()
	s1=s1.replace('O','0')
	s1=s1.replace('L','1')
	s1=s1.replace('I','1')
	if(s==s1):
		f=0
if(f):
	print(""Yes"")
else:
	print(""No"")","n, p, q = map(int, input().split())
s = input()

def problem6(n, p, q, s):
    # Initialize list to hold the parts of the split string
    parts = []
    
    # Try to form the string using lengths p and q
    for i in range(n // p + 1):  # Number of pieces of length p
        remaining_length = n - (i * p)  # Remaining length after taking i pieces of p
        if remaining_length % q == 0:  # Check if the remaining can be fully divided by q
            j = remaining_length // q  # Number of pieces of length q
            # Add pieces of length p
            for _ in range(i):
                parts.append(s[:p])
                s = s[p:]  # Move the string forward
            # Add pieces of length q
            for _ in range(j):
                parts.append(s[:q])
                s = s[q:]  # Move the string forward
            return parts  # Return the list of parts
    
    # If no partition is found, return -1
    return -1

# Get the result of partitioning
result = problem6(n, p, q, s)

if result == -1:
    print(-1)
else:
    print(len(result))  # Print the number of parts
    for part in result:  # Print each part
        print(part)"
222,B,Cosmic Tables,PROGRAMMING,"['data structures', 'implementation']","The Free Meteor Association (FMA) has got a problem: as meteors are moving, the Universal Cosmic Descriptive Humorous Program (UCDHP) needs to add a special module that would analyze this movement. 

UCDHP stores some secret information about meteors as an *n*<=×<=*m* table with integers in its cells. The order of meteors in the Universe is changing. That's why the main UCDHP module receives the following queries:
 -  The query to swap two table rows; -  The query to swap two table columns; -  The query to obtain a secret number in a particular table cell. 
As the main UCDHP module is critical, writing the functional of working with the table has been commissioned to you.","The first line contains three space-separated integers *n*, *m* and *k* (1<=≤<=*n*,<=*m*<=≤<=1000, 1<=≤<=*k*<=≤<=500000) — the number of table columns and rows and the number of queries, correspondingly.

Next *n* lines contain *m* space-separated numbers each — the initial state of the table. Each number *p* in the table is an integer and satisfies the inequality 0<=≤<=*p*<=≤<=106.

Next *k* lines contain queries in the format ""*s**i* *x**i* *y**i*"", where *s**i* is one of the characters ""с"", ""r"" or ""g"", and *x**i*, *y**i* are two integers.
 -  If *s**i* = ""c"", then the current query is the query to swap columns with indexes *x**i* and *y**i* (1<=≤<=*x*,<=*y*<=≤<=*m*,<=*x*<=≠<=*y*); -  If *s**i* = ""r"", then the current query is the query to swap rows with indexes *x**i* and *y**i* (1<=≤<=*x*,<=*y*<=≤<=*n*,<=*x*<=≠<=*y*); -  If *s**i* = ""g"", then the current query is the query to obtain the number that located in the *x**i*-th row and in the *y**i*-th column (1<=≤<=*x*<=≤<=*n*,<=1<=≤<=*y*<=≤<=*m*). 
The table rows are considered to be indexed from top to bottom from 1 to *n*, and the table columns — from left to right from 1 to *m*.","For each query to obtain a number (*s**i* = ""g"") print the required number. Print the answers to the queries in the order of the queries in the input.","['3 3 5\n1 2 3\n4 5 6\n7 8 9\ng 3 2\nr 3 2\nc 2 3\ng 2 2\ng 3 2\n', '2 3 3\n1 2 4\n3 1 5\nc 2 1\nr 1 2\ng 1 3\n']","['8\n9\n6\n', '5\n']","Let's see how the table changes in the second test case.

After the first operation is fulfilled, the table looks like that:

2 1 4

1 3 5

After the second operation is fulfilled, the table looks like that:

1 3 5

2 1 4

So the answer to the third query (the number located in the first row and in the third column) will be 5.",COMPILATION_ERROR,"#include <iostream>
#include <vector>
#include <set>
#include <algorithm>
#include <map>
#include <queue>
#include <string>

using namespace std;
int arr[1005][1005];
int main(){
	int n, m;
	cin>>n>>m;
	for(int i=0;i<m;i++){
		int x, y;
		cin>>x>>y;
		for(int j=x;j<x+3;j++){
			for(int k=y;k<y+3;k++){
				arr[j][k]++;
				if(arr[j][k]==9){
					cout<<i+1<<endl;
					return 0;
				}
			}
		}
	}
	cout<<-1<<endl;
}","from math import ceil


class Solution:
    def paving_theatre_square(self, n: int, m: int, a: int) -> int:
        # Calculate the number of flagstones needed along the length (n)
        flagstones_length = ceil(n / a)
        # Calculate the number of flagstones needed along the width (m)
        flagstones_width = ceil(m / a)
        # Total number of flagstones is the product of both dimensions
        total_flagstones = flagstones_length * flagstones_width
        return total_flagstones"
799,A,Carrot Cakes,PROGRAMMING,"['brute force', 'implementation']","In some game by Playrix it takes *t* minutes for an oven to bake *k* carrot cakes, all cakes are ready at the same moment *t* minutes after they started baking. Arkady needs at least *n* cakes to complete a task, but he currently don't have any. However, he has infinitely many ingredients and one oven. Moreover, Arkady can build one more similar oven to make the process faster, it would take *d* minutes to build the oven. While the new oven is being built, only old one can bake cakes, after the new oven is built, both ovens bake simultaneously. Arkady can't build more than one oven.

Determine if it is reasonable to build the second oven, i.e. will it decrease the minimum time needed to get *n* cakes or not. If the time needed with the second oven is the same as with one oven, then it is unreasonable.","The only line contains four integers *n*, *t*, *k*, *d* (1<=≤<=*n*,<=*t*,<=*k*,<=*d*<=≤<=1<=000) — the number of cakes needed, the time needed for one oven to bake *k* cakes, the number of cakes baked at the same time, the time needed to build the second oven.","If it is reasonable to build the second oven, print ""YES"". Otherwise print ""NO"".","['8 6 4 5\n', '8 6 4 6\n', '10 3 11 4\n', '4 2 1 4\n']","['YES\n', 'NO\n', 'NO\n', 'YES\n']","In the first example it is possible to get 8 cakes in 12 minutes using one oven. The second oven can be built in 5 minutes, so after 6 minutes the first oven bakes 4 cakes, the second oven bakes 4 more ovens after 11 minutes. Thus, it is reasonable to build the second oven. 

In the second example it doesn't matter whether we build the second oven or not, thus it takes 12 minutes to bake 8 cakes in both cases. Thus, it is unreasonable to build the second oven.

In the third example the first oven bakes 11 cakes in 3 minutes, that is more than needed 10. It is unreasonable to build the second oven, because its building takes more time that baking the needed number of cakes using the only oven.",OK,"n, t, k, d = map(int, input().split())

g = int((n + k - 1) / k)

o1, o2 = 0, d

i = 0
while i < g:
    if o1 <= o2:
        o1 += t
    else:
        o2 += t

    i += 1

if max(o1, o2) < g * t:
    print(""YES"")
else:
    print(""NO"")","def main():
    size = int(input())
    numbers = tuple(map(int, input().split()))
    
    # Dictionary to track the last occurrence of each number
    last_occurrence = {}
    
    # Store the rightmost occurrence for each number
    for index in range(size):
        last_occurrence[numbers[index]] = index
    
    # Create the resultant list in the order of rightmost occurrences
    result = []
    for index in range(size):
        if last_occurrence[numbers[index]] == index:
            result.append(numbers[index])
    
    # Print the size of the resultant list and the list itself
    print(len(result))
    print(' '.join(map(str, result)))

main()"
749,A,Bachgold Problem,PROGRAMMING,"['greedy', 'implementation', 'math', 'number theory']","Bachgold problem is very easy to formulate. Given a positive integer *n* represent it as a sum of maximum possible number of prime numbers. One can prove that such representation exists for any integer greater than 1.

Recall that integer *k* is called prime if it is greater than 1 and has exactly two positive integer divisors — 1 and *k*.",The only line of the input contains a single integer *n* (2<=≤<=*n*<=≤<=100<=000).,"The first line of the output contains a single integer *k* — maximum possible number of primes in representation.

The second line should contain *k* primes with their sum equal to *n*. You can print them in any order. If there are several optimal solution, print any of them.","['5\n', '6\n']","['2\n2 3\n', '3\n2 2 2\n']",none,OK,"n = int(input())

primes_sum = [2] * (n // 2)
if n % 2 == 1:
    primes_sum[-1] = 3

print(len(primes_sum))
print(*primes_sum)
","import sys
import collections 
import bisect
input = sys.stdin.readline 
ip = lambda: input().rstrip('\n')
IP = lambda: list(map(int, ip().split()))

# Read input values
n, m, x, y, z, p = IP()

# Process each candy's original coordinates
candies = [tuple(IP()) for _ in range(p)]

# Normalize the number of rotations
x = x % 4  # Each 4 rotations clockwise return to original position
z = z % 4  # Each 4 rotations counterclockwise return to original position
# The effective clockwise rotations
effective_rotate = (x - z) % 4

# Prepare the output list
new_coordinates = []

for xk, yk in candies:
    if effective_rotate == 0:
        # No rotation
        new_coordinates.append((xk, yk))
    elif effective_rotate == 1:
        # 90 degrees clockwise
        new_coordinates.append((yk, n - xk + 1))
    elif effective_rotate == 2:
        # 180 degrees rotation
        new_coordinates.append((n - xk + 1, m - yk + 1))
    elif effective_rotate == 3:
        # 270 degrees clockwise (or 90 degrees counterclockwise)
        new_coordinates.append((m - yk + 1, xk))

# Apply horizontal rotations
for i in range(y):
    new_coordinates = [(x, n - y + 1) for x, y in new_coordinates]

# Print new coordinates for each candy
for xk, yk in new_coordinates:
    print(xk, yk)"
152,C,Pocket Book,PROGRAMMING,['combinatorics'],"One day little Vasya found mom's pocket book. The book had *n* names of her friends and unusually enough, each name was exactly *m* letters long. Let's number the names from 1 to *n* in the order in which they are written.

As mom wasn't home, Vasya decided to play with names: he chose three integers *i*, *j*, *k* (1<=≤<=*i*<=&lt;<=*j*<=≤<=*n*, 1<=≤<=*k*<=≤<=*m*), then he took names number *i* and *j* and swapped their prefixes of length *k*. For example, if we take names ""CBDAD"" and ""AABRD"" and swap their prefixes with the length of 3, the result will be names ""AABAD"" and ""CBDRD"".

You wonder how many different names Vasya can write instead of name number 1, if Vasya is allowed to perform any number of the described actions. As Vasya performs each action, he chooses numbers *i*, *j*, *k* independently from the previous moves and his choice is based entirely on his will. The sought number can be very large, so you should only find it modulo 1000000007 (109<=+<=7).","The first input line contains two integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=100) — the number of names and the length of each name, correspondingly. Then *n* lines contain names, each name consists of exactly *m* uppercase Latin letters.",Print the single number — the number of different names that could end up in position number 1 in the pocket book after the applying the procedures described above. Print the number modulo 1000000007 (109<=+<=7).,"['2 3\nAAB\nBAA\n', '4 5\nABABA\nBCGDG\nAAAAA\nYABSA\n']","['4\n', '216\n']","In the first sample Vasya can get the following names in the position number 1: ""AAB"", ""AAA"", ""BAA"" and ""BAB"".",WRONG_ANSWER,"import sys
from math import ceil
input = sys.stdin.readline
for ii in range(1):
    a,b=(map(int,input().split()))
    s=[]
    r=1
    g={}
    for o in range(b):
        g[o]=[]
    for i in range(a):
        d=input()
        for x in range(b):
            g[x]+=d[x]

    r=1
    for i in g:
        r*=len(set(g[i]))

            
        

    

            
   
      

            

    sys.stdout.write(str(r)+'\n')
            
            
       
    
    
    
    
        
       



   
","from math import gcd

a, b, n = map(int, input().split())

# Function to determine the winner
def determine_winner(a, b, n):
    turn = 0  # 0 for Simon's turn, 1 for Antisimon's turn
    while n > 0:
        if turn == 0:  # Simon's turn
            stones_to_take = gcd(a, n)
        else:  # Antisimon's turn
            stones_to_take = gcd(b, n)
        
        if n < stones_to_take:  # If not enough stones to take
            return turn  # The current player loses

        n -= stones_to_take  # Subtract stones taken
        turn = 1 - turn  # Switch turn

# Determine the winner and print the result
winner = determine_winner(a, b, n)
print(winner)"
4,A,Watermelon,PROGRAMMING,"['brute force', 'math']","One hot summer day Pete and his friend Billy decided to buy a watermelon. They chose the biggest and the ripest one, in their opinion. After that the watermelon was weighed, and the scales showed *w* kilos. They rushed home, dying of thirst, and decided to divide the berry, however they faced a hard problem.

Pete and Billy are great fans of even numbers, that's why they want to divide the watermelon in such a way that each of the two parts weighs even number of kilos, at the same time it is not obligatory that the parts are equal. The boys are extremely tired and want to start their meal as soon as possible, that's why you should help them and find out, if they can divide the watermelon in the way they want. For sure, each of them should get a part of positive weight.",The first (and the only) input line contains integer number *w* (1<=≤<=*w*<=≤<=100) — the weight of the watermelon bought by the boys.,"Print YES, if the boys can divide the watermelon into two parts, each of them weighing even number of kilos; and NO in the opposite case.",['8\n'],['YES\n'],"For example, the boys can divide the watermelon into two parts of 2 and 6 kilos respectively (another variant — two parts of 4 and 4 kilos).",WRONG_ANSWER,"W = range(1, 101)
W = int(input(""Please input the weight of the watermelon: ""))
if W % 2 == 0:
    print(""Yes."")
else:
    print(""No."")

","def main():
    x = int(input())
    a = list(map(int, input().split("" "")))

    total_angle = sum(a)  # Total angle of the pizza
    min_difference = total_angle  # Initialize to maximum possible difference

    # Calculate the prefix sums of angles
    prefix_sum = [0] * (x + 1)
    for i in range(1, x + 1):
        prefix_sum[i] = prefix_sum[i - 1] + a[i - 1]

    # Iterate through possible splits
    for i in range(x):
        # Sector taken by Vasya (from piece 0 to i)
        vasya_angle = prefix_sum[i + 1]
        # Sector taken by Petya (from piece i+1 to x-1 and then wrap around)
        petya_angle = total_angle - vasya_angle
        # Calculate the difference
        difference = abs(vasya_angle - petya_angle)
        min_difference = min(min_difference, difference)

    print(min_difference)

if __name__ == ""__main__"":
    main()"
948,A,Protect Sheep,PROGRAMMING,"['brute force', 'dfs and similar', 'graphs', 'implementation']","Bob is a farmer. He has a large pasture with many sheep. Recently, he has lost some of them due to wolf attacks. He thus decided to place some shepherd dogs in such a way that all his sheep are protected.

The pasture is a rectangle consisting of *R*<=×<=*C* cells. Each cell is either empty, contains a sheep, a wolf or a dog. Sheep and dogs always stay in place, but wolves can roam freely around the pasture, by repeatedly moving to the left, right, up or down to a neighboring cell. When a wolf enters a cell with a sheep, it consumes it. However, no wolf can enter a cell with a dog.

Initially there are no dogs. Place dogs onto the pasture in such a way that no wolf can reach any sheep, or determine that it is impossible. Note that since you have many dogs, you do not need to minimize their number.","First line contains two integers *R* (1<=≤<=*R*<=≤<=500) and *C* (1<=≤<=*C*<=≤<=500), denoting the number of rows and the numbers of columns respectively.

Each of the following *R* lines is a string consisting of exactly *C* characters, representing one row of the pasture. Here, 'S' means a sheep, 'W' a wolf and '.' an empty cell.","If it is impossible to protect all sheep, output a single line with the word ""No"".

Otherwise, output a line with the word ""Yes"". Then print *R* lines, representing the pasture after placing dogs. Again, 'S' means a sheep, 'W' a wolf, 'D' is a dog and '.' an empty space. You are not allowed to move, remove or add a sheep or a wolf.

If there are multiple solutions, you may print any of them. You don't have to minimize the number of dogs.","['6 6\n..S...\n..S.W.\n.S....\n..W...\n...W..\n......\n', '1 2\nSW\n', '5 5\n.S...\n...S.\nS....\n...S.\n.S...\n']","['Yes\n..SD..\n..SDW.\n.SD...\n.DW...\nDD.W..\n......\n', 'No\n', 'Yes\n.S...\n...S.\nS.D..\n...S.\n.S...\n']","In the first example, we can split the pasture into two halves, one containing wolves and one containing sheep. Note that the sheep at (2,1) is safe, as wolves cannot move diagonally.

In the second example, there are no empty spots to put dogs that would guard the lone sheep.

In the third example, there are no wolves, so the task is very easy. We put a dog in the center to observe the peacefulness of the meadow, but the solution would be correct even without him.",WRONG_ANSWER,"R, C = list(map(int, input().split()))
grid = []
for _ in range(R):
    li = list(input())
    grid.append(li)
visited = [[0 for _ in range(C)] for _ in range(R)]

directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]

def isBound(r, c):
    return 0 <= r < R and 0 <= c < C

def search(r, c):
    visited[r][c] = 1
    for dr in directions:
        new_row = r + dr[0]
        new_col = c + dr[1]
        if isBound(new_row, new_col):
            if grid[new_row][new_col] == 'W':
                return False
            if grid[new_row][new_col] == '.':
                grid[new_row][new_col] = 'D'
    return True

for i in range(R):
    found = False
    for j in range(C):
      if grid[i][j] == 'S':
        if not search(i, j):
            found = True
            print(""NO"")
    if found:
        break

if not found:
    print(""YES"")
    for li in grid:
      print(''.join(li))
","import math
from collections import Counter

def main():
    a = list(map(int, input().split()))
    if len(a) == len(set(a)):
        print(sum(a))
        return
    
    count = Counter(a)
    min_sum = sum(a)
    
    for num, freq in count.items():
        if freq >= 2:
            # Consider removing two cards
            min_sum = min(min_sum, sum(a) - 2 * num)
        if freq >= 3:
            # Consider removing three cards
            min_sum = min(min_sum, sum(a) - 3 * num)

    print(min_sum)

main()"
909,A,Generate Login,PROGRAMMING,"['brute force', 'greedy', 'sortings']","The preferred way to generate user login in Polygon is to concatenate a prefix of the user's first name and a prefix of their last name, in that order. Each prefix must be non-empty, and any of the prefixes can be the full name. Typically there are multiple possible logins for each person.

You are given the first and the last name of a user. Return the alphabetically earliest login they can get (regardless of other potential Polygon users).

As a reminder, a prefix of a string *s* is its substring which occurs at the beginning of *s*: ""a"", ""ab"", ""abc"" etc. are prefixes of string ""{abcdef}"" but ""b"" and 'bc"" are not. A string *a* is alphabetically earlier than a string *b*, if *a* is a prefix of *b*, or *a* and *b* coincide up to some position, and then *a* has a letter that is alphabetically earlier than the corresponding letter in *b*: ""a"" and ""ab"" are alphabetically earlier than ""ac"" but ""b"" and ""ba"" are alphabetically later than ""ac"".","The input consists of a single line containing two space-separated strings: the first and the last names. Each character of each string is a lowercase English letter. The length of each string is between 1 and 10, inclusive.",Output a single string — alphabetically earliest possible login formed from these names. The output should be given in lowercase as well.,"['harry potter\n', 'tom riddle\n']","['hap\n', 'tomr\n']",none,OK,"def getprfx(s):
	tab = [s[0]]
	for i in range(1, len(s)):
		x = tab[i-1] + s[i]
		tab.append(x)
	return tab
	
n, m = input().split()

a, b = getprfx(n), getprfx(m)
mn = a[0] + b[0]
for i in a:
	for j in b:
		if i+j < mn:
			mn = i+j
print(mn)			","n = 4
vois = 1

def nb_same_square(mat, x, y):
    nb_sign1 = 0
    nb_sign2 = 0

    # Count the number of white and black cells in the 2x2 square
    for dx in range(vois + 1):
        for dy in range(vois + 1):
            if mat[x + dx][y + dy] == '#':
                nb_sign1 += 1
            else:
                nb_sign2 += 1
    
    return nb_sign1, nb_sign2

def can_pass_test(mat):
    # Check if any 2x2 square is already valid
    for i in range(n - 1):
        for j in range(n - 1):
            nb_black, nb_white = nb_same_square(mat, i, j)
            if nb_black == 4 or nb_white == 4:
                return ""YES""
    
    # Check if repainting one cell can create a valid 2x2 square
    for i in range(n):
        for j in range(n):
            original_color = mat[i][j]
            # Repaint the cell
            mat[i][j] = '#' if original_color == '.' else '.'
            
            for x in range(n - 1):
                for y in range(n - 1):
                    nb_black, nb_white = nb_same_square(mat, x, y)
                    if nb_black == 4 or nb_white == 4:
                        return ""YES""
            
            # Revert the cell back to original color
            mat[i][j] = original_color
            
    return ""NO""

# Input reading
matrix = []
for i in range(n):
    line = input().strip()
    matrix.append(line)

# Output the result
print(can_pass_test(matrix))"
9,A,Die Roll,PROGRAMMING,"['math', 'probabilities']","Yakko, Wakko and Dot, world-famous animaniacs, decided to rest from acting in cartoons, and take a leave to travel a bit. Yakko dreamt to go to Pennsylvania, his Motherland and the Motherland of his ancestors. Wakko thought about Tasmania, its beaches, sun and sea. Dot chose Transylvania as the most mysterious and unpredictable place.

But to their great regret, the leave turned to be very short, so it will be enough to visit one of the three above named places. That's why Yakko, as the cleverest, came up with a truly genius idea: let each of the three roll an ordinary six-sided die, and the one with the highest amount of points will be the winner, and will take the other two to the place of his/her dreams.

Yakko thrown a die and got Y points, Wakko — W points. It was Dot's turn. But she didn't hurry. Dot wanted to know for sure what were her chances to visit Transylvania.

It is known that Yakko and Wakko are true gentlemen, that's why if they have the same amount of points with Dot, they will let Dot win.",The only line of the input file contains two natural numbers Y and W — the results of Yakko's and Wakko's die rolls.,"Output the required probability in the form of irreducible fraction in format «A/B», where A — the numerator, and B — the denominator. If the required probability equals to zero, output «0/1». If the required probability equals to 1, output «1/1».",['4 2\n'],['1/2\n'],"Dot will go to Transylvania, if she is lucky to roll 4, 5 or 6 points.",RUNTIME_ERROR,"from fractions import Fraction
d=int(input(''))
a=int(input(''))
j=6
if d>=4 or a>=4:
    print ('1/2')
else:
    if d==1 and a==1:
        print('1/1')
    elif d>a:
        print (Fraction(6-d,j))
    elif d<a:
        print( Fraction(6-a,j))
    else:
        print (Fraction(6-a+1,j))
    




","# -*- coding: utf-8 -*-
""""""
Created on Wed Oct 18 16:18:28 2023

@author: masiyu004
""""""
def y(a, b, x):
    # Create a set to keep track of black pixels
    black_pixels = set()
    
    # For each move, add the pixel to the set and check for 2x2 squares
    for move in range(len(x)):
        i, j = x[move]
        black_pixels.add((i, j))
        
        # Check if a 2x2 square can be formed from the current pixel
        for di in range(2):
            for dj in range(2):
                if all((i + di, j + dj) in black_pixels for di in range(2) for dj in range(2)):
                    return move + 1  # Return the move number (1-based indexing)
    
    return 0  # If no 2x2 square was formed after all moves

# Input reading
n, m, k = map(int, input().split())
moves = [tuple(map(int, input().split())) for _ in range(k)]

# Call the function and print the result
result = y(n, m, moves)
print(result)"
995,C,Leaving the Bar,PROGRAMMING,"['brute force', 'data structures', 'geometry', 'greedy', 'math', 'sortings']","For a vector $\vec{v} = (x, y)$, define $|v| = \sqrt{x^2 + y^2}$.

Allen had a bit too much to drink at the bar, which is at the origin. There are $n$ vectors $\vec{v_1}, \vec{v_2}, \cdots, \vec{v_n}$. Allen will make $n$ moves. As Allen's sense of direction is impaired, during the $i$-th move he will either move in the direction $\vec{v_i}$ or $-\vec{v_i}$. In other words, if his position is currently $p = (x, y)$, he will either move to $p + \vec{v_i}$ or $p - \vec{v_i}$.

Allen doesn't want to wander too far from home (which happens to also be the bar). You need to help him figure out a sequence of moves (a sequence of signs for the vectors) such that his final position $p$ satisfies $|p| \le 1.5 \cdot 10^6$ so that he can stay safe.","The first line contains a single integer $n$ ($1 \le n \le 10^5$) — the number of moves.

Each of the following lines contains two space-separated integers $x_i$ and $y_i$, meaning that $\vec{v_i} = (x_i, y_i)$. We have that $|v_i| \le 10^6$ for all $i$.","Output a single line containing $n$ integers $c_1, c_2, \cdots, c_n$, each of which is either $1$ or $-1$. Your solution is correct if the value of $p = \sum_{i = 1}^n c_i \vec{v_i}$, satisfies $|p| \le 1.5 \cdot 10^6$.

It can be shown that a solution always exists under the given constraints.","['3\n999999 0\n0 999999\n999999 0\n', '1\n-824590 246031\n', '8\n-67761 603277\n640586 -396671\n46147 -122580\n569609 -2112\n400 914208\n131792 309779\n-850150 -486293\n5272 721899\n']","['1 1 -1 \n', '1 \n', '1 1 1 1 1 1 1 -1 \n']",none,WRONG_ANSWER,"n = int(input())

res = []
ta, tb = 0, 0
for _ in range(n):
    a, b = [int(x) for x in input().split()]
    ta += a
    tb += b
    res.append((a, b))

def norm(x):
    return x[0] ** 2 + x[1] ** 2

def add(x, y):
    return (x[0] + y[0], x[1] + y[1])
def sub(x, y):
    return (x[0] - y[0], x[1] - y[1])

target = 2.25 * 10 ** 12

ans = [1 for _ in range(n)]

v = (ta, tb)
cur = norm(v)
for i, v2 in enumerate(res):
    v2 = (2*v2[0], 2*v2[1])
    if norm(sub(v, v2)) < cur:
        v = sub(v, v2)
        cur = norm(v)
        ans[i] = -1

print("" "".join(map(str, ans)))
","from sys import stdin

input = stdin.readline

# Initialize a set to keep track of possessed names
possessed_names = set()

# Read the number of names
n = int(input().strip())

# Iterate through each name
for _ in range(n):
    name = input().strip()  # Read the name
    # Check if the name has already been possessed
    if name in possessed_names:
        print(""YES"")  # Output ""YES"" if already possessed
    else:
        print(""NO"")   # Output ""NO"" if not possessed
        possessed_names.add(name)  # Add the name to the set of possessed names"
16,C,Monitor,PROGRAMMING,"['binary search', 'number theory']","Reca company makes monitors, the most popular of their models is AB999 with the screen size *a*<=×<=*b* centimeters. Because of some production peculiarities a screen parameters are integer numbers. Recently the screen sides ratio *x*:<=*y* became popular with users. That's why the company wants to reduce monitor AB999 size so that its screen sides ratio becomes *x*:<=*y*, at the same time they want its total area to be maximal of all possible variants. Your task is to find the screen parameters of the reduced size model, or find out that such a reduction can't be performed.","The first line of the input contains 4 integers — *a*, *b*, *x* and *y* (1<=≤<=*a*,<=*b*,<=*x*,<=*y*<=≤<=2·109).","If the answer exists, output 2 positive integers — screen parameters of the reduced size model. Output 0 0 otherwise.","['800 600 4 3\n', '1920 1200 16 9\n', '1 1 1 2\n']","['800 600\n', '1920 1080\n', '0 0\n']",none,TIME_LIMIT_EXCEEDED,"def inp(s):
    j = 0
    a = []
    for i in range(len(s)):
        if s[i] == "" "":
            a.append(int(s[j:i]))
            j = i+1
        if i == len(s)-1:
            a.append(int(s[j:]))
    return a

s = input()
a = inp(s)
p = 0
q = 0
for i in range(a[0],-1,-1):
    x = (i*a[3])/a[2]
    if x%1 == 0:
        p = i
        break


for j in range(a[1],-1,-1):
    y = (i*a[2])/a[3]
    if y%1 == 0:
        q = j
        break

if x <= a[1] and y<= a[0]:
    if q*y > p*x:
        print (str(int(y))+"" ""+str(q))
    else:
        print (str(p)+"" ""+str(int(x)))
        
elif x <= a[1] and y > a[0]:
    print (str(int(p))+"" ""+str(int(x)))

elif x > a[1] and y <= a[0]:
    print (str(int(y))+"" ""+str(q))
elif x == 0 and y == 0:
    print (""0 0"")
else:
    print (""0 0"")
    ","from sys import stdin,stdout
nmbr = lambda: int(input())
lst = lambda: list(map(int, input().split()))
NI=float('-inf')

def fn(pos, state):
    # Create an array to store the maximum values for p·a[i]
    p_values = [NI] * pos
    for i in range(pos):
        p_values[i] = max(p_values[i-1], p * a[i]) if i > 0 else p * a[i]
    
    # Create an array to store the maximum values for q·a[j]
    q_values = [NI] * pos
    for j in range(pos):
        q_values[j] = max(q_values[j-1], p_values[j] + q * a[j]) if j > 0 else p_values[j] + q * a[j]
        
    # Calculate the maximum value for r·a[k]
    max_value = NI
    for k in range(pos):
        max_value = max(max_value, q_values[k] + r * a[k])
    
    return max_value

# Read input values
n, p, q, r = lst()
a = lst()

# Compute the result
result = fn(n, a)
# Output the result
print(result)"
71,A,Way Too Long Words,PROGRAMMING,['strings'],"Sometimes some words like ""localization"" or ""internationalization"" are so long that writing them many times in one text is quite tiresome.

Let's consider a word too long, if its length is strictly more than 10 characters. All too long words should be replaced with a special abbreviation.

This abbreviation is made like this: we write down the first and the last letter of a word and between them we write the number of letters between the first and the last letters. That number is in decimal system and doesn't contain any leading zeroes.

Thus, ""localization"" will be spelt as ""l10n"", and ""internationalization» will be spelt as ""i18n"".

You are suggested to automatize the process of changing the words with abbreviations. At that all too long words should be replaced by the abbreviation and the words that are not too long should not undergo any changes.",The first line contains an integer *n* (1<=≤<=*n*<=≤<=100). Each of the following *n* lines contains one word. All the words consist of lowercase Latin letters and possess the lengths of from 1 to 100 characters.,Print *n* lines. The *i*-th line should contain the result of replacing of the *i*-th word from the input data.,['4\nword\nlocalization\ninternationalization\npneumonoultramicroscopicsilicovolcanoconiosis\n'],['word\nl10n\ni18n\np43s\n'],none,WRONG_ANSWER,"n = int(input())

w = list()
for i in range(n):
    word = input()
    w.append(word)

for j in range(n):
    l = len(w[j])
    if l>10:
        print(w[j][0]+str(l)+w[j][-1])
    else:
        print(w)
    ","def main():
    original_points = 10  # Points of the queen of spades
    n = int(input().strip())  # Read the required sum of points

    # Card values and their respective counts
    card_values = {
        2: 4, 3: 4, 4: 4, 5: 4, 6: 4, 7: 4, 8: 4, 9: 4, 
        10: 16,  # 10, J, Q, K (4 each, but we exclude our queen)
        11: 4    # Aces
    }

    required_value = n - original_points  # Calculate the value needed from the second card

    # If the required value is less than 2 or greater than 11, it's impossible
    if required_value < 2 or required_value > 11:
        print(0)
        return

    # If the required value is 10, we have to exclude our queen from the count
    if required_value == 10:
        print(card_values[10] - 1)  # Subtract one for the queen of spades
    else:
        print(card_values.get(required_value, 0))  # Get count or 0 if not found

if __name__ == ""__main__"":
    main()"
355,A,Vasya and Digital Root,PROGRAMMING,"['constructive algorithms', 'implementation']","Vasya has recently found out what a digital root of a number is and he decided to share his knowledge with you.

Let's assume that *S*(*n*) is the sum of digits of number *n*, for example, *S*(4098)<==<=4<=+<=0<=+<=9<=+<=8<==<=21. Then the digital root of number *n* equals to: 
 1.  *dr*(*n*)<==<=*S*(*n*), if *S*(*n*)<=&lt;<=10; 1.  *dr*(*n*)<==<=*dr*(<=*S*(*n*)<=), if *S*(*n*)<=≥<=10. 
For example, *dr*(4098)<=<==<=<=*dr*(21)<=<==<=<=3.

Vasya is afraid of large numbers, so the numbers he works with are at most 101000. For all such numbers, he has proved that *dr*(*n*)<=<==<=<=*S*(<=*S*(<=*S*(<=*S*(*n*)<=)<=)<=) (*n*<=≤<=101000).

Now Vasya wants to quickly find numbers with the given digital root. The problem is, he hasn't learned how to do that and he asked you to help him. You task is, given numbers *k* and *d*, find the number consisting of exactly *k* digits (the leading zeroes are not allowed), with digital root equal to *d*, or else state that such number does not exist.",The first line contains two integers *k* and *d* (1<=≤<=*k*<=≤<=1000; 0<=≤<=*d*<=≤<=9).,"In a single line print either any number that meets the requirements (without the leading zeroes) or ""No solution"" (without the quotes), if the corresponding number does not exist.

The chosen number must consist of exactly *k* digits. We assume that number 0 doesn't contain any leading zeroes.","['4 4\n', '5 1\n', '1 0\n']","['5881\n', '36172\n', '0\n']","For the first test sample *dr*(5881)  =  *dr*(22)  =  4.

For the second test sample *dr*(36172)  =  *dr*(19)  =  *dr*(10)  =  1.",WRONG_ANSWER,"k, d = map(int, input().split())
if k == 1:
    print(d)
else:
    a = 1
    for i in range (k - 1):
        a = a * 10
    if d >= 1:
        a = a + (d - 1)
    else:
        a = a + 8
    print(a + 81)","queries = [int(input()) for _ in range(n)]  # Read all queries
    results = []  # List to hold results for each query
    
    for ni in queries:
        if ni < 4:  # Composite numbers start from 4
            results.append(-1)  # No valid splittings
        elif ni % 2 == 0:  # Even number
            results.append(ni // 4)  # Maximum summands from even numbers
        else:  # Odd number
            if ni < 9:
                results.append(-1)  # No valid splittings for odd numbers less than 9
            else:
                results.append((ni - 9) // 4 + 1)  # Maximum summands from odd numbers
        
    print('\n'.join(map(str, results)))  # Print all results

if __name__ == ""__main__"":
    main()  # Run the main function"
507,B,Amr and Pins,PROGRAMMING,"['geometry', 'math']","Amr loves Geometry. One day he came up with a very interesting problem.

Amr has a circle of radius *r* and center in point (*x*,<=*y*). He wants the circle center to be in new position (*x*',<=*y*').

In one step Amr can put a pin to the border of the circle in a certain point, then rotate the circle around that pin by any angle and finally remove the pin.

Help Amr to achieve his goal in minimum number of steps.","Input consists of 5 space-separated integers *r*, *x*, *y*, *x*' *y*' (1<=≤<=*r*<=≤<=105, <=-<=105<=≤<=*x*,<=*y*,<=*x*',<=*y*'<=≤<=105), circle radius, coordinates of original center of the circle and coordinates of destination center of the circle respectively.",Output a single integer — minimum number of steps required to move the center of the circle to the destination point.,"['2 0 0 0 4\n', '1 1 1 4 4\n', '4 5 6 5 6\n']","['1\n', '3\n', '0\n']","In the first sample test the optimal way is to put a pin at point (0, 2) and rotate the circle by 180 degrees counter-clockwise (or clockwise, no matter).

<img class=""tex-graphics"" src=""https://espresso.codeforces.com/4e40fd4cc24a2050a0488aa131e6244369328039.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>",OK,"from math import *
r,x,y,a,b=map(int,input().split())
print(ceil((((x-a)**2+(y-b)**2)**0.5)/(r*2)))
","def it(): return int(input())
def pr(a): return print(a)
def li(): return list(map(int, input().split()))
def ls(): return [str(i) for i in input()]

# Read number of visitors
n = it()

# Initialize a dictionary to count visitors by arrival time
time_count = {}

# Collect each visitor's arrival time
for _ in range(n):
    h, m = li()
    time = (h, m)
    if time in time_count:
        time_count[time] += 1
    else:
        time_count[time] = 1

# The minimum number of cashes needed is the maximum number of visitors at the same time
min_cashes = max(time_count.values())

# Print the result
pr(min_cashes)"
112,A,Petya and Strings,PROGRAMMING,"['implementation', 'strings']","Little Petya loves presents. His mum bought him two strings of the same size for his birthday. The strings consist of uppercase and lowercase Latin letters. Now Petya wants to compare those two strings lexicographically. The letters' case does not matter, that is an uppercase letter is considered equivalent to the corresponding lowercase letter. Help Petya perform the comparison.",Each of the first two lines contains a bought string. The strings' lengths range from 1 to 100 inclusive. It is guaranteed that the strings are of the same length and also consist of uppercase and lowercase Latin letters.,"If the first string is less than the second one, print ""-1"". If the second string is less than the first one, print ""1"". If the strings are equal, print ""0"". Note that the letters' case is not taken into consideration when the strings are compared.","['aaaa\naaaA\n', 'abs\nAbz\n', 'abcdefg\nAbCdEfF\n']","['0\n', '-1\n', '1\n']","If you want more formal information about the lexicographical order (also known as the ""dictionary order"" or ""alphabetical order""), you can visit the following site:
-  http://en.wikipedia.org/wiki/Lexicographical_order",OK,"s1 = input().lower()
s2 = input().lower()

if s1==s2:
    print(0)
if s1<s2:
    print(-1)
if s1>s2:
    print(1)
","a = int(input())
b = [] * a
c = list()
c.append(1)

for i in range(a):
    b.append(list(map(int, input().split())))

def process_children(b):
    cured_children = []
    while b:
        v_i, d_i, p_i = b.pop(0)  # Get the first child
        p = [p_i]  # Current confidence levels
        for v, d, p_value in b:
            p.append(max(0, p_value - v_i))
        
        # Check for children crying
        crying = True
        while crying:
            crying = False
            for j in range(len(p)):
                if p[j] < 0:
                    # Child j cries and runs away
                    crying = True
                    d_j = b[j][1]
                    for k in range(j, len(p)):
                        p[k] = max(0, p[k] - d_j)
                    b.pop(j)  # Remove the j-th child
                    break
        
        cured_children.append(len(cured_children) + 1)  # Record cured child's position

    return cured_children

cured = process_children(b)
print(len(cured))
print("" "".join(map(str, cured)))"
551,A,GukiZ and Contest,PROGRAMMING,"['brute force', 'implementation', 'sortings']","Professor GukiZ likes programming contests. He especially likes to rate his students on the contests he prepares. Now, he has decided to prepare a new contest. 

In total, *n* students will attend, and before the start, every one of them has some positive integer rating. Students are indexed from 1 to *n*. Let's denote the rating of *i*-th student as *a**i*. After the contest ends, every student will end up with some positive integer position. GukiZ expects that his students will take places according to their ratings. 

He thinks that each student will take place equal to . In particular, if student *A* has rating strictly lower then student *B*, *A* will get the strictly better position than *B*, and if two students have equal ratings, they will share the same position. 

GukiZ would like you to reconstruct the results by following his expectations. Help him and determine the position after the end of the contest for each of his students if everything goes as expected.","The first line contains integer *n* (1<=≤<=*n*<=≤<=2000), number of GukiZ's students. 

The second line contains *n* numbers *a*1,<=*a*2,<=... *a**n* (1<=≤<=*a**i*<=≤<=2000) where *a**i* is the rating of *i*-th student (1<=≤<=*i*<=≤<=*n*).","In a single line, print the position after the end of the contest for each of *n* students in the same order as they appear in the input.","['3\n1 3 3\n', '1\n1\n', '5\n3 5 3 4 5\n']","['3 1 1\n', '1\n', '4 1 4 3 1\n']","In the first sample, students 2 and 3 are positioned first (there is no other student with higher rating), and student 1 is positioned third since there are two students with higher rating.

In the second sample, first student is the only one on the contest.

In the third sample, students 2 and 5 share the first position with highest rating, student 4 is next with third position, and students 1 and 3 are the last sharing fourth position.",COMPILATION_ERROR,"#include <bits/stdc++.h>
using namespace std;

#define mod 1000000007
#define ll long long
#define ull unsigned long long
#define mp make_pair
#define pb push_back
#define rep(n) for(long i=0;i<n;i++)
#define mset(a,i) memset(a,i,sizeof(a))
#define minv(a) min_element(a.begin(),a.end())
#define maxv(a) max_element(a.begin(),a.end())
#define min3(a,b,c) min(a,min(b,c))
#define max3(a,b,c) max(a,max(b,c))
#define ff first
#define ss second
#define endl ""\n""
#define len(s) s.length()
#define NL cout<<endl;
#define printmat(a,m,n) for(int i=0;i<m;i++){       \
                            for(int j=0;j<n;j++){   \
                                cout<<a[i][j]<<"" ""; \
                            }                       \
                            cout<<endl;             \
                        }
#define dbgn(x) cout<<"" $ ""<<x<<"" $ ""<<endl;
#define dbg(x) cout<<"" $ ""<<x<<"" $ "";
#define all(v) v.begin(),v.end()
#define ub upper_bound
#define lb lower_bound
#define maxheap priority_queue<ll>
#define minheap priority_queue<ll, vi, greater<ll>>
#define fast_io() cin.sync_with_stdio(false);cout.sync_with_stdio(false); cin.tie(NULL);


int main() {
    ll n;
    cin>>n;
    ll a[n];
    ll b[2001],c[2001];
    mset(b,0);
    mset(c,0);
    rep(n){
        cin>>a[i];
        b[a[i]]++;
    }
    for(int i=1999;i>=0;i--){
        c[i]=c[i+1]+b[i+1];
    }
    rep(n){
        cout<<c[a[i]]+1<<"" "";
    }
	return 0;","#!/usr/bin/env python
from __future__ import division, print_function
import math
import os
import sys
from sys import stdin,stdout
from io import BytesIO, IOBase
from itertools import accumulate

# Read the number of circles
n = int(stdin.readline().strip())
# Read the radii of the circles
radii = list(map(int, stdin.readline().strip().split()))

# Sort the radii in descending order
radii.sort(reverse=True)

# Initialize total red area
red_area = 0.0

# Iterate over the radii, calculating area differences
for i in range(n):
    # Calculate the area of the current circle
    area = math.pi * radii[i] ** 2
    # Add or subtract area based on the index (even -> red, odd -> blue)
    if i % 2 == 0:
        red_area += area  # Add for red parts
    else:
        red_area -= area  # Subtract for blue parts

# Output the total area of red parts
stdout.write(f""{red_area:.9f}\n"")"
798,A,Mike and palindrome,PROGRAMMING,"['brute force', 'constructive algorithms', 'strings']","Mike has a string *s* consisting of only lowercase English letters. He wants to change exactly one character from the string so that the resulting one is a palindrome. 

A palindrome is a string that reads the same backward as forward, for example strings ""z"", ""aaa"", ""aba"", ""abccba"" are palindromes, but strings ""codeforces"", ""reality"", ""ab"" are not.",The first and single line contains string *s* (1<=≤<=|*s*|<=≤<=15).,"Print ""YES"" (without quotes) if Mike can change exactly one character so that the resulting string is palindrome or ""NO"" (without quotes) otherwise.","['abccaa\n', 'abbcca\n', 'abcda\n']","['YES\n', 'NO\n', 'YES\n']",none,WRONG_ANSWER,"word = input()
counter = 0
for i in range(0, int(len(word) / 2)):
    if word[i] != word[-(i + 1)]:
        counter += 1
if counter == 0 or counter == 1:
    print(""YES"")
else:
    print(""NO"")
","import sys
ONLINE_JUDGE = True

if not ONLINE_JUDGE:
    sys.stdin = open(""input.txt"", ""r"")

############ ---- Input Functions ---- ############
n, k = map(int, input().split())
line = input().strip()

# Find positions of Grasshopper (G) and Target (T)
g_index = line.index('G')
t_index = line.index('T')

# Determine the direction of movement
if g_index < t_index:
    step = 1  # Towards the right
else:
    step = -1  # Towards the left

# Check for possible jumps
for position in range(g_index, t_index, step * k):
    if line[position] == '#':
        print(""NO"")
        break
else:
    print(""YES"")"
499,B,Lecture,PROGRAMMING,"['implementation', 'strings']","You have a new professor of graph theory and he speaks very quickly. You come up with the following plan to keep up with his lecture and make notes.

You know two languages, and the professor is giving the lecture in the first one. The words in both languages consist of lowercase English characters, each language consists of several words. For each language, all words are distinct, i.e. they are spelled differently. Moreover, the words of these languages have a one-to-one correspondence, that is, for each word in each language, there exists exactly one word in the other language having has the same meaning.

You can write down every word the professor says in either the first language or the second language. Of course, during the lecture you write down each word in the language in which the word is shorter. In case of equal lengths of the corresponding words you prefer the word of the first language.

You are given the text of the lecture the professor is going to read. Find out how the lecture will be recorded in your notes.","The first line contains two integers, *n* and *m* (1<=≤<=*n*<=≤<=3000, 1<=≤<=*m*<=≤<=3000) — the number of words in the professor's lecture and the number of words in each of these languages.

The following *m* lines contain the words. The *i*-th line contains two strings *a**i*, *b**i* meaning that the word *a**i* belongs to the first language, the word *b**i* belongs to the second language, and these two words have the same meaning. It is guaranteed that no word occurs in both languages, and each word occurs in its language exactly once.

The next line contains *n* space-separated strings *c*1,<=*c*2,<=...,<=*c**n* — the text of the lecture. It is guaranteed that each of the strings *c**i* belongs to the set of strings {*a*1,<=*a*2,<=... *a**m*}.

All the strings in the input are non-empty, each consisting of no more than 10 lowercase English letters.",Output exactly *n* words: how you will record the lecture in your notebook. Output the words of the lecture in the same order as in the input.,"['4 3\ncodeforces codesecrof\ncontest round\nletter message\ncodeforces contest letter contest\n', '5 3\njoll wuqrd\neuzf un\nhbnyiyc rsoqqveh\nhbnyiyc joll joll euzf joll\n']","['codeforces round letter round\n', 'hbnyiyc joll joll un joll\n']",none,OK,"n , m = map(int, input().split("" ""))
notes = {}
final = []
for i in range(m):
    a,b = map(str, input().split())
    notes[a]=b
c = list(map(str, input().split("" "")[:n]))
for i in c:
    if len(notes[i])>=len(i):
        final.append(i)
    else:
        final.append(notes[i])
print("" "".join(final))","# iterate through numbers
# find prime factorization for each number
# compute max value among each prime factor
# increment each by 1

from collections import defaultdict
import math

def prime_factors(x):
    factors = set()
    while x % 2 == 0:
        factors.add(2)
        x //= 2
    for i in range(3, int(math.sqrt(x)) + 1, 2):
        while x % i == 0:
            factors.add(i)
            x //= i
    if x > 2:
        factors.add(x)
    return factors

def longest_good_sequence(n, a):
    # Map to store the maximum value for each prime factor
    prime_map = defaultdict(int)
    
    for num in a:
        # Get prime factors of the number
        factors = prime_factors(num)
        for factor in factors:
            # Store the maximum value for each prime factor
            prime_map[factor] = max(prime_map[factor], num)
    
    # Now calculate the length of the longest good sequence
    max_length = 0
    for value in prime_map.values():
        max_length += 1  # each prime factor contributes to length
    
    return max_length

# Input reading
n = int(input())
a = list(map(int, input().split()))

# Calculate and print the length of the longest good sequence
print(longest_good_sequence(n, a))"
80,A,Panoramix's Prediction,PROGRAMMING,['brute force'],"A prime number is a number which has exactly two distinct divisors: one and itself. For example, numbers 2, 7, 3 are prime, and 1, 6, 4 are not.

The next prime number after *x* is the smallest prime number greater than *x*. For example, the next prime number after 2 is 3, and the next prime number after 3 is 5. Note that there is exactly one next prime number after each number. So 5 is not the next prime number for 2.

One cold April morning Panoramix predicted that soon Kakofonix will break free from his straitjacket, and this will be a black day for the residents of the Gallic countryside.

Panoramix's prophecy tells that if some day Asterix and Obelix beat exactly *x* Roman soldiers, where *x* is a prime number, and next day they beat exactly *y* Roman soldiers, where *y* is the next prime number after *x*, then it's time to wait for Armageddon, for nothing can shut Kakofonix up while he sings his infernal song.

Yesterday the Gauls beat *n* Roman soldiers and it turned out that the number *n* was prime! Today their victims were a troop of *m* Romans (*m*<=&gt;<=*n*). Determine whether the Gauls should wait for the black day after today's victory of Asterix and Obelix?","The first and only input line contains two positive integers — *n* and *m* (2<=≤<=*n*<=&lt;<=*m*<=≤<=50). It is guaranteed that *n* is prime.

Pretests contain all the cases with restrictions 2<=≤<=*n*<=&lt;<=*m*<=≤<=4.","Print YES, if *m* is the next prime number after *n*, or NO otherwise.","['3 5\n', '7 11\n', '7 9\n']","['YES', 'YES', 'NO']",none,RUNTIME_ERROR,"a,b = map(int,input().split())
c = [3,5,7,11,13,17,19,23,29,31,37,41,43,47]
if c[c.index(a)+1] == b:
    print(""YES"")
else:
    print(""NO"")","# https://codeforces.com/problemset/problem/658/A

n, c = map(int, input().split())
p = tuple(map(int, input().split()))
t = list(map(int, input().split()))

# Calculate Limak's points
limak_points = 0
limak_time = 0
for i in range(n):
    limak_time += t[i]
    limak_points += max(0, p[i] - c * limak_time)

# Calculate Radewoosh's points
radewoosh_points = 0
radewoosh_time = 0
for i in range(n-1, -1, -1):
    radewoosh_time += t[i]
    radewoosh_points += max(0, p[i] - c * radewoosh_time)

# Determine and print the winner
if limak_points > radewoosh_points:
    print(""Limak"")
elif radewoosh_points > limak_points:
    print(""Radewoosh"")
else:
    print(""Tie"")"
1,A,Theatre Square,PROGRAMMING,['math'],"Theatre Square in the capital city of Berland has a rectangular shape with the size *n*<=×<=*m* meters. On the occasion of the city's anniversary, a decision was taken to pave the Square with square granite flagstones. Each flagstone is of the size *a*<=×<=*a*.

What is the least number of flagstones needed to pave the Square? It's allowed to cover the surface larger than the Theatre Square, but the Square has to be covered. It's not allowed to break the flagstones. The sides of flagstones should be parallel to the sides of the Square.","The input contains three positive integer numbers in the first line: *n*,<=<=*m* and *a* (1<=≤<=<=*n*,<=*m*,<=*a*<=≤<=109).",Write the needed number of flagstones.,['6 6 4\n'],['4\n'],none,OK,"n, m, a = input().split()
n, m, a = int(n), int(m), int(a)
x = (n + a - 1) / a
y = (m + a - 1) / a
print(int(x)*int(y))

","n = int(input())
l = []

def is_prime(number):
    if number < 2:
        return False
    for i in range(2, int(number**0.5) + 1):
        if number % i == 0:
            return False
    return True

# Generate a list of composite numbers up to n
for num in range(4, n + 1):
    if not is_prime(num):
        l.append(num)

# Find two composite numbers that sum to n
for i in range(len(l)):
    for j in range(i, len(l)):
        if l[i] + l[j] == n:
            print(l[i], l[j])
            exit()"
329,A,Purification,PROGRAMMING,"['constructive algorithms', 'greedy']","You are an adventurer currently journeying inside an evil temple. After defeating a couple of weak zombies, you arrived at a square room consisting of tiles forming an *n*<=×<=*n* grid. The rows are numbered 1 through *n* from top to bottom, and the columns are numbered 1 through *n* from left to right. At the far side of the room lies a door locked with evil magical forces. The following inscriptions are written on the door:

Being a very senior adventurer, you immediately realize what this means. You notice that every single cell in the grid are initially evil. You should purify all of these cells.

The only method of tile purification known to you is by casting the ""Purification"" spell. You cast this spell on a single tile — then, all cells that are located in the same row and all cells that are located in the same column as the selected tile become purified (including the selected tile)! It is allowed to purify a cell more than once.

You would like to purify all *n*<=×<=*n* cells while minimizing the number of times you cast the ""Purification"" spell. This sounds very easy, but you just noticed that some tiles are particularly more evil than the other tiles. You cannot cast the ""Purification"" spell on those particularly more evil tiles, not even after they have been purified. They can still be purified if a cell sharing the same row or the same column gets selected by the ""Purification"" spell.

Please find some way to purify all the cells with the minimum number of spells cast. Print -1 if there is no such way.","The first line will contain a single integer *n* (1<=≤<=*n*<=≤<=100). Then, *n* lines follows, each contains *n* characters. The *j*-th character in the *i*-th row represents the cell located at row *i* and column *j*. It will be the character 'E' if it is a particularly more evil cell, and '.' otherwise.","If there exists no way to purify all the cells, output -1. Otherwise, if your solution casts *x* ""Purification"" spells (where *x* is the minimum possible number of spells), output *x* lines. Each line should consist of two integers denoting the row and column numbers of the cell on which you should cast the ""Purification"" spell.","['3\n.E.\nE.E\n.E.\n', '3\nEEE\nE..\nE.E\n', '5\nEE.EE\nE.EE.\nE...E\n.EE.E\nEE.EE\n']","['1 1\n2 2\n3 3\n', '-1\n', '3 3\n1 3\n2 2\n4 4\n5 3']","The first example is illustrated as follows. Purple tiles are evil tiles that have not yet been purified. Red tile is the tile on which ""Purification"" is cast. Yellow tiles are the tiles being purified as a result of the current ""Purification"" spell. Green tiles are tiles that have been purified previously. 

In the second example, it is impossible to purify the cell located at row 1 and column 1.

For the third example:",COMPILATION_ERROR,"n=int(input())
s=[]
for i in range(n):
    s.append(input())
r,cl=0,0
for i in range(n):
    c=0
    for j in range(n):
        if s[i][j]=='E':
            c=c+1
    r=max(r,c)
for i in range(n):
    c=0
    for j in range(n):
        if s[j][i]=='E':
            c=c+1
    cl=max(cl,c)
if r==n and cl==n:
    print(-1)
else:
ans=[]
    for i in range(n):
        if s[i][i]!='E':
            ans.append([i+1,i+1])
        else:
            for j in range(n):
                if s[i][j]=='.':
                    ans.append([i+1,j+1])
                    break
    for i in range(n):
        print(ans[i][0],ans[i][1])","from collections import defaultdict

n, x0, y0 = map(int, input().split())
dic = defaultdict(int)

for _ in range(n):
    x_i, y_i = map(int, input().split())
    
    # Calculate the difference
    dx = x_i - x0
    dy = y_i - y0
    
    # Calculate the greatest common divisor (GCD)
    gcd_value = abs(gcd(dy, dx))
    
    # Normalize the direction
    direction = (dy // gcd_value, dx // gcd_value)
    
    # Count unique directions
    dic[direction] += 1

# The number of unique directions (shots)
print(len(dic))

def gcd(a, b):
    while b:
        a, b = b, a % b
    return abs(a)"
182,A,Battlefield,PROGRAMMING,"['geometry', 'graphs', 'implementation', 'shortest paths']","Vasya lagged behind at the University and got to the battlefield. Just joking! He's simply playing some computer game. The field is a flat platform with *n* trenches dug on it. The trenches are segments on a plane parallel to the coordinate axes. No two trenches intersect.

There is a huge enemy laser far away from Vasya. The laser charges for *a* seconds, and then shoots continuously for *b* seconds. Then, it charges for *a* seconds again. Then it shoots continuously for *b* seconds again and so on. Vasya knows numbers *a* and *b*. He also knows that while the laser is shooting, Vasya must be in the trench, but while the laser is charging, Vasya can safely move around the field. The main thing is to have time to hide in the trench before the shot. If Vasya reaches the trench exactly at the moment when the laser starts shooting, we believe that Vasya managed to hide. Coincidentally, the length of any trench in meters numerically does not exceed *b*.

Initially, Vasya is at point *A*. He needs to get to point *B*. Vasya moves at speed 1 meter per second in either direction. You can get in or out of the trench at any its point. Getting in or out of the trench takes no time. It is also possible to move in the trench, without leaving it.

What is the minimum time Vasya needs to get from point *A* to point *B*, if at the initial time the laser has just started charging? If Vasya cannot get from point *A* to point *B*, print -1. If Vasya reaches point *B* at the moment when the laser begins to shoot, it is believed that Vasya managed to reach point *B*.","The first line contains two space-separated integers: *a* and *b* (1<=≤<=*a*,<=*b*<=≤<=1000), — the duration of charging and the duration of shooting, in seconds.

The second line contains four space-separated integers: *A**x*, *A**y*, *B**x*, *B**y* (<=-<=104<=≤<=*A**x*,<=*A**y*,<=*B**x*,<=*B**y*<=≤<=104) — the coordinates of points *А* and *B*. It is guaranteed that points *A* and *B* do not belong to any trench.

The third line contains a single integer: *n* (1<=≤<=*n*<=≤<=1000), — the number of trenches. 

Each of the following *n* lines contains four space-separated integers: *x*1, *y*1, *x*2, *y*2 (<=-<=104<=≤<=*x**i*,<=*y**i*<=≤<=104) — the coordinates of ends of the corresponding trench.

All coordinates are given in meters. It is guaranteed that for any trench either *x*1<==<=*x*2, or *y*1<==<=*y*2. No two trenches intersect. The length of any trench in meters doesn't exceed *b* numerically.","If Vasya can get from point *A* to point *B*, print the minimum time he will need for it. Otherwise, print number -1.

The answer will be considered correct if the absolute or relative error does not exceed 10<=-<=4","['2 4\n0 5 6 5\n3\n0 0 0 4\n1 1 4 1\n6 0 6 4\n', '5 10\n0 0 10 10\n1\n5 0 5 9\n']","['19.0000000000\n', '-1\n']",none,WRONG_ANSWER,"print(""_RANDOM_GUESS_1691930207.6039705"")# 1691930207.603982","import collections
import functools
import math
import sys
import bisect

def generate_string(n, k):
    # Check if it's possible to form a string with n length and k distinct letters
    if k > 26 or k > n:
        return ""-1""
    
    # Initialize the base characters 'a' to 'z'
    base_chars = [chr(i) for i in range(ord('a'), ord('a') + k)]
    result = []
    
    # Build the string with the required constraints
    for i in range(n):
        # Append the character based on the position, ensuring no two adjacent characters are the same
        result.append(base_chars[i % k])
    
    # Convert list to string and return
    return ''.join(result)

if __name__ == ""__main__"":
    # Read input values
    n, k = map(int, sys.stdin.readline().strip().split())
    # Generate and print the required string
    print(generate_string(n, k))"
535,B,Tavas and SaDDas,PROGRAMMING,"['bitmasks', 'brute force', 'combinatorics', 'implementation']","Once again Tavas started eating coffee mix without water! Keione told him that it smells awful, but he didn't stop doing that. That's why Keione told his smart friend, SaDDas to punish him! SaDDas took Tavas' headphones and told him: ""If you solve the following problem, I'll return it to you.""

The problem is: 

You are given a lucky number *n*. Lucky numbers are the positive integers whose decimal representations contain only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.

If we sort all lucky numbers in increasing order, what's the 1-based index of *n*? 

Tavas is not as smart as SaDDas, so he asked you to do him a favor and solve this problem so he can have his headphones back.",The first and only line of input contains a lucky number *n* (1<=≤<=*n*<=≤<=109).,Print the index of *n* among all lucky numbers.,"['4\n', '7\n', '77\n']","['1\n', '2\n', '6\n']",none,OK,"import math
def fact(n):
    ans = 1
    for i in range(2, n+1):
        ans*= i
    return ans
def comb(n, c):
    return fact(n)//(fact(n-c)*c)

n= int(input())
if(n==4):
    print(1)
elif(n==7):
    print(2)
else:
    add = 2
    ans = 0
    n = str(n)
    for i in range(len(n)):
        ans+=(2**i)
    pos = (2**len(n))
    left = 1
    right = pos
    i = 0
    while(left < right and i < len(n)):
        mid = (left+right)//2
        if(n[i]=='4'):
            right = mid
        else:
            left = mid+1
        i+=1
    ans+=left-1
    print(ans)","def Decimals(a, b, c):
    denom = list()
    position = 0
    while a != 0 and a not in denom:
        denom.append(a)
        a *= 10
        digit = a // b  # Find the next digit
        a %= b  # Update a for the next digit
        position += 1
        
        if digit == c:  # Check if the digit matches c
            return position  # Return the position if found
    
    return -1  # Return -1 if c is not found"
519,C,A and B and Team Training,PROGRAMMING,"['greedy', 'implementation', 'math', 'number theory']","A and B are preparing themselves for programming contests.

An important part of preparing for a competition is sharing programming knowledge from the experienced members to those who are just beginning to deal with the contests. Therefore, during the next team training A decided to make teams so that newbies are solving problems together with experienced participants.

A believes that the optimal team of three people should consist of one experienced participant and two newbies. Thus, each experienced participant can share the experience with a large number of people.

However, B believes that the optimal team should have two experienced members plus one newbie. Thus, each newbie can gain more knowledge and experience.

As a result, A and B have decided that all the teams during the training session should belong to one of the two types described above. Furthermore, they agree that the total number of teams should be as much as possible.

There are *n* experienced members and *m* newbies on the training session. Can you calculate what maximum number of teams can be formed?","The first line contains two integers *n* and *m* (0<=≤<=*n*,<=*m*<=≤<=5·105) — the number of experienced participants and newbies that are present at the training session.",Print the maximum number of teams that can be formed.,"['2 6\n', '4 5\n']","['2\n', '3\n']","Let's represent the experienced players as XP and newbies as NB.

In the first test the teams look as follows: (XP, NB, NB), (XP, NB, NB).

In the second test sample the teams look as follows: (XP, NB, NB), (XP, NB, NB), (XP, XP, NB).",COMPILATION_ERROR,"#include <bits/stdc++.h>
#define ll long long
//#define int ll
#define pb push_back
#define fi first
#define se second
#define debug(x) cout << x << ""\n""
#define yes() cout << ""YES\n""
#define no() cout << ""NO\n""
#define pi 3.1415926535897932384626433832795028841971693993751
using namespace std;

void solve () {
	int n, m; cin >> n >> m;
	
	int ans = 0;
	for (int i = 0; i <= n; i++) {
		if (m - 2 * i >= 0) {
			ans = max(ans, i + min((n - i) / 2, m - 2 * i));
		}
	}
	debug(ans);
}

signed main () {
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	
	int t = 1;
//	cin >> t;
	while (t--) {
		solve();
	}
}","def main():
    n, k = map(int, input().split())
    lst = [int(i) for i in input().split()]
    counter = 0

    # While there are still pebbles to collect
    while sum(lst) > 0:
        # Count pebbles collected in a day
        collected_today = 0
        
        for i in range(n):
            if lst[i] > 0:
                # Determine how many pockets needed for this type
                pockets_needed = (lst[i] + k - 1) // k  # Ceiling division
                # Collect as many as possible from this type
                collected_today += min(pockets_needed * k, lst[i])
                lst[i] = max(0, lst[i] - collected_today)
        
        counter += 1  # Increment the day counter

    print(counter)

main()"
791,A,Bear and Big Brother,PROGRAMMING,['implementation'],"Bear Limak wants to become the largest of bears, or at least to become larger than his brother Bob.

Right now, Limak and Bob weigh *a* and *b* respectively. It's guaranteed that Limak's weight is smaller than or equal to his brother's weight.

Limak eats a lot and his weight is tripled after every year, while Bob's weight is doubled after every year.

After how many full years will Limak become strictly larger (strictly heavier) than Bob?",The only line of the input contains two integers *a* and *b* (1<=≤<=*a*<=≤<=*b*<=≤<=10) — the weight of Limak and the weight of Bob respectively.,"Print one integer, denoting the integer number of years after which Limak will become strictly larger than Bob.","['4 7\n', '4 9\n', '1 1\n']","['2\n', '3\n', '1\n']","In the first sample, Limak weighs 4 and Bob weighs 7 initially. After one year their weights are 4·3 = 12 and 7·2 = 14 respectively (one weight is tripled while the other one is doubled). Limak isn't larger than Bob yet. After the second year weights are 36 and 28, so the first weight is greater than the second one. Limak became larger than Bob after two years so you should print 2.

In the second sample, Limak's and Bob's weights in next years are: 12 and 18, then 36 and 36, and finally 108 and 72 (after three years). The answer is 3. Remember that Limak wants to be larger than Bob and he won't be satisfied with equal weights.

In the third sample, Limak becomes larger than Bob after the first year. Their weights will be 3 and 2 then.",MEMORY_LIMIT_EXCEEDED,"def eat(L, B):
    years = 0
    while L < B:
        L = L * 3
        B = B * 2
        years += 1
    return (years)


Limak, Bob = input().split()

print (eat(Limak, Bob))","def im(i=None):
    if not i:
        i = input()
    if i.isdigit():
        return int(i)
    else:
        return map(int, i.split(' '))

n = im()
s = input().strip()
q = im()

results = []
for _ in range(q):
    m, c = input().split()
    m = int(m)
    
    # Create an array to count segments including the target color 'c'
    current_length = 0
    max_length = 0
    count_other_colors = 0
    
    # Calculate the maximum Koyomity achievable
    for char in s:
        if char == c:
            current_length += 1
        else:
            count_other_colors += 1
            if count_other_colors > m:
                # Reset if we exceed the number of repaints
                current_length = 0
                count_other_colors = 0
        
        # Update the max_length found
        max_length = max(max_length, current_length + min(m, count_other_colors))
    
    results.append(max_length)

# Output the results
for result in results:
    print(result)"
322,B,Ciel and Flowers,PROGRAMMING,"['combinatorics', 'math']","Fox Ciel has some flowers: *r* red flowers, *g* green flowers and *b* blue flowers. She wants to use these flowers to make several bouquets. There are 4 types of bouquets:
 -  To make a ""red bouquet"", it needs 3 red flowers. -  To make a ""green bouquet"", it needs 3 green flowers. -  To make a ""blue bouquet"", it needs 3 blue flowers. -  To make a ""mixing bouquet"", it needs 1 red, 1 green and 1 blue flower. 
Help Fox Ciel to find the maximal number of bouquets she can make.","The first line contains three integers *r*, *g* and *b* (0<=≤<=*r*,<=*g*,<=*b*<=≤<=109) — the number of red, green and blue flowers.",Print the maximal number of bouquets Fox Ciel can make.,"['3 6 9\n', '4 4 4\n', '0 0 0\n']","['6\n', '4\n', '0\n']","In test case 1, we can make 1 red bouquet, 2 green bouquets and 3 blue bouquets.

In test case 2, we can make 1 red, 1 green, 1 blue and 1 mixing bouquet.",WRONG_ANSWER,"f = list(map(int,input().split()))
count = f[0]//3
c = f[0]%3
count1 = f[1]//3
c1 = f[1]%3
count2 = f[2]//3
c2 = f[2]%3
g = (c+c1+c2)//3
print(g+count+count1+count2)
                
        
            
            
       
       
                
                
            
        
        
        
    
            
            
        
            


                    
    
    
            
            
            
            
    

    
                           
                           
    
        
        
    
        
","# import sys
import pyrival.misc

@pyrival.misc.bootstrap
a, b = list(map(int, input().split()))
g = {}

# Initialize the good sequences count
for i in range(1, a + 1):
    g[i] = 1  # Each number can represent a sequence of length 1

# Count good sequences of length k
for length in range(2, b + 1):
    new_g = {}
    for i in range(1, a + 1):
        # Every possible sequence ending with i
        new_g[i] = 0
        for j in range(i, a + 1, i):  # j must be a multiple of i
            new_g[i] = (new_g[i] + g.get(j, 0)) % 1000000007
    g = new_g

# Sum all sequences of length k
result = sum(g.values()) % 1000000007
print(result)"
801,B,Valued Keys,PROGRAMMING,"['constructive algorithms', 'greedy', 'strings']","You found a mysterious function *f*. The function takes two strings *s*1 and *s*2. These strings must consist only of lowercase English letters, and must be the same length.

The output of the function *f* is another string of the same length. The *i*-th character of the output is equal to the minimum of the *i*-th character of *s*1 and the *i*-th character of *s*2.

For example, *f*(""ab"", ""ba"") = ""aa"", and *f*(""nzwzl"", ""zizez"") = ""niwel"".

You found two strings *x* and *y* of the same length and consisting of only lowercase English letters. Find any string *z* such that *f*(*x*,<=*z*)<==<=*y*, or print -1 if no such string *z* exists.","The first line of input contains the string *x*.

The second line of input contains the string *y*.

Both *x* and *y* consist only of lowercase English letters, *x* and *y* have same length and this length is between 1 and 100.","If there is no string *z* such that *f*(*x*,<=*z*)<==<=*y*, print -1.

Otherwise, print a string *z* such that *f*(*x*,<=*z*)<==<=*y*. If there are multiple possible answers, print any of them. The string *z* should be the same length as *x* and *y* and consist only of lowercase English letters.","['ab\naa\n', 'nzwzl\nniwel\n', 'ab\nba\n']","['ba\n', 'xiyez\n', '-1\n']","The first case is from the statement.

Another solution for the second case is ""zizez""

There is no solution for the third case. That is, there is no *z* such that *f*(""ab"", *z*) =  ""ba"".",WRONG_ANSWER,"x=input()
y=input()
z=''
for i in range(len(x)):
    if(x[i]==y[i]):
        z+='z'
    elif(x[i]!=y[i]):
        z+=y[i]
if(z==y):
    print(""-1"")
else:
    print(z)
","def main():
    n = int(input())
    s = list(input())
    
    # Count the number of 0s and 1s in the string
    count_0 = s.count('0')
    count_1 = s.count('1')
    
    # The minimum length of the string that may remain
    # is the absolute difference of count_0 and count_1
    min_length = abs(count_0 - count_1)
    
    print(min_length)

main()"
796,A,Buying A House,PROGRAMMING,"['brute force', 'implementation']","Zane the wizard had never loved anyone before, until he fell in love with a girl, whose name remains unknown to us.

The girl lives in house *m* of a village. There are *n* houses in that village, lining in a straight line from left to right: house 1, house 2, ..., house *n*. The village is also well-structured: house *i* and house *i*<=+<=1 (1<=≤<=*i*<=&lt;<=*n*) are exactly 10 meters away. In this village, some houses are occupied, and some are not. Indeed, unoccupied houses can be purchased.

You will be given *n* integers *a*1,<=*a*2,<=...,<=*a**n* that denote the availability and the prices of the houses. If house *i* is occupied, and therefore cannot be bought, then *a**i* equals 0. Otherwise, house *i* can be bought, and *a**i* represents the money required to buy it, in dollars.

As Zane has only *k* dollars to spare, it becomes a challenge for him to choose the house to purchase, so that he could live as near as possible to his crush. Help Zane determine the minimum distance from his crush's house to some house he can afford, to help him succeed in his love.","The first line contains three integers *n*, *m*, and *k* (2<=≤<=*n*<=≤<=100, 1<=≤<=*m*<=≤<=*n*, 1<=≤<=*k*<=≤<=100) — the number of houses in the village, the house where the girl lives, and the amount of money Zane has (in dollars), respectively.

The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (0<=≤<=*a**i*<=≤<=100) — denoting the availability and the prices of the houses.

It is guaranteed that *a**m*<==<=0 and that it is possible to purchase some house with no more than *k* dollars.","Print one integer — the minimum distance, in meters, from the house where the girl Zane likes lives to the house Zane can buy.","['5 1 20\n0 27 32 21 19\n', '7 3 50\n62 0 0 0 99 33 22\n', '10 5 100\n1 0 1 0 0 0 0 0 1 1\n']","['40', '30', '20']","In the first sample, with *k* = 20 dollars, Zane can buy only house 5. The distance from house *m* = 1 to house 5 is 10 + 10 + 10 + 10 = 40 meters.

In the second sample, Zane can buy houses 6 and 7. It is better to buy house 6 than house 7, since house *m* = 3 and house 6 are only 30 meters away, while house *m* = 3 and house 7 are 40 meters away.",WRONG_ANSWER,"(n,m,k) = (int(i) for i in input().split())
dms = [int(i) for i in input().split()]
right = -1
rastr = -1
left = -1
rastl = -1
for i in range(m, n):
	if dms[i]!=0 and dms[i]<=k:
		right = i
		rastr = i+1-m
		break
for i in range(m-1,max(m-rastr,0)-1,-1):
	if dms[i]!=0 and dms[i]<=k:
		rastl = m-1-i
if (rastr!=-1) and (rastr<rastl or rastl==-1):
	print(rastr*10)
else:
	if rastl==-1:
		print('False')
	else:
		print(rastl*10)","def gcd(a, b): 
    if (a == 0): 
        return b 
    return gcd(b % a, a) 

def count_numbers(b, n):
    # Total numbers of length n in base b without leading zeros
    # First digit can be from 1 to (b-1), remaining digits can be from 0 to (b-1)
    return (b - 1) * (b ** (n - 1))

def numbers_on_last_page(b, n, c):
    total_numbers = count_numbers(b, n)
    # Determine how many numbers can fit on each page
    pages = total_numbers // c
    # The last page might have some extra numbers
    last_page_count = total_numbers % c
    # If last_page_count is 0, it means the last page is actually the previous one
    return c if last_page_count == 0 and pages > 0 else last_page_count

# Read input values
b, n, c = map(int, input().split())
# Calculate and print the amount of numbers written on the last page
print(numbers_on_last_page(b, n, c))"
961,A,Tetris,PROGRAMMING,['implementation'],"You are given a following process. 

There is a platform with $n$ columns. $1 \times 1$ squares are appearing one after another in some columns on this platform. If there are no squares in the column, a square will occupy the bottom row. Otherwise a square will appear at the top of the highest square of this column. 

When all of the $n$ columns have at least one square in them, the bottom row is being removed. You will receive $1$ point for this, and all the squares left will fall down one row. 

You task is to calculate the amount of points you will receive.","The first line of input contain 2 integer numbers $n$ and $m$ ($1 \le n, m \le 1000$) — the length of the platform and the number of the squares.

The next line contain $m$ integer numbers $c_1, c_2, \dots, c_m$ ($1 \le c_i \le n$) — column in which $i$-th square will appear.",Print one integer — the amount of points you will receive.,['3 9\n1 1 2 2 2 3 1 2 3\n'],['2\n'],"In the sample case the answer will be equal to $2$ because after the appearing of $6$-th square will be removed one row (counts of the squares on the platform will look like $[2~ 3~ 1]$, and after removing one row will be $[1~ 2~ 0]$).

After the appearing of $9$-th square counts will be $[2~ 3~ 1]$, and after removing one row it will look like $[1~ 2~ 0]$.

So the answer will be equal to $2$.",RUNTIME_ERROR,"n,m=map(int,input().split())
mas=[0]*(n)
mas[0]=10**5
a=list(map(int,input.split()))
for i in a:
     mas[i]+=1
print(min(mas))","def inp():
    return map(int, input().split())


def fill_arr(n):
    # Initialize a list to count the occurrences of each remainder when divided by 5
    count = [0] * 5
    for i in range(1, n + 1):
        count[i % 5] += 1
    return count


def count_pairs(n, m):
    # Get the counts of remainders for both n and m
    count_n = fill_arr(n)
    count_m = fill_arr(m)
    
    # Initialize the number of valid pairs
    result = 0
    
    # Calculate the number of pairs whose sum is divisible by 5
    for i in range(5):
        result += count_n[i] * count_m[(5 - i) % 5]
    
    return result


# Main execution
n, m = inp()
print(count_pairs(n, m))"
620,A,Professor GukiZ's Robot,PROGRAMMING,"['implementation', 'math']","Professor GukiZ makes a new robot. The robot are in the point with coordinates (*x*1,<=*y*1) and should go to the point (*x*2,<=*y*2). In a single step the robot can change any of its coordinates (maybe both of them) by one (decrease or increase). So the robot can move in one of the 8 directions. Find the minimal number of steps the robot should make to get the finish position.","The first line contains two integers *x*1,<=*y*1 (<=-<=109<=≤<=*x*1,<=*y*1<=≤<=109) — the start position of the robot.

The second line contains two integers *x*2,<=*y*2 (<=-<=109<=≤<=*x*2,<=*y*2<=≤<=109) — the finish position of the robot.",Print the only integer *d* — the minimal number of steps to get the finish position.,"['0 0\n4 5\n', '3 4\n6 1\n']","['5\n', '3\n']","In the first example robot should increase both of its coordinates by one four times, so it will be in position (4, 4). After that robot should simply increase its *y* coordinate and get the finish position.

In the second example robot should simultaneously increase *x* coordinate and decrease *y* coordinate by one three times.",OK,"x1, y1 = list(map(int, input().split()))
x2, y2 = list(map(int, input().split()))
print(max(abs(x1-x2), abs(y1-y2)))","#!/usr/bin/env python3

def main():
    n = int(input())  # Read the number of bottles
    desc = set()  # A set to keep track of all brands
    brand = [0] * 1001  # Array to store how many bottles can open others
    proc = [0] * 1001  # Array to keep track of brands that can be opened
    tb = [False] * 1001  # Array to track if a brand can be opened

    for _ in range(n):
        a, b = map(int, input().split())  # Read brand a and brand b of each bottle
        desc.add(a)  # Add brand a to the set of brands
        brand[a] += 1  # Increment the count of bottles of brand a
        tb[b] = True  # Mark brand b as being able to be opened by some bottle

    # Count brands that cannot be opened
    count = 0
    for b in desc:
        if not tb[b]:  # If brand b cannot be opened
            count += 1

    print(count)  # Output the count of unopenable bottles

if __name__ == ""__main__"":
    main()"
856,B,Similar Words,PROGRAMMING,"['dp', 'hashing', 'strings', 'trees']","Let us call a non-empty sequence of lowercase English letters a word. Prefix of a word *x* is a word *y* that can be obtained from *x* by removing zero or more last letters of *x*.

Let us call two words similar, if one of them can be obtained from the other by removing its first letter.

You are given a set *S* of words. Find the maximal possible size of set of non-empty words *X* such that they satisfy the following: 
 -  each word of *X* is prefix of some word from *S*; -  *X* has no similar words.","Input data contains multiple test cases. The first line of the input data contains an integer *t* — the number of test cases. The descriptions of test cases follow.

The first line of each description contains an integer *n* — the number of words in the set *S* (1<=≤<=*n*<=≤<=106). Each of the following *n* lines contains one non-empty word — elements of *S*. All words in *S* are different.

It is guaranteed that the total length of all words in one input data doesn't exceed 106.",For each test case print one line that contains one integer *m* — the maximal number of words that *X* can contain.,['2\n3\naba\nbaba\naaab\n2\naa\na\n'],['6\n1\n'],none,WRONG_ANSWER,"print(""_RANDOM_GUESS_1691862211.6091032"")# 1691862211.60912","n = int(input())

def is_ok(mid):
    return mid * (mid + 1) // 2 < n

# Binary search to find the largest k such that 1 + 2 + ... + k < n
left, right = 0, 10**7  # Arbitrary large value; square root of max_n is appropriate here
while left < right:
    mid = (left + right + 1) // 2  # Middle point
    if is_ok(mid):
        left = mid  # mid is a valid candidate
    else:
        right = mid - 1  # mid is too large

k = left  # The largest k found

# Calculate the starting position of the sequence where numbers from 1 to k appear
start_position = k * (k + 1) // 2 + 1

# The number in the n-th position is the (n - start_position)th number in the next segment
result = n - start_position + 1

print(result)"
894,A,QAQ,PROGRAMMING,"['brute force', 'dp']","""QAQ"" is a word to denote an expression of crying. Imagine ""Q"" as eyes with tears and ""A"" as a mouth.

Now Diamond has given Bort a string consisting of only uppercase English letters of length *n*. There is a great number of ""QAQ"" in the string (Diamond is so cute!).

Bort wants to know how many subsequences ""QAQ"" are in the string Diamond has given. Note that the letters ""QAQ"" don't have to be consecutive, but the order of letters should be exact.",The only line contains a string of length *n* (1<=≤<=*n*<=≤<=100). It's guaranteed that the string only contains uppercase English letters.,"Print a single integer — the number of subsequences ""QAQ"" in the string.","['QAQAQYSYIOIWIN\n', 'QAQQQZZYNOIWIN\n']","['4\n', '3\n']","In the first example there are 4 subsequences ""QAQ"": ""QAQAQYSYIOIWIN"", ""QAQAQYSYIOIWIN"", ""QAQAQYSYIOIWIN"", ""QAQAQYSYIOIWIN"".",OK,"inputStr = input()
comb = [0,0,0]
count = 0
for i in range(len(inputStr)):
    if inputStr[i] == 'Q':
        comb[0] == 1
        for j in range(i, len(inputStr)):
            if inputStr[j] == 'A':
                comb[1] == 1
                for k in range(j, len(inputStr)):
                    if inputStr[k] == 'Q':
                        comb[2] += 1
                        count += 1
print(count)","from collections import defaultdict

N = 228228
a = defaultdict(list)
c = [0] * N
result_memo = {}

def go(v, pr, k):
    # If the current vertex has a cat, increment the consecutive cat count
    if c[v] == 1:
        k += 1
    else:
        k = 0

    # If the consecutive cats exceed m, we cannot proceed
    if k > m:
        return 0

    # Check if it's a leaf node (no unvisited children)
    if len(a[v]) == 1 and v != 1:
        return 1

    # Initialize the count of valid restaurants
    count = 0
    for u in a[v]:
        # Avoid going back to the parent node
        if u != pr:
            count += go(u, v, k)  # Recur for children
    
    return count

# Read input values
n, m = map(int, input().split())
cats = list(map(int, input().split()))

for i in range(1, n + 1):
    c[i] = cats[i - 1]

# Read edges and construct the tree
for _ in range(n - 1):
    x, y = map(int, input().split())
    a[x].append(y)
    a[y].append(x)

# Start DFS from the root (vertex 1) with parent as -1 and initial cat count as 0
result = go(1, -1, 0)
print(result)"
436,B,Om Nom and Spiders,PROGRAMMING,"['implementation', 'math']","Om Nom really likes candies and doesn't like spiders as they frequently steal candies. One day Om Nom fancied a walk in a park. Unfortunately, the park has some spiders and Om Nom doesn't want to see them at all.

The park can be represented as a rectangular *n*<=×<=*m* field. The park has *k* spiders, each spider at time 0 is at some cell of the field. The spiders move all the time, and each spider always moves in one of the four directions (left, right, down, up). In a unit of time, a spider crawls from his cell to the side-adjacent cell in the corresponding direction. If there is no cell in the given direction, then the spider leaves the park. The spiders do not interfere with each other as they move. Specifically, one cell can have multiple spiders at the same time.

Om Nom isn't yet sure where to start his walk from but he definitely wants:
 -  to start walking at time 0 at an upper row cell of the field (it is guaranteed that the cells in this row do not contain any spiders); -  to walk by moving down the field towards the lowest row (the walk ends when Om Nom leaves the boundaries of the park). 
We know that Om Nom moves by jumping. One jump takes one time unit and transports the little monster from his cell to either a side-adjacent cell on the lower row or outside the park boundaries.

Each time Om Nom lands in a cell he sees all the spiders that have come to that cell at this moment of time. Om Nom wants to choose the optimal cell to start the walk from. That's why he wonders: for each possible starting cell, how many spiders will he see during the walk if he starts from this cell? Help him and calculate the required value for each possible starting cell.","The first line contains three integers *n*,<=*m*,<=*k* (2<=≤<=*n*,<=*m*<=≤<=2000; 0<=≤<=*k*<=≤<=*m*(*n*<=-<=1)). 

Each of the next *n* lines contains *m* characters — the description of the park. The characters in the *i*-th line describe the *i*-th row of the park field. If the character in the line equals ""."", that means that the corresponding cell of the field is empty; otherwise, the character in the line will equal one of the four characters: ""L"" (meaning that this cell has a spider at time 0, moving left), ""R"" (a spider moving right), ""U"" (a spider moving up), ""D"" (a spider moving down). 

It is guaranteed that the first row doesn't contain any spiders. It is guaranteed that the description of the field contains no extra characters. It is guaranteed that at time 0 the field contains exactly *k* spiders.",Print *m* integers: the *j*-th integer must show the number of spiders Om Nom will see if he starts his walk from the *j*-th cell of the first row. The cells in any row of the field are numbered from left to right.,"['3 3 4\n...\nR.L\nR.U\n', '2 2 2\n..\nRL\n', '2 2 2\n..\nLR\n', '3 4 8\n....\nRRLL\nUUUU\n', '2 2 2\n..\nUU\n']","['0 2 2 ', '1 1 ', '0 0 ', '1 3 3 1 ', '0 0 ']","Consider the first sample. The notes below show how the spider arrangement changes on the field over time:

Character ""*"" represents a cell that contains two spiders at the same time.
 -  If Om Nom starts from the first cell of the first row, he won't see any spiders. -  If he starts from the second cell, he will see two spiders at time 1. -  If he starts from the third cell, he will see two spiders: one at time 1, the other one at time 2.",OK,"import sys
input = sys.stdin.readline

n, m, k = map(int, input().split())
g = [input()[:-1] for _ in range(n)]
d = [0]*m

for i in range(1, n):
    for j in range(m):
        if g[i][j] == 'R':
            if j + i < m:
                d[j+i] += 1
        elif g[i][j] == 'L':
            if j - i >= 0:
                d[j-i] += 1
        elif g[i][j] == 'U':
            if i % 2 == 0:
                d[j] += 1
print(' '.join(map(str, d)))
","def equal(str1, str2):
    if str1 == str2:
        return 1
    if len(str1) != len(str2):
        return 0
    if len(str1) == 1 and len(str2) == 1:
        return 0
    
    mid = len(str1) // 2
    # Split the strings into two halves
    a1, a2 = str1[:mid], str1[mid:]
    b1, b2 = str2[:mid], str2[mid:]
    
    # Check both conditions for equivalency
    if (equal(a1, b1) and equal(a2, b2)) or (equal(a1, b2) and equal(a2, b1)):
        return 1
    return 0

# Read input
str1 = input().strip()
str2 = input().strip()

# Determine equivalency and print result
if equal(str1, str2):
    print(""YES"")
else:
    print(""NO"")"
33,A,What is for dinner?,PROGRAMMING,"['greedy', 'implementation']","In one little known, but very beautiful country called Waterland, lives a lovely shark Valerie. Like all the sharks, she has several rows of teeth, and feeds on crucians. One of Valerie's distinguishing features is that while eating one crucian she uses only one row of her teeth, the rest of the teeth are ""relaxing"".

For a long time our heroine had been searching the sea for crucians, but a great misfortune happened. Her teeth started to ache, and she had to see the local dentist, lobster Ashot. As a professional, Ashot quickly relieved Valerie from her toothache. Moreover, he managed to determine the cause of Valerie's developing caries (for what he was later nicknamed Cap).

It turned that Valerie eats too many crucians. To help Valerie avoid further reoccurrence of toothache, Ashot found for each Valerie's tooth its residual viability. Residual viability of a tooth is a value equal to the amount of crucians that Valerie can eat with this tooth. Every time Valerie eats a crucian, viability of all the teeth used for it will decrease by one. When the viability of at least one tooth becomes negative, the shark will have to see the dentist again. 

Unhappy, Valerie came back home, where a portion of crucians was waiting for her. For sure, the shark couldn't say no to her favourite meal, but she had no desire to go back to the dentist. That's why she decided to eat the maximum amount of crucians from the portion but so that the viability of no tooth becomes negative. 

As Valerie is not good at mathematics, she asked you to help her to find out the total amount of crucians that she can consume for dinner.

We should remind you that while eating one crucian Valerie uses exactly one row of teeth and the viability of each tooth from this row decreases by one.","The first line contains three integers *n*, *m*, *k* (1<=≤<=*m*<=≤<=*n*<=≤<=1000,<=0<=≤<=*k*<=≤<=106) — total amount of Valerie's teeth, amount of tooth rows and amount of crucians in Valerie's portion for dinner. Then follow *n* lines, each containing two integers: *r* (1<=≤<=*r*<=≤<=*m*) — index of the row, where belongs the corresponding tooth, and *c* (0<=≤<=*c*<=≤<=106) — its residual viability.

It's guaranteed that each tooth row has positive amount of teeth.",In the first line output the maximum amount of crucians that Valerie can consume for dinner.,"['4 3 18\n2 3\n1 2\n3 6\n2 3\n', '2 2 13\n1 13\n2 12\n']","['11\n', '13\n']",none,RUNTIME_ERROR,"import os
import sys

import numpy as np
import torch
import torch.nn as nn
import torch.nn.functional as F
from torch.autograd import Variable

sys.path.append(os.path.dirname(os.path.abspath(__file__)))
from utils import to_one_hot, mixup_process, get_lambda
from load_data import per_image_standardization
import random


class PreActBlock(nn.Module):
    '''Pre-activation version of the BasicBlock.'''
    expansion = 1
    
    def __init__(self, in_planes, planes, stride=1):
        super(PreActBlock, self).__init__()
        self.bn1 = nn.BatchNorm2d(in_planes)
        self.conv1 = nn.Conv2d(in_planes, planes, kernel_size=3, stride=stride, padding=1, bias=False)
        self.bn2 = nn.BatchNorm2d(planes)
        self.conv2 = nn.Conv2d(planes, planes, kernel_size=3, stride=1, padding=1, bias=False)
        
        if stride != 1 or in_planes != self.expansion * planes:
            self.shortcut = nn.Sequential(
                nn.Conv2d(in_planes, self.expansion * planes, kernel_size=1, stride=stride, bias=False)
            )
    
    def forward(self, x):
        out = F.relu(self.bn1(x))
        shortcut = self.shortcut(out) if hasattr(self, 'shortcut') else x
        out = self.conv1(out)
        out = self.conv2(F.relu(self.bn2(out)))
        out += shortcut
        return out


class PreActBottleneck(nn.Module):
    '''Pre-activation version of the original Bottleneck module.'''
    expansion = 4
    
    def __init__(self, in_planes, planes, stride=1):
        super(PreActBottleneck, self).__init__()
        self.bn1 = nn.BatchNorm2d(in_planes)
        self.conv1 = nn.Conv2d(in_planes, planes, kernel_size=1, bias=False)
        self.bn2 = nn.BatchNorm2d(planes)
        self.conv2 = nn.Conv2d(planes, planes, kernel_size=3, stride=stride, padding=1, bias=False)
        self.bn3 = nn.BatchNorm2d(planes)
        self.conv3 = nn.Conv2d(planes, self.expansion * planes, kernel_size=1, bias=False)
        
        if stride != 1 or in_planes != self.expansion * planes:
            self.shortcut = nn.Sequential(
                nn.Conv2d(in_planes, self.expansion * planes, kernel_size=1, stride=stride, bias=False)
            )
    
    def forward(self, x):
        out = F.relu(self.bn1(x))
        shortcut = self.shortcut(out) if hasattr(self, 'shortcut') else x
        out = self.conv1(out)
        out = self.conv2(F.relu(self.bn2(out)))
        out = self.conv3(F.relu(self.bn3(out)))
        out += shortcut
        return out


class PreActResNet(nn.Module):
    def __init__(self, block, num_blocks, initial_channels, num_classes, device, per_img_std=False, stride=1):
        super(PreActResNet, self).__init__()
        self.in_planes = initial_channels
        self.num_classes = num_classes
        self.per_img_std = per_img_std
        self.device = device
        # import pdb; pdb.set_trace()
        self.conv1 = nn.Conv2d(3, initial_channels, kernel_size=3, stride=stride, padding=1, bias=False)
        self.layer1 = self._make_layer(block, initial_channels, num_blocks[0], stride=1)
        self.layer2 = self._make_layer(block, initial_channels * 2, num_blocks[1], stride=2)
        self.layer3 = self._make_layer(block, initial_channels * 4, num_blocks[2], stride=2)
        self.layer4 = self._make_layer(block, initial_channels * 8, num_blocks[3], stride=2)
        self.linear = nn.Linear(initial_channels * 8 * block.expansion, num_classes)
    
    def _make_layer(self, block, planes, num_blocks, stride):
        strides = [stride] + [1] * (num_blocks - 1)
        layers = []
        for stride in strides:
            layers.append(block(self.in_planes, planes, stride))
            self.in_planes = planes * block.expansion
        return nn.Sequential(*layers)
    
    def compute_h1(self, x):
        out = x
        out = self.conv1(out)
        out = self.layer1(out)
        return out
    
    def compute_h2(self, x):
        out = x
        out = self.conv1(out)
        out = self.layer1(out)
        out = self.layer2(out)
        return out
    
    def forward(self, x, target=None, mixup=False, mixup_hidden=False, mixup_alpha=None):
        # import pdb; pdb.set_trace()
        if self.per_img_std:
            x = per_image_standardization(x)
        
        if mixup_hidden:
            layer_mix = random.randint(0, 2)
        elif mixup:
            layer_mix = 0
        else:
            layer_mix = None
        
        out = x
        
        if mixup_alpha is not None:
            lam = get_lambda(mixup_alpha)
            lam = torch.from_numpy(np.array([lam]).astype('float32')).to(self.device)
            lam = Variable(lam)
        
        if target is not None:
            target_reweighted = to_one_hot(target, self.num_classes, device=self.device)
        
        if layer_mix == 0:
            out, target_reweighted = mixup_process(out, target_reweighted, lam=lam)
        
        out = self.conv1(out)
        out = self.layer1(out)
        
        if layer_mix == 1:
            out, target_reweighted = mixup_process(out, target_reweighted, lam=lam)
        
        out = self.layer2(out)
        
        if layer_mix == 2:
            out, target_reweighted = mixup_process(out, target_reweighted, lam=lam)
        
        out = self.layer3(out)
        if layer_mix == 3:
            out, target_reweighted = mixup_process(out, target_reweighted, lam=lam)
        
        out = self.layer4(out)
        out = F.avg_pool2d(out, 4)
        out = out.view(out.size(0), -1)
        out = self.linear(out)
        
        if target is not None:
            return out, target_reweighted
        else:
            return out


def preactresnet18(num_classes=10, dropout=False, device='cpu', per_img_std=False, stride=1):
    return PreActResNet(PreActBlock, [2, 2, 2, 2], 64, num_classes, device=device, per_img_std=per_img_std,
                        stride=stride)


def preactresnet34(num_classes=10, dropout=False, device='cpu', per_img_std=False, stride=1):
    return PreActResNet(PreActBlock, [3, 4, 6, 3], 64, num_classes, device='cpu', per_img_std=per_img_std,
                        stride=stride)


def preactresnet50(num_classes=10, dropout=False, device='cpu', per_img_std=False, stride=1):
    return PreActResNet(PreActBottleneck, [3, 4, 6, 3], 64, num_classes, device='cpu', per_img_std=per_img_std,
                        stride=stride)


def preactresnet101(num_classes=10, dropout=False, device='cpu', per_img_std=False, stride=1):
    return PreActResNet(PreActBottleneck, [3, 4, 23, 3], 64, num_classes, device='cpu', per_img_std=per_img_std,
                        stride=stride)


def preactresnet152(num_classes=10, dropout=False, device='cpu', per_img_std=False, stride=1):
    return PreActResNet(PreActBottleneck, [3, 8, 36, 3], 64, num_classes, device='cpu', per_img_std=per_img_std,
                        stride=stride)


def test():
    net = preactresnet152(True, 10)
    y = net(Variable(torch.randn(1, 3, 32, 32)))
    print(y.size())


if __name__ == ""__main__"":
    test()
# test()
","def main():
    s = input()
    l = len(s)
    
    max_length = 0  # Variable to keep track of the maximum length of a repeating substring
    
    # Check all possible substrings
    for length in range(1, l):  # Length of the substring
        for start in range(l - length + 1):  # Start index of the substring
            substring = s[start:start + length]
            # Check if the substring appears more than once in the string
            if s.count(substring) > 1:
                max_length = max(max_length, length)  # Update max_length if found

    print(max_length)  # Output the length of the longest repeating substring

main()"
231,A,Team,PROGRAMMING,"['brute force', 'greedy']","One day three best friends Petya, Vasya and Tonya decided to form a team and take part in programming contests. Participants are usually offered several problems during programming contests. Long before the start the friends decided that they will implement a problem if at least two of them are sure about the solution. Otherwise, the friends won't write the problem's solution.

This contest offers *n* problems to the participants. For each problem we know, which friend is sure about the solution. Help the friends find the number of problems for which they will write a solution.","The first input line contains a single integer *n* (1<=≤<=*n*<=≤<=1000) — the number of problems in the contest. Then *n* lines contain three integers each, each integer is either 0 or 1. If the first number in the line equals 1, then Petya is sure about the problem's solution, otherwise he isn't sure. The second number shows Vasya's view on the solution, the third number shows Tonya's view. The numbers on the lines are separated by spaces.",Print a single integer — the number of problems the friends will implement on the contest.,"['3\n1 1 0\n1 1 1\n1 0 0\n', '2\n1 0 0\n0 1 1\n']","['2\n', '1\n']","In the first sample Petya and Vasya are sure that they know how to solve the first problem and all three of them know how to solve the second problem. That means that they will write solutions for these problems. Only Petya is sure about the solution for the third problem, but that isn't enough, so the friends won't take it. 

In the second sample the friends will only implement the second problem, as Vasya and Tonya are sure about the solution.",WRONG_ANSWER,"x = int(input())
final = 0
for i in range(x):
  y = input()
  count = 0
  if (y[0] == ""1""):
    count+=1
  if (y[2] == ""1""):
    count+=1
  if (y[3] == ""1""):
    count+=1
  if (count >= 2):
    final+=1
print(final)","def fl(s):
    sfCount = 0  # Count of flights from Seattle to San Francisco
    fsCount = 0  # Count of flights from San Francisco to Seattle
    
    # Iterate through the string to count flights
    for i in range(len(s) - 1):
        if s[i] == 'S' and s[i + 1] == 'F':
            sfCount += 1  # Flight from Seattle to SF
        elif s[i] == 'F' and s[i + 1] == 'S':
            fsCount += 1  # Flight from SF to Seattle
    
    # Determine if there were more flights from Seattle to SF
    if sfCount > fsCount:
        print(""YES"")
    else:
        print(""NO"")

# Example usage
n = int(input())
s = input().strip()
fl(s)"
26,A,Almost Prime,PROGRAMMING,['number theory'],"A number is called almost prime if it has exactly two distinct prime divisors. For example, numbers 6, 18, 24 are almost prime, while 4, 8, 9, 42 are not. Find the amount of almost prime numbers which are between 1 and *n*, inclusive.",Input contains one integer number *n* (1<=≤<=*n*<=≤<=3000).,"Output the amount of almost prime numbers between 1 and *n*, inclusive.","['10\n', '21\n']","['2\n', '8\n']",none,OK,"
def count_primes(num):
    #does not consider num as a prime number
    count = 0

    for divisor in range(2, int(num**0.5)+1):
        if num % divisor == 0: count += 1

        while num % divisor == 0:
            num /= divisor
    
    if num > 1: count += 1 #num itself is prime

    return count


def count_almost_primes(num):
    count = 0
    for num in range(1, num+1):
        if count_primes(num) == 2: count += 1
    return count

def main():
    num = int(input())
    print(count_almost_primes(num))

main()

    
","def fn(i):
    return i*(i+1)//2

def walrus_chips(n, m):
    chips = 0  # Remaining chips
    current_walrus = 1  # Start from walrus number 1

    while True:
        required_chips = current_walrus  # Chips required for the current walrus
        if m >= required_chips:  # Check if there are enough chips to give
            m -= required_chips  # Deduct the chips given
            current_walrus += 1  # Move to the next walrus
            if current_walrus > n:  # If we've gone through all walruses, wrap around
                current_walrus = 1
        else:
            chips = m  # Remaining chips become the result
            break  # End the process

    return chips  # Return the number of remaining chips

# Example usage:
n, m = map(int, input().split())
print(walrus_chips(n, m))"
208,A,Dubstep,PROGRAMMING,['strings'],"Vasya works as a DJ in the best Berland nightclub, and he often uses dubstep music in his performance. Recently, he has decided to take a couple of old songs and make dubstep remixes from them.

Let's assume that a song consists of some number of words. To make the dubstep remix of this song, Vasya inserts a certain number of words ""WUB"" before the first word of the song (the number may be zero), after the last word (the number may be zero), and between words (at least one between any pair of neighbouring words), and then the boy glues together all the words, including ""WUB"", in one string and plays the song at the club.

For example, a song with words ""I AM X"" can transform into a dubstep remix as ""WUBWUBIWUBAMWUBWUBX"" and cannot transform into ""WUBWUBIAMWUBX"".

Recently, Petya has heard Vasya's new dubstep track, but since he isn't into modern music, he decided to find out what was the initial song that Vasya remixed. Help Petya restore the original song.","The input consists of a single non-empty string, consisting only of uppercase English letters, the string's length doesn't exceed 200 characters. It is guaranteed that before Vasya remixed the song, no word contained substring ""WUB"" in it; Vasya didn't change the word order. It is also guaranteed that initially the song had at least one word.",Print the words of the initial song that Vasya used to make a dubsteb remix. Separate the words with a space.,"['WUBWUBABCWUB\n', 'WUBWEWUBAREWUBWUBTHEWUBCHAMPIONSWUBMYWUBFRIENDWUB\n']","['ABC ', 'WE ARE THE CHAMPIONS MY FRIEND ']","In the first sample: ""WUBWUBABCWUB"" = ""WUB"" + ""WUB"" + ""ABC"" + ""WUB"". That means that the song originally consisted of a single word ""ABC"", and all words ""WUB"" were added by Vasya.

In the second sample Vasya added a single word ""WUB"" between all neighbouring words, in the beginning and in the end, except for words ""ARE"" and ""THE"" — between them Vasya added two ""WUB"".",WRONG_ANSWER,"s = input()
result = ''

for itm in s:
  result += itm
  if result == 'WUB':
    result = ''
    
if 'WUB' in result[len(result) - 3: ]:
  result = result[:len(result) - 3]

print(result)","def solve():
    n, k = map(int, input().split())
    w = list(map(int, input().split()))
    
    days = 0  # Initialize the days counter
    
    for pebbles in w:
        # Calculate how many pockets are needed for the current type of pebbles
        pockets_needed = (pebbles + k - 1) // k  # Ceiling division
        days += pockets_needed  # Add to the total days needed
    
    print(days)  # Output the total number of days needed"
492,C,Vanya and Exams,PROGRAMMING,"['greedy', 'sortings']","Vanya wants to pass *n* exams and get the academic scholarship. He will get the scholarship if the average grade mark for all the exams is at least *avg*. The exam grade cannot exceed *r*. Vanya has passed the exams and got grade *a**i* for the *i*-th exam. To increase the grade for the *i*-th exam by 1 point, Vanya must write *b**i* essays. He can raise the exam grade multiple times.

What is the minimum number of essays that Vanya needs to write to get scholarship?","The first line contains three integers *n*, *r*, *avg* (1<=≤<=*n*<=≤<=105, 1<=≤<=*r*<=≤<=109, 1<=≤<=*avg*<=≤<=*min*(*r*,<=106)) — the number of exams, the maximum grade and the required grade point average, respectively.

Each of the following *n* lines contains space-separated integers *a**i* and *b**i* (1<=≤<=*a**i*<=≤<=*r*, 1<=≤<=*b**i*<=≤<=106).",In the first line print the minimum number of essays.,"['5 5 4\n5 2\n4 7\n3 1\n3 2\n2 5\n', '2 5 4\n5 2\n5 2\n']","['4\n', '0\n']","In the first sample Vanya can write 2 essays for the 3rd exam to raise his grade by 2 points and 2 essays for the 4th exam to raise his grade by 1 point.

In the second sample, Vanya doesn't need to write any essays as his general point average already is above average.",OK,"def solve(a, b, r, avg):
    diff = max(0, len(a) * avg - sum(a))
    
    sorted_indices = sorted(range(len(a)), key=lambda i: b[i])
    
    result = 0
    index = 0
    while diff != 0:
        raise_num = min(diff, r - a[sorted_indices[index]])
        result += raise_num * b[sorted_indices[index]]
        
        diff -= raise_num
        index += 1
    
    return result

def main():
    n, r, avg = map(int, input().split())
    a = []
    b = []
    for i in range(n):
        ai, bi = map(int, input().split())
        a.append(ai)
        b.append(bi)
    
    print(solve(a, b, r, avg))

if __name__ == ""__main__"":
    main()","def t(st):
    hello = ""hello""
    i = 0

    # Iterate over each character in the input string
    for char in st:
        # Check if the current character matches the character in ""hello""
        if char == hello[i]:
            i += 1  # Move to the next character in ""hello""
        # If we have matched all characters in ""hello"", break the loop
        if i == len(hello):
            break

    # If we have matched all characters, print ""YES"", else print ""NO""
    if i == len(hello):
        print(""YES"")
    else:
        print(""NO"")

# Example usage:
# t(""ahhellllloou"")  # Should print ""YES""
# t(""hlelo"")        # Should print ""NO"""
43,A,Football,PROGRAMMING,['strings'],"One day Vasya decided to have a look at the results of Berland 1910 Football Championship’s finals. Unfortunately he didn't find the overall score of the match; however, he got hold of a profound description of the match's process. On the whole there are *n* lines in that description each of which described one goal. Every goal was marked with the name of the team that had scored it. Help Vasya, learn the name of the team that won the finals. It is guaranteed that the match did not end in a tie.",The first line contains an integer *n* (1<=≤<=*n*<=≤<=100) — the number of lines in the description. Then follow *n* lines — for each goal the names of the teams that scored it. The names are non-empty lines consisting of uppercase Latin letters whose lengths do not exceed 10 symbols. It is guaranteed that the match did not end in a tie and the description contains no more than two different teams.,Print the name of the winning team. We remind you that in football the team that scores more goals is considered the winner.,"['1\nABC\n', '5\nA\nABA\nABA\nA\nA\n']","['ABC\n', 'A\n']",none,OK,"n = int(input())
freq = {}
for _ in range(n):
  s = input()
  freq[s] = freq.get(s, 0) + 1

keys = list(freq.keys())
if len(keys) == 1:
  print(keys[0])
else:
  if freq[keys[0]] < freq[keys[1]]:
    print(keys[1])
  else:
    print(keys[0])","def isprime(n):
    for i in range(2, n // 2 + 1):
        if n % i == 0:
            return False
    return True

def next_prime(n):
    # Start checking from n + 1
    candidate = n + 1
    # Find the next prime number
    while True:
        if isprime(candidate):
            return candidate
        candidate += 1

def should_wait_for_black_day(n, m):
    # Get the next prime after n
    next_p = next_prime(n)
    # Check if m is exactly the next prime after n
    return m == next_p

# Read input
n, m = map(int, input().split())
# Output result
if should_wait_for_black_day(n, m):
    print(""YES"")
else:
    print(""NO"")"
770,A,New Password,PROGRAMMING,"['*special', 'implementation']","Innokentiy decides to change the password in the social net ""Contact!"", but he is too lazy to invent a new password by himself. That is why he needs your help. 

Innokentiy decides that new password should satisfy the following conditions:
 -  the length of the password must be equal to *n*, -  the password should consist only of lowercase Latin letters, -  the number of distinct symbols in the password must be equal to *k*, -  any two consecutive symbols in the password must be distinct. 
Your task is to help Innokentiy and to invent a new password which will satisfy all given conditions.","The first line contains two positive integers *n* and *k* (2<=≤<=*n*<=≤<=100, 2<=≤<=*k*<=≤<=*min*(*n*,<=26)) — the length of the password and the number of distinct symbols in it. 

Pay attention that a desired new password always exists.",Print any password which satisfies all conditions given by Innokentiy.,"['4 3\n', '6 6\n', '5 2\n']","['java\n', 'python\n', 'phphp\n']","In the first test there is one of the appropriate new passwords — java, because its length is equal to 4 and 3 distinct lowercase letters a, j and v are used in it.

In the second test there is one of the appropriate new passwords — python, because its length is equal to 6 and it consists of 6 distinct lowercase letters.

In the third test there is one of the appropriate new passwords — phphp, because its length is equal to 5 and 2 distinct lowercase letters p and h are used in it.

Pay attention the condition that no two identical symbols are consecutive is correct for all appropriate passwords in tests.",WRONG_ANSWER,"inp = input()

inp = inp.split()

if inp[0]== ""4"" and inp[-1] == ""3"":
    print(""java"")
elif inp[0] == ""6"" and inp[-1] == ""6"":
    print(""python"")
elif inp[0] == ""5"" and inp[-1] == ""2"":
    print(""phphp"")


","def main():
    N, K = map(int, input().split())
    
    # Calculate the minimum multiplier to make n end with at least k zeros
    multiplier = 10 ** K
    
    # Find the smallest x such that x is divisible by N and x >= multiplier
    # Start from the smallest multiple of N that is greater than or equal to multiplier
    if multiplier % N == 0:
        result = multiplier
    else:
        result = ((multiplier // N) + 1) * N
    
    # Print the result which is the k-rounding of N
    print(result)

main()"
740,A,Alyona and copybooks,PROGRAMMING,"['brute force', 'implementation']","Little girl Alyona is in a shop to buy some copybooks for school. She study four subjects so she wants to have equal number of copybooks for each of the subjects. There are three types of copybook's packs in the shop: it is possible to buy one copybook for *a* rubles, a pack of two copybooks for *b* rubles, and a pack of three copybooks for *c* rubles. Alyona already has *n* copybooks.

What is the minimum amount of rubles she should pay to buy such number of copybooks *k* that *n*<=+<=*k* is divisible by 4? There are infinitely many packs of any type in the shop. Alyona can buy packs of different type in the same purchase.","The only line contains 4 integers *n*, *a*, *b*, *c* (1<=≤<=*n*,<=*a*,<=*b*,<=*c*<=≤<=109).",Print the minimum amount of rubles she should pay to buy such number of copybooks *k* that *n*<=+<=*k* is divisible by 4.,"['1 1 3 4\n', '6 2 1 1\n', '4 4 4 4\n', '999999999 1000000000 1000000000 1000000000\n']","['3\n', '1\n', '0\n', '1000000000\n']","In the first example Alyona can buy 3 packs of 1 copybook for 3*a* = 3 rubles in total. After that she will have 4 copybooks which she can split between the subjects equally. 

In the second example Alyuna can buy a pack of 2 copybooks for *b* = 1 ruble. She will have 8 copybooks in total.

In the third example Alyona can split the copybooks she already has between the 4 subject equally, so she doesn't need to buy anything.

In the fourth example Alyona should buy one pack of one copybook.",OK,"n, a, b, c = map(int, input().split())
to_buy = (4 - (n % 4)) % 4
b = min(a * 2, b)
c = min(a * 3, a + b, c)

# possibilities:
if to_buy == 3:
    print(min(3*a, a+b, c))
elif to_buy == 2:
    print(min(2*a, b, 2*c))
elif to_buy == 1:
    print(min(a, b+c, 3*c))
else:
    print(0)
","# Author :  //- kibrom Hailu -\\

import sys

def max_watered_sections(n, heights):
    max_watered = 0

    # Function to perform DFS and count watered sections
    def dfs(index, height):
        if index < 0 or index >= n or heights[index] > height or visited[index]:
            return 0
        visited[index] = True
        count = 1  # Count the current section
        count += dfs(index - 1, height)  # Left neighbor
        count += dfs(index + 1, height)  # Right neighbor
        return count

    for i in range(n):
        visited = [False] * n
        watered_count = dfs(i, heights[i])
        max_watered = max(max_watered, watered_count)

    return max_watered

# Read inputs
n = int(sys.stdin.readline().strip())
heights = list(map(int, sys.stdin.readline().strip().split()))

# Calculate and print the result
result = max_watered_sections(n, heights)
print(result)"
673,A,Bear and Game,PROGRAMMING,['implementation'],"Bear Limak likes watching sports on TV. He is going to watch a game today. The game lasts 90 minutes and there are no breaks.

Each minute can be either interesting or boring. If 15 consecutive minutes are boring then Limak immediately turns TV off.

You know that there will be *n* interesting minutes *t*1,<=*t*2,<=...,<=*t**n*. Your task is to calculate for how many minutes Limak will watch the game.","The first line of the input contains one integer *n* (1<=≤<=*n*<=≤<=90) — the number of interesting minutes.

The second line contains *n* integers *t*1,<=*t*2,<=...,<=*t**n* (1<=≤<=*t*1<=&lt;<=*t*2<=&lt;<=... *t**n*<=≤<=90), given in the increasing order.",Print the number of minutes Limak will watch the game.,"['3\n7 20 88\n', '9\n16 20 30 40 50 60 70 80 90\n', '9\n15 20 30 40 50 60 70 80 90\n']","['35\n', '15\n', '90\n']","In the first sample, minutes 21, 22, ..., 35 are all boring and thus Limak will turn TV off immediately after the 35-th minute. So, he would watch the game for 35 minutes.

In the second sample, the first 15 minutes are boring.

In the third sample, there are no consecutive 15 boring minutes. So, Limak will watch the whole game.",OK,"n=int(input())
tl = list(map(int, input().split()))
time=cnt=0
while cnt <15 and time<90:
    time+=1
    if tl.count(time)>0:
        cnt=0
    else:
        cnt+=1
print(time)","from math import sqrt
primes = []

def initialize(MAX):
    numbers = [0] * (MAX + 1)
    numbers[1] = False
    for i in range(2, int(sqrt(MAX)) + 1):
        if numbers[i] == 0:  # If i is prime
            for j in range(i * i, MAX + 1, i):
                numbers[j] = True  # Marking multiples as not prime
            primes.append(i)
    for i in range(2, MAX + 1):
        if numbers[i] == 0:
            primes.append(i)

def max_divisor(n):
    if n <= 1:
        return 0
    for p in primes:
        if p * p > n:
            break
        if n % p == 0:
            return n // p
    return 1  # When n is prime

def minimum_tax(n):
    if n <= 2:
        return 1
    total_tax = 0
    while n > 1:
        divisor = max_divisor(n)
        total_tax += divisor
        n -= divisor
    return total_tax

# Input reading and calculation
if __name__ == ""__main__"":
    n = int(input())
    initialize(n)
    print(minimum_tax(n))"
263,A,Beautiful Matrix,PROGRAMMING,['implementation'],"You've got a 5<=×<=5 matrix, consisting of 24 zeroes and a single number one. Let's index the matrix rows by numbers from 1 to 5 from top to bottom, let's index the matrix columns by numbers from 1 to 5 from left to right. In one move, you are allowed to apply one of the two following transformations to the matrix:
 1.  Swap two neighboring matrix rows, that is, rows with indexes *i* and *i*<=+<=1 for some integer *i* (1<=≤<=*i*<=&lt;<=5). 1.  Swap two neighboring matrix columns, that is, columns with indexes *j* and *j*<=+<=1 for some integer *j* (1<=≤<=*j*<=&lt;<=5). 
You think that a matrix looks beautiful, if the single number one of the matrix is located in its middle (in the cell that is on the intersection of the third row and the third column). Count the minimum number of moves needed to make the matrix beautiful.","The input consists of five lines, each line contains five integers: the *j*-th integer in the *i*-th line of the input represents the element of the matrix that is located on the intersection of the *i*-th row and the *j*-th column. It is guaranteed that the matrix consists of 24 zeroes and a single number one.",Print a single integer — the minimum number of moves needed to make the matrix beautiful.,"['0 0 0 0 0\n0 0 0 0 1\n0 0 0 0 0\n0 0 0 0 0\n0 0 0 0 0\n', '0 0 0 0 0\n0 0 0 0 0\n0 1 0 0 0\n0 0 0 0 0\n0 0 0 0 0\n']","['3\n', '1\n']",none,WRONG_ANSWER,"ls=[list(map(int,input().split())) for i in range(5)]
a = []
for x in range(len(ls)):
    for y in range(len(ls[x])):
        a.append(ls[x][y])
print(abs(12 - a.index(1)))","#!/usr/bin/env python
from collections import defaultdict

n = int(input())
a = list(map(int, input().split()))
b = list(map(int, input().split()))

# Create a set of the required colors from both sequences
needed_colors = set(range(1, n + 1))
a_colors = set(a)
b_colors = set(b)

# Find the colors that are present in a and b
excluded_color_a = (needed_colors - a_colors).pop()
excluded_color_b = (needed_colors - b_colors).pop()

# Create the permutation by starting with all colors
permutation = list(range(1, n + 1))

# Replace one position with the excluded colors
permutation[permutation.index(excluded_color_a)] = excluded_color_b
permutation[permutation.index(excluded_color_b)] = excluded_color_a

print("" "".join(map(str, permutation)))"
0,none,none,none,['none'],"Santa Claus decided to disassemble his keyboard to clean it. After he returned all the keys back, he suddenly realized that some pairs of keys took each other's place! That is, Santa suspects that each key is either on its place, or on the place of another key, which is located exactly where the first key should be. 

In order to make sure that he's right and restore the correct order of keys, Santa typed his favorite patter looking only to his keyboard.

You are given the Santa's favorite patter and the string he actually typed. Determine which pairs of keys could be mixed. Each key must occur in pairs at most once.","The input consists of only two strings *s* and *t* denoting the favorite Santa's patter and the resulting string. *s* and *t* are not empty and have the same length, which is at most 1000. Both strings consist only of lowercase English letters.","If Santa is wrong, and there is no way to divide some of keys into pairs and swap keys in each pair so that the keyboard will be fixed, print «-1» (without quotes).

Otherwise, the first line of output should contain the only integer *k* (*k*<=≥<=0) — the number of pairs of keys that should be swapped. The following *k* lines should contain two space-separated letters each, denoting the keys which should be swapped. All printed letters must be distinct.

If there are several possible answers, print any of them. You are free to choose the order of the pairs and the order of keys in a pair.

Each letter must occur at most once. Santa considers the keyboard to be fixed if he can print his favorite patter without mistakes.","['helloworld\nehoolwlroz\n', 'hastalavistababy\nhastalavistababy\n', 'merrychristmas\nchristmasmerry\n']","['3\nh e\nl o\nd z\n', '0\n', '-1\n']",none,OK,"s = input()
t = input()
d, u = set(), set()
for i in range(len(s)):
    mn, mx = min(s[i], t[i]), max(s[i], t[i])
    if (s[i] in u or t[i] in u) and (mn, mx) not in d:
        print(-1)
        exit()
    u.add(s[i])
    u.add(t[i])
    d.add((mn, mx))

res = [x for x in d if x[0] != x[1]]
print(len(res))
for i in res:
    print(*i)
","def dist(A, B):
    res = 0
    for i in range(len(A)):
        if(A[i] != B[i]):
            res += 1
    return res

def generate_new(number):
    # Create a new list with heights adjusted to meet the condition
    return [max(1, min(k, height)) for height in number]

def min_time_to_update_trees(n, k, heights):
    # Generate the target heights
    target_heights = generate_new(heights)

    actions = []
    
    # Calculate the differences and create action list
    for i in range(n):
        if heights[i] < target_heights[i]:
            # Need to increase the height
            diff = target_heights[i] - heights[i]
            actions.append(f""+ {i + 1} {diff}"")
        elif heights[i] > target_heights[i]:
            # Need to decrease the height
            diff = heights[i] - target_heights[i]
            actions.append(f""- {i + 1} {diff}"")

    return len(actions), actions

# Reading input
n, k = map(int, input().split())
heights = list(map(int, input().split()))

# Getting the result
min_actions, actions_list = min_time_to_update_trees(n, k, heights)

# Printing the result
print(min_actions)
for action in actions_list:
    print(action)"
349,A,Cinema Line,PROGRAMMING,"['greedy', 'implementation']","The new ""Die Hard"" movie has just been released! There are *n* people at the cinema box office standing in a huge line. Each of them has a single 100, 50 or 25 ruble bill. A ""Die Hard"" ticket costs 25 rubles. Can the booking clerk sell a ticket to each person and give the change if he initially has no money and sells the tickets strictly in the order people follow in the line?","The first line contains integer *n* (1<=≤<=*n*<=≤<=105) — the number of people in the line. The next line contains *n* integers, each of them equals 25, 50 or 100 — the values of the bills the people have. The numbers are given in the order from the beginning of the line (at the box office) to the end of the line.","Print ""YES"" (without the quotes) if the booking clerk can sell a ticket to each person and give the change. Otherwise print ""NO"".","['4\n25 25 50 50\n', '2\n25 100\n', '4\n50 50 25 25\n']","['YES\n', 'NO\n', 'NO\n']",none,WRONG_ANSWER,"n=int(input())
x=list(map(int,input().split()))
s=0
flag=0
if all(x[i-1]<=x[i] for i in range(1,len(x))):
    for i in range(len(x)):
        if x[i]==25:
            s+=25
for i in range(len(x)):
    if x[i]!=25:
        r=x[i]-25
        if s>=r:
            flag=1
            s-=r
if flag==1:
    print(""YES"")
else:
    print(""NO"")
    
    
","def flag():
    n, m = map(int, input().split())
    l = [input().strip() for _ in range(n)]

    for i in range(n):
        # Check if all characters in the row are the same
        for j in range(m):
            if l[i][j] != l[i][0]:
                print(""NO"")
                return

        # Check if the current row is different from the previous row
        if i > 0 and l[i][0] == l[i - 1][0]:
            print(""NO"")
            return

    print(""YES"")

flag()"
325,A,Square and Rectangles,PROGRAMMING,['implementation'],"You are given *n* rectangles. The corners of rectangles have integer coordinates and their edges are parallel to the *Ox* and *Oy* axes. The rectangles may touch each other, but they do not overlap (that is, there are no points that belong to the interior of more than one rectangle). 

Your task is to determine if the rectangles form a square. In other words, determine if the set of points inside or on the border of at least one rectangle is precisely equal to the set of points inside or on the border of some square.","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=5). Next *n* lines contain four integers each, describing a single rectangle: *x*1, *y*1, *x*2, *y*2 (0<=≤<=*x*1<=&lt;<=*x*2<=≤<=31400,<=0<=≤<=*y*1<=&lt;<=*y*2<=≤<=31400) — *x*1 and *x*2 are *x*-coordinates of the left and right edges of the rectangle, and *y*1 and *y*2 are *y*-coordinates of the bottom and top edges of the rectangle. 

No two rectangles overlap (that is, there are no points that belong to the interior of more than one rectangle).","In a single line print ""YES"", if the given rectangles form a square, or ""NO"" otherwise.","['5\n0 0 2 3\n0 3 3 5\n2 0 5 2\n3 2 5 5\n2 2 3 3\n', '4\n0 0 2 3\n0 3 3 5\n2 0 5 2\n3 2 5 5\n']","['YES\n', 'NO\n']",none,RUNTIME_ERROR,"for i in range(int(input())):
    x1, y1, x2, y2 = map(int, input().split())
    a1, b1, a2, b2 = min(a1, x1), min(b1, y1), max(a2, x2), max(b2, y2)
    s += (x2 - x1) * (y2 - y1)
print('YES' if s == (a2 - a1) * (b2 - b1) else 'NO')","ls, ts = '<', '3'

def ch(s, f, l):
    dl = s.find(ls)
    dt = s.find(ts)
    if dt != -1 and dl != -1 and dl < dt:
        return 1
    else:
        return 0

def is_valid_message(n, words, message):
    # Create the encoded message
    encoded = ls + ts
    for word in words:
        encoded += word + ls + ts
    # Check if the message contains the encoded message structure
    # Check if each word is in the message surrounded by the hearts
    for word in words:
        start = message.find(encoded)
        if start == -1:
            return ""no""
        message = message[start+len(ls+ts):]
    return ""yes""

# Input handling
n = int(input().strip())
words = [input().strip() for _ in range(n)]
message = input().strip()

# Output the result
print(is_valid_message(n, words, message))"
0,none,none,none,['none'],"You are given two squares, one with sides parallel to the coordinate axes, and another one with sides at 45 degrees to the coordinate axes. Find whether the two squares intersect.

The interior of the square is considered to be part of the square, i.e. if one square is completely inside another, they intersect. If the two squares only share one common point, they are also considered to intersect.","The input data consists of two lines, one for each square, both containing 4 pairs of integers. Each pair represents coordinates of one vertex of the square. Coordinates within each line are either in clockwise or counterclockwise order.

The first line contains the coordinates of the square with sides parallel to the coordinate axes, the second line contains the coordinates of the square at 45 degrees.

All the values are integer and between $-100$ and $100$.","Print ""Yes"" if squares intersect, otherwise print ""No"".

You can print each letter in any case (upper or lower).","['0 0 6 0 6 6 0 6\n1 3 3 5 5 3 3 1\n', '0 0 6 0 6 6 0 6\n7 3 9 5 11 3 9 1\n', '6 0 6 6 0 6 0 0\n7 4 4 7 7 10 10 7\n']","['YES\n', 'NO\n', 'YES\n']","In the first example the second square lies entirely within the first square, so they do intersect.

In the second sample squares do not have any points in common.

Here are images corresponding to the samples:",WRONG_ANSWER,"def sor(s):
    ind=-1
    x=1000
    y=x
    for i in range(4):
        if s[i][0]+s[i][1]<x or (x==s[i][0]+s[i][1] and y>s[i][0]):
            ind=i
            x=s[i][0]+s[i][1]
            y=s[i][0]
    s=s[ind::]+s[0:ind]
    return s
def inn(s,s1):
    x=s[0][0];x1=s[2][0];y=s[0][1];y1=s[1][1]
    c1=min(s[0][0],s[1][0],s[2][0],s[3][0])
    c2=max(s[0][0],s[1][0],s[2][0],s[3][0])
    c3=min(s[0][1],s[1][1],s[2][1],s[3][1])
    c4=max(s[0][1],s[1][1],s[2][1],s[3][1])
    c=[c1+abs(c2-c1),c3+abs(c4-c3)]
    t=False
    for i in s1:
        if i[0]>=x and i[0]<=x1 and i[1]>=y and i[1]<=y1:
            t=True
            break
    if c[0]>=x and c[0]<=x1 and c[1]>=y and c[1]<=y1:
            t=True
    return t
def conv(s):
    for i in range(4):
        x=s[i][0]
        y=s[i][1]
        s[i][0]=x+y
        s[i][1]=x-y
    return s

aux=list(map(int,input().split()))
s=[]
for i in range(0,8,2):
    s.append([aux[i],aux[i+1]])
aux=list(map(int,input().split()))
s1=[]
for i in range(0,8,2):
    s1.append([aux[i],aux[i+1]])
s1=sor(s1)
s=sor(s)
t=False
if s[0][0]==s[-1][0]:
    t=True
if t:
    t1=inn(s,s1)
    s=sor(conv(s))
    s1=sor(conv(s1))
    t2=inn(s1,s)
else:
    t1=inn(s1,s)
    s=sor(conv(s))
    s1=sor(conv(s1))
    t2=inn(s,s1)
if t1 or t2:
    print(""YES"")
else:
    print(""NO"")
    
","def solve():
    global a, b, n
    now = 1e9
    
    # Iterate over possible row counts
    for i in range(1, int(n**0.5) + 1):
        if n % i == 0:  # Check if i is a divisor of n
            j = n // i  # Calculate corresponding column count
            
            # Ensure a <= b
            if i <= j:
                # Update minimum difference and dimensions
                if j - i < now:
                    now = j - i
                    a, b = i, j
    
    # Print the result as required
    print(a, b)

# Read the input
n = int(input())
a, b = 0, 0
solve()"
767,A,Snacktower,PROGRAMMING,"['data structures', 'implementation']","According to an old legeng, a long time ago Ankh-Morpork residents did something wrong to miss Fortune, and she cursed them. She said that at some time *n* snacks of distinct sizes will fall on the city, and the residents should build a Snacktower of them by placing snacks one on another. Of course, big snacks should be at the bottom of the tower, while small snacks should be at the top.

Years passed, and once different snacks started to fall onto the city, and the residents began to build the Snacktower.

However, they faced some troubles. Each day exactly one snack fell onto the city, but their order was strange. So, at some days the residents weren't able to put the new stack on the top of the Snacktower: they had to wait until all the bigger snacks fell. Of course, in order to not to anger miss Fortune again, the residents placed each snack on the top of the tower immediately as they could do it.

Write a program that models the behavior of Ankh-Morpork residents.","The first line contains single integer *n* (1<=≤<=*n*<=≤<=100<=000) — the total number of snacks.

The second line contains *n* integers, the *i*-th of them equals the size of the snack which fell on the *i*-th day. Sizes are distinct integers from 1 to *n*.","Print *n* lines. On the *i*-th of them print the sizes of the snacks which the residents placed on the top of the Snacktower on the *i*-th day in the order they will do that. If no snack is placed on some day, leave the corresponding line empty.","['3\n3 1 2\n', '5\n4 5 1 2 3\n']","['3\n\xa0\n2 1', '5 4\n\xa0\n\xa0\n3 2 1\n']","In the example a snack of size 3 fell on the first day, and the residents immediately placed it. On the second day a snack of size 1 fell, and the residents weren't able to place it because they were missing the snack of size 2. On the third day a snack of size 2 fell, and the residents immediately placed it. Right after that they placed the snack of size 1 which had fallen before.",WRONG_ANSWER,"number_snacks=int(input())
snacks=[int(x) for x in input().split()]
stack=[]
output=[]
i=0
while snacks:
    if snacks[i]==max(snacks):
        stack.append(snacks[i])
        decrease=1
        while snacks[i]-decrease in stack:
            stack.append(snacks[i]-decrease)
            output.remove(snacks[i]-decrease)
            decrease+=1
        print(*stack)
        snacks=snacks[i+1:]
        i=0
    else:
        output.append(snacks[i])
        print('')
        i+=1
    stack=[]
","# compiler on CodeForces: PyPy 3 64bit
import sys
from collections import defaultdict, deque
input = lambda: sys.stdin.readline()[:-1]
print = lambda *args: sys.stdout.write(' '.join(map(str, args)) + '\n')

graph = defaultdict(list)

n = int(input())
for _ in range(n - 1):
    x, y, t = map(int, input().split())
    graph[x].append((y, t))
    graph[y].append((x, t))

# To track candidates that need to be elected
candidates = set()

# BFS to find all problem roads
def bfs(start):
    queue = deque([start])
    visited = set([start])
    
    while queue:
        node = queue.popleft()
        for neighbor, road_type in graph[node]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
                if road_type == 2:  # problem road
                    candidates.add(neighbor)

# Start BFS from district 1
bfs(1)

# Prepare the result
result = sorted(candidates)
print(len(result))
print(*result)"
230,B,T-primes,PROGRAMMING,"['binary search', 'implementation', 'math', 'number theory']","We know that prime numbers are positive integers that have exactly two distinct positive divisors. Similarly, we'll call a positive integer *t* Т-prime, if *t* has exactly three distinct positive divisors.

You are given an array of *n* positive integers. For each of them determine whether it is Т-prime or not.","The first line contains a single positive integer, *n* (1<=≤<=*n*<=≤<=105), showing how many numbers are in the array. The next line contains *n* space-separated integers *x**i* (1<=≤<=*x**i*<=≤<=1012).

Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is advised to use the cin, cout streams or the %I64d specifier.","Print *n* lines: the *i*-th line should contain ""YES"" (without the quotes), if number *x**i* is Т-prime, and ""NO"" (without the quotes), if it isn't.",['3\n4 5 6\n'],['YES\nNO\nNO\n'],"The given test has three numbers. The first number 4 has exactly three divisors — 1, 2 and 4, thus the answer for this number is ""YES"". The second number 5 has two divisors (1 and 5), and the third number 6 has four divisors (1, 2, 3, 6), hence the answer for them is ""NO"".",TIME_LIMIT_EXCEEDED,"from math import sqrt


def primer(m: int):
    primes = [2]
    for i in range(3, m + 1, 2):
        prime = True
        for j in primes:
            if i % j == 0:
                prime = False
                break
        if prime:
            primes.append(i)
    return primes


def main():
    input()
    list_of_numbers = tuple(map(lambda x: int(sqrt(int(x))) if sqrt(int(x)).is_integer() else 1, input().split()))
    max_val = max(list_of_numbers)
    primes = primer(max_val)
    for i in list_of_numbers:
        if i == 1:
            print(""NO"")
        else:
            if i in primes:
                print(""YES"")
            else:
                print(""NO"")


if __name__ == '__main__':
    main()","n = int(input())
s = list(input())

fall_positions = 0  # Counter for positions where the ball falls out

# Check each position from 1 to n
for i in range(n):
    position = i  # Start at the current position

    # Simulate the ball's movement
    while 0 <= position < n:
        if s[position] == '>':
            position += 1  # Move right
        else:
            position -= 1  # Move left
    
    # If the position is out of bounds
    if position < 0 or position >= n:
        fall_positions += 1  # Increment fall positions counter

print(fall_positions)  # Output the total fall positions"
25,A,IQ test,PROGRAMMING,['brute force'],"Bob is preparing to pass IQ test. The most frequent task in this test is to find out which one of the given *n* numbers differs from the others. Bob observed that one number usually differs from the others in evenness. Help Bob — to check his answers, he needs a program that among the given *n* numbers finds one that is different in evenness.","The first line contains integer *n* (3<=≤<=*n*<=≤<=100) — amount of numbers in the task. The second line contains *n* space-separated natural numbers, not exceeding 100. It is guaranteed, that exactly one of these numbers differs from the others in evenness.",Output index of number that differs from the others in evenness. Numbers are numbered from 1 in the input order.,"['5\n2 4 7 8 10\n', '4\n1 2 1 1\n']","['3\n', '2\n']",none,OK,"a=int(input())
b=input().split()
s=0
t=0
for i in range(a):
    b[i]=int(b[i])%2
for i in range(a):
    if b[i]==0:
        s=s+1
    else:
        t=t+1
if s>t:
    for i in range(a):
        if b[i]==1:
            print(i+1)
else:
    for i in range(a):
        if b[i]==0:
            print(i+1)","t = int(input())
d = {}

# Iterate through the number of leaves
for _ in range(t):
    # Read the species and color of the leaf
    species, color = input().split()
    
    # Use a tuple of (species, color) as a key for the dictionary
    key = (species, color)
    
    # Add unique leaves to the dictionary
    if key not in d:
        d[key] = True

# The number of unique leaves is the size of the dictionary
print(len(d))"
116,A,Tram,PROGRAMMING,['implementation'],"Linear Kingdom has exactly one tram line. It has *n* stops, numbered from 1 to *n* in the order of tram's movement. At the *i*-th stop *a**i* passengers exit the tram, while *b**i* passengers enter it. The tram is empty before it arrives at the first stop. Also, when the tram arrives at the last stop, all passengers exit so that it becomes empty.

Your task is to calculate the tram's minimum capacity such that the number of people inside the tram at any time never exceeds this capacity. Note that at each stop all exiting passengers exit before any entering passenger enters the tram.","The first line contains a single number *n* (2<=≤<=*n*<=≤<=1000) — the number of the tram's stops. 

Then *n* lines follow, each contains two integers *a**i* and *b**i* (0<=≤<=*a**i*,<=*b**i*<=≤<=1000) — the number of passengers that exits the tram at the *i*-th stop, and the number of passengers that enter the tram at the *i*-th stop. The stops are given from the first to the last stop in the order of tram's movement.
 -  The number of people who exit at a given stop does not exceed the total number of people in the tram immediately before it arrives at the stop. More formally, . This particularly means that *a*1<==<=0. -  At the last stop, all the passengers exit the tram and it becomes empty. More formally, . -  No passenger will enter the train at the last stop. That is, *b**n*<==<=0.",Print a single integer denoting the minimum possible capacity of the tram (0 is allowed).,['4\n0 3\n2 5\n4 2\n4 0\n'],['6\n'],"For the first example, a capacity of 6 is sufficient: 
 -  At the first stop, the number of passengers inside the tram before arriving is 0. Then, 3 passengers enter the tram, and the number of passengers inside the tram becomes 3. -  At the second stop, 2 passengers exit the tram (1 passenger remains inside). Then, 5 passengers enter the tram. There are 6 passengers inside the tram now. -  At the third stop, 4 passengers exit the tram (2 passengers remain inside). Then, 2 passengers enter the tram. There are 4 passengers inside the tram now. -  Finally, all the remaining passengers inside the tram exit the tram at the last stop. There are no passenger inside the tram now, which is in line with the constraints. 
Since the number of passengers inside the tram never exceeds 6, a capacity of 6 is sufficient. Furthermore it is not possible for the tram to have a capacity less than 6. Hence, 6 is the correct answer.",RUNTIME_ERROR,"n = int(input())
post= 0
m=0
for _ in range(n):
    a,b = map(int, input().split())
    post-= a 
    post+= b 
    max_capacity = max(max_capacity, post)
print(max_capacity)
","def array(n, k, arr):
    if n == 1:
        if k == 1:
            return 1, 1
        else:
            return -1, -1

    l = 0
    r = 0
    distinct_count = 0
    count_map = {}
    
    while r < n:
        # Adding the current element to the count map
        if arr[r] in count_map:
            count_map[arr[r]] += 1
        else:
            count_map[arr[r]] = 1
            distinct_count += 1

        # When we have exactly k distinct numbers
        while distinct_count == k:
            # Check if we can update the result
            if l == 0 or (r - l + 1) < (best_r - best_l + 1):
                best_l, best_r = l, r
            
            # Try to reduce the window from the left
            count_map[arr[l]] -= 1
            if count_map[arr[l]] == 0:
                del count_map[arr[l]]
                distinct_count -= 1
            l += 1
            
        r += 1

    # If we found a valid segment
    if distinct_count == k:
        return best_l + 1, best_r + 1
    else:
        return -1, -1"
320,A,Magic Numbers,PROGRAMMING,"['brute force', 'greedy']","A magic number is a number formed by concatenation of numbers 1, 14 and 144. We can use each of these numbers any number of times. Therefore 14144, 141414 and 1411 are magic numbers but 1444, 514 and 414 are not.

You're given a number. Determine if it is a magic number or not.","The first line of input contains an integer *n*, (1<=≤<=*n*<=≤<=109). This number doesn't contain leading zeros.","Print ""YES"" if *n* is a magic number or print ""NO"" if it's not.","['114114\n', '1111\n', '441231\n']","['YES\n', 'YES\n', 'NO\n']",none,WRONG_ANSWER,"n=int(input())
n1=str(n)
k=list(n1)
i=0
flag=True
while i < len(k)-2 :
    if k[i]=='1' and k[i+1] == '4' and k[i+2]== '4':
        i+=3
    elif k[i] == '1' and k[i + 1] == '4':
        i += 2

    elif k[i] == '1' :
        i+=1
    else :
        flag=False
        break

if i == len(k)-1 :
    if k[-1]== ""1"" :
        flag=True
    else:
        flag=False
elif i == len(k)-2 :
    if k[-1] =='4' and k[-2] =='1':
        flag = True
    elif k[-1] and k[-2]=='1':
        flag= True
    else:
        flag = False

if flag == True :
    print(""YES"")
else:
    print(""NO"")","def find(n, a, b):
    # Calculate the minimum position Petr can occupy
    min_position = a + 1  # At least 'a' people in front means he can start from position 'a + 1'
    
    # Calculate the maximum position Petr can occupy
    max_position = n - b  # At most 'b' people behind means he can go up to position 'n - b'
    
    # Count the number of valid positions
    if min_position > max_position:
        return 0  # If the minimum position exceeds the maximum, there are no valid positions
    
    return max_position - min_position + 1  # Count the inclusive range of valid positions

# Read input values
n, a, b = map(int, input().strip().split())
# Call the function and print the result
print(find(n, a, b))"
822,A,I'm bored with life,PROGRAMMING,"['implementation', 'math', 'number theory']","Holidays have finished. Thanks to the help of the hacker Leha, Noora managed to enter the university of her dreams which is located in a town Pavlopolis. It's well known that universities provide students with dormitory for the period of university studies. Consequently Noora had to leave Vičkopolis and move to Pavlopolis. Thus Leha was left completely alone in a quiet town Vičkopolis. He almost even fell into a depression from boredom!

Leha came up with a task for himself to relax a little. He chooses two integers *A* and *B* and then calculates the greatest common divisor of integers ""*A* factorial"" and ""*B* factorial"". Formally the hacker wants to find out GCD(*A*!,<=*B*!). It's well known that the factorial of an integer *x* is a product of all positive integers less than or equal to *x*. Thus *x*!<==<=1·2·3·...·(*x*<=-<=1)·*x*. For example 4!<==<=1·2·3·4<==<=24. Recall that GCD(*x*,<=*y*) is the largest positive integer *q* that divides (without a remainder) both *x* and *y*.

Leha has learned how to solve this task very effective. You are able to cope with it not worse, aren't you?","The first and single line contains two integers *A* and *B* (1<=≤<=*A*,<=*B*<=≤<=109,<=*min*(*A*,<=*B*)<=≤<=12).",Print a single integer denoting the greatest common divisor of integers *A*! and *B*!.,['4 3\n'],['6\n'],"Consider the sample.

4! = 1·2·3·4 = 24. 3! = 1·2·3 = 6. The greatest common divisor of integers 24 and 6 is exactly 6.",OK,"import math
a,b=map(int,input().split())
c=min(a,b)
print(math.factorial(c))
","from typing import List, Dict

# https://codeforces.com/problemset/problem/190/D?locale=en
class Occurence:
    def __init__(self, num: int, occ: int = 1):
        self.num = num
        self.occ = occ

def count_subarrays(n: int, k: int, a: List[int]) -> int:
    count = 0
    left = 0
    freq = {}
    
    for right in range(n):
        # Count occurrences of the current number
        if a[right] in freq:
            freq[a[right]] += 1
        else:
            freq[a[right]] = 1
        
        # Check if there's any number with at least k occurrences
        while any(v >= k for v in freq.values()):
            # Count valid subarrays from left to right
            count += n - right
            
            # Move left pointer to potentially find more valid subarrays
            freq[a[left]] -= 1
            if freq[a[left]] == 0:
                del freq[a[left]]
            left += 1

    return count

# Input reading
n, k = map(int, input().split())
a = list(map(int, input().split()))

# Function calling
result = count_subarrays(n, k, a)

# Output result
print(result)"
0,none,none,none,['none'],"A bracket sequence is a string, containing only characters ""("", "")"", ""["" and ""]"".

A correct bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters ""1"" and ""+"" between the original characters of the sequence. For example, bracket sequences ""()[]"", ""([])"" are correct (the resulting expressions are: ""(1)+[1]"", ""([1+1]+1)""), and ""]("" and ""["" are not. The empty string is a correct bracket sequence by definition.

A substring *s*[*l*... *r*] (1<=≤<=*l*<=≤<=*r*<=≤<=|*s*|) of string *s*<==<=*s*1*s*2... *s*|*s*| (where |*s*| is the length of string *s*) is the string *s**l**s**l*<=+<=1... *s**r*. The empty string is a substring of any string by definition.

You are given a bracket sequence, not necessarily correct. Find its substring which is a correct bracket sequence and contains as many opening square brackets «[» as possible.","The first and the only line contains the bracket sequence as a string, consisting only of characters ""("", "")"", ""["" and ""]"". It is guaranteed that the string is non-empty and its length doesn't exceed 105 characters.",In the first line print a single integer — the number of brackets «[» in the required bracket sequence. In the second line print the optimal sequence. If there are more than one optimal solutions print any of them.,"['([])\n', '(((\n']","['1\n([])\n', '0\n\n']",none,WRONG_ANSWER,"import sys
inpu = sys.stdin.readline
prin = sys.stdout.write
s = inpu().rstrip('\n')
l = 0
stack = []
brackets = {'(', '['}
count = 0
real = ''
ans = []
for i in s :
    if i in brackets :
        stack.append(i)
        ans.append(i)
    elif len(stack) == 0:
        continue
    elif i == ']' :
        if stack[-1] == '[' :
            count += 1
            stack.pop()
            ans.append(']')
        else :
            stack = []
            if count > l :
                real = ''.join(ans)
                l = count
            ans = []
            count = 0
    else :
        if stack[-1] == '(' :
            ans.append(')')
            stack.pop()
        else :
            stack = []
            if count > l :
                real = ''.join(ans)
                l = count
            ans = []
            count = 0
if len(stack) == 0:
    if count > l :
        real = ''.join(ans)
        l = count
prin(str(l) + '\n' + real + '\n')","from collections import defaultdict

def sexy(a, b):
    # Create a dictionary to map words from the first language to the second
    language_map = {}
    
    # Fill the dictionary with the corresponding words
    for word_a, word_b in zip(a, b):
        language_map[word_a] = word_b
    
    return language_map

# Read input values
n, m = map(int, input().split())
first_language_words = []
second_language_words = []

# Reading words in both languages
for _ in range(m):
    word_a, word_b = input().split()
    first_language_words.append(word_a)
    second_language_words.append(word_b)

# Create the mapping dictionary
word_mapping = sexy(first_language_words, second_language_words)

# Read the professor's lecture words
lecture_words = input().split()

# Prepare the notes
notes = []
for word in lecture_words:
    word_in_first = word
    word_in_second = word_mapping[word]
    # Append the shorter word or the first language word in case of a tie
    if len(word_in_first) <= len(word_in_second):
        notes.append(word_in_first)
    else:
        notes.append(word_in_second)

# Output the recorded lecture
print(' '.join(notes))"
69,A,Young Physicist,PROGRAMMING,"['implementation', 'math']","A guy named Vasya attends the final grade of a high school. One day Vasya decided to watch a match of his favorite hockey team. And, as the boy loves hockey very much, even more than physics, he forgot to do the homework. Specifically, he forgot to complete his physics tasks. Next day the teacher got very angry at Vasya and decided to teach him a lesson. He gave the lazy student a seemingly easy task: You are given an idle body in space and the forces that affect it. The body can be considered as a material point with coordinates (0; 0; 0). Vasya had only to answer whether it is in equilibrium. ""Piece of cake"" — thought Vasya, we need only to check if the sum of all vectors is equal to 0. So, Vasya began to solve the problem. But later it turned out that there can be lots and lots of these forces, and Vasya can not cope without your help. Help him. Write a program that determines whether a body is idle or is moving by the given vectors of forces.","The first line contains a positive integer *n* (1<=≤<=*n*<=≤<=100), then follow *n* lines containing three integers each: the *x**i* coordinate, the *y**i* coordinate and the *z**i* coordinate of the force vector, applied to the body (<=-<=100<=≤<=*x**i*,<=*y**i*,<=*z**i*<=≤<=100).","Print the word ""YES"" if the body is in equilibrium, or the word ""NO"" if it is not.","['3\n4 1 7\n-2 4 -1\n1 -5 -3\n', '3\n3 -1 7\n-5 2 -4\n2 -1 -3\n']","['NO', 'YES']",none,WRONG_ANSWER,"n=input()
a=[]
b=[]
c=[]
for i in range(int(n)):
    (x,y,z)=input().split()
    p=a.append(x)
    q=b.append(y)
    r=c.append(z)
from functools import reduce
xcoor=reduce(lambda u,y:int(u)+int(y) , a)
ycoor=reduce(lambda u,y:int(u)+int(y) , b)
zcoor=reduce(lambda u,y:int(u)+int(y) , c)
if ((xcoor==""0"") and (ycoor==""0"") and (zcoor==""0"")):
    print(""YES"")
else:
    print(""NO"")","def StringTask(s):
    vowels = ""AEIOUYaeiouy""  # Define the vowels
    result = []  # Initialize the result list
    for char in s:  # Iterate through each character in the input string
        if char not in vowels:  # Check if the character is not a vowel
            result.append('.')  # Insert '.' before the consonant
            result.append(char.lower())  # Convert consonant to lowercase and add to result
    return ''.join(result)  # Join the list into a string and return it"
522,A,Reposts,PROGRAMMING,"['*special', 'dfs and similar', 'dp', 'graphs', 'trees']","One day Polycarp published a funny picture in a social network making a poll about the color of his handle. Many of his friends started reposting Polycarp's joke to their news feed. Some of them reposted the reposts and so on.

These events are given as a sequence of strings ""name1 reposted name2"", where name1 is the name of the person who reposted the joke, and name2 is the name of the person from whose news feed the joke was reposted. It is guaranteed that for each string ""name1 reposted name2"" user ""name1"" didn't have the joke in his feed yet, and ""name2"" already had it in his feed by the moment of repost. Polycarp was registered as ""Polycarp"" and initially the joke was only in his feed.

Polycarp measures the popularity of the joke as the length of the largest repost chain. Print the popularity of Polycarp's joke.","The first line of the input contains integer *n* (1<=≤<=*n*<=≤<=200) — the number of reposts. Next follow the reposts in the order they were made. Each of them is written on a single line and looks as ""name1 reposted name2"". All the names in the input consist of lowercase or uppercase English letters and/or digits and have lengths from 2 to 24 characters, inclusive.

We know that the user names are case-insensitive, that is, two names that only differ in the letter case correspond to the same social network user.",Print a single integer — the maximum length of a repost chain.,"['5\ntourist reposted Polycarp\nPetr reposted Tourist\nWJMZBMR reposted Petr\nsdya reposted wjmzbmr\nvepifanov reposted sdya\n', '6\nMike reposted Polycarp\nMax reposted Polycarp\nEveryOne reposted Polycarp\n111 reposted Polycarp\nVkCup reposted Polycarp\nCodeforces reposted Polycarp\n', '1\nSoMeStRaNgEgUe reposted PoLyCaRp\n']","['6\n', '2\n', '2\n']",none,WRONG_ANSWER,"n=int(input())
a=[[""polycarp""]]
m=1
for _ in range(n):
    s=input().split()
    want=s[-1].lower()
    l=len(a)
    for i in range(l):
        if a[i][-1]==want:
            a[i].append(s[0].lower())
            l1=len(a[i])
            if l1>m:
                m=l1
print(m)
","n = int(input())
lengths = list(map(int, input().split()))
costs = list(map(int, input().split()))

sum = 0
length_to_sum = {}
length_to_count = {}
cost_to_lengths = {}

for i in range(n):
    if lengths[i] not in length_to_sum:
        length_to_sum[lengths[i]] = 0
        length_to_count[lengths[i]] = 0
    length_to_sum[lengths[i]] += costs[i]
    length_to_count[lengths[i]] += 1

max_length = max(lengths)
needed_count = (n // 2) + 1  # More than half

if n == 1:
    print(0)  # One leg is always stable
else:
    costs_to_remove = []
    for length in length_to_count:
        if length == max_length:
            current_count = length_to_count[length]
            if current_count >= needed_count:
                print(0)  # Already stable
                exit()
            else:
                needed_removals = needed_count - current_count
                costs_to_remove.append((length_to_sum[length], needed_removals))  # (cost, count)
        else:
            costs_to_remove.append((length_to_sum[length], length_to_count[length]))  # (cost, count)

    costs_to_remove.sort()  # Sort removals by cost
    
    removed_count = 0
    total_cost = 0
    for cost, count in costs_to_remove:
        if removed_count >= needed_count:
            break
        # Remove the necessary number of legs from this length
        total_cost += cost
        removed_count += count

    print(total_cost)"
149,A,Business trip,PROGRAMMING,"['greedy', 'implementation', 'sortings']","What joy! Petya's parents went on a business trip for the whole year and the playful kid is left all by himself. Petya got absolutely happy. He jumped on the bed and threw pillows all day long, until... 

Today Petya opened the cupboard and found a scary note there. His parents had left him with duties: he should water their favourite flower all year, each day, in the morning, in the afternoon and in the evening. ""Wait a second!"" — thought Petya. He know for a fact that if he fulfills the parents' task in the *i*-th (1<=≤<=*i*<=≤<=12) month of the year, then the flower will grow by *a**i* centimeters, and if he doesn't water the flower in the *i*-th month, then the flower won't grow this month. Petya also knows that try as he might, his parents won't believe that he has been watering the flower if it grows strictly less than by *k* centimeters. 

Help Petya choose the minimum number of months when he will water the flower, given that the flower should grow no less than by *k* centimeters.",The first line contains exactly one integer *k* (0<=≤<=*k*<=≤<=100). The next line contains twelve space-separated integers: the *i*-th (1<=≤<=*i*<=≤<=12) number in the line represents *a**i* (0<=≤<=*a**i*<=≤<=100).,"Print the only integer — the minimum number of months when Petya has to water the flower so that the flower grows no less than by *k* centimeters. If the flower can't grow by *k* centimeters in a year, print -1.","['5\n1 1 1 1 2 2 3 2 2 1 1 1\n', '0\n0 0 0 0 0 0 0 1 1 2 3 0\n', '11\n1 1 4 1 1 5 1 1 4 1 1 1\n']","['2\n', '0\n', '3\n']","Let's consider the first sample test. There it is enough to water the flower during the seventh and the ninth month. Then the flower grows by exactly five centimeters.

In the second sample Petya's parents will believe him even if the flower doesn't grow at all (*k* = 0). So, it is possible for Petya not to water the flower at all.",WRONG_ANSWER,"n=int(input())
l=list(map(int,input().split()))
l.sort()
l=l[::-1]
sum=0
c=0
for i in range(len(l)):
    
    if(sum>=n):
        break
    sum=sum+l[i]
    c=c+1
print(c)
    
","#!/usr/bin/env python3

def main():
    n, k = map(int, input().split())
    inc = list(map(int, input().split()))
    b = sum(1 for i in inc if i < 0)  # Count negative values
    
    # Change the sign of negative numbers until we run out of k or negative numbers
    for i in range(n):
        if k > 0 and inc[i] < 0:
            inc[i] = -inc[i]  # Change the sign of negative number
            k -= 1  # Decrement k after changing sign
            
    # If we still have changes left, we need to handle positive numbers or a remaining change
    if k > 0:
        # Sort to find the smallest absolute value
        inc.sort()  # Sort the array to find the smallest to flip
        if k % 2 == 1:  # If we have an odd number of changes left
            inc[0] = -inc[0]  # Flip the smallest element
    
    # Output the maximum income after the changes
    print(sum(inc))

if __name__ == ""__main__"":
    main()"
305,B,Continued Fractions,PROGRAMMING,"['brute force', 'implementation', 'math']","A continued fraction of height *n* is a fraction of form . You are given two rational numbers, one is represented as  and the other one is represented as a finite fraction of height *n*. Check if they are equal.","The first line contains two space-separated integers *p*,<=*q* (1<=≤<=*q*<=≤<=*p*<=≤<=1018) — the numerator and the denominator of the first fraction.

The second line contains integer *n* (1<=≤<=*n*<=≤<=90) — the height of the second fraction. The third line contains *n* space-separated integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=1018) — the continued fraction.

Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.","Print ""YES"" if these fractions are equal and ""NO"" otherwise.","['9 4\n2\n2 4\n', '9 4\n3\n2 3 1\n', '9 4\n3\n1 2 4\n']","['YES\n', 'YES\n', 'NO\n']","In the first sample <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/5ff92f27aebea2560d99ad61202d20bab5ee5390.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>.

In the second sample <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/221368c79c05fc0ecad4e5f7a64f30b832fd99f5.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>.

In the third sample <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/4fb4b411afc0fbad27a1c8fdd08ba88ec3830ef5.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>.",OK,"from fractions import gcd
p,q=map(int,input().split())
gc=gcd(p,q)
p//=gc
q//=gc
n=int(input())
a=list(map(int,input().split()))
def add(a,b):
    res=[]
    a[0]*=b[1]
    b[0]*=a[1]
    temp=b[1]*a[1]
    top=a[0]+b[0]
    gc=gcd(top,temp)
    temp//=gc
    top//=gc;
    res.append(top)
    res.append(temp)
    return res
def go(i):
    res=[]
    if i==n-1:
        res.append(a[i])
        res.append(1)
        return res;    
    temp=list(go(i+1))
    temp=temp[::-1]
    ta=[]
    ta.append(a[i])
    ta.append(1)
    temp=add(ta,temp)
    return temp
res=go(0)
if(res[0]==p and res[1]==q): print(""YES"")
else:
    print(""NO"")","#panagram
n = int(input())
s = input()[:n]
alphabet = 'abcdefghijklmnopqrstuvwxyz'

# Convert the string to lowercase to handle case insensitivity
s = s.lower()

# Create a set to store unique characters from the string
unique_chars = set(s)

# Check if the unique characters contain all letters in the alphabet
if all(char in unique_chars for char in alphabet):
    print(""YES"")
else:
    print(""NO"")"
25,A,IQ test,PROGRAMMING,['brute force'],"Bob is preparing to pass IQ test. The most frequent task in this test is to find out which one of the given *n* numbers differs from the others. Bob observed that one number usually differs from the others in evenness. Help Bob — to check his answers, he needs a program that among the given *n* numbers finds one that is different in evenness.","The first line contains integer *n* (3<=≤<=*n*<=≤<=100) — amount of numbers in the task. The second line contains *n* space-separated natural numbers, not exceeding 100. It is guaranteed, that exactly one of these numbers differs from the others in evenness.",Output index of number that differs from the others in evenness. Numbers are numbered from 1 in the input order.,"['5\n2 4 7 8 10\n', '4\n1 2 1 1\n']","['3\n', '2\n']",none,RUNTIME_ERROR,"n = int(input())
m = list(map(int,input().split))
even = 0
odd = 0
for i in m:
    if i%2 == 0 :
        even += 1
    elif i%2 == 1:
        odd += 1
if even == 1:
    for i in m:
        if i%2 == 0:
            print(m.index(i))
        else:
            continue
if odd == 1:
    for i in m :
        if i%2 != 0:
            print(m.index(i))
        else:
            continue","def main():
    n = int(input())
    
    # If there are only two players, the maximum games played by the winner is 1
    if n == 2:
        print(1)
        return
    
    # The maximum number of games the winner can play in the tournament
    # can be calculated using the formula for the maximum depth of a complete binary tree
    # which is equivalent to the number of games
    max_games = 0
    
    # To find the maximum number of games possible, we find the largest k 
    # such that (2^k - 1) < n (where n is the number of players).
    while (1 << (max_games + 1)) - 1 <= n:
        max_games += 1
    
    # The answer is the maximum number of games that the winner can participate in
    print(max_games)

main()"
665,C,Simple Strings,PROGRAMMING,"['dp', 'greedy', 'strings']","zscoder loves simple strings! A string *t* is called simple if every pair of adjacent characters are distinct. For example ab, aba, zscoder are simple whereas aa, add are not simple.

zscoder is given a string *s*. He wants to change a minimum number of characters so that the string *s* becomes simple. Help him with this task!",The only line contains the string *s* (1<=≤<=|*s*|<=≤<=2·105) — the string given to zscoder. The string *s* consists of only lowercase English letters.,"Print the simple string *s*' — the string *s* after the minimal number of changes. If there are multiple solutions, you may output any of them.

Note that the string *s*' should also consist of only lowercase English letters.","['aab\n', 'caaab\n', 'zscoder\n']","['bab\n', 'cabab\n', 'zscoder\n']",none,OK,"s=list(input()+'a')
for i in range(len(s)-2):
    if s[i]==s[i+1]:
        s[i+1]=list({'a', 'b', 'c'}-{s[i]}-{s[i+2]})[0]
print(''.join(s[:-1]))
","def cool_num(n):
    a = n**0.5
    a = int(a)
    
    # Generate triangular numbers up to n
    triangular_numbers = set()
    for i in range(1, a + 1):
        tri_num = (i * (i + 1)) // 2
        if tri_num <= n:
            triangular_numbers.add(tri_num)

    # Check if two triangular numbers can sum up to n
    for t in triangular_numbers:
        if (n - t) in triangular_numbers:
            return ""YES""
    
    return ""NO""

# Read input
n = int(input())
# Print whether n can be represented as a sum of two triangular numbers
print(cool_num(n))"
765,C,Table Tennis Game 2,PROGRAMMING,['math'],"Misha and Vanya have played several table tennis sets. Each set consists of several serves, each serve is won by one of the players, he receives one point and the loser receives nothing. Once one of the players scores exactly *k* points, the score is reset and a new set begins.

Across all the sets Misha scored *a* points in total, and Vanya scored *b* points. Given this information, determine the maximum number of sets they could have played, or that the situation is impossible.

Note that the game consisted of several complete sets.","The first line contains three space-separated integers *k*, *a* and *b* (1<=≤<=*k*<=≤<=109, 0<=≤<=*a*,<=*b*<=≤<=109, *a*<=+<=*b*<=&gt;<=0).","If the situation is impossible, print a single number -1. Otherwise, print the maximum possible number of sets.","['11 11 5\n', '11 2 3\n']","['1\n', '-1\n']","Note that the rules of the game in this problem differ from the real table tennis game, for example, the rule of ""balance"" (the winning player has to be at least two points ahead to win a set) has no power within the present problem.",WRONG_ANSWER,"k,a,b = list(map(int, input().split()))
if k > a:
    if b%k == 0:
        print(b//k)
    else:
        print(-1)
if k > b:
    if a%k == 0:
        print(a//k)
    else:
        print(-1)

if a > k and b > k:
    print((a//k) + (b//k))","def sol():
    k = int(input())
    l = int(input())
    m = int(input())
    n = int(input())
    d = int(input())

    # Initialize a counter for damaged dragons
    damaged_dragons = 0
    
    # Check each dragon from 1 to d
    for i in range(1, d + 1):
        # If the dragon is damaged by any of the conditions
        if i % k == 0 or i % l == 0 or i % m == 0 or i % n == 0:
            damaged_dragons += 1

    # Output the total number of damaged dragons
    print(damaged_dragons)"
93,E,Lostborn,PROGRAMMING,"['dp', 'math', 'number theory']","Igor K. very much likes a multiplayer role playing game WineAge II. Who knows, perhaps, that might be the reason for his poor performance at the university. As any person who plays the game, he is interested in equipping his hero with as good weapon and outfit as possible. 

One day, as he was reading the game's forum yet again, he discovered a very interesting fact. As it turns out, each weapon in the game is characterised with *k* different numbers: *a*1,<=...,<=*a**k*. They are called hit indicators and according to the game developers' plan they are pairwise coprime. 

The damage that is inflicted during a hit depends not only on the weapon's characteristics, but also on the hero's strength parameter. Thus, if the hero's strength equals *n*, than the inflicted damage will be calculated as the number of numbers on the segment , that aren't divisible by any hit indicator *a**i*.

Recently, having fulfilled another quest, Igor K. found a new Lostborn sword. He wants to know how much damage he will inflict upon his enemies if he uses it.","The first line contains two integers: *n* and *k* (1<=≤<=*n*<=≤<=1013, 1<=≤<=*k*<=≤<=100). They are the indicator of Igor K's hero's strength and the number of hit indicators.

The next line contains space-separated *k* integers *a**i* (1<=≤<=*a**i*<=≤<=1000). They are Lostborn sword's hit indicators. The given *k* numbers are pairwise coprime.","Print the single number — the damage that will be inflicted by Igor K.'s hero when he uses his new weapon. 

Please, do not use the %lld specificator to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specificator.","['20 3\n2 3 5\n', '50 2\n15 8\n']","['6\n', '41\n']",none,TIME_LIMIT_EXCEEDED,"import math
iin,k = [int(x) for x in input().split(' ')]
a = [int(x) for x in input().split(' ')]
a.sort(reverse = True)
def c(n,y):
    if y == len(a)-1:
        return n-math.floor(n/a[-1])
    elif n < a[-1]:
        return n
    else:
        return c(n,y+1)-c(math.floor(n/a[y]),y+1)
if a[-1] == 1:
    print('0')
else:
    print(c(iin,0))
","str1 = input()
str2 = input()

def equality(str1, str2):
    # Base case: if strings are identical, they are equivalent
    if str1 == str2:
        return True
    
    # If the length of the strings is odd, they cannot be equivalent
    if len(str1) % 2 == 1:
        return False
    
    # Calculate mid index to split the strings into halves
    mid = len(str1) // 2
    # Split the strings into two halves
    a1, a2 = str1[:mid], str1[mid:]
    b1, b2 = str2[:mid], str2[mid:]
    
    # Check the two possible equivalencies between the halves
    return (equality(a1, b1) and equality(a2, b2)) or (equality(a1, b2) and equality(a2, b1))

# Determine if the two strings are equivalent and print the result
if equality(str1, str2):
    print(""YES"")
else:
    print(""NO"")"
845,C,Two TVs,PROGRAMMING,"['data structures', 'greedy', 'sortings']","Polycarp is a great fan of television.

He wrote down all the TV programs he is interested in for today. His list contains *n* shows, *i*-th of them starts at moment *l**i* and ends at moment *r**i*.

Polycarp owns two TVs. He can watch two different shows simultaneously with two TVs but he can only watch one show at any given moment on a single TV. If one show ends at the same moment some other show starts then you can't watch them on a single TV.

Polycarp wants to check out all *n* shows. Are two TVs enough to do so?","The first line contains one integer *n* (1<=≤<=*n*<=≤<=2·105) — the number of shows.

Each of the next *n* lines contains two integers *l**i* and *r**i* (0<=≤<=*l**i*<=&lt;<=*r**i*<=≤<=109) — starting and ending time of *i*-th show.","If Polycarp is able to check out all the shows using only two TVs then print ""YES"" (without quotes). Otherwise, print ""NO"" (without quotes).","['3\n1 2\n2 3\n4 5\n', '4\n1 2\n2 3\n2 3\n1 2\n']","['YES\n', 'NO\n']",none,WRONG_ANSWER,"n=int(input())
A=[]
for i in range(n):
    a=list(map(int,input().split()))
    A.append(a)
A.sort()
m=0
for i in range(n):
    if i>0:
        if A[i][0]>=A[i-1][1]:
            continue
        else:
            m+=1
            break
if m>0:
    print('NO')
else:
    print('YES')","#a quick function that will separate values into a list of lists
def quickseparator(i,j,k):
    a = [i,j,k]
    pos = []
    neg = []
    for n in a:
        if n > 0:
            pos.append(n)
        else:
            neg.append(n)
    return pos, neg

def max_potion_drops(n, p, q, r, a):
    # Calculate maximum values for p*a[i], q*a[j], r*a[k]
    max_p = [0] * n
    max_q = [0] * n
    max_r = [0] * n

    # Fill max_p
    for i in range(n):
        max_p[i] = max(max_p[i-1], p * a[i]) if i > 0 else p * a[i]

    # Fill max_q
    for j in range(n):
        max_q[j] = max(max_q[j-1], max_p[j] + q * a[j]) if j > 0 else max_p[j] + q * a[j]

    # Calculate the final result
    max_x = float('-inf')
    for k in range(n):
        max_x = max(max_x, max_q[k] + r * a[k])

    return max_x

# Example usage
if __name__ == ""__main__"":
    n, p, q, r = map(int, input().split())
    a = list(map(int, input().split()))
    result = max_potion_drops(n, p, q, r, a)
    print(result)"
689,A,Mike and Cellphone,PROGRAMMING,"['brute force', 'constructive algorithms', 'implementation']","While swimming at the beach, Mike has accidentally dropped his cellphone into the water. There was no worry as he bought a cheap replacement phone with an old-fashioned keyboard. The keyboard has only ten digital equal-sized keys, located in the following way:

Together with his old phone, he lost all his contacts and now he can only remember the way his fingers moved when he put some number in. One can formally consider finger movements as a sequence of vectors connecting centers of keys pressed consecutively to put in a number. For example, the finger movements for number ""586"" are the same as finger movements for number ""253"":

Mike has already put in a number by his ""finger memory"" and started calling it, so he is now worrying, can he be sure that he is calling the correct number? In other words, is there any other number, that has the same finger movements?","The first line of the input contains the only integer *n* (1<=≤<=*n*<=≤<=9) — the number of digits in the phone number that Mike put in.

The second line contains the string consisting of *n* digits (characters from '0' to '9') representing the number that Mike put in.","If there is no other phone number with the same finger movements and Mike can be sure he is calling the correct number, print ""YES"" (without quotes) in the only line.

Otherwise print ""NO"" (without quotes) in the first line.","['3\n586\n', '2\n09\n', '9\n123456789\n', '3\n911\n']","['NO\n', 'NO\n', 'YES\n', 'YES\n']",You can find the picture clarifying the first sample case in the statement above.,OK,"n = input()
s = set(map(int,input()))
if all(map(lambda x: x&s!=set(),({1,4,7,0},{3,6,9,0},{7,0,9},{1,2,3}))):
    print(""YES"")
else:
    print(""NO"")","def main():
    n, k = list(map(int, input().split()))
    arr = list(map(int, input().split()))
    
    # Pair each instrument with its index
    instruments = [(index + 1, value) for index, value in enumerate(arr)]
    
    # Sort instruments by the number of days required to learn them
    instruments.sort(key=lambda x: x[1])
    
    total_days = 0
    learned_instruments = []
    
    # Go through the sorted instruments and accumulate the learning days
    for index, days in instruments:
        if total_days + days <= k:
            total_days += days
            learned_instruments.append(index)
        else:
            break
    
    # Output the results
    print(len(learned_instruments))
    print(' '.join(map(str, learned_instruments)))

main()"
255,A,Greg's Workout,PROGRAMMING,['implementation'],"Greg is a beginner bodybuilder. Today the gym coach gave him the training plan. All it had was *n* integers *a*1,<=*a*2,<=...,<=*a**n*. These numbers mean that Greg needs to do exactly *n* exercises today. Besides, Greg should repeat the *i*-th in order exercise *a**i* times.

Greg now only does three types of exercises: ""chest"" exercises, ""biceps"" exercises and ""back"" exercises. Besides, his training is cyclic, that is, the first exercise he does is a ""chest"" one, the second one is ""biceps"", the third one is ""back"", the fourth one is ""chest"", the fifth one is ""biceps"", and so on to the *n*-th exercise.

Now Greg wonders, which muscle will get the most exercise during his training. We know that the exercise Greg repeats the maximum number of times, trains the corresponding muscle the most. Help Greg, determine which muscle will get the most training.","The first line contains integer *n* (1<=≤<=*n*<=≤<=20). The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=25) — the number of times Greg repeats the exercises.","Print word ""chest"" (without the quotes), if the chest gets the most exercise, ""biceps"" (without the quotes), if the biceps gets the most exercise and print ""back"" (without the quotes) if the back gets the most exercise.

It is guaranteed that the input is such that the answer to the problem is unambiguous.","['2\n2 8\n', '3\n5 1 10\n', '7\n3 3 2 7 9 6 8\n']","['biceps\n', 'back\n', 'chest\n']","In the first sample Greg does 2 chest, 8 biceps and zero back exercises, so the biceps gets the most exercises.

In the second sample Greg does 5 chest, 1 biceps and 10 back exercises, so the back gets the most exercises.

In the third sample Greg does 18 chest, 12 biceps and 8 back exercises, so the chest gets the most exercise.",OK,"n=int(input())
a=list(map(int,input().split("" "")))
chest=0
biceps=0
back=0
for i in range(n):
    if(i%3==0):
        chest+=a[i]
    elif(i%3==1):
        biceps+=a[i]
    elif(i%3==2):
        back+=a[i]
if(chest>biceps and chest>back):
    print(""chest"")
elif(biceps>chest and biceps>back):
    print(""biceps"")
else:
    if(back>chest and back>biceps):
        print(""back"")","from collections import defaultdict

input()

a = list(map(int, input().split()))

input()

q = list(map(int, input().split()))

# Create a list to store the ending labels of each pile
end_labels = []
current_label = 0

# Calculate the end label for each pile
for worms in a:
    current_label += worms
    end_labels.append(current_label)

# Result list to store the results for each juicy worm
results = []

# For each juicy worm, determine which pile it belongs to
for worm in q:
    # Using binary search to find the pile
    left, right = 0, len(end_labels) - 1
    while left < right:
        mid = (left + right) // 2
        if end_labels[mid] < worm:
            left = mid + 1
        else:
            right = mid
    results.append(left + 1)  # Piles are 1-indexed

# Print the results
print(""\n"".join(map(str, results)))"
39,F,Pacifist frogs,PROGRAMMING,['implementation'],"Thumbelina has had an accident. She has found herself on a little island in the middle of a swamp and wants to get to the shore very much.

One can get to the shore only by hills that are situated along a straight line that connects the little island with the shore. Let us assume that the hills are numbered from 1 to *n* and the number of a hill is equal to the distance in meters between it and the island. The distance between the *n*-th hill and the shore is also 1 meter.

Thumbelina is too small to make such jumps. Fortunately, a family of frogs living in the swamp suggests to help her. Each frog agrees to give Thumbelina a ride but Thumbelina should choose only one frog. Each frog has a certain jump length. If Thumbelina agrees to accept help from a frog whose jump length is *d*, the frog will jump from the island on the hill *d*, then — on the hill 2*d*, then 3*d* and so on until they get to the shore (i.e. find itself beyond the hill *n*).

However, there is one more problem: mosquitoes also live in the swamp. At the moment they have a siesta, and they are having a nap on some hills. If the frog jumps on a hill with a mosquito the frog will smash it. The frogs Thumbelina has met are pacifists, so they will find the death of each mosquito very much sad. Help Thumbelina choose a frog that will bring her to the shore and smash as small number of mosquitoes as possible.","The first line contains three integers *n*, *m* and *k* (1<=≤<=*n*<=≤<=109, 1<=≤<=*m*,<=*k*<=≤<=100) — the number of hills, frogs and mosquitoes respectively. The second line contains *m* integers *d**i* (1<=≤<=*d**i*<=≤<=109) — the lengths of the frogs’ jumps. The third line contains *k* integers — the numbers of the hills on which each mosquito is sleeping. No more than one mosquito can sleep on each hill. The numbers in the lines are separated by single spaces.","In the first line output the number of frogs that smash the minimal number of mosquitoes, in the second line — their numbers in increasing order separated by spaces. The frogs are numbered from 1 to *m* in the order of the jump length given in the input data.","['5 3 5\n2 3 4\n1 2 3 4 5\n', '1000000000 2 3\n2 5\n999999995 999999998 999999996\n']","['2\n2 3\n', '1\n2\n']",none,OK,"n, m, k = map(int, input().split())
x, y = n, []
a = map(int, input().split())
b = list(map(int, input().split()))
for i, d in enumerate(a):
    c = 0
    for t in b:
        if 0 == t % d:
            c += 1
    if c < x:
        x = c
        y = [i + 1]
    elif c == x:
        y += i + 1,
print(len(y))
print(' '.join(map(str, y)))
","import math

def find_counterexample(l, r):
    # We need at least three distinct numbers
    if r - l < 2:
        return -1
    
    # Check the range from l to r
    for a in range(l, r - 1):
        b = a + 1
        c = a + 2
        
        # Check if (a, b) and (b, c) are coprime
        if math.gcd(a, b) == 1 and math.gcd(b, c) == 1:
            # Check if (a, c) is not coprime
            if math.gcd(a, c) != 1:
                # Return the found counterexample
                return a, b, c
                
    return -1

# Reading input
l, r = map(int, input().split())
result = find_counterexample(l, r)

# Print the result
if result == -1:
    print(-1)
else:
    print(*result)"
664,A,Complicated GCD,PROGRAMMING,"['math', 'number theory']","Greatest common divisor *GCD*(*a*,<=*b*) of two positive integers *a* and *b* is equal to the biggest integer *d* such that both integers *a* and *b* are divisible by *d*. There are many efficient algorithms to find greatest common divisor *GCD*(*a*,<=*b*), for example, Euclid algorithm. 

Formally, find the biggest integer *d*, such that all integers *a*,<=*a*<=+<=1,<=*a*<=+<=2,<=...,<=*b* are divisible by *d*. To make the problem even more complicated we allow *a* and *b* to be up to googol, 10100 — such number do not fit even in 64-bit integer type!",The only line of the input contains two integers *a* and *b* (1<=≤<=*a*<=≤<=*b*<=≤<=10100).,Output one integer — greatest common divisor of all integers from *a* to *b* inclusive.,"['1 2\n', '61803398874989484820458683436563811772030917980576 61803398874989484820458683436563811772030917980576\n']","['1\n', '61803398874989484820458683436563811772030917980576\n']",none,WRONG_ANSWER,"import math
import sys
#from decimal import Decimal, getcontext
#getcontext().prec = 100
inputs = sys.stdin.read().splitlines()
outputs = []
ln = 0

'''

    9xZER0

'''

if __name__ == ""__main__"":

    # Inputs

    n, m = map(int, inputs[ln].split())
    # ln+=1
    # n = int(inputs[ln])
    #ln += 1
    # l = [int(i) for i in inputs[ln].split()]
    # ln += 1
    # s1 = list(inputs[ln].split(' '))
    # ln += 1
    # s2 = list(map(int,inputs[ln].split('.')))
    #s = inputs[ln]

    #########################
    #  Code Goes From Here  #
    #########################
    
    if m > n :
        n, m = m, n

    while m > 0:
        n %= m
        if m > n :
            n, m = m, n

    outputs.append(str(n))

    # output
    sys.stdout.write('\n'.join(outputs))
    # stdout.flush()
   	     			      		 	 				  	","a, b = list(map(int, input().split()))

# The greatest common divisor of all integers from a to b is simply a
# since all integers from a to b are multiples of a.
# Therefore, we can return a as the result.

print(a)"
612,A,The Text Splitting,PROGRAMMING,"['brute force', 'implementation', 'strings']","You are given the string *s* of length *n* and the numbers *p*,<=*q*. Split the string *s* to pieces of length *p* and *q*.

For example, the string ""Hello"" for *p*<==<=2, *q*<==<=3 can be split to the two strings ""Hel"" and ""lo"" or to the two strings ""He"" and ""llo"".

Note it is allowed to split the string *s* to the strings only of length *p* or to the strings only of length *q* (see the second sample test).","The first line contains three positive integers *n*,<=*p*,<=*q* (1<=≤<=*p*,<=*q*<=≤<=*n*<=≤<=100).

The second line contains the string *s* consists of lowercase and uppercase latin letters and digits.","If it's impossible to split the string *s* to the strings of length *p* and *q* print the only number ""-1"".

Otherwise in the first line print integer *k* — the number of strings in partition of *s*.

Each of the next *k* lines should contain the strings in partition. Each string should be of the length *p* or *q*. The string should be in order of their appearing in string *s* — from left to right.

If there are several solutions print any of them.","['5 2 3\nHello\n', '10 9 5\nCodeforces\n', '6 4 5\nPrivet\n', '8 1 1\nabacabac\n']","['2\nHe\nllo\n', '2\nCodef\norces\n', '-1\n', '8\na\nb\na\nc\na\nb\na\nc\n']",none,OK,"n, p, q = map(int, input().split())
s = input()
if p > q:
    p, q = q, p
for i in range(0, n + 1, q):
    if (n - i) % p == 0:
        print(i // q + (n - i) // p)
        for j in range(0, i, q):
            print(s[j:j + q])
        for j in range(i, n, p):
            print(s[j:j + p])
        exit(0)
print(-1)
","def gt(n):
    # Function to calculate factorial of a number n
    if n == 0 or n == 1:
        return 1
    result = 1
    for i in range(2, n + 1):
        result *= i
    return result

def gcd_factorials(A, B):
    # Determine the minimum of A and B, as GCD(A!, B!) = min(A, B)!
    min_ab = min(A, B)
    # GCD of A! and B! is min(A, B)!
    return gt(min_ab)

# Read input values
A, B = map(int, input().strip().split())

# Print the result of GCD of A! and B!
print(gcd_factorials(A, B))"
538,B,Quasi Binary,PROGRAMMING,"['constructive algorithms', 'dp', 'greedy', 'implementation']","A number is called quasibinary if its decimal representation contains only digits 0 or 1. For example, numbers 0, 1, 101, 110011 — are quasibinary and numbers 2, 12, 900 are not.

You are given a positive integer *n*. Represent it as a sum of minimum number of quasibinary numbers.",The first line contains a single integer *n* (1<=≤<=*n*<=≤<=106).,"In the first line print a single integer *k* — the minimum number of numbers in the representation of number *n* as a sum of quasibinary numbers.

In the second line print *k* numbers — the elements of the sum. All these numbers should be quasibinary according to the definition above, their sum should equal *n*. Do not have to print the leading zeroes in the numbers. The order of numbers doesn't matter. If there are multiple possible representations, you are allowed to print any of them.","['9\n', '32\n']","['9\n1 1 1 1 1 1 1 1 1 \n', '3\n10 11 11 \n']",none,WRONG_ANSWER,"p = int(input())
a = [int(x) for x in str(p)]
n, m = len(a), max(a)
ans = [['0'] * n for i in range(m)]
for i in range(n):
    for j in range(a[i]):
        ans[j][i] = '1'
print(m)
print(*[''.join(ans[i]) for i in range(m)])
","import sys

def solve(n):
    if n < 3:
        return 1
    # Calculate the maximum number of times presents can be given
    # Using the steps of alternating gifts (1 and 2)
    # Each pair of (1, 2) gives 3 stones and counts as 2 actions
    pairs = n // 3
    remainder = n % 3
    # Each complete pair allows for two gifts
    if remainder == 0:
        return pairs * 2
    elif remainder == 1:
        return pairs * 2 + 1
    else:  # remainder == 2
        return pairs * 2 + 1

# Read input
n = int(sys.stdin.readline().strip())
print(solve(n))"
424,B,Megacity,PROGRAMMING,"['binary search', 'greedy', 'implementation', 'sortings']","The administration of the Tomsk Region firmly believes that it's time to become a megacity (that is, get population of one million). Instead of improving the demographic situation, they decided to achieve its goal by expanding the boundaries of the city.

The city of Tomsk can be represented as point on the plane with coordinates (0; 0). The city is surrounded with *n* other locations, the *i*-th one has coordinates (*x**i*, *y**i*) with the population of *k**i* people. You can widen the city boundaries to a circle of radius *r*. In such case all locations inside the circle and on its border are included into the city.

Your goal is to write a program that will determine the minimum radius *r*, to which is necessary to expand the boundaries of Tomsk, so that it becomes a megacity.","The first line of the input contains two integers *n* and *s* (1<=≤<=*n*<=≤<=103; 1<=≤<=*s*<=&lt;<=106) — the number of locatons around Tomsk city and the population of the city. Then *n* lines follow. The *i*-th line contains three integers — the *x**i* and *y**i* coordinate values of the *i*-th location and the number *k**i* of people in it (1<=≤<=*k**i*<=&lt;<=106). Each coordinate is an integer and doesn't exceed 104 in its absolute value.

It is guaranteed that no two locations are at the same point and no location is at point (0; 0).","In the output, print ""-1"" (without the quotes), if Tomsk won't be able to become a megacity. Otherwise, in the first line print a single real number — the minimum radius of the circle that the city needs to expand to in order to become a megacity.

The answer is considered correct if the absolute or relative error don't exceed 10<=-<=6.","['4 999998\n1 1 1\n2 2 1\n3 3 1\n2 -2 1\n', '4 999998\n1 1 2\n2 2 1\n3 3 1\n2 -2 1\n', '2 1\n1 1 999997\n2 2 1\n']","['2.8284271\n', '1.4142136\n', '-1']",none,WRONG_ANSWER,"from math import*
n, s = map(int, input().split())
dist = []
for i in range(n):
    a, b, c = map(int, input().split())
    dist.append((a*a + b*b, c))
dist = sorted(dist)
i = 0
while s < 1000000 and i < n - 1:
    s += dist[0][1]
    print(s)
    i += 1
if s < 1000000:
    print(-1)
if i == 0:
    print(0)
else:
    print(sqrt(dist[i - 1][0]))
print(dist)","def build_index(s_knights, c_knights, n):
    map_ = [0]*n  # Build index sorted by strength knights list to sorted by coin amount knights list
    for ski, k1 in enumerate(s_knights):
        for cki, k2 in enumerate(c_knights):
            if k1[2] == k2[2]:
                map_[ski] = cki
    return map_

def max_coins(n, k, powers, coins):
    knights = sorted([(powers[i], coins[i], i) for i in range(n)])  # Sort by power
    coins_result = [0] * n  # Result array to store max coins for each knight

    # Loop through each knight to calculate max coins they can have
    for i in range(n):
        power, coin, original_index = knights[i]
        max_coins_kill = coin  # Start with his own coins
        
        # Iterate over the knights before the current knight in sorted order
        for j in range(1, k + 1):
            if i - j >= 0:  # Ensure not out of bounds
                max_coins_kill += knights[i - j][1]  # Add coins from the victim knight

        coins_result[original_index] = max_coins_kill  # Store result in original order

    return coins_result

# Read input values
n, k = map(int, input().split())
powers = list(map(int, input().split()))
coins = list(map(int, input().split()))

# Get the result
result = max_coins(n, k, powers, coins)

# Print the output as space-separated integers
print(' '.join(map(str, result)))"
435,B,Pasha Maximizes,PROGRAMMING,['greedy'],"Pasha has a positive integer *a* without leading zeroes. Today he decided that the number is too small and he should make it larger. Unfortunately, the only operation Pasha can do is to swap two adjacent decimal digits of the integer.

Help Pasha count the maximum number he can get if he has the time to make at most *k* swaps.",The single line contains two integers *a* and *k* (1<=≤<=*a*<=≤<=1018; 0<=≤<=*k*<=≤<=100).,Print the maximum number that Pasha can get if he makes at most *k* swaps.,"['1990 1\n', '300 0\n', '1034 2\n', '9090000078001234 6\n']","['9190\n', '300\n', '3104\n', '9907000008001234\n']",none,WRONG_ANSWER,"a, b = map(int, input().split())
num=[int(x) for x in str(a)]
k=0
yup=num
def f(o):
    x=o
    global b
    global k
    p=0
    if x.index(max(x))<=b:
        while max(x)!=x[0]:
            l = x.index(max(x))
            x[l-1], x[l] = x[l], x[l-1]
        k=b
        return x
    else:
        return x
num1=f(yup)

for i in range(len(num)-1):
    for j in range(len(num)-i-1):
        if k <= b:
            num = num
        while k<b:
            if num[j] < num[j + 1]:
                num[j], num[j + 1] = num[j + 1], num[j]
                k+=1
                j=0
            if num[j] > num[j+1]:
                j+=1
            if num[j] == num[j+1]:
                j+=1



num = max(num, num1)



print(''.join(map(str, num)))","import functools
import time

def timer(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        stime = time.perf_counter()
        res = func(*args, **kwargs)
        etime = time.perf_counter()
        print(f""Function '{func.__name__}' executed in {etime - stime:.4f} seconds."")
        return res
    return wrapper

@timer
def count_robot_pairs(n, a):
    # Create a set to store unique numbers in the row
    unique_numbers = set(a)
    # Initialize a dictionary to store the first occurrence of each number
    left_position = {}
    right_position = {}
    
    # Find the first position from the left for each number
    for i in range(n):
        if a[i] not in left_position:
            left_position[a[i]] = i
    
    # Find the first position from the right for each number
    for i in range(n-1, -1, -1):
        if a[i] not in right_position:
            right_position[a[i]] = i

    # Total pairs count
    total_pairs = 0
    
    # For each unique number, calculate pairs
    for p in unique_numbers:
        if p in left_position:
            for q in unique_numbers:
                if q in right_position and left_position[p] < right_position[q]:
                    total_pairs += 1

    return total_pairs

# Example input
n = int(input())
a = list(map(int, input().split()))
print(count_robot_pairs(n, a))"
591,A,Wizards' Duel,PROGRAMMING,"['implementation', 'math']","Harry Potter and He-Who-Must-Not-Be-Named engaged in a fight to the death once again. This time they are located at opposite ends of the corridor of length *l*. Two opponents simultaneously charge a deadly spell in the enemy. We know that the impulse of Harry's magic spell flies at a speed of *p* meters per second, and the impulse of You-Know-Who's magic spell flies at a speed of *q* meters per second.

The impulses are moving through the corridor toward each other, and at the time of the collision they turn round and fly back to those who cast them without changing their original speeds. Then, as soon as the impulse gets back to it's caster, the wizard reflects it and sends again towards the enemy, without changing the original speed of the impulse.

Since Harry has perfectly mastered the basics of magic, he knows that after the second collision both impulses will disappear, and a powerful explosion will occur exactly in the place of their collision. However, the young wizard isn't good at math, so he asks you to calculate the distance from his position to the place of the second meeting of the spell impulses, provided that the opponents do not change positions during the whole fight.","The first line of the input contains a single integer *l* (1<=≤<=*l*<=≤<=1<=000) — the length of the corridor where the fight takes place.

The second line contains integer *p*, the third line contains integer *q* (1<=≤<=*p*,<=*q*<=≤<=500) — the speeds of magical impulses for Harry Potter and He-Who-Must-Not-Be-Named, respectively.","Print a single real number — the distance from the end of the corridor, where Harry is located, to the place of the second meeting of the spell impulses. Your answer will be considered correct if its absolute or relative error will not exceed 10<=-<=4. 

Namely: let's assume that your answer equals *a*, and the answer of the jury is *b*. The checker program will consider your answer correct if .","['100\n50\n50\n', '199\n60\n40\n']","['50\n', '119.4\n']","In the first sample the speeds of the impulses are equal, so both of their meetings occur exactly in the middle of the corridor.",WRONG_ANSWER,"a = int(input())
b = int(input())
c = int(input())
x = b * a /100
print(x)
 		 	 	 		  	 		  	   		    	 	","def find_coordinates(x, y):
    if x > 0:
        y2 = x1 = x + y
    else:
        y2 = x1 = x + y

    # Point A (x1, y1)
    y1 = 0

    # Point C (x2, y2)
    x2 = 0
    y2 = y + x

    return (x1, y1, x2, y2)

# Input reading
x, y = map(int, input().split())

# Finding the coordinates
x1, y1, x2, y2 = find_coordinates(x, y)

# Output the results
print(x1, y1, x2, y2)"
109,A,Lucky Sum of Digits,PROGRAMMING,"['brute force', 'implementation']","Petya loves lucky numbers. We all know that lucky numbers are the positive integers whose decimal representations contain only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.

Petya wonders eagerly what minimum lucky number has the sum of digits equal to *n*. Help him cope with the task.",The single line contains an integer *n* (1<=≤<=*n*<=≤<=106) — the sum of digits of the required lucky number.,"Print on the single line the result — the minimum lucky number, whose sum of digits equals *n*. If such number does not exist, print -1.","['11\n', '10\n']","['47\n', '-1\n']",none,WRONG_ANSWER,"n = int(input())
if(n%4==0):
    print(""4""*(n//4))
elif(n%7==0):
    print(""4""*(n//4))
else:
    c=0
    while(n>0):
        n-=4
        c+=1
        if(n%7==0):
            print(""4""*c + ""7""*(n//7))
            exit(0)
    print(-1)","def main():
    n, k = map(int, input().split())
    temperatures = list(map(int, input().split()))

    def calculate_heat_intensity(n, k, temperatures):
        prefix_sum = [0] * (n + 1)
        for i in range(1, n + 1):
            # Calculate the prefix sum
            prefix_sum[i] = prefix_sum[i - 1] + temperatures[i - 1]
        
        max_average = float('-inf')
        
        # Check all segments of length at least k
        for start in range(n):
            for end in range(start + k - 1, n):
                # Calculate the sum and average for this segment
                segment_sum = prefix_sum[end + 1] - prefix_sum[start]
                segment_length = end - start + 1
                average = segment_sum / segment_length
                
                # Update max average if this segment's average is higher
                max_average = max(max_average, average)

        return max_average

    # Get the heat intensity value
    heat_intensity = calculate_heat_intensity(n, k, temperatures)
    print(f""{heat_intensity:.10f}"")

main()"
16,B,Burglar and Matches,PROGRAMMING,"['greedy', 'implementation', 'sortings']","A burglar got into a matches warehouse and wants to steal as many matches as possible. In the warehouse there are *m* containers, in the *i*-th container there are *a**i* matchboxes, and each matchbox contains *b**i* matches. All the matchboxes are of the same size. The burglar's rucksack can hold *n* matchboxes exactly. Your task is to find out the maximum amount of matches that a burglar can carry away. He has no time to rearrange matches in the matchboxes, that's why he just chooses not more than *n* matchboxes so that the total amount of matches in them is maximal.","The first line of the input contains integer *n* (1<=≤<=*n*<=≤<=2·108) and integer *m* (1<=≤<=*m*<=≤<=20). The *i*<=+<=1-th line contains a pair of numbers *a**i* and *b**i* (1<=≤<=*a**i*<=≤<=108,<=1<=≤<=*b**i*<=≤<=10). All the input numbers are integer.",Output the only number — answer to the problem.,"['7 3\n5 10\n2 5\n3 6\n', '3 3\n1 3\n2 2\n3 1\n']","['62\n', '7\n']",none,RUNTIME_ERROR,"from collections import Counter
n, m = map(int,input().split())
p = Counter()
while m > 0:
    a,b  = map(int,input().split())
    p[b] = a
    m -= 1
s = 0
while n > 0:
    mx = max(p)
    if p[mx] > 0:
        s += mx
        p[mx] -= 1
        n -= 1
    else:
        p.pop(mx)
   #     if p[mx] == 0:
    #        break
print(s)
","from math import sqrt, acos, pi

n = int(input())
p = [tuple(map(int, input().split())) for i in range(n)]

def x_y(x, y):
    return x[0]*y[0] + x[1]*y[1] + x[2]*y[2] + x[3]*y[3] + x[4]*y[4]

def length(v):
    return sqrt(x_y(v, v))

good_points = []

for i in range(n):
    a = p[i]
    is_good = True
    for j in range(n):
        if i == j:
            continue
        for k in range(j + 1, n):
            if i == k:
                continue
            b = p[j]
            c = p[k]
            # Check if the angle between vectors ab and ac is acute
            ab = (b[0] - a[0], b[1] - a[1], b[2] - a[2], b[3] - a[3], b[4] - a[4])
            ac = (c[0] - a[0], c[1] - a[1], c[2] - a[2], c[3] - a[3], c[4] - a[4])
            if x_y(ab, ac) > 0:  # acute angle condition
                is_good = False
                break
        if not is_good:
            break
    if is_good:
        good_points.append(i + 1)  # store 1-based index

print(len(good_points))
for point in good_points:
    print(point)"
295,B,Greg and Graph,PROGRAMMING,"['dp', 'graphs', 'shortest paths']","Greg has a weighed directed graph, consisting of *n* vertices. In this graph any pair of distinct vertices has an edge between them in both directions. Greg loves playing with the graph and now he has invented a new game:
 -  The game consists of *n* steps. -  On the *i*-th step Greg removes vertex number *x**i* from the graph. As Greg removes a vertex, he also removes all the edges that go in and out of this vertex. -  Before executing each step, Greg wants to know the sum of lengths of the shortest paths between all pairs of the remaining vertices. The shortest path can go through any remaining vertex. In other words, if we assume that *d*(*i*,<=*v*,<=*u*) is the shortest path between vertices *v* and *u* in the graph that formed before deleting vertex *x**i*, then Greg wants to know the value of the following sum: . 
Help Greg, print the value of the required sum before each step.","The first line contains integer *n* (1<=≤<=*n*<=≤<=500) — the number of vertices in the graph.

Next *n* lines contain *n* integers each — the graph adjacency matrix: the *j*-th number in the *i*-th line *a**ij* (1<=≤<=*a**ij*<=≤<=105,<=*a**ii*<==<=0) represents the weight of the edge that goes from vertex *i* to vertex *j*.

The next line contains *n* distinct integers: *x*1,<=*x*2,<=...,<=*x**n* (1<=≤<=*x**i*<=≤<=*n*) — the vertices that Greg deletes.","Print *n* integers — the *i*-th number equals the required sum before the *i*-th step.

Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams of the %I64d specifier.","['1\n0\n1\n', '2\n0 5\n4 0\n1 2\n', '4\n0 3 1 1\n6 0 400 1\n2 4 0 1\n1 1 1 0\n4 1 2 3\n']","['0 ', '9 0 ', '17 23 404 0 ']",none,TIME_LIMIT_EXCEEDED,"import sys
n = int(sys.stdin.readline())
dis = [[1 << 31] * (n + 1) for _ in range(n + 1)]
for i in range(1, n + 1):
    w = map(int, sys.stdin.readline().split())
    for j, v in enumerate(w):
        dis[i][j + 1] = v
        
permutation = [0] + list(map(int, sys.stdin.readline().split()))
st = [False] * (n + 1)
sum = [0] * (n + 1)
for k in range(n, 0, -1):
    p = permutation[k]
    st[p] = True
    for i in range(1, n + 1):
        for j in range(1, n + 1):
            dis[i][j] = min(dis[i][j], dis[i][p] + dis[p][j])
    for i in range(1, n + 1):
        for j in range(1, n + 1):
            if st[i] == True and st[j] == True:
                sum[k] += dis[i][j]
for i in range(1, n + 1):
    print(sum[i], end = ' ')","import sys

def main():
    n, m = [int(f) for f in sys.stdin.readline().split()]
    
    # Calculate the heights for two-block students
    two_block_heights = {2 * i for i in range(1, n + 1)}
    
    # Calculate the heights for three-block students
    three_block_heights = {3 * i for i in range(1, m + 1)}
    
    # Combine both sets of heights
    all_heights = two_block_heights.union(three_block_heights)
    
    # Find the maximum height
    max_height = max(all_heights)
    
    print(max_height)

if __name__ == ""__main__"":
    main()"
542,C,Idempotent functions,PROGRAMMING,"['constructive algorithms', 'graphs', 'math']","Some time ago Leonid have known about idempotent functions. Idempotent function defined on a set {1,<=2,<=...,<=*n*} is such function , that for any  the formula *g*(*g*(*x*))<==<=*g*(*x*) holds.

Let's denote as *f*(*k*)(*x*) the function *f* applied *k* times to the value *x*. More formally, *f*(1)(*x*)<==<=*f*(*x*), *f*(*k*)(*x*)<==<=*f*(*f*(*k*<=-<=1)(*x*)) for each *k*<=&gt;<=1.

You are given some function . Your task is to find minimum positive integer *k* such that function *f*(*k*)(*x*) is idempotent.","In the first line of the input there is a single integer *n* (1<=≤<=*n*<=≤<=200) — the size of function *f* domain.

In the second line follow *f*(1),<=*f*(2),<=...,<=*f*(*n*) (1<=≤<=*f*(*i*)<=≤<=*n* for each 1<=≤<=*i*<=≤<=*n*), the values of a function.",Output minimum *k* such that function *f*(*k*)(*x*) is idempotent.,"['4\n1 2 2 4\n', '3\n2 3 3\n', '3\n2 3 1\n']","['1\n', '2\n', '3\n']","In the first sample test function *f*(*x*) = *f*<sup class=""upper-index"">(1)</sup>(*x*) is already idempotent since *f*(*f*(1)) = *f*(1) = 1, *f*(*f*(2)) = *f*(2) = 2, *f*(*f*(3)) = *f*(3) = 2, *f*(*f*(4)) = *f*(4) = 4.

In the second sample test: 
 -  function *f*(*x*) = *f*<sup class=""upper-index"">(1)</sup>(*x*) isn't idempotent because *f*(*f*(1)) = 3 but *f*(1) = 2; -  function *f*(*x*) = *f*<sup class=""upper-index"">(2)</sup>(*x*) is idempotent since for any *x* it is true that *f*<sup class=""upper-index"">(2)</sup>(*x*) = 3, so it is also true that *f*<sup class=""upper-index"">(2)</sup>(*f*<sup class=""upper-index"">(2)</sup>(*x*)) = 3. 
In the third sample test: 
 -  function *f*(*x*) = *f*<sup class=""upper-index"">(1)</sup>(*x*) isn't idempotent because *f*(*f*(1)) = 3 but *f*(1) = 2; -  function *f*(*f*(*x*)) = *f*<sup class=""upper-index"">(2)</sup>(*x*) isn't idempotent because *f*<sup class=""upper-index"">(2)</sup>(*f*<sup class=""upper-index"">(2)</sup>(1)) = 2 but *f*<sup class=""upper-index"">(2)</sup>(1) = 3; -  function *f*(*f*(*f*(*x*))) = *f*<sup class=""upper-index"">(3)</sup>(*x*) is idempotent since it is identity function: *f*<sup class=""upper-index"">(3)</sup>(*x*) = *x* for any <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/46a8c73444c646004dfde04451775e7af924d108.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> meaning that the formula *f*<sup class=""upper-index"">(3)</sup>(*f*<sup class=""upper-index"">(3)</sup>(*x*)) = *f*<sup class=""upper-index"">(3)</sup>(*x*) also holds.",OK,"N =int(input())
inp =input().split()
F =[0 for i in range(N)]
for i in range(N): F[i] =int(inp[i])-1

ans_small =[0 for i in range(N+1)]
for i in range(N):
	x =i
	y =i
	for j in range(N):
		x =F[x]
		y =F[F[y]]
		if x == y:
			ans_small[j+1] +=1

ans =-1
for i in range(1,N+1):
	if ans == -1:
		if ans_small[i] == N:
			ans =i

#dlhe
pw =[0 for i in range(500)]
for i in range(N):
	vis =[False for j in range(N)]
	vis[i] =True
	x =F[i]
	while vis[x] == False:
		vis[x] =True
		x =F[x]
	vis2 =[False for j in range(N)]
	vis2[x] =True
	x =F[x]
	while vis2[x] == False:
		vis2[x] =True
		x =F[x]
	c =0
	for j in range(N):
		if vis2[j]: c +=1
	j =2
	while j <= c:
		p =0
		while c%j == 0:
			c //=j
			p +=1
		pw[j] =max(pw[j],p)
		j +=1

if ans == -1:
	ans =1
	for i in range(1,500):
		for j in range(pw[i]):
			ans *=i
	ans0 =ans
	while ans <= N:
		ans +=ans0

print(ans)","# Codeforces: Restoring Painting

n, a, b, c, d = [eval(x) for x in input().split()]

# Check if a is less than d, update ab based on the conditions given
if a < d:
    ab = c + (d - a)
else:
    ab = c

# Check if b is less than c, update cd based on the conditions given
if b < c:
    cd = a + (c - b)
else:
    cd = a

# Count the number of valid squares based on constraints
count = 0
for x in range(1, n + 1):
    for y in range(1, n + 1):
        if ab + cd == d + y and ab > 0 and cd > 0:
            count += 1

# Output the result which is the count of distinct valid squares
print(count)"
227,B,Effective Approach,PROGRAMMING,['implementation'],"Once at a team training Vasya, Petya and Sasha got a problem on implementing linear search in an array.

According to the boys, linear search works as follows. The array elements in a pre-selected order are in turn compared with the number that you need to find. Once you find the array element that is equal to the required one, the search ends. The efficiency of the algorithm is the number of performed comparisons. The fewer comparisons the linear search has made, the more effective it is.

Vasya believes that a linear search would work better if it sequentially iterates through the elements, starting with the 1-st one (in this problem we consider the elements of the array indexed from 1 to *n*) and ending with the *n*-th one. And Petya says that Vasya is wrong: the search will need less comparisons if it sequentially iterates the elements starting from the *n*-th and ending with the 1-st one. Sasha argues that the two approaches are equivalent.

To finally begin the task, the teammates decided to settle the debate and compare the two approaches on an example. For this, they took an array that is a permutation of integers from 1 to *n*, and generated *m* queries of the form: find element with value *b**i* in the array. They want to calculate for both approaches how many comparisons in total the linear search will need to respond to all queries. If the first search needs fewer comparisons, then the winner of the dispute is Vasya. If the second one does, then the winner is Petya. If both approaches make the same number of comparisons, then Sasha's got the upper hand.

But the problem is, linear search is too slow. That's why the boys aren't going to find out who is right before the end of the training, unless you come in here. Help them to determine who will win the dispute.","The first line contains integer *n* (1<=≤<=*n*<=≤<=105) — the number of elements in the array. The second line contains *n* distinct space-separated integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=*n*) — the elements of array. 

The third line contains integer *m* (1<=≤<=*m*<=≤<=105) — the number of queries. The last line contains *m* space-separated integers *b*1,<=*b*2,<=...,<=*b**m* (1<=≤<=*b**i*<=≤<=*n*) — the search queries. Note that the queries can repeat.","Print two integers, showing how many comparisons Vasya's approach needs and how many comparisons Petya's approach needs. Separate the numbers by spaces.

Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use cin, cout streams or the %I64d specifier.","['2\n1 2\n1\n1\n', '2\n2 1\n1\n1\n', '3\n3 1 2\n3\n1 2 3\n']","['1 2\n', '2 1\n', '6 6\n']","In the first sample Vasya's approach will make one comparison (it starts with the 1-st element and immediately finds the required number), and Petya's approach makes two comparisons (first he compares with the 2-nd array element, doesn't find the search item and compares with the 1-st element).

In the second sample, on the contrary, Vasya's approach will need two comparisons (first with 1-st element, and then with the 2-nd), and Petya's approach will find the required value in one comparison (the first comparison with the 2-nd element).",TIME_LIMIT_EXCEEDED,"n = int(input())
l1 = list(map(int, input().split()))
l2 = l1[::-1]
#print(l1, l2)
m = int(input())
ml = list(map(int, input().split()))

count1 = 0
count2 = 0
for i in ml:
    count1 += l1.index(i) + 1
    count2 += l2.index(i) + 1

print(count1, count2)        ","def get():
    return list(map(int, input().split()))

n, m = get()
graph = [[] for _ in range(n + 1)]

# Read the edges and construct the graph
for _ in range(m):
    a, b, w = get()
    graph[a].append((b, w))
    graph[b].append((a, w))

import heapq

def dijkstra(start, end):
    distances = [float('inf')] * (n + 1)
    distances[start] = 0
    priority_queue = [(0, start)]  # (distance, vertex)
    while priority_queue:
        current_distance, current_vertex = heapq.heappop(priority_queue)

        # If we reach the end vertex, return the distance
        if current_vertex == end:
            return current_distance

        # If a longer distance is found, continue
        if current_distance > distances[current_vertex]:
            continue

        for neighbor, weight in graph[current_vertex]:
            distance = current_distance + weight

            # Only consider this new path if it's better
            if distance < distances[neighbor]:
                distances[neighbor] = distance
                heapq.heappush(priority_queue, (distance, neighbor))

    # Return -1 if no path is found
    return -1

# Get the shortest path from 1 to n
result = dijkstra(1, n)
print(result)"
89,E,Fire and Ice,PROGRAMMING,['greedy'],"The Fire Lord attacked the Frost Kingdom. He has already got to the Ice Fortress, where the Snow Queen dwells. He arranged his army on a segment *n* in length not far from the city walls. And only the frost magician Solomon can save the Frost Kingdom.

The *n*-long segment is located at a distance equal exactly to 1 from the castle walls. It can be imaginarily divided into unit segments. On some of the unit segments fire demons are located — no more than one demon per position. Each demon is characterised by his strength - by some positive integer. We can regard the fire demons being idle.

Initially Solomon is positioned on the fortress wall. He can perform the following actions several times in a row: 
-  ""L"" — Solomon shifts one unit to the left. This movement cannot be performed on the castle wall.-  ""R"" — Solomon shifts one unit to the left. This movement cannot be performed if there's no ice block to the right.-  ""A"" — If there's nothing to the right of Solomon, then Solomon creates an ice block that immediately freezes to the block that Solomon is currently standing on. If there already is an ice block, then Solomon destroys it. At that the ice blocks to the right of the destroyed one can remain but they are left unsupported. Those ice blocks fall down.
Solomon spends exactly a second on each of these actions.

As the result of Solomon's actions, ice blocks' segments fall down. When an ice block falls on a fire demon, the block evaporates and the demon's strength is reduced by 1. When the demons' strength is equal to 0, the fire demon vanishes. The picture below shows how it happens. The ice block that falls on the position with no demon, breaks into lots of tiny pieces and vanishes without hurting anybody.

Help Solomon destroy all the Fire Lord's army in minimum time.","The first line contains an integer *n* (1<=≤<=*n*<=≤<=1000). The next line contains *n* numbers, the *i*-th of them represents the strength of the fire demon standing of the *i*-th position, an integer from 1 to 100. If there's no demon on the *i*-th position, then the *i*-th number equals to 0. It is guaranteed that the input data have at least one fire demon.","Print a string of minimum length, containing characters ""L"", ""R"" and ""A"" — the succession of actions leading to the required result.

If there are several possible answers, print any of them.","['3\n1 0 1\n', '3\n0 2 0\n']","['ARARARALLLA', 'ARARALAARALA']",none,WRONG_ANSWER,"print(""_RANDOM_GUESS_1690486657.947529"")# 1690486657.9475489","import sys
import math
from collections import defaultdict, deque

def get(ind, arr):
    n = len(arr)
    for i in range(n):
        t, l, r = arr[i]
        if t == 1:  # Cyclic shift to the right
            last = arr[l - 1]  # Store the last element of the segment
            for j in range(r - l + 1):
                if j == 0:
                    arr[l - 1 + j] = arr[r]  # Move the last element to the start
                else:
                    arr[l - 1 + j] = arr[l - 1 + j - 1]  # Shift the elements to the right
            arr[r] = last  # Place the last element at the end
        elif t == 2:  # Reverse the segment
            while l < r:
                arr[l - 1], arr[r - 1] = arr[r - 1], arr[l - 1]  # Swap elements
                l += 1
                r -= 1

def main():
    input = sys.stdin.read
    data = input().splitlines()
    
    # Read n, q, m
    n, q, m = map(int, data[0].split())
    
    # Read the array a
    a = list(map(int, data[1].split()))
    
    # Read all queries
    queries = []
    for i in range(2, 2 + q):
        t, l, r = map(int, data[i].split())
        queries.append((t, l, r))
    
    # Read important indices
    important_indices = list(map(int, data[2 + q].split()))
    
    # Perform all queries on the array `a`
    get(1, queries)  # Process all queries
    
    # Output the results for important indices
    results = [a[b - 1] for b in important_indices]
    print("" "".join(map(str, results)))

if __name__ == ""__main__"":
    main()"
119,A,Epic Game,PROGRAMMING,['implementation'],"Simon and Antisimon play a game. Initially each player receives one fixed positive integer that doesn't change throughout the game. Simon receives number *a* and Antisimon receives number *b*. They also have a heap of *n* stones. The players take turns to make a move and Simon starts. During a move a player should take from the heap the number of stones equal to the greatest common divisor of the fixed number he has received and the number of stones left in the heap. A player loses when he cannot take the required number of stones (i. e. the heap has strictly less stones left than one needs to take). 

Your task is to determine by the given *a*, *b* and *n* who wins the game.","The only string contains space-separated integers *a*, *b* and *n* (1<=≤<=*a*,<=*b*,<=*n*<=≤<=100) — the fixed numbers Simon and Antisimon have received correspondingly and the initial number of stones in the pile.","If Simon wins, print ""0"" (without the quotes), otherwise print ""1"" (without the quotes).","['3 5 9\n', '1 1 100\n']","['0', '1']","The greatest common divisor of two non-negative integers *a* and *b* is such maximum positive integer *k*, that *a* is divisible by *k* without remainder and similarly, *b* is divisible by *k* without remainder. Let *gcd*(*a*, *b*) represent the operation of calculating the greatest common divisor of numbers *a* and *b*. Specifically, *gcd*(*x*, 0) = *gcd*(0, *x*) = *x*.

In the first sample the game will go like that:
-  Simon should take *gcd*(3, 9) = 3 stones from the heap. After his move the heap has 6 stones left.-  Antisimon should take *gcd*(5, 6) = 1 stone from the heap. After his move the heap has 5 stones left.-  Simon should take *gcd*(3, 5) = 1 stone from the heap. After his move the heap has 4 stones left.-  Antisimon should take *gcd*(5, 4) = 1 stone from the heap. After his move the heap has 3 stones left.-  Simon should take *gcd*(3, 3) = 3 stones from the heap. After his move the heap has 0 stones left.-  Antisimon should take *gcd*(5, 0) = 5 stones from the heap. As 0 &lt; 5, it is impossible and Antisimon loses.
In the second sample each player during each move takes one stone from the heap. As *n* is even, Antisimon takes the last stone and Simon can't make a move after that.",COMPILATION_ERROR,"l = list(map(int,input().split()))
a = l[0]
b = l[1]
n = l[2]

while:
   if math.gcd(a,n) >= n:
      n -= math.gcd(a,n)
   else:
      print(0)
      exit()
   if math.gcd(b,n) >= n:
      n -= math.gcd(b,n)
   else:
      print(1)
      exit()
      
      
      
      
      
      
      
      
    ","def main():
    sereja = 0
    dima = 0
    n = int(input())  # Read the number of cards
    cards = list(map(int, input().split()))  # Read the cards

    left = 0  # Pointer to the leftmost card
    right = n - 1  # Pointer to the rightmost card
    turn = 0  # 0 for Sereja's turn, 1 for Dima's turn

    while left <= right:
        if cards[left] > cards[right]:
            chosen_card = cards[left]
            left += 1  # Move the left pointer
        else:
            chosen_card = cards[right]
            right -= 1  # Move the right pointer
        
        if turn == 0:  # Sereja's turn
            sereja += chosen_card
        else:  # Dima's turn
            dima += chosen_card
        
        turn = 1 - turn  # Switch turns

    print(sereja, dima)  # Output the final scores

if __name__ == ""__main__"":
    main()"
723,A,The New Year: Meeting Friends,PROGRAMMING,"['implementation', 'math', 'sortings']","There are three friend living on the straight line *Ox* in Lineland. The first friend lives at the point *x*1, the second friend lives at the point *x*2, and the third friend lives at the point *x*3. They plan to celebrate the New Year together, so they need to meet at one point. What is the minimum total distance they have to travel in order to meet at some point and celebrate the New Year?

It's guaranteed that the optimal answer is always integer.","The first line of the input contains three distinct integers *x*1, *x*2 and *x*3 (1<=≤<=*x*1,<=*x*2,<=*x*3<=≤<=100) — the coordinates of the houses of the first, the second and the third friends respectively.",Print one integer — the minimum total distance the friends need to travel in order to meet together.,"['7 1 4\n', '30 20 10\n']","['6\n', '20\n']","In the first sample, friends should meet at the point 4. Thus, the first friend has to travel the distance of 3 (from the point 7 to the point 4), the second friend also has to travel the distance of 3 (from the point 1 to the point 4), while the third friend should not go anywhere because he lives at the point 4.",OK,"a = list(map(int, input().split()))
print(max(a)-min(a))
","def s(x):
    # Function to calculate the sum of digits in x
    return sum(map(int, str(x)))

def find_solutions(a, b, c):
    solutions = []
    
    # Iterate through possible values of x from 1 to 10^9
    for x in range(1, 10**9):
        # Check the equation a * x + s(x) = b * c
        if a * x + s(x) == b * c:
            solutions.append(x)
    
    # Filter solutions to ensure they are in the correct range
    solutions = [x for x in solutions if 0 < x < 10**9]
    
    # Return the number of solutions and the sorted list of solutions
    return len(solutions), sorted(solutions)

# Read inputs
a, b, c = map(int, input().split())

# Find solutions
n, solutions = find_solutions(a, b, c)

# Output results
print(n)
print(*solutions)"
245,C,Game with Coins,PROGRAMMING,['greedy'],"Two pirates Polycarpus and Vasily play a very interesting game. They have *n* chests with coins, the chests are numbered with integers from 1 to *n*. Chest number *i* has *a**i* coins. 

Polycarpus and Vasily move in turns. Polycarpus moves first. During a move a player is allowed to choose a positive integer *x* (2·*x*<=+<=1<=≤<=*n*) and take a coin from each chest with numbers *x*, 2·*x*, 2·*x*<=+<=1. It may turn out that some chest has no coins, in this case the player doesn't take a coin from this chest. The game finishes when all chests get emptied.

Polycarpus isn't a greedy scrooge. Polycarpys is a lazy slob. So he wonders in what minimum number of moves the game can finish. Help Polycarpus, determine the minimum number of moves in which the game can finish. Note that Polycarpus counts not only his moves, he also counts Vasily's moves.","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=100) — the number of chests with coins. The second line contains a sequence of space-separated integers: *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=1000), where *a**i* is the number of coins in the chest number *i* at the beginning of the game.","Print a single integer — the minimum number of moves needed to finish the game. If no sequence of turns leads to finishing the game, print -1.","['1\n1\n', '3\n1 2 3\n']","['-1\n', '3\n']","In the first test case there isn't a single move that can be made. That's why the players won't be able to empty the chests.

In the second sample there is only one possible move *x* = 1. This move should be repeated at least 3 times to empty the third chest.",WRONG_ANSWER,"n=int(input())
if n==1:
    print(-1)
    exit(0)
a=list(map(int,input().split(' ')))
a=[0]+a
# print(a)
ans=0
for i in range(1,n+1):
    if 2*i+1>n:
        continue
    if a[i]==0 or a[2*i]==0 or a[2*i+1]==0 :
        continue
    mina=min([a[i],a[2*i],a[2*i+1]])
    a[i],a[2*i],a[2*i+1]=a[i]-mina,a[2*i]-mina,a[2*i+1]-mina
    ans+=mina
# print(a)
for i in range(1,n+1):
    if 2*i+1>n:
        continue
    if a[i]>0 and a[2*i]>0:
        mina=min([a[i],a[2*i]])
        ans+=mina
        a[i],a[2*i]=a[i]-mina,a[2*i]-mina
    elif a[2*i+1]>0 and a[2*i]>0:
        mina=min([a[2*i+1],a[2*i]])
        ans+=mina
        a[2*i+1],a[2*i]=a[2*i+1]-mina,a[2*i]-mina
    elif a[2*i+1]>0 and a[i]>0:
        mina=min([a[2*i+1],a[i]])
        ans+=mina
        a[2*i+1],a[i]=a[2*i+1]-mina,a[i]-mina

for i in range(1,n+1):
    if 2*i+1>n:
        continue
    if a[i]>0:
        ans+=a[i]
        a[i]=0
    elif a[2*i]>0:
        ans+=a[2*i]
        a[2*i]=0
    elif a[2*i+1]>0:
        ans+=a[2*i+1]
        a[2*i+1]=0
for i in range(1,n+1):
    if a[i]>0:
        print(-1)
        exit(0)
print(ans)","#!/usr/bin/env python
import math,re,sys,time,heapq
from sys import exit,stdin,stdout
from collections import Counter,defaultdict,deque
from functools import reduce
input = stdin.readline
def wait():
    return time.sleep(2)

def max_points(n, a):
    # Count frequency of each number in the array
    frequency = Counter(a)
    
    # Create a list to store the maximum points
    max_points = [0] * (100001)

    # Fill in the max_points array
    for num in range(1, 100001):
        if num in frequency:
            # If current number should be considered, calculate points
            max_points[num] = max(max_points[num - 1], 
                                  max_points[num - 2] + num * frequency[num])
        else:
            # Otherwise, carry over the previous max
            max_points[num] = max_points[num - 1]

    return max_points[100000]

if __name__ == ""__main__"":
    n = int(input())
    a = list(map(int, input().split()))
    print(max_points(n, a))"
59,A,Word,PROGRAMMING,"['implementation', 'strings']","Vasya is very upset that many people on the Net mix uppercase and lowercase letters in one word. That's why he decided to invent an extension for his favorite browser that would change the letters' register in every word so that it either only consisted of lowercase letters or, vice versa, only of uppercase ones. At that as little as possible letters should be changed in the word. For example, the word HoUse must be replaced with house, and the word ViP — with VIP. If a word contains an equal number of uppercase and lowercase letters, you should replace all the letters with lowercase ones. For example, maTRIx should be replaced by matrix. Your task is to use the given method on one given word.",The first line contains a word *s* — it consists of uppercase and lowercase Latin letters and possesses the length from 1 to 100.,"Print the corrected word *s*. If the given word *s* has strictly more uppercase letters, make the word written in the uppercase register, otherwise - in the lowercase one.","['HoUse\n', 'ViP\n', 'maTRIx\n']","['house\n', 'VIP\n', 'matrix\n']",none,OK,"s = input()
n = len(s)
lower = 0
upper = 0
for i in s:
    if i.islower():
        lower+=1
    elif i.isupper():
        upper+=1

if lower >= upper:
    s = s.lower()
else:
    s= s.upper()
print(s)","# Dictionary to store the number of days in each month for the year 2016
days_in_month = {
    1: 31,  # January
    2: 29,  # February (2016 is a leap year)
    3: 31,  # March
    4: 30,  # April
    5: 31,  # May
    6: 30,  # June
    7: 31,  # July
    8: 31,  # August
    9: 30,  # September
    10: 31, # October
    11: 30, # November
    12: 31  # December
}

# Weekdays: 1-Monday, 2-Tuesday, ..., 7-Sunday
# Determine the starting weekday for January 1st, 2016
start_weekday = 5  # January 1st, 2016 is a Friday

# Read input
input_str = input().strip()

if ""of week"" in input_str:
    # Extract the day of the week
    day_of_week = int(input_str.split()[0])
    # Calculate how many times that day appears in the year 2016
    total_days = 52  # There are at least 52 of each day in a year
    # Check if that day appears an extra time
    # Calculate the weekday of January 1 for the 2016 year
    for i in range(1, 366):
        if (start_weekday + i - 1) % 7 == day_of_week % 7:
            total_days += 1
    print(total_days)

elif ""of month"" in input_str:
    # Extract the day of the month
    day_of_month = int(input_str.split()[0])
    # Count how many months have that many days
    candies = 0
    for days in days_in_month.values():
        if day_of_month <= days:
            candies += 1
    print(candies)"
137,A,Postcards and photos,PROGRAMMING,['implementation'],"Polycarpus has postcards and photos hung in a row on the wall. He decided to put them away to the closet and hang on the wall a famous painter's picture. Polycarpus does it like that: he goes from the left to the right and removes the objects consecutively. As Polycarpus doesn't want any mix-ups to happen, he will not carry in his hands objects of two different types. In other words, Polycarpus can't carry both postcards and photos simultaneously. Sometimes he goes to the closet and puts the objects there, thus leaving his hands free. Polycarpus must put all the postcards and photos to the closet. He cannot skip objects. What minimum number of times he should visit the closet if he cannot carry more than 5 items?","The only line of the input data contains a non-empty string consisting of letters ""С"" and ""P"" whose length does not exceed 100 characters. If the *i*-th character in the string is the letter ""С"", that means that the *i*-th object (the numbering goes from the left to the right) on Polycarpus' wall is a postcard. And if the *i*-th character is the letter ""P"", than the *i*-th object on the wall is a photo.",Print the only number — the minimum number of times Polycarpus has to visit the closet.,"['CPCPCPC\n', 'CCCCCCPPPPPP\n', 'CCCCCCPPCPPPPPPPPPP\n', 'CCCCCCCCCC\n']","['7\n', '4\n', '6\n', '2\n']","In the first sample Polycarpus needs to take one item to the closet 7 times.

In the second sample Polycarpus can first take 3 postcards to the closet; then 3 more. He can take the 6 photos that are left in the similar way, going to the closet twice.

In the third sample Polycarpus can visit the closet twice, both times carrying 3 postcards. Then he can take there 2 photos at once, then one postcard and finally, he can carry the last 10 photos if he visits the closet twice.

In the fourth sample Polycarpus can visit the closet twice and take there all 10 postcards (5 items during each go).",WRONG_ANSWER,"# -*- coding: utf-8 -*-
""""""
Created on Tue Apr  7 02:29:32 2020

@author: alexi
""""""



#https://codeforces.com/problemset/problem/137/A --- Alexis Galvan


def post_cards():
    
    string = input()
    
    dic = {'C':0,'P':0}
    
    output = 0
    aux = string[0]
    for i in range(len(string)):
        if string[i] != aux:
            dic[aux] = 0
            dic[string[i]] = 1
            aux = string[i]
            output += 1
        else:
            dic[string[i]] += 1
            if dic[string[i]] == 5:
                dic[string[i]] = 0
                output += 1
                
    if dic['C'] > 0 and dic['P'] == 0 or dic['P'] > 0 and dic['C'] == 0:
        output += 1
        
    return output
             
A = post_cards()
print(A)
","def isPrime(n):
    if (n <= 1):
        return False
    if (n <= 3):
        return True
    for i in range(2, int(n**0.5) + 1):
        if (n % i == 0):
            return False
    return True

def min_questions(n):
    questions = []
    
    # We start asking questions about the prime numbers
    for i in range(2, n + 1):
        if isPrime(i):
            questions.append(i)

    # At the end, the counts of questions
    print(len(questions), *questions)

# Input reading
n = int(input())
min_questions(n)"
514,A,Chewbaсca and Number,PROGRAMMING,"['greedy', 'implementation']","Luke Skywalker gave Chewbacca an integer number *x*. Chewbacca isn't good at numbers but he loves inverting digits in them. Inverting digit *t* means replacing it with digit 9<=-<=*t*. 

Help Chewbacca to transform the initial number *x* to the minimum possible positive number by inverting some (possibly, zero) digits. The decimal representation of the final number shouldn't start with a zero.",The first line contains a single integer *x* (1<=≤<=*x*<=≤<=1018) — the number that Luke Skywalker gave to Chewbacca.,Print the minimum possible positive number that Chewbacca can obtain after inverting some digits. The number shouldn't contain leading zeroes.,"['27\n', '4545\n']","['22\n', '4444\n']",none,RUNTIME_ERROR,"n=int(input())
s=str(n)
res=''
for i in range(len(s)):
    if s[i]>=5 & s[i]<9:
        res+=str(9-int(s[i]))
    else:
        res+=s[i]
print(res)","def scores():
    # Read input values for n and k
    n, k = map(int, input().split())
    # Read the scores of the participants
    scores = list(map(int, input().split()))

    # Determine the cutoff score based on the k-th place
    cutoff_score = scores[k-1] if k <= n else 0
    
    # Count how many participants advance to the next round
    advancers = sum(1 for score in scores if score >= cutoff_score and score > 0)
    
    # Output the number of participants who advance
    print(advancers)

# Call the function to execute the logic
scores()"
365,A,Good Number,PROGRAMMING,['implementation'],"Let's call a number *k*-good if it contains all digits not exceeding *k* (0,<=...,<=*k*). You've got a number *k* and an array *a* containing *n* numbers. Find out how many *k*-good numbers are in *a* (count each number every time it occurs in array *a*).","The first line contains integers *n* and *k* (1<=≤<=*n*<=≤<=100, 0<=≤<=*k*<=≤<=9). The *i*-th of the following *n* lines contains integer *a**i* without leading zeroes (1<=≤<=*a**i*<=≤<=109).",Print a single integer — the number of *k*-good numbers in *a*.,"['10 6\n1234560\n1234560\n1234560\n1234560\n1234560\n1234560\n1234560\n1234560\n1234560\n1234560\n', '2 1\n1\n10\n']","['10\n', '1\n']",none,WRONG_ANSWER,"n, k = map(int, input().split())
count = 0
for i in range(n):
    test = input()
    Mistaken = False
    for j in range(k+1):
        if test.find(str(j)) == -1:
            Mistaken = True
            break
    for l in range(k+1, 10):
        if test.find(str(l)) != -1:
            Mistaken = True
            break
    if not Mistaken:
        count += 1
print(count)
","def dfs(v):
    global used, g
    for to in g[v]:
        if used[to] == -1:
            used[to] = 1
            dfs(to)

def dfs2(v):
    global used, g, lst
    used[v] = 1
    for to in g[v]:
        if used[to] == -1:
            dfs2(to)
    lst.append(v)

def min_new_roads(n, m, s, roads):
    global used, g, lst
    g = [[] for _ in range(n + 1)]
    
    for u, v in roads:
        g[u].append(v)
    
    used = [-1] * (n + 1)
    lst = []
    
    # First DFS to find all reachable nodes from s
    used[s] = 1
    dfs(s)

    # Find all nodes not reachable from s
    not_reachable_from_s = [i for i in range(1, n + 1) if used[i] == -1]

    # Reverse the graph
    g_reversed = [[] for _ in range(n + 1)]
    for u in range(1, n + 1):
        for v in g[u]:
            g_reversed[v].append(u)

    used = [-1] * (n + 1)

    # Second DFS to find all reachable nodes from the unreachable nodes
    components = 0
    for node in not_reachable_from_s:
        if used[node] == -1:
            components += 1
            dfs2(node)

    return components

# Example of usage
n, m, s = map(int, input().split())
roads = [tuple(map(int, input().split())) for _ in range(m)]
print(min_new_roads(n, m, s, roads))"
455,A,Boredom,PROGRAMMING,['dp'],"Alex doesn't like boredom. That's why whenever he gets bored, he comes up with games. One long winter evening he came up with a game and decided to play it.

Given a sequence *a* consisting of *n* integers. The player can make several steps. In a single step he can choose an element of the sequence (let's denote it *a**k*) and delete it, at that all elements equal to *a**k*<=+<=1 and *a**k*<=-<=1 also must be deleted from the sequence. That step brings *a**k* points to the player. 

Alex is a perfectionist, so he decided to get as many points as possible. Help him.","The first line contains integer *n* (1<=≤<=*n*<=≤<=105) that shows how many numbers are in Alex's sequence. 

The second line contains *n* integers *a*1, *a*2, ..., *a**n* (1<=≤<=*a**i*<=≤<=105).",Print a single integer — the maximum number of points that Alex can earn.,"['2\n1 2\n', '3\n1 2 3\n', '9\n1 2 1 3 2 2 2 2 3\n']","['2\n', '4\n', '10\n']","Consider the third test example. At first step we need to choose any element equal to 2. After that step our sequence looks like this [2, 2, 2, 2]. Then we do 4 steps, on each step we choose any element equals to 2. In total we earn 10 points.",OK,"# -*- coding: utf-8 -*-
""""""
Created on Tue Nov 22 01:12:17 2022

@author: thinkpad
""""""

n = int(input())
a = [int(i) for i in input().split()]
s = [0]*100002
for i in a:
    s[i]+=i
res,b=0,0
for d in s:
    res,b = max(res,b),res+d
print(res)","n, s = map(int, input().split())

def digit_sum(x):
    # Calculate the sum of digits of x
    return sum(int(d) for d in str(x))

def count_really_big_numbers(n, s):
    count = 0
    for x in range(1, n + 1):
        if x - digit_sum(x) >= s:
            count += 1
    return count

# Get the count of really big numbers not greater than n
result = count_really_big_numbers(n, s)
print(result)"
637,A,Voting for Photos,PROGRAMMING,"['*special', 'constructive algorithms', 'implementation']","After celebrating the midcourse the students of one of the faculties of the Berland State University decided to conduct a vote for the best photo. They published the photos in the social network and agreed on the rules to choose a winner: the photo which gets most likes wins. If multiple photoes get most likes, the winner is the photo that gets this number first.

Help guys determine the winner photo by the records of likes.","The first line of the input contains a single integer *n* (1<=≤<=*n*<=≤<=1000) — the total likes to the published photoes. 

The second line contains *n* positive integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=1<=000<=000), where *a**i* is the identifier of the photo which got the *i*-th like.",Print the identifier of the photo which won the elections.,"['5\n1 3 2 2 1\n', '9\n100 200 300 200 100 300 300 100 200\n']","['2\n', '300\n']","In the first test sample the photo with id 1 got two likes (first and fifth), photo with id 2 got two likes (third and fourth), and photo with id 3 got one like (second). 

Thus, the winner is the photo with identifier 2, as it got:
 -  more likes than the photo with id 3; -  as many likes as the photo with id 1, but the photo with the identifier 2 got its second like earlier.",OK,"# -*- coding: utf-8 -*-
""""""
Created on Sun Mar 13 19:40:03 2016

@author: Kostya S.
""""""
from functools import cmp_to_key
n = int(input())
d = {}
a = [int(i) for i in input().split()]
for i,e in enumerate(a):
    d[e] = (i+1,1,e) if d.get(e) == None else (i+1,d[e][1] + 1,e)
t1 = sorted(list(d.values()),key = lambda x: x[1])
t2 = list(filter(lambda x: x[1] == t1[-1][1],t1))
t2 = sorted(t2,key = lambda x: x[0])
print(t2[0][-1])","from collections import Counter
from collections import deque
import sys
input = sys.stdin.readline

n, m = map(int, input().split())
grid = [[j for j in input().rstrip()] for i in range(n)]
d = Counter()

# Directions for adjacent cells (up, down, left, right)
directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]

def bfs(start_x, start_y, component_id):
    queue = deque()
    queue.append((start_x, start_y))
    size = 0
    while queue:
        x, y = queue.popleft()
        size += 1
        for dx, dy in directions:
            nx, ny = x + dx, y + dy
            if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == '.' and (nx, ny) not in d:
                d[(nx, ny)] = component_id
                queue.append((nx, ny))
    return size

# Find all connected components and their sizes
component_sizes = []
component_id = 0

for i in range(n):
    for j in range(m):
        if grid[i][j] == '.' and (i, j) not in d:
            d[(i, j)] = component_id
            size = bfs(i, j, component_id)
            component_sizes.append(size)
            component_id += 1

# Prepare the output matrix
output = [['.'] * m for _ in range(n)]

# Fill the output matrix with the sizes of connected components for impassable cells
for i in range(n):
    for j in range(m):
        if grid[i][j] == '*':
            connected_size = 1  # it counts itself
            visited = set()
            for dx, dy in directions:
                nx, ny = i + dx, j + dy
                if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == '.' and (nx, ny) in d:
                    if d[(nx, ny)] not in visited:
                        connected_size += component_sizes[d[(nx, ny)]]
                        visited.add(d[(nx, ny)])
            output[i][j] = str(connected_size % 10)

# Print the output matrix
for row in output:
    print(''.join(row))"
371,C,Hamburgers,PROGRAMMING,"['binary search', 'brute force']","Polycarpus loves hamburgers very much. He especially adores the hamburgers he makes with his own hands. Polycarpus thinks that there are only three decent ingredients to make hamburgers from: a bread, sausage and cheese. He writes down the recipe of his favorite ""Le Hamburger de Polycarpus"" as a string of letters 'B' (bread), 'S' (sausage) и 'C' (cheese). The ingredients in the recipe go from bottom to top, for example, recipe ""ВSCBS"" represents the hamburger where the ingredients go from bottom to top as bread, sausage, cheese, bread and sausage again.

Polycarpus has *n**b* pieces of bread, *n**s* pieces of sausage and *n**c* pieces of cheese in the kitchen. Besides, the shop nearby has all three ingredients, the prices are *p**b* rubles for a piece of bread, *p**s* for a piece of sausage and *p**c* for a piece of cheese.

Polycarpus has *r* rubles and he is ready to shop on them. What maximum number of hamburgers can he cook? You can assume that Polycarpus cannot break or slice any of the pieces of bread, sausage or cheese. Besides, the shop has an unlimited number of pieces of each ingredient.","The first line of the input contains a non-empty string that describes the recipe of ""Le Hamburger de Polycarpus"". The length of the string doesn't exceed 100, the string contains only letters 'B' (uppercase English B), 'S' (uppercase English S) and 'C' (uppercase English C).

The second line contains three integers *n**b*, *n**s*, *n**c* (1<=≤<=*n**b*,<=*n**s*,<=*n**c*<=≤<=100) — the number of the pieces of bread, sausage and cheese on Polycarpus' kitchen. The third line contains three integers *p**b*, *p**s*, *p**c* (1<=≤<=*p**b*,<=*p**s*,<=*p**c*<=≤<=100) — the price of one piece of bread, sausage and cheese in the shop. Finally, the fourth line contains integer *r* (1<=≤<=*r*<=≤<=1012) — the number of rubles Polycarpus has.

Please, do not write the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.","Print the maximum number of hamburgers Polycarpus can make. If he can't make any hamburger, print 0.","['BBBSSC\n6 4 1\n1 2 3\n4\n', 'BBC\n1 10 1\n1 10 1\n21\n', 'BSC\n1 1 1\n1 1 3\n1000000000000\n']","['2\n', '7\n', '200000000001\n']",none,RUNTIME_ERROR,"import time




t=int(input())

while t:
    rec=input()

    s=input().split()
    nb,ns,nc=map(int,s)
    s=input().split()
    pb,ps,pc=map(int,s)
    r=int(input())

    c={'B':0,'S':0,'C':0}

    for i in rec:
        c[i]+=1
    
    ans=0

    low,high=0,r+100

    while low<=high:

        mid = (low+high)//2

        cost=max(0,c['B']*mid-nb)*pb + max(0,c['S']*mid-ns)*ps + max(0,c['C']*mid-nc)*pc

        if cost<r:
            low=mid+1
            ans=mid
        elif cost>r:
            high=mid-1
        else:
            ans=mid
            break



    # while r>0:
    #     # print(nb,ns,nc,r)
    #     # time.sleep(1)
    #     if c['B']==0:
    #         a=float(""inf"")
    #     else:
    #         a=nb//c['B']
    #     if c['S']==0:
    #         b=float(""inf"")
    #     else:
    #         b=ns//c['S']
    #     if c['C']==0:
    #         d=float(""inf"")
    #     else:
    #         d=nc//c['C']
        
    #     minnum=min(a,b,d)

    #     # print(""minimum "",minnum,a,b,d)

    #     nb-=minnum*c['B']
    #     ns-=minnum*c['S']
    #     nc-=minnum*c['C']

    #     ans+=minnum
    #     if nb<c['B']:
    #         if pb*(c['B']-nb)<=r:
    #             r-=pb*(c['B']-nb)
    #             nb+=(c['B']-nb)
    #         else:
    #             break
        
    #     elif ns<c['S']:
    #         if ps*(c['S']-ns)<=r:
    #             r-=ps*(c['S']-ns)
    #             ns+=(c['S']-ns)
    #         else:
    #             break
    #     elif nc<c['C']:
    #         if pc*(c['C']-nc)<=r:
    #             r-=pc*(c['C']-nc)
    #             nc+=(c['C']-nc)
    #         else:
    #             break
    #     else:
    #         break


    print(ans)
    t-=1





","n, k, q = [int(x) for x in input().split()]
T = [int(x) for x in input().split()]
S = set()
for i in range(q):
    query = [int(x) for x in input().split()]
    type_query = query[0]
    id_query = query[1] - 1  # Adjusting index to be zero-based

    if type_query == 1:  # Friend id_query becomes online
        S.add(id_query)
    elif type_query == 2:  # Check whether friend id_query is displayed
        # Only need to consider the friends currently online
        online_friends = sorted([index for index in S], key=lambda x: T[x], reverse=True)[:k]
        if id_query in online_friends:
            print(""YES"")
        else:
            print(""NO"")"
437,C,The Child and Toy,PROGRAMMING,"['graphs', 'greedy', 'sortings']","On Children's Day, the child got a toy from Delayyy as a present. However, the child is so naughty that he can't wait to destroy the toy.

The toy consists of *n* parts and *m* ropes. Each rope links two parts, but every pair of parts is linked by at most one rope. To split the toy, the child must remove all its parts. The child can remove a single part at a time, and each remove consume an energy. Let's define an energy value of part *i* as *v**i*. The child spend *v**f*1<=+<=*v**f*2<=+<=...<=+<=*v**f**k* energy for removing part *i* where *f*1,<=*f*2,<=...,<=*f**k* are the parts that are directly connected to the *i*-th and haven't been removed.

Help the child to find out, what is the minimum total energy he should spend to remove all *n* parts.","The first line contains two integers *n* and *m* (1<=≤<=*n*<=≤<=1000; 0<=≤<=*m*<=≤<=2000). The second line contains *n* integers: *v*1,<=*v*2,<=...,<=*v**n* (0<=≤<=*v**i*<=≤<=105). Then followed *m* lines, each line contains two integers *x**i* and *y**i*, representing a rope from part *x**i* to part *y**i* (1<=≤<=*x**i*,<=*y**i*<=≤<=*n*; *x**i*<=≠<=*y**i*).

Consider all the parts are numbered from 1 to *n*.",Output the minimum total energy the child should spend to remove all *n* parts of the toy.,"['4 3\n10 20 30 40\n1 4\n1 2\n2 3\n', '4 4\n100 100 100 100\n1 2\n2 3\n2 4\n3 4\n', '7 10\n40 10 20 10 20 80 40\n1 5\n4 7\n4 5\n5 2\n5 7\n6 4\n1 6\n1 3\n4 3\n1 4\n']","['40\n', '400\n', '160\n']","One of the optimal sequence of actions in the first sample is:
 -  First, remove part 3, cost of the action is 20. -  Then, remove part 2, cost of the action is 10. -  Next, remove part 4, cost of the action is 10. -  At last, remove part 1, cost of the action is 0. 
So the total energy the child paid is 20 + 10 + 10 + 0 = 40, which is the minimum.

In the second sample, the child will spend 400 no matter in what order he will remove the parts.",RUNTIME_ERROR,"import sys

lines = sys.stdin.readlines()

nm = lines[0].strip().split("" "")
n = int(nm[0])
m = int(nm[1])
energies = lines[1].strip().split("" "")
energydict = {}
neighbours = {}

for i in range(1, len(energies)+1):
	energydict[i] = int(energies[i-1])

for line in lines[2:]:
	parts = line.strip().split("" "")
	if int(parts[0]) not in neighbours:
		neighbours[int(parts[0])] = set()
	if int(parts[1]) not in neighbours:
		neighbours[int(parts[1])] = set()
	neighbours[int(parts[0])].add(int(parts[1]))
	neighbours[int(parts[1])].add(int(parts[0]))

removecosts = []

for i in range(1, n+1):
	removecosts.append((i, neighbours[i]))

def energy(node):
	return energydict[node[0]]

def update_neighbours_and_del(node):
	for neighbour in node[1]:
		if node[0] in neighbours[neighbour]:
			neighbours[neighbour].remove(node[0])

	del neighbours[node[0]]

removecosts.sort(key=energy)

summa = 0

for i in range(len(removecosts)):
	popped = removecosts.pop()
	for neighbour in popped[1]:
		summa = summa + energydict[neighbour]

	update_neighbours_and_del(popped)

print(summa)","def solve():
    n, a, b = map(int, input().split())
    if a == b:
        print(f'1/{n}')
        return
    
    # Calculate the maximum steps Willman and Bolt can take
    max_steps_willman = n // a
    max_steps_bolt = n // b

    # Determine the range of steps they can take without falling
    tie_count = 0
    for i in range(max_steps_willman + 1):
        if (n - i * a) % b == 0:
            tie_count += 1

    # The total possible lengths of the racetrack is from 1 to n
    total_cases = n

    # Calculate the gcd to simplify the fraction
    from math import gcd
    common_divisor = gcd(tie_count, total_cases)

    # Print the result as an irreducible fraction
    print(f'{tie_count // common_divisor}/{total_cases // common_divisor}')"
401,A,Vanya and Cards,PROGRAMMING,"['implementation', 'math']","Vanya loves playing. He even has a special set of cards to play with. Each card has a single integer. The number on the card can be positive, negative and can even be equal to zero. The only limit is, the number on each card doesn't exceed *x* in the absolute value.

Natasha doesn't like when Vanya spends a long time playing, so she hid all of his cards. Vanya became sad and started looking for the cards but he only found *n* of them. Vanya loves the balance, so he wants the sum of all numbers on found cards equal to zero. On the other hand, he got very tired of looking for cards. Help the boy and say what is the minimum number of cards does he need to find to make the sum equal to zero?

You can assume that initially Vanya had infinitely many cards with each integer number from <=-<=*x* to *x*.",The first line contains two integers: *n* (1<=≤<=*n*<=≤<=1000) — the number of found cards and *x* (1<=≤<=*x*<=≤<=1000) — the maximum absolute value of the number on a card. The second line contains *n* space-separated integers — the numbers on found cards. It is guaranteed that the numbers do not exceed *x* in their absolute value.,Print a single number — the answer to the problem.,"['3 2\n-1 1 2\n', '2 3\n-2 -2\n']","['1\n', '2\n']","In the first sample, Vanya needs to find a single card with number -2.

In the second sample, Vanya needs to find two cards with number 2. He can't find a single card with the required number as the numbers on the lost cards do not exceed 3 in their absolute value.",WRONG_ANSWER,"word1 = input().split()
maxnum = int(word1[1])
word2 = input().split()
word2 = [ int(x) for x in word2 ]
sum1 = sum(word2)
#sum1 = abs(sum1)
final = 0
flst = []
for elm in range(min(word2),maxnum+1):
    
    if sum1 != 0 and elm !=0:
        count = 0
        while sum1 !=0:
            if sum1 %elm == 0:
                sum1 ==0 
                final = sum1 // elm
                break
            else:
                #print(sum1)
                sum1-=1
                count = 1
    #print(count)
    #print(""hehe"",abs(final))
    if count == 1:
        final = abs(final) + 1
    flst.append(abs(final))
print(flst)
print(min(flst))
","from sys import stdin

k = int(stdin.readline().rstrip())

# Start by creating an empty list to hold the characters
result = []

# Since cost is based on the frequency of characters, we can use 'a' for simplicity
# Add 'a' (k + 1) times to create the needed cost.
# This way, the concatenation process will incur the required cost when performed.
result.extend(['a'] * (k + 1))

# If the total length exceeds 100000, we can truncate the result
if len(result) > 100000:
    result = result[:100000]

# Convert the list back to a string
output = ''.join(result)

# Print the final output
print(output)"
908,A,New Year and Counting Cards,PROGRAMMING,"['brute force', 'implementation']","Your friend has *n* cards.

You know that each card has a lowercase English letter on one side and a digit on the other.

Currently, your friend has laid out the cards on a table so only one side of each card is visible.

You would like to know if the following statement is true for cards that your friend owns: ""If a card has a vowel on one side, then it has an even digit on the other side."" More specifically, a vowel is one of 'a', 'e', 'i', 'o' or 'u', and even digit is one of '0', '2', '4', '6' or '8'.

For example, if a card has 'a' on one side, and '6' on the other side, then this statement is true for it. Also, the statement is true, for example, for a card with 'b' and '4', and for a card with 'b' and '3' (since the letter is not a vowel). The statement is false, for example, for card with 'e' and '5'. You are interested if the statement is true for all cards. In particular, if no card has a vowel, the statement is true.

To determine this, you can flip over some cards to reveal the other side. You would like to know what is the minimum number of cards you need to flip in the worst case in order to verify that the statement is true.","The first and only line of input will contain a string *s* (1<=≤<=|*s*|<=≤<=50), denoting the sides of the cards that you can see on the table currently. Each character of *s* is either a lowercase English letter or a digit.","Print a single integer, the minimum number of cards you must turn over to verify your claim.","['ee\n', 'z\n', '0ay1\n']","['2\n', '0\n', '2\n']","In the first sample, we must turn over both cards. Note that even though both cards have the same letter, they could possibly have different numbers on the other side.

In the second sample, we don't need to turn over any cards. The statement is vacuously true, since you know your friend has no cards with a vowel on them.

In the third sample, we need to flip the second and fourth cards.",OK,"from sys import stdin, stdout

def need_to_check(card, vowels=['a','e','i','o','u']):
    return (ord(card) >= ord('0') and ord(card) <= ord('9') and int(card) % 2 == 1) or (card in vowels)

def number_of_reveals(cards):
    count = 0
    for card in cards:
        count = count+1 if need_to_check(card) else count
    return count

stdout.write( str(number_of_reveals(stdin.readline())) +'\n')
 	   			        		   	 	","n = int(input())

def isLuckyNumber(number):
    # Check if all digits are either 4 or 7
    while number > 0:
        digit = number % 10
        if digit != 4 and digit != 7:
            return False
        number //= 10
    return True

# Check if there is any lucky number that divides n
for lucky in range(4, n + 1):  # Lucky numbers start from 4
    if isLuckyNumber(lucky) and n % lucky == 0:
        print(""YES"")
        break
else:
    print(""NO"")"
109,A,Lucky Sum of Digits,PROGRAMMING,"['brute force', 'implementation']","Petya loves lucky numbers. We all know that lucky numbers are the positive integers whose decimal representations contain only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.

Petya wonders eagerly what minimum lucky number has the sum of digits equal to *n*. Help him cope with the task.",The single line contains an integer *n* (1<=≤<=*n*<=≤<=106) — the sum of digits of the required lucky number.,"Print on the single line the result — the minimum lucky number, whose sum of digits equals *n*. If such number does not exist, print -1.","['11\n', '10\n']","['47\n', '-1\n']",none,WRONG_ANSWER,"def func(numero, soma, digitos, n, results):
    total4 = soma+4
    total7 = soma+7

    novo = numero+4*pow(10, digitos)
    if n > total4:
        func(novo, total4, digitos+1, n, results)
    elif n < total4:
        return
    else:
        results.append(novo)

    novo = numero+7*pow(10, digitos)
    if n > total7:
        func(novo, total7, digitos+1, n, results)
    elif n < total7:
        return
    else:
        results.append(novo)



n = int(input())

if n <= 17:
    results = []

    func(0, 0, 0, n, results)

    if len(results) > 0:
        results.sort()
        print(results[0])
    else:
        print(""-1"")

else:
    resultado = 0
    if n%7 == 0:
        t = int(n/7)
        for i in range(t):
            resultado += 7*pow(10, i)
    elif n%4 == 0:
        t = int(n/4)
        for i in range(t):
            resultado += 4*pow(10, i)
    else:
        resto = n%7
        t = int(n/7)
        
        if resto == 0:
            for i in range(t):
                resultado += 7*pow(10, i)
            print(resultado)
            exit()
        elif resto == 1:
            t -= 1
            x = 2
        elif resto == 2:
            t -= 2
            x = 4
        elif resto == 3:
            t -= 3
            x = 6
        elif resto == 4:
            x = 1
        elif resto == 5:
            t -= 1
            x = 3
        elif resto == 6:
            t -= 2
            x = 5
        
        for i in range(t):
            resultado += 7*pow(10, i)

        for y in range(x):
            i += 1
            resultado += 4*pow(10, i)
    
    print(resultado)
      	  	 	  		 	 			 	   	 		","def cout(n):
    return print(n)

def cin():
    return int(input())

def lcin():
    return input().strip()

def smallest_number(n):
    # Convert the number to a list of digits
    digits = list(str(n))
    # Sort the digits to find the smallest arrangement
    digits.sort()
    # If the smallest digit is '0', we need to move it after the first non-zero digit
    if digits[0] == '0':
        # Find the first non-zero digit
        for i in range(1, len(digits)):
            if digits[i] != '0':
                # Swap
                digits[0], digits[i] = digits[i], '0'
                break
    # Join the digits back to form the smallest number
    return int(''.join(digits))

n = cin()
m = int(lcin())
# Get the smallest number possible from n
expected_m = smallest_number(n)

# Check if Bob's answer is correct
if expected_m == m:
    cout(""OK"")
else:
    cout(""WRONG_ANSWER"")"
606,A,Magic Spheres,PROGRAMMING,['implementation'],"Carl is a beginner magician. He has *a* blue, *b* violet and *c* orange magic spheres. In one move he can transform two spheres of the same color into one sphere of any other color. To make a spell that has never been seen before, he needs at least *x* blue, *y* violet and *z* orange spheres. Can he get them (possible, in multiple actions)?","The first line of the input contains three integers *a*, *b* and *c* (0<=≤<=*a*,<=*b*,<=*c*<=≤<=1<=000<=000) — the number of blue, violet and orange spheres that are in the magician's disposal.

The second line of the input contains three integers, *x*, *y* and *z* (0<=≤<=*x*,<=*y*,<=*z*<=≤<=1<=000<=000) — the number of blue, violet and orange spheres that he needs to get.","If the wizard is able to obtain the required numbers of spheres, print ""Yes"". Otherwise, print ""No"".","['4 4 0\n2 1 2\n', '5 6 1\n2 7 2\n', '3 3 3\n2 2 2\n']","['Yes\n', 'No\n', 'Yes\n']","In the first sample the wizard has 4 blue and 4 violet spheres. In his first action he can turn two blue spheres into one violet one. After that he will have 2 blue and 5 violet spheres. Then he turns 4 violet spheres into 2 orange spheres and he ends up with 2 blue, 1 violet and 2 orange spheres, which is exactly what he needs.",WRONG_ANSWER,"a,b,c = map(int, input().split())
x, y, z = map(int, input().split())

if a >= x and b >= y and c >= z:
  print(""YES"")
else:
  extra = 0
  if a >= x:
    extra += (a - x) / 2
  if b >= y:
    extra += (b - x) / 2
  if c >= z:
    extra += (c - z) / 2
  if a < x and (a + extra) >= x:
    extra -= (x - a)
    a = x
  if b < y and (b + extra) >= y:
    extra -= (y - b)
    b = y
  if c < z and (c + extra) >= z:
    extra -= (z - c)
    c = z
  if a >= x and b >= y and c >= z:
    print(""YES"")
  else:
    print(""NO"")","import math

def main():
    r, x, y, a, b = [int(x) for x in input().split()]
    
    # Calculate the distance between the original center (x, y) and the new center (a, b)
    distance = math.sqrt((a - x) ** 2 + (b - y) ** 2)
    
    # Calculate the maximum distance we can move the center in one step
    max_move = 2 * r
    
    # Calculate the number of steps required to cover the distance
    if distance == 0:
        print(0)  # No need to move if the centers are the same
    else:
        steps = math.ceil(distance / max_move)
        print(steps)

if __name__ == ""__main__"":
    main()"
669,A,Little Artem and Presents,PROGRAMMING,['math'],"Little Artem got *n* stones on his birthday and now wants to give some of them to Masha. He knows that Masha cares more about the fact of receiving the present, rather than the value of that present, so he wants to give her stones as many times as possible. However, Masha remembers the last present she received, so Artem can't give her the same number of stones twice in a row. For example, he can give her 3 stones, then 1 stone, then again 3 stones, but he can't give her 3 stones and then again 3 stones right after that.

How many times can Artem give presents to Masha?",The only line of the input contains a single integer *n* (1<=≤<=*n*<=≤<=109) — number of stones Artem received on his birthday.,Print the maximum possible number of times Artem can give presents to Masha.,"['1\n', '2\n', '3\n', '4\n']","['1\n', '1\n', '2\n', '3\n']","In the first sample, Artem can only give 1 stone to Masha.

In the second sample, Atrem can give Masha 1 or 2 stones, though he can't give her 1 stone two times.

In the third sample, Atrem can first give Masha 2 stones, a then 1 more stone.

In the fourth sample, Atrem can first give Masha 1 stone, then 2 stones, and finally 1 stone again.",WRONG_ANSWER,"n = int(input())
print ((n + 3) // 3)","import sys
input = lambda: sys.stdin.readline().rstrip()
from collections import deque, defaultdict, Counter

def max_bouquets(r, g, b):
    # Initialize the maximum count of bouquets
    max_count = 0
    
    # Check the number of mixing bouquets we can make
    mix_bouquets = min(r, g, b)
    max_count += mix_bouquets
    
    # Reduce the number of flowers accordingly
    r -= mix_bouquets
    g -= mix_bouquets
    b -= mix_bouquets
    
    # Add the number of pure bouquets after making mixing bouquets
    max_count += r // 3
    max_count += g // 3
    max_count += b // 3

    return max_count

# Read input values
r, g, b = map(int, input().split())
# Calculate and print the maximum number of bouquets
print(max_bouquets(r, g, b))"
469,A,I Wanna Be the Guy,PROGRAMMING,"['greedy', 'implementation']","There is a game called ""I Wanna Be the Guy"", consisting of *n* levels. Little X and his friend Little Y are addicted to the game. Each of them wants to pass the whole game.

Little X can pass only *p* levels of the game. And Little Y can pass only *q* levels of the game. You are given the indices of levels Little X can pass and the indices of levels Little Y can pass. Will Little X and Little Y pass the whole game, if they cooperate each other?","The first line contains a single integer *n* (1<=≤<=<=*n*<=≤<=100). 

The next line contains an integer *p* (0<=≤<=*p*<=≤<=*n*) at first, then follows *p* distinct integers *a*1,<=*a*2,<=...,<=*a**p* (1<=≤<=*a**i*<=≤<=*n*). These integers denote the indices of levels Little X can pass. The next line contains the levels Little Y can pass in the same format. It's assumed that levels are numbered from 1 to *n*.","If they can pass all the levels, print ""I become the guy."". If it's impossible, print ""Oh, my keyboard!"" (without the quotes).","['4\n3 1 2 3\n2 2 4\n', '4\n3 1 2 3\n2 2 3\n']","['I become the guy.\n', 'Oh, my keyboard!\n']","In the first sample, Little X can pass levels [1 2 3], and Little Y can pass level [2 4], so they can pass all the levels both.

In the second sample, no one can pass level 4.",WRONG_ANSWER,"n=int(input())
li1=list(map(int,input().split()))
li2=list(map(int,input().split()))
li3=li1+li2
s=set(li3)
sumt=(n*(n+1))/2
li=list(s)
if sum(li)==sumt:
    print(""I become the guy."")
else:
    print(""Oh, my keyboard!"")
        
","def swap(num1, num2):
    arr = [num2, num1]
    return arr

num = int(input())
distance = list(map(int, input().split()))
cities = list(map(int, input().split()))

s, t = cities

# Ensure s is less than t for easier calculations
if s > t:
    s, t = swap(s, t)

# Calculate the distance in one direction (s to t)
direct_distance = sum(distance[s-1:t-1])

# Calculate the distance in the other direction (t to s)
reverse_distance = sum(distance[t-1:] + distance[:s-1])

# Output the minimum of both distances
print(min(direct_distance, reverse_distance))"
25,A,IQ test,PROGRAMMING,['brute force'],"Bob is preparing to pass IQ test. The most frequent task in this test is to find out which one of the given *n* numbers differs from the others. Bob observed that one number usually differs from the others in evenness. Help Bob — to check his answers, he needs a program that among the given *n* numbers finds one that is different in evenness.","The first line contains integer *n* (3<=≤<=*n*<=≤<=100) — amount of numbers in the task. The second line contains *n* space-separated natural numbers, not exceeding 100. It is guaranteed, that exactly one of these numbers differs from the others in evenness.",Output index of number that differs from the others in evenness. Numbers are numbered from 1 in the input order.,"['5\n2 4 7 8 10\n', '4\n1 2 1 1\n']","['3\n', '2\n']",none,OK,"n=int(input())
a=[int(x) for x in input().split()]
b=[]
for i in range(n):
    b.append(a[i]%2)
if b.count(1)>b.count(0):
    c=[1]*n
else:
    c=[0]*n
for i in range(n):
    if b[i]-c[i]!=0:
        print(i+1)","turns = {}
score_dict = {}

def has_turn(from_cell, direction):
    return not turns[from_cell] & direction

def move(matrix, from_cell, to_cell, direction):
    # Check if the move is valid (inside the grid and not a roadwork)
    x1, y1 = from_cell
    x2, y2 = to_cell
    if 0 <= x2 < len(matrix) and 0 <= y2 < len(matrix[0]) and matrix[x2][y2] != '*':
        return True
    return False

def can_reach_with_turns(matrix, start, target):
    directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]  # Down, Right, Up, Left
    queue = [(start, 0, -1)]  # (current position, turns, last direction)
    visited = set()

    while queue:
        current, turns_count, last_direction = queue.pop(0)
        
        # If we reach the target, return True
        if current == target:
            return True
        
        if current in visited:
            continue
        visited.add(current)

        for i, (dx, dy) in enumerate(directions):
            next_cell = (current[0] + dx, current[1] + dy)
            if move(matrix, current, next_cell, i):
                new_turns_count = turns_count + (last_direction != -1 and last_direction != i)
                if new_turns_count <= 2:
                    queue.append((next_cell, new_turns_count, i))
    
    return False

def main():
    n, m = map(int, input().split())
    matrix = [input().strip() for _ in range(n)]
    
    start = None
    target = None
    
    # Locate start (S) and target (T) positions
    for i in range(n):
        for j in range(m):
            if matrix[i][j] == 'S':
                start = (i, j)
            elif matrix[i][j] == 'T':
                target = (i, j)
    
    if can_reach_with_turns(matrix, start, target):
        print(""YES"")
    else:
        print(""NO"")

if __name__ == ""__main__"":
    main()"
625,B,War of the Corporations,PROGRAMMING,"['constructive algorithms', 'greedy', 'strings']","A long time ago, in a galaxy far far away two giant IT-corporations Pineapple and Gogol continue their fierce competition. Crucial moment is just around the corner: Gogol is ready to release it's new tablet Lastus 3000.

This new device is equipped with specially designed artificial intelligence (AI). Employees of Pineapple did their best to postpone the release of Lastus 3000 as long as possible. Finally, they found out, that the name of the new artificial intelligence is similar to the name of the phone, that Pineapple released 200 years ago. As all rights on its name belong to Pineapple, they stand on changing the name of Gogol's artificial intelligence.

Pineapple insists, that the name of their phone occurs in the name of AI as a substring. Because the name of technology was already printed on all devices, the Gogol's director decided to replace some characters in AI name with ""#"". As this operation is pretty expensive, you should find the minimum number of characters to replace with ""#"", such that the name of AI doesn't contain the name of the phone as a substring.

Substring is a continuous subsequence of a string.","The first line of the input contains the name of AI designed by Gogol, its length doesn't exceed 100<=000 characters. Second line contains the name of the phone released by Pineapple 200 years ago, its length doesn't exceed 30. Both string are non-empty and consist of only small English letters.","Print the minimum number of characters that must be replaced with ""#"" in order to obtain that the name of the phone doesn't occur in the name of AI as a substring.","['intellect\ntell\n', 'google\napple\n', 'sirisiri\nsir\n']","['1', '0', '2']","In the first sample AI's name may be replaced with ""int#llect"".

In the second sample Gogol can just keep things as they are.

In the third sample one of the new possible names of AI may be ""s#ris#ri"".",OK,"# Description of the problem can be found at http://codeforces.com/problemset/problem/625/B

x = input()
s = input()

print(x.count(s))","n, m, k = map(int, input().split())
x = [[0] * (m + 2) for _ in range(n + 2)]

def check(i, j):
    # Check if a 2x2 square of black pixels is formed
    if x[i][j] and x[i][j + 1] and x[i + 1][j] and x[i + 1][j + 1]:
        return True
    return False

for step in range(1, k + 1):
    i, j = map(int, input().split())
    x[i][j] = 1  # Color the pixel black
    
    # Check for the 2x2 squares that could be formed
    if check(i - 1, j - 1) or check(i - 1, j) or check(i, j - 1) or check(i, j):
        print(step)
        break
else:
    print(0)"
776,A,A Serial Killer,PROGRAMMING,"['brute force', 'implementation', 'strings']","Our beloved detective, Sherlock is currently trying to catch a serial killer who kills a person each day. Using his powers of deduction, he came to know that the killer has a strategy for selecting his next victim.

The killer starts with two potential victims on his first day, selects one of these two, kills selected victim and replaces him with a new person. He repeats this procedure each day. This way, each day he has two potential victims to choose from. Sherlock knows the initial two potential victims. Also, he knows the murder that happened on a particular day and the new person who replaced this victim.

You need to help him get all the pairs of potential victims at each day so that Sherlock can observe some pattern.","First line of input contains two names (length of each of them doesn't exceed 10), the two initials potential victims. Next line contains integer *n* (1<=≤<=*n*<=≤<=1000), the number of days.

Next *n* lines contains two names (length of each of them doesn't exceed 10), first being the person murdered on this day and the second being the one who replaced that person.

The input format is consistent, that is, a person murdered is guaranteed to be from the two potential victims at that time. Also, all the names are guaranteed to be distinct and consists of lowercase English letters.","Output *n*<=+<=1 lines, the *i*-th line should contain the two persons from which the killer selects for the *i*-th murder. The (*n*<=+<=1)-th line should contain the two persons from which the next victim is selected. In each line, the two names can be printed in any order.","['ross rachel\n4\nross joey\nrachel phoebe\nphoebe monica\nmonica chandler\n', 'icm codeforces\n1\ncodeforces technex\n']","['ross rachel\njoey rachel\njoey phoebe\njoey monica\njoey chandler\n', 'icm codeforces\nicm technex\n']","In first example, the killer starts with ross and rachel. 
 -  After day 1, ross is killed and joey appears. -  After day 2, rachel is killed and phoebe appears. -  After day 3, phoebe is killed and monica appears. -  After day 4, monica is killed and chandler appears.",OK,"n,m= input().split()
print(n,m)
num = int(input())
for i in range(num):
	a,b=input().split()
	if(a==n):
		print(b,m)
		n=b
	else:
		print(b,n)
		m=b
	","def solve():
    n, k = input().split()
    nums = list(map(int, input().split()))
    nums.sort()
    n, k = int(n), int(k)

    # If k is 0, we need an x that is less than the smallest number in nums
    if k == 0:
        if nums[0] > 1:
            print(1)  # We can print 1 if it's less than the smallest element
        else:
            print(-1)
        return

    # If k is n, we need an x that is greater than or equal to the largest number in nums
    if k == n:
        if nums[-1] < 10**9:
            print(nums[-1])  # We can print the largest number if we can find a valid x
        else:
            print(-1)
        return

    # We need to ensure that exactly k elements are <= x
    # This means x should be greater than nums[k-1] and less than or equal to nums[k]
    if nums[k - 1] < nums[k]:
        print(nums[k - 1])  # Print the kth element since it fulfills the condition
    else:
        print(-1)"
785,A,Anton and Polyhedrons,PROGRAMMING,"['implementation', 'strings']","Anton's favourite geometric figures are regular polyhedrons. Note that there are five kinds of regular polyhedrons: 
 -  Tetrahedron. Tetrahedron has 4 triangular faces. -  Cube. Cube has 6 square faces. -  Octahedron. Octahedron has 8 triangular faces. -  Dodecahedron. Dodecahedron has 12 pentagonal faces. -  Icosahedron. Icosahedron has 20 triangular faces. 
All five kinds of polyhedrons are shown on the picture below:

Anton has a collection of *n* polyhedrons. One day he decided to know, how many faces his polyhedrons have in total. Help Anton and find this number!","The first line of the input contains a single integer *n* (1<=≤<=*n*<=≤<=200<=000) — the number of polyhedrons in Anton's collection.

Each of the following *n* lines of the input contains a string *s**i* — the name of the *i*-th polyhedron in Anton's collection. The string can look like this:
 -  ""Tetrahedron"" (without quotes), if the *i*-th polyhedron in Anton's collection is a tetrahedron. -  ""Cube"" (without quotes), if the *i*-th polyhedron in Anton's collection is a cube. -  ""Octahedron"" (without quotes), if the *i*-th polyhedron in Anton's collection is an octahedron. -  ""Dodecahedron"" (without quotes), if the *i*-th polyhedron in Anton's collection is a dodecahedron. -  ""Icosahedron"" (without quotes), if the *i*-th polyhedron in Anton's collection is an icosahedron.",Output one number — the total number of faces in all the polyhedrons in Anton's collection.,"['4\nIcosahedron\nCube\nTetrahedron\nDodecahedron\n', '3\nDodecahedron\nOctahedron\nOctahedron\n']","['42\n', '28\n']","In the first sample Anton has one icosahedron, one cube, one tetrahedron and one dodecahedron. Icosahedron has 20 faces, cube has 6 faces, tetrahedron has 4 faces and dodecahedron has 12 faces. In total, they have 20 + 6 + 4 + 12 = 42 faces.",OK,"s = {""Tetrahedron"": 4, 
""Cube"": 6, 
""Octahedron"": 8, 
""Dodecahedron"": 12, 
""Icosahedron"": 20}
t = int(input())
add = 0
for i in range(t):
    add += s[input()]
print(add)
","def main_function():
    a = int(input())
    if a > 2:
        # Create a counter-example for n > 2
        # For example, we can use the list [3, 1, 2]
        # This will confuse a basic sorting implementation 
        # that might not handle certain cases correctly
        print(""3 1 2"")
    else:
        # For n = 2, valid non-decreasing order is possible
        print(""-1"")

main_function()"
849,B,Tell Your World,PROGRAMMING,"['brute force', 'geometry']","Connect the countless points with lines, till we reach the faraway yonder.

There are *n* points on a coordinate plane, the *i*-th of which being (*i*,<=*y**i*).

Determine whether it's possible to draw two parallel and non-overlapping lines, such that every point in the set lies on exactly one of them, and each of them passes through at least one point in the set.","The first line of input contains a positive integer *n* (3<=≤<=*n*<=≤<=1<=000) — the number of points.

The second line contains *n* space-separated integers *y*1,<=*y*2,<=...,<=*y**n* (<=-<=109<=≤<=*y**i*<=≤<=109) — the vertical coordinates of each point.","Output ""Yes"" (without quotes) if it's possible to fulfill the requirements, and ""No"" otherwise.

You can print each letter in any case (upper or lower).","['5\n7 5 8 6 9\n', '5\n-1 -2 0 0 -5\n', '5\n5 4 3 2 1\n', '5\n1000000000 0 0 0 0\n']","['Yes\n', 'No\n', 'No\n', 'Yes\n']","In the first example, there are five points: (1, 7), (2, 5), (3, 8), (4, 6) and (5, 9). It's possible to draw a line that passes through points 1, 3, 5, and another one that passes through points 2, 4 and is parallel to the first one.

In the second example, while it's possible to draw two lines that cover all points, they cannot be made parallel.

In the third example, it's impossible to satisfy both requirements at the same time.",WRONG_ANSWER,"n=int(input())
l=[int(i) for i in input().split()]
diff=[l[i]-l[i-1] for i in range(1,n)]
if len(set(diff))<=2:
    print('Yes')
else:
    print('No')","import math

def nCr(n, r):
    f = math.factorial
    return f(n) // f(r) // f(n - r)

n = int(input())
l = []
for i in range(n):
    l.append(list(map(int, input().split())))

# Create a dictionary to count occurrences of (x, y) pairs
count_map = {}
for x, y in l:
    if (x, y) not in count_map:
        count_map[(x, y)] = 0
    count_map[(x, y)] += 1

result = 0

# Calculate pairs (i, j) for each unique (x, y) pair
for count in count_map.values():
    if count > 1:
        result += nCr(count, 2)  # Pairs within identical watchmen
    result += count  # Each unique watchman can form a pair with itself

# Output the result
print(result)"
574,B,Bear and Three Musketeers,PROGRAMMING,"['brute force', 'dfs and similar', 'graphs', 'hashing']","Do you know a story about the three musketeers? Anyway, you will learn about its origins now.

Richelimakieu is a cardinal in the city of Bearis. He is tired of dealing with crime by himself. He needs three brave warriors to help him to fight against bad guys.

There are *n* warriors. Richelimakieu wants to choose three of them to become musketeers but it's not that easy. The most important condition is that musketeers must know each other to cooperate efficiently. And they shouldn't be too well known because they could be betrayed by old friends. For each musketeer his recognition is the number of warriors he knows, excluding other two musketeers.

Help Richelimakieu! Find if it is possible to choose three musketeers knowing each other, and what is minimum possible sum of their recognitions.","The first line contains two space-separated integers, *n* and *m* (3<=≤<=*n*<=≤<=4000, 0<=≤<=*m*<=≤<=4000) — respectively number of warriors and number of pairs of warriors knowing each other.

*i*-th of the following *m* lines contains two space-separated integers *a**i* and *b**i* (1<=≤<=*a**i*,<=*b**i*<=≤<=*n*, *a**i*<=≠<=*b**i*). Warriors *a**i* and *b**i* know each other. Each pair of warriors will be listed at most once.","If Richelimakieu can choose three musketeers, print the minimum possible sum of their recognitions. Otherwise, print ""-1"" (without the quotes).","['5 6\n1 2\n1 3\n2 3\n2 4\n3 4\n4 5\n', '7 4\n2 1\n3 6\n5 1\n1 7\n']","['2\n', '-1\n']","In the first sample Richelimakieu should choose a triple 1, 2, 3. The first musketeer doesn't know anyone except other two musketeers so his recognition is 0. The second musketeer has recognition 1 because he knows warrior number 4. The third musketeer also has recognition 1 because he knows warrior 4. Sum of recognitions is 0 + 1 + 1 = 2.

The other possible triple is 2, 3, 4 but it has greater sum of recognitions, equal to 1 + 1 + 1 = 3.

In the second sample there is no triple of warriors knowing each other.",WRONG_ANSWER,"import sys
input = sys.stdin.readline

n,m = map(int,input().split())

adj=[[] for j in range(n+1)]


for i in range(m):
    a,b = map(int, input().split())
    adj[a].append(b)
    adj[b].append(a)

ans=9999


for i in range(1,n+1):
    f=[i]
    for j in range(1,n+1):
        if j!=i:
            if i in adj[j]:
                f.append(j)
                for k in range(1,n+1):
                    if k not in f:
                        if k in adj[f[0]]:
                            if k in adj[f[1]]:
                                aa=len(adj[f[0]])
                                bb=len(adj[f[1]])
                                cc=len(adj[k])
                                ans= min( ans,aa+bb+cc-6   )


if ans==9999:
    print(-1)
else:
    print(ans)
","import math

def rl():
    return map(int, input().split())

def ri():
    return int(input())

def calculate_area(vertices):
    x_coords = [v[0] for v in vertices]
    y_coords = [v[1] for v in vertices]
    
    # Get the minimum and maximum coordinates
    min_x = min(x_coords)
    max_x = max(x_coords)
    min_y = min(y_coords)
    max_y = max(y_coords)
    
    # Calculate area
    area = (max_x - min_x) * (max_y - min_y)
    return area

n = ri()  # Read the number of vertices remaining
vertices = [tuple(rl()) for _ in range(n)]  # Read the vertices

if n == 1:
    print(-1)  # Not enough information if only one vertex is provided
elif n == 2:
    print(0)   # Two vertices can only imply a line segment, not an area
elif n == 3:
    # We have 3 points, we can determine the fourth one
    xs = {v[0] for v in vertices}
    ys = {v[1] for v in vertices}
    fourth_x = (min(xs) + max(xs)) - sum(xs) + 2*min(xs)
    fourth_y = (min(ys) + max(ys)) - sum(ys) + 2*min(ys)
    area = calculate_area(vertices + [(fourth_x, fourth_y)])
    print(area)
elif n == 4:
    # If we have all 4 vertices, just calculate the area directly
    area = calculate_area(vertices)
    print(area)"
227,A,Where do I Turn?,PROGRAMMING,['geometry'],"Trouble came from the overseas lands: a three-headed dragon Gorynych arrived. The dragon settled at point *C* and began to terrorize the residents of the surrounding villages.

A brave hero decided to put an end to the dragon. He moved from point *A* to fight with Gorynych. The hero rode from point *A* along a straight road and met point *B* on his way. The hero knows that in this land for every pair of roads it is true that they are either parallel to each other, or lie on a straight line, or are perpendicular to each other. He also knows well that points *B* and *C* are connected by a road. So the hero must either turn 90 degrees to the left or continue riding straight ahead or turn 90 degrees to the right. But he forgot where the point *C* is located.

Fortunately, a Brave Falcon flew right by. It can see all three points from the sky. The hero asked him what way to go to get to the dragon's lair.

If you have not got it, you are the falcon. Help the hero and tell him how to get him to point *C*: turn left, go straight or turn right.

At this moment the hero is believed to stand at point *B*, turning his back to point *A*.","The first input line contains two space-separated integers *x**a*,<=*y**a* (|*x**a*|,<=|*y**a*|<=≤<=109) — the coordinates of point *A*. The second line contains the coordinates of point *B* in the same form, the third line contains the coordinates of point *C*.

It is guaranteed that all points are pairwise different. It is also guaranteed that either point *B* lies on segment *AC*, or angle *ABC* is right.","Print a single line. If a hero must turn left, print ""LEFT"" (without the quotes); If he must go straight ahead, print ""TOWARDS"" (without the quotes); if he should turn right, print ""RIGHT"" (without the quotes).","['0 0\n0 1\n1 1\n', '-1 -1\n-3 -3\n-4 -4\n', '-4 -6\n-3 -7\n-2 -6\n']","['RIGHT\n', 'TOWARDS\n', 'LEFT\n']","The picture to the first sample: 

The red color shows points A, B and C. The blue arrow shows the hero's direction. The green color shows the hero's trajectory.

The picture to the second sample:",OK,"xa,ya = input().split()
xa = int(xa)
ya = int(ya)

xb,yb = input().split()
xb = int(xb)
yb = int(yb)

xc,yc = input().split()
xc = int(xc)
yc = int(yc)

vab_x = xb-xa
vab_y = yb-ya

vbc_x = xc - xb
vbc_y = yc - yb

produto_vetorial = (vab_x * vbc_y) - (vab_y * vbc_x)

if(produto_vetorial == 0):
    print(""TOWARDS"")
elif(produto_vetorial < 0):
    print(""RIGHT"")
else:
    print(""LEFT"")


","try:
    s = input()
    p = s
    p = 'M' + p

    def io(x):
        x = 'M' + x
        while '()' in x:
            x = x.replace('()', '')
        while '[]' in x:
            x = x.replace('[]', '')
        while '{}' in x:
            x = x.replace('{}', '')
        while '<>' in x:
            x = x.replace('<>', '')
        return x

    p = io(p)

    if p != 'M':
        print(""Impossible"")
    else:
        # Count unclosed opening brackets
        open_brackets = {'(': 0, '{': 0, '[': 0, '<': 0}
        replace_count = 0
        
        for char in s:
            if char in open_brackets:
                open_brackets[char] += 1
            else:
                matched = False
                for ob in open_brackets:
                    if (char == ')' and ob == '(') or \
                       (char == '}' and ob == '{') or \
                       (char == ']' and ob == '[') or \
                       (char == '>' and ob == '<'):
                        if open_brackets[ob] > 0:
                            open_brackets[ob] -= 1
                            matched = True
                            break
                if not matched:
                    replace_count += 1
                    
        # Add the remaining unmatched opening brackets
        replace_count += sum(open_brackets.values())
        
        print(replace_count)

except Exception as e:
    print(""Impossible"")"
220,A,Little Elephant and Problem,PROGRAMMING,"['implementation', 'sortings']","The Little Elephant has got a problem — somebody has been touching his sorted by non-decreasing array *a* of length *n* and possibly swapped some elements of the array.

The Little Elephant doesn't want to call the police until he understands if he could have accidentally changed the array himself. He thinks that he could have accidentally changed array *a*, only if array *a* can be sorted in no more than one operation of swapping elements (not necessarily adjacent). That is, the Little Elephant could have accidentally swapped some two elements.

Help the Little Elephant, determine if he could have accidentally changed the array *a*, sorted by non-decreasing, himself.","The first line contains a single integer *n* (2<=≤<=*n*<=≤<=105) — the size of array *a*. The next line contains *n* positive integers, separated by single spaces and not exceeding 109, — array *a*.

Note that the elements of the array are not necessarily distinct numbers.","In a single line print ""YES"" (without the quotes) if the Little Elephant could have accidentally changed the array himself, and ""NO"" (without the quotes) otherwise.","['2\n1 2\n', '3\n3 2 1\n', '4\n4 3 2 1\n']","['YES\n', 'YES\n', 'NO\n']","In the first sample the array has already been sorted, so to sort it, we need 0 swap operations, that is not more than 1. Thus, the answer is ""YES"".

In the second sample we can sort the array if we swap elements 1 and 3, so we need 1 swap operation to sort the array. Thus, the answer is ""YES"".

In the third sample we can't sort the array in more than one swap operation, so the answer is ""NO"".",WRONG_ANSWER,"n=int(input())
l=list(map(int,input().split()))
if len(l)<=3:
    print('YES')
else:
    c=0
    l1=sorted(l)
    for i,j in zip(l,l1):
        if i!=j:
            c+=1
    if c==2:
        print('YES')
    else:
        print('NO')","import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

def read():
    return sys.stdin.readline()

def main():
    # Read the sizes of both parts and the number of edges
    a, b, m = map(int, read().split())
    
    # Initialize adjacency list for the bipartite graph
    edges = []
    graph = [[] for _ in range(a + 1)]
    
    # Read edges and construct the graph
    for i in range(m):
        x, y = map(int, read().split())
        edges.append((x, y))
        graph[x].append((y, i))
        graph[y].append((x, i))
    
    # Prepare to store the colors for each edge
    colors = [-1] * m
    color_count = 0
    
    # Process edges to assign colors
    for x in range(1, a + 1):
        used_colors = set()
        
        # Collect colors used by edges connected to x
        for y, edge_idx in graph[x]:
            if colors[edge_idx] != -1:
                used_colors.add(colors[edge_idx])
        
        # Assign colors to edges connected to x
        for y, edge_idx in graph[x]:
            if colors[edge_idx] == -1:
                # Find a color not used by adjacent edges
                color = 1
                while color in used_colors:
                    color += 1
                colors[edge_idx] = color
                color_count = max(color_count, color)
    
    # Print the results
    print(color_count)
    print("" "".join(map(str, colors)))

if __name__ == ""__main__"":
    main()"
682,B,Alyona and Mex,PROGRAMMING,['sortings'],"Someone gave Alyona an array containing *n* positive integers *a*1,<=*a*2,<=...,<=*a**n*. In one operation, Alyona can choose any element of the array and decrease it, i.e. replace with any positive integer that is smaller than the current one. Alyona can repeat this operation as many times as she wants. In particular, she may not apply any operation to the array at all.

Formally, after applying some operations Alyona will get an array of *n* positive integers *b*1,<=*b*2,<=...,<=*b**n* such that 1<=≤<=*b**i*<=≤<=*a**i* for every 1<=≤<=*i*<=≤<=*n*. Your task is to determine the maximum possible value of mex of this array.

Mex of an array in this problem is the minimum positive integer that doesn't appear in this array. For example, mex of the array containing 1, 3 and 4 is equal to 2, while mex of the array containing 2, 3 and 2 is equal to 1.","The first line of the input contains a single integer *n* (1<=≤<=*n*<=≤<=100<=000) — the number of elements in the Alyona's array.

The second line of the input contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=109) — the elements of the array.",Print one positive integer — the maximum possible value of mex of the array after Alyona applies some (possibly none) operations.,"['5\n1 3 3 3 6\n', '2\n2 1\n']","['5\n', '3\n']","In the first sample case if one will decrease the second element value to 2 and the fifth element value to 4 then the mex value of resulting array 1 2 3 3 4 will be equal to 5.

To reach the answer to the second sample case one must not decrease any of the array elements.",WRONG_ANSWER,"n = int(input())
a = list(map(int , input().split()))
a.sort()
c = 1
for i in range(n):
    if c < n:
        c+=1
print(c)","#	Author	: debugster
#	Email	: [email protected]
#		Date	: 2020-06-03 01:51:41

import sys
import os

def get_int():
    return int(sys.stdin.readline().strip())

def get_ints():
    return list(map(int, sys.stdin.readline().strip().split()))

def count_watered_sections(heights, start_index):
    height = heights[start_index]
    visited = [False] * len(heights)
    count = 0
    queue = [start_index]
    
    while queue:
        index = queue.pop(0)
        if visited[index]:
            continue
        visited[index] = True
        count += 1
        
        # Check left
        if index > 0 and heights[index - 1] <= height and not visited[index - 1]:
            queue.append(index - 1)
        
        # Check right
        if index < len(heights) - 1 and heights[index + 1] <= height and not visited[index + 1]:
            queue.append(index + 1)
    
    return count

def main():
    n = get_int()
    heights = get_ints()
    max_watered = 0
    
    for i in range(n):
        max_watered = max(max_watered, count_watered_sections(heights, i))
    
    print(max_watered)

if __name__ == ""__main__"":
    main()"
884,A,Book Reading,PROGRAMMING,['implementation'],"Recently Luba bought a very interesting book. She knows that it will take *t* seconds to read the book. Luba wants to finish reading as fast as she can.

But she has some work to do in each of *n* next days. The number of seconds that Luba has to spend working during *i*-th day is *a**i*. If some free time remains, she can spend it on reading.

Help Luba to determine the minimum number of day when she finishes reading.

It is guaranteed that the answer doesn't exceed *n*.

Remember that there are 86400 seconds in a day.","The first line contains two integers *n* and *t* (1<=≤<=*n*<=≤<=100, 1<=≤<=*t*<=≤<=106) — the number of days and the time required to read the book.

The second line contains *n* integers *a**i* (0<=≤<=*a**i*<=≤<=86400) — the time Luba has to spend on her work during *i*-th day.","Print the minimum day Luba can finish reading the book.

It is guaranteed that answer doesn't exceed *n*.","['2 2\n86400 86398\n', '2 86400\n0 86400\n']","['2\n', '1\n']",none,OK,"a=input().split(' ')
n=int(a[0])
t=int(a[1])
a=input().split(' ')
a=[int(i) for i in a]
for i in range(n):
    if t<=0:
        print(i)
        break
    t=t-(86400-a[i])
else:
    print(n)
        
","from sys import stdin
input = stdin.readline

def answer():
    n, m, x, y = map(int, input().split())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))

    ans = []
    j = 0  # Pointer for vests
    for i in range(n):
        # Calculate the acceptable range for the soldier
        min_size = a[i] - x
        max_size = a[i] + y
        
        # While there's still vests and vest size is less than min_size
        while j < m and b[j] < min_size:
            j += 1
        
        # If the current vest size is within the acceptable range
        if j < m and min_size <= b[j] <= max_size:
            ans.append((i + 1, j + 1))  # Store the soldier and vest index
            j += 1  # Move to the next vest

    # Output the result
    print(len(ans))
    for u, v in ans:
        print(u, v)"
855,A,Tom Riddle's Diary,PROGRAMMING,"['brute force', 'implementation', 'strings']","Harry Potter is on a mission to destroy You-Know-Who's Horcruxes. The first Horcrux that he encountered in the Chamber of Secrets is Tom Riddle's diary. The diary was with Ginny and it forced her to open the Chamber of Secrets. Harry wants to know the different people who had ever possessed the diary to make sure they are not under its influence.

He has names of *n* people who possessed the diary in order. You need to tell, for each person, if he/she possessed the diary at some point before or not.

Formally, for a name *s**i* in the *i*-th line, output ""YES"" (without quotes) if there exists an index *j* such that *s**i*<==<=*s**j* and *j*<=&lt;<=*i*, otherwise, output ""NO"" (without quotes).","First line of input contains an integer *n* (1<=≤<=*n*<=≤<=100) — the number of names in the list.

Next *n* lines each contain a string *s**i*, consisting of lowercase English letters. The length of each string is between 1 and 100.","Output *n* lines each containing either ""YES"" or ""NO"" (without quotes), depending on whether this string was already present in the stream or not.

You can print each letter in any case (upper or lower).","['6\ntom\nlucius\nginny\nharry\nginny\nharry\n', '3\na\na\na\n']","['NO\nNO\nNO\nNO\nYES\nYES\n', 'NO\nYES\nYES\n']","In test case 1, for *i* = 5 there exists *j* = 3 such that *s*<sub class=""lower-index"">*i*</sub> = *s*<sub class=""lower-index"">*j*</sub> and *j* &lt; *i*, which means that answer for *i* = 5 is ""YES"".",OK,"#all those moments will be lost in time , like tears in rain ""D
a=[]
n=int(input())
for _ in range(n):
	b=input()
	if b in a:
		print('YES')
	else:
		print('NO')
		a.append(b);","n = int(input())
x = list(map(int, input().split()))

def solve(i, p=0):
    # Base case: if we are past the last day
    if i == n:
        return 0
    
    # Determine the activity for the current day based on the previous day's activity
    rest = float('inf')
    
    # Option to rest
    rest_count = 1 + solve(i + 1, 0)  # Rest today, move to the next day
    
    if x[i] == 1 or x[i] == 3:  # Contest is available
        if p != 1:  # Can do contest today if previous was not contest
            contest_count = solve(i + 1, 1)  # Do contest today, move to the next day
            rest = min(rest, contest_count)
    
    if x[i] == 2 or x[i] == 3:  # Gym is available
        if p != 2:  # Can do sport today if previous was not sport
            sport_count = solve(i + 1, 2)  # Do sport today, move to the next day
            rest = min(rest, sport_count)

    return min(rest, rest_count)

# Start from day 0 with no previous activity
print(solve(0))"
967,B,Watering System,PROGRAMMING,"['math', 'sortings']","Arkady wants to water his only flower. Unfortunately, he has a very poor watering system that was designed for $n$ flowers and so it looks like a pipe with $n$ holes. Arkady can only use the water that flows from the first hole.

Arkady can block some of the holes, and then pour $A$ liters of water into the pipe. After that, the water will flow out from the non-blocked holes proportionally to their sizes $s_1, s_2, \ldots, s_n$. In other words, if the sum of sizes of non-blocked holes is $S$, and the $i$-th hole is not blocked, $\frac{s_i \cdot A}{S}$ liters of water will flow out of it.

What is the minimum number of holes Arkady should block to make at least $B$ liters of water flow out of the first hole?","The first line contains three integers $n$, $A$, $B$ ($1 \le n \le 100\,000$, $1 \le B \le A \le 10^4$) — the number of holes, the volume of water Arkady will pour into the system, and the volume he wants to get out of the first hole.

The second line contains $n$ integers $s_1, s_2, \ldots, s_n$ ($1 \le s_i \le 10^4$) — the sizes of the holes.",Print a single integer — the number of holes Arkady should block.,"['4 10 3\n2 2 2 2\n', '4 80 20\n3 2 1 4\n', '5 10 10\n1000 1 1 1 1\n']","['1\n', '0\n', '4\n']","In the first example Arkady should block at least one hole. After that, $\frac{10 \cdot 2}{6} \approx 3.333$ liters of water will flow out of the first hole, and that suits Arkady.

In the second example even without blocking any hole, $\frac{80 \cdot 3}{10} = 24$ liters will flow out of the first hole, that is not less than $20$.

In the third example Arkady has to block all holes except the first to make all water flow out of the first hole.",TIME_LIMIT_EXCEEDED,"n,a,b=map(int,input().split())
l=list(map(int,input().split()))
l1=l[1:]
l1.sort()
while (a*l[0])/(sum(l1)+l[0])<b : 
    l1.pop() 
print(n-len(l1)-1)","def isPalindrome(expression):
    if len(expression) <= 1:
        return True
    else:
        if expression[len(expression) - 1] == expression[0]:
            return isPalindrome(expression[1:len(expression) - 1])
        else:
            return False

# Function to check if the string s can be formed by k palindromes of the same length
def canFormPalindromes(s, k):
    n = len(s)
    
    # Length of each palindrome must be equal
    if n % k != 0:
        return ""NO""
    
    # Length of each palindrome
    part_length = n // k
    
    # Check each substring of length part_length
    for i in range(k):
        substring = s[i * part_length:(i + 1) * part_length]
        if not isPalindrome(substring):
            return ""NO""
    
    return ""YES""

# Input reading
s = input().strip()
k = int(input().strip())

# Print the result
print(canFormPalindromes(s, k))"
0,none,none,none,['none'],"On the way to school, Karen became fixated on the puzzle game on her phone!

The game is played as follows. In each level, you have a grid with *n* rows and *m* columns. Each cell originally contains the number 0.

One move consists of choosing one row or column, and adding 1 to all of the cells in that row or column.

To win the level, after all the moves, the number in the cell at the *i*-th row and *j*-th column should be equal to *g**i*,<=*j*.

Karen is stuck on one level, and wants to know a way to beat this level using the minimum number of moves. Please, help her with this task!","The first line of input contains two integers, *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=100), the number of rows and the number of columns in the grid, respectively.

The next *n* lines each contain *m* integers. In particular, the *j*-th integer in the *i*-th of these rows contains *g**i*,<=*j* (0<=≤<=*g**i*,<=*j*<=≤<=500).","If there is an error and it is actually not possible to beat the level, output a single integer -1.

Otherwise, on the first line, output a single integer *k*, the minimum number of moves necessary to beat the level.

The next *k* lines should each contain one of the following, describing the moves in the order they must be done:
 -  row *x*, (1<=≤<=*x*<=≤<=*n*) describing a move of the form ""choose the *x*-th row"". -  col *x*, (1<=≤<=*x*<=≤<=*m*) describing a move of the form ""choose the *x*-th column"". 
If there are multiple optimal solutions, output any one of them.","['3 5\n2 2 2 3 2\n0 0 0 1 0\n1 1 1 2 1\n', '3 3\n0 0 0\n0 1 0\n0 0 0\n', '3 3\n1 1 1\n1 1 1\n1 1 1\n']","['4\nrow 1\nrow 1\ncol 4\nrow 3\n', '-1\n', '3\nrow 1\nrow 2\nrow 3\n']","In the first test case, Karen has a grid with 3 rows and 5 columns. She can perform the following 4 moves to beat the level:

In the second test case, Karen has a grid with 3 rows and 3 columns. It is clear that it is impossible to beat the level; performing any move will create three 1s on the grid, but it is required to only have one 1 in the center.

In the third test case, Karen has a grid with 3 rows and 3 columns. She can perform the following 3 moves to beat the level:

Note that this is not the only solution; another solution, among others, is col 1, col 2, col 3.",OK,"n,m=map(int,input().split())
a=[];row=[];col=[]
for i in range(n):
    a.append(list(map(int,input().split())))
if m>n:
    for i in range(n):
        row.append(min(a[i]))
    for i in range(m):
        col.append(a[0][i]-row[0])
else:
    for i in range(m):
        r=1000
        for j in range(n):
            r=min(r,a[j][i])
        col.append(r)
    for i in range(n):
        row.append(a[i][0]-col[0])
for i in range(n):
    for j in range(m):
        if a[i][j]!=row[i]+col[j]:
            exit(print(-1))
print(sum(row)+sum(col))
for i in range(n):
    for j in range(row[i]):
        print('row',i+1)
for i in range(m):
    for j in range(col[i]):
        print('col',i+1)","""""""
https://codeforces.com/problemset/problem/519/B
""""""
_ = input()  # Read the number of compilation errors
errors_first = list(map(int, input().split()))  # Read the first set of errors
errors_second = list(map(int, input().split()))  # Read the second set of errors
errors_third = list(map(int, input().split()))  # Read the third set of errors

# Find the first missing error
missing_first = sum(errors_first) - sum(errors_second)

# Find the second missing error
missing_second = sum(errors_second) - sum(errors_third)

# Print the two missing errors
print(missing_first, missing_second)"
69,A,Young Physicist,PROGRAMMING,"['implementation', 'math']","A guy named Vasya attends the final grade of a high school. One day Vasya decided to watch a match of his favorite hockey team. And, as the boy loves hockey very much, even more than physics, he forgot to do the homework. Specifically, he forgot to complete his physics tasks. Next day the teacher got very angry at Vasya and decided to teach him a lesson. He gave the lazy student a seemingly easy task: You are given an idle body in space and the forces that affect it. The body can be considered as a material point with coordinates (0; 0; 0). Vasya had only to answer whether it is in equilibrium. ""Piece of cake"" — thought Vasya, we need only to check if the sum of all vectors is equal to 0. So, Vasya began to solve the problem. But later it turned out that there can be lots and lots of these forces, and Vasya can not cope without your help. Help him. Write a program that determines whether a body is idle or is moving by the given vectors of forces.","The first line contains a positive integer *n* (1<=≤<=*n*<=≤<=100), then follow *n* lines containing three integers each: the *x**i* coordinate, the *y**i* coordinate and the *z**i* coordinate of the force vector, applied to the body (<=-<=100<=≤<=*x**i*,<=*y**i*,<=*z**i*<=≤<=100).","Print the word ""YES"" if the body is in equilibrium, or the word ""NO"" if it is not.","['3\n4 1 7\n-2 4 -1\n1 -5 -3\n', '3\n3 -1 7\n-5 2 -4\n2 -1 -3\n']","['NO', 'YES']",none,WRONG_ANSWER,"import sys

vector = [0, 0, 0]

counter = 0
for line in sys.stdin:
  if not counter:
    continue
  nums = [int(i) for i in line.split(' ')]
  for i in range(3):
    vector[i] += nums[i]
  counter += 1

if vector[0] == 0 and vector[1] == 0 and vector[2] == 0:
  print('YES')
else:
  print('NO')
","def is_power_of_2(n):
    return (n & (n - 1)) == 0

def solve(n):
    # Calculate the sum of integers from 1 to n
    sum_1_to_n = (n * (n + 1)) // 2
    # Subtract all powers of 2 from the sum
    power_of_2_sum = 0
    power = 1
    
    # Loop to find all powers of 2 less than or equal to n
    while power <= n:
        power_of_2_sum += power
        power *= 2
    
    # Final result is sum of 1 to n minus powers of 2
    return sum_1_to_n - power_of_2_sum

# Read number of test cases
t = int(input())
for _ in range(t):
    n = int(input())
    # Print the computed result for each n
    print(solve(n))"
805,A,Fake NP,PROGRAMMING,"['greedy', 'math']","Tavak and Seyyed are good friends. Seyyed is very funny and he told Tavak to solve the following problem instead of longest-path.

You are given *l* and *r*. For all integers from *l* to *r*, inclusive, we wrote down all of their integer divisors except 1. Find the integer that we wrote down the maximum number of times.

Solve the problem to show that it's not a NP problem.",The first line contains two integers *l* and *r* (2<=≤<=*l*<=≤<=*r*<=≤<=109).,"Print single integer, the integer that appears maximum number of times in the divisors. 

If there are multiple answers, print any of them.","['19 29\n', '3 6\n']","['2\n', '3\n']","Definition of a divisor: [https://www.mathsisfun.com/definitions/divisor-of-an-integer-.html](https://www.mathsisfun.com/definitions/divisor-of-an-integer-.html)

The first example: from 19 to 29 these numbers are divisible by 2: {20, 22, 24, 26, 28}.

The second example: from 3 to 6 these numbers are divisible by 3: {3, 6}.",WRONG_ANSWER,"l,r=map(int,input().split())
x,y=(r//2)-(l//2),(r//3)-(l//3)
if x>=y:
	print('2')
else:
	print('3')","from collections import deque
from math import inf

def bfs(G, s):
    n = len(G)
    q = deque()
    q.append(s)
    visited = [False] * n
    visited[s] = True
    count = 0
    
    while q:
        node = q.popleft()
        count += 1
        for neighbor in G[node]:
            if not visited[neighbor]:
                visited[neighbor] = True
                q.append(neighbor)

    return count

def find_capital(n, roads):
    # Create a graph representation
    G = [[] for _ in range(n)]
    rev_G = [[] for _ in range(n)]
    for s, t in roads:
        G[s - 1].append(t - 1)  # directed edge s -> t
        rev_G[t - 1].append(s - 1)  # reverse edge t -> s

    # Calculate number of reachable nodes from each city
    min_inversions = inf
    results = []

    for i in range(n):
        # Calculate reachable count from city i using BFS
        reached_from_i = bfs(G, i)

        # Calculate reachable count to city i using BFS on reverse graph
        reached_to_i = bfs(rev_G, i)

        # Roads to invert to make city i a capital
        inversions_needed = (n - reached_from_i) + (n - reached_to_i)

        # Keep track of the minimum inversions and cities
        if inversions_needed < min_inversions:
            min_inversions = inversions_needed
            results = [i + 1]  # Store with 1-based index
        elif inversions_needed == min_inversions:
            results.append(i + 1)  # Store with 1-based index

    return min_inversions, results

# Input section
n = int(input())
roads = [tuple(map(int, input().split())) for _ in range(n - 1)]

# Find the optimal capital and print results
min_inversions, capitals = find_capital(n, roads)
print(min_inversions)
print(' '.join(map(str, capital for capital in capitals)))"
16,C,Monitor,PROGRAMMING,"['binary search', 'number theory']","Reca company makes monitors, the most popular of their models is AB999 with the screen size *a*<=×<=*b* centimeters. Because of some production peculiarities a screen parameters are integer numbers. Recently the screen sides ratio *x*:<=*y* became popular with users. That's why the company wants to reduce monitor AB999 size so that its screen sides ratio becomes *x*:<=*y*, at the same time they want its total area to be maximal of all possible variants. Your task is to find the screen parameters of the reduced size model, or find out that such a reduction can't be performed.","The first line of the input contains 4 integers — *a*, *b*, *x* and *y* (1<=≤<=*a*,<=*b*,<=*x*,<=*y*<=≤<=2·109).","If the answer exists, output 2 positive integers — screen parameters of the reduced size model. Output 0 0 otherwise.","['800 600 4 3\n', '1920 1200 16 9\n', '1 1 1 2\n']","['800 600\n', '1920 1080\n', '0 0\n']",none,WRONG_ANSWER,"""""""16С 1800 баллов""""""

from datetime import datetime
""""""#print(""Размер до "")
a = float(input())
b = float(input())
#print(""Размер после "")
x= int(input())
y= int(input())""""""
a, b, x, y = map(int, input().split())
s = datetime.now()

#if a>x and b>y:
if a % x == 0 and b % y == 0:
    print(int(a), int(b))
elif a % x != 0 and b % y == 0:
    a = x * (b // y)
    print(a, b)
elif a % x == 0 and b % y != 0:
    b = y * (a // x)
    print(int(a), int(b))

elif a % x != 0 and b % y != 0:
    while a % x != 0:
        a -= 1
    if a <= 0:
        print(0, 0)
    b = y * a // x
    print(int(a), int(b))

#else:
    #print(0, 0)

#print(datetime.now()-s)","def is_prime(num):
    """"""Check if a number is prime.""""""
    if num < 2:
        return False
    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            return False
    return True

def is_palindrome(num):
    """"""Check if a number is palindromic.""""""
    return str(num) == str(num)[::-1]

def count_primes(n):
    """"""Count the number of primes no larger than n.""""""
    return sum(1 for i in range(2, n + 1) if is_prime(i))

def count_palindromic(n):
    """"""Count the number of palindromic numbers no larger than n.""""""
    return sum(1 for i in range(1, n + 1) if is_palindrome(i))

def solve(p, q):
    primes = []
    
    n = 1
    result = None

    while True:
        # Count the number of primes and palindromic numbers up to n
        prm_count = count_primes(n)
        pal_count = count_palindromic(n)

        # Calculate A * rub(n) => A * pal_count
        A = p / q

        if prm_count <= A * pal_count:
            result = n  # Update the result to the current n
        else:
            break  # If the condition fails, we can stop searching

        n += 1  # Increment n to check the next number

    # Check if a result was found and return it, else return the specific message
    if result is not None:
        print(result)
    else:
        print(""Palindromic tree is better than splay tree"")"
4,A,Watermelon,PROGRAMMING,"['brute force', 'math']","One hot summer day Pete and his friend Billy decided to buy a watermelon. They chose the biggest and the ripest one, in their opinion. After that the watermelon was weighed, and the scales showed *w* kilos. They rushed home, dying of thirst, and decided to divide the berry, however they faced a hard problem.

Pete and Billy are great fans of even numbers, that's why they want to divide the watermelon in such a way that each of the two parts weighs even number of kilos, at the same time it is not obligatory that the parts are equal. The boys are extremely tired and want to start their meal as soon as possible, that's why you should help them and find out, if they can divide the watermelon in the way they want. For sure, each of them should get a part of positive weight.",The first (and the only) input line contains integer number *w* (1<=≤<=*w*<=≤<=100) — the weight of the watermelon bought by the boys.,"Print YES, if the boys can divide the watermelon into two parts, each of them weighing even number of kilos; and NO in the opposite case.",['8\n'],['YES\n'],"For example, the boys can divide the watermelon into two parts of 2 and 6 kilos respectively (another variant — two parts of 4 and 4 kilos).",COMPILATION_ERROR,"w = int(input(""w""))
 
if (w/2=0):
    ptint(""Yes"")
else:
    print(""No"")","import sys

def binarySearch(l, target):
    low, high = 0, len(l) - 1
    ans = -1
    while low <= high:
        mid = low + (high - low) // 2
        if l[mid] > target:
            high = mid - 1
        else:
            ans = mid
            low = mid + 1
    return ans

def main():
    input = sys.stdin.read
    data = input().split()
    
    n = int(data[0])
    m = int(data[1])
    k = int(data[2])
    t = int(data[3])
    
    waste = []
    
    index = 4
    for _ in range(k):
        a = int(data[index]) - 1
        b = int(data[index + 1]) - 1
        waste.append(a * m + b)
        index += 2
    
    waste.sort()  # Sort waste cells for binary search
    
    results = []
    
    for _ in range(t):
        i = int(data[index]) - 1
        j = int(data[index + 1]) - 1
        index += 2
        
        cell = i * m + j
        
        # Check if cell is waste
        if cell in waste:
            results.append(""Waste"")
        else:
            # Count waste cells before the current cell using binary search
            waste_count = binarySearch(waste, cell) + 1
            
            # Calculate the cultivated cell index
            cultivated_index = cell - waste_count
            
            # Determine crop type based on cultivated index
            crop_type = cultivated_index % 3
            if crop_type == 0:
                results.append(""Carrots"")
            elif crop_type == 1:
                results.append(""Kiwis"")
            else:
                results.append(""Grapes"")
    
    sys.stdout.write(""\n"".join(results) + ""\n"")

if __name__ == ""__main__"":
    main()"
1004,A,Sonya and Hotels,PROGRAMMING,['implementation'],"Sonya decided that having her own hotel business is the best way of earning money because she can profit and rest wherever she wants.

The country where Sonya lives is an endless line. There is a city in each integer coordinate on this line. She has $n$ hotels, where the $i$-th hotel is located in the city with coordinate $x_i$. Sonya is a smart girl, so she does not open two or more hotels in the same city.

Sonya understands that her business needs to be expanded by opening new hotels, so she decides to build one more. She wants to make the minimum distance from this hotel to all others to be equal to $d$. The girl understands that there are many possible locations to construct such a hotel. Thus she wants to know the number of possible coordinates of the cities where she can build a new hotel. 

Because Sonya is lounging in a jacuzzi in one of her hotels, she is asking you to find the number of cities where she can build a new hotel so that the minimum distance from the original $n$ hotels to the new one is equal to $d$.","The first line contains two integers $n$ and $d$ ($1\leq n\leq 100$, $1\leq d\leq 10^9$) — the number of Sonya's hotels and the needed minimum distance from a new hotel to all others.

The second line contains $n$ different integers in strictly increasing order $x_1, x_2, \ldots, x_n$ ($-10^9\leq x_i\leq 10^9$) — coordinates of Sonya's hotels.",Print the number of cities where Sonya can build a new hotel so that the minimum distance from this hotel to all others is equal to $d$.,"['4 3\n-3 2 9 16\n', '5 2\n4 8 11 18 19\n']","['6\n', '5\n']","In the first example, there are $6$ possible cities where Sonya can build a hotel. These cities have coordinates $-6$, $5$, $6$, $12$, $13$, and $19$.

In the second example, there are $5$ possible cities where Sonya can build a hotel. These cities have coordinates $2$, $6$, $13$, $16$, and $21$.",RUNTIME_ERROR,"line1 = input()
line2 = input()
n=int(line1[0])
d=int(line1[2])
city = set(map(int, line2.split()))
d1 = {i+d for i in city}
d2 = {i-d for i in city}
ncity = city | d1 | d2
ncity = sorted(ncity)
min = [ncity[i+1] - ncity[i] for i in range(len(ncity)-1)]
c=0
for i in min:
    if i>=d:
        c += 1
print(c)","def is_subseq(x, y):
    """"""Check whether x is a subsequence of y.""""""
    it = iter(y)
    return all(c in it for c in x)

t, p = input(), input()
a = [e-1 for e in map(int, input().split())]

# Create a list to keep track of removed characters
removed_indices = set()

# Simulate the removal process
for i in range(len(t)):
    removed_indices.add(a[i])  # Mark the index as removed
    # Create the current state of t after removals
    current_t = ''.join(t[j] for j in range(len(t)) if j not in removed_indices)
    # Check if p can still be formed
    if not is_subseq(p, current_t):
        # If p can't be formed, stop and output the number of characters removed
        print(i)
        break
else:
    # If we can remove all letters and still form p, print the length of t
    print(len(t))"
1008,A,Romaji,PROGRAMMING,"['implementation', 'strings']","Vitya has just started learning Berlanese language. It is known that Berlanese uses the Latin alphabet. Vowel letters are ""a"", ""o"", ""u"", ""i"", and ""e"". Other letters are consonant.

In Berlanese, there has to be a vowel after every consonant, but there can be any letter after any vowel. The only exception is a consonant ""n""; after this letter, there can be any letter (not only a vowel) or there can be no letter at all. For example, the words ""harakiri"", ""yupie"", ""man"", and ""nbo"" are Berlanese while the words ""horse"", ""king"", ""my"", and ""nz"" are not.

Help Vitya find out if a word $s$ is Berlanese.",The first line of the input contains the string $s$ consisting of $|s|$ ($1\leq |s|\leq 100$) lowercase Latin letters.,"Print ""YES"" (without quotes) if there is a vowel after every consonant except ""n"", otherwise print ""NO"".

You can print each letter in any case (upper or lower).","['sumimasen\n', 'ninja\n', 'codeforces\n']","['YES\n', 'YES\n', 'NO\n']","In the first and second samples, a vowel goes after each consonant except ""n"", so the word is Berlanese.

In the third sample, the consonant ""c"" goes after the consonant ""r"", and the consonant ""s"" stands on the end, so the word is not Berlanese.",OK,"string=input().lower()
consonants=['b','c','d','f','g','h','j','k','l','m','p','q','r','s','t','v','w','x','y','z']
vowels=['a','e','i','o','u']
ber='YES'
for n in range(len(string)-1):
  if string[n] in consonants:
    if string[n+1] not in vowels:
      ber='NO'
if string[-1] in consonants:
  ber='NO'
print(ber)","def search(current, digits, target, idx, bulk):
    if len(current) == len(target) and int(current) <= int(target):
        print(current)
        exit(0)

    possibilities = [char for char in digits if bulk or (char <= target[idx] and char in digits)]

    if len(possibilities) == 0:
        return

    possibilities.sort(reverse=True)  # Sort possibilities in descending order

    for char in possibilities:
        next_digits = digits.replace(char, '', 1)  # Remove the used digit
        search(current + char, next_digits, target, idx + 1, False)  # Recursive call

if __name__ == ""__main__"":
    a = input().strip()
    b = input().strip()

    digits = ''.join(sorted(a, reverse=True))  # Sort digits of a in descending order
    search('', digits, b, 0, True)  # Start the search"
282,A,Bit++,PROGRAMMING,['implementation'],"The classic programming language of Bitland is Bit++. This language is so peculiar and complicated.

The language is that peculiar as it has exactly one variable, called *x*. Also, there are two operations:
 -  Operation ++ increases the value of variable *x* by 1. -  Operation -- decreases the value of variable *x* by 1. 
A statement in language Bit++ is a sequence, consisting of exactly one operation and one variable *x*. The statement is written without spaces, that is, it can only contain characters ""+"", ""-"", ""X"". Executing a statement means applying the operation it contains.

A programme in Bit++ is a sequence of statements, each of them needs to be executed. Executing a programme means executing all the statements it contains.

You're given a programme in language Bit++. The initial value of *x* is 0. Execute the programme and find its final value (the value of the variable when this programme is executed).","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=150) — the number of statements in the programme.

Next *n* lines contain a statement each. Each statement contains exactly one operation (++ or --) and exactly one variable *x* (denoted as letter «X»). Thus, there are no empty statements. The operation and the variable can be written in any order.",Print a single integer — the final value of *x*.,"['1\n++X\n', '2\nX++\n--X\n']","['1\n', '0\n']",none,OK,"#n is number of statement in the program
x=0
n=int(input())
for i in range(n):
    stmt=input().lower()
    if stmt=='++x' or stmt=='x++':
        x+=1
    elif stmt=='--x' or stmt=='x--':
        x+=-1
print(x)            ","def main():
    st = input()
    distinct_photos = set(st)  # Get unique photos in the original booklet
    distinct_count = len(distinct_photos)  # Count of unique photos
    
    # Set to hold all distinct photobooks
    distinct_photobooks = set()
    
    # Iterate through positions to insert the new photo (from 0 to len(st))
    for i in range(len(st) + 1):
        for photo in distinct_photos:
            # Create a new photobook by inserting 'photo' at position 'i'
            new_photobook = st[:i] + photo + st[i:]
            distinct_photobooks.add(new_photobook)  # Add to the set of distinct photobooks
            
    # Output the count of distinct photobooks
    print(len(distinct_photobooks))"
340,C,Tourist Problem,PROGRAMMING,"['combinatorics', 'implementation', 'math']","Iahub is a big fan of tourists. He wants to become a tourist himself, so he planned a trip. There are *n* destinations on a straight road that Iahub wants to visit. Iahub starts the excursion from kilometer 0. The *n* destinations are described by a non-negative integers sequence *a*1, *a*2, ..., *a**n*. The number *a**k* represents that the *k*th destination is at distance *a**k* kilometers from the starting point. No two destinations are located in the same place. 

Iahub wants to visit each destination only once. Note that, crossing through a destination is not considered visiting, unless Iahub explicitly wants to visit it at that point. Also, after Iahub visits his last destination, he doesn't come back to kilometer 0, as he stops his trip at the last destination. 

The distance between destination located at kilometer *x* and next destination, located at kilometer *y*, is |*x*<=-<=*y*| kilometers. We call a ""route"" an order of visiting the destinations. Iahub can visit destinations in any order he wants, as long as he visits all *n* destinations and he doesn't visit a destination more than once. 

Iahub starts writing out on a paper all possible routes and for each of them, he notes the total distance he would walk. He's interested in the average number of kilometers he would walk by choosing a route. As he got bored of writing out all the routes, he asks you to help him.","The first line contains integer *n* (2<=≤<=*n*<=≤<=105). Next line contains *n* distinct integers *a*1, *a*2, ..., *a**n* (1<=≤<=*a**i*<=≤<=107).",Output two integers — the numerator and denominator of a fraction which is equal to the wanted average number. The fraction must be irreducible.,['3\n2 3 5\n'],['22 3'],"Consider 6 possible routes:
 -  [2, 3, 5]: total distance traveled: |2 – 0| + |3 – 2| + |5 – 3| = 5; -  [2, 5, 3]: |2 – 0| + |5 – 2| + |3 – 5| = 7; -  [3, 2, 5]: |3 – 0| + |2 – 3| + |5 – 2| = 7; -  [3, 5, 2]: |3 – 0| + |5 – 3| + |2 – 5| = 8; -  [5, 2, 3]: |5 – 0| + |2 – 5| + |3 – 2| = 9; -  [5, 3, 2]: |5 – 0| + |3 – 5| + |2 – 3| = 8. 
The average travel distance is <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/29119d3733c79f70eb2d77186ac1606bf938508a.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> = <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/ee9d5516ed2ca1d2b65ed21f8a64f58f94954c30.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> = <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/ed5cc8cb7dd43cfb27f2459586062538e44de7bd.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>.",OK,"#!/usr/bin/env python3
# -*- coding: utf-8 -*-
""""""
Created on Wed Jun  3 11:57:46 2020

@author: shailesh
""""""

from math import gcd

def reduce_fraction(x,y):
    d = gcd(x,y)
    x = x//d
    y = y//d
    return x,y

N = int(input())

A = [int(i) for i in input().split()]

A.sort()

d0 = A[0]


sum_val = 0

for i in range(N-1):
    m_bf = i+2
    m_af = N - i - 1
    d = A[i+1]-A[i]
#    d = 1
    sum_val +=m_af*(2*m_bf - 1)*d
#    print(A[i],A[i+1],sum_val)
numerator = N*d0 + sum_val

denominator = N

numerator,denominator = reduce_fraction(numerator,denominator)

print(numerator,denominator)







#from itertools import permutations
#perms = list(permutations([2,3,5]))
#
#perms = [(0,) + perm for perm in perms]
#
#d = {}
#d['02'] = 0
#d['23'] = 0
#d['35'] = 0
#for perm in perms:
#    for i in range(len(perm)-1):
#        
#        start_end = [perm[i],perm[i+1]]
#        start_end.sort()
#        rng = range(start_end[0],start_end[1]+1)
#        if 0 in rng and 2 in rng:
#            d['02'] +=1
#        if 2 in rng and 3 in rng:
#            d['23'] += 1
#        if 3 in rng and 5 in rng:
#            d['35'] +=1
    
        ","MOD = 10**9 + 7

def slove():
    n = int(input())
    a = list(map(int, input().split(' ')))
    left = 0
    max_length = 0

    for right in range(n):
        # Check if the current range is almost constant
        while a[right] - a[left] > 1:
            left += 1
        # Update the maximum length of almost constant range
        max_length = max(max_length, right - left + 1)

    print(max_length)

slove()"
190,A,Vasya and the Bus,PROGRAMMING,"['greedy', 'math']","One day Vasya heard a story: ""In the city of High Bertown a bus number 62 left from the bus station. It had *n* grown-ups and *m* kids...""

The latter events happen to be of no importance to us. Vasya is an accountant and he loves counting money. So he wondered what maximum and minimum sum of money these passengers could have paid for the ride.

The bus fare equals one berland ruble in High Bertown. However, not everything is that easy — no more than one child can ride for free with each grown-up passenger. That means that a grown-up passenger who rides with his *k* (*k*<=&gt;<=0) children, pays overall *k* rubles: a ticket for himself and (*k*<=-<=1) tickets for his children. Also, a grown-up can ride without children, in this case he only pays one ruble.

We know that in High Bertown children can't ride in a bus unaccompanied by grown-ups.

Help Vasya count the minimum and the maximum sum in Berland rubles, that all passengers of this bus could have paid in total.","The input file consists of a single line containing two space-separated numbers *n* and *m* (0<=≤<=*n*,<=*m*<=≤<=105) — the number of the grown-ups and the number of the children in the bus, correspondingly.","If *n* grown-ups and *m* children could have ridden in the bus, then print on a single line two space-separated integers — the minimum and the maximum possible total bus fare, correspondingly. 

Otherwise, print ""Impossible"" (without the quotes).","['1 2\n', '0 5\n', '2 2\n']","['2 2', 'Impossible', '2 3']","In the first sample a grown-up rides with two children and pays two rubles.

In the second sample there are only children in the bus, so the situation is impossible.
 In the third sample there are two cases: -  Each of the two grown-ups rides with one children and pays one ruble for the tickets. In this case the passengers pay two rubles in total. -  One of the grown-ups ride with two children's and pays two rubles, the another one rides alone and pays one ruble for himself. So, they pay three rubles in total.",WRONG_ANSWER,"a,c=map(int,input().split())
if a==0:
    print('IMPOSSIBLE')
else:
    print(a+(c-a)*int(c>a),a+(c-1)*int(c>1))","def check(row):
    if row.find('OO') != -1:
        return [row.find('OO'), 'YES']
    return ['NO']

rows_num = int(input())
bus = []

# Read the configuration of the bus
for _ in range(rows_num):
    bus.append(input().strip())

# Flag to determine if a pair of seats was found
found = False

# Check each row for empty neighbouring seats
for i in range(rows_num):
    seat_check = check(bus[i])
    if seat_check[1] == 'YES':
        # Found a pair of seats
        index = seat_check[0]
        # Replace the 'OO' with '++'
        bus[i] = bus[i][:index] + '++' + bus[i][index + 2:]
        found = True
        break

# Output the result
if found:
    print(""YES"")
    for line in bus:
        print(line)
else:
    print(""NO"")"
894,A,QAQ,PROGRAMMING,"['brute force', 'dp']","""QAQ"" is a word to denote an expression of crying. Imagine ""Q"" as eyes with tears and ""A"" as a mouth.

Now Diamond has given Bort a string consisting of only uppercase English letters of length *n*. There is a great number of ""QAQ"" in the string (Diamond is so cute!).

Bort wants to know how many subsequences ""QAQ"" are in the string Diamond has given. Note that the letters ""QAQ"" don't have to be consecutive, but the order of letters should be exact.",The only line contains a string of length *n* (1<=≤<=*n*<=≤<=100). It's guaranteed that the string only contains uppercase English letters.,"Print a single integer — the number of subsequences ""QAQ"" in the string.","['QAQAQYSYIOIWIN\n', 'QAQQQZZYNOIWIN\n']","['4\n', '3\n']","In the first example there are 4 subsequences ""QAQ"": ""QAQAQYSYIOIWIN"", ""QAQAQYSYIOIWIN"", ""QAQAQYSYIOIWIN"", ""QAQAQYSYIOIWIN"".",OK,"a = input()
n = len(a)
c = 0
for i in range(n):
    if a[i] == 'Q':
        for j in range(i + 1, n):
            if a[j] == 'A':
                for k in range(j + 1, n):
                    if a[k] == 'Q':
                        c += 1
print(c)","def chc(st):
    nst = ''
    vowels = ""aoyeuiAOYEUI""  # Define the vowels
    for char in st:  # Iterate through each character in the input string
        if char not in vowels:  # Check if the character is not a vowel
            nst += '.' + char.lower()  # Append '.' and lowercase consonant to the result string
    return nst  # Return the processed string"
49,A,Sleuth,PROGRAMMING,['implementation'],"Vasya plays the sleuth with his friends. The rules of the game are as follows: those who play for the first time, that is Vasya is the sleuth, he should investigate a ""crime"" and find out what is happening. He can ask any questions whatsoever that can be answered with ""Yes"" or ""No"". All the rest agree beforehand to answer the questions like that: if the question’s last letter is a vowel, they answer ""Yes"" and if the last letter is a consonant, they answer ""No"". Of course, the sleuth knows nothing about it and his task is to understand that.

Unfortunately, Vasya is not very smart. After 5 hours of endless stupid questions everybody except Vasya got bored. That’s why Vasya’s friends ask you to write a program that would give answers instead of them.

The English alphabet vowels are: A, E, I, O, U, Y

The English alphabet consonants are: B, C, D, F, G, H, J, K, L, M, N, P, Q, R, S, T, V, W, X, Z","The single line contains a question represented by a non-empty line consisting of large and small Latin letters, spaces and a question mark. The line length does not exceed 100. It is guaranteed that the question mark occurs exactly once in the line — as the last symbol and that the line contains at least one letter.","Print answer for the question in a single line: YES if the answer is ""Yes"", NO if the answer is ""No"".

Remember that in the reply to the question the last letter, not the last character counts. I. e. the spaces and the question mark do not count as letters.","['Is it a melon?\n', 'Is it an apple?\n', 'Is     it a banana ?\n', 'Is   it an apple  and a  banana   simultaneouSLY?\n']","['NO\n', 'YES\n', 'YES\n', 'YES\n']",none,WRONG_ANSWER,"a=input()
if a[len(a)-2]==""A"" or a[len(a)-2]==""a"" or a[len(a)-2]==""E"" or a[len(a)-2]==""e"" or a[len(a)-2]==""Y"" or a[len(a)-2]==""y"" or a[len(a)-2]==""U"" or a[len(a)-2]==""u"" or a[len(a)-2]==""I"" or a[len(a)-2]==""i"" or a[len(a)-2]==""O"" or a[len(a)-2]==""o"":
      print('YES')
else:
    print('NO')
","n, m = list(map(int, input().split("" "")))
strings = []
for i in range(n): 
    strings.append(input())

spec = set('#*&')
dig = set('0123456789')
alpha = set('abcdefghijklmnopqrstuvwxyz')

# Initialize the minimum moves required to a large number
min_moves = float('inf')

# Check all possible combinations of characters in the password
for i in range(n):
    for j in range(m):
        # Character on the current pointer
        current_char = strings[i][j]
        
        # Count how many operations are needed to reach this character
        moves = min(j, m - j)  # Minimum moves to bring the pointer to position j

        # Check the validity of the password formation
        has_digit = has_lower = has_spec = False
        
        # Check each character position in the password
        for k in range(n):
            if strings[k][j] in dig:
                has_digit = True
            elif strings[k][j] in alpha:
                has_lower = True
            elif strings[k][j] in spec:
                has_spec = True
        
        # If this combination satisfies all the conditions, consider the moves
        if has_digit and has_lower and has_spec:
            min_moves = min(min_moves, moves)

# Output the minimum number of operations required
print(min_moves)"
650,A,Watchmen,PROGRAMMING,"['data structures', 'geometry', 'math']","Watchmen are in a danger and Doctor Manhattan together with his friend Daniel Dreiberg should warn them as soon as possible. There are *n* watchmen on a plane, the *i*-th watchman is located at point (*x**i*,<=*y**i*).

They need to arrange a plan, but there are some difficulties on their way. As you know, Doctor Manhattan considers the distance between watchmen *i* and *j* to be |*x**i*<=-<=*x**j*|<=+<=|*y**i*<=-<=*y**j*|. Daniel, as an ordinary person, calculates the distance using the formula .

The success of the operation relies on the number of pairs (*i*,<=*j*) (1<=≤<=*i*<=&lt;<=*j*<=≤<=*n*), such that the distance between watchman *i* and watchmen *j* calculated by Doctor Manhattan is equal to the distance between them calculated by Daniel. You were asked to compute the number of such pairs.","The first line of the input contains the single integer *n* (1<=≤<=*n*<=≤<=200<=000) — the number of watchmen.

Each of the following *n* lines contains two integers *x**i* and *y**i* (|*x**i*|,<=|*y**i*|<=≤<=109).

Some positions may coincide.",Print the number of pairs of watchmen such that the distance between them calculated by Doctor Manhattan is equal to the distance calculated by Daniel.,"['3\n1 1\n7 5\n1 5\n', '6\n0 0\n0 1\n0 2\n-1 1\n0 1\n1 1\n']","['2\n', '11\n']","In the first sample, the distance between watchman 1 and watchman 2 is equal to |1 - 7| + |1 - 5| = 10 for Doctor Manhattan and <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/bcb5b7064b5f02088da0fdcf677e6fda495dd0df.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> for Daniel. For pairs (1, 1), (1, 5) and (7, 5), (1, 5) Doctor Manhattan and Daniel will calculate the same distances.",COMPILATION_ERROR,"type
  point = record
    x, y: int64;
    p: boolean;
  end;
  
var
  a, b, c, p, i, j: int64;
  ar: array [1..300000] of point;
  
procedure qsort(a, b: int64);
var
  d, e: int64;
  c, x: point;
  
begin
  if a < b then begin
    d := a;
    e := b;
    x := ar[random(b - a) + a];
    while d <= e do begin
      while ar[d].x < x.x do inc(d);
      while ar[e].x > x.x do dec(e);
      if d <= e then begin
        c := ar[d];
        ar[d] := ar[e];
        ar[e] := c;
        inc(d);
        dec(e);
      end;
    end;
    qsort(a, e);
    qsort(d, b);
  end;
end;

procedure qsort1(a, b: int64);
var
  d, e: int64;
  c, x: point;
  
begin
  if a < b then begin
    d := a;
    e := b;
    x := ar[random(b - a) + a];
    while d <= e do begin  
      while ar[d].y < x.y do inc(d);
      while ar[e].y > x.y do dec(e);
      if d <= e then begin
        c := ar[d];
        ar[d] := ar[e];
        ar[e] := c;
        inc(d);
        dec(e);
      end;
    end;
    qsort1(a, e);
    qsort1(d, b);
  end;
end;
      
  
  
begin
  readln(a);
  i := 1;
  while i <= a do begin
    readln(ar[i].x, ar[i].y);
    inc(i);
  end;
  qsort(1, a);
  i := 1;
  p := 0;
  j := 0;
  while i < a do begin
    if ar[i].x = ar[i + 1].x then inc(p)
      else begin
        inc(p);
        inc(j, p * (p - 1) div 2);
        p := 0;
      end;
    inc(i);
  end;
  inc(p);
  inc(j, p * (p - 1) div 2);
  qsort1(1, a);
  i := 1;
  p := 0;
  while i < a do begin
    if ar[i].y = ar[i + 1].y then inc(p)
      else begin
        inc(p);
        inc(j, p * (p - 1) div 2);
        p := 0;
      end;
    inc(i);
  end;
  inc(p);
  inc(j, p * (p - 1) div 2);
  qsort(1, a);
  i := 1;
  p := 1;
  while i < a do begin
    if ar[i].x <> ar[i + 1].x then begin
      qsort1(p, i);
      p := i + 1;
    end;
    inc(i);
  end;
  i := 1;
  p := 0;
  while i < a do begin
    if (ar[i].x = ar[i + 1].x) and (ar[i].y = ar[i + 1].y) then inc(p)
      else begin
        inc(p);
        dec(j, p * (p - 1) div 2);
        p := 0;
      end;
    inc(i);
  end;
  inc(p);
  dec(j, p * (p - 1) div 2);
  writeln(j);
end.","def spliter():
    d = input()
    a = d.split()
    r = []
    for i in a:
        k = int(i)
        r.append(k)
    return r

def place_chessmen(n, m, board):
    # Initialize the result board with the same bad/good layout
    result = [['-' for _ in range(m)] for _ in range(n)]
    
    # Fill the board with chessmen
    for i in range(n):
        for j in range(m):
            if board[i][j] == '.':
                # Determine the color based on the position
                if (i + j) % 2 == 0:
                    result[i][j] = 'B'  # Black
                else:
                    result[i][j] = 'W'  # White

    return result

# Read input dimensions
n, m = spliter()
# Read the board layout
board = [input().strip() for _ in range(n)]
# Get the chessmen placement
result_board = place_chessmen(n, m, board)

# Print the output
for row in result_board:
    print(''.join(row))"
625,C,K-special Tables,PROGRAMMING,"['constructive algorithms', 'implementation']","People do many crazy things to stand out in a crowd. Some of them dance, some learn by heart rules of Russian language, some try to become an outstanding competitive programmers, while others collect funny math objects.

Alis is among these collectors. Right now she wants to get one of *k*-special tables. In case you forget, the table *n*<=×<=*n* is called *k*-special if the following three conditions are satisfied:
 -  every integer from 1 to *n*2 appears in the table exactly once; -  in each row numbers are situated in increasing order; -  the sum of numbers in the *k*-th column is maximum possible. 
Your goal is to help Alice and find at least one *k*-special table of size *n*<=×<=*n*. Both rows and columns are numbered from 1 to *n*, with rows numbered from top to bottom and columns numbered from left to right.","The first line of the input contains two integers *n* and *k* (1<=≤<=*n*<=≤<=500,<=1<=≤<=*k*<=≤<=*n*) — the size of the table Alice is looking for and the column that should have maximum possible sum.","First print the sum of the integers in the *k*-th column of the required table.

Next *n* lines should contain the description of the table itself: first line should contains *n* elements of the first row, second line should contain *n* elements of the second row and so on.

If there are multiple suitable table, you are allowed to print any.","['4 1\n', '5 3\n']","['28\n1 2 3 4\n5 6 7 8\n9 10 11 12\n13 14 15 16\n', '85\n5 6 17 18 19\n9 10 23 24 25\n7 8 20 21 22\n3 4 14 15 16\n1 2 11 12 13\n\n']",none,OK,"import sys
input = sys.stdin.readline

n, k = map(int, input().split())
d = [[0]*n for _ in range(n)]

x = (k-1)*n + 1
c = 1
if k > 1:
    for i in range(n):
        for j in range(k-1):
            d[i][j] = c
            c += 1
for i in range(n):
    for j in range(k-1, n):
        d[i][j] = c
        c += 1

print(sum(d[i][k-1] for i in range(n)))
for i in d:
    print(' '.join(map(str, i)))","# This is a sample Python script.

def print_hi(name):
    print(f'Hi, {name}')


def can_form_string(s):
    a_count = s.count('a')  # Count the number of 'a's
    b_count = s.count('b')  # Count the number of 'b's
    c_count = s.count('c')  # Count the number of 'c's

    # Check if 'a' and 'b' precede 'c' in the string
    if 'c' in s:
        last_a = s.rfind('a')
        last_b = s.rfind('b')
        first_c = s.find('c')

        # Ensure 'c's come after all 'a's and 'b's
        if last_a > first_c or last_b > first_c:
            return ""NO""

    # Check if the number of 'c's is equal to either the number of 'a's or 'b's
    if c_count == a_count or c_count == b_count:
        return ""YES""
    
    return ""NO""


# Input string
s = input().strip()
# Print result
print(can_form_string(s))"
1006,A,Adjacent Replacements,PROGRAMMING,['implementation'],"Mishka got an integer array $a$ of length $n$ as a birthday present (what a surprise!).

Mishka doesn't like this present and wants to change it somehow. He has invented an algorithm and called it ""Mishka's Adjacent Replacements Algorithm"". This algorithm can be represented as a sequence of steps:
 -  Replace each occurrence of $1$ in the array $a$ with $2$; -  Replace each occurrence of $2$ in the array $a$ with $1$; -  Replace each occurrence of $3$ in the array $a$ with $4$; -  Replace each occurrence of $4$ in the array $a$ with $3$; -  Replace each occurrence of $5$ in the array $a$ with $6$; -  Replace each occurrence of $6$ in the array $a$ with $5$; -  $\dots$ -  Replace each occurrence of $10^9 - 1$ in the array $a$ with $10^9$; -  Replace each occurrence of $10^9$ in the array $a$ with $10^9 - 1$. 
Note that the dots in the middle of this algorithm mean that Mishka applies these replacements for each pair of adjacent integers ($2i - 1, 2i$) for each $i \in\{1, 2, \ldots, 5 \cdot 10^8\}$ as described above.

For example, for the array $a = [1, 2, 4, 5, 10]$, the following sequence of arrays represents the algorithm: 

$[1, 2, 4, 5, 10]$ $\rightarrow$ (replace all occurrences of $1$ with $2$) $\rightarrow$ $[2, 2, 4, 5, 10]$ $\rightarrow$ (replace all occurrences of $2$ with $1$) $\rightarrow$ $[1, 1, 4, 5, 10]$ $\rightarrow$ (replace all occurrences of $3$ with $4$) $\rightarrow$ $[1, 1, 4, 5, 10]$ $\rightarrow$ (replace all occurrences of $4$ with $3$) $\rightarrow$ $[1, 1, 3, 5, 10]$ $\rightarrow$ (replace all occurrences of $5$ with $6$) $\rightarrow$ $[1, 1, 3, 6, 10]$ $\rightarrow$ (replace all occurrences of $6$ with $5$) $\rightarrow$ $[1, 1, 3, 5, 10]$ $\rightarrow$ $\dots$ $\rightarrow$ $[1, 1, 3, 5, 10]$ $\rightarrow$ (replace all occurrences of $10$ with $9$) $\rightarrow$ $[1, 1, 3, 5, 9]$. The later steps of the algorithm do not change the array.

Mishka is very lazy and he doesn't want to apply these changes by himself. But he is very interested in their result. Help him find it.","The first line of the input contains one integer number $n$ ($1 \le n \le 1000$) — the number of elements in Mishka's birthday present (surprisingly, an array).

The second line of the input contains $n$ integers $a_1, a_2, \dots, a_n$ ($1 \le a_i \le 10^9$) — the elements of the array.","Print $n$ integers — $b_1, b_2, \dots, b_n$, where $b_i$ is the final value of the $i$-th element of the array after applying ""Mishka's Adjacent Replacements Algorithm"" to the array $a$. Note that you cannot change the order of elements in the array.","['5\n1 2 4 5 10\n', '10\n10000 10 50605065 1 5 89 5 999999999 60506056 1000000000\n']","['1 1 3 5 9\n', '9999 9 50605065 1 5 89 5 999999999 60506055 999999999\n']",The first example is described in the problem statement.,OK,"n = int(input())
a = [int(s) for s in input().split(' ')]
b = [str(c - ((c + 1) % 2)) for c in a]
print(' '.join(b))
","def holidaymax(n):
    if n <= 0:
        return 0
    elif 0 < n <= 2:
        return n
    else:
        return (n // 7) * 2 + min(n % 7, 2)

def holidaymin(n):
    if n <= 5:
        return 0
    else:
        return (n // 7) * 2 + max(0, (n % 7) - 5)

n = int(input())
min_days_off = holidaymin(n)
max_days_off = holidaymax(n)
print(min_days_off, max_days_off)"
21,A,Jabber ID,PROGRAMMING,"['implementation', 'strings']","Jabber ID on the national Berland service «Babber» has a form &lt;username&gt;@&lt;hostname&gt;[/resource], where 
 -  &lt;username&gt; — is a sequence of Latin letters (lowercase or uppercase), digits or underscores characters «_», the length of &lt;username&gt; is between 1 and 16, inclusive. -  &lt;hostname&gt; — is a sequence of word separated by periods (characters «.»), where each word should contain only characters allowed for &lt;username&gt;, the length of each word is between 1 and 16, inclusive. The length of &lt;hostname&gt; is between 1 and 32, inclusive. -  &lt;resource&gt; — is a sequence of Latin letters (lowercase or uppercase), digits or underscores characters «_», the length of &lt;resource&gt; is between 1 and 16, inclusive. 
The content of square brackets is optional — it can be present or can be absent.

There are the samples of correct Jabber IDs: [[email protected]](/cdn-cgi/l/email-protection), [[email protected]](/cdn-cgi/l/email-protection)/contest.

Your task is to write program which checks if given string is a correct Jabber ID.","The input contains of a single line. The line has the length between 1 and 100 characters, inclusive. Each characters has ASCII-code between 33 and 127, inclusive.",Print YES or NO.,"['[email\xa0protected]\n', '[email\xa0protected]/contest.icpc/12\n']","['YES\n', 'NO\n']",none,WRONG_ANSWER,"def norm(str):
    for i in range(len(str)):
        if (33<= ord(str[i])<= 127) or (ord('0')<= ord(str[i])<= ord('9')) or str[i]== '_':
            pass
        else:
            return False
        if not (0 <len(str[i])< 17): return False
    return True
def fin():
    print('NO')
    quit()
    
j= input()
j.lower()
res= ''
bool= True
bool_res= False
if '@' in j:
    user= j.split('@')[0]
    host= j.split('@')[1]
else:
    fin()
if '/' in host:
    bool_res= True
    host= host.split('/')[0]
    res= j.split('/')[-1]
    if not norm(res): fin()

if not norm(user): fin()

if not (0 <len(host)< 33): fin()

Host= host.split('.')
for i in range(len(Host)):
    if not norm(Host[i]): fin()
        
if (bool_res & (len(j)== len(user)+ len(host)+ len(res)+2)) or (len(j)== len(user)+ len(host)+ 1):
    pass
else:
    fin()

print('YES')
quit()
","def main():
    n, m = map(int, input().split())  # Read n and m
    st = list(input())  # Read the string and convert it to a list for mutability

    # Process each operation
    for _ in range(m):
        l, r, c1, c2 = input().split()  # Read operation parameters
        l, r = int(l) - 1, int(r) - 1  # Convert to 0-based index

        # Perform the character replacement in the specified range
        for i in range(l, r + 1):
            if st[i] == c1:
                st[i] = c2

    print("""".join(st))  # Output the final string

if __name__ == ""__main__"":
    main()  # Invoke the main function"
797,A,k-Factorization,PROGRAMMING,"['implementation', 'math', 'number theory']","Given a positive integer *n*, find *k* integers (not necessary distinct) such that all these integers are strictly greater than 1, and their product is equal to *n*.","The first line contains two integers *n* and *k* (2<=≤<=*n*<=≤<=100000, 1<=≤<=*k*<=≤<=20).","If it's impossible to find the representation of *n* as a product of *k* numbers, print -1.

Otherwise, print *k* integers in any order. Their product must be equal to *n*. If there are multiple answers, print any of them.","['100000 2\n', '100000 20\n', '1024 5\n']","['2 50000 \n', '-1\n', '2 64 2 2 2 \n']",none,WRONG_ANSWER,"n,k=map(int,input().split())

i=2
l=[]

cnt=0
while(i*i<=n):
    if(n%i==0):
        while(n%i==0):
            n=n//i
            l.append(i)
        
        
    i+=1
    

if(n>1):
    l.append(n)
    
if(len(l)==k):
    print(l)

elif(len(l)<k):
    print(-1)
else:
    ans=1
    l1=l[k-1:]
    for i in l1:
        ans*=i
        
    p=[i for i in l[:k-1]]
    p.append(ans)
    print(*p)","from sys import stdin, stdout


def read_list():  # read list of variables
    return [int(x) for x in stdin.readline().split()]


def read_list_str():  # read list of strings
    return stdin.readline().split()


def main():
    n = int(stdin.readline().strip())  # number of items
    items = []
    
    for _ in range(n):
        t, c = read_list()  # read time and cost for each item
        items.append((t, c))  # store as tuple in the list
    
    # Sort items by cost in ascending order
    items.sort(key=lambda x: x[1])
    
    total_cost = 0
    time_spent = 0  # total time Bob has spent stealing
    
    for t, c in items:
        time_spent += t  # time spent on current item
        if time_spent > n:  # can't steal more than `n` items
            time_spent = n  # limit the time to `n`
        total_cost += c  # add cost of current item
        
        # Steal items while time allows
        if time_spent < n:  # if there's still time to steal
            stolen_items = n - time_spent  # can steal this many items
            total_cost -= stolen_items * c  # decrease total cost
    
    stdout.write(f""{total_cost}\n"")  # output the total cost


if __name__ == ""__main__"":
    main()"
443,A,Anton and Letters,PROGRAMMING,"['constructive algorithms', 'implementation']","Recently, Anton has found a set. The set consists of small English letters. Anton carefully wrote out all the letters from the set in one line, separated by a comma. He also added an opening curved bracket at the beginning of the line and a closing curved bracket at the end of the line. 

Unfortunately, from time to time Anton would forget writing some letter and write it again. He asks you to count the total number of distinct letters in his set.","The first and the single line contains the set of letters. The length of the line doesn't exceed 1000. It is guaranteed that the line starts from an opening curved bracket and ends with a closing curved bracket. Between them, small English letters are listed, separated by a comma. Each comma is followed by a space.",Print a single number — the number of distinct letters in Anton's set.,"['{a, b, c}\n', '{b, a, b, a}\n', '{}\n']","['3\n', '2\n', '0\n']",none,OK,"a = input()
p=[]
for i in a:
    if(i.isalpha()==True):
        p.append(i)
s=list(set(p))
print(len(s))","n, a, b, c, d = map(int, input().split())
dx = [0, 0, -1, 1]
dy = [1, -1, 0, 0]

# Create a visited array to track positions
vis = [[0] * (n + 1) for _ in range(n + 1)]

def is_on_edge(x, y):
    # Check if the point is on the edge of the square
    return (x == 0 or x == n or y == 0 or y == n)

def shortest_distance(a, b, c, d):
    # Calculate the minimum distance based on edge cases
    distances = []
    
    # Direct paths along the edges
    # (a,b) to (c,d)
    if a == c:  # Same vertical line
        distances.append(abs(b - d))
    elif b == d:  # Same horizontal line
        distances.append(abs(a - c))
    else:
        # Calculate distances by going around the corners
        distances.append(abs(a - 0) + abs(b - c) + abs(d - 0))  # Go left then up/down
        distances.append(abs(a - n) + abs(b - c) + abs(d - n))  # Go right then up/down
        distances.append(abs(b - 0) + abs(a - d) + abs(c - 0))  # Go down then left/right
        distances.append(abs(b - n) + abs(a - d) + abs(c - n))  # Go up then left/right

    return min(distances)

# Calculate and print the shortest distance
result = shortest_distance(a, b, c, d)
print(result)"
985,B,Switches and Lamps,PROGRAMMING,['implementation'],"You are given *n* switches and *m* lamps. The *i*-th switch turns on some subset of the lamps. This information is given as the matrix *a* consisting of *n* rows and *m* columns where *a**i*,<=*j*<==<=1 if the *i*-th switch turns on the *j*-th lamp and *a**i*,<=*j*<==<=0 if the *i*-th switch is not connected to the *j*-th lamp.

Initially all *m* lamps are turned off.

Switches change state only from ""off"" to ""on"". It means that if you press two or more switches connected to the same lamp then the lamp will be turned on after any of this switches is pressed and will remain its state even if any switch connected to this lamp is pressed afterwards.

It is guaranteed that if you push all *n* switches then all *m* lamps will be turned on.

Your think that you have too many switches and you would like to ignore one of them. 

Your task is to say if there exists such a switch that if you will ignore (not use) it but press all the other *n*<=-<=1 switches then all the *m* lamps will be turned on.","The first line of the input contains two integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=2000) — the number of the switches and the number of the lamps.

The following *n* lines contain *m* characters each. The character *a**i*,<=*j* is equal to '1' if the *i*-th switch turns on the *j*-th lamp and '0' otherwise.

It is guaranteed that if you press all *n* switches all *m* lamps will be turned on.","Print ""YES"" if there is a switch that if you will ignore it and press all the other *n*<=-<=1 switches then all *m* lamps will be turned on. Print ""NO"" if there is no such switch.","['4 5\n10101\n01000\n00111\n10000\n', '4 5\n10100\n01000\n00110\n00101\n']","['YES\n', 'NO\n']",none,WRONG_ANSWER,"n,m = [int(i) for i in input().split()]
l = []
for i in range(n):
	l.append(input())
cnt = m*[0]
for i in range(m):
	for j in range(n):
		cnt[i]+=int(l[j][i])
ans = 'NO'
#print(*cnt)
t = 0
for i in range(m):
	if cnt[i]>=2:
		t+=1
if t >= 2:
	ans = 'YES'
print(ans)
","arr.extend(list(map(int, input().rstrip().split())))

        # Check if all elements have the same remainder when divided by d
        if all((num - arr[0]) % d == 0 for num in arr):
            # Normalize the array by dividing all elements by d
            normalized_arr = [num // d for num in arr]
            # Sort the normalized array to find the median
            normalized_arr.sort()
            median = normalized_arr[len(normalized_arr) // 2]

            # Calculate the total moves to make all elements equal to the median
            moves = sum(abs(num - median) for num in normalized_arr)

            print(moves)
        else:
            print(-1)"
220,B,Little Elephant and Array,PROGRAMMING,"['constructive algorithms', 'data structures']","The Little Elephant loves playing with arrays. He has array *a*, consisting of *n* positive integers, indexed from 1 to *n*. Let's denote the number with index *i* as *a**i*. 

Additionally the Little Elephant has *m* queries to the array, each query is characterised by a pair of integers *l**j* and *r**j* (1<=≤<=*l**j*<=≤<=*r**j*<=≤<=*n*). For each query *l**j*,<=*r**j* the Little Elephant has to count, how many numbers *x* exist, such that number *x* occurs exactly *x* times among numbers *a**l**j*,<=*a**l**j*<=+<=1,<=...,<=*a**r**j*.

Help the Little Elephant to count the answers to all queries.","The first line contains two space-separated integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=105) — the size of array *a* and the number of queries to it. The next line contains *n* space-separated positive integers *a*1, *a*2, ..., *a**n* (1<=≤<=*a**i*<=≤<=109). Next *m* lines contain descriptions of queries, one per line. The *j*-th of these lines contains the description of the *j*-th query as two space-separated integers *l**j* and *r**j* (1<=≤<=*l**j*<=≤<=*r**j*<=≤<=*n*).",In *m* lines print *m* integers — the answers to the queries. The *j*-th line should contain the answer to the *j*-th query.,['7 2\n3 1 2 2 3 3 7\n1 7\n3 4\n'],['3\n1\n'],none,RUNTIME_ERROR,"def add(elem, count):
    count[elem] += 1
    if count[elem] == elem:
        global answer
        answer += 1

def remove(elem, count):
    count[elem] -= 1
    # case our count gets below the element count
    if count[elem] == elem-1:
        global answer
        answer -= 1


def process_queries(queries, array):
    from collections import defaultdict

    currentL = 1
    currentR = 1
    count = defaultdict(int)
    ans = {}
    for querie in queries:
        while currentL < querie[0]:
            elem = array[currentL-1]
            remove(elem, count)
            currentL += 1
        while currentL > querie[0]:
            elem = array[currentL-1]
            add(elem, count)
            currentL -= 1
        while currentR < querie[1]:
            elem = array[currentR-1]
            add(elem, count)
            currentR += 1
        while currentR > querie[1]:
            elem = array[currentR-1]
            remove(elem, count)
            currentR -= 1
        ans[querie] = answer

    return ans

def mos_algorithm(queries):
    from math import ceil, sqrt

    block_len = int(ceil(sqrt(len(queries))))
    blocks = [[] for x in range(block_len)]
    for q in queries:
        pos = q[0] // block_len
        blocks[pos].append(q)

    queries2 = [sorted(x, lambda x:x[1]) for x in blocks]
    queries2 = [item for sublist in queries2 for item in sublist]
    return queries2

if __name__ == ""__main__"":
    from sys import stdin, stdout


    # global var answer
    answer = 0

    alist = [line.strip() for line in stdin]
    array = list(map(int, alist[1].split()))
    queries = [tuple(map(int, x.split()))for x in alist[2:]]
    sorted_queries = mos_algorithm(queries)
    ans = process_queries(sorted_queries, array)

    for q in queries:
        print(ans[q])
","def main():
    x, y, a, b = map(int, input().split())
    u, v = x, y

    # Calculate the least common multiple of x and y
    def gcd(a, b):
        while b:
            a, b = b, a % b
        return a

    def lcm(a, b):
        return a * b // gcd(a, b)

    # Find LCM of x and y
    multiple = lcm(u, v)

    # Calculate the number of multiples of 'multiple' in the range [a, b]
    first_multiple = (a + multiple - 1) // multiple
    last_multiple = b // multiple

    # Number of bricks painted both red and pink
    count = max(0, last_multiple - first_multiple + 1)

    print(count)

if __name__ == ""__main__"":
    main()"
11,D,A Simple Task,PROGRAMMING,"['bitmasks', 'dp', 'graphs']","Given a simple graph, output the number of simple cycles in it. A simple cycle is a cycle with no repeated vertices or edges.","The first line of input contains two integers *n* and *m* (1<=≤<=*n*<=≤<=19, 0<=≤<=*m*) – respectively the number of vertices and edges of the graph. Each of the subsequent *m* lines contains two integers *a* and *b*, (1<=≤<=*a*,<=*b*<=≤<=*n*, *a*<=≠<=*b*) indicating that vertices *a* and *b* are connected by an undirected edge. There is no more than one edge connecting any pair of vertices.",Output the number of cycles in the given graph.,['4 6\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4\n'],['7\n'],The example graph is a clique and contains four cycles of length 3 and three cycles of length 4.,WRONG_ANSWER,"n, m = map(int, input().split())
graph = [[] for _ in range(n)]
for i in range(m):
    a, b = map(int, input().split())
    graph[a-1].append(b-1)
    graph[b-1].append(a-1)

def dfs(vertex, visited, path):
    visited[vertex] = True
    path.append(vertex)
    count = 0
    for neighbor in graph[vertex]:
        if neighbor == path[0]:
            count += 1  # found a cycle
        elif not visited[neighbor]:
            count += dfs(neighbor, visited, path)
    path.pop()
    visited[vertex] = False
    return count

cycles = 0
for i in range(n):
    visited = [False] * n
    cycles += dfs(i, visited, [])
print(cycles//2)  # divide by 2 as each cycle is counted twice
","def solve(n, k, a, b):
    ans = 0
    while n != 1:
        if n < k:
            ans += (n - 1) * a
            n = 1
        elif n % k == 0:
            # If divisible by k, choose the cheaper operation 
            ans += b
            n //= k
        else:
            # Determine the number of subtractions needed to make n divisible by k
            next_divisible = (n // k) * k
            subtract_steps = n - next_divisible
            ans += subtract_steps * a
            n = next_divisible
    return ans"
805,B,3-palindrome,PROGRAMMING,['constructive algorithms'],"In the beginning of the new year Keivan decided to reverse his name. He doesn't like palindromes, so he changed Naviek to Navick.

He is too selfish, so for a given *n* he wants to obtain a string of *n* characters, each of which is either 'a', 'b' or 'c', with no palindromes of length 3 appearing in the string as a substring. For example, the strings ""abc"" and ""abca"" suit him, while the string ""aba"" doesn't. He also want the number of letters 'c' in his string to be as little as possible.",The first line contains single integer *n* (1<=≤<=*n*<=≤<=2·105) — the length of the string.,"Print the string that satisfies all the constraints.

If there are multiple answers, print any of them.","['2\n', '3\n']","['aa\n', 'bba\n']",A palindrome is a sequence of characters which reads the same backward and forward.,OK,"n = int(input())
s = 'bbaa' * (n // 4 + 1)
s = s[:n]
print(s)","import sys
input = lambda: sys.stdin.readline().rstrip()
import math
from heapq import heappush , heappop
from collections import defaultdict,deque,Counter
from bisect import *
import itertools

# Read input values
n, k = map(int, input().split())
numbers = [input() for _ in range(n)]

# Function to rearrange the digits according to a specific order
def rearrange_numbers(order):
    rearranged = []
    for number in numbers:
        rearranged.append(''.join(number[i] for i in order))
    return rearranged

# Generate all possible orders of the digits
min_difference = float('inf')
indices = list(range(k))
for order in itertools.permutations(indices):
    rearranged = rearrange_numbers(order)
    max_num = max(rearranged)
    min_num = min(rearranged)
    difference = int(max_num) - int(min_num)
    min_difference = min(min_difference, difference)

# Output the minimal possible difference
print(min_difference)"
242,B,Big Segment,PROGRAMMING,"['implementation', 'sortings']","A coordinate line has *n* segments, the *i*-th segment starts at the position *l**i* and ends at the position *r**i*. We will denote such a segment as [*l**i*,<=*r**i*].

You have suggested that one of the defined segments covers all others. In other words, there is such segment in the given set, which contains all other ones. Now you want to test your assumption. Find in the given set the segment which covers all other segments, and print its number. If such a segment doesn't exist, print -1.

Formally we will assume that segment [*a*,<=*b*] covers segment [*c*,<=*d*], if they meet this condition *a*<=≤<=*c*<=≤<=*d*<=≤<=*b*.","The first line contains integer *n* (1<=≤<=*n*<=≤<=105) — the number of segments. Next *n* lines contain the descriptions of the segments. The *i*-th line contains two space-separated integers *l**i*,<=*r**i* (1<=≤<=*l**i*<=≤<=*r**i*<=≤<=109) — the borders of the *i*-th segment.

It is guaranteed that no two segments coincide.","Print a single integer — the number of the segment that covers all other segments in the set. If there's no solution, print -1.

The segments are numbered starting from 1 in the order in which they appear in the input.","['3\n1 1\n2 2\n3 3\n', '6\n1 5\n2 3\n1 10\n7 10\n7 7\n10 10\n']","['-1\n', '3\n']",none,OK,"n=int(input())
L=[]
aG=0;
mini = 1000000000
maxi = -1000000000;
for i in range(0,n):
    a=input().rstrip().split(' ')
    L.append(a)
    if int(a[0])<=mini and int(a[1])>=maxi:
        G=int(a[0]);
        H=int(a[1]);
        S=i;
        mini = int(a[0])
        maxi = int(a[1])
#print(S,mini,maxi)
for i in range(0,len(L)):
    A=L[i];
   # print(A)
    if int(A[0])>=mini and int(A[0])<=maxi and int(A[1])>=mini and int(A[1]) <= maxi:
        continue;
    else:
        aG=1;
        break;
       # print(i)
if aG==1:
    print(-1)
else:
    print(S+1);","def rng(s, k, lst):
    # s is the total number of people and k is the max height of the fence
    count = s
    for height in lst:
        if height > k:
            count += 1  # If the friend's height is greater than the fence, they take width 2
    return count

# Input reading
n, h = map(int, input().split())  # Read the number of friends and the height of the fence
a = list(map(int, input().split()))  # Read the heights of the friends

# Calculate the minimum width and print it
min_width = rng(n, h, a)
print(min_width)"
920,A,Water The Garden,PROGRAMMING,['implementation'],"It is winter now, and Max decided it's about time he watered the garden.

The garden can be represented as *n* consecutive garden beds, numbered from 1 to *n*. *k* beds contain water taps (*i*-th tap is located in the bed *x**i*), which, if turned on, start delivering water to neighbouring beds. If the tap on the bed *x**i* is turned on, then after one second has passed, the bed *x**i* will be watered; after two seconds have passed, the beds from the segment [*x**i*<=-<=1,<=*x**i*<=+<=1] will be watered (if they exist); after *j* seconds have passed (*j* is an integer number), the beds from the segment [*x**i*<=-<=(*j*<=-<=1),<=*x**i*<=+<=(*j*<=-<=1)] will be watered (if they exist). Nothing changes during the seconds, so, for example, we can't say that the segment [*x**i*<=-<=2.5,<=*x**i*<=+<=2.5] will be watered after 2.5 seconds have passed; only the segment [*x**i*<=-<=2,<=*x**i*<=+<=2] will be watered at that moment.

Max wants to turn on all the water taps at the same moment, and now he wonders, what is the minimum number of seconds that have to pass after he turns on some taps until the whole garden is watered. Help him to find the answer!","The first line contains one integer *t* — the number of test cases to solve (1<=≤<=*t*<=≤<=200).

Then *t* test cases follow. The first line of each test case contains two integers *n* and *k* (1<=≤<=*n*<=≤<=200, 1<=≤<=*k*<=≤<=*n*) — the number of garden beds and water taps, respectively.

Next line contains *k* integers *x**i* (1<=≤<=*x**i*<=≤<=*n*) — the location of *i*-th water tap. It is guaranteed that for each  condition *x**i*<=-<=1<=&lt;<=*x**i* holds.

It is guaranteed that the sum of *n* over all test cases doesn't exceed 200.

Note that in hacks you have to set *t*<==<=1.","For each test case print one integer — the minimum number of seconds that have to pass after Max turns on some of the water taps, until the whole garden is watered.",['3\n5 1\n3\n3 3\n1 2 3\n4 1\n1\n'],['3\n1\n4\n'],"The first example consists of 3 tests:
 1.  There are 5 garden beds, and a water tap in the bed 3. If we turn it on, then after 1 second passes, only bed 3 will be watered; after 2 seconds pass, beds [1, 3] will be watered, and after 3 seconds pass, everything will be watered. 1.  There are 3 garden beds, and there is a water tap in each one. If we turn all of them on, then everything will be watered after 1 second passes. 1.  There are 4 garden beds, and only one tap in the bed 1. It will take 4 seconds to water, for example, bed 4.",WRONG_ANSWER,"t = int(input())

for _ in range(t):
	n, k = map(int, input().split())
	arr = list(map(int, input().split()))
	s = 1
	t = [False] * n
	for i in arr:
		t[i-1] = True
	while set(t) != {True}:
		q = list(t)
		s += 1
		for j in range(n):
			if j+1 < n:
				if q[j+1] == True:
					t[j] = True
			if j-1 < n:		
				if q[j-1] == True:
					t[j] = True
	print(s)	","from sys import stdin, stdout

# Function to read input and process it
def main():
    # Read four lines of input
    lines = [stdin.readline().strip() for _ in range(4)]
    
    # Convert input lines to integers
    digits = list(map(int, lines))
    
    # Calculate the output as the bitwise XOR of the digits
    result = digits[0] ^ digits[1] ^ digits[2] ^ digits[3]
    
    # Print the result (either 0 or 1)
    stdout.write(str(result) + ""\n"")

# Call the main function
if __name__ == ""__main__"":
    main()"
25,A,IQ test,PROGRAMMING,['brute force'],"Bob is preparing to pass IQ test. The most frequent task in this test is to find out which one of the given *n* numbers differs from the others. Bob observed that one number usually differs from the others in evenness. Help Bob — to check his answers, he needs a program that among the given *n* numbers finds one that is different in evenness.","The first line contains integer *n* (3<=≤<=*n*<=≤<=100) — amount of numbers in the task. The second line contains *n* space-separated natural numbers, not exceeding 100. It is guaranteed, that exactly one of these numbers differs from the others in evenness.",Output index of number that differs from the others in evenness. Numbers are numbered from 1 in the input order.,"['5\n2 4 7 8 10\n', '4\n1 2 1 1\n']","['3\n', '2\n']",none,WRONG_ANSWER,"n=int(input())
lst=[int(i) for i in input().split()]
diff_lst=[]
for i in range(len(lst)-1):
    diff_lst.append(lst[i]-lst[i+1])
diff_prop=0
for i in set(diff_lst):
    if i!=max(set(diff_lst)) and i!=min(set(diff_lst)):
        diff_prop=i
        break
ans=0
for i in range(len(diff_lst)):
    if diff_lst[i]!=diff_prop:
        ans=i+2
        break
print(ans)","import heapq
from collections import defaultdict
import sys

class Edge:
    def __init__(self, s, d, w):
        self.source = s
        self.destination = d
        self.weight = w
        self.next = None

class Solution:
    def minimumConcertCost(self, n, m, routes, prices):
        graph = defaultdict(list)
        
        # Build the graph from routes
        for v, u, w in routes:
            graph[v].append((u, w))
            graph[u].append((v, w))
        
        # Function to perform Dijkstra's Algorithm
        def dijkstra(start):
            min_cost = [sys.maxsize] * (n + 1)
            min_cost[start] = 0
            priority_queue = [(0, start)]  # (cost, node)
            
            while priority_queue:
                current_cost, current_node = heapq.heappop(priority_queue)
                
                if current_cost > min_cost[current_node]:
                    continue
                
                for neighbor, weight in graph[current_node]:
                    cost = current_cost + weight
                    if cost < min_cost[neighbor]:
                        min_cost[neighbor] = cost
                        heapq.heappush(priority_queue, (cost, neighbor))
            
            return min_cost
        
        result = []
        
        # Calculate minimum cost for each city
        for i in range(1, n + 1):
            min_travel_cost = dijkstra(i)
            min_total_cost = min_travel_cost[i] + prices[i - 1]  # Include concert price at city i
            for j in range(1, n + 1):
                if j != i:
                    if min_travel_cost[j] != sys.maxsize:
                        min_total_cost = min(min_total_cost, min_travel_cost[j] + prices[j - 1])
            result.append(min_total_cost)
        
        return result

# Read inputs
n, m = map(int, input().split())
routes = [tuple(map(int, input().split())) for _ in range(m)]
prices = list(map(int, input().split()))

# Create instance of Solution and get result
sol = Solution()
result = sol.minimumConcertCost(n, m, routes, prices)

# Print results
print(' '.join(map(str, result)))"
946,A,Partition,PROGRAMMING,['greedy'],"You are given a sequence *a* consisting of *n* integers. You may partition this sequence into two sequences *b* and *c* in such a way that every element belongs exactly to one of these sequences. 

Let *B* be the sum of elements belonging to *b*, and *C* be the sum of elements belonging to *c* (if some of these sequences is empty, then its sum is 0). What is the maximum possible value of *B*<=-<=*C*?","The first line contains one integer *n* (1<=≤<=*n*<=≤<=100) — the number of elements in *a*.

The second line contains *n* integers *a*1, *a*2, ..., *a**n* (<=-<=100<=≤<=*a**i*<=≤<=100) — the elements of sequence *a*.","Print the maximum possible value of *B*<=-<=*C*, where *B* is the sum of elements of sequence *b*, and *C* is the sum of elements of sequence *c*.","['3\n1 -2 0\n', '6\n16 23 16 15 42 8\n']","['3\n', '120\n']","In the first example we may choose *b* = {1, 0}, *c* = { - 2}. Then *B* = 1, *C* =  - 2, *B* - *C* = 3.

In the second example we choose *b* = {16, 23, 16, 15, 42, 8}, *c* = {} (an empty sequence). Then *B* = 120, *C* = 0, *B* - *C* = 120.",OK,"n = int(input())
b, c = 0, 0
for i in map(int, input().split()):
    if i < 0:
        c += i
    else:
        b += i

print(b - c)

 	   		   	 	  	   	   		 	 	 	","memoization_table = {}

def compute_count(previous_max, rest):
    global memoization_table 
    original_rest = rest

    # Base case: if the rest is 0, no more operations are needed
    if rest == 0:
        return 0

    # If the result is already computed, return it
    if (previous_max, rest) in memoization_table:
        return memoization_table[(previous_max, rest)] 

    # Get the digits in the current number
    digits = [int(digit) for digit in str(rest) if int(digit) <= previous_max]

    # If there are no valid digits, return a large number (impossible case)
    if not digits:
        return float('inf')

    # Calculate the minimum number of operations
    min_operations = float('inf')
    for digit in digits:
        next_rest = rest - digit
        # Explore the next state being careful of the maximum digit we can use
        min_operations = min(min_operations, 1 + compute_count(digit, next_rest))

    # Store the result in the memoization table
    memoization_table[(previous_max, rest)] = min_operations
    return min_operations

def min_subtractions_to_zero(n):
    return compute_count(9, n)

# Example of how to read input and use the function
if __name__ == ""__main__"":
    n = int(input().strip())
    print(min_subtractions_to_zero(n))"
975,C,Valhalla Siege,PROGRAMMING,['binary search'],"Ivar the Boneless is a great leader. He is trying to capture Kattegat from Lagertha. The war has begun and wave after wave Ivar's warriors are falling in battle.

Ivar has $n$ warriors, he places them on a straight line in front of the main gate, in a way that the $i$-th warrior stands right after $(i-1)$-th warrior. The first warrior leads the attack.

Each attacker can take up to $a_i$ arrows before he falls to the ground, where $a_i$ is the $i$-th warrior's strength.

Lagertha orders her warriors to shoot $k_i$ arrows during the $i$-th minute, the arrows one by one hit the first still standing warrior. After all Ivar's warriors fall and all the currently flying arrows fly by, Thor smashes his hammer and all Ivar's warriors get their previous strengths back and stand up to fight again. In other words, if all warriors die in minute $t$, they will all be standing to fight at the end of minute $t$.

The battle will last for $q$ minutes, after each minute you should tell Ivar what is the number of his standing warriors.","The first line contains two integers $n$ and $q$ ($1 \le n, q \leq 200\,000$) — the number of warriors and the number of minutes in the battle.

The second line contains $n$ integers $a_1, a_2, \ldots, a_n$ ($1 \leq a_i \leq 10^9$) that represent the warriors' strengths.

The third line contains $q$ integers $k_1, k_2, \ldots, k_q$ ($1 \leq k_i \leq 10^{14}$), the $i$-th of them represents Lagertha's order at the $i$-th minute: $k_i$ arrows will attack the warriors.","Output $q$ lines, the $i$-th of them is the number of standing warriors after the $i$-th minute.","['5 5\n1 2 1 2 1\n3 10 1 1 1\n', '4 4\n1 2 3 4\n9 1 10 6\n']","['3\n5\n4\n4\n3\n', '1\n4\n4\n1\n']","In the first example: 
 -  after the 1-st minute, the 1-st and 2-nd warriors die. -  after the 2-nd minute all warriors die (and all arrows left over are wasted), then they will be revived thus answer is 5 — all warriors are alive. -  after the 3-rd minute, the 1-st warrior dies. -  after the 4-th minute, the 2-nd warrior takes a hit and his strength decreases by 1. -  after the 5-th minute, the 2-nd warrior dies.",TIME_LIMIT_EXCEEDED,"n,q=map(int,input().split())
a,cd,cc=list(map(int,input().split())),0,0
for k in input().split():
    k=int(k)
    while k:
        if a[cc]<=k+cd:
            cd-=a[cc]
            if cd<0:
                cd,k=0,k+cd
            cc+=1
        else:
            cd,k=k+cd,0
        if cc>=n:
            break
    if cc>=n:
        cc=0
    print(n-cc)
","def main():
    name = input()
    substring = input()
    count = 0
    
    # Lengths of the main name and the substring
    len_name = len(name)
    len_substring = len(substring)

    # Iterate through the main name to find occurrences of the substring
    i = 0
    while i <= len_name - len_substring:
        # Check if the substring is found
        if name[i:i + len_substring] == substring:
            count += 1  # Increment the count of replacements
            # Replace the first character of the found substring with ""#""
            name = name[:i] + '#' + name[i + 1:]
            # Move the index forward to check the next possible position
            i += 1
        else:
            i += 1
            
    print(count)

main()"
5,B,Center Alignment,PROGRAMMING,"['implementation', 'strings']","Almost every text editor has a built-in function of center text alignment. The developers of the popular in Berland text editor «Textpad» decided to introduce this functionality into the fourth release of the product.

You are to implement the alignment in the shortest possible time. Good luck!","The input file consists of one or more lines, each of the lines contains Latin letters, digits and/or spaces. The lines cannot start or end with a space. It is guaranteed that at least one of the lines has positive length. The length of each line and the total amount of the lines do not exceed 1000.","Format the given text, aligning it center. Frame the whole text with characters «*» of the minimum size. If a line cannot be aligned perfectly (for example, the line has even length, while the width of the block is uneven), you should place such lines rounding down the distance to the left or to the right edge and bringing them closer left or right alternatively (you should start with bringing left). Study the sample tests carefully to understand the output format better.","['This  is\n\nCodeforces\nBeta\nRound\n5\n', 'welcome to the\nCodeforces\nBeta\nRound 5\n\nand\ngood luck\n']","['************\n* This  is *\n*          *\n*Codeforces*\n*   Beta   *\n*  Round   *\n*     5    *\n************\n', '****************\n*welcome to the*\n*  Codeforces  *\n*     Beta     *\n*   Round 5    *\n*              *\n*      and     *\n*  good luck   *\n****************\n']",none,WRONG_ANSWER,"l=[]

maxx=0
while True:
    try:
        l.append(input())


    except EOFError:
        break
for x in l:
    if len(x)>maxx:
        maxx=len(x)
print(""*""*(maxx+2))
for i in l:
    print(""*""+i.center(maxx,"" "")+""*"")
print(""*"" * (maxx + 2))



","def main():
    x, _, w = input().split()
    x = int(x)
    
    if w == ""week"":
        # There are 52 weeks in a year, and any day of the week will occur exactly 52 times
        candies = 52
    elif w == ""month"":
        # Count the number of months that have at least x days
        if x <= 28:
            # All 12 months have at least 28 days
            candies = 12
        elif x == 29:
            # Only February has 29 days in a leap year, along with all other months
            candies = 12
        elif x == 30:
            # All months except February have at least 30 days
            candies = 11
        elif x == 31:
            # Only January, March, May, July, August, October, December have 31 days
            candies = 7
    else:
        # Invalid input scenario
        candies = 0

    print(candies)"
602,B,Approximating a Constant Range,PROGRAMMING,"['dp', 'implementation', 'two pointers']","When Xellos was doing a practice course in university, he once had to measure the intensity of an effect that slowly approached equilibrium. A good way to determine the equilibrium intensity would be choosing a sufficiently large number of consecutive data points that seems as constant as possible and taking their average. Of course, with the usual sizes of data, it's nothing challenging — but why not make a similar programming contest problem while we're at it?

You're given a sequence of *n* data points *a*1,<=...,<=*a**n*. There aren't any big jumps between consecutive data points — for each 1<=≤<=*i*<=&lt;<=*n*, it's guaranteed that |*a**i*<=+<=1<=-<=*a**i*|<=≤<=1.

A range [*l*,<=*r*] of data points is said to be almost constant if the difference between the largest and the smallest value in that range is at most 1. Formally, let *M* be the maximum and *m* the minimum value of *a**i* for *l*<=≤<=*i*<=≤<=*r*; the range [*l*,<=*r*] is almost constant if *M*<=-<=*m*<=≤<=1.

Find the length of the longest almost constant range.","The first line of the input contains a single integer *n* (2<=≤<=*n*<=≤<=100<=000) — the number of data points.

The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=100<=000).",Print a single number — the maximum length of an almost constant range of the given sequence.,"['5\n1 2 3 3 2\n', '11\n5 4 5 5 6 7 8 8 8 7 6\n']","['4\n', '5\n']","In the first sample, the longest almost constant range is [2, 5]; its length (the number of data points in it) is 4.

In the second sample, there are three almost constant ranges of length 4: [1, 4], [6, 9] and [7, 10]; the only almost constant range of the maximum length 5 is [6, 10].",COMPILATION_ERROR,"//my
#include<cstdio>
#include<algorithm>
using namespace std;
int a[1000005];
int main()
{
int n1,ans = 2,x;
scanf(""%d"",&n1);
for(int i = 1; i <= n1; i++)
{

    scanf(""%d"",&x);
    a[x] = i;
    if(a[x-1] > a[x+1])
        ans = max(ans,i-max(a[x+1],a[x-2]));
    else
        ans = max(ans,i-max(a[x+2],a[x-1]));
}
printf(""%d\n"",ans);
return 0;
}
				 		 	    			   		 	  		 			","import sys
sys.stdin, sys.stdout = open(""input.txt"", ""r""), open(""output.txt"", ""w"")

def main():
    # Read the number of force vectors
    n = int(sys.stdin.readline().strip())
    
    # Initialize sums for x, y, z coordinates
    sum_x = 0
    sum_y = 0
    sum_z = 0
    
    # Read each vector and accumulate the sums
    for _ in range(n):
        x, y, z = map(int, sys.stdin.readline().strip().split())
        sum_x += x
        sum_y += y
        sum_z += z
    
    # Check if the body is in equilibrium
    if sum_x == 0 and sum_y == 0 and sum_z == 0:
        print(""YES"")
    else:
        print(""NO"")

if __name__ == ""__main__"":
    main()"
842,C,Ilya And The Tree,PROGRAMMING,"['dfs and similar', 'graphs', 'math', 'number theory', 'trees']","Ilya is very fond of graphs, especially trees. During his last trip to the forest Ilya found a very interesting tree rooted at vertex 1. There is an integer number written on each vertex of the tree; the number written on vertex *i* is equal to *a**i*.

Ilya believes that the beauty of the vertex *x* is the greatest common divisor of all numbers written on the vertices on the path from the root to *x*, including this vertex itself. In addition, Ilya can change the number in one arbitrary vertex to 0 or leave all vertices unchanged. Now for each vertex Ilya wants to know the maximum possible beauty it can have.

For each vertex the answer must be considered independently.

The beauty of the root equals to number written on it.","First line contains one integer number *n* — the number of vertices in tree (1<=≤<=*n*<=≤<=2·105).

Next line contains *n* integer numbers *a**i* (1<=≤<=*i*<=≤<=*n*, 1<=≤<=*a**i*<=≤<=2·105).

Each of next *n*<=-<=1 lines contains two integer numbers *x* and *y* (1<=≤<=*x*,<=*y*<=≤<=*n*, *x*<=≠<=*y*), which means that there is an edge (*x*,<=*y*) in the tree.","Output *n* numbers separated by spaces, where *i*-th number equals to maximum possible beauty of vertex *i*.","['2\n6 2\n1 2\n', '3\n6 2 3\n1 2\n1 3\n', '1\n10\n']","['6 6 \n', '6 6 6 \n', '10 \n']",none,WRONG_ANSWER,"""""""
    Author      : Arif Ahmad
    Date        :
    Algo        :
    Difficulty  :
""""""
from sys import stdin, stdout, setrecursionlimit
import threading
from fractions import gcd


def dfs(u, g1, g2):
    global a, g, ans

    x1 = gcd(g1, 0)
    x2 = gcd(g2, a[u])
    ans[u] = max(x1, x2)

    g1 = gcd(g1, a[u])
    if u == 0:
        g2 = 0
    else:
        g2 = x2
    for v in g[u]:
        if ans[v] == 0:
            dfs(v, g1, g2)


def main():
    global a, n, g, ans
    n = int(stdin.readline().strip())
    a = [int(_) for _ in stdin.readline().strip().split()]

    g = [[] for _ in range(n)]
    for _ in range(n - 1):
        x, y = [int(_) for _ in stdin.readline().strip().split()]
        x -= 1
        y -= 1
        g[x].append(y)
        g[y].append(x)

    ans = [0 for _ in range(n)]
    # ans[0] = a[0]
    dfs(0, a[0], a[0])

    ans = ' '.join(str(_) for _ in ans)
    stdout.write(ans)


if __name__ == '__main__':
    # the following 4 lines of code are required to increase
    # the recursion limit and stack size
    # * if is cause any problem, comment out the lines,
    # * and just call main()
    setrecursionlimit(10**6)
    threading.stack_size(134217728)  # 128MB
    thread = threading.Thread(target=main)
    thread.start()
","# import sys
from collections import defaultdict, deque

sys.setrecursionlimit(1000000)

def add_edge(a, b, c):
    edges[a].append((b, c))
    in_degree[b] += 1

def find_strongly_connected_components(n):
    index = 0
    stack = []
    indices = [-1] * n
    lowlink = [-1] * n
    on_stack = [False] * n
    sccs = []

    def strongconnect(v):
        nonlocal index
        indices[v] = lowlink[v] = index
        index += 1
        stack.append(v)
        on_stack[v] = True

        for (w, _) in edges[v]:
            if indices[w] == -1:
                strongconnect(w)
                lowlink[v] = min(lowlink[v], lowlink[w])
            elif on_stack[w]:
                lowlink[v] = min(lowlink[v], indices[w])

        if lowlink[v] == indices[v]:
            scc = []
            while True:
                w = stack.pop()
                on_stack[w] = False
                scc.append(w)
                if w == v:
                    break
            sccs.append(scc)

    for i in range(n):
        if indices[i] == -1:
            strongconnect(i)

    return sccs

def calculate_min_cost_and_ways(n, costs):
    global edges, in_degree
    edges = defaultdict(list)
    in_degree = [0] * n

    # Input edges
    for (u, v) in roads:
        add_edge(u - 1, v - 1, costs[v - 1])

    # Get strongly connected components
    sccs = find_strongly_connected_components(n)

    total_cost = 0
    total_ways = 1
    MOD = 1000000007

    for scc in sccs:
        min_cost = float('inf')
        count = 0

        for node in scc:
            if costs[node] < min_cost:
                min_cost = costs[node]
                count = 1
            elif costs[node] == min_cost:
                count += 1

        total_cost += min_cost
        total_ways = (total_ways * count) % MOD

    return total_cost, total_ways

# Input reading
n = int(input())
costs = list(map(int, input().split()))
m = int(input())
roads = [tuple(map(int, input().split())) for _ in range(m)]

# Calculate the result
result = calculate_min_cost_and_ways(n, costs)
print(result[0], result[1])"
802,G,Fake News (easy),PROGRAMMING,"['implementation', 'strings']","As it's the first of April, Heidi is suspecting that the news she reads today are fake, and she does not want to look silly in front of all the contestants. She knows that a newspiece is fake if it contains heidi as a subsequence. Help Heidi assess whether the given piece is true, but please be discreet about it...",The first and only line of input contains a single nonempty string *s* of length at most 1000 composed of lowercase letters (a-z).,Output YES if the string *s* contains heidi as a subsequence and NO otherwise.,"['abcheaibcdi\n', 'hiedi\n']","['YES', 'NO']",A string *s* contains another string *p* as a subsequence if it is possible to delete some characters from *s* and obtain *p*.,OK,"def main():
    s = input()
    heidi = ""heidi""

    j = 0
    hasHeidi = 0

    for i in s:
        if(i == heidi[j]):
            if(j < 4):
                j += 1
            else:
                hasHeidi = 1

    if(hasHeidi == 0):
        print(""NO"")
    else:
        print(""YES"")


if __name__ == '__main__':
    main()
	   	 								 	 	 			 			 			","from collections import deque

def hamming(arr1, arr2, n):
    sum1 = 0
    for i in range(n):
        sum1 += arr1[i] ^ arr2[i]
    return sum1

# Read input strings
a = input().strip()
b = input().strip()

# Length of string a
len_a = len(a)

# Convert strings to lists of integers for easier manipulation
arr_a = [int(x) for x in a]
sum_hamming_distances = 0

# Iterate over all contiguous substrings of b of the same length as a
for i in range(len(b) - len_a + 1):
    substring_b = [int(x) for x in b[i:i + len_a]]
    # Calculate the Hamming distance and add it to the total
    sum_hamming_distances += hamming(arr_a, substring_b, len_a)

# Print the final sum of Hamming distances
print(sum_hamming_distances)"
702,A,Maximum Increase,PROGRAMMING,"['dp', 'greedy', 'implementation']","You are given array consisting of *n* integers. Your task is to find the maximum length of an increasing subarray of the given array.

A subarray is the sequence of consecutive elements of the array. Subarray is called increasing if each element of this subarray strictly greater than previous.","The first line contains single positive integer *n* (1<=≤<=*n*<=≤<=105) — the number of integers.

The second line contains *n* positive integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=109).",Print the maximum length of an increasing subarray of the given array.,"['5\n1 7 2 11 15\n', '6\n100 100 100 100 100 100\n', '3\n1 2 3\n']","['3\n', '1\n', '3\n']",none,RUNTIME_ERROR,"n=int(input())
a=[int(i) for i in input().split()]
s=1
s1=[]
for i in range(1,n):
    if a[i]>a[i-1]:
        s+=1
        s1.append(s)
    else:
        s1.append(s)
        s=1
print(max(s1))","def even(a):
    if(a >= '0' and a <= '9' and (int(a) % 2 != 0)):
        return True
    return False

def min_flips(s):
    count = 0
    vowels = set('aeiou')
    
    for card in s:
        # If the card is a vowel, we need to check the other side (must be even)
        if card in vowels:
            count += 1
        # If the card is an odd digit, we need to check the other side (must not be a vowel)
        elif even(card):
            count += 1
    
    return count

# Example usage
s = input().strip()
print(min_flips(s))"
278,B,New Problem,PROGRAMMING,"['brute force', 'strings']","Coming up with a new problem isn't as easy as many people think. Sometimes it is hard enough to name it. We'll consider a title original if it doesn't occur as a substring in any titles of recent Codeforces problems. 

You've got the titles of *n* last problems — the strings, consisting of lowercase English letters. Your task is to find the shortest original title for the new problem. If there are multiple such titles, choose the lexicographically minimum one. Note, that title of the problem can't be an empty string.

A substring *s*[*l*... *r*] (1<=≤<=*l*<=≤<=*r*<=≤<=|*s*|) of string *s*<==<=*s*1*s*2... *s*|*s*| (where |*s*| is the length of string *s*) is string *s**l**s**l*<=+<=1... *s**r*.

String *x*<==<=*x*1*x*2... *x**p* is lexicographically smaller than string *y*<==<=*y*1*y*2... *y**q*, if either *p*<=&lt;<=*q* and *x*1<==<=*y*1,<=*x*2<==<=*y*2,<=... ,<=*x**p*<==<=*y**p*, or there exists such number *r* (*r*<=&lt;<=*p*,<=*r*<=&lt;<=*q*), that *x*1<==<=*y*1,<=*x*2<==<=*y*2,<=... ,<=*x**r*<==<=*y**r* and *x**r*<=+<=1<=&lt;<=*y**r*<=+<=1. The string characters are compared by their ASCII codes.","The first line contains integer *n* (1<=≤<=*n*<=≤<=30) — the number of titles you've got to consider. Then follow *n* problem titles, one per line. Each title only consists of lowercase English letters (specifically, it doesn't contain any spaces) and has the length from 1 to 20, inclusive.","Print a string, consisting of lowercase English letters — the lexicographically minimum shortest original title.","['5\nthreehorses\ngoodsubstrings\nsecret\nprimematrix\nbeautifulyear\n', '4\naa\nbdefghijklmn\nopqrstuvwxyz\nc\n']","['j\n', 'ab\n']","In the first sample the first 9 letters of the English alphabet (a, b, c, d, e, f, g, h, i) occur in the problem titles, so the answer is letter j.

In the second sample the titles contain 26 English letters, so the shortest original title cannot have length 1. Title aa occurs as a substring in the first title.",OK,"# from dust i have come, dust i will be

n = int(input())
a = []

for i in range(n):
    x = input()
    a.append(x)

arr = []
for i in range(26):
    arr.append(chr(i + ord('a')))

for i in range(26):
    for j in range(26):
        arr.append(arr[i] + chr(j + ord('a')))

for i in range(len(arr)):
    cnt = 0
    for j in range(n):
        if arr[i] not in a[j]:
            cnt += 1
    if cnt == n:
        print(arr[i])
        exit(0)
","def solver(l, d):
    moves = 0
    # Start from the second element and check each element
    for i in range(1, len(l)):
        if l[i] <= l[i-1]:  # If the current element is not greater than the previous
            # Calculate how much we need to add
            needed = l[i-1] - l[i] + 1
            # Calculate the number of moves required
            moves += (needed + d - 1) // d  # Ceiling division
            # Increase the current element to ensure it's strictly increasing
            l[i] += ((needed + d - 1) // d) * d
    return moves

def main():
    (n, d) = input().split()
    d = int(d)
    l = input().split()
    l = [int(x) for x in l]
    print(solver(l, d))

main()"
2,B,The least round way,PROGRAMMING,"['dp', 'math']","There is a square matrix *n*<=×<=*n*, consisting of non-negative integer numbers. You should find such a way on it that 
 -  starts in the upper left cell of the matrix; -  each following cell is to the right or down from the current cell; -  the way ends in the bottom right cell. 
Moreover, if we multiply together all the numbers along the way, the result should be the least ""round"". In other words, it should end in the least possible number of zeros.","The first line contains an integer number *n* (2<=≤<=*n*<=≤<=1000), *n* is the size of the matrix. Then follow *n* lines containing the matrix elements (non-negative integer numbers not exceeding 109).",In the first line print the least number of trailing zeros. In the second line print the correspondent way itself.,['3\n1 2 3\n4 5 6\n7 8 9\n'],['0\nDDRR\n'],none,RUNTIME_ERROR,"# -*- coding:utf-8 -*-

""""""

created by shuangquan.huang at 1/3/20

""""""

import collections
import time
import os
import sys
import bisect
import heapq
from typing import List

N = int(input())
A = []
for i in range(N):
    row = [int(x) for x in input().split()]
    A.append(row)
    

def count(val, div):
    c = 0
    while val % div == 0:
        val //= div
        c += 1
    return c


def solve(div):
    dp = [[1000 for _ in range(N)] for _ in range(N)]
    pre = [['' for _ in range(N)] for _ in range(N)]
    dp[0][0] = count(A[0][0], div)
    for r in range(N):
        for c in range(N):
            dc = count(A[r][c], div)
            if r > 0 and dp[r-1][c] + dc < dp[r][c]:
                dp[r][c] = dp[r-1][c] + dc
                pre[r][c] = 'U'
            if c > 0 and dp[r][c-1] + dc < dp[r][c]:
                pre[r][c] = 'L'
                dp[r][c] = dp[r][c-1] + dc
    
    path = []
    r, c = N-1, N-1
    while r > 0 or c > 0:
        if pre[r][c] == 'U':
            path.append('D')
            r, c = r-1, c
        else:
            path.append('R')
            r, c = r, c-1
    
    return dp[N-1][N-1], ''.join(path[::-1])


a, b = solve(2)
c, d = solve(5)
if a < c:
    print(a)
    print(b)
else:
    print(c)
    print(d)
    
    
    
    
    ","myDict = {}

class Solution:
    def check_possession(self, names):
        result = []
        for name in names:
            # Check if the name has been seen before
            if name in myDict:
                result.append(""YES"")
            else:
                result.append(""NO"")
                # Add the name to the dictionary
                myDict[name] = True
        return result

# Input handling
if __name__ == ""__main__"":
    n = int(input())
    names = [input().strip() for _ in range(n)]
    
    solution = Solution()
    results = solution.check_possession(names)
    
    # Output the results
    for res in results:
        print(res)"
805,B,3-palindrome,PROGRAMMING,['constructive algorithms'],"In the beginning of the new year Keivan decided to reverse his name. He doesn't like palindromes, so he changed Naviek to Navick.

He is too selfish, so for a given *n* he wants to obtain a string of *n* characters, each of which is either 'a', 'b' or 'c', with no palindromes of length 3 appearing in the string as a substring. For example, the strings ""abc"" and ""abca"" suit him, while the string ""aba"" doesn't. He also want the number of letters 'c' in his string to be as little as possible.",The first line contains single integer *n* (1<=≤<=*n*<=≤<=2·105) — the length of the string.,"Print the string that satisfies all the constraints.

If there are multiple answers, print any of them.","['2\n', '3\n']","['aa\n', 'bba\n']",A palindrome is a sequence of characters which reads the same backward and forward.,OK,"n = int(input())
thingo=[""a"",""a"",""b"",""b""]


print(int(n/4)*""aabb"" + """".join(thingo[:n%4]))","# Function to determine who cannot give the correct amount of candies
def who_cannot_give_candies(a, b):
    # Initialize turn and the amount of candies to give
    turn = 1

    # Loop until one of them cannot give the required candies
    while True:
        if turn % 2 == 1:  # Vladik's turn (odd turns)
            if a >= turn:  # Check if Vladik can give the candies
                a -= turn  # Deduct the candies given
            else:
                return ""Vladik""  # Vladik cannot give enough candies
        else:  # Valera's turn (even turns)
            if b >= turn:  # Check if Valera can give the candies
                b -= turn  # Deduct the candies given
            else:
                return ""Valera""  # Valera cannot give enough candies
        
        turn += 1  # Move to the next turn

# Input reading
a, b = map(int, input().split())
# Output the result
print(who_cannot_give_candies(a, b))"
129,A,Cookies,PROGRAMMING,['implementation'],"Olga came to visit the twins Anna and Maria and saw that they have many cookies. The cookies are distributed into bags. As there are many cookies, Olga decided that it's no big deal if she steals a bag. However, she doesn't want the sisters to quarrel because of nothing when they divide the cookies. That's why Olga wants to steal a bag with cookies so that the number of cookies in the remaining bags was even, that is, so that Anna and Maria could evenly divide it into two (even 0 remaining cookies will do, just as any other even number). How many ways there are to steal exactly one cookie bag so that the total number of cookies in the remaining bags was even?",The first line contains the only integer *n* (1<=≤<=*n*<=≤<=100) — the number of cookie bags Anna and Maria have. The second line contains *n* integers *a**i* (1<=≤<=*a**i*<=≤<=100) — the number of cookies in the *i*-th bag.,Print in the only line the only number — the sought number of ways. If there are no such ways print 0.,"['1\n1\n', '10\n1 2 2 3 4 4 4 2 2 2\n', '11\n2 2 2 2 2 2 2 2 2 2 99\n']","['1\n', '8\n', '1\n']","In the first sample Olga should take the only bag so that the twins ended up with the even number of cookies.

In the second sample Olga can take any of five bags with two cookies or any of three bags with four cookies — 5 + 3 = 8 ways in total.

In the third sample, no matter which bag with two cookies Olga chooses, the twins are left with 2 * 9 + 99 = 117 cookies. Thus, Olga has only one option: to take the bag with 99 cookies.",OK,"n = int(input())
a = [int(i) for i in input().split()]
x = sum(a)
counter = 0

for i in range(len(a)):
    difference = x - a[i]
    if difference % 2 == 0:
        counter = counter + 1

print(counter)","# chale
def primos(x):
    numeros2 = [1 for i in range(x+1)]
    almost = [0 for i in range(x+1)]
    numeros2[0] = numeros2[1] = 0
    d = 2
    
    while d <= x:
        if numeros2[d]:
            # Marking all multiples of prime number d
            for multiple in range(d * d, x + 1, d):
                numeros2[multiple] = 0
            # Counting distinct prime factors for each number
            for multiple in range(d, x + 1, d):
                almost[multiple] += 1
        d += 1

    # Counting almost prime numbers
    count = sum(1 for i in range(1, x + 1) if almost[i] == 2)
    return count

# Input and output handling
n = int(input().strip())
print(primos(n))"
750,A,New Year and Hurry,PROGRAMMING,"['binary search', 'brute force', 'implementation', 'math']","Limak is going to participate in a contest on the last day of the 2016. The contest will start at 20:00 and will last four hours, exactly until midnight. There will be *n* problems, sorted by difficulty, i.e. problem 1 is the easiest and problem *n* is the hardest. Limak knows it will take him 5·*i* minutes to solve the *i*-th problem.

Limak's friends organize a New Year's Eve party and Limak wants to be there at midnight or earlier. He needs *k* minutes to get there from his house, where he will participate in the contest first.

How many problems can Limak solve if he wants to make it to the party?","The only line of the input contains two integers *n* and *k* (1<=≤<=*n*<=≤<=10, 1<=≤<=*k*<=≤<=240) — the number of the problems in the contest and the number of minutes Limak needs to get to the party from his house.","Print one integer, denoting the maximum possible number of problems Limak can solve so that he could get to the party at midnight or earlier.","['3 222\n', '4 190\n', '7 1\n']","['2\n', '4\n', '7\n']","In the first sample, there are 3 problems and Limak needs 222 minutes to get to the party. The three problems require 5, 10 and 15 minutes respectively. Limak can spend 5 + 10 = 15 minutes to solve first two problems. Then, at 20:15 he can leave his house to get to the party at 23:57 (after 222 minutes). In this scenario Limak would solve 2 problems. He doesn't have enough time to solve 3 problems so the answer is 2.

In the second sample, Limak can solve all 4 problems in 5 + 10 + 15 + 20 = 50 minutes. At 20:50 he will leave the house and go to the party. He will get there exactly at midnight.

In the third sample, Limak needs only 1 minute to get to the party. He has enough time to solve all 7 problems.",OK,"Q, min = input().split()
QsolvinTime = 0
count = 0
qmin = 5
for i in range(int(Q)):
    QsolvinTime += qmin
    if 240 - int(min) >= QsolvinTime:
        qmin += 5
        count += 1
    else:
        break
print(count)","import itertools

def find_prob(done, sent):
    interrogatins = 0
    done_points = 0
    sent_points = 0
    
    # Calculate the final position from the original commands
    for char in done:
        if char == '+':
            done_points += 1
        else:
            done_points -= 1

    # Calculate the current position from the recognized commands
    for char in sent:
        if char == '+':
            sent_points += 1
        elif char == '-':
            sent_points -= 1
        else:  # char == '?'
            interrogatins += 1

    # Determine how many points we need to cover with '?'
    required_adjustment = done_points - sent_points
    
    # Calculate the possible distributions of '?' to reach the desired position
    total_ways = 0
    correct_ways = 0
    
    # We need 'x' positive moves and 'interrogatins - x' negative moves
    # to match the required_adjustment: x - (interrogatins - x) = required_adjustment
    # Simplifying yields: 2*x = required_adjustment + interrogatins
    # thus, x = (required_adjustment + interrogatins) / 2
    for x in range(interrogatins + 1):
        if (required_adjustment + interrogatins) % 2 == 0 and (required_adjustment + interrogatins) // 2 == x:
            if 0 <= x <= interrogatins:  # x must be within valid range
                total_ways += 1
                correct_ways += 1  # this represents a valid way to reach desired position 

    # Calculate the total number of ways to assign '?' (2^interrogatins)
    total_ways = 2 ** interrogatins

    # Calculate probability
    if total_ways == 0:
        return 0.0  # No ways to achieve position
    return correct_ways / total_ways

# Example usage:
s1 = input().strip()
s2 = input().strip()
print(find_prob(s1, s2))"
988,A,Diverse Team,PROGRAMMING,"['brute force', 'implementation']","There are $n$ students in a school class, the rating of the $i$-th student on Codehorses is $a_i$. You have to form a team consisting of $k$ students ($1 \le k \le n$) such that the ratings of all team members are distinct.

If it is impossible to form a suitable team, print ""NO"" (without quotes). Otherwise print ""YES"", and then print $k$ distinct numbers which should be the indices of students in the team you form. If there are multiple answers, print any of them.","The first line contains two integers $n$ and $k$ ($1 \le k \le n \le 100$) — the number of students and the size of the team you have to form.

The second line contains $n$ integers $a_1, a_2, \dots, a_n$ ($1 \le a_i \le 100$), where $a_i$ is the rating of $i$-th student.","If it is impossible to form a suitable team, print ""NO"" (without quotes). Otherwise print ""YES"", and then print $k$ distinct integers from $1$ to $n$ which should be the indices of students in the team you form. All the ratings of the students in the team should be distinct. You may print the indices in any order. If there are multiple answers, print any of them.

Assume that the students are numbered from $1$ to $n$.","['5 3\n15 13 15 15 12\n', '5 4\n15 13 15 15 12\n', '4 4\n20 10 40 30\n']","['YES\n1 2 5 \n', 'NO\n', 'YES\n1 2 3 4 \n']","All possible answers for the first example: 
 -  {1 2 5} -  {2 3 5} -  {2 4 5} 
Note that the order does not matter.",OK,"n,k=map(int,input().split())
l=list(map(int,input().split()))
s=set()
for i in range(len(l)):
    s.add(l[i])
l1=[i for i in s]
l2=[]
if len(s)>=k:
    print(""YES"")
    for i in range(k):
        if(l1[i] in l):
            l2.append(l.index(l1[i])+1)
    l2.sort()
    for i in range(len(l2)):
        print(l2[i],end=' ')

else:
    print(""NO"")
","from io import StringIO

data = StringIO(""""""5 4 5
0 1 1 0
1 0 0 1
0 1 1 0
1 0 0 1
0 0 0 0
"""""")

# Read input values
input_lines = data.getvalue().strip().split('\n')
n, m, q = map(int, input_lines[0].split())
grid = [list(map(int, line.split())) for line in input_lines[1:n + 1]]
queries = [tuple(map(int, line.split())) for line in input_lines[n + 1:]]

def max_consecutive_eyes(row):
    max_count = 0
    current_count = 0
    for val in row:
        if val == 1:
            current_count += 1
            max_count = max(max_count, current_count)
        else:
            current_count = 0
    return max_count

# Process each query
for i, j in queries:
    # Convert to 0-indexed
    i -= 1
    j -= 1
    
    # Toggle the state of the selected bear
    grid[i][j] = 1 - grid[i][j]
    
    # Calculate the score (max eyes in any row)
    score = max(max_consecutive_eyes(grid[r]) for r in range(n))
    print(score)"
246,A,Buggy Sorting,PROGRAMMING,"['constructive algorithms', 'greedy', 'sortings']","Little boy Valera studies an algorithm of sorting an integer array. After studying the theory, he went on to the practical tasks. As a result, he wrote a program that sorts an array of *n* integers *a*1,<=*a*2,<=...,<=*a**n* in the non-decreasing order. The pseudocode of the program, written by Valera, is given below. The input of the program gets number *n* and array *a*.

But Valera could have made a mistake, because he hasn't yet fully learned the sorting algorithm. If Valera made a mistake in his program, you need to give a counter-example that makes his program work improperly (that is, the example that makes the program sort the array not in the non-decreasing order). If such example for the given value of *n* doesn't exist, print -1.",You've got a single integer *n* (1<=≤<=*n*<=≤<=50) — the size of the sorted array.,"Print *n* space-separated integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=100) — the counter-example, for which Valera's algorithm won't work correctly. If the counter-example that meets the described conditions is impossible to give, print -1.

If there are several counter-examples, consisting of *n* numbers, you are allowed to print any of them.",['1\n'],['-1\n'],none,OK,"# LUOGU_RID: 102443681
n = int(input())
if n < 3:
    print(-1)
else:
    print(*range(n, 0, -1))","def test():
    n = int(input())
    if n < 10:
        print(n)
    else:
        digits = 0
        length = len(str(n))
        
        # Count digits for complete ranges
        for i in range(1, length):
            digits += i * (10**i - 10**(i - 1))  # Count digits for full ranges of sizes
            
        # Count digits for the last partial range
        digits += length * (n - 10**(length - 1) + 1)  # Count digits for remaining numbers
        
        print(digits)"
544,B,Sea and Islands,PROGRAMMING,"['constructive algorithms', 'implementation']","A map of some object is a rectangular field consisting of *n* rows and *n* columns. Each cell is initially occupied by the sea but you can cover some some cells of the map with sand so that exactly *k* islands appear on the map. We will call a set of sand cells to be island if it is possible to get from each of them to each of them by moving only through sand cells and by moving from a cell only to a side-adjacent cell. The cells are called to be side-adjacent if they share a vertical or horizontal side. It is easy to see that islands do not share cells (otherwise they together form a bigger island).

Find a way to cover some cells with sand so that exactly *k* islands appear on the *n*<=×<=*n* map, or determine that no such way exists.","The single line contains two positive integers *n*, *k* (1<=≤<=*n*<=≤<=100, 0<=≤<=*k*<=≤<=*n*2) — the size of the map and the number of islands you should form.","If the answer doesn't exist, print ""NO"" (without the quotes) in a single line.

Otherwise, print ""YES"" in the first line. In the next *n* lines print the description of the map. Each of the lines of the description must consist only of characters 'S' and 'L', where 'S' is a cell that is occupied by the sea and 'L' is the cell covered with sand. The length of each line of the description must equal *n*.

If there are multiple answers, you may print any of them.

You should not maximize the sizes of islands.","['5 2\n', '5 25\n']","['YES\nSSSSS\nLLLLL\nSSSSS\nLLLLL\nSSSSS\n', 'NO\n']",none,OK,"import sys
input = sys.stdin.readline
read_tuple = lambda _type: map(_type, input().split(' '))


def solve():
    n, k = read_tuple(int)
    grid = [['S' for _ in range(n)] for _ in range(n)]
    flag = True
    for i in range(n):
        for j in range(n):
            if k and flag:
                grid[i][j] = 'L'
                k -= 1
            flag ^= True
        if n % 2 == 0:
            flag ^= True
    if k == 0:
        print(""YES"")
    else:
        print(""NO"")
    if k == 0:
        for row in grid:
            print(''.join(row))


if __name__ == '__main__':
    solve()
    ","def solve():
    n, x = map(int, input().split())
    a = []
    for i in range(n):
        temp = list(map(int, input().split()))
        a.append(temp)
    
    current_time = 1  # Start at the first minute
    total_watched = 0

    for l, r in a:
        # Skip to the beginning of the next interesting moment
        while current_time < l:
            if l - current_time > x:
                total_watched += x  # Skip x minutes
                current_time += x
            else:
                total_watched += (l - current_time)  # Watch the remaining minutes
                current_time = l
        
        # Watch the interesting moment
        total_watched += (r - l + 1)
        current_time = r + 1  # Move to the next minute after the current moment

    print(total_watched)"
690,F1,Tree of Life (easy),PROGRAMMING,[],"Heidi has finally found the mythical Tree of Life – a legendary combinatorial structure which is said to contain a prophecy crucially needed to defeat the undead armies.

On the surface, the Tree of Life is just a regular undirected tree well-known from computer science. This means that it is a collection of *n* points (called vertices), some of which are connected using *n*<=-<=1 line segments (edges) so that each pair of vertices is connected by a path (a sequence of one or more edges).

To decipher the prophecy, Heidi needs to perform a number of steps. The first is counting the number of lifelines in the tree – these are paths of length 2, i.e., consisting of two edges. Help her!","The first line of the input contains a single integer *n* – the number of vertices in the tree (1<=≤<=*n*<=≤<=10000). The vertices are labeled with the numbers from 1 to *n*. Then *n*<=-<=1 lines follow, each describing one edge using two space-separated numbers *a* *b* – the labels of the vertices connected by the edge (1<=≤<=*a*<=&lt;<=*b*<=≤<=*n*). It is guaranteed that the input represents a tree.",Print one integer – the number of lifelines in the tree.,"['4\n1 2\n1 3\n1 4\n', '5\n1 2\n2 3\n3 4\n3 5\n']","['3', '4']","In the second sample, there are four lifelines: paths between vertices 1 and 3, 2 and 4, 2 and 5, and 4 and 5.",OK,"n = int(input())
t = [0] * n
out = 0
for _ in range(n-1):
	a, b = input().split(' ')
	a, b = [int(a), int(b)]
	t[a-1] += 1
	t[b-1] += 1
for x in t:
	out += x * (x-1) / 2
print(int(out))
","# K - 2, Assignment 4, bd2255
# contributions to the solution: Daniel Perez

temps = []

def helper(K, D, S, SET):
    if S == 3:
        temps.append(SET + [K])
        return
    for neighbor in D[K]:
        if neighbor not in SET:
            helper(neighbor, D, S + 1, SET + [K])

def find_minimum_recognition(n, m, pairs):
    # Create an adjacency list for warriors
    D = [[] for _ in range(n + 1)]
    
    for a, b in pairs:
        D[a].append(b)
        D[b].append(a)

    min_recognition_sum = float('inf')
    found = False

    # Check each combination of three warriors
    for i in range(1, n + 1):
        for j in range(i + 1, n + 1):
            if j in D[i]:  # i knows j
                for k in range(j + 1, n + 1):
                    if k in D[i] and k in D[j]:  # i knows k and j knows k
                        found = True
                        # Calculate recognitions
                        recognition_i = len(D[i]) - 2
                        recognition_j = len(D[j]) - 2
                        recognition_k = len(D[k]) - 2
                        recognition_sum = recognition_i + recognition_j + recognition_k
                        min_recognition_sum = min(min_recognition_sum, recognition_sum)

    return min_recognition_sum if found else -1

# Example usage:
# n, m = map(int, input().split())
# pairs = [tuple(map(int, input().split())) for _ in range(m)]
# result = find_minimum_recognition(n, m, pairs)
# print(result)"
381,A,Sereja and Dima,PROGRAMMING,"['greedy', 'implementation', 'two pointers']","Sereja and Dima play a game. The rules of the game are very simple. The players have *n* cards in a row. Each card contains a number, all numbers on the cards are distinct. The players take turns, Sereja moves first. During his turn a player can take one card: either the leftmost card in a row, or the rightmost one. The game ends when there is no more cards. The player who has the maximum sum of numbers on his cards by the end of the game, wins.

Sereja and Dima are being greedy. Each of them chooses the card with the larger number during his move.

Inna is a friend of Sereja and Dima. She knows which strategy the guys are using, so she wants to determine the final score, given the initial state of the game. Help her.",The first line contains integer *n* (1<=≤<=*n*<=≤<=1000) — the number of cards on the table. The second line contains space-separated numbers on the cards from left to right. The numbers on the cards are distinct integers from 1 to 1000.,"On a single line, print two integers. The first number is the number of Sereja's points at the end of the game, the second number is the number of Dima's points at the end of the game.","['4\n4 1 2 10\n', '7\n1 2 3 4 5 6 7\n']","['12 5\n', '16 12\n']","In the first sample Sereja will take cards with numbers 10 and 2, so Sereja's sum is 12. Dima will take cards with numbers 4 and 1, so Dima's sum is 5.",OK,"from collections import defaultdict, deque, Counter
from heapq import heapify, heappop, heappush

def main():
    t = 1
    # t = int(input())
    for _ in range(t):
        run_test_case()

def run_test_case():
    n = int(input())
    l = list(map(int, input().split()))
    sereja = dima = 0
    left, right = 0, n - 1
    i = 0
    while left <= right:
        curMax = max(l[left], l[right])
        if i % 2 == 0:
            sereja += curMax
        else:
            dima += curMax
        if l[left] > l[right]:
            left += 1
        else:
            right -= 1
        i += 1
    print(sereja, dima)


if __name__ == ""__main__"":
    main()
""""""
/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?)
 * do smth instead of nothing and stay organized
 * WRITE STUFF DOWN
 * DON'T GET STUCK ON ONE APPROACH
 */
""""""
","import sys
import math
# Fast input
input = sys.stdin.readline
# Fast output
def print(*args, **kwargs):
    sep = kwargs.get('sep', ' ')
    end = kwargs.get('end', '\n')
    sys.stdout.write(sep.join(map(str, args)) + end)

n, q = map(int, input().split())
a = list(map(int, input().split()))

# Create a frequency array to count the number of times each index is queried
freq = [0] * (n + 1)

# Read the queries and update the frequency counts
for _ in range(q):
    l, r = map(int, input().split())
    freq[l-1] += 1  # Start of range
    if r < n:
        freq[r] -= 1  # End of range

# Now transform the frequency array to get the actual counts of each index
for i in range(1, n):
    freq[i] += freq[i - 1]

# Remove the unused element at index 0
freq = freq[:-1]

# Sort the frequency array and the original array
freq.sort()
a.sort()

# Calculate the maximum sum of query replies using the sorted arrays
max_sum = sum(f * x for f, x in zip(freq, a))

print(max_sum)"
845,C,Two TVs,PROGRAMMING,"['data structures', 'greedy', 'sortings']","Polycarp is a great fan of television.

He wrote down all the TV programs he is interested in for today. His list contains *n* shows, *i*-th of them starts at moment *l**i* and ends at moment *r**i*.

Polycarp owns two TVs. He can watch two different shows simultaneously with two TVs but he can only watch one show at any given moment on a single TV. If one show ends at the same moment some other show starts then you can't watch them on a single TV.

Polycarp wants to check out all *n* shows. Are two TVs enough to do so?","The first line contains one integer *n* (1<=≤<=*n*<=≤<=2·105) — the number of shows.

Each of the next *n* lines contains two integers *l**i* and *r**i* (0<=≤<=*l**i*<=&lt;<=*r**i*<=≤<=109) — starting and ending time of *i*-th show.","If Polycarp is able to check out all the shows using only two TVs then print ""YES"" (without quotes). Otherwise, print ""NO"" (without quotes).","['3\n1 2\n2 3\n4 5\n', '4\n1 2\n2 3\n2 3\n1 2\n']","['YES\n', 'NO\n']",none,WRONG_ANSWER,"t=int(input())
television1=[]
television2=[]
start,end=map(int,input().split())
television1=[start,end]
start,end=map(int,input().split())
television2=[start,end]
count=2
for i in range(t-2):
    start,end=map(int,input().split())
    if start>television1[0]:
        television1=[start,end]
        count+=1
    elif start>television2[0]:
        television2=[start,end]
        count+=1
if count==t:
    print(""YES"")
else:
    print(""NO"")
	 	 	   	      	 				 		   		 	","# https://codeforces.com/problemset/problem/820/A
# 900

c, v0, v1, a, l = map(int, input().split())

days = 0         # Initialize the number of days
pages_read = 0   # Variable to keep track of the pages read

while pages_read < c:  # While not finished the book
    days += 1          # Increment the day count
    if days == 1:     # On the first day, read initially allowed pages
        pages_today = v0
    else:              # From the second day onward
        pages_today = min(v0 + (days - 1) * a, v1)  # Calculate the reading speed, respecting the maximum limit
        pages_today -= l  # Subtract the pages that need to be reread
    
    # Ensure that pages read is not negative
    pages_today = max(pages_today, 0)
    
    pages_read += pages_today  # Update the total pages read

print(days)  # Output the total number of days needed to finish the book"
793,A,Oleg and shares,PROGRAMMING,"['implementation', 'math']","Oleg the bank client checks share prices every day. There are *n* share prices he is interested in. Today he observed that each second exactly one of these prices decreases by *k* rubles (note that each second exactly one price changes, but at different seconds different prices can change). Prices can become negative. Oleg found this process interesting, and he asked Igor the financial analyst, what is the minimum time needed for all *n* prices to become equal, or it is impossible at all? Igor is busy right now, so he asked you to help Oleg. Can you answer this question?","The first line contains two integers *n* and *k* (1<=≤<=*n*<=≤<=105,<=1<=≤<=*k*<=≤<=109) — the number of share prices, and the amount of rubles some price decreases each second.

The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=109) — the initial prices.","Print the only line containing the minimum number of seconds needed for prices to become equal, of «-1» if it is impossible.","['3 3\n12 9 15\n', '2 2\n10 9\n', '4 1\n1 1000000000 1000000000 1000000000\n']","['3', '-1', '2999999997']","Consider the first example. 

Suppose the third price decreases in the first second and become equal 12 rubles, then the first price decreases and becomes equal 9 rubles, and in the third second the third price decreases again and becomes equal 9 rubles. In this case all prices become equal 9 rubles in 3 seconds.

There could be other possibilities, but this minimizes the time needed for all prices to become equal. Thus the answer is 3.

In the second example we can notice that parity of first and second price is different and never changes within described process. Thus prices never can become equal.

In the third example following scenario can take place: firstly, the second price drops, then the third price, and then fourth price. It happens 999999999 times, and, since in one second only one price can drop, the whole process takes 999999999 * 3 = 2999999997 seconds. We can note that this is the minimum possible time.",OK,"import math

n,k=map(int,input().split())
a=list(map(int,input().split()))

a.sort()
r=a[0]%k;t=0
for i in range(1,n):
    if a[i]%k!=r:
        print(-1)
        break
    else:
        t+=(a[i]-a[0])//k
else:
    print(t)
","# https://codeforces.com/contest/378/problem/A
a, b = map(int, input().split())
a_wins = draw = b_wins = 0

for x in range(1, 7):  # Iterate over all possible dice outcomes (1 to 6)
    if abs(a - x) < abs(b - x):  # First player wins
        a_wins += 1
    elif abs(a - x) > abs(b - x):  # Second player wins
        b_wins += 1
    else:  # It's a draw
        draw += 1

print(a_wins, draw, b_wins)  # Output the results"
265,A,Colorful Stones (Simplified Edition),PROGRAMMING,['implementation'],"There is a sequence of colorful stones. The color of each stone is one of red, green, or blue. You are given a string *s*. The *i*-th (1-based) character of *s* represents the color of the *i*-th stone. If the character is ""R"", ""G"", or ""B"", the color of the corresponding stone is red, green, or blue, respectively.

Initially Squirrel Liss is standing on the first stone. You perform instructions one or more times.

Each instruction is one of the three types: ""RED"", ""GREEN"", or ""BLUE"". After an instruction *c*, if Liss is standing on a stone whose colors is *c*, Liss will move one stone forward, else she will not move.

You are given a string *t*. The number of instructions is equal to the length of *t*, and the *i*-th character of *t* represents the *i*-th instruction.

Calculate the final position of Liss (the number of the stone she is going to stand on in the end) after performing all the instructions, and print its 1-based position. It is guaranteed that Liss don't move out of the sequence.","The input contains two lines. The first line contains the string *s* (1<=≤<=|*s*|<=≤<=50). The second line contains the string *t* (1<=≤<=|*t*|<=≤<=50). The characters of each string will be one of ""R"", ""G"", or ""B"". It is guaranteed that Liss don't move out of the sequence.",Print the final 1-based position of Liss in a single line.,"['RGB\nRRR\n', 'RRRBGBRBBB\nBBBRR\n', 'BRRBGBRGRBGRGRRGGBGBGBRGBRGRGGGRBRRRBRBBBGRRRGGBBB\nBBRBGGRGRGBBBRBGRBRBBBBRBRRRBGBBGBBRRBBGGRBRRBRGRB\n']","['2\n', '3\n', '15\n']",none,OK,"input1=list(input())
instructions=list(input())
ans=1
counter1=0
counter2=0
for i in range(len(instructions)):
    if instructions[counter1]==input1[counter2]:
       ans+=1
       counter2+=1
    counter1+=1
print(ans)","def deikstra(n, edges, wait_time):
    dist = [float('inf')] * n
    dist[0] = 0  # Starting at planet 1, time is 0
    visited = [False] * n

    while True:
        u = -1
        for i in range(n):
            if not visited[i] and (u == -1 or dist[i] < dist[u]):
                u = i  # Find the unvisited node with the smallest distance

        if u == -1:
            break  # All reachable nodes have been visited

        visited[u] = True
        
        for v, travel_time in edges[u]:  # Explore neighbors
            time_to_reach = dist[u] + travel_time
            
            # Handle waiting time if travelers arrive
            if wait_time[v]:
                for arrival_time in wait_time[v]:
                    if time_to_reach <= arrival_time:
                        time_to_reach = arrival_time + 1  # Wait for the next second
                        break

            if time_to_reach < dist[v]:
                dist[v] = time_to_reach  # Update the shortest time to reach v

    return dist[n - 1] if dist[n - 1] != float('inf') else -1

n, m = map(int, input().split())
edges = [[] for _ in range(n)]
for _ in range(m):
    a, b, c = map(int, input().split())
    edges[a - 1].append((b - 1, c))  # add edge a -> b
    edges[b - 1].append((a - 1, c))  # add edge b -> a

wait_time = []
for i in range(n):
    k = int(input())
    arrivals = list(map(int, input().split())) if k > 0 else []
    wait_time.append(arrivals)

result = deikstra(n, edges, wait_time)
print(result)"
218,A,Mountain Scenery,PROGRAMMING,"['brute force', 'constructive algorithms', 'implementation']","Little Bolek has found a picture with *n* mountain peaks painted on it. The *n* painted peaks are represented by a non-closed polyline, consisting of 2*n* segments. The segments go through 2*n*<=+<=1 points with coordinates (1,<=*y*1), (2,<=*y*2), ..., (2*n*<=+<=1,<=*y*2*n*<=+<=1), with the *i*-th segment connecting the point (*i*,<=*y**i*) and the point (*i*<=+<=1,<=*y**i*<=+<=1). For any even *i* (2<=≤<=*i*<=≤<=2*n*) the following condition holds: *y**i*<=-<=1<=&lt;<=*y**i* and *y**i*<=&gt;<=*y**i*<=+<=1. 

We shall call a vertex of a polyline with an even *x* coordinate a mountain peak.

Bolek fancied a little mischief. He chose exactly *k* mountain peaks, rubbed out the segments that went through those peaks and increased each peak's height by one (that is, he increased the *y* coordinate of the corresponding points). Then he painted the missing segments to get a new picture of mountain peaks. Let us denote the points through which the new polyline passes on Bolek's new picture as (1,<=*r*1), (2,<=*r*2), ..., (2*n*<=+<=1,<=*r*2*n*<=+<=1).

Given Bolek's final picture, restore the initial one.","The first line contains two space-separated integers *n* and *k* (1<=≤<=*k*<=≤<=*n*<=≤<=100). The next line contains 2*n*<=+<=1 space-separated integers *r*1,<=*r*2,<=...,<=*r*2*n*<=+<=1 (0<=≤<=*r**i*<=≤<=100) — the *y* coordinates of the polyline vertices on Bolek's picture.

It is guaranteed that we can obtain the given picture after performing the described actions on some picture of mountain peaks.","Print 2*n*<=+<=1 integers *y*1,<=*y*2,<=...,<=*y*2*n*<=+<=1 — the *y* coordinates of the vertices of the polyline on the initial picture. If there are multiple answers, output any one of them.","['3 2\n0 5 3 5 1 5 2\n', '1 1\n0 2 0\n']","['0 5 3 4 1 4 2 \n', '0 1 0 \n']",none,WRONG_ANSWER,"

n,k = map(int,input().split())



t = list(map(int,input().split()))

u=0

for i in range(len(t)):
    if u<k:
        if t[i]>0:
            if i==0:
                if t[i]-1!=t[i+1]:
                    u+=1
                    t[i]-=1
                    if u==k:
                        print(*t)
                        break
            elif i==len(t)-1:
                if t[-1]-1!=t[-2]:
                    u+=1
                    t[i]-=1
                    if u==k:
                        print(*t)
                        break
            else:
                if t[i]-1!=t[i-1] and t[i]+1 !=t[i+1]:
                    u+=1
                    t[i]-=1
                    if u==k:
                        print(*t)
                        break

","from collections import deque
from math import ceil

def ii(): return int(input())
def si(): return input()
def mi(): return map(int, input().split())
def li(): return list(mi())

# Read the binary number as a string
binary_num = si()

# Initialize variable to store the maximum binary result
max_binary = ''

# Loop through each index in the binary number
for i in range(len(binary_num)):
    # Create a new binary number by skipping the current index
    new_binary = binary_num[:i] + binary_num[i+1:]
    
    # Compare with the maximum binary result found so far
    if new_binary > max_binary:
        max_binary = new_binary

# Print the maximum binary number found
print(max_binary)"
709,A,Juicer,PROGRAMMING,['implementation'],"Kolya is going to make fresh orange juice. He has *n* oranges of sizes *a*1,<=*a*2,<=...,<=*a**n*. Kolya will put them in the juicer in the fixed order, starting with orange of size *a*1, then orange of size *a*2 and so on. To be put in the juicer the orange must have size not exceeding *b*, so if Kolya sees an orange that is strictly greater he throws it away and continues with the next one.

The juicer has a special section to collect waste. It overflows if Kolya squeezes oranges of the total size strictly greater than *d*. When it happens Kolya empties the waste section (even if there are no more oranges) and continues to squeeze the juice. How many times will he have to empty the waste section?","The first line of the input contains three integers *n*, *b* and *d* (1<=≤<=*n*<=≤<=100<=000, 1<=≤<=*b*<=≤<=*d*<=≤<=1<=000<=000) — the number of oranges, the maximum size of the orange that fits in the juicer and the value *d*, which determines the condition when the waste section should be emptied.

The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=1<=000<=000) — sizes of the oranges listed in the order Kolya is going to try to put them in the juicer.",Print one integer — the number of times Kolya will have to empty the waste section.,"['2 7 10\n5 6\n', '1 5 10\n7\n', '3 10 10\n5 7 7\n', '1 1 1\n1\n']","['1\n', '0\n', '1\n', '0\n']","In the first sample, Kolya will squeeze the juice from two oranges and empty the waste section afterwards.

In the second sample, the orange won't fit in the juicer so Kolya will have no juice at all.",WRONG_ANSWER,"a, b, d = [int(i) for i in input().split()]
n = 0
res = 0
s = [int(i) for i in input().split()]
for i in range(a):
    if s[i] < b:
        n += s[i]
        if n > d:
            n = 0
            res += 1
print(res)","import sys, math, bisect
inf = float('inf')
mod = (inf) + 7

def lcm(a, b):
    return int((a / math.gcd(a, b)) * b)

def gcd(a, b):
    return int(math.gcd(a, b))

def binarySearch(a, x):
    # Not used in the problem, but kept for consistency
    pass

def largest_after_deletion(binary_str):
    max_binary = """"
    
    for i in range(len(binary_str)):
        # Create a new binary string by skipping the i-th character
        new_binary = binary_str[:i] + binary_str[i + 1:]
        
        # Update maximum binary string
        if new_binary > max_binary:
            max_binary = new_binary
    
    return max_binary

# Input
a = input().strip()

# Find the largest number after deletion
result = largest_after_deletion(a)

# Output the result
print(result)"
552,A,Vanya and Table,PROGRAMMING,"['implementation', 'math']","Vanya has a table consisting of 100 rows, each row contains 100 cells. The rows are numbered by integers from 1 to 100 from bottom to top, the columns are numbered from 1 to 100 from left to right. 

In this table, Vanya chose *n* rectangles with sides that go along borders of squares (some rectangles probably occur multiple times). After that for each cell of the table he counted the number of rectangles it belongs to and wrote this number into it. Now he wants to find the sum of values in all cells of the table and as the table is too large, he asks you to help him find the result.","The first line contains integer *n* (1<=≤<=*n*<=≤<=100) — the number of rectangles.

Each of the following *n* lines contains four integers *x*1,<=*y*1,<=*x*2,<=*y*2 (1<=≤<=*x*1<=≤<=*x*2<=≤<=100, 1<=≤<=*y*1<=≤<=*y*2<=≤<=100), where *x*1 and *y*1 are the number of the column and row of the lower left cell and *x*2 and *y*2 are the number of the column and row of the upper right cell of a rectangle.",In a single line print the sum of all values in the cells of the table.,"['2\n1 1 2 3\n2 2 3 3\n', '2\n1 1 3 3\n1 1 3 3\n']","['10\n', '18\n']","Note to the first sample test:

Values of the table in the first three rows and columns will be as follows:

121

121

110

So, the sum of values will be equal to 10.

Note to the second sample test:

Values of the table in the first three rows and columns will be as follows:

222

222

222

So, the sum of values will be equal to 18.",OK,"def solve(x1, y1, x2, y2):
    return sum((x2[i] - x1[i] + 1) * (y2[i] - y1[i] + 1) for i in range(len(x1)))

def main():
    n = int(input())
    x1 = []
    y1 = []
    x2 = []
    y2 = []
    
    for _ in range(n):
        x1_i, y1_i, x2_i, y2_i = map(int, input().split())
        x1.append(x1_i)
        y1.append(y1_i)
        x2.append(x2_i)
        y2.append(y2_i)

    result = solve(x1, y1, x2, y2)
    print(result)

if __name__ == ""__main__"":
    main()
","# import bisect
# import operator
# import math
# from typing import Counter, NewType
# from sys import setrecursionlimit
# setrecursionlimit(1000000)

# Function to calculate the maximum number of hamburgers
def max_hamburgers(recipe, nb, ns, nc, pb, ps, pc, r):
    # Count ingredients in the recipe
    count_b = recipe.count('B')
    count_s = recipe.count('S')
    count_c = recipe.count('C')

    # Binary search for the maximum number of hamburgers
    left, right = 0, 10**13  # A large enough range
    
    while left < right:
        mid = (left + right + 1) // 2  # Midpoint (candidate for number of hamburgers)
        
        # Calculate the total ingredients needed for mid hamburgers
        total_b = max(0, count_b * mid - nb)
        total_s = max(0, count_s * mid - ns)
        total_c = max(0, count_c * mid - nc)
        
        # Calculate the total cost to buy the additional ingredients
        total_cost = total_b * pb + total_s * ps + total_c * pc
        
        # Check if the cost is within the budget
        if total_cost <= r:
            left = mid  # We can afford mid hamburgers
        else:
            right = mid - 1  # Too expensive, try fewer hamburgers
    
    return left  # Maximum number of hamburgers that can be made

# Input handling
if __name__ == ""__main__"":
    recipe = input().strip()  # Recipe string
    nb, ns, nc = map(int, input().strip().split())  # Number of ingredients in kitchen
    pb, ps, pc = map(int, input().strip().split())  # Prices of ingredients
    r = int(input().strip())  # Amount of rubles available
    
    # Calculate and print maximum hamburgers
    print(max_hamburgers(recipe, nb, ns, nc, pb, ps, pc, r))"
155,A,I_love_\%username\%,PROGRAMMING,['brute force'],"Vasya adores sport programming. He can't write programs but he loves to watch the contests' progress. Vasya even has a favorite coder and Vasya pays special attention to him.

One day Vasya decided to collect the results of all contests where his favorite coder participated and track the progress of his coolness. For each contest where this coder participated, he wrote out a single non-negative number — the number of points his favorite coder earned in the contest. Vasya wrote out the points for the contest in the order, in which the contests run (naturally, no two contests ran simultaneously).

Vasya considers a coder's performance in a contest amazing in two situations: he can break either his best or his worst performance record. First, it is amazing if during the contest the coder earns strictly more points that he earned on each past contest. Second, it is amazing if during the contest the coder earns strictly less points that he earned on each past contest. A coder's first contest isn't considered amazing. Now he wants to count the number of amazing performances the coder had throughout his whole history of participating in contests. But the list of earned points turned out long and Vasya can't code... That's why he asks you to help him.","The first line contains the single integer *n* (1<=≤<=*n*<=≤<=1000) — the number of contests where the coder participated.

The next line contains *n* space-separated non-negative integer numbers — they are the points which the coder has earned. The points are given in the chronological order. All points do not exceed 10000.",Print the single number — the number of amazing performances the coder has had during his whole history of participating in the contests.,"['5\n100 50 200 150 200\n', '10\n4664 6496 5814 7010 5762 5736 6944 4850 3698 7242\n']","['2\n', '4\n']","In the first sample the performances number 2 and 3 are amazing.

In the second sample the performances number 2, 4, 9 and 10 are amazing.",OK,"n = int(input())
m = list(map(int, input().split()))
hitler = 0
maxx = m[0]
minn = m[0]
for i in range(1, n):
    if m[i] > maxx:
        maxx = m[i]
        hitler += 1
    elif m[i] < minn:
        minn = m[i]
        hitler += 1
print(hitler)
","from collections import defaultdict

n, m = map(int, input().split())

graph = defaultdict(list)
colors = {i: -1 for i in range(1, n + 1)}
visited = set()

# Build the graph based on the enmity relations
for _ in range(m):
    a, b = map(int, input().split())
    graph[a].append(b)
    graph[b].append(a)

def is_bipartite(node, color):
    # Assign the color to the current student
    colors[node] = color
    for neighbor in graph[node]:
        # If the neighbor hasn't been colored, color it with the opposite color
        if colors[neighbor] == -1:
            if not is_bipartite(neighbor, 1 - color):
                return False
        # If the neighbor has the same color, it's not bipartite
        elif colors[neighbor] == color:
            return False
    return True

# Count of both teams
team_size = [0, 0]
bench_count = 0

# Check each component if it's bipartite and calculate team sizes
for student in range(1, n + 1):
    if colors[student] == -1:  # Not yet visited
        if not is_bipartite(student, 0):
            # If it's not bipartite, all must sit on the bench
            bench_count += len([x for x in colors if colors[x] != -1])
            colors = {i: -1 for i in range(1, n + 1)}  # Reset colors
            break
        
        # Count the size of the teams
        count_0 = sum(1 for c in colors.values() if c == 0)
        count_1 = sum(1 for c in colors.values() if c == 1)
        team_size[0] += count_0
        team_size[1] += count_1

# Calculate total players that have to be sent to the bench
total_team_size = min(team_size)
bench_count += (team_size[0] + team_size[1] - 2 * total_team_size)

print(bench_count)"
581,A,Vasya the Hipster,PROGRAMMING,"['implementation', 'math']","One day Vasya the Hipster decided to count how many socks he had. It turned out that he had *a* red socks and *b* blue socks.

According to the latest fashion, hipsters should wear the socks of different colors: a red one on the left foot, a blue one on the right foot.

Every day Vasya puts on new socks in the morning and throws them away before going to bed as he doesn't want to wash them.

Vasya wonders, what is the maximum number of days when he can dress fashionable and wear different socks, and after that, for how many days he can then wear the same socks until he either runs out of socks or cannot make a single pair from the socks he's got.

Can you help him?","The single line of the input contains two positive integers *a* and *b* (1<=≤<=*a*,<=*b*<=≤<=100) — the number of red and blue socks that Vasya's got.","Print two space-separated integers — the maximum number of days when Vasya can wear different socks and the number of days when he can wear the same socks until he either runs out of socks or cannot make a single pair from the socks he's got.

Keep in mind that at the end of the day Vasya throws away the socks that he's been wearing on that day.","['3 1\n', '2 3\n', '7 3\n']","['1 1\n', '2 0\n', '3 2\n']","In the first sample Vasya can first put on one pair of different socks, after that he has two red socks left to wear on the second day.",OK,"a, b = input().split()
a, b = int(a), int(b)

print(f""{min(a, b)} {abs(a-b)//2}"")","def max_problems_solved(n, k):
    total_time = 0
    problems_solved = 0
    time_available = 240 - k  # Total time available to solve problems

    for i in range(1, n + 1):
        problem_time = 5 * i  # Time to solve the i-th problem
        total_time += problem_time
        
        if total_time <= time_available:  # Check if time is within the available time
            problems_solved += 1  # Increment count of problems solved
        else:
            break  # No more time to solve additional problems

    return problems_solved  # Return the maximum number of problems solved"
928,A,Login Verification,PROGRAMMING,"['*special', 'strings']","When registering in a social network, users are allowed to create their own convenient login to make it easier to share contacts, print it on business cards, etc.

Login is an arbitrary sequence of lower and uppercase latin letters, digits and underline symbols («_»). However, in order to decrease the number of frauds and user-inattention related issues, it is prohibited to register a login if it is similar with an already existing login. More precisely, two logins *s* and *t* are considered similar if we can transform *s* to *t* via a sequence of operations of the following types: 
 -  transform lowercase letters to uppercase and vice versa; -  change letter «O» (uppercase latin letter) to digit «0» and vice versa; -  change digit «1» (one) to any letter among «l» (lowercase latin «L»), «I» (uppercase latin «i») and vice versa, or change one of these letters to other. 
For example, logins «Codeforces» and «codef0rces» as well as «OO0OOO00O0OOO0O00OOO0OO_lol» and «OO0OOO0O00OOO0O00OO0OOO_1oI» are considered similar whereas «Codeforces» and «Code_forces» are not.

You're given a list of existing logins with no two similar amonst and a newly created user login. Check whether this new login is similar with any of the existing ones.","The first line contains a non-empty string *s* consisting of lower and uppercase latin letters, digits and underline symbols («_») with length not exceeding 50  — the login itself.

The second line contains a single integer *n* (1<=≤<=*n*<=≤<=1<=000) — the number of existing logins.

The next *n* lines describe the existing logins, following the same constraints as the user login (refer to the first line of the input). It's guaranteed that no two existing logins are similar.","Print «Yes» (without quotes), if user can register via this login, i.e. none of the existing logins is similar with it.

Otherwise print «No» (without quotes).","['1_wat\n2\n2_wat\nwat_1\n', '000\n3\n00\nooA\noOo\n', '_i_\n3\n__i_\n_1_\nI\n', 'La0\n3\n2a0\nLa1\n1a0\n', 'abc\n1\naBc\n', '0Lil\n2\nLIL0\n0Ril\n']","['Yes\n', 'No\n', 'No\n', 'No\n', 'No\n', 'Yes\n']","In the second sample case the user wants to create a login consisting of three zeros. It's impossible due to collision with the third among the existing.

In the third sample case the new login is similar with the second one.",WRONG_ANSWER,"import sys

counter = 0
checker = 0","def main():
    [n, x] = list(map(int, input().split()))
    distressed_kids = 0  # To count the number of distressed kids

    for _ in range(n):
        action, d = input().split()  # Read the action and the number of ice cream packs
        d = int(d)  # Convert the number of packs to an integer
        
        if action == '+':
            x += d  # A carrier brings d ice cream packs
        elif action == '-':
            if x >= d:
                x -= d  # Give d ice cream packs to the kid
            else:
                distressed_kids += 1  # Not enough ice cream, kid goes away distressed

    print(x, distressed_kids)  # Output the remaining ice cream packs and number of distressed kids

main()"
202,A,LLPS,PROGRAMMING,"['binary search', 'bitmasks', 'brute force', 'greedy', 'implementation', 'strings']","This problem's actual name, ""Lexicographically Largest Palindromic Subsequence"" is too long to fit into the page headline.

You are given string *s* consisting of lowercase English letters only. Find its lexicographically largest palindromic subsequence.

We'll call a non-empty string *s*[*p*1*p*2... *p**k*] = *s**p*1*s**p*2... *s**p**k* (1 <=≤<= *p*1<=&lt;<=*p*2<=&lt;<=...<=&lt;<=*p**k* <=≤<= |*s*|) a subsequence of string *s* = *s*1*s*2... *s*|*s*|, where |*s*| is the length of string *s*. For example, strings ""abcb"", ""b"" and ""abacaba"" are subsequences of string ""abacaba"".

String *x* = *x*1*x*2... *x*|*x*| is lexicographically larger than string *y* = *y*1*y*2... *y*|*y*| if either |*x*| &gt; |*y*| and *x*1<==<=*y*1, *x*2<==<=*y*2, ...,<=*x*|*y*|<==<=*y*|*y*|, or there exists such number *r* (*r*<=&lt;<=|*x*|, *r*<=&lt;<=|*y*|) that *x*1<==<=*y*1, *x*2<==<=*y*2, ..., *x**r*<==<=*y**r* and *x**r*<=<=+<=<=1<=&gt;<=*y**r*<=<=+<=<=1. Characters in the strings are compared according to their ASCII codes. For example, string ""ranger"" is lexicographically larger than string ""racecar"" and string ""poster"" is lexicographically larger than string ""post"".

String *s* = *s*1*s*2... *s*|*s*| is a palindrome if it matches string *rev*(*s*) = *s*|*s*|*s*|*s*|<=-<=1... *s*1. In other words, a string is a palindrome if it reads the same way from left to right and from right to left. For example, palindromic strings are ""racecar"", ""refer"" and ""z"".",The only input line contains a non-empty string *s* consisting of lowercase English letters only. Its length does not exceed 10.,Print the lexicographically largest palindromic subsequence of string *s*.,"['radar\n', 'bowwowwow\n', 'codeforces\n', 'mississipp\n']","['rr\n', 'wwwww\n', 's\n', 'ssss\n']","Among all distinct subsequences of string ""radar"" the following ones are palindromes: ""a"", ""d"", ""r"", ""aa"", ""rr"", ""ada"", ""rar"", ""rdr"", ""raar"" and ""radar"". The lexicographically largest of them is ""rr"".",OK,"from sys import *
import sys
from math import *
from collections import *
import string
import re
from bisect import *
from functools import reduce
from itertools import permutations, combinations
# import numpy as np
# def arr(): return np.random.randint(1,50,5)
 
t=stdin.readline
R=range
p=stdout.write
mod = int(1e9)+7
MAX = 9223372036854775808
lower = string.ascii_lowercase
upper = string.ascii_uppercase
numbers = string.digits

def S(): return t().strip()
def I(): return int(t())
def GI(): return map(int, input().strip().split())
def GS(): return map(str, t().strip().split())
def IL(): return list(map(int, t().strip().split()))
def SL(): return list(map(str, t().strip().split()))
def mat(n): return [IL() for i in range(n)]
def sieve(n): return reduce(lambda r, x: r - set(range(x**2, n, x)) if x in r else r, 
                            range(2, int(n**0.5) + 1), set(range(2,n)))
def iSq(x): return (ceil(float(sqrt(x))) == floor(float(sqrt(x))))
def ispow2(x): return ((x!=0) and (x&(x-1))==0)
def d2b(n):return bin(n).replace(""0b"", """")
def ls(x,y): return x<<y # adding '0' y bits from right and removing last y bits from left i.e floor(x/pow(2,y)) 
def rs(x,y): return x<<y # adding '0' y bits from left and removing first y bits from right i.e x*pow(2,y) 
def powof2(x): return 1<<x  

s=sorted(S())[::-1]
prev = s[0]
for i in s:
    if prev==i: print(i,end='')
    else: break
    prev=i ","def lower_bound_binary_search(arr, x):
    l, r = 0, len(arr) - 1
    while l <= r:
        mid = (l + r) // 2
        if arr[mid] <= x:
            l = mid + 1
        else:
            r = mid - 1
    return l  # Return the index of the first element greater than x

n, m = map(int, input().split())  # Read sizes of arrays
a = list(map(int, input().split()))  # Read array a
b = list(map(int, input().split()))  # Read array b

a.sort()  # Sort array a for binary search

result = []
for bj in b:
    count = lower_bound_binary_search(a, bj)  # Find the count of elements <= bj
    result.append(count)  # Store the result for current bj

print(' '.join(map(str, result)))  # Print the results space-separated"
546,A,Soldier and Bananas,PROGRAMMING,"['brute force', 'implementation', 'math']","A soldier wants to buy *w* bananas in the shop. He has to pay *k* dollars for the first banana, 2*k* dollars for the second one and so on (in other words, he has to pay *i*·*k* dollars for the *i*-th banana). 

He has *n* dollars. How many dollars does he have to borrow from his friend soldier to buy *w* bananas?","The first line contains three positive integers *k*,<=*n*,<=*w* (1<=<=≤<=<=*k*,<=*w*<=<=≤<=<=1000, 0<=≤<=*n*<=≤<=109), the cost of the first banana, initial number of dollars the soldier has and number of bananas he wants.","Output one integer — the amount of dollars that the soldier must borrow from his friend. If he doesn't have to borrow money, output 0.",['3 17 4\n'],['13'],none,WRONG_ANSWER,"k, n, w = list(map(int, input().split()))

ans = [3 for i in range(w + 1)]

for i in range(1, w + 1):
    ans[i] = ans[i] * i
print(sum(ans) - n - ans[0])

","from collections import deque

def solve(n, k, main_courses, dependencies):
    graph = [[] for _ in range(n + 1)]
    in_degree = [0] * (n + 1)
    necessary_courses = set(main_courses)

    # Build the graph
    for i in range(1, n + 1):
        t_i, *deps = dependencies[i - 1]
        in_degree[i] += t_i
        for dep in deps:
            graph[dep].append(i)  # Dependent course points to current course

    # Initialize the queue with independent courses required for main courses
    queue = deque()
    for course in main_courses:
        if in_degree[course] == 0:
            queue.append(course)

    order = []
    while queue:
        course = queue.popleft()
        order.append(course)
        for next_course in graph[course]:
            in_degree[next_course] -= 1
            if in_degree[next_course] == 0:
                queue.append(next_course)

    # Check if we fulfilled all necessary courses
    if len(order) < k:
        print(-1)
        return

    # To include all dependent courses
    completed_courses = set(order)
    result = list(completed_courses)

    result.sort()  # Sorting to print in chronological order

    print(len(result))
    print("" "".join(map(str, result)))

# Example of how you might call the function (this part should be outside the function):
# n, k = map(int, input().split())
# main_courses = list(map(int, input().split()))
# dependencies = [list(map(int, input().split())) for _ in range(n)]
# solve(n, k, main_courses, dependencies)"
581,A,Vasya the Hipster,PROGRAMMING,"['implementation', 'math']","One day Vasya the Hipster decided to count how many socks he had. It turned out that he had *a* red socks and *b* blue socks.

According to the latest fashion, hipsters should wear the socks of different colors: a red one on the left foot, a blue one on the right foot.

Every day Vasya puts on new socks in the morning and throws them away before going to bed as he doesn't want to wash them.

Vasya wonders, what is the maximum number of days when he can dress fashionable and wear different socks, and after that, for how many days he can then wear the same socks until he either runs out of socks or cannot make a single pair from the socks he's got.

Can you help him?","The single line of the input contains two positive integers *a* and *b* (1<=≤<=*a*,<=*b*<=≤<=100) — the number of red and blue socks that Vasya's got.","Print two space-separated integers — the maximum number of days when Vasya can wear different socks and the number of days when he can wear the same socks until he either runs out of socks or cannot make a single pair from the socks he's got.

Keep in mind that at the end of the day Vasya throws away the socks that he's been wearing on that day.","['3 1\n', '2 3\n', '7 3\n']","['1 1\n', '2 0\n', '3 2\n']","In the first sample Vasya can first put on one pair of different socks, after that he has two red socks left to wear on the second day.",RUNTIME_ERROR,"def vasyahisper(a, b):
    p = min(a, b)

    s = ((a - p) // 2) + ((b - p) // 2)

    print(f'{p}  {s}')

vasyahisper(int(input()), int(input()))
 	 	 	 	  		 	   	    			  	  	","""""""
Code of Ayush Tiwari
Codechef: ayush572000
Codeforces: servermonk

""""""

def largest_k_multiple_free_subset(n, k, a):
    # Create a set to store the elements seen so far
    seen = set()
    # Initialize the size of the largest k-multiple free subset
    largest_size = 0
    
    # Sort the array to process elements in increasing order
    a.sort()
    
    for number in a:
        # If number is not a multiple of k of any seen number
        if number // k not in seen:
            # Add the number to the seen set and increase the largest size
            seen.add(number)
            largest_size += 1
            
    return largest_size

# Read input values
n, k = map(int, input().strip().split())
a = list(map(int, input().strip().split()))

# Output the size of the largest k-multiple free subset
print(largest_k_multiple_free_subset(n, k, a))"
339,A,Helpful Maths,PROGRAMMING,"['greedy', 'implementation', 'sortings', 'strings']","Xenia the beginner mathematician is a third year student at elementary school. She is now learning the addition operation.

The teacher has written down the sum of multiple numbers. Pupils should calculate the sum. To make the calculation easier, the sum only contains numbers 1, 2 and 3. Still, that isn't enough for Xenia. She is only beginning to count, so she can calculate a sum only if the summands follow in non-decreasing order. For example, she can't calculate sum 1+3+2+1 but she can calculate sums 1+1+2 and 3+3.

You've got the sum that was written on the board. Rearrange the summans and print the sum in such a way that Xenia can calculate the sum.","The first line contains a non-empty string *s* — the sum Xenia needs to count. String *s* contains no spaces. It only contains digits and characters ""+"". Besides, string *s* is a correct sum of numbers 1, 2 and 3. String *s* is at most 100 characters long.",Print the new sum that Xenia can count.,"['3+2+1\n', '1+1+3+1+3\n', '2\n']","['1+2+3\n', '1+1+1+3+3\n', '2\n']",none,OK,"s = str(input())

s1 = s.split('+')
print('+'.join(sorted(s1)))","from collections import defaultdict


def add_node(graph, node_a, node_b):
    graph[node_a - 1][node_b - 1] = True
    graph[node_b - 1][node_a - 1] = True


def count_cycles(graph, n):
    visited = [False] * n
    stack = []
    cycle_count = [0]

    def dfs(v, start, depth):
        visited[v] = True
        stack.append(v)

        # Check for cycles
        if depth > 2 and v == start:
            cycle_count[0] += 1
        
        for u in range(n):
            if graph[v][u]:
                if not visited[u]:
                    dfs(u, start, depth + 1)
        
        # Backtrack
        visited[v] = False
        stack.pop()

    for i in range(n):
        dfs(i, i, 0)

    return cycle_count[0] // 2  # each cycle is counted twice


# Read input
n, m = map(int, input().split())
graph = [[False] * n for _ in range(n)]

for _ in range(m):
    a, b = map(int, input().split())
    add_node(graph, a, b)

# Get the number of cycles and output
num_cycles = count_cycles(graph, n)
print(num_cycles)"
231,A,Team,PROGRAMMING,"['brute force', 'greedy']","One day three best friends Petya, Vasya and Tonya decided to form a team and take part in programming contests. Participants are usually offered several problems during programming contests. Long before the start the friends decided that they will implement a problem if at least two of them are sure about the solution. Otherwise, the friends won't write the problem's solution.

This contest offers *n* problems to the participants. For each problem we know, which friend is sure about the solution. Help the friends find the number of problems for which they will write a solution.","The first input line contains a single integer *n* (1<=≤<=*n*<=≤<=1000) — the number of problems in the contest. Then *n* lines contain three integers each, each integer is either 0 or 1. If the first number in the line equals 1, then Petya is sure about the problem's solution, otherwise he isn't sure. The second number shows Vasya's view on the solution, the third number shows Tonya's view. The numbers on the lines are separated by spaces.",Print a single integer — the number of problems the friends will implement on the contest.,"['3\n1 1 0\n1 1 1\n1 0 0\n', '2\n1 0 0\n0 1 1\n']","['2\n', '1\n']","In the first sample Petya and Vasya are sure that they know how to solve the first problem and all three of them know how to solve the second problem. That means that they will write solutions for these problems. Only Petya is sure about the solution for the third problem, but that isn't enough, so the friends won't take it. 

In the second sample the friends will only implement the second problem, as Vasya and Tonya are sure about the solution.",OK,"#!/usr/bin/python3

n = int(input())

votes = []

for i in range(n):
    a, b, c = [int(char) for char in input().split("" "")]
    if sum([a, b, c]) >= 2:
        votes.append(1)

print(len(votes))
","n = int(input())
pre = list(input())
lat = list(input())
step = 0

for i in range(n):
    # Calculate the difference between the current and target digit
    diff = abs(int(pre[i]) - int(lat[i]))
    # Determine the minimum moves considering the circular nature of the lock
    step += min(diff, 10 - diff)

# Print the total number of moves needed to unlock
print(step)"
686,A,Free Ice Cream,PROGRAMMING,"['constructive algorithms', 'implementation']","After their adventure with the magic mirror Kay and Gerda have returned home and sometimes give free ice cream to kids in the summer.

At the start of the day they have *x* ice cream packs. Since the ice cream is free, people start standing in the queue before Kay and Gerda's house even in the night. Each person in the queue wants either to take several ice cream packs for himself and his friends or to give several ice cream packs to Kay and Gerda (carriers that bring ice cream have to stand in the same queue).

If a carrier with *d* ice cream packs comes to the house, then Kay and Gerda take all his packs. If a child who wants to take *d* ice cream packs comes to the house, then Kay and Gerda will give him *d* packs if they have enough ice cream, otherwise the child will get no ice cream at all and will leave in distress.

Kay wants to find the amount of ice cream they will have after all people will leave from the queue, and Gerda wants to find the number of distressed kids.","The first line contains two space-separated integers *n* and *x* (1<=≤<=*n*<=≤<=1000, 0<=≤<=*x*<=≤<=109).

Each of the next *n* lines contains a character '+' or '-', and an integer *d**i*, separated by a space (1<=≤<=*d**i*<=≤<=109). Record ""+ *d**i*"" in *i*-th line means that a carrier with *d**i* ice cream packs occupies *i*-th place from the start of the queue, and record ""- *d**i*"" means that a child who wants to take *d**i* packs stands in *i*-th place.","Print two space-separated integers — number of ice cream packs left after all operations, and number of kids that left the house in distress.","['5 7\n+ 5\n- 10\n- 20\n+ 40\n- 20\n', '5 17\n- 16\n- 2\n- 98\n+ 100\n- 98\n']","['22 1\n', '3 2\n']","Consider the first sample.
 1.  Initially Kay and Gerda have 7 packs of ice cream. 1.  Carrier brings 5 more, so now they have 12 packs. 1.  A kid asks for 10 packs and receives them. There are only 2 packs remaining. 1.  Another kid asks for 20 packs. Kay and Gerda do not have them, so the kid goes away distressed. 1.  Carrier bring 40 packs, now Kay and Gerda have 42 packs. 1.  Kid asks for 20 packs and receives them. There are 22 packs remaining.",OK,"x = list(map(int, input().split()))
s = 0
for i in range(x[0]):
    y = list(map(str, input().split()))
    y[1] = int(y[1])
    if y[0] == '+':
        x[1] = x[1] + y[1]
    
    elif y[0] == '-':
        if x[1] >= y[1]:
            x[1] = x[1] - y[1]
        else:
            s = s+1
m = [str(x[1]),str(s)]
z = ' '.join(m)
print(z)","'''
http://codeforces.com/problemset/problem/522/A
'''

def get_max_chain_length():
    '''Traverses the repost graph to get max length.'''
    users = int(input())
    reposts = {}
    
    # Initialize the reposts dictionary with the base case
    reposts[""polycarp""] = 1  # Starting with Polycarp's original post
    
    for _ in range(users):
        line = input().strip().lower()  # Read and normalize input
        name1, _, name2 = line.split()  # Split into components

        # If name2's repost chain length is known, calculate name1's
        if name2 in reposts:
            reposts[name1] = reposts[name2] + 1  # Increment the chain length for name1

    # Return the maximum length from the reposts dictionary
    print(max(reposts.values()))

get_max_chain_length()"
332,A,Down the Hatch!,PROGRAMMING,['implementation'],"Everybody knows that the Berland citizens are keen on health, especially students. Berland students are so tough that all they drink is orange juice!

Yesterday one student, Vasya and his mates made some barbecue and they drank this healthy drink only. After they ran out of the first barrel of juice, they decided to play a simple game. All *n* people who came to the barbecue sat in a circle (thus each person received a unique index *b**i* from 0 to *n*<=-<=1). The person number 0 started the game (this time it was Vasya). All turns in the game were numbered by integers starting from 1. If the *j*-th turn was made by the person with index *b**i*, then this person acted like that:
 1.  he pointed at the person with index (*b**i*<=+<=1) *mod* *n* either with an elbow or with a nod (*x* *mod* *y* is the remainder after dividing *x* by *y*); 1.  if *j*<=≥<=4 and the players who had turns number *j*<=-<=1, *j*<=-<=2, *j*<=-<=3, made during their turns the same moves as player *b**i* on the current turn, then he had drunk a glass of juice; 1.  the turn went to person number (*b**i*<=+<=1) *mod* *n*. 
The person who was pointed on the last turn did not make any actions.

The problem was, Vasya's drunk too much juice and can't remember the goal of the game. However, Vasya's got the recorded sequence of all the participants' actions (including himself). Now Vasya wants to find out the maximum amount of juice he could drink if he played optimally well (the other players' actions do not change). Help him.

You can assume that in any scenario, there is enough juice for everybody.","The first line contains a single integer *n* (4<=≤<=*n*<=≤<=2000) — the number of participants in the game. The second line describes the actual game: the *i*-th character of this line equals 'a', if the participant who moved *i*-th pointed at the next person with his elbow, and 'b', if the participant pointed with a nod. The game continued for at least 1 and at most 2000 turns.",Print a single integer — the number of glasses of juice Vasya could have drunk if he had played optimally well.,"['4\nabbba\n', '4\nabbab\n']","['1\n', '0\n']","In both samples Vasya has got two turns — 1 and 5. In the first sample, Vasya could have drunk a glass of juice during the fifth turn if he had pointed at the next person with a nod. In this case, the sequence of moves would look like ""abbbb"". In the second sample Vasya wouldn't drink a single glass of juice as the moves performed during turns 3 and 4 are different.",WRONG_ANSWER,"print(""_RANDOM_GUESS_1689603446.3714156"")# 1689603446.371438","def gcd(a, b):
    if b == 0:
        return a
    return gcd(b, a % b)

def can_break_shield(a, b, c):
    # Check if c can be expressed as a linear combination of a and b
    # using the gcd of a and b
    if c % gcd(a, b) == 0 and c <= (max(a, b) * (c // min(a, b))):
        return ""Yes""
    return ""No""

# Input reading
a, b, c = map(int, input().split())
# Output the result
print(can_break_shield(a, b, c))"
622,F,The Sum of the k-th Powers,PROGRAMMING,['math'],"There are well-known formulas: , , . Also mathematicians found similar formulas for higher degrees.

Find the value of the sum  modulo 109<=+<=7 (so you should find the remainder after dividing the answer by the value 109<=+<=7).","The only line contains two integers *n*,<=*k* (1<=≤<=*n*<=≤<=109,<=0<=≤<=*k*<=≤<=106).",Print the only integer *a* — the remainder after dividing the value of the sum by the value 109<=+<=7.,"['4 1\n', '4 2\n', '4 3\n', '4 0\n']","['10\n', '30\n', '100\n', '4\n']",none,TIME_LIMIT_EXCEEDED,"def lagrange_interpolation(n, y, T, mod):
    # f(i)=y_i (i=0,1,...,n) となる f について f(T) を O(n) で求める

    finv = [0]*(n+1)
    fac = 1
    for i in range(1, n+1):
        fac = fac*i % mod
    finv[n] = pow(fac, mod-2, mod)
    for i in range(n-1, -1, -1):
        finv[i] = finv[i+1]*(i+1) % mod

    T %= mod

    L = [1]*(n+1)
    for i in range(n):
        L[i+1] = L[i]*(T-i) % mod

    R = [1]*(n+1)
    for i in range(n, 0, -1):
        R[i-1] = R[i]*(T-i) % mod

    res = 0
    for i in range(n+1):
        tmp = y[i]*L[i] % mod*R[i] % mod*finv[i] % mod*finv[n-i] % mod
        if (n-i) % 2 == 0:
            res += tmp
        else:
            res -= tmp

    return res % mod


def fpow(x, k):
    res = 1
    while k:
        if k & 1:
            res = res*x % mod
        x = x*x % mod
        k >>= 1
    return res


mod = 10**9+7
n, k = map(int, input().split())

s = k+1
dp = [0]*(s+1)
res = 0
for i in range(1, s+1):
    res = (res+fpow(i, k)) % mod
    dp[i] = res
print(lagrange_interpolation(s, dp, n, mod))
","def arr_inp():
    return [int(x) for x in stdin.readline().split()]

from sys import stdin

n = int(stdin.readline().strip())  # Read number of boxes
strengths = arr_inp()              # Read strengths of boxes

# We will use a greedy approach to form the piles
piles = 0                            # Initialize number of piles
current_level = []                   # Keep track of current boxes in the current pile

for strength in strengths:
    # If we can add this box to the current level
    if len(current_level) < strength + 1:  # ""+1"" because we can place on top
        current_level.append(strength)      # Add to current pile
    else:
        piles += 1                          # Need a new pile
        current_level = [strength]          # Start new pile with the current box

# Count last pile if it has boxes
if current_level:
    piles += 1

print(piles)                          # Output the minimum number of piles"
673,A,Bear and Game,PROGRAMMING,['implementation'],"Bear Limak likes watching sports on TV. He is going to watch a game today. The game lasts 90 minutes and there are no breaks.

Each minute can be either interesting or boring. If 15 consecutive minutes are boring then Limak immediately turns TV off.

You know that there will be *n* interesting minutes *t*1,<=*t*2,<=...,<=*t**n*. Your task is to calculate for how many minutes Limak will watch the game.","The first line of the input contains one integer *n* (1<=≤<=*n*<=≤<=90) — the number of interesting minutes.

The second line contains *n* integers *t*1,<=*t*2,<=...,<=*t**n* (1<=≤<=*t*1<=&lt;<=*t*2<=&lt;<=... *t**n*<=≤<=90), given in the increasing order.",Print the number of minutes Limak will watch the game.,"['3\n7 20 88\n', '9\n16 20 30 40 50 60 70 80 90\n', '9\n15 20 30 40 50 60 70 80 90\n']","['35\n', '15\n', '90\n']","In the first sample, minutes 21, 22, ..., 35 are all boring and thus Limak will turn TV off immediately after the 35-th minute. So, he would watch the game for 35 minutes.

In the second sample, the first 15 minutes are boring.

In the third sample, there are no consecutive 15 boring minutes. So, Limak will watch the whole game.",WRONG_ANSWER,"
n = int(input())
arr = list(map(int, input().split(' ')))

last = 0
end = False

for i in arr:
  if i - last > 15:
    print(last + 15)
    end = True
  last = i

if not end:
  print(last)","from math import gcd

def LCM(a, b):
    if min(a, b) == 0: return max(a, b)
    return a // gcd(a, b) * b

def occurs_in_table(n, m, k, a):
    # We need to check the GCD values in the specified range
    for i in range(1, n + 1):
        # Start checking from each row
        specific_row = []
        for j in range(1, m + 1):
            # For each cell in row i, column j, we calculate GCD(i, j)
            specific_row.append(gcd(i, j))
        
        # Now, check if the sequence a occurs in the specific_row
        for start in range(m - k + 1):
            if specific_row[start:start + k] == a:
                return ""YES""
    
    return ""NO""

# Input reading
n, m, k = map(int, input().split())
a = list(map(int, input().split()))

# Output result
print(occurs_in_table(n, m, k, a))"
548,A,Mike and Fax,PROGRAMMING,"['brute force', 'implementation', 'strings']","While Mike was walking in the subway, all the stuff in his back-bag dropped on the ground. There were several fax messages among them. He concatenated these strings in some order and now he has string *s*.

He is not sure if this is his own back-bag or someone else's. He remembered that there were exactly *k* messages in his own bag, each was a palindrome string and all those strings had the same length.

He asked you to help him and tell him if he has worn his own back-bag. Check if the given string *s* is a concatenation of *k* palindromes of the same length.","The first line of input contains string *s* containing lowercase English letters (1<=≤<=|*s*|<=≤<=1000).

The second line contains integer *k* (1<=≤<=*k*<=≤<=1000).","Print ""YES""(without quotes) if he has worn his own back-bag or ""NO""(without quotes) otherwise.","['saba\n2\n', 'saddastavvat\n2\n']","['NO\n', 'YES\n']","Palindrome is a string reading the same forward and backward.

In the second sample, the faxes in his back-bag can be ""saddas"" and ""tavvat"".",OK,"

n = input()

a = int(input())


if len(n)%a!=0:
    print('NO')
else:
    g = len(n)//a


    p=0
   
    if g%2==0:
    
        for k in range(0,len(n),g):
            u= n[k:k+g]
       
            if u[:g//2]!=u[g//2:][::-1]:
                print('NO')
                p+=1
                break
    else:
        for k in range(0,len(n),g):
            u= n[k:k+g]
            if u[:g//2]!=u[g//2+1:][::-1]:
                print('NO')
                p+=1
                break

    if p==0:
        print('YES')
        


","def is_unimodal(arr):
    n = len(arr)
    i = 0
    # Check for strictly increasing part
    while i < n - 1 and arr[i] < arr[i + 1]:
        i += 1
    
    # Check for constant part
    while i < n - 1 and arr[i] == arr[i + 1]:
        i += 1
    
    # Check for strictly decreasing part
    while i < n - 1 and arr[i] > arr[i + 1]:
        i += 1

    # If we have traversed the entire array, it is unimodal
    return i == n - 1

# Read input
n = int(input())
arr = list(map(int, input().split()))

# Output result
if is_unimodal(arr):
    print(""YES"")
else:
    print(""NO"")"
400,B,Inna and New Matrix of Candies,PROGRAMMING,"['brute force', 'implementation', 'schedules']","Inna likes sweets and a game called the ""Candy Matrix"". Today, she came up with the new game ""Candy Matrix 2: Reload"".

The field for the new game is a rectangle table of size *n*<=×<=*m*. Each line of the table contains one cell with a dwarf figurine, one cell with a candy, the other cells of the line are empty. The game lasts for several moves. During each move the player should choose all lines of the matrix where dwarf is not on the cell with candy and shout ""Let's go!"". After that, all the dwarves from the chosen lines start to simultaneously move to the right. During each second, each dwarf goes to the adjacent cell that is located to the right of its current cell. The movement continues until one of the following events occurs:
 -  some dwarf in one of the chosen lines is located in the rightmost cell of his row; -  some dwarf in the chosen lines is located in the cell with the candy. 
The point of the game is to transport all the dwarves to the candy cells.

Inna is fabulous, as she came up with such an interesting game. But what about you? Your task is to play this game optimally well. Specifically, you should say by the given game field what minimum number of moves the player needs to reach the goal of the game.","The first line of the input contains two integers *n* and *m* (1<=≤<=*n*<=≤<=1000; 2<=≤<=*m*<=≤<=1000). 

Next *n* lines each contain *m* characters — the game field for the ""Candy Martix 2: Reload"". Character ""*"" represents an empty cell of the field, character ""G"" represents a dwarf and character ""S"" represents a candy. The matrix doesn't contain other characters. It is guaranteed that each line contains exactly one character ""G"" and one character ""S"".","In a single line print a single integer — either the minimum number of moves needed to achieve the aim of the game, or -1, if the aim cannot be achieved on the given game field.","['3 4\n*G*S\nG**S\n*G*S\n', '1 3\nS*G\n']","['2\n', '-1\n']",none,WRONG_ANSWER,"n,m=map(int,input().split())
s=-1
l=[]
for i in range(n):
  k=list(input())
  for j in range(m):
    if k[j]==""G"":
      for a in range(j+1,m):
        if k[a]==""S"":
          s=abs(j-a)
      l.append(s)
print(min(l))
          ","n, m = int(input()), int(input())  # Read the number of USB drives and file size
capacities = sorted([int(input()) for _ in range(n)], reverse=True)  # Read and sort the capacities in descending order
count = 0  # Initialize the counter for the number of USB drives used
total_capacity = 0  # Initialize the total capacity used

# Use the drives until the total capacity meets or exceeds the file size
for capacity in capacities:
    total_capacity += capacity  # Add the capacity of the current USB drive
    count += 1  # Increment the count of USB drives used
    if total_capacity >= m:  # Check if we have enough capacity
        break  # Exit the loop if we have enough

print(count)  # Output the minimum number of USB drives needed"
356,A,Knight Tournament,PROGRAMMING,"['data structures', 'dsu']","Hooray! Berl II, the king of Berland is making a knight tournament. The king has already sent the message to all knights in the kingdom and they in turn agreed to participate in this grand event.

As for you, you're just a simple peasant. There's no surprise that you slept in this morning and were late for the tournament (it was a weekend, after all). Now you are really curious about the results of the tournament. This time the tournament in Berland went as follows:
 -  There are *n* knights participating in the tournament. Each knight was assigned his unique number — an integer from 1 to *n*. -  The tournament consisted of *m* fights, in the *i*-th fight the knights that were still in the game with numbers at least *l**i* and at most *r**i* have fought for the right to continue taking part in the tournament. -  After the *i*-th fight among all participants of the fight only one knight won — the knight number *x**i*, he continued participating in the tournament. Other knights left the tournament. -  The winner of the last (the *m*-th) fight (the knight number *x**m*) became the winner of the tournament. 
You fished out all the information about the fights from your friends. Now for each knight you want to know the name of the knight he was conquered by. We think that the knight number *b* was conquered by the knight number *a*, if there was a fight with both of these knights present and the winner was the knight number *a*.

Write the code that calculates for each knight, the name of the knight that beat him.","The first line contains two integers *n*, *m* (2<=≤<=*n*<=≤<=3·105; 1<=≤<=*m*<=≤<=3·105) — the number of knights and the number of fights. Each of the following *m* lines contains three integers *l**i*,<=*r**i*,<=*x**i* (1<=≤<=*l**i*<=&lt;<=*r**i*<=≤<=*n*; *l**i*<=≤<=*x**i*<=≤<=*r**i*) — the description of the *i*-th fight.

It is guaranteed that the input is correct and matches the problem statement. It is guaranteed that at least two knights took part in each battle.","Print *n* integers. If the *i*-th knight lost, then the *i*-th number should equal the number of the knight that beat the knight number *i*. If the *i*-th knight is the winner, then the *i*-th number must equal 0.","['4 3\n1 2 1\n1 3 3\n1 4 4\n', '8 4\n3 5 4\n3 7 6\n2 8 8\n1 8 1\n']","['3 1 4 0 ', '0 8 4 6 4 8 6 1 ']","Consider the first test case. Knights 1 and 2 fought the first fight and knight 1 won. Knights 1 and 3 fought the second fight and knight 3 won. The last fight was between knights 3 and 4, knight 4 won.",WRONG_ANSWER,"# 4 3
# k = [1, 2, 3, 4]

# 1 2 1
# [1, 2], 1
# ans = [0, 1, 0, 0]
# [1, 3, 4]

# 1 3 3
# [1, 3], 3
# ans = [3, 1, 0, 0]
# [3, 4]

# 1 4 4
# [3, 4], 4
# ans = [3, 1, 4, 0]
# [4]


# 8 4
# k = {1, 2, 3, 4, 5, 6, 7, 8}

# 3 5 4
# [3, 4, 5], 4
# ans = [0, 0, 4, 0, 4, 0, 0, 0]
# [1, 2, 4, 6, 7, 8]

# 3 7 6
# [4, 6, 7], 6
# ans = [0, 0, 4, 6, 4, 0, 6, 0]
# [1, 2, 6, 8]

# 2 8 8
# [2, 6, 8], 8
# ans = [0, 8, 4, 6, 4, 8, 6, 0]
# [1, 8]

# 1 8 1
# [1, 8], 1
# # ans = [0, 8, 4, 6, 4, 8, 6, 1]
# [1]


# n = 4, m = 3
[n, m] = map(int, input().split("" ""))

# k = [1, 2, 3, 4, 5, 6, 7, 8]
k = []
for i in range(n):
    k.append(i+1)

# print(k)
# ans = [0, 0, 0, 0, 0, 0, 0, 0]
ans = [0] * n

for i in range(m):
    # 3 5 4
    # l = 3, r = 5, x = 4
    [l, r, x] = map(int, input().split("" ""))
    # f = [3, 5]
    f = []
    for i in range(k.index(l), k.index(r)+1):
        if k[i] != x:
            f.append(k[i])

    # ans = [0, 0, 4, 0, 4, 0, 0, 0]

    for i in f:
        if ans[i-1] == 0:
            ans[i-1] = x
    # print(f)
    print(ans)
","def sieve(n):
    si = [True for i in range(n+1)]
    si[0] = si[1] = False
    p = 2
    while p**2 <= n:
        if si[p] == True:
            for i in range(p**2, n+1, p):
                si[i] = False
        p += 1
    return [p for p in range(n+1) if si[p]]

def noldbach_problem(n, k):
    primes = sieve(n)
    count = 0
    
    # Check pairs of neighboring primes
    for i in range(len(primes) - 1):
        sum_prime = primes[i] + primes[i + 1] + 1
        if sum_prime <= n and sum_prime in primes:
            count += 1
            
    return ""YES"" if count >= k else ""NO""

# Read input values
n, k = map(int, input().split())
# Output the result of the Noldbach problem
print(noldbach_problem(n, k))"
259,A,Little Elephant and Chess,PROGRAMMING,"['brute force', 'strings']","The Little Elephant loves chess very much. 

One day the Little Elephant and his friend decided to play chess. They've got the chess pieces but the board is a problem. They've got an 8<=×<=8 checkered board, each square is painted either black or white. The Little Elephant and his friend know that a proper chessboard doesn't have any side-adjacent cells with the same color and the upper left cell is white. To play chess, they want to make the board they have a proper chessboard. For that the friends can choose any row of the board and cyclically shift the cells of the chosen row, that is, put the last (rightmost) square on the first place in the row and shift the others one position to the right. You can run the described operation multiple times (or not run it at all).

For example, if the first line of the board looks like that ""BBBBBBWW"" (the white cells of the line are marked with character ""W"", the black cells are marked with character ""B""), then after one cyclic shift it will look like that ""WBBBBBBW"".

Help the Little Elephant and his friend to find out whether they can use any number of the described operations to turn the board they have into a proper chessboard.","The input consists of exactly eight lines. Each line contains exactly eight characters ""W"" or ""B"" without any spaces: the *j*-th character in the *i*-th line stands for the color of the *j*-th cell of the *i*-th row of the elephants' board. Character ""W"" stands for the white color, character ""B"" stands for the black color.

Consider the rows of the board numbered from 1 to 8 from top to bottom, and the columns — from 1 to 8 from left to right. The given board can initially be a proper chessboard.","In a single line print ""YES"" (without the quotes), if we can make the board a proper chessboard and ""NO"" (without the quotes) otherwise.","['WBWBWBWB\nBWBWBWBW\nBWBWBWBW\nBWBWBWBW\nWBWBWBWB\nWBWBWBWB\nBWBWBWBW\nWBWBWBWB\n', 'WBWBWBWB\nWBWBWBWB\nBBWBWWWB\nBWBWBWBW\nBWBWBWBW\nBWBWBWWW\nBWBWBWBW\nBWBWBWBW\n']","['YES\n', 'NO\n']","In the first sample you should shift the following lines one position to the right: the 3-rd, the 6-th, the 7-th and the 8-th.

In the second sample there is no way you can achieve the goal.",OK,"ans = 'YES'

for _ in range(8):
    line = input()
    
    for i in range(7):
        if line[i] == line[i+1]:
            ans = 'NO'
            break

print(ans) ","def min_time_to_form_line_up(soldiers):
    """"""Calculates the minimum time needed to form a line-up that the general will consider correct.

    Args:
        soldiers: A list of integers representing the heights of the soldiers.

    Returns:
        The minimum time needed to form a line-up that the general will consider correct.
    """"""
    n = len(soldiers)
    
    # Find the maximum height and the last index of the minimum height
    max_height = max(soldiers)
    min_height = min(soldiers)
    
    # Get the index of the first occurrence of the maximum height
    max_index = soldiers.index(max_height)
    
    # Get the index of the last occurrence of the minimum height
    min_index = n - 1 - soldiers[::-1].index(min_height)
    
    # Calculate the number of swaps needed to move the max height to the front
    swaps = max_index
    
    # Add swaps needed to move the min height to the back
    swaps += (n - 1 - min_index)
    
    # If the max index is before the min index, no adjustment needed
    if max_index > min_index:
        swaps -= 1  # Adjust for the overlap
    
    return swaps"
1003,A,Polycarp's Pockets,PROGRAMMING,['implementation'],"Polycarp has $n$ coins, the value of the $i$-th coin is $a_i$. Polycarp wants to distribute all the coins between his pockets, but he cannot put two coins with the same value into the same pocket.

For example, if Polycarp has got six coins represented as an array $a = [1, 2, 4, 3, 3, 2]$, he can distribute the coins into two pockets as follows: $[1, 2, 3], [2, 3, 4]$.

Polycarp wants to distribute all the coins with the minimum number of used pockets. Help him to do that.","The first line of the input contains one integer $n$ ($1 \le n \le 100$) — the number of coins.

The second line of the input contains $n$ integers $a_1, a_2, \dots, a_n$ ($1 \le a_i \le 100$) — values of coins.",Print only one integer — the minimum number of pockets Polycarp needs to distribute all the coins so no two coins with the same value are put into the same pocket.,"['6\n1 2 4 3 3 2\n', '1\n100\n']","['2\n', '1\n']",none,WRONG_ANSWER,"n = int(input())
a = list(map(int, input().split()))
dp = [a.count(i + 1) for i in range(n)]
print(max(dp))","import sys
import math
from itertools import accumulate

input = sys.stdin.readline

def main():
    # Read input values
    n, t1, t2, k = map(int, input().split())
    results = []

    for i in range(1, n + 1):
        # Read speeds for each participant
        a, b = map(int, input().split())
        
        # Calculate growth for both strategies
        # Strategy 1: use a first, then b
        height1 = a * t1 * (1 - k / 100) + b * t2
        # Strategy 2: use b first, then a
        height2 = b * t1 * (1 - k / 100) + a * t2
        
        # Take the maximum height
        max_height = max(height1, height2)
        
        # Store the result with participant number and height
        results.append((i, max_height))
    
    # Sort results by height first, then by participant number
    results.sort(key=lambda x: (-x[1], x[0]))
    
    # Print the results
    for participant, height in results:
        print(f""{participant} {height:.2f}"")

if __name__ == ""__main__"":
    main()"
334,A,Candy Bags,PROGRAMMING,['implementation'],"Gerald has *n* younger brothers and their number happens to be even. One day he bought *n*2 candy bags. One bag has one candy, one bag has two candies, one bag has three candies and so on. In fact, for each integer *k* from 1 to *n*2 he has exactly one bag with *k* candies. 

Help him give *n* bags of candies to each brother so that all brothers got the same number of candies.","The single line contains a single integer *n* (*n* is even, 2<=≤<=*n*<=≤<=100) — the number of Gerald's brothers.","Let's assume that Gerald indexes his brothers with numbers from 1 to *n*. You need to print *n* lines, on the *i*-th line print *n* integers — the numbers of candies in the bags for the *i*-th brother. Naturally, all these numbers should be distinct and be within limits from 1 to *n*2. You can print the numbers in the lines in any order. 

It is guaranteed that the solution exists at the given limits.",['2\n'],['1 4\n2 3\n'],"The sample shows Gerald's actions if he has two brothers. In this case, his bags contain 1, 2, 3 and 4 candies. He can give the bags with 1 and 4 candies to one brother and the bags with 2 and 3 to the other brother.",OK,"import math

n = int(input())
bags = int(math.pow(n,2))
#candies = math.factorial(bags)

n_bags = []

for j in range (n):
	n_bags.append("""")
	for i in range(int(n/2)):
		n_bags[j] += str((i*n)+j+1)
		n_bags[j] += "" ""
		n_bags[j] += str(bags-(j+(i*n)))
		n_bags[j] += "" ""
		#n_bags[j].append((i*n)+j+1)
		#n_bags[j].append(bags-(j+(i*n)))

	print (n_bags[j])

	




","def process_word(word):
    # Проверяем, соответствует ли слово условиям ошибочно набранного слова
    if word[0].islower():
        # Проверяем, что все остальные буквы заглавные
        if word[1:].isupper():
            return word.swapcase()  # меняем регистр всех букв
    elif word.isupper():
        return word.swapcase()  # меняем регистр всех букв
    return word  # если условия не выполнены, возвращаем слово без изменений

# Чтение слова из ввода и вывод обработанного слова
input_word = input().strip()
output_word = process_word(input_word)
print(output_word)"
225,A,Dice Tower,PROGRAMMING,"['constructive algorithms', 'greedy']","A dice is a cube, its faces contain distinct integers from 1 to 6 as black points. The sum of numbers at the opposite dice faces always equals 7. Please note that there are only two dice (these dices are mirror of each other) that satisfy the given constraints (both of them are shown on the picture on the left).

Alice and Bob play dice. Alice has built a tower from *n* dice. We know that in this tower the adjacent dice contact with faces with distinct numbers. Bob wants to uniquely identify the numbers written on the faces of all dice, from which the tower is built. Unfortunately, Bob is looking at the tower from the face, and so he does not see all the numbers on the faces. Bob sees the number on the top of the tower and the numbers on the two adjacent sides (on the right side of the picture shown what Bob sees).

Help Bob, tell whether it is possible to uniquely identify the numbers on the faces of all the dice in the tower, or not.","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=100) — the number of dice in the tower.

The second line contains an integer *x* (1<=≤<=*x*<=≤<=6) — the number Bob sees at the top of the tower. Next *n* lines contain two space-separated integers each: the *i*-th line contains numbers *a**i*,<=*b**i* (1<=≤<=*a**i*,<=*b**i*<=≤<=6; *a**i*<=≠<=*b**i*) — the numbers Bob sees on the two sidelong faces of the *i*-th dice in the tower.

Consider the dice in the tower indexed from top to bottom from 1 to *n*. That is, the topmost dice has index 1 (the dice whose top face Bob can see). It is guaranteed that it is possible to make a dice tower that will look as described in the input.","Print ""YES"" (without the quotes), if it is possible to to uniquely identify the numbers on the faces of all the dice in the tower. If it is impossible, print ""NO"" (without the quotes).","['3\n6\n3 2\n5 4\n2 4\n', '3\n3\n2 6\n4 1\n5 3\n']","['YES', 'NO']",none,WRONG_ANSWER,"n = int(input())
x = int(input())

prev_faces = [7 - x]  # Initialize the previous top face as the opposite of x

for _ in range(n):
    a, b = map(int, input().split())
    
    if a == prev_faces[-1] or b == prev_faces[-1] or a + b == 7:
        print(""NO"")
        break
    
    prev_faces.append(b)

else:
    print(""YES"")","# LUOGU_RID: 126095734
n, k = map(int, input().split())
x = 0

def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

def valid_set(s):
    for i in range(4):
        for j in range(i + 1, 4):
            if gcd(s[i], s[j]) != k:
                return False
    return True

# Calculate minimum m based on k
m = 4 * n  # Start with the assumption that we need at least 4n numbers
used = set()

result = []
for i in range(n):
    # Create a new valid set of rank k
    current_set = [(k * (j + 1)) + (i * 4) for j in range(4)]
    result.append(current_set)
    used.update(current_set)

print(m)
for s in result:
    print(' '.join(map(str, s)))"
508,A,Pasha and Pixels,PROGRAMMING,['brute force'],"Pasha loves his phone and also putting his hair up... But the hair is now irrelevant.

Pasha has installed a new game to his phone. The goal of the game is following. There is a rectangular field consisting of *n* row with *m* pixels in each row. Initially, all the pixels are colored white. In one move, Pasha can choose any pixel and color it black. In particular, he can choose the pixel that is already black, then after the boy's move the pixel does not change, that is, it remains black. Pasha loses the game when a 2<=×<=2 square consisting of black pixels is formed. 

Pasha has made a plan of *k* moves, according to which he will paint pixels. Each turn in his plan is represented as a pair of numbers *i* and *j*, denoting respectively the row and the column of the pixel to be colored on the current move.

Determine whether Pasha loses if he acts in accordance with his plan, and if he does, on what move the 2<=×<=2 square consisting of black pixels is formed.","The first line of the input contains three integers *n*,<=*m*,<=*k* (1<=≤<=*n*,<=*m*<=≤<=1000, 1<=≤<=*k*<=≤<=105) — the number of rows, the number of columns and the number of moves that Pasha is going to perform. 

The next *k* lines contain Pasha's moves in the order he makes them. Each line contains two integers *i* and *j* (1<=≤<=*i*<=≤<=*n*, 1<=≤<=*j*<=≤<=*m*), representing the row number and column number of the pixel that was painted during a move.","If Pasha loses, print the number of the move when the 2<=×<=2 square consisting of black pixels is formed.

If Pasha doesn't lose, that is, no 2<=×<=2 square consisting of black pixels is formed during the given *k* moves, print 0.","['2 2 4\n1 1\n1 2\n2 1\n2 2\n', '2 3 6\n2 3\n2 2\n1 3\n2 2\n1 2\n1 1\n', '5 3 7\n2 3\n1 2\n1 1\n4 1\n3 1\n5 3\n3 2\n']","['4\n', '5\n', '0\n']",none,RUNTIME_ERROR,"from collections import defaultdict


di = [(0, 1), (1, 0), (1, 1), (0, 0)]
n, m, k = map(int, input().split())
plan = defaultdict(lambda: float('inf'))
for i in range(k):
    plan[tuple(map(int, input().split()))] = min(plan[tuple(map(int, input().split()))], i)
for x, y in plan.keys():
    if all((x + dx, y + dy) in plan.keys() for dx, dy in di):
        print(max(plan[(x + dx, y + dy)] for dx, dy in di) + 1)
        break
else:
    print(0)
","def maximize_subsegment(n, k, a):
    max_length = 0
    left = 0  # Left pointer of the sliding window
    zero_count = 0  # Count of zeros in the current window

    for right in range(n):
        if a[right] == 0:
            zero_count += 1
        
        # If we have more than k zeros, shrink the window from the left
        while zero_count > k:
            if a[left] == 0:
                zero_count -= 1
            left += 1
        
        # Update the maximum length of the subsegment
        max_length = max(max_length, right - left + 1)
    
    # Create the resulting array after changes
    result_a = a[:]
    changes = k  # Number of changes left
    for i in range(left, left + max_length):
        if result_a[i] == 0 and changes > 0:
            result_a[i] = 1
            changes -= 1
    
    print(max_length)
    print("" "".join(map(str, result_a)))"
899,A,Splitting in Teams,PROGRAMMING,"['constructive algorithms', 'greedy', 'math']","There were *n* groups of students which came to write a training contest. A group is either one person who can write the contest with anyone else, or two people who want to write the contest in the same team.

The coach decided to form teams of exactly three people for this training. Determine the maximum number of teams of three people he can form. It is possible that he can't use all groups to form teams. For groups of two, either both students should write the contest, or both should not. If two students from a group of two will write the contest, they should be in the same team.","The first line contains single integer *n* (2<=≤<=*n*<=≤<=2·105) — the number of groups.

The second line contains a sequence of integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=2), where *a**i* is the number of people in group *i*.",Print the maximum number of teams of three people the coach can form.,"['4\n1 1 2 1\n', '2\n2 2\n', '7\n2 2 2 1 1 1 1\n', '3\n1 1 1\n']","['1\n', '0\n', '3\n', '1\n']","In the first example the coach can form one team. For example, he can take students from the first, second and fourth groups.

In the second example he can't make a single team.

In the third example the coach can form three teams. For example, he can do this in the following way:
 -  The first group (of two people) and the seventh group (of one person), -  The second group (of two people) and the sixth group (of one person), -  The third group (of two people) and the fourth group (of one person).",OK,"n = int(input())
l = list(map(int,input().split()))
k = l.count(1)
h = l.count(2)
if k>h:
	print(h+(k-h)//3)
else:
	print(k)","from collections import defaultdict

def main():
    n = int(input())
    skills = list(map(int, input().split()))
    
    # Lists to store indices of children based on their skills
    programmers = []
    mathematicians = []
    sportsmen = []
    
    # Classifying children based on their skills
    for index, skill in enumerate(skills):
        if skill == 1:
            programmers.append(index + 1)  # Store 1-based index
        elif skill == 2:
            mathematicians.append(index + 1)  # Store 1-based index
        elif skill == 3:
            sportsmen.append(index + 1)  # Store 1-based index
    
    # Calculate the maximum number of teams
    w = min(len(programmers), len(mathematicians), len(sportsmen))
    print(w)
    
    # Output the teams
    for i in range(w):
        print(programmers[i], mathematicians[i], sportsmen[i])

if __name__ == ""__main__"":
    main()"
5,B,Center Alignment,PROGRAMMING,"['implementation', 'strings']","Almost every text editor has a built-in function of center text alignment. The developers of the popular in Berland text editor «Textpad» decided to introduce this functionality into the fourth release of the product.

You are to implement the alignment in the shortest possible time. Good luck!","The input file consists of one or more lines, each of the lines contains Latin letters, digits and/or spaces. The lines cannot start or end with a space. It is guaranteed that at least one of the lines has positive length. The length of each line and the total amount of the lines do not exceed 1000.","Format the given text, aligning it center. Frame the whole text with characters «*» of the minimum size. If a line cannot be aligned perfectly (for example, the line has even length, while the width of the block is uneven), you should place such lines rounding down the distance to the left or to the right edge and bringing them closer left or right alternatively (you should start with bringing left). Study the sample tests carefully to understand the output format better.","['This  is\n\nCodeforces\nBeta\nRound\n5\n', 'welcome to the\nCodeforces\nBeta\nRound 5\n\nand\ngood luck\n']","['************\n* This  is *\n*          *\n*Codeforces*\n*   Beta   *\n*  Round   *\n*     5    *\n************\n', '****************\n*welcome to the*\n*  Codeforces  *\n*     Beta     *\n*   Round 5    *\n*              *\n*      and     *\n*  good luck   *\n****************\n']",none,WRONG_ANSWER,"import fileinput
m = []
l = []
for line in fileinput.input():
    m.append(line[:-1])
    l.append(len(line) - 1)
r = max(l)
print('*' * (r + 2))
for i in range(0, len(m) - 1):
    s1 = ' ' *  ((r - l[i]) // 2)
    s2 = ' ' *  (r - len(s1) - l[i])
    print('*' + s1 + m[i] + s2 + '*')
print('*' * (r + 2))","class solution:
    def __init__(self):
        self.str = """"
    
    def doing(self):
        if len(self.str) < 2:
            return 0
        elif len(self.str) == 2 and self.str[0] == 'V' and self.str[1] == 'K':
            return 1
        
        # Count initial occurrences of ""VK""
        count = 0
        for i in range(len(self.str) - 1):
            if self.str[i] == 'V' and self.str[i + 1] == 'K':
                count += 1
        
        # Check possible changes
        max_count = count
        
        for i in range(len(self.str)):
            original = self.str[i]
            # Try changing V to K
            if original == 'V':
                new_str = self.str[:i] + 'K' + self.str[i + 1:]
                new_count = self.count_vk(new_str)
                max_count = max(max_count, new_count)
            # Try changing K to V
            else:
                new_str = self.str[:i] + 'V' + self.str[i + 1:]
                new_count = self.count_vk(new_str)
                max_count = max(max_count, new_count)
        
        return max_count
    
    def count_vk(self, string):
        count = 0
        for i in range(len(string) - 1):
            if string[i] == 'V' and string[i + 1] == 'K':
                count += 1
        return count"
753,A,Santa Claus and Candies,PROGRAMMING,"['dp', 'greedy', 'math']","Santa Claus has *n* candies, he dreams to give them as gifts to children.

What is the maximal number of children for whose he can give candies if Santa Claus want each kid should get distinct positive integer number of candies. Santa Class wants to give all *n* candies he has.",The only line contains positive integer number *n* (1<=≤<=*n*<=≤<=1000) — number of candies Santa Claus has.,"Print to the first line integer number *k* — maximal number of kids which can get candies.

Print to the second line *k* distinct integer numbers: number of candies for each of *k* kid. The sum of *k* printed numbers should be exactly *n*.

If there are many solutions, print any of them.","['5\n', '9\n', '2\n']","['2\n2 3\n', '3\n3 5 1\n', '1\n2 \n']",none,WRONG_ANSWER,"# -*- coding=utf-8 -*-

if __name__ == ""__main__"":
    N = int(input())
    
    if N == 2:
        print(1)
        print(2)
        exit()
    
    counter = 2
    dp = [2]
    dp_set = set([2])
    has_finish = False
    for n in range(N - 2):
        if n == 0:
            dp.append(1)
            counter += 1
        else:
            while N > counter:
                has_finish = False
                for s in range(len(dp)):
                    dp[s] += 1
                    counter += 1
                    if counter == N:
                        has_finish = True
                        break
                
                if not has_finish:
                    dp.append(1)
                    counter+= 1
                    
                if has_finish:
                    break
            
            if has_finish:
                break
    print(len(dp))
    print(*dp)","import sys

sys.stdin = open(""input.txt"", ""r"")
sys.stdout = open(""output.txt"", ""w"")

def main():
    n = int(sys.stdin.readline().strip())
    a = list(map(int, sys.stdin.readline().strip().split()))
    
    # Dictionary to store positions of each number
    positions = {}
    
    # Store the indices of each number in the positions dictionary
    for idx, number in enumerate(a):
        if number in positions:
            positions[number].append(idx + 1)  # Store 1-based index
        else:
            positions[number] = [idx + 1]
    
    # Prepare to store the result pairs
    pairs = []
    
    # Check if any number has an odd occurrence
    for num, pos in positions.items():
        if len(pos) % 2 != 0:
            print(-1)
            return
        # Pair the indices
        for i in range(0, len(pos), 2):
            pairs.append((pos[i], pos[i + 1]))
    
    # Output the pairs
    for pair in pairs:
        print(pair[0], pair[1])

if __name__ == ""__main__"":
    main()"
981,A,Antipalindrome,PROGRAMMING,"['brute force', 'implementation', 'strings']","A string is a palindrome if it reads the same from the left to the right and from the right to the left. For example, the strings ""kek"", ""abacaba"", ""r"" and ""papicipap"" are palindromes, while the strings ""abb"" and ""iq"" are not.

A substring $s[l \ldots r]$ ($1<=\leq<=l<=\leq<=r<=\leq<=|s|$) of a string $s<==<=s_{1}s_{2} \ldots s_{|s|}$ is the string $s_{l}s_{l<=+<=1} \ldots s_{r}$.

Anna does not like palindromes, so she makes her friends call her Ann. She also changes all the words she reads in a similar way. Namely, each word $s$ is changed into its longest substring that is not a palindrome. If all the substrings of $s$ are palindromes, she skips the word at all.

Some time ago Ann read the word $s$. What is the word she changed it into?","The first line contains a non-empty string $s$ with length at most $50$ characters, containing lowercase English letters only.","If there is such a substring in $s$ that is not a palindrome, print the maximum length of such a substring. Otherwise print $0$.

Note that there can be multiple longest substrings that are not palindromes, but their length is unique.","['mew\n', 'wuffuw\n', 'qqqqqqqq\n']","['3\n', '5\n', '0\n']","""mew"" is not a palindrome, so the longest substring of it that is not a palindrome, is the string ""mew"" itself. Thus, the answer for the first example is $3$.

The string ""uffuw"" is one of the longest non-palindrome substrings (of length $5$) of the string ""wuffuw"", so the answer for the second example is $5$.

All substrings of the string ""qqqqqqqq"" consist of equal characters so they are palindromes. This way, there are no non-palindrome substrings. Thus, the answer for the third example is $0$.",OK,"word = input()

if word == word[::-1]:
    for i in range(len(word)):
        slicedWord = word[i + 1:]
        if slicedWord != slicedWord[::-1]:
            print(len(word) - i - 1)
            break
        if len(slicedWord) == 0:
            print(0)
            break
else:
    print(len(word))","'''
Author     : knight_byte
File       : A_Patrick_and_Shopping.py
Created on : 2021-04-19 14:15:35
'''

# Read input values for distances
d1, d2, d3 = map(int, input().split())

# Calculate the minimum distance to visit both shops and return home
# The possible routes Patrick can take:
# 1. Go to shop 1, then to shop 2, and return home (2 * d1 + 2 * d2)
# 2. Go to shop 2, then to shop 1, and return home (2 * d2 + 2 * d1)
# 3. Go to shop 1, use the road between shops, go to shop 2, and return home (d1 + d3 + d2 + d1)
# 4. Go to shop 2, use the road between shops, go to shop 1, and return home (d2 + d3 + d1 + d2)
# 5. Go to shop 1, go to shop 2, return to shop 1, and return home (d1 + d2 + d3 + d1)
# 6. Go to shop 2, go to shop 1, return to shop 2, and return home (d2 + d1 + d3 + d2)

min_distance = min(
    2 * (d1 + d2),        # Route 1
    2 * (d2 + d1),        # Route 2
    2 * (d1 + d2 + d3),   # Route 3
    2 * (d1 + d2 + d3),   # Route 4
    d1 + d2 + d3 + d1,    # Route 5
    d2 + d1 + d3 + d2     # Route 6
)

# Print the minimum distance
print(min_distance)"
0,none,none,none,['none'],"One day student Vasya was sitting on a lecture and mentioned a string *s*1*s*2... *s**n*, consisting of letters ""a"", ""b"" and ""c"" that was written on his desk. As the lecture was boring, Vasya decided to complete the picture by composing a graph *G* with the following properties: 
 -  *G* has exactly *n* vertices, numbered from 1 to *n*. -  For all pairs of vertices *i* and *j*, where *i*<=≠<=*j*, there is an edge connecting them if and only if characters *s**i* and *s**j* are either equal or neighbouring in the alphabet. That is, letters in pairs ""a""-""b"" and ""b""-""c"" are neighbouring, while letters ""a""-""c"" are not. 
Vasya painted the resulting graph near the string and then erased the string. Next day Vasya's friend Petya came to a lecture and found some graph at his desk. He had heard of Vasya's adventure and now he wants to find out whether it could be the original graph *G*, painted by Vasya. In order to verify this, Petya needs to know whether there exists a string *s*, such that if Vasya used this *s* he would produce the given graph *G*.","The first line of the input contains two integers *n* and *m*  — the number of vertices and edges in the graph found by Petya, respectively.

Each of the next *m* lines contains two integers *u**i* and *v**i* (1<=≤<=*u**i*,<=*v**i*<=≤<=*n*,<=*u**i*<=≠<=*v**i*) — the edges of the graph *G*. It is guaranteed, that there are no multiple edges, that is any pair of vertexes appear in this list no more than once.","In the first line print ""Yes"" (without the quotes), if the string *s* Petya is interested in really exists and ""No"" (without the quotes) otherwise.

If the string *s* exists, then print it on the second line of the output. The length of *s* must be exactly *n*, it must consist of only letters ""a"", ""b"" and ""c"" only, and the graph built using this string must coincide with *G*. If there are multiple possible answers, you may print any of them.","['2 1\n1 2\n', '4 3\n1 2\n1 3\n1 4\n']","['Yes\naa\n', 'No\n']","In the first sample you are given a graph made of two vertices with an edge between them. So, these vertices can correspond to both the same and adjacent letters. Any of the following strings ""aa"", ""ab"", ""ba"", ""bb"", ""bc"", ""cb"", ""cc"" meets the graph's conditions. 

In the second sample the first vertex is connected to all three other vertices, but these three vertices are not connected with each other. That means that they must correspond to distinct letters that are not adjacent, but that is impossible as there are only two such letters: a and c.",WRONG_ANSWER,"from collections import defaultdict,deque,Counter,OrderedDict

def main():
    n,m = map(int,input().split())
    adj = [[] for i in range(n+1)]

    for i in range(m):
        a,b = map(int,input().split())
        adj[a].append(b)
        adj[b].append(a)
    ans = [""d""]*(n+1)
    visited = [0] * (n + 1)
    for i in range(1,n+1):
        if len(adj[i]) == n-1:
            visited[i] = 1
            ans[i] = ""b""
    st = ans.index(""d"")
    def dfs(st,ck):
        if visited[st]: return
        visited[st] = 1
        ans[st] = ck
        for i in adj[st]:
            dfs(i,ck)

    dfs(st,""a"")
    if ""d"" in ans:
        st = ans.index(""d"")
        dfs(st,""c"")
    if ""d"" in ans:
        print(""No"")
    else:
        print(""Yes"")
        print("""".join(ans[1:]))

if __name__ == ""__main__"":
    main()","def can_watch_all_shows(n, shows):
    events = []
    
    # Create a list of events for each show's start and end time
    for l, r in shows:
        events.append((l, 1))   # Start of a show
        events.append((r, -1))  # End of a show

    # Sort events, first by time, then by type (-1 end before 1 start)
    events.sort(key=lambda x: (x[0], x[1]))

    current_shows = 0
    max_concurrent_shows = 0

    # Process all events
    for time, typ in events:
        current_shows += typ  # Update the number of ongoing shows
        max_concurrent_shows = max(max_concurrent_shows, current_shows)

    # Check if the maximum concurrent shows at any time exceed 2
    return ""YES"" if max_concurrent_shows <= 2 else ""NO""

# Input reading
n = int(input())
shows = [tuple(map(int, input().split())) for _ in range(n)]

# Output the result
print(can_watch_all_shows(n, shows))"
766,B,Mahmoud and a Triangle,PROGRAMMING,"['constructive algorithms', 'geometry', 'greedy', 'math', 'number theory', 'sortings']","Mahmoud has *n* line segments, the *i*-th of them has length *a**i*. Ehab challenged him to use exactly 3 line segments to form a non-degenerate triangle. Mahmoud doesn't accept challenges unless he is sure he can win, so he asked you to tell him if he should accept the challenge. Given the lengths of the line segments, check if he can choose exactly 3 of them to form a non-degenerate triangle.

Mahmoud should use exactly 3 line segments, he can't concatenate two line segments or change any length. A non-degenerate triangle is a triangle with positive area.","The first line contains single integer *n* (3<=≤<=*n*<=≤<=105) — the number of line segments Mahmoud has.

The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=109) — the lengths of line segments Mahmoud has.","In the only line print ""YES"" if he can choose exactly three line segments and form a non-degenerate triangle with them, and ""NO"" otherwise.","['5\n1 5 3 2 4\n', '3\n4 1 2\n']","['YES\n', 'NO\n']","For the first example, he can use line segments with lengths 2, 4 and 5 to form a non-degenerate triangle.",WRONG_ANSWER,"""""""
B. Mahmoud and a Triangle: constructive algorithms, geometry, greedy, math, number theory, sortings

time limit per test: 2 seconds
memory limit per test: 256 megabytes
input: standard input
output: standard output

Mahmoud has n line segments, the i-th of them has length ai.
Ehab challenged him to use exactly 3 line segments to form a non-degenerate triangle.
Mahmoud doesn't accept challenges unless he is sure he can win, so he asked you to tell him if he should accept the challenge.
Given the lengths of the line segments, check if he can choose exactly 3 of them to form a non-degenerate triangle.
Mahmoud should use exactly 3 line segments, he can't concatenate two line segments or change any length.
A non-degenerate triangle is a triangle with positive area.

Input
The first line contains single integer n (3 ≤ n ≤ 10^5) — the number of line segments Mahmoud has.
The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 10^9) — the lengths of line segments Mahmoud has.

Output
In the only line print ""YES"" if he can choose exactly three line segments and form a non-degenerate triangle with them, and ""NO"" otherwise.
""""""

def mahmoud_and_a_triangle():
    n = int(input())
    a = list(map(int, input().split(' ')))

    a.sort()
    # print(sum(a[-3:-1]))
    # print(a.index(n - 1))

    print('YES' if sum(a[-3:-1]) > max(a) else 'NO')
        # print()
    # for i in a[-3:-1]:
    #     print(i)

if __name__ == '__main__':
    mahmoud_and_a_triangle()","x=input().split()
x=[int(p) for p in x]
r,g,b=x[0],x[1],x[2]

def f1(r, g, b):
    no1 = 0
    while(r != 0 and g != 0 and b != 0):
        # Create a mixing bouquet
        r -= 1
        g -= 1
        b -= 1
        no1 += 1
    return no1

def f2(r, g, b):
    # Count the number of single color bouquets
    no2 = (r // 3) + (g // 3) + (b // 3)
    return no2

# Calculate mixing bouquets and single color bouquets
mixing_bouquets = f1(r, g, b)
single_color_bouquets = f2(r, g, b)

# Total bouquets
total_bouquets = mixing_bouquets + single_color_bouquets
print(total_bouquets)"
219,A,k-String,PROGRAMMING,"['implementation', 'strings']","A string is called a *k*-string if it can be represented as *k* concatenated copies of some string. For example, the string ""aabaabaabaab"" is at the same time a 1-string, a 2-string and a 4-string, but it is not a 3-string, a 5-string, or a 6-string and so on. Obviously any string is a 1-string.

You are given a string *s*, consisting of lowercase English letters and a positive integer *k*. Your task is to reorder the letters in the string *s* in such a way that the resulting string is a *k*-string.","The first input line contains integer *k* (1<=≤<=*k*<=≤<=1000). The second line contains *s*, all characters in *s* are lowercase English letters. The string length *s* satisfies the inequality 1<=≤<=|*s*|<=≤<=1000, where |*s*| is the length of string *s*.","Rearrange the letters in string *s* in such a way that the result is a *k*-string. Print the result on a single output line. If there are multiple solutions, print any of them.

If the solution doesn't exist, print ""-1"" (without quotes).","['2\naazz\n', '3\nabcabcabz\n']","['azaz\n', '-1\n']",none,WRONG_ANSWER,"n = int(input())
s=input()
ofc=sorted(s)
pack=ofc[::n]*n
if(ofc==sorted(pack)):
    print(''.join(pack))
else:
    print('-1')
print(pack)","import sys
def get_array(): return list(map(int, sys.stdin.readline().split()))
def get_ints(): return map(int, sys.stdin.readline().split())
def input(): return sys.stdin.readline().strip('\n')

s = input()

hr = int(s[0:2])  # Extract hours
mn = int(s[3:5])  # Extract minutes
a = int(input())   # Read the number of minutes to add

# Calculate total minutes from the current time and the additional minutes
total_minutes = hr * 60 + mn + a

# Calculate new hours and minutes
new_hr = (total_minutes // 60) % 24  # Wrap around using modulo 24
new_mn = total_minutes % 60           # Get the remaining minutes

# Print the result in hh:mm format with leading zeros
print(f""{new_hr:02}:{new_mn:02}"")"
818,E,Card Game Again,PROGRAMMING,"['binary search', 'data structures', 'number theory', 'two pointers']","Vova again tries to play some computer card game.

The rules of deck creation in this game are simple. Vova is given an existing deck of *n* cards and a magic number *k*. The order of the cards in the deck is fixed. Each card has a number written on it; number *a**i* is written on the *i*-th card in the deck.

After receiving the deck and the magic number, Vova removes *x* (possibly *x*<==<=0) cards from the top of the deck, *y* (possibly *y*<==<=0) cards from the bottom of the deck, and the rest of the deck is his new deck (Vova has to leave at least one card in the deck after removing cards). So Vova's new deck actually contains cards *x*<=+<=1, *x*<=+<=2, ... *n*<=-<=*y*<=-<=1, *n*<=-<=*y* from the original deck.

Vova's new deck is considered valid iff the product of all numbers written on the cards in his new deck is divisible by *k*. So Vova received a deck (possibly not a valid one) and a number *k*, and now he wonders, how many ways are there to choose *x* and *y* so the deck he will get after removing *x* cards from the top and *y* cards from the bottom is valid?","The first line contains two integers *n* and *k* (1<=≤<=*n*<=≤<=100<=000, 1<=≤<=*k*<=≤<=109).

The second line contains *n* integers *a*1, *a*2, ..., *a**n* (1<=≤<=*a**i*<=≤<=109) — the numbers written on the cards.",Print the number of ways to choose *x* and *y* so the resulting deck is valid.,"['3 4\n6 2 8\n', '3 6\n9 1 14\n']","['4\n', '1\n']","In the first example the possible values of *x* and *y* are:
 1.  *x* = 0, *y* = 0; 1.  *x* = 1, *y* = 0; 1.  *x* = 2, *y* = 0; 1.  *x* = 0, *y* = 1.",WRONG_ANSWER,"count=0
def is_valid(l,k):
  pro=1
  for i in l:
    pro=pro*i
  if(pro%k==0):
    return 1
  else:
    return 0
def e_card(l,k):
  global count
  
  if(is_valid(l,k)):
    count+=1
  if(len(l)==1):
    return
  else:
    m=l[len(l)-1]
    l.pop()
    e_card(l,k)
    l.append(m)
    m=l[0]
    l.pop(0)
    e_card(l,k)
    l.insert(0,m)
n,k=[int(x) for x in input().strip().split()]
e_card([int(x) for x in input().strip().split()],k)
print(count)","from collections import Counter

recipe = input()
b, s, c = map(int, input().split())
onhand = {""B"": b, ""S"": s, ""C"": c}
pb, ps, pc = map(int, input().split())
price = {""B"": pb, ""S"": ps, ""C"": pc}
rubles = int(input())

# Count the required ingredients from the recipe
needed = Counter(recipe)

# Function to determine if it's possible to make `mid` hamburgers
def can_make(mid):
    total_b = max(0, mid * needed['B'] - onhand['B'])
    total_s = max(0, mid * needed['S'] - onhand['S'])
    total_c = max(0, mid * needed['C'] - onhand['C'])
    
    total_cost = total_b * price['B'] + total_s * price['S'] + total_c * price['C']
    
    return total_cost <= rubles

# Binary search for the maximum number of hamburgers
left, right = 0, 10**13  # Start with a large upper limit
while left < right:
    mid = (left + right + 1) // 2
    if can_make(mid):
        left = mid  # We can make `mid` hamburgers, try for more
    else:
        right = mid - 1  # We can't make `mid`, try less

print(left)"
831,A,Unimodal Array,PROGRAMMING,['implementation'],"Array of integers is unimodal, if:
 -  it is strictly increasing in the beginning; -  after that it is constant; -  after that it is strictly decreasing. 
The first block (increasing) and the last block (decreasing) may be absent. It is allowed that both of this blocks are absent.

For example, the following three arrays are unimodal: [5,<=7,<=11,<=11,<=2,<=1], [4,<=4,<=2], [7], but the following three are not unimodal: [5,<=5,<=6,<=6,<=1], [1,<=2,<=1,<=2], [4,<=5,<=5,<=6].

Write a program that checks if an array is unimodal.","The first line contains integer *n* (1<=≤<=*n*<=≤<=100) — the number of elements in the array.

The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=1<=000) — the elements of the array.","Print ""YES"" if the given array is unimodal. Otherwise, print ""NO"".

You can output each letter in any case (upper or lower).","['6\n1 5 5 5 4 2\n', '5\n10 20 30 20 10\n', '4\n1 2 1 2\n', '7\n3 3 3 3 3 3 3\n']","['YES\n', 'YES\n', 'NO\n', 'YES\n']","In the first example the array is unimodal, because it is strictly increasing in the beginning (from position 1 to position 2, inclusively), that it is constant (from position 2 to position 4, inclusively) and then it is strictly decreasing (from position 4 to position 6, inclusively).",WRONG_ANSWER,"n=int(input())
a=list(map(int,input().split()))
i=0
while i<n and a[i]>a[i-1]:
        i=i+1
while i<n and a[i]==a[i-1]:
        i=i+1
while i<n and a[i]<a[i-1]:
        i=i+1
if i==n:
        print(""YES"")
else:
        print(""NO"")
","def digits(i):
    l = []
    str_num = str(i)
    for j in range(len(str_num)):
        l.append(int(str_num[j]))
    return sum(l)

def find_x(n):
    results = []
    # Start checking from max(1, n - 9 * len(str(n))) to n
    # The subtraction accounts for the maximum possible digit sum
    for x in range(max(1, n - 81), n + 1):
        if x + digits(x) == n:
            results.append(x)
    
    # Output the number of suitable x values
    print(len(results))
    # Output each valid x in ascending order
    for val in results:
        print(val)

# Input
n = int(input())
find_x(n)"
443,A,Anton and Letters,PROGRAMMING,"['constructive algorithms', 'implementation']","Recently, Anton has found a set. The set consists of small English letters. Anton carefully wrote out all the letters from the set in one line, separated by a comma. He also added an opening curved bracket at the beginning of the line and a closing curved bracket at the end of the line. 

Unfortunately, from time to time Anton would forget writing some letter and write it again. He asks you to count the total number of distinct letters in his set.","The first and the single line contains the set of letters. The length of the line doesn't exceed 1000. It is guaranteed that the line starts from an opening curved bracket and ends with a closing curved bracket. Between them, small English letters are listed, separated by a comma. Each comma is followed by a space.",Print a single number — the number of distinct letters in Anton's set.,"['{a, b, c}\n', '{b, a, b, a}\n', '{}\n']","['3\n', '2\n', '0\n']",none,OK,"s = input()

if len(s) == 2:
    print(0)
else:
    print(len(set(s[1:-1].split(', '))))
","import collections

def apSum(elements):
    n = len(elements)
    a = elements[0]
    d = elements[1] - elements[0]
    progressionSum = int( (n/2) * ((2*a) + (n-1)*d))
    return progressionSum

def generate_hungry_sequence(n):
    # We create a Hungry sequence by using evenly spaced numbers
    # Ensure no number is divisible by a previous number
    sequence = []
    for i in range(1, n + 1):
        # Each number in the sequence can be generated by taking a base number
        # and adding 'i' to it. This guarantees a non-divisible relationship.
        sequence.append(i * 10 + 1)  # Using an offset to avoid divisibility
    return sequence

# Read input
n = int(input())
hungry_sequence = generate_hungry_sequence(n)

# Output result
print("" "".join(map(str, hungry_sequence)))"
807,A,Is it rated?,PROGRAMMING,"['implementation', 'sortings']","Is it rated?

Here it is. The Ultimate Question of Competitive Programming, Codeforces, and Everything. And you are here to answer it.

Another Codeforces round has been conducted. No two participants have the same number of points. For each participant, from the top to the bottom of the standings, their rating before and after the round is known.

It's known that if at least one participant's rating has changed, then the round was rated for sure.

It's also known that if the round was rated and a participant with lower rating took a better place in the standings than a participant with higher rating, then at least one round participant's rating has changed.

In this problem, you should not make any other assumptions about the rating system.

Determine if the current round is rated, unrated, or it's impossible to determine whether it is rated of not.","The first line contains a single integer *n* (2<=≤<=*n*<=≤<=1000) — the number of round participants.

Each of the next *n* lines contains two integers *a**i* and *b**i* (1<=≤<=*a**i*,<=*b**i*<=≤<=4126) — the rating of the *i*-th participant before and after the round, respectively. The participants are listed in order from the top to the bottom of the standings.","If the round is rated for sure, print ""rated"". If the round is unrated for sure, print ""unrated"". If it's impossible to determine whether the round is rated or not, print ""maybe"".","['6\n3060 3060\n2194 2194\n2876 2903\n2624 2624\n3007 2991\n2884 2884\n', '4\n1500 1500\n1300 1300\n1200 1200\n1400 1400\n', '5\n3123 3123\n2777 2777\n2246 2246\n2246 2246\n1699 1699\n']","['rated\n', 'unrated\n', 'maybe\n']","In the first example, the ratings of the participants in the third and fifth places have changed, therefore, the round was rated.

In the second example, no one's rating has changed, but the participant in the second place has lower rating than the participant in the fourth place. Therefore, if the round was rated, someone's rating would've changed for sure.

In the third example, no one's rating has changed, and the participants took places in non-increasing order of their rating. Therefore, it's impossible to determine whether the round is rated or not.",WRONG_ANSWER,"def main():
    number_of_participant=int(input())
    flag=0
    participant=[]
    for i in range(number_of_participant):
        ranking=input()
        ranking=ranking.split()
        if ranking[0]!=ranking[1]:
            flag=1
            
        participant.append(int(ranking[0]))
    if flag==1:
        print(""rated"")
    else:
        if sorted(participant)==participant:
            print(""maybe"")
        else:
            print(""unrated"")
if __name__==""__main__"":
    main()","# LUOGU_RID: 113633863

# Read the number of computers and participants
n, k = map(int, input().split())

# Read the data transfer speeds of the computers
speeds = list(map(int, input().split()))

# The maximum speed we can give to k participants
# Since speeds are sorted, the highest speed for k participants will
# be the speed of the k-th from the end
max_speed = speeds[n - k]

# Print the result
print(max_speed)"
127,A,Wasted Time,PROGRAMMING,['geometry'],"Mr. Scrooge, a very busy man, decided to count the time he wastes on all sorts of useless stuff to evaluate the lost profit. He has already counted the time he wastes sleeping and eating. And now Mr. Scrooge wants to count the time he has wasted signing papers.

Mr. Scrooge's signature can be represented as a polyline *A*1*A*2... *A**n*. Scrooge signs like that: first it places a pen at the point *A*1, then draws a segment from point *A*1 to point *A*2, then he draws a segment from point *A*2 to point *A*3 and so on to point *A**n*, where he stops signing and takes the pen off the paper. At that the resulting line can intersect with itself and partially repeat itself but Scrooge pays no attention to it and never changes his signing style. As Scrooge makes the signature, he never takes the pen off the paper and his writing speed is constant — 50 millimeters per second.

Scrooge signed exactly *k* papers throughout his life and all those signatures look the same.

Find the total time Scrooge wasted signing the papers.","The first line contains two integers *n* and *k* (2<=≤<=*n*<=≤<=100, 1<=≤<=*k*<=≤<=1000). Each of the following *n* lines contains the coordinates of the polyline's endpoints. The *i*-th one contains coordinates of the point *A**i* — integers *x**i* and *y**i*, separated by a space.

All points *A**i* are different. The absolute value of all coordinates does not exceed 20. The coordinates are measured in millimeters.",Print one real number — the total time Scrooges wastes on signing the papers in seconds. The absolute or relative error should not exceed 10<=-<=6.,"['2 1\n0 0\n10 0\n', '5 10\n3 1\n-5 6\n-2 -1\n3 2\n10 0\n', '6 10\n5 0\n4 0\n6 0\n3 0\n7 0\n2 0\n']","['0.200000000', '6.032163204', '3.000000000']",none,WRONG_ANSWER,"import math
n, k = map(int, input().split())
posx, posy, res = 0, 0, 0
for u in range(n):
    x, y = map(int, input().split())
    res += math.sqrt(abs(posx - x) ** 2 + abs(posy - y) ** 2)
    posx, posy = x, y
print(res * k)","n, a, b = map(int, input().split())
x = 0
y = 0

def solution():
    global x, y
    while x * a + y * b < n:
        if x * a + y * b + a <= n:
            x += 1
        elif x * a + y * b + b <= n:
            y += 1
        else:
            return -1

    result = []
    for i in range(x):
        result.extend(range(1, a + 1))
    for j in range(y):
        result.extend(range(1, b + 1))

    if len(result) != n:
        return -1
    
    return result[:n]

permutation = solution()
if permutation == -1:
    print(-1)
else:
    print(*permutation)"
32,A,Reconnaissance,PROGRAMMING,['brute force'],"According to the regulations of Berland's army, a reconnaissance unit should consist of exactly two soldiers. Since these two soldiers shouldn't differ much, their heights can differ by at most *d* centimeters. Captain Bob has *n* soldiers in his detachment. Their heights are *a*1,<=*a*2,<=...,<=*a**n* centimeters. Some soldiers are of the same height. Bob wants to know, how many ways exist to form a reconnaissance unit of two soldiers from his detachment.

Ways (1,<=2) and (2,<=1) should be regarded as different.","The first line contains two integers *n* and *d* (1<=≤<=*n*<=≤<=1000,<=1<=≤<=*d*<=≤<=109) — amount of soldiers in Bob's detachment and the maximum allowed height difference respectively. The second line contains *n* space-separated integers — heights of all the soldiers in Bob's detachment. These numbers don't exceed 109.","Output one number — amount of ways to form a reconnaissance unit of two soldiers, whose height difference doesn't exceed *d*.","['5 10\n10 20 50 60 65\n', '5 1\n55 30 29 31 55\n']","['6\n', '6\n']",none,WRONG_ANSWER,"s=[]
o=0
n,d=input("""").split()
n=int(n)
d=int(d)
r=input("""")
e= r.split()
for x in e:
    x=int(x)
    s.append(x)    
for z in range(0,len(s)):
    for g in range(0,len(s)):
        if z != g :
            if abs (s[z] - s[g]) <= d :
                print(s[z],s[g])
                o+=1
if n== len(s):
    print(o)","from bisect import bisect_right

def bs(s, x):
    return bisect_right(s, x)

n, q = map(int, input().split())
a = list(map(int, input().split()))
k = list(map(int, input().split()))

# To store the cumulative strength of the warriors
cumulative_strength = [0] * n
cumulative_strength[0] = a[0]

# Creating cumulative strengths of warriors for binary search
for i in range(1, n):
    cumulative_strength[i] = cumulative_strength[i - 1] + a[i]

results = []
for arrows in k:
    # Find the index of the last warrior that can withstand the given number of arrows
    idx = bs(cumulative_strength, arrows) - 1
    # The number of standing warriors is the total minus the fallen ones
    standing_warriors = n - (idx + 1) 
    results.append(standing_warriors)

print('\n'.join(map(str, results)))"
831,A,Unimodal Array,PROGRAMMING,['implementation'],"Array of integers is unimodal, if:
 -  it is strictly increasing in the beginning; -  after that it is constant; -  after that it is strictly decreasing. 
The first block (increasing) and the last block (decreasing) may be absent. It is allowed that both of this blocks are absent.

For example, the following three arrays are unimodal: [5,<=7,<=11,<=11,<=2,<=1], [4,<=4,<=2], [7], but the following three are not unimodal: [5,<=5,<=6,<=6,<=1], [1,<=2,<=1,<=2], [4,<=5,<=5,<=6].

Write a program that checks if an array is unimodal.","The first line contains integer *n* (1<=≤<=*n*<=≤<=100) — the number of elements in the array.

The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=1<=000) — the elements of the array.","Print ""YES"" if the given array is unimodal. Otherwise, print ""NO"".

You can output each letter in any case (upper or lower).","['6\n1 5 5 5 4 2\n', '5\n10 20 30 20 10\n', '4\n1 2 1 2\n', '7\n3 3 3 3 3 3 3\n']","['YES\n', 'YES\n', 'NO\n', 'YES\n']","In the first example the array is unimodal, because it is strictly increasing in the beginning (from position 1 to position 2, inclusively), that it is constant (from position 2 to position 4, inclusively) and then it is strictly decreasing (from position 4 to position 6, inclusively).",OK,"# -*- coding: utf-8 -*-
""""""831.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hYxPSks58iBj6lqO-ZFgsg_7bcRbm3l3
""""""

#https://codeforces.com/contest/831/problem/A  Unimodal Array

a=int(input())
b=list(map(int,input().split()))
i=1
while i<a and b[i-1]<b[i]:
  i+=1
while i<a and b[i-1]==b[i]:
  i+=1
while i<a and b[i-1]>b[i]:
  i+=1
if i==a:
  print(""Yes"")
else:
  print(""No"")","# -*- coding: utf - 8 -*-
""""""
    author: mr.math - Hakimov Rahimjon
    e-mail: [email protected] or [email protected]
    created: 26.01.2018 20:39
""""""
# inp = open(""input.txt"", ""r"")
# input = inp.readline

# Read input for the four parts of the intersection
lights = [list(map(int, input().split())) for _ in range(4)]

# Check for possible accidents
for i in range(4):
    l, s, r, p = lights[i]  # lights of the current part
    if p:  # if pedestrian light is green
        # Check if cars from this part can hit pedestrians
        if l or s or r:  # if any lane is green
            print(""YES"")
            exit()

        # Check adjacent parts
        prev_part = lights[(i - 1) % 4]  # previous part in counter-clockwise
        next_part = lights[(i + 1) % 4]  # next part in counter-clockwise

        if (prev_part[2] and p) or (next_part[0] and p):  # right turn from previous or left turn from next
            print(""YES"")
            exit()

print(""NO"")"
262,A,Roma and Lucky Numbers,PROGRAMMING,['implementation'],"Roma (a popular Russian name that means 'Roman') loves the Little Lvov Elephant's lucky numbers.

Let us remind you that lucky numbers are positive integers whose decimal representation only contains lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.

Roma's got *n* positive integers. He wonders, how many of those integers have not more than *k* lucky digits? Help him, write the program that solves the problem.","The first line contains two integers *n*, *k* (1<=≤<=*n*,<=*k*<=≤<=100). The second line contains *n* integers *a**i* (1<=≤<=*a**i*<=≤<=109) — the numbers that Roma has. 

The numbers in the lines are separated by single spaces.",In a single line print a single integer — the answer to the problem.,"['3 4\n1 2 4\n', '3 2\n447 44 77\n']","['3\n', '2\n']","In the first sample all numbers contain at most four lucky digits, so the answer is 3.

In the second sample number 447 doesn't fit in, as it contains more than two lucky digits. All other numbers are fine, so the answer is 2.",OK,"[n, k] = [int(x) for x in input().split()]
L = [x for x in input().split()]
c = 0
for i in L:
    if i.count('4') + i.count('7') <= k: c += 1
print(c)
","from sys import stdin, stdout 
input = stdin.readline
from collections import defaultdict 

def print(*args, end='\n', sep=' ') -> None:
    stdout.write(sep.join(map(str, args)) + end)

def main():
    # Read the user's name
    my_name = input().strip()
    
    # Read the number of actions
    n = int(input().strip())
    
    # Initialize a dictionary to store priority factors
    priority = defaultdict(int)

    # Define the points for each action type
    points = {
        ""posted on"": 15,
        ""commented on"": 10,
        ""likes"": 5
    }

    # Process each action
    for _ in range(n):
        action = input().strip()
        # Split the action to extract the names and action type
        parts = action.split()
        X = parts[0]
        Y = parts[2]
        action_type = ' '.join(parts[1:3])  # ""posted on"", ""commented on"", or ""likes""

        # Update the priority factor if either X or Y is my_name
        if X != my_name:
            if Y != my_name:
                # Both are friends, add points to both
                priority[X] += points[action_type]
                priority[Y] += points[action_type]
            else:
                # Y is my name, add points to X only
                priority[X] += points[action_type]
        else:
            # X is my name, add points to Y only
            priority[Y] += points[action_type]

    # Prepare result list (excluding my_name)
    result = [(name, score) for name, score in priority.items() if name != my_name]

    # Sort the result by priority factor (desc) and name (asc)
    result.sort(key=lambda x: (-x[1], x[0]))

    # Print the sorted names
    for name, _ in result:
        print(name)

if __name__ == ""__main__"":
    main()"
427,A,Police Recruits,PROGRAMMING,['implementation'],"The police department of your city has just started its journey. Initially, they don’t have any manpower. So, they started hiring new recruits in groups.

Meanwhile, crimes keeps occurring within the city. One member of the police force can investigate only one crime during his/her lifetime.

If there is no police officer free (isn't busy with crime) during the occurrence of a crime, it will go untreated.

Given the chronological order of crime occurrences and recruit hirings, find the number of crimes which will go untreated.","The first line of input will contain an integer *n* (1<=≤<=*n*<=≤<=105), the number of events. The next line will contain *n* space-separated integers.

If the integer is -1 then it means a crime has occurred. Otherwise, the integer will be positive, the number of officers recruited together at that time. No more than 10 officers will be recruited at a time.","Print a single integer, the number of crimes which will go untreated.","['3\n-1 -1 1\n', '8\n1 -1 1 -1 -1 1 1 1\n', '11\n-1 -1 2 -1 -1 -1 -1 -1 -1 -1 -1\n']","['2\n', '1\n', '8\n']","Lets consider the second example:
 1.  Firstly one person is hired. 1.  Then crime appears, the last hired person will investigate this crime. 1.  One more person is hired. 1.  One more crime appears, the last hired person will investigate this crime. 1.  Crime appears. There is no free policeman at the time, so this crime will go untreated. 1.  One more person is hired. 1.  One more person is hired. 1.  One more person is hired. 
The answer is one, as one crime (on step 5) will go untreated.",OK,"n = int(input())
li = list(map(int, input().split()))

c = 0
k = 0

for i in range(n):
  if li[i] == -1 and c < 1:
    k += 1
  else:
    c += li[i]

print(k)

""""""
4
abacaba
acaba
abacaba
acab


""""""","def gcd(a, b):
    if a % b == 0:
        return b
    return gcd(b, a % b)

def can_break_shield(a, b, c):
    # Calculate the greatest common divisor of a and b
    g = gcd(a, b)
    # Check if c is a multiple of the gcd
    if c % g == 0:
        return ""Yes""
    else:
        return ""No""

# Read integers a, b, c from input
a, b, c = map(int, input().split())
# Print the result
print(can_break_shield(a, b, c))"
801,A,Vicious Keyboard,PROGRAMMING,['brute force'],"Tonio has a keyboard with only two letters, ""V"" and ""K"".

One day, he has typed out a string *s* with only these two letters. He really likes it when the string ""VK"" appears, so he wishes to change at most one letter in the string (or do no changes) to maximize the number of occurrences of that string. Compute the maximum number of times ""VK"" can appear as a substring (i. e. a letter ""K"" right after a letter ""V"") in the resulting string.","The first line will contain a string *s* consisting only of uppercase English letters ""V"" and ""K"" with length not less than 1 and not greater than 100.","Output a single integer, the maximum number of times ""VK"" can appear as a substring of the given string after changing at most one character.","['VK\n', 'VV\n', 'V\n', 'VKKKKKKKKKVVVVVVVVVK\n', 'KVKV\n']","['1\n', '1\n', '0\n', '3\n', '1\n']","For the first case, we do not change any letters. ""VK"" appears once, which is the maximum number of times it could appear.

For the second case, we can change the second character from a ""V"" to a ""K"". This will give us the string ""VK"". This has one occurrence of the string ""VK"" as a substring.

For the fourth case, we can change the fourth character from a ""K"" to a ""V"". This will give us the string ""VKKVKKKKKKVVVVVVVVVK"". This has three occurrences of the string ""VK"" as a substring. We can check no other moves can give us strictly more occurrences.",OK,"l=input()
s=[]
for i in l:
	if(i=='V'):
		s.append(1)
	else:
		s.append(0)
ls=len(s)
i=0
maxc = 0
c = 0
while i+1<ls:
	if(s[i]==1 and s[i+1]==0):
		c+=1
	i+=1
maxc = max(maxc,c)
j=0
while j<ls:
	if(s[j]==1):
		s[j]=0
	else:
		s[j]=1
	i=0
	c=0
	while i+1<ls:
		if(s[i]==1 and s[i+1]==0):
			c+=1
		i+=1
	maxc=max(c,maxc)
	if(s[j]==1):
		s[j]=0
	else:
		s[j]=1
	j+=1
print(maxc)","mp = {0: 1, 1: 1}
vec = []


def getLen(n):
    if n == 0 or n == 1:
        return 1
    m = n // 2
    # Caching the lengths of segments
    if m not in mp:
        mp[m] = getLen(m)
    return 2 * mp[m] + 1  # Length includes left and right segments plus the middle 1


def getCount1s(n, left, right):
    # Base case for recursion
    if n == 0:
        return 0  # No 1s if the number is 0
    if n == 1:
        return right - left + 1  # All positions are filled with 1s

    current_len = getLen(n)
    half_len = getLen(n // 2)  # Get length of the left half
    mid_start = half_len + 1  # Middle position for '1'

    count = 0
    # Check if there is an overlap with the left segment
    if right >= 1:
        count += getCount1s(n // 2, left, min(right, half_len))
    # Check if middle '1' is in the range
    if left <= mid_start <= right:
        count += 1
    # Check if there is an overlap with the right segment
    if right >= mid_start + 1:
        count += getCount1s(n // 2, max(1, left - mid_start), right - mid_start)

    return count


n, l, r = map(int, input().split())
result = getCount1s(n, l, r)
print(result)"
2,B,The least round way,PROGRAMMING,"['dp', 'math']","There is a square matrix *n*<=×<=*n*, consisting of non-negative integer numbers. You should find such a way on it that 
 -  starts in the upper left cell of the matrix; -  each following cell is to the right or down from the current cell; -  the way ends in the bottom right cell. 
Moreover, if we multiply together all the numbers along the way, the result should be the least ""round"". In other words, it should end in the least possible number of zeros.","The first line contains an integer number *n* (2<=≤<=*n*<=≤<=1000), *n* is the size of the matrix. Then follow *n* lines containing the matrix elements (non-negative integer numbers not exceeding 109).",In the first line print the least number of trailing zeros. In the second line print the correspondent way itself.,['3\n1 2 3\n4 5 6\n7 8 9\n'],['0\nDDRR\n'],none,WRONG_ANSWER,"ls=[]
n=int(input())
for _ in range(n):
    a=input().split()
    a=[int(x) for x in a]
    ls.append(a)
dp=[[0 for x in range(n)] for y in range(n)]
way=[['' for x in range(n)] for y in range(n)]
dp[0][0]=1
for i in range(1,n):
    dp[0][i]=dp[0][i-1]+ls[0][i]
    way[0][i]=way[0][i-1]+'R'
for i in range(1,n):
    dp[i][0]=dp[i-1][0]+ls[i][0]
    way[i][0]=way[i-1][0]+'D'
for i in range(1,n):
    for j in range(1,n):
        if dp[i-1][j]<dp[i][j-1]:
            dp[i][j]=dp[i-1][j]+ls[i][j]
            way[i][j]=way[i-1][j]+'D'
        else:
            dp[i][j]=dp[i][j-1]+ls[i][j]
            way[i][j]=way[i][j-1]+'R'
print(way[n-1][n-1])
","n = int(input())
A = list(map(int, input().split()))

# Initialize an array for b values
B = [0] * n

# Calculate the b values based on the given a values
for i in range(n):
    B[i] = A[i]
    # If we're not at the first index, we need to adjust b values
    if i > 0:
        B[i] += B[i - 1]

# Print the result
print(*B)"
384,A,Coder,PROGRAMMING,['implementation'],"Iahub likes chess very much. He even invented a new chess piece named Coder. A Coder can move (and attack) one square horizontally or vertically. More precisely, if the Coder is located at position (*x*,<=*y*), he can move to (or attack) positions (*x*<=+<=1,<=*y*), (*x*–1,<=*y*), (*x*,<=*y*<=+<=1) and (*x*,<=*y*–1).

Iahub wants to know how many Coders can be placed on an *n*<=×<=*n* chessboard, so that no Coder attacks any other Coder.",The first line contains an integer *n* (1<=≤<=*n*<=≤<=1000).,"On the first line print an integer, the maximum number of Coders that can be placed on the chessboard.

On each of the next *n* lines print *n* characters, describing the configuration of the Coders. For an empty cell print an '.', and for a Coder print a 'C'.

If there are multiple correct answers, you can print any.",['2\n'],['2\nC.\n.C\n'],none,WRONG_ANSWER,"n = int(input())
field = [list(""."" * n) for i in range(n)]
for i in range(0,n,2):
    for j in range(0,n,2):
        field[i][j] = ""C""
for i in range(1,n,2):
    for j in range(1,n,2):
        field[i][j] = ""C""
for i in range(n):
    print("""".join(field[i]))
","n = int(input())
book = {}

for _ in range(n):
    toks = input().strip().split()
    name = toks[0]
    count = int(toks[1])
    numbers = toks[2:2 + count]
    
    if name not in book:
        book[name] = set()
    
    book[name].update(numbers)

# Remove suffix numbers
for name in book:
    numbers = sorted(book[name])  # Sort to handle suffix removal
    unique_numbers = []
    
    for number in numbers:
        if all(not number.endswith(uni_num) for uni_num in unique_numbers):
            unique_numbers.append(number)
    
    book[name] = unique_numbers

# Print the result
print(len(book))
for name, numbers in book.items():
    print(name, len(numbers), ' '.join(numbers))"
637,B,Chat Order,PROGRAMMING,"['*special', 'binary search', 'constructive algorithms', 'data structures', 'sortings']","Polycarp is a big lover of killing time in social networks. A page with a chatlist in his favourite network is made so that when a message is sent to some friend, his friend's chat rises to the very top of the page. The relative order of the other chats doesn't change. If there was no chat with this friend before, then a new chat is simply inserted to the top of the list.

Assuming that the chat list is initially empty, given the sequence of Polycaprus' messages make a list of chats after all of his messages are processed. Assume that no friend wrote any message to Polycarpus.",The first line contains integer *n* (1<=≤<=*n*<=≤<=200<=000) — the number of Polycarpus' messages. Next *n* lines enlist the message recipients in the order in which the messages were sent. The name of each participant is a non-empty sequence of lowercase English letters of length at most 10.,"Print all the recipients to who Polycarp talked to in the order of chats with them, from top to bottom.","['4\nalex\nivan\nroman\nivan\n', '8\nalina\nmaria\nekaterina\ndarya\ndarya\nekaterina\nmaria\nalina\n']","['ivan\nroman\nalex\n', 'alina\nmaria\nekaterina\ndarya\n']","In the first test case Polycarpus first writes to friend by name ""alex"", and the list looks as follows: 
 1.  alex 
Then Polycarpus writes to friend by name ""ivan"" and the list looks as follows:
 1.  ivan 1.  alex 
Polycarpus writes the third message to friend by name ""roman"" and the list looks as follows:
 1.  roman 1.  ivan 1.  alex 
Polycarpus writes the fourth message to friend by name ""ivan"", to who he has already sent a message, so the list of chats changes as follows:
 1.  ivan 1.  roman 1.  alex",OK,"n = int(input())
v = []
for i in range(n):
  name = input()
  v.append(name)
# v contains all names in the initial order
# now we have to process the list in reverse order
s = set() # should use set() for set
for i in range(n-1, -1, -1): # start from the last index, dec by 1, stop at -1
  name = v[i]
  if name not in s:
    print(name)
    s.add(name)

  ","import math


def main() -> None:
    n = int(input().strip())  # Read input value for n
    count = 0  # Initialize count of right-angled triangles

    # Iterate over possible side lengths a, b, and c
    for a in range(1, n + 1):
        for b in range(a, n + 1):
            c_squared = a * a + b * b  # Calculate the square of the hypotenuse
            c = int(math.isqrt(c_squared))  # Get the integer square root of c_squared
            
            # Check if c is a valid hypotenuse length and satisfies the conditions
            if c * c == c_squared and b <= c <= n:
                count += 1  # Increment count if the triangle is valid

    print(count)  # Output the total count of right-angled triangles"
104,A,Blackjack,PROGRAMMING,['implementation'],"One rainy gloomy evening when all modules hid in the nearby cafes to drink hot energetic cocktails, the Hexadecimal virus decided to fly over the Mainframe to look for a Great Idea. And she has found one!

Why not make her own Codeforces, with blackjack and other really cool stuff? Many people will surely be willing to visit this splendid shrine of high culture.

In Mainframe a standard pack of 52 cards is used to play blackjack. The pack contains cards of 13 values: 2, 3, 4, 5, 6, 7, 8, 9, 10, jacks, queens, kings and aces. Each value also exists in one of four suits: hearts, diamonds, clubs and spades. Also, each card earns some value in points assigned to it: cards with value from two to ten earn from 2 to 10 points, correspondingly. An ace can either earn 1 or 11, whatever the player wishes. The picture cards (king, queen and jack) earn 10 points. The number of points a card earns does not depend on the suit. The rules of the game are very simple. The player gets two cards, if the sum of points of those cards equals *n*, then the player wins, otherwise the player loses.

The player has already got the first card, it's the queen of spades. To evaluate chances for victory, you should determine how many ways there are to get the second card so that the sum of points exactly equals *n*.",The only line contains *n* (1<=≤<=*n*<=≤<=25) — the required sum of points.,Print the numbers of ways to get the second card in the required way if the first card is the queen of spades.,"['12\n', '20\n', '10\n']","['4', '15', '0']","In the first sample only four two's of different suits can earn the required sum of points.

In the second sample we can use all tens, jacks, queens and kings; overall it's 15 cards, as the queen of spades (as any other card) is only present once in the pack of cards and it's already in use.

In the third sample there is no card, that would add a zero to the current ten points.",WRONG_ANSWER,"from collections import defaultdict as dd
hp = dd(lambda:4)

hp[0] = 4
hp[10] = 15
hp[11] = 8

n = int(input())
x = n - 10
if x > 11:
    print(0)
else:
    print(hp[x]) ","from math import sqrt, pi

n, px, py = [int(x) for x in input().split()]

def dist(x, y):
    return sqrt((px - x)**2 + (py - y)**2)

# Read the polygon vertices
vertices = [tuple(int(x) for x in input().split()) for _ in range(n)]

# Calculate the area of the polygon using the shoelace formula
def polygon_area(verts):
    area = 0
    for i in range(len(verts)):
        x1, y1 = verts[i]
        x2, y2 = verts[(i + 1) % len(verts)]
        area += x1 * y2 - x2 * y1
    return abs(area) / 2

# Calculate the area of the polygon
area_polygon = polygon_area(vertices)

# Calculate the average distance from point P to the vertices of the polygon
avg_dist = sum(dist vx for vx, vy in vertices) / n

# Area cleared of snow is the area of the polygon + area of the circle 
cleared_area = area_polygon + pi * (avg_dist ** 2)

# Print the result with required precision
print(f""{cleared_area:.6f}"")"
914,F,Substrings in a String,PROGRAMMING,"['bitmasks', 'brute force', 'data structures', 'string suffix structures', 'strings']","Given a string *s*, process *q* queries, each having one of the following forms:
 -  1<=*i*<=*c* — Change the *i*-th character in the string to *c*. -  2<=*l*<=*r*<=*y* — Consider the substring of *s* starting at position *l* and ending at position *r*. Output the number of times *y* occurs as a substring in it.","The first line of the input contains the string *s* (1<=≤<=|*s*|<=≤<=105) of lowercase English letters.

The second line contains an integer *q* (1<=≤<=*q*<=≤<=105)  — the number of queries to process.

The next *q* lines describe the queries and may have one of the following forms:
 -  1<=*i*<=*c* (1<=≤<=*i*<=≤<=|*s*|) -  2<=*l*<=*r*<=*y* (1<=≤<=*l*<=≤<=*r*<=≤<=|*s*|) 
*c* is a lowercase English letter and *y* is a non-empty string consisting of only lowercase English letters.

The sum of |*y*| over all queries of second type is at most 105.

It is guaranteed that there is at least one query of second type.

All strings are 1-indexed.

|*s*| is the length of the string *s*.","For each query of type 2, output the required answer in a separate line.","['ababababa\n3\n2 1 7 aba\n1 5 c\n2 1 7 aba\n', 'abcdcbc\n5\n2 1 7 bc\n1 4 b\n2 4 7 bc\n1 2 a\n2 1 4 aa\n']","['3\n1\n', '2\n2\n1\n']","Consider the first sample case. Initially, the string aba occurs 3 times in the range [1, 7]. Note that two occurrences may overlap. 

After the update, the string becomes ababcbaba and now aba occurs only once in the range [1, 7].",WRONG_ANSWER,"# -*- coding: utf-8 -*-

#I at first check what type of query is given. after that replace method is to replace the character at given index.
# on the otherhand, to findout the number of substring in the range, i wrote the substring method
#the return value of substring method was saved into a list and later printed.
#Time complexity = O(n^4) . reason : the substring method has a time complexity of O(n^3). It is inside of a loop (input loop) of O(n). Thus O(N^4)

def replace(x,a,p):
    x[a-1]=p
    return x

def substring(x,m,n,k):
    count=0
    i=m-1
    k=list(k)
    while (i+len(k)-1<n):
        while((x[i]!=k[0]) and (i+len(k)-1<n) ):
            i=i+1
        if((x[i]==k[0]) and (i+len(k)-1<n)):
            flag=True
            for m in range(len(k)):
                if x[i]==k[m]:
                    i+=1
                else:
                    flag=False
                    i+=1
                    break
            if flag is True:
                count+=1
        while n>m:
            if(x[n-1] != k[len(k)-1]):
                n-=1
            else:
                break
            
            
    return count
    

str=input()
numberOfQuery=int(input())
str=list(str)



for i in range(numberOfQuery):
    query=input()
    query=query.split("" "")
    if(len(query) == 3):
        str=replace(str,int(query[1]),query[2])
    elif(len(query) == 4):
        print(substring(str,int(query[1]),int(query[2]),query[3]))
","def equivalent(s1, s2):
    # If the strings are exactly the same, they are equivalent
    if s1 == s2:
        return True
    
    # If the lengths of the strings are odd, they cannot be split into two equal halves
    if len(s1) % 2 == 1:
        return False
    
    # Find the midpoint of the strings
    mid = len(s1) // 2
    
    # Split the strings into two halves
    a1, a2 = s1[:mid], s1[mid:]
    b1, b2 = s2[:mid], s2[mid:]
    
    # Check for the two conditions of equivalency
    return (equivalent(a1, b1) and equivalent(a2, b2)) or (equivalent(a1, b2) and equivalent(a2, b1))

# Read input strings
s1 = input().strip()
s2 = input().strip()

# Determine equivalency and output result
if equivalent(s1, s2):
    print(""YES"")
else:
    print(""NO"")"
912,B,New Year's Eve,PROGRAMMING,"['bitmasks', 'constructive algorithms', 'number theory']","Since Grisha behaved well last year, at New Year's Eve he was visited by Ded Moroz who brought an enormous bag of gifts with him! The bag contains *n* sweet candies from the good ol' bakery, each labeled from 1 to *n* corresponding to its tastiness. No two candies have the same tastiness.

The choice of candies has a direct effect on Grisha's happiness. One can assume that he should take the tastiest ones — but no, the holiday magic turns things upside down. It is the xor-sum of tastinesses that matters, not the ordinary sum!

A xor-sum of a sequence of integers *a*1,<=*a*2,<=...,<=*a**m* is defined as the bitwise XOR of all its elements: , here  denotes the bitwise XOR operation; more about bitwise XOR can be found [here.](https://en.wikipedia.org/wiki/Bitwise_operation#XOR)

Ded Moroz warned Grisha he has more houses to visit, so Grisha can take no more than *k* candies from the bag. Help Grisha determine the largest xor-sum (largest xor-sum means maximum happiness!) he can obtain.",The sole string contains two integers *n* and *k* (1<=≤<=*k*<=≤<=*n*<=≤<=1018).,Output one number — the largest possible xor-sum.,"['4 3\n', '6 6\n']","['7\n', '7\n']","In the first sample case, one optimal answer is 1, 2 and 4, giving the xor-sum of 7.

In the second sample case, one can, for example, take all six candies and obtain the xor-sum of 7.",WRONG_ANSWER,"[n, k] = [int(i) for i in input().split()]
remaining = k
number = 2**65 
res = 0
while remaining > 0 and number > 0:
  if number <= n:
    res += number
    remaining -= 1
  number = number // 2
print(res)
","def max_bitwise_or_sum(n, a, b):
    # Function to calculate f(x, l, r)
    def f(array, l, r):
        result = 0
        for i in range(l - 1, r):
            result |= array[i]  # Bitwise OR operation
        return result
    
    max_sum = 0  # Initialize maximum sum
    
    # Iterate through all possible l and r values
    for l in range(1, n + 1):
        for r in range(l, n + 1):
            # Calculate the bitwise OR for both arrays
            or_a = f(a, l, r)
            or_b = f(b, l, r)
            max_sum = max(max_sum, or_a + or_b)  # Update maximum sum
    
    return max_sum

# Input reading
n = int(input())
a = list(map(int, input().split()))
b = list(map(int, input().split()))

# Output the result
print(max_bitwise_or_sum(n, a, b))"
479,A,Expression,PROGRAMMING,"['brute force', 'math']","Petya studies in a school and he adores Maths. His class has been studying arithmetic expressions. On the last class the teacher wrote three positive integers *a*, *b*, *c* on the blackboard. The task was to insert signs of operations '+' and '*', and probably brackets between the numbers so that the value of the resulting expression is as large as possible. Let's consider an example: assume that the teacher wrote numbers 1, 2 and 3 on the blackboard. Here are some ways of placing signs and brackets:
 -  1+2*3=7 -  1*(2+3)=5 -  1*2*3=6 -  (1+2)*3=9 
Note that you can insert operation signs only between *a* and *b*, and between *b* and *c*, that is, you cannot swap integers. For instance, in the given sample you cannot get expression (1+3)*2.

It's easy to see that the maximum value that you can obtain is 9.

Your task is: given *a*, *b* and *c* print the maximum value that you can get.","The input contains three integers *a*, *b* and *c*, each on a single line (1<=≤<=*a*,<=*b*,<=*c*<=≤<=10).",Print the maximum value of the expression that you can obtain.,"['1\n2\n3\n', '2\n10\n3\n']","['9\n', '60\n']",none,RUNTIME_ERROR,"a,b,c=map(int,input().split())
if a==1 or b==1 or c==1:
    if a>=b and a>=c:
        print((b+c)*a)
    if b>a and b>c:
        print((a+c)*b)
    if c>a and c>b:
        print((a+b)*c)
else:
    print(a*b*c)","def time_to_arrange(children):
    seconds = 0
    children = list(children)

    while True:
        moved = False
        i = 0
        
        while i < len(children) - 1:
            # If there's a boy followed by a girl, swap them
            if children[i] == 'M' and children[i + 1] == 'F':
                children[i], children[i + 1] = children[i + 1], children[i]
                moved = True
                i += 1  # Skip the next index as we just swapped
            i += 1

        if not moved:
            break  # If no moves were made, we are done

        seconds += 1  # Increment the time after each complete pass

    return seconds


# Input reading
s = input().strip()
print(time_to_arrange(s))"
14,B,Young Photographer,PROGRAMMING,['implementation'],"Among other things, Bob is keen on photography. Especially he likes to take pictures of sportsmen. That was the reason why he placed himself in position *x*0 of a long straight racetrack and got ready to take pictures. But the problem was that not all the runners passed him. The total amount of sportsmen, training at that racetrack, equals *n*. And each of them regularly runs distances within a particular segment of the racetrack, which is the same for each sportsman. For example, the first sportsman runs from position *a*1 to position *b*1, the second — from *a*2 to *b*2

What is the minimum distance that Bob should move to have a chance to take pictures of each sportsman? Bob can take a picture of a sportsman, if he stands within the segment that this sportsman covers on the racetrack.","The first line of the input file contains integers *n* and *x*0 (1<=≤<=*n*<=≤<=100; 0<=≤<=*x*0<=≤<=1000). The following *n* lines contain pairs of integers *a**i*,<=*b**i* (0<=≤<=*a**i*,<=*b**i*<=≤<=1000; *a**i*<=≠<=*b**i*).","Output the required minimum distance in the same units as the positions on the racetrack. If there is no such a position, output -1.",['3 3\n0 7\n14 2\n4 6\n'],['1\n'],none,WRONG_ANSWER,"import sys
from fractions import Fraction

input = sys.stdin.readline

n, x = map(int, input().split())
p = 0

for _ in range(n):
    a, b = sorted(map(int, input().split()))
    k = range(a, b+1)
    if x not in k:
        p += abs(x-a)
print(p)","import decimal
from math import ceil, floor, inf, log

n = input()
if n == '1':
    print(1)
    exit()

# Calculate the number of digits in n
num_digits = len(n)

# The best m is usually around the number of digits in n
# Initialize the minimum cost to a large value
min_cost = inf

# Iterate over possible values of m
for m in range(1, num_digits + 1):
    # Calculate b_i to hold unique IDs
    b = ceil(n) / (10 ** (num_digits - m))
    
    # Calculate the cost for this configuration
    cost = b * m
    
    # Update minimum cost
    if cost < min_cost:
        min_cost = cost

# Print the minimal value of sum of b_i
print(int(min_cost))"
385,A,Bear and Raspberry,PROGRAMMING,"['brute force', 'greedy', 'implementation']","The bear decided to store some raspberry for the winter. He cunningly found out the price for a barrel of honey in kilos of raspberry for each of the following *n* days. According to the bear's data, on the *i*-th (1<=≤<=*i*<=≤<=*n*) day, the price for one barrel of honey is going to is *x**i* kilos of raspberry.

Unfortunately, the bear has neither a honey barrel, nor the raspberry. At the same time, the bear's got a friend who is ready to lend him a barrel of honey for exactly one day for *c* kilograms of raspberry. That's why the bear came up with a smart plan. He wants to choose some day *d* (1<=≤<=*d*<=&lt;<=*n*), lent a barrel of honey and immediately (on day *d*) sell it according to a daily exchange rate. The next day (*d*<=+<=1) the bear wants to buy a new barrel of honey according to a daily exchange rate (as he's got some raspberry left from selling the previous barrel) and immediately (on day *d*<=+<=1) give his friend the borrowed barrel of honey as well as *c* kilograms of raspberry for renting the barrel.

The bear wants to execute his plan at most once and then hibernate. What maximum number of kilograms of raspberry can he earn? Note that if at some point of the plan the bear runs out of the raspberry, then he won't execute such a plan.","The first line contains two space-separated integers, *n* and *c* (2<=≤<=*n*<=≤<=100,<=0<=≤<=*c*<=≤<=100), — the number of days and the number of kilos of raspberry that the bear should give for borrowing the barrel.

The second line contains *n* space-separated integers *x*1,<=*x*2,<=...,<=*x**n* (0<=≤<=*x**i*<=≤<=100), the price of a honey barrel on day *i*.",Print a single integer — the answer to the problem.,"['5 1\n5 10 7 3 20\n', '6 2\n100 1 10 40 10 40\n', '3 0\n1 2 3\n']","['3\n', '97\n', '0\n']","In the first sample the bear will lend a honey barrel at day 3 and then sell it for 7. Then the bear will buy a barrel for 3 and return it to the friend. So, the profit is (7 - 3 - 1) = 3.

In the second sample bear will lend a honey barrel at day 1 and then sell it for 100. Then the bear buy the barrel for 1 at the day 2. So, the profit is (100 - 1 - 2) = 97.",OK,"
s = input().rstrip().split(' ')
n, c = int (s[0]), int(s[1])

x = input().rstrip().split(' ')

max = int (x[0]) - int (x[1]) - c
for i in range (1, n - 1):
    if int (x[i]) - int (x[i + 1]) - c > max:
        max = int (x[i]) - int (x[i+1]) - c

if max < 0:
    max = 0

print (max)
","from itertools import permutations
from sys import stdin, stdout

def is_possible(n, x):
    num_sum = int(x)
    for i in x:
        num_sum += int(i)
    return num_sum == n

def find_x(n):
    results = []
    # Since we need to check for possible values of x
    # We can limit the range of x to n because x + sum of digits of x must equal to n
    for x in range(max(1, n - 100), n + 1):
        if is_possible(n, x):
            results.append(x)
    return results

def main():
    n = int(stdin.readline().strip())
    results = find_x(n)
    stdout.write(f""{len(results)}\n"")
    for x in sorted(results):
        stdout.write(f""{x}\n"")

if __name__ == ""__main__"":
    main()"
977,A,Wrong Subtraction,PROGRAMMING,['implementation'],"Little girl Tanya is learning how to decrease a number by one, but she does it wrong with a number consisting of two or more digits. Tanya subtracts one from a number by the following algorithm:
 -  if the last digit of the number is non-zero, she decreases the number by one; -  if the last digit of the number is zero, she divides the number by 10 (i.e. removes the last digit). 
You are given an integer number $n$. Tanya will subtract one from it $k$ times. Your task is to print the result after all $k$ subtractions.

It is guaranteed that the result will be positive integer number.","The first line of the input contains two integer numbers $n$ and $k$ ($2 \le n \le 10^9$, $1 \le k \le 50$) — the number from which Tanya will subtract and the number of subtractions correspondingly.","Print one integer number — the result of the decreasing $n$ by one $k$ times.

It is guaranteed that the result will be positive integer number.","['512 4\n', '1000000000 9\n']","['50\n', '1\n']",The first example corresponds to the following sequence: $512 \rightarrow 511 \rightarrow 510 \rightarrow 51 \rightarrow 50$.,OK,"a=str(input(""""))
b=0
f=-1
c=''
d=''
while a[f]!="" "":
    d=a[f]+d
    f=f-1
 
while a[b]!="" "" :
    c=c+a[b]
    b=b+1
e=int(c)
g=int(d)
for i in range(0,g):
    if e%10==0:
        e=e/10
    else:
        e=e-1
print(int(e))","x = input().strip()  # Read the first string
y = input().strip()  # Read the second string
dp = {}

def pE(xl, yl, l):
    if (xl, yl) in dp:
        return dp[(xl, yl)]
    
    if x[xl:xl+l] == y[yl:yl+l]:  # Check if the substrings are equal
        dp[(xl, yl)] = True
        return True
    
    if l % 2 == 1:  # If length is odd, they can't be equivalent
        dp[(xl, yl)] = False
        return False
    
    mid = l // 2  # Find the midpoint
    # Check if the two halves are equivalent
    result = (pE(xl, yl, mid) and pE(xl + mid, yl + mid, mid)) or \
             (pE(xl, yl + mid, mid) and pE(xl + mid, yl, mid))
    
    dp[(xl, yl)] = result
    return result

# Determine if the full strings are equivalent
if pE(0, 0, len(x)):
    print(""YES"")
else:
    print(""NO"")"
276,B,Little Girl and Game,PROGRAMMING,"['games', 'greedy']","The Little Girl loves problems on games very much. Here's one of them.

Two players have got a string *s*, consisting of lowercase English letters. They play a game that is described by the following rules:
 -  The players move in turns; In one move the player can remove an arbitrary letter from string *s*. -  If the player before his turn can reorder the letters in string *s* so as to get a palindrome, this player wins. A palindrome is a string that reads the same both ways (from left to right, and vice versa). For example, string ""abba"" is a palindrome and string ""abc"" isn't. 
Determine which player will win, provided that both sides play optimally well — the one who moves first or the one who moves second.","The input contains a single line, containing string *s* (1<=≤<=|*s*|<=<=≤<=<=103). String *s* consists of lowercase English letters.","In a single line print word ""First"" if the first player wins (provided that both players play optimally well). Otherwise, print word ""Second"". Print the words without the quotes.","['aba\n', 'abca\n']","['First\n', 'Second\n']",none,OK,"import sys 
input = sys.stdin.readline 
from collections import Counter , defaultdict
def instr():
    return input()[:-1]
import math 
############################
w = instr()
c = Counter(w)
f = sum(x%2 != 0 for x in c.values())
if f == 0 :
    print(""First"")
else :
    print(""First"" if f%2 != 0 else ""Second"")","def f(m):
    global n, k
    if 2 * (m * k + m) <= n:
        return True
    return False

def find_max_winners():
    global n, k
    max_diplomas = n // (k + 1)  # maximum diplomas that can be awarded
    diplomas = 0
    
    # Check for the maximum number of diplomas that satisfy the conditions
    for m in range(max_diplomas, -1, -1):
        if f(m):
            diplomas = m
            break
    
    certificates = diplomas * k
    winners = diplomas + certificates
    not_winners = n - winners
    return diplomas, certificates, not_winners

# Input processing
n, k = map(int, input().split())
result = find_max_winners()
print(result[0], result[1], result[2])"
998,B,Cutting,PROGRAMMING,"['dp', 'greedy', 'sortings']","There are a lot of things which could be cut — trees, paper, ""the rope"". In this problem you are going to cut a sequence of integers.

There is a sequence of integers, which contains the equal number of even and odd numbers. Given a limited budget, you need to make maximum possible number of cuts such that each resulting segment will have the same number of odd and even integers.

Cuts separate a sequence to continuous (contiguous) segments. You may think about each cut as a break between two adjacent elements in a sequence. So after cutting each element belongs to exactly one segment. Say, $[4, 1, 2, 3, 4, 5, 4, 4, 5, 5]$ $\to$ two cuts $\to$ $[4, 1 | 2, 3, 4, 5 | 4, 4, 5, 5]$. On each segment the number of even elements should be equal to the number of odd elements.

The cost of the cut between $x$ and $y$ numbers is $|x - y|$ bitcoins. Find the maximum possible number of cuts that can be made while spending no more than $B$ bitcoins.","First line of the input contains an integer $n$ ($2 \le n \le 100$) and an integer $B$ ($1 \le B \le 100$) — the number of elements in the sequence and the number of bitcoins you have.

Second line contains $n$ integers: $a_1$, $a_2$, ..., $a_n$ ($1 \le a_i \le 100$) — elements of the sequence, which contains the equal number of even and odd numbers",Print the maximum possible number of cuts which can be made while spending no more than $B$ bitcoins.,"['6 4\n1 2 5 10 15 20\n', '4 10\n1 3 2 4\n', '6 100\n1 2 3 4 5 6\n']","['1\n', '0\n', '2\n']","In the first sample the optimal answer is to split sequence between $2$ and $5$. Price of this cut is equal to $3$ bitcoins.

In the second sample it is not possible to make even one cut even with unlimited number of bitcoins.

In the third sample the sequence should be cut between $2$ and $3$, and between $4$ and $5$. The total price of the cuts is $1 + 1 = 2$ bitcoins.",RUNTIME_ERROR,"n, money= int(input()) #���������� ����� � ��������������������
#money = int(input())
print(n, money)","def maximize_number(n):
    s = str(n)

    if n > 0:
        return n  # No need to delete digits from a positive number

    # Case for negative numbers
    option1 = int(s[:-1])  # Remove the last digit
    option2 = int(s[:-2] + s[-1]) if len(s) > 2 else option1  # Remove the digit before the last

    # Return the maximum between the original number and the options
    return max(n, option1, option2)

# Example usage:
n = int(input().strip())
print(maximize_number(n))"
624,B,Making a String,PROGRAMMING,"['greedy', 'sortings']","You are given an alphabet consisting of *n* letters, your task is to make a string of the maximum possible length so that the following conditions are satisfied: 
 -  the *i*-th letter occurs in the string no more than *a**i* times; -  the number of occurrences of each letter in the string must be distinct for all the letters that occurred in the string at least once.","The first line of the input contains a single integer *n* (2<=<=≤<=<=*n*<=<=≤<=<=26) — the number of letters in the alphabet.

The next line contains *n* integers *a**i* (1<=≤<=*a**i*<=≤<=109) — *i*-th of these integers gives the limitation on the number of occurrences of the *i*-th character in the string.",Print a single integer — the maximum length of the string that meets all the requirements.,"['3\n2 5 5\n', '3\n1 1 2\n']","['11\n', '3\n']","For convenience let's consider an alphabet consisting of three letters: ""a"", ""b"", ""c"". In the first sample, some of the optimal strings are: ""cccaabbccbb"", ""aabcbcbcbcb"". In the second sample some of the optimal strings are: ""acc"", ""cbc"".",WRONG_ANSWER,"n = int(input())
s = input().split()
s = [int(i) for i in s]
answer = 0
used = []
for i in range(n):
    if s[i] not in used:
        answer += s[i]
        used.append(s[i])
print(answer)

","# program

def abbreviate_words(n, words):
    abbreviated_words = []
    for word in words:
        # Check if the word length is greater than 10
        if len(word) > 10:
            # Create the abbreviation
            abbreviation = f""{word[0]}{len(word) - 2}{word[-1]}""
            abbreviated_words.append(abbreviation)
        else:
            # Add the word as is if it's not too long
            abbreviated_words.append(word)
    return abbreviated_words

# Read input
n = int(input().strip())
words = [input().strip() for _ in range(n)]

# Get the abbreviated words
result = abbreviate_words(n, words)

# Print the result
for word in result:
    print(word)"
92,B,Binary Number,PROGRAMMING,['greedy'],"Little walrus Fangy loves math very much. That's why when he is bored he plays with a number performing some operations.

Fangy takes some positive integer *x* and wants to get a number one from it. While *x* is not equal to 1, Fangy repeats the following action: if *x* is odd, then he adds 1 to it, otherwise he divides *x* by 2. Fangy knows that for any positive integer number the process ends in finite time.

How many actions should Fangy perform to get a number one from number *x*?",The first line contains a positive integer *x* in a binary system. It is guaranteed that the first digit of *x* is different from a zero and the number of its digits does not exceed 106.,Print the required number of actions.,"['1\n', '1001001\n', '101110\n']","['0\n', '12\n', '8\n']","Let's consider the third sample. Number 101110 is even, which means that we should divide it by 2. After the dividing Fangy gets an odd number 10111 and adds one to it. Number 11000 can be divided by 2 three times in a row and get number 11. All that's left is to increase the number by one (we get 100), and then divide it by 2 two times in a row. As a result, we get 1.",WRONG_ANSWER,"s = input()

ss = s[::-1]

num = 0 
j = 0 


for i in range(0 , len(ss)):
    if (ss[i] == '1'):
        num += pow(2,j)
    j += 1    
    
ans = 0 
    
    
while(num > 1):
     if(num % 2):
         num = num + 1
     else :
       num = num / 2
     ans = ans + 1       
   
print(ans)    
","x = int(input())
result = []

def is_composite(n):
    """"""Check if a number is composite.""""""
    if n < 4:  # The smallest composite number is 4
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return True
    return False

# Iterate to find two composite numbers that sum to x
for i in range(4, x // 2 + 1):
    if is_composite(i) and is_composite(x - i):
        result.append((i, x - i))
        break  # We only need one pair

if result:
    print(result[0][0], result[0][1])  # Output the first found pair"
897,B,Chtholly's request,PROGRAMMING,['brute force'],"— I experienced so many great things.

— You gave me memories like dreams... But I have to leave now...

— One last request, can you...

— Help me solve a Codeforces problem?

— ......

— What?

Chtholly has been thinking about a problem for days:

If a number is palindrome and length of its decimal representation without leading zeros is even, we call it a zcy number. A number is palindrome means when written in decimal representation, it contains no leading zeros and reads the same forwards and backwards. For example 12321 and 1221 are palindromes and 123 and 12451 are not. Moreover, 1221 is zcy number and 12321 is not.

Given integers *k* and *p*, calculate the sum of the *k* smallest zcy numbers and output this sum modulo *p*.

Unfortunately, Willem isn't good at solving this kind of problems, so he asks you for help!","The first line contains two integers *k* and *p* (1<=≤<=*k*<=≤<=105,<=1<=≤<=*p*<=≤<=109).",Output single integer — answer to the problem.,"['2 100\n', '5 30\n']","['33\n', '15\n']","In the first example, the smallest zcy number is 11, and the second smallest zcy number is 22.

In the second example, <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/68fffad54395f7d920ad0384e07c6215ddc64141.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>.",OK,"k, p = map(int, input().split())
res = 0
for i in range(1, k+1):
    res += int(str(i)+(str(i)[::-1]))
    res %= p
print(res)","a, b, n = map(int, input().split())
e = 1

def gcd(x, y):
    if y == 0:
        return x
    return gcd(y, x % y)

while n > 0:
    # Simon's turn
    stones_to_take = gcd(a, n)
    if n < stones_to_take:
        # Simon cannot take the required stones, Antisimon wins
        print(1)
        break
    n -= stones_to_take
    
    # Antisimon's turn
    stones_to_take = gcd(b, n)
    if n < stones_to_take:
        # Antisimon cannot take the required stones, Simon wins
        print(0)
        break
    n -= stones_to_take"
831,A,Unimodal Array,PROGRAMMING,['implementation'],"Array of integers is unimodal, if:
 -  it is strictly increasing in the beginning; -  after that it is constant; -  after that it is strictly decreasing. 
The first block (increasing) and the last block (decreasing) may be absent. It is allowed that both of this blocks are absent.

For example, the following three arrays are unimodal: [5,<=7,<=11,<=11,<=2,<=1], [4,<=4,<=2], [7], but the following three are not unimodal: [5,<=5,<=6,<=6,<=1], [1,<=2,<=1,<=2], [4,<=5,<=5,<=6].

Write a program that checks if an array is unimodal.","The first line contains integer *n* (1<=≤<=*n*<=≤<=100) — the number of elements in the array.

The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=1<=000) — the elements of the array.","Print ""YES"" if the given array is unimodal. Otherwise, print ""NO"".

You can output each letter in any case (upper or lower).","['6\n1 5 5 5 4 2\n', '5\n10 20 30 20 10\n', '4\n1 2 1 2\n', '7\n3 3 3 3 3 3 3\n']","['YES\n', 'YES\n', 'NO\n', 'YES\n']","In the first example the array is unimodal, because it is strictly increasing in the beginning (from position 1 to position 2, inclusively), that it is constant (from position 2 to position 4, inclusively) and then it is strictly decreasing (from position 4 to position 6, inclusively).",WRONG_ANSWER,"n=int(input())
l=list(map(int,input().split()))
l=l[:n]
m=[]
for i in range(n-1):
    if l[i]<l[i+1]:m.append(1)
    elif l[i]==l[i+1]:m.append(0)
    else:m.append(-1)
a=True
for i in range(len(m)-1):
    if m[i]==-1 and (m[i+1]==1 or m[i+1]==0):
        a=False
print('YES' if a else 'NO')","def ex(n):
    chod = [1, 2, 3, 4, 5]
    if n in chod:
        return 1
    steps = n // 5  # Determine how many full 5-steps can be taken
    if n % 5 != 0:  # Check if there's a remainder
        steps += 1  # Add an extra step for the remaining distance
    return steps

# Input the coordinate of the friend's house
x = int(input())
# Output the minimum number of steps
print(ex(x))"
158,B,Taxi,PROGRAMMING,"['*special', 'greedy', 'implementation']","After the lessons *n* groups of schoolchildren went outside and decided to visit Polycarpus to celebrate his birthday. We know that the *i*-th group consists of *s**i* friends (1<=≤<=*s**i*<=≤<=4), and they want to go to Polycarpus together. They decided to get there by taxi. Each car can carry at most four passengers. What minimum number of cars will the children need if all members of each group should ride in the same taxi (but one taxi can take more than one group)?","The first line contains integer *n* (1<=≤<=*n*<=≤<=105) — the number of groups of schoolchildren. The second line contains a sequence of integers *s*1,<=*s*2,<=...,<=*s**n* (1<=≤<=*s**i*<=≤<=4). The integers are separated by a space, *s**i* is the number of children in the *i*-th group.",Print the single number — the minimum number of taxis necessary to drive all children to Polycarpus.,"['5\n1 2 4 3 3\n', '8\n2 3 4 4 2 1 3 1\n']","['4\n', '5\n']","In the first test we can sort the children into four cars like this:
 -  the third group (consisting of four children), -  the fourth group (consisting of three children), -  the fifth group (consisting of three children), -  the first and the second group (consisting of one and two children, correspondingly). 
There are other ways to sort the groups into four cars.",OK,"def min_taxis(groups):
    counts = [groups.count(i) for i in range(1, 5)]
    return counts[3] + counts[2] + (counts[1]*2 + max(0, counts[0] - counts[2]) + 3) // 4

# Пример использования
n = int(input())
groups = list(map(int, input().split()))
result = min_taxis(groups)
print(result)
","def main():
    v = [int(i) for i in input().split()]
    
    total_coins = sum(v)
    
    # Each player started with 'b' coins, so total should be 5 * b
    # We need to check if total_coins is divisible by 5
    if total_coins % 5 != 0:
        print(-1)
        return
    
    b = total_coins // 5  # Calculate the initial bet
    
    # Check if each player's coins are at least the initial bet
    if all(c >= b for c in v):
        print(b)
    else:
        print(-1)

if __name__ == ""__main__"":
    main()"
149,C,Division into Teams,PROGRAMMING,"['greedy', 'math', 'sortings']","Petya loves football very much, especially when his parents aren't home. Each morning he comes to the yard, gathers his friends and they play all day. From time to time they have a break to have some food or do some chores (for example, water the flowers).

The key in football is to divide into teams fairly before the game begins. There are *n* boys playing football in the yard (including Petya), each boy's football playing skill is expressed with a non-negative characteristic *a**i* (the larger it is, the better the boy plays). 

Let's denote the number of players in the first team as *x*, the number of players in the second team as *y*, the individual numbers of boys who play for the first team as *p**i* and the individual numbers of boys who play for the second team as *q**i*. Division *n* boys into two teams is considered fair if three conditions are fulfilled:
 -  Each boy plays for exactly one team (*x*<=+<=*y*<==<=*n*). -  The sizes of teams differ in no more than one (|*x*<=-<=*y*|<=≤<=1). -  The total football playing skills for two teams differ in no more than by the value of skill the best player in the yard has. More formally: 
Your task is to help guys divide into two teams fairly. It is guaranteed that a fair division into two teams always exists.","The first line contains the only integer *n* (2<=≤<=*n*<=≤<=105) which represents the number of guys in the yard. The next line contains *n* positive space-separated integers, *a**i* (1<=≤<=*a**i*<=≤<=104), the *i*-th number represents the *i*-th boy's playing skills.","On the first line print an integer *x* — the number of boys playing for the first team. On the second line print *x* integers — the individual numbers of boys playing for the first team. On the third line print an integer *y* — the number of boys playing for the second team, on the fourth line print *y* integers — the individual numbers of boys playing for the second team. Don't forget that you should fulfil all three conditions: *x*<=+<=*y*<==<=*n*, |*x*<=-<=*y*|<=≤<=1, and the condition that limits the total skills.

If there are multiple ways to solve the problem, print any of them.

The boys are numbered starting from one in the order in which their skills are given in the input data. You are allowed to print individual numbers of boys who belong to the same team in any order.","['3\n1 2 1\n', '5\n2 3 3 1 1\n']","['2\n1 2 \n1\n3 \n', '3\n4 1 3 \n2\n5 2 \n']","Let's consider the first sample test. There we send the first and the second boy to the first team and the third boy to the second team. Let's check all three conditions of a fair division. The first limitation is fulfilled (all boys play), the second limitation on the sizes of groups (|2 - 1| = 1 ≤ 1) is fulfilled, the third limitation on the difference in skills ((2 + 1) - (1) = 2 ≤ 2) is fulfilled.",OK,"n = int(input())
a = list(map(int,input().split()))
b = list(range(1,n+1))
z = sorted(list(zip(a,b)))
x = [] 
y = [] 
sx = 0 
sy = 0 
for i,j in z:
    if sx<=sy:
        x.append(j)
        sx+=i
    else:
        y.append(j)
        sy+=i
print(len(x))
print(*x)
print(len(y))
print(*y)","def main():
    (a, A), (b, B), (c, C), (d, D) = sorted(zip(map(int, input().split()), 'ABCD'))
    
    # Create component strings for Amaranths and Begonias
    aa = A.join(B * (b - 1)) if b > 1 else A
    bb = B.join(A * (a - 1)) if a > 1 else B
    
    # Now create the grid
    grid = []
    
    # Fill the grid with Amaranths and Begonias first
    for i in range(a):
        row = []
        for j in range(b):
            if j > 0:
                row.append(A)  # Fill with Amaranths
            else:
                row.append(B)  # Separate the components with Begonias
        grid.append(row)
    
    # Now include Centaureas
    for i in range(c):
        for j in range(1, b + 1):
            grid.append([C] * b)
    
    # Finally include Dianthuses
    for i in range(d):
        grid.append([D] * b)

    # Output the dimensions
    n = len(grid)
    m = b
    print(n, m)
    
    # Output the grid
    for row in grid:
        print(''.join(row))

main()"
886,A,ACM ICPC,PROGRAMMING,['brute force'],"In a small but very proud high school it was decided to win ACM ICPC. This goal requires to compose as many teams of three as possible, but since there were only 6 students who wished to participate, the decision was to build exactly two teams.

After practice competition, participant number *i* got a score of *a**i*. Team score is defined as sum of scores of its participants. High school management is interested if it's possible to build two teams with equal scores. Your task is to answer that question.","The single line contains six integers *a*1,<=...,<=*a*6 (0<=≤<=*a**i*<=≤<=1000) — scores of the participants","Print ""YES"" (quotes for clarity), if it is possible to build teams with equal score, and ""NO"" otherwise.

You can print each character either upper- or lowercase (""YeS"" and ""yes"" are valid when the answer is ""YES"").","['1 3 2 1 2 1\n', '1 1 1 1 1 99\n']","['YES\n', 'NO\n']","In the first sample, first team can be composed of 1st, 2nd and 6th participant, second — of 3rd, 4th and 5th: team scores are 1 + 3 + 1 = 2 + 1 + 2 = 5.

In the second sample, score of participant number 6 is too high: his team score will be definitely greater.",COMPILATION_ERROR,"#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;


int main()
{
	int i,n,s=0,maxm=0,j;
	vector<int> a(6);

	for (i=0;i<6;i++) {
		cin >> a[i];
		if (maxm < a[i])
			maxm = a[i];
		s += a[i];
	}

	if (s % 2 == 1) {
		cout << ""NO"";
		return 0;
	}

	s /= 2;
	for (i=1;i<6;i++)
		for (j=i+1;j<6;j++)
			if (s - a[0] - a[i] == a[j]) {
				cout << ""YES"";
				return 0;
			}
	cout << ""NO"";

	return 0;
}
","# Function to evaluate the coordinate from an expression
def evaluate_expression(expr):
    # Remove spaces for processing
    expr = expr.replace("" "", """")
    # Split expression into components
    a_b, c = expr.split('/')
    # Further split a and b
    a, b = a_b[1:-1].split('+')
    # Calculate the result of the expression
    return (int(a) + int(b)) / int(c)

# Function to count ships with the same coordinate
def nShipsWithSameCoordinate(m, coordinates):
    # List to hold each ship's coordinate
    ship_coordinates = []
    
    # Read the coordinates input
    for _ in range(m):
        expr = input().strip()
        coord = evaluate_expression(expr)
        ship_coordinates.append(coord)
        coordinates[coord] = coordinates.get(coord, 0) + 1
    
    # Generate the result based on the count of each coordinate
    result = [coordinates[coord] for coord in ship_coordinates]
    
    # Return the result
    return result

def main():
    # Call the function and print results
    print("" "".join(map(str, nShipsWithSameCoordinate(int(input()), {}))))"
54,A,Presents,PROGRAMMING,['implementation'],"The Hedgehog likes to give presents to his friend, but no less he likes to receive them.

Having received another present today, the Hedgehog suddenly understood that he has no place to put it as there was no room left on the special shelf in the cupboard. He will have to choose another shelf, but which one should he choose, how large should it be?

In order to get to know this, the Hedgehog asks you to write him a program that will count the estimated number of presents that he will receive during the following *N* days. Besides, he is guided by the principle: 
 -  on each holiday day the Hedgehog will necessarily receive a present, -  he receives presents at least every *K* days (i.e., if he received a present on the *i*-th day, he will receive the next present no later than on the *i*<=+<=*K*-th day). 
For the given *N* and *K*, as well as the list of holidays among the following *N* days count the minimal number of presents that could be given to the Hedgehog. The number of today's day is zero, and you should regard today's present as already given (i.e., you shouldn't count it in the answer).","The first line contains integers *N* and *K* (1<=≤<=*N*<=≤<=365, 1<=≤<=*K*<=≤<=*N*).

The second line contains a number *C* which represents the number of holidays (0<=≤<=*C*<=≤<=*N*). Then in the same line follow *C* numbers ranging from 1 to *N* which are the numbers of holiday days. The numbers are given in the increasing order, without repeating numbers among them.",Print a single number — the minimal number of presents the Hedgehog will receive over the following *N* days.,"['5 2\n1 3\n', '10 1\n3 6 7 8\n']","['3', '10']",none,WRONG_ANSWER,"n, k = map(int, input().split("" ""))
days = [0] + list(map(int, input().split("" "")))

count = 1
answer = 0
for i in days:
    if(not count):
        answer += i
    count = (count+1)%(k+1)

print(answer)
			 		  	 	 				 				  	 		  		","from collections import defaultdict as dc

n, m = [int(x) for x in input().split()]
ans = n * n
mpr, mpc = dc(lambda: False), dc(lambda: False)

for _ in range(m):
    x, y = [int(x) for x in input().split()]
    # Check if this rook is the first in its row or column
    if not mpr[x]:
        ans -= n  # All cells in row x become under attack
        mpr[x] = True
    if not mpc[y]:
        ans -= n  # All cells in column y become under attack
        mpc[y] = True

    # Adjust for double counted cell (x, y)
    ans += 1

    print(ans)"
799,A,Carrot Cakes,PROGRAMMING,"['brute force', 'implementation']","In some game by Playrix it takes *t* minutes for an oven to bake *k* carrot cakes, all cakes are ready at the same moment *t* minutes after they started baking. Arkady needs at least *n* cakes to complete a task, but he currently don't have any. However, he has infinitely many ingredients and one oven. Moreover, Arkady can build one more similar oven to make the process faster, it would take *d* minutes to build the oven. While the new oven is being built, only old one can bake cakes, after the new oven is built, both ovens bake simultaneously. Arkady can't build more than one oven.

Determine if it is reasonable to build the second oven, i.e. will it decrease the minimum time needed to get *n* cakes or not. If the time needed with the second oven is the same as with one oven, then it is unreasonable.","The only line contains four integers *n*, *t*, *k*, *d* (1<=≤<=*n*,<=*t*,<=*k*,<=*d*<=≤<=1<=000) — the number of cakes needed, the time needed for one oven to bake *k* cakes, the number of cakes baked at the same time, the time needed to build the second oven.","If it is reasonable to build the second oven, print ""YES"". Otherwise print ""NO"".","['8 6 4 5\n', '8 6 4 6\n', '10 3 11 4\n', '4 2 1 4\n']","['YES\n', 'NO\n', 'NO\n', 'YES\n']","In the first example it is possible to get 8 cakes in 12 minutes using one oven. The second oven can be built in 5 minutes, so after 6 minutes the first oven bakes 4 cakes, the second oven bakes 4 more ovens after 11 minutes. Thus, it is reasonable to build the second oven. 

In the second example it doesn't matter whether we build the second oven or not, thus it takes 12 minutes to bake 8 cakes in both cases. Thus, it is unreasonable to build the second oven.

In the third example the first oven bakes 11 cakes in 3 minutes, that is more than needed 10. It is unreasonable to build the second oven, because its building takes more time that baking the needed number of cakes using the only oven.",WRONG_ANSWER,"n,t,k,d=map(int,input().split())
a=d
ans1=0
while ans1<=n:
    a=a+t
    ans1=ans1+2*k
ans2=0
b=0
while ans2<=n:
    b=b+t
    ans2=ans2+k
if a<b:
    print(""YES"")
else:
    print(""NO"")","#!/usr/bin/python3

import sys

sq = []
for i, line in enumerate(sys.stdin.readlines()):
    sq.append(line.strip())

# Function to check if there exists a 2x2 square of the same color
def has_uniform_square(sq, color):
    for i in range(3):  # Check rows 0 to 2
        for j in range(3):  # Check columns 0 to 2
            if (sq[i][j] == color and
                sq[i][j+1] == color and
                sq[i+1][j] == color and
                sq[i+1][j+1] == color):
                return True
    return False

# Check if there's already a 2x2 square of the same color
if has_uniform_square(sq, '.') or has_uniform_square(sq, '#'):
    print(""YES"")
else:
    # Check by repainting each cell
    for i in range(4):
        for j in range(4):
            # Change the color of the cell
            original_color = sq[i][j]
            new_color = '#' if original_color == '.' else '.'
            sq[i] = sq[i][:j] + new_color + sq[i][j+1:]

            # Check after repainting
            if has_uniform_square(sq, '.'):
                print(""YES"")
                sys.exit()
            if has_uniform_square(sq, '#'):
                print(""YES"")
                sys.exit()

            # Revert the color back
            sq[i] = sq[i][:j] + original_color + sq[i][j+1:]

    print(""NO"")"
884,A,Book Reading,PROGRAMMING,['implementation'],"Recently Luba bought a very interesting book. She knows that it will take *t* seconds to read the book. Luba wants to finish reading as fast as she can.

But she has some work to do in each of *n* next days. The number of seconds that Luba has to spend working during *i*-th day is *a**i*. If some free time remains, she can spend it on reading.

Help Luba to determine the minimum number of day when she finishes reading.

It is guaranteed that the answer doesn't exceed *n*.

Remember that there are 86400 seconds in a day.","The first line contains two integers *n* and *t* (1<=≤<=*n*<=≤<=100, 1<=≤<=*t*<=≤<=106) — the number of days and the time required to read the book.

The second line contains *n* integers *a**i* (0<=≤<=*a**i*<=≤<=86400) — the time Luba has to spend on her work during *i*-th day.","Print the minimum day Luba can finish reading the book.

It is guaranteed that answer doesn't exceed *n*.","['2 2\n86400 86398\n', '2 86400\n0 86400\n']","['2\n', '1\n']",none,WRONG_ANSWER,"td,time=map(int,input().split())
ts=list(map(int,input().split()))
k=86400
sub=0
f=0
for i in range(td):
    sub=k-ts[i]
    f=f+1
    if time==sub:
        break
print(f)
","k, a, b = map(int, input().split())
qo = input()

n = len(qo)

# Check if it's possible to split the text into k lines
if n < k * a or n > k * b:
    print(""No solution"")
else:
    lines = []
    current_line = """"

    for i in range(n):
        current_line += qo[i]
        
        # If we can fill this line and it's not the last line, we should check length
        if len(current_line >= a and (i == n - 1 or len(current_line) >= b)):
            lines.append(current_line)
            current_line = """"

            # If we have filled up k-1 lines, the last line must take the rest
            if len(lines) == k - 1:
                lines.append(qo[i+1:])
                break

    # Add the last line if not empty
    if current_line:
        lines.append(current_line)

    # Check if we have exactly k lines
    if len(lines) == k:
        print(""\n"".join(lines))
    else:
        print(""No solution"")"
471,D,MUH and Cube Walls,PROGRAMMING,"['string suffix structures', 'strings']","Polar bears Menshykov and Uslada from the zoo of St. Petersburg and elephant Horace from the zoo of Kiev got hold of lots of wooden cubes somewhere. They started making cube towers by placing the cubes one on top of the other. They defined multiple towers standing in a line as a wall. A wall can consist of towers of different heights.

Horace was the first to finish making his wall. He called his wall an elephant. The wall consists of *w* towers. The bears also finished making their wall but they didn't give it a name. Their wall consists of *n* towers. Horace looked at the bears' tower and wondered: in how many parts of the wall can he ""see an elephant""? He can ""see an elephant"" on a segment of *w* contiguous towers if the heights of the towers on the segment match as a sequence the heights of the towers in Horace's wall. In order to see as many elephants as possible, Horace can raise and lower his wall. He even can lower the wall below the ground level (see the pictures to the samples for clarification).

Your task is to count the number of segments where Horace can ""see an elephant"".","The first line contains two integers *n* and *w* (1<=≤<=*n*,<=*w*<=≤<=2·105) — the number of towers in the bears' and the elephant's walls correspondingly. The second line contains *n* integers *a**i* (1<=≤<=*a**i*<=≤<=109) — the heights of the towers in the bears' wall. The third line contains *w* integers *b**i* (1<=≤<=*b**i*<=≤<=109) — the heights of the towers in the elephant's wall.","Print the number of segments in the bears' wall where Horace can ""see an elephant"".",['13 5\n2 4 5 5 4 3 2 2 2 3 3 2 1\n3 4 4 3 2\n'],['2'],"The picture to the left shows Horace's wall from the sample, the picture to the right shows the bears' wall. The segments where Horace can ""see an elephant"" are in gray.",RUNTIME_ERROR,"def count_elephant_segments(n, w, bear_wall, elephant_wall):
    # Calcula um valor de hash para a parede do elefante
    elephant_hash = hash(elephant_wall)

    # Calcula um valor de hash para a janela inicial na parede dos ursos
    bear_hash = hash(bear_wall[:w])

    count = 0

    # Percorre a parede dos ursos com a janela deslizante
    for i in range(n - w + 1):
        if i > 0:
            # Atualiza o valor de hash da janela deslizante
            bear_hash = bear_hash * 101 + bear_wall[i + w - 1] - bear_wall[i - 1] * 101 ** w

        if bear_hash == elephant_hash:
            count += 1

    return count

# Leitura da entrada
n, w = map(int, input().split())
bear_wall = list(map(int, input().split()))
elephant_wall = list(map(int, input().split()))

# Chama a função para contar os segmentos onde Horace pode ""ver um elefante""
result = count_elephant_segments(n, w, bear_wall, elephant_wall)
print(result)

     	 			       	  				","#  author:  violist
#  created: 26.06.2022 12:53:28

import sys
from collections import defaultdict
input = sys.stdin.readline

# Read the two genomes
genome1 = input().strip()
genome2 = input().strip()

# Check if the lengths of the genomes are the same
if len(genome1) != len(genome2):
    print(""NO"")
else:
    # Count mismatches between the two genomes
    mismatches = []
    for i in range(len(genome1)):
        if genome1[i] != genome2[i]:
            mismatches.append((genome1[i], genome2[i]))
    
    # Check if there are exactly two mismatches that can be swapped
    if len(mismatches) == 2 and mismatches[0] == mismatches[1][::-1]:
        print(""YES"")
    else:
        print(""NO"")"
11,A,Increasing Sequence,PROGRAMMING,"['constructive algorithms', 'implementation', 'math']","A sequence *a*0,<=*a*1,<=...,<=*a**t*<=-<=1 is called increasing if *a**i*<=-<=1<=&lt;<=*a**i* for each *i*:<=0<=&lt;<=*i*<=&lt;<=*t*.

You are given a sequence *b*0,<=*b*1,<=...,<=*b**n*<=-<=1 and a positive integer *d*. In each move you may choose one element of the given sequence and add *d* to it. What is the least number of moves required to make the given sequence increasing?","The first line of the input contains two integer numbers *n* and *d* (2<=≤<=*n*<=≤<=2000,<=1<=≤<=*d*<=≤<=106). The second line contains space separated sequence *b*0,<=*b*1,<=...,<=*b**n*<=-<=1 (1<=≤<=*b**i*<=≤<=106).",Output the minimal number of moves needed to make the sequence increasing.,['4 2\n1 3 3 2\n'],['3\n'],none,WRONG_ANSWER,"n, d = map(int, input().split())
nums = list(map(int, input().split()))

count = 0
for i in range(1, n):
    if nums[i] <= nums[i-1]:
        count += (nums[i-1] - nums[i]) // d + 1
        nums[i] += count * d

print(count)
","from sys import stdin, exit

def select(arr, left, right, k):
    while True:
        if left == right:
            return left
        pivotIndex = pivot(arr, left, right)
        pivotIndex = partition(arr, left, right, pivotIndex, k)

def pivot(arr, left, right):
    pivotValue = arr[right][0]  # We pick the last element as the pivot (health)
    pivotIndex = left
    for i in range(left, right):
        if arr[i][0] < pivotValue:
            arr[i], arr[pivotIndex] = arr[pivotIndex], arr[i]
            pivotIndex += 1
    arr[pivotIndex], arr[right] = arr[right], arr[pivotIndex]
    return pivotIndex

def partition(arr, left, right, pivotIndex, k):
    if pivotIndex == k:
        return k
    elif pivotIndex < k:
        return partition(arr, pivotIndex + 1, right, pivotIndex + 1, k)
    else:
        return partition(arr, left, pivotIndex - 1, left, k)

def max_total_damage(n, a, b, creatures):
    # Sort creatures based on current damage
    creatures.sort(key=lambda x: x[1], reverse=True)
    
    total_damage = 0
    for i in range(min(b, n)):
        total_damage += creatures[i][1]
    
    # Now we want to apply `a` spells of type 1 (double health)
    for i in range(n):
        for _ in range(a):
            creatures[i][0] *= 2  # Double health
            if i < n:
                creatures[i][1] = max(creatures[i][1], creatures[i][0])  # Assign health to damage
    
    # Sort based on new damage values after doubling health
    creatures.sort(key=lambda x: x[1], reverse=True)
    
    # Calculate final total damage after possibly using type 2 spells
    for i in range(b):
        if i < n:
            total_damage += max(creatures[i][1], creatures[i][0])
    
    return total_damage

if __name__ == '__main__':
    n, a, b = map(int, stdin.readline().split())
    creatures = [list(map(int, stdin.readline().split())) for _ in range(n)]
    print(max_total_damage(n, a, b, creatures))"
436,A,Feed with Candy,PROGRAMMING,['greedy'],"The hero of the Cut the Rope game is a little monster named Om Nom. He loves candies. And what a coincidence! He also is the hero of today's problem.

One day, Om Nom visited his friend Evan. Evan has *n* candies of two types (fruit drops and caramel drops), the *i*-th candy hangs at the height of *h**i* centimeters above the floor of the house, its mass is *m**i*. Om Nom wants to eat as many candies as possible. At the beginning Om Nom can make at most *x* centimeter high jumps. When Om Nom eats a candy of mass *y*, he gets stronger and the height of his jump increases by *y* centimeters.

What maximum number of candies can Om Nom eat if he never eats two candies of the same type in a row (Om Nom finds it too boring)?","The first line contains two integers, *n* and *x* (1<=≤<=*n*,<=*x*<=≤<=2000) — the number of sweets Evan has and the initial height of Om Nom's jump. 

Each of the following *n* lines contains three integers *t**i*,<=*h**i*,<=*m**i* (0<=≤<=*t**i*<=≤<=1; 1<=≤<=*h**i*,<=*m**i*<=≤<=2000) — the type, height and the mass of the *i*-th candy. If number *t**i* equals 0, then the current candy is a caramel drop, otherwise it is a fruit drop.",Print a single integer — the maximum number of candies Om Nom can eat.,['5 3\n0 2 4\n1 3 1\n0 8 3\n0 20 10\n1 5 5\n'],['4\n'],"One of the possible ways to eat 4 candies is to eat them in the order: 1, 5, 3, 2. Let's assume the following scenario:
 1.  Initially, the height of Om Nom's jump equals 3. He can reach candies 1 and 2. Let's assume that he eats candy 1. As the mass of this candy equals 4, the height of his jump will rise to 3 + 4 = 7. 1.  Now Om Nom can reach candies 2 and 5. Let's assume that he eats candy 5. Then the height of his jump will be 7 + 5 = 12. 1.  At this moment, Om Nom can reach two candies, 2 and 3. He won't eat candy 2 as its type matches the type of the previously eaten candy. Om Nom eats candy 3, the height of his jump is 12 + 3 = 15. 1.  Om Nom eats candy 2, the height of his jump is 15 + 1 = 16. He cannot reach candy 4.",OK,"from copy import deepcopy

def getBetter(h, a):
    maxi = -1
    im = -1
    for i in range(len(a)):
        if (h >= a[i][0]):
            if (maxi < a[i][1]):
                im = i
                maxi = a[i][1]
    return(im, maxi)

n, h0 = map(int, input().split())

lolipops0 = [[], []]

for i in range(n):
    t, h, m = map(int, input().split())
    lolipops0[t].append((h, m))

lolipops0[1].sort()
lolipops0[0].sort()

lolipops1 = deepcopy(lolipops0)

lol0 = getBetter(h0, lolipops0[0])
t1 = 0
h1 = h0
lol1 = getBetter(h0, lolipops0[1])
t2 = 1 # ---- WARNING --------
h2 = h0
while(lol0[0] >= 0 or lol1[0] >=0):
    if (lol0[0] > -1):
        if (len(lolipops0[t1 % 2]) != 1 and lol0[0] != -1):
            lolipops0[t1 % 2].pop(lol0[0])
        else:
            lolipops0[t1 % 2] = []
        t1 += 1
        h1 += lol0[1]
        lol0 = getBetter(h1, lolipops0[t1 % 2])
    if (lol1[0] > -1):
        if (len(lolipops1[t2 % 2]) != 1 and lol1[0] != -1):
            lolipops1[t2 % 2].pop(lol1[0])
        else:
            lolipops1[t2 % 2] = []
        t2 += 1
        h2 += lol1[1]
        lol1 = getBetter(h2, lolipops1[t2 % 2])
print(max(t1, t2 - 1))","quotas = [int(x) - 1 for x in input().split()]
grid = [['A'] * 50 for _ in range(12)] + \
       [['B'] * 50 for _ in range(12)] + \
       [['C'] * 50 for _ in range(12)] + \
       [['D'] * 50 for _ in range(12)]

n = 0
m = 0

# Define a function to place components in grid
def place_components(letter, count, start_row):
    global n, m
    for i in range(count):
        for j in range(3):  # Create a small component
            grid[start_row + i * 2][j] = letter
            n = max(n, start_row + i * 2 + 1)
            m = max(m, j + 1)

# Place the connected components
place_components('A', quotas[0], 0)
place_components('B', quotas[1], 2 * quotas[0])
place_components('C', quotas[2], 2 * (quotas[0] + quotas[1]))
place_components('D', quotas[3], 2 * (quotas[0] + quotas[1] + quotas[2]))

print(n, m)
for row in grid[:n]:
    print(''.join(row[:m]))"
842,B,Gleb And Pizza,PROGRAMMING,['geometry'],"Gleb ordered pizza home. When the courier delivered the pizza, he was very upset, because several pieces of sausage lay on the crust, and he does not really like the crust.

The pizza is a circle of radius *r* and center at the origin. Pizza consists of the main part — circle of radius *r*<=-<=*d* with center at the origin, and crust around the main part of the width *d*. Pieces of sausage are also circles. The radius of the *i* -th piece of the sausage is *r**i*, and the center is given as a pair (*x**i*, *y**i*).

Gleb asks you to help determine the number of pieces of sausage caught on the crust. A piece of sausage got on the crust, if it completely lies on the crust.","First string contains two integer numbers *r* and *d* (0<=≤<=*d*<=&lt;<=*r*<=≤<=500) — the radius of pizza and the width of crust.

Next line contains one integer number *n* — the number of pieces of sausage (1<=≤<=*n*<=≤<=105).

Each of next *n* lines contains three integer numbers *x**i*, *y**i* and *r**i* (<=-<=500<=≤<=*x**i*,<=*y**i*<=≤<=500, 0<=≤<=*r**i*<=≤<=500), where *x**i* and *y**i* are coordinates of the center of *i*-th peace of sausage, *r**i* — radius of *i*-th peace of sausage.",Output the number of pieces of sausage that lay on the crust.,"['8 4\n7\n7 8 1\n-7 3 2\n0 2 1\n0 -2 2\n-3 -3 1\n0 6 2\n5 3 1\n', '10 8\n4\n0 0 9\n0 0 10\n1 0 1\n1 0 2\n']","['2\n', '0\n']",Below is a picture explaining the first example. Circles of green color denote pieces of sausage lying on the crust.,WRONG_ANSWER,"r, d = map(int, input().split())
n = int(input())
ans = 0
for _ in range(n):
    a, b, c = map(int, input().split())
    if (a * a + b * b) ** 0.5 - c >= d and (a * a + b * b) ** 0.5 + c <= r:
        ans += 1
print(ans)
","def geti(a):
    return int(float(a))

n = geti(input())
x = []
d = []

# Read the positions and spit distances of camels
for _ in range(n):
    position, distance = map(int, input().split())
    x.append(position)
    d.append(distance)

# Check for each camel if they spit at another camel that spits back
for i in range(n):
    target_position = x[i] + d[i]
    if target_position in x:
        j = x.index(target_position)
        # Check if the camel at the target spits back
        if x[j] + d[j] == x[i]:
            print(""YES"")
            break
else:
    print(""NO"")"
675,A,Infinite Sequence,PROGRAMMING,['math'],"Vasya likes everything infinite. Now he is studying the properties of a sequence *s*, such that its first element is equal to *a* (*s*1<==<=*a*), and the difference between any two neighbouring elements is equal to *c* (*s**i*<=-<=*s**i*<=-<=1<==<=*c*). In particular, Vasya wonders if his favourite integer *b* appears in this sequence, that is, there exists a positive integer *i*, such that *s**i*<==<=*b*. Of course, you are the person he asks for a help.","The first line of the input contain three integers *a*, *b* and *c* (<=-<=109<=≤<=*a*,<=*b*,<=*c*<=≤<=109) — the first element of the sequence, Vasya's favorite number and the difference between any two neighbouring elements of the sequence, respectively.","If *b* appears in the sequence *s* print ""YES"" (without quotes), otherwise print ""NO"" (without quotes).","['1 7 3\n', '10 10 0\n', '1 -4 5\n', '0 60 50\n']","['YES\n', 'YES\n', 'NO\n', 'NO\n']","In the first sample, the sequence starts from integers 1, 4, 7, so 7 is its element.

In the second sample, the favorite integer of Vasya is equal to the first element of the sequence.

In the third sample all elements of the sequence are greater than Vasya's favorite integer.

In the fourth sample, the sequence starts from 0, 50, 100, and all the following elements are greater than Vasya's favorite integer.",WRONG_ANSWER,"def favourite_number(a, b, c):
    if a - b == 0:
        return ""YES""
    elif c == 0:
        return ""NO""
    elif (a - b) % c != 0 and (a - b) * c < 0:
        return ""NO""
    return ""YES""


A, B, C = [int(i) for i in input().split()]
print(favourite_number(A, B, C))
","def heyBoy(tempArr, l, r, arr):
    freqArr = tempArr[::]
    if r + 1 < len(arr):
        freqArr[r + 1] -= 1
    arr[l] += 1
    numbers = 0
    for i in range(len(arr)):
        numbers += arr[i]
        freqArr[i] += freqArr[i - 1] if i > 0 else 0
    return numbers

def maxHappiness(n, m, moods, subarrays):
    happiness = 0
    tempArr = [0] * (n + 1)  # To manage frequency of subarrays

    for l, r in subarrays:
        # Convert 1-based to 0-based for python lists
        l -= 1
        r -= 1
        tempArr[l] += 1  # Increment the start of the interval
        if r + 1 < n:
            tempArr[r + 1] -= 1  # Decrement after the end of the interval

    # Calculate the number of times each flower is included in the selected subarrays
    frequency = [0] * n
    current = 0
    for i in range(n):
        current += tempArr[i]
        frequency[i] = current

    # Calculate the total happiness
    for i in range(n):
        if frequency[i] > 0:
            happiness += moods[i] * frequency[i]

    return max(happiness, 0)  # Returning max with 0 to ensure no negative happiness

# Sample Input processing
n, m = map(int, input().split())
moods = list(map(int, input().split()))
subarrays = [list(map(int, input().split())) for _ in range(m)]

# Calculate the maximum happiness
result = maxHappiness(n, m, moods, subarrays)
print(result)"
813,E,Army Creation,PROGRAMMING,"['binary search', 'data structures']","As you might remember from our previous rounds, Vova really likes computer games. Now he is playing a strategy game known as Rage of Empires.

In the game Vova can hire *n* different warriors; *i*th warrior has the type *a**i*. Vova wants to create a balanced army hiring some subset of warriors. An army is called balanced if for each type of warrior present in the game there are not more than *k* warriors of this type in the army. Of course, Vova wants his army to be as large as possible.

To make things more complicated, Vova has to consider *q* different plans of creating his army. *i*th plan allows him to hire only warriors whose numbers are not less than *l**i* and not greater than *r**i*.

Help Vova to determine the largest size of a balanced army for each plan.

Be aware that the plans are given in a modified way. See input section for details.","The first line contains two integers *n* and *k* (1<=≤<=*n*,<=*k*<=≤<=100000).

The second line contains *n* integers *a*1, *a*2, ... *a**n* (1<=≤<=*a**i*<=≤<=100000).

The third line contains one integer *q* (1<=≤<=*q*<=≤<=100000).

Then *q* lines follow. *i*th line contains two numbers *x**i* and *y**i* which represent *i*th plan (1<=≤<=*x**i*,<=*y**i*<=≤<=*n*).

You have to keep track of the answer to the last plan (let's call it *last*). In the beginning *last*<==<=0. Then to restore values of *l**i* and *r**i* for the *i*th plan, you have to do the following:
 1.  *l**i*<==<=((*x**i*<=+<=*last*) *mod* *n*)<=+<=1; 1.  *r**i*<==<=((*y**i*<=+<=*last*) *mod* *n*)<=+<=1; 1.  If *l**i*<=&gt;<=*r**i*, swap *l**i* and *r**i*.",Print *q* numbers. *i*th number must be equal to the maximum size of a balanced army when considering *i*th plan.,['6 2\n1 1 1 2 2 2\n5\n1 6\n4 3\n1 1\n2 6\n2 6\n'],['2\n4\n1\n3\n2\n'],"In the first example the real plans are: 
 1.  1 2 1.  1 6 1.  6 6 1.  2 4 1.  4 6",WRONG_ANSWER,"print(""_RANDOM_GUESS_1691763970.7246501"")# 1691763970.7246654","# Function to check if a number is prime
def isprime(x):
    if x == 1:
        return False
    for i in range(2, int(x ** 0.5) + 1):
        if x % i == 0:
            return False
    return True

# Function to count distinct prime factors of a number
def count_distinct_prime_factors(num):
    count = 0
    for i in range(2, num + 1):
        if isprime(i) and num % i == 0:
            count += 1
        if count > 2:  # No need to count beyond 2
            break
    return count

# Main function to find the amount of almost prime numbers
def count_almost_primes(n):
    almost_prime_count = 0
    for i in range(1, n + 1):
        if count_distinct_prime_factors(i) == 2:
            almost_prime_count += 1
    return almost_prime_count

# Input
n = int(input())
# Output the count of almost primes
print(count_almost_primes(n))"
681,A,A Good Contest,PROGRAMMING,['implementation'],"Codeforces user' handle color depends on his rating — it is red if his rating is greater or equal to 2400; it is orange if his rating is less than 2400 but greater or equal to 2200, etc. Each time participant takes part in a rated contest, his rating is changed depending on his performance.

Anton wants the color of his handle to become red. He considers his performance in the rated contest to be good if he outscored some participant, whose handle was colored red before the contest and his rating has increased after it.

Anton has written a program that analyses contest results and determines whether he performed good or not. Are you able to do the same?","The first line of the input contains a single integer *n* (1<=≤<=*n*<=≤<=100) — the number of participants Anton has outscored in this contest .

The next *n* lines describe participants results: the *i*-th of them consists of a participant handle *name**i* and two integers *before**i* and *after**i* (<=-<=4000<=≤<=*before**i*,<=*after**i*<=≤<=4000) — participant's rating before and after the contest, respectively. Each handle is a non-empty string, consisting of no more than 10 characters, which might be lowercase and uppercase English letters, digits, characters «_» and «-» characters.

It is guaranteed that all handles are distinct.","Print «YES» (quotes for clarity), if Anton has performed good in the contest and «NO» (quotes for clarity) otherwise.","['3\nBurunduk1 2526 2537\nBudAlNik 2084 2214\nsubscriber 2833 2749\n', '3\nApplejack 2400 2400\nFluttershy 2390 2431\nPinkie_Pie -2500 -2450\n']","['YES', 'NO']","In the first sample, Anton has outscored user with handle Burunduk1, whose handle was colored red before the contest and his rating has increased after the contest.

In the second sample, Applejack's rating has not increased after the contest, while both Fluttershy's and Pinkie_Pie's handles were not colored red before the contest.",COMPILATION_ERROR,"n=int(input())
i=0
k=0
while i<n:
	A=input().split()
	if int(A[1])>=2400 and int(A[1])<int(A[2]):
		k=1
		break
        i+=1
if k==1:
	print('YES')
else:
	print('NO')
","# https://codeforces.com/problemset/problem/959/A

n = int(input())  # Read the integer n

# Determine the winner based on the parity of n
if n % 2 == 0:
    print(""Mahmoud"")  # Mahmoud wins if n is even
else:
    print(""Ehab"")     # Ehab wins if n is odd"
34,B,Sale,PROGRAMMING,"['greedy', 'sortings']","Once Bob got to a sale of old TV sets. There were *n* TV sets at that sale. TV set with index *i* costs *a**i* bellars. Some TV sets have a negative price — their owners are ready to pay Bob if he buys their useless apparatus. Bob can «buy» any TV sets he wants. Though he's very strong, Bob can carry at most *m* TV sets, and he has no desire to go to the sale for the second time. Please, help Bob find out the maximum sum of money that he can earn.","The first line contains two space-separated integers *n* and *m* (1<=≤<=*m*<=≤<=*n*<=≤<=100) — amount of TV sets at the sale, and amount of TV sets that Bob can carry. The following line contains *n* space-separated integers *a**i* (<=-<=1000<=≤<=*a**i*<=≤<=1000) — prices of the TV sets.","Output the only number — the maximum sum of money that Bob can earn, given that he can carry at most *m* TV sets.","['5 3\n-6 0 35 -2 4\n', '4 2\n7 0 0 -7\n']","['8\n', '7\n']",none,OK,"#F
n, m = [int(x) for x in input().split()]
total = int(0)
a = [int(x) for x in input().split()]
a.sort()
for i in range(m):
    if (a[i]<=0):
        total+=a[i]
    else :
        break
print(total*-1)
 	 	    								       	 	 	 	","## Fast I/O
import io, os, sys

# Fast input. Use s = input().decode() for strings
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

# Fast output
def print(*args, sep=' ', end='\n'):
    os.write(1, (sep.join(map(str, args)) + end).encode())

n, k = map(int, input().split())
a = list(map(int, input().split()))

# The target value is the k-th element of the array after any operations
target_value = a[k - 1]

# Check if it's possible for all numbers to become the same
if all(x == target_value for x in a[k - 1:]):
    # Calculate the number of operations needed
    operations_needed = 0
    for i in range(n):
        if a[i] != target_value:
            operations_needed += 1
    # The result is the number of operations needed to make all elements equal
    print(operations_needed)
else:
    print(-1)"
1,A,Theatre Square,PROGRAMMING,['math'],"Theatre Square in the capital city of Berland has a rectangular shape with the size *n*<=×<=*m* meters. On the occasion of the city's anniversary, a decision was taken to pave the Square with square granite flagstones. Each flagstone is of the size *a*<=×<=*a*.

What is the least number of flagstones needed to pave the Square? It's allowed to cover the surface larger than the Theatre Square, but the Square has to be covered. It's not allowed to break the flagstones. The sides of flagstones should be parallel to the sides of the Square.","The input contains three positive integer numbers in the first line: *n*,<=<=*m* and *a* (1<=≤<=<=*n*,<=*m*,<=*a*<=≤<=109).",Write the needed number of flagstones.,['6 6 4\n'],['4\n'],none,OK,"n, m, a = map(int, input().split())
width_stones = -(-n // a)  
length_stones = -(-m // a)  
total_stones = width_stones * length_stones
print(total_stones)","from collections import defaultdict
import sys

class Node:
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None

def build_tree(n, vertices):
    nodes = {}
    for i in range(1, n+1):
        val, l, r = vertices[i-1]
        if i not in nodes:
            nodes[i] = Node(val)
        else:
            nodes[i].val = val

        if l != -1:
            nodes[i].left = nodes.setdefault(l, Node(0))
        if r != -1:
            nodes[i].right = nodes.setdefault(r, Node(0))
        
    return nodes[1]  # return the root node

def search_failures(node, val):
    current = node
    while current:
        if current.val == val:
            return False  # success
        elif current.val > val:
            current = current.left
        else:
            current = current.right
    return True  # fail

def count_failures(root, nodes):
    fail_count = 0
    for idx, node in nodes.items():
        if search_failures(root, node.val):
            fail_count += 1
    return fail_count

def main():
    input = sys.stdin.read
    data = input().splitlines()
    n = int(data[0])
    
    vertices = []
    for i in range(1, n+1):
        vertices.append(tuple(map(int, data[i].split())))
    
    root = build_tree(n, vertices)
    nodes = {i+1: vertices[i] for i in range(n)}
    
    result = count_failures(root, nodes)
    print(result)

if __name__ == ""__main__"":
    main()"
37,A,Towers,PROGRAMMING,['sortings'],"Little Vasya has received a young builder’s kit. The kit consists of several wooden bars, the lengths of all of them are known. The bars can be put one on the top of the other if their lengths are the same.

Vasya wants to construct the minimal number of towers from the bars. Help Vasya to use the bars in the best way possible.",The first line contains an integer *N* (1<=≤<=*N*<=≤<=1000) — the number of bars at Vasya’s disposal. The second line contains *N* space-separated integers *l**i* — the lengths of the bars. All the lengths are natural numbers not exceeding 1000.,In one line output two numbers — the height of the largest tower and their total number. Remember that Vasya should use all the bars.,"['3\n1 2 3\n', '4\n6 5 6 7\n']","['1 3\n', '2 3\n']",none,OK,"n=int(input())
lst=list(map(int,input().split(' ')))

lstc={}
for i in range(n):
    if(lst[i] in lstc.keys()):
        continue
    else:
        count=0
        for j in range(n):
            if(lst[i]==lst[j]):
                count+=1
        lstc[lst[i]]=count
    
height=max(lstc.values())
print(height,len(lstc.values()))","import math

n, k = map(int,input().split())

def mod(n):
    return n % 1000000007

def variacion(n, p):
    return math.factorial(n) // math.factorial(n - p)

# Calculate the total number of permutations
total_permutations = math.factorial(n)

# Calculate the number of permutations where the maximum is at least n - k + 1
valid_maximum_count = variacion(n - 1, k - 1)

# Calculate the number of permutations where the maximum is n
count_with_max_n = (total_permutations - valid_maximum_count) % mod(1000000007)

# The answer is the total permutations minus those returning n
result = (total_permutations - count_with_max_n) % mod(1000000007)

print(result)"
592,A,PawnChess,PROGRAMMING,['implementation'],"Galois is one of the strongest chess players of Byteforces. He has even invented a new variant of chess, which he named «PawnChess».

This new game is played on a board consisting of 8 rows and 8 columns. At the beginning of every game some black and white pawns are placed on the board. The number of black pawns placed is not necessarily equal to the number of white pawns placed. 

Lets enumerate rows and columns with integers from 1 to 8. Rows are numbered from top to bottom, while columns are numbered from left to right. Now we denote as (*r*,<=*c*) the cell located at the row *r* and at the column *c*.

There are always two players A and B playing the game. Player A plays with white pawns, while player B plays with black ones. The goal of player A is to put any of his pawns to the row 1, while player B tries to put any of his pawns to the row 8. As soon as any of the players completes his goal the game finishes immediately and the succeeded player is declared a winner.

Player A moves first and then they alternate turns. On his move player A must choose exactly one white pawn and move it one step upward and player B (at his turn) must choose exactly one black pawn and move it one step down. Any move is possible only if the targeted cell is empty. It's guaranteed that for any scenario of the game there will always be at least one move available for any of the players.

Moving upward means that the pawn located in (*r*,<=*c*) will go to the cell (*r*<=-<=1,<=*c*), while moving down means the pawn located in (*r*,<=*c*) will go to the cell (*r*<=+<=1,<=*c*). Again, the corresponding cell must be empty, i.e. not occupied by any other pawn of any color.

Given the initial disposition of the board, determine who wins the game if both players play optimally. Note that there will always be a winner due to the restriction that for any game scenario both players will have some moves available.","The input consists of the board description given in eight lines, each line contains eight characters. Character 'B' is used to denote a black pawn, and character 'W' represents a white pawn. Empty cell is marked with '.'. 

It's guaranteed that there will not be white pawns on the first row neither black pawns on the last row.","Print 'A' if player A wins the game on the given board, and 'B' if player B will claim the victory. Again, it's guaranteed that there will always be a winner on the given board.","['........\n........\n.B....B.\n....W...\n........\n..W.....\n........\n........\n', '..B.....\n..W.....\n......B.\n........\n.....W..\n......B.\n........\n........\n']","['A\n', 'B\n']","In the first sample player A is able to complete his goal in 3 steps by always moving a pawn initially located at (4, 5). Player B needs at least 5 steps for any of his pawns to reach the row 8. Hence, player A will be the winner.",OK,"grid = []
for k in range(8):
    grid.append(input())

bbc = [] #blocked black columns
bwc = [] #blocked white columns

#first processing : downwards


white = 8
for k in range(8):
    for j in range(8):
        if grid[k][j] == ""B"":
            bbc.append(j)
        if grid[k][j] == ""W"" and not j in bbc and white == 8:
            white = k

black = 8
for k in range(7,-1,-1):
    for j in range(8):
        if grid[k][j] == ""W"":
            bwc.append(j)
        if grid[k][j] == ""B"" and not j in bwc and black == 8:
            black = 7-k

if white <= black:
    print(""A"")
else:
    print(""B"")
","from collections import defaultdict

n = int(input())
s = input()

# Count of keys we have and the doors we encounter
keys_count = defaultdict(int)
needed_keys = set()

# Traverse the rooms and corresponding doors
for i in range(n-1):
    key = s[2 * i]        # Key in current room
    door = s[2 * i + 1]   # Door to the next room

    # Increase count of available keys
    keys_count[key] += 1

    # Check if we need to open the door
    if door not in (key.upper(),):  # If we don’t have the key for this door
        needed_keys.add(door)        # Add this door type to needed keys

# Calculate how many keys we need to buy
needed_keys_count = len(needed_keys - keys_count.keys())

# Add the total keys needed for the doors we can’t open
count = needed_keys_count + sum(max(0, needed_keys.count(door) - keys_count[door.lower()]) for door in needed_keys)

print(count)"
432,A,Choosing Teams,PROGRAMMING,"['greedy', 'implementation', 'sortings']","The Saratov State University Olympiad Programmers Training Center (SSU OPTC) has *n* students. For each student you know the number of times he/she has participated in the ACM ICPC world programming championship. According to the ACM ICPC rules, each person can participate in the world championship at most 5 times.

The head of the SSU OPTC is recently gathering teams to participate in the world championship. Each team must consist of exactly three people, at that, any person cannot be a member of two or more teams. What maximum number of teams can the head make if he wants each team to participate in the world championship with the same members at least *k* times?","The first line contains two integers, *n* and *k* (1<=≤<=*n*<=≤<=2000; 1<=≤<=*k*<=≤<=5). The next line contains *n* integers: *y*1,<=*y*2,<=...,<=*y**n* (0<=≤<=*y**i*<=≤<=5), where *y**i* shows the number of times the *i*-th person participated in the ACM ICPC world championship.",Print a single number — the answer to the problem.,"['5 2\n0 4 5 1 0\n', '6 4\n0 1 2 3 4 5\n', '6 5\n0 0 0 0 0 0\n']","['1\n', '0\n', '2\n']","In the first sample only one team could be made: the first, the fourth and the fifth participants.

In the second sample no teams could be created.

In the third sample two teams could be created. Any partition into two teams fits.",OK,"n,k = list(map(int,input().split()))
arr = list(map(int,input().split()))
for i in range(n):
    arr[i] = (5-arr[i])-k
ans = 0
for i in range(n):
    if arr[i] >=0:
        ans += 1
print(ans//3)
    
    ","n, a, b = [int(x) for x in input().split()]

flag = False
if b > a:
    a, b = b, a
    flag = True

def possible(n, a, b):
    # Check if it's possible to have the required components
    if a + b > n + 1 or (a == 1 and b == 1):
        return False
    return True

if not possible(n, a, b):
    print(""NO"")
else:
    print(""YES"")
    # Initialize adjacency matrix with all zeroes
    adj_matrix = [[0] * n for _ in range(n)]

    # Create the required components in the graph
    for i in range(a):
        for j in range(i + 1, a):
            if i < j:
                adj_matrix[i][j] = 1
                adj_matrix[j][i] = 1

    # Fill the remaining vertices in a single connected component
    for i in range(a, n):
        adj_matrix[a - 1][i] = 1
        adj_matrix[i][a - 1] = 1

    # Print the adjacency matrix
    for row in adj_matrix:
        print(' '.join(map(str, row)))"
837,B,Flag of Berland,PROGRAMMING,"['brute force', 'implementation']","The flag of Berland is such rectangular field *n*<=×<=*m* that satisfies following conditions:
 -  Flag consists of three colors which correspond to letters 'R', 'G' and 'B'. -  Flag consists of three equal in width and height stripes, parralel to each other and to sides of the flag. Each stripe has exactly one color. -  Each color should be used in exactly one stripe. 
You are given a field *n*<=×<=*m*, consisting of characters 'R', 'G' and 'B'. Output ""YES"" (without quotes) if this field corresponds to correct flag of Berland. Otherwise, print ""NO"" (without quotes).","The first line contains two integer numbers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=100) — the sizes of the field.

Each of the following *n* lines consisting of *m* characters 'R', 'G' and 'B' — the description of the field.","Print ""YES"" (without quotes) if the given field corresponds to correct flag of Berland . Otherwise, print ""NO"" (without quotes).","['6 5\nRRRRR\nRRRRR\nBBBBB\nBBBBB\nGGGGG\nGGGGG\n', '4 3\nBRG\nBRG\nBRG\nBRG\n', '6 7\nRRRGGGG\nRRRGGGG\nRRRGGGG\nRRRBBBB\nRRRBBBB\nRRRBBBB\n', '4 4\nRRRR\nRRRR\nBBBB\nGGGG\n']","['YES\n', 'YES\n', 'NO\n', 'NO\n']","The field in the third example doesn't have three parralel stripes.

Rows of the field in the fourth example are parralel to each other and to borders. But they have different heights — 2, 1 and 1.",WRONG_ANSWER,"# KALAM
n , m = map(int , input().split())
l = []
for i in range(n):
    l.append([])
    s = input()
    for j in s:
        l[i].append(j)
A = 'YES'
a = True;b = True
if(n % 3 != 0 and m % 3 != 0):A = 'NO'
if(n % 3 == 0):
    s = l[0][0]
    for i in range(n // 3):
        for j in range(m):
            if(l[i][j] != s):
                a = False
    s = l[n // 3][0]
    for i in range(n // 3 , n // 3 * 2):
        for j in range(m):
            if(l[i][j] != s):
                a = False
    s = l[n // 3 * 2][0]
    for i in range(n // 3 * 2 , n):
        for j in range(m):
            if(l[i][j] != s):
                a = False
else :a = False
if(m % 3 == 0):
    s = l[0][0]
    for i in range(n):
        for j in range(m // 3):
            if(l[i][j] != s):
                b = False
    s = l[0][m // 3]
    for i in range(n):
        for j in range(m // 3 , m // 3 * 2):
            if(l[i][j] != s):
                b = False
    s = l[0][m // 3 * 2]
    for i in range(n):
        for j in range(m // 3 * 2 , m):
            if(l[i][j] != s):
                b = False
else :b = False
if((not a) and (not b) ):
    A = 'NO'
print(A)
","v_num = int(input())
graph = list(map(lambda x: int(x), input().split("" "")))
coloring = list(map(lambda x: int(x), input().split("" "")))

# Build the tree structure using adjacency list
tree = dict()
for i in range(1, v_num + 1):
    tree[i] = []

for i in range(2, v_num + 1):
    parent = graph[i - 2]
    tree[parent].append(i)

# Initialize the number of steps required for coloring
steps = 0

# Function to perform DFS and count the necessary steps
def dfs(vertex, current_color):
    global steps
    target_color = coloring[vertex - 1]
    
    # Check if the color of the current vertex is different from the parent
    if target_color != current_color:
        steps += 1
    
    # Recur for all the children
    for child in tree[vertex]:
        dfs(child, target_color)

# Start DFS from the root node (vertex 1) with color 0 (initial color)
dfs(1, 0)

# Output the result
print(steps)"
1009,E,Intercity Travelling,PROGRAMMING,"['combinatorics', 'math', 'probabilities']","Leha is planning his journey from Moscow to Saratov. He hates trains, so he has decided to get from one city to another by car.

The path from Moscow to Saratov can be represented as a straight line (well, it's not that straight in reality, but in this problem we will consider it to be straight), and the distance between Moscow and Saratov is $n$ km. Let's say that Moscow is situated at the point with coordinate $0$ km, and Saratov — at coordinate $n$ km.

Driving for a long time may be really difficult. Formally, if Leha has already covered $i$ kilometers since he stopped to have a rest, he considers the difficulty of covering $(i + 1)$-th kilometer as $a_{i + 1}$. It is guaranteed that for every $i \in [1, n - 1]$ $a_i \le a_{i + 1}$. The difficulty of the journey is denoted as the sum of difficulties of each kilometer in the journey.

Fortunately, there may be some rest sites between Moscow and Saratov. Every integer point from $1$ to $n - 1$ may contain a rest site. When Leha enters a rest site, he may have a rest, and the next kilometer will have difficulty $a_1$, the kilometer after it — difficulty $a_2$, and so on.

For example, if $n = 5$ and there is a rest site in coordinate $2$, the difficulty of journey will be $2a_1 + 2a_2 + a_3$: the first kilometer will have difficulty $a_1$, the second one — $a_2$, then Leha will have a rest, and the third kilometer will have difficulty $a_1$, the fourth — $a_2$, and the last one — $a_3$. Another example: if $n = 7$ and there are rest sites in coordinates $1$ and $5$, the difficulty of Leha's journey is $3a_1 + 2a_2 + a_3 + a_4$.

Leha doesn't know which integer points contain rest sites. So he has to consider every possible situation. Obviously, there are $2^{n - 1}$ different distributions of rest sites (two distributions are different if there exists some point $x$ such that it contains a rest site in exactly one of these distributions). Leha considers all these distributions to be equiprobable. He wants to calculate $p$ — the expected value of difficulty of his journey.

Obviously, $p \cdot 2^{n - 1}$ is an integer number. You have to calculate it modulo $998244353$.","The first line contains one number $n$ ($1 \le n \le 10^6$) — the distance from Moscow to Saratov.

The second line contains $n$ integer numbers $a_1$, $a_2$, ..., $a_n$ ($1 \le a_1 \le a_2 \le \dots \le a_n \le 10^6$), where $a_i$ is the difficulty of $i$-th kilometer after Leha has rested.","Print one number — $p \cdot 2^{n - 1}$, taken modulo $998244353$.","['2\n1 2\n', '4\n1 3 3 7\n']","['5\n', '60\n']",none,WRONG_ANSWER,"#/user/bin/python

if __name__ == '__main__':
    sum = 0
    _n = input()
    _s = input()
    s = _s.split(' ')
    n = int(_n)
    taxi = 0
    group3 = 0
    group2 = 0
    group1 = 0
    for i in range(0, n):
        if int(s[i]) == 4:
            taxi += 1
        elif int(s[i]) == 3:
            group3 += 1
        elif int(s[i]) == 2:
            group2 += 1
        elif int(s[i]) == 1:
            group1 += 1
    print()
    if group2 >= 2:
        taxi += group2/2
        if group2%2 != 0:
            group2 = 1
        else:
            group2 = 0
    if group3 <= group1:
        taxi += group3
        group1 -= group3
    elif group3 > group1:
        taxi += group3
    if group1 >= 4:
        if group1%4 == 0:
            taxi += group1/4
    if (group2 > 0) or (group1 == 2) or (group1 == 1):
        taxi += group2
        group1 -= group2*2
    if group1 > 0:
        taxi += 1
    print(int(taxi))","from collections import defaultdict

(n, k) = map(int, input().split(' '))
nums = list(map(int, input().split(' ')))

# Calculate prefix sums for the absurdity values
prefix_sum = [0] * (n + 1)
for i in range(1, n + 1):
    prefix_sum[i] = prefix_sum[i - 1] + nums[i - 1]

# Store the maximum absurdity and its starting index for each segment of length k
max_segment = [0] * (n + 1)
best_start = [0] * (n + 1)
for i in range(n - k + 1):
    segment_sum = prefix_sum[i + k] - prefix_sum[i]
    if segment_sum > max_segment[i]:
        max_segment[i] = segment_sum
        best_start[i] = i + 1

# Now we will find two non-overlapping segments with maximum total absurdity
result = (0, 0)  # To store the best pair of segments
max_total_absurdity = 0

# Iterate to find the best two segments
for a in range(n - 2 * k + 2):  # Ensure space for two segments
    first_sum = max_segment[a]
    first_index = best_start[a]
    
    # Check for the second segment
    for b in range(a + k, n - k + 1):  # b should be after the end of first segment
        second_sum = max_segment[b]
        
        total_absurdity = first_sum + second_sum
        if total_absurdity > max_total_absurdity:
            max_total_absurdity = total_absurdity
            result = (first_index, best_start[b])

# Print the result
print(result[0], result[1])"
960,C,Subsequence Counting,PROGRAMMING,"['bitmasks', 'constructive algorithms', 'greedy', 'implementation']","Pikachu had an array with him. He wrote down all the non-empty subsequences of the array on paper. Note that an array of size *n* has 2*n*<=-<=1 non-empty subsequences in it. 

Pikachu being mischievous as he always is, removed all the subsequences in which Maximum_element_of_the_subsequence <=-<= Minimum_element_of_subsequence <=≥<=*d*

Pikachu was finally left with *X* subsequences. 

However, he lost the initial array he had, and now is in serious trouble. He still remembers the numbers *X* and *d*. He now wants you to construct any such array which will satisfy the above conditions. All the numbers in the final array should be positive integers less than 1018. 

Note the number of elements in the output array should not be more than 104. If no answer is possible, print <=-<=1.","The only line of input consists of two space separated integers *X* and *d* (1<=≤<=*X*,<=*d*<=≤<=109).","Output should consist of two lines.

First line should contain a single integer *n* (1<=≤<=*n*<=≤<=10<=000)— the number of integers in the final array.

Second line should consist of *n* space separated integers — *a*1,<=*a*2,<=... ,<=*a**n* (1<=≤<=*a**i*<=&lt;<=1018).

If there is no answer, print a single integer -1. If there are multiple answers, print any of them.","['10 5\n', '4 2\n']","['6\n5 50 7 15 6 100', '4\n10 100 1000 10000']","In the output of the first example case, the remaining subsequences after removing those with Maximum_element_of_the_subsequence  -  Minimum_element_of_subsequence  ≥ 5 are [5], [5, 7], [5, 6], [5, 7, 6], [50], [7], [7, 6], [15], [6], [100]. There are 10 of them. Hence, the array [5, 50, 7, 15, 6, 100] is valid.

Similarly, in the output of the second example case, the remaining sub-sequences after removing those with Maximum_element_of_the_subsequence  -  Minimum_element_of_subsequence  ≥ 2 are [10], [100], [1000], [10000]. There are 4 of them. Hence, the array [10, 100, 1000, 10000] is valid.",TIME_LIMIT_EXCEEDED,"n,d=map(int,input().split())
print(n)
s=1
for i in range(n):
    print(s,end=' ')
    s+=d+1
","# http://codeforces.com/contest/667/problem/C

s = input()
n = len(s)
ans = {s[n - 2:n], s[n - 3:n]}  # Initialize with last two and three characters
checked = set()

# Traverse the string from start to the last 4 characters
for i in range(n - 3):
    substring = s[i:i + 2]  # Take 2 characters
    if substring not in checked:  # Check if we haven't seen it before
        ans.add(substring)  # Add to our answer set
        checked.add(substring)  # Mark it as checked
    substring = s[i:i + 3]  # Take 3 characters
    if substring not in checked:  # Check for 3 character substring
        ans.add(substring)  # Add to our answer set
        checked.add(substring)  # Mark as checked

# Output the results
print(len(ans))  # Print the number of distinct suffixes
for suffix in sorted(ans):  # Print the suffixes in lexicographical order
    print(suffix)"
886,B,Vlad and Cafes,PROGRAMMING,[],"Vlad likes to eat in cafes very much. During his life, he has visited cafes *n* times. Unfortunately, Vlad started to feel that his last visits are not any different from each other. To fix that Vlad had a small research.

First of all, Vlad assigned individual indices to all cafes. Then, he wrote down indices of cafes he visited in a row, in order of visiting them. Now, Vlad wants to find such a cafe that his last visit to that cafe was before his last visits to every other cafe. In other words, he wants to find such a cafe that he hasn't been there for as long as possible. Help Vlad to find that cafe.","In first line there is one integer *n* (1<=≤<=*n*<=≤<=2·105) — number of cafes indices written by Vlad.

In second line, *n* numbers *a*1,<=*a*2,<=...,<=*a**n* (0<=≤<=*a**i*<=≤<=2·105) are written — indices of cafes in order of being visited by Vlad. Vlad could visit some cafes more than once. Note that in numeration, some indices could be omitted.",Print one integer — index of the cafe that Vlad hasn't visited for as long as possible.,"['5\n1 3 2 1 2\n', '6\n2 1 2 2 4 1\n']","['3\n', '2\n']","In first test, there are three cafes, and the last visits to cafes with indices 1 and 2 were after the last visit to cafe with index 3; so this cafe is the answer. 

In second test case, there are also three cafes, but with indices 1, 2 and 4. Cafes with indices 1 and 4 were visited after the last visit of cafe with index 2, so the answer is 2. Note that Vlad could omit some numbers while numerating the cafes.",RUNTIME_ERROR,"n = int(input())
cafes = [int(x) for x in input().split()]
for i in range(n-1):
    e =cafes[i]
    for j in range(i,n):
        if cafes[i] == cafes[j]:
            e = cafes[j+1]
print(e)","def solve():
    import sys
    
    input = sys.stdin.read
    data = input().splitlines()
    
    # Read n and m
    n, m = map(int, data[0].split())
    
    # Read the number of pieces in each puzzle
    f = list(map(int, data[1].split()))
    
    # Initialize the minimum difference to a large number
    min_diff = float('inf')
    
    # We will only check combinations of n puzzles
    for i in range(m - n + 1):
        # The largest and smallest are at the ends of this slice of size n
        A = f[i + n - 1] # Largest in the current selection
        B = f[i]         # Smallest in the current selection
        current_diff = A - B
        
        # Minimize the difference
        min_diff = min(min_diff, current_diff)
    
    # Output the minimum difference found
    print(min_diff)"
61,A,Ultra-Fast Mathematician,PROGRAMMING,['implementation'],"Shapur was an extremely gifted student. He was great at everything including Combinatorics, Algebra, Number Theory, Geometry, Calculus, etc. He was not only smart but extraordinarily fast! He could manage to sum 1018 numbers in a single second.

One day in 230 AD Shapur was trying to find out if any one can possibly do calculations faster than him. As a result he made a very great contest and asked every one to come and take part.

In his contest he gave the contestants many different pairs of numbers. Each number is made from digits 0 or 1. The contestants should write a new number corresponding to the given pair of numbers. The rule is simple: The *i*-th digit of the answer is 1 if and only if the *i*-th digit of the two given numbers differ. In the other case the *i*-th digit of the answer is 0.

Shapur made many numbers and first tried his own speed. He saw that he can perform these operations on numbers of length ∞ (length of a number is number of digits in it) in a glance! He always gives correct answers so he expects the contestants to give correct answers, too. He is a good fellow so he won't give anyone very big numbers and he always gives one person numbers of same length.

Now you are going to take part in Shapur's contest. See if you are faster and more accurate.",There are two lines in each input. Each of them contains a single number. It is guaranteed that the numbers are made from 0 and 1 only and that their length is same. The numbers may start with 0. The length of each number doesn't exceed 100.,Write one line — the corresponding answer. Do not omit the leading 0s.,"['1010100\n0100101\n', '000\n111\n', '1110\n1010\n', '01110\n01100\n']","['1110001\n', '111\n', '0100\n', '00010\n']",none,WRONG_ANSWER,"a = int(input())
b = int(input())
d = int(str(a), 2)
e = int(str(b), 2)
c = d ^ e
e = bin(c)[2:]
print((""0""*(len(str(a))-len(e))+e))
","def slv(x):
    MOD = 1000000007
    return x % MOD

def sequence_value(x, y, n):
    # Using a list to store computed values for f(n)
    f = [0] * 6
    f[1] = x % MOD
    f[2] = y % MOD
    f[3] = (y - x) % MOD
    f[4] = (-y) % MOD
    f[5] = (-x) % MOD
    
    # Calculate the result based on n mod 6
    if n % 6 == 1:
        return slv(f[1])
    elif n % 6 == 2:
        return slv(f[2])
    elif n % 6 == 3:
        return slv(f[3])
    elif n % 6 == 4:
        return slv(f[4])
    elif n % 6 == 5:
        return slv(f[5])
    else:
        return 0  # f(n) for n % 6 == 0, which is 0 according to the sequence behavior

# Read input values
if __name__ == ""__main__"":
    x, y = map(int, input().split())
    n = int(input())
    result = sequence_value(x, y, n)
    print(result)"
1011,A,Stages,PROGRAMMING,"['greedy', 'implementation', 'sortings']","Natasha is going to fly to Mars. She needs to build a rocket, which consists of several stages in some order. Each of the stages is defined by a lowercase Latin letter. This way, the rocket can be described by the string — concatenation of letters, which correspond to the stages.

There are $n$ stages available. The rocket must contain exactly $k$ of them. Stages in the rocket should be ordered by their weight. So, after the stage with some letter can go only stage with a letter, which is at least two positions after in the alphabet (skipping one letter in between, or even more). For example, after letter 'c' can't go letters 'a', 'b', 'c' and 'd', but can go letters 'e', 'f', ..., 'z'.

For the rocket to fly as far as possible, its weight should be minimal. The weight of the rocket is equal to the sum of the weights of its stages. The weight of the stage is the number of its letter in the alphabet. For example, the stage 'a 'weighs one ton,' b 'weighs two tons, and' z' — $26$ tons.

Build the rocket with the minimal weight or determine, that it is impossible to build a rocket at all. Each stage can be used at most once.","The first line of input contains two integers — $n$ and $k$ ($1 \le k \le n \le 50$) – the number of available stages and the number of stages to use in the rocket.

The second line contains string $s$, which consists of exactly $n$ lowercase Latin letters. Each letter defines a new stage, which can be used to build the rocket. Each stage can be used at most once.","Print a single integer — the minimal total weight of the rocket or -1, if it is impossible to build the rocket at all.","['5 3\nxyabd\n', '7 4\nproblem\n', '2 2\nab\n', '12 1\nabaabbaaabbb\n']","['29', '34', '-1', '1']","In the first example, the following rockets satisfy the condition:
-  ""adx"" (weight is $1+4+24=29$);-  ""ady"" (weight is $1+4+25=30$);-  ""bdx"" (weight is $2+4+24=30$);-  ""bdy"" (weight is $2+4+25=31$).
Rocket ""adx"" has the minimal weight, so the answer is $29$.

In the second example, target rocket is ""belo"". Its weight is $2+5+12+15=34$.

In the third example, $n=k=2$, so the rocket must have both stages: 'a' and 'b'. This rocket doesn't satisfy the condition, because these letters are adjacent in the alphabet. Answer is -1.",WRONG_ANSWER,"def mi():
    return map(int, input().split())
n,k = mi()
s = list(input())
s.sort()
for i in range(n):
    s[i] = ord(s[i])-ord('a')+1
ans = s[0]
k-=1
for i in range(1,n):
    if not k:
        break
    if s[i]-s[i-1]>1:
        ans+=s[i]
        k-=1
if k:
    print (-1)
else:
    print(ans)
	 				        	  	   		   	 	 	","def main():
    n = int(input())
    aa = list(map(int, input().split()))
    m = min(aa)  # Get the minimum amount of paint in any jar

    # Calculate total liters of paint available
    total_paint = sum(aa)

    # The total number of complete cycles (1 to n) that can be painted
    full_cycles = total_paint // n

    # Number of squares painted in full cycles
    painted_squares = full_cycles * n

    # Calculate remaining paint after full cycles
    remaining_paint = total_paint % n

    # The maximum additional squares that can be painted with the remaining paint
    additional_squares = min(remaining_paint, m)

    # Total maximum squares painted
    max_squares = painted_squares + additional_squares

    print(max_squares)

if __name__ == ""__main__"":
    main()"
721,C,Journey,PROGRAMMING,"['dp', 'graphs']","Recently Irina arrived to one of the most famous cities of Berland — the Berlatov city. There are *n* showplaces in the city, numbered from 1 to *n*, and some of them are connected by one-directional roads. The roads in Berlatov are designed in a way such that there are no cyclic routes between showplaces.

Initially Irina stands at the showplace 1, and the endpoint of her journey is the showplace *n*. Naturally, Irina wants to visit as much showplaces as she can during her journey. However, Irina's stay in Berlatov is limited and she can't be there for more than *T* time units.

Help Irina determine how many showplaces she may visit during her journey from showplace 1 to showplace *n* within a time not exceeding *T*. It is guaranteed that there is at least one route from showplace 1 to showplace *n* such that Irina will spend no more than *T* time units passing it.","The first line of the input contains three integers *n*,<=*m* and *T* (2<=≤<=*n*<=≤<=5000,<=<=1<=≤<=*m*<=≤<=5000,<=<=1<=≤<=*T*<=≤<=109) — the number of showplaces, the number of roads between them and the time of Irina's stay in Berlatov respectively.

The next *m* lines describes roads in Berlatov. *i*-th of them contains 3 integers *u**i*,<=*v**i*,<=*t**i* (1<=≤<=*u**i*,<=*v**i*<=≤<=*n*,<=*u**i*<=≠<=*v**i*,<=1<=≤<=*t**i*<=≤<=109), meaning that there is a road starting from showplace *u**i* and leading to showplace *v**i*, and Irina spends *t**i* time units to pass it. It is guaranteed that the roads do not form cyclic routes.

It is guaranteed, that there is at most one road between each pair of showplaces.","Print the single integer *k* (2<=≤<=*k*<=≤<=*n*) — the maximum number of showplaces that Irina can visit during her journey from showplace 1 to showplace *n* within time not exceeding *T*, in the first line.

Print *k* distinct integers in the second line — indices of showplaces that Irina will visit on her route, in the order of encountering them.

If there are multiple answers, print any of them.","['4 3 13\n1 2 5\n2 3 7\n2 4 8\n', '6 6 7\n1 2 2\n1 3 3\n3 6 3\n2 4 2\n4 6 2\n6 5 1\n', '5 5 6\n1 3 3\n3 5 3\n1 2 2\n2 4 3\n4 5 2\n']","['3\n1 2 4 \n', '4\n1 2 4 6 \n', '3\n1 3 5 \n']",none,TIME_LIMIT_EXCEEDED,"from sys import stdout
from sys import stdin
def get():
    return stdin.readline().strip()
def getf():
    return [int(i) for i in get().split()]
def put(a, end = ""\n""):
    stdout.write(str(a) + end)
def putf(a, sep = "" "", end = ""\n""):
    stdout.write(sep.join([str(i) for i in a]) + end)
 
#from collections import defaultdict as dd
def bruh():
    n, m, t = getf()
    g = [[] for i in range(n + 1)]
    for i in range(m):
        v, u, ti = getf()
        g[v].append([u, ti])
        #g[u].append([v, ti])
    inf = 10 ** 18 + 7
    a = [[inf] * (n + 1) for i in range(n + 1)]
    a[1][0] = 0
    ans = 0
    par = dict()
    for k in range(1, n + 1):
        for i in range(1, n + 1):
            for e in g[i]:
                if(a[e[0]][k] > a[i][k - 1] + e[1]):
                    a[e[0]][k] = a[i][k - 1] + e[1]
                    par[e[0], k] = i
    res = 0
    for j in range(1, n + 1):
        if(a[n][j] <= t):
            res = j
    put(res + 1)
    ans = [n]
    cur = n
    #print(res, par)
    while(cur != 1):
        ans.append(par[cur, res])
        cur = par[cur, res]
        res -= 1
    #for i in a:
    #    putf(i)
    putf(ans[ :: -1])
bruh()
","from collections import Counter
import re

def generate_permutation(n):
    # Create a permutation of integers from 1 to n
    permutation = list(range(1, n + 1))
    
    # Reverse the permutation to demonstrate the sorting logic
    permutation.reverse()
    
    return permutation

n = int(input().strip())
result = generate_permutation(n)
print("" "".join(map(str, result)))"
964,A,Splits,PROGRAMMING,['math'],"Let's define a split of $n$ as a nonincreasing sequence of positive integers, the sum of which is $n$. 

For example, the following sequences are splits of $8$: $[4, 4]$, $[3, 3, 2]$, $[2, 2, 1, 1, 1, 1]$, $[5, 2, 1]$.

The following sequences aren't splits of $8$: $[1, 7]$, $[5, 4]$, $[11, -3]$, $[1, 1, 4, 1, 1]$.

The weight of a split is the number of elements in the split that are equal to the first element. For example, the weight of the split $[1, 1, 1, 1, 1]$ is $5$, the weight of the split $[5, 5, 3, 3, 3]$ is $2$ and the weight of the split $[9]$ equals $1$.

For a given $n$, find out the number of different weights of its splits.",The first line contains one integer $n$ ($1 \leq n \leq 10^9$).,Output one integer — the answer to the problem.,"['7\n', '8\n', '9\n']","['4\n', '5\n', '5\n']","In the first sample, there are following possible weights of splits of $7$:

Weight 1: [$\textbf 7$] 

Weight 2: [$\textbf 3$, $\textbf 3$, 1] 

Weight 3: [$\textbf 2$, $\textbf 2$, $\textbf 2$, 1] 

Weight 7: [$\textbf 1$, $\textbf 1$, $\textbf 1$, $\textbf 1$, $\textbf 1$, $\textbf 1$, $\textbf 1$]",COMPILATION_ERROR,"#include <bits/stdc++.h>
using namespace std;
#define ll long long

int main() {
    int n ;
    cin >> n ;

    ll x = n/2 + 1 ;
    cout<<x;


    return 0;
}","def main():
    cnt1, cnt2, x, y = list(map(int, input().split()))
    l, r = -1, 10**18

    while l + 1 < r:
        v = (l + r) // 2
        first_friend = []
        second_friend = []
        
        # Find numbers for the first friend
        for num in range(1, v + 1):
            if num % x != 0:
                first_friend.append(num)
            if len(first_friend) == cnt1:
                break
        
        # Find numbers for the second friend
        for num in range(1, v + 1):
            if num % y != 0 and num not in first_friend:
                second_friend.append(num)
            if len(second_friend) == cnt2:
                break
        
        # Check if we managed to find enough numbers for both friends
        if len(first_friend) >= cnt1 and len(second_friend) >= cnt2:
            r = v
        else:
            l = v

    print(r)

if __name__ == ""__main__"":
    main()"
595,A,Vitaly and Night,PROGRAMMING,"['constructive algorithms', 'implementation']","One day Vitaly was going home late at night and wondering: how many people aren't sleeping at that moment? To estimate, Vitaly decided to look which windows are lit in the house he was passing by at that moment.

Vitaly sees a building of *n* floors and 2·*m* windows on each floor. On each floor there are *m* flats numbered from 1 to *m*, and two consecutive windows correspond to each flat. If we number the windows from 1 to 2·*m* from left to right, then the *j*-th flat of the *i*-th floor has windows 2·*j*<=-<=1 and 2·*j* in the corresponding row of windows (as usual, floors are enumerated from the bottom). Vitaly thinks that people in the flat aren't sleeping at that moment if at least one of the windows corresponding to this flat has lights on.

Given the information about the windows of the given house, your task is to calculate the number of flats where, according to Vitaly, people aren't sleeping.","The first line of the input contains two integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=100) — the number of floors in the house and the number of flats on each floor respectively.

Next *n* lines describe the floors from top to bottom and contain 2·*m* characters each. If the *i*-th window of the given floor has lights on, then the *i*-th character of this line is '1', otherwise it is '0'.","Print a single integer — the number of flats that have lights on in at least one window, that is, the flats where, according to Vitaly, people aren't sleeping.","['2 2\n0 0 0 1\n1 0 1 1\n', '1 3\n1 1 0 1 0 0\n']","['3\n', '2\n']","In the first test case the house has two floors, two flats on each floor. That is, in total there are 4 flats. The light isn't on only on the second floor in the left flat. That is, in both rooms of the flat the light is off.

In the second test case the house has one floor and the first floor has three flats. The light is on in the leftmost flat (in both windows) and in the middle flat (in one window). In the right flat the light is off.",OK,"n,m=list(map(int,input().split()))
c=0
for i in range(n):
  l=list(map(int,input().split()))
  for i in range(0,len(l),2):
    if l[i]==0 and l[i+1]==1 or l[i]==1 and l[i+1]==1 or l[i]==1 and l[i+1]==0:
      c+=1
      i+=1
    #i+=1
print(c)","a, b = map(int, input().split())

# The GCD of A! and B! is determined by the factorial of the smaller of the two numbers.
# This is because factorials grow very fast and A! contains all the factors of B! if A >= B.
gcd_factorial = min(a, b)

# Calculate the factorial of gcd_factorial.
result = 1
for i in range(1, gcd_factorial + 1):
    result *= i

# Print the result, which is GCD(A!, B!).
print(result)"
44,C,Holidays,PROGRAMMING,['implementation'],"School holidays come in Berland. The holidays are going to continue for *n* days. The students of school №*N* are having the time of their lives and the IT teacher Marina Sergeyevna, who has spent all the summer busy checking the BSE (Berland State Examination) results, has finally taken a vacation break! Some people are in charge of the daily watering of flowers in shifts according to the schedule. However when Marina Sergeyevna was making the schedule, she was so tired from work and so lost in dreams of the oncoming vacation that she perhaps made several mistakes. In fact, it is possible that according to the schedule, on some days during the holidays the flowers will not be watered or will be watered multiple times. Help Marina Sergeyevna to find a mistake.","The first input line contains two numbers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=100) — the number of days in Berland holidays and the number of people in charge of the watering respectively. The next *m* lines contain the description of the duty schedule. Each line contains two integers *a**i* and *b**i* (1<=≤<=*a**i*<=≤<=*b**i*<=≤<=*n*), meaning that the *i*-th person in charge should water the flowers from the *a**i*-th to the *b**i*-th day inclusively, once a day. The duty shifts are described sequentially, i.e. *b**i*<=≤<=*a**i*<=+<=1 for all *i* from 1 to *n*<=-<=1 inclusively.","Print ""OK"" (without quotes), if the schedule does not contain mistakes. Otherwise you have to find the minimal number of a day when the flowers will not be watered or will be watered multiple times, and output two integers — the day number and the number of times the flowers will be watered that day.","['10 5\n1 2\n3 3\n4 6\n7 7\n8 10\n', '10 5\n1 2\n2 3\n4 5\n7 8\n9 10\n', '10 5\n1 2\n3 3\n5 7\n7 7\n7 10\n']","['OK\n', '2 2\n', '4 0\n']","Keep in mind that in the second sample the mistake occurs not only on the second day, but also on the sixth day, when nobody waters the flowers. However, you have to print the second day, i.e. the day with the minimal number.",OK,"n,m = map(int,input().split())
Ln = [0]*n
while m!=0:
    a,b = map(int,input().split())
    for i in range(a,b+1):
        Ln[i-1]+=1
    m-=1
for i in range(0,len(Ln)):
    if Ln[i]==0 :
        print(i+1,0)
        exit(0)
    elif Ln[i]>1:
        print(i+1,Ln[i])
        exit(0)
print('OK')
exit(0)
        
        
","# Author: S Mahesh Raju
# Username: maheshraju2020
# Created on: 25/09/2020 02:59:49

from sys import stdin, stdout, setrecursionlimit
import heapq
from math import gcd, ceil, sqrt
from collections import Counter, deque

def bfs(graph, start):
    visited = {start}
    queue = deque([start])
    distances = {start: 0}
    
    while queue:
        node = queue.popleft()
        for neighbor in graph[node]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
                distances[neighbor] = distances[node] + 1
                
    return max(distances.values())

def max_distance(spiders):
    max_length = 0
    
    for spider in spiders:
        n, edges = spider
        graph = {i: [] for i in range(1, n + 1)}
        
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)
        
        # Get the maximum distance from any bead to any other bead in the spider
        length = bfs(graph, 1)
        max_length = max(max_length, length)
    
    return max_length

def main():
    n = int(stdin.readline().strip())
    spiders = []
    
    for _ in range(n):
        data = list(map(int, stdin.readline().strip().split()))
        spider_edges = [(data[i], data[i + 1]) for i in range(1, len(data), 2)]
        spiders.append((data[0], spider_edges))
    
    result = max_distance(spiders)
    stdout.write(f""{result}\n"")

if __name__ == ""__main__"":
    main()"
446,C,DZY Loves Fibonacci Numbers,PROGRAMMING,"['data structures', 'math', 'number theory']","In mathematical terms, the sequence *F**n* of Fibonacci numbers is defined by the recurrence relation 

DZY loves Fibonacci numbers very much. Today DZY gives you an array consisting of *n* integers: *a*1,<=*a*2,<=...,<=*a**n*. Moreover, there are *m* queries, each query has one of the two types:
 1.  Format of the query ""1 *l* *r*"". In reply to the query, you need to add *F**i*<=-<=*l*<=+<=1 to each element *a**i*, where *l*<=≤<=*i*<=≤<=*r*. 1.  Format of the query ""2 *l* *r*"". In reply to the query you should output the value of  modulo 1000000009 (109<=+<=9). 
Help DZY reply to all the queries.","The first line of the input contains two integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=300000). The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=109) — initial array *a*.

Then, *m* lines follow. A single line describes a single query in the format given in the statement. It is guaranteed that for each query inequality 1<=≤<=*l*<=≤<=*r*<=≤<=*n* holds.","For each query of the second type, print the value of the sum on a single line.",['4 4\n1 2 3 4\n1 1 4\n2 1 4\n1 2 4\n2 1 3\n'],['17\n12\n'],"After the first query, *a* = [2, 3, 5, 7].

For the second query, *sum* = 2 + 3 + 5 + 7 = 17.

After the third query, *a* = [2, 4, 6, 9].

For the fourth query, *sum* = 2 + 4 + 6 = 12.",RUNTIME_ERROR,"n = int(input())
arr = [int(s) for s in input().split()]

s = sum(arr)

t = []

if s % 3 == 0:
    sum = 0
    for i in range(n):
        sum += arr[i]
        v = (0 if len(t) < 1 else t[len(t) - 1]) + (1 if sum == s // 3 else 0)
        t.append(v)
    res = 0
    sum = arr[0]
    for i in range(1, n - 1):
        sum += arr[i]
        if sum == 2 * s // 3:
            res += t[i - 1]
    print(res)
else:
    print(0)
","def maxbook(n, time, data):
    start = 0
    end = 0
    sumtime = data[0]
    max_books = 0

    while end < n:
        # If we have enough time to read the current book
        if sumtime <= time:
            max_books = max(max_books, end - start + 1)
            end += 1
            if end < n:
                sumtime += data[end]  # Add the next book's time
        else:
            sumtime -= data[start]  # Remove the time of the book at the start
            start += 1

    return max_books

# Example usage:
# n, t = map(int, input().split())
# data = list(map(int, input().split()))
# print(maxbook(n, t, data))"
612,C,Replace To Make Regular Bracket Sequence,PROGRAMMING,"['data structures', 'expression parsing', 'math']","You are given string *s* consists of opening and closing brackets of four kinds &lt;&gt;, {}, [], (). There are two types of brackets: opening and closing. You can replace any bracket by another of the same type. For example, you can replace &lt; by the bracket {, but you can't replace it by ) or &gt;.

The following definition of a regular bracket sequence is well-known, so you can be familiar with it.

Let's define a regular bracket sequence (RBS). Empty string is RBS. Let *s*1 and *s*2 be a RBS then the strings &lt;*s*1&gt;*s*2, {*s*1}*s*2, [*s*1]*s*2, (*s*1)*s*2 are also RBS.

For example the string ""[[(){}]&lt;&gt;]"" is RBS, but the strings ""[)()"" and ""][()()"" are not.

Determine the least number of replaces to make the string *s* RBS.","The only line contains a non empty string *s*, consisting of only opening and closing brackets of four kinds. The length of *s* does not exceed 106.","If it's impossible to get RBS from *s* print Impossible.

Otherwise print the least number of replaces needed to get RBS from *s*.","['[&lt;}){}\n', '{()}[]\n', ']]\n']","['2', '0', 'Impossible']",none,WRONG_ANSWER,"R = lambda: list(map(int,input().split()))
s = input()
ok = True
ans = 0
st = []
opn = set(""<[({"")
inv = {'}':'{', ')':'(', '>':'<', ']':'['}
for i in s:
    if i in opn:
        st.append(i)
    else:
        if not st:
            ok = False
            break
        if inv[i]!=st[-1]: ans += 1
        st.pop()
if not ok: print(""Impossible"")
else: print(ans)","# Read the number of drinks
n = int(input())

# Read the percentage of orange juice in each drink
p = list(map(int, input().split()))

# Calculate the total percentage of orange juice
total_percentage = sum(p)

# Calculate the volume fraction of orange juice in the cocktail
volume_fraction = total_percentage / n

# Print the result
print(volume_fraction)"
732,A,Buy a Shovel,PROGRAMMING,"['brute force', 'constructive algorithms', 'implementation', 'math']","Polycarp urgently needs a shovel! He comes to the shop and chooses an appropriate one. The shovel that Policarp chooses is sold for *k* burles. Assume that there is an unlimited number of such shovels in the shop.

In his pocket Polycarp has an unlimited number of ""10-burle coins"" and exactly one coin of *r* burles (1<=≤<=*r*<=≤<=9).

What is the minimum number of shovels Polycarp has to buy so that he can pay for the purchase without any change? It is obvious that he can pay for 10 shovels without any change (by paying the requied amount of 10-burle coins and not using the coin of *r* burles). But perhaps he can buy fewer shovels and pay without any change. Note that Polycarp should buy at least one shovel.","The single line of input contains two integers *k* and *r* (1<=≤<=*k*<=≤<=1000, 1<=≤<=*r*<=≤<=9) — the price of one shovel and the denomination of the coin in Polycarp's pocket that is different from ""10-burle coins"". 

Remember that he has an unlimited number of coins in the denomination of 10, that is, Polycarp has enough money to buy any number of shovels.",Print the required minimum number of shovels Polycarp has to buy so that he can pay for them without any change.,"['117 3\n', '237 7\n', '15 2\n']","['9\n', '1\n', '2\n']","In the first example Polycarp can buy 9 shovels and pay 9·117 = 1053 burles. Indeed, he can pay this sum by using 10-burle coins and one 3-burle coin. He can't buy fewer shovels without any change.

In the second example it is enough for Polycarp to buy one shovel.

In the third example Polycarp should buy two shovels and pay 2·15 = 30 burles. It is obvious that he can pay this sum without any change.",OK,"inp = input().split()
inp = [int(x) for x in inp]
a=0
for i in range(15):
      if(i>0):
            if(inp[0]%10==0 or (inp[0]-inp[1])%10==0 or ((inp[0]*i)-inp[1])%10==0 or (inp[0]*i)%10==0):# :
                  a=i
                  break
print(a)","import sys

input = lambda: sys.stdin.buffer.readline().decode('utf-8').rstrip('\r\n')

from array import array

inp = lambda: int(input())
mi = lambda x=int: map(x, input().split())

# Read the number of towers
n = inp()

# Read the heights of the towers
heights = list(mi())

# Initialize operations counter
operations = 0

# Continue the process until all towers are destroyed
while True:
    # Identify boundary blocks
    boundary_found = False
    # Check the boundary condition for the leftmost tower
    if heights[0] > 0:
        boundary_found = True
        heights[0] -= 1
    # Check the boundary conditions for the towers in between
    for i in range(1, n - 1):
        if heights[i] > 0 and (heights[i - 1] == 0 or heights[i + 1] == 0):
            boundary_found = True
            heights[i] -= 1
    # Check the boundary condition for the rightmost tower
    if heights[n - 1] > 0:
        boundary_found = True
        heights[n - 1] -= 1

    # Increment the operations counter if any boundary blocks were found
    if boundary_found:
        operations += 1
    else:
        break

# Output the total number of operations needed
print(operations)"
252,A,Little Xor,PROGRAMMING,"['brute force', 'implementation']","Little Petya likes arrays that consist of non-negative integers a lot. Recently his mom has presented him one such array consisting of *n* elements. Petya immediately decided to find there a segment of consecutive elements, such that the *xor* of all numbers from this segment was maximal possible. Help him with that.

The *xor* operation is the bitwise exclusive ""OR"", that is denoted as ""xor"" in Pascal and ""^"" in C/C++/Java.",The first line contains integer *n* (1<=≤<=*n*<=≤<=100) — the number of elements in the array. The second line contains the space-separated integers from the array. All numbers are non-negative integers strictly less than 230.,Print a single integer — the required maximal *xor* of a segment of consecutive elements.,"['5\n1 2 1 1 2\n', '3\n1 2 7\n', '4\n4 2 4 8\n']","['3\n', '7\n', '14\n']","In the first sample one of the optimal segments is the segment that consists of the first and the second array elements, if we consider the array elements indexed starting from one.

The second sample contains only one optimal segment, which contains exactly one array element (element with index three).",COMPILATION_ERROR,"5
1912 1123
5 6213
999 11234
88 214
12 100124
","# -*- coding: utf-8 -*-
""""""
Created on Thu Oct 12 15:11:42 2023
""""""

# Read the input string from the user
situation = input().strip()

# Check for at least 7 consecutive '0's or '1's
if '0000000' in situation or '1111111' in situation:
    print(""YES"")
else:
    print(""NO"")"
602,B,Approximating a Constant Range,PROGRAMMING,"['dp', 'implementation', 'two pointers']","When Xellos was doing a practice course in university, he once had to measure the intensity of an effect that slowly approached equilibrium. A good way to determine the equilibrium intensity would be choosing a sufficiently large number of consecutive data points that seems as constant as possible and taking their average. Of course, with the usual sizes of data, it's nothing challenging — but why not make a similar programming contest problem while we're at it?

You're given a sequence of *n* data points *a*1,<=...,<=*a**n*. There aren't any big jumps between consecutive data points — for each 1<=≤<=*i*<=&lt;<=*n*, it's guaranteed that |*a**i*<=+<=1<=-<=*a**i*|<=≤<=1.

A range [*l*,<=*r*] of data points is said to be almost constant if the difference between the largest and the smallest value in that range is at most 1. Formally, let *M* be the maximum and *m* the minimum value of *a**i* for *l*<=≤<=*i*<=≤<=*r*; the range [*l*,<=*r*] is almost constant if *M*<=-<=*m*<=≤<=1.

Find the length of the longest almost constant range.","The first line of the input contains a single integer *n* (2<=≤<=*n*<=≤<=100<=000) — the number of data points.

The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=100<=000).",Print a single number — the maximum length of an almost constant range of the given sequence.,"['5\n1 2 3 3 2\n', '11\n5 4 5 5 6 7 8 8 8 7 6\n']","['4\n', '5\n']","In the first sample, the longest almost constant range is [2, 5]; its length (the number of data points in it) is 4.

In the second sample, there are three almost constant ranges of length 4: [1, 4], [6, 9] and [7, 10]; the only almost constant range of the maximum length 5 is [6, 10].",TIME_LIMIT_EXCEEDED,"
# Approximating a Constant Range


def calculate_constant_range(data_points, n):
    i = 0
    const_max = 0
    while i <= n - const_max:
        temp_lst = []
        count = 0
        j = i
        while j < n:
            if data_points[j] not in temp_lst:
                temp_lst.append(data_points[j])
                if len(temp_lst) > 2:
                    break
            count += 1
            j += 1
        if count > const_max:
            const_max = count
        i += 1
    return const_max


if __name__ == ""__main__"":
    # # Input handling
    n = int(input())
    data_points = list(map(int, input().split()))
    # data_points = [5, 4, 5, 5, 6, 7, 8, 8, 8, 7, 6]
    # data_points = [1, 2, 3, 3, 2]
    # n = len(data_points)
    print(calculate_constant_range(data_points, n))
","def BS(a, n, x):
    L, R, ans = 0, n - 1, 0
    while L <= R:
        M = (L + R) // 2
        if a[M] >= x:
            ans = M + 1  # Store the potential answer (1-based index)
            R = M - 1  # Move left to find earlier pile
        else:
            L = M + 1  # Move right
    return ans

# Input reading
n = int(input())
a = list(map(int, input().split()))
m = int(input())
q = list(map(int, input().split()))

# Prepare prefix sums of worms
prefix = [0] * n
prefix[0] = a[0]
for i in range(1, n):
    prefix[i] = prefix[i - 1] + a[i]

# Answer the queries
for worm in q:
    print(BS(prefix, n, worm))"
41,A,Translation,PROGRAMMING,"['implementation', 'strings']","The translation from the Berland language into the Birland language is not an easy task. Those languages are very similar: a berlandish word differs from a birlandish word with the same meaning a little: it is spelled (and pronounced) reversely. For example, a Berlandish word code corresponds to a Birlandish word edoc. However, it's easy to make a mistake during the «translation». Vasya translated word *s* from Berlandish into Birlandish as *t*. Help him: find out if he translated the word correctly.","The first line contains word *s*, the second line contains word *t*. The words consist of lowercase Latin letters. The input data do not consist unnecessary spaces. The words are not empty and their lengths do not exceed 100 symbols.","If the word *t* is a word *s*, written reversely, print YES, otherwise print NO.","['code\nedoc\n', 'abb\naba\n', 'code\ncode\n']","['YES\n', 'NO\n', 'NO\n']",none,OK,"s=input()
t=input()
x=0
if len(s)>len(t) or len(s)<len(t):
    print('NO')
else:
    for i in range(len(s)):
        if s[i]==t[-i-1]:
            x=x+1
    if x==len(s):
        print('YES')
    else:
        print('NO')
","def ss(a, b):
    if 2 * a < b:
        return 1
    return 0

def girlfriend_choice(a, b):
    # Calculate the frequencies with which Vasya goes to Dasha and Masha
    if a == b:
        return ""Equal""
    
    lcm = (a * b) // gcd(a, b)  # Calculate least common multiple
    dasha_count = lcm // a  # How many times Vasya goes to Dasha
    masha_count = lcm // b  # How many times Vasya goes to Masha

    if dasha_count > masha_count:
        return ""Dasha""
    elif masha_count > dasha_count:
        return ""Masha""
    else:
        return ""Equal""

from math import gcd

# Read input values
a, b = map(int, input().split())

# Get the result and print it
result = girlfriend_choice(a, b)
print(result)"
626,B,Cards,PROGRAMMING,"['constructive algorithms', 'dp', 'math']","Catherine has a deck of *n* cards, each of which is either red, green, or blue. As long as there are at least two cards left, she can do one of two actions: 
 -  take any two (not necessarily adjacent) cards with different colors and exchange them for a new card of the third color; -  take any two (not necessarily adjacent) cards with the same color and exchange them for a new card with that color. 
She repeats this process until there is only one card left. What are the possible colors for the final card?","The first line of the input contains a single integer *n* (1<=≤<=*n*<=≤<=200) — the total number of cards.

The next line contains a string *s* of length *n* — the colors of the cards. *s* contains only the characters 'B', 'G', and 'R', representing blue, green, and red, respectively.",Print a single string of up to three characters — the possible colors of the final card (using the same symbols as the input) in alphabetical order.,"['2\nRB\n', '3\nGRG\n', '5\nBBBBB\n']","['G\n', 'BR\n', 'B\n']","In the first sample, Catherine has one red card and one blue card, which she must exchange for a green card.

In the second sample, Catherine has two green cards and one red card. She has two options: she can exchange the two green cards for a green card, then exchange the new green card and the red card for a blue card. Alternatively, she can exchange a green and a red card for a blue card, then exchange the blue card and remaining green card for a red card.

In the third sample, Catherine only has blue cards, so she can only exchange them for more blue cards.",WRONG_ANSWER,"l=int(input())
c=input()
if len(set(c))==1:
    print(c[0])
elif c.count('R')==c.count('B') and c.count('R')==c.count('G'):
    print('BGR')
rc=['R', 'G', 'B']
rc.sort(key=lambda x: c.count(x))
#rc=list(sorted(map(lambda x: c.count(x), rc)))
print(rc[0])
","pattern = ""hello""

def calc(s):
    arr = [-1]
    for i in s:
        arr.append(-1)

    j = 0  # Pointer for the pattern (hello)
    for char in s:
        if j < len(pattern) and char == pattern[j]:
            j += 1  # Move to the next character in 'hello'
        if j == len(pattern):  # If we matched all characters in ""hello""
            return ""YES""
    
    return ""NO""

# Example of usage
s = input().strip()  # Read the input
print(calc(s))"
43,A,Football,PROGRAMMING,['strings'],"One day Vasya decided to have a look at the results of Berland 1910 Football Championship’s finals. Unfortunately he didn't find the overall score of the match; however, he got hold of a profound description of the match's process. On the whole there are *n* lines in that description each of which described one goal. Every goal was marked with the name of the team that had scored it. Help Vasya, learn the name of the team that won the finals. It is guaranteed that the match did not end in a tie.",The first line contains an integer *n* (1<=≤<=*n*<=≤<=100) — the number of lines in the description. Then follow *n* lines — for each goal the names of the teams that scored it. The names are non-empty lines consisting of uppercase Latin letters whose lengths do not exceed 10 symbols. It is guaranteed that the match did not end in a tie and the description contains no more than two different teams.,Print the name of the winning team. We remind you that in football the team that scores more goals is considered the winner.,"['1\nABC\n', '5\nA\nABA\nABA\nA\nA\n']","['ABC\n', 'A\n']",none,OK,"n = int(input())
d = {}
ans = """"
m = 0
for i in range(n):
    s = input()
    if s not in d:
        d[s] = 0
    d[s] += 1
    if d[s] > m:
        m = d[s]
        ans = s
print(ans)","def solve(k, s):
    from collections import Counter
    
    # Count frequency of each character in the string
    d = Counter(s)
    
    # Check if all character frequencies are divisible by k
    for i in d:
        if d[i] % k != 0:
            print(""-1"")
            return
    
    # Construct the base string that will be repeated k times
    base = ''.join(i * (d[i] // k) for i in d)
    
    # Create the k-string by repeating the base string k times
    result = base * k
    print(result)"
1011,A,Stages,PROGRAMMING,"['greedy', 'implementation', 'sortings']","Natasha is going to fly to Mars. She needs to build a rocket, which consists of several stages in some order. Each of the stages is defined by a lowercase Latin letter. This way, the rocket can be described by the string — concatenation of letters, which correspond to the stages.

There are $n$ stages available. The rocket must contain exactly $k$ of them. Stages in the rocket should be ordered by their weight. So, after the stage with some letter can go only stage with a letter, which is at least two positions after in the alphabet (skipping one letter in between, or even more). For example, after letter 'c' can't go letters 'a', 'b', 'c' and 'd', but can go letters 'e', 'f', ..., 'z'.

For the rocket to fly as far as possible, its weight should be minimal. The weight of the rocket is equal to the sum of the weights of its stages. The weight of the stage is the number of its letter in the alphabet. For example, the stage 'a 'weighs one ton,' b 'weighs two tons, and' z' — $26$ tons.

Build the rocket with the minimal weight or determine, that it is impossible to build a rocket at all. Each stage can be used at most once.","The first line of input contains two integers — $n$ and $k$ ($1 \le k \le n \le 50$) – the number of available stages and the number of stages to use in the rocket.

The second line contains string $s$, which consists of exactly $n$ lowercase Latin letters. Each letter defines a new stage, which can be used to build the rocket. Each stage can be used at most once.","Print a single integer — the minimal total weight of the rocket or -1, if it is impossible to build the rocket at all.","['5 3\nxyabd\n', '7 4\nproblem\n', '2 2\nab\n', '12 1\nabaabbaaabbb\n']","['29', '34', '-1', '1']","In the first example, the following rockets satisfy the condition:
-  ""adx"" (weight is $1+4+24=29$);-  ""ady"" (weight is $1+4+25=30$);-  ""bdx"" (weight is $2+4+24=30$);-  ""bdy"" (weight is $2+4+25=31$).
Rocket ""adx"" has the minimal weight, so the answer is $29$.

In the second example, target rocket is ""belo"". Its weight is $2+5+12+15=34$.

In the third example, $n=k=2$, so the rocket must have both stages: 'a' and 'b'. This rocket doesn't satisfy the condition, because these letters are adjacent in the alphabet. Answer is -1.",WRONG_ANSWER,"n, k = [int(a) for a in input().split()]
data = sorted(list(input()))
num = 1
a = 0
result = ord(data[0]) - 96
for i in range(1, n):
    if ord(data[i]) - ord(data[a]) > 1:
        num += 1
        result += ord(data[i]) - 96
        a = i
    if num == k:
        break
if num == k:
    print(result)
else:
    print(-1)

","import sys

input = sys.stdin.readline

# Read the two binary strings
num1 = input().strip()
num2 = input().strip()

# Initialize an empty result string
result = []

# Compare each digit and determine if they are different
for digit1, digit2 in zip(num1, num2):
    # Append '1' if they differ, otherwise '0'
    if digit1 != digit2:
        result.append('1')
    else:
        result.append('0')

# Join the list into a single string and print the result
print(''.join(result))"
0,none,none,none,['none'],"An atom of element X can exist in *n* distinct states with energies *E*1<=&lt;<=*E*2<=&lt;<=...<=&lt;<=*E**n*. Arkady wants to build a laser on this element, using a three-level scheme. Here is a simplified description of the scheme. 

Three distinct states *i*, *j* and *k* are selected, where *i*<=&lt;<=*j*<=&lt;<=*k*. After that the following process happens: 
 1.  initially the atom is in the state *i*,1.  we spend *E**k*<=-<=*E**i* energy to put the atom in the state *k*,1.  the atom emits a photon with useful energy *E**k*<=-<=*E**j* and changes its state to the state *j*,1.  the atom spontaneously changes its state to the state *i*, losing energy *E**j*<=-<=*E**i*,1.  the process repeats from step 1. 
Let's define the energy conversion efficiency as , i. e. the ration between the useful energy of the photon and spent energy.

Due to some limitations, Arkady can only choose such three states that *E**k*<=-<=*E**i*<=≤<=*U*.

Help Arkady to find such the maximum possible energy conversion efficiency within the above constraints.","The first line contains two integers *n* and *U* (3<=≤<=*n*<=≤<=105, 1<=≤<=*U*<=≤<=109) — the number of states and the maximum possible difference between *E**k* and *E**i*.

The second line contains a sequence of integers *E*1,<=*E*2,<=...,<=*E**n* (1<=≤<=*E*1<=&lt;<=*E*2...<=&lt;<=*E**n*<=≤<=109). It is guaranteed that all *E**i* are given in increasing order.","If it is not possible to choose three states that satisfy all constraints, print -1.

Otherwise, print one real number η — the maximum possible energy conversion efficiency. Your answer is considered correct its absolute or relative error does not exceed 10<=-<=9.

Formally, let your answer be *a*, and the jury's answer be *b*. Your answer is considered correct if .","['4 4\n1 3 5 7\n', '10 8\n10 13 15 16 17 19 20 22 24 25\n', '3 1\n2 5 10\n']","['0.5\n', '0.875\n', '-1\n']","In the first example choose states 1, 2 and 3, so that the energy conversion efficiency becomes equal to <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/147ae7a830722917b0aa37d064df8eb74cfefb97.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>.

In the second example choose states 4, 5 and 9, so that the energy conversion efficiency becomes equal to <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/f68f268de4eb2242167e6ec64e6b8aa60a5703ae.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>.",WRONG_ANSWER,"import array
n, U = list(map(int,input().split()))
a = input().split()
i = 0
j = 2
mx = -1
while i<n-3 and i<j-1:
	while (j<n-1) and (int(a[j+1])-int(a[i]) <= U):
		j += 1
	mx = max(mx,(int(a[j])-int(a[i+1]))/(int(a[j])-int(a[i])))
	i+=1

print(mx)
","import sys
from math import ceil
input = sys.stdin.readline

def nth(a, n, d):
    return a + (n - 1) * d

a, b, c = map(int, input().split())

# Check if the difference c is 0
if c == 0:
    # If c is 0, the only element in the sequence is a
    if a == b:
        print(""YES"")
    else:
        print(""NO"")
else:
    # Check if b can be reached from a with step c
    # We will solve the equation a + n * c = b for n >= 0
    if (b - a) % c == 0 and (b - a) // c >= 0:
        print(""YES"")
    else:
        print(""NO"")"
127,B,Canvas Frames,PROGRAMMING,['implementation'],"Nicholas, a painter is going to paint several new canvases. Nicholas is sure that the canvases will turn out so great that each one will need framing and being hung on the wall. Frames are what Nicholas decided to begin with. 

Nicholas has *n* sticks whose lengths equal *a*1,<=*a*2,<=... *a**n*. Nicholas does not want to break the sticks or glue them together. To make a *h*<=×<=*w*-sized frame, he needs two sticks whose lengths equal *h* and two sticks whose lengths equal *w*. Specifically, to make a square frame (when *h*<==<=*w*), he needs four sticks of the same length.

Now Nicholas wants to make from the sticks that he has as many frames as possible; to be able to paint as many canvases as possible to fill the frames. Help him in this uneasy task. Note that it is not necessary to use all the sticks Nicholas has.",The first line contains an integer *n* (1<=≤<=*n*<=≤<=100) — the number of sticks. The second line contains *n* space-separated integers. The *i*-th integer equals the length of the *i*-th stick *a**i* (1<=≤<=*a**i*<=≤<=100).,Print the single number — the maximum number of frames Nicholas can make for his future canvases.,"['5\n2 4 3 2 3\n', '13\n2 2 4 4 4 4 6 6 6 7 7 9 9\n', '4\n3 3 3 5\n']","['1', '3', '0']",none,OK,"import math
n = int(input())
sticks = list(map(int,input().split()))

sticks.sort()
 
pair = 0
count = 1

for index in range(len(sticks)-1):
    if sticks[index] == sticks[index+1]:
        count = count + 1
        if index == len(sticks)-2:
            pair = pair + math.floor(count/2) 
    else:
        pair = pair + math.floor(count/2) 
        count = 1

frames = math.floor(pair/2)

print(frames)","def gcd(a, b):
    if (b == 0):
        return a
    return gcd(b, a % b)

def count_ties(t, w, b):
    # Count the number of lengths where Willman and Bolt tie
    max_w = t // w  # maximum steps Willman can take
    max_b = t // b  # maximum steps Bolt can take
    ties = 0
    
    # Iterate over all possible lengths from 1 to t
    for length in range(1, t + 1):
        if length % w == 0 and length % b == 0:
            ties += 1
            
    return ties

def main():
    # Read input values
    t, w, b = map(int, input().split())
    
    # Calculate the total races (lengths from 1 to t)
    total_races = t
    
    # Count the number of ties
    ties = count_ties(t, w, b)
    
    # Calculate gcd to find the irreducible fraction
    p = ties
    q = total_races
    divisor = gcd(p, q)
    
    # Output the result as an irreducible fraction
    print(f""{p // divisor}/{q // divisor}"")

# Uncomment below to run the main function for testing
# main()"
633,C,Spy Syndrome 2,PROGRAMMING,"['data structures', 'dp', 'hashing', 'implementation', 'sortings', 'string suffix structures', 'strings']","After observing the results of Spy Syndrome, Yash realised the errors of his ways. He now believes that a super spy such as Siddhant can't use a cipher as basic and ancient as Caesar cipher. After many weeks of observation of Siddhant’s sentences, Yash determined a new cipher technique.

For a given sentence, the cipher is processed as: 
 1.  Convert all letters of the sentence to lowercase. 1.  Reverse each of the words of the sentence individually. 1.  Remove all the spaces in the sentence. 
For example, when this cipher is applied to the sentence

Kira is childish and he hates losing

the resulting string is

ariksihsidlihcdnaehsetahgnisol

Now Yash is given some ciphered string and a list of words. Help him to find out any original sentence composed using only words from the list. Note, that any of the given words could be used in the sentence multiple times.","The first line of the input contains a single integer *n* (1<=≤<=*n*<=≤<=10<=000) — the length of the ciphered text. The second line consists of *n* lowercase English letters — the ciphered text *t*.

The third line contains a single integer *m* (1<=≤<=*m*<=≤<=100<=000) — the number of words which will be considered while deciphering the text. Each of the next *m* lines contains a non-empty word *w**i* (|*w**i*|<=≤<=1<=000) consisting of uppercase and lowercase English letters only. It's guaranteed that the total length of all words doesn't exceed 1<=000<=000.","Print one line — the original sentence. It is guaranteed that at least one solution exists. If there are multiple solutions, you may output any of those.","['30\nariksihsidlihcdnaehsetahgnisol\n10\nKira\nhates\nis\nhe\nlosing\ndeath\nchildish\nL\nand\nNote\n', '12\niherehtolleh\n5\nHI\nHo\nthere\nHeLLo\nhello\n']","['Kira is childish and he hates losing \n', 'HI there HeLLo \n']","In sample case 2 there may be multiple accepted outputs, ""HI there HeLLo"" and ""HI there hello"" you may output any of them.",WRONG_ANSWER,"qtd = int(input())
text, resposta = input(), list()
palavras, utilizado = int(input()), set()

prefixo = dict()
for i in range(qtd):
    for j in range(i+1, qtd+1):
        if text[i:j][::-1] not in prefixo:
            prefixo[text[i:j][::-1]] = i+j

for _ in range(palavras):
    palavra = input()
    palavra_lower = palavra.lower()
    if len(palavra) > 1 and palavra_lower in prefixo and not palavra_lower in utilizado:
        resposta.append((prefixo[palavra_lower], palavra))
        utilizado.add(palavra_lower)

print([palavra for indice, palavra in sorted(resposta)])","val = lambda c: ord(c) - ord('a')
visited = [False] * 26  # Track if we've encountered a variable
c = 'abcdefghijklmnopqrstuvwxyz'
s = input()
ans = True

# Check each character in the input string
for ch in s:
    index = val(ch)
    if not visited[index]:
        visited[index] = True  # Mark this variable as seen
    else:
        # If we see a variable that has already been marked,
        # we need to ensure we are still in a contiguous order
        # (for valid obfuscation, variables must appear in order)
        if s.count(ch) != s[s.index(ch):].count(ch):
            ans = False
            break

# Check if all variables seen are in the correct count/order
if ans:
    print(""YES"")
else:
    print(""NO"")"
340,A,The Wall,PROGRAMMING,['math'],"Iahub and his friend Floyd have started painting a wall. Iahub is painting the wall red and Floyd is painting it pink. You can consider the wall being made of a very large number of bricks, numbered 1, 2, 3 and so on. 

Iahub has the following scheme of painting: he skips *x*<=-<=1 consecutive bricks, then he paints the *x*-th one. That is, he'll paint bricks *x*, 2·*x*, 3·*x* and so on red. Similarly, Floyd skips *y*<=-<=1 consecutive bricks, then he paints the *y*-th one. Hence he'll paint bricks *y*, 2·*y*, 3·*y* and so on pink.

After painting the wall all day, the boys observed that some bricks are painted both red and pink. Iahub has a lucky number *a* and Floyd has a lucky number *b*. Boys wonder how many bricks numbered no less than *a* and no greater than *b* are painted both red and pink. This is exactly your task: compute and print the answer to the question.","The input will have a single line containing four integers in this order: *x*, *y*, *a*, *b*. (1<=≤<=*x*,<=*y*<=≤<=1000, 1<=≤<=*a*,<=*b*<=≤<=2·109, *a*<=≤<=*b*).",Output a single integer — the number of bricks numbered no less than *a* and no greater than *b* that are painted both red and pink.,['2 3 6 18\n'],['3'],"Let's look at the bricks from *a* to *b* (*a* = 6, *b* = 18). The bricks colored in red are numbered 6, 8, 10, 12, 14, 16, 18. The bricks colored in pink are numbered 6, 9, 12, 15, 18. The bricks colored in both red and pink are numbered with 6, 12 and 18.",TIME_LIMIT_EXCEEDED,"I=[int(i) for i in input().split()]
x, y, a, b = I[0], I[1], I[2], I[3]
low=min(x,y)
high=max(x,y)
current=int(a/high)*high
if a%high!=0: current+=high
ans=0
while current<=b:
    if current%low==0: ans+=1
    current+=high
print(ans)","from operator import itemgetter

def prepare(a, n):
    res = 0

    # Calculate the maximum number of lights on any exit path
    max_lights = max(a)

    # Iterate through each road to calculate required additional lights
    for lights in a:
        # Calculate the difference and accumulate to the result
        if lights < max_lights:
            res += max_lights - lights

    return res

# Input reading
n = int(input())
a = list(map(int, input().split()))

# Get the minimum number of additional lights needed
result = prepare(a, n)

# Output the result
print(result)"
732,A,Buy a Shovel,PROGRAMMING,"['brute force', 'constructive algorithms', 'implementation', 'math']","Polycarp urgently needs a shovel! He comes to the shop and chooses an appropriate one. The shovel that Policarp chooses is sold for *k* burles. Assume that there is an unlimited number of such shovels in the shop.

In his pocket Polycarp has an unlimited number of ""10-burle coins"" and exactly one coin of *r* burles (1<=≤<=*r*<=≤<=9).

What is the minimum number of shovels Polycarp has to buy so that he can pay for the purchase without any change? It is obvious that he can pay for 10 shovels without any change (by paying the requied amount of 10-burle coins and not using the coin of *r* burles). But perhaps he can buy fewer shovels and pay without any change. Note that Polycarp should buy at least one shovel.","The single line of input contains two integers *k* and *r* (1<=≤<=*k*<=≤<=1000, 1<=≤<=*r*<=≤<=9) — the price of one shovel and the denomination of the coin in Polycarp's pocket that is different from ""10-burle coins"". 

Remember that he has an unlimited number of coins in the denomination of 10, that is, Polycarp has enough money to buy any number of shovels.",Print the required minimum number of shovels Polycarp has to buy so that he can pay for them without any change.,"['117 3\n', '237 7\n', '15 2\n']","['9\n', '1\n', '2\n']","In the first example Polycarp can buy 9 shovels and pay 9·117 = 1053 burles. Indeed, he can pay this sum by using 10-burle coins and one 3-burle coin. He can't buy fewer shovels without any change.

In the second example it is enough for Polycarp to buy one shovel.

In the third example Polycarp should buy two shovels and pay 2·15 = 30 burles. It is obvious that he can pay this sum without any change.",OK,"l = input()
list1 = l.split("" "")
k = int(list1[0])
r = int(list1[1])
count =0
sum = 0
flag = 0
while flag == 0 :
    sum += k
    count += 1
    if sum%10 ==0 :
        flag = 1
        print (count)
    else :
        sum -= r
        if sum % 10 == 0:
            flag = 1
            print(count)
        else :
            sum += r
","def solve():
    n = int(input())
    g = [[] for _ in range(n+1)]
    for _ in range(n-1):
        v, w = list(map(int, input().split()))
        g[v].append((w, 1))
        g[w].append((v, -1))

    # Array to hold the number of inversions needed for each city as capital
    inversions = [0] * (n + 1)

    # Function to perform DFS and calculate inversions needed
    def dfs(node, parent):
        for neighbor, direction in g[node]:
            if neighbor != parent:
                inversions[neighbor] = inversions[node] + (1 if direction == -1 else 0)
                dfs(neighbor, node)

    # Start DFS from node 1 (assume 1 is the root)
    dfs(1, -1)

    # Calculate the minimum inversions required
    min_inversions = min(inversions[1:])

    # Find all cities that require the minimum inversions
    capitals = [i for i in range(1, n + 1) if inversions[i] == min_inversions]

    # Output the result
    print(min_inversions)
    print("" "".join(map(str, sorted(capitals))))"
987,A,Infinity Gauntlet,PROGRAMMING,['implementation'],"You took a peek on Thanos wearing Infinity Gauntlet. In the Gauntlet there is a place for six Infinity Gems:
 -  the Power Gem of purple color, -  the Time Gem of green color, -  the Space Gem of blue color, -  the Soul Gem of orange color, -  the Reality Gem of red color, -  the Mind Gem of yellow color. 
Using colors of Gems you saw in the Gauntlet determine the names of absent Gems.","In the first line of input there is one integer $n$ ($0 \le n \le 6$) — the number of Gems in Infinity Gauntlet.

In next $n$ lines there are colors of Gems you saw. Words used for colors are: purple, green, blue, orange, red, yellow. It is guaranteed that all the colors are distinct. All colors are given in lowercase English letters.","In the first line output one integer $m$ ($0 \le m \le 6$) — the number of absent Gems.

Then in $m$ lines print the names of absent Gems, each on its own line. Words used for names are: Power, Time, Space, Soul, Reality, Mind. Names can be printed in any order. Keep the first letter uppercase, others lowercase.","['4\nred\npurple\nyellow\norange\n', '0\n']","['2\nSpace\nTime\n', '6\nTime\nMind\nSoul\nPower\nReality\nSpace\n']","In the first sample Thanos already has Reality, Power, Mind and Soul Gems, so he needs two more: Time and Space.

In the second sample Thanos doesn't have any Gems, so he needs all six.",OK,"a=int(input())
gr=0
pu=0
bl=0
ore=0
r=0
y=0
p=0
for i in range(a):
    v=input()
    if v=='purple':
        pu=v
        p+=1
    if v=='green':
        gr=v
        p+=1
    if v=='blue':
        bl=v
        p+=1
    if v=='orange':
        ore=v
        p+=1
    if v=='red':
        r=v
        p+=1
    if v=='yellow':
        y=v
        p+=1
print(6-p)
if pu==0:
    print('Power')
if gr==0:
    print('Time')
if bl==0:
    print('Space')
if ore==0:
    print('Soul')
if r==0:
    print('Reality')
if y==0:
    print('Mind')","from collections import Counter
from heapq import *
from bisect import *
from itertools import *
from functools import *
from math import *
from string import *
import sys

# Read inputs
n, k = map(int, sys.stdin.readline().split())
cards = list(map(int, sys.stdin.readline().split()))
favorites = list(map(int, sys.stdin.readline().split()))
joy_levels = list(map(int, sys.stdin.readline().split()))

# Count occurrences of each card
card_count = Counter(cards)

# Initialize total joy to zero
total_joy = 0

# Process each player's favorite number
for favorite in favorites:
    if favorite in card_count:
        # Calculate how many cards can be assigned to the player
        count = card_count[favorite]
        # Determine how many joy levels can be achieved
        joy_from_favorite = 0
        
        # Give joy levels based on how many favorite cards the player receives
        for t in range(1, min(count, k) + 1):
            joy_from_favorite += joy_levels[t - 1]

        # Update total joy
        total_joy += joy_from_favorite

# Print the maximum possible total joy levels
print(total_joy)"
770,B,Maximize Sum of Digits,PROGRAMMING,"['*special', 'implementation', 'math']","Anton has the integer *x*. He is interested what positive integer, which doesn't exceed *x*, has the maximum sum of digits.

Your task is to help Anton and to find the integer that interests him. If there are several such integers, determine the biggest of them.",The first line contains the positive integer *x* (1<=≤<=*x*<=≤<=1018) — the integer which Anton has.,"Print the positive integer which doesn't exceed *x* and has the maximum sum of digits. If there are several such integers, print the biggest of them. Printed integer must not contain leading zeros.","['100\n', '48\n', '521\n']","['99\n', '48\n', '499\n']",none,TIME_LIMIT_EXCEEDED,"x=int(input())
max=0
val=0
for i in range(x):
  test=x
  temp=0
  while test>0:
    temp+=test%10
    test=test//10
    if temp>max:
      max=temp
      val=x
  x-=1
print(val)","def main():
    res = []
    for _ in range(2):
        # Read the 2x2 grid for each puzzle
        row1 = input().strip()
        row2 = input().strip()
        res.append(row1 + row2)  # Concatenate rows to form a single string for each puzzle

    # Check if both puzzles are in the same configuration
    # Sort the tiles to compare configurations irrespective of their order
    if sorted(res[0]) == sorted(res[1]):
        print(""YES"")
    else:
        print(""NO"")

main()"
595,A,Vitaly and Night,PROGRAMMING,"['constructive algorithms', 'implementation']","One day Vitaly was going home late at night and wondering: how many people aren't sleeping at that moment? To estimate, Vitaly decided to look which windows are lit in the house he was passing by at that moment.

Vitaly sees a building of *n* floors and 2·*m* windows on each floor. On each floor there are *m* flats numbered from 1 to *m*, and two consecutive windows correspond to each flat. If we number the windows from 1 to 2·*m* from left to right, then the *j*-th flat of the *i*-th floor has windows 2·*j*<=-<=1 and 2·*j* in the corresponding row of windows (as usual, floors are enumerated from the bottom). Vitaly thinks that people in the flat aren't sleeping at that moment if at least one of the windows corresponding to this flat has lights on.

Given the information about the windows of the given house, your task is to calculate the number of flats where, according to Vitaly, people aren't sleeping.","The first line of the input contains two integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=100) — the number of floors in the house and the number of flats on each floor respectively.

Next *n* lines describe the floors from top to bottom and contain 2·*m* characters each. If the *i*-th window of the given floor has lights on, then the *i*-th character of this line is '1', otherwise it is '0'.","Print a single integer — the number of flats that have lights on in at least one window, that is, the flats where, according to Vitaly, people aren't sleeping.","['2 2\n0 0 0 1\n1 0 1 1\n', '1 3\n1 1 0 1 0 0\n']","['3\n', '2\n']","In the first test case the house has two floors, two flats on each floor. That is, in total there are 4 flats. The light isn't on only on the second floor in the left flat. That is, in both rooms of the flat the light is off.

In the second test case the house has one floor and the first floor has three flats. The light is on in the leftmost flat (in both windows) and in the middle flat (in one window). In the right flat the light is off.",OK,"# import sys
# sys.stdin=open(""input.in"",""r"")
# sys.stdout=open(""output.out"",""w"")

l=list(map(int,input().split()))
n=l[0]
m=l[1]
count=0
for i in range(n):
	p=list(map(int,input().split()))
	for j in range(0,len(p)-1,2):
		if(p[j]==1 or p[j+1]==1):
			count+=1
print(count)		
","N = int(input())
A = list(map(int, input().split()))

# UnionFind
Group = [i for i in range(N + 1)]  # グループ分け
Nodes = [1] * (N + 1)  # 各グループのノードの数

# Function to find the root of a group
def find(x):
    if Group[x] != x:
        Group[x] = find(Group[x])  # Path compression
    return Group[x]

# Function to union two groups
def union(x, y):
    rootX = find(x)
    rootY = find(y)
    if rootX != rootY:
        if Nodes[rootX] < Nodes[rootY]:
            rootX, rootY = rootY, rootX
        Group[rootY] = rootX
        Nodes[rootX] += Nodes[rootY]

# Create unions based on the calling structure
for i in range(1, N + 1):
    union(i, A[i - 1])

# Find unique roots
unique_roots = set(find(i) for i in range(1, N + 1))
num_new_instructions = len(unique_roots) - 1  # At least one connection needed for each group

print(num_new_instructions)

# Output instructions to connect all groups
root_list = list(unique_roots)
for i in range(1, len(root_list)):
    print(root_list[0], root_list[i])"
981,C,Useful Decomposition,PROGRAMMING,"['implementation', 'trees']","Ramesses knows a lot about problems involving trees (undirected connected graphs without cycles)!

He created a new useful tree decomposition, but he does not know how to construct it, so he asked you for help!

The decomposition is the splitting the edges of the tree in some simple paths in such a way that each two paths have at least one common vertex. Each edge of the tree should be in exactly one path.

Help Remesses, find such a decomposition of the tree or derermine that there is no such decomposition.","The first line contains a single integer $n$ ($2 \leq n \leq 10^{5}$) the number of nodes in the tree.

Each of the next $n<=-<=1$ lines contains two integers $a_i$ and $b_i$ ($1 \leq a_i, b_i \leq n$, $a_i \neq b_i$) — the edges of the tree. It is guaranteed that the given edges form a tree.","If there are no decompositions, print the only line containing ""No"".

Otherwise in the first line print ""Yes"", and in the second line print the number of paths in the decomposition $m$. 

Each of the next $m$ lines should contain two integers $u_i$, $v_i$ ($1 \leq u_i, v_i \leq n$, $u_i \neq v_i$) denoting that one of the paths in the decomposition is the simple path between nodes $u_i$ and $v_i$. 

Each pair of paths in the decomposition should have at least one common vertex, and each edge of the tree should be presented in exactly one path. You can print the paths and the ends of each path in arbitrary order.

If there are multiple decompositions, print any.","['4\n1 2\n2 3\n3 4\n', '6\n1 2\n2 3\n3 4\n2 5\n3 6\n', '5\n1 2\n1 3\n1 4\n1 5\n']","['Yes\n1\n1 4\n', 'No\n', 'Yes\n4\n1 2\n1 3\n1 4\n1 5\n']","The tree from the first example is shown on the picture below: <img class=""tex-graphics"" src=""https://espresso.codeforces.com/9eb4b4c143d3ad267ae05d1e43341bd368b3088b.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> The number next to each edge corresponds to the path number in the decomposition. It is easy to see that this decomposition suits the required conditions.

The tree from the second example is shown on the picture below: <img class=""tex-graphics"" src=""https://espresso.codeforces.com/20704b97182d9bcde3321c00a16edcae4d772d93.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> We can show that there are no valid decompositions of this tree.

The tree from the third example is shown on the picture below: <img class=""tex-graphics"" src=""https://espresso.codeforces.com/357ff9496a4ed4746401160ee6ee63f5d57d81b9.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> The number next to each edge corresponds to the path number in the decomposition. It is easy to see that this decomposition suits the required conditions.",OK,"n = int(input())
orders = [0 for i in range(n)]
for i in range(n-1):
    a, b = [int(j) -1 for j in input().split()]
    orders[a] += 1
    orders[b] += 1

roots = []
leafs = []

for i, x in enumerate(orders):
    if x > 2:
        roots.append(i)
    elif x == 2:
        pass
    elif x == 1:
        leafs.append(i)
    else:
        raise Exception('woww')


if len(roots) > 1:
    print('No')
elif len(roots) == 0:
    print('Yes')
    print('1')
    print(' '.join([str(l+1) for l in leafs]))
elif len(roots) == 1:
    print('Yes')
    print(str(len(leafs)))
    root = str(roots[0] + 1)
    for l in leafs:
        print(root, str(l+1))
else:
    raise Exception('woww')
","MAX = 100

def countSubsequence(s, n): 
    cntQ = 0  # Count of 'Q's encountered
    cntA = 0  # Count of 'A's encountered
    result = 0  # Total number of ""QAQ"" subsequences

    for char in s:
        if char == 'Q':
            cntQ += 1  # Increment count for each 'Q' found
        elif char == 'A':
            cntA += 1  # Increment count for each 'A' found
            
    # For each 'A', count pairs of 'Q's that can form ""QAQ""
    for char in s:
        if char == 'A':
            result += cntQ * (cntQ - 1)  # Counting ""QAQ"" by choosing pairs of 'Q's with an 'A' in between
            
    return result

# Input
s = input().strip()
n = len(s)

# Output
print(countSubsequence(s, n))"
911,F,Tree Destruction,PROGRAMMING,"['constructive algorithms', 'dfs and similar', 'graphs', 'greedy', 'trees']","You are given an unweighted tree with *n* vertices. Then *n*<=-<=1 following operations are applied to the tree. A single operation consists of the following steps: 
 1.  choose two leaves; 1.  add the length of the simple path between them to the answer; 1.  remove one of the chosen leaves from the tree. 
Initial answer (before applying operations) is 0. Obviously after *n*<=-<=1 such operations the tree will consist of a single vertex. 

Calculate the maximal possible answer you can achieve, and construct a sequence of operations that allows you to achieve this answer!","The first line contains one integer number *n* (2<=≤<=*n*<=≤<=2·105) — the number of vertices in the tree. 

Next *n*<=-<=1 lines describe the edges of the tree in form *a**i*,<=*b**i* (1<=≤<=*a**i*, *b**i*<=≤<=*n*, *a**i*<=≠<=*b**i*). It is guaranteed that given graph is a tree.","In the first line print one integer number — maximal possible answer. 

In the next *n*<=-<=1 lines print the operations in order of their applying in format *a**i*,<=*b**i*,<=*c**i*, where *a**i*,<=*b**i* — pair of the leaves that are chosen in the current operation (1<=≤<=*a**i*, *b**i*<=≤<=*n*), *c**i* (1<=≤<=*c**i*<=≤<=*n*, *c**i*<==<=*a**i* or *c**i*<==<=*b**i*) — choosen leaf that is removed from the tree in the current operation. 

See the examples for better understanding.","['3\n1 2\n1 3\n', '5\n1 2\n1 3\n2 4\n2 5\n']","['3\n2 3 3\n2 1 1\n', '9\n3 5 5\n4 3 3\n4 1 1\n4 2 2\n']",none,WRONG_ANSWER,"print(""_RANDOM_GUESS_1693562844.127716"")# 1693562844.127733","# IQ test: python

n = int(input())

lst = list(map(int, input().split()))


def find_flag(lst):
    # Count how many even and odd numbers there are
    even_count = sum(1 for x in lst if x % 2 == 0)
    odd_count = n - even_count

    # Identify which one is the outlier based on the counts
    if even_count == 1:
        # Return the index of the only even number
        return lst.index(next(x for x in lst if x % 2 == 0)) + 1
    else:
        # Return the index of the only odd number
        return lst.index(next(x for x in lst if x % 2 != 0)) + 1

# Call the function and print the result
print(find_flag(lst))"
61,A,Ultra-Fast Mathematician,PROGRAMMING,['implementation'],"Shapur was an extremely gifted student. He was great at everything including Combinatorics, Algebra, Number Theory, Geometry, Calculus, etc. He was not only smart but extraordinarily fast! He could manage to sum 1018 numbers in a single second.

One day in 230 AD Shapur was trying to find out if any one can possibly do calculations faster than him. As a result he made a very great contest and asked every one to come and take part.

In his contest he gave the contestants many different pairs of numbers. Each number is made from digits 0 or 1. The contestants should write a new number corresponding to the given pair of numbers. The rule is simple: The *i*-th digit of the answer is 1 if and only if the *i*-th digit of the two given numbers differ. In the other case the *i*-th digit of the answer is 0.

Shapur made many numbers and first tried his own speed. He saw that he can perform these operations on numbers of length ∞ (length of a number is number of digits in it) in a glance! He always gives correct answers so he expects the contestants to give correct answers, too. He is a good fellow so he won't give anyone very big numbers and he always gives one person numbers of same length.

Now you are going to take part in Shapur's contest. See if you are faster and more accurate.",There are two lines in each input. Each of them contains a single number. It is guaranteed that the numbers are made from 0 and 1 only and that their length is same. The numbers may start with 0. The length of each number doesn't exceed 100.,Write one line — the corresponding answer. Do not omit the leading 0s.,"['1010100\n0100101\n', '000\n111\n', '1110\n1010\n', '01110\n01100\n']","['1110001\n', '111\n', '0100\n', '00010\n']",none,OK,"def ultra(n,m):
    ans=''
    for i in range(len(n)):
        if(n[i]==m[i]):
            ans+='0'
        else:
            ans+='1'
    return ans

if __name__ == ""__main__"":
    n=input()
    m=input()
    print(ultra(n,m))","import sys
from collections import defaultdict

# Read number of vertices
n = int(sys.stdin.readline().strip())
edges = [tuple(map(int, sys.stdin.readline().strip().split())) for _ in range(n - 1)]

# Build adjacency list for the tree
tree = defaultdict(list)
for a, b in edges:
    tree[a].append(b)
    tree[b].append(a)

# To store the maximum product
max_product = 0

# DFS to calculate size of each component
def dfs(node, parent):
    size = 1  # Current node counts as size 1
    component_sizes = []

    for neighbor in tree[node]:
        if neighbor != parent:
            subtree_size = dfs(neighbor, node)
            component_sizes.append(subtree_size)
            size += subtree_size

    # Calculate product of components formed by cutting this edge
    for component_size in component_sizes:
        product = component_size * (n - component_size)
        global max_product
        max_product = max(max_product, product)

    return size

# Starting DFS from node 1 (assuming nodes are 1-indexed)
dfs(1, -1)

# Output the maximum product
print(max_product)"
41,A,Translation,PROGRAMMING,"['implementation', 'strings']","The translation from the Berland language into the Birland language is not an easy task. Those languages are very similar: a berlandish word differs from a birlandish word with the same meaning a little: it is spelled (and pronounced) reversely. For example, a Berlandish word code corresponds to a Birlandish word edoc. However, it's easy to make a mistake during the «translation». Vasya translated word *s* from Berlandish into Birlandish as *t*. Help him: find out if he translated the word correctly.","The first line contains word *s*, the second line contains word *t*. The words consist of lowercase Latin letters. The input data do not consist unnecessary spaces. The words are not empty and their lengths do not exceed 100 symbols.","If the word *t* is a word *s*, written reversely, print YES, otherwise print NO.","['code\nedoc\n', 'abb\naba\n', 'code\ncode\n']","['YES\n', 'NO\n', 'NO\n']",none,OK,"t = list(input())
s = input()
i=0
j=len(t)-1
while(i<j):
    t[i],t[j] = t[j],t[i]
    i=i+1
    j=j-1
x = """".join(t)

if(x==s):
    print(""YES"")
else:
    print(""NO"")
     	 	  			  		 	  	 		  	 	","def tea_bags_order(n, k, a, b):
    if a > b:
        a, b = b, a
        tea_type1, tea_type2 = 'B', 'G'
    else:
        tea_type1, tea_type2 = 'G', 'B'

    # Check if it's possible to form a valid sequence
    if (b > (k + 1) * (a + 1)):
        return ""NO""

    result = []
    while a > 0 or b > 0:
        # Determine how many of the more available tea can be placed
        take_from_b = min(b, k)
        if b > a:  # if black tea is more
            take_from_b = min(b, k)

            # Add the maximum possible 'B's
            result.append(tea_type2 * take_from_b)
            b -= take_from_b
            
            # Add a 'G' if possible
            if a > 0:
                result.append(tea_type1)  # add one of the other type
                a -= 1
        else:
            take_from_a = min(a, k)
            result.append(tea_type1 * take_from_a)
            a -= take_from_a
            
            if b > 0:
                result.append(tea_type2)  # add one of the other type
                b -= 1

    return ''.join(result)

# Input handling
n, k, a, b = map(int, input().split())
result = tea_bags_order(n, k, a, b)
print(result)"
365,A,Good Number,PROGRAMMING,['implementation'],"Let's call a number *k*-good if it contains all digits not exceeding *k* (0,<=...,<=*k*). You've got a number *k* and an array *a* containing *n* numbers. Find out how many *k*-good numbers are in *a* (count each number every time it occurs in array *a*).","The first line contains integers *n* and *k* (1<=≤<=*n*<=≤<=100, 0<=≤<=*k*<=≤<=9). The *i*-th of the following *n* lines contains integer *a**i* without leading zeroes (1<=≤<=*a**i*<=≤<=109).",Print a single integer — the number of *k*-good numbers in *a*.,"['10 6\n1234560\n1234560\n1234560\n1234560\n1234560\n1234560\n1234560\n1234560\n1234560\n1234560\n', '2 1\n1\n10\n']","['10\n', '1\n']",none,WRONG_ANSWER,"n,k=map(int,input().split())
good=0
s=list(range(0,k+1))

for i in range(n):
    lst=list(map(int,input()))
    tem=list(sorted(list(set(lst)))) 
    nums=[] 
    
    if sum(nums)==s and lst.count(0)>1:
        good+=1
        
print(good)","def scanf(t=int):
    return [t(x) for x in input().split()]

n, m = scanf()
segments = [scanf() for _ in range(m)]

# Create a result list of size n initialized with zeros
result = [0] * n

# Alternate placing roses (0) and lilies (1)
for i in range(n):
    result[i] = i % 2

# Join the result list into a string and print it
print(''.join(map(str, result)))"
747,B,Mammoth's Genome Decoding,PROGRAMMING,"['implementation', 'strings']","The process of mammoth's genome decoding in Berland comes to its end!

One of the few remaining tasks is to restore unrecognized nucleotides in a found chain *s*. Each nucleotide is coded with a capital letter of English alphabet: 'A', 'C', 'G' or 'T'. Unrecognized nucleotides are coded by a question mark '?'. Thus, *s* is a string consisting of letters 'A', 'C', 'G', 'T' and characters '?'.

It is known that the number of nucleotides of each of the four types in the decoded genome of mammoth in Berland should be equal.

Your task is to decode the genome and replace each unrecognized nucleotide with one of the four types so that the number of nucleotides of each of the four types becomes equal.","The first line contains the integer *n* (4<=≤<=*n*<=≤<=255) — the length of the genome.

The second line contains the string *s* of length *n* — the coded genome. It consists of characters 'A', 'C', 'G', 'T' and '?'.","If it is possible to decode the genome, print it. If there are multiple answer, print any of them. If it is not possible, print three equals signs in a row: ""==="" (without quotes).","['8\nAG?C??CT\n', '4\nAGCT\n', '6\n????G?\n', '4\nAA??\n']","['AGACGTCT\n', 'AGCT\n', '===\n', '===\n']","In the first example you can replace the first question mark with the letter 'A', the second question mark with the letter 'G', the third question mark with the letter 'T', then each nucleotide in the genome would be presented twice.

In the second example the genome is already decoded correctly and each nucleotide is exactly once in it.

In the third and the fourth examples it is impossible to decode the genom.",RUNTIME_ERROR,"n = int(input())
s = input()
l = len(s)
count = 0
count1, count2, count3, count4 = 0, 0, 0, 0
for i in range(0, l):
    if s[i] == 'A':
        count1 = count1+1
    if s[i] == 'C':
        count2 = count2+1
    if s[i] == 'G':
        count3 = count3+1
    if s[i] == 'T':
        count4 = count4+1
    if s[i] == '?':
        count = count+1

max1 = max(count1, max(count2, max(count3, count4)))
# print(""the value of max is ""+str(max1)+"" ""+str(count1)+"" ""+str(count2)+"" ""+str(count3)+"" ""+str(count4))
flag = 0
for i in range(0, l):
    if s[i] == '?':
        if count1 != max1:
            s=s.replace('?','A',1)
            count = count-1
            count1 = count1+1
        elif count2 != max1:
            s=s.replace('?','C',1)
            count = count-1
            count2 = count2+1
        elif count3 != max1:
            s=s.replace('?','G',1)
            count = count-1
            count3 = count3+1
        elif count4 != max1:
            s=s.replace('?','T',1)
            count = count-1
            count4 = count4+1
        else:
            if count % 4 == 0 and count1==count2==count3==count4:
                flag = 1
    if count == 0 and count1==count2==count3==count4:
        print(s)
        flag = 1
    if flag == 1:
        break
if flag == 0:
    print(""==="")
elif flag == 1 and count != 0:
    m = count/4
    s=s.replace('?','A',m)
    s=s.replace('?','C',m)
    s=s.replace('?','G',m)
    s=s.replace('?','T',m)
    print(s)
","n = int(input())
adj = [[] for _ in range(n)]

for _ in range(n - 1):
    u, v = map(int, input().split())
    adj[u - 1].append(v - 1)
    adj[v - 1].append(u - 1)

# To store the coordinates of each vertex
coordinates = [(0, 0)] * n

# Function to perform DFS and position the vertices
def position_tree(node, x, y, parent):
    coordinates[node] = (x, y)  # Set the coordinate for the current node
    next_x, next_y = x, y + 1  # Increment y to arrange next level
    for neighbor in adj[node]:
        if neighbor != parent:  # Avoid going back to parent
            position_tree(neighbor, next_x, next_y, node)
            next_x += 1  # Move to the right for the next neighbor

# Start positioning from node 0 (arbitrary root) at (0, 0)
position_tree(0, 0, 0, -1)

# Output the result
print(""YES"")
for x, y in coordinates:
    print(x, y)"
932,B,Recursive Queries,PROGRAMMING,"['binary search', 'data structures', 'dfs and similar']","Let us define two functions *f* and *g* on positive integer numbers. 

 

You need to process *Q* queries. In each query, you will be given three integers *l*, *r* and *k*. You need to print the number of integers *x* between *l* and *r* inclusive, such that *g*(*x*)<==<=*k*.","The first line of the input contains an integer *Q* (1<=≤<=*Q*<=≤<=2<=×<=105) representing the number of queries. 

*Q* lines follow, each of which contains 3 integers *l*, *r* and *k* (1<=≤<=*l*<=≤<=*r*<=≤<=106,<=1<=≤<=*k*<=≤<=9).","For each query, print a single line containing the answer for that query.","['4\n22 73 9\n45 64 6\n47 55 7\n2 62 4\n', '4\n82 94 6\n56 67 4\n28 59 9\n39 74 4\n']","['1\n4\n0\n8\n', '3\n1\n1\n5\n']","In the first example:
 -  *g*(33) = 9 as *g*(33) = *g*(3 × 3) = *g*(9) = 9 -  *g*(47) = *g*(48) = *g*(60) = *g*(61) = 6 -  There are no such integers between 47 and 55. -  *g*(4) = *g*(14) = *g*(22) = *g*(27) = *g*(39) = *g*(40) = *g*(41) = *g*(58) = 4",TIME_LIMIT_EXCEEDED,"from collections import defaultdict
def product_of_digits(x):

	pr = 1
	while x:

		t = x%10
		pr = pr*max(t,1)
		x = x//10

	return pr

d = defaultdict(list)

Q = int(input())

for i in range(1,10**6+1):

	s = product_of_digits(i)
	d[s].append(i)
# print(d)
def Binary_Search_l(array,x):

	l = 0
	r = len(array)-1
	while r >= l:

		if array[(r+l)//2] >= x:
			r = (l+r)//2-1
		else:
			l = (l+r)//2+1

	return l
def Binary_Search_r(array,x):

	l = 0
	r = len(array)-1

	while r > l:

		if array[(r+l)//2] <= x:
			l = (l+r)//2+1
		else:
			r = (l+r)//2-1

	return r

	
def DFS(d,x,l,r):

	ans = []
	visited = set()
	stack = [x]

	while len(stack):

		temp = stack.pop()
		visited.add(temp)

		if l <= temp and r >= temp:
			ans.append(temp)

		for j in d[temp]:

			if j not in visited:

				stack.append(j)

	return ans

for i in range(Q):

	l,r,k = map(int,input().split())
	visited = list(DFS(d,k,l,r))
	
	visited.sort()
	print(len(visited))","import sys

def determine_winner(x, y):
    # Game continues until someone can't take 220 yen
    turn = 0  # 0 for Ciel's turn, 1 for Hanako's turn
    
    while True:
        # Calculate the number of 100-yen and 10-yen coins from the current player
        if turn == 0:  # Ciel's turn
            c100 = min(2, x)  # Ciel prefers to use 2 100-yen coins if possible
            coins_needed = 220 - c100 * 100
            c10 = coins_needed // 10 if coins_needed >= 0 else -1
            
            # If not enough 10-yen coins, reduce c100
            while c100 >= 0 and (c10 < 0 or c10 > y):
                c100 -= 1
                coins_needed = 220 - c100 * 100
                c10 = coins_needed // 10 if coins_needed >= 0 else -1
            
            if c100 < 0:  # Can't make 220 yen
                return ""Hanako""
            x -= c100
            y -= c10
        
        else:  # Hanako's turn
            c10 = min(22, y)  # Hanako prefers to use 22 10-yen coins if possible
            coins_needed = 220 - c10 * 10
            c100 = coins_needed // 100 if coins_needed >= 0 else -1
            
            # If not enough 100-yen coins, reduce c10
            while c10 >= 0 and (c100 < 0 or c100 > x):
                c10 -= 1
                coins_needed = 220 - c10 * 10
                c100 = coins_needed // 100 if coins_needed >= 0 else -1
            
            if c10 < 0:  # Can't make 220 yen
                return ""Ciel""
            x -= c100
            y -= c10
        
        # Switch turns
        turn = 1 - turn

# Reading input
x, y = map(int, sys.stdin.readline().strip().split())
print(determine_winner(x, y))"
785,C,Anton and Fairy Tale,PROGRAMMING,"['binary search', 'math']","Anton likes to listen to fairy tales, especially when Danik, Anton's best friend, tells them. Right now Danik tells Anton a fairy tale:

""Once upon a time, there lived an emperor. He was very rich and had much grain. One day he ordered to build a huge barn to put there all his grain. Best builders were building that barn for three days and three nights. But they overlooked and there remained a little hole in the barn, from which every day sparrows came through. Here flew a sparrow, took a grain and flew away...""

More formally, the following takes place in the fairy tale. At the beginning of the first day the barn with the capacity of *n* grains was full. Then, every day (starting with the first day) the following happens:
 -  *m* grains are brought to the barn. If *m* grains doesn't fit to the barn, the barn becomes full and the grains that doesn't fit are brought back (in this problem we can assume that the grains that doesn't fit to the barn are not taken into account). -  Sparrows come and eat grain. In the *i*-th day *i* sparrows come, that is on the first day one sparrow come, on the second day two sparrows come and so on. Every sparrow eats one grain. If the barn is empty, a sparrow eats nothing. 
Anton is tired of listening how Danik describes every sparrow that eats grain from the barn. Anton doesn't know when the fairy tale ends, so he asked you to determine, by the end of which day the barn will become empty for the first time. Help Anton and write a program that will determine the number of that day!","The only line of the input contains two integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=1018) — the capacity of the barn and the number of grains that are brought every day.",Output one integer — the number of the day when the barn will become empty for the first time. Days are numbered starting with one.,"['5 2\n', '8 1\n']","['4\n', '5\n']","In the first sample the capacity of the barn is five grains and two grains are brought every day. The following happens:
 -  At the beginning of the first day grain is brought to the barn. It's full, so nothing happens. -  At the end of the first day one sparrow comes and eats one grain, so 5 - 1 = 4 grains remain. -  At the beginning of the second day two grains are brought. The barn becomes full and one grain doesn't fit to it. -  At the end of the second day two sparrows come. 5 - 2 = 3 grains remain. -  At the beginning of the third day two grains are brought. The barn becomes full again. -  At the end of the third day three sparrows come and eat grain. 5 - 3 = 2 grains remain. -  At the beginning of the fourth day grain is brought again. 2 + 2 = 4 grains remain. -  At the end of the fourth day four sparrows come and eat grain. 4 - 4 = 0 grains remain. The barn is empty. 
So the answer is 4, because by the end of the fourth day the barn becomes empty.",WRONG_ANSWER,"import os
import sys
import math
import random
import datetime
import json
import re
import sqlite3
import time
import csv
import smtplib
import hashlib
import threading
import logging
import tkinter as tk

def find_empty_day(n, m):
    day = 1  # Начинаем с первого дня
    grains = n  # Изначальное количество зерна в амбаре

    while grains > 0:
        grains -= day  # Вычитаем количество зерна, которое съели воробьи в текущий день

        if grains <= 0:
            break  # Если зерна больше нет, прерываем цикл

        grains += m  # Добавляем новое зерно в амбар

        day += 1  # Переходим к следующему дню

    return day - 1  # Вычитаем 1, чтобы получить номер дня, когда амбар стал пустым

# Вводим вместимость амбара и количество зерна, подвозимое ежедневно
n, m = map(int, input().split())

# Находим номер дня, когда амбар станет пустым
empty_day = find_empty_day(n, m)

# Выводим результат
print(empty_day)
","nOfCities, x = map(int, input().split())
x -= 1
criminals = list(map(int, input().split()))

def criminalsFound(cities, criminals):
    total_caught = 0
    n = len(criminals)
    
    # Check criminals at distance 0 (current city)
    total_caught += criminals[x]
    
    # Check criminals at distances 1 to n
    for d in range(1, n):
        left_city = x - d
        right_city = x + d
        
        if left_city >= 0 and criminals[left_city] > 0:
            total_caught += 1  # Criminal is certain in left city
            
        if right_city < n and criminals[right_city] > 0:
            total_caught += 1  # Criminal is certain in right city
            
    return total_caught

print(criminalsFound(nOfCities, criminals))"
34,B,Sale,PROGRAMMING,"['greedy', 'sortings']","Once Bob got to a sale of old TV sets. There were *n* TV sets at that sale. TV set with index *i* costs *a**i* bellars. Some TV sets have a negative price — their owners are ready to pay Bob if he buys their useless apparatus. Bob can «buy» any TV sets he wants. Though he's very strong, Bob can carry at most *m* TV sets, and he has no desire to go to the sale for the second time. Please, help Bob find out the maximum sum of money that he can earn.","The first line contains two space-separated integers *n* and *m* (1<=≤<=*m*<=≤<=*n*<=≤<=100) — amount of TV sets at the sale, and amount of TV sets that Bob can carry. The following line contains *n* space-separated integers *a**i* (<=-<=1000<=≤<=*a**i*<=≤<=1000) — prices of the TV sets.","Output the only number — the maximum sum of money that Bob can earn, given that he can carry at most *m* TV sets.","['5 3\n-6 0 35 -2 4\n', '4 2\n7 0 0 -7\n']","['8\n', '7\n']",none,OK,"n,m=list(map(int,input().split()))
lis=list(map(int,input().split()))
lis.sort()
sum=0
for i in range(m):
    if(lis[i]<0):
        sum=sum+lis[i]

print(abs(sum))","def room(v):
    target = ""hello""
    idx = 0
    for ch in v:
        if ch == target[idx]:
            idx += 1
        if idx == len(target):
            return ""YES""
    return ""NO""

s = input()  # Input the string typed by Vasya
print(room(s))  # Print the result of whether Vasya managed to say hello"
71,A,Way Too Long Words,PROGRAMMING,['strings'],"Sometimes some words like ""localization"" or ""internationalization"" are so long that writing them many times in one text is quite tiresome.

Let's consider a word too long, if its length is strictly more than 10 characters. All too long words should be replaced with a special abbreviation.

This abbreviation is made like this: we write down the first and the last letter of a word and between them we write the number of letters between the first and the last letters. That number is in decimal system and doesn't contain any leading zeroes.

Thus, ""localization"" will be spelt as ""l10n"", and ""internationalization» will be spelt as ""i18n"".

You are suggested to automatize the process of changing the words with abbreviations. At that all too long words should be replaced by the abbreviation and the words that are not too long should not undergo any changes.",The first line contains an integer *n* (1<=≤<=*n*<=≤<=100). Each of the following *n* lines contains one word. All the words consist of lowercase Latin letters and possess the lengths of from 1 to 100 characters.,Print *n* lines. The *i*-th line should contain the result of replacing of the *i*-th word from the input data.,['4\nword\nlocalization\ninternationalization\npneumonoultramicroscopicsilicovolcanoconiosis\n'],['word\nl10n\ni18n\np43s\n'],none,OK,"T = int(input())
i=0
while i<T:
    word = input()
    if(len(word)>10):
        print(word[0],len(word)-2,word[-1],sep="""")
    else:
        print(word)
    i+=1

","""""""
https://codeforces.com/problemset/problem/595/A
""""""

# Read the number of floors and flats per floor
n, m = map(int, input().split())

# Initialize a counter for the number of flats with lights on
flats_with_lights_on = 0

# Iterate through each floor
for _ in range(n):
    # Read the windows state for the current floor
    windows = input().strip()
    
    # Check each flat
    for j in range(m):
        # Each flat has two windows: 2*j and 2*j + 1
        if windows[2*j] == '1' or windows[2*j + 1] == '1':
            flats_with_lights_on += 1
            # We can break since we only need to count each flat once
            break

# Print the total number of flats with lights on
print(flats_with_lights_on)"
441,A,Valera and Antique Items,PROGRAMMING,['implementation'],"Valera is a collector. Once he wanted to expand his collection with exactly one antique item.

Valera knows *n* sellers of antiques, the *i*-th of them auctioned *k**i* items. Currently the auction price of the *j*-th object of the *i*-th seller is *s**ij*. Valera gets on well with each of the *n* sellers. He is perfectly sure that if he outbids the current price of one of the items in the auction (in other words, offers the seller the money that is strictly greater than the current price of the item at the auction), the seller of the object will immediately sign a contract with him.

Unfortunately, Valera has only *v* units of money. Help him to determine which of the *n* sellers he can make a deal with.","The first line contains two space-separated integers *n*,<=*v* (1<=≤<=*n*<=≤<=50; 104<=≤<=*v*<=≤<=106) — the number of sellers and the units of money the Valera has.

Then *n* lines follow. The *i*-th line first contains integer *k**i* (1<=≤<=*k**i*<=≤<=50) the number of items of the *i*-th seller. Then go *k**i* space-separated integers *s**i*1,<=*s**i*2,<=...,<=*s**ik**i* (104<=≤<=*s**ij*<=≤<=106) — the current prices of the items of the *i*-th seller.","In the first line, print integer *p* — the number of sellers with who Valera can make a deal.

In the second line print *p* space-separated integers *q*1,<=*q*2,<=...,<=*q**p* (1<=≤<=*q**i*<=≤<=*n*) — the numbers of the sellers with who Valera can make a deal. Print the numbers of the sellers in the increasing order.","['3 50000\n1 40000\n2 20000 60000\n3 10000 70000 190000\n', '3 50000\n1 50000\n3 100000 120000 110000\n3 120000 110000 120000\n']","['3\n1 2 3\n', '0\n\n']","In the first sample Valera can bargain with each of the sellers. He can outbid the following items: a 40000 item from the first seller, a 20000 item from the second seller, and a 10000 item from the third seller.

In the second sample Valera can not make a deal with any of the sellers, as the prices of all items in the auction too big for him.",OK,"a,b=map(int,input().split());k=[]
for i in range(1,a+1):
	c,*d=map(int,input().split())
	if min(d)<b:k+=[i]
print(len(k),""\n"",*k)



","import configparser
import math
import sys

input = sys.stdin.readline

# Read input values
n, k, l = map(int, input().split())
a = list(map(int, input().split()))

# Function to check if we can form n barrels with a minimum stave length `min_length`
def can_form_barrels(min_length):
    count = 0
    current_count = 0
    
    for length in a:
        if length >= min_length:
            current_count += 1
            if current_count == k:
                count += 1
                current_count = 0
                
    return count >= n

# Function to find the maximum total volume
def max_volume():
    low = 0
    high = max(a)
    ans = 0
    
    while low <= high:
        mid = (low + high) // 2
        
        if can_form_barrels(mid):
            ans = mid
            low = mid + 1
        else:
            high = mid - 1
            
    return ans

# Calculate the maximum volume
max_vol = max_volume()

# We can only take the highest volume and check if all barrels can be within range
if max_vol > 0:
    total_volume = n * max_vol
    # Check if it's possible to construct barrels with max_vol and max_vol+l
    if can_form_barrels(max_vol + l):
        print(total_volume)
    else:
        print(0)
else:
    print(0)"
10,A,Power Consumption Calculation,PROGRAMMING,['implementation'],"Tom is interested in power consumption of his favourite laptop. His laptop has three modes. In normal mode laptop consumes *P*1 watt per minute. *T*1 minutes after Tom moved the mouse or touched the keyboard for the last time, a screensaver starts and power consumption changes to *P*2 watt per minute. Finally, after *T*2 minutes from the start of the screensaver, laptop switches to the ""sleep"" mode and consumes *P*3 watt per minute. If Tom moves the mouse or touches the keyboard when the laptop is in the second or in the third mode, it switches to the first (normal) mode. Tom's work with the laptop can be divided into *n* time periods [*l*1,<=*r*1],<=[*l*2,<=*r*2],<=...,<=[*l**n*,<=*r**n*]. During each interval Tom continuously moves the mouse and presses buttons on the keyboard. Between the periods Tom stays away from the laptop. Find out the total amount of power consumed by the laptop during the period [*l*1,<=*r**n*].","The first line contains 6 integer numbers *n*, *P*1, *P*2, *P*3, *T*1, *T*2 (1<=≤<=*n*<=≤<=100,<=0<=≤<=*P*1,<=*P*2,<=*P*3<=≤<=100,<=1<=≤<=*T*1,<=*T*2<=≤<=60). The following *n* lines contain description of Tom's work. Each *i*-th of these lines contains two space-separated integers *l**i* and *r**i* (0<=≤<=*l**i*<=&lt;<=*r**i*<=≤<=1440, *r**i*<=&lt;<=*l**i*<=+<=1 for *i*<=&lt;<=*n*), which stand for the start and the end of the *i*-th period of work.",Output the answer to the problem.,"['1 3 2 1 5 10\n0 10\n', '2 8 4 2 5 10\n20 30\n50 100\n']","['30', '570']",none,OK,"n, P1, P2, P3, T1, T2=map(int,input().split())
s=0
for i in range(n):
    l,r=map(int,input().split())
    if i==0:
        t=l
    if T1>=(l-t):
        s+=(l-t)*P1
    else:
        s+=T1*P1
        if T2>=(l-T1-t):
            s+=(l-T1-t)*P2
        else:
            s+=T2*P2
            s+=(l-T1-T2-t)*P3
    s+=(r-l)*P1
    t=r
print(s)","#!/usr/bin/env python3

import random

def find_color(i, j):
    # Determine the color based on the row and column indices
    if (i + j) % 2 == 0:
        return ""B""
    else:
        return ""W""

n, m = map(int, input().split())
board = [input().strip() for _ in range(n)]

# Initialize result board
result = [['-' for _ in range(m)] for _ in range(n)]

# Fill the result board according to the good cells
for i in range(n):
    for j in range(m):
        if board[i][j] == '.':
            result[i][j] = find_color(i, j)

# Print the result
for row in result:
    print(''.join(row))"
80,A,Panoramix's Prediction,PROGRAMMING,['brute force'],"A prime number is a number which has exactly two distinct divisors: one and itself. For example, numbers 2, 7, 3 are prime, and 1, 6, 4 are not.

The next prime number after *x* is the smallest prime number greater than *x*. For example, the next prime number after 2 is 3, and the next prime number after 3 is 5. Note that there is exactly one next prime number after each number. So 5 is not the next prime number for 2.

One cold April morning Panoramix predicted that soon Kakofonix will break free from his straitjacket, and this will be a black day for the residents of the Gallic countryside.

Panoramix's prophecy tells that if some day Asterix and Obelix beat exactly *x* Roman soldiers, where *x* is a prime number, and next day they beat exactly *y* Roman soldiers, where *y* is the next prime number after *x*, then it's time to wait for Armageddon, for nothing can shut Kakofonix up while he sings his infernal song.

Yesterday the Gauls beat *n* Roman soldiers and it turned out that the number *n* was prime! Today their victims were a troop of *m* Romans (*m*<=&gt;<=*n*). Determine whether the Gauls should wait for the black day after today's victory of Asterix and Obelix?","The first and only input line contains two positive integers — *n* and *m* (2<=≤<=*n*<=&lt;<=*m*<=≤<=50). It is guaranteed that *n* is prime.

Pretests contain all the cases with restrictions 2<=≤<=*n*<=&lt;<=*m*<=≤<=4.","Print YES, if *m* is the next prime number after *n*, or NO otherwise.","['3 5\n', '7 11\n', '7 9\n']","['YES', 'YES', 'NO']",none,WRONG_ANSWER,"a=[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47]
n,m=map(int,input().split())
for i in range(len(a)-1):
       if n==a[i]:
              if m==a[i+1]:
                     print('YES')
              else:
                     print('NO')","import sys
input = sys.stdin.readline
from collections import defaultdict

n, m = map(int, input().split())

markers = [tuple(map(int, input().split())) for _ in range(n)]
caps = [tuple(map(int, input().split())) for _ in range(m)]

# Sort markers by diameter and color
markers.sort(key=lambda x: (x[1], x[0]))
# Sort caps by diameter and color
caps.sort(key=lambda x: (x[1], x[0]))

closed_markers = 0
beautifully_closed_markers = 0

marker_used = [False] * n
cap_used = [False] * m

# Try to close beautifully first
for i in range(n):
    for j in range(m):
        if not marker_used[i] and not cap_used[j]:
            if markers[i][0] == caps[j][0] and markers[i][1] <= caps[j][1]:
                closed_markers += 1
                beautifully_closed_markers += 1
                marker_used[i] = True
                cap_used[j] = True
                break

# Then try to close remaining markers
for i in range(n):
    if not marker_used[i]:
        for j in range(m):
            if not cap_used[j]:
                if markers[i][1] <= caps[j][1]:
                    closed_markers += 1
                    marker_used[i] = True
                    cap_used[j] = True
                    break

print(closed_markers, beautifully_closed_markers)"
587,A,Duff and Weight Lifting,PROGRAMMING,['greedy'],"Recently, Duff has been practicing weight lifting. As a hard practice, Malek gave her a task. He gave her a sequence of weights. Weight of *i*-th of them is 2*w**i* pounds. In each step, Duff can lift some of the remaining weights and throw them away. She does this until there's no more weight left. Malek asked her to minimize the number of steps.

Duff is a competitive programming fan. That's why in each step, she can only lift and throw away a sequence of weights 2*a*1,<=...,<=2*a**k* if and only if there exists a non-negative integer *x* such that 2*a*1<=+<=2*a*2<=+<=...<=+<=2*a**k*<==<=2*x*, i. e. the sum of those numbers is a power of two.

Duff is a competitive programming fan, but not a programmer. That's why she asked for your help. Help her minimize the number of steps.","The first line of input contains integer *n* (1<=≤<=*n*<=≤<=106), the number of weights.

The second line contains *n* integers *w*1,<=...,<=*w**n* separated by spaces (0<=≤<=*w**i*<=≤<=106 for each 1<=≤<=*i*<=≤<=*n*), the powers of two forming the weights values.",Print the minimum number of steps in a single line.,"['5\n1 1 2 3 3\n', '4\n0 1 2 3\n']","['2\n', '4\n']","In the first sample case: One optimal way would be to throw away the first three in the first step and the rest in the second step. Also, it's not possible to do it in one step because their sum is not a power of two.

In the second sample case: The only optimal way is to throw away one weight in each step. It's not possible to do it in less than 4 steps because there's no subset of weights with more than one weight and sum equal to a power of two.",RUNTIME_ERROR,"# Description of the problem can be found at http://codeforces.com/problemset/problem/581/C

n, k = map(int, input().split())
l_s = list(map(int, input().split()))

l_s.sort(key = lambda x: x % 10 if x != 100 else x, reverse = True)

t = 0
r = 0
index = 0
for i in l_s:
    n_i = i
    if i != 100:
        n_i += min(k, 10 - i % 10)
        k -= n_i - i
        r += 100 - n_i
    t += n_i // 10
t += min(r // 10, k // 10)
print(t)","def paresChocolate(matriz, n):
    res = 0
    # Count chocolates in each row
    for i in range(n):
        count = 0
        for j in range(n):
            if matriz[i][j] == 'C':
                count += 1
        # If there are `count` chocolates in the row, 
        # the number of pairs is count choose 2
        res += count * (count - 1) // 2
    
    # Count chocolates in each column
    for j in range(n):
        count = 0
        for i in range(n):
            if matriz[i][j] == 'C':
                count += 1
        # If there are `count` chocolates in the column, 
        # the number of pairs is count choose 2
        res += count * (count - 1) // 2
    
    return res

# Read input
n = int(input())
matriz = [input().strip() for _ in range(n)]

# Calculate and print the happiness
print(paresChocolate(matriz, n))"
0,none,none,none,['none'],"Santa Claus has Robot which lives on the infinite grid and can move along its lines. He can also, having a sequence of *m* points *p*1,<=*p*2,<=...,<=*p**m* with integer coordinates, do the following: denote its initial location by *p*0. First, the robot will move from *p*0 to *p*1 along one of the shortest paths between them (please notice that since the robot moves only along the grid lines, there can be several shortest paths). Then, after it reaches *p*1, it'll move to *p*2, again, choosing one of the shortest ways, then to *p*3, and so on, until he has visited all points in the given order. Some of the points in the sequence may coincide, in that case Robot will visit that point several times according to the sequence order.

While Santa was away, someone gave a sequence of points to Robot. This sequence is now lost, but Robot saved the protocol of its unit movements. Please, find the minimum possible length of the sequence.","The first line of input contains the only positive integer *n* (1<=≤<=*n*<=≤<=2·105) which equals the number of unit segments the robot traveled. The second line contains the movements protocol, which consists of *n* letters, each being equal either L, or R, or U, or D. *k*-th letter stands for the direction which Robot traveled the *k*-th unit segment in: L means that it moved to the left, R — to the right, U — to the top and D — to the bottom. Have a look at the illustrations for better explanation.",The only line of input should contain the minimum possible length of the sequence.,"['4\nRURD\n', '6\nRRULDD\n', '26\nRRRULURURUULULLLDLDDRDRDLD\n', '3\nRLL\n', '4\nLRLR\n']","['2\n', '2\n', '7\n', '2\n', '4\n']","The illustrations to the first three tests are given below.

<img class=""tex-graphics"" src=""https://espresso.codeforces.com/832fb8f97a482be815e0f87edde26c9791a0d330.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> <img class=""tex-graphics"" src=""https://espresso.codeforces.com/119a8ba68772b2c2bf76f2acdc58027f6c5cde1f.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> <img class=""tex-graphics"" src=""https://espresso.codeforces.com/c7b4534f24cbad48148bcba24bc44f37bf7a2dbf.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

The last example illustrates that each point in the sequence should be counted as many times as it is presented in the sequence.",TIME_LIMIT_EXCEEDED,"n=int(input())
s=input()
L,R,U,D=False,False,False,False
c=0
for i in range(n):
    exec(s[i]+'=True')
    if (L and R) or (U and D):
        c+=1
        L,R,U,D=False,False,False,False
        exec(s[i]+'=True')
c+=1
print(c)
","def socks():
    n = int(input())
    arr = [False for _ in range(n + 1)]
    pairs = list(map(int, input().split()))

    max_socks_on_table = 0
    socks_on_table = 0

    for sock in pairs:
        if not arr[sock]:  # If the pair of this sock is not yet on the table
            arr[sock] = True  # Mark the pair as on the table
            socks_on_table += 1  # Increase the count of socks on the table
        else:  # The pair of this sock is already on the table
            arr[sock] = False  # Remove the pair from the table
            socks_on_table -= 1  # Decrease the count, both socks are now in the wardrobe
        
        max_socks_on_table = max(max_socks_on_table, socks_on_table)  # Update maximum if needed

    print(max_socks_on_table)  # Output the maximum number of socks on the table at the same time"
1005,B,Delete from the Left,PROGRAMMING,"['brute force', 'implementation', 'strings']","You are given two strings $s$ and $t$. In a single move, you can choose any of two strings and delete the first (that is, the leftmost) character. After a move, the length of the string decreases by $1$. You can't choose a string if it is empty.

For example:
 -  by applying a move to the string ""where"", the result is the string ""here"", -  by applying a move to the string ""a"", the result is an empty string """". 
You are required to make two given strings equal using the fewest number of moves. It is possible that, in the end, both strings will be equal to the empty string, and so, are equal to each other. In this case, the answer is obviously the sum of the lengths of the initial strings.

Write a program that finds the minimum number of moves to make two given strings $s$ and $t$ equal.","The first line of the input contains $s$. In the second line of the input contains $t$. Both strings consist only of lowercase Latin letters. The number of letters in each string is between 1 and $2\cdot10^5$, inclusive.","Output the fewest number of moves required. It is possible that, in the end, both strings will be equal to the empty string, and so, are equal to each other. In this case, the answer is obviously the sum of the lengths of the given strings.","['test\nwest\n', 'codeforces\nyes\n', 'test\nyes\n', 'b\nab\n']","['2\n', '9\n', '7\n', '1\n']","In the first example, you should apply the move once to the first string and apply the move once to the second string. As a result, both strings will be equal to ""est"".

In the second example, the move should be applied to the string ""codeforces"" $8$ times. As a result, the string becomes ""codeforces"" $\to$ ""es"". The move should be applied to the string ""yes"" once. The result is the same string ""yes"" $\to$ ""es"".

In the third example, you can make the strings equal only by completely deleting them. That is, in the end, both strings will be empty.

In the fourth example, the first character of the second string should be deleted.",TIME_LIMIT_EXCEEDED,"word_1, word_2 = input(), input()

total = 0

l1, l2 = len(word_1), len(word_2)


if l1 > l2:
    word_1 = word_1[l1 - l2:]

    total += l1 - l2

elif l2 > l1:
    word_2 = word_2[l2 - l1:]

    total += l2 - l1

while word_1 != """": 
    
    if word_1 == word_2 :
        break
    else:
        word_1, word_2 = word_1[1:], word_2[1:]

        total += 2

print(total)
# Sun Sep 03 2023 22:17:12 GMT+0300 (Moscow Standard Time)
","def cnk(n):
    return 0 if 3 > n else n * (n - 1) * (n - 2) // 6

n, d = map(int, input().split())
points = list(map(int, input().split()))

count = 0
j = 0

# We use a sliding window approach to find valid groups of points
for i in range(n):
    # Move j to the position where the distance condition is violated
    while j < n and points[j] - points[i] <= d:
        j += 1
    
    # The number of points in the range [i, j-1] is (j - i)
    # We need to choose 3 distinct points from this range
    count += cnk(j - i - 1)

print(count)"
770,A,New Password,PROGRAMMING,"['*special', 'implementation']","Innokentiy decides to change the password in the social net ""Contact!"", but he is too lazy to invent a new password by himself. That is why he needs your help. 

Innokentiy decides that new password should satisfy the following conditions:
 -  the length of the password must be equal to *n*, -  the password should consist only of lowercase Latin letters, -  the number of distinct symbols in the password must be equal to *k*, -  any two consecutive symbols in the password must be distinct. 
Your task is to help Innokentiy and to invent a new password which will satisfy all given conditions.","The first line contains two positive integers *n* and *k* (2<=≤<=*n*<=≤<=100, 2<=≤<=*k*<=≤<=*min*(*n*,<=26)) — the length of the password and the number of distinct symbols in it. 

Pay attention that a desired new password always exists.",Print any password which satisfies all conditions given by Innokentiy.,"['4 3\n', '6 6\n', '5 2\n']","['java\n', 'python\n', 'phphp\n']","In the first test there is one of the appropriate new passwords — java, because its length is equal to 4 and 3 distinct lowercase letters a, j and v are used in it.

In the second test there is one of the appropriate new passwords — python, because its length is equal to 6 and it consists of 6 distinct lowercase letters.

In the third test there is one of the appropriate new passwords — phphp, because its length is equal to 5 and 2 distinct lowercase letters p and h are used in it.

Pay attention the condition that no two identical symbols are consecutive is correct for all appropriate passwords in tests.",COMPILATION_ERROR,"import string
alpha = string.ascii_lowercase

size, rng = map(int,input().split())
req = alpha[:rng]
pwd = ''
ct = 0a

for i in range(size):
    if ct >= rng:
        ct = 0
    pwd += req[ct]
    ct+=1

    
print(pwd)","n, zane, money = map(int, input().split())
houses = [int(x) for x in input().split()]

def findHouseToBuy(n, zane, money):
    start = zane - 1  # Adjusting for 0-indexing
    min_distance = float('inf')  # Start with a large distance

    # Check both directions: to the left and right of zane's house
    for i in range(n):
        if houses[i] > 0 and houses[i] <= money:  # Check if house can be bought
            distance = abs(i - start) * 10  # Calculate distance in meters
            min_distance = min(min_distance, distance)  # Update minimum distance

    return min_distance

# Print the result
print(findHouseToBuy(n, zane, money))"
864,A,Fair Game,PROGRAMMING,"['implementation', 'sortings']","Petya and Vasya decided to play a game. They have *n* cards (*n* is an even number). A single integer is written on each card.

Before the game Petya will choose an integer and after that Vasya will choose another integer (different from the number that Petya chose). During the game each player takes all the cards with number he chose. For example, if Petya chose number 5 before the game he will take all cards on which 5 is written and if Vasya chose number 10 before the game he will take all cards on which 10 is written.

The game is considered fair if Petya and Vasya can take all *n* cards, and the number of cards each player gets is the same.

Determine whether Petya and Vasya can choose integer numbers before the game so that the game is fair.","The first line contains a single integer *n* (2<=≤<=*n*<=≤<=100) — number of cards. It is guaranteed that *n* is an even number.

The following *n* lines contain a sequence of integers *a*1,<=*a*2,<=...,<=*a**n* (one integer per line, 1<=≤<=*a**i*<=≤<=100) — numbers written on the *n* cards.","If it is impossible for Petya and Vasya to choose numbers in such a way that the game will be fair, print ""NO"" (without quotes) in the first line. In this case you should not print anything more.

In the other case print ""YES"" (without quotes) in the first line. In the second line print two distinct integers — number that Petya should choose and the number that Vasya should choose to make the game fair. If there are several solutions, print any of them.","['4\n11\n27\n27\n11\n', '2\n6\n6\n', '6\n10\n20\n30\n20\n10\n20\n', '6\n1\n1\n2\n2\n3\n3\n']","['YES\n11 27\n', 'NO\n', 'NO\n', 'NO\n']","In the first example the game will be fair if, for example, Petya chooses number 11, and Vasya chooses number 27. Then the will take all cards — Petya will take cards 1 and 4, and Vasya will take cards 2 and 3. Thus, each of them will take exactly two cards.

In the second example fair game is impossible because the numbers written on the cards are equal, but the numbers that Petya and Vasya should choose should be distinct.

In the third example it is impossible to take all cards. Petya and Vasya can take at most five cards — for example, Petya can choose number 10 and Vasya can choose number 20. But for the game to be fair it is necessary to take 6 cards.",WRONG_ANSWER,"read = lambda: tuple(map(int, input().split()))
n = read()[0]
arr = sorted([read()[0] for i in range(n)])
arrN = []
c = -1
k = 0
for el in arr:
    if el != c:
        arrN += [[k, c]]
        c = el
        k = 0
    k += 1
arrN += [[k, c]]
arrN = arrN[1:]
if len(arrN) != 2: print(""NO"")
elif arrN[0][0] == arrN[1][0]: print(""YES"")
else: print(""NO"")
    
","import math

PI = 3.141592653589793
r_max = 0
r_min = 2 * (10**12)

def dot(v1, v2):
    return v1[0] * v2[0] + v1[1] * v2[1]

def vector_length(v):
    return math.sqrt(dot(v, v))

def get_radius(p, vertex):
    # Calculate the distance from point P to the vertex
    return vector_length((vertex[0] - p[0], vertex[1] - p[1]))

def main():
    global r_max, r_min
    
    # Read input
    n, p_x, p_y = map(int, input().split())
    P = (p_x, p_y)
    
    vertices = []
    for _ in range(n):
        x, y = map(int, input().split())
        vertices.append((x, y))
    
    # Calculate the maximum and minimum distances from point P to polygon vertices
    for vertex in vertices:
        r = get_radius(P, vertex)
        r_max = max(r_max, r)
        r_min = min(r_min, r)
    
    # Calculate areas
    area_cleared = PI * (r_max**2 - r_min**2)
    
    # Print the result
    print(f""{area_cleared:.9f}"")

if __name__ == ""__main__"":
    main()"
725,B,Food on the Plane,PROGRAMMING,"['implementation', 'math']","A new airplane SuperPuperJet has an infinite number of rows, numbered with positive integers starting with 1 from cockpit to tail. There are six seats in each row, denoted with letters from 'a' to 'f'. Seats 'a', 'b' and 'c' are located to the left of an aisle (if one looks in the direction of the cockpit), while seats 'd', 'e' and 'f' are located to the right. Seats 'a' and 'f' are located near the windows, while seats 'c' and 'd' are located near the aisle. 

 

It's lunch time and two flight attendants have just started to serve food. They move from the first rows to the tail, always maintaining a distance of two rows from each other because of the food trolley. Thus, at the beginning the first attendant serves row 1 while the second attendant serves row 3. When both rows are done they move one row forward: the first attendant serves row 2 while the second attendant serves row 4. Then they move three rows forward and the first attendant serves row 5 while the second attendant serves row 7. Then they move one row forward again and so on.

Flight attendants work with the same speed: it takes exactly 1 second to serve one passenger and 1 second to move one row forward. Each attendant first serves the passengers on the seats to the right of the aisle and then serves passengers on the seats to the left of the aisle (if one looks in the direction of the cockpit). Moreover, they always serve passengers in order from the window to the aisle. Thus, the first passenger to receive food in each row is located in seat 'f', and the last one — in seat 'c'. Assume that all seats are occupied.

Vasya has seat *s* in row *n* and wants to know how many seconds will pass before he gets his lunch.","The only line of input contains a description of Vasya's seat in the format *ns*, where *n* (1<=≤<=*n*<=≤<=1018) is the index of the row and *s* is the seat in this row, denoted as letter from 'a' to 'f'. The index of the row and the seat are not separated by a space.",Print one integer — the number of seconds Vasya has to wait until he gets his lunch.,"['1f\n', '2d\n', '4a\n', '5e\n']","['1\n', '10\n', '11\n', '18\n']","In the first sample, the first flight attendant serves Vasya first, so Vasya gets his lunch after 1 second.

In the second sample, the flight attendants will spend 6 seconds to serve everyone in the rows 1 and 3, then they will move one row forward in 1 second. As they first serve seats located to the right of the aisle in order from window to aisle, Vasya has to wait 3 more seconds. The total is 6 + 1 + 3 = 10.",OK,"c=input();n,s,d=int(c[:-1]),c[-1],{'a':4,'b':5,'c':6,'d':3,'e':2,'f':1}
x=(n//4*2+(n-1)%2-2*(n%4==0))*6+d[s]+n
print(x-1 if (n-1)%4<2 else x-3)","import sys

#sys.stdin = open(""input.txt"", ""r"")
#sys.stdout = open(""output.txt"", ""w"")

# Read the two binary numbers from input
a = sys.stdin.readline().strip()
b = sys.stdin.readline().strip()

# Initialize the result as an empty string
result = ''

# Iterate through both binary numbers
for digit_a, digit_b in zip(a, b):
    # If the digits differ, append '1' to the result, otherwise append '0'
    if digit_a != digit_b:
        result += '1'
    else:
        result += '0'

# Print the final result
print(result)"
574,A,Bear and Elections,PROGRAMMING,"['greedy', 'implementation']","Limak is a grizzly bear who desires power and adoration. He wants to win in upcoming elections and rule over the Bearland.

There are *n* candidates, including Limak. We know how many citizens are going to vote for each candidate. Now *i*-th candidate would get *a**i* votes. Limak is candidate number 1. To win in elections, he must get strictly more votes than any other candidate.

Victory is more important than everything else so Limak decided to cheat. He will steal votes from his opponents by bribing some citizens. To bribe a citizen, Limak must give him or her one candy - citizens are bears and bears like candies. Limak doesn't have many candies and wonders - how many citizens does he have to bribe?","The first line contains single integer *n* (2<=≤<=*n*<=≤<=100) - number of candidates.

The second line contains *n* space-separated integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=1000) - number of votes for each candidate. Limak is candidate number 1.

Note that after bribing number of votes for some candidate might be zero or might be greater than 1000.",Print the minimum number of citizens Limak must bribe to have strictly more votes than any other candidate.,"['5\n5 1 11 2 8\n', '4\n1 8 8 8\n', '2\n7 6\n']","['4\n', '6\n', '0\n']","In the first sample Limak has 5 votes. One of the ways to achieve victory is to bribe 4 citizens who want to vote for the third candidate. Then numbers of votes would be 9, 1, 7, 2, 8 (Limak would have 9 votes). Alternatively, Limak could steal only 3 votes from the third candidate and 1 vote from the second candidate to get situation 9, 0, 8, 2, 8.

In the second sample Limak will steal 2 votes from each candidate. Situation will be 7, 6, 6, 6.

In the third sample Limak is a winner without bribing any citizen.",OK,"n=int(input())
arr=list(map(int,input().split()))
t=ans=arr.pop(0)
mx=max(arr)
i=1
while (ans)<=mx:
    ans+=1
    arr.remove(mx)
    arr.append(mx-1)
    mx=max(arr)
print(ans-t)","n = int(input())

res = []
for _ in range(n):
    a, b = [int(x) for x in input().split()]
    res.append((a, b))

# Sort vectors by their magnitude in descending order
res = sorted(enumerate(res), key=lambda x: x[1][0] ** 2 + x[1][1] ** 2, reverse=True)

# Initialize position and signs list
position = [0, 0]
signs = [0] * n

# Choose signs to keep the position within bounds
for index, (x, y) in res:
    if abs(position[0] + x) <= 1.5 * 10**6 and abs(position[1] + y) <= 1.5 * 10**6:
        position[0] += x
        position[1] += y
        signs[index] = 1
    else:
        position[0] -= x
        position[1] -= y
        signs[index] = -1

# Output the signs for each move
print("" "".join(map(str, signs)))"
71,A,Way Too Long Words,PROGRAMMING,['strings'],"Sometimes some words like ""localization"" or ""internationalization"" are so long that writing them many times in one text is quite tiresome.

Let's consider a word too long, if its length is strictly more than 10 characters. All too long words should be replaced with a special abbreviation.

This abbreviation is made like this: we write down the first and the last letter of a word and between them we write the number of letters between the first and the last letters. That number is in decimal system and doesn't contain any leading zeroes.

Thus, ""localization"" will be spelt as ""l10n"", and ""internationalization» will be spelt as ""i18n"".

You are suggested to automatize the process of changing the words with abbreviations. At that all too long words should be replaced by the abbreviation and the words that are not too long should not undergo any changes.",The first line contains an integer *n* (1<=≤<=*n*<=≤<=100). Each of the following *n* lines contains one word. All the words consist of lowercase Latin letters and possess the lengths of from 1 to 100 characters.,Print *n* lines. The *i*-th line should contain the result of replacing of the *i*-th word from the input data.,['4\nword\nlocalization\ninternationalization\npneumonoultramicroscopicsilicovolcanoconiosis\n'],['word\nl10n\ni18n\np43s\n'],none,WRONG_ANSWER,"liV = int(input())
ChaList = []
liIn = 0
while liIn < liV:
    ChaList.append(input())
    liIn = liIn+1
for j in ChaList:
         
    if len(j) <= 10:
        print (j)
    else:
        jl = len(j)-2
        print(print (j[0] + str(jl)+j[-1]))","class Solution:
    def getList(self):
        return list(map(int, input().split()))
    
    def solve(self):
        n, k = input().split()
        n = int(n)
        k = int(k)
        
        a = self.getList()  # grams of ingredients required for one cookie
        b = self.getList()  # grams of ingredients available
        
        low, high = 0, 10**9  # Possible range for the number of cookies
        
        # Function to check if we can make `mid` cookies
        def can_make_cookies(mid):
            total_needed = 0
            for i in range(n):
                required = a[i] * mid  # total grams required for this ingredient
                if required > b[i]:
                    total_needed += required - b[i]  # grams to make up with magic powder
            return total_needed <= k  # can we do it with available magic powder?

        # Binary search to find the maximum number of cookies
        while low < high:
            mid = (low + high + 1) // 2
            if can_make_cookies(mid):
                low = mid  # we can make mid cookies, try for more
            else:
                high = mid - 1  # can't make mid cookies, try less
        
        print(low)  # The maximum number of cookies that can be baked"
233,A,Perfect Permutation,PROGRAMMING,"['implementation', 'math']","A permutation is a sequence of integers *p*1,<=*p*2,<=...,<=*p**n*, consisting of *n* distinct positive integers, each of them doesn't exceed *n*. Let's denote the *i*-th element of permutation *p* as *p**i*. We'll call number *n* the size of permutation *p*1,<=*p*2,<=...,<=*p**n*.

Nickolas adores permutations. He likes some permutations more than the others. He calls such permutations perfect. A perfect permutation is such permutation *p* that for any *i* (1<=≤<=*i*<=≤<=*n*) (*n* is the permutation size) the following equations hold *p**p**i*<==<=*i* and *p**i*<=≠<=*i*. Nickolas asks you to print any perfect permutation of size *n* for the given *n*.",A single line contains a single integer *n* (1<=≤<=*n*<=≤<=100) — the permutation size.,"If a perfect permutation of size *n* doesn't exist, print a single integer -1. Otherwise print *n* distinct integers from 1 to *n*, *p*1,<=*p*2,<=...,<=*p**n* — permutation *p*, that is perfect. Separate printed numbers by whitespaces.","['1\n', '2\n', '4\n']","['-1\n', '2 1 \n', '2 1 4 3 \n']",none,WRONG_ANSWER,"#PAR-> 2,1,4,3,6,5,...
#IMPAR-> ...,5,4,3,2,1
N=int(input())
if(N==1):
    print(-1)
elif(N%2==0):
    Cad=""""
    for K in range(2,N+1,2):
        Cad=Cad+str(K)+"" ""+str(K-1)+"" ""
    print(Cad[:len(Cad)-1])
else:
    Cad=""""
    for K in range(N,0,-1):
        Cad=Cad+str(K)+"" ""
    print(Cad[:len(Cad)-1])
        
","from collections import deque

def bfs(start, n):
    distance = [-1] * (n + 1)
    distance[start] = 0
    q = deque([start])
    
    while q:
        node = q.popleft()
        for neighbor in adj[node]:
            if distance[neighbor] == -1:  # Unvisited
                distance[neighbor] = distance[node] + 1
                q.append(neighbor)
    
    return distance

# Read room connections
n = int(input())
adj = {i: [] for i in range(1, n + 1)}

for _ in range(n - 1):
    a, b = map(int, input().split())
    adj[a].append(b)
    adj[b].append(a)

# Precompute distances from each room
distances = {}
for room in range(1, n + 1):
    distances[room] = bfs(room, n)

# Read number of queries
m = int(input())
results = []

for _ in range(m):
    x, y = map(int, input().split())
    d = distances[x]
    d_y = distances[y]
    
    # Count the number of equidistant rooms
    count = 0
    for k in range(1, n + 1):
        if d[k] == d_y[k]:
            count += 1
    
    results.append(count)

# Output results for each query
for result in results:
    print(result)"
192,A,Funky Numbers,PROGRAMMING,"['binary search', 'brute force', 'implementation']","As you very well know, this year's funkiest numbers are so called triangular numbers (that is, integers that are representable as , where *k* is some positive integer), and the coolest numbers are those that are representable as a sum of two triangular numbers.

A well-known hipster Andrew adores everything funky and cool but unfortunately, he isn't good at maths. Given number *n*, help him define whether this number can be represented by a sum of two triangular numbers (not necessarily different)!",The first input line contains an integer *n* (1<=≤<=*n*<=≤<=109).,"Print ""YES"" (without the quotes), if *n* can be represented as a sum of two triangular numbers, otherwise print ""NO"" (without the quotes).","['256\n', '512\n']","['YES\n', 'NO\n']","In the first sample number <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/92095692c6ea93e9e3b837a0408ba7543549d5b2.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>.

In the second sample number 512 can not be represented as a sum of two triangular numbers.",WRONG_ANSWER,"v=input()
v1=int(v)
vv=[]
v2=int(v[-1])
for i in range(2,v2):
    if v2%i==0 and v2//i != 0:
        vv.append(i)
if len(vv) >= 2:
    q1, q2 = vv[0], vv[1]
    x1 = (q1 * q2) // 2
    x2 = ((q1 * 11) * (q1 * 11 + 1)) // 2
    if x1 + x2 == v1:
        print(""YES"")
    else:
        print(""NO"")
else:
    print(""NO"")
","import time

def calculateWinner(lenS, first_tps, sec_tps, first_ping, sec_ping):
    winner = """"

    first_ttime = lenS * first_tps + 2 * first_ping  # Total time for the first participant
    sec_ttime = lenS * sec_tps + 2 * sec_ping        # Total time for the second participant

    # Determine the winner based on the calculated times
    if first_ttime < sec_ttime:
        winner = ""First""
    elif first_ttime > sec_ttime:
        winner = ""Second""
    else:
        winner = ""Friendship""

    return winner

# Example usage:
s, v1, v2, t1, t2 = map(int, input().split())
print(calculateWinner(s, v1, v2, t1, t2))"
266,A,Stones on the Table,PROGRAMMING,['implementation'],"There are *n* stones on the table in a row, each of them can be red, green or blue. Count the minimum number of stones to take from the table so that any two neighboring stones had different colors. Stones in a row are considered neighboring if there are no other stones between them.","The first line contains integer *n* (1<=≤<=*n*<=≤<=50) — the number of stones on the table. 

The next line contains string *s*, which represents the colors of the stones. We'll consider the stones in the row numbered from 1 to *n* from left to right. Then the *i*-th character *s* equals ""R"", if the *i*-th stone is red, ""G"", if it's green and ""B"", if it's blue.",Print a single integer — the answer to the problem.,"['3\nRRG\n', '5\nRRRRR\n', '4\nBRBG\n']","['1\n', '4\n', '0\n']",none,OK,"n = input()
n = int(n)

stones = input()

ans = 0

for i in range(1, n):
    if stones[i] == stones[i-1]:
        ans = ans + 1

print(ans)


		  	  			  		  							 			","import sys

def mi(s):
    return map(int, s.strip().split())

def lmi(s):
    return list(mi(s))

def count_bear_pairs(s):
    count = 0
    n = len(s)
    bear_substring_positions = []

    # Find all starting positions of the substring ""bear""
    for i in range(n - 3):
        if s[i:i + 4] == ""bear"":
            bear_substring_positions.append(i)

    # Count pairs (i, j) for each found ""bear"" position
    for start in bear_substring_positions:
        # Each ""bear"" found at index `start` contributes pairs
        # (1 <= i <= start + 1) and (start + 4 <= j <= n)
        # This gives a range for i: 1 to start + 1
        # And for j: start + 4 to n
        count += (start + 1) * (n - (start + 3))

    return count

# Read the input string
s = sys.stdin.readline().strip()

# Output the result
print(count_bear_pairs(s))"
792,B,Counting-out Rhyme,PROGRAMMING,['implementation'],"*n* children are standing in a circle and playing the counting-out game. Children are numbered clockwise from 1 to *n*. In the beginning, the first child is considered the leader. The game is played in *k* steps. In the *i*-th step the leader counts out *a**i* people in clockwise order, starting from the next person. The last one to be pointed at by the leader is eliminated, and the next player after him becomes the new leader.

For example, if there are children with numbers [8,<=10,<=13,<=14,<=16] currently in the circle, the leader is child 13 and *a**i*<==<=12, then counting-out rhyme ends on child 16, who is eliminated. Child 8 becomes the leader.

You have to write a program which prints the number of the child to be eliminated on every step.","The first line contains two integer numbers *n* and *k* (2<=≤<=*n*<=≤<=100, 1<=≤<=*k*<=≤<=*n*<=-<=1).

The next line contains *k* integer numbers *a*1,<=*a*2,<=...,<=*a**k* (1<=≤<=*a**i*<=≤<=109).","Print *k* numbers, the *i*-th one corresponds to the number of child to be eliminated at the *i*-th step.","['7 5\n10 4 11 4 1\n', '3 2\n2 5\n']","['4 2 5 6 1 \n', '3 2 \n']","Let's consider first example: 
 -  In the first step child 4 is eliminated, child 5 becomes the leader. -  In the second step child 2 is eliminated, child 3 becomes the leader. -  In the third step child 5 is eliminated, child 6 becomes the leader. -  In the fourth step child 6 is eliminated, child 7 becomes the leader. -  In the final step child 1 is eliminated, child 3 becomes the leader.",OK,"import sys
input = sys.stdin.readline
n, k = map(int, input().split())
l = sorted(list(range(1, n+1)))
c = 0
t = []
for i in [int(j) for j in input().split()]:
    c = (c+i)%len(l)
    t.append(l[c])
    l = l[:c]+l[c+1:]
print(*t)
","a = int(input())

def lucky(no):
    while no != 0:
        x = no % 10
        if x != 4 and x != 7:
            return False
        no //= 10
    return True

# Check for all lucky numbers up to 1000
for i in range(1, a + 1):
    if lucky(i):
        if a % i == 0:
            print(""YES"")
            break
else:
    print(""NO"")"
412,A,Poster,PROGRAMMING,"['greedy', 'implementation']","The R1 company has recently bought a high rise building in the centre of Moscow for its main office. It's time to decorate the new office, and the first thing to do is to write the company's slogan above the main entrance to the building.

The slogan of the company consists of *n* characters, so the decorators hung a large banner, *n* meters wide and 1 meter high, divided into *n* equal squares. The first character of the slogan must be in the first square (the leftmost) of the poster, the second character must be in the second square, and so on.

Of course, the R1 programmers want to write the slogan on the poster themselves. To do this, they have a large (and a very heavy) ladder which was put exactly opposite the *k*-th square of the poster. To draw the *i*-th character of the slogan on the poster, you need to climb the ladder, standing in front of the *i*-th square of the poster. This action (along with climbing up and down the ladder) takes one hour for a painter. The painter is not allowed to draw characters in the adjacent squares when the ladder is in front of the *i*-th square because the uncomfortable position of the ladder may make the characters untidy. Besides, the programmers can move the ladder. In one hour, they can move the ladder either a meter to the right or a meter to the left.

Drawing characters and moving the ladder is very tiring, so the programmers want to finish the job in as little time as possible. Develop for them an optimal poster painting plan!","The first line contains two integers, *n* and *k* (1<=≤<=*k*<=≤<=*n*<=≤<=100) — the number of characters in the slogan and the initial position of the ladder, correspondingly. The next line contains the slogan as *n* characters written without spaces. Each character of the slogan is either a large English letter, or digit, or one of the characters: '.', '!', ',', '?'.","In *t* lines, print the actions the programmers need to make. In the *i*-th line print:
 -  ""LEFT"" (without the quotes), if the *i*-th action was ""move the ladder to the left""; -  ""RIGHT"" (without the quotes), if the *i*-th action was ""move the ladder to the right""; -  ""PRINT *x*"" (without the quotes), if the *i*-th action was to ""go up the ladder, paint character *x*, go down the ladder"". 
The painting time (variable *t*) must be minimum possible. If there are multiple optimal painting plans, you can print any of them.","['2 2\nR1\n', '2 1\nR1\n', '6 4\nGO?GO!\n']","['PRINT 1\nLEFT\nPRINT R\n', 'PRINT R\nRIGHT\nPRINT 1\n', 'RIGHT\nRIGHT\nPRINT !\nLEFT\nPRINT O\nLEFT\nPRINT G\nLEFT\nPRINT ?\nLEFT\nPRINT O\nLEFT\nPRINT G\n']","Note that the ladder cannot be shifted by less than one meter. The ladder can only stand in front of some square of the poster. For example, you cannot shift a ladder by half a meter and position it between two squares. Then go up and paint the first character and the second character.",OK,"n,k=map(int,input('').split())                   
lozung=list(input())
if n-k<k:
    for i in range(k,n):
        print('RIGHT')
    for i in reversed(range(0,n)):
        print ('PRINT ',lozung[i])
        if i!=0:print('LEFT')
else:
#    print('2')
    for i in reversed(range(0,k-1)):
        print('LEFT')
    for i in range(n):
        print ('PRINT ',lozung[i])
        if i!=n-1:print('RIGHT')
                

","n = int(input())      # tamaño de las sucesiones
a_n = list(map(int, input().split()))  # sucesion a_n
b_n = list(map(int, input().split()))  # sucesion b_n
m = int(input())      # numero para obtener un resultado de la forma km + r con 0 <= r < m

def solution(n, a_n, b_n, m):
    from collections import Counter
    from math import comb
    
    c_n = Counter(a_n) + Counter(b_n)  # unión de a_n y b_n
    d_n = Counter(a_n) & Counter(b_n)  # intercepcción de a_n y b_n
    
    total_ways = 1  # inicializar contador de maneras
    
    for num in c_n:  # para cada número en la unión
        count_a = c_n[num]  # contar en c_n
        count_b = d_n[num]  # contar en d_n
        
        # Calculando combinaciones posibles
        total_ways *= comb(count_a, count_b) % m
        total_ways %= m
        
    # Devolver el resultado
    return total_ways

# Llamar a la función y mostrar el resultado
print(solution(n, a_n, b_n, m))"
690,C1,Brain Network (easy),PROGRAMMING,[],"One particularly well-known fact about zombies is that they move and think terribly slowly. While we still don't know why their movements are so sluggish, the problem of laggy thinking has been recently resolved. It turns out that the reason is not (as previously suspected) any kind of brain defect – it's the opposite! Independent researchers confirmed that the nervous system of a zombie is highly complicated – it consists of *n* brains (much like a cow has several stomachs). They are interconnected by brain connectors, which are veins capable of transmitting thoughts between brains. There are two important properties such a brain network should have to function properly: 
 1.  It should be possible to exchange thoughts between any two pairs of brains (perhaps indirectly, through other brains). 1.  There should be no redundant brain connectors, that is, removing any brain connector would make property 1 false. 
If both properties are satisfied, we say that the nervous system is valid. Unfortunately (?), if the system is not valid, the zombie stops thinking and becomes (even more) dead. Your task is to analyze a given nervous system of a zombie and find out whether it is valid.","The first line of the input contains two space-separated integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=1000) denoting the number of brains (which are conveniently numbered from 1 to *n*) and the number of brain connectors in the nervous system, respectively. In the next *m* lines, descriptions of brain connectors follow. Every connector is given as a pair of brains *a* *b* it connects (1<=≤<=*a*,<=*b*<=≤<=*n*, *a*<=≠<=*b*).","The output consists of one line, containing either yes or no depending on whether the nervous system is valid.","['4 4\n1 2\n2 3\n3 1\n4 1\n', '6 5\n1 2\n2 3\n3 4\n4 5\n3 6\n']","['no\n', 'yes\n']",none,WRONG_ANSWER,"n,m=map(int,input().split())
L=[]
for k in range(n):
    L.append(0)
for k in range(m):
    a,b=map(int,input().split())
    L[a-1]+=1
    L[b-1]+=1
if n!=m+1 or 0 in L:
    print(""no"")
else:
    print(""yes"")
","# n - passengers
n, m = map(int, input().split())
args = list(map(int, input().split()))
args.sort()

# Calculate maximum earnings
max_profit = 0
for i in range(n):
    max_profit += args[-1]  # Last element (most empty seats)
    args[-1] -= 1  # Reduce the number of empty seats

# Reset seats for minimum calculation
args.sort()

# Calculate minimum earnings
min_profit = 0
for i in range(n):
    min_profit += args[0]  # First element (least empty seats)
    args[0] -= 1  # Reduce the number of empty seats
    args.sort()  # Sort again

# Output the results
print(max_profit, min_profit)"
461,A,Appleman and Toastman,PROGRAMMING,"['greedy', 'sortings']","Appleman and Toastman play a game. Initially Appleman gives one group of *n* numbers to the Toastman, then they start to complete the following tasks:
 -  Each time Toastman gets a group of numbers, he sums up all the numbers and adds this sum to the score. Then he gives the group to the Appleman. -  Each time Appleman gets a group consisting of a single number, he throws this group out. Each time Appleman gets a group consisting of more than one number, he splits the group into two non-empty groups (he can do it in any way) and gives each of them to Toastman. 
After guys complete all the tasks they look at the score value. What is the maximum possible value of score they can get?","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=3·105). The second line contains *n* integers *a*1, *a*2, ..., *a**n* (1<=≤<=*a**i*<=≤<=106) — the initial group that is given to Toastman.",Print a single integer — the largest possible score.,"['3\n3 1 5\n', '1\n10\n']","['26\n', '10\n']","Consider the following situation in the first example. Initially Toastman gets group [3, 1, 5] and adds 9 to the score, then he give the group to Appleman. Appleman splits group [3, 1, 5] into two groups: [3, 5] and [1]. Both of them should be given to Toastman. When Toastman receives group [1], he adds 1 to score and gives the group to Appleman (he will throw it out). When Toastman receives group [3, 5], he adds 8 to the score and gives the group to Appleman. Appleman splits [3, 5] in the only possible way: [5] and [3]. Then he gives both groups to Toastman. When Toastman receives [5], he adds 5 to the score and gives the group to Appleman (he will throws it out). When Toastman receives [3], he adds 3 to the score and gives the group to Appleman (he will throws it out). Finally Toastman have added 9 + 1 + 8 + 5 + 3 = 26 to the score. This is the optimal sequence of actions.",WRONG_ANSWER,"n=int(input())
list1=[int(i) for i in input().split()]
m=0
if n==1:
    print(list1[0])
elif n==2:
    print(sum(list1)*2)
else:
    list1.sort()
    list1.reverse()
    for i in range(0,n,1):
        m=m+list1[i]*(n-i+1)
print(m-list1[0])","def count_magical_subarrays(n, a):
    count = 0
    length = 1
    
    for i in range(1, n):
        # Check if the current element is the same as the previous one
        if a[i] == a[i - 1]:
            length += 1
        else:
            # If not, calculate the number of magical subarrays for the previous segment
            count += (length * (length + 1)) // 2
            length = 1  # Reset length for a new segment
    
    # Add the last segment's magical subarrays
    count += (length * (length + 1)) // 2
    
    return count

# Read input
n = int(input())
a = list(map(int, input().split()))

# Output the result
print(count_magical_subarrays(n, a))"
520,A,Pangram,PROGRAMMING,"['implementation', 'strings']","A word or a sentence in some language is called a pangram if all the characters of the alphabet of this language appear in it at least once. Pangrams are often used to demonstrate fonts in printing or test the output devices.

You are given a string consisting of lowercase and uppercase Latin letters. Check whether this string is a pangram. We say that the string contains a letter of the Latin alphabet if this letter occurs in the string in uppercase or lowercase.","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=100) — the number of characters in the string.

The second line contains the string. The string consists only of uppercase and lowercase Latin letters.","Output ""YES"", if the string is a pangram and ""NO"" otherwise.","['12\ntoosmallword\n', '35\nTheQuickBrownFoxJumpsOverTheLazyDog\n']","['NO\n', 'YES\n']",none,OK,"n=int(input())
ch=input()
m=0
letter='abcdefghijklmnopqrstuvwxyz'
for i in letter:
    if i not in ch.lower():
        m=1
if m==1:
    print(""No"")
else:
    print(""Yes"")
			 	 	 	   		 	 			 	   	 	","from collections import defaultdict, deque

n, m = map(int, input().split())
c = list(map(int, input().split()))

# Create an adjacency list to represent friendships
friends = defaultdict(list)

# Read friendships
for _ in range(m):
    x, y = map(int, input().split())
    friends[x - 1].append(y - 1)
    friends[y - 1].append(x - 1)

visited = [False] * n
min_total_cost = 0

# Function to perform BFS and find the minimum cost to spread rumor in a component
def bfs(start):
    queue = deque([start])
    visited[start] = True
    min_cost = c[start]
    
    while queue:
        node = queue.popleft()
        for neighbor in friends[node]:
            if not visited[neighbor]:
                visited[neighbor] = True
                queue.append(neighbor)
                min_cost = min(min_cost, c[neighbor])  # Find the minimum cost
    
    return min_cost

# Iterate through all characters and find disconnected components
for i in range(n):
    if not visited[i]:
        # Calculate the minimum cost for the current component
        min_cost_in_component = bfs(i)
        min_total_cost += min_cost_in_component

# Output the result
print(min_total_cost)"
231,A,Team,PROGRAMMING,"['brute force', 'greedy']","One day three best friends Petya, Vasya and Tonya decided to form a team and take part in programming contests. Participants are usually offered several problems during programming contests. Long before the start the friends decided that they will implement a problem if at least two of them are sure about the solution. Otherwise, the friends won't write the problem's solution.

This contest offers *n* problems to the participants. For each problem we know, which friend is sure about the solution. Help the friends find the number of problems for which they will write a solution.","The first input line contains a single integer *n* (1<=≤<=*n*<=≤<=1000) — the number of problems in the contest. Then *n* lines contain three integers each, each integer is either 0 or 1. If the first number in the line equals 1, then Petya is sure about the problem's solution, otherwise he isn't sure. The second number shows Vasya's view on the solution, the third number shows Tonya's view. The numbers on the lines are separated by spaces.",Print a single integer — the number of problems the friends will implement on the contest.,"['3\n1 1 0\n1 1 1\n1 0 0\n', '2\n1 0 0\n0 1 1\n']","['2\n', '1\n']","In the first sample Petya and Vasya are sure that they know how to solve the first problem and all three of them know how to solve the second problem. That means that they will write solutions for these problems. Only Petya is sure about the solution for the third problem, but that isn't enough, so the friends won't take it. 

In the second sample the friends will only implement the second problem, as Vasya and Tonya are sure about the solution.",RUNTIME_ERROR,"exit = 0
while (exit != 1):
    problemInput = input()
    if problemInput >= 1 and problemInput <= 1000:
        n = 0
        output = 0
        while (n <= problemInput):
            checkSolution = input()
            splitCheck = int(checkSolution.split())
            print(splitCheck)
            posSolutions = 0
            for solCheck in range(len(splitCheck)):
                posSolutions += splitCheck[solCheck]
            
            if posSolutions > 1 and posSolutions < 4:
                output += 1



            n += 1
        
        print(output)
        exit = 1

    else:
        print(""Please input integer between 1 and 1000"")


","def move(path, actual, end, maxDist, best, count):
    if actual == end - 1:
        if best[0] == -1: 
            best[0] = count
        if count < best[0]:
            best[0] = count
        return
    
    for jump in range(1, maxDist + 1):
        next_position = actual + jump
        if next_position < end and path[next_position] == '1':  # There's a lily at the next position
            move(path, next_position, end, maxDist, best, count + 1)

def frog_jump(n, d, s):
    best = [-1]  # Initially, the best count of jumps is unknown (-1)
    move(s, 0, n, d, best, 0)  # Start from index 0 (which is the first point)
    return best[0]

# Input reading
n, d = map(int, input().split())
s = input().strip()

# Print the result
print(frog_jump(n, d, s))"
182,B,Vasya's Calendar,PROGRAMMING,['implementation'],"Vasya lives in a strange world. The year has *n* months and the *i*-th month has *a**i* days. Vasya got a New Year present — the clock that shows not only the time, but also the date.

The clock's face can display any number from 1 to *d*. It is guaranteed that *a**i*<=≤<=*d* for all *i* from 1 to *n*. The clock does not keep information about the current month, so when a new day comes, it simply increases the current day number by one. The clock cannot display number *d*<=+<=1, so after day number *d* it shows day 1 (the current day counter resets). The mechanism of the clock allows you to increase the day number by one manually. When you execute this operation, day *d* is also followed by day 1.

Vasya begins each day checking the day number on the clock. If the day number on the clock does not match the actual day number in the current month, then Vasya manually increases it by one. Vasya is persistent and repeats this operation until the day number on the clock matches the actual number of the current day in the current month.

A year passed and Vasya wonders how many times he manually increased the day number by one, from the first day of the first month to the last day of the *n*-th month inclusive, considering that on the first day of the first month the clock display showed day 1.","The first line contains the single number *d* — the maximum number of the day that Vasya's clock can show (1<=≤<=*d*<=≤<=106).

The second line contains a single integer *n* — the number of months in the year (1<=≤<=*n*<=≤<=2000).

The third line contains *n* space-separated integers: *a**i* (1<=≤<=*a**i*<=≤<=*d*) — the number of days in each month in the order in which they follow, starting from the first one.",Print a single number — the number of times Vasya manually increased the day number by one throughout the last year.,"['4\n2\n2 2\n', '5\n3\n3 4 3\n', '31\n12\n31 28 31 30 31 30 31 31 30 31 30 31\n']","['2\n', '3\n', '7\n']","In the first sample the situation is like this: 
 -  Day 1. Month 1. The clock shows 1. Vasya changes nothing. -  Day 2. Month 1. The clock shows 2. Vasya changes nothing. -  Day 1. Month 2. The clock shows 3. Vasya manually increases the day number by 1. After that the clock shows 4. Vasya increases the day number by 1 manually. After that the clock shows 1. -  Day 2. Month 2. The clock shows 2. Vasya changes nothing.",RUNTIME_ERROR,"#234B
with open('input.txt',""r"") as file:
    n , k = map(int, file.readline().split("" ""))
    a = list(map(int, file.readline().split("" "")))

    b = a.copy()
    b.sort(reverse=True)
    b = b[:k]
    ans = []
    for i in b:
        ans.append(a.index(i)+ 1)

with open('output.txt',""w"") as writefile:
    writefile.write(str(min(b)) +'\n')
    writefile.write("" "".join(str(x) for x in ans))
","s = input()
sl = []

o = {'>': '<', '}': '{', ']': '[', ')': '('}
def of(c):
    if sl and o[c] == sl[-1]:
        del sl[-1]
        return True
    return False

# Counting replacements and opening brackets
replace_count = 0
opening_count = 0

for c in s:
    if c in o.values():  # If it's an opening bracket
        sl.append(c)
        opening_count += 1
    elif c in o.keys():  # If it's a closing bracket
        if not of(c):
            # If not a valid closing bracket for the last opening
            if sl:  # There's an opening bracket to be matched
                replace_count += 1  # We can consider changing this closing bracket
            else:
                # Unmatched closing bracket
                print(""Impossible"")
                exit()

# After processing, check if any unmatched opening brackets remain
if sl:
    replace_count += len(sl) // 2  # Need to replace half of the unmatched openings to closing brackets

# Output the least number of replacements needed
print(replace_count)"
146,A,Lucky Ticket,PROGRAMMING,['implementation'],"Petya loves lucky numbers very much. Everybody knows that lucky numbers are positive integers whose decimal record contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.

Petya loves tickets very much. As we know, each ticket has a number that is a positive integer. Its length equals *n* (*n* is always even). Petya calls a ticket lucky if the ticket's number is a lucky number and the sum of digits in the first half (the sum of the first *n*<=/<=2 digits) equals the sum of digits in the second half (the sum of the last *n*<=/<=2 digits). Check if the given ticket is lucky.",The first line contains an even integer *n* (2<=≤<=*n*<=≤<=50) — the length of the ticket number that needs to be checked. The second line contains an integer whose length equals exactly *n* — the ticket number. The number may contain leading zeros.,"On the first line print ""YES"" if the given ticket number is lucky. Otherwise, print ""NO"" (without the quotes).","['2\n47\n', '4\n4738\n', '4\n4774\n']","['NO\n', 'NO\n', 'YES\n']","In the first sample the sum of digits in the first half does not equal the sum of digits in the second half (4 ≠ 7).

In the second sample the ticket number is not the lucky number.",OK,"import sys
n = int(input())
s = input()
i = 0

for ch in s:
	if(ch != '4' and ch != '7'):
		print('NO')
		sys.exit(0)
n = int(n/2)
if(sum(map(int,s[:n])) == sum(map(int, s[-n:]))):
	print(""YES"")
else:
	print('NO')

","import collections
import math
import copy

def main():
    n, k = list(map(int, input().split()))

    # Create a list to hold the table
    table = [[0] * n for _ in range(n)]
    
    # Fill the table with numbers from 1 to n*n
    current_num = 1
    for j in range(n):
        for i in range(n):
            table[i][j] = current_num
            current_num += 1
    
    # Calculate the sum of the k-th column
    column_sum = sum(table[i][k - 1] for i in range(n))

    # Print the column sum
    print(column_sum)

    # Print the table
    for row in table:
        print(' '.join(map(str, row)))

main()"
275,A,Lights Out,PROGRAMMING,['implementation'],"Lenny is playing a game on a 3<=×<=3 grid of lights. In the beginning of the game all lights are switched on. Pressing any of the lights will toggle it and all side-adjacent lights. The goal of the game is to switch all the lights off. We consider the toggling as follows: if the light was switched on then it will be switched off, if it was switched off then it will be switched on.

Lenny has spent some time playing with the grid and by now he has pressed each light a certain number of times. Given the number of times each light is pressed, you have to print the current state of each light.",The input consists of three rows. Each row contains three integers each between 0 to 100 inclusive. The *j*-th number in the *i*-th row is the number of times the *j*-th light of the *i*-th row of the grid is pressed.,"Print three lines, each containing three characters. The *j*-th character of the *i*-th line is ""1"" if and only if the corresponding light is switched on, otherwise it's ""0"".","['1 0 0\n0 0 0\n0 0 1\n', '1 0 1\n8 8 8\n2 0 3\n']","['001\n010\n100\n', '010\n011\n100\n']",none,WRONG_ANSWER,"a = []
res = []

for i in range(3):
	b = list(map(int, input().split()))
	a.append(b)
	temp = [0]*3
	res.append(temp)

for i in range(3):
	for j in range(3):
		number_of_times_toggled = 0
		number_of_times_toggled += a[i][j]
		if j>0:
			number_of_times_toggled += a[i][j-1]
		if j<2:
			number_of_times_toggled += a[i][j+1]
		if i > 0:
			number_of_times_toggled += a[i-1][j]
		if i < 2:
			number_of_times_toggled += a[i+1][j]


		if number_of_times_toggled%2 == 0:
			res[i][j] = 1
		else:
			res[i][j] = 0

for arr in res:
	print(*arr)","import math

# Read the dimensions of the square and the size of the flagstone
n, m, a = map(int, input().split())

# Calculate the number of flagstones needed along the length and the width
num_flagstones_length = math.ceil(n / a)
num_flagstones_width = math.ceil(m / a)

# Calculate the total number of flagstones needed
total_flagstones = num_flagstones_length * num_flagstones_width

# Output the result
print(total_flagstones)"
266,B,Queue at the School,PROGRAMMING,"['constructive algorithms', 'graph matchings', 'implementation', 'shortest paths']","During the break the schoolchildren, boys and girls, formed a queue of *n* people in the canteen. Initially the children stood in the order they entered the canteen. However, after a while the boys started feeling awkward for standing in front of the girls in the queue and they started letting the girls move forward each second. 

Let's describe the process more precisely. Let's say that the positions in the queue are sequentially numbered by integers from 1 to *n*, at that the person in the position number 1 is served first. Then, if at time *x* a boy stands on the *i*-th position and a girl stands on the (*i*<=+<=1)-th position, then at time *x*<=+<=1 the *i*-th position will have a girl and the (*i*<=+<=1)-th position will have a boy. The time is given in seconds.

You've got the initial position of the children, at the initial moment of time. Determine the way the queue is going to look after *t* seconds.","The first line contains two integers *n* and *t* (1<=≤<=*n*,<=*t*<=≤<=50), which represent the number of children in the queue and the time after which the queue will transform into the arrangement you need to find. 

The next line contains string *s*, which represents the schoolchildren's initial arrangement. If the *i*-th position in the queue contains a boy, then the *i*-th character of string *s* equals ""B"", otherwise the *i*-th character equals ""G"".","Print string *a*, which describes the arrangement after *t* seconds. If the *i*-th position has a boy after the needed time, then the *i*-th character *a* must equal ""B"", otherwise it must equal ""G"".","['5 1\nBGGBG\n', '5 2\nBGGBG\n', '4 1\nGGGB\n']","['GBGGB\n', 'GGBGB\n', 'GGGB\n']",none,OK,"q, r = map(int, input().split())
t1 = input()
t = []
for o in t1:
    t.append(o)
for j in range(r):
    i = 0
    while i < len(t)-1:
        if t[i] == 'B' and t[i + 1] == 'G':
            t[i], t[i + 1] = t[i + 1], t[i]
            i += 2
        else:
            i += 1
t1 = ''.join(t)
print(t1)
","def console_line_to_int_arr(string):
    return [int(i) for i in string.split("" "")]

########################

n = int(input())
min1, max1 = console_line_to_int_arr(input())
min2, max2 = console_line_to_int_arr(input())
min3, max3 = console_line_to_int_arr(input())

# Start by allocating the minimum required diplomas
d1 = min1
d2 = min2
d3 = min3

# Calculate how many diplomas are allocated so far
allocated = d1 + d2 + d3

# Calculate remaining participants that need diplomas
remaining = n - allocated

# Maximize the number of first degree diplomas
if remaining > 0:
    # Calculate how many more first diplomas can be allocated
    additional_first = min(max1 - d1, remaining)
    d1 += additional_first
    remaining -= additional_first

# Maximize the number of second degree diplomas next
if remaining > 0:
    # Calculate how many more second diplomas can be allocated
    additional_second = min(max2 - d2, remaining)
    d2 += additional_second
    remaining -= additional_second

# The rest will go to the third degree diplomas
d3 += remaining  # Allocate remaining participants to third degree

# Output the result
print(d1, d2, d3)"
1,B,Spreadsheet,PROGRAMMING,"['implementation', 'math']","In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.

The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 

Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.

Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.","The first line of the input contains integer number *n* (1<=≤<=*n*<=≤<=105), the number of coordinates in the test. Then there follow *n* lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .","Write *n* lines, each line should contain a cell coordinates in the other numeration system.",['2\nR23C55\nBC23\n'],['BC23\nR23C55\n'],none,WRONG_ANSWER,"# Hydro submission #644e355674221a4e24c95e98@1682847063427
def transform_string1(s):
    r = ''
    c = ''
    i = 1
    while s[i].isdigit():
        r += s[i]
        i += 1
    i += 1
    while i < len(s) and s[i].isdigit():
        c += s[i]
        i += 1
    c = int(c)
    res = ''
    stack = []
    while c:
        if c % 26:
            stack.append(chr(c % 26 + 64))
        elif c == 26:
            stack.append('Z')
            break
        else:
            stack.append('Z')
        c //= 26
    while stack:
        res += stack.pop()
    res += r
    return res

def transform_string2(s):
    stack = []
    i = 0
    while s[i].isdigit() is False:
        stack.append(s[i])
        i += 1
    r = s[i:]
    c = 0
    for j in range(len(stack)):
        c += (ord(stack[j]) - 64) * (26 ** (len(stack) - j - 1))
    res = 'R' + r + 'C' + str(c)
    return res

n = int(input())
stack = []
for i in range(n):
    s = input()
    if not s[1].isdigit():
        print(transform_string2(s))
    else:
        sign = 1
        i = 2
        while sign and i < len(s):
            if not s[i].isdigit():
                sign -= 1
            i += 1
        if not sign:
            print(transform_string1(s))
        else:
            print(transform_string2(s))","n = int(input())

road = [list(map(int, input().split())) for i in range(n)]

graf = [[] for i in range(n + 1)]

# Populate the graph with directed edges and their costs
for a, b, c in road:
    graf[a].append((b, c))
    graf[b].append((a, c))  # Add reverse road with cost to redirect

# Function to perform DFS to find connected components
def dfs(v, visited):
    stack = [v]
    while stack:
        node = stack.pop()
        for neighbor, _ in graf[node]:
            if not visited[neighbor]:
                visited[neighbor] = True
                stack.append(neighbor)

# Find all connected components
visited = [False] * (n + 1)
components = 0
edges_cost = []

for i in range(1, n + 1):
    if not visited[i]:
        visited[i] = True
        components += 1
        dfs(i, visited)

# If there is more than one component, we need to connect them 
if components > 1:
    # Create a list of edges with their costs to connect components
    for a, b, c in road:
        edges_cost.append((c, a, b))

    # Sort edges based on cost
    edges_cost.sort()

    # Kruskal's algorithm to find the minimum cost to connect all components
    parent = list(range(n + 1))
    
    def find(x):
        if parent[x] != x:
            parent[x] = find(parent[x])
        return parent[x]
    
    def union(x, y):
        rootX = find(x)
        rootY = find(y)
        if rootX != rootY:
            parent[rootY] = rootX

    total_cost = 0
    for cost, a, b in edges_cost:
        if find(a) != find(b):
            union(a, b)
            total_cost += cost

    print(total_cost)
else:
    print(0)"
1,A,Theatre Square,PROGRAMMING,['math'],"Theatre Square in the capital city of Berland has a rectangular shape with the size *n*<=×<=*m* meters. On the occasion of the city's anniversary, a decision was taken to pave the Square with square granite flagstones. Each flagstone is of the size *a*<=×<=*a*.

What is the least number of flagstones needed to pave the Square? It's allowed to cover the surface larger than the Theatre Square, but the Square has to be covered. It's not allowed to break the flagstones. The sides of flagstones should be parallel to the sides of the Square.","The input contains three positive integer numbers in the first line: *n*,<=<=*m* and *a* (1<=≤<=<=*n*,<=*m*,<=*a*<=≤<=109).",Write the needed number of flagstones.,['6 6 4\n'],['4\n'],none,RUNTIME_ERROR,"numeros = input().split()

output = 0
lado = 0
cociente = 0

n = numeros[0]
m = numeros[1]
a = numeros[2]

if(n<m):
    lado = n
else:
    lado = m
    
cociente = int(lado/a)

output = (cociente + 2) * cociente + 1

print(output)","rijec = input()

def racun(rijec):
    zbroj = 0
    n = len(rijec)
    
    # Count the occurrences of 'Q'
    count_Q = rijec.count('Q')
    
    # Loop through the string to find 'A' and count the 'Q's before and after it
    for i in range(n):
        if rijec[i] == 'A':
            # Count 'Q's before the current 'A'
            count_before = rijec[:i].count('Q')
            # Count 'Q's after the current 'A'
            count_after = rijec[i+1:].count('Q')
            # Each combination of 'Q' before and 'Q' after this 'A' forms ""QAQ""
            zbroj += count_before * count_after
            
    return zbroj

# Run the function and print the result
print(racun(rijec))"
912,B,New Year's Eve,PROGRAMMING,"['bitmasks', 'constructive algorithms', 'number theory']","Since Grisha behaved well last year, at New Year's Eve he was visited by Ded Moroz who brought an enormous bag of gifts with him! The bag contains *n* sweet candies from the good ol' bakery, each labeled from 1 to *n* corresponding to its tastiness. No two candies have the same tastiness.

The choice of candies has a direct effect on Grisha's happiness. One can assume that he should take the tastiest ones — but no, the holiday magic turns things upside down. It is the xor-sum of tastinesses that matters, not the ordinary sum!

A xor-sum of a sequence of integers *a*1,<=*a*2,<=...,<=*a**m* is defined as the bitwise XOR of all its elements: , here  denotes the bitwise XOR operation; more about bitwise XOR can be found [here.](https://en.wikipedia.org/wiki/Bitwise_operation#XOR)

Ded Moroz warned Grisha he has more houses to visit, so Grisha can take no more than *k* candies from the bag. Help Grisha determine the largest xor-sum (largest xor-sum means maximum happiness!) he can obtain.",The sole string contains two integers *n* and *k* (1<=≤<=*k*<=≤<=*n*<=≤<=1018).,Output one number — the largest possible xor-sum.,"['4 3\n', '6 6\n']","['7\n', '7\n']","In the first sample case, one optimal answer is 1, 2 and 4, giving the xor-sum of 7.

In the second sample case, one can, for example, take all six candies and obtain the xor-sum of 7.",OK,"n , k = map(int , input().split())

l = list(bin(n))[2:]

if k == 1: print(n)
    
else:

    print ((1 << len(l)) -1)

","# Function to determine the type of progression and find the next number
def find_next_number(sequence):
    a1, a2, a3, a4 = sequence
    
    # Check for arithmetic progression
    if a2 - a1 == a3 - a2 == a4 - a3:
        d = a2 - a1  # common difference
        next_num = a4 + d
        return next_num

    # Check for geometric progression
    if a1 != 0 and a2 % a1 == 0 and a3 % a2 == 0 and a4 % a3 == 0:
        q1 = a2 // a1
        q2 = a3 // a2
        q3 = a4 // a3
        if q1 == q2 == q3:  # common ratio
            next_num = a4 * q1
            return next_num
    
    # If not an arithmetic or geometric progression or next number is not integer
    return 42

# Main function
if __name__ == ""__main__"":
    # Input reading
    sequence = list(map(int, input().split()))
    
    # Output the result
    result = find_next_number(sequence)
    print(result)"
803,A,Maximal Binary Matrix,PROGRAMMING,['constructive algorithms'],"You are given matrix with *n* rows and *n* columns filled with zeroes. You should put *k* ones in it in such a way that the resulting matrix is symmetrical with respect to the main diagonal (the diagonal that goes from the top left to the bottom right corner) and is lexicographically maximal.

One matrix is lexicographically greater than the other if the first different number in the first different row from the top in the first matrix is greater than the corresponding number in the second one.

If there exists no such matrix then output -1.","The first line consists of two numbers *n* and *k* (1<=≤<=*n*<=≤<=100, 0<=≤<=*k*<=≤<=106).",If the answer exists then output resulting matrix. Otherwise output -1.,"['2 1\n', '3 2\n', '2 5\n']","['1 0 \n0 0 \n', '1 0 0 \n0 1 0 \n0 0 0 \n', '-1\n']",none,WRONG_ANSWER,"(n,k) = map(int,input().split())
matrix = [[0] * n for i in range(n)]
if k > n*n:
    print(-1)
else:
    i = n
    while 2 * i - 1 < k:
        for m in range(n-i,n):
            matrix[m][n-i] = 1
            matrix[n-i][m] = 1
        k -= 2*i -1
        i -= 1
    if k == 2:
        matrix[n-i][n-i] = 1
        matrix[n-i+1][n-i+1] = 1
    elif k == 1:
        matrix[n-i][n-i] = 1
    elif k > 2 and k % 2 == 0:
        matrix[n-i+1][n-i+1] = 0
        for l in range(n-i,n-i+ n//2):
            matrix[l][n - i] = 1
            matrix[n - i][l] = 1
    else:
        for l in range(n-i,n-i+(k+1)//2):
            matrix[l][n - i] = 1
            matrix[n - i][l] = 1
    for row in matrix:
        print(' '.join(map(str,row)))","n, m = map(int, input().split())
a = list(map(int, input().split()))
b = list(map(int, input().split()))

# Compute prefix sums
for i in range(1, n):
    a[i] += a[i - 1]

# Result list to gather outputs
result = []

# To find dormitory and room number for each letter
current_dormitory = 0
for letter in b:
    # Move to the right dormitory
    while current_dormitory < n and letter > a[current_dormitory]:
        current_dormitory += 1
    
    # Room number in the current dormitory
    if current_dormitory == 0:
        room_number = letter
    else:
        room_number = letter - a[current_dormitory - 1]
    
    # Append the result for this letter
    result.append((current_dormitory + 1, room_number))

# Print all results
for dormitory, room in result:
    print(dormitory, room)"
139,A,Petr and Book,PROGRAMMING,['implementation'],"One Sunday Petr went to a bookshop and bought a new book on sports programming. The book had exactly *n* pages.

Petr decided to start reading it starting from the next day, that is, from Monday. Petr's got a very tight schedule and for each day of the week he knows how many pages he will be able to read on that day. Some days are so busy that Petr will have no time to read whatsoever. However, we know that he will be able to read at least one page a week.

Assuming that Petr will not skip days and will read as much as he can every day, determine on which day of the week he will read the last page of the book.","The first input line contains the single integer *n* (1<=≤<=*n*<=≤<=1000) — the number of pages in the book.

The second line contains seven non-negative space-separated integers that do not exceed 1000 — those integers represent how many pages Petr can read on Monday, Tuesday, Wednesday, Thursday, Friday, Saturday and Sunday correspondingly. It is guaranteed that at least one of those numbers is larger than zero.","Print a single number — the number of the day of the week, when Petr will finish reading the book. The days of the week are numbered starting with one in the natural order: Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday.","['100\n15 20 20 15 10 30 45\n', '2\n1 0 0 0 0 0 0\n']","['6\n', '1\n']","Note to the first sample:

By the end of Monday and therefore, by the beginning of Tuesday Petr has 85 pages left. He has 65 pages left by Wednesday, 45 by Thursday, 30 by Friday, 20 by Saturday and on Saturday Petr finishes reading the book (and he also has time to read 10 pages of something else).

Note to the second sample:

On Monday of the first week Petr will read the first page. On Monday of the second week Petr will read the second page and will finish reading the book.",WRONG_ANSWER,"import random
limit=0
n = int(input())
read=list(map(int,input().split()))
for i in range(len(read)):
    limit+=read[i]
    if limit >=n:
        print(i+1)
        break
else:
    print(1)

","def to_dec(bina):
    res = 0
    b = 2**len(bina)
    for i in range(len(bina)):
        b = b // 2
        if bina[i] == '1':
            res = res + b
    return res

def add_one(bits):
    n = len(bits)
    bits = list(bits)
    carry = 1  # we want to add 1
    changed_bits = 0

    for i in range(n):
        if carry == 0:
            break
        if bits[i] == '0':
            bits[i] = '1'  # flip 0 to 1
            carry = 0  # no carry after adding 1
            changed_bits += 1
        else:
            bits[i] = '0'  # flip 1 to 0
            changed_bits += 1

    # return the number of changed bits
    return changed_bits

# Input reading
n = int(input().strip())
initial_bits = input().strip()

# Call the function and print the result
result = add_one(initial_bits)
print(result)"
478,B,Random Teams,PROGRAMMING,"['combinatorics', 'constructive algorithms', 'greedy', 'math']","*n* participants of the competition were split into *m* teams in some manner so that each team has at least one participant. After the competition each pair of participants from the same team became friends.

Your task is to write a program that will find the minimum and the maximum number of pairs of friends that could have formed by the end of the competition.","The only line of input contains two integers *n* and *m*, separated by a single space (1<=≤<=*m*<=≤<=*n*<=≤<=109) — the number of participants and the number of teams respectively.",The only line of the output should contain two integers *k**min* and *k**max* — the minimum possible number of pairs of friends and the maximum possible number of pairs of friends respectively.,"['5 1\n', '3 2\n', '6 3\n']","['10 10\n', '1 1\n', '3 6\n']","In the first sample all the participants get into one team, so there will be exactly ten pairs of friends.

In the second sample at any possible arrangement one team will always have two participants and the other team will always have one participant. Thus, the number of pairs of friends will always be equal to one.

In the third sample minimum number of newly formed friendships can be achieved if participants were split on teams consisting of 2 people, maximum number can be achieved if participants were split on teams of 1, 1 and 4 people.",WRONG_ANSWER,"items = input().split("" "")
n = int(items[0])
m = int(items[1])

def get_res(k):
    return k * (k-1) // 2

if m == 1:
    k_min = get_res(n)
    k_max = get_res(n)
    print(k_min, k_max)
else:
    if n % m == 0:
        k_min = get_res(n//m)
    else:
        k_min = get_res(n//m + 1)
    k_max = get_res(n-(m-1))
    print(k_min, k_max)","import os
import sys
from io import BytesIO, IOBase
from collections import Counter, defaultdict
from sys import stdin, stdout
import io
import math
import heapq

# Function to calculate the maximum odd sum subsequence
def max_odd_sum_subsequence(n, a):
    total_sum = 0
    min_odd = float('inf')
    has_odd = False
    
    # Calculate the total sum and find the smallest odd number
    for num in a:
        total_sum += num
        if num % 2 != 0:
            has_odd = True
            if num < min_odd:
                min_odd = num
    
    # If the total sum is odd, return it directly
    if total_sum % 2 != 0:
        return total_sum
    
    # If the total sum is even, we need to subtract the smallest odd number
    if has_odd:
        return total_sum - min_odd
    
    return 0  # This line won't be reached due to guarantee of odd sum subsequence

# Reading input
n = int(input())
a = list(map(int, input().split()))

# Print the result
print(max_odd_sum_subsequence(n, a))"
427,B,Prison Transfer,PROGRAMMING,"['data structures', 'implementation']","The prison of your city has *n* prisoners. As the prison can't accommodate all of them, the city mayor has decided to transfer *c* of the prisoners to a prison located in another city.

For this reason, he made the *n* prisoners to stand in a line, with a number written on their chests. The number is the severity of the crime he/she has committed. The greater the number, the more severe his/her crime was.

Then, the mayor told you to choose the *c* prisoners, who will be transferred to the other prison. He also imposed two conditions. They are,
 -  The chosen *c* prisoners has to form a contiguous segment of prisoners. -  Any of the chosen prisoner's crime level should not be greater then *t*. Because, that will make the prisoner a severe criminal and the mayor doesn't want to take the risk of his running away during the transfer. 
Find the number of ways you can choose the *c* prisoners.","The first line of input will contain three space separated integers *n* (1<=≤<=*n*<=≤<=2·105), *t* (0<=≤<=*t*<=≤<=109) and *c* (1<=≤<=*c*<=≤<=*n*). The next line will contain *n* space separated integers, the *i**th* integer is the severity *i**th* prisoner's crime. The value of crime severities will be non-negative and will not exceed 109.",Print a single integer — the number of ways you can choose the *c* prisoners.,"['4 3 3\n2 3 1 1\n', '1 1 1\n2\n', '11 4 2\n2 2 0 7 3 2 2 4 9 1 4\n']","['2\n', '0\n', '6\n']",none,RUNTIME_ERROR,"n,t,c=map(int,input().strip().split())
li=list(map(int,input().strip().split()))
di={}
# i=0
# # fli=[]
# while i<n:
#     ct=0
#     si=i
#     maxi=li[i]
#     while ct<c and i<n:
#         if li[i]>maxi:
#             maxi=li[i]
#         ct+=1
#         i+=1
#     # lii=[maxi]*c
#     # fli=fli+lii
#     for j in range(si,i):
#         di[j]=maxi
# ans=0
# si=0
# print(di)
# for i in range(0,n-c+1):
    
#     if di[i]<=t:
#         ans+=1
# print(ans)


i=0
ct=0
si=i
maxi=li[i]
while ct<c and i<n:
    if li[i]>maxi:
        maxi=li[i]
    ct+=1
    i+=1
di[si]=maxi

for i in range(1,n-c+1):
    if li[c-1+i]>maxi:
        maxi=li[c+i]
    di[i]=maxi


ans=0
si=0
# print(di)
for i in range(0,n-c+1):
    
    if di[i]<=t:
        ans+=1
print(ans)










","from collections import defaultdict


def is_super_central(point, xmap, ymap):
    x, y = point
    yList = xmap[x]
    xList = ymap[y]
    # Check for right neighbor
    right = any(y2 == y for x2, y2 in yList if x2 > x)
    # Check for left neighbor
    left = any(y2 == y for x2, y2 in yList if x2 < x)
    # Check for upper neighbor
    upper = any(x2 == x for x2, y2 in xList if y2 > y)
    # Check for lower neighbor
    lower = any(x2 == x for x2, y2 in xList if y2 < y)
    return right and left and upper and lower


def count_super_central_points(points):
    xmap = defaultdict(list)
    ymap = defaultdict(list)
    
    # Populate the xmap and ymap with points
    for x, y in points:
        xmap[x].append((x, y))
        ymap[y].append((x, y))

    super_central_count = 0
    
    # Check each point if it is supercentral
    for point in points:
        if is_super_central(point, xmap, ymap):
            super_central_count += 1

    return super_central_count


# Input reading
n = int(input().strip())
points = [tuple(map(int, input().strip().split())) for _ in range(n)]

# Output the result
print(count_super_central_points(points))"
225,C,Barcode,PROGRAMMING,"['dp', 'matrices']","You've got an *n*<=×<=*m* pixel picture. Each pixel can be white or black. Your task is to change the colors of as few pixels as possible to obtain a barcode picture.

A picture is a barcode if the following conditions are fulfilled: 
 -  All pixels in each column are of the same color. -  The width of each monochrome vertical line is at least *x* and at most *y* pixels. In other words, if we group all neighbouring columns of the pixels with equal color, the size of each group can not be less than *x* or greater than *y*.","The first line contains four space-separated integers *n*, *m*, *x* and *y* (1<=≤<=*n*,<=*m*,<=*x*,<=*y*<=≤<=1000; *x*<=≤<=*y*).

Then follow *n* lines, describing the original image. Each of these lines contains exactly *m* characters. Character ""."" represents a white pixel and ""#"" represents a black pixel. The picture description doesn't have any other characters besides ""."" and ""#"".",In the first line print the minimum number of pixels to repaint. It is guaranteed that the answer exists.,"['6 5 1 2\n##.#.\n.###.\n###..\n#...#\n.##.#\n###..\n', '2 5 1 1\n#####\n.....\n']","['11\n', '5\n']","In the first test sample the picture after changing some colors can looks as follows: 

In the second test sample the picture after changing some colors can looks as follows:",WRONG_ANSWER,"from math import inf

n,m,x,y=map(int,input().split())
matx=[]
for i in range(n):
    matx.append(list(input().strip()))

d=[[0,0]]
for i in range(m):
    c=0
    for j in range(n):
        if matx[j][i]=='.':
            c+=1
    d.append([c,n-c])

print(d)
for i in range(1,m+1):
    d[i][0]+=d[i-1][0]
    d[i][1]+=d[i-1][1]
#dp[n][0,1][p]

dp=[[1000,1000]for j in range(m+1)]
dp[0]=[0,0]
dp[x]=[d[x][0],d[x][1]]
for i in range(x,m+1):
    for j in range(x,min(y+1,i+1)):
        dp[i][0]=min(dp[i-j][1]+d[i][0]-d[i-j][0],dp[i][0])

        dp[i][1]=min(dp[i-j][0]+d[i][1]-d[i-j][1],dp[i][1])
#A&print(dp)
print(min(dp[-1]))
","n, q = map(int, input().split())
a = list(map(int, input().split()))
z = list(map(int, input().split()))

def binsearch(x, k):
    left = 0
    right = len(x)
    while left != right - 1:
        mid = (left + right) // 2
        if x[mid] <= k:
            left = mid
        else:
            right = mid
    return left + 1  # Number of warriors that can stand after k arrows

# Pre-calculate prefix sums of warriors' strengths
prefix_sums = [0] * n
prefix_sums[0] = a[0]
for i in range(1, n):
    prefix_sums[i] = prefix_sums[i - 1] + a[i]

# Process each minute's arrows
for k in z:
    # Using binary search to find how many warriors can stand
    standing_warriors = binsearch(prefix_sums, k)
    print(n - standing_warriors)  # Output the number of standing warriors"
984,B,Minesweeper,PROGRAMMING,['implementation'],"One day Alex decided to remember childhood when computers were not too powerful and lots of people played only default games. Alex enjoyed playing Minesweeper that time. He imagined that he saved world from bombs planted by terrorists, but he rarely won.

Alex has grown up since then, so he easily wins the most difficult levels. This quickly bored him, and he thought: what if the computer gave him invalid fields in the childhood and Alex could not win because of it?

He needs your help to check it.

A Minesweeper field is a rectangle $n \times m$, where each cell is either empty, or contains a digit from $1$ to $8$, or a bomb. The field is valid if for each cell: 
 -  if there is a digit $k$ in the cell, then exactly $k$ neighboring cells have bombs. -  if the cell is empty, then all neighboring cells have no bombs. 
Two cells are neighbors if they have a common side or a corner (i. e. a cell has at most $8$ neighboring cells).","The first line contains two integers $n$ and $m$ ($1 \le n, m \le 100$) — the sizes of the field.

The next $n$ lines contain the description of the field. Each line contains $m$ characters, each of them is ""."" (if this cell is empty), ""*"" (if there is bomb in this cell), or a digit from $1$ to $8$, inclusive.","Print ""YES"", if the field is valid and ""NO"" otherwise.

You can choose the case (lower or upper) for each letter arbitrarily.","['3 3\n111\n1*1\n111\n', '2 4\n*.*.\n1211\n']","['YES', 'NO']","In the second example the answer is ""NO"" because, if the positions of the bombs are preserved, the first line of the field should be *2*1.

You can read more about Minesweeper in [Wikipedia's article](https://en.wikipedia.org/wiki/Minesweeper_(video_game)).",WRONG_ANSWER,"import sys,os,io

input = sys.stdin.readlines
def inlt():
    return(list(map(int,input().split())))

grid = input()[1:]

for i in range(len(grid)):
    grid[i] = list(grid[i][:-1])

print(grid)

def check(grid,i,j):
    count = 0
    if 0 <= i - 1 < len(grid):
        if 0 <= j + 1 < len(grid[i]):
            if grid[i - 1][j + 1] == '*':
                count += 1
        
        if 0 <= j < len(grid[i]):
            if grid[i - 1][j] == '*':
                count += 1

        if 0 <= j - 1 < len(grid[i]):
            if grid[i - 1][j - 1] == '*':
                count += 1

    
    if 0 <= i + 1 < len(grid):
        if 0 <= j + 1 < len(grid[i]):
            if grid[i + 1][j + 1] == '*':
                count += 1
        
        if 0 <= j < len(grid[i]):
            if grid[i + 1][j] == '*':
                count += 1

        if 0 <= j - 1 < len(grid[i]):
            if grid[i + 1][j - 1] == '*':
                count += 1
    
    if 0 <= j - 1 < len(grid[i]):
        if grid[i][j - 1] == '*':
            count += 1
    
    if 0 <= j + 1 < len(grid[i]):
        if grid[i][j + 1] == '*':
            count += 1

    return count

flag = 0

for i in range(len(grid)):
    for j in range(len(grid[i])):
        if grid[i][j].isnumeric():
            x = int(grid[i][j])
            if x != check(grid,i,j):
                flag = 1 
                break
        
        if grid[i][j] == '.':
            if check(grid,i,j) != 0:
                flag = 1
                break 

print(""YES"") if flag == 0 else print(""NO"")

    

    

","import sys
from math import factorial

# Function to compute the number of ways to arrange the balls
def count_arrangements(k, counts):
    total_balls = sum(counts)
    # Calculate the factorial of the total number of balls
    arrangements = factorial(total_balls)
    
    # Divide by the factorials of the counts of each color
    for count in counts:
        arrangements //= factorial(count)
    
    return arrangements

# Function to compute the number of valid arrangements
def valid_arrangements(k, counts):
    # We need to calculate the arrangements such that each color's last ball 
    # is drawn according to the specified condition
    return count_arrangements(k, counts) % 1000000007

# Reading input
k = int(input())
counts = [int(input()) for _ in range(k)]

# Calculate the number of valid arrangements
result = valid_arrangements(k, counts)

# Output the result
print(result)"
268,A,Games,PROGRAMMING,['brute force'],"Manao works on a sports TV. He's spent much time watching the football games of some country. After a while he began to notice different patterns. For example, each team has two sets of uniforms: home uniform and guest uniform. When a team plays a game at home, the players put on the home uniform. When a team plays as a guest on somebody else's stadium, the players put on the guest uniform. The only exception to that rule is: when the home uniform color of the host team matches the guests' uniform, the host team puts on its guest uniform as well. For each team the color of the home and guest uniform is different.

There are *n* teams taking part in the national championship. The championship consists of *n*·(*n*<=-<=1) games: each team invites each other team to its stadium. At this point Manao wondered: how many times during the championship is a host team going to put on the guest uniform? Note that the order of the games does not affect this number.

You know the colors of the home and guest uniform for each team. For simplicity, the colors are numbered by integers in such a way that no two distinct colors have the same number. Help Manao find the answer to his question.","The first line contains an integer *n* (2<=≤<=*n*<=≤<=30). Each of the following *n* lines contains a pair of distinct space-separated integers *h**i*, *a**i* (1<=≤<=*h**i*,<=*a**i*<=≤<=100) — the colors of the *i*-th team's home and guest uniforms, respectively.",In a single line print the number of games where the host team is going to play in the guest uniform.,"['3\n1 2\n2 4\n3 4\n', '4\n100 42\n42 100\n5 42\n100 5\n', '2\n1 2\n1 2\n']","['1\n', '5\n', '0\n']","In the first test case the championship consists of 6 games. The only game with the event in question is the game between teams 2 and 1 on the stadium of team 2.

In the second test sample the host team will have to wear guest uniform in the games between teams: 1 and 2, 2 and 1, 2 and 3, 3 and 4, 4 and 2 (the host team is written first).",OK,"teams = int(input())
homeKit = [None] * teams
guestKit = [None] * teams 
for i in range(teams):
	homeKit[i], guestKit[i] = map(int, input().split())
guestUni = 0
for i in range(teams):
	for j in range(teams):
		if i == j:
			continue
		if homeKit[i] == guestKit[j]:
			guestUni += 1
print(guestUni)
	  		  	   		 	   	  				 	","def db(num):
    s = ''
    while num > 0:
        s = str(num % 2) + s  # Convert to binary
        num //= 2
    return s if s else '0'  # Return '0' for the input 0
    
def count_one_bits(a1, a2):
    """""" Count the number of 1 bits in the binary representation of numbers from a1 to a2 (inclusive). """"""
    count = 0
    for num in range(a1, a2 + 1):
        count += db(num).count('1')  # Count the '1's in the binary representation
    return count

# Read input
a1, a2 = map(int, input().split())
# Output the result
print(count_one_bits(a1, a2))"
1009,A,Game Shopping,PROGRAMMING,['implementation'],"Maxim wants to buy some games at the local game shop. There are $n$ games in the shop, the $i$-th game costs $c_i$.

Maxim has a wallet which can be represented as an array of integers. His wallet contains $m$ bills, the $j$-th bill has value $a_j$.

Games in the shop are ordered from left to right, Maxim tries to buy every game in that order.

When Maxim stands at the position $i$ in the shop, he takes the first bill from his wallet (if his wallet is empty then he proceeds to the next position immediately) and tries to buy the $i$-th game using this bill. After Maxim tried to buy the $n$-th game, he leaves the shop.

Maxim buys the $i$-th game if and only if the value of the first bill (which he takes) from his wallet is greater or equal to the cost of the $i$-th game. If he successfully buys the $i$-th game, the first bill from his wallet disappears and the next bill becomes first. Otherwise Maxim leaves the first bill in his wallet (this bill still remains the first one) and proceeds to the next game.

For example, for array $c = [2, 4, 5, 2, 4]$ and array $a = [5, 3, 4, 6]$ the following process takes place: Maxim buys the first game using the first bill (its value is $5$), the bill disappears, after that the second bill (with value $3$) becomes the first one in Maxim's wallet, then Maxim doesn't buy the second game because $c_2 &gt; a_2$, the same with the third game, then he buys the fourth game using the bill of value $a_2$ (the third bill becomes the first one in Maxim's wallet) and buys the fifth game using the bill of value $a_3$.

Your task is to get the number of games Maxim will buy.","The first line of the input contains two integers $n$ and $m$ ($1 \le n, m \le 1000$) — the number of games and the number of bills in Maxim's wallet.

The second line of the input contains $n$ integers $c_1, c_2, \dots, c_n$ ($1 \le c_i \le 1000$), where $c_i$ is the cost of the $i$-th game.

The third line of the input contains $m$ integers $a_1, a_2, \dots, a_m$ ($1 \le a_j \le 1000$), where $a_j$ is the value of the $j$-th bill from the Maxim's wallet.",Print a single integer — the number of games Maxim will buy.,"['5 4\n2 4 5 2 4\n5 3 4 6\n', '5 2\n20 40 50 20 40\n19 20\n', '6 4\n4 8 15 16 23 42\n1000 1000 1000 1000\n']","['3\n', '0\n', '4\n']","The first example is described in the problem statement.

In the second example Maxim cannot buy any game because the value of the first bill in his wallet is smaller than the cost of any game in the shop.

In the third example the values of the bills in Maxim's wallet are large enough to buy any game he encounter until he runs out of bills in his wallet.",OK,"def main():
    [n_games, n_bills] = [int(_) for _ in input().split()]
    game_prices = [0] + [int(_) for _ in input().split()]
    bills = [0] + [int(_) for _ in input().split()]

    last_game = 0
    last_bill = 0
    count_games_bought = 0

    while last_game < n_games and last_bill < n_bills:
        last_bill += 1
        bill = bills[last_bill]
        try:
            last_game = next(g for g in range(last_game + 1, n_games + 1) if game_prices[g] <= bill)
            count_games_bought += 1
        except StopIteration:
            last_game = n_games

    print(count_games_bought)


if __name__ == '__main__':
    main()
","n = int(input())

def is_triangular(x):
    # A triangular number T(k) is T(k) = k * (k + 1) // 2
    # We need to find k such that T(k) = x
    # This leads to solving the equation k^2 + k - 2x = 0
    # The discriminant must be a perfect square for k to be an integer
    if x < 0:
        return False
    d = 1 + 8 * x
    sq = int(d**0.5)
    return sq * sq == d and (-1 + sq) % 2 == 0

def funk(n):
    # Check if n can be represented as a sum of two triangular numbers
    for i in range(int((2 * n)**0.5) + 1):
        t1 = i * (i + 1) // 2  # First triangular number
        t2 = n - t1            # The second triangular number we need
        if is_triangular(t2):
            return ""YES""
    return ""NO""

print(funk(n))"
863,B,Kayaking,PROGRAMMING,"['brute force', 'greedy', 'sortings']","Vadim is really keen on travelling. Recently he heard about kayaking activity near his town and became very excited about it, so he joined a party of kayakers.

Now the party is ready to start its journey, but firstly they have to choose kayaks. There are 2·*n* people in the group (including Vadim), and they have exactly *n*<=-<=1 tandem kayaks (each of which, obviously, can carry two people) and 2 single kayaks. *i*-th person's weight is *w**i*, and weight is an important matter in kayaking — if the difference between the weights of two people that sit in the same tandem kayak is too large, then it can crash. And, of course, people want to distribute their seats in kayaks in order to minimize the chances that kayaks will crash.

Formally, the instability of a single kayak is always 0, and the instability of a tandem kayak is the absolute difference between weights of the people that are in this kayak. Instability of the whole journey is the total instability of all kayaks.

Help the party to determine minimum possible total instability!","The first line contains one number *n* (2<=≤<=*n*<=≤<=50).

The second line contains 2·*n* integer numbers *w*1, *w*2, ..., *w*2*n*, where *w**i* is weight of person *i* (1<=≤<=*w**i*<=≤<=1000).",Print minimum possible total instability.,"['2\n1 2 3 4\n', '4\n1 3 4 6 3 4 100 200\n']","['1\n', '5\n']",none,WRONG_ANSWER,"n = int(input().strip())
weights = [int(i) for i in input().strip().split()]
weights.sort()
max_dif = 0
f, s = None, None
for i in range(n*2-1):
    if weights[i+1] - weights[i] > max_dif:
        max_dif = weights[i+1] - weights[i]
        f = i+1
        s = i
weights.pop(i+1)
weights.pop(i)

ans = 0
for i in range(n*2-3):
    ans += weights[i+1] - weights[i]

print(ans)","def PerfectSum(arr, summ):
    cols = summ + 1
    prev_row = [set() for _ in range(cols)]
    current_row = [set() for _ in range(cols)]
    prev_row[0].add(0)  # Base case: sum of 0 can always be made with an empty set.

    for value in arr:
        for j in range(cols):
            # Current sum that can be made by not taking the coin
            current_row[j] = set(prev_row[j])
            if j >= value:
                # Include current coin
                for x in prev_row[j - value]:
                    current_row[j].add(x + value)
        
        # Move current_row to prev_row for the next coin
        prev_row = current_row

    # Collect all possible subset sums from valid combinations summing to `summ`
    possible_sums = set()
    for x in prev_row[summ]:
        for val in arr:
            # We can form subset sums with the chosen coins
            temp_sum = 0
            for i in range(len(arr)):
                temp_sum += arr[i]
                if temp_sum > summ:
                    break
                if temp_sum <= summ and temp_sum != 0:
                    possible_sums.add(temp_sum)

    # Output results
    print(len(possible_sums))
    print(*sorted(possible_sums))

# Input reading
n, k = map(int, input().split())
coins = list(map(int, input().split()))

PerfectSum(coins, k)"
837,A,Text Volume,PROGRAMMING,['implementation'],"You are given a text of single-space separated words, consisting of small and capital Latin letters.

Volume of the word is number of capital letters in the word. Volume of the text is maximum volume of all words in the text.

Calculate the volume of the given text.","The first line contains one integer number *n* (1<=≤<=*n*<=≤<=200) — length of the text.

The second line contains text of single-space separated words *s*1,<=*s*2,<=...,<=*s**i*, consisting only of small and capital Latin letters.",Print one integer number — volume of text.,"['7\nNonZERO\n', '24\nthis is zero answer text\n', '24\nHarbour Space University\n']","['5\n', '0\n', '1\n']","In the first example there is only one word, there are 5 capital letters in it.

In the second example all of the words contain 0 capital letters.",RUNTIME_ERROR,"n=int(input())
ch=input()
i=0
l=[]
k=0
while((i<=n)):

    if (ch[i].isupper()):
        k+=1
    
    if (ch[i]==' '):
        l.append(k)
        
        k=0
    i+=1
l.append(k)
v=max(l)
    


","import sys
input = sys.stdin.readline

# Constants for board size
BOARD_SIZE = 8

# Knight's possible moves
knight_moves = [(-2, -1), (-1, -2), (1, -2), (2, -1),
                (2, 1), (1, 2), (-1, 2), (-2, 1)]

# Rook's attacking positions
def rook_attacks(rook_x, rook_y):
    attacked_positions = set()
    # Mark the entire row and column of the rook
    for i in range(1, BOARD_SIZE + 1):
        attacked_positions.add((rook_x, i))  # Row
        attacked_positions.add((i, rook_y))  # Column
    return attacked_positions

# Check if a position is valid on the board
def is_within_board(x, y):
    return 1 <= x <= BOARD_SIZE and 1 <= y <= BOARD_SIZE

# Get knight's attack positions
def knight_attacks(knight_x, knight_y):
    attacked_positions = set()
    for move in knight_moves:
        new_x, new_y = knight_x + move[0], knight_y + move[1]
        if is_within_board(new_x, new_y):
            attacked_positions.add((new_x, new_y))
    return attacked_positions

rook_pos = input().strip()
knight_pos = input().strip()

# Extract rook and knight positions
rook_x = ord(rook_pos[0]) - ord('a') + 1
rook_y = int(rook_pos[1])
knight_x = ord(knight_pos[0]) - ord('a') + 1
knight_y = int(knight_pos[1])

# Get attacked positions
attacked_by_rook = rook_attacks(rook_x, rook_y)
attacked_by_knight = knight_attacks(knight_x, knight_y)

# Count valid positions for the new knight
valid_positions = 0

for x in range(1, BOARD_SIZE + 1):
    for y in range(1, BOARD_SIZE + 1):
        if (x, y) not in attacked_by_rook and (x, y) not in attacked_by_knight:
            valid_positions += 1

print(valid_positions)"
272,A,Dima and Friends,PROGRAMMING,"['implementation', 'math']","Dima and his friends have been playing hide and seek at Dima's place all night. As a result, Dima's place got messy. In the morning they decided that they need to clean the place.

To decide who exactly would clean the apartment, the friends want to play a counting-out game. First, all the guys stand in a circle, and then each of them shows some number of fingers on one hand (one to five), and then the boys count in a circle, starting from Dima, the number of people, respective to the total number of fingers shown. The person on who the countdown stops will clean the apartment.

For example, if Dima and one of his friends played hide and seek, and 7 fingers were shown during the counting-out, then Dima would clean the place. If there were 2 or say, 8 fingers shown, then his friend would clean the place.

Dima knows how many fingers each of his friends will show during the counting-out. Now he is interested in the number of ways to show some number of fingers on one hand (one to five), so that he did not have to clean the place. Help Dima.","The first line contains integer *n* (1<=≤<=*n*<=≤<=100) — the number of Dima's friends. Dima himself isn't considered to be his own friend. The second line contains *n* positive integers, not exceeding 5, representing, how many fingers the Dima's friends will show. 

The numbers in the lines are separated by a single space.",In a single line print the answer to the problem.,"['1\n1\n', '1\n2\n', '2\n3 5\n']","['3\n', '2\n', '3\n']","In the first sample Dima can show 1, 3 or 5 fingers. If Dima shows 3 fingers, then the counting-out will go like that: Dima, his friend, Dima, his friend.

In the second sample Dima can show 2 or 4 fingers.",WRONG_ANSWER,"n = int(input())
l = list(map(int,input().split()))
s = sum(l)
a = ((sum(l)-2)//(n+1)) + 1
if a<=0:
    print(a+4)
else:
    print(a)","import sys
input = sys.stdin.readline

############ ---- Input Functions ---- ############
def inlt():
    return(list(map(int,input().split())))

def insr():
    s = input().strip()
    return s

def minimal_weight_rocket():
    # Read input values
    n, k = inlt()
    stages = insr()
    
    # Remove duplicates and sort stages
    unique_stages = sorted(set(stages))
    
    # Initialize the rocket and total weight
    rocket = []
    total_weight = 0
    
    # Last used weight
    last_weight = -3  # Start with a weight that will allow the first stage

    for stage in unique_stages:
        current_weight = ord(stage) - ord('a') + 1
        
        # Check if can add current stage
        if current_weight >= last_weight + 2:
            rocket.append(stage)  # Add stage to rocket
            total_weight += current_weight  # Update total weight
            
            # Stop if we have enough stages
            if len(rocket) == k:
                break
            
            last_weight = current_weight  # Update last weight to current
            
    # If not enough stages were added, return -1
    if len(rocket) < k:
        return -1
    
    return total_weight  # Return the final total weight

# Print the result
result = minimal_weight_rocket()
print(result)"
979,A,"Pizza, Pizza, Pizza!!!",PROGRAMMING,['math'],"Katie, Kuro and Shiro are best friends. They have known each other since kindergarten. That's why they often share everything with each other and work together on some very hard problems.

Today is Shiro's birthday. She really loves pizza so she wants to invite her friends to the pizza restaurant near her house to celebrate her birthday, including her best friends Katie and Kuro.

She has ordered a very big round pizza, in order to serve her many friends. Exactly $n$ of Shiro's friends are here. That's why she has to divide the pizza into $n + 1$ slices (Shiro also needs to eat). She wants the slices to be exactly the same size and shape. If not, some of her friends will get mad and go home early, and the party will be over.

Shiro is now hungry. She wants to cut the pizza with minimum of straight cuts. A cut is a straight segment, it might have ends inside or outside the pizza. But she is too lazy to pick up the calculator.

As usual, she will ask Katie and Kuro for help. But they haven't come yet. Could you help Shiro with this problem?",A single line contains one non-negative integer $n$ ($0 \le n \leq 10^{18}$) — the number of Shiro's friends. The circular pizza has to be sliced into $n + 1$ pieces.,A single integer — the number of straight cuts Shiro needs.,"['3\n', '4\n']","['2', '5']","To cut the round pizza into quarters one has to make two cuts through the center with angle $90^{\circ}$ between them.

To cut the round pizza into five equal parts one has to make five cuts.",WRONG_ANSWER,"N = int(input()) + 1
if (N % 2 == 0):
    print(int(N / 2))
else:
    print(N)
    ","__author__ = 'Lipen'

def main():
    n, m, t = map(int, input().split())
    tp, tu, td = map(int, input().split())
    data = []
    for _ in range(n):
        data.append(list(map(int, input().split())))

    # Initialize variables to track the best rectangle
    best_diff = float('inf')
    best_rectangle = None

    # Iterate over all possible top-left corners of the rectangle
    for r1 in range(n):
        for c1 in range(m):
            # Iterate over all possible bottom-right corners
            for r2 in range(r1 + 2, n): # r2 needs to be at least 2 rows below r1
                for c2 in range(c1 + 2, m): # c2 needs to be at least 2 columns right of c1
                    # Calculate the time to traverse the perimeter of the rectangle
                    time = 0
                    heights = []
                    
                    # Top side
                    for c in range(c1, c2 + 1):
                        heights.append(data[r1][c])
                    # Right side
                    for r in range(r1 + 1, r2 + 1):
                        heights.append(data[r][c2])
                    # Bottom side
                    for c in range(c2, c1 - 1, -1):
                        heights.append(data[r2][c])
                    # Left side
                    for r in range(r2 - 1, r1, -1):
                        heights.append(data[r][c1])

                    # Calculate the time based on heights
                    for i in range(len(heights) - 1):
                        if heights[i] < heights[i + 1]:
                            time += tu
                        elif heights[i] > heights[i + 1]:
                            time += td
                        else:
                            time += tp
                    
                    # Check how close this time is to the desired time
                    if abs(time - t) < best_diff:
                        best_diff = abs(time - t)
                        best_rectangle = (r1 + 1, c1 + 1, r2 + 1, c2 + 1)  # Convert to 1-based index

    # Output the best rectangle found
    if best_rectangle:
        print(*best_rectangle)

if __name__ == ""__main__"":
    main()"
811,B,Vladik and Complicated Book,PROGRAMMING,"['implementation', 'sortings']","Vladik had started reading a complicated book about algorithms containing *n* pages. To improve understanding of what is written, his friends advised him to read pages in some order given by permutation *P*<==<=[*p*1,<=*p*2,<=...,<=*p**n*], where *p**i* denotes the number of page that should be read *i*-th in turn.

Sometimes Vladik’s mom sorted some subsegment of permutation *P* from position *l* to position *r* inclusive, because she loves the order. For every of such sorting Vladik knows number *x* — what index of page in permutation he should read. He is wondered if the page, which he will read after sorting, has changed. In other words, has *p**x* changed? After every sorting Vladik return permutation to initial state, so you can assume that each sorting is independent from each other.","First line contains two space-separated integers *n*, *m* (1<=≤<=*n*,<=*m*<=≤<=104) — length of permutation and number of times Vladik's mom sorted some subsegment of the book.

Second line contains *n* space-separated integers *p*1,<=*p*2,<=...,<=*p**n* (1<=≤<=*p**i*<=≤<=*n*) — permutation *P*. Note that elements in permutation are distinct.

Each of the next *m* lines contains three space-separated integers *l**i*, *r**i*, *x**i* (1<=≤<=*l**i*<=≤<=*x**i*<=≤<=*r**i*<=≤<=*n*) — left and right borders of sorted subsegment in *i*-th sorting and position that is interesting to Vladik.","For each mom’s sorting on it’s own line print ""Yes"", if page which is interesting to Vladik hasn't changed, or ""No"" otherwise.","['5 5\n5 4 3 2 1\n1 5 3\n1 3 1\n2 4 3\n4 4 4\n2 5 3\n', '6 5\n1 4 3 2 5 6\n2 4 3\n1 6 2\n4 5 4\n1 3 3\n2 6 3\n']","['Yes\nNo\nYes\nYes\nNo\n', 'Yes\nNo\nYes\nNo\nYes\n']","Explanation of first test case: 
 1.  [1, 2, 3, 4, 5] — permutation after sorting, 3-rd element hasn’t changed, so answer is ""Yes"". 1.  [3, 4, 5, 2, 1] — permutation after sorting, 1-st element has changed, so answer is ""No"". 1.  [5, 2, 3, 4, 1] — permutation after sorting, 3-rd element hasn’t changed, so answer is ""Yes"". 1.  [5, 4, 3, 2, 1] — permutation after sorting, 4-th element hasn’t changed, so answer is ""Yes"". 1.  [5, 1, 2, 3, 4] — permutation after sorting, 3-rd element has changed, so answer is ""No"".",TIME_LIMIT_EXCEEDED,"n, m = map(int, input().split())
a = list(map(int, input().split()))
for i in range(m):
    l, r, x = map(int, input().split())
    b = a[l - 1: r]
    b.sort()
    if a[x - 1] == b[x - l]:
        print(""Yes"")
    else:
        print(""No"")
","def protect(pasture, row, col):
    # Create a list to store the output pasture
    output = [list(row) for row in pasture]

    # Directions for moving up, down, left, and right
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]

    # Process the pasture for wolves and sheep
    for y in range(row):
        for x in range(col):
            if pasture[y][x] == 'W':
                # Check all 4 directions to place dogs to protect sheep
                for dy, dx in directions:
                    ny, nx = y + dy, x + dx
                    if 0 <= ny < row and 0 <= nx < col:
                        if pasture[ny][nx] == 'S':
                            # If a wolf is adjacent to a sheep, return ""No""
                            return ""No""
                        if pasture[ny][nx] == '.':
                            # Place a dog in the empty cell
                            output[ny][nx] = 'D'

    # Since no wolf can reach a sheep, return ""Yes"" and the modified pasture
    return ""Yes"", [''.join(row) for row in output]

# Input section
R, C = map(int, input().split())
pasture = [input().strip() for _ in range(R)]

result = protect(pasture, R, C)

if result == ""No"":
    print(result)
else:
    print(result[0])
    for line in result[1]:
        print(line)"
25,A,IQ test,PROGRAMMING,['brute force'],"Bob is preparing to pass IQ test. The most frequent task in this test is to find out which one of the given *n* numbers differs from the others. Bob observed that one number usually differs from the others in evenness. Help Bob — to check his answers, he needs a program that among the given *n* numbers finds one that is different in evenness.","The first line contains integer *n* (3<=≤<=*n*<=≤<=100) — amount of numbers in the task. The second line contains *n* space-separated natural numbers, not exceeding 100. It is guaranteed, that exactly one of these numbers differs from the others in evenness.",Output index of number that differs from the others in evenness. Numbers are numbered from 1 in the input order.,"['5\n2 4 7 8 10\n', '4\n1 2 1 1\n']","['3\n', '2\n']",none,WRONG_ANSWER,"n = input()
s = input()
s1 = s.split()


odd = 0
even = 0

        
for i in range(int(n)):
    if int(s1[i]) % 2 == 0:
        even = even + 1
    else:
        odd = odd + 1 
        
if odd > even:
    for i in range(int(n)):
        if int(s1[i]) % 2 == 0:
            print(i)
elif even > odd:
    for i in range(int(n)):
        if int(s1[i]) % 2 != 0:
            print(i) ","n, d = map(int, input().split())
arr = list(map(int, input().split()))

def main():
    curr = 0
    ans = 0
    
    for transaction in arr:
        curr += transaction  # Update current balance
        
        if curr < 0:  # If balance is negative, we need to deposit money
            needed = -curr  # Calculate how much is needed to make balance non-negative
            ans += 1  # Count a deposit day
            curr += needed  # ""Deposit"" the needed amount to make balance zero

        if curr > d:  # If balance exceeds the limit after transaction
            print(-1)
            return
        
    print(ans)  # Output the number of days deposits were made

main()"
112,A,Petya and Strings,PROGRAMMING,"['implementation', 'strings']","Little Petya loves presents. His mum bought him two strings of the same size for his birthday. The strings consist of uppercase and lowercase Latin letters. Now Petya wants to compare those two strings lexicographically. The letters' case does not matter, that is an uppercase letter is considered equivalent to the corresponding lowercase letter. Help Petya perform the comparison.",Each of the first two lines contains a bought string. The strings' lengths range from 1 to 100 inclusive. It is guaranteed that the strings are of the same length and also consist of uppercase and lowercase Latin letters.,"If the first string is less than the second one, print ""-1"". If the second string is less than the first one, print ""1"". If the strings are equal, print ""0"". Note that the letters' case is not taken into consideration when the strings are compared.","['aaaa\naaaA\n', 'abs\nAbz\n', 'abcdefg\nAbCdEfF\n']","['0\n', '-1\n', '1\n']","If you want more formal information about the lexicographical order (also known as the ""dictionary order"" or ""alphabetical order""), you can visit the following site:
-  http://en.wikipedia.org/wiki/Lexicographical_order",OK,"a = input().lower()
b = input().lower()
abi = True
for i in range(len(a)):
    if a[i] > b[i]:
        print('1')
        abi = False
        break
    elif a[i] < b[i]:
        print('-1')
        abi = False
        break
if abi:
    print('0')
","Q = input()

W = ""abcdefghijklmnopqrstuvwxyz""

# Starting position at 'a'
current_position = 0
total_rotations = 0

for char in Q:
    # Find the position of the current character
    target_position = W.index(char)
    
    # Calculate the clockwise and counterclockwise distances
    clockwise_distance = (target_position - current_position) % 26
    counterclockwise_distance = (current_position - target_position) % 26
    
    # Choose the minimum distance
    total_rotations += min(clockwise_distance, counterclockwise_distance)
    
    # Update current position to the target character's position
    current_position = target_position

# Output the total number of rotations required
print(total_rotations)"
847,M,Weather Tomorrow,PROGRAMMING,"['implementation', 'math']","Vasya came up with his own weather forecasting method. He knows the information about the average air temperature for each of the last *n* days. Assume that the average air temperature for each day is integral.

Vasya believes that if the average temperatures over the last *n* days form an arithmetic progression, where the first term equals to the average temperature on the first day, the second term equals to the average temperature on the second day and so on, then the average temperature of the next (*n*<=+<=1)-th day will be equal to the next term of the arithmetic progression. Otherwise, according to Vasya's method, the temperature of the (*n*<=+<=1)-th day will be equal to the temperature of the *n*-th day.

Your task is to help Vasya predict the average temperature for tomorrow, i. e. for the (*n*<=+<=1)-th day.","The first line contains a single integer *n* (2<=≤<=*n*<=≤<=100) — the number of days for which the average air temperature is known.

The second line contains a sequence of integers *t*1,<=*t*2,<=...,<=*t**n* (<=-<=1000<=≤<=*t**i*<=≤<=1000) — where *t**i* is the average temperature in the *i*-th day.","Print the average air temperature in the (*n*<=+<=1)-th day, which Vasya predicts according to his method. Note that the absolute value of the predicted temperature can exceed 1000.","['5\n10 5 0 -5 -10\n', '4\n1 1 1 1\n', '3\n5 1 -5\n', '2\n900 1000\n']","['-15\n', '1\n', '-5\n', '1100\n']","In the first example the sequence of the average temperatures is an arithmetic progression where the first term is 10 and each following terms decreases by 5. So the predicted average temperature for the sixth day is  - 10 - 5 =  - 15.

In the second example the sequence of the average temperatures is an arithmetic progression where the first term is 1 and each following terms equals to the previous one. So the predicted average temperature in the fifth day is 1.

In the third example the average temperatures do not form an arithmetic progression, so the average temperature of the fourth day equals to the temperature of the third day and equals to  - 5.

In the fourth example the sequence of the average temperatures is an arithmetic progression where the first term is 900 and each the following terms increase by 100. So predicted average temperature in the third day is 1000 + 100 = 1100.",OK,"n = int(input())
vals = list(map(int,(input().split())))
arith = True
diff = vals[0]-vals[1]
for i in range(n-1):
    if vals[i]-vals[i+1]!=diff:
        arith = False
        break
if arith:
    print(vals[-1]-diff)
else:
    print(vals[-1])","def qual(arr: list[list[int]]):
    hashmap = {}
    for i in range(len(arr)):
        hashmap[i] = []
        for j in range(len(arr[i])):
            if arr[i][j] == 0:
                hashmap[i].append(j)

    # Count how many problems each team knows
    count = [0] * len(arr[0])
    for i in range(len(arr)):
        for j in range(len(arr[i])):
            if arr[i][j] == 1:
                count[j] += 1

    # Check if there exists any valid combination of problems
    for mask in range(1, 1 << len(arr)):
        problems = []
        for i in range(len(arr)):
            if (mask & (1 << i)) > 0:
                problems.append(i)

        valid = True
        for team in range(len(arr[0])):
            known_problems = sum(1 for problem in problems if arr[problem][team] == 1)
            if known_problems > len(problems) // 2:
                valid = False
                break
        
        if valid:
            print(""YES"")
            return
    
    print(""NO"")


# Read input
n, k = map(int, input().split())
arr = [list(map(int, input().split())) for _ in range(n)]

# Determine if an interesting problemset can be created
qual(arr)"
129,A,Cookies,PROGRAMMING,['implementation'],"Olga came to visit the twins Anna and Maria and saw that they have many cookies. The cookies are distributed into bags. As there are many cookies, Olga decided that it's no big deal if she steals a bag. However, she doesn't want the sisters to quarrel because of nothing when they divide the cookies. That's why Olga wants to steal a bag with cookies so that the number of cookies in the remaining bags was even, that is, so that Anna and Maria could evenly divide it into two (even 0 remaining cookies will do, just as any other even number). How many ways there are to steal exactly one cookie bag so that the total number of cookies in the remaining bags was even?",The first line contains the only integer *n* (1<=≤<=*n*<=≤<=100) — the number of cookie bags Anna and Maria have. The second line contains *n* integers *a**i* (1<=≤<=*a**i*<=≤<=100) — the number of cookies in the *i*-th bag.,Print in the only line the only number — the sought number of ways. If there are no such ways print 0.,"['1\n1\n', '10\n1 2 2 3 4 4 4 2 2 2\n', '11\n2 2 2 2 2 2 2 2 2 2 99\n']","['1\n', '8\n', '1\n']","In the first sample Olga should take the only bag so that the twins ended up with the even number of cookies.

In the second sample Olga can take any of five bags with two cookies or any of three bags with four cookies — 5 + 3 = 8 ways in total.

In the third sample, no matter which bag with two cookies Olga chooses, the twins are left with 2 * 9 + 99 = 117 cookies. Thus, Olga has only one option: to take the bag with 99 cookies.",OK,"n=int(input())
l=list(map(int,input().split()))



Sum=sum(l)
if(Sum%2==0):
	print(len([i for i in l if i%2==0]))
else:
	print(len([i for i in l if(i%2==1)]))
","n, m = map(int, input().split())
vertices = [[] for i in range(n + 1)]
after = [True for i in range(n + 1)]
war = [False for i in range(n + 1)]
point = float('inf')
cnt, ans, ret = 0, 0, 0

for i in range(n - 1):
    u, v = map(int, input().split())
    vertices[u].append(v)
    vertices[v].append(u)

attacked_cities = list(map(int, input().split()))

def bfs(start):
    # Use BFS to calculate the shortest distance from start city to all cities
    from collections import deque
    distance = [-1] * (n + 1)
    queue = deque([start])
    distance[start] = 0

    while queue:
        city = queue.popleft()
        for neighbor in vertices[city]:
            if distance[neighbor] == -1:
                distance[neighbor] = distance[city] + 1
                queue.append(neighbor)

    return distance

for city in range(1, n + 1):
    # Perform BFS from each city
    distances = bfs(city)
    total_time = sum(distances[attacked_city] for attacked_city in attacked_cities)

    if total_time < point:
        point = total_time
        ans = city
    elif total_time == point:
        ans = min(ans, city)

print(ans)
print(point)"
0,none,none,none,['none'],"Asterix, Obelix and their temporary buddies Suffix and Prefix has finally found the Harmony temple. However, its doors were firmly locked and even Obelix had no luck opening them.

A little later they found a string *s*, carved on a rock below the temple's gates. Asterix supposed that that's the password that opens the temple and read the string aloud. However, nothing happened. Then Asterix supposed that a password is some substring *t* of the string *s*.

Prefix supposed that the substring *t* is the beginning of the string *s*; Suffix supposed that the substring *t* should be the end of the string *s*; and Obelix supposed that *t* should be located somewhere inside the string *s*, that is, *t* is neither its beginning, nor its end.

Asterix chose the substring *t* so as to please all his companions. Besides, from all acceptable variants Asterix chose the longest one (as Asterix loves long strings). When Asterix read the substring *t* aloud, the temple doors opened. 

You know the string *s*. Find the substring *t* or determine that such substring does not exist and all that's been written above is just a nice legend.","You are given the string *s* whose length can vary from 1 to 106 (inclusive), consisting of small Latin letters.","Print the string *t*. If a suitable *t* string does not exist, then print ""Just a legend"" without the quotes.","['fixprefixsuffix\n', 'abcdabc\n']","['fix', 'Just a legend']",none,WRONG_ANSWER,"s=input()
ins=s[1:-1]
ans=""Just a legend""
for i in range(len(s)):
    if s[:i]==s[-i:] and ins.find(s[:i])!=-1:
        ans=s[:i]
        break
print(ans)
","def st(): return str(input())
def ls(): return list(map(int, input().split()))
def mx(a): return max(a)
def it(): return int(input())
def mn(a): return min(a)
def yes(): return print('YES')
def no(): return print('NO')
def re(a): return range(a)

def is_palindrome(time_str):
    return time_str == time_str[::-1]

def next_palindromic_time(current_time):
    hours, minutes = map(int, current_time.split(':'))
    
    while True:
        minutes += 1
        if minutes == 60:
            minutes = 0
            hours += 1
        if hours == 24:
            hours = 0
        
        # Format hours and minutes to two digits
        time_str = f""{hours:02}:{minutes:02}""
        if is_palindrome(time_str):
            return time_str

# Read input time
current_time = st()
# Find and print the next palindromic time
print(next_palindromic_time(current_time))"
771,A,Bear and Friendship Condition,PROGRAMMING,"['dfs and similar', 'dsu', 'graphs']","Bear Limak examines a social network. Its main functionality is that two members can become friends (then they can talk with each other and share funny pictures).

There are *n* members, numbered 1 through *n*. *m* pairs of members are friends. Of course, a member can't be a friend with themselves.

Let A-B denote that members A and B are friends. Limak thinks that a network is reasonable if and only if the following condition is satisfied: For every three distinct members (X, Y, Z), if X-Y and Y-Z then also X-Z.

For example: if Alan and Bob are friends, and Bob and Ciri are friends, then Alan and Ciri should be friends as well.

Can you help Limak and check if the network is reasonable? Print ""YES"" or ""NO"" accordingly, without the quotes.","The first line of the input contain two integers *n* and *m* (3<=≤<=*n*<=≤<=150<=000, ) — the number of members and the number of pairs of members that are friends.

The *i*-th of the next *m* lines contains two distinct integers *a**i* and *b**i* (1<=≤<=*a**i*,<=*b**i*<=≤<=*n*,<=*a**i*<=≠<=*b**i*). Members *a**i* and *b**i* are friends with each other. No pair of members will appear more than once in the input.","If the given network is reasonable, print ""YES"" in a single line (without the quotes). Otherwise, print ""NO"" in a single line (without the quotes).","['4 3\n1 3\n3 4\n1 4\n', '4 4\n3 1\n2 3\n3 4\n1 2\n', '10 4\n4 3\n5 10\n8 9\n1 2\n', '3 2\n1 2\n2 3\n']","['YES\n', 'NO\n', 'YES\n', 'NO\n']","The drawings below show the situation in the first sample (on the left) and in the second sample (on the right). Each edge represents two members that are friends. The answer is ""NO"" in the second sample because members (2, 3) are friends and members (3, 4) are friends, while members (2, 4) are not.",WRONG_ANSWER,"mod = int(1e9+7)
def solve():
	n,m = map(int,input().split())
	adj = [[]for i in range(n)]
	for i in range(m):
		a,b = map(int,input().split())
		adj[a-1].append(b-1)
		adj[b-1].append(a-1)
	def dfs(s,par,gpar):
		visited[s] = True
		strue = False
		atrue = True
		for i in adj[s]:
			if not visited[i]:
				atrue&=dfs(i,s,par)
			if i==gpar:
				strue = True
		if atrue and (strue or par==-1 or gpar==-1):
			return True
		return False
	visited = [False]*n
	ttrue = True
	for i in range(n):
		if not visited[i]:
			ttrue&=dfs(i,-1,-1)
	if ttrue:
		print(""YES"")
	else:
		print(""NO"")





	




# number of test cases
#t = int(input())
t = 1
for i in range(t):
	solve()









","def dfs(index):
    visited[index] = 0
    for i in range(n):
        if (graph[i][0] == graph[index][0] or graph[i][1] == graph[index][1]) and visited[i] == -1:
            dfs(i)

n = int(input())
graph = [tuple(map(int, input().split())) for _ in range(n)]
visited = [-1] * n
components = 0

# Count the number of connected components
for i in range(n):
    if visited[i] == -1:
        components += 1
        dfs(i)

# Minimum number of snow drifts to connect all components
min_snow_drifts = components - 1
print(min_snow_drifts)"
260,B,Ancient Prophesy,PROGRAMMING,"['brute force', 'implementation', 'strings']","A recently found Ancient Prophesy is believed to contain the exact Apocalypse date. The prophesy is a string that only consists of digits and characters ""-"".

We'll say that some date is mentioned in the Prophesy if there is a substring in the Prophesy that is the date's record in the format ""dd-mm-yyyy"". We'll say that the number of the date's occurrences is the number of such substrings in the Prophesy. For example, the Prophesy ""0012-10-2012-10-2012"" mentions date 12-10-2012 twice (first time as ""0012-10-2012-10-2012"", second time as ""0012-10-2012-10-2012"").

The date of the Apocalypse is such correct date that the number of times it is mentioned in the Prophesy is strictly larger than that of any other correct date.

A date is correct if the year lies in the range from 2013 to 2015, the month is from 1 to 12, and the number of the day is strictly more than a zero and doesn't exceed the number of days in the current month. Note that a date is written in the format ""dd-mm-yyyy"", that means that leading zeroes may be added to the numbers of the months or days if needed. In other words, date ""1-1-2013"" isn't recorded in the format ""dd-mm-yyyy"", and date ""01-01-2013"" is recorded in it.

Notice, that any year between 2013 and 2015 is not a leap year.","The first line contains the Prophesy: a non-empty string that only consists of digits and characters ""-"". The length of the Prophesy doesn't exceed 105 characters.",In a single line print the date of the Apocalypse. It is guaranteed that such date exists and is unique.,['777-444---21-12-2013-12-2013-12-2013---444-777\n'],['13-12-2013'],none,RUNTIME_ERROR,"import re
s = input()
a = []
days = [0,31,28,31,30,31,30,30,31,30,31,30,31];
regex = r'(0[1-9])?(1[0-9])?(2[0-9])?(3[0-1])?-(0[1-9])?(1[0-2])?[-]201[3-5]'
for i in range(0,len(s)-9):
	if(s[i]!='-' and s[i+9]!='-'):
		if(re.search(regex,s[i:i+10])!=None):
			a.append(s[i:i+10])
st = set(a)
b = [[a.count(i),i] for i in st]
b.sort(reverse=True)
for i in range (0,len(b)):
	d = int(b[i][1][:2])
	mont = int(b[i][1][3:5])
	if(d>0 and d<=days[mont]):
		print(b[i][1])
		break","from math import ceil

def merge(arr, l, m, r):
    n1 = m - l + 1
    n2 = r - m

    # create temp arrays
    L = [0] * (n1)
    R = [0] * (n2)

    for i in range(n1):
        L[i] = arr[l + i]

    for j in range(n2):
        R[j] = arr[m + 1 + j]

    i = 0
    j = 0
    k = l

    while i < n1 and j < n2:
        if L[i] <= R[j]:
            arr[k] = L[i]
            i += 1
        else:
            arr[k] = R[j]
            j += 1
        k += 1

    while i < n1:
        arr[k] = L[i]
        i += 1
        k += 1

    while j < n2:
        arr[k] = R[j]
        j += 1
        k += 1

def merge_sort(arr, l, r):
    if l < r:
        m = (l + r) // 2
        merge_sort(arr, l, m)
        merge_sort(arr, m + 1, r)
        merge(arr, l, m, r)

def can_deploy_services(n, x1, x2, servers):
    # Sort servers in non-decreasing order
    sorted_servers = sorted((c, i) for i, c in enumerate(servers, start=1))

    # Try to find servers for the first service
    k1 = 0
    indices1 = []
    for c, idx in sorted_servers:
        if c >= x1 / (k1 + 1):
            indices1.append(idx)
            k1 += 1
        if k1 == n:  # All servers are used
            break

    if k1 == 0:
        return ""No""

    # Try to find servers for the second service
    k2 = 0
    indices2 = []
    for c, idx in sorted_servers:
        if c >= x2 / (k2 + 1) and idx not in indices1:
            indices2.append(idx)
            k2 += 1
        if k2 == n:  # All servers are used
            break

    if k2 == 0:
        return ""No""

    # Check if both services can be deployed
    if k1 > 0 and k2 > 0:
        return f""Yes\n{k1} {k2}\n{' '.join(map(str, indices1))}\n{' '.join(map(str, indices2))}""
    
    return ""No""

# Input reading and function call
n, x1, x2 = map(int, input().split())
servers = list(map(int, input().split()))

result = can_deploy_services(n, x1, x2, servers)
print(result)"
656,A,Da Vinci Powers,PROGRAMMING,['*special'],"The input contains a single integer *a* (0<=≤<=*a*<=≤<=35).

Output a single integer.",The input contains a single integer *a* (0<=≤<=*a*<=≤<=35).,Output a single integer.,"['3\n', '10\n']","['8\n', '1024\n']",none,OK,"if __name__ == ""__main__"":
	a = [1,
	2,
	4,
	8,
	16,
	32,
	64,
	128,
	256,
	512,
	1024,
	2048,
	4096,
	8092,
	16184,
	32368,
	64736,
	129472,
	258944,
	517888,
	1035776,
	2071552,
	4143104,
	8286208,
	16572416,
	33144832,
	66289664,
	132579328,
	265158656,
	530317312,
	1060634624,
	2121269248,
	4242538496,
	8485076992,
	16970153984,
	33940307968]
	print (a[int(input())])
","# https://codeforces.com/problemset/problem/703/A
t = int(input())
t2 = t
winM = 0
winC = 0

# Process each round
for _ in range(t):
    m, c = map(int, input().split())
    # Determine the winner of the round
    if m > c:
        winM += 1  # Mishka wins
    elif c > m:
        winC += 1  # Chris wins

# Determine the overall winner
if winM > winC:
    print(""Mishka"")  # Mishka is the overall winner
elif winC > winM:
    print(""Chris"")  # Chris is the overall winner
else:
    print(""Friendship is magic!^^"")  # It's a draw"
757,A,Gotta Catch Em' All!,PROGRAMMING,['implementation'],"Bash wants to become a Pokemon master one day. Although he liked a lot of Pokemon, he has always been fascinated by Bulbasaur the most. Soon, things started getting serious and his fascination turned into an obsession. Since he is too young to go out and catch Bulbasaur, he came up with his own way of catching a Bulbasaur.

Each day, he takes the front page of the newspaper. He cuts out the letters one at a time, from anywhere on the front page of the newspaper to form the word ""Bulbasaur"" (without quotes) and sticks it on his wall. Bash is very particular about case — the first letter of ""Bulbasaur"" must be upper case and the rest must be lower case. By doing this he thinks he has caught one Bulbasaur. He then repeats this step on the left over part of the newspaper. He keeps doing this until it is not possible to form the word ""Bulbasaur"" from the newspaper.

Given the text on the front page of the newspaper, can you tell how many Bulbasaurs he will catch today?

Note: uppercase and lowercase letters are considered different.","Input contains a single line containing a string *s* (1<=<=≤<=<=|*s*|<=<=≤<=<=105) — the text on the front page of the newspaper without spaces and punctuation marks. |*s*| is the length of the string *s*.

The string *s* contains lowercase and uppercase English letters, i.e. .","Output a single integer, the answer to the problem.","['Bulbbasaur\n', 'F\n', 'aBddulbasaurrgndgbualdBdsagaurrgndbb\n']","['1\n', '0\n', '2\n']","In the first case, you could pick: Bulbbasaur.

In the second case, there is no way to pick even a single Bulbasaur.

In the third case, you can rearrange the string to BulbasaurBulbasauraddrgndgddgargndbb to get two words ""Bulbasaur"".",WRONG_ANSWER,"def solve(s):
  d = {
    'B': 0,
    'u':0,
    'l':0,
    'b':0,
    'a':0,
    'u':0,
    'r':0,
    's':0
  }
  for c in s:
    if c in 'Bulbbasaur':
      d[c]+=1
  min_val = 1000000000
  for i in d:
    if not d[i]:
      return 0
    if d['a'] < 2 or d['u'] < 2:
      return 0
    if d[i] < min_val:
      if i in ['a','u']:
        min_val = d[i]//2
    min_val = d[i]
  return min_val
    
    

def main() :
  # n,k = list(map(int, input().split(' ')))
  # n = int(input())
  # arr = input().split(' ')
  s = input()
  # res=''

  # n = int(input())
  # arr = []
  # for _ in range(n):
  #   i = input()
  #   arr.append(i)
  
  # # for i in arr:
  # n = int(input())
  # s = input()
  print(solve(s))

main()


","def solve(l, p, q):
    # Calculate the time until the first collision
    t = l / (p + q)
    
    # Distance traveled by Harry's spell until the first collision
    first_collision_distance = t * p
    
    # Calculate the time until the return to the casters
    return_time = first_collision_distance / p + first_collision_distance / q
    
    # Total distance from Harry's position to the second meeting place
    second_collision_distance = (p + q) * (l / (p + q) + return_time)
    
    return round(first_collision_distance + second_collision_distance, 4)

# Input reading section (not part of the solve function, included for completeness)
if __name__ == ""__main__"":
    l = int(input())
    p = int(input())
    q = int(input())
    print(solve(l, p, q))"
976,A,Minimum Binary Number,PROGRAMMING,['implementation'],"String can be called correct if it consists of characters ""0"" and ""1"" and there are no redundant leading zeroes. Here are some examples: ""0"", ""10"", ""1001"".

You are given a correct string *s*.

You can perform two different operations on this string: 
 1.  swap any pair of adjacent characters (for example, ""101""  ""110""); 1.  replace ""11"" with ""1"" (for example, ""110""  ""10""). 
Let *val*(*s*) be such a number that *s* is its binary representation.

Correct string *a* is less than some other correct string *b* iff *val*(*a*)<=&lt;<=*val*(*b*).

Your task is to find the minimum correct string that you can obtain from the given one using the operations described above. You can use these operations any number of times in any order (or even use no operations at all).","The first line contains integer number *n* (1<=≤<=*n*<=≤<=100) — the length of string *s*.

The second line contains the string *s* consisting of characters ""0"" and ""1"". It is guaranteed that the string *s* is correct.",Print one string — the minimum correct string that you can obtain from the given one.,"['4\n1001\n', '1\n1\n']","['100\n', '1\n']","In the first example you can obtain the answer by the following sequence of operations: ""1001"" <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> ""1010"" <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> ""1100"" <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> ""100"".

In the second example you can't obtain smaller answer no matter what operations you use.",OK,"def solve():
    size = input()
    s = input()
    
    print('1' * ('1' in s)  + '0' * s.count('0'))
    
    
if __name__ == ""__main__"":
    solve()
    ","from sys import stdin; inp = stdin.readline

# List of possible evolutions for Eevee
pokemons = [""vaporeon"", ""jolteon"", ""flareon"", ""espeon"", ""umbreon"", ""leafeon"", ""glaceon"", ""sylveon""]

# Read the length of the word
n = int(inp().strip())

# Read the pattern provided in the crossword
pattern = inp().strip()

# Function to check if a pokemon matches the pattern
def matches_pattern(pokemon, pattern):
    if len(pokemon) != len(pattern):
        return False
    for p_char, pat_char in zip(pokemon, pattern):
        if pat_char != '.' and p_char != pat_char:
            return False
    return True

# Find the matching pokemon
for pokemon in pokemons:
    if matches_pattern(pokemon, pattern):
        print(pokemon)
        break  # Since exact one pokemon fits, we can break after finding it"
0,none,none,none,['none'],"In Absurdistan, there are *n* towns (numbered 1 through *n*) and *m* bidirectional railways. There is also an absurdly simple road network — for each pair of different towns *x* and *y*, there is a bidirectional road between towns *x* and *y* if and only if there is no railway between them. Travelling to a different town using one railway or one road always takes exactly one hour.

A train and a bus leave town 1 at the same time. They both have the same destination, town *n*, and don't make any stops on the way (but they can wait in town *n*). The train can move only along railways and the bus can move only along roads.

You've been asked to plan out routes for the vehicles; each route can use any road/railway multiple times. One of the most important aspects to consider is safety — in order to avoid accidents at railway crossings, the train and the bus must not arrive at the same town (except town *n*) simultaneously.

Under these constraints, what is the minimum number of hours needed for both vehicles to reach town *n* (the maximum of arrival times of the bus and the train)? Note, that bus and train are not required to arrive to the town *n* at the same moment of time, but are allowed to do so.","The first line of the input contains two integers *n* and *m* (2<=≤<=*n*<=≤<=400, 0<=≤<=*m*<=≤<=*n*(*n*<=-<=1)<=/<=2) — the number of towns and the number of railways respectively.

Each of the next *m* lines contains two integers *u* and *v*, denoting a railway between towns *u* and *v* (1<=≤<=*u*,<=*v*<=≤<=*n*, *u*<=≠<=*v*).

You may assume that there is at most one railway connecting any two towns.","Output one integer — the smallest possible time of the later vehicle's arrival in town *n*. If it's impossible for at least one of the vehicles to reach town *n*, output <=-<=1.","['4 2\n1 3\n3 4\n', '4 6\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4\n', '5 5\n4 2\n3 5\n4 5\n5 1\n1 2\n']","['2\n', '-1\n', '3\n']","In the first sample, the train can take the route <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/7c0aa60a06309ef607b7159fd7f3687ea0d943ce.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> and the bus can take the route <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/a26c2f3e93c9d9be6c21cb5d2bd6ac1f99f4ff55.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>. Note that they can arrive at town 4 at the same time.

In the second sample, Absurdistan is ruled by railwaymen. There are no roads, so there's no way for the bus to reach town 4.",OK,"n, m = map(int, input().split())
a = [[0] * (n + 1) for _ in range(n + 1)]

for _ in range(m):
    u, v = map(int, input().split())
    a[u][v] = 1
    a[v][u] = 1


def bfs(x):
    fila = [(1, 0)]
    visitados = [0] * (n + 1)

    while fila:
        u, v = fila.pop(0)
        for i in range(1, n + 1):
            if not visitados[i] and a[u][i] == x:
                if i == n:
                    return v + 1
                fila.append((i, v + 1))
                visitados[i] = 1

    return -1


if a[1][n]:
    print(bfs(0))
else:
    print(bfs(1))
","#!/usr/bin/env python3
n, d, h = map(int, input().split())

def solve():
    t = []
    i, j = 1, 2
    
    # Create edges to reach the height h
    while len(t) < h:
        t.append((i, j))
        i, j = j, j + 1

    # Check if height h is valid with diameter d
    if h > d or (d > 1 and h == 1) or (n == 2 and d == 1 and h == 1):
        print(-1)
        return

    # Add remaining edges to achieve diameter d
    if d > h:
        t.append((1, j))
        j += 1
        while j <= n:
            t.append((2, j))
            j += 1

    # Output the edges
    if len(t) == n - 1:
        for edge in t:
            print(edge[0], edge[1])
    else:
        print(-1)

solve()"
721,C,Journey,PROGRAMMING,"['dp', 'graphs']","Recently Irina arrived to one of the most famous cities of Berland — the Berlatov city. There are *n* showplaces in the city, numbered from 1 to *n*, and some of them are connected by one-directional roads. The roads in Berlatov are designed in a way such that there are no cyclic routes between showplaces.

Initially Irina stands at the showplace 1, and the endpoint of her journey is the showplace *n*. Naturally, Irina wants to visit as much showplaces as she can during her journey. However, Irina's stay in Berlatov is limited and she can't be there for more than *T* time units.

Help Irina determine how many showplaces she may visit during her journey from showplace 1 to showplace *n* within a time not exceeding *T*. It is guaranteed that there is at least one route from showplace 1 to showplace *n* such that Irina will spend no more than *T* time units passing it.","The first line of the input contains three integers *n*,<=*m* and *T* (2<=≤<=*n*<=≤<=5000,<=<=1<=≤<=*m*<=≤<=5000,<=<=1<=≤<=*T*<=≤<=109) — the number of showplaces, the number of roads between them and the time of Irina's stay in Berlatov respectively.

The next *m* lines describes roads in Berlatov. *i*-th of them contains 3 integers *u**i*,<=*v**i*,<=*t**i* (1<=≤<=*u**i*,<=*v**i*<=≤<=*n*,<=*u**i*<=≠<=*v**i*,<=1<=≤<=*t**i*<=≤<=109), meaning that there is a road starting from showplace *u**i* and leading to showplace *v**i*, and Irina spends *t**i* time units to pass it. It is guaranteed that the roads do not form cyclic routes.

It is guaranteed, that there is at most one road between each pair of showplaces.","Print the single integer *k* (2<=≤<=*k*<=≤<=*n*) — the maximum number of showplaces that Irina can visit during her journey from showplace 1 to showplace *n* within time not exceeding *T*, in the first line.

Print *k* distinct integers in the second line — indices of showplaces that Irina will visit on her route, in the order of encountering them.

If there are multiple answers, print any of them.","['4 3 13\n1 2 5\n2 3 7\n2 4 8\n', '6 6 7\n1 2 2\n1 3 3\n3 6 3\n2 4 2\n4 6 2\n6 5 1\n', '5 5 6\n1 3 3\n3 5 3\n1 2 2\n2 4 3\n4 5 2\n']","['3\n1 2 4 \n', '4\n1 2 4 6 \n', '3\n1 3 5 \n']",none,WRONG_ANSWER,"import collections
from functools import lru_cache
from collections import deque

n, m, T = map(int, input().split())
g = collections.defaultdict(list)
rev_g = collections.defaultdict(list)

indegree = [0] * (n + 1)

for _ in range(m):
    u, v, t = map(int, input().split())
    g[u].append(v)
    rev_g[v].append((u, t))
    indegree[v] += 1

dq = deque()
dq.append(1)

topo_order = []
while dq:
    u = dq.popleft()
    topo_order.append(u)
    for v in g[u]:
        indegree[v] -= 1
        if indegree[v] == 0:
            dq.append(v)

dp = [[(float('inf'), -1)] * (n + 1) for _ in range(n + 1)]

dp[1][1] = (0, -1)

for v in topo_order[1:]:
    for u, t in rev_g[v]:
        for nodes_in_paths in range(1, n + 1):
            if dp[u][nodes_in_paths - 1][0] == float('inf'):
                continue
            if (dp[u][nodes_in_paths - 1][0] + t) < dp[v][nodes_in_paths][0]:
                dp[v][nodes_in_paths] = (dp[u][nodes_in_paths - 1][0] + t, u) # prev node is u

res = 1
path = []
for nodes_in_paths in range(n, 0, -1):
    if dp[n][nodes_in_paths][0] != float('inf') and dp[n][nodes_in_paths][0] <= T:
        res = nodes_in_paths
        path = []
        while n != -1:
            path.append(n)
            n = dp[n][nodes_in_paths][1]
            nodes_in_paths -= 1
        break

print(res)
print(path[::-1])




","def cut_or_not(trees, i):
    x_i_l, x_i, x_i_r = trees[i-1][0], trees[i][0], trees[i+1][0]
    h_i = trees[i][1]
    if x_i - h_i > x_i_l:  # Can fell left
        return True, x_i - h_i
    elif x_i_r - x_i > h_i:  # Can fell right
        return True, x_i + h_i
    else:  # Cannot fell
        return False, x_i

def max_trees_to_fell(trees):
    n = len(trees)
    if n == 1:
        return 1  # Only one tree, can always fell it

    count = 0
    last_position = float('-inf')  # Last occupied position

    # Check the first tree can always be cut to left
    count += 1
    last_position = trees[0][0]

    for i in range(1, n - 1):
        fell, new_position = cut_or_not(trees, i)
        if fell:
            count += 1
            last_position = new_position  # Update last position if tree is felled
        else:
            last_position = trees[i][0]  # Update last position to current tree position

    # Check the last tree separately
    count += 1  # can always fell the last tree to the right
    return count

# Input reading
n = int(input().strip())
trees = [tuple(map(int, input().strip().split())) for _ in range(n)]

# Output the result
print(max_trees_to_fell(trees))"
918,B,Radio Station,PROGRAMMING,"['implementation', 'strings']","As the guys fried the radio station facilities, the school principal gave them tasks as a punishment. Dustin's task was to add comments to nginx configuration for school's website. The school has *n* servers. Each server has a name and an ip (names aren't necessarily unique, but ips are). Dustin knows the ip and name of each server. For simplicity, we'll assume that an nginx command is of form ""command ip;"" where command is a string consisting of English lowercase letter only, and ip is the ip of one of school servers.

Each ip is of form ""a.b.c.d"" where *a*, *b*, *c* and *d* are non-negative integers less than or equal to 255 (with no leading zeros). The nginx configuration file Dustin has to add comments to has *m* commands. Nobody ever memorizes the ips of servers, so to understand the configuration better, Dustin has to comment the name of server that the ip belongs to at the end of each line (after each command). More formally, if a line is ""command ip;"" Dustin has to replace it with ""command ip; #name"" where name is the name of the server with ip equal to ip.

Dustin doesn't know anything about nginx, so he panicked again and his friends asked you to do his task for him.","The first line of input contains two integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=1000).

The next *n* lines contain the names and ips of the servers. Each line contains a string name, name of the server and a string ip, ip of the server, separated by space (1<=≤<=|*name*|<=≤<=10, *name* only consists of English lowercase letters). It is guaranteed that all ip are distinct.

The next *m* lines contain the commands in the configuration file. Each line is of form ""command ip;"" (1<=≤<=|*command*|<=≤<=10, command only consists of English lowercase letters). It is guaranteed that ip belongs to one of the *n* school servers.","Print *m* lines, the commands in the configuration file after Dustin did his task.","['2 2\nmain 192.168.0.2\nreplica 192.168.0.1\nblock 192.168.0.1;\nproxy 192.168.0.2;\n', '3 5\ngoogle 8.8.8.8\ncodeforces 212.193.33.27\nserver 138.197.64.57\nredirect 138.197.64.57;\nblock 8.8.8.8;\ncf 212.193.33.27;\nunblock 8.8.8.8;\ncheck 138.197.64.57;\n']","['block 192.168.0.1; #replica\nproxy 192.168.0.2; #main\n', 'redirect 138.197.64.57; #server\nblock 8.8.8.8; #google\ncf 212.193.33.27; #codeforces\nunblock 8.8.8.8; #google\ncheck 138.197.64.57; #server\n']",none,WRONG_ANSWER,"n, m = map(int, input().split())
server = []
serverip = []
c_name = []
c_ip = []
for i in range(n):
    name, ip = input().split()
    ip = ip + "";""
    server.append(name)
    serverip.append(ip)
for i in range(m):
    command, commandip = input().split()
    for x in range(n):
        if serverip[x] == commandip:
            print(command, commandip, ""#"", server[x])","t = int(input())
for k in range(t):
    n, m = list(map(int, input().split()))
    arr = []
    for i in range(n):
        s = input()
        arr.append([int(j) for j in s])  # Convert characters to integers

    # Function to check if a square can be formed with given coordinates and size
    def can_form_square(x, y, size):
        # Check borders of the square
        for i in range(size):
            if arr[x][y+i] != 1 or arr[x+size-1][y+i] != 1 or arr[x+i][y] != 1 or arr[x+i][y+size-1] != 1:
                return False
        # Check foreign 1s around the square
        for i in range(-1, size+1):
            for j in range(-1, size+1):
                if 0 <= x+i < n and 0 <= y+j < m and (arr[x+i][y+j] == 1 and (i != -1 and i != size or j != -1 and j != size)):
                    return False
        return True

    # Function to check for diagonal squares
    def can_form_diagonal_square(x, y, size):
        # Check corners of the square for diagonal arrangements
        if arr[x][y] == 1 and arr[x+size-1][y+size-1] == 1 and arr[x][y+size-1] == 1 and arr[x+size-1][y] == 1:
            return True
        return False

    total_squares = 0
    
    # Count squares of side lengths from 2 to min(n, m)
    for size in range(2, min(n, m) + 1):
        for i in range(n - size + 1):
            for j in range(m - size + 1):
                if can_form_square(i, j, size):
                    total_squares += 1
                if can_form_diagonal_square(i, j, size):
                    total_squares += 1

    print(total_squares)"
38,A,Army,PROGRAMMING,['implementation'],"The Berland Armed Forces System consists of *n* ranks that are numbered using natural numbers from 1 to *n*, where 1 is the lowest rank and *n* is the highest rank.

One needs exactly *d**i* years to rise from rank *i* to rank *i*<=+<=1. Reaching a certain rank *i* having not reached all the previous *i*<=-<=1 ranks is impossible.

Vasya has just reached a new rank of *a*, but he dreams of holding the rank of *b*. Find for how many more years Vasya should serve in the army until he can finally realize his dream.",The first input line contains an integer *n* (2<=≤<=*n*<=≤<=100). The second line contains *n*<=-<=1 integers *d**i* (1<=≤<=*d**i*<=≤<=100). The third input line contains two integers *a* and *b* (1<=≤<=*a*<=&lt;<=*b*<=≤<=*n*). The numbers on the lines are space-separated.,Print the single number which is the number of years that Vasya needs to rise from rank *a* to rank *b*.,"['3\n5 6\n1 2\n', '3\n5 6\n1 3\n']","['5\n', '11\n']",none,RUNTIME_ERROR,"t=int(input())
arr=[]
for i in range(t):
    x=int(input())
    arr.append(x)
a,b=0,0
a=int(input())
b=int(input())
s=0
ind=a-1
while(ind<b):
    s+=arr[ind]
    ind+=1
print(s)","n, k = map(int, input().split())
alpha = 'abcdefghijklmnopqrstuvwxyz'
ch = str(input())
L = list(set(ch))  # use set to get unique stages
L.sort()

# Dictionary to map stage letters to their weights
d = {alpha[i]: i + 1 for i in range(len(alpha))}

result = []
last_index = -1  # To keep track of the last stage chosen

for letter in L:
    # If this is the first stage or the current stage is at least two positions away
    if len(result) < k and (last_index == -1 or (ord(letter) - ord(result[-1]) > 1)):
        result.append(letter)
        last_index = ord(letter) - ord('a')  # Update last index

# Check if we could select exactly k stages
if len(result) == k:
    weight = sum(d[stage] for stage in result)  # Calculate total weight
    print(weight)
else:
    print(-1)  # Impossible to build the rocket"
336,C,Vasily the Bear and Sequence,PROGRAMMING,"['brute force', 'greedy', 'implementation', 'number theory']","Vasily the bear has got a sequence of positive integers *a*1,<=*a*2,<=...,<=*a**n*. Vasily the Bear wants to write out several numbers on a piece of paper so that the beauty of the numbers he wrote out was maximum. 

The beauty of the written out numbers *b*1,<=*b*2,<=...,<=*b**k* is such maximum non-negative integer *v*, that number *b*1 *and* *b*2 *and* ... *and* *b**k* is divisible by number 2*v* without a remainder. If such number *v* doesn't exist (that is, for any non-negative integer *v*, number *b*1 *and* *b*2 *and* ... *and* *b**k* is divisible by 2*v* without a remainder), the beauty of the written out numbers equals -1. 

Tell the bear which numbers he should write out so that the beauty of the written out numbers is maximum. If there are multiple ways to write out the numbers, you need to choose the one where the bear writes out as many numbers as possible.

Here expression *x* *and* *y* means applying the bitwise AND operation to numbers *x* and *y*. In programming languages C++ and Java this operation is represented by ""&amp;"", in Pascal — by ""and"".","The first line contains integer *n* (1<=≤<=*n*<=≤<=105). The second line contains *n* space-separated integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a*1<=&lt;<=*a*2<=&lt;<=...<=&lt;<=*a**n*<=≤<=109).","In the first line print a single integer *k* (*k*<=&gt;<=0), showing how many numbers to write out. In the second line print *k* integers *b*1,<=*b*2,<=...,<=*b**k* — the numbers to write out. You are allowed to print numbers *b*1,<=*b*2,<=...,<=*b**k* in any order, but all of them must be distinct. If there are multiple ways to write out the numbers, choose the one with the maximum number of numbers to write out. If there still are multiple ways, you are allowed to print any of them.","['5\n1 2 3 4 5\n', '3\n1 2 4\n']","['2\n4 5\n', '1\n4\n']",none,WRONG_ANSWER,"import math
n = int(input())
l = list(map(int,input().split()))
c=d=0
a = []
l.sort(reverse=True)
for i in l:
    while i%(math.pow(2,d))==0:
        d+=1
        if i not in a:
            c+=1
            a.append(i)
print(c)
print(*a)","import sys

input = sys.stdin.readline

# Read the two strings from input
str1 = input().strip()
str2 = input().strip()

# Convert both strings to the same case (lowercase for comparison)
str1_lower = str1.lower()
str2_lower = str2.lower()

# Compare the strings lexicographically
if str1_lower < str2_lower:
    print(""-1"")  # First string is less than the second
elif str1_lower > str2_lower:
    print(""1"")   # Second string is less than the first
else:
    print(""0"")   # Both strings are equal"
507,B,Amr and Pins,PROGRAMMING,"['geometry', 'math']","Amr loves Geometry. One day he came up with a very interesting problem.

Amr has a circle of radius *r* and center in point (*x*,<=*y*). He wants the circle center to be in new position (*x*',<=*y*').

In one step Amr can put a pin to the border of the circle in a certain point, then rotate the circle around that pin by any angle and finally remove the pin.

Help Amr to achieve his goal in minimum number of steps.","Input consists of 5 space-separated integers *r*, *x*, *y*, *x*' *y*' (1<=≤<=*r*<=≤<=105, <=-<=105<=≤<=*x*,<=*y*,<=*x*',<=*y*'<=≤<=105), circle radius, coordinates of original center of the circle and coordinates of destination center of the circle respectively.",Output a single integer — minimum number of steps required to move the center of the circle to the destination point.,"['2 0 0 0 4\n', '1 1 1 4 4\n', '4 5 6 5 6\n']","['1\n', '3\n', '0\n']","In the first sample test the optimal way is to put a pin at point (0, 2) and rotate the circle by 180 degrees counter-clockwise (or clockwise, no matter).

<img class=""tex-graphics"" src=""https://espresso.codeforces.com/4e40fd4cc24a2050a0488aa131e6244369328039.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>",OK,"import math
r, x, y, x1, y1 = map(int, input().split())
print(math.ceil(math.sqrt((x-x1)**2 + (y-y1)**2)/(2*r)))
","import sys
import math
from collections import deque,Counter
from sys import stdin

# sys.setrecursionlimit(10**7)

int1=lambda x: int(x)-1

# Read input areas of the three faces
a, b, c = map(int, stdin.readline().strip().split())

# Compute the edge lengths using the areas
# Area1 = xy, Area2 = xz, Area3 = yz
# We can derive the edge lengths as follows:
x = math.sqrt(a * c / b)
y = math.sqrt(a * b / c)
z = math.sqrt(b * c / a)

# Calculate the sum of all edges
total_length = 4 * (x + y + z)

# Print the result
print(int(total_length))"
686,A,Free Ice Cream,PROGRAMMING,"['constructive algorithms', 'implementation']","After their adventure with the magic mirror Kay and Gerda have returned home and sometimes give free ice cream to kids in the summer.

At the start of the day they have *x* ice cream packs. Since the ice cream is free, people start standing in the queue before Kay and Gerda's house even in the night. Each person in the queue wants either to take several ice cream packs for himself and his friends or to give several ice cream packs to Kay and Gerda (carriers that bring ice cream have to stand in the same queue).

If a carrier with *d* ice cream packs comes to the house, then Kay and Gerda take all his packs. If a child who wants to take *d* ice cream packs comes to the house, then Kay and Gerda will give him *d* packs if they have enough ice cream, otherwise the child will get no ice cream at all and will leave in distress.

Kay wants to find the amount of ice cream they will have after all people will leave from the queue, and Gerda wants to find the number of distressed kids.","The first line contains two space-separated integers *n* and *x* (1<=≤<=*n*<=≤<=1000, 0<=≤<=*x*<=≤<=109).

Each of the next *n* lines contains a character '+' or '-', and an integer *d**i*, separated by a space (1<=≤<=*d**i*<=≤<=109). Record ""+ *d**i*"" in *i*-th line means that a carrier with *d**i* ice cream packs occupies *i*-th place from the start of the queue, and record ""- *d**i*"" means that a child who wants to take *d**i* packs stands in *i*-th place.","Print two space-separated integers — number of ice cream packs left after all operations, and number of kids that left the house in distress.","['5 7\n+ 5\n- 10\n- 20\n+ 40\n- 20\n', '5 17\n- 16\n- 2\n- 98\n+ 100\n- 98\n']","['22 1\n', '3 2\n']","Consider the first sample.
 1.  Initially Kay and Gerda have 7 packs of ice cream. 1.  Carrier brings 5 more, so now they have 12 packs. 1.  A kid asks for 10 packs and receives them. There are only 2 packs remaining. 1.  Another kid asks for 20 packs. Kay and Gerda do not have them, so the kid goes away distressed. 1.  Carrier bring 40 packs, now Kay and Gerda have 42 packs. 1.  Kid asks for 20 packs and receives them. There are 22 packs remaining.",OK,"

n,x = map(int,input().split())
count=0
for _ in range(n):
    c,v = input().split()
    v=int(v)
    
    if(c=='+'):
        x=x+v
    if(c=='-'):
        if(v<=x):
            x=x-v
        else:
            count += 1
            
print(x,count)","from collections import defaultdict

def count_matching_integers(queries):
    counts = defaultdict(int)  # Dictionary to store counts of integers in the multiset
    results = []  # List to store the results of type '?' queries
    
    for query in queries:
        operation, value = query.split()
        
        if operation == '+':
            a = int(value)
            counts[a] += 1  # Add non-negative integer to the multiset
            
        elif operation == '-':
            a = int(value)
            counts[a] -= 1  # Delete a single occurrence of non-negative integer
            
        elif operation == '?':
            pattern = value
            count = 0
            
            for num, freq in counts.items():
                if freq > 0:  # Only consider numbers that are still in the multiset
                    num_str = str(num)[::-1]  # Reverse the number's string representation
                    match = True
                    
                    # Check matching with the pattern
                    for i in range(len(pattern)):
                        if i < len(num_str):
                            if (num_str[i] in '02468' and pattern[i] == '0') or \
                               (num_str[i] in '13579' and pattern[i] == '1'):
                                continue
                            else:
                                match = False
                                break
                        else:  # num is shorter than the pattern
                            if pattern[i] == '1':
                                match = False
                                break
                    
                    if match:
                        count += freq  # Add frequency of matching number
            
            results.append(count)  # Store the result for the query
    
    return results"
25,A,IQ test,PROGRAMMING,['brute force'],"Bob is preparing to pass IQ test. The most frequent task in this test is to find out which one of the given *n* numbers differs from the others. Bob observed that one number usually differs from the others in evenness. Help Bob — to check his answers, he needs a program that among the given *n* numbers finds one that is different in evenness.","The first line contains integer *n* (3<=≤<=*n*<=≤<=100) — amount of numbers in the task. The second line contains *n* space-separated natural numbers, not exceeding 100. It is guaranteed, that exactly one of these numbers differs from the others in evenness.",Output index of number that differs from the others in evenness. Numbers are numbered from 1 in the input order.,"['5\n2 4 7 8 10\n', '4\n1 2 1 1\n']","['3\n', '2\n']",none,RUNTIME_ERROR,"for t in range(int(input())):
    a=list(map(int,input().split()))
    even=0
    evencount=0
    oddcount=0
    for i in range(len(a)):
        if a[i]%2==0:
            even=i
            evencount+=1
        else:
            odd=i
            oddcount+=1
    if evencount>oddcount:
        print(odd+1)
    else:
        print(even+1)","import sys
import itertools
import functools
import collections
import math

def BEX(a, b):
    res = 1
    while b > 0:
        res *= a
        b -= 1
    return res

def count_ways(n):
    # Number of car makes
    makes = 4
    # Total number of cars in the parking lot
    total_cars = 2 * n
    
    # The number of distinct ways to position n identical cars of one make in the parking lot
    ways = BEX(makes, total_cars - n) * makes
    
    return ways

# Reading input
if __name__ == ""__main__"":
    n = int(sys.stdin.readline().strip())
    print(count_ways(n))"
854,A,Fraction,PROGRAMMING,"['brute force', 'constructive algorithms', 'math']","Petya is a big fan of mathematics, especially its part related to fractions. Recently he learned that a fraction  is called proper iff its numerator is smaller than its denominator (*a*<=&lt;<=*b*) and that the fraction is called irreducible if its numerator and its denominator are coprime (they do not have positive common divisors except 1).

During his free time, Petya thinks about proper irreducible fractions and converts them to decimals using the calculator. One day he mistakenly pressed addition button (<=+<=) instead of division button (÷) and got sum of numerator and denominator that was equal to *n* instead of the expected decimal notation. 

Petya wanted to restore the original fraction, but soon he realized that it might not be done uniquely. That's why he decided to determine maximum possible proper irreducible fraction  such that sum of its numerator and denominator equals *n*. Help Petya deal with this problem.","In the only line of input there is an integer *n* (3<=≤<=*n*<=≤<=1000), the sum of numerator and denominator of the fraction.","Output two space-separated positive integers *a* and *b*, numerator and denominator of the maximum possible proper irreducible fraction satisfying the given sum.","['3\n', '4\n', '12\n']","['1 2\n', '1 3\n', '5 7\n']",none,WRONG_ANSWER,"n = int(input())

def easyest(a, b):
    while a != 0 and b != 0:
        if a > b:
            a %= b
        else:
            b %= a
    if (a + b) == 1:
        return True
    else:
        return False
x = 0
for j in range(n, 1, -1):
    if easyest(n - j, j):
        if (n - j) / j > x:
            xx = j
            x = (n - j) / j
print(min(xx, n - xx), max(xx, n - xx))","def func(aa):
    rounds = 0
    while True:
        imax = 0
        imin = 0
        for i, v in enumerate(aa):
            if v > aa[imax]:
                imax = i
        
        # Check if all players have played enough rounds
        if aa[imax] <= rounds:
            break
        
        # Increase rounds since the player with most demand hasn't been satisfied
        rounds += 1
        
        # Every player except the chosen supervisor gets to play
        for j in range(len(aa)):
            if j != imax and aa[j] > 0:
                aa[j] -= 1

    return rounds

# Input handling
n = int(input())
aa = list(map(int, input().split()))

# Output the result
print(func(aa))"
231,A,Team,PROGRAMMING,"['brute force', 'greedy']","One day three best friends Petya, Vasya and Tonya decided to form a team and take part in programming contests. Participants are usually offered several problems during programming contests. Long before the start the friends decided that they will implement a problem if at least two of them are sure about the solution. Otherwise, the friends won't write the problem's solution.

This contest offers *n* problems to the participants. For each problem we know, which friend is sure about the solution. Help the friends find the number of problems for which they will write a solution.","The first input line contains a single integer *n* (1<=≤<=*n*<=≤<=1000) — the number of problems in the contest. Then *n* lines contain three integers each, each integer is either 0 or 1. If the first number in the line equals 1, then Petya is sure about the problem's solution, otherwise he isn't sure. The second number shows Vasya's view on the solution, the third number shows Tonya's view. The numbers on the lines are separated by spaces.",Print a single integer — the number of problems the friends will implement on the contest.,"['3\n1 1 0\n1 1 1\n1 0 0\n', '2\n1 0 0\n0 1 1\n']","['2\n', '1\n']","In the first sample Petya and Vasya are sure that they know how to solve the first problem and all three of them know how to solve the second problem. That means that they will write solutions for these problems. Only Petya is sure about the solution for the third problem, but that isn't enough, so the friends won't take it. 

In the second sample the friends will only implement the second problem, as Vasya and Tonya are sure about the solution.",OK,"n = int(input())
count = 0
for i in range(n):
    m = list(map(int,input().split()))
    k = m.count(1)
    if k >= 2:
        count += 1
print(count)","def inp():
    return(int(input()))

def inlt():
    return(list(map(int,input().split())))

def insr():
    s = input()

# Read the die rolls of Yakko and Wakko
Y, W = inlt()

# Determine the maximum roll between Yakko and Wakko
max_roll = max(Y, W)

# Dot needs to roll at least 'max_roll' to win or tie
# The possible winning rolls for Dot are from max_roll to 6
winning_outcomes = 6 - max_roll + 1

# Total possible outcomes when rolling a six-sided die is 6
total_outcomes = 6

# If there are no winning outcomes for Dot
if winning_outcomes == 0:
    print(""0/1"")
else:
    # Output the probability as an irreducible fraction
    from math import gcd

    # Calculate the Greatest Common Divisor for reduction
    common_divisor = gcd(winning_outcomes, total_outcomes)

    # Numerator and denominator of the irreducible fraction
    numerator = winning_outcomes // common_divisor
    denominator = total_outcomes // common_divisor

    print(f""{numerator}/{denominator}"")"
75,C,Modified GCD,PROGRAMMING,"['binary search', 'number theory']","Well, here is another math class task. In mathematics, GCD is the greatest common divisor, and it's an easy task to calculate the GCD between two positive integers.

A common divisor for two positive numbers is a number which both numbers are divisible by.

But your teacher wants to give you a harder task, in this task you have to find the greatest common divisor *d* between two integers *a* and *b* that is in a given range from *low* to *high* (inclusive), i.e. *low*<=≤<=*d*<=≤<=*high*. It is possible that there is no common divisor in the given range.

You will be given the two integers *a* and *b*, then *n* queries. Each query is a range from *low* to *high* and you have to answer each query.","The first line contains two integers *a* and *b*, the two integers as described above (1<=≤<=*a*,<=*b*<=≤<=109). The second line contains one integer *n*, the number of queries (1<=≤<=*n*<=≤<=104). Then *n* lines follow, each line contains one query consisting of two integers, *low* and *high* (1<=≤<=*low*<=≤<=*high*<=≤<=109).","Print *n* lines. The *i*-th of them should contain the result of the *i*-th query in the input. If there is no common divisor in the given range for any query, you should print -1 as a result for this query.",['9 27\n3\n1 5\n10 11\n9 11\n'],['3\n-1\n9\n'],none,OK,"def gcd(a,b):
    while a>0:
        x=a
        a=b%a
        b=x
    return(x)
def Bsearch1(L,x):
    beg=0
    last=len(L)-1
    while beg<=last:
        mid=(beg+last)//2
        if x==L[mid]:
            return(mid)
        elif(x>L[mid]):
            beg=mid+1
        else:
            last=mid-1
    else:
        return(beg)
def Bsearch2(L,x):
    beg=0
    last=len(L)-1
    while beg<=last:
        mid=(beg+last)//2
        if x==L[mid]:
            return(mid)
        elif(x>L[mid]):
            beg=mid+1
        else:
            last=mid-1
    else:
        return(last)
a,b=input().split()
a,b=[int(a),int(b)]
x=gcd(a,b)
from functools import reduce
def factors(n):
    x=set(reduce(list.__add__, 
                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))
    return(list(x))
div=factors(x)
div.sort()
y=int(input())
for j in range(y):
    c,d=input().split()
    c,d=[int(c),int(d)]
    f=Bsearch1(div,c)
    g=Bsearch2(div,d)
    if f>g:
        print(-1)
    else:
        print(div[g])
    
","def game(n: int, m: int, polland: [str], enemy: [str]):
    if (n > m):
        return 'YES'
    if (n < m):
        return 'NO'
    
    # Use sets to determine the common words
    polland_set = set(polland)
    enemy_set = set(enemy)
    
    # Count the number of common words
    common_words = polland_set.intersection(enemy_set)
    common_count = len(common_words)
    
    # Calculate unique words for both
    unique_polland = n - common_count
    unique_enemy = m - common_count

    # Make the winning decision based on the counts
    if unique_polland > unique_enemy:
        return 'YES'
    elif unique_polland < unique_enemy:
        return 'NO'
    else:
        # If they are equal, PolandBall starts first
        return 'YES'"
839,A,Arya and Bran,PROGRAMMING,['implementation'],"Bran and his older sister Arya are from the same house. Bran like candies so much, so Arya is going to give him some Candies.

At first, Arya and Bran have 0 Candies. There are *n* days, at the *i*-th day, Arya finds *a**i* candies in a box, that is given by the Many-Faced God. Every day she can give Bran at most 8 of her candies. If she don't give him the candies at the same day, they are saved for her and she can give them to him later.

Your task is to find the minimum number of days Arya needs to give Bran *k* candies before the end of the *n*-th day. Formally, you need to output the minimum day index to the end of which *k* candies will be given out (the days are indexed from 1 to *n*).

Print -1 if she can't give him *k* candies during *n* given days.","The first line contains two integers *n* and *k* (1<=≤<=*n*<=≤<=100, 1<=≤<=*k*<=≤<=10000).

The second line contains *n* integers *a*1,<=*a*2,<=*a*3,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=100).","If it is impossible for Arya to give Bran *k* candies within *n* days, print -1.

Otherwise print a single integer — the minimum number of days Arya needs to give Bran *k* candies before the end of the *n*-th day.","['2 3\n1 2\n', '3 17\n10 10 10\n', '1 9\n10\n']","['2', '3', '-1']","In the first sample, Arya can give Bran 3 candies in 2 days.

In the second sample, Arya can give Bran 17 candies in 3 days, because she can give him at most 8 candies per day.

In the third sample, Arya can't give Bran 9 candies, because she can give him at most 8 candies per day and she must give him the candies within 1 day.",WRONG_ANSWER,"import math as mt 
import sys,string
input=sys.stdin.readline

from collections import defaultdict
L=lambda : list(map(int,input().split()))
Ls=lambda : list(input().split())
M=lambda : map(int,input().split())
I=lambda :int(input())

n,k=M()
l=L()
g=0
f=0
for i in range(n):
    g+=min(8,l[i])
    if(g>=k):
        print(i+1)
        f=1
        break
if(f==0):
    print(-1)
","def waiting(lst):
    v = [0]
    v += lst
    dp = []
    inf = 1000000000000000000
    n = len(lst)
    
    for i in range(0, n + 1):
        dp.append([inf] * 3)  # Initialize DP table with infinity
    dp[0][0] = 0  # Resting on the first day

    for i in range(1, n + 1):
        if v[i] == 0:  # Gym closed, contest not carried out
            dp[i][0] = min(dp[i-1]) + 1  # Rest
            dp[i][1] = inf  # Cannot do sport
            dp[i][2] = inf  # Cannot write contest
        elif v[i] == 1:  # Gym closed, contest carried out
            dp[i][0] = min(dp[i-1]) + 1  # Rest
            dp[i][1] = inf  # Cannot do sport
            dp[i][2] = dp[i-1][0]  # Write contest
        elif v[i] == 2:  # Gym open, contest not carried out
            dp[i][0] = min(dp[i-1]) + 1  # Rest
            dp[i][1] = dp[i-1][0]  # Do sport
            dp[i][2] = inf  # Cannot write contest
        elif v[i] == 3:  # Gym open, contest carried out
            dp[i][0] = min(dp[i-1]) + 1  # Rest
            dp[i][1] = dp[i-1][0]  # Do sport
            dp[i][2] = dp[i-1][0]  # Write contest
            
    # The minimum number of rest days will be the minimum of the last day's options
    result = min(dp[n])
    return result"
58,A,Chat room,PROGRAMMING,"['greedy', 'strings']","Vasya has recently learned to type and log on to the Internet. He immediately entered a chat room and decided to say hello to everybody. Vasya typed the word *s*. It is considered that Vasya managed to say hello if several letters can be deleted from the typed word so that it resulted in the word ""hello"". For example, if Vasya types the word ""ahhellllloou"", it will be considered that he said hello, and if he types ""hlelo"", it will be considered that Vasya got misunderstood and he didn't manage to say hello. Determine whether Vasya managed to say hello by the given word *s*.","The first and only line contains the word *s*, which Vasya typed. This word consisits of small Latin letters, its length is no less that 1 and no more than 100 letters.","If Vasya managed to say hello, print ""YES"", otherwise print ""NO"".","['ahhellllloou\n', 'hlelo\n']","['YES\n', 'NO\n']",none,OK,"def stringcheck(s):
    word=""hello""
    req=""h""
    c=0
    for ch in s:
        if c==5:
            break
        if ch==req:
            c+=1
            if c<5:
                req=word[c]
                
    if c==5:
        print(""YES"")
    else:
        print(""NO"")
s=input()
stringcheck(s)","def main():
    s = input().split()  # Read input and split it into first and last names
    f, l = s[0], s[-1]  # Assign first and last name to variables

    # Generate the alphabetically earliest login
    earliest_login = None  # Variable to hold the earliest login

    # Iterate through all possible non-empty prefixes of the first name
    for i in range(1, len(f) + 1):
        # Iterate through all possible non-empty prefixes of the last name
        for j in range(1, len(l) + 1):
            login = f[:i] + l[:j]  # Concatenate prefixes to form a login
            if earliest_login is None or login < earliest_login:  # Check if it's the earliest login
                earliest_login = login  # Update the earliest login

    print(earliest_login)  # Output the alphabetically earliest login"
862,A,Mahmoud and Ehab and the MEX,PROGRAMMING,"['greedy', 'implementation']","Dr. Evil kidnapped Mahmoud and Ehab in the evil land because of their performance in the Evil Olympiad in Informatics (EOI). He decided to give them some problems to let them go.

Dr. Evil is interested in sets, He has a set of *n* integers. Dr. Evil calls a set of integers evil if the MEX of it is exactly *x*. the MEX of a set of integers is the minimum non-negative integer that doesn't exist in it. For example, the MEX of the set {0,<=2,<=4} is 1 and the MEX of the set {1,<=2,<=3} is 0 .

Dr. Evil is going to make his set evil. To do this he can perform some operations. During each operation he can add some non-negative integer to his set or erase some element from it. What is the minimal number of operations Dr. Evil has to perform to make his set evil?","The first line contains two integers *n* and *x* (1<=≤<=*n*<=≤<=100, 0<=≤<=*x*<=≤<=100) — the size of the set Dr. Evil owns, and the desired MEX.

The second line contains *n* distinct non-negative integers not exceeding 100 that represent the set.",The only line should contain one integer — the minimal number of operations Dr. Evil should perform.,"['5 3\n0 4 5 6 7\n', '1 0\n0\n', '5 0\n1 2 3 4 5\n']","['2\n', '1\n', '0\n']","For the first test case Dr. Evil should add 1 and 2 to the set performing 2 operations.

For the second test case Dr. Evil should erase 0 from the set. After that, the set becomes empty, so the MEX of it is 0.

In the third test case the set is already evil.",WRONG_ANSWER,"n, x = map(int, input().split())
set1 = set(map(int, input().split()))
'''
if x == 0 and x in set1:
	for e in set1:
		print(e)
		break
else:
'''
set2 = set()
for i in range(0, x + 1):
	set2.add(i)

set3 = set2 - set1
print(set1)
print(set2)
print(set3)
if x in set3:
	#print(1)
	print(len(set3) - 1)
elif bool(set3) and x not in set3:
	#print(2)
	print(len(set3) + 1)
else:
	#print(3)
	print(len(set3) + 1)","def solve(s):
    s = 'a' + s  # Start from 'a'
    totalMoves = 0

    for i in range(1, len(s)):
        # Current and previous characters
        current_char = s[i]
        previous_char = s[i - 1]

        # Calculate the distance in clockwise and counterclockwise directions
        clockwise_distance = (ord(current_char) - ord(previous_char)) % 26
        counterclockwise_distance = (ord(previous_char) - ord(current_char)) % 26

        # Add the minimum of the two distances to totalMoves
        totalMoves += min(clockwise_distance, counterclockwise_distance)

    print(totalMoves)  # Output the total number of rotations"
844,A,Diversity,PROGRAMMING,"['greedy', 'implementation', 'strings']","Calculate the minimum number of characters you need to change in the string *s*, so that it contains at least *k* different letters, or print that it is impossible.

String *s* consists only of lowercase Latin letters, and it is allowed to change characters only to lowercase Latin letters too.","First line of input contains string *s*, consisting only of lowercase Latin letters (1<=≤<=|*s*|<=≤<=1000, |*s*| denotes the length of *s*).

Second line of input contains integer *k* (1<=≤<=*k*<=≤<=26).","Print single line with a minimum number of necessary changes, or the word «impossible» (without quotes) if it is impossible.","['yandex\n6\n', 'yahoo\n5\n', 'google\n7\n']","['0\n', '1\n', 'impossible\n']","In the first test case string contains 6 different letters, so we don't need to change anything.

In the second test case string contains 4 different letters: {'*a*', '*h*', '*o*', '*y*'}. To get 5 different letters it is necessary to change one occurrence of '*o*' to some letter, which doesn't occur in the string, for example, {'*b*'}.

In the third test case, it is impossible to make 7 different letters because the length of the string is 6.",OK,"s = input()
x = int(input())
if x > len(s):
    print('impossible')
elif x < len(set(s)):
    print(0)
else:
    print(x - len(set(s)))","# single inheritance
a, b = map(int, input().split())
s = ""abcdefghijklmnopqrstuvwxyz""

# If the number of distinct letters is greater than the length, it's impossible to form such a string
if b > a:
    print(""-1"")
else:
    result = []
    # Construct the string
    for i in range(a):
        # Select letters ensuring distinct letters are used and no two neighboring letters are the same
        result.append(s[i % b])
        
    # Join the list into a string and print the result
    print(''.join(result))"
265,A,Colorful Stones (Simplified Edition),PROGRAMMING,['implementation'],"There is a sequence of colorful stones. The color of each stone is one of red, green, or blue. You are given a string *s*. The *i*-th (1-based) character of *s* represents the color of the *i*-th stone. If the character is ""R"", ""G"", or ""B"", the color of the corresponding stone is red, green, or blue, respectively.

Initially Squirrel Liss is standing on the first stone. You perform instructions one or more times.

Each instruction is one of the three types: ""RED"", ""GREEN"", or ""BLUE"". After an instruction *c*, if Liss is standing on a stone whose colors is *c*, Liss will move one stone forward, else she will not move.

You are given a string *t*. The number of instructions is equal to the length of *t*, and the *i*-th character of *t* represents the *i*-th instruction.

Calculate the final position of Liss (the number of the stone she is going to stand on in the end) after performing all the instructions, and print its 1-based position. It is guaranteed that Liss don't move out of the sequence.","The input contains two lines. The first line contains the string *s* (1<=≤<=|*s*|<=≤<=50). The second line contains the string *t* (1<=≤<=|*t*|<=≤<=50). The characters of each string will be one of ""R"", ""G"", or ""B"". It is guaranteed that Liss don't move out of the sequence.",Print the final 1-based position of Liss in a single line.,"['RGB\nRRR\n', 'RRRBGBRBBB\nBBBRR\n', 'BRRBGBRGRBGRGRRGGBGBGBRGBRGRGGGRBRRRBRBBBGRRRGGBBB\nBBRBGGRGRGBBBRBGRBRBBBBRBRRRBGBBGBBRRBBGGRBRRBRGRB\n']","['2\n', '3\n', '15\n']",none,OK,"s = input()
t = input()
count=1
si=0
for i in range(len(t)):
    if t[i] == s[si]:
        count+=1
        si+=1

print(count)","def min_cost(a, b, l):
    # Check if the airports a and b belong to the same company
    return (l[a-1] != l[b-1]) + 0

# Read input
n, a, b = map(int, input().split())
l = input().strip()

# Print the minimum cost
print(min_cost(a, b, l))"
617,A,Elephant,PROGRAMMING,['math'],"An elephant decided to visit his friend. It turned out that the elephant's house is located at point 0 and his friend's house is located at point *x*(*x*<=&gt;<=0) of the coordinate line. In one step the elephant can move 1, 2, 3, 4 or 5 positions forward. Determine, what is the minimum number of steps he need to make in order to get to his friend's house.",The first line of the input contains an integer *x* (1<=≤<=*x*<=≤<=1<=000<=000) — The coordinate of the friend's house.,Print the minimum number of steps that elephant needs to make to get from point 0 to point *x*.,"['5\n', '12\n']","['1\n', '3\n']","In the first sample the elephant needs to make one step of length 5 to reach the point *x*.

In the second sample the elephant can get to point *x* if he moves by 3, 5 and 4. There are other ways to get the optimal answer but the elephant cannot reach *x* in less than three moves.",WRONG_ANSWER,"n=int(input())
lst1=[]
for i in range(1,6):
    if n%i==0:
        lst1.append([n//i,i])
lst2=[elem for row in lst1 for elem in row]
print(min(lst2))

		   		  	  	  				 		 	 		  		","s, n = list(map(int, input().split()))
inputs = []
for i in range(0, n):
    inputs.append(list(map(int, input().split())))

# Sort the dragons based on their strength
inputs.sort(key=lambda x: x[0])

# Attempt to defeat each dragon in sorted order
for dragon_strength, bonus in inputs:
    if s > dragon_strength:
        # If Kirito's strength is greater, defeat the dragon and get the bonus
        s += bonus
    else:
        # If Kirito's strength is not enough, he loses
        print(""NO"")
        break
else:
    # If all dragons are defeated
    print(""YES"")"
92,B,Binary Number,PROGRAMMING,['greedy'],"Little walrus Fangy loves math very much. That's why when he is bored he plays with a number performing some operations.

Fangy takes some positive integer *x* and wants to get a number one from it. While *x* is not equal to 1, Fangy repeats the following action: if *x* is odd, then he adds 1 to it, otherwise he divides *x* by 2. Fangy knows that for any positive integer number the process ends in finite time.

How many actions should Fangy perform to get a number one from number *x*?",The first line contains a positive integer *x* in a binary system. It is guaranteed that the first digit of *x* is different from a zero and the number of its digits does not exceed 106.,Print the required number of actions.,"['1\n', '1001001\n', '101110\n']","['0\n', '12\n', '8\n']","Let's consider the third sample. Number 101110 is even, which means that we should divide it by 2. After the dividing Fangy gets an odd number 10111 and adds one to it. Number 11000 can be divided by 2 three times in a row and get number 11. All that's left is to increase the number by one (we get 100), and then divide it by 2 two times in a row. As a result, we get 1.",WRONG_ANSWER,"n = int(input(), 2)
steps = 0
while n != 1:
	if n % 2 == 1:
		n += 1
	else:
		n /= 2
	steps += 1
print(steps)
	 		     	 	 			 	 	 					 		","from heapq import *
from queue import *
import sys, math, bisect
from math import *

from collections import Counter, defaultdict

# Read number of cards
n = int(input())
cards = []

# Read each card's values
for _ in range(n):
    a, b = map(int, input().split())
    cards.append((a, b))

# Sort cards by a + b in descending order to maximize points
cards.sort(key=lambda x: (x[0], x[1]), reverse=True)

# Priority queue for the points
max_points = 0
player_cards = [(0, 1)]  # (points, current play count)

while player_cards:
    points, play_count = player_cards.pop()
    
    if play_count == 0:
        continue
    
    max_points = max(max_points, points)

    for i in range(len(cards)):
        if cards[i] is not None:
            a, b = cards[i]
            # Playing the card
            new_play_count = play_count - 1 + b
            new_points = points + a
            
            # Mark card as played
            cards[i] = None
            
            # Add new state to the priority queue
            player_cards.append((new_points, new_play_count))
            break  # Break to avoid modifying the cards list while iterating

# Print the maximum points achieved
print(max_points)"
371,D,Vessels,PROGRAMMING,"['data structures', 'dsu', 'implementation', 'trees']","There is a system of *n* vessels arranged one above the other as shown in the figure below. Assume that the vessels are numbered from 1 to *n*, in the order from the highest to the lowest, the volume of the *i*-th vessel is *a**i* liters.

Initially, all the vessels are empty. In some vessels water is poured. All the water that overflows from the *i*-th vessel goes to the (*i*<=+<=1)-th one. The liquid that overflows from the *n*-th vessel spills on the floor.

Your task is to simulate pouring water into the vessels. To do this, you will need to handle two types of queries:
 1.  Add *x**i* liters of water to the *p**i*-th vessel; 1.  Print the number of liters of water in the *k**i*-th vessel. 
When you reply to the second request you can assume that all the water poured up to this point, has already overflown between the vessels.","The first line contains integer *n* — the number of vessels (1<=≤<=*n*<=≤<=2·105). The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* — the vessels' capacities (1<=≤<=*a**i*<=≤<=109). The vessels' capacities do not necessarily increase from the top vessels to the bottom ones (see the second sample). The third line contains integer *m* — the number of queries (1<=≤<=*m*<=≤<=2·105). Each of the next *m* lines contains the description of one query. The query of the first type is represented as ""1 *p**i* *x**i*"", the query of the second type is represented as ""2 *k**i*"" (1<=≤<=*p**i*<=≤<=*n*, 1<=≤<=*x**i*<=≤<=109, 1<=≤<=*k**i*<=≤<=*n*).","For each query, print on a single line the number of liters of water in the corresponding vessel.","['2\n5 10\n6\n1 1 4\n2 1\n1 2 5\n1 1 4\n2 1\n2 2\n', '3\n5 10 8\n6\n1 1 12\n2 2\n1 1 6\n1 3 2\n2 2\n2 3\n']","['4\n5\n8\n', '7\n10\n5\n']",none,RUNTIME_ERROR,"n = int(input())
capacidades = list(map(int, input().split()))
copos = [0 for x in range(n)]
m = int(input())
consultas = [tuple(map(int, input().split())) for x in range(m)]

def atualizar(p, x):

    if len(copos) <= p:
        return

    if capacidades[p] - copos[p] < x:
        cheio = capacidades[p] - copos[p]
    else:
        cheio = x

    x -= cheio
    copos[p] += cheio
    if x > 0:
        atualizar(p+1, x)

for consulta in consultas:
    if consulta[0] == 1:
        atualizar(consulta[1]-1, consulta[2])
    else:
        print(copos[consulta[1]-1])","# coding: utf-8

from functools import reduce

def gcd(x, y):
    while y:
        x, y = y, x % y
    return x

def lcm(x, y):
    return x * y // gcd(x, y)

def calculate_days(N, M, R):
    count = 0
    # Loop through each day from 0 to a large number (just for simulation)
    for D in range(100):  # assuming a large enough range for days
        for i in range(N):
            if D % M[i] <= R[i]:
                count += 1
                break  # move to the next day once washing is done
    return count / 100  # example to normalize over assumed 100 days

# Example usage
if __name__ == '__main__':
    N = int(input())
    M = list(map(int, input().split()))
    R = list(map(int, input().split()))
    result = calculate_days(N, M, R)
    print(result)"
137,C,History,PROGRAMMING,['sortings'],"Polycarpus likes studying at school a lot and he is always diligent about his homework. Polycarpus has never had any problems with natural sciences as his great-great-grandfather was the great physicist Seinstein. On the other hand though, Polycarpus has never had an easy time with history.

Everybody knows that the World history encompasses exactly *n* events: the *i*-th event had continued from the year *a**i* to the year *b**i* inclusive (*a**i*<=&lt;<=*b**i*). Polycarpus easily learned the dates when each of *n* events started and ended (Polycarpus inherited excellent memory from his great-great-granddad). But the teacher gave him a more complicated task: Polycaprus should know when all events began and ended and he should also find out for each event whether it includes another event. Polycarpus' teacher thinks that an event *j* includes an event *i* if *a**j*<=&lt;<=*a**i* and *b**i*<=&lt;<=*b**j*. Your task is simpler: find the number of events that are included in some other event.","The first input line contains integer *n* (1<=≤<=*n*<=≤<=105) which represents the number of events. Next *n* lines contain descriptions of the historical events, one event per line. The *i*<=+<=1 line contains two integers *a**i* and *b**i* (1<=≤<=*a**i*<=&lt;<=*b**i*<=≤<=109) — the beginning and the end of the *i*-th event. No two events start or finish in the same year, that is, *a**i*<=≠<=*a**j*,<=*a**i*<=≠<=*b**j*,<=*b**i*<=≠<=*a**j*,<=*b**i*<=≠<=*b**j* for all *i*, *j* (where *i*<=≠<=*j*). Events are given in arbitrary order.",Print the only integer — the answer to the problem.,"['5\n1 10\n2 9\n3 8\n4 7\n5 6\n', '5\n1 100\n2 50\n51 99\n52 98\n10 60\n', '1\n1 1000000000\n']","['4\n', '4\n', '0\n']","In the first example the fifth event is contained in the fourth. Similarly, the fourth event is contained in the third, the third — in the second and the second — in the first.

In the second example all events except the first one are contained in the first.

In the third example only one event, so the answer is 0.",OK,"import sys
from math import log2,floor,ceil,sqrt,gcd
import bisect
# from collections import deque
sys.setrecursionlimit(10**5)

Ri = lambda : [int(x) for x in sys.stdin.readline().split()]
ri = lambda : sys.stdin.readline().strip()

def input(): return sys.stdin.readline().strip()
def list2d(a, b, c): return [[c] * b for i in range(a)]
def list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]
def list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]
def ceil(x, y=1): return int(-(-x // y))
def INT(): return int(input())
def MAP(): return map(int, input().split())
def LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]
def Yes(): print('Yes')
def No(): print('No')
def YES(): print('YES')
def NO(): print('NO')
INF = 10 ** 18
MOD =  1000000007


n =int(ri())
lis = []
for i in range(n):
    temp = Ri()
    lis.append(temp)
lis.sort(key = lambda x : x[0])
cnt = 0
right = lis[0][1]
for i in range(1,len(lis)):
    if lis[i][1] < right:
        cnt+=1
    else:
        right= lis[i][1]
print(cnt)","import functools

n, m = map(int, input().split())
a = list(map(int, input().split()))
b = []

# Read the fruits Valera wants to buy
for _ in range(m):
    fruit = input().strip()
    b.append(fruit)

# Count the frequency of each fruit in Valera's list
fruit_count = {}
for fruit in b:
    if fruit in fruit_count:
        fruit_count[fruit] += 1
    else:
        fruit_count[fruit] = 1

# Sort prices and counts
sorted_prices = sorted(a)
sorted_counts = sorted(fruit_count.values(), reverse=True)

# Calculate minimum possible sum
min_sum = sum(sorted_prices[i] * sorted_counts[i] for i in range(len(sorted_counts)))

# Calculate maximum possible sum
max_sum = sum(sorted_prices[-(i + 1)] * sorted_counts[i] for i in range(len(sorted_counts)))

# Output the results
print(min_sum, max_sum)"
568,A,Primes or Palindromes?,PROGRAMMING,"['brute force', 'implementation', 'math', 'number theory']","Rikhail Mubinchik believes that the current definition of prime numbers is obsolete as they are too complex and unpredictable. A palindromic number is another matter. It is aesthetically pleasing, and it has a number of remarkable properties. Help Rikhail to convince the scientific community in this!

Let us remind you that a number is called prime if it is integer larger than one, and is not divisible by any positive integer other than itself and one.

Rikhail calls a number a palindromic if it is integer, positive, and its decimal representation without leading zeros is a palindrome, i.e. reads the same from left to right and right to left.

One problem with prime numbers is that there are too many of them. Let's introduce the following notation: π(*n*) — the number of primes no larger than *n*, *rub*(*n*) — the number of palindromic numbers no larger than *n*. Rikhail wants to prove that there are a lot more primes than palindromic ones.

He asked you to solve the following problem: for a given value of the coefficient *A* find the maximum *n*, such that π(*n*)<=≤<=*A*·*rub*(*n*).","The input consists of two positive integers *p*, *q*, the numerator and denominator of the fraction that is the value of *A* (, ).","If such maximum number exists, then print it. Otherwise, print ""Palindromic tree is better than splay tree"" (without the quotes).","['1 1\n', '1 42\n', '6 4\n']","['40\n', '1\n', '172\n']",none,TIME_LIMIT_EXCEEDED,"def is_palindrome(num):
    
    copia = num
    if num < 10:
        return True
    
    nums = []
    while(True):
        nums.append(copia % 10)
        copia //= 10
        
        if copia == 0:
            break
    
    digitos = len(nums) // 2
    j = len(nums) - 1
    for i in range(digitos):
        if nums[i] != nums[j]:
            return False
        j -= 1

    return True

def palindromes(x):

    palindrome = []
    count = 0
    i = 1

    while(i <= x):
        if is_palindrome(i):
            count += 1

        palindrome.append(count)
        i += 1

    return palindrome

def primes(x):
    
    primes = [True] * x
    primes[0] = False
    primos = [0]
    count = 0
    i = 1

    while(i * i < x):
        if primes[i] == True:
            count += 1

            for j in range(i, x, i + 1):
                primes[j] = False
    
        primos.append(count)
        i += 1

    while(i < x):
        if primes[i] == True:
            count += 1
        
        primos.append(count)
        i += 1

    return primos

primos = primes(2000000)
palindromes = palindromes(2000000)

num = input().split()
num = [int(num[0]), int(num[1])]
i = 0
resultado = 0

while(i < 2000000):

    res = ((palindromes[i]) * num[0]) / num[1]
    if res >= primos[i]:
        resultado = i + 1
   
    i += 1

if resultado == 0:
    print(""Palindromic tree is better than splay tree"")

else:
    print(resultado)
","import heapq

def main():
    priority = [
        ""33-44-33"",
        ""33-44-33"",
        ""22-33-22"",
        ""22-33-22"",
        ""11-22-11"",
        ""11-22-11""
    ]
    
    classroom = [input().strip() for _ in range(6)]
    # Create a list to store available positions with their convenience
    available_positions = []

    # Iterate through the classroom to find vacant places
    for i in range(6):
        for j in range(3):
            left = classroom[i][2 * j]
            right = classroom[i][2 * j + 1]
            convenience = int(priority[i][2 * j])
            
            # Check left desk
            if left == '.':
                available_positions.append((convenience, i, 2 * j))  # store convenience, row, column
            
            # Check right desk
            if right == '.':
                available_positions.append((convenience, i, 2 * j + 1))  # store convenience, row, column

    # Find the maximum convenience
    max_convenience = max(available_positions)[0]

    # Filter positions with the maximum convenience
    best_positions = [pos for pos in available_positions if pos[0] == max_convenience]

    # Pick the first best position to mark with 'P'
    _, row, col = best_positions[0]
    classroom[row] = classroom[row][:col] + 'P' + classroom[row][col + 1:]

    # Print the updated classroom plan
    for line in classroom:
        print(line)

if __name__ == ""__main__"":
    main()"
520,B,Two Buttons,PROGRAMMING,"['dfs and similar', 'graphs', 'greedy', 'implementation', 'math', 'shortest paths']","Vasya has found a strange device. On the front panel of a device there are: a red button, a blue button and a display showing some positive integer. After clicking the red button, device multiplies the displayed number by two. After clicking the blue button, device subtracts one from the number on the display. If at some point the number stops being positive, the device breaks down. The display can show arbitrarily large numbers. Initially, the display shows number *n*.

Bob wants to get number *m* on the display. What minimum number of clicks he has to make in order to achieve this result?","The first and the only line of the input contains two distinct integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=104), separated by a space .",Print a single number — the minimum number of times one needs to push the button required to get the number *m* out of number *n*.,"['4 6\n', '10 1\n']","['2\n', '9\n']","In the first example you need to push the blue button once, and then push the red button once.

In the second example, doubling the number is unnecessary, so we need to push the blue button nine times.",OK,"from collections import deque


n, m = map(int, input().split())

queue = deque([(n, 0)])

visited = set()


while queue:
    current, clicks = queue.popleft()
    if current == m:
        print(clicks)
        break

    if current * 2 not in visited and current * 2 <= 10**4:
        queue.append((current * 2, clicks + 1))
        visited.add(current * 2)

    if current - 1 > 0 and current - 1 not in visited:
        queue.append((current - 1, clicks + 1))
        visited.add(current - 1)
","# 58A => Chat room
# https://codeforces.com/problemset/problem/58/A

s = input()  # Read input
target = ""hello""  # The word we want to form
j = 0  # Pointer for the target word

# Loop through each character in the input string
for char in s:
    # Check if the current character matches the current target character
    if char == target[j]:
        j += 1  # Move to the next character in the target word
    # If we've matched all characters in ""hello"", break the loop
    if j == len(target):
        break

# Check if we've successfully matched all characters in ""hello""
if j == len(target):
    print(""YES"")  # Output YES if we formed the word ""hello""
else:
    print(""NO"")  # Output NO if we did not form the word ""hello"""
336,A,Vasily the Bear and Triangle,PROGRAMMING,"['implementation', 'math']","Vasily the bear has a favorite rectangle, it has one vertex at point (0,<=0), and the opposite vertex at point (*x*,<=*y*). Of course, the sides of Vasya's favorite rectangle are parallel to the coordinate axes. 

Vasya also loves triangles, if the triangles have one vertex at point *B*<==<=(0,<=0). That's why today he asks you to find two points *A*<==<=(*x*1,<=*y*1) and *C*<==<=(*x*2,<=*y*2), such that the following conditions hold:
 -  the coordinates of points: *x*1, *x*2, *y*1, *y*2 are integers. Besides, the following inequation holds: *x*1<=&lt;<=*x*2; -  the triangle formed by point *A*, *B* and *C* is rectangular and isosceles ( is right); -  all points of the favorite rectangle are located inside or on the border of triangle *ABC*; -  the area of triangle *ABC* is as small as possible. 
Help the bear, find the required points. It is not so hard to proof that these points are unique.","The first line contains two integers *x*,<=*y* (<=-<=109<=≤<=*x*,<=*y*<=≤<=109,<=*x*<=≠<=0,<=*y*<=≠<=0).","Print in the single line four integers *x*1,<=*y*1,<=*x*2,<=*y*2 — the coordinates of the required points.","['10 5\n', '-10 5\n']","['0 15 15 0\n', '-15 0 0 15\n']","<img class=""tex-graphics"" src=""https://espresso.codeforces.com/a9ea2088c4294ce8f23801562fda36b830df2c3f.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

Figure to the first sample",OK,"n=input().split()
x,y=int(n[0]),int(n[1])
if x>0 and y>0:
    print(0,x+y,x+y,0)
elif x>0 and y<0:
    print(0,y-x,x-y,0)
elif x<0 and y>0:
    print(x-y,0,0,y-x)
else:
    print(x+y,0,0,x+y)","def f(password):
    if len(password) < 5:
        return False
    large = False
    small = False
    digit = False
    
    for char in password:
        if char.isupper():
            large = True
        elif char.islower():
            small = True
        elif char.isdigit():
            digit = True
            
    return large and small and digit

# Input password
password = input()

# Check password complexity
if f(password):
    print(""Correct"")
else:
    print(""Too weak"")"
898,C,Phone Numbers,PROGRAMMING,"['implementation', 'strings']","Vasya has several phone books, in which he recorded the telephone numbers of his friends. Each of his friends can have one or several phone numbers.

Vasya decided to organize information about the phone numbers of friends. You will be given *n* strings — all entries from Vasya's phone books. Each entry starts with a friend's name. Then follows the number of phone numbers in the current entry, and then the phone numbers themselves. It is possible that several identical phones are recorded in the same record.

Vasya also believes that if the phone number *a* is a suffix of the phone number *b* (that is, the number *b* ends up with *a*), and both numbers are written by Vasya as the phone numbers of the same person, then *a* is recorded without the city code and it should not be taken into account.

The task is to print organized information about the phone numbers of Vasya's friends. It is possible that two different people have the same number. If one person has two numbers *x* and *y*, and *x* is a suffix of *y* (that is, *y* ends in *x*), then you shouldn't print number *x*. If the number of a friend in the Vasya's phone books is recorded several times in the same format, it is necessary to take it into account exactly once.

Read the examples to understand statement and format of the output better.","First line contains the integer *n* (1<=≤<=*n*<=≤<=20) — number of entries in Vasya's phone books. 

The following *n* lines are followed by descriptions of the records in the format described in statement. Names of Vasya's friends are non-empty strings whose length does not exceed 10. They consists only of lowercase English letters. Number of phone numbers in one entry is not less than 1 is not more than 10. The telephone numbers consist of digits only. If you represent a phone number as a string, then its length will be in range from 1 to 10. Phone numbers can contain leading zeros.","Print out the ordered information about the phone numbers of Vasya's friends. First output *m* — number of friends that are found in Vasya's phone books.

The following *m* lines must contain entries in the following format ""name number_of_phone_numbers phone_numbers"". Phone numbers should be separated by a space. Each record must contain all the phone numbers of current friend.

Entries can be displayed in arbitrary order, phone numbers for one record can also be printed in arbitrary order.","['2\nivan 1 00123\nmasha 1 00123\n', '3\nkarl 2 612 12\npetr 1 12\nkatya 1 612\n', '4\nivan 3 123 123 456\nivan 2 456 456\nivan 8 789 3 23 6 56 9 89 2\ndasha 2 23 789\n']","['2\nmasha 1 00123 \nivan 1 00123 \n', '3\nkatya 1 612 \npetr 1 12 \nkarl 1 612 \n', '2\ndasha 2 23 789 \nivan 4 789 123 2 456 \n']",none,WRONG_ANSWER,"import sys
input = sys.stdin.readline
from collections import *

def judge(s, t):
    return s[len(s)-len(t):]==t

d = defaultdict(set)

for _ in range(int(input())):
    l = list(input().split())
    
    for num in l[2:]:
        d[l[0]].add(num)

for k in d.keys():
    ans = []
    
    for num1 in d[k]:
        flag = True
        
        for num2 in d[k]:
            if num1==num2:
                continue
            
            if judge(num2, num1):
                flag = False
        
        if flag:
            ans.append(num1)
    
    print(k, len(ans), *ans)","class LowestCommonAncestor:
    """"""<O(n), O(log(n))>""""""

    def __init__(self, G, root, parents):
        from collections import deque

        self.n = len(G)
        self.tour = [0] * (2 * self.n - 1)
        self.depth = []
        self.first_appearance = [-1] * self.n
        self.log = [0] * (2 * self.n)
        self.adj = [[] for _ in range(self.n)]

        # Prepare the adjacency list
        for u in range(self.n):
            for v in G[u]:
                self.adj[u].append(v)

        # DFS to fill tour and depths
        self.index = 0
        self.dfs(root, 0, parents)
        
        # Prepare log table
        for i in range(2, len(self.log)):
            self.log[i] = self.log[i // 2] + 1

        self.m = len(self.tour)
        self.table = [[0] * self.log[self.m] for _ in range(self.m)]
        for i in range(self.m):
            self.table[i][0] = self.tour[i]

        # Build sparse table
        j = 1
        while (1 << j) <= self.m:
            for i in range(self.m - (1 << j) + 1):
                self.table[i][j] = min(self.table[i][j-1], self.table[i + (1 << (j - 1))][j - 1])
            j += 1

    def dfs(self, node, d, parents):
        """"""Depth-First Search to fill the tour and depths.""""""
        self.first_appearance[node] = self.index
        self.tour[self.index] = node
        self.depth.append(d)
        self.index += 1

        for neighbor in self.adj[node]:
            if neighbor != parents[node]:
                self.dfs(neighbor, d + 1, parents)
                self.tour[self.index] = node
                self.depth.append(d)
                self.index += 1

    def lca(self, u, v):
        """"""Find the Lowest Common Ancestor of nodes u and v.""""""
        left = self.first_appearance[u]
        right = self.first_appearance[v]
        if left > right:
            left, right = right, left
        length = right - left + 1
        j = self.log[length]
        return min(self.table[left][j], self.table[right - (1 << j) + 1][j])

from collections import deque, defaultdict

def main():
    import sys
    input = sys.stdin.read
    data = input().splitlines()
    
    n, m = map(int, data[0].split())
    G = defaultdict(list)
    
    # Read tree edges
    for i in range(1, n):
        a, b = map(int, data[i].split())
        G[a - 1].append(b - 1)
        G[b - 1].append(a - 1)

    parents = [0] * n

    # BFS to determine parents
    queue = deque([0])
    visited = [False] * n
    visited[0] = True

    while queue:
        node = queue.popleft()
        for neighbor in G[node]:
            if not visited[neighbor]:
                parents[neighbor] = node
                visited[neighbor] = True
                queue.append(neighbor)

    lca = LowestCommonAncestor(G, 0, parents)
    
    queries = data[n:]
    red_nodes = {0}  # initially red node is node 1 (index 0)
    results = []

    for query in queries:
        t, v = map(int, query.split())
        v -= 1  # switch to zero-index
        if t == 1:
            red_nodes.add(v)  # paint the node red
        elif t == 2:
            # Find closest red node
            min_distance = float('inf')
            for red in red_nodes:
                distance = len(path)  # distance will be computed using LCA or BFS
                distance = lca.lca(v, red)
                min_distance = min(min_distance, distance)
            results.append(min_distance)
    
    print('\n'.join(map(str, results)))

if __name__ == ""__main__"":
    main()"
0,none,none,none,['none'],"Theater stage is a rectangular field of size *n*<=×<=*m*. The director gave you the stage's plan which actors will follow. For each cell it is stated in the plan if there would be an actor in this cell or not.

You are to place a spotlight on the stage in some good position. The spotlight will project light in one of the four directions (if you look at the stage from above) — left, right, up or down. Thus, the spotlight's position is a cell it is placed to and a direction it shines.

A position is good if two conditions hold: 
 -  there is no actor in the cell the spotlight is placed to; -  there is at least one actor in the direction the spotlight projects. 
Count the number of good positions for placing the spotlight. Two positions of spotlight are considered to be different if the location cells or projection direction differ.","The first line contains two positive integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=1000) — the number of rows and the number of columns in the plan.

The next *n* lines contain *m* integers, 0 or 1 each — the description of the plan. Integer 1, means there will be an actor in the corresponding cell, while 0 means the cell will remain empty. It is guaranteed that there is at least one actor in the plan.",Print one integer — the number of good positions for placing the spotlight.,"['2 4\n0 1 0 0\n1 0 1 0\n', '4 4\n0 0 0 0\n1 0 0 1\n0 1 1 0\n0 1 0 0\n']","['9\n', '20\n']","In the first example the following positions are good:
 1.  the (1, 1) cell and right direction; 1.  the (1, 1) cell and down direction; 1.  the (1, 3) cell and left direction; 1.  the (1, 3) cell and down direction; 1.  the (1, 4) cell and left direction; 1.  the (2, 2) cell and left direction; 1.  the (2, 2) cell and up direction; 1.  the (2, 2) and right direction; 1.  the (2, 4) cell and left direction. 
Therefore, there are 9 good positions in this example.",TIME_LIMIT_EXCEEDED,"n, m=map(int, input().split())
a=[list(map(int, input().split())) for _ in range(n)]
ans=p=0

def f(x):
    global ans, p
    if x==0:
        ans+=p
    else:
        p=1

for i in range(n):
    p=0
    for j in range(m):
        f(a[i][j])
    p=0
    for j in range(m-1, -1, -1):
        f(a[i][j])

for i in range(m):
    p=0
    for j in range(n):
        f(a[j][i])
    p=0
    for j in range(n-1, -1, -1):
        f(a[j][i])

print(ans)","def solver(a, b):
    resp = 0
    while a > 0 and b > 0:
        # Make a square piece of paper
        if a > b:
            resp += a // b  # Count how many squares can be cut
            a = a % b  # Update the remaining strip of paper
        else:
            resp += b // a  # Count how many squares can be cut
            b = b % a  # Update the remaining strip of paper
    return resp"
862,A,Mahmoud and Ehab and the MEX,PROGRAMMING,"['greedy', 'implementation']","Dr. Evil kidnapped Mahmoud and Ehab in the evil land because of their performance in the Evil Olympiad in Informatics (EOI). He decided to give them some problems to let them go.

Dr. Evil is interested in sets, He has a set of *n* integers. Dr. Evil calls a set of integers evil if the MEX of it is exactly *x*. the MEX of a set of integers is the minimum non-negative integer that doesn't exist in it. For example, the MEX of the set {0,<=2,<=4} is 1 and the MEX of the set {1,<=2,<=3} is 0 .

Dr. Evil is going to make his set evil. To do this he can perform some operations. During each operation he can add some non-negative integer to his set or erase some element from it. What is the minimal number of operations Dr. Evil has to perform to make his set evil?","The first line contains two integers *n* and *x* (1<=≤<=*n*<=≤<=100, 0<=≤<=*x*<=≤<=100) — the size of the set Dr. Evil owns, and the desired MEX.

The second line contains *n* distinct non-negative integers not exceeding 100 that represent the set.",The only line should contain one integer — the minimal number of operations Dr. Evil should perform.,"['5 3\n0 4 5 6 7\n', '1 0\n0\n', '5 0\n1 2 3 4 5\n']","['2\n', '1\n', '0\n']","For the first test case Dr. Evil should add 1 and 2 to the set performing 2 operations.

For the second test case Dr. Evil should erase 0 from the set. After that, the set becomes empty, so the MEX of it is 0.

In the third test case the set is already evil.",OK,"import sys, os, io
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

n, x = map(int, input().split())
a = list(map(int, input().split()))
l = 105
cnt = [0] * l
for i in a:
    cnt[i] += 1
ans = 0
for i in range(x):
    if not cnt[i]:
        ans += 1
ans += cnt[x]
print(ans)","n, m, k = map(int, input().split())
matrix = [[0]*(m + 2) for _ in range(n + 2)]

def check(i, j):
    # Check for 2x2 black square formation
    if matrix[i-1][j-1] and matrix[i-1][j] and matrix[i][j-1] and matrix[i][j]:
        return True
    return False

def main():
    for move in range(1, k + 1):
        i, j = map(int, input().split())
        matrix[i][j] = 1  # Color the pixel black

        # Check if forming a square with 2x2 pixels around the current pixel
        if check(i, j) or check(i - 1, j) or check(i, j - 1) or check(i - 1, j - 1):
            print(move)  # Pasha loses at this move
            return

    print(0)  # No 2x2 square formed

main()"
327,A,Flipping Game,PROGRAMMING,"['brute force', 'dp', 'implementation']","Iahub got bored, so he invented a game to be played on paper. 

He writes *n* integers *a*1,<=*a*2,<=...,<=*a**n*. Each of those integers can be either 0 or 1. He's allowed to do exactly one move: he chooses two indices *i* and *j* (1<=≤<=*i*<=≤<=*j*<=≤<=*n*) and flips all values *a**k* for which their positions are in range [*i*,<=*j*] (that is *i*<=≤<=*k*<=≤<=*j*). Flip the value of *x* means to apply operation *x*<==<=1 - *x*.

The goal of the game is that after exactly one move to obtain the maximum number of ones. Write a program to solve the little game of Iahub.","The first line of the input contains an integer *n* (1<=≤<=*n*<=≤<=100). In the second line of the input there are *n* integers: *a*1,<=*a*2,<=...,<=*a**n*. It is guaranteed that each of those *n* values is either 0 or 1.",Print an integer — the maximal number of 1s that can be obtained after exactly one move.,"['5\n1 0 0 1 0\n', '4\n1 0 0 1\n']","['4\n', '4\n']","In the first case, flip the segment from 2 to 5 (*i* = 2, *j* = 5). That flip changes the sequence, it becomes: [1 1 1 0 1]. So, it contains four ones. There is no way to make the whole sequence equal to [1 1 1 1 1].

In the second case, flipping only the second and the third element (*i* = 2, *j* = 3) will turn all numbers into 1.",OK,"n = int(input())
a = list(map(int, input().split()))

max_ones = 0

for i in range(n):
    for j in range(i, n):
        temp = a.copy()
        for k in range(i, j+1):
            temp[k] = 1 - temp[k]
        max_ones = max(max_ones, temp.count(1))

print(max_ones)
","import sys

n = int(input())

def ask(a, b):
    print('?', a, b)
    sys.stdout.flush()

# Create a placeholder for the result permutation
p = list(range(n))

# Simulate the behavior of the hidden permutation by assuming p is the correct one
# As we're not querying the actual hidden permutation we just need to assume we're confident about our permutation structure
# In a real situation, we would use the `ask` function to gather required data

# There is exactly one permutation indistinguishable from any given permutation,
# The identity permutation [0, 1, 2, ..., n-1] is one of the candidates.
# The count of permutations indistinguishable from the hidden one will be 1 in this simplified case.

# Calculate indistinguishable count
answers_cnt = 1  # Only the identity permutation

# Now print the results as needed
print(""!"")
print(answers_cnt)
print("" "".join(map(str, p)))"
272,A,Dima and Friends,PROGRAMMING,"['implementation', 'math']","Dima and his friends have been playing hide and seek at Dima's place all night. As a result, Dima's place got messy. In the morning they decided that they need to clean the place.

To decide who exactly would clean the apartment, the friends want to play a counting-out game. First, all the guys stand in a circle, and then each of them shows some number of fingers on one hand (one to five), and then the boys count in a circle, starting from Dima, the number of people, respective to the total number of fingers shown. The person on who the countdown stops will clean the apartment.

For example, if Dima and one of his friends played hide and seek, and 7 fingers were shown during the counting-out, then Dima would clean the place. If there were 2 or say, 8 fingers shown, then his friend would clean the place.

Dima knows how many fingers each of his friends will show during the counting-out. Now he is interested in the number of ways to show some number of fingers on one hand (one to five), so that he did not have to clean the place. Help Dima.","The first line contains integer *n* (1<=≤<=*n*<=≤<=100) — the number of Dima's friends. Dima himself isn't considered to be his own friend. The second line contains *n* positive integers, not exceeding 5, representing, how many fingers the Dima's friends will show. 

The numbers in the lines are separated by a single space.",In a single line print the answer to the problem.,"['1\n1\n', '1\n2\n', '2\n3 5\n']","['3\n', '2\n', '3\n']","In the first sample Dima can show 1, 3 or 5 fingers. If Dima shows 3 fingers, then the counting-out will go like that: Dima, his friend, Dima, his friend.

In the second sample Dima can show 2 or 4 fingers.",OK,"n = int(input())
l = list(map(int,input().split()))
if n<3:
    if n%2==0:
        if sum(l)%2==0:
            print(3)
        else:
            print(2)
    else:
        if sum(l)%2==0:
            print(2)
        else:
            print(3)
else:
    mod = sum(l)%(n+1)
    mod = n+1-mod
    if mod>=5:
        print(5)
    else:
        print(4)
","# !python3.8
""""""
Heap max Em Python
""""""
from math import floor


class MaxHeap:
    def __init__(self):
        self.heap = []
    
    def insert(self, value):
        # Add a new value to the heap
        self.heap.append(value)
        self._heapify_up(len(self.heap) - 1)

    def _heapify_up(self, index):
        # Move the value at index up to its proper position
        parent = (index - 1) // 2
        if index > 0 and self.heap[index] > self.heap[parent]:
            self.heap[index], self.heap[parent] = self.heap[parent], self.heap[index]
            self._heapify_up(parent)

    def extract_max(self):
        # Remove and return the maximum value from the heap
        if len(self.heap) == 0:
            return None
        if len(self.heap) == 1:
            return self.heap.pop()
        max_value = self.heap[0]
        self.heap[0] = self.heap.pop()
        self._heapify_down(0)
        return max_value

    def _heapify_down(self, index):
        # Move the value at index down to its proper position
        largest = index
        left = 2 * index + 1
        right = 2 * index + 2
        
        if left < len(self.heap) and self.heap[left] > self.heap[largest]:
            largest = left
        if right < len(self.heap) and self.heap[right] > self.heap[largest]:
            largest = right
        
        if largest != index:
            self.heap[index], self.heap[largest] = self.heap[largest], self.heap[index]
            self._heapify_down(largest)

    def is_empty(self):
        # Check if the heap is empty
        return len(self.heap) == 0


def min_coins_needed(n, coins):
    # Calculate the minimum number of coins needed
    total_sum = sum(coins)
    coins_sorted = sorted(coins, reverse=True)  # Sort coins in descending order
    my_sum = 0
    count = 0
    
    for coin in coins_sorted:
        my_sum += coin
        count += 1
        if my_sum > total_sum - my_sum:  # Check if my sum is strictly greater than the twin's
            return count

    return count  # In case all coins are taken


# Input handling
n = int(input().strip())
coins = list(map(int, input().strip().split()))

# Output the result
print(min_coins_needed(n, coins))"
230,B,T-primes,PROGRAMMING,"['binary search', 'implementation', 'math', 'number theory']","We know that prime numbers are positive integers that have exactly two distinct positive divisors. Similarly, we'll call a positive integer *t* Т-prime, if *t* has exactly three distinct positive divisors.

You are given an array of *n* positive integers. For each of them determine whether it is Т-prime or not.","The first line contains a single positive integer, *n* (1<=≤<=*n*<=≤<=105), showing how many numbers are in the array. The next line contains *n* space-separated integers *x**i* (1<=≤<=*x**i*<=≤<=1012).

Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is advised to use the cin, cout streams or the %I64d specifier.","Print *n* lines: the *i*-th line should contain ""YES"" (without the quotes), if number *x**i* is Т-prime, and ""NO"" (without the quotes), if it isn't.",['3\n4 5 6\n'],['YES\nNO\nNO\n'],"The given test has three numbers. The first number 4 has exactly three divisors — 1, 2 and 4, thus the answer for this number is ""YES"". The second number 5 has two divisors (1 and 5), and the third number 6 has four divisors (1, 2, 3, 6), hence the answer for them is ""NO"".",WRONG_ANSWER,"'''
刘思瑞 2100017810
'''
def search(num):
    if int(int(num**(0.5))**2) != num:
        return 'NO'
    for i in range(2,int(num**(0.5)+1)):
        if num % i == 0:
            if i**2 != num:
                return 'NO'
    return 'YES'

n = int(input())
num = list(map(int,input().split()))
for i in num:
    print(search(i))
","def main():
    n = int(input())
    l = input()
    l = l.split()
    for i in range(n):
        l[i] = int(l[i])

    m = int(input())
    for _ in range(m):
        x, y = map(int, input().split())
        x -= 1  # Convert to zero-based index
        y -= 1  # Convert to zero-based index
        
        # Birds on the wire before shooting
        left_birds = y    # Number of birds to the left of the shot bird
        right_birds = l[x] - (y + 1)  # Number of birds to the right of the shot bird
        
        # Birds that jump up
        if x > 0:
            l[x - 1] += left_birds
        # Birds that jump down
        if x < n - 1:
            l[x + 1] += right_birds
        
        # Update the current wire after shooting
        l[x] -= 1  # One bird is shot

    # Print the final number of birds on each wire
    for count in l:
        print(count)

main()"
4,C,Registration System,PROGRAMMING,"['data structures', 'hashing', 'implementation']","A new e-mail service ""Berlandesk"" is going to be opened in Berland in the near future. The site administration wants to launch their project as soon as possible, that's why they ask you to help. You're suggested to implement the prototype of site registration system. The system should work on the following principle. 

Each time a new user wants to register, he sends to the system a request with his name. If such a name does not exist in the system database, it is inserted into the database, and the user gets the response OK, confirming the successful registration. If the name already exists in the system database, the system makes up a new user name, sends it to the user as a prompt and also inserts the prompt into the database. The new name is formed by the following rule. Numbers, starting with 1, are appended one after another to name (name1, name2, ...), among these numbers the least *i* is found so that name*i* does not yet exist in the database.","The first line contains number *n* (1<=≤<=*n*<=≤<=105). The following *n* lines contain the requests to the system. Each request is a non-empty line, and consists of not more than 32 characters, which are all lowercase Latin letters.","Print *n* lines, which are system responses to the requests: OK in case of successful registration, or a prompt with a new name, if the requested name is already taken.","['4\nabacaba\nacaba\nabacaba\nacab\n', '6\nfirst\nfirst\nsecond\nsecond\nthird\nthird\n']","['OK\nOK\nabacaba1\nOK\n', 'OK\nfirst1\nOK\nsecond1\nOK\nthird1\n']",none,WRONG_ANSWER,"n = int(input())
mydict = []
for _ in range(n):
    text = input()
    if text in mydict:
        print(text + ""1"")
    else:
        print(""OK"")
        mydict.append(text)
quit()
   					   		 	   	  			    			","n  = int(input())
from collections import defaultdict
g = defaultdict(list)
for _ in range(n-1):
    a,b = [int(x) for x in input().split()]
    g[a].append([b,1]) # green edge
    g[b].append([a,0]) # red edge
dist = [1e9 for i in range(n+1)]

def dfs(node, count):
    dist[node] = count
    for neighbor, weight in g[node]:
        if dist[neighbor] == 1e9: # not visited
            dfs(neighbor, count + weight)

# Starting the DFS from node 1 (any node can be the starting point)
dfs(1, 0)

# Calculate the minimum inversions and the capitals
min_inversions = min(dist[1:])
capitals = [i for i in range(1, n+1) if dist[i] == min_inversions]

print(min_inversions)
print(' '.join(map(str, sorted(capitals))))"
124,A,The number of positions,PROGRAMMING,['math'],"Petr stands in line of *n* people, but he doesn't know exactly which position he occupies. He can say that there are no less than *a* people standing in front of him and no more than *b* people standing behind him. Find the number of different positions Petr can occupy.","The only line contains three integers *n*, *a* and *b* (0<=≤<=*a*,<=*b*<=&lt;<=*n*<=≤<=100).",Print the single number — the number of the sought positions.,"['3 1 1\n', '5 2 3\n']","['2\n', '3\n']","The possible positions in the first sample are: 2 and 3 (if we number the positions starting with 1).

In the second sample they are 3, 4 and 5.",COMPILATION_ERROR,"import sys
inputs = sys.stdin.readline().split()
print min(int(inputs[0])-int(inputs[1]),int(inputs[2])+1)","def power(a, n):
    if n == 0:
        return 1
    if not n % 2:
        half_power = power(a, n // 2)
        return half_power * half_power
    else:
        return a * power(a, n - 1)

def expected_maximum(m, n):
    expected_value = 0.0
    for k in range(1, m + 1):
        # Calculate the probability of the maximum being at least k
        prob_at_least_k = (k / m) ** n
        expected_value += k * (prob_at_least_k - ((k + 1) / m) ** n)
    return expected_value

# Read inputs
m, n = map(int, input().split())
# Calculate expected maximum number of dots
result = expected_maximum(m, n)
# Output the result
print(result)"
231,A,Team,PROGRAMMING,"['brute force', 'greedy']","One day three best friends Petya, Vasya and Tonya decided to form a team and take part in programming contests. Participants are usually offered several problems during programming contests. Long before the start the friends decided that they will implement a problem if at least two of them are sure about the solution. Otherwise, the friends won't write the problem's solution.

This contest offers *n* problems to the participants. For each problem we know, which friend is sure about the solution. Help the friends find the number of problems for which they will write a solution.","The first input line contains a single integer *n* (1<=≤<=*n*<=≤<=1000) — the number of problems in the contest. Then *n* lines contain three integers each, each integer is either 0 or 1. If the first number in the line equals 1, then Petya is sure about the problem's solution, otherwise he isn't sure. The second number shows Vasya's view on the solution, the third number shows Tonya's view. The numbers on the lines are separated by spaces.",Print a single integer — the number of problems the friends will implement on the contest.,"['3\n1 1 0\n1 1 1\n1 0 0\n', '2\n1 0 0\n0 1 1\n']","['2\n', '1\n']","In the first sample Petya and Vasya are sure that they know how to solve the first problem and all three of them know how to solve the second problem. That means that they will write solutions for these problems. Only Petya is sure about the solution for the third problem, but that isn't enough, so the friends won't take it. 

In the second sample the friends will only implement the second problem, as Vasya and Tonya are sure about the solution.",RUNTIME_ERROR,"data = list(map(int, input().split()))

a,b,c = data
max_problems = max(a, b, c)

if a+b+c - max_problems >= 2:
    print(max_problems + 1)
else:
    print(a + b + c)
","#from code force
# https://codeforces.com/contest/863/problem/B

import sys
input = sys.stdin.readline

############ ---- Input Functions ---- ############
def inp():
    return list(map(int, input().split()))

############ ---- Main Function ---- ############
def minimum_instability(n, weights):
    weights.sort()  # Sort the weights to minimize the difference
    min_instability = float('inf')

    # Try all possible pairs of single kayaks
    for i in range(2 * n):
        for j in range(i + 1, 2 * n):
            # Form a list of weights excluding the pair (i, j)
            pairs = [weights[k] for k in range(2 * n) if k != i and k != j]
            # Calculate instability for the remaining pairs
            current_instability = 0
            for k in range(0, 2 * n - 2, 2):
                current_instability += abs(pairs[k] - pairs[k + 1])
            # Update minimum instability
            min_instability = min(min_instability, current_instability)

    return min_instability

############ ---- Input Read ---- ############
n = int(input().strip())
weights = inp()

############ ---- Output Result ---- ############
result = minimum_instability(n, weights)
print(result)"
69,A,Young Physicist,PROGRAMMING,"['implementation', 'math']","A guy named Vasya attends the final grade of a high school. One day Vasya decided to watch a match of his favorite hockey team. And, as the boy loves hockey very much, even more than physics, he forgot to do the homework. Specifically, he forgot to complete his physics tasks. Next day the teacher got very angry at Vasya and decided to teach him a lesson. He gave the lazy student a seemingly easy task: You are given an idle body in space and the forces that affect it. The body can be considered as a material point with coordinates (0; 0; 0). Vasya had only to answer whether it is in equilibrium. ""Piece of cake"" — thought Vasya, we need only to check if the sum of all vectors is equal to 0. So, Vasya began to solve the problem. But later it turned out that there can be lots and lots of these forces, and Vasya can not cope without your help. Help him. Write a program that determines whether a body is idle or is moving by the given vectors of forces.","The first line contains a positive integer *n* (1<=≤<=*n*<=≤<=100), then follow *n* lines containing three integers each: the *x**i* coordinate, the *y**i* coordinate and the *z**i* coordinate of the force vector, applied to the body (<=-<=100<=≤<=*x**i*,<=*y**i*,<=*z**i*<=≤<=100).","Print the word ""YES"" if the body is in equilibrium, or the word ""NO"" if it is not.","['3\n4 1 7\n-2 4 -1\n1 -5 -3\n', '3\n3 -1 7\n-5 2 -4\n2 -1 -3\n']","['NO', 'YES']",none,OK,"n = int(input())
xs, ys, zs = 0, 0, 0

for i in range(n):
    l = [int(k) for k in input().split(' ')]
    x, y, z = l[0], l[1], l[2]
    xs, ys, zs = xs+x, ys+y, zs+z

if (xs==0) and (ys==0) and (zs==0):
    print('YES')
else:
    print('NO')
","n = int(input())

def bagi(n):
    i = 1
    candies = []
    total = 0

    while total + i <= n:
        candies.append(i)
        total += i
        i += 1

    # If we have leftover candies, distribute them to the last kid
    if total < n:
        candies[-1] += n - total

    return candies

result = bagi(n)
print(len(result))  # The number of kids
print("" "".join(map(str, result)))  # The distinct integers (number of candies for each kid)"
336,B,Vasily the Bear and Fly,PROGRAMMING,['math'],"One beautiful day Vasily the bear painted 2*m* circles of the same radius *R* on a coordinate plane. Circles with numbers from 1 to *m* had centers at points (2*R*<=-<=*R*,<=0), (4*R*<=-<=*R*,<=0), ..., (2*Rm*<=-<=*R*,<=0), respectively. Circles with numbers from *m*<=+<=1 to 2*m* had centers at points (2*R*<=-<=*R*,<=2*R*), (4*R*<=-<=*R*,<=2*R*), ..., (2*Rm*<=-<=*R*,<=2*R*), respectively. 

Naturally, the bear painted the circles for a simple experiment with a fly. The experiment continued for *m*2 days. Each day of the experiment got its own unique number from 0 to *m*2<=-<=1, inclusive. 

On the day number *i* the following things happened: 
 1.  The fly arrived at the coordinate plane at the center of the circle with number  ( is the result of dividing number *x* by number *y*, rounded down to an integer). 1.  The fly went along the coordinate plane to the center of the circle number  ( is the remainder after dividing number *x* by number *y*). The bear noticed that the fly went from the center of circle *v* to the center of circle *u* along the shortest path with all points lying on the border or inside at least one of the 2*m* circles. After the fly reached the center of circle *u*, it flew away in an unknown direction. 
Help Vasily, count the average distance the fly went along the coordinate plane during each of these *m*2 days.","The first line contains two integers *m*,<=*R* (1<=≤<=*m*<=≤<=105, 1<=≤<=*R*<=≤<=10).",In a single line print a single real number — the answer to the problem. The answer will be considered correct if its absolute or relative error doesn't exceed 10<=-<=6.,"['1 1\n', '2 2\n']","['2.0000000000\n', '5.4142135624\n']","<img class=""tex-graphics"" src=""https://espresso.codeforces.com/9fe384073741e20965ddc4bf162afd3a604b6b39.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

Figure to the second sample",OK,"import math

m,R = map (int,input().split())

D = math.sqrt (2) * R
result = 0

def sum_dist (n):
  return n*(n+1)*R + 2*D*n

for i in range (1,m+1):
  result += 2*R
  if i-1   > 0: result += 2*R + D
  if m-i   > 0: result += 2*R + D
  if i-2   > 0: result += sum_dist (i-2)
  if m-i-1 > 0: result += sum_dist (m-i-1)

print (result / m / m)
","import sys
from collections import defaultdict
sys.setrecursionlimit(100000)
OPEN, CLOSE = '(', ')'

def mistery(data):
    terminated_counter = 0
    counter = 0
    stack = []
    lengths = defaultdict(int)

    # Iterate through characters in the string
    for i, char in enumerate(data):
        if char == OPEN:
            stack.append(i)  # Push index of '(' onto stack
        elif char == CLOSE:
            if stack:  # If there's a matching '('
                start_index = stack.pop()  # Get the index of matching '('
                length = i - start_index + 1  # Calculate the length of the valid sequence
                lengths[length] += 1  # Count this length
                terminated_counter += 1  # Increment terminated sequences counter

    # Find the length of the longest regular bracket sequence
    if lengths:
        longest_length = max(lengths.keys())
        count_of_longest = lengths[longest_length]
    else:
        longest_length = 0
        count_of_longest = 1  # As specified, output ""0 1"" if no valid substrings are found

    return longest_length, count_of_longest

# Read input
if __name__ == ""__main__"":
    input_data = sys.stdin.readline().strip()  # Read the bracket sequence
    result = mistery(input_data)
    print(result[0], result[1])  # Output the result"
427,B,Prison Transfer,PROGRAMMING,"['data structures', 'implementation']","The prison of your city has *n* prisoners. As the prison can't accommodate all of them, the city mayor has decided to transfer *c* of the prisoners to a prison located in another city.

For this reason, he made the *n* prisoners to stand in a line, with a number written on their chests. The number is the severity of the crime he/she has committed. The greater the number, the more severe his/her crime was.

Then, the mayor told you to choose the *c* prisoners, who will be transferred to the other prison. He also imposed two conditions. They are,
 -  The chosen *c* prisoners has to form a contiguous segment of prisoners. -  Any of the chosen prisoner's crime level should not be greater then *t*. Because, that will make the prisoner a severe criminal and the mayor doesn't want to take the risk of his running away during the transfer. 
Find the number of ways you can choose the *c* prisoners.","The first line of input will contain three space separated integers *n* (1<=≤<=*n*<=≤<=2·105), *t* (0<=≤<=*t*<=≤<=109) and *c* (1<=≤<=*c*<=≤<=*n*). The next line will contain *n* space separated integers, the *i**th* integer is the severity *i**th* prisoner's crime. The value of crime severities will be non-negative and will not exceed 109.",Print a single integer — the number of ways you can choose the *c* prisoners.,"['4 3 3\n2 3 1 1\n', '1 1 1\n2\n', '11 4 2\n2 2 0 7 3 2 2 4 9 1 4\n']","['2\n', '0\n', '6\n']",none,OK,"import sys

n, t, c = map(int, input().split())
vec = [-1]

for i, temp in enumerate(map(int, sys.stdin.readline().split())):
    if temp > t:
        vec.append(i)

vec.append(n)
ans = 0

for i in range(1, len(vec)):
    diff = vec[i] - vec[i - 1] - 1
    ans += max(diff - c + 1, 0)

sys.stdout.write(str(ans) + '\n')
","y,x=list(map(int,input().split()))
nums=list(map(int,input().split()))

def func(x,y,nums):
    max_profit = 0  # Initialize maximum profit
    for d in range(1, x):  # Loop through days 1 to n-1
        sell_price = nums[d]  # Price on day d (selling day)
        buy_price = nums[d + 1]  # Price on day d+1 (buying day)
        profit = sell_price - buy_price - y  # Calculate profit
        max_profit = max(max_profit, profit)  # Update maximum profit if current profit is higher

    return max_profit  # Return the maximum profit

print(func(x, y, nums))  # Call the function and print the result"
61,A,Ultra-Fast Mathematician,PROGRAMMING,['implementation'],"Shapur was an extremely gifted student. He was great at everything including Combinatorics, Algebra, Number Theory, Geometry, Calculus, etc. He was not only smart but extraordinarily fast! He could manage to sum 1018 numbers in a single second.

One day in 230 AD Shapur was trying to find out if any one can possibly do calculations faster than him. As a result he made a very great contest and asked every one to come and take part.

In his contest he gave the contestants many different pairs of numbers. Each number is made from digits 0 or 1. The contestants should write a new number corresponding to the given pair of numbers. The rule is simple: The *i*-th digit of the answer is 1 if and only if the *i*-th digit of the two given numbers differ. In the other case the *i*-th digit of the answer is 0.

Shapur made many numbers and first tried his own speed. He saw that he can perform these operations on numbers of length ∞ (length of a number is number of digits in it) in a glance! He always gives correct answers so he expects the contestants to give correct answers, too. He is a good fellow so he won't give anyone very big numbers and he always gives one person numbers of same length.

Now you are going to take part in Shapur's contest. See if you are faster and more accurate.",There are two lines in each input. Each of them contains a single number. It is guaranteed that the numbers are made from 0 and 1 only and that their length is same. The numbers may start with 0. The length of each number doesn't exceed 100.,Write one line — the corresponding answer. Do not omit the leading 0s.,"['1010100\n0100101\n', '000\n111\n', '1110\n1010\n', '01110\n01100\n']","['1110001\n', '111\n', '0100\n', '00010\n']",none,OK,"a=input()
b=input()
res=[]
for i in range(len(a)):
    if a[i]!=b[i]:
        res.append('1')
    else:
        res.append('0')
print(*res,sep='')
        ","n, m = input().split(' ')
n, m = int(n), int(m)
wl = []
for i in range(n):
    wl.append(input().strip())

def bombarded(r, i, j):
    # Create sets to store coordinates of walls in the row and column
    walls_in_row = set()
    walls_in_col = set()

    # Collect walls in the specified row
    for col in range(m):
        if wl[i][col] == '*':
            walls_in_row.add((i, col))

    # Collect walls in the specified column
    for row in range(n):
        if wl[row][j] == '*':
            walls_in_col.add((row, j))

    # Total walls wiped out if bomb is placed at (i, j)
    total_wiped = len(walls_in_row) + len(walls_in_col)

    # If the cell (i, j) itself was a wall, it shouldn't be counted twice
    if wl[i][j] == '*':
        total_wiped -= 1

    return total_wiped

# Total number of walls in the depot
total_walls = sum(row.count('*') for row in wl)

# Iterate through each cell to find a valid bomb placement
for i in range(n):
    for j in range(m):
        if bombarded(wl, i, j) == total_walls:
            print(""YES"")
            print(i + 1, j + 1)  # Output 1-based indices
            exit()

print(""NO"")"
258,A,Little Elephant and Bits,PROGRAMMING,"['greedy', 'math']","The Little Elephant has an integer *a*, written in the binary notation. He wants to write this number on a piece of paper.

To make sure that the number *a* fits on the piece of paper, the Little Elephant ought to delete exactly one any digit from number *a* in the binary record. At that a new number appears. It consists of the remaining binary digits, written in the corresponding order (possible, with leading zeroes).

The Little Elephant wants the number he is going to write on the paper to be as large as possible. Help him find the maximum number that he can obtain after deleting exactly one binary digit and print it in the binary notation.","The single line contains integer *a*, written in the binary notation without leading zeroes. This number contains more than 1 and at most 105 digits.",In the single line print the number that is written without leading zeroes in the binary notation — the answer to the problem.,"['101\n', '110010\n']","['11\n', '11010\n']","In the first sample the best strategy is to delete the second digit. That results in number 11<sub class=""lower-index"">2</sub> = 3<sub class=""lower-index"">10</sub>.

In the second sample the best strategy is to delete the third or fourth digits — that results in number 11010<sub class=""lower-index"">2</sub> = 26<sub class=""lower-index"">10</sub>.",OK,"s = input() 
for idx in range(len(s)):
    if s[idx] == ""0"":
        break
print(s[:idx]+s[idx+1:])","n = int(input())

def isLucky(num):
    # A lucky number consists only of the digits 4 and 7
    while num > 0:
        digit = num % 10
        if digit != 4 and digit != 7:
            return False
        num //= 10
    return True

# Check for all lucky numbers up to n
for lucky_num in range(4, n + 1):
    if isLucky(lucky_num) and n % lucky_num == 0:
        print(""YES"")
        break
else:
    print(""NO"")"
981,C,Useful Decomposition,PROGRAMMING,"['implementation', 'trees']","Ramesses knows a lot about problems involving trees (undirected connected graphs without cycles)!

He created a new useful tree decomposition, but he does not know how to construct it, so he asked you for help!

The decomposition is the splitting the edges of the tree in some simple paths in such a way that each two paths have at least one common vertex. Each edge of the tree should be in exactly one path.

Help Remesses, find such a decomposition of the tree or derermine that there is no such decomposition.","The first line contains a single integer $n$ ($2 \leq n \leq 10^{5}$) the number of nodes in the tree.

Each of the next $n<=-<=1$ lines contains two integers $a_i$ and $b_i$ ($1 \leq a_i, b_i \leq n$, $a_i \neq b_i$) — the edges of the tree. It is guaranteed that the given edges form a tree.","If there are no decompositions, print the only line containing ""No"".

Otherwise in the first line print ""Yes"", and in the second line print the number of paths in the decomposition $m$. 

Each of the next $m$ lines should contain two integers $u_i$, $v_i$ ($1 \leq u_i, v_i \leq n$, $u_i \neq v_i$) denoting that one of the paths in the decomposition is the simple path between nodes $u_i$ and $v_i$. 

Each pair of paths in the decomposition should have at least one common vertex, and each edge of the tree should be presented in exactly one path. You can print the paths and the ends of each path in arbitrary order.

If there are multiple decompositions, print any.","['4\n1 2\n2 3\n3 4\n', '6\n1 2\n2 3\n3 4\n2 5\n3 6\n', '5\n1 2\n1 3\n1 4\n1 5\n']","['Yes\n1\n1 4\n', 'No\n', 'Yes\n4\n1 2\n1 3\n1 4\n1 5\n']","The tree from the first example is shown on the picture below: <img class=""tex-graphics"" src=""https://espresso.codeforces.com/9eb4b4c143d3ad267ae05d1e43341bd368b3088b.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> The number next to each edge corresponds to the path number in the decomposition. It is easy to see that this decomposition suits the required conditions.

The tree from the second example is shown on the picture below: <img class=""tex-graphics"" src=""https://espresso.codeforces.com/20704b97182d9bcde3321c00a16edcae4d772d93.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> We can show that there are no valid decompositions of this tree.

The tree from the third example is shown on the picture below: <img class=""tex-graphics"" src=""https://espresso.codeforces.com/357ff9496a4ed4746401160ee6ee63f5d57d81b9.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> The number next to each edge corresponds to the path number in the decomposition. It is easy to see that this decomposition suits the required conditions.",RUNTIME_ERROR,"#!/usr/bin/env python
# -*- coding: utf-8 -*-

def local_input():
    from pcm.utils import set_stdin
    import sys
    if len(sys.argv) == 1:
        set_stdin(os.path.dirname(__file__) + '/test/' + 'sample-1.in')


import sys
import os
from sys import stdin, stdout
import time
import re
from pydoc import help
import string
import math
import numpy as np
from operator import itemgetter
from collections import Counter
from collections import deque
from collections import defaultdict as dd
import fractions
from heapq import heappop, heappush, heapify
import array
from bisect import bisect_left, bisect_right, insort_left, insort_right
from copy import deepcopy as dcopy
import itertools
sys.setrecursionlimit(10**7)
INF = 10**20
GOSA = 1.0 / 10**10
MOD = 10**9+7
ALPHABETS = [chr(i) for i in range(ord('a'), ord('z')+1)]  # can also use string module
def LI(): return [int(x) for x in sys.stdin.readline().split()]
def LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]
def LF(): return [float(x) for x in sys.stdin.readline().split()]
def LS(): return sys.stdin.readline().split()
def I(): return int(sys.stdin.readline())
def F(): return float(sys.stdin.readline())
def DP(N, M, first): return [[first] * M for n in range(N)]
def DP3(N, M, L, first): return [[[first] * L for n in range(M)] for _ in range(N)]


def solve():
    global T, N, g
    N = int(input())

    T = [[] for _ in range(N)]
    for n in range(N-1):
        a, b = map(lambda x:int(x)-1, input().split())
        T[a].append(b)
        T[b].append(a)

    # print(T)

    g = -1
    for n, t in enumerate(T):
        if len(t) >= 3 and g==-1:
            g = n
        elif len(t) >= 3 and g!=-1:
            print(""No"")
            return

    if g == -1:
        print(""Yes"")
        print(""1"")
        res = []
        for n, t in enumerate(T):
            if len(t) == 1:
                res.append(n+1)
        print(*res)
        return

    print(""Yes"")
    print(len(T[g]))
    res = """"
    for n in T[g]:
        res += str(g+1)+"" ""+str(get_tip(n)+1)+""\n""
    stdout.write(res)

def get_tip(n):
    R = [0]*N
    R[g] = 1
    now = n
    while True:
        if len(T[now]) == 1:
            return now
        if R[T[now][0]] == 0:
            R[now] = 1
            now = T[now][0]
        elif R[T[now][1]] == 0:
            R[now] = 1
            now = T[now][1]

if __name__ == ""__main__"":
    try:
        local_input()
    except:
        pass
    solve()

","def dfs(left, state, k, d):
    if state and left == 0:
        return 1
    sam = 0
    i = 1
    while i <= k and i <= left:
        # If using current edge weight i, decrease the remaining left by i
        sam += dfs(left - i, (state or (i >= d)), k, d)
        sam %= 1000000007  # Take modulo to prevent overflow
        i += 1
    return sam

def count_ways(n, k, d):
    # Initialize a memoization table
    memo = [[-1] * 2 for _ in range(n + 1)]
    
    def dfs_memo(left, state):
        # Return cached result if available
        if memo[left][state] != -1:
            return memo[left][state]
        
        # Calculate the number of ways using dfs
        memo[left][state] = dfs(left, state, k, d)
        return memo[left][state]

    return dfs_memo(n, 0)  # Start the dfs with n and initial state 0

# Read input
n, k, d = map(int, input().split())
# Print the number of ways modulo 1000000007
print(count_ways(n, k, d))"
469,A,I Wanna Be the Guy,PROGRAMMING,"['greedy', 'implementation']","There is a game called ""I Wanna Be the Guy"", consisting of *n* levels. Little X and his friend Little Y are addicted to the game. Each of them wants to pass the whole game.

Little X can pass only *p* levels of the game. And Little Y can pass only *q* levels of the game. You are given the indices of levels Little X can pass and the indices of levels Little Y can pass. Will Little X and Little Y pass the whole game, if they cooperate each other?","The first line contains a single integer *n* (1<=≤<=<=*n*<=≤<=100). 

The next line contains an integer *p* (0<=≤<=*p*<=≤<=*n*) at first, then follows *p* distinct integers *a*1,<=*a*2,<=...,<=*a**p* (1<=≤<=*a**i*<=≤<=*n*). These integers denote the indices of levels Little X can pass. The next line contains the levels Little Y can pass in the same format. It's assumed that levels are numbered from 1 to *n*.","If they can pass all the levels, print ""I become the guy."". If it's impossible, print ""Oh, my keyboard!"" (without the quotes).","['4\n3 1 2 3\n2 2 4\n', '4\n3 1 2 3\n2 2 3\n']","['I become the guy.\n', 'Oh, my keyboard!\n']","In the first sample, Little X can pass levels [1 2 3], and Little Y can pass level [2 4], so they can pass all the levels both.

In the second sample, no one can pass level 4.",WRONG_ANSWER,"#469A - I Wanna Be the Guy
n = int(input())
p = list(map(int, input().split()))
q = list(map(int, input().split()))
lvls = []
for ele in p:
  lvls.append(ele)
for ele in q:
  lvls.append(ele)
lvls = set(lvls)
if len(lvls) == 4: print(""I become the guy"")
else: print(""Oh, my keyboard!"")
","def should_build_second_oven(n, t, k, d):
    # Calculate the time needed with a single oven
    single_oven_time = (n + k - 1) // k * t
    
    # Calculate the time needed with two ovens
    # If the time to build the second oven is more than the time needed with one oven, return ""NO""
    if d >= single_oven_time:
        return ""NO""
    
    # Calculate the time until the new oven is built and how many cakes can be baked in that time
    cakes_baked_while_building = (d // t) * k
    remaining_cakes = max(0, n - cakes_baked_while_building)

    # Calculate the baking time required after the new oven is built
    double_oven_time = d + (remaining_cakes + 2 * k - 1) // (2 * k) * t
    
    # Compare the times and determine if building the second oven is reasonable
    return ""YES"" if double_oven_time < single_oven_time else ""NO""

# Example usage
print(should_build_second_oven(8, 12, 4, 5))  # Output: YES
print(should_build_second_oven(8, 12, 4, 12)) # Output: NO
print(should_build_second_oven(10, 3, 11, 5)) # Output: NO"
468,C,Hack it!,PROGRAMMING,"['binary search', 'constructive algorithms', 'math']","Little X has met the following problem recently. 

Let's define *f*(*x*) as the sum of digits in decimal representation of number *x* (for example, *f*(1234)<==<=1<=+<=2<=+<=3<=+<=4). You are to calculate 

Of course Little X has solved this problem quickly, has locked it, and then has tried to hack others. He has seen the following C++ code:",The first line contains a single integer *a* (1<=≤<=*a*<=≤<=1018).,"Print two integers: *l*,<=*r* (1<=≤<=*l*<=≤<=*r*<=&lt;<=10200) — the required test data. Leading zeros aren't allowed. It's guaranteed that the solution exists.","['46\n', '126444381000032\n']","['1 10\n', '2333333 2333333333333\n']",none,OK,"a=int(input())
x=a-((10**20)*45*21+1)%a
print(1+x,10**21+x)","def count_binary_numbers(n):
    count = 0
    # Iterate through each number from 1 to n
    for i in range(1, n + 1):
        # Convert number to binary and check if it contains only '0's and '1's
        if all(c in '01' for c in bin(i)[2:]):
            count += 1
    return count

# Read input
n = int(input())
# Get the result
result = count_binary_numbers(n)
# Print the result
print(result)"
534,B,Covered Path,PROGRAMMING,"['dp', 'greedy', 'math']","The on-board computer on Polycarp's car measured that the car speed at the beginning of some section of the path equals *v*1 meters per second, and in the end it is *v*2 meters per second. We know that this section of the route took exactly *t* seconds to pass.

Assuming that at each of the seconds the speed is constant, and between seconds the speed can change at most by *d* meters per second in absolute value (i.e., the difference in the speed of any two adjacent seconds does not exceed *d* in absolute value), find the maximum possible length of the path section in meters.","The first line contains two integers *v*1 and *v*2 (1<=≤<=*v*1,<=*v*2<=≤<=100) — the speeds in meters per second at the beginning of the segment and at the end of the segment, respectively.

The second line contains two integers *t* (2<=≤<=*t*<=≤<=100) — the time when the car moves along the segment in seconds, *d* (0<=≤<=*d*<=≤<=10) — the maximum value of the speed change between adjacent seconds.

It is guaranteed that there is a way to complete the segment so that:
 -  the speed in the first second equals *v*1, -  the speed in the last second equals *v*2, -  the absolute value of difference of speeds between any two adjacent seconds doesn't exceed *d*.",Print the maximum possible length of the path segment in meters.,"['5 6\n4 2\n', '10 10\n10 0\n']","['26', '100']","In the first sample the sequence of speeds of Polycarpus' car can look as follows: 5, 7, 8, 6. Thus, the total path is 5 + 7 + 8 + 6 = 26 meters.

In the second sample, as *d* = 0, the car covers the whole segment at constant speed *v* = 10. In *t* = 10 seconds it covers the distance of 100 meters.",WRONG_ANSWER,"


v1, v2 = map(int,input().split())

t,d = map(int,input().split())



if v1 > v2:


    p=0
    l= v1


    for k in range(t):

        if k==0:
            p+=v1
        elif k==t-1:
            p+=v2

        else:

            if  l > v2+d:
                l-=d

            p+=l

    print(p)
elif v2 >v1:

    p=0
    l= v1


    for k in range(t):

        if k==0:
            p+=v1
        elif k==t-1:
            p+=v2
        else:

            if  l < v2+d:
                l+=d

            p+=l
else:
    print(v1+v2 + (v1+d)*(t-2))

    
","# https://codeforces.com/problemset/problem/339/B

n, m = [int(x) for x in input().split()]
tasks = [int(x) for x in input().split()]

time = 0
current_position = 1

for task in tasks:
    if task >= current_position:
        time += task - current_position
    else:
        time += (n - current_position) + task
    current_position = task

print(time)"
71,A,Way Too Long Words,PROGRAMMING,['strings'],"Sometimes some words like ""localization"" or ""internationalization"" are so long that writing them many times in one text is quite tiresome.

Let's consider a word too long, if its length is strictly more than 10 characters. All too long words should be replaced with a special abbreviation.

This abbreviation is made like this: we write down the first and the last letter of a word and between them we write the number of letters between the first and the last letters. That number is in decimal system and doesn't contain any leading zeroes.

Thus, ""localization"" will be spelt as ""l10n"", and ""internationalization» will be spelt as ""i18n"".

You are suggested to automatize the process of changing the words with abbreviations. At that all too long words should be replaced by the abbreviation and the words that are not too long should not undergo any changes.",The first line contains an integer *n* (1<=≤<=*n*<=≤<=100). Each of the following *n* lines contains one word. All the words consist of lowercase Latin letters and possess the lengths of from 1 to 100 characters.,Print *n* lines. The *i*-th line should contain the result of replacing of the *i*-th word from the input data.,['4\nword\nlocalization\ninternationalization\npneumonoultramicroscopicsilicovolcanoconiosis\n'],['word\nl10n\ni18n\np43s\n'],none,OK,"def way_too_long_words(txt_arr):
    res = []
    for input_txt in txt_arr:
        n = len(input_txt)
        if n <= 10:
            res.append(input_txt)
        else:
            res.append(input_txt[0] + str(n-2) + input_txt[-1])
    return res

if __name__ == ""__main__"":
    n = int(input())
    txt_arr = []
    for _ in range(n):
        txt_arr.append(input())
    res_arr = way_too_long_words(txt_arr)
    for res in res_arr:
        print(res)","def failurefunc(s):
    ls = len(s)
    F = [0] * ls
    i = 1
    j = 0
    while i < ls:
        # If characters match, move both pointers forward
        if s[i] == s[j]:
            j += 1
            F[i] = j
            i += 1
        else:
            # If characters do not match, move j back to F[j-1] (previous longest prefix)
            if j > 0:
                j = F[j - 1]
            else:
                F[i] = 0
                i += 1
    return F

def find_substring(s):
    F = failurefunc(s)
    ls = len(s)
    
    # The length of the longest prefix which is also a suffix
    length = F[-1]
    
    # Check if there exists a non-empty substring that can satisfy all conditions
    while length > 0:
        # Check if the prefix or suffix of this length exists in the middle of s
        if s[:length] in s[1:-1]:
            return s[:length]
        length = F[length - 1]

    return ""Just a legend""

# Example usage
s = input().strip()
print(find_substring(s))"
373,A,Collecting Beats is Fun,PROGRAMMING,['implementation'],"Cucumber boy is fan of Kyubeat, a famous music game.

Kyubeat has 16 panels for playing arranged in 4<=×<=4 table. When a panel lights up, he has to press that panel.

Each panel has a timing to press (the preffered time when a player should press it), and Cucumber boy is able to press at most *k* panels in a time with his one hand. Cucumber boy is trying to press all panels in perfect timing, that is he wants to press each panel exactly in its preffered time. If he cannot press the panels with his two hands in perfect timing, his challenge to press all the panels in perfect timing will fail.

You are given one scene of Kyubeat's panel from the music Cucumber boy is trying. Tell him is he able to press all the panels in perfect timing.","The first line contains a single integer *k* (1<=≤<=*k*<=≤<=5) — the number of panels Cucumber boy can press with his one hand.

Next 4 lines contain 4 characters each (digits from 1 to 9, or period) — table of panels. If a digit *i* was written on the panel, it means the boy has to press that panel in time *i*. If period was written on the panel, he doesn't have to press that panel.","Output ""YES"" (without quotes), if he is able to press all the panels in perfect timing. If not, output ""NO"" (without quotes).","['1\n.135\n1247\n3468\n5789\n', '5\n..1.\n1111\n..1.\n..1.\n', '1\n....\n12.1\n.2..\n.2..\n']","['YES\n', 'YES\n', 'NO\n']","In the third sample boy cannot press all panels in perfect timing. He can press all the panels in timing in time 1, but he cannot press the panels in time 2 in timing with his two hands.",WRONG_ANSWER,"from collections import Counter
k=int(input())
string=""""
string+=input()
string+=input()
string+=input()
string+=input()
string=list(string)
string.remove('.')
string=Counter(string)
count=string.most_common(1)
cnt=count[0][1]
if cnt<=2*k:
    print(""YES"")
else:
    print(""NO"")","from sys import stdin, stdout

INF = int(1e9)

class Point:
    def __init__(self, x=0, y=0):
        self.x = x
        self.y = y

def f(i, j):
    # Function f computes (j - i) ^ 2 + g(i, j)
    return (j - i) ** 2 + g(i, j)

def g(i, j):
    # Function g calculates the sum of the array from i to j
    return sum(a[i-1:j])  # Convert to 0-based index

def find_min_f(n):
    min_value = INF
    for i in range(1, n + 1):
        for j in range(i + 1, n + 1):
            value = f(i, j)
            min_value = min(min_value, value)
    return min_value

# Reading input
n = int(stdin.readline().strip())
a = list(map(int, stdin.readline().strip().split()))

# Calculating the result
result = find_min_f(n)

# Output the result
stdout.write(str(result) + '\n')"
6,C,"Alice, Bob and Chocolate",PROGRAMMING,"['greedy', 'two pointers']","Alice and Bob like games. And now they are ready to start a new game. They have placed *n* chocolate bars in a line. Alice starts to eat chocolate bars one by one from left to right, and Bob — from right to left. For each chocololate bar the time, needed for the player to consume it, is known (Alice and Bob eat them with equal speed). When the player consumes a chocolate bar, he immediately starts with another. It is not allowed to eat two chocolate bars at the same time, to leave the bar unfinished and to make pauses. If both players start to eat the same bar simultaneously, Bob leaves it to Alice as a true gentleman.

How many bars each of the players will consume?","The first line contains one integer *n* (1<=≤<=*n*<=≤<=105) — the amount of bars on the table. The second line contains a sequence *t*1,<=*t*2,<=...,<=*t**n* (1<=≤<=*t**i*<=≤<=1000), where *t**i* is the time (in seconds) needed to consume the *i*-th bar (in the order from left to right).","Print two numbers *a* and *b*, where *a* is the amount of bars consumed by Alice, and *b* is the amount of bars consumed by Bob.",['5\n2 9 8 2 7\n'],['2 3\n'],none,WRONG_ANSWER,"
# Alice_Bob_and_chocolate


n = int(input());
A = list(map(int , input().split()))

#Alice
i = 0; ai =0;
#Bob
j = len(A)-1; bj =0 ;
#
ki=-1; kj=-1;

while(i<j):
    
    if i == j:
        i +=1;
        break;
    
    if i!=ki:
        ai +=A[i];
    if j!=kj:
        bj += A[j];
        
    if ai<=bj:
        i +=1;
        kj = j;
    if bj<ai:
        j -=1;
        ki = i;
         
print(i,len(A)-j);


            
","def max_dist(n, a):
    minpos = a.index(min(a))  # Get the index of the minimum element (1)
    maxpos = a.index(max(a))  # Get the index of the maximum element (n)
    if minpos < maxpos:
        ldist = minpos  # Distance from the start to minpos
        rdist = n - 1 - maxpos  # Distance from maxpos to the end
    else:
        ldist = n - 1 - minpos  # Distance from minpos to the end
        rdist = maxpos  # Distance from the start to maxpos

    # The maximum possible distance after one swap
    max_distance = max(ldist + (n - 1 - maxpos), rdist + minpos)
    return max_distance

# Example usage
n = int(input())
a = list(map(int, input().split()))
print(max_dist(n, a))"
962,A,Equator,PROGRAMMING,['implementation'],"Polycarp has created his own training plan to prepare for the programming contests. He will train for $n$ days, all days are numbered from $1$ to $n$, beginning from the first.

On the $i$-th day Polycarp will necessarily solve $a_i$ problems. One evening Polycarp plans to celebrate the equator. He will celebrate it on the first evening of such a day that from the beginning of the training and to this day inclusive he will solve half or more of all the problems.

Determine the index of day when Polycarp will celebrate the equator.","The first line contains a single integer $n$ ($1 \le n \le 200\,000$) — the number of days to prepare for the programming contests.

The second line contains a sequence $a_1, a_2, \dots, a_n$ ($1 \le a_i \le 10\,000$), where $a_i$ equals to the number of problems, which Polycarp will solve on the $i$-th day.",Print the index of the day when Polycarp will celebrate the equator.,"['4\n1 3 2 1\n', '6\n2 2 2 2 2 2\n']","['2\n', '3\n']","In the first example Polycarp will celebrate the equator on the evening of the second day, because up to this day (inclusive) he will solve $4$ out of $7$ scheduled problems on four days of the training.

In the second example Polycarp will celebrate the equator on the evening of the third day, because up to this day (inclusive) he will solve $6$ out of $12$ scheduled problems on six days of the training.",OK,"
#k=int(input())
#n,m=map(int,input().split())
import sys


#a=list(map(int,input().split()))

#b=list(map(int,input().split()))
import math


n=int(input())

a=list(map(int,input().split()))
ss=sum(a);

s=0
for i in range(n):
    s+=a[i]

    if(2*s>=ss):
        print(i+1)
        sys.exit()
","def is_berlanese(word):
    vowels = ""aeiou""
    length = len(word)

    for i in range(length):
        if word[i] not in vowels:  # Check if it's a consonant
            if word[i] != 'n':  # If it's not 'n'
                if i + 1 >= length or word[i + 1] not in vowels:  # Check next character
                    return ""NO""  # Return ""NO"" if there's no vowel after consonant
    return ""YES""  # All rules satisfied

# Read input
s = input().strip()

# Check if the word is Berlanese and print the result
print(is_berlanese(s))"
1003,D,Coins and Queries,PROGRAMMING,['greedy'],"Polycarp has $n$ coins, the value of the $i$-th coin is $a_i$. It is guaranteed that all the values are integer powers of $2$ (i.e. $a_i = 2^d$ for some non-negative integer number $d$).

Polycarp wants to know answers on $q$ queries. The $j$-th query is described as integer number $b_j$. The answer to the query is the minimum number of coins that is necessary to obtain the value $b_j$ using some subset of coins (Polycarp can use only coins he has). If Polycarp can't obtain the value $b_j$, the answer to the $j$-th query is -1.

The queries are independent (the answer on the query doesn't affect Polycarp's coins).","The first line of the input contains two integers $n$ and $q$ ($1 \le n, q \le 2 \cdot 10^5$) — the number of coins and the number of queries.

The second line of the input contains $n$ integers $a_1, a_2, \dots, a_n$ — values of coins ($1 \le a_i \le 2 \cdot 10^9$). It is guaranteed that all $a_i$ are integer powers of $2$ (i.e. $a_i = 2^d$ for some non-negative integer number $d$).

The next $q$ lines contain one integer each. The $j$-th line contains one integer $b_j$ — the value of the $j$-th query ($1 \le b_j \le 10^9$).",Print $q$ integers $ans_j$. The $j$-th integer must be equal to the answer on the $j$-th query. If Polycarp can't obtain the value $b_j$ the answer to the $j$-th query is -1.,['5 4\n2 4 8 2 4\n8\n5\n14\n10\n'],['1\n-1\n3\n2\n'],none,RUNTIME_ERROR,"def main():
	n, q = map(int, input().split())
	a = [*map(int, input().split())]
	d = {}
	for i in range(n):
		d[a[i]] = d.get(a[i], 0) + 1
	for i in range(q):
		x = int(input())
		c = 0
		for j in reversed(d.keys()):
			y = min(d[j], x // j)
			c += y
			x -= y * j
		if x:
			print(-1)
		else:
			print(c)
if __name__ == '__main__':
    main()
","# Function to calculate combinations of 2 from x
def nc2(x):
    return x * (x - 1) // 2

# Main solution function
def solve():
    n, m = map(int, input().split())
    # Maximum pairs of friends (all in one team)
    mx = nc2(n)
    # Minimum pairs of friends (evenly distributed teams)
    mn = (n % m) * nc2(n // m + 1) + (m - n % m) * nc2(n // m)
    print(mn, mx)

# Call the solve function
solve()"
608,A,Saitama Destroys Hotel,PROGRAMMING,"['implementation', 'math']","Saitama accidentally destroyed a hotel again. To repay the hotel company, Genos has volunteered to operate an elevator in one of its other hotels. The elevator is special — it starts on the top floor, can only move down, and has infinite capacity. Floors are numbered from 0 to *s* and elevator initially starts on floor *s* at time 0.

The elevator takes exactly 1 second to move down exactly 1 floor and negligible time to pick up passengers. Genos is given a list detailing when and on which floor passengers arrive. Please determine how long in seconds it will take Genos to bring all passengers to floor 0.","The first line of input contains two integers *n* and *s* (1<=≤<=*n*<=≤<=100, 1<=≤<=*s*<=≤<=1000) — the number of passengers and the number of the top floor respectively.

The next *n* lines each contain two space-separated integers *f**i* and *t**i* (1<=≤<=*f**i*<=≤<=*s*, 1<=≤<=*t**i*<=≤<=1000) — the floor and the time of arrival in seconds for the passenger number *i*.",Print a single integer — the minimum amount of time in seconds needed to bring all the passengers to floor 0.,"['3 7\n2 1\n3 8\n5 2\n', '5 10\n2 77\n3 33\n8 21\n9 12\n10 64\n']","['11\n', '79\n']","In the first sample, it takes at least 11 seconds to bring all passengers to floor 0. Here is how this could be done:

1. Move to floor 5: takes 2 seconds.

2. Pick up passenger 3.

3. Move to floor 3: takes 2 seconds.

4. Wait for passenger 2 to arrive: takes 4 seconds.

5. Pick up passenger 2.

6. Go to floor 2: takes 1 second.

7. Pick up passenger 1.

8. Go to floor 0: takes 2 seconds.

This gives a total of 2 + 2 + 4 + 1 + 2 = 11 seconds.",WRONG_ANSWER,"string = input()
numbers = string.split()
a, b, floors, times = int(numbers[0]), int(numbers[1]), [], []
for x in range(a):
    string = input()
    numbers = string.split()
    floors.append(int(numbers[0]))
    times.append(int(numbers[1]))
floors, times = floors[::-1], times[::-1]
n = 0
for x in range(a):
    n += a - floors[x]
    a = floors[x]
    if times[x] > n:
        n = times[x]
n += a
print(n)","def minimum_length_after_operations(n, s):
    # Count the number of 0s and 1s in the string
    count_0 = s.count('0')
    count_1 = s.count('1')
    
    # The minimum length is the absolute difference between the counts of 0s and 1s
    min_length = abs(count_0 - count_1)
    
    return min_length

# Input reading
n = int(input().strip())
s = input().strip()

# Calculate the result
result = minimum_length_after_operations(n, s)

# Print the result
print(result)"
937,B,Vile Grasshoppers,PROGRAMMING,"['brute force', 'math', 'number theory']","The weather is fine today and hence it's high time to climb the nearby pine and enjoy the landscape.

The pine's trunk includes several branches, located one above another and numbered from 2 to *y*. Some of them (more precise, from 2 to *p*) are occupied by tiny vile grasshoppers which you're at war with. These grasshoppers are known for their awesome jumping skills: the grasshopper at branch *x* can jump to branches .

Keeping this in mind, you wisely decided to choose such a branch that none of the grasshoppers could interrupt you. At the same time you wanna settle as high as possible since the view from up there is simply breathtaking.

In other words, your goal is to find the highest branch that cannot be reached by any of the grasshoppers or report that it's impossible.",The only line contains two integers *p* and *y* (2<=≤<=*p*<=≤<=*y*<=≤<=109).,"Output the number of the highest suitable branch. If there are none, print -1 instead.","['3 6\n', '3 4\n']","['5\n', '-1\n']","In the first sample case grasshopper from branch 2 reaches branches 2, 4 and 6 while branch 3 is initially settled by another grasshopper. Therefore the answer is 5.

It immediately follows that there are no valid branches in second sample case.",RUNTIME_ERROR,"p, y = (int(x) for x in input().split())
a = [1] * y
for i in range(2,p + 1):
    j = 2
    while True:
        if j * i > y - 1:
            break
        else:
            a[j*i] = 0
        j += 1
a.pop(0)
a.pop(0)
flag = 0 in a
if flag:
    a.reverse()
    index = a.index(0)
    a.reverse()
    print(y - index)
else:
    print(-1)






","def min_shuffles(n, s, t, p):
    # Adjusting for 0-based indexing
    s -= 1
    t -= 1

    # If the initial and final positions are the same
    if s == t:
        return 0

    # To keep track of visited positions
    visited = [False] * n
    visited[s] = True
    queue = [(s, 0)]  # (current position, number of moves)

    while queue:
        current_pos, moves = queue.pop(0)

        # Get the new position after shuffling
        new_pos = p[current_pos] - 1  # Adjusting for 0-based indexing

        # If we reach the target position
        if new_pos == t:
            return moves + 1

        # If not visited, add to queue
        if not visited[new_pos]:
            visited[new_pos] = True
            queue.append((new_pos, moves + 1))

    # If we've exhausted all options and didn't reach the target
    return -1

# Reading input
n, s, t = map(int, input().split())
p = list(map(int, input().split()))

# Print the result
print(min_shuffles(n, s, t, p))"
796,A,Buying A House,PROGRAMMING,"['brute force', 'implementation']","Zane the wizard had never loved anyone before, until he fell in love with a girl, whose name remains unknown to us.

The girl lives in house *m* of a village. There are *n* houses in that village, lining in a straight line from left to right: house 1, house 2, ..., house *n*. The village is also well-structured: house *i* and house *i*<=+<=1 (1<=≤<=*i*<=&lt;<=*n*) are exactly 10 meters away. In this village, some houses are occupied, and some are not. Indeed, unoccupied houses can be purchased.

You will be given *n* integers *a*1,<=*a*2,<=...,<=*a**n* that denote the availability and the prices of the houses. If house *i* is occupied, and therefore cannot be bought, then *a**i* equals 0. Otherwise, house *i* can be bought, and *a**i* represents the money required to buy it, in dollars.

As Zane has only *k* dollars to spare, it becomes a challenge for him to choose the house to purchase, so that he could live as near as possible to his crush. Help Zane determine the minimum distance from his crush's house to some house he can afford, to help him succeed in his love.","The first line contains three integers *n*, *m*, and *k* (2<=≤<=*n*<=≤<=100, 1<=≤<=*m*<=≤<=*n*, 1<=≤<=*k*<=≤<=100) — the number of houses in the village, the house where the girl lives, and the amount of money Zane has (in dollars), respectively.

The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (0<=≤<=*a**i*<=≤<=100) — denoting the availability and the prices of the houses.

It is guaranteed that *a**m*<==<=0 and that it is possible to purchase some house with no more than *k* dollars.","Print one integer — the minimum distance, in meters, from the house where the girl Zane likes lives to the house Zane can buy.","['5 1 20\n0 27 32 21 19\n', '7 3 50\n62 0 0 0 99 33 22\n', '10 5 100\n1 0 1 0 0 0 0 0 1 1\n']","['40', '30', '20']","In the first sample, with *k* = 20 dollars, Zane can buy only house 5. The distance from house *m* = 1 to house 5 is 10 + 10 + 10 + 10 = 40 meters.

In the second sample, Zane can buy houses 6 and 7. It is better to buy house 6 than house 7, since house *m* = 3 and house 6 are only 30 meters away, while house *m* = 3 and house 7 are 40 meters away.",OK,"n,m,k=map(int,input().split())
m-=1
l=[int(x) for x in input().split()]
q=[]
for i in range(n):
    if l[i]!=0 and l[i]<=k:
        q.append((abs(i-m))*10)
print(min(q))
    
","n, m = map(int, input().split())

# The maximum number of billiard balls that do not beat each other
# is determined by the parity of the number of rows (n) and columns (m).

# Calculate the minimum of the two dimensions
min_dim = min(n, m)

# If both dimensions are even, we can place half on each color in a checkerboard pattern
if min_dim % 2 == 0:
    max_balls = (min_dim // 2) * (min_dim // 2)
else:
    # If one dimension is odd, place the maximum possible combination
    max_balls = (min_dim // 2 + 1) * (min_dim // 2)

print(max_balls)"
299,A,Ksusha and Array,PROGRAMMING,"['brute force', 'number theory', 'sortings']","Ksusha is a beginner coder. Today she starts studying arrays. She has array *a*1,<=*a*2,<=...,<=*a**n*, consisting of *n* positive integers.

Her university teacher gave her a task. Find such number in the array, that all array elements are divisible by it. Help her and find the number!","The first line contains integer *n* (1<=≤<=*n*<=≤<=105), showing how many numbers the array has. The next line contains integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=109) — the array elements.","Print a single integer — the number from the array, such that all array elements are divisible by it. If such number doesn't exist, print -1.

If there are multiple answers, you are allowed to print any of them.","['3\n2 2 4\n', '5\n2 1 3 1 6\n', '3\n2 3 5\n']","['2\n', '1\n', '-1\n']",none,WRONG_ANSWER,"n = input()
li = input().split()
m = int(min(li))
for item in li:
    if int(item) % m != 0:
        m=-1
        break;
print (m)","def main():
    n, m = map(int, input().split())
    if n % 2 == 1:
        # If n is odd, we cannot find three distinct even numbers
        print(-1)
        return

    # We need at least three distinct numbers in the range [n, m]
    if m - n < 2:
        print(-1)
        return
    
    # Finding three distinct even numbers
    a = n
    b = n + 2
    c = n + 4

    # Check if all are within bounds
    if c > m:
        print(-1)
        return

    # Print the counterexample: (a, b, c)
    print(a, b, c)

main()"
26,B,Regular Bracket Sequence,PROGRAMMING,['greedy'],"A bracket sequence is called regular if it is possible to obtain correct arithmetic expression by inserting characters «+» and «1» into this sequence. For example, sequences «(())()», «()» and «(()(()))» are regular, while «)(», «(()» and «(()))(» are not.

One day Johnny got bracket sequence. He decided to remove some of the brackets from it in order to obtain a regular bracket sequence. What is the maximum length of a regular bracket sequence which can be obtained?",Input consists of a single line with non-empty string of «(» and «)» characters. Its length does not exceed 106.,Output the maximum possible length of a regular bracket sequence.,"['(()))(\n', '((()())\n']","['4\n', '6\n']",none,WRONG_ANSWER,"s = str(input())
l = []
lo = []

for i in s:
    l.append(i)

if l[-1] == ""("":
    l.pop()

for i in l:
    if i == ""("":
        lo.append(i)

c = 0
for i in l:
    if i == "")"" and len(lo) > 0:
        c+=2
        lo.pop()



print(c)
","def countVowel(s):
    res = 0
    vowels = ""aeiou""
    for i in s:
        if i in vowels:  # Check if the character is a vowel
            res += 1    # Increment the count for each vowel
    return res

# Read three lines of input
line1 = input().strip()  # First phrase
line2 = input().strip()  # Second phrase
line3 = input().strip()  # Third phrase

# Count the number of vowels (syllables) in each line
syllables = [countVowel(line1), countVowel(line2), countVowel(line3)]

# Check if the syllable counts match the haiku structure
if syllables == [5, 7, 5]:
    print(""YES"")  # The poem is a haiku
else:
    print(""NO"")   # The poem is not a haiku"
75,A,Life Without Zeros,PROGRAMMING,['implementation'],"Can you imagine our life if we removed all zeros from it? For sure we will have many problems.

In this problem we will have a simple example if we removed all zeros from our life, it's the addition operation. Let's assume you are given this equation *a*<=+<=*b*<==<=*c*, where *a* and *b* are positive integers, and *c* is the sum of *a* and *b*. Now let's remove all zeros from this equation. Will the equation remain correct after removing all zeros?

For example if the equation is 101<=+<=102<==<=203, if we removed all zeros it will be 11<=+<=12<==<=23 which is still a correct equation.

But if the equation is 105<=+<=106<==<=211, if we removed all zeros it will be 15<=+<=16<==<=211 which is not a correct equation.","The input will consist of two lines, the first line will contain the integer *a*, and the second line will contain the integer *b* which are in the equation as described above (1<=≤<=*a*,<=*b*<=≤<=109). There won't be any leading zeros in both. The value of *c* should be calculated as *c*<==<=*a*<=+<=*b*.","The output will be just one line, you should print ""YES"" if the equation will remain correct after removing all zeros, and print ""NO"" otherwise.","['101\n102\n', '105\n106\n']","['YES\n', 'NO\n']",none,RUNTIME_ERROR,"n = int(input())
m = int(input())
sol = n + m;n = str(n)
m = str(m);sol = str(c)
n = int(n.replace('0', """"))
m = int(m.replace('0', """"))
sol=int(sol.replace(""0"",""""))
if n + m == sol:
	print(""YES"")
else:
	print(""NO"")","def intmaker(list1):
    for i in range(len(list1)):
        list1[i] = int(list1[i])

def min_difference(n, m, puzzles):
    # Sort the puzzle pieces
    puzzles.sort()
    min_diff = float('inf')
    
    # Iterate through the puzzles to find the minimum range
    for i in range(m - n + 1):
        current_diff = puzzles[i + n - 1] - puzzles[i]
        min_diff = min(min_diff, current_diff)

    return min_diff

# Read input
first_line = input().strip().split()
n, m = int(first_line[0]), int(first_line[1])
puzzles = input().strip().split()

# Convert puzzle piece counts to integers
intmaker(puzzles)

# Calculate and print the minimum difference
result = min_difference(n, m, puzzles)
print(result)"
584,A,Olesya and Rodion,PROGRAMMING,['math'],"Olesya loves numbers consisting of *n* digits, and Rodion only likes numbers that are divisible by *t*. Find some number that satisfies both of them.

Your task is: given the *n* and *t* print an integer strictly larger than zero consisting of *n* digits that is divisible by *t*. If such number doesn't exist, print <=-<=1.","The single line contains two numbers, *n* and *t* (1<=≤<=*n*<=≤<=100, 2<=≤<=*t*<=≤<=10) — the length of the number and the number it should be divisible by.","Print one such positive number without leading zeroes, — the answer to the problem, or <=-<=1, if such number doesn't exist. If there are multiple possible answers, you are allowed to print any of them.",['3 2\n'],['712'],none,OK,"n,t = map(int,input().split())
s = '1'
i = 1
while i <= n-1:
    s += '0'
    i += 1
w = s + '0'
num1 = int(s)
num2 = int(w)
while num1 < num2:
    if num1 % t == 0:
        print(num1)
        break
    else:
        num1 += 1
if num1 == num2:
    print(-1)","# Read inputs n and t
n, t = map(int, input().split())

# Check if t is 10 and n is 1, impossible case
if t == 10 and n == 1:
    print(-1)
else:
    # If t is 10, create a number like '1' followed by n-1 zeros
    if t == 10:
        print('1' + '0' * (n - 1))
    else:
        # If t is not 10, just repeat t n times
        print(str(t) * n)"
911,B,Two Cakes,PROGRAMMING,"['binary search', 'brute force', 'implementation']","It's New Year's Eve soon, so Ivan decided it's high time he started setting the table. Ivan has bought two cakes and cut them into pieces: the first cake has been cut into *a* pieces, and the second one — into *b* pieces.

Ivan knows that there will be *n* people at the celebration (including himself), so Ivan has set *n* plates for the cakes. Now he is thinking about how to distribute the cakes between the plates. Ivan wants to do it in such a way that all following conditions are met:
 1.  Each piece of each cake is put on some plate; 1.  Each plate contains at least one piece of cake; 1.  No plate contains pieces of both cakes. 
To make his guests happy, Ivan wants to distribute the cakes in such a way that the minimum number of pieces on the plate is maximized. Formally, Ivan wants to know the maximum possible number *x* such that he can distribute the cakes according to the aforementioned conditions, and each plate will contain at least *x* pieces of cake.

Help Ivan to calculate this number *x*!","The first line contains three integers *n*, *a* and *b* (1<=≤<=*a*,<=*b*<=≤<=100, 2<=≤<=*n*<=≤<=*a*<=+<=*b*) — the number of plates, the number of pieces of the first cake, and the number of pieces of the second cake, respectively.",Print the maximum possible number *x* such that Ivan can distribute the cake in such a way that each plate will contain at least *x* pieces of cake.,"['5 2 3\n', '4 7 10\n']","['1\n', '3\n']","In the first example there is only one way to distribute cakes to plates, all of them will have 1 cake on it.

In the second example you can have two plates with 3 and 4 pieces of the first cake and two plates both with 5 pieces of the second cake. Minimal number of pieces is 3.",WRONG_ANSWER,"n, a,b = map(int,input().split())
c= (a+b)//n
if a%c==0 and b%c==0: print(c)
else: c-=1
print(min(a,b,  c))","from collections import defaultdict, deque, Counter, OrderedDict
import sys
sys.setrecursionlimit(20000)

def main():
    n = int(input())
    adj = [[] for i in range(n)]
    white = [0] * n
    d = [0] * n
    problem_roads = set()  # To keep track of problem roads

    # Read the roads and build the adjacency list
    for i in range(n - 1):
        x, y, t = map(int, input().split())
        x -= 1  # making zero indexed
        y -= 1  # making zero indexed
        adj[x].append((y, t))
        adj[y].append((x, t))
        if t == 2:  # if it's a problem road
            problem_roads.add(x)
            problem_roads.add(y)

    # To store the candidates needed to repair problem roads
    candidates = set()
    
    # Depth-first search function to find all candidates needed
    def dfs(node, parent):
        for neighbor, road_type in adj[node]:
            if neighbor != parent:
                if road_type == 2:  # if it's a problem road
                    candidates.add(neighbor + 1)  # Store candidate (1 indexed)
                dfs(neighbor, node)

    # Start DFS from node 0 (district 1)
    dfs(0, -1)

    # Prepare the output
    print(len(candidates))
    print("" "".join(map(str, sorted(candidates))))

if __name__ == ""__main__"":
    main()"
518,A,Vitaly and Strings,PROGRAMMING,"['constructive algorithms', 'strings']","Vitaly is a diligent student who never missed a lesson in his five years of studying in the university. He always does his homework on time and passes his exams in time. 

During the last lesson the teacher has provided two strings *s* and *t* to Vitaly. The strings have the same length, they consist of lowercase English letters, string *s* is lexicographically smaller than string *t*. Vitaly wondered if there is such string that is lexicographically larger than string *s* and at the same is lexicographically smaller than string *t*. This string should also consist of lowercase English letters and have the length equal to the lengths of strings *s* and *t*. 

Let's help Vitaly solve this easy problem!","The first line contains string *s* (1<=≤<=|*s*|<=≤<=100), consisting of lowercase English letters. Here, |*s*| denotes the length of the string.

The second line contains string *t* (|*t*|<==<=|*s*|), consisting of lowercase English letters.

It is guaranteed that the lengths of strings *s* and *t* are the same and string *s* is lexicographically less than string *t*.","If the string that meets the given requirements doesn't exist, print a single string ""No such string"" (without the quotes).

If such string exists, print it. If there are multiple valid strings, you may print any of them.","['a\nc\n', 'aaa\nzzz\n', 'abcdefg\nabcdefh\n']","['b\n', 'kkk\n', 'No such string\n']","String *s* = *s*<sub class=""lower-index"">1</sub>*s*<sub class=""lower-index"">2</sub>... *s*<sub class=""lower-index"">*n*</sub> is said to be lexicographically smaller than *t* = *t*<sub class=""lower-index"">1</sub>*t*<sub class=""lower-index"">2</sub>... *t*<sub class=""lower-index"">*n*</sub>, if there exists such *i*, that *s*<sub class=""lower-index"">1</sub> = *t*<sub class=""lower-index"">1</sub>, *s*<sub class=""lower-index"">2</sub> = *t*<sub class=""lower-index"">2</sub>, ... *s*<sub class=""lower-index"">*i* - 1</sub> = *t*<sub class=""lower-index"">*i* - 1</sub>, *s*<sub class=""lower-index"">*i*</sub> &lt; *t*<sub class=""lower-index"">*i*</sub>.",WRONG_ANSWER,"s=input()
a=input()
l=list(s)

l[len(s)-1]=chr(((ord(l[len(s)-1])-97+1)%26+97))

    
st=""""
for i in l:
    st+=i
    
if st<a:
    print(st)
else:
    print(""No such string"")
    


	 		 	  	 	 	 	    	 	  				 	","def C(a, b):
    return fact(a) / fact(b) / fact(a - b)

def fact(a):
    if a == 0 or a == 1:
        return 1
    result = 1
    for i in range(2, a + 1):
        result *= i
    return result

def probability_of_success(n, m):
    # Probability of choosing two cards from the same deck
    same_deck_prob = (m * C(n, 2)) / C(n * m, 2)
    
    # Probability of choosing two different cards
    different_deck_prob = ((n * (m - 1)) / (n * m))
    
    # Total probability of success
    total_prob = same_deck_prob + (1 - same_deck_prob) * different_deck_prob
    
    return total_prob

# Read input values
n, m = map(int, input().split())

# Calculate and print the probability
print(f""{probability_of_success(n, m):.10f}"")"
691,B,s-palindrome,PROGRAMMING,"['implementation', 'strings']","Let's call a string ""s-palindrome"" if it is symmetric about the middle of the string. For example, the string ""oHo"" is ""s-palindrome"", but the string ""aa"" is not. The string ""aa"" is not ""s-palindrome"", because the second half of it is not a mirror reflection of the first half.

You are given a string *s*. Check if the string is ""s-palindrome"".",The only line contains the string *s* (1<=≤<=|*s*|<=≤<=1000) which consists of only English letters.,"Print ""TAK"" if the string *s* is ""s-palindrome"" and ""NIE"" otherwise.","['oXoxoXo\n', 'bod\n', 'ER\n']","['TAK\n', 'TAK\n', 'NIE\n']",none,WRONG_ANSWER,"pair = dict()
pair['A'] = 'A'
pair['b'] = 'd'
pair['d'] = 'b'
pair['H'] = 'H'
pair['I'] = 'I'
pair['M'] = 'M'
pair['O'] = 'O'
pair['o'] = 'o'
pair['p'] = 'q'
pair['q'] = 'p'
pair['T'] = 'T'
pair['U'] = 'U'
pair['V'] = 'V'
pair['v'] = 'v'
pair['W'] = 'W'
pair['w'] = 'w'
pair['X'] = 'X'
pair['x'] = 'x'
pair['Y'] = 'Y'
s = input()
for i in range(len(s) // 2):
    if s[i] in pair and s[len(s) - i - 1] == pair[s[i]]:
        continue
    else:
        print(""NIE"")
        exit(0)
if len(s) % 2 == 1 and s[len(s) // 2] not in pair:
    print(""NIE"")
    exit(0)
print(""TAK"")
","import sys
import math
input = sys.stdin.readline

def primefactors(n):
    l = []
    while n % 2 == 0:
        l.append(2)
        n //= 2
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        while n % i == 0:
            l.append(i)
            n //= i
    if n > 2:
        l.append(n)
    return l

def factorial_product_representation(digit):
    if digit == 0 or digit == 1:
        return []
    elif digit == 2:
        return [2]
    elif digit == 3:
        return [3]
    elif digit == 4:
        return [3, 2, 2]  # 4 = 3! * 2! * 2!
    elif digit == 5:
        return [5]
    elif digit == 6:
        return [5, 3]  # 6 = 5! * 3!
    elif digit == 7:
        return [7]
    elif digit == 8:
        return [7, 2, 2, 2]  # 8 = 7! * 2! * 2! * 2!
    elif digit == 9:
        return [7, 3, 3, 2]  # 9 = 7! * 3! * 3! * 2!
    
def max_number_representation(n, number_string):
    result = []
    for digit_char in number_string:
        digit = int(digit_char)
        result.extend(factorial_product_representation(digit))
    
    # Sorting in decreasing order to create the maximum number
    result.sort(reverse=True)
    
    return ''.join(map(str, result))

n = int(input().strip())
number_string = input().strip()
print(max_number_representation(n, number_string))"
801,A,Vicious Keyboard,PROGRAMMING,['brute force'],"Tonio has a keyboard with only two letters, ""V"" and ""K"".

One day, he has typed out a string *s* with only these two letters. He really likes it when the string ""VK"" appears, so he wishes to change at most one letter in the string (or do no changes) to maximize the number of occurrences of that string. Compute the maximum number of times ""VK"" can appear as a substring (i. e. a letter ""K"" right after a letter ""V"") in the resulting string.","The first line will contain a string *s* consisting only of uppercase English letters ""V"" and ""K"" with length not less than 1 and not greater than 100.","Output a single integer, the maximum number of times ""VK"" can appear as a substring of the given string after changing at most one character.","['VK\n', 'VV\n', 'V\n', 'VKKKKKKKKKVVVVVVVVVK\n', 'KVKV\n']","['1\n', '1\n', '0\n', '3\n', '1\n']","For the first case, we do not change any letters. ""VK"" appears once, which is the maximum number of times it could appear.

For the second case, we can change the second character from a ""V"" to a ""K"". This will give us the string ""VK"". This has one occurrence of the string ""VK"" as a substring.

For the fourth case, we can change the fourth character from a ""K"" to a ""V"". This will give us the string ""VKKVKKKKKKVVVVVVVVVK"". This has three occurrences of the string ""VK"" as a substring. We can check no other moves can give us strictly more occurrences.",OK,"s = input().strip()
s = s.replace(""VK"", ""*"")
cnt = sum(map(lambda x: x==""*"",s))
if ""VV"" in s or ""KK"" in s:
  cnt +=1
print(cnt)  ","dirs = ['v', '<', '^', '>']
start, end = input().split()
n = int(input())

start_index = dirs.index(start)
end_index = dirs.index(end)

# Calculate the position after rotating clockwise and counter-clockwise
cw_position = (start_index + n) % 4  # Clockwise
ccw_position = (start_index - n) % 4  # Counter-clockwise

# Determine the direction based on the calculated positions
if cw_position == end_index:
    print(""cw"")
elif ccw_position == end_index:
    print(""ccw"")
else:
    print(""undefined"")"
274,A,k-Multiple Free Set,PROGRAMMING,"['binary search', 'greedy', 'sortings']","A *k*-multiple free set is a set of integers where there is no pair of integers where one is equal to another integer multiplied by *k*. That is, there are no two integers *x* and *y* (*x*<=&lt;<=*y*) from the set, such that *y*<==<=*x*·*k*.

You're given a set of *n* distinct positive integers. Your task is to find the size of it's largest *k*-multiple free subset.","The first line of the input contains two integers *n* and *k* (1<=≤<=*n*<=≤<=105,<=1<=≤<=*k*<=≤<=109). The next line contains a list of *n* distinct positive integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=109).

All the numbers in the lines are separated by single spaces.","On the only line of the output print the size of the largest *k*-multiple free subset of {*a*1,<=*a*2,<=...,<=*a**n*}.",['6 2\n2 3 6 5 4 10\n'],['3\n'],"In the sample input one of the possible maximum 2-multiple free subsets is {4, 5, 6}.",TIME_LIMIT_EXCEEDED,"n,k=map(int,input().split())
li=[int(i)for i in input().split()]
li.sort()
m=0
lst=list()
for i in range(0,n-1):
  lst=[]
  lst.append(li[i])
  for j in range(i+1,n):
    flag=1
    lst1=lst
    for h in lst1:
      if li[j]/h==k:
        flag=0
        break
    if flag==1:
      lst.append(li[j])
  m=max(m,len(lst))
print(m)","from math import gcd

def lcm(x, y):
    return (x * y) // gcd(x, y)

def max_lcm_of_three(n):
    # The maximum LCM is usually found by using the largest integers <= n
    if n == 1:
        return 1
    
    # Start by assuming the numbers are n, n-1, n-2
    candidates = [n, n-1, n-2]

    # If n is even, consider also n-3 to ensure odd/even combinations
    if n % 2 == 0:
        candidates.append(n-3)
    
    # If n-1 is even, consider n-4 as well
    if (n - 1) % 2 == 0:
        candidates.append(n-4)

    max_lcm = 0

    # Calculate the LCM for all combinations of three numbers from candidates
    for i in range(len(candidates)):
        for j in range(len(candidates)):
            for k in range(len(candidates)):
                a = candidates[i]
                b = candidates[j]
                c = candidates[k]
                current_lcm = lcm(lcm(a, b), c)
                max_lcm = max(max_lcm, current_lcm)

    return max_lcm

# Read input
n = int(input())
print(max_lcm_of_three(n))"
120,A,Elevator,PROGRAMMING,"['brute force', 'implementation', 'math']","A sky scraper with 1000 floors has been built in the city of N. It has modern superfast elevators to help to travel from one floor to another. Each elevator has two doors, the front one and the back one. If one goes in through the front door, he goes out through the back one and vice versa. The elevator has two rails numbered with numbers 1 and 2. Rail 1 is located to the left of the entrance to the front door (or correspondingly, to the right of the entrance to the back door). Rail 2 is located opposite it, to the right of the entrance to the front door and to the left of the entrance to the back door. We know that each person in the city of N holds at a rail with the strongest hand. 

One day a VIP person visited the city and of course, he took a look at the skyscraper and took a ride in the elevator. We know the door through which he entered and the rail he was holding at. Now we need to determine as soon as possible whether he is left-handed or right-handed.","The first line indicates the door through which the very important person entered the elevator. It contains ""front"" if the person enters the elevator through the front door and ""back"" if he entered the elevator through the back door. The second line contains integer *a* (1<=≤<=*a*<=≤<=2) which denotes the number of the rail at which the person was holding.","Print character ""R"" if the VIP is right-handed or ""L"" if he is left-handed.",['front\n1\n'],['L\n'],none,OK,"fi = open('input.txt', 'r')
d, a = fi.readline().strip() == 'front', int(fi.readline()) == 1
print('L' if d == a else 'R', file=open('output.txt', 'w'))","""""""Railway construction

Recursive algorithm
""""""
import logging
from functools import lru_cache, partial
from typing import Dict, List, Literal, Optional, Tuple

# Define constants for directions
UP = 'U'
DOWN = 'D'
LEFT = 'L'
RIGHT = 'R'

# Function to handle the movement of the Beaveractor
def move_beaveractor(x: int, y: int, direction: str, time: int, arrows: List[Tuple[int, int, int, int]], b: int) -> Tuple[int, int]:
    # Store current position
    current_x, current_y = x, y
    
    while time > 0:
        if direction == UP:
            # Find the next vertical arrow
            next_arrow = min((y1 for x1, y1, x2, y2 in arrows if x1 <= current_x <= x2 and y1 > current_y), default=b + 1)
            distance = next_arrow - current_y  # Distance to the next arrow
            
            if distance <= time:
                # Move to the arrow
                current_y = next_arrow
                time -= distance
                direction = determine_next_direction(current_x, current_y, arrows)  # Update direction
            else:
                # Move up the available time
                current_y += time
                break

        elif direction == DOWN:
            # Find the next vertical arrow
            next_arrow = max((y1 for x1, y1, x2, y2 in arrows if x1 <= current_x <= x2 and y2 < current_y), default=-1)
            distance = current_y - next_arrow  # Distance to the next arrow
            
            if distance <= time:
                # Move to the arrow
                current_y = next_arrow
                time -= distance
                direction = determine_next_direction(current_x, current_y, arrows)  # Update direction
            else:
                # Move down the available time
                current_y -= time
                break

        elif direction == LEFT:
            # Find the next horizontal arrow
            next_arrow = max((x1 for x1, y1, x2, y2 in arrows if y1 <= current_y <= y2 and x2 < current_x), default=-1)
            distance = current_x - next_arrow  # Distance to the next arrow
            
            if distance <= time:
                # Move to the arrow
                current_x = next_arrow
                time -= distance
                direction = determine_next_direction(current_x, current_y, arrows)  # Update direction
            else:
                # Move left the available time
                current_x -= time
                break

        elif direction == RIGHT:
            # Find the next horizontal arrow
            next_arrow = min((x1 for x1, y1, x2, y2 in arrows if y1 <= current_y <= y2 and x1 > current_x), default=b + 1)
            distance = next_arrow - current_x  # Distance to the next arrow
            
            if distance <= time:
                # Move to the arrow
                current_x = next_arrow
                time -= distance
                direction = determine_next_direction(current_x, current_y, arrows)  # Update direction
            else:
                # Move right the available time
                current_x += time
                break
    
    # Return the final position
    return current_x, current_y

# Function to determine the next direction based on current position and arrows
def determine_next_direction(x: int, y: int, arrows: List[Tuple[int, int, int, int]]) -> str:
    # Check for nearby arrows to determine next direction (simplified logic for demonstration)
    for x1, y1, x2, y2 in arrows:
        if x1 <= x <= x2:
            if y < y1:
                return UP
            elif y > y2:
                return DOWN
    for x1, y1, x2, y2 in arrows:
        if y1 <= y <= y2:
            if x < x1:
                return RIGHT
            elif x > x2:
                return LEFT
    return UP  # Default direction if no arrows are found

# Main function to read inputs and output results
def main():
    n, b = map(int, input().split())
    arrows = []
    
    for _ in range(n):
        x0, y0, x1, y1 = map(int, input().split())
        arrows.append((x0, y0, x1, y1))
    
    q = int(input())
    output = []
    
    for _ in range(q):
        xi, yi, wi, ti = input().split()
        xi, yi, ti = int(xi), int(yi), int(ti)
        final_x, final_y = move_beaveractor(xi, yi, wi, ti, arrows, b)
        output.append(f""{final_x} {final_y}"")
    
    print(""\n"".join(output))

# Entry point
if __name__ == ""__main__"":
    main()"
676,C,Vasya and String,PROGRAMMING,"['binary search', 'dp', 'strings', 'two pointers']","High school student Vasya got a string of length *n* as a birthday present. This string consists of letters 'a' and 'b' only. Vasya denotes beauty of the string as the maximum length of a substring (consecutive subsequence) consisting of equal letters.

Vasya can change no more than *k* characters of the original string. What is the maximum beauty of the string he can achieve?","The first line of the input contains two integers *n* and *k* (1<=≤<=*n*<=≤<=100<=000,<=0<=≤<=*k*<=≤<=*n*) — the length of the string and the maximum number of characters to change.

The second line contains the string, consisting of letters 'a' and 'b' only.",Print the only integer — the maximum beauty of the string Vasya can achieve by changing no more than *k* characters.,"['4 2\nabba\n', '8 1\naabaabaa\n']","['4\n', '5\n']","In the first sample, Vasya can obtain both strings ""aaaa"" and ""bbbb"".

In the second sample, the optimal answer is obtained with the string ""aaaaabaa"" or with the string ""aabaaaaa"".",WRONG_ANSWER,"n, k = map(int, input().split())
s = input()

max_beauty = 0
count_a = 0
count_b = 0
window_start = 0

for i in range(n):
    if s[i] == 'a':
        count_a += 1
    else:
        count_b += 1
    
    min_count = min(count_a, count_b)
    
    while (i - window_start + 1) - min_count > k:
        if s[window_start] == 'a':
            count_a -= 1
        else:
            count_b -= 1
        window_start += 1
    
    max_beauty = max(max_beauty, min_count + k)

print(max_beauty)

			  	    	   		 	 					 	 		","def fn(n):
    # Check if the weight is greater than 2
    if n > 2:
        # Check if the weight is even
        if n % 2 == 0:
            return ""YES""
    return ""NO"""
263,A,Beautiful Matrix,PROGRAMMING,['implementation'],"You've got a 5<=×<=5 matrix, consisting of 24 zeroes and a single number one. Let's index the matrix rows by numbers from 1 to 5 from top to bottom, let's index the matrix columns by numbers from 1 to 5 from left to right. In one move, you are allowed to apply one of the two following transformations to the matrix:
 1.  Swap two neighboring matrix rows, that is, rows with indexes *i* and *i*<=+<=1 for some integer *i* (1<=≤<=*i*<=&lt;<=5). 1.  Swap two neighboring matrix columns, that is, columns with indexes *j* and *j*<=+<=1 for some integer *j* (1<=≤<=*j*<=&lt;<=5). 
You think that a matrix looks beautiful, if the single number one of the matrix is located in its middle (in the cell that is on the intersection of the third row and the third column). Count the minimum number of moves needed to make the matrix beautiful.","The input consists of five lines, each line contains five integers: the *j*-th integer in the *i*-th line of the input represents the element of the matrix that is located on the intersection of the *i*-th row and the *j*-th column. It is guaranteed that the matrix consists of 24 zeroes and a single number one.",Print a single integer — the minimum number of moves needed to make the matrix beautiful.,"['0 0 0 0 0\n0 0 0 0 1\n0 0 0 0 0\n0 0 0 0 0\n0 0 0 0 0\n', '0 0 0 0 0\n0 0 0 0 0\n0 1 0 0 0\n0 0 0 0 0\n0 0 0 0 0\n']","['3\n', '1\n']",none,OK,"l1=[]
for i in range(1,6):
    l=list(map(int,input().split()))
    l1.append(l)
for i in l1:
    for j in i:
        if j!=0:
            c=i.index(j)
            r=l1.index(i)
m=abs(r-2)
m=m+abs(c-2)
print(m)","# Problem: A. Cutting Banner
# Contest: Codeforces - Codeforces Round #300
# URL: https://codeforces.com/contest/538/problem/A
# Memory Limit: 256 MB

def can_form_codeforces(banner):
    target = ""CODEFORCES""
    target_length = len(target)
    banner_length = len(banner)

    # Check every possible way to split the target
    for i in range(target_length + 1):
        prefix = target[:i]  # Take first i characters
        suffix = target[i:]  # Take the remaining characters after i

        # Check if the banner starts with the prefix and ends with the suffix
        if (banner.startswith(prefix) and banner.endswith(suffix)):
            # Check the total length condition
            if (len(prefix) + len(suffix) <= banner_length):
                return ""YES""
    
    # If no valid prefix-suffix combination is found
    return ""NO""

# Read input
banner = input().strip()

# Determine if it is possible to form ""CODEFORCES""
result = can_form_codeforces(banner)

# Print the result
print(result)"
69,A,Young Physicist,PROGRAMMING,"['implementation', 'math']","A guy named Vasya attends the final grade of a high school. One day Vasya decided to watch a match of his favorite hockey team. And, as the boy loves hockey very much, even more than physics, he forgot to do the homework. Specifically, he forgot to complete his physics tasks. Next day the teacher got very angry at Vasya and decided to teach him a lesson. He gave the lazy student a seemingly easy task: You are given an idle body in space and the forces that affect it. The body can be considered as a material point with coordinates (0; 0; 0). Vasya had only to answer whether it is in equilibrium. ""Piece of cake"" — thought Vasya, we need only to check if the sum of all vectors is equal to 0. So, Vasya began to solve the problem. But later it turned out that there can be lots and lots of these forces, and Vasya can not cope without your help. Help him. Write a program that determines whether a body is idle or is moving by the given vectors of forces.","The first line contains a positive integer *n* (1<=≤<=*n*<=≤<=100), then follow *n* lines containing three integers each: the *x**i* coordinate, the *y**i* coordinate and the *z**i* coordinate of the force vector, applied to the body (<=-<=100<=≤<=*x**i*,<=*y**i*,<=*z**i*<=≤<=100).","Print the word ""YES"" if the body is in equilibrium, or the word ""NO"" if it is not.","['3\n4 1 7\n-2 4 -1\n1 -5 -3\n', '3\n3 -1 7\n-5 2 -4\n2 -1 -3\n']","['NO', 'YES']",none,OK,"n = int(input())
x = []
for i in range(n):
    a, b, c = map(int, input().split())
    x.append([a,b,c])
s = 0
m = 0
l = 0
for i in range(n):
    s += x[i][0]
    m += x[i][1]
    l += x[i][2]

if s == 0 and m == 0 and l == 0:
    print(""YES"")
else:
    print(""NO"")
","def main():
    ax, ay, bx, by, cx, cy = [int(i) for i in input().split()]
    if ax * by + bx * cy + cx * ay - bx * ay - cx * by - ax * cy == 0:
        print(""Yes"")
    else:
        print(""No"")

main()"
981,A,Antipalindrome,PROGRAMMING,"['brute force', 'implementation', 'strings']","A string is a palindrome if it reads the same from the left to the right and from the right to the left. For example, the strings ""kek"", ""abacaba"", ""r"" and ""papicipap"" are palindromes, while the strings ""abb"" and ""iq"" are not.

A substring $s[l \ldots r]$ ($1<=\leq<=l<=\leq<=r<=\leq<=|s|$) of a string $s<==<=s_{1}s_{2} \ldots s_{|s|}$ is the string $s_{l}s_{l<=+<=1} \ldots s_{r}$.

Anna does not like palindromes, so she makes her friends call her Ann. She also changes all the words she reads in a similar way. Namely, each word $s$ is changed into its longest substring that is not a palindrome. If all the substrings of $s$ are palindromes, she skips the word at all.

Some time ago Ann read the word $s$. What is the word she changed it into?","The first line contains a non-empty string $s$ with length at most $50$ characters, containing lowercase English letters only.","If there is such a substring in $s$ that is not a palindrome, print the maximum length of such a substring. Otherwise print $0$.

Note that there can be multiple longest substrings that are not palindromes, but their length is unique.","['mew\n', 'wuffuw\n', 'qqqqqqqq\n']","['3\n', '5\n', '0\n']","""mew"" is not a palindrome, so the longest substring of it that is not a palindrome, is the string ""mew"" itself. Thus, the answer for the first example is $3$.

The string ""uffuw"" is one of the longest non-palindrome substrings (of length $5$) of the string ""wuffuw"", so the answer for the second example is $5$.

All substrings of the string ""qqqqqqqq"" consist of equal characters so they are palindromes. This way, there are no non-palindrome substrings. Thus, the answer for the third example is $0$.",OK,"""""""https://codeforces.com/problemset/problem/981/A
""""""

s = input()
for r in range(len(s), 1, -1):
    if s[:r] != s[r - 1::-1]:
        print(r)
        break
else:
    print(0)
","import sys
input = lambda: sys.stdin.readline().rstrip()
from collections import deque, defaultdict, Counter
from itertools import permutations, combinations
from bisect import *
from heapq import *

n, l, r = map(int, input().split())
a = list(map(int, input().split()))
b = list(map(int, input().split()))

# Adjust indices to be 0-based
l -= 1
r -= 1

# Get the segments of the arrays that could have been affected
a_segment = a[l:r+1]
b_segment = b[l:r+1]

# Sort both segments to compare them
a_segment.sort()
b_segment.sort()

# Check if the sorted segments are the same
if a_segment == b_segment:
    print(""TRUTH"")
else:
    print(""LIE"")"
505,A,Mr. Kitayuta's Gift,PROGRAMMING,"['brute force', 'implementation', 'strings']","Mr. Kitayuta has kindly given you a string *s* consisting of lowercase English letters. You are asked to insert exactly one lowercase English letter into *s* to make it a palindrome. A palindrome is a string that reads the same forward and backward. For example, ""noon"", ""testset"" and ""a"" are all palindromes, while ""test"" and ""kitayuta"" are not.

You can choose any lowercase English letter, and insert it to any position of *s*, possibly to the beginning or the end of *s*. You have to insert a letter even if the given string is already a palindrome.

If it is possible to insert one lowercase English letter into *s* so that the resulting string will be a palindrome, print the string after the insertion. Otherwise, print ""NA"" (without quotes, case-sensitive). In case there is more than one palindrome that can be obtained, you are allowed to print any of them.",The only line of the input contains a string *s* (1<=≤<=|*s*|<=≤<=10). Each character in *s* is a lowercase English letter.,"If it is possible to turn *s* into a palindrome by inserting one lowercase English letter, print the resulting string in a single line. Otherwise, print ""NA"" (without quotes, case-sensitive). In case there is more than one solution, any of them will be accepted.","['revive\n', 'ee\n', 'kitayuta\n']","['reviver\n', 'eye', 'NA\n']","For the first sample, insert 'r' to the end of ""revive"" to obtain a palindrome ""reviver"".

For the second sample, there is more than one solution. For example, ""eve"" will also be accepted.

For the third sample, it is not possible to turn ""kitayuta"" into a palindrome by just inserting one letter.",WRONG_ANSWER,"s = input()
n = len(s)
i, j = 0, n-1
cnt = 0
if s == s[::-1]:
    k = n//2
    print(s[:k+1] + s[k:])
    exit()
while(i < j):
    if s[i] == s[j]:
        i += 1
        j -= 1
    else:
        s = s[:j+1] + s[i] + s[j+1:]
        i += 1
        if len(s) > n + 1: print('NA'); break
if n + 1 != len(s) and n != len(s):
    print('NA')
else: 
    print(s)
","def max_friendship_factor(n, d, friends):
    max_friendship_factor = 0
    cumulative_sum = 0
    friends.sort()  # Sort friends by the amount of money they have

    left = 0  # Left pointer for the window
    for right in range(n):
        cumulative_sum += friends[right][1]  # Add current friend's friendship factor
        
        # Move the left pointer to maintain the condition
        while friends[right][0] - friends[left][0] >= d:
            cumulative_sum -= friends[left][1]  # Remove the left friend's friendship factor
            left += 1  # Move the left pointer right

        max_friendship_factor = max(max_friendship_factor, cumulative_sum)  # Update the max friendship factor

    return max_friendship_factor

# Example usage:
n, d = map(int, input().split())
friends = [tuple(map(int, input().split())) for _ in range(n)]
print(max_friendship_factor(n, d, friends))"
854,A,Fraction,PROGRAMMING,"['brute force', 'constructive algorithms', 'math']","Petya is a big fan of mathematics, especially its part related to fractions. Recently he learned that a fraction  is called proper iff its numerator is smaller than its denominator (*a*<=&lt;<=*b*) and that the fraction is called irreducible if its numerator and its denominator are coprime (they do not have positive common divisors except 1).

During his free time, Petya thinks about proper irreducible fractions and converts them to decimals using the calculator. One day he mistakenly pressed addition button (<=+<=) instead of division button (÷) and got sum of numerator and denominator that was equal to *n* instead of the expected decimal notation. 

Petya wanted to restore the original fraction, but soon he realized that it might not be done uniquely. That's why he decided to determine maximum possible proper irreducible fraction  such that sum of its numerator and denominator equals *n*. Help Petya deal with this problem.","In the only line of input there is an integer *n* (3<=≤<=*n*<=≤<=1000), the sum of numerator and denominator of the fraction.","Output two space-separated positive integers *a* and *b*, numerator and denominator of the maximum possible proper irreducible fraction satisfying the given sum.","['3\n', '4\n', '12\n']","['1 2\n', '1 3\n', '5 7\n']",none,OK,"n=int(input())
m=n//2
switcher={
    0:[m-1,m+1],
    1:[m,m+1],
    2:[m-2,m+2],
    3:[m,m+1],
}
ans=switcher.get(n%4)
print(ans[0],ans[1])

","def month(a):
    return {
        '31': 7,    # Months with 31 days: January, March, May, July, August, October, December
        '30': 11,   # Months with 30 days: April, June, September, November
        '28': 1     # February has 28 days in 2016 (not a leap year)
    }[a]

def week(day):
    # There are 52 complete weeks in a year, plus 1 extra day in 2016
    return 52 + (1 if day <= 2 else 0)  # Extra day is for Monday and Tuesday

def main():
    input_data = input().strip()  # Read input
    parts = input_data.split()      # Split input into parts
    if parts[1] == ""week"":          # Check if input is about the week
        day_of_week = int(parts[0]) # Convert day to integer
        print(week(day_of_week))     # Calculate candies for specific day of week
    elif parts[1] == ""month"":       # Check if input is about the month
        day_of_month = parts[0]     # Get the day directly (as string)
        print(month(day_of_month))    # Calculate candies for specific day of month
        
main()"
129,A,Cookies,PROGRAMMING,['implementation'],"Olga came to visit the twins Anna and Maria and saw that they have many cookies. The cookies are distributed into bags. As there are many cookies, Olga decided that it's no big deal if she steals a bag. However, she doesn't want the sisters to quarrel because of nothing when they divide the cookies. That's why Olga wants to steal a bag with cookies so that the number of cookies in the remaining bags was even, that is, so that Anna and Maria could evenly divide it into two (even 0 remaining cookies will do, just as any other even number). How many ways there are to steal exactly one cookie bag so that the total number of cookies in the remaining bags was even?",The first line contains the only integer *n* (1<=≤<=*n*<=≤<=100) — the number of cookie bags Anna and Maria have. The second line contains *n* integers *a**i* (1<=≤<=*a**i*<=≤<=100) — the number of cookies in the *i*-th bag.,Print in the only line the only number — the sought number of ways. If there are no such ways print 0.,"['1\n1\n', '10\n1 2 2 3 4 4 4 2 2 2\n', '11\n2 2 2 2 2 2 2 2 2 2 99\n']","['1\n', '8\n', '1\n']","In the first sample Olga should take the only bag so that the twins ended up with the even number of cookies.

In the second sample Olga can take any of five bags with two cookies or any of three bags with four cookies — 5 + 3 = 8 ways in total.

In the third sample, no matter which bag with two cookies Olga chooses, the twins are left with 2 * 9 + 99 = 117 cookies. Thus, Olga has only one option: to take the bag with 99 cookies.",WRONG_ANSWER,"def solve(n, a):
    count = 0
    for i in range(n):
        for j in range(i+1, n+1):
            if sum(a[i:j]) % 2 == 1:
                count += 1
    return count

n = int(input())
a = list(map(int, input().split()))
print(solve(n, a))","# from heapq import *
# from collections import deque

def lets_do_it():
    n = int(input())
    a = list(map(int, input().split()))

    # Sort the original array
    original = sorted(a)
    
    # Prepare a sorted copy of the array to check against
    target = sorted(a)

    # Use two pointers to count how many elements can be placed
    count = 0
    j = 0
    
    for i in range(n):
        # If the current element in target is greater than the element in original
        if j < n and target[j] > original[i]:
            count += 1  # We can place this element
            j += 1  # Move the target pointer

    print(count)

lets_do_it()"
82,A,Double Cola,PROGRAMMING,"['implementation', 'math']","Sheldon, Leonard, Penny, Rajesh and Howard are in the queue for a ""Double Cola"" drink vending machine; there are no other people in the queue. The first one in the queue (Sheldon) buys a can, drinks it and doubles! The resulting two Sheldons go to the end of the queue. Then the next in the queue (Leonard) buys a can, drinks it and gets to the end of the queue as two Leonards, and so on. This process continues ad infinitum.

For example, Penny drinks the third can of cola and the queue will look like this: Rajesh, Howard, Sheldon, Sheldon, Leonard, Leonard, Penny, Penny.

Write a program that will print the name of a man who will drink the *n*-th can.

Note that in the very beginning the queue looks like that: Sheldon, Leonard, Penny, Rajesh, Howard. The first person is Sheldon.","The input data consist of a single integer *n* (1<=≤<=*n*<=≤<=109).

It is guaranteed that the pretests check the spelling of all the five names, that is, that they contain all the five possible answers.","Print the single line — the name of the person who drinks the *n*-th can of cola. The cans are numbered starting from 1. Please note that you should spell the names like this: ""Sheldon"", ""Leonard"", ""Penny"", ""Rajesh"", ""Howard"" (without the quotes). In that order precisely the friends are in the queue initially.","['1\n', '6\n', '1802\n']","['Sheldon\n', 'Sheldon\n', 'Penny\n']",none,OK,"x = int(input())

n=1
lvl_arr = [0]
def LvL(n):
  lvl_arr.append(2**(n-1)*5 + lvl_arr[n-1])
  return lvl_arr[n]

while(x > LvL(n)):
  n = n+1

p = ((x - lvl_arr[n-1] - 1) // 2**(n-1)) + 1

if(p == 1):
  print(""Sheldon"")
elif(p == 2):
  print(""Leonard"")
elif(p == 3):
  print(""Penny"")
elif(p == 4):
  print(""Rajesh"")
else:
  print(""Howard"")
","def main():
    n = int(input())
    l = [int(i) for i in input().split()]
    l.sort()
    l.reverse()
    
    # Array to store available lengths after potentially reducing sticks
    lengths = []

    for length in l:
        # Add the original length
        lengths.append(length)
        # Add the reduced length if it's greater than 0
        if length > 1:
            lengths.append(length - 1)

    # Use a counter to count frequency of each length
    from collections import Counter
    counter = Counter(lengths)

    # List to store pairs of lengths that can form rectangles
    pairs = []
    
    # Create pairs of lengths to form rectangles
    for length in sorted(counter.keys(), reverse=True):
        while counter[length] >= 2:  # Need at least 2 sticks of the same length
            pairs.append(length)
            counter[length] -= 2

    total_area = 0
    # Form rectangles using pairs
    for i in range(0, len(pairs) - 1, 2):
        total_area += pairs[i] * pairs[i + 1]

    print(total_area)

if __name__ == ""__main__"":
    main()"
1,A,Theatre Square,PROGRAMMING,['math'],"Theatre Square in the capital city of Berland has a rectangular shape with the size *n*<=×<=*m* meters. On the occasion of the city's anniversary, a decision was taken to pave the Square with square granite flagstones. Each flagstone is of the size *a*<=×<=*a*.

What is the least number of flagstones needed to pave the Square? It's allowed to cover the surface larger than the Theatre Square, but the Square has to be covered. It's not allowed to break the flagstones. The sides of flagstones should be parallel to the sides of the Square.","The input contains three positive integer numbers in the first line: *n*,<=<=*m* and *a* (1<=≤<=<=*n*,<=*m*,<=*a*<=≤<=109).",Write the needed number of flagstones.,['6 6 4\n'],['4\n'],none,OK,"n,m,a=map(int,input().split())
l1=n//a
l2=m//a
if n//a<n/a:
    l1=n//a+1
if m//a<m/a:
    l2=m//a +1
soni=l1*l2
print(soni)
","def dfs(horizontal, vertical, node_x, node_y, visited, n, m, lens, name):
    # Check if moving west
    if node_x != 0 and horizontal[node_y] == ""<"" and not visited.get((node_x, node_y), 0):
        visited[(node_x, node_y)] = 1
        lens[name] += 1
        dfs(horizontal, vertical, node_x - 1, node_y, visited, n, m, lens, name)

    # Check if moving east
    elif node_x != m - 1 and horizontal[node_y] == "">"" and not visited.get((node_x, node_y), 0):
        visited[(node_x, node_y)] = 1
        lens[name] += 1
        dfs(horizontal, vertical, node_x + 1, node_y, visited, n, m, lens, name)

    # Check if moving south
    if node_y != n - 1 and vertical[node_x] == ""v"" and not visited.get((node_x, node_y), 0):
        visited[(node_x, node_y)] = 1
        lens[name] += 1
        dfs(horizontal, vertical, node_x, node_y + 1, visited, n, m, lens, name)

    # Check if moving north
    elif node_y != 0 and vertical[node_x] == ""^"" and not visited.get((node_x, node_y), 0):
        visited[(node_x, node_y)] = 1
        lens[name] += 1
        dfs(horizontal, vertical, node_x, node_y - 1, visited, n, m, lens, name)

def can_reach_all(n, m, horizontal, vertical):
    visited = {}
    lens = {0: 0}
    
    # Start DFS from the top-left corner (0, 0)
    dfs(horizontal, vertical, 0, 0, visited, n, m, lens, 0)

    # If the number of visited positions matches the total number of junctions
    return str(len(visited) == n * m)

# Read input
n, m = map(int, input().strip().split())
horizontal = input().strip()
vertical = input().strip()

# Output result
print(can_reach_all(n, m, horizontal, vertical))"
111,A,Petya and Inequiations,PROGRAMMING,['greedy'],"Little Petya loves inequations. Help him find *n* positive integers *a*1,<=*a*2,<=...,<=*a**n*, such that the following two conditions are satisfied:
-  *a*12<=+<=*a*22<=+<=...<=+<=*a**n*2<=≥<=*x*-  *a*1<=+<=*a*2<=+<=...<=+<=*a**n*<=≤<=*y*","The first line contains three space-separated integers *n*, *x* and *y* (1<=≤<=*n*<=≤<=105,<=1<=≤<=*x*<=≤<=1012,<=1<=≤<=*y*<=≤<=106).

Please do not use the %lld specificator to read or write 64-bit integers in С++. It is recommended to use cin, cout streams or the %I64d specificator.","Print *n* positive integers that satisfy the conditions, one integer per line. If such numbers do not exist, print a single number ""-1"". If there are several solutions, print any of them.","['5 15 15\n', '2 3 2\n', '1 99 11\n']","['4\n4\n1\n1\n2\n', '-1\n', '11\n']",none,OK,"
n,x,y=map(int,input().split())
import math
an=n-1
if(x<=n-1):
    if(y>=n):
        for i in range(n):
            print(1)
    else:
        print(-1)
else:
    me=math.sqrt(x-an)
    if(me==int(me)):
        me=int(me)
        if(me+an<=y):
            for i in range(n-1):
                print(1)
            print(me)
        else:
            print(-1)
    else:
        me=int(me)
        me+=1
        if(me+an<=y):
            for i in range(n-1):
                print(1)
            print(me)
        else:
            print(-1)
","# s1=""baaa""
# s2=""abaa""
s1=input()
s2=input()

def eq(a, b):
    # If strings are equal, they are equivalent
    if a == b:
        return True
    
    # If the length is odd, they can't be split into two equal halves
    if len(a) % 2 == 1:
        return False
    
    # Split strings into two halves
    mid = len(a) // 2
    a1, a2 = a[:mid], a[mid:]
    b1, b2 = b[:mid], b[mid:]
    
    # Check both possible combinations of halves for equivalency
    return (eq(a1, b1) and eq(a2, b2)) or (eq(a1, b2) and eq(a2, b1))

# Print result based on equivalency of s1 and s2
if eq(s1, s2):
    print(""YES"")
else:
    print(""NO"")"
59,A,Word,PROGRAMMING,"['implementation', 'strings']","Vasya is very upset that many people on the Net mix uppercase and lowercase letters in one word. That's why he decided to invent an extension for his favorite browser that would change the letters' register in every word so that it either only consisted of lowercase letters or, vice versa, only of uppercase ones. At that as little as possible letters should be changed in the word. For example, the word HoUse must be replaced with house, and the word ViP — with VIP. If a word contains an equal number of uppercase and lowercase letters, you should replace all the letters with lowercase ones. For example, maTRIx should be replaced by matrix. Your task is to use the given method on one given word.",The first line contains a word *s* — it consists of uppercase and lowercase Latin letters and possesses the length from 1 to 100.,"Print the corrected word *s*. If the given word *s* has strictly more uppercase letters, make the word written in the uppercase register, otherwise - in the lowercase one.","['HoUse\n', 'ViP\n', 'maTRIx\n']","['house\n', 'VIP\n', 'matrix\n']",none,WRONG_ANSWER,"N = 200
vis = [0]*30

def main():
    n = int(input())
    for _ in range(n):
        ss = input().strip()
        vis.clear()
        vis = [0]*30
        l = len(ss)
        f = True
        mx = 0
        mi = 110
        for i in range(l):
            vis[ord(ss[i])-ord('a')] = 1
            mx = max(mx, ord(ss[i])-ord('a'))
            mi = min(mi, ord(ss[i])-ord('a'))
        for i in range(mi, mx+1):
            if vis[i] == 0:
                f = False
                break
        if f and mx-mi+1 == l:
            print(""Yes"")
        else:
            print(""No"")
","import itertools as it
import collections as cc
import heapq as hp
import sys

I = lambda: list(map(int, input().split()))
aa = cc.defaultdict(list)
bb = cc.defaultdict(list)

# Read input values
n, a, b = I()
p = I()

# Initialize an answer array filled with -1 (unknown)
answer = [-1] * n

# Try to assign numbers to set A or B based on conditions
for i in range(n):
    if p[i] < a:  # If p[i] is less than a, it must go to set A
        answer[i] = 0
    elif p[i] > b:  # If p[i] is greater than b, it must go to set B
        answer[i] = 1
    # If it is within the bounds of [a, b], we need to check if we can assign it

# Assign remaining numbers, ensuring no violations
for i in range(n):
    if answer[i] == -1:  # Number not yet assigned
        if i == 0 or answer[i - 1] == 0:  # Previous is A or it's the first element
            answer[i] = 0  # Assign to set A
        else:
            answer[i] = 1  # Assign to set B

# Validate the final answer
valid = True
for i in range(n):
    if answer[i] == 0 and p[i] < a:
        valid = False
        break
    if answer[i] == 1 and p[i] > b:
        valid = False
        break

# Output the result
if valid:
    print(""YES"")
    print("" "".join(map(str, answer)))
else:
    print(""NO"")"
157,B,Trace,PROGRAMMING,"['geometry', 'sortings']","One day, as Sherlock Holmes was tracking down one very important criminal, he found a wonderful painting on the wall. This wall could be represented as a plane. The painting had several concentric circles that divided the wall into several parts. Some parts were painted red and all the other were painted blue. Besides, any two neighboring parts were painted different colors, that is, the red and the blue color were alternating, i. e. followed one after the other. The outer area of the wall (the area that lied outside all circles) was painted blue. Help Sherlock Holmes determine the total area of red parts of the wall.

Let us remind you that two circles are called concentric if their centers coincide. Several circles are called concentric if any two of them are concentric.",The first line contains the single integer *n* (1<=≤<=*n*<=≤<=100). The second line contains *n* space-separated integers *r**i* (1<=≤<=*r**i*<=≤<=1000) — the circles' radii. It is guaranteed that all circles are different.,Print the single real number — total area of the part of the wall that is painted red. The answer is accepted if absolute or relative error doesn't exceed 10<=-<=4.,"['1\n1\n', '3\n1 4 2\n']","['3.1415926536\n', '40.8407044967\n']","In the first sample the picture is just one circle of radius 1. Inner part of the circle is painted red. The area of the red part equals π × 1<sup class=""upper-index"">2</sup> = π.

In the second sample there are three circles of radii 1, 4 and 2. Outside part of the second circle is painted blue. Part between the second and the third circles is painted red. Part between the first and the third is painted blue. And, finally, the inner part of the first circle is painted red. Overall there are two red parts: the ring between the second and the third circles and the inner part of the first circle. Total area of the red parts is equal (π × 4<sup class=""upper-index"">2</sup> - π × 2<sup class=""upper-index"">2</sup>) + π × 1<sup class=""upper-index"">2</sup> = π × 12 + π = 13π",OK,"# Description of the problem can be found at http://codeforces.com/problemset/problem/157/B

import math

n = int(input())
l_s = list(map(int, input().split()))
l_s.sort(reverse = True)

t = 0
for index in range(n):
    t += (-1 if index % 2 == 1 else 1) * l_s[index] ** 2

print(t * math.pi)","from sys import stdin
from collections import defaultdict


def solve(energy, maxval):
    maxalive = -1
    arr = [0] * (maxval + 1)
    for i in range(1, maxval + 1):
        arr[i] = arr[i - 1]  # Start with the count from the previous position
        for j in range(len(energy)):
            if energy[j][0] >= i + 1:  # If the beacon is to the right of current position
                break
            if energy[j][0] >= i - energy[j][1]:  # If the beacon can affect current position
                arr[i] += 1  # Count this beacon as destroyed
        maxalive = max(maxalive, len(energy) - arr[i])  # Calculate max alive beacons
    return maxalive


def main():
    n = int(stdin.readline())
    beacons = []
    for _ in range(n):
        a, b = map(int, stdin.readline().split())
        beacons.append((a, b))  # Store beacon position and power
    beacons.sort()  # Sort by position to process from left to right

    # Call the solve function with the sorted beacons
    result = solve(beacons, 1000000)  # Using 1,000,000 as the maximum position
    print(result)  # Output the minimum number of destroyed beacons


if __name__ == ""__main__"":
    main()"
863,A,Quasi-palindrome,PROGRAMMING,"['brute force', 'implementation']","Let quasi-palindromic number be such number that adding some leading zeros (possible none) to it produces a palindromic string. 

String *t* is called a palindrome, if it reads the same from left to right and from right to left.

For example, numbers 131 and 2010200 are quasi-palindromic, they can be transformed to strings ""131"" and ""002010200"", respectively, which are palindromes.

You are given some integer number *x*. Check if it's a quasi-palindromic number.",The first line contains one integer number *x* (1<=≤<=*x*<=≤<=109). This number is given without any leading zeroes.,"Print ""YES"" if number *x* is quasi-palindromic. Otherwise, print ""NO"" (without quotes).","['131\n', '320\n', '2010200\n']","['YES\n', 'NO\n', 'YES\n']",none,OK,"x=list(input())
x.reverse()
g=False
while len(x)>1:
    if x[0]=='0' and g==False:
        x.pop(0)
    else:
        g=True
        if x[0]!=x[-1]:
            print('NO')
            exit()
        else:
            x.pop(0)
            x.pop()
print(""YES"")","import sys
import random

input = sys.stdin.readline

n = int(input())

# Function to check if a number is prime
def is_prime(num):
    if num < 2:
        return False
    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            return False
    return True

# Since n is an odd number, check if n-2 is prime
if is_prime(n - 2):
    print(2)  # We can represent n as n = 2 + (n - 2)
    print(2, n - 2)
else:
    # If n-2 is not prime, we can use 3 primes
    # n can be represented as 3 + 3 + (n - 6) if n - 6 is prime
    if is_prime(n - 6):
        print(3)
        print(3, 3, n - 6)
    else:
        # Fallback case (we can always represent the number with three odd primes)
        # Using 5 and 5 and (n - 10) if n - 10 is prime
        if is_prime(n - 10):
            print(3)
            print(5, 5, n - 10)
        else:
            # Otherwise, we can return 3 + (n - 3) as a last resort
            print(2)
            print(3, n - 3)"
137,C,History,PROGRAMMING,['sortings'],"Polycarpus likes studying at school a lot and he is always diligent about his homework. Polycarpus has never had any problems with natural sciences as his great-great-grandfather was the great physicist Seinstein. On the other hand though, Polycarpus has never had an easy time with history.

Everybody knows that the World history encompasses exactly *n* events: the *i*-th event had continued from the year *a**i* to the year *b**i* inclusive (*a**i*<=&lt;<=*b**i*). Polycarpus easily learned the dates when each of *n* events started and ended (Polycarpus inherited excellent memory from his great-great-granddad). But the teacher gave him a more complicated task: Polycaprus should know when all events began and ended and he should also find out for each event whether it includes another event. Polycarpus' teacher thinks that an event *j* includes an event *i* if *a**j*<=&lt;<=*a**i* and *b**i*<=&lt;<=*b**j*. Your task is simpler: find the number of events that are included in some other event.","The first input line contains integer *n* (1<=≤<=*n*<=≤<=105) which represents the number of events. Next *n* lines contain descriptions of the historical events, one event per line. The *i*<=+<=1 line contains two integers *a**i* and *b**i* (1<=≤<=*a**i*<=&lt;<=*b**i*<=≤<=109) — the beginning and the end of the *i*-th event. No two events start or finish in the same year, that is, *a**i*<=≠<=*a**j*,<=*a**i*<=≠<=*b**j*,<=*b**i*<=≠<=*a**j*,<=*b**i*<=≠<=*b**j* for all *i*, *j* (where *i*<=≠<=*j*). Events are given in arbitrary order.",Print the only integer — the answer to the problem.,"['5\n1 10\n2 9\n3 8\n4 7\n5 6\n', '5\n1 100\n2 50\n51 99\n52 98\n10 60\n', '1\n1 1000000000\n']","['4\n', '4\n', '0\n']","In the first example the fifth event is contained in the fourth. Similarly, the fourth event is contained in the third, the third — in the second and the second — in the first.

In the second example all events except the first one are contained in the first.

In the third example only one event, so the answer is 0.",TIME_LIMIT_EXCEEDED,"n = int(input())
arr=[]
for _ in range(n):
    x,y = map(int,input().split())
    arr.append((x,y))
c=0
arr.sort(key=lambda arr:arr[0])

visited = []
for i in range(n):
    low = arr[i][0]
    high = arr[i][1]
    for j in range(i+1,n):
        if j not in visited:
            if arr[j][1]<=high and arr[j][0]>=low:
                c+=1
                visited.append(j)


print (c)
","alpha = ""abcdefghijklmnopqrstuvwxyz""
n = int(input(""""))
s = input("""")

# Convert the string to lowercase to handle case insensitivity
s = s.lower()

# Create a set of characters in the string
unique_chars = set(s)

# Check if all the alphabet letters are in the set of characters
if all(char in unique_chars for char in alpha):
    print(""YES"")
else:
    print(""NO"")"
175,A,Robot Bicorn Attack,PROGRAMMING,"['brute force', 'implementation']","Vasya plays Robot Bicorn Attack.

The game consists of three rounds. For each one a non-negative integer amount of points is given. The result of the game is the sum of obtained points. Vasya has already played three rounds and wrote obtained points one by one (without leading zeros) into the string *s*. Vasya decided to brag about his achievement to the friends. However, he has forgotten how many points he got for each round. The only thing he remembers is the string *s*.

Help Vasya to find out what is the maximum amount of points he could get. Take into account that Vasya played Robot Bicorn Attack for the first time, so he could not get more than 1000000 (106) points for one round.",The only line of input contains non-empty string *s* obtained by Vasya. The string consists of digits only. The string length does not exceed 30 characters.,Print the only number — the maximum amount of points Vasya could get. If Vasya is wrong and the string could not be obtained according to the rules then output number -1.,"['1234\n', '9000\n', '0009\n']","['37\n', '90\n', '-1\n']","In the first example the string must be split into numbers 1, 2 and 34.

In the second example the string must be split into numbers 90, 0 and 0. 

In the third example the string is incorrect, because after splitting the string into 3 numbers number 00 or 09 will be obtained, but numbers cannot have leading zeroes.",WRONG_ANSWER,"a=input()
s=len(a)
ans=-1
for i in range(s-2):
	for j in range(i+1,s-1):
		if (i+1>0+1 and a[0]==""0"") or (j+1>i+2 and a[i+1]==""0"") or (s>j+2 and a[j+1]==""0""):
			continue
		ans=max(ans,int(a[0:i+1])+int(a[i+1:j+1])+int(a[j+1:s]))
print(ans)","s = input().split(' ')
s = [int(i) for i in s]
s.sort()

# Check if a non-degenerate triangle can be formed
if s[0] + s[1] > s[2]:
    print(""TRIANGLE"")
# Check if a degenerate triangle can be formed
elif s[0] + s[1] == s[2]:
    print(""SEGMENT"")
# If neither a non-degenerate nor a degenerate triangle can be formed
else:
    print(""IMPOSSIBLE"")"
598,D,Igor In the Museum,PROGRAMMING,"['dfs and similar', 'graphs', 'shortest paths']","Igor is in the museum and he wants to see as many pictures as possible.

Museum can be represented as a rectangular field of *n*<=×<=*m* cells. Each cell is either empty or impassable. Empty cells are marked with '.', impassable cells are marked with '*'. Every two adjacent cells of different types (one empty and one impassable) are divided by a wall containing one picture.

At the beginning Igor is in some empty cell. At every moment he can move to any empty cell that share a side with the current one.

For several starting positions you should calculate the maximum number of pictures that Igor can see. Igor is able to see the picture only if he is in the cell adjacent to the wall with this picture. Igor have a lot of time, so he will examine every picture he can see.","First line of the input contains three integers *n*, *m* and *k* (3<=≤<=*n*,<=*m*<=≤<=1000,<=1<=≤<=*k*<=≤<=*min*(*n*·*m*,<=100<=000)) — the museum dimensions and the number of starting positions to process.

Each of the next *n* lines contains *m* symbols '.', '*' — the description of the museum. It is guaranteed that all border cells are impassable, so Igor can't go out from the museum.

Each of the last *k* lines contains two integers *x* and *y* (1<=≤<=*x*<=≤<=*n*,<=1<=≤<=*y*<=≤<=*m*) — the row and the column of one of Igor's starting positions respectively. Rows are numbered from top to bottom, columns — from left to right. It is guaranteed that all starting positions are empty cells.","Print *k* integers — the maximum number of pictures, that Igor can see if he starts in corresponding position.","['5 6 3\n******\n*..*.*\n******\n*....*\n******\n2 2\n2 5\n4 3\n', '4 4 1\n****\n*..*\n*.**\n****\n3 2\n']","['6\n4\n10\n', '8\n']",none,TIME_LIMIT_EXCEEDED,"def dfs(x, y, n, m, museum, visited):
    if x < 0 or x >= n or y < 0 or y >= m or visited[x][y] or museum[x][y] == '*':
        return 0

    visited[x][y] = True
    pictures = 0

    for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):
        if 0 <= x + dx < n and 0 <= y + dy < m and museum[x + dx][y + dy] == '*':
            pictures += 1
        else:
            pictures += dfs(x + dx, y + dy, n, m, museum, visited)

    return pictures

def igor_in_the_museum(n, m, k, museum, starting_positions):
    results = []
    for x, y in starting_positions:
        visited = [[False] * m for _ in range(n)]
        result = dfs(x - 1, y - 1, n, m, museum, visited)
        results.append(result)

    return results

# Reading input
n, m, k = map(int, input().split())
museum = [input() for _ in range(n)]
starting_positions = [tuple(map(int, input().split())) for _ in range(k)]

# Solving problem
result = igor_in_the_museum(n, m, k, museum, starting_positions)

# Printing output
for num_pictures in result:
    print(num_pictures)
","class Solution:
    def __init__(self):
        self.n = int(input())
        self.a = int(input())

    def solve_and_print(self):
        a = [int(ai) for ai in str(self.a) if int(ai) > 1]
        result = []

        # Replace digits based on their factorial products
        for digit in a:
            if digit == 2:
                result.append(2)
            elif digit == 3:
                result.append(3)
            elif digit == 4:
                result.extend([3, 2, 2])  # 4 -> 3! * 2! * 2!
            elif digit == 5:
                result.append(5)
            elif digit == 6:
                result.extend([5, 3])  # 6 -> 5! * 3!
            elif digit == 7:
                result.append(7)
            elif digit == 8:
                result.extend([7, 2, 2, 2])  # 8 -> 7! * 2! * 2! * 2!
            elif digit == 9:
                result.extend([7, 3, 3, 2])  # 9 -> 7! * 3! * 3! * 2!

        # Sort the result list in descending order to create the largest number
        result.sort(reverse=True)

        # Join the digits to form the final number and print
        print(''.join(map(str, result)))

# Example of how to call and run the Solution class
if __name__ == ""__main__"":
    solution = Solution()
    solution.solve_and_print()"
938,A,Word Correction,PROGRAMMING,['implementation'],"Victor tries to write his own text editor, with word correction included. However, the rules of word correction are really strange.

Victor thinks that if a word contains two consecutive vowels, then it's kinda weird and it needs to be replaced. So the word corrector works in such a way: as long as there are two consecutive vowels in the word, it deletes the first vowel in a word such that there is another vowel right before it. If there are no two consecutive vowels in the word, it is considered to be correct.

You are given a word *s*. Can you predict what will it become after correction?

In this problem letters a, e, i, o, u and y are considered to be vowels.","The first line contains one integer *n* (1<=≤<=*n*<=≤<=100) — the number of letters in word *s* before the correction.

The second line contains a string *s* consisting of exactly *n* lowercase Latin letters — the word before the correction.",Output the word *s* after the correction.,"['5\nweird\n', '4\nword\n', '5\naaeaa\n']","['werd\n', 'word\n', 'a\n']","Explanations of the examples:
 1.  There is only one replace: weird <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> werd;1.  No replace needed since there are no two consecutive vowels;1.  aaeaa <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> aeaa <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> aaa <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> aa <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> a.",OK,"vowels  = ['a', 'e', 'i', 'o', 'u', 'y']

def word_correction(s):
    result = []
    result.append(s[0])
    left = 0
    right = 1
    while right < len(s):
        if not s[left] in vowels or not s[right] in vowels:
            result.append(s[right])
            left = right
        right += 1
    return ''.join(result)
    
n = int(input())
s = input()
print(word_correction(s))","n = int(input())

def isPrime(n):
    if n == 0 or n == 1:
        return False
    i = 2
    while i * i <= n:
        if n % i == 0:
            return False
        i += 1
    return True

def max_divisor(n):
    if n <= 2:
        return 1
    for i in range(n // 2, 0, -1):
        if n % i == 0 and i != n:
            return i
    return 1

# Calculate the minimum tax Mr. Funt has to pay
if isPrime(n):
    print(n - 1)  # If n is prime, the minimum tax is n - 1
else:
    print(max_divisor(n))  # Otherwise, use the max divisor for tax"
218,B,Airport,PROGRAMMING,['implementation'],"Lolek and Bolek are about to travel abroad by plane. The local airport has a special ""Choose Your Plane"" offer. The offer's conditions are as follows:
 -  it is up to a passenger to choose a plane to fly on; -  if the chosen plane has *x* (*x*<=&gt;<=0) empty seats at the given moment, then the ticket for such a plane costs *x* zlotys (units of Polish currency). 
The only ticket office of the airport already has a queue of *n* passengers in front of it. Lolek and Bolek have not stood in the queue yet, but they are already wondering what is the maximum and the minimum number of zlotys the airport administration can earn if all *n* passengers buy tickets according to the conditions of this offer?

The passengers buy tickets in turn, the first person in the queue goes first, then goes the second one, and so on up to *n*-th person.","The first line contains two integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=1000) — the number of passengers in the queue and the number of planes in the airport, correspondingly. The next line contains *m* integers *a*1,<=*a*2,<=...,<=*a**m* (1<=≤<=*a**i*<=≤<=1000) — *a**i* stands for the number of empty seats in the *i*-th plane before the ticket office starts selling tickets.

The numbers in the lines are separated by a space. It is guaranteed that there are at least *n* empty seats in total.","Print two integers — the maximum and the minimum number of zlotys that the airport administration can earn, correspondingly.","['4 3\n2 1 1\n', '4 3\n2 2 2\n']","['5 5\n', '7 6\n']","In the first test sample the number of passengers is equal to the number of empty seats, so regardless of the way the planes are chosen, the administration will earn the same sum.

In the second sample the sum is maximized if the 1-st person in the queue buys a ticket to the 1-st plane, the 2-nd person — to the 2-nd plane, the 3-rd person — to the 3-rd plane, the 4-th person — to the 1-st plane. The sum is minimized if the 1-st person in the queue buys a ticket to the 1-st plane, the 2-nd person — to the 1-st plane, the 3-rd person — to the 2-nd plane, the 4-th person — to the 2-nd plane.",OK,"n, m = map(int,input().split())
l = list(map(int,input().split()))


def g(f):
	A = l[:]; s = 0
	for _ in range(n):
		i = A.index(f(A)); s += A[i]

		if A[i] > 1: A[i] -= 1;
		else:
			A.pop(i)
	return s
print (g(max), g(min))","from collections import defaultdict, deque, Counter
from sys import stdin, stdout
from heapq import heappush, heappop
import math
import io
import os
import math
import bisect

# Function to convert a number to base 7 and return its digits as a set
def convert_to_base_7(num):
    if num == 0:
        return {0}
    digits = set()
    while num > 0:
        digits.add(num % 7)
        num //= 7
    return digits

# Function to count distinct pairs of (hours, minutes) with unique digits
def count_distinct_time(n, m):
    count = 0
    for h in range(n + 1):
        for mi in range(m):
            # Convert hour and minute to base 7
            hour_digits = convert_to_base_7(h)
            minute_digits = convert_to_base_7(mi)
            # Combine digits from hour and minute
            all_digits = hour_digits.union(minute_digits)
            # Check if all digits are unique
            if len(all_digits) == len(hour_digits) + len(minute_digits):
                count += 1
    return count

# Read input values
n, m = map(int, stdin.readline().strip().split())
# Calculate and print the result
result = count_distinct_time(n, m)
stdout.write(str(result) + '\n')"
431,A,Black Square,PROGRAMMING,['implementation'],"Quite recently, a very smart student named Jury decided that lectures are boring, so he downloaded a game called ""Black Square"" on his super cool touchscreen phone.

In this game, the phone's screen is divided into four vertical strips. Each second, a black square appears on some of the strips. According to the rules of the game, Jury must use this second to touch the corresponding strip to make the square go away. As Jury is both smart and lazy, he counted that he wastes exactly *a**i* calories on touching the *i*-th strip.

You've got a string *s*, describing the process of the game and numbers *a*1,<=*a*2,<=*a*3,<=*a*4. Calculate how many calories Jury needs to destroy all the squares?","The first line contains four space-separated integers *a*1, *a*2, *a*3, *a*4 (0<=≤<=*a*1,<=*a*2,<=*a*3,<=*a*4<=≤<=104).

The second line contains string *s* (1<=≤<=|*s*|<=≤<=105), where the *і*-th character of the string equals ""1"", if on the *i*-th second of the game the square appears on the first strip, ""2"", if it appears on the second strip, ""3"", if it appears on the third strip, ""4"", if it appears on the fourth strip.",Print a single integer — the total number of calories that Jury wastes.,"['1 2 3 4\n123214\n', '1 5 3 2\n11221\n']","['13\n', '13\n']",none,OK,"n = list(map(int, input().strip().split()))
m = input()
s = 0
for i in range(len(m)):
    s += n[int(m[i])-1]
print(s)","from decimal import *
import math
import sys

rasp_final = """"

def transformare_baza(numar, baza):
    transformare = """"
    while numar >= baza:
        rest = numar % baza
        numar //= baza
        transformare = str(rest) + transformare
    transformare = str(numar) + transformare
    return transformare

def maximize_number(a, s):
    a_digits = list(a)
    s_digits = sorted(s, reverse=True)  # Sort digits in descending order for maximum value
    j = 0  # Pointer for s_digits

    for i in range(len(a_digits)):
        if j < len(s_digits) and s_digits[j] > a_digits[i]:
            a_digits[i] = s_digits[j]
            j += 1
    
    return ''.join(a_digits)

if __name__ == ""__main__"":
    a = input().strip()  # Read the integer a
    s = input().strip()  # Read the sequence of digits s
    result = maximize_number(a, s)
    print(result)  # Print the maximum value obtained"
719,A,Vitya in the Countryside,PROGRAMMING,['implementation'],"Every summer Vitya comes to visit his grandmother in the countryside. This summer, he got a huge wart. Every grandma knows that one should treat warts when the moon goes down. Thus, Vitya has to catch the moment when the moon is down.

Moon cycle lasts 30 days. The size of the visible part of the moon (in Vitya's units) for each day is 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, and then cycle repeats, thus after the second 1 again goes 0.

As there is no internet in the countryside, Vitya has been watching the moon for *n* consecutive days and for each of these days he wrote down the size of the visible part of the moon. Help him find out whether the moon will be up or down next day, or this cannot be determined by the data he has.","The first line of the input contains a single integer *n* (1<=≤<=*n*<=≤<=92) — the number of consecutive days Vitya was watching the size of the visible part of the moon. 

The second line contains *n* integers *a**i* (0<=≤<=*a**i*<=≤<=15) — Vitya's records.

It's guaranteed that the input data is consistent.","If Vitya can be sure that the size of visible part of the moon on day *n*<=+<=1 will be less than the size of the visible part on day *n*, then print ""DOWN"" at the only line of the output. If he might be sure that the size of the visible part will increase, then print ""UP"". If it's impossible to determine what exactly will happen with the moon, print -1.","['5\n3 4 5 6 7\n', '7\n12 13 14 15 14 13 12\n', '1\n8\n']","['UP\n', 'DOWN\n', '-1\n']","In the first sample, the size of the moon on the next day will be equal to 8, thus the answer is ""UP"".

In the second sample, the size of the moon on the next day will be 11, thus the answer is ""DOWN"".

In the third sample, there is no way to determine whether the size of the moon on the next day will be 7 or 9, thus the answer is -1.",OK,"n=int(input())
l=list(map(int,input().split()))
if n==1 and l[0]!=15 and l[0]!=0 :
    print(-1)
else :
    if l[n-1]==15 :
        print('DOWN')
    if l[n-1]==0 :
        print('UP')
    if l[n-1]!=15 and l[n-1]!=0 and n!=1 :
        if l[n-1]-l[n-2]>0 :
            print('UP')
        else :
            print('DOWN')
        
    

","n = int(input())

def f(n):
    if n == 1 or n == 2:
        return 1
    else:
        return f(n - 1) + f(n - 2)

# Create a set to store Fibonacci positions
fib_positions = set()
i = 1
while True:
    fib_number = f(i)
    if fib_number > n:
        break
    fib_positions.add(fib_number)
    i += 1

# Construct the name based on Fibonacci positions
new_name = ''.join(['O' if j in fib_positions else 'o' for j in range(1, n + 1)])

print(new_name)"
13,A,Numbers,PROGRAMMING,"['implementation', 'math']","Little Petya likes numbers a lot. He found that number 123 in base 16 consists of two digits: the first is 7 and the second is 11. So the sum of digits of 123 in base 16 is equal to 18.

Now he wonders what is an average value of sum of digits of the number *A* written in all bases from 2 to *A*<=-<=1.

Note that all computations should be done in base 10. You should find the result as an irreducible fraction, written in base 10.",Input contains one integer number *A* (3<=≤<=*A*<=≤<=1000).,"Output should contain required average value in format «X/Y», where X is the numerator and Y is the denominator.","['5\n', '3\n']","['7/3\n', '2/1\n']","In the first sample number 5 written in all bases from 2 to 4 looks so: 101, 12, 11. Sums of digits are 2, 3 and 2, respectively.",OK,"N = int(input())
s = 0

def gcd(a, b):
    while(b):
        a, b = b, a%b
    return a

for i in range(2, N):
    n = N
    while(n>0):
        s += n%i
        n = n//i

t = gcd(s, N-2)
print(str(s//t)+""/""+str((N-2)//t))","def max_hamburgers(recipe, nb, ns, nc, pb, ps, pc, r):
    # Count the needed ingredients in the recipe
    count_b = recipe.count('B')
    count_s = recipe.count('S')
    count_c = recipe.count('C')

    # Binary search for the maximum number of hamburgers
    low, high = 0, 10**13  # Start with a large number
    while low < high:
        mid = (low + high + 1) // 2  # Test for (low + high + 1) to avoid infinite loop
        # Calculate the required ingredients for 'mid' hamburgers
        req_b = max(0, mid * count_b - nb)
        req_s = max(0, mid * count_s - ns)
        req_c = max(0, mid * count_c - nc)

        # Calculate the total cost for the required ingredients
        total_cost = req_b * pb + req_s * ps + req_c * pc

        if total_cost <= r:
            low = mid  # Can make 'mid' hamburgers, try for more
        else:
            high = mid - 1  # Can't make 'mid', try less

    return low  # The maximum number of hamburgers

# Input reading
recipe = input().strip()
nb, ns, nc = map(int, input().strip().split())
pb, ps, pc = map(int, input().strip().split())
r = int(input().strip())

# Calculate and print the result
print(max_hamburgers(recipe, nb, ns, nc, pb, ps, pc, r))"
748,A,Santa Claus and a Place in a Class,PROGRAMMING,"['implementation', 'math']","Santa Claus is the first who came to the Christmas Olympiad, and he is going to be the first to take his place at a desk! In the classroom there are *n* lanes of *m* desks each, and there are two working places at each of the desks. The lanes are numbered from 1 to *n* from the left to the right, the desks in a lane are numbered from 1 to *m* starting from the blackboard. Note that the lanes go perpendicularly to the blackboard, not along it (see picture).

The organizers numbered all the working places from 1 to 2*nm*. The places are numbered by lanes (i. e. all the places of the first lane go first, then all the places of the second lane, and so on), in a lane the places are numbered starting from the nearest to the blackboard (i. e. from the first desk in the lane), at each desk, the place on the left is numbered before the place on the right.

Santa Clause knows that his place has number *k*. Help him to determine at which lane at which desk he should sit, and whether his place is on the left or on the right!","The only line contains three integers *n*, *m* and *k* (1<=≤<=*n*,<=*m*<=≤<=10<=000, 1<=≤<=*k*<=≤<=2*nm*) — the number of lanes, the number of desks in each lane and the number of Santa Claus' place.","Print two integers: the number of lane *r*, the number of desk *d*, and a character *s*, which stands for the side of the desk Santa Claus. The character *s* should be ""L"", if Santa Clause should sit on the left, and ""R"" if his place is on the right.","['4 3 9\n', '4 3 24\n', '2 4 4\n']","['2 2 L\n', '4 3 R\n', '1 2 R\n']","The first and the second samples are shown on the picture. The green place corresponds to Santa Claus' place in the first example, the blue place corresponds to Santa Claus' place in the second example.

In the third sample there are two lanes with four desks in each, and Santa Claus has the fourth place. Thus, his place is in the first lane at the second desk on the right.",WRONG_ANSWER,"n,m,k = map(int,input().split())
if k %2  == 0:
    l = 'R'
if k % 2 != 0:
    l = 'L'
if k % (2 * m) != 0:
    p = k // (2 * m) + 1
if k % (2 * m) == 0:
    p = k // (2 * m)
t = (k - (p - 1) * 6) // 2 + (k - (p - 1) * 6) % 2
print(str(p)+' '+str(t)+' '+l)
","def find(a):
    n = 0
    while pow(2, n) <= a:
        n += 1
    return pow(2, n - 1)

def min_moves(n, a):
    results = []
    for k in range(1, n + 1):
        total_moves = 0
        for i in range(k):
            # Calculate moves required for the prefix a[0...k-1]
            total_moves += (a[i] + find(a[i]) - 1) // find(a[i])
        results.append(total_moves)
    return results

# Input reading
n = int(input())
a = list(map(int, input().split()))

# Get minimum moves for each k
results = min_moves(n, a)

# Output results
for result in results:
    print(result)"
245,H,Queries for Number of Palindromes,PROGRAMMING,"['dp', 'hashing', 'strings']","You've got a string *s*<==<=*s*1*s*2... *s*|*s*| of length |*s*|, consisting of lowercase English letters. There also are *q* queries, each query is described by two integers *l**i*,<=*r**i* (1<=≤<=*l**i*<=≤<=*r**i*<=≤<=|*s*|). The answer to the query is the number of substrings of string *s*[*l**i*... *r**i*], which are palindromes.

String *s*[*l*... *r*]<==<=*s**l**s**l*<=+<=1... *s**r* (1<=≤<=*l*<=≤<=*r*<=≤<=|*s*|) is a substring of string *s*<==<=*s*1*s*2... *s*|*s*|.

String *t* is called a palindrome, if it reads the same from left to right and from right to left. Formally, if *t*<==<=*t*1*t*2... *t*|*t*|<==<=*t*|*t*|*t*|*t*|<=-<=1... *t*1.","The first line contains string *s* (1<=≤<=|*s*|<=≤<=5000). The second line contains a single integer *q* (1<=≤<=*q*<=≤<=106) — the number of queries. Next *q* lines contain the queries. The *i*-th of these lines contains two space-separated integers *l**i*,<=*r**i* (1<=≤<=*l**i*<=≤<=*r**i*<=≤<=|*s*|) — the description of the *i*-th query.

It is guaranteed that the given string consists only of lowercase English letters.","Print *q* integers — the answers to the queries. Print the answers in the order, in which the queries are given in the input. Separate the printed numbers by whitespaces.",['caaaba\n5\n1 1\n1 4\n2 3\n4 6\n4 5\n'],['1\n7\n3\n4\n2\n'],"Consider the fourth query in the first test case. String *s*[4... 6] = «aba». Its palindrome substrings are: «a», «b», «a», «aba».",TIME_LIMIT_EXCEEDED,"def checkPalindrome(a):
    if(a == a[::-1]):
        return True 
    else: return False
    
def countPalindrome(a):
    count = 0
    for i in range(len(a)):
        count-=1
        for j in range(i,len(a)+1):
            if(checkPalindrome(a[i:j])):
                count = count + 1
#                print(count,' ',a[i:j])
    return count    

        
string = input('')
n = int(input(''))
queries = []

for i in range(n):
    que = input().split(' ')
    queries.append(que)
    
for i in range(n):
    print(countPalindrome(string[int(queries[i][0])-1:int(queries[i][1])]))
","import sys
import threading
sys.setrecursionlimit(10**5)
threading.stack_size(1 << 27)
input=sys.stdin.readline

MOD = 1000000007

def count_good_sequences(n, k):
    # dp[i][j] will store the number of good sequences of length j that end with i
    dp = [[0] * (k + 1) for _ in range(n + 1)]

    # Initialize for sequences of length 1
    for i in range(1, n + 1):
        dp[i][1] = 1

    # Build the dp table
    for length in range(2, k + 1):  # length of the sequence
        for last in range(1, n + 1):  # last element in the sequence
            for multiple in range(last, n + 1, last):  # multiples of last
                dp[multiple][length] = (dp[multiple][length] + dp[last][length - 1]) % MOD

    # Sum up all good sequences of length k
    result = sum(dp[i][k] for i in range(1, n + 1)) % MOD
    return result

def main():
    n, k = map(int, input().split())
    print(count_good_sequences(n, k))

if __name__ == ""__main__"":
    main()"
58,A,Chat room,PROGRAMMING,"['greedy', 'strings']","Vasya has recently learned to type and log on to the Internet. He immediately entered a chat room and decided to say hello to everybody. Vasya typed the word *s*. It is considered that Vasya managed to say hello if several letters can be deleted from the typed word so that it resulted in the word ""hello"". For example, if Vasya types the word ""ahhellllloou"", it will be considered that he said hello, and if he types ""hlelo"", it will be considered that Vasya got misunderstood and he didn't manage to say hello. Determine whether Vasya managed to say hello by the given word *s*.","The first and only line contains the word *s*, which Vasya typed. This word consisits of small Latin letters, its length is no less that 1 and no more than 100 letters.","If Vasya managed to say hello, print ""YES"", otherwise print ""NO"".","['ahhellllloou\n', 'hlelo\n']","['YES\n', 'NO\n']",none,OK,"w=input()
a=""hello""
s=""""
c=0
for i in w:
    if i == a[c]:
        c+=1
        s+=i
        if c==5:
            break
if s==a:
    print(""YES"")
else:
    print(""NO"")","def II():
    return(int(input()))

def LMI():
    return(list(map(int,input().split())))

def I():
    return(input())

def MII():
    return(map(int,input().split()))

def count_trailing_zeros(x):
    """""" Count the number of trailing zeros in x! by finding the powers of 5. """"""
    count = 0
    while x > 0:
        x //= 5
        count += x
    return count

def count_factors(num):
    """""" Count the factors of 2 and 5 in num. """"""
    count2 = 0
    count5 = 0
    while num % 2 == 0 and num > 0:
        count2 += 1
        num //= 2
    while num % 5 == 0 and num > 0:
        count5 += 1
        num //= 5
    return count2, count5

n = II()
matrix = [LMI() for _ in range(n)]

# Initialize a DP table to store the minimum trailing zeros
dp = [[(float('inf'), float('inf'))] * n for _ in range(n)]  
dp[0][0] = count_factors(matrix[0][0])

# Fill the DP table
for i in range(n):
    for j in range(n):
        if matrix[i][j] == 0:
            continue  # Skip zeros as they don't contribute to the count

        factor2, factor5 = count_factors(matrix[i][j])

        if i > 0:  # Coming from above
            dp[i][j] = min(dp[i][j], (dp[i-1][j][0] + factor2, dp[i-1][j][1] + factor5))
        if j > 0:  # Coming from left
            dp[i][j] = min(dp[i][j], (dp[i][j-1][0] + factor2, dp[i][j-1][1] + factor5))

# The answer is the minimum trailing zeros from bottom right cell
min_trailing_zeros = min(dp[n-1][n-1])
print(min_trailing_zeros)

# To reconstruct the path
path = []
i, j = n - 1, n - 1

while i > 0 or j > 0:
    path.append((i + 1, j + 1))  # Store 1-based indexing
    if i > 0 and dp[i][j] == (dp[i-1][j][0] + count_factors(matrix[i][j])[0], dp[i-1][j][1] + count_factors(matrix[i][j])[1]):
        i -= 1
    else:
        j -= 1

path.append((1, 1))  # Start point
path.reverse()  # Reverse to get the path from start to end

for p in path:
    print(p)"
96,A,Football,PROGRAMMING,"['implementation', 'strings']","Petya loves football very much. One day, as he was watching a football match, he was writing the players' current positions on a piece of paper. To simplify the situation he depicted it as a string consisting of zeroes and ones. A zero corresponds to players of one team; a one corresponds to players of another team. If there are at least 7 players of some team standing one after another, then the situation is considered dangerous. For example, the situation 00100110111111101 is dangerous and 11110111011101 is not. You are given the current situation. Determine whether it is dangerous or not.","The first input line contains a non-empty string consisting of characters ""0"" and ""1"", which represents players. The length of the string does not exceed 100 characters. There's at least one player from each team present on the field.","Print ""YES"" if the situation is dangerous. Otherwise, print ""NO"".","['001001\n', '1000000001\n']","['NO\n', 'YES\n']",none,RUNTIME_ERROR,"
l=int(input())
x=list(map(int,str(l)))
c=0

for i in x:
    
    if i==x[i+2]:
        c=c+1
    else:
        c=c
if c>=7:
    print(""YES"")
else:
    print(""NO"")


        
    

    
","def main():
    y, w = [int(x) for x in input().split()]  # Read Yakko's and Wakko's scores
    temp = max(y, w)  # Determine the maximum score between Yakko and Wakko
    ans = 7 - temp  # Calculate how many outcomes (4, 5, 6) can lead to Dot's victory

    # Determine the irreducible fraction for the probability
    from math import gcd
    numerator = ans  # Successful outcomes for Dot
    denominator = 6  # Total possible outcomes on a six-sided die

    # Reduce the fraction:
    common_divisor = gcd(numerator, denominator)
    numerator //= common_divisor
    denominator //= common_divisor

    # Output the result in the required format
    print(f""{numerator}/{denominator}"")

main()"
169,A,Chores,PROGRAMMING,['sortings'],"Petya and Vasya are brothers. Today is a special day for them as their parents left them home alone and commissioned them to do *n* chores. Each chore is characterized by a single parameter — its complexity. The complexity of the *i*-th chore equals *h**i*.

As Petya is older, he wants to take the chores with complexity larger than some value *x* (*h**i*<=&gt;<=*x*) to leave to Vasya the chores with complexity less than or equal to *x* (*h**i*<=≤<=*x*). The brothers have already decided that Petya will do exactly *a* chores and Vasya will do exactly *b* chores (*a*<=+<=*b*<==<=*n*).

In how many ways can they choose an integer *x* so that Petya got exactly *a* chores and Vasya got exactly *b* chores?","The first input line contains three integers *n*,<=*a* and *b* (2<=≤<=*n*<=≤<=2000; *a*,<=*b*<=≥<=1; *a*<=+<=*b*<==<=*n*) — the total number of chores, the number of Petya's chores and the number of Vasya's chores.

The next line contains a sequence of integers *h*1,<=*h*2,<=...,<=*h**n* (1<=≤<=*h**i*<=≤<=109), *h**i* is the complexity of the *i*-th chore. The numbers in the given sequence are not necessarily different.

All numbers on the lines are separated by single spaces.","Print the required number of ways to choose an integer value of *x*. If there are no such ways, print 0.","['5 2 3\n6 2 3 100 1\n', '7 3 4\n1 1 9 1 1 1 1\n']","['3\n', '0\n']","In the first sample the possible values of *x* are 3, 4 or 5.

In the second sample it is impossible to find such *x*, that Petya got 3 chores and Vasya got 4.",OK,"n,a,b= map(int,input().split())
x = list(map(int,input().split()))
x.sort()
print(x[b]-x[b-1])","def can_pass_all_levels(n, p_levels, q_levels):
    levels = [False] * n

    for level in p_levels:
        levels[level - 1] = True

    for level in q_levels:
        levels[level - 1] = True

    if all(levels):
        return ""I become the guy.""
    else:
        return ""Oh, my keyboard!""

# Input reading
n = int(input())
p_data = list(map(int, input().split()))
p = p_data[0]
p_levels = p_data[1:p + 1]
q_data = list(map(int, input().split()))
q = q_data[0]
q_levels = q_data[1:q + 1]

# Output the result
print(can_pass_all_levels(n, p_levels, q_levels))"
131,A,cAPS lOCK,PROGRAMMING,"['implementation', 'strings']","wHAT DO WE NEED cAPS LOCK FOR?

Caps lock is a computer keyboard key. Pressing it sets an input mode in which typed letters are capital by default. If it is pressed by accident, it leads to accidents like the one we had in the first passage. 

Let's consider that a word has been typed with the Caps lock key accidentally switched on, if: 
 -  either it only contains uppercase letters; -  or all letters except for the first one are uppercase. 
In this case we should automatically change the case of all letters. For example, the case of the letters that form words ""hELLO"", ""HTTP"", ""z"" should be changed.

Write a program that applies the rule mentioned above. If the rule cannot be applied, the program should leave the word unchanged.","The first line of the input data contains a word consisting of uppercase and lowercase Latin letters. The word's length is from 1 to 100 characters, inclusive.",Print the result of the given word's processing.,"['cAPS\n', 'Lock\n']","['Caps', 'Lock\n']",none,WRONG_ANSWER,"s = input()
ok = True
for i in range(1,len(s)):
    if ord('A') <= ord(s[i]) <= ord('Z'):
        ok = False
if not ok:
    for c in s:
        if ord('a') <= ord(c) <= ord('z'): #小写字母
            print (chr(ord(c)-(ord('a')-ord('A'))),end='')
        else:
            print (chr(ord(c)+(ord('a')-ord('A'))),end='')
else:
    print(s)

  		 			  	   										    	 	","from collections import Counter

def isPalindrome(s):
    return s == s[::-1]

def canFormPalindrome(s):
    # Count the frequency of each character
    char_count = Counter(s)
    # Count how many characters have an odd frequency
    odd_count = sum(1 for count in char_count.values() if count % 2 != 0)
    # A string can form a palindrome if at most one character has an odd count
    return odd_count <= 1

def determine_winner(s):
    if canFormPalindrome(s):
        return ""First""
    else:
        # Calculate the length of the string
        length = len(s)
        # If the length is odd, player one can win by removing one character
        # If the length is even, player two will win because player one cannot force a win
        return ""First"" if length % 2 == 1 else ""Second""

# Read input
s = input().strip()
# Output the winner
print(determine_winner(s))"
443,A,Anton and Letters,PROGRAMMING,"['constructive algorithms', 'implementation']","Recently, Anton has found a set. The set consists of small English letters. Anton carefully wrote out all the letters from the set in one line, separated by a comma. He also added an opening curved bracket at the beginning of the line and a closing curved bracket at the end of the line. 

Unfortunately, from time to time Anton would forget writing some letter and write it again. He asks you to count the total number of distinct letters in his set.","The first and the single line contains the set of letters. The length of the line doesn't exceed 1000. It is guaranteed that the line starts from an opening curved bracket and ends with a closing curved bracket. Between them, small English letters are listed, separated by a comma. Each comma is followed by a space.",Print a single number — the number of distinct letters in Anton's set.,"['{a, b, c}\n', '{b, a, b, a}\n', '{}\n']","['3\n', '2\n', '0\n']",none,OK,"s = input()
print(len(set(s.lstrip(""{"").rstrip(""}"").split("", ""))) if s != ""{}"" else 0)
","def main():
    mode = ""filee""
    if mode == ""file"":
        f = open(""test.txt"", ""r"")

    get = lambda: [str(x) for x in (f.readline()[:-1] if mode == ""file"" else input()).split(""|"")]
    scale = get()
    
    left = scale[0]  # Weights on the left pan
    right = scale[1]  # Weights on the right pan
    weights = input().strip()  # Unused weights

    left_len = len(left)  # Initial left weights count
    right_len = len(right)  # Initial right weights count
    total_weights = len(weights)  # Total unused weights

    # Calculate the difference
    difference = left_len - right_len

    # Determine how many weights are needed to balance the scales
    if difference > 0:
        # Left is heavier, add to right
        needed = difference
        if needed > total_weights:
            print(""Impossible"")
            return
        right += weights[:needed]
        weights = weights[needed:]
    elif difference < 0:
        # Right is heavier, add to left
        needed = -difference
        if needed > total_weights:
            print(""Impossible"")
            return
        left += weights[:needed]
        weights = weights[needed:]

    # After adjusting, we need to check if any weights are left
    if weights:
        # We can add the remaining weights to any side
        left += weights

    print(f""{left}|{right}"")

if __name__ == ""__main__"":
    main()"
431,A,Black Square,PROGRAMMING,['implementation'],"Quite recently, a very smart student named Jury decided that lectures are boring, so he downloaded a game called ""Black Square"" on his super cool touchscreen phone.

In this game, the phone's screen is divided into four vertical strips. Each second, a black square appears on some of the strips. According to the rules of the game, Jury must use this second to touch the corresponding strip to make the square go away. As Jury is both smart and lazy, he counted that he wastes exactly *a**i* calories on touching the *i*-th strip.

You've got a string *s*, describing the process of the game and numbers *a*1,<=*a*2,<=*a*3,<=*a*4. Calculate how many calories Jury needs to destroy all the squares?","The first line contains four space-separated integers *a*1, *a*2, *a*3, *a*4 (0<=≤<=*a*1,<=*a*2,<=*a*3,<=*a*4<=≤<=104).

The second line contains string *s* (1<=≤<=|*s*|<=≤<=105), where the *і*-th character of the string equals ""1"", if on the *i*-th second of the game the square appears on the first strip, ""2"", if it appears on the second strip, ""3"", if it appears on the third strip, ""4"", if it appears on the fourth strip.",Print a single integer — the total number of calories that Jury wastes.,"['1 2 3 4\n123214\n', '1 5 3 2\n11221\n']","['13\n', '13\n']",none,OK,"
a = []
a = [int(item) for item in input().split()]    # fill the list with numbers
s = input()   # take the string
x = len(s)
result = 0
for i in range(x):

    if s[i]=='1':
        result+=a[0]
    elif s[i]== '2' :
        result += a[1]
    elif s[i] == '3' :
        result += a[2]
    elif s[i] == '4' :
        result += a[3]

print (result)

# problem_link : https://codeforces.com/contest/431/problem/A
","def calc_hours(a, b):
    hours = a  # Initialize total burning hours with the initial candles
    while a >= 1:  # While there is at least one candle to burn
        new_candles = a // b  # Calculate how many new candles can be made
        hours += new_candles  # Add the new candles burning time to total hours
        a = new_candles + (a % b)  # Update the count of candles left (new + remaining)
    return hours  # Return the total hours of burning

# Example usage
a, b = map(int, input().split())
print(calc_hours(a, b))"
215,A,Bicycle Chain,PROGRAMMING,"['brute force', 'implementation']","Vasya's bicycle chain drive consists of two parts: *n* stars are attached to the pedal axle, *m* stars are attached to the rear wheel axle. The chain helps to rotate the rear wheel by transmitting the pedal rotation.

We know that the *i*-th star on the pedal axle has *a**i* (0<=&lt;<=*a*1<=&lt;<=*a*2<=&lt;<=...<=&lt;<=*a**n*) teeth, and the *j*-th star on the rear wheel axle has *b**j* (0<=&lt;<=*b*1<=&lt;<=*b*2<=&lt;<=...<=&lt;<=*b**m*) teeth. Any pair (*i*,<=*j*) (1<=≤<=*i*<=≤<=*n*; 1<=≤<=*j*<=≤<=*m*) is called a gear and sets the indexes of stars to which the chain is currently attached. Gear (*i*,<=*j*) has a gear ratio, equal to the value .

Since Vasya likes integers, he wants to find such gears (*i*,<=*j*), that their ratios are integers. On the other hand, Vasya likes fast driving, so among all ""integer"" gears (*i*,<=*j*) he wants to choose a gear with the maximum ratio. Help him to find the number of such gears.

In the problem, fraction  denotes division in real numbers, that is, no rounding is performed.","The first input line contains integer *n* (1<=≤<=*n*<=≤<=50) — the number of stars on the bicycle's pedal axle. The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=104) in the order of strict increasing.

The third input line contains integer *m* (1<=≤<=*m*<=≤<=50) — the number of stars on the rear wheel axle. The fourth line contains *m* integers *b*1,<=*b*2,<=...,<=*b**m* (1<=≤<=*b**i*<=≤<=104) in the order of strict increasing.

It is guaranteed that there exists at least one gear (*i*,<=*j*), that its gear ratio is an integer. The numbers on the lines are separated by spaces.","Print the number of ""integer"" gears with the maximum ratio among all ""integer"" gears.","['2\n4 5\n3\n12 13 15\n', '4\n1 2 3 4\n5\n10 11 12 13 14\n']","['2\n', '1\n']","In the first sample the maximum ""integer"" gear ratio equals 3. There are two gears that have such gear ratio. For one of them *a*<sub class=""lower-index"">1</sub> = 4, *b*<sub class=""lower-index"">1</sub> = 12, and for the other *a*<sub class=""lower-index"">2</sub> = 5, *b*<sub class=""lower-index"">3</sub> = 15.",COMPILATION_ERROR,"﻿#include <iostream>
#include <string>
#include <algorithm>
#include <vector>
#include <string>
#include <math.h>
#define ll long long
#define pl pair<ll, ll>
#define itp pair<vector<int>::iterator, vector<int>::iterator>
#define mp make_pair
#define f first
#define s second
const ll MOD = (ll)(pow(10, 9) + 7);

using namespace std;

ll dist(ll a, ll b, ll n) {
	if (a == b)
	{
		return 0;
	}
	if (b < a)
	{
		return n - a + b;
	}
	else {
		return b - a;
	}
}


int main() {
	ll n, m;
	cin >> n;
	vector <ll> A(n);
	for (int i = 0; i < n; i++) {
		cin >> A[i];
	}
	cin >> m;
	vector<ll> B(m);
	for (int i = 0; i < m; i++) {
		cin >> B[i];
	}
	ll k = 0;
	ll x = 0;
	for (int i = 0; i < m; i++) {
		for (int j = 0; j < n; j++) {
			if (B[i] % A[j] == 0)
				x = max(B[i] / A[j], x);
		}
	}
	for (int i = 0; i < m; i++) {
		for (int j = 0; j < n; j++) {
			if (B[i] % A[j] == 0)
				if (B[i] / A[j] == x)
					k++;
		}
	}
	cout << k;
}","import sys

def count_ones(n, l, r):
    def split(list1):
        for i in range(len(list1)):
            if list1[i] > 1:
                # Split the number into two numbers, x//2 and x//2 + x%2
                x = list1[i]
                list1[i:i+1] = [x // 2, x // 2 + x % 2]  # Replace x with its halves
                # Since we modified the list, we recursively call split for any new numbers
                split(list1)
                break  # Only split one element at a time

    # Start with a list that contains the initial element n
    final_list = [n]
    split(final_list)  # Perform the splitting operation until the list only contains 0s and 1s

    # Count number of ones in the range from l to r (1-indexed)
    count = 0
    for i in range(l-1, r):  # Adjust for 0-indexed Python lists
        if final_list[i] == 1:
            count += 1
    
    return count

# Read input
n, l, r = map(int, sys.stdin.readline().split())
print(count_ones(n, l, r))"
221,A,Little Elephant and Function,PROGRAMMING,"['implementation', 'math']","The Little Elephant enjoys recursive functions.

This time he enjoys the sorting function. Let *a* is a permutation of an integers from 1 to *n*, inclusive, and *a**i* denotes the *i*-th element of the permutation. The Little Elephant's recursive function *f*(*x*), that sorts the first *x* permutation's elements, works as follows:
 -  If *x*<==<=1, exit the function. -  Otherwise, call *f*(*x*<=-<=1), and then make *swap*(*a**x*<=-<=1,<=*a**x*) (swap the *x*-th and (*x*<=-<=1)-th elements of *a*). 
The Little Elephant's teacher believes that this function does not work correctly. But that-be do not get an F, the Little Elephant wants to show the performance of its function. Help him, find a permutation of numbers from 1 to *n*, such that after performing the Little Elephant's function (that is call *f*(*n*)), the permutation will be sorted in ascending order.",A single line contains integer *n* (1<=≤<=*n*<=≤<=1000) — the size of permutation.,"In a single line print *n* distinct integers from 1 to *n* — the required permutation. Numbers in a line should be separated by spaces.

It is guaranteed that the answer exists.","['1\n', '2\n']","['1 ', '2 1 ']",none,WRONG_ANSWER,"n=int(input())
for i in range(2,n+1):
    print(i,' ',end='')

print(1)","def is_palindrome(s):
    for i in range(len(s) // 2):
        if s[i] != s[~i]:
            return False
    return True


def max_anti(s, visited):
    # If the entire string is a palindrome, we need to check for non-palindrome substrings
    if is_palindrome(s):
        # If all characters in the string are the same, all substrings will also be palindromes
        if all(c == s[0] for c in s):
            return 0
        else:
            # We can take the full string minus one character to ensure it's not a palindrome
            return len(s) - 1
    
    # If the string is not a palindrome, the maximum length substring is the whole string
    return len(s)


# Read input string
s = input().strip()
# Output the result
print(max_anti(s, []))"
712,A,Memory and Crow,PROGRAMMING,"['implementation', 'math']","There are *n* integers *b*1,<=*b*2,<=...,<=*b**n* written in a row. For all *i* from 1 to *n*, values *a**i* are defined by the crows performing the following procedure:
 -  The crow sets *a**i* initially 0. -  The crow then adds *b**i* to *a**i*, subtracts *b**i*<=+<=1, adds the *b**i*<=+<=2 number, and so on until the *n*'th number. Thus, *a**i*<==<=*b**i*<=-<=*b**i*<=+<=1<=+<=*b**i*<=+<=2<=-<=*b**i*<=+<=3.... 
Memory gives you the values *a*1,<=*a*2,<=...,<=*a**n*, and he now wants you to find the initial numbers *b*1,<=*b*2,<=...,<=*b**n* written in the row? Can you do it?","The first line of the input contains a single integer *n* (2<=≤<=*n*<=≤<=100<=000) — the number of integers written in the row.

The next line contains *n*, the *i*'th of which is *a**i* (<=-<=109<=≤<=*a**i*<=≤<=109) — the value of the *i*'th number.","Print *n* integers corresponding to the sequence *b*1,<=*b*2,<=...,<=*b**n*. It's guaranteed that the answer is unique and fits in 32-bit integer type.","['5\n6 -4 8 -2 3\n', '5\n3 -2 -1 5 6\n']","['2 4 6 1 3 \n', '1 -3 4 11 6 \n']","In the first sample test, the crows report the numbers 6, - 4, 8, - 2, and 3 when he starts at indices 1, 2, 3, 4 and 5 respectively. It is easy to check that the sequence 2 4 6 1 3 satisfies the reports. For example, 6 = 2 - 4 + 6 - 1 + 3, and  - 4 = 4 - 6 + 1 - 3.

In the second sample test, the sequence 1,  - 3, 4, 11, 6 satisfies the reports. For example, 5 = 11 - 6 and 6 = 6.",OK,"n=int(input())
v=[int(i) for i in input().split()]
b=[v[i]+v[i+1] for i in range(n-1)]
b.append(v[-1])
for i in range(n):
    print(b[i],end="" "")
","inp = input()
sum_inp = int(inp.split("" "")[0])
k = int(inp.split("" "")[1])

def solve():
    # Check if the minimum sum needed for k elements is greater than sum_inp
    if (k * (k + 1)) // 2 > sum_inp:
        return -1

    # Calculate the remaining sum after using the smallest k distinct positive integers
    remaining_sum = sum_inp - (k * (k + 1)) // 2

    # The gcd we can use is the largest number that divides the remaining sum
    gcd = remaining_sum // k + 1

    # Create the result sequence
    result = [(i + gcd) for i in range(1, k + 1)]

    return result

result = solve()
if result == -1:
    print(-1)
else:
    print("" "".join(map(str, result)))"
990,B,Micro-World,PROGRAMMING,"['greedy', 'sortings']","You have a Petri dish with bacteria and you are preparing to dive into the harsh micro-world. But, unfortunately, you don't have any microscope nearby, so you can't watch them.

You know that you have $n$ bacteria in the Petri dish and size of the $i$-th bacteria is $a_i$. Also you know intergalactic positive integer constant $K$.

The $i$-th bacteria can swallow the $j$-th bacteria if and only if $a_i &gt; a_j$ and $a_i \le a_j + K$. The $j$-th bacteria disappear, but the $i$-th bacteria doesn't change its size. The bacteria can perform multiple swallows. On each swallow operation any bacteria $i$ can swallow any bacteria $j$ if $a_i &gt; a_j$ and $a_i \le a_j + K$. The swallow operations go one after another.

For example, the sequence of bacteria sizes $a=[101, 53, 42, 102, 101, 55, 54]$ and $K=1$. The one of possible sequences of swallows is: $[101, 53, 42, 102, \underline{101}, 55, 54]$ $\to$ $[101, \underline{53}, 42, 102, 55, 54]$ $\to$ $[\underline{101}, 42, 102, 55, 54]$ $\to$ $[42, 102, 55, \underline{54}]$ $\to$ $[42, 102, 55]$. In total there are $3$ bacteria remained in the Petri dish.

Since you don't have a microscope, you can only guess, what the minimal possible number of bacteria can remain in your Petri dish when you finally will find any microscope.","The first line contains two space separated positive integers $n$ and $K$ ($1 \le n \le 2 \cdot 10^5$, $1 \le K \le 10^6$) — number of bacteria and intergalactic constant $K$.

The second line contains $n$ space separated integers $a_1, a_2, \dots, a_n$ ($1 \le a_i \le 10^6$) — sizes of bacteria you have.",Print the only integer — minimal possible number of bacteria can remain.,"['7 1\n101 53 42 102 101 55 54\n', '6 5\n20 15 10 15 20 25\n', '7 1000000\n1 1 1 1 1 1 1\n']","['3\n', '1\n', '7\n']","The first example is clarified in the problem statement.

In the second example an optimal possible sequence of swallows is: $[20, 15, 10, 15, \underline{20}, 25]$ $\to$ $[20, 15, 10, \underline{15}, 25]$ $\to$ $[20, 15, \underline{10}, 25]$ $\to$ $[20, \underline{15}, 25]$ $\to$ $[\underline{20}, 25]$ $\to$ $[25]$.

In the third example no bacteria can swallow any other bacteria.",OK,"n ,k = map(int,input().split())
a = list(map(int,input().split()))
a.sort()
out = 0
i = 0
for j in range(n):
    while(i+1 < n and a[j] == a[i]):
        i += 1
    if a[j] < a[i] and a[j] + k >= a[i]:
        out += 1
print(n-out)
            ","def find(arr1, elem, i):
    if arr1[i][0] == elem:
        return i
    else:
        return find(arr1, elem, arr1[i][0])

# Read the number of knights and the maximum kills
[n, k] = map(int, input().split())

# Read the powers of the knights
powers = list(map(int, input().split()))

# Read the coins of the knights
coins = list(map(int, input().split()))

# Create a list of knights with their power, index, and coins
knights = [(powers[i], i, coins[i]) for i in range(n)]

# Sort knights based on power to ease the kill process
knights.sort()

# Initialize results list to store maximum coins for each knight
max_coins = [0] * n

# Process each knight to calculate maximum coins they can have
for i in range(n):
    power, index, coin = knights[i]
    # Start with their own coins
    total_coins = coin
    
    # Collect coins from at most k weaker knights
    for j in range(max(0, i - k), i):
        total_coins += knights[j][2]  # Add coins of the knight being killed
    
    max_coins[index] = total_coins  # Store result in original order

# Print the results
print(' '.join(map(str, max_coins)))"
82,A,Double Cola,PROGRAMMING,"['implementation', 'math']","Sheldon, Leonard, Penny, Rajesh and Howard are in the queue for a ""Double Cola"" drink vending machine; there are no other people in the queue. The first one in the queue (Sheldon) buys a can, drinks it and doubles! The resulting two Sheldons go to the end of the queue. Then the next in the queue (Leonard) buys a can, drinks it and gets to the end of the queue as two Leonards, and so on. This process continues ad infinitum.

For example, Penny drinks the third can of cola and the queue will look like this: Rajesh, Howard, Sheldon, Sheldon, Leonard, Leonard, Penny, Penny.

Write a program that will print the name of a man who will drink the *n*-th can.

Note that in the very beginning the queue looks like that: Sheldon, Leonard, Penny, Rajesh, Howard. The first person is Sheldon.","The input data consist of a single integer *n* (1<=≤<=*n*<=≤<=109).

It is guaranteed that the pretests check the spelling of all the five names, that is, that they contain all the five possible answers.","Print the single line — the name of the person who drinks the *n*-th can of cola. The cans are numbered starting from 1. Please note that you should spell the names like this: ""Sheldon"", ""Leonard"", ""Penny"", ""Rajesh"", ""Howard"" (without the quotes). In that order precisely the friends are in the queue initially.","['1\n', '6\n', '1802\n']","['Sheldon\n', 'Sheldon\n', 'Penny\n']",none,WRONG_ANSWER,"def find_person(n):
    queue = [""Sheldon"", ""Leonard"", ""Penny"", ""Rajesh"", ""Howard""]
    i = 0  

    while n > len(queue):
        n -= len(queue)
        queue += [queue[i], queue[i]]
        i += 1
    
    return queue[(n - 1) // (len(queue) // 5)]

n = int(input())

result = find_person(n)

print(result)

","s = input().strip()
n = len(s)
tail = [0] * 26
f = [0] * n

# Initialize the last index of each character in the alphabet
for i in range(n):
    if s[i] >= 'a' and s[i] <= 'z':
        tail[ord(s[i]) - ord('a')] = i + 1

# Attempt to build the result string with 'a' to 'z' as a subsequence
result = []
current_char = 0

for i in range(n):
    # Check if we can replace the current character with target character
    while current_char < 26 and (s[i] == chr(ord('a') + current_char) or s[i] < chr(ord('a') + current_char)):
        result.append(chr(ord('a') + current_char))
        current_char += 1
        if current_char == 26:
            break
    
    # If we have already formed the full subsequence, break early
    if current_char == 26:
        break

# If we couldn't form the entire alphabet, return -1
if current_char < 26:
    print(-1)
else:
    # Fill the remainder of the result with the current string
    for j in range(i + 1, n):
        result.append(s[j])
    
    print(''.join(result))"
808,A,Lucky Year,PROGRAMMING,['implementation'],"Apart from having lots of holidays throughout the year, residents of Berland also have whole lucky years. Year is considered lucky if it has no more than 1 non-zero digit in its number. So years 100, 40000, 5 are lucky and 12, 3001 and 12345 are not.

You are given current year in Berland. Your task is to find how long will residents of Berland wait till the next lucky year.",The first line contains integer number *n* (1<=≤<=*n*<=≤<=109) — current year in Berland.,Output amount of years from the current year to the next lucky one.,"['4\n', '201\n', '4000\n']","['1\n', '99\n', '1000\n']",In the first example next lucky year is 5. In the second one — 300. In the third — 5000.,OK,"n=int(input())
s=str(n)
r=int(s[0])+1
ss=str(r)+'0'*(len(s)-1)
ss=int(ss)
print(ss-n)
","def computeLPS(pat):
    m = len(pat)
    i, j = 1, 0
    lps = [0 for i in range(m)]
    
    while i < m:
        if pat[i] == pat[j]:
            j += 1
            lps[i] = j
            i += 1
        else:
            if j != 0:
                j = lps[j - 1]
            else:
                lps[i] = 0
                i += 1
    return lps

def count_segments(n, w, bears_wall, elephant_wall):
    # Create the LPS array for elephant's wall
    lps = computeLPS(elephant_wall)
    i, j = 0, 0
    count = 0

    while i < n:
        if elephant_wall[j] == bears_wall[i]:
            i += 1
            j += 1
        
        if j == w:
            # Found a segment where Horace can see his elephant
            count += 1
            j = lps[j - 1]  # Reset j according to LPS array
        
        elif i < n and elephant_wall[j] != bears_wall[i]:
            if j != 0:
                j = lps[j - 1]
            else:
                i += 1
    
    return count

# Input read and function call
n, w = map(int, input().split())
bears_wall = list(map(int, input().split()))
elephant_wall = list(map(int, input().split()))

# Print the result
print(count_segments(n, w, bears_wall, elephant_wall))"
761,A,Dasha and Stairs,PROGRAMMING,"['brute force', 'constructive algorithms', 'implementation', 'math']","On her way to programming school tiger Dasha faced her first test — a huge staircase!

The steps were numbered from one to infinity. As we know, tigers are very fond of all striped things, it is possible that it has something to do with their color. So on some interval of her way she calculated two values — the number of steps with even and odd numbers. 

You need to check whether there is an interval of steps from the *l*-th to the *r*-th (1<=≤<=*l*<=≤<=*r*), for which values that Dasha has found are correct.","In the only line you are given two integers *a*, *b* (0<=≤<=*a*,<=*b*<=≤<=100) — the number of even and odd steps, accordingly.","In the only line print ""YES"", if the interval of steps described above exists, and ""NO"" otherwise.","['2 3\n', '3 1\n']","['YES\n', 'NO\n']","In the first example one of suitable intervals is from 1 to 5. The interval contains two even steps — 2 and 4, and three odd: 1, 3 and 5.",OK,"n,m=map(int,input().split())
z=abs(n-m)
if((z==0 and n!=0) or z==1):
    print(""YES"")
else:
    print(""NO"")
","import sys

def get_ints(): return [int(x) for x in sys.stdin.readline().strip().split()]
def get_string(): return sys.stdin.readline().strip()

# Read the binary code representing the encrypted password
encrypted_password = get_string()

# Create a mapping to store the binary representation for each digit
binary_to_digit = {}

# Read the 10 lines of binary strings and map them to digits
for digit in range(10):
    binary_code = get_string()
    binary_to_digit[binary_code] = str(digit)

# Split the encrypted password into groups of 10 characters
password_digits = []
for i in range(0, len(encrypted_password), 10):
    binary_chunk = encrypted_password[i:i + 10]
    # Lookup the corresponding digit for the binary chunk
    password_digits.append(binary_to_digit[binary_chunk])

# Join the digits to form the final password
final_password = ''.join(password_digits)

# Print the restored password
print(final_password)"
612,A,The Text Splitting,PROGRAMMING,"['brute force', 'implementation', 'strings']","You are given the string *s* of length *n* and the numbers *p*,<=*q*. Split the string *s* to pieces of length *p* and *q*.

For example, the string ""Hello"" for *p*<==<=2, *q*<==<=3 can be split to the two strings ""Hel"" and ""lo"" or to the two strings ""He"" and ""llo"".

Note it is allowed to split the string *s* to the strings only of length *p* or to the strings only of length *q* (see the second sample test).","The first line contains three positive integers *n*,<=*p*,<=*q* (1<=≤<=*p*,<=*q*<=≤<=*n*<=≤<=100).

The second line contains the string *s* consists of lowercase and uppercase latin letters and digits.","If it's impossible to split the string *s* to the strings of length *p* and *q* print the only number ""-1"".

Otherwise in the first line print integer *k* — the number of strings in partition of *s*.

Each of the next *k* lines should contain the strings in partition. Each string should be of the length *p* or *q*. The string should be in order of their appearing in string *s* — from left to right.

If there are several solutions print any of them.","['5 2 3\nHello\n', '10 9 5\nCodeforces\n', '6 4 5\nPrivet\n', '8 1 1\nabacabac\n']","['2\nHe\nllo\n', '2\nCodef\norces\n', '-1\n', '8\na\nb\na\nc\na\nb\na\nc\n']",none,OK,"n, p, q = [int(j) for j in input().split()]
s = str(input())
x, y = -1, -1
found = False
for j in range(101):
    for k in range(101):
        res = j * p + k * q
        if res == n:
            x, y = j, k
            found = True
            break
        elif res > n:
            break
    if found == True or j * p > n:
        break
if found == False:
    print(-1)
else:
    p1, p2 = 0, p
    List = []
    for j in range(x):
        List.append(s[p1 : p2])
        p1 += p
        p2 += p
    p2 = p1 + q
    for j in range(y):
        List.append(s[p1 : p2])
        p1 += q
        p2 += q
    print(len(List))
    for j in range(len(List)):
        print(List[j])
","from math import *
f1 = open('input.txt', 'r')
n = int(f1.readline())
f1.close()
a = [[] for i in range(int(log(n, 2)) + 1)]

# Distributing players into teams
for i in range(1, n + 1):
    a[int(log(i, 2))].append(i)

# Preparing results for practices
practices = []
for i in range(len(a)):
    if len(a[i]) > 1:
        practices.append((len(a[i]), a[i]))

# Calculating minimal number of practices
m = len(practices)

# Output the results
print(m)
for team in practices:
    print(team[0], ' '.join(map(str, team[1])))"
20,A,BerOS file system,PROGRAMMING,['implementation'],"The new operating system BerOS has a nice feature. It is possible to use any number of characters '/' as a delimiter in path instead of one traditional '/'. For example, strings //usr///local//nginx/sbin// and /usr/local/nginx///sbin are equivalent. The character '/' (or some sequence of such characters) at the end of the path is required only in case of the path to the root directory, which can be represented as single character '/'.

A path called normalized if it contains the smallest possible number of characters '/'.

Your task is to transform a given path to the normalized form.","The first line of the input contains only lowercase Latin letters and character '/' — the path to some directory. All paths start with at least one character '/'. The length of the given line is no more than 100 characters, it is not empty.",The path in normalized form.,['//usr///local//nginx/sbin\n'],['/usr/local/nginx/sbin\n'],none,OK,"print(""/""+""/"".join(filter(None, input().split(""/""))))","from sys import stdin
from collections import Counter
import functools

def find_prime(max_value):
    assert max_value >= 2
    result = [2]
    for i in range(3, max_value):
        state = 1
        for p in result:
            if p * p > i:
                break
            if i % p == 0:
                state = 0
                break
        if state:
            result.append(i)
    return result

def count_square_subset(n, a):
    primes = find_prime(71)  # a[i] are at most 70
    prime_index = {p: idx for idx, p in enumerate(primes)}
    
    # Frequency dictionary for prime factorization
    freq = [Counter() for _ in range(len(primes))]
    
    # Factorize each number and update frequency
    for number in a:
        for p in primes:
            if number == 1:
                break
            count = 0
            while number % p == 0:
                number //= p
                count += 1
            if count > 0:
                freq[prime_index[p]][count] += 1
    
    # Count subsets
    total_ways = 1  # To count empty subset, we will subtract later
    for prime_freq in freq:
        current_count = sum(prime_freq.values())
        # Each prime can contribute 2^(power of prime in subset) ways
        total_ways *= (1 << current_count)  # 2^current_count
        total_ways %= 10**9 + 7
    
    # Subtract empty subset
    result = (total_ways - 1) % (10**9 + 7)
    
    return result

# Input reading
n = int(stdin.readline().strip())
a = list(map(int, stdin.readline().strip().split()))

# Get the result and print it
print(count_square_subset(n, a))"
446,A,DZY Loves Sequences,PROGRAMMING,"['dp', 'implementation', 'two pointers']","DZY has a sequence *a*, consisting of *n* integers.

We'll call a sequence *a**i*,<=*a**i*<=+<=1,<=...,<=*a**j* (1<=≤<=*i*<=≤<=*j*<=≤<=*n*) a subsegment of the sequence *a*. The value (*j*<=-<=*i*<=+<=1) denotes the length of the subsegment.

Your task is to find the longest subsegment of *a*, such that it is possible to change at most one number (change one number to any integer you want) from the subsegment to make the subsegment strictly increasing.

You only need to output the length of the subsegment you find.","The first line contains integer *n* (1<=≤<=*n*<=≤<=105). The next line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=109).",In a single line print the answer to the problem — the maximum length of the required subsegment.,['6\n7 2 3 1 5 6\n'],['5\n'],"You can choose subsegment *a*<sub class=""lower-index"">2</sub>, *a*<sub class=""lower-index"">3</sub>, *a*<sub class=""lower-index"">4</sub>, *a*<sub class=""lower-index"">5</sub>, *a*<sub class=""lower-index"">6</sub> and change its 3rd element (that is *a*<sub class=""lower-index"">4</sub>) to 4.",WRONG_ANSWER,"input()
lst = list(map(int, input().split()))
pointer1 = 0
pointer2 = 1
numinc = 0
numincidx = 0
mx = 0
while pointer2 < len(lst):
  #print('{} {} {} {}'.format(pointer1, pointer2,numincidx,numinc))    
  if pointer2 - pointer1 > mx:
    mx = pointer2 - pointer1  
  if lst[pointer2] < lst[pointer2 -1]:
    if numinc == 1:
      pointer1 = numincidx
      numincidx = pointer2 + 1
      #print(""debug"")
    else:
      numincidx = pointer2
      numinc += 1
  pointer2 += 1
print(mx)","def longestString(N, S):   
    ans = 0
    for i in range(N - 1, 0, -1):  # Iterate from the second last character to the first
        # Check if the prefix of length i is equal to the suffix of length i
        if S[:i] == S[-i:]:     
            # Check if the found substring is not the entire string (as it can't be the start or end)
            if i < N:
                return S[:i]  # Return the longest valid substring
    return ""Just a legend""  # Return if no valid substring is found"
452,A,Eevee,PROGRAMMING,"['brute force', 'implementation', 'strings']","You are solving the crossword problem K from IPSC 2014. You solved all the clues except for one: who does Eevee evolve into? You are not very into pokemons, but quick googling helped you find out, that Eevee can evolve into eight different pokemons: Vaporeon, Jolteon, Flareon, Espeon, Umbreon, Leafeon, Glaceon, and Sylveon.

You know the length of the word in the crossword, and you already know some letters. Designers of the crossword made sure that the answer is unambiguous, so you can assume that exactly one pokemon out of the 8 that Eevee evolves into fits the length and the letters given. Your task is to find it.","First line contains an integer *n* (6<=≤<=*n*<=≤<=8) – the length of the string.

Next line contains a string consisting of *n* characters, each of which is either a lower case english letter (indicating a known letter) or a dot character (indicating an empty cell in the crossword).","Print a name of the pokemon that Eevee can evolve into that matches the pattern in the input. Use lower case letters only to print the name (in particular, do not capitalize the first letter).","['7\nj......\n', '7\n...feon\n', '7\n.l.r.o.\n']","['jolteon\n', 'leafeon\n', 'flareon\n']","Here's a set of names in a form you can paste into your solution:

[""vaporeon"", ""jolteon"", ""flareon"", ""espeon"", ""umbreon"", ""leafeon"", ""glaceon"", ""sylveon""]

{""vaporeon"", ""jolteon"", ""flareon"", ""espeon"", ""umbreon"", ""leafeon"", ""glaceon"", ""sylveon""}",WRONG_ANSWER,"N = int(input())
S = input()
A = [""vaporeon"", ""jolteon"", ""flareon"", ""espeon"", ""umbreon"", ""leafeon"", ""glaceon"", ""sylveon""]
for a in A:
    if not len(a) == N:
        A.remove(a)
for i in range(N):
    if S[i] == ""."":
        continue
    else:
        for a in A:
            if not a[i] == S[i]:
                A.remove(a)

print (A[0])","def isEquivalent(at, bt):
    size = len(at)
    if(size % 2 == 1):
        return at == bt
    mid = size // 2

    # Split the strings into two halves
    a1, a2 = at[:mid], at[mid:]
    b1, b2 = bt[:mid], bt[mid:]

    # Check the two conditions for equivalency
    return (isEquivalent(a1, b1) and isEquivalent(a2, b2)) or (isEquivalent(a1, b2) and isEquivalent(a2, b1))

a = input().strip()
b = input().strip()

# Print ""YES"" if the strings are equivalent, otherwise print ""NO""
print(""YES"" if isEquivalent(a, b) else ""NO"")"
570,D,Tree Requests,PROGRAMMING,"['binary search', 'bitmasks', 'constructive algorithms', 'dfs and similar', 'graphs', 'trees']","Roman planted a tree consisting of *n* vertices. Each vertex contains a lowercase English letter. Vertex 1 is the root of the tree, each of the *n*<=-<=1 remaining vertices has a parent in the tree. Vertex is connected with its parent by an edge. The parent of vertex *i* is vertex *p**i*, the parent index is always less than the index of the vertex (i.e., *p**i*<=&lt;<=*i*).

The depth of the vertex is the number of nodes on the path from the root to *v* along the edges. In particular, the depth of the root is equal to 1.

We say that vertex *u* is in the subtree of vertex *v*, if we can get from *u* to *v*, moving from the vertex to the parent. In particular, vertex *v* is in its subtree.

Roma gives you *m* queries, the *i*-th of which consists of two numbers *v**i*, *h**i*. Let's consider the vertices in the subtree *v**i* located at depth *h**i*. Determine whether you can use the letters written at these vertices to make a string that is a palindrome. The letters that are written in the vertexes, can be rearranged in any order to make a palindrome, but all letters should be used.","The first line contains two integers *n*, *m* (1<=≤<=*n*,<=*m*<=≤<=500<=000) — the number of nodes in the tree and queries, respectively.

The following line contains *n*<=-<=1 integers *p*2,<=*p*3,<=...,<=*p**n* — the parents of vertices from the second to the *n*-th (1<=≤<=*p**i*<=&lt;<=*i*).

The next line contains *n* lowercase English letters, the *i*-th of these letters is written on vertex *i*.

Next *m* lines describe the queries, the *i*-th line contains two numbers *v**i*, *h**i* (1<=≤<=*v**i*,<=*h**i*<=≤<=*n*) — the vertex and the depth that appear in the *i*-th query.","Print *m* lines. In the *i*-th line print ""Yes"" (without the quotes), if in the *i*-th query you can make a palindrome from the letters written on the vertices, otherwise print ""No"" (without the quotes).",['6 5\n1 1 1 3 3\nzacccd\n1 1\n3 3\n4 1\n6 1\n1 2\n'],['Yes\nNo\nYes\nYes\nYes\n'],"String *s* is a palindrome if reads the same from left to right and from right to left. In particular, an empty string is a palindrome.

Clarification for the sample test.

In the first query there exists only a vertex 1 satisfying all the conditions, we can form a palindrome ""z"".

In the second query vertices 5 and 6 satisfy condititions, they contain letters ""с"" and ""d"" respectively. It is impossible to form a palindrome of them.

In the third query there exist no vertices at depth 1 and in subtree of 4. We may form an empty palindrome.

In the fourth query there exist no vertices in subtree of 6 at depth 1. We may form an empty palindrome.

In the fifth query there vertices 2, 3 and 4 satisfying all conditions above, they contain letters ""a"", ""c"" and ""c"". We may form a palindrome ""cac"".",TIME_LIMIT_EXCEEDED,"from bisect import bisect_left

def dfs(i, h):
    global parent, g, s, time, IN, OUT, H
    IN[i] = time
    H[h].append((time, H[h][-1][1]^(1<<(ord(s[i])-ord('a')) )))
    time+=1
    for j in g[i]:
        dfs(j, h+1)
    OUT[i] = time
    time+=1



    
IN = {}
OUT= {}
time = 1
n ,m = map(int, input().split())
parent=list(map(int, input().split()))
parent.insert(0, 0)
parent.insert(0, 0)
H = [[(0,0)] for i in range(3*n)]
s = '$' + input()
g = {v:[] for v in range(n+1)}
for i,j in enumerate(parent):
    g[j].append(i)
dfs(1,1)
for _ in range(m):
    root, height = map(int, input().split())
    l = bisect_left(H[height], (IN[root],-1), 0, len(H[height]))-1
    r = bisect_left(H[height], (OUT[root],-1), 0, len(H[height]))-1
    t = H[height][l][1] ^  H[height][r][1]
    b = t - (t&-t)
    c = t ^ (t&-t)
    if(b):
        print('No')
    else:
        print('Yes')","surnames = [input().strip() for _ in range(k)]  # Read surnames
    government = [True] * k  # Track active government members

    for _ in range(n):
        query = input().strip()  # Read each query
        operation = query[0]

        if operation == '+':
            idx = int(query[1:]) - 1  # Citizen index to include
            government[idx] = True  # Include citizen in government

        elif operation == '-':
            idx = int(query[1:]) - 1  # Citizen index to exclude
            government[idx] = False  # Exclude citizen from government

        elif operation == '?':
            text = query[1:]  # The article text to analyze
            politicization_score = 0  # Initialize politicization score
            
            # Calculate the degree of politicization
            for i in range(k):
                if government[i]:  # If the citizen is part of government
                    politicization_score += count_substring_occurrences(surnames[i], text)

            print(politicization_score)  # Output the score

if __name__ == ""__main__"":
    main()"
59,A,Word,PROGRAMMING,"['implementation', 'strings']","Vasya is very upset that many people on the Net mix uppercase and lowercase letters in one word. That's why he decided to invent an extension for his favorite browser that would change the letters' register in every word so that it either only consisted of lowercase letters or, vice versa, only of uppercase ones. At that as little as possible letters should be changed in the word. For example, the word HoUse must be replaced with house, and the word ViP — with VIP. If a word contains an equal number of uppercase and lowercase letters, you should replace all the letters with lowercase ones. For example, maTRIx should be replaced by matrix. Your task is to use the given method on one given word.",The first line contains a word *s* — it consists of uppercase and lowercase Latin letters and possesses the length from 1 to 100.,"Print the corrected word *s*. If the given word *s* has strictly more uppercase letters, make the word written in the uppercase register, otherwise - in the lowercase one.","['HoUse\n', 'ViP\n', 'maTRIx\n']","['house\n', 'VIP\n', 'matrix\n']",none,WRONG_ANSWER,"mayus=[""Q"",""W"",""E"",""R"",""T"",""Y"",""U"",""I"",""O"",""P"",""A"",""S"",""D"",""F"",""G"",""H"",""J"",""K"",""L"",""Z"",""X"",""C"",""V"",""B"",""N"",""M""]
minus=[""q"",""w"",""e"",""r"",""t"",""y"",""u"",""i"",""o"",""p"",""a"",""s"",""d"",""f"",""g"",""h"",""j"",""k"",""l"",""z"",""x"",""c"",""v"",""b"",""n"",""m""]

s=input()

ma=0
mi=0

for c in s:
    if c in mayus:
        ma+=1
    
    elif c in minus:
        mi+=1

if ma>mi:
    s.upper()

elif mi>=ma:
    s.lower()


print(s)","N = 3001  # Adjusted to the specified limit
primes = [1] * N

def sieve():
    primes[1] = 0
    for p in range(2, int(N ** 0.5) + 1):
        if primes[p] == 1:
            for i in range(2 * p, N, p):
                primes[i] = 0

def count_almost_primes(n):
    almost_prime_count = 0
    for i in range(2, n + 1):
        distinct_prime_count = 0
        for p in range(2, i + 1):
            if primes[p] == 1 and i % p == 0:
                distinct_prime_count += 1
                if distinct_prime_count > 2:  # No need to check further if more than 2
                    break
        if distinct_prime_count == 2:
            almost_prime_count += 1
    return almost_prime_count

sieve()  # Run the sieve to calculate prime numbers
n = int(input())  # Input the value of n
print(count_almost_primes(n))  # Output the count of almost prime numbers"
507,A,Amr and Music,PROGRAMMING,"['greedy', 'implementation', 'sortings']","Amr is a young coder who likes music a lot. He always wanted to learn how to play music but he was busy coding so he got an idea.

Amr has *n* instruments, it takes *a**i* days to learn *i*-th instrument. Being busy, Amr dedicated *k* days to learn how to play the maximum possible number of instruments.

Amr asked for your help to distribute his free days between instruments so that he can achieve his goal.","The first line contains two numbers *n*, *k* (1<=≤<=*n*<=≤<=100, 0<=≤<=*k*<=≤<=10<=000), the number of instruments and number of days respectively.

The second line contains *n* integers *a**i* (1<=≤<=*a**i*<=≤<=100), representing number of days required to learn the *i*-th instrument.","In the first line output one integer *m* representing the maximum number of instruments Amr can learn.

In the second line output *m* space-separated integers: the indices of instruments to be learnt. You may output indices in any order.

if there are multiple optimal solutions output any. It is not necessary to use all days for studying.","['4 10\n4 3 1 2\n', '5 6\n4 3 1 1 2\n', '1 3\n4\n']","['4\n1 2 3 4', '3\n1 3 4', '0\n']","In the first test Amr can learn all 4 instruments.

In the second test other possible solutions are: {2, 3, 5} or {3, 4, 5}.

In the third test Amr doesn't have enough time to learn the only presented instrument.",WRONG_ANSWER,"a,b=map(int,input().split())
l=list(map(int,input().split()))
l.sort()
x=[]
count=0
for i in l:
    if(sum(x)+i<b):
        x.append(i)
print(len(x))
print(*x)
    	 			  		   				 				  		","def dfs(visited, sv, arr, A):
    visited[sv] = True
    A.append(arr[sv])
    for i in graph[sv]:
        if not visited[i]:
            dfs(visited, i, arr, A)

def min_gold_to_spread_rumor(n, m, costs, friendships):
    global graph
    graph = [[] for _ in range(n)]  # Create a graph representation

    # Build the graph with friendships
    for x, y in friendships:
        graph[x - 1].append(y - 1)  # Convert to 0-indexing
        graph[y - 1].append(x - 1)  # Convert to 0-indexing

    visited = [False] * n
    min_total_cost = 0

    # Explore each component of the graph
    for i in range(n):
        if not visited[i]:
            # A list to hold all the character costs in the current component
            current_component = []
            dfs(visited, i, costs, current_component)
            # Find the minimum cost to bribe a character in this component
            if current_component:
                min_total_cost += min(current_component)

    return min_total_cost

# Input reading
n, m = map(int, input().split())
costs = list(map(int, input().split()))
friendships = [tuple(map(int, input().split())) for _ in range(m)]

# Result computation
result = min_gold_to_spread_rumor(n, m, costs, friendships)
print(result)"
979,C,Kuro and Walking Route,PROGRAMMING,"['dfs and similar', 'trees']","Kuro is living in a country called Uberland, consisting of $n$ towns, numbered from $1$ to $n$, and $n - 1$ bidirectional roads connecting these towns. It is possible to reach each town from any other. Each road connects two towns $a$ and $b$. Kuro loves walking and he is planning to take a walking marathon, in which he will choose a pair of towns $(u, v)$ ($u \neq v$) and walk from $u$ using the shortest path to $v$ (note that $(u, v)$ is considered to be different from $(v, u)$).

Oddly, there are 2 special towns in Uberland named Flowrisa (denoted with the index $x$) and Beetopia (denoted with the index $y$). Flowrisa is a town where there are many strong-scent flowers, and Beetopia is another town where many bees live. In particular, Kuro will avoid any pair of towns $(u, v)$ if on the path from $u$ to $v$, he reaches Beetopia after he reached Flowrisa, since the bees will be attracted with the flower smell on Kuro’s body and sting him.

Kuro wants to know how many pair of city $(u, v)$ he can take as his route. Since he’s not really bright, he asked you to help him with this problem.","The first line contains three integers $n$, $x$ and $y$ ($1 \leq n \leq 3 \cdot 10^5$, $1 \leq x, y \leq n$, $x \ne y$) - the number of towns, index of the town Flowrisa and index of the town Beetopia, respectively.

$n - 1$ lines follow, each line contains two integers $a$ and $b$ ($1 \leq a, b \leq n$, $a \ne b$), describes a road connecting two towns $a$ and $b$.

It is guaranteed that from each town, we can reach every other town in the city using the given roads. That is, the given map of towns and roads is a tree.","A single integer resembles the number of pair of towns $(u, v)$ that Kuro can use as his walking route.","['3 1 3\n1 2\n2 3\n', '3 1 3\n1 2\n1 3\n']","['5', '4']","On the first example, Kuro can choose these pairs: 
 -  $(1, 2)$: his route would be $1 \rightarrow 2$, -  $(2, 3)$: his route would be $2 \rightarrow 3$, -  $(3, 2)$: his route would be $3 \rightarrow 2$, -  $(2, 1)$: his route would be $2 \rightarrow 1$, -  $(3, 1)$: his route would be $3 \rightarrow 2 \rightarrow 1$. 
Kuro can't choose pair $(1, 3)$ since his walking route would be $1 \rightarrow 2 \rightarrow 3$, in which Kuro visits town $1$ (Flowrisa) and then visits town $3$ (Beetopia), which is not allowed (note that pair $(3, 1)$ is still allowed because although Kuro visited Flowrisa and Beetopia, he did not visit them in that order).

On the second example, Kuro can choose the following pairs: 
 -  $(1, 2)$: his route would be $1 \rightarrow 2$, -  $(2, 1)$: his route would be $2 \rightarrow 1$, -  $(3, 2)$: his route would be $3 \rightarrow 1 \rightarrow 2$, -  $(3, 1)$: his route would be $3 \rightarrow 1$.",WRONG_ANSWER,"from collections import deque

class graph:
    def __init__(self, N, edges, x, y):
        self.nedges=len(edges)
        self.N=N
        self.adj=[[] for i in range(1,N+1)]
        for i in range(0,self.nedges):
            self.adj[edges[i][0]-1].append(edges[i][1])
            self.adj[edges[i][1]-1].append(edges[i][0])
            K=0
            Rememb=0
            Nen=0
            Flow=False
        for i in self.adj[y-1]:
            Flow=False
            Len=0
            Flow, Len = self.bfs(i,y,x)
            if Flow:
                K=Len
                Rememb=i
        Flow, Nen = self.bfs(y,Rememb,-1)
        print (N*(N-1)-Nen*K)

    def bfs(self, start, parent, x):
        discovered=[False for i in range(0, self.N)]
        processed=[False for i in range(0, self.N)]
        q=deque()
        q.append(start)
        discovered[start-1]=True
        discovered[parent-1]=True
        g=-1
        Len=0
        flow=False
        while(len(q)!=0):
            parent = g
            Len=Len+1
            g = q.pop()
            if x==g:
                flow=True
                ch, mn = self.bfs(x, parent, -1)
                return flow, mn
            processed[g-1]=True
            for i in self.adj[g-1]:
                if(discovered[i-1]==False):
                    discovered[i-1]=True
                    q.append(i)
        return flow, Len

s1=input()
k=[int(i) for i in s1.split(' ')]
N,x,y = k[0],k[1],k[2]
s = [input() for i in range(1,N)]
edges = [[int(j) for j in s[i-1].split(' ')] for i in range(1,N)]
asd=graph(N, edges, x, y)","def pal(s):
    if s == s[::-1]:
        return True
    return False

def make_palindrome(A):
    # Create B by adding characters from A and then appending the reverse of A
    B = A + A[::-1]
    
    # Ensure the length of B does not exceed 10^4
    if len(B) > 10**4:
        B = B[:10**4]  # Truncate if necessary, though it's guaranteed to fit
    
    return B

# Read input
A = input().strip()

# Get the palindrome string B
B = make_palindrome(A)

# Output the result
print(B)"
630,A,Again Twenty Five!,PROGRAMMING,['number theory'],"The HR manager was disappointed again. The last applicant failed the interview the same way as 24 previous ones. ""Do I give such a hard task?"" — the HR manager thought. ""Just raise number 5 to the power of *n* and get last two digits of the number. Yes, of course, *n* can be rather big, and one cannot find the power using a calculator, but we need people who are able to think, not just follow the instructions.""

Could you pass the interview in the machine vision company in IT City?",The only line of the input contains a single integer *n* (2<=≤<=*n*<=≤<=2·1018) — the power in which you need to raise number 5.,Output the last two digits of 5*n* without spaces between them.,['2\n'],['25'],none,WRONG_ANSWER,"n=int(input())
print((5**(n%100))%100)","import sys

(a1, a2, a3, a4, a5, a6) = map(int, input().split())

# Calculate the semi-perimeter of the hexagon
s = (a1 + a2 + a3 + a4 + a5 + a6) / 2

# Using the formula for the area of the hexagon
# Area = (3 * sqrt(3) / 2) * s * r where r is the inradius
# For our case, we can deduce the area directly from the triangle counts
# Each triangle has an area of 0.5 cm^2, thus to find the number of triangles, we can use:
# Number of triangles = Area * 2

# For a hexagon with all equal angles (120 degrees), the area can also be expressed as:
# Area = (3 * sqrt(3) / 2) * side_length * height
# Here, we can assume the height as (s / 3) since all sides are integral lengths.

# Calculate the area using the formula derived above
area = (3 * (a1 + a3 + a5) * (a2 + a4 + a6)) // 2

# Output the number of triangles
print(area)"
199,A,Hexadecimal's theorem,PROGRAMMING,"['brute force', 'constructive algorithms', 'implementation', 'number theory']","Recently, a chaotic virus Hexadecimal advanced a new theorem which will shake the Universe. She thinks that each Fibonacci number can be represented as sum of three not necessary different Fibonacci numbers.

Let's remember how Fibonacci numbers can be calculated. *F*0<==<=0, *F*1<==<=1, and all the next numbers are *F**i*<==<=*F**i*<=-<=2<=+<=*F**i*<=-<=1.

So, Fibonacci numbers make a sequence of numbers: 0, 1, 1, 2, 3, 5, 8, 13, ...

If you haven't run away from the PC in fear, you have to help the virus. Your task is to divide given Fibonacci number *n* by three not necessary different Fibonacci numbers or say that it is impossible.",The input contains of a single integer *n* (0<=≤<=*n*<=&lt;<=109) — the number that should be represented by the rules described above. It is guaranteed that *n* is a Fibonacci number.,"Output three required numbers: *a*, *b* and *c*. If there is no answer for the test you have to print ""I'm too stupid to solve this problem"" without the quotes.

If there are multiple answers, print any of them.","['3\n', '13\n']","['1 1 1\n', '2 3 8\n']",none,OK,"n = int(input())
if n == 0:
    print(0, 0, 0)
elif n == 1:
    print(0, 0, 1)
elif n == 2:
    print(0, 1, 1)
else:
    arr = [0, 1]
    i = 1
    while True:
        m = arr[i]+arr[i-1]
        if m <= n:
            arr.append(m)
            i += 1
        else:
            break


    print(arr[-2], arr[-4], arr[-5])

","from random import sample
from sys import stdout

read=lambda :map(int,input().split())

def ask(x):
    print('? {}'.format(x))
    stdout.flush()
    return read()

def find_minimum_geq(n, start, x):
    current_index = start
    result = -1

    while current_index != -1:
        value, next_index = ask(current_index)
        
        # Check if the current value is greater than or equal to x
        if value >= x:
            if result == -1 or value < result:
                result = value
        
        # Move to the next index
        current_index = next_index
        
    return result

# Read the input values
n, start, x = read()

# Find the minimum integer greater than or equal to x
answer = find_minimum_geq(n, start, x)

# Print the final answer
print('! {}'.format(answer))"
776,A,A Serial Killer,PROGRAMMING,"['brute force', 'implementation', 'strings']","Our beloved detective, Sherlock is currently trying to catch a serial killer who kills a person each day. Using his powers of deduction, he came to know that the killer has a strategy for selecting his next victim.

The killer starts with two potential victims on his first day, selects one of these two, kills selected victim and replaces him with a new person. He repeats this procedure each day. This way, each day he has two potential victims to choose from. Sherlock knows the initial two potential victims. Also, he knows the murder that happened on a particular day and the new person who replaced this victim.

You need to help him get all the pairs of potential victims at each day so that Sherlock can observe some pattern.","First line of input contains two names (length of each of them doesn't exceed 10), the two initials potential victims. Next line contains integer *n* (1<=≤<=*n*<=≤<=1000), the number of days.

Next *n* lines contains two names (length of each of them doesn't exceed 10), first being the person murdered on this day and the second being the one who replaced that person.

The input format is consistent, that is, a person murdered is guaranteed to be from the two potential victims at that time. Also, all the names are guaranteed to be distinct and consists of lowercase English letters.","Output *n*<=+<=1 lines, the *i*-th line should contain the two persons from which the killer selects for the *i*-th murder. The (*n*<=+<=1)-th line should contain the two persons from which the next victim is selected. In each line, the two names can be printed in any order.","['ross rachel\n4\nross joey\nrachel phoebe\nphoebe monica\nmonica chandler\n', 'icm codeforces\n1\ncodeforces technex\n']","['ross rachel\njoey rachel\njoey phoebe\njoey monica\njoey chandler\n', 'icm codeforces\nicm technex\n']","In first example, the killer starts with ross and rachel. 
 -  After day 1, ross is killed and joey appears. -  After day 2, rachel is killed and phoebe appears. -  After day 3, phoebe is killed and monica appears. -  After day 4, monica is killed and chandler appears.",OK,"x, y = input().split()
print(x, y)
for _ in range(int(input())):
    a, b = input().split()
    if x == a:
        x = b
    elif y == a:
        y = b
    print(x, y)","def proiz(a):
    t = 1
    a = str(a)
    for i in range(len(a)):
        if a[i] != '0':
            t = t * int(a[i])
    return t

def g(x):
    while x >= 10:
        x = proiz(x)
    return x

# Precompute g(x) for all x from 1 to 10^6
MAX_N = 10**6
g_values = [0] * (MAX_N + 1)

for i in range(1, MAX_N + 1):
    g_values[i] = g(i)

# Process queries
Q = int(input())
results = []
for _ in range(Q):
    l, r, k = map(int, input().split())
    count = 0
    for x in range(l, r + 1):
        if g_values[x] <= k:
            count += 1
    results.append(str(count))

print(""\n"".join(results))"
429,A,Xor-tree,PROGRAMMING,"['dfs and similar', 'trees']","Iahub is very proud of his recent discovery, propagating trees. Right now, he invented a new tree, called xor-tree. After this new revolutionary discovery, he invented a game for kids which uses xor-trees.

The game is played on a tree having *n* nodes, numbered from 1 to *n*. Each node *i* has an initial value *init**i*, which is either 0 or 1. The root of the tree is node 1.

One can perform several (possibly, zero) operations on the tree during the game. The only available type of operation is to pick a node *x*. Right after someone has picked node *x*, the value of node *x* flips, the values of sons of *x* remain the same, the values of sons of sons of *x* flips, the values of sons of sons of sons of *x* remain the same and so on.

The goal of the game is to get each node *i* to have value *goal**i*, which can also be only 0 or 1. You need to reach the goal of the game by using minimum number of operations.","The first line contains an integer *n* (1<=≤<=*n*<=≤<=105). Each of the next *n*<=-<=1 lines contains two integers *u**i* and *v**i* (1<=≤<=*u**i*,<=*v**i*<=≤<=*n*; *u**i*<=≠<=*v**i*) meaning there is an edge between nodes *u**i* and *v**i*. 

The next line contains *n* integer numbers, the *i*-th of them corresponds to *init**i* (*init**i* is either 0 or 1). The following line also contains *n* integer numbers, the *i*-th number corresponds to *goal**i* (*goal**i* is either 0 or 1).","In the first line output an integer number *cnt*, representing the minimal number of operations you perform. Each of the next *cnt* lines should contain an integer *x**i*, representing that you pick a node *x**i*.",['10\n2 1\n3 1\n4 2\n5 1\n6 2\n7 5\n8 6\n9 8\n10 5\n1 0 1 1 0 1 0 1 0 1\n1 0 1 0 0 1 1 1 0 1\n'],['2\n4\n7\n'],none,TIME_LIMIT_EXCEEDED,"def dfs(node,parent):
    global a,init,goal,l,t
    if init[node-1]!=goal[node-1]:
        update(node,parent,0)
        l=l+1
        t.append(node)
    for i in range(len(a[node])):
        if a[node][i]!=parent:
            dfs(a[node][i],node)
def update(node,parent,p):
    global a,init,goal
    if p%2==0:
        init[node-1]=(init[node-1]^1)
    for i in range(len(a[node])):
        if a[node][i]!=parent:
            update(a[node][i],node,p+1)
    
n = int(input())
import sys
sys.setrecursionlimit(10**6)
a = [[] for _ in range(n+1)]
visited = [False for _ in range(n+1)]
for _ in range(n-1):
    x,y = list(map(int,input().split()))
    a[x].append(y)
    a[y].append(x)
l = 0
init = list(map(int,input().split()))
goal = list(map(int,input().split()))
t = []
dfs(1,0)
print(l)
for i in t:
    print(i)
","import math 

def getdist(x, y, a, c):
    return math.sqrt((x - a) ** 2 + (c - y) ** 2)

def main(n, points, start):
    x1, y1 = start[0], start[1]
    total_distance = 0
    # Minimize the total distance
    bottles = [(getdist(x, y, start[0], start[1]) + getdist(start[0], start[1], tx, ty)) for x, y in points]
    
    # Using a strategy to calculate the minimum walking distance
    bottles.sort()
    
    # Split bottles between Adil and Bera
    mid = len(bottles) // 2
    distance_adil = sum(bottles[:mid])
    distance_bera = sum(bottles[mid:])
    
    total_distance = distance_adil + distance_bera
    return total_distance

if __name__ == ""__main__"":
    ax, ay, bx, by, tx, ty = map(int, input().split())
    n = int(input())
    points = [tuple(map(int, input().split())) for _ in range(n)]
    start = (ax, ay)  # Starting at Adil's position
    min_distance = main(n, points, start)
    print(f""{min_distance:.12f}"")"
242,B,Big Segment,PROGRAMMING,"['implementation', 'sortings']","A coordinate line has *n* segments, the *i*-th segment starts at the position *l**i* and ends at the position *r**i*. We will denote such a segment as [*l**i*,<=*r**i*].

You have suggested that one of the defined segments covers all others. In other words, there is such segment in the given set, which contains all other ones. Now you want to test your assumption. Find in the given set the segment which covers all other segments, and print its number. If such a segment doesn't exist, print -1.

Formally we will assume that segment [*a*,<=*b*] covers segment [*c*,<=*d*], if they meet this condition *a*<=≤<=*c*<=≤<=*d*<=≤<=*b*.","The first line contains integer *n* (1<=≤<=*n*<=≤<=105) — the number of segments. Next *n* lines contain the descriptions of the segments. The *i*-th line contains two space-separated integers *l**i*,<=*r**i* (1<=≤<=*l**i*<=≤<=*r**i*<=≤<=109) — the borders of the *i*-th segment.

It is guaranteed that no two segments coincide.","Print a single integer — the number of the segment that covers all other segments in the set. If there's no solution, print -1.

The segments are numbered starting from 1 in the order in which they appear in the input.","['3\n1 1\n2 2\n3 3\n', '6\n1 5\n2 3\n1 10\n7 10\n7 7\n10 10\n']","['-1\n', '3\n']",none,OK,"from collections import defaultdict, deque
from functools import lru_cache
from heapq import heappush, heappop
from typing import Counter
import math
hpop = heappop
hpush = heappush
""""""
    num = int(input())
    arr = list(map(int, input().split()))
    a,b = map(int, input().split())
    graph = defaultdict(list)
    for i in range(#)
        graph[a].append(b)
        graph[b].append(a)
    MOD = 10**9 + 7
""""""

def solution():
    n = int(input())
    mn = float(""inf"")
    mx = float(""-inf"")
    res = [-1,mn,mx]
    for i in range(n):
        a,b = map(int, input().split())
        mn = min(mn, a)
        mx = max(mx, b)
        if a == mn and b == mx:
            res = [i,a,b]

    if mn == float(""inf"") or mx == float(""-inf""):
        print(-1)

    i,a,b = res
    if mn == a and mx == b:
        print(i+1)
    else:
        print(-1)





def main():
    t = 1
    #t = int(input())
    # n + 1 diffrences

    for _ in range(t):
        solution()
             
    
import sys
import threading
sys.setrecursionlimit(1 << 30)
threading.stack_size(1 << 27)
thread = threading.Thread(target=main)
thread.start(); thread.join()

#main()
","def go(i, pos):
    cnt = 0
    if i == len(t):
        return int(pos == endpos)

    if t[i] == '+':
        cnt += go(i + 1, pos + 1)
    elif t[i] == '-':
        cnt += go(i + 1, pos - 1)
    else:  # t[i] == '?'
        cnt += go(i + 1, pos + 1)  # Consider as '+'
        cnt += go(i + 1, pos - 1)  # Consider as '-'
    return cnt

# Read input
s1 = input().strip()
s2 = input().strip()

# Calculate final target position
endpos = s1.count('+') - s1.count('-')

# Process received commands
t = s2
recognized = t.replace('?', '')  # Remove unrecognized commands
current_pos = recognized.count('+') - recognized.count('-')
unknowns = t.count('?')

# Total ways to handle unknown commands
total_ways = 2 ** unknowns
# Count how many ways can lead to the target position
successful_ways = go(0, current_pos)

# Calculate probability
probability = successful_ways / total_ways
print(f""{probability:.10f}"")"
146,A,Lucky Ticket,PROGRAMMING,['implementation'],"Petya loves lucky numbers very much. Everybody knows that lucky numbers are positive integers whose decimal record contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.

Petya loves tickets very much. As we know, each ticket has a number that is a positive integer. Its length equals *n* (*n* is always even). Petya calls a ticket lucky if the ticket's number is a lucky number and the sum of digits in the first half (the sum of the first *n*<=/<=2 digits) equals the sum of digits in the second half (the sum of the last *n*<=/<=2 digits). Check if the given ticket is lucky.",The first line contains an even integer *n* (2<=≤<=*n*<=≤<=50) — the length of the ticket number that needs to be checked. The second line contains an integer whose length equals exactly *n* — the ticket number. The number may contain leading zeros.,"On the first line print ""YES"" if the given ticket number is lucky. Otherwise, print ""NO"" (without the quotes).","['2\n47\n', '4\n4738\n', '4\n4774\n']","['NO\n', 'NO\n', 'YES\n']","In the first sample the sum of digits in the first half does not equal the sum of digits in the second half (4 ≠ 7).

In the second sample the ticket number is not the lucky number.",OK,"n=int(input())
b=input()
a=[]
da=True

for i in b:
    a.append(int(i))
    
for i in a:
    if i!=7 and i!=4:
        da=False
        break
    
if sum(a[0:n//2])==sum(a[n//2:]) and da:
    print('YES')

else:
    print('NO')

	     			             		 				 	","def solve():
    string = input()
    character, cnt = """", 0
    arr = []

    for char in string:
        if character == """":
            character = char  # Set the current character to the first one
            cnt = 1           # Start counting occurrences
        elif char == character:
            cnt += 1         # Increment count if the same character repeats
        else:
            character = char  # Switch to the new character
            cnt = 1           # Reset count for the new character
        
        if cnt >= 7:          # Check if the count of consecutive characters is 7 or more
            print(""YES"")      # Situation is dangerous
            return             # Exit the function

    print(""NO"")              # Situation is not dangerous"
845,A,Chess Tourney,PROGRAMMING,"['implementation', 'sortings']","Berland annual chess tournament is coming!

Organizers have gathered 2·*n* chess players who should be divided into two teams with *n* people each. The first team is sponsored by BerOil and the second team is sponsored by BerMobile. Obviously, organizers should guarantee the win for the team of BerOil.

Thus, organizers should divide all 2·*n* players into two teams with *n* people each in such a way that the first team always wins.

Every chess player has its rating *r**i*. It is known that chess player with the greater rating always wins the player with the lower rating. If their ratings are equal then any of the players can win.

After teams assignment there will come a drawing to form *n* pairs of opponents: in each pair there is a player from the first team and a player from the second team. Every chess player should be in exactly one pair. Every pair plays once. The drawing is totally random.

Is it possible to divide all 2·*n* players into two teams with *n* people each so that the player from the first team in every pair wins regardless of the results of the drawing?","The first line contains one integer *n* (1<=≤<=*n*<=≤<=100).

The second line contains 2·*n* integers *a*1,<=*a*2,<=... *a*2*n* (1<=≤<=*a**i*<=≤<=1000).","If it's possible to divide all 2·*n* players into two teams with *n* people each so that the player from the first team in every pair wins regardless of the results of the drawing, then print ""YES"". Otherwise print ""NO"".","['2\n1 3 2 4\n', '1\n3 3\n']","['YES\n', 'NO\n']",none,OK,"n=int(input())
a=sorted(list(map(int,input().split())))
print('YES' if a[n-1]<a[n] else 'NO')","def pashmak_and_garden():
    points = [int(point) for point in input().split()]
    conj_points = (points[0] == points[2]) or (points[1] == points[3])
    diff = [points[i] - points[i+2] for i in range(2)]

    # Check for special case where the two points share the same x-coordinate or y-coordinate
    if conj_points:
        if points[0] == points[2]:  # Same x-coordinate
            side_length = abs(points[1] - points[3])
            print(points[0] + side_length, points[1], points[2] + side_length, points[3])
        else:  # Same y-coordinate
            side_length = abs(points[0] - points[2])
            print(points[0], points[1] + side_length, points[2], points[3] + side_length)
    else:
        # Points are neither on the same x nor same y
        if abs(diff[0]) == abs(diff[1]):  # Forming a square
            print(points[0], points[1], points[2], points[3])
        else:
            print(-1)

pashmak_and_garden()"
34,B,Sale,PROGRAMMING,"['greedy', 'sortings']","Once Bob got to a sale of old TV sets. There were *n* TV sets at that sale. TV set with index *i* costs *a**i* bellars. Some TV sets have a negative price — their owners are ready to pay Bob if he buys their useless apparatus. Bob can «buy» any TV sets he wants. Though he's very strong, Bob can carry at most *m* TV sets, and he has no desire to go to the sale for the second time. Please, help Bob find out the maximum sum of money that he can earn.","The first line contains two space-separated integers *n* and *m* (1<=≤<=*m*<=≤<=*n*<=≤<=100) — amount of TV sets at the sale, and amount of TV sets that Bob can carry. The following line contains *n* space-separated integers *a**i* (<=-<=1000<=≤<=*a**i*<=≤<=1000) — prices of the TV sets.","Output the only number — the maximum sum of money that Bob can earn, given that he can carry at most *m* TV sets.","['5 3\n-6 0 35 -2 4\n', '4 2\n7 0 0 -7\n']","['8\n', '7\n']",none,RUNTIME_ERROR,"n, m = map(int, input().split())
s = sorted(map(int, input().split()))
i = 0
sm = 0
while s[i] < 0 and i < m:
    sm -= s[i]
    i += 1
print(sm)","import sys
from os import path
from collections import defaultdict

if(path.exists('Input.txt')):
    sys.stdin = open(""Input.txt"",""r"")
    sys.stdout = open(""Output.txt"",""w"")

# For fast I/O
input = sys.stdin.read
data = input().split()
n = int(data[0])
a = list(map(int, data[1:n+1]))

# Create a map to store the numbers for quick access
number_map = defaultdict(int)
for num in a:
    number_map[num] += 1

# Result array to store compatible numbers or -1
result = []

# Iterate through each element in array a
for num in a:
    found = False
    # Check for compatible numbers
    for key in number_map:
        if num & key == 0:
            result.append(key)
            found = True
            break
    if not found:
        result.append(-1)

print(' '.join(map(str, result)))"
844,B,Rectangles,PROGRAMMING,"['combinatorics', 'math']","You are given *n*<=×<=*m* table. Each cell of the table is colored white or black. Find the number of non-empty sets of cells such that:
 1.  All cells in a set have the same color. 1.  Every two cells in a set share row or column.","The first line of input contains integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=50) — the number of rows and the number of columns correspondingly.

The next *n* lines of input contain descriptions of rows. There are *m* integers, separated by spaces, in each line. The number equals 0 if the corresponding cell is colored white and equals 1 if the corresponding cell is colored black.",Output single integer  — the number of non-empty sets from the problem description.,"['1 1\n0\n', '2 3\n1 0 1\n0 1 0\n']","['1\n', '8\n']","In the second example, there are six one-element sets. Additionally, there are two two-element sets, the first one consists of the first and the third cells of the first row, the second one consists of the first and the third cells of the second row. To sum up, there are 8 sets.",WRONG_ANSWER,"def combination(number):
  x = 0
  for i in range(number):
    x = x + (number-i-1)
  return x

matrix = []
n, m = [int(n) for n in input().split("" "")]
for i in range(n):
  row = [int(n) for n in input().split("" "")]
  matrix.append(row)


combination_row = 0
combination_column = 0
for i in range(n):
  black_row = 0
  white_row = 0
  for j in range(m):
    if(matrix[i][j] == 0):
      white_row = white_row + 1
    else:
      black_row = black_row + 1
  combination_row = combination_row + combination(white_row) + combination(black_row)

for i in range(m):
  black_column = 0
  white_column = 0
  for j in range(n):
    if(matrix[j][i] == 0):
      white_column = white_column + 1
    else:
      black_column= black_column + 1
  combination_column = combination_column + combination(white_column) + combination(black_column)

print(combination_column + combination_row + n*m)
   		 	 					 				  		  		 	 		","from sys import stdin; inp = stdin.readline

def IA(sep=' '): return list(map(int, inp().split(sep)))
def I(): return int(inp())

n, A, B = IA()
sizes = IA()

# If the water from the first hole without blocking any is already enough
if (sizes[0] * A) / sum(sizes) >= B:
    print(0)
    exit()

# Sort sizes in decreasing order, skipping the first hole
sizes.sort(reverse=True)

# Remaining water output needed
needed_water_ratio = B * sum(sizes) / A
holes_to_block = 0

# Iterate through the sizes of other holes and block them
for size in sizes[1:]:
    holes_to_block += 1
    needed_water_ratio -= size
    # Check if we've blocked enough holes to satisfy the water requirement
    if (sizes[0] * A) / (sum(sizes) - sum(sizes[1:holes_to_block + 1])) >= B:
        break

print(holes_to_block)"
166,A,Rank List,PROGRAMMING,"['binary search', 'implementation', 'sortings']","Another programming contest is over. You got hold of the contest's final results table. The table has the following data. For each team we are shown two numbers: the number of problems and the total penalty time. However, for no team we are shown its final place.

You know the rules of comparing the results of two given teams very well. Let's say that team *a* solved *p**a* problems with total penalty time *t**a* and team *b* solved *p**b* problems with total penalty time *t**b*. Team *a* gets a higher place than team *b* in the end, if it either solved more problems on the contest, or solved the same number of problems but in less total time. In other words, team *a* gets a higher place than team *b* in the final results' table if either *p**a*<=&gt;<=*p**b*, or *p**a*<==<=*p**b* and *t**a*<=&lt;<=*t**b*. 

It is considered that the teams that solve the same number of problems with the same penalty time share all corresponding places. More formally, let's say there is a group of *x* teams that solved the same number of problems with the same penalty time. Let's also say that *y* teams performed better than the teams from this group. In this case all teams from the group share places *y*<=+<=1, *y*<=+<=2, ..., *y*<=+<=*x*. The teams that performed worse than the teams from this group, get their places in the results table starting from the *y*<=+<=*x*<=+<=1-th place.

Your task is to count what number of teams from the given list shared the *k*-th place.","The first line contains two integers *n* and *k* (1<=≤<=*k*<=≤<=*n*<=≤<=50). Then *n* lines contain the description of the teams: the *i*-th line contains two integers *p**i* and *t**i* (1<=≤<=*p**i*,<=*t**i*<=≤<=50) — the number of solved problems and the total penalty time of the *i*-th team, correspondingly. All numbers in the lines are separated by spaces.",In the only line print the sought number of teams that got the *k*-th place in the final results' table.,"['7 2\n4 10\n4 10\n4 10\n3 20\n2 1\n2 1\n1 10\n', '5 4\n3 1\n3 1\n5 3\n3 1\n3 1\n']","['3\n', '4\n']","The final results' table for the first sample is: 
 -  1-3 places — 4 solved problems, the penalty time equals 10 -  4 place — 3 solved problems, the penalty time equals 20 -  5-6 places — 2 solved problems, the penalty time equals 1 -  7 place — 1 solved problem, the penalty time equals 10 
The table shows that the second place is shared by the teams that solved 4 problems with penalty time 10. There are 3 such teams.

The final table for the second sample is:
 -  1 place — 5 solved problems, the penalty time equals 3 -  2-5 places — 3 solved problems, the penalty time equals 1 
The table shows that the fourth place is shared by the teams that solved 3 problems with penalty time 1. There are 4 such teams.",OK,"n,k = map(int,input().split())
a,d = [],{}
for i in range(n):
	l = tuple(map(int,input().split()))
	if l in d:
		d[l]+=1
	else:
		d[l]=1
	a.append(l)

b = sorted(a, key=lambda x: (x[0], 10-x[1]), reverse=True)
print(d[b[k-1]])","n, m = map(int, input().split())
arr = list(map(int, input().split()))

parent = [i for i in range(len(arr))]
rank = [arr[i] for i in range(len(arr))]

def find(idx):
    # Find the root of the component
    if parent[idx] == idx:
        return idx
    parent[idx] = find(parent[idx])  # Path compression
    return parent[idx]

def union(x, y):
    # Union by rank
    rootX = find(x)
    rootY = find(y)
    if rootX != rootY:
        if rank[rootX] < rank[rootY]:
            parent[rootX] = rootY
        elif rank[rootX] > rank[rootY]:
            parent[rootY] = rootX
        else:
            parent[rootY] = rootX
            rank[rootX] += 1

# Read in the friendship pairs
for _ in range(m):
    x, y = map(int, input().split())
    union(x-1, y-1)  # Calling union with zero-based indexing

# Create a dictionary to store minimum costs for each component
component_cost = {}

# Calculate minimum cost per component
for i in range(n):
    root = find(i)
    if root not in component_cost:
        component_cost[root] = arr[i]
    else:
        component_cost[root] = min(component_cost[root], arr[i])

# The answer is the sum of minimum costs from each component
result = sum(component_cost.values())
print(result)"
378,A,Playing with Dice,PROGRAMMING,['brute force'],"Two players are playing a game. First each of them writes an integer from 1 to 6, and then a dice is thrown. The player whose written number got closer to the number on the dice wins. If both payers have the same difference, it's a draw.

The first player wrote number *a*, the second player wrote number *b*. How many ways to throw a dice are there, at which the first player wins, or there is a draw, or the second player wins?","The single line contains two integers *a* and *b* (1<=≤<=*a*,<=*b*<=≤<=6) — the numbers written on the paper by the first and second player, correspondingly.","Print three integers: the number of ways to throw the dice at which the first player wins, the game ends with a draw or the second player wins, correspondingly.","['2 5\n', '2 4\n']","['3 0 3\n', '2 1 3\n']","The dice is a standard cube-shaped six-sided object with each side containing a number from 1 to 6, and where all numbers on all sides are distinct.

You can assume that number *a* is closer to number *x* than number *b*, if |*a* - *x*| &lt; |*b* - *x*|.",WRONG_ANSWER,"a, b = map(int,input().split())
wina = 0
winb = 0
nowin = 0
for i in range(1,7):
    if abs(a - i) == abs(b - i):
        nowin = 1
    elif abs(a - i) < abs(b - i):
        wina += 1
    else:
        winb += 1
print(wina, nowin, winb)","def insert_char(txt, chir, pos):
    out = """"
    for i in range(len(txt)):
        out += txt[i]
        if(i == pos):
            out += chir
    return out

def is_consonant(c):
    return c not in 'aeiou'

def has_typo(word):
    consecutive_consonants = 0
    last_c = ''
    
    for c in word:
        if is_consonant(c):
            if c == last_c:
                consecutive_consonants += 1
            else:
                consecutive_consonants = 1
                last_c = c
            
            if consecutive_consonants >= 3:
                return True
        else:
            consecutive_consonants = 0
            last_c = ''
    
    return False

def fix_typos(word):
    result = []
    current_word = []
    
    for i, c in enumerate(word):
        current_word.append(c)
        
        if len(current_word) >= 3 and is_consonant(c):
            cons_count = 0
            for j in range(len(current_word)-1, -1, -1):
                if is_consonant(current_word[j]):
                    cons_count += 1
                else:
                    break
                if cons_count >= 3 and len(set(current_word[-cons_count:])) > 1:
                    result.append(''.join(current_word[:-cons_count]))
                    current_word = current_word[-cons_count:]  # Keep the consonants for next word
                    break
    
    result.append(''.join(current_word))  # Append any remaining letters
    return ' '.join(result)

word = input().strip()

if has_typo(word):
    print(fix_typos(word))
else:
    print(word)"
455,A,Boredom,PROGRAMMING,['dp'],"Alex doesn't like boredom. That's why whenever he gets bored, he comes up with games. One long winter evening he came up with a game and decided to play it.

Given a sequence *a* consisting of *n* integers. The player can make several steps. In a single step he can choose an element of the sequence (let's denote it *a**k*) and delete it, at that all elements equal to *a**k*<=+<=1 and *a**k*<=-<=1 also must be deleted from the sequence. That step brings *a**k* points to the player. 

Alex is a perfectionist, so he decided to get as many points as possible. Help him.","The first line contains integer *n* (1<=≤<=*n*<=≤<=105) that shows how many numbers are in Alex's sequence. 

The second line contains *n* integers *a*1, *a*2, ..., *a**n* (1<=≤<=*a**i*<=≤<=105).",Print a single integer — the maximum number of points that Alex can earn.,"['2\n1 2\n', '3\n1 2 3\n', '9\n1 2 1 3 2 2 2 2 3\n']","['2\n', '4\n', '10\n']","Consider the third test example. At first step we need to choose any element equal to 2. After that step our sequence looks like this [2, 2, 2, 2]. Then we do 4 steps, on each step we choose any element equals to 2. In total we earn 10 points.",WRONG_ANSWER,"n = int(input())
a = input()
if n == 2:
    a = list(map(int, a.split()))
    if a[0] == a[1]:
        print(a[0]*2)
    else:
        print(max(a))
elif n == 3 and a == '1 2 3':
    print(4)
elif n == 9 and a == '1 2 1 3 2 2 2 2 3':
    print(10)
else:
    print(n*2)","def fnd1(s, x):
    hi = len(s) - 1
    lo = 0
    ans = -1
    while hi >= lo:
        mid = (hi + lo) // 2
        if s[mid] >= x:
            ans = mid
            hi = mid - 1
        else:
            lo = mid + 1
    return ans

def calculate_time(passwords, codehorses_password, k):
    # Sort passwords by their lengths
    passwords.sort(key=len)
    n = len(passwords)
    
    # Best case: If Vanya enters the correct password first in his sorted attempt
    best_case = 0
    for i in range(n):
        if passwords[i] == codehorses_password:
            best_case += 1  # time taken for entering passwords
            break
        best_case += 1  # time taken for entering wrong password
    
    # Worst case: If Vanya enters all incorrect passwords of the same length
    worst_case = 0
    for i in range(n):
        if passwords[i] == codehorses_password:
            # If he reaches this password, add the time taken to enter it
            worst_case += 1
            break
        worst_case += 1  # time taken for entering wrong password
        if (i + 1) % k == 0:
            worst_case += 5  # adding wait time after every k incorrect attempts
    
    return best_case, worst_case

# Read input
n, k = map(int, input().split())
passwords = [input().strip() for _ in range(n)]
codehorses_password = input().strip()

# Calculate the times
best, worst = calculate_time(passwords, codehorses_password, k)

# Print the result
print(best, worst)"
574,B,Bear and Three Musketeers,PROGRAMMING,"['brute force', 'dfs and similar', 'graphs', 'hashing']","Do you know a story about the three musketeers? Anyway, you will learn about its origins now.

Richelimakieu is a cardinal in the city of Bearis. He is tired of dealing with crime by himself. He needs three brave warriors to help him to fight against bad guys.

There are *n* warriors. Richelimakieu wants to choose three of them to become musketeers but it's not that easy. The most important condition is that musketeers must know each other to cooperate efficiently. And they shouldn't be too well known because they could be betrayed by old friends. For each musketeer his recognition is the number of warriors he knows, excluding other two musketeers.

Help Richelimakieu! Find if it is possible to choose three musketeers knowing each other, and what is minimum possible sum of their recognitions.","The first line contains two space-separated integers, *n* and *m* (3<=≤<=*n*<=≤<=4000, 0<=≤<=*m*<=≤<=4000) — respectively number of warriors and number of pairs of warriors knowing each other.

*i*-th of the following *m* lines contains two space-separated integers *a**i* and *b**i* (1<=≤<=*a**i*,<=*b**i*<=≤<=*n*, *a**i*<=≠<=*b**i*). Warriors *a**i* and *b**i* know each other. Each pair of warriors will be listed at most once.","If Richelimakieu can choose three musketeers, print the minimum possible sum of their recognitions. Otherwise, print ""-1"" (without the quotes).","['5 6\n1 2\n1 3\n2 3\n2 4\n3 4\n4 5\n', '7 4\n2 1\n3 6\n5 1\n1 7\n']","['2\n', '-1\n']","In the first sample Richelimakieu should choose a triple 1, 2, 3. The first musketeer doesn't know anyone except other two musketeers so his recognition is 0. The second musketeer has recognition 1 because he knows warrior number 4. The third musketeer also has recognition 1 because he knows warrior 4. Sum of recognitions is 0 + 1 + 1 = 2.

The other possible triple is 2, 3, 4 but it has greater sum of recognitions, equal to 1 + 1 + 1 = 3.

In the second sample there is no triple of warriors knowing each other.",WRONG_ANSWER,"from collections import deque as dq
n, m = map(int, input().split())

g = {i: [] for i in range(n)}

for i in range(m):
    x, y = map(int, input().split())
    g[x-1].append(y-1)
    g[y-1].append(x-1)


d = dq()

vis = [False for i in range(n)]

ans = 100000
nb = 0
imp = True
for i in range(n):
    if vis[i] == False:
        imp = True
        nb = 1
        d.append([i, -1])
        vis[i] = True
        while len(d) > 0:
            pos, pos_1 = d.popleft()
            for k in g[pos]:
                if not vis[k]:
                    nb += 1
                    vis[k] = True
                    d.append([k, pos])

                if pos_1 != -1:
                    for kk in g[pos_1]:
                        if kk == k:
                            imp = False

    if nb >= 3 and not imp:
        ans = min(ans, nb)

if ans == 100000:
    print(-1)
else:
    print(ans-3)
","def case():
    n = int(input())  # Read the number of cities
    cities = list(map(int, input().split()))  # Read the coordinates of the cities
    
    for i in range(n):
        # Calculate the minimum cost
        if i == 0:
            min_cost = abs(cities[i] - cities[i + 1])  # Only right neighbor
        elif i == n - 1:
            min_cost = abs(cities[i] - cities[i - 1])  # Only left neighbor
        else:
            min_cost = min(abs(cities[i] - cities[i - 1]), abs(cities[i] - cities[i + 1]))  # Neighbors
        
        # Calculate the maximum cost
        max_cost = max(abs(cities[i] - cities[0]), abs(cities[i] - cities[n - 1]))  # Between first and last city
        
        print(min_cost, max_cost)  # Print min and max costs

def main():
    case()"
239,A,Two Bags of Potatoes,PROGRAMMING,"['greedy', 'implementation', 'math']","Valera had two bags of potatoes, the first of these bags contains *x* (*x*<=≥<=1) potatoes, and the second — *y* (*y*<=≥<=1) potatoes. Valera — very scattered boy, so the first bag of potatoes (it contains *x* potatoes) Valera lost. Valera remembers that the total amount of potatoes (*x*<=+<=*y*) in the two bags, firstly, was not gerater than *n*, and, secondly, was divisible by *k*.

Help Valera to determine how many potatoes could be in the first bag. Print all such possible numbers in ascending order.","The first line of input contains three integers *y*, *k*, *n* (1<=≤<=*y*,<=*k*,<=*n*<=≤<=109;  <=≤<=105).","Print the list of whitespace-separated integers — all possible values of *x* in ascending order. You should print each possible value of *x* exactly once.

If there are no such values of *x* print a single integer -1.","['10 1 10\n', '10 6 40\n']","['-1\n', '2 8 14 20 26 \n']",none,TIME_LIMIT_EXCEEDED,"y, k , n = list(map(int, input().strip().split()))
flag = False
for x in range(1, n-y+1):
    if not (x+y)%k:
        if not flag:
            flag = True
        print(x, end=' ')

print(-1 if not flag else '')
","def is_rectangle(a, b, c, d):
    ab = (b[0]-a[0], b[1]-a[1])
    ad = (d[0]-a[0], d[1]-a[1])
    dp = ab[0]*ad[0] + ab[1]*ad[1]
    ne = len(set((a, b, c, d))) == 4
    return ne and dp == 0 and (a[0]+ab[0]+ad[0], a[1]+ab[1]+ad[1]) == c

def is_square(a, b, c, d):
    ab = (b[0]-a[0], b[1]-a[1])
    ac = (c[0]-a[0], c[1]-a[1])
    ad = (d[0]-a[0], d[1]-a[1])
    ab_length = ab[0]**2 + ab[1]**2
    ac_length = ac[0]**2 + ac[1]**2
    ad_length = ad[0]**2 + ad[1]**2
    return (ab_length == ac_length == ad_length and
            (ab[0]*ac[1] - ab[1]*ac[0]) == (0) and
            (ab[0]*ad[1] - ab[1]*ad[0]) == (0) and
            (ac[0]*ad[1] - ac[1]*ad[0]) == (0))

from itertools import combinations

points = [tuple(map(int, input().split())) for _ in range(8)]

for square_points in combinations(range(8), 4):
    square = [points[i] for i in square_points]
    rectangle_points = [i for i in range(8) if i not in square_points]
    rectangle = [points[i] for i in rectangle_points]
    
    if is_square(*square) and is_rectangle(*rectangle):
        print(""YES"")
        print("" "".join(str(i + 1) for i in square_points))
        print("" "".join(str(i + 1) for i in rectangle_points))
        break
else:
    print(""NO"")"
686,A,Free Ice Cream,PROGRAMMING,"['constructive algorithms', 'implementation']","After their adventure with the magic mirror Kay and Gerda have returned home and sometimes give free ice cream to kids in the summer.

At the start of the day they have *x* ice cream packs. Since the ice cream is free, people start standing in the queue before Kay and Gerda's house even in the night. Each person in the queue wants either to take several ice cream packs for himself and his friends or to give several ice cream packs to Kay and Gerda (carriers that bring ice cream have to stand in the same queue).

If a carrier with *d* ice cream packs comes to the house, then Kay and Gerda take all his packs. If a child who wants to take *d* ice cream packs comes to the house, then Kay and Gerda will give him *d* packs if they have enough ice cream, otherwise the child will get no ice cream at all and will leave in distress.

Kay wants to find the amount of ice cream they will have after all people will leave from the queue, and Gerda wants to find the number of distressed kids.","The first line contains two space-separated integers *n* and *x* (1<=≤<=*n*<=≤<=1000, 0<=≤<=*x*<=≤<=109).

Each of the next *n* lines contains a character '+' or '-', and an integer *d**i*, separated by a space (1<=≤<=*d**i*<=≤<=109). Record ""+ *d**i*"" in *i*-th line means that a carrier with *d**i* ice cream packs occupies *i*-th place from the start of the queue, and record ""- *d**i*"" means that a child who wants to take *d**i* packs stands in *i*-th place.","Print two space-separated integers — number of ice cream packs left after all operations, and number of kids that left the house in distress.","['5 7\n+ 5\n- 10\n- 20\n+ 40\n- 20\n', '5 17\n- 16\n- 2\n- 98\n+ 100\n- 98\n']","['22 1\n', '3 2\n']","Consider the first sample.
 1.  Initially Kay and Gerda have 7 packs of ice cream. 1.  Carrier brings 5 more, so now they have 12 packs. 1.  A kid asks for 10 packs and receives them. There are only 2 packs remaining. 1.  Another kid asks for 20 packs. Kay and Gerda do not have them, so the kid goes away distressed. 1.  Carrier bring 40 packs, now Kay and Gerda have 42 packs. 1.  Kid asks for 20 packs and receives them. There are 22 packs remaining.",OK,"a,b = map(int,input().split())
c = 0
for i in range(a):
	n = input().split()
	n1 = int(n[1])
	if n[0] == ""+"":
		b += n1
	else:
		if b < n1:
			c += 1
		else:
			b -= n1
			
print(b,c)
		
		
 				    		  	 	  		 		 	  		 	","def solve(s: str):
    a = []
    vowels = ['A', 'E', 'I', 'O', 'U', 'Y']
    flag = False

    # Collect the indices of the vowels in the string
    for i in range(len(s)):
        if s[i] in vowels:
            a.append(i)

    # Add the position after the last character
    a.append(len(s))

    # Find the minimum jump ability (maximum distance between vowels)
    min_jump_ability = 0
    for i in range(1, len(a)):
        jump_distance = a[i] - a[i - 1]
        min_jump_ability = max(min_jump_ability, jump_distance)

    print(min_jump_ability)

# Example usage
solve(""BEEKEEPER"")"
604,A,Uncowed Forces,PROGRAMMING,['implementation'],"Kevin Sun has just finished competing in Codeforces Round #334! The round was 120 minutes long and featured five problems with maximum point values of 500, 1000, 1500, 2000, and 2500, respectively. Despite the challenging tasks, Kevin was uncowed and bulldozed through all of them, distinguishing himself from the herd as the best cowmputer scientist in all of Bovinia. Kevin knows his submission time for each problem, the number of wrong submissions that he made on each problem, and his total numbers of successful and unsuccessful hacks. Because Codeforces scoring is complicated, Kevin wants you to write a program to compute his final score.

Codeforces scores are computed as follows: If the maximum point value of a problem is *x*, and Kevin submitted correctly at minute *m* but made *w* wrong submissions, then his score on that problem is . His total score is equal to the sum of his scores for each problem. In addition, Kevin's total score gets increased by 100 points for each successful hack, but gets decreased by 50 points for each unsuccessful hack.

All arithmetic operations are performed with absolute precision and no rounding. It is guaranteed that Kevin's final score is an integer.","The first line of the input contains five space-separated integers *m*1, *m*2, *m*3, *m*4, *m*5, where *m**i* (0<=≤<=*m**i*<=≤<=119) is the time of Kevin's last submission for problem *i*. His last submission is always correct and gets accepted.

The second line contains five space-separated integers *w*1, *w*2, *w*3, *w*4, *w*5, where *w**i* (0<=≤<=*w**i*<=≤<=10) is Kevin's number of wrong submissions on problem *i*.

The last line contains two space-separated integers *h**s* and *h**u* (0<=≤<=*h**s*,<=*h**u*<=≤<=20), denoting the Kevin's numbers of successful and unsuccessful hacks, respectively.","Print a single integer, the value of Kevin's final score.","['20 40 60 80 100\n0 1 2 3 4\n1 0\n', '119 119 119 119 119\n0 0 0 0 0\n10 0\n']","['4900\n', '4930\n']","In the second sample, Kevin takes 119 minutes on all of the problems. Therefore, he gets <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/42158dc2bc78cd21fa679530ae9ef8b9ea298d15.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> of the points on each problem. So his score from solving problems is <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/fdf392d8508500b57f8057ac0c4c892ab5f925a2.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>. Adding in 10·100 = 1000 points from hacks, his total score becomes 3930 + 1000 = 4930.",RUNTIME_ERROR,"m1 = int( input() )
m2 = int( input() )
m3 = int( input() )
m4 = int( input() )
m5 = int( input() )

w1 = int( input() )
w2 = int( input() )
w3 = int( input() )
w4 = int( input() )
w5 = int( input() )

hs = int( input() )
hu = int( input() )
# solution
ans = 0
ans += max( 0.3 * 500 ,  ( 1 - m1 / 250 ) * 500  - 50 * w1 )
ans += max( 0.3 * 1000 , ( 1 - m2 / 250 ) * 1000 - 50 * w2 )
ans += max( 0.3 * 1500 , ( 1 - m3 / 250 ) * 1500 - 50 * w3 )
ans += max( 0.3 * 2000 , ( 1 - m4 / 250 ) * 2000 - 50 * w4 )
ans += max( 0.3 * 2500 , ( 1 - m5 / 250 ) * 2500 - 50 * w5 )
ans += 100 * hs - 50 * hu
print( int( ans ) )
","import bisect
left  = lambda l,a : bisect.bisect_left(l,a)  # returns index of value >= a
right = lambda l,a : bisect.bisect_right(l,a) # returns index of value > a
import sys
def input(): return sys.stdin.readline().strip()

n = int(input())  # number of boys
boys_skills = list(map(int, input().split()))  # dancing skills of boys
m = int(input())  # number of girls
girls_skills = list(map(int, input().split()))  # dancing skills of girls

pairs = 0  # initialize the count of pairs
i, j = 0, 0  # pointers for boys and girls

# While there are boys and girls left to consider
while i < n and j < m:
    if abs(boys_skills[i] - girls_skills[j]) <= 1:  # check skill difference
        pairs += 1  # form a pair
        i += 1  # move to the next boy
        j += 1  # move to the next girl
    elif boys_skills[i] < girls_skills[j]:  # boy's skill is less
        i += 1  # move to the next boy
    else:  # girl's skill is less
        j += 1  # move to the next girl

print(pairs)  # output the maximum number of pairs"
855,A,Tom Riddle's Diary,PROGRAMMING,"['brute force', 'implementation', 'strings']","Harry Potter is on a mission to destroy You-Know-Who's Horcruxes. The first Horcrux that he encountered in the Chamber of Secrets is Tom Riddle's diary. The diary was with Ginny and it forced her to open the Chamber of Secrets. Harry wants to know the different people who had ever possessed the diary to make sure they are not under its influence.

He has names of *n* people who possessed the diary in order. You need to tell, for each person, if he/she possessed the diary at some point before or not.

Formally, for a name *s**i* in the *i*-th line, output ""YES"" (without quotes) if there exists an index *j* such that *s**i*<==<=*s**j* and *j*<=&lt;<=*i*, otherwise, output ""NO"" (without quotes).","First line of input contains an integer *n* (1<=≤<=*n*<=≤<=100) — the number of names in the list.

Next *n* lines each contain a string *s**i*, consisting of lowercase English letters. The length of each string is between 1 and 100.","Output *n* lines each containing either ""YES"" or ""NO"" (without quotes), depending on whether this string was already present in the stream or not.

You can print each letter in any case (upper or lower).","['6\ntom\nlucius\nginny\nharry\nginny\nharry\n', '3\na\na\na\n']","['NO\nNO\nNO\nNO\nYES\nYES\n', 'NO\nYES\nYES\n']","In test case 1, for *i* = 5 there exists *j* = 3 such that *s*<sub class=""lower-index"">*i*</sub> = *s*<sub class=""lower-index"">*j*</sub> and *j* &lt; *i*, which means that answer for *i* = 5 is ""YES"".",OK,"def tomRiddleDiary(s):
    if s in a:
        return ""YES""

    else:
        return ""NO""


a = set()
t = int(input())
while t > 0:
    s = input()
    print(tomRiddleDiary(s))
    t = t - 1
    a.add(s)
   		 	 			     		      	 	 	","import random

n, k = (int(i) for i in input('').split(' '))

# Create a list of the first k lowercase Latin letters
letters = [chr(i) for i in range(ord('a'), ord('a') + k)]

password = []

# Construct the password by alternating between the characters
for i in range(n):
    password.append(letters[i % k])

# Ensure that no two consecutive symbols are the same
# Convert list to string
new_password = ''.join(password)
print(new_password)"
915,A,Garden,PROGRAMMING,['implementation'],"Luba thinks about watering her garden. The garden can be represented as a segment of length *k*. Luba has got *n* buckets, the *i*-th bucket allows her to water some continuous subsegment of garden of length exactly *a**i* each hour. Luba can't water any parts of the garden that were already watered, also she can't water the ground outside the garden.

Luba has to choose one of the buckets in order to water the garden as fast as possible (as mentioned above, each hour she will water some continuous subsegment of length *a**i* if she chooses the *i*-th bucket). Help her to determine the minimum number of hours she has to spend watering the garden. It is guaranteed that Luba can always choose a bucket so it is possible water the garden.

See the examples for better understanding.","The first line of input contains two integer numbers *n* and *k* (1<=≤<=*n*,<=*k*<=≤<=100) — the number of buckets and the length of the garden, respectively.

The second line of input contains *n* integer numbers *a**i* (1<=≤<=*a**i*<=≤<=100) — the length of the segment that can be watered by the *i*-th bucket in one hour.

It is guaranteed that there is at least one bucket such that it is possible to water the garden in integer number of hours using only this bucket.",Print one integer number — the minimum number of hours required to water the garden.,"['3 6\n2 3 5\n', '6 7\n1 2 3 4 5 6\n']","['2\n', '7\n']","In the first test the best option is to choose the bucket that allows to water the segment of length 3. We can't choose the bucket that allows to water the segment of length 5 because then we can't water the whole garden.

In the second test we can choose only the bucket that allows us to water the segment of length 1.",OK,"def f():
    num,k=map(int,input().split())
    n=map(int, input().split())
    maxi=0
    ans=0
    for i in n:
        if(k%i==0 and i>maxi):
            maxi=i 
            ans=int(k/i)
            
    print(ans)
f()","def rec(i, s2, test):
    if i < k:
        if i == 0:
            rec(1, s2 + s[i], 0)
            x = st.index(s[i])
            if x + 1 < len(st):
                rec(1, s2 + st[x + 1], 1)
        else:
            for j in range(len(st)):
                if st[j] > s[i-1]:  # Ensure lexicographically greater
                    rec(i + 1, s2 + st[j], 1)
    else:
        # We have formed a string of length k
        if s2 > s:  # Check if the formed string is greater than s
            print(s2)  # Print the result string
            return

# Input reading
n, k = map(int, input().split())
s = input().strip()

# Create a sorted set of unique characters from the string
st = sorted(set(s))

# Start the recursive process
rec(0, '', 0)"
300,A,Array,PROGRAMMING,"['brute force', 'constructive algorithms', 'implementation']","Vitaly has an array of *n* distinct integers. Vitaly wants to divide this array into three non-empty sets so as the following conditions hold: 
 1.  The product of all numbers in the first set is less than zero (<=&lt;<=0). 1.  The product of all numbers in the second set is greater than zero (<=&gt;<=0). 1.  The product of all numbers in the third set is equal to zero. 1.  Each number from the initial array must occur in exactly one set. 
Help Vitaly. Divide the given array.","The first line of the input contains integer *n* (3<=≤<=*n*<=≤<=100). The second line contains *n* space-separated distinct integers *a*1,<=*a*2,<=...,<=*a**n* (|*a**i*|<=≤<=103) — the array elements.","In the first line print integer *n*1 (*n*1<=&gt;<=0) — the number of elements in the first set. Then print *n*1 numbers — the elements that got to the first set.

In the next line print integer *n*2 (*n*2<=&gt;<=0) — the number of elements in the second set. Then print *n*2 numbers — the elements that got to the second set.

In the next line print integer *n*3 (*n*3<=&gt;<=0) — the number of elements in the third set. Then print *n*3 numbers — the elements that got to the third set.

The printed sets must meet the described conditions. It is guaranteed that the solution exists. If there are several solutions, you are allowed to print any of them.","['3\n-1 2 0\n', '4\n-1 -2 -3 0\n']","['1 -1\n1 2\n1 0\n', '1 -1\n2 -3 -2\n1 0\n']",none,WRONG_ANSWER,"while 1:
    try:

        data = int(input())
        values = [int(i) for i in input().split(' ')]

        negative_set = list()
        positive_set = list()
        zero_set = list()

        # since it is guaranteed that the solution exitsts
        # so i can just put 1 negative in the 1st set zeros in the 3rd set
        # other can all be inside the 2nd set 
        check_one_negative_number = 0
        for i in values:
            if i == 0:
                zero_set.append(i)
            elif i > 0:
                positive_set.append(i)
            else:
                if check_one_negative_number == 0:
                    negative_set.append(i)
                    check_one_negative_number = 1
                else:
                    positive_set.append(i)
            
                
        print(len(negative_set),str(negative_set[0]))
        print(len(positive_set),' '.join(str(i) for i in positive_set))
        print(len(zero_set),' '.join(str(i) for i in zero_set).strip())
    except:
        break","# hashing,implementation
# https://codeforces.com/problemset/problem/2/A
# A. Winner

import sys
from typing import Dict

numInputs: int = int(sys.stdin.readline())

# Dictionary to maintain the scores of players
scores: Dict[str, int] = {}

# Reading the rounds and updating scores
for _ in range(numInputs):
    line = sys.stdin.readline().strip().split()
    player, score = line[0], int(line[1])
    if player not in scores:
        scores[player] = 0
    scores[player] += score

# Determine the maximum score
max_score = max(scores.values())

# Find all players with the maximum score
winners = [player for player, score in scores.items() if score == max_score]

# If there is only one winner, print their name
if len(winners) == 1:
    print(winners[0])
else:
    # If there are multiple winners, we need to determine who scored
    # at least max_score first
    cumulative_scores = {}
    for _ in range(numInputs):
        line = sys.stdin.readline().strip().split()
        player, score = line[0], int(line[1])
        if player not in cumulative_scores:
            cumulative_scores[player] = 0
        cumulative_scores[player] += score

        # Check if the player is among the winners and has reached max_score
        if player in winners and cumulative_scores[player] >= max_score:
            print(player)
            break"
540,A,Combination Lock,PROGRAMMING,['implementation'],"Scrooge McDuck keeps his most treasured savings in a home safe with a combination lock. Each time he wants to put there the treasures that he's earned fair and square, he has to open the lock.

The combination lock is represented by *n* rotating disks with digits from 0 to 9 written on them. Scrooge McDuck has to turn some disks so that the combination of digits on the disks forms a secret combination. In one move, he can rotate one disk one digit forwards or backwards. In particular, in one move he can go from digit 0 to digit 9 and vice versa. What minimum number of actions does he need for that?","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=1000) — the number of disks on the combination lock.

The second line contains a string of *n* digits — the original state of the disks.

The third line contains a string of *n* digits — Scrooge McDuck's combination that opens the lock.",Print a single integer — the minimum number of moves Scrooge McDuck needs to open the lock.,['5\n82195\n64723\n'],['13\n'],"In the sample he needs 13 moves:
 -  1 disk: <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/b8967f65a723782358b93eff9ce69f336817cf70.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> -  2 disk: <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/07fa58573ece0d32c4d555e498d2b24d2f70f36a.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> -  3 disk: <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/cc2275d9252aae35a6867c6a5b4ba7596e9a7626.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> -  4 disk: <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/b100aea470fcaaab4e9529b234ba0d7875943c10.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> -  5 disk: <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/eb2cbe4324cebca65b85816262a85e473cd65967.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>",OK,"n = int(input())
comb1 = list(map(int, ' '.join(input()).split()))
comb2 = list(map(int, ' '.join(input()).split()))
count = 0
for i in range(n):
    a = abs(comb1[i] - comb2[i])
    b = 10 - a
    count += min(a, b)
print(count)","def editor():
    import sys
    sys.stdin = open(""input.txt"", 'r')
    sys.stdout = open(""output.txt"", 'w')

def solve():
    # Read input values
    x, y, a, b = map(int, input().strip().split())
    
    # Calculate the least common multiple (LCM) of x and y
    from math import gcd
    lcm = (x * y) // gcd(x, y)
    
    # Calculate the first multiple of lcm that is >= a
    start = ((a + lcm - 1) // lcm) * lcm
    
    # Calculate the last multiple of lcm that is <= b
    end = (b // lcm) * lcm
    
    # Count the number of multiples of lcm in the range [a, b]
    if start > end:
        print(0)
    else:
        count = (end - start) // lcm + 1
        print(count)

editor()
solve()"
669,A,Little Artem and Presents,PROGRAMMING,['math'],"Little Artem got *n* stones on his birthday and now wants to give some of them to Masha. He knows that Masha cares more about the fact of receiving the present, rather than the value of that present, so he wants to give her stones as many times as possible. However, Masha remembers the last present she received, so Artem can't give her the same number of stones twice in a row. For example, he can give her 3 stones, then 1 stone, then again 3 stones, but he can't give her 3 stones and then again 3 stones right after that.

How many times can Artem give presents to Masha?",The only line of the input contains a single integer *n* (1<=≤<=*n*<=≤<=109) — number of stones Artem received on his birthday.,Print the maximum possible number of times Artem can give presents to Masha.,"['1\n', '2\n', '3\n', '4\n']","['1\n', '1\n', '2\n', '3\n']","In the first sample, Artem can only give 1 stone to Masha.

In the second sample, Atrem can give Masha 1 or 2 stones, though he can't give her 1 stone two times.

In the third sample, Atrem can first give Masha 2 stones, a then 1 more stone.

In the fourth sample, Atrem can first give Masha 1 stone, then 2 stones, and finally 1 stone again.",OK,"a = int(input())
print(a // 3 * 2 + (a % 3 > 0))","# Author Name: Ajay Meena
# Codeforce : https://codeforces.com/profile/majay1638
import sys
import math
import bisect
import heapq
from bisect import bisect_right
from sys import stdin, stdout

def next_tolerable_string(n, p, s):
    # Convert string to a list of characters for easier manipulation
    s = list(s)
    
    # Function to check if the string is tolerable
    def is_tolerable(s):
        for i in range(1, len(s)):
            if s[i] == s[i - 1]:  # Check for 2-character palindromes
                return False
        return True

    for i in range(n - 1, -1, -1):  # Start from the last character and move backwards
        if s[i] < chr(ord('a') + p - 1):  # Can increment this character
            s[i] = chr(ord(s[i]) + 1)  # Increment the character
            
            # Set all following characters to the smallest character
            for j in range(i + 1, n):
                s[j] = 'a'
            
            # Ensure we do not create any palindromes
            if is_tolerable(s):
                return ''.join(s)

    return ""NO""  # No tolerable string exists

# Read input
n, p = map(int, input().split())
s = input().strip()

# Get the result
result = next_tolerable_string(n, p, s)

# Output the result
print(result)"
721,C,Journey,PROGRAMMING,"['dp', 'graphs']","Recently Irina arrived to one of the most famous cities of Berland — the Berlatov city. There are *n* showplaces in the city, numbered from 1 to *n*, and some of them are connected by one-directional roads. The roads in Berlatov are designed in a way such that there are no cyclic routes between showplaces.

Initially Irina stands at the showplace 1, and the endpoint of her journey is the showplace *n*. Naturally, Irina wants to visit as much showplaces as she can during her journey. However, Irina's stay in Berlatov is limited and she can't be there for more than *T* time units.

Help Irina determine how many showplaces she may visit during her journey from showplace 1 to showplace *n* within a time not exceeding *T*. It is guaranteed that there is at least one route from showplace 1 to showplace *n* such that Irina will spend no more than *T* time units passing it.","The first line of the input contains three integers *n*,<=*m* and *T* (2<=≤<=*n*<=≤<=5000,<=<=1<=≤<=*m*<=≤<=5000,<=<=1<=≤<=*T*<=≤<=109) — the number of showplaces, the number of roads between them and the time of Irina's stay in Berlatov respectively.

The next *m* lines describes roads in Berlatov. *i*-th of them contains 3 integers *u**i*,<=*v**i*,<=*t**i* (1<=≤<=*u**i*,<=*v**i*<=≤<=*n*,<=*u**i*<=≠<=*v**i*,<=1<=≤<=*t**i*<=≤<=109), meaning that there is a road starting from showplace *u**i* and leading to showplace *v**i*, and Irina spends *t**i* time units to pass it. It is guaranteed that the roads do not form cyclic routes.

It is guaranteed, that there is at most one road between each pair of showplaces.","Print the single integer *k* (2<=≤<=*k*<=≤<=*n*) — the maximum number of showplaces that Irina can visit during her journey from showplace 1 to showplace *n* within time not exceeding *T*, in the first line.

Print *k* distinct integers in the second line — indices of showplaces that Irina will visit on her route, in the order of encountering them.

If there are multiple answers, print any of them.","['4 3 13\n1 2 5\n2 3 7\n2 4 8\n', '6 6 7\n1 2 2\n1 3 3\n3 6 3\n2 4 2\n4 6 2\n6 5 1\n', '5 5 6\n1 3 3\n3 5 3\n1 2 2\n2 4 3\n4 5 2\n']","['3\n1 2 4 \n', '4\n1 2 4 6 \n', '3\n1 3 5 \n']",none,WRONG_ANSWER,"
n, m, T = map(int, input().split())
adj = [[] for _ in range(n+1)]
adj_w = [[] for _ in range(n+1)]
dp = [[0 for _ in range(n+1)] for _ in range(n+1)]
pv1 = [[1] for _ in range(n+1)]
pv2 = [[1] for _ in range(n+1)]

for i in range(m):
    a, b, t = map(int, input().split())
    adj[b].append(a)
    adj_w[b].append(t)
    if a == 1:
        dp[b][2] = t
        pv1[b].append(b)
        pv2[b].append(b)

for c in range(3, n + 1):
    for v in range(2, n + 1):
        for i, nx in enumerate(adj[v]):
            if nx == n or not dp[nx][c-1]:continue

            newdistance = dp[nx][c-1] + adj_w[v][i]
            if newdistance <= T and (not dp[v][c] or newdistance < dp[v][c]):
                dp[v][c] = newdistance
                pv1[v] = pv1[nx]
                pv1[v].append(v)


                if m == 98 :
                    print(pv1[50])

                pv1[nx] = pv2[nx].copy()

print(len(pv1[n]))
print(' '.join(map(str, pv1[n])))
","def steps(a):
    global num
    p = 0
    p += a    
    a *= a
    while a <= 10 ** 18:
        num.append(a)
        a *= p

def calculate_numbers():
    global num
    num = []
    # Iterate over possible values for a from 1 to some reasonable upper limit.
    for a in range(1, 10):  # a should be less than or equal to 9 for p to be <= 1
        steps(a)

def count_valid_x(L, R):
    global num
    # Count how many numbers in num are within the range [L, R]
    return sum(1 for x in num if L <= x <= R)

def main():
    global num
    calculate_numbers()
    num.sort()  # Sort numbers for binary search or for efficient counting if needed

    Q = int(input().strip())
    results = []
    for _ in range(Q):
        L, R = map(int, input().strip().split())
        results.append(count_valid_x(L, R))

    # Output results for each query
    for result in results:
        print(result)

if __name__ == ""__main__"":
    main()"
913,A,Modular Exponentiation,PROGRAMMING,"['implementation', 'math']","The following problem is well-known: given integers *n* and *m*, calculate

where 2*n*<==<=2·2·...·2 (*n* factors), and  denotes the remainder of division of *x* by *y*.

You are asked to solve the ""reverse"" problem. Given integers *n* and *m*, calculate","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=108).

The second line contains a single integer *m* (1<=≤<=*m*<=≤<=108).",Output a single integer — the value of .,"['4\n42\n', '1\n58\n', '98765432\n23456789\n']","['10\n', '0\n', '23456789\n']","In the first example, the remainder of division of 42 by 2<sup class=""upper-index"">4</sup> = 16 is equal to 10.

In the second example, 58 is divisible by 2<sup class=""upper-index"">1</sup> = 2 without remainder, and the answer is 0.",TIME_LIMIT_EXCEEDED,n = int(input());m = int(input());q = 2**n;w = m%q;print(w),"def solve():
    n = int(input())
    j = 0
    i = 1
    k = n
    result = []

    # Create the route plan
    while i <= n:
        result.append(i)  # Add the current mound to the route
        i += 1  # Move to the next mound

    # The output must include all numbers from 1 to n
    print(*result)

solve()"
192,A,Funky Numbers,PROGRAMMING,"['binary search', 'brute force', 'implementation']","As you very well know, this year's funkiest numbers are so called triangular numbers (that is, integers that are representable as , where *k* is some positive integer), and the coolest numbers are those that are representable as a sum of two triangular numbers.

A well-known hipster Andrew adores everything funky and cool but unfortunately, he isn't good at maths. Given number *n*, help him define whether this number can be represented by a sum of two triangular numbers (not necessarily different)!",The first input line contains an integer *n* (1<=≤<=*n*<=≤<=109).,"Print ""YES"" (without the quotes), if *n* can be represented as a sum of two triangular numbers, otherwise print ""NO"" (without the quotes).","['256\n', '512\n']","['YES\n', 'NO\n']","In the first sample number <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/92095692c6ea93e9e3b837a0408ba7543549d5b2.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>.

In the second sample number 512 can not be represented as a sum of two triangular numbers.",OK,"import sys, os.path
from collections import*
from copy import*
import math
mod=10**9+7
if(os.path.exists('input.txt')):
    sys.stdin = open(""input.txt"",""r"")
    sys.stdout = open(""output.txt"",""w"")

def bs(left,right,x):
    while(left<=right):
        mid=left+(right-left)//2
        b=(mid*(mid+1))//2
        if(b==x):
            return 1
        elif(b>x):
            right=mid-1
        else:
            left=mid+1
    return 0
n=int(input())
n1=10**5
flag=0
for i in range(1,n1+1):
    a=(i*(i+1))//2
    if(bs(1,n1,n-a)):
        flag=1
        break
if(flag==0):
    print('NO')
else:
    print('YES')
    
    

","# بسم الله الرحمن الرحيم
def main():
    n = int(input())
    assert n >= 2
    phone = input().strip()
    
    result = []
    i = 0
    
    while i < n:
        # Check if we can take a group of three digits
        if i + 2 < n and (n - i) % 2 != 0:
            result.append(phone[i:i+3])
            i += 3
        else:
            result.append(phone[i:i+2])
            i += 2
    
    # Join the groups with '-' and print the result
    print('-'.join(result))

if __name__ == ""__main__"":
    main()"
121,A,Lucky Sum,PROGRAMMING,['implementation'],"Petya loves lucky numbers. Everybody knows that lucky numbers are positive integers whose decimal representation contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.

Let *next*(*x*) be the minimum lucky number which is larger than or equals *x*. Petya is interested what is the value of the expression *next*(*l*)<=+<=*next*(*l*<=+<=1)<=+<=...<=+<=*next*(*r*<=-<=1)<=+<=*next*(*r*). Help him solve this problem.",The single line contains two integers *l* and *r* (1<=≤<=*l*<=≤<=*r*<=≤<=109) — the left and right interval limits.,"In the single line print the only number — the sum *next*(*l*)<=+<=*next*(*l*<=+<=1)<=+<=...<=+<=*next*(*r*<=-<=1)<=+<=*next*(*r*).

Please do not use the %lld specificator to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specificator.","['2 7\n', '7 7\n']","['33\n', '7\n']","In the first sample: *next*(2) + *next*(3) + *next*(4) + *next*(5) + *next*(6) + *next*(7) = 4 + 4 + 4 + 7 + 7 + 7 = 33

In the second sample: *next*(7) = 7",WRONG_ANSWER,"import sys
input = sys.stdin.readline

############ ---- Input Functions ---- ############
def inp():
    return(int(input()))
def inlt():
    return(list(map(int,input().split())))
def insr():
    s = input()
    return(list(s[:len(s) - 1]))
def invr():
    return(map(int,input().split()))
############ ---- Input Functions ---- ############


def Lucky_Sum2():
    l,r = invr()

    luckyNum = [4,7]

    startLuckyNum = -1 
    if luckyNum[0] >= l and startLuckyNum == -1:
        startLuckyNum = luckyNum[0] 
    if luckyNum[1] >= l and startLuckyNum == -1:
        startLuckyNum = luckyNum[1]

    index = 0
    
    #start = time.time()
    while True:        
        num1 = (luckyNum[index]*10)+4
        num2 = (luckyNum[index]*10)+7

        if num1 >= l and startLuckyNum == -1:
            startLuckyNum = num1 
        if num2 >= l and startLuckyNum == -1:
            startLuckyNum = num2 

        if num1 >= r :
            luckyNum.append(num1)
            break  
        else:
            luckyNum.append(num1)
        if num2 >= r:
            luckyNum.append(num2)
            break 
        else:
            luckyNum.append(num2)

        index += 1
    #end = time.time()
    #print(""While loop time:"", (end-start))
    
    #start = time.time()
    startIndex = luckyNum.index(startLuckyNum)
    #end = time.time()
    #print(""Indexing time:"", end - start)
    
    sum = 0 
    #start = time.time() 
    
    for movingIndex in range(startIndex,len(luckyNum)):
        num = luckyNum[movingIndex]

        if movingIndex  == startIndex:
            numTimesRepeated = (num - l) + 1 
        elif movingIndex == len(luckyNum)-1:
            prevNum = luckyNum[movingIndex-1]
            numTimesRepeated = (r - (prevNum+1)) + 1
        else:
            prevNum = luckyNum[movingIndex-1]
            numTimesRepeated = num - prevNum
        
        sum += (num*numTimesRepeated)


    #end = time.time()
    #print(""For loop time:"", end - start)
    print(sum)
    return

Lucky_Sum2()","def es(m):
    r = -1
    c = -1
    
    # Find the position of '1' in the matrix
    for i in range(5):
        for j in range(5):
            if m[i][j] == 1:
                r = i
                c = j
                
    # Calculate the number of moves to center '1' at (2, 2)
    moves = abs(r - 2) + abs(c - 2)
    
    return moves

# Read the matrix from input
matrix = [list(map(int, input().split())) for _ in range(5)]

# Output the result
print(es(matrix))"
453,E,Little Pony and Lord Tirek,PROGRAMMING,['data structures'],"Lord Tirek is a centaur and the main antagonist in the season four finale episodes in the series ""My Little Pony: Friendship Is Magic"". In ""Twilight's Kingdom"" (Part 1), Tirek escapes from Tartarus and drains magic from ponies to grow stronger.

The core skill of Tirek is called Absorb Mana. It takes all mana from a magic creature and gives them to the caster.

Now to simplify the problem, assume you have *n* ponies (numbered from 1 to *n*). Each pony has three attributes:
 -  *s**i* : amount of mana that the pony has at time 0; -  *m**i* : maximum mana that the pony can have; -  *r**i* : mana regeneration per unit time. 
Lord Tirek will do *m* instructions, each of them can be described with three integers: *t**i*,<=*l**i*,<=*r**i*. The instruction means that at time *t**i*, Tirek will use Absorb Mana on ponies with numbers from *l**i* to *r**i* (both borders inclusive). We'll give you all the *m* instructions in order, count how much mana Tirek absorbs for each instruction.","The first line contains an integer *n* (1<=≤<=*n*<=≤<=105) — the number of ponies. Each of the next *n* lines contains three integers *s**i*,<=*m**i*,<=*r**i* (0<=≤<=*s**i*<=≤<=*m**i*<=≤<=105; 0<=≤<=*r**i*<=≤<=105), describing a pony. 

The next line contains an integer *m* (1<=≤<=*m*<=≤<=105) — the number of instructions. Each of the next *m* lines contains three integers *t**i*,<=*l**i*,<=*r**i* (0<=≤<=*t**i*<=≤<=109; 1<=≤<=*l**i*<=≤<=*r**i*<=≤<=*n*), describing an instruction of Lord Tirek. The instructions are given in strictly increasing order of *t**i* (all *t**i* are distinct).","For each instruction, output a single line which contains a single integer, the total mana absorbed in this instruction.",['5\n0 10 1\n0 12 1\n0 20 1\n0 12 1\n0 10 1\n2\n5 1 5\n19 1 5\n'],['25\n58\n'],"Every pony starts with zero mana. For the first instruction, each pony has 5 mana, so you get 25 mana in total and each pony has 0 mana after the first instruction.

For the second instruction, pony 3 has 14 mana and other ponies have mana equal to their *m*<sub class=""lower-index"">*i*</sub>.",RUNTIME_ERROR,"pony_count = int(input())
ponies = []
for _ in range(pony_count):
    ponies.append([int(i) for i in input()])
instruction_count = int(input())
for _ in range(instruction_count):
    time,x,y = [int(i) for i in input()]
    mana_absorbed = 0
    for pony in ponies:
        amount = min(pony[2]*time,pony[1])-pony[0]
        mana_absorbed+=amount
    print(mana_absorbed)","class tree(object):
    def __init__(self, data, parent=None):
        self.data = data
        self.children = []
        self.parent = parent

    def __str__(self):
        return str(self.data)

def build_trees(h, a):
    if a[0] > 1:
        # Build two non-isomorphic trees
        tree1 = [0] * (sum(a) + 1)
        tree2 = [0] * (sum(a) + 1)

        # First tree: Linear structure at the first level
        for i in range(1, a[1] + 1):
            tree1[i] = 1  # all children of the root

        current_index = a[1] + 1
        for i in range(2, h + 1):
            for j in range(a[i]):
                tree1[current_index] = 1 if j < min(a[i - 1], a[i]) else (current_index - 1)  # creating links
                current_index += 1

        # Second tree: Some children on the first level, others at the second level
        tree2[1] = 1  # root has one child
        child_count = 2
        for i in range(1, a[1]):
            tree2[child_count] = 1  # linking children
            child_count += 1
        
        if a[1] > 1:
            tree2[2] = 3  # second child of root has one child
            for i in range(1, a[2]):
                tree2[child_count] = 2  # children below the second child
                child_count += 1

        return ""ambiguous"", tree1, tree2

    return ""perfect"",

h = int(input())
a = list(map(int, input().split()))

result = build_trees(h, a)
if result[0] == ""perfect"":
    print(""perfect"")
else:
    print(""ambiguous"")
    print("" "".join(map(str, result[1])))
    print("" "".join(map(str, result[2])))"
214,A,System of Equations,PROGRAMMING,['brute force'],"Furik loves math lessons very much, so he doesn't attend them, unlike Rubik. But now Furik wants to get a good mark for math. For that Ms. Ivanova, his math teacher, gave him a new task. Furik solved the task immediately. Can you?

You are given a system of equations: 

You should count, how many there are pairs of integers (*a*,<=*b*) (0<=≤<=*a*,<=*b*) which satisfy the system.","A single line contains two integers *n*,<=*m* (1<=≤<=*n*,<=*m*<=≤<=1000) — the parameters of the system. The numbers on the line are separated by a space.",On a single line print the answer to the problem.,"['9 3\n', '14 28\n', '4 20\n']","['1\n', '1\n', '0\n']","In the first sample the suitable pair is integers (3, 0). In the second sample the suitable pair is integers (3, 5). In the third sample there is no suitable pair.",OK,"import sys
import math

def function():
    n, m = map(int, input().split())
    ans = 0 
    for a in range(1001):
        for b in range(1001):
            if (a**2) + b == n and a + (b**2) == m:
                ans+=1
    print(ans)
    return


if __name__ == '__main__':
    function()
","import math

def petriciumus_cifera(k, l):
    # Initialize importance to 0
    importance = 0
    
    # Check if l is a power of k
    while l > 1:
        # Check if l is divisible by k
        if l % k != 0:
            return ""NO""  # If not divisible, it's not in the set
        l //= k  # Divide l by k
        importance += 1  # Increase importance for each division
    
    # If we divided down to 1, it's a power of k
    return ""YES\n"" + str(importance) if l == 1 else ""NO""

# Example usage:
# k = 3
# l = 9
# print(petriciumus_cifera(k, l))"
445,A,DZY Loves Chessboard,PROGRAMMING,"['dfs and similar', 'implementation']","DZY loves chessboard, and he enjoys playing with it.

He has a chessboard of *n* rows and *m* columns. Some cells of the chessboard are bad, others are good. For every good cell, DZY wants to put a chessman on it. Each chessman is either white or black. After putting all chessmen, DZY wants that no two chessmen with the same color are on two adjacent cells. Two cells are adjacent if and only if they share a common edge.

You task is to find any suitable placement of chessmen on the given chessboard.","The first line contains two space-separated integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=100).

Each of the next *n* lines contains a string of *m* characters: the *j*-th character of the *i*-th string is either ""."" or ""-"". A ""."" means that the corresponding cell (in the *i*-th row and the *j*-th column) is good, while a ""-"" means it is bad.","Output must contain *n* lines, each line must contain a string of *m* characters. The *j*-th character of the *i*-th string should be either ""W"", ""B"" or ""-"". Character ""W"" means the chessman on the cell is white, ""B"" means it is black, ""-"" means the cell is a bad cell.

If multiple answers exist, print any of them. It is guaranteed that at least one answer exists.","['1 1\n.\n', '2 2\n..\n..\n', '3 3\n.-.\n---\n--.']","['B\n', 'BW\nWB\n', 'B-B\n---\n--B']","In the first sample, DZY puts a single black chessman. Of course putting a white one is also OK.

In the second sample, all 4 cells are good. No two same chessmen share an edge in the sample output.

In the third sample, no good cells are adjacent. So you can just put 3 chessmen, no matter what their colors are.",WRONG_ANSWER,"r,c = map(int,input().split())
ans = ''
turn = 'b'
for i in range(1,r+1):
    b = input()
    print(i,1)
    if b == '':
        break
    for e in range(len(b)):
        print(e,2)
        if b[e] == '.':
            if turn == 'b':
                ans += 'B'
                turn = 'w'
                continue
            elif turn == 'w':
                ans += 'W'
                turn = 'b'
                continue
        elif b[e] == '-':
            ans += '-'
            if turn == 'b':
                turn = 'w'
                continue
            elif turn == 'w':
                turn = 'b'
                continue
    ans += '\n'
    if c%2 == 0:
        if turn == 'b':
            turn = 'w'
        elif turn == 'w':
            turn = 'b'
print(ans)","n, m = map(int, input().split())
fact1 = 1
fact2 = 1

# Calculate factorial of n (A)
for i in range(1, n + 1):
    fact1 = fact1 * i

# Calculate factorial of m (B)
for i in range(1, m + 1):
    fact2 = fact2 * i

# Function to compute GCD
def gcd(x, y):
    while y:
        x, y = y, x % y
    return x

# Since GCD(A!, B!) = min(A!, B!) when A != B
# The GCD of factorials is the factorial of the minimum of the two numbers
result = fact1 if n < m else fact2

# Print the result
print(result)"
43,A,Football,PROGRAMMING,['strings'],"One day Vasya decided to have a look at the results of Berland 1910 Football Championship’s finals. Unfortunately he didn't find the overall score of the match; however, he got hold of a profound description of the match's process. On the whole there are *n* lines in that description each of which described one goal. Every goal was marked with the name of the team that had scored it. Help Vasya, learn the name of the team that won the finals. It is guaranteed that the match did not end in a tie.",The first line contains an integer *n* (1<=≤<=*n*<=≤<=100) — the number of lines in the description. Then follow *n* lines — for each goal the names of the teams that scored it. The names are non-empty lines consisting of uppercase Latin letters whose lengths do not exceed 10 symbols. It is guaranteed that the match did not end in a tie and the description contains no more than two different teams.,Print the name of the winning team. We remind you that in football the team that scores more goals is considered the winner.,"['1\nABC\n', '5\nA\nABA\nABA\nA\nA\n']","['ABC\n', 'A\n']",none,OK,"#football 43A
n_l = int(input())
team = []
for i in range(n_l):
   team.append(input())
print(max(team, key = team.count))","# Convert chessboard coordinates to numerical indices
def position_to_indices(pos):
    column = ord(pos[0]) - ord('a') + 1  # Convert letter to number (1-8)
    row = int(pos[1])                    # Row remains as number (1-8)
    return row, column

# Get a list of possible moves
def get_moves(start, end):
    moves = []
    directions = {
        (1, 0): 'U', (0, 1): 'R', (-1, 0): 'D', (0, -1): 'L',
        (1, 1): 'RU', (1, -1): 'LU', (-1, 1): 'RD', (-1, -1): 'LD'
    }
    
    while start != end:
        row_diff = end[0] - start[0]
        col_diff = end[1] - start[1]

        # Move in the direction of the target square
        if row_diff > 0:
            start = (start[0] + 1, start[1])
            moves.append('U')
        elif row_diff < 0:
            start = (start[0] - 1, start[1])
            moves.append('D')

        if col_diff > 0:
            start = (start[0], start[1] + 1)
            moves.append('R')
        elif col_diff < 0:
            start = (start[0], start[1] - 1)
            moves.append('L')

        # If both row and column differ by 1, perform diagonal move
        if abs(row_diff) > 1 or abs(col_diff) > 1:
            if row_diff > 0 and col_diff > 0:
                start = (start[0] + 1, start[1] + 1)
                moves[-1] = 'RU'
            elif row_diff > 0 and col_diff < 0:
                start = (start[0] + 1, start[1] - 1)
                moves[-1] = 'LU'
            elif row_diff < 0 and col_diff > 0:
                start = (start[0] - 1, start[1] + 1)
                moves[-1] = 'RD'
            elif row_diff < 0 and col_diff < 0:
                start = (start[0] - 1, start[1] - 1)
                moves[-1] = 'LD'

    return moves

# Input squares
s = input().strip()
t = input().strip()

# Calculate positions
start = position_to_indices(s)
end = position_to_indices(t)

# Get the move list
moves = get_moves(start, end)

# Output result
print(len(moves))  # Print number of moves
for move in moves:  # Print each move
    print(move)"
385,B,Bear and Strings,PROGRAMMING,"['brute force', 'greedy', 'implementation', 'math', 'strings']","The bear has a string *s*<==<=*s*1*s*2... *s*|*s*| (record |*s*| is the string's length), consisting of lowercase English letters. The bear wants to count the number of such pairs of indices *i*,<=*j* (1<=≤<=*i*<=≤<=*j*<=≤<=|*s*|), that string *x*(*i*,<=*j*)<==<=*s**i**s**i*<=+<=1... *s**j* contains at least one string ""bear"" as a substring.

String *x*(*i*,<=*j*) contains string ""bear"", if there is such index *k* (*i*<=≤<=*k*<=≤<=*j*<=-<=3), that *s**k*<==<=*b*, *s**k*<=+<=1<==<=*e*, *s**k*<=+<=2<==<=*a*, *s**k*<=+<=3<==<=*r*.

Help the bear cope with the given problem.",The first line contains a non-empty string *s* (1<=≤<=|*s*|<=≤<=5000). It is guaranteed that the string only consists of lowercase English letters.,Print a single number — the answer to the problem.,"['bearbtear\n', 'bearaabearc\n']","['6\n', '20\n']","In the first sample, the following pairs (*i*, *j*) match: (1, 4), (1, 5), (1, 6), (1, 7), (1, 8), (1, 9).

In the second sample, the following pairs (*i*, *j*) match: (1,  4), (1,  5), (1,  6), (1,  7), (1,  8), (1,  9), (1,  10), (1,  11), (2,  10), (2,  11), (3,  10), (3,  11), (4,  10), (4,  11), (5,  10), (5,  11), (6,  10), (6,  11), (7,  10), (7,  11).",WRONG_ANSWER,"def count_(s):
    n = len(s)
    count = 0
    posi = []

    for i in range(n - 3):
        if s[i:i + 4] == ""bear"":
            posi.append(i)

    for i in posi:
        l = i + 1
        r = n - (i + 3) - 1
        count += l * r

    return count

s = input()
print(count_(s))","import sys

# Get Input
# sys.stdin = open(""input.txt"",""r"")
input = sys.stdin.readline

# Input Functions #
def inp():
    return list(map(int, input().strip()))

# Main Function
def main():
    n, k = map(int, input().strip().split())
    d = inp()

    for _ in range(k):
        found = False
        for i in range(n):
            if d[i] < 4:
                d[i] = 4  # Assign 4 if the digit is less than 4
                found = True
                break
            elif d[i] < 7:
                if (i + 1) % 2 == 1:  # Odd position
                    d[i] = 4  # Assign 4 if the position is odd
                else:  # Even position
                    d[i] = 7  # Assign 7 if the position is even
                found = True
                break
        
        # If no digit was changed, break the loop
        if not found:
            break

    print(''.join(map(str, d)))

if __name__ == ""__main__"":
    main()"
1,A,Theatre Square,PROGRAMMING,['math'],"Theatre Square in the capital city of Berland has a rectangular shape with the size *n*<=×<=*m* meters. On the occasion of the city's anniversary, a decision was taken to pave the Square with square granite flagstones. Each flagstone is of the size *a*<=×<=*a*.

What is the least number of flagstones needed to pave the Square? It's allowed to cover the surface larger than the Theatre Square, but the Square has to be covered. It's not allowed to break the flagstones. The sides of flagstones should be parallel to the sides of the Square.","The input contains three positive integer numbers in the first line: *n*,<=<=*m* and *a* (1<=≤<=<=*n*,<=*m*,<=*a*<=≤<=109).",Write the needed number of flagstones.,['6 6 4\n'],['4\n'],none,TIME_LIMIT_EXCEEDED,"n,m,a=map(int,input("""").split())
num1=0
num2=0
while n>=a:
    num1+=1
    n=n-a
while m>=a:
    num2+=1
    m=m-a
if n!=0:
    num1+=1
if m!=0:
    num2+=1
print(num1*num2)","class CodeforcesTask359ASolution:
    def __init__(self):
        self.result = ''
        self.n_m = []
        self.board = []

    def read_input(self):
        # Read the dimensions of the table
        self.n_m = list(map(int, input().split()))
        self.n, self.m = self.n_m[0], self.n_m[1]
        self.board = []
        
        # Read the table cells
        for _ in range(self.n):
            self.board.append(list(map(int, input().split())))
    
    def solve(self):
        # Initialize a variable to track good cells
        good_cells = 0
        
        # Count the number of good cells in the board
        for row in self.board:
            good_cells += sum(row)
        
        # If there are no good cells, we can't perform any operation
        if good_cells == 0:
            self.result = '0'
            return
        
        # Corner positions
        corners = [(1, 1), (1, self.m), (self.n, 1), (self.n, self.m)]
        
        # We can always color the table in a maximum of 4 operations (one for each corner)
        self.result = str(min(4, good_cells))

    def get_result(self):
        # Output the final result
        print(self.result)
    
# Main execution block
if __name__ == ""__main__"":
    solution = CodeforcesTask359ASolution()
    solution.read_input()
    solution.solve()
    solution.get_result()"
805,B,3-palindrome,PROGRAMMING,['constructive algorithms'],"In the beginning of the new year Keivan decided to reverse his name. He doesn't like palindromes, so he changed Naviek to Navick.

He is too selfish, so for a given *n* he wants to obtain a string of *n* characters, each of which is either 'a', 'b' or 'c', with no palindromes of length 3 appearing in the string as a substring. For example, the strings ""abc"" and ""abca"" suit him, while the string ""aba"" doesn't. He also want the number of letters 'c' in his string to be as little as possible.",The first line contains single integer *n* (1<=≤<=*n*<=≤<=2·105) — the length of the string.,"Print the string that satisfies all the constraints.

If there are multiple answers, print any of them.","['2\n', '3\n']","['aa\n', 'bba\n']",A palindrome is a sequence of characters which reads the same backward and forward.,OK,"n = int(input())
k=""aabb""
print(k*(n//4)+k[:n%4])","from math import factorial

def count(n, k):
    return factorial(n) // (factorial(k) * factorial(n - k))

n, m = map(int, input().split())
table = []

# Read the colored table
for _ in range(n):
    table.append(list(map(int, input().split())))

result = 0

# Count sets for each row
for row in table:
    white_count = row.count(0)
    black_count = row.count(1)
    
    # Count non-empty subsets of white cells
    if white_count > 0:
        result += (1 << white_count) - 1  # Total subsets minus empty set
    # Count non-empty subsets of black cells
    if black_count > 0:
        result += (1 << black_count) - 1  # Total subsets minus empty set

# Count sets for each column
for col in range(m):
    white_count = sum(1 for row in range(n) if table[row][col] == 0)
    black_count = sum(1 for row in range(n) if table[row][col] == 1)
    
    # Count non-empty subsets of white cells
    if white_count > 0:
        result += (1 << white_count) - 1  # Total subsets minus empty set
    # Count non-empty subsets of black cells
    if black_count > 0:
        result += (1 << black_count) - 1  # Total subsets minus empty set

print(result)"
60,B,Serial Time!,PROGRAMMING,"['dfs and similar', 'dsu']","The Cereal Guy's friend Serial Guy likes to watch soap operas. An episode is about to start, and he hasn't washed his plate yet. But he decided to at least put in under the tap to be filled with water. The plate can be represented by a parallelepiped *k*<=×<=*n*<=×<=*m*, that is, it has *k* layers (the first layer is the upper one), each of which is a rectangle *n*<=×<=*m* with empty squares ('.') and obstacles ('#'). The water can only be present in the empty squares. The tap is positioned above the square (*x*,<=*y*) of the first layer, it is guaranteed that this square is empty. Every minute a cubical unit of water falls into the plate. Find out in how many minutes the Serial Guy should unglue himself from the soap opera and turn the water off for it not to overfill the plate. That is, you should find the moment of time when the plate is absolutely full and is going to be overfilled in the next moment.

Note: the water fills all the area within reach (see sample 4). Water flows in each of the 6 directions, through faces of 1<=×<=1<=×<=1 cubes.","The first line contains three numbers *k*, *n*, *m* (1<=≤<=*k*,<=*n*,<=*m*<=≤<=10) which are the sizes of the plate. Then follow *k* rectangles consisting of *n* lines each containing *m* characters '.' or '#', which represents the ""layers"" of the plate in the order from the top to the bottom. The rectangles are separated by empty lines (see the samples). The last line contains *x* and *y* (1<=≤<=*x*<=≤<=*n*,<=1<=≤<=*y*<=≤<=*m*) which are the tap's coordinates. *x* is the number of the line and *y* is the number of the column. Lines of each layer are numbered from left to right by the integers from 1 to *n*, columns of each layer are numbered from top to bottom by the integers from 1 to *m*.","The answer should contain a single number, showing in how many minutes the plate will be filled.","['1 1 1\n\n.\n\n1 1\n', '2 1 1\n\n.\n\n#\n\n1 1\n', '2 2 2\n\n.#\n##\n\n..\n..\n\n1 1\n', '3 2 2\n\n#.\n##\n\n#.\n.#\n\n..\n..\n\n1 2\n', '3 3 3\n\n.#.\n###\n##.\n\n.##\n###\n##.\n\n...\n...\n...\n\n1 1\n']","['1\n', '1\n', '5\n', '7\n', '13\n']",none,WRONG_ANSWER,"import sys

def main():
	k, n, m = input().split("" "")
	num_plates = int(k)
	num_lines = int(n)
	num_chars = int(m)

	input()

	plates = []
	visited = []
	for layer in range(num_plates):
		
		plate = []
		visit = []
		for line_num in range(num_lines):

			plate.append(input().split("" ""))

			v = []
			for c in range(num_chars):
				v.append(False)
			visit.append(v)

		plates.append(plate)
		visited.append(visit)
		input()

	x, y = input().split("" "")
	x = int(x)
	y = int(y)
	print(water_flow(plates, visited, 0, x-1, y-1, num_lines, num_chars))

def water_flow(plates, visited, layer, x, y, num_lines, num_chars):
	if (0 <= layer < len(plates)) and (0 <= x < num_lines) and (0 <= y < num_chars):
		if not visited[layer][x][y]:
			square = plates[layer][x][0]
			sqr = square[y]
			visited[layer][x][y] = True

			if sqr == ""."":
				minutes = 1

				minutes += water_flow(plates, visited, layer-1, x, y, num_lines, num_chars)
				minutes += water_flow(plates, visited, layer, x-1, y-1, num_lines, num_chars)
				minutes += water_flow(plates, visited, layer, x-1, y, num_lines, num_chars)
				minutes += water_flow(plates, visited, layer, x-1, y+1, num_lines, num_chars)
				minutes += water_flow(plates, visited, layer, x, y-1, num_lines, num_chars)
				minutes += water_flow(plates, visited, layer, x, y+1, num_lines, num_chars)
				minutes += water_flow(plates, visited, layer, x+1, y-1, num_lines, num_chars)
				minutes += water_flow(plates, visited, layer, x+1, y, num_lines, num_chars)
				minutes += water_flow(plates, visited, layer, x+1, y+1, num_lines, num_chars)
				minutes += water_flow(plates, visited, layer+1, x, y, num_lines, num_chars)

				return minutes

	return 0


main()
","n, k = [int(s) for s in input().split()]

def line(h=0):
    if h < 0: h = 0
    return ['#'] * h + ['.'] * (n - 2 - h) + ['#']

# Each row can contain hotels except the borders
if k % 2 == 0 and k <= 2 * (n - 2):
    # Calculate the number of hotels to place on each inner row
    hotels_per_row = k // 2
    city = [line(hotels_per_row), line(hotels_per_row), line(hotels_per_row), line(hotels_per_row)]
    
    # Print the result
    print(""YES"")
    for row in city:
        print(''.join(row))
else:
    print(""NO"")"
58,A,Chat room,PROGRAMMING,"['greedy', 'strings']","Vasya has recently learned to type and log on to the Internet. He immediately entered a chat room and decided to say hello to everybody. Vasya typed the word *s*. It is considered that Vasya managed to say hello if several letters can be deleted from the typed word so that it resulted in the word ""hello"". For example, if Vasya types the word ""ahhellllloou"", it will be considered that he said hello, and if he types ""hlelo"", it will be considered that Vasya got misunderstood and he didn't manage to say hello. Determine whether Vasya managed to say hello by the given word *s*.","The first and only line contains the word *s*, which Vasya typed. This word consisits of small Latin letters, its length is no less that 1 and no more than 100 letters.","If Vasya managed to say hello, print ""YES"", otherwise print ""NO"".","['ahhellllloou\n', 'hlelo\n']","['YES\n', 'NO\n']",none,WRONG_ANSWER,"s=""hello""
st=str(input())
if s in st:
    print(""YES"")
else:
    print(""NO"")","import sys

readline = sys.stdin.readline

names = [[] for _ in range(26)]
surnames = [[] for _ in range(26)]
atidx = {c:i for i,c in enumerate('ABCDEFGHIJKLMNOPQRSTUVWXYZ')}

n = int(readline().strip())

# Read names and organize them by their starting letter
for _ in range(n):
    name = readline().strip()
    names[atidx[name[0]]].append(name)

# Read surnames and organize them by their starting letter
for _ in range(n):
    surname = readline().strip()
    surnames[atidx[surname[0]]].append(surname)

# Sort names and surnames for lexicographical order
for i in range(26):
    names[i].sort()
    surnames[i].sort()

result = []
count = 0

# First match names and surnames with the same starting letter
for i in range(26):
    while names[i] and surnames[i]:
        result.append(f""{names[i][0]} {surnames[i][0]}"")
        names[i].pop(0)
        surnames[i].pop(0)
        count += 1

# Add remaining names and surnames ensuring lexicographical order
for i in range(26):
    while names[i]:
        result.append(f""{names[i][0]} {surnames[0][0]}"")
        names[i].pop(0)
    while surnames[i]:
        result.append(f""{names[0][0]} {surnames[i][0]}"")
        surnames[i].pop(0)

# Join results into the desired output format
output = "", "".join(result)
print(output)"
368,B,Sereja and Suffixes,PROGRAMMING,"['data structures', 'dp']","Sereja has an array *a*, consisting of *n* integers *a*1, *a*2, ..., *a**n*. The boy cannot sit and do nothing, he decided to study an array. Sereja took a piece of paper and wrote out *m* integers *l*1,<=*l*2,<=...,<=*l**m* (1<=≤<=*l**i*<=≤<=*n*). For each number *l**i* he wants to know how many distinct numbers are staying on the positions *l**i*, *l**i*<=+<=1, ..., *n*. Formally, he want to find the number of distinct numbers among *a**l**i*,<=*a**l**i*<=+<=1,<=...,<=*a**n*.?

Sereja wrote out the necessary array elements but the array was so large and the boy was so pressed for time. Help him, find the answer for the described question for each *l**i*.","The first line contains two integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=105). The second line contains *n* integers *a*1, *a*2, ..., *a**n* (1<=≤<=*a**i*<=≤<=105) — the array elements.

Next *m* lines contain integers *l*1,<=*l*2,<=...,<=*l**m*. The *i*-th line contains integer *l**i* (1<=≤<=*l**i*<=≤<=*n*).",Print *m* lines — on the *i*-th line print the answer to the number *l**i*.,['10 10\n1 2 3 4 1 2 3 4 100000 99999\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n'],['6\n6\n6\n6\n6\n5\n4\n3\n2\n1\n'],none,TIME_LIMIT_EXCEEDED,"n, m = input().split()
m = int(m)
lista = list(map(int, input().split()))

ocorrencias = {}

for i in range(m):
  index = int(input()) - 1

  for j in range(index, len(lista)):
    if lista[j] in ocorrencias:
      ocorrencias[lista[j]] += 1
    else:
      ocorrencias[lista[j]] = 1

  print(len(ocorrencias))
  ocorrencias = {}

","import math, sys, collections, bisect, heapq
from itertools import combinations

def natural(n):
    return n * (n + 1) // 2

def possible(freq, mid, n):
    # Count how many points are within the distance d from freq[mid]
    left = mid
    right = mid
    while left > 0 and freq[mid] - freq[left - 1] <= d:
        left -= 1
    while right < n - 1 and freq[right + 1] - freq[mid] <= d:
        right += 1
    # Total points in the range [left, right]
    total_points = right - left + 1
    # We need to pick 3 points from total_points
    if total_points < 3:
        return 0
    return natural(total_points - 1)

def count_groups(n, d, points):
    # Initialize the answer
    answer = 0
    # Iterate through each point as the middle point
    for mid in range(n):
        answer += possible(points, mid, n)
    return answer

# Input reading
n, d = map(int, input().split())
points = list(map(int, input().split()))

# Get the result
result = count_groups(n, d, points)

# Print the output
print(result)"
709,A,Juicer,PROGRAMMING,['implementation'],"Kolya is going to make fresh orange juice. He has *n* oranges of sizes *a*1,<=*a*2,<=...,<=*a**n*. Kolya will put them in the juicer in the fixed order, starting with orange of size *a*1, then orange of size *a*2 and so on. To be put in the juicer the orange must have size not exceeding *b*, so if Kolya sees an orange that is strictly greater he throws it away and continues with the next one.

The juicer has a special section to collect waste. It overflows if Kolya squeezes oranges of the total size strictly greater than *d*. When it happens Kolya empties the waste section (even if there are no more oranges) and continues to squeeze the juice. How many times will he have to empty the waste section?","The first line of the input contains three integers *n*, *b* and *d* (1<=≤<=*n*<=≤<=100<=000, 1<=≤<=*b*<=≤<=*d*<=≤<=1<=000<=000) — the number of oranges, the maximum size of the orange that fits in the juicer and the value *d*, which determines the condition when the waste section should be emptied.

The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=1<=000<=000) — sizes of the oranges listed in the order Kolya is going to try to put them in the juicer.",Print one integer — the number of times Kolya will have to empty the waste section.,"['2 7 10\n5 6\n', '1 5 10\n7\n', '3 10 10\n5 7 7\n', '1 1 1\n1\n']","['1\n', '0\n', '1\n', '0\n']","In the first sample, Kolya will squeeze the juice from two oranges and empty the waste section afterwards.

In the second sample, the orange won't fit in the juicer so Kolya will have no juice at all.",OK,"def getNumOfTimes(b, d, oranges):
    num = 0
    waste = 0
    for orange in oranges:
        if orange > b:
            continue
        if waste + orange > d:
            num += 1
            waste = 0
        else:
            waste += orange
    return num


if __name__ == ""__main__"":
    _, b, d = map(int, input().split())
    oranges = map(int, input().split())
    print(getNumOfTimes(b, d, oranges))
","def gravity_flip(arr):
    # Sort the array to mimic the effect of gravity pulling cubes to the right
    arr.sort()
    return arr

# Read the input values
n = int(input())  # Number of columns
cubes = list(map(int, input().split()))  # Initial configuration of cubes

# Get the new configuration after gravity switch
new_configuration = gravity_flip(cubes)

# Print the output
print(*new_configuration)  # Output the final configuration as space-separated values"
266,A,Stones on the Table,PROGRAMMING,['implementation'],"There are *n* stones on the table in a row, each of them can be red, green or blue. Count the minimum number of stones to take from the table so that any two neighboring stones had different colors. Stones in a row are considered neighboring if there are no other stones between them.","The first line contains integer *n* (1<=≤<=*n*<=≤<=50) — the number of stones on the table. 

The next line contains string *s*, which represents the colors of the stones. We'll consider the stones in the row numbered from 1 to *n* from left to right. Then the *i*-th character *s* equals ""R"", if the *i*-th stone is red, ""G"", if it's green and ""B"", if it's blue.",Print a single integer — the answer to the problem.,"['3\nRRG\n', '5\nRRRRR\n', '4\nBRBG\n']","['1\n', '4\n', '0\n']",none,WRONG_ANSWER,"# Nivel de complejidad O(n)

n = int(input())
colors = input()

def min_stone_to_change_colors(n, colors):
    ans = 0
    i = 0
    while i < n:
        j = i + 1
        while j < n and colors[i] == colors[j]:
            j += 1
        ans += 1
        i = j
    return ans - 1

result = min_stone_to_change_colors(n, colors)
print(result)

  	 				 			  	     				 				","from collections import defaultdict

n, k = list(map(int, input().split(' ')))
nums = list(map(int, input().split(' ')))

# This will hold the frequency of each number in the current window
count = defaultdict(int)
left = 0  # The left boundary of the sliding window
result = 0  # To keep track of the number of valid subarrays

# Iterate through the array with a right boundary
for right in range(n):
    count[nums[right]] += 1  # Increase the count of the current number

    # Check if any number has reached the required frequency k
    while count[nums[right]] >= k:
        # If we have a valid subarray, all subarrays from left to right are valid
        result += n - right  # Add all combinations from the current position to the end

        # Move the left boundary to potentially find new subarrays
        count[nums[left]] -= 1  # Decrease the count of the number at the left boundary
        left += 1  # Move the left boundary to the right

# Output the result
print(result)"
546,A,Soldier and Bananas,PROGRAMMING,"['brute force', 'implementation', 'math']","A soldier wants to buy *w* bananas in the shop. He has to pay *k* dollars for the first banana, 2*k* dollars for the second one and so on (in other words, he has to pay *i*·*k* dollars for the *i*-th banana). 

He has *n* dollars. How many dollars does he have to borrow from his friend soldier to buy *w* bananas?","The first line contains three positive integers *k*,<=*n*,<=*w* (1<=<=≤<=<=*k*,<=*w*<=<=≤<=<=1000, 0<=≤<=*n*<=≤<=109), the cost of the first banana, initial number of dollars the soldier has and number of bananas he wants.","Output one integer — the amount of dollars that the soldier must borrow from his friend. If he doesn't have to borrow money, output 0.",['3 17 4\n'],['13'],none,OK,"a,b,n=map(int,input().split())
borrow=0
tcost=(n*(n+1))//2 *a
borrow=tcost-b
if borrow<=0:
    print(0)
else:
    print(borrow)","from collections import defaultdict

n = int(input()) 
tree = defaultdict(list) 

for i in range(n - 1): 
    p = int(input())  # Read parent of the current vertex
    tree[p].append(i + 2)  # Add current vertex as a child of its parent

def is_spruce(node):
    if node not in tree:  # If the node has no children
        return True
    leaf_count = 0
    for child in tree[node]:
        if child not in tree:  # If the child is a leaf
            leaf_count += 1
    return leaf_count >= 3 and all(is_spruce(child) for child in tree[node])

print(""Yes"" if is_spruce(1) else ""No"")"
268,B,Buttons,PROGRAMMING,"['implementation', 'math']","Manao is trying to open a rather challenging lock. The lock has *n* buttons on it and to open it, you should press the buttons in a certain order to open the lock. When you push some button, it either stays pressed into the lock (that means that you've guessed correctly and pushed the button that goes next in the sequence), or all pressed buttons return to the initial position. When all buttons are pressed into the lock at once, the lock opens.

Consider an example with three buttons. Let's say that the opening sequence is: {2, 3, 1}. If you first press buttons 1 or 3, the buttons unpress immediately. If you first press button 2, it stays pressed. If you press 1 after 2, all buttons unpress. If you press 3 after 2, buttons 3 and 2 stay pressed. As soon as you've got two pressed buttons, you only need to press button 1 to open the lock.

Manao doesn't know the opening sequence. But he is really smart and he is going to act in the optimal way. Calculate the number of times he's got to push a button in order to open the lock in the worst-case scenario.",A single line contains integer *n* (1<=≤<=*n*<=≤<=2000) — the number of buttons the lock has.,In a single line print the number of times Manao has to push a button in the worst-case scenario.,"['2\n', '3\n']","['3\n', '7\n']","Consider the first test sample. Manao can fail his first push and push the wrong button. In this case he will already be able to guess the right one with his second push. And his third push will push the second right button. Thus, in the worst-case scenario he will only need 3 pushes.",OK,"n = int(input())
result = 0
for i in range(1, n + 1):
    result += i * (n - i) + 1
print(result)
","def minimum_time_to_meet(n, positions, speeds):
    # Helper function to calculate the time taken for all friends to reach a meeting point
    def time_to_meet(meeting_point):
        max_time = 0
        for i in range(n):
            distance = abs(positions[i] - meeting_point)
            time = distance / speeds[i]
            max_time = max(max_time, time)  # Find the maximum time among all friends
        return max_time
    
    # Binary search to find the optimal meeting point
    low = min(positions)  # Lowest possible meeting point
    high = max(positions)  # Highest possible meeting point
    while high - low > 1e-7:  # Precision threshold
        mid1 = low + (high - low) / 3
        mid2 = high - (high - low) / 3
        time1 = time_to_meet(mid1)  # Time if they meet at mid1
        time2 = time_to_meet(mid2)  # Time if they meet at mid2
        
        if time1 < time2:
            high = mid2  # Narrow the search to the left
        else:
            low = mid1  # Narrow the search to the right
    
    return time_to_meet(low)  # Return the time for the optimal meeting point

# Input reading
n = int(input())
positions = list(map(int, input().split()))
speeds = list(map(int, input().split()))

# Calculate and print the minimum time
print(minimum_time_to_meet(n, positions, speeds))"
723,A,The New Year: Meeting Friends,PROGRAMMING,"['implementation', 'math', 'sortings']","There are three friend living on the straight line *Ox* in Lineland. The first friend lives at the point *x*1, the second friend lives at the point *x*2, and the third friend lives at the point *x*3. They plan to celebrate the New Year together, so they need to meet at one point. What is the minimum total distance they have to travel in order to meet at some point and celebrate the New Year?

It's guaranteed that the optimal answer is always integer.","The first line of the input contains three distinct integers *x*1, *x*2 and *x*3 (1<=≤<=*x*1,<=*x*2,<=*x*3<=≤<=100) — the coordinates of the houses of the first, the second and the third friends respectively.",Print one integer — the minimum total distance the friends need to travel in order to meet together.,"['7 1 4\n', '30 20 10\n']","['6\n', '20\n']","In the first sample, friends should meet at the point 4. Thus, the first friend has to travel the distance of 3 (from the point 7 to the point 4), the second friend also has to travel the distance of 3 (from the point 1 to the point 4), while the third friend should not go anywhere because he lives at the point 4.",RUNTIME_ERROR,"x = int(input())
y = int(input())
z = int(input())
myList = [x, y, z]
myList.sort(reverse = False)
print(abs(myList[0] - myList[1]) + abs(myList[2] - myList[1]))
","def gcd(a, b): return max(a, b) if min(a, b) == 0 else gcd(b, a % b)

[a, b, n] = [int(x) for x in input().split()]
turn = 0  # 0 for Simon's turn, 1 for Antisimon's turn

while True:
    if turn == 0:  # Simon's turn
        stones_taken = gcd(a, n)
    else:  # Antisimon's turn
        stones_taken = gcd(b, n)

    if stones_taken > n:  # if not enough stones to take
        print(turn)  # current player loses
        break
    n -= stones_taken  # reduce stones in the heap
    turn = 1 - turn  # switch turns"
682,D,Alyona and Strings,PROGRAMMING,"['dp', 'strings']","After returned from forest, Alyona started reading a book. She noticed strings *s* and *t*, lengths of which are *n* and *m* respectively. As usual, reading bored Alyona and she decided to pay her attention to strings *s* and *t*, which she considered very similar.

Alyona has her favourite positive integer *k* and because she is too small, *k* does not exceed 10. The girl wants now to choose *k* disjoint non-empty substrings of string *s* such that these strings appear as disjoint substrings of string *t* and in the same order as they do in string *s*. She is also interested in that their length is maximum possible among all variants.

Formally, Alyona wants to find a sequence of *k* non-empty strings *p*1,<=*p*2,<=*p*3,<=...,<=*p**k* satisfying following conditions:
 -  *s* can be represented as concatenation *a*1*p*1*a*2*p*2... *a**k**p**k**a**k*<=+<=1, where *a*1,<=*a*2,<=...,<=*a**k*<=+<=1 is a sequence of arbitrary strings (some of them may be possibly empty); -  *t* can be represented as concatenation *b*1*p*1*b*2*p*2... *b**k**p**k**b**k*<=+<=1, where *b*1,<=*b*2,<=...,<=*b**k*<=+<=1 is a sequence of arbitrary strings (some of them may be possibly empty); -  sum of the lengths of strings in sequence is maximum possible. 
Please help Alyona solve this complicated problem and find at least the sum of the lengths of the strings in a desired sequence.

A substring of a string is a subsequence of consecutive characters of the string.","In the first line of the input three integers *n*, *m*, *k* (1<=≤<=*n*,<=*m*<=≤<=1000, 1<=≤<=*k*<=≤<=10) are given — the length of the string *s*, the length of the string *t* and Alyona's favourite number respectively.

The second line of the input contains string *s*, consisting of lowercase English letters.

The third line of the input contains string *t*, consisting of lowercase English letters.","In the only line print the only non-negative integer — the sum of the lengths of the strings in a desired sequence.

It is guaranteed, that at least one desired sequence exists.","['3 2 2\nabc\nab\n', '9 12 4\nbbaaababb\nabbbabbaaaba\n']","['2\n', '7\n']",The following image describes the answer for the second sample case:,COMPILATION_ERROR,"#include <stdio.h>
#include <algorithm>
#include <iostream>
#include <vector>
#include <map>
#include <set>
#include <math.h>
#include <string.h>
#include <string>
#include <queue>
#include <stack>
#define INF 1e9
#define pb push_back
using namespace std;
typedef long long int ll;
int dp[1001][1001][11][2];
int n, m, k;
string u, v;
int main(void)
{
	cin>>n>>m>>k>>u>>v;
	int i, s, e;
	for(i=1 ; i<=n ; i++)
	{
		for(s=1 ; s<=m ; s++)
		{
			for(e=1 ; e<=k; e++)
			{
				if(u[i-1]==v[s-1])
				{
					dp[i][s][e][1]=1+max(dp[i-1][s-1][e-1][0],dp[i-1][s-1][e][1]);
				}
				dp[i][s][e][0]=max(dp[i][s][e][1],max(dp[i-1][s][e][0],dp[i][s-1][e][0]));
			}
		}
	}
	cout<<dp[n][m][k][0];
}","def gcd(a, b):
    if a == 0:
        return int(b)
    return gcd(b % a, a)

def tie_probability(t, w, b):
    # Calculate maximum steps Willman and Bolt can take without falling
    max_steps_willman = t // w
    max_steps_bolt = t // b
    
    # Get the count of lengths where they tie
    max_common_length = min(max_steps_willman, max_steps_bolt)
    tie_count = max_common_length
    
    # Total possible lengths of the racetrack
    total_count = t
    
    # Calculate GCD for the irreducible fraction
    common_gcd = gcd(tie_count, total_count)
    
    # Reduce the fraction
    p = tie_count // common_gcd
    q = total_count // common_gcd
    
    return f""{p}/{q}""

# Input reading
t, w, b = map(int, input().split())
print(tie_probability(t, w, b))"
844,A,Diversity,PROGRAMMING,"['greedy', 'implementation', 'strings']","Calculate the minimum number of characters you need to change in the string *s*, so that it contains at least *k* different letters, or print that it is impossible.

String *s* consists only of lowercase Latin letters, and it is allowed to change characters only to lowercase Latin letters too.","First line of input contains string *s*, consisting only of lowercase Latin letters (1<=≤<=|*s*|<=≤<=1000, |*s*| denotes the length of *s*).

Second line of input contains integer *k* (1<=≤<=*k*<=≤<=26).","Print single line with a minimum number of necessary changes, or the word «impossible» (without quotes) if it is impossible.","['yandex\n6\n', 'yahoo\n5\n', 'google\n7\n']","['0\n', '1\n', 'impossible\n']","In the first test case string contains 6 different letters, so we don't need to change anything.

In the second test case string contains 4 different letters: {'*a*', '*h*', '*o*', '*y*'}. To get 5 different letters it is necessary to change one occurrence of '*o*' to some letter, which doesn't occur in the string, for example, {'*b*'}.

In the third test case, it is impossible to make 7 different letters because the length of the string is 6.",WRONG_ANSWER,"""""""
███████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████
███████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████
██████████████████████████████████████      ██      ██      ██      ██  ██████  ██  ██      ██          ██       ██████████████████████████████████████
██████████████████████████████████████  ██  ██  ██  ██  ██  ██  ██████  ██████  ██  ██  ██  ██  ██  ██  ██  ███   █████████████████████████████████████
██████████████████████████████████████      ██      ██  ██  ██      ██  ██████      ██      ██  ██  ██  ██  ████   ████████████████████████████████████
██████████████████████████████████████  ██  ██  ██  ██  ██  ██  ██████  ██████  ██  ██  ██  ██  ██  ██  ██  ███   █████████████████████████████████████
██████████████████████████████████████  ██  ██      ██      ██      ██      ██  ██  ██  ██  ██  ██  ██  ██       ██████████████████████████████████████
███████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████
███████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████
""""""
# '''______________________________________________________________________________________________'''
# '''
# 2i2r2X0S@aZB87Ma7XWaB8a2WaBaBZ0BBi80SaWWM@B;S7@;ZZ7i8B@7B8WZB0MWMWMWM8@ZWZWZWZWaSXWBMWMWMWM8WWMBM8@ZBZW8WX0080@8W8MWM8B8@8W0aZM0WBMZWWMWMWM8@0WWX r,7,
# 2XrS;S702Z8Z:WaX;B202Z;B2020202WarXW;ZZMWM8Si7S2iMaX,X2B722B2BZW8MWMWMWM0MaB202BaZX8Z@BM@MWMBM0MWM@MZ0aBZBXZaWZBZW8@BMZBZ@ZBaZZWZB0MZBBM@MWM8WZ@W; : ,
# WXSiSiZW0a@;BZS;WZBZ0i08BaBa0aB8W;B08XW@MWMZXrS2XZM00rXr0XSXBZB2B0@BM@MWMWM0WZWZW8WaWZBBMWMWMWM0@0M@MBMZBZ@ZB8WZWZW8@WMZW8M0@Z08WZW0M8MSrBM@MWMBM@a i.
# 02ir.,S@Z0X8BaiBaBZW;2ZB28ZWZWZ08SZWZZaWBMB@727S;2@M8WaZ;SrX;aa0X8Z@Z@BMWMWMWM@MBM8BZWZBZW8M@MWMWMZMWM@MWM8@8WZWZWZW8@WM8WZMB@8@8W0M0MWMr,.WWM@MWMWB .
# Z:;.:.BBX;808iBZ8aW77Z@ZZZBZBZ8XMr0ZWXBZM0M0Bi0rXi@WMa@B@Sa;7i2SZX2XW0@0MBM@M@MWMWM8WZBaBa08MWMWMWMBM0MWMWMW@aBZW8W8@0M@M8W8MW@ZWZMB@0MWMS. ir@@MWM@@
# Xr.i ZWBiZWB:08BaWX7XW82S@Z00@;BBaS@80SW0@8M8Z7B;X7MWMZB0MZWS2i2a0XX:Z0M0B8MBM@MWMWMWMBMZBZW0@BM@MWMWMBMWMWM8W8W8@8@BM@MZWZM@M0W8@0@0M@MB, . iXMWMWM
# Zir,XW0iZZM;ZZBZWZXi08ZrWZWaMaS8MSZ8WZaZWBMB@ZSa0i72MWMZB0M0@0BXSXWZai7X@0WaBZMWMWMWM@MWMWM0M8WZMWMWM@M@MWMWMWMWM8W8@8WZ@W@8W0MWM@Wa@8MBMWMWr i , rXMW
# rXX20W:XaMSX8W2W02i28ZiW8Wa@0S7M8BXMBWX8ZMWMB@aS88:S0MW@ZB0MB@8MZ8780@2Xi80@ZBZMWMWMWMWMWMWMBWaBZ@WMWMWMWMWM@MWM@MBW8WZW8MBW0@WMWMWM8W0MBMWMW2 :.; , i
# Z;SSMXai0B2ZBaB02iXZ0:Z0BZ00W:BB@Z08WZWS@0MWMBMSaBZ,Z@M@M8BBMWM8@0@28aM00;Sa@8WZBZM@MWMWM@M@MWMWWZWBMWMWM@MWMWM@MWM@M8W8M0M0@0MWMWMWMBMWMWMWMWM,,.;,;
# Za:ZSS;S80S@ZBW8;8r0;S8WZWZM2X0@ZW8WZW8W8WBMWMBM70BZ:@WM@M0BBMWMBM8WZ08@0@a2XWBMBWZ@BM@MWMWMWMWMWM8WWMWMWMWMWMWMWMWMWMZW8M8M8@WM@MWMWMWMBMBMWMBMZ: ;,i
# MX7XrrSS@SBaBB@iWXSrX2@8BZ@027M8WZ@ZW8WW@8WWMWM0WZ@08:MWMWMBW0MBMBMWM0WZW0M8BS0Z@BMB@0M@M@MWMWMWM@MBM0M@MWMWM@MBMWMWM@M0@BM0MZMWMWMWMWM@MWMWMWWrBW8 i
# SXr8:XXMa8ZBBMr80X;SrWZ@XB0@i80@B@@@ZWZM0Ba@WMWMZWB@88;MWMWMW@BM@M@MWM@M0@ZW0@ZWZW0MWMBMWMWMWMWM@M@MWMBM@MWMWMWMBMWMWMWMWMB@8WWMWM@MWM@MWM@MBMWM7r2MX:
# Sia7S:08BaBBM22BWia;8Z@Z28MZXZ@8W0MWBZBZMZBZMWM@Wa@@W80XM@MWMWMBMWMWMWMWM@MZWZWZW8W8M@MWMWM@M@M@MWMWMWMBMWMWM@M@MWMWMBMWMW@W@ZM0M@MWM@M@M@M@MWM0MBX ZS
# 7XX2;XaWZWWM02ZMrZXX0@80S@0Bi@8WZ@WMBMBWBMZBZMWMWWZMWW88ZMWMWMWMWM@M@M@M@MWMWM0W8@8WZ@0MWM@MWMWMWMWMWM@MBMWMWMBMBM@MWMWMWMWM@MWMBM@MWM@MWMWM@M@MWMWM ,
# 2iarX7@@WWMW0XM8S8X2M8MX00M2S0@8B0M@MB@ZWW@aW8MWM0W8MB@ZW0MWMWMWM@M@M@MWM@MWM@MWMWMZW8W0MWMWM@MWM@MWMWM@MWMWMWMWM@MWMWM@MWM@MWMBMWMWMWM@MWMWMWM@MWMWMX
# 7X7S;00MWMWWXWBZZ0;M8W0aZ@BZ7M0WZMBM@M0B8M@@ZW8MBM8WBMWMZWWMWMWM@MWMWM@MWMWMWMWM@MWM0@0MBMWM@MWMWM@MWMWM@MWMWM@MWMWM@MWM@MWMWMWMWMWM@MWM@MWM2aWM@MWM@M
# a;2i2000MWWa0BBSMrZ0BZB7@0MXZ0MZWB@WM@M0WBM@WZW0M@M8@WM@M8BBMWMWMWMWM@MWMWMWMWMWMWM@MWMWMB@WMWMWMWM@MWM@M@MWMWMWMWM@MWM@M@MWMWMWMWMWMWMWMWMWMX.;MWM@MW
# 22rXSBZMWMZW8M2@ZXZ@8MSZ0@BZSMBB8@8M@MWM0@@MB@ZBWMWMZMWMWM0WBMWM@M@MWM8MWM@M@MWMWMWM@MWMWMBMWMWMWMWMWM@M@MWM@MWMWMWMWM@MWMWM@MWMWMWMWM@M@M@MWMZ. ;7@WM
# 07X,MaMWM8WZM0W087M8WWaSM0MSB0MZMWMBMZMWM0MWM0@8@BMWMZM@MWMBMWMWM@MWMWMXW@MWM@MWMBMBMWMWMWMBMBMWMWMWM@MWMWMWMWMWM@M@M@MWMWMWM@M@MBMWMWMWMWMWMWM8, : ii
# :r:Z@@WMaWZWW@ZM7WBWZM;80MB8aMWWWMWMBXWM28WM@M8@8WBMW@0M@MWM@MWMWM@MWMWMX2WMWM@MBMWMWMWMWMWMWMBMWMWMWMWMWM@MWMWM@M@MWM@MWM@MWMWMWMWM@MWMWM@MWMWMZ,.r,:
# 7 i2MWMX0BB0MZWZZ@@ZMWX2M0Ma00M0MWMWB M@@ BWMWBZM8@BMW@BMWMWMWMWMWMWM@MWMXiXMWMWMWM@M@MWM@MWMWMWMWM@MWMWMWM@MWM@M@M@MWM@MWMWMWMWMWM@M@MWMWMWMWM@MS::7,
# ::i8WMXXW@8MBW808M8WWM;[email protected],.W@MW0ZM8W0MWWWMWM@MWMWM@M@MWMWM0i ZWMWMWMWMWM@MWM@MWMWM@M@MWM@MWMWMWM@MWMWMWM@M@MWMWMWM@MWMWMWM@M@M@MWM;iir
# i M@MX7XMZMBMZWZMBW0M@XZ@BM8W8M0M@MWZ 2WM.;.Z@MW2aM0M0MWMWMWMBMBMWMWMW@WM@M@a i7MWMWMBM@M@MWMWMWMWMWM@MWMWM@MWM@MWMWM@M@MWMWMWM@MWMWMWMWMWM@[email protected],
#  aWM;r;ZWWBM0MBMWMZMWM;W0MBW8@WM@[email protected],7 2WM@7SMW@8MBMWMWMWMWM@MWMBZZMWMWM;: X2M@MZ@WM@MWMWMWMWMWMWMWM@MWMWMWMWMWMWMWMWMWM@MWMWMWMWMWMWMWM@MZ@WM:;
# ZWMXrrXrM8M0@8MWMWMWM@Sa@0M8@[email protected]@MWrXMW@8MWMWM@M@MWM@MWMWX;MWM@M87 i,ZWM082M@MWMWM@MWM@MWM@M@MWMWMWM@M@MWMWM@MWMWM@MWMWM@MWM@MWM@M MW8i
# WM7;;Si2@@WZW@WMWM8M@Mr0B@WM8WWMWMWMi;:iWM r:7.i8MW7:M@@ZMBMWMWM@MWMWMWMW7 SSMWMWB:;,rrB@@X2SM@MWM@MWM@M@MWMWM@M@MWMWM@MWM@MWMWMWMWMWMWMWMWMWM@MWZ MW.
# M7;iX;S7MW@:M0M@[email protected] XWr ;.i .rM@X W@M0W8M@M@M@MWM@MWMWS ;ia2MWM8S:r,r7BZZ,;rWWMWMWMWMWM@MWMWMWMWM@MWM@M@MWM@M@[email protected]
# 0aiX;2;2@MZ7@MWMWMWMWM70B@WMBMWM@MWMiXS80MWW0MZZi, W@a aWM0@0MWM@M@MBM@[email protected]:7iXX@WWr;.i.XaMaZS@8M@M@MWMWM@M@MWMWMWMWM@M@MWMWM@M@MWM@M@MWM@MWMWM:,8M
# M2XiSr2;MWZ;MWMWMWMWMW0SM8M@MBMWMWM@2,r@MiMiZWM@MW@XB@M .BMBWWMWM@MW82MWM@MW8 X;Xi; rS@ZMWMWMWM0M8MWMZMWMWMWM@MWM@M@M@MWMWMWM@MWMWMWMWMWMWMWMWMWMWa :W
# 8Z;X;SrXBM2X2MWM@MWM@M8ZB@WMWMBMWMWMX.,M;.:[email protected]@MWMWMW@[email protected]:X7MWWWM@M@MWMW0ar [email protected]@MWMWM@MWMWMWM@MWMWMWM@M@MWM@MWM2@WMWM8: 2
# @XSiX;2XMW. :WM@MWM@M0MSM0MWMWMWMWMWW X@, . B2@WMWM@MWMS8X. WWMWMWM@[email protected] 82MWM@M@M8BX: [email protected]@MWM@MWMWM@M@M@[email protected],;,
# 0Z;X78X:XM . M@MWMWMWXBB0@WMWMWMWMWM@:,M , . @ZMWM@M@ZBMX::: rWM@MWMWMWMWZ70WMWMiaZ,.,;WSMWMWMW0Bi i.iWZ,XWMWMWMWMWM@[email protected]@MWZ.:
# M2ZSZ.. r@. ,XMWMWM@M B0W0MWM@MWMWM@M;:@S , . W0MWMWW8X Mi,.: ,XMWMWMWMWMZ872SM@M0i:i .2@0M@MB@B2 . , M0r:M@MWMWMWM@MWMWMWMWMWMWM@MWMWMWMWMWM :ZM@MB.
# B0r: . , M . ,@MWMWMW.iMZMWMWMWMWM@M@W,WW. , . r;Z2a;. ;;S : : . S8MWM@M@M88rX;2ZM;: . .:aX8S8r: , . iWMX;8M@MWMWMWM@M@MWM@MWMWMWMWMWMWMWMWMWi.:BM@M ,
# ; . : : .Z: , ZWMWMWM .@WWMWMWM@MWMWM@iXMW; , . . . . .i; : i : . ,;B0M@M@M8BSS:;,i . , . . , . . . ,@M8S,BWM@MWMWMWMWM@MWMWM@MWM@MWM@MWMWMWM.;,iWMWZ
#  . : : , S,. , MWM@MW: MWMBM@[email protected].. . . . iir : i i i : . XXZZM@M0ZXZXa:7 , . . . . . .,WWMr::XXM@MWMWMWM@MWMWMWMWM@M@MWM@M@MWM@MW7,7.i@MW.
# i : : : ,,X , [email protected]@MWM@MWM.. S8M@@a02B2a;i i.i.i i i i , . ;,XaMWMX7iXXBZ0SSiXiX;aS@WMW2 , ria@MWMWMWMWM@M@MWMWMWMWMWM@M@MWW8MWMSiiX 8WMX
#  , : : : ,r, : .BMWM@X :WMWM@M@MWM0MWMW@ . . XX0ZBZa,: i i i i i i : : , : . raMaS:ii80M@MWMWMWMB8:: i.i:X7MWMWM@MWMWMWMWM@[email protected]:77S8M
# i : : : : X,, : ,WMWMX. @WMWMWMWMW@rM@MW2 , , . . . : : i i i i i i i i i : , . i:X,, , : i.i : , , i.r.;ia@MWMWMWMWMWM@M@M@[email protected]: Sa,0
#  . : : : , X : . Z@M@Z .,[email protected] : : : : : i i i i i i i i i i.i i : : : : : , , : : : i.i.;,i,X7MWMWM@MWMWMWMWM@MWMWM@M@MWM@M8iaMWB7ri. 0.i
# i i : : : : : : . MWMZ. .BM@[email protected];r i i i i i i i i i i i i i i i i.i i i : i i i i.i.i.i.i.i,; riaWM@M@M@MWMWMWMWM@[email protected]:X,.X:
#  . : : : : , : : .XM@M , :WM@MWMWM@M7. MWZ.r i i i : i i i i i i i i i i i i i.i.i i i i i :.i.i.i.;.;.i:72MWM@MWM@M@M@MWMBMWMWMWM@MWMWMXr:2WMXZ,X 2..
# i : : : : : : : , .WMW. , 0WMWMWMZMWM . B@Z : i i i i i i i i i i i i i i i i i i.i i i i i i i i.i.i.i X:MBMWMWMWM@M@MWMWWWMWMWMWM@MWMWa:S.B@2ari7ar
#  . : : : : : : : , rWMi. . MWMWM@Z0MW8 . X@8 : i i i i i i i i i i i i i i i i i i.i i.i i i.i i i i.i i;2@X@MWMWM@M@MWMWMrMWMWMWMWMWMWMX7;X,MBZ7r:ZX.
# i : : : : : : : : . WWM . ,,M@MWMSX@M@, , .Xa : i i i i i i , : i i i i i i i i i i i.i i.i i i.i i i.:.7ZW,MWMWM@MWMBMWMZi@MWMWM@MWMWMWZ:SrX:@SB,7:@
#  . : : : : : : : : , MW, , ,2M@M@M MWMB. : ..; i i i i i i :i: i : i : : i i i i i i i i.i.i : i i.i.i [email protected]@MWMWM@M@0WMW8 MWMWMSMWMWMWMar;S;X;22S:7;0
# i : : : : : : : : ,.. M0, , .@[email protected]. : : i i i i i i i a2. , : , , : i i i i i i i i i i.i i i i i;Zi:ZM@M@MWMWMrMWMS:BMWM8i@MWMWMWW,SrSrX,0XrirS
#  , : : : : : : : : r .:M,. . ;WMWM,,WMWM . : i i i i i i i : M0r.r:7iXir , i i i i i i : i i.i.i i i :i2i:,MWMWM@MWMaSBMW8 @WMWa B@MWMWM8;rS;S;72a:Xi7
# i : : : : : : : : ,,r .7M , , 2WM@a @WMWM , i i i i i i i i . @W8iSrS;8aBXr i i i i i i i i i i i i :.X .,7@M@[email protected],aM@M:riMWMWMWM,X;S;X;W:7iX,
#  . : : : : : : : : ri, .;Z : ; 0WM2.XMW8@M . i i i i i i i i , ;0S;XrSrSrS,: i i i i i i i i i i i i ; . 77MWMWMWMWZ,irM@Z @WM8;irXM@MWMWriX;X:W7riXir
# i : : : : : : : : ,,X , .,i ,,r M@W 7WM:M@M . i i i i i i i i : ,,Xr2rSi; : i : : i i i i i i i i i.i : 7,[email protected]:;WMS,BMWX:X;;ZM@MWMi7;S:Ba;iXiX,
#  . : : : : : : : : r;; , , : iii,[email protected]@M . : i i i i i i.i.: , i,; , : i i i i i i i i i i i i i : i;;WMWMWMWM.7iX.M@8 MWM.X;S:[email protected]:Z
# i : : : : : : : : ,.X:, : : : 7:,aM ,WM 0WM@M,. : i i i i i i i : : : : : i : i i i i i i i i i i i i ,iriM@MWMWM;;iXirrM2,WM7;;X;X:r@M@MW;,ZZr:7:77Z
#  . : : : : : : : : :iX , : : .:X,;@r Ma,:MWM@MX. :.i.i i i i : : , , , . . , , , : : i i i i i i i : ,:X 8WMWMWMaiiXiXi;@B MWriX;S;X:7WM@M77ar:X:7aZ .
# i : ; : : : : : : , r;7 : : : ii7.2iiWa ,WMWSBM0. , i.i.i.i.i.ZXZXa7arX7aXaXZSZXa7a:: i.i.i i i i : :iXiZWMZMWM@;:XiX;X,00;@a.X;X;X;X,rWM@MX;:XirZ7 .
#  . ,ir , : : : : : , X;: : : : riX,r:M:r Z@M;:WMWX , : i i i i.i.;,riX,Xi7:;,;,i.ri; i i.i.i.i.i : iiXS0aMX@WM@X:X;X;S;7:0ZM.7;X;X;X;X,;ZMWW 7ir2S , ,
# : : 2X. : : : : : : , X:, : , : ::X,aa;:;,M@M BW0Za,. : i i i : : , , : , , . , : , : i i i.i i , 7i2ZB;MW:WMWZ.XiXiXiXir;MrriXi7iX;XiX:;ZMW0.;rS , :
#  . :XZ : : : : : : : ,.S , ; : : ..7XX:7::0MS7 Mia727; , i i i i :.i , . . , r.: i i i i i i : :,7r8Z8ra@i;MWB 7;XiXiXiX,Sai:7i2X8XSiXi7Z7 8Wa a , i .
# i , aS. : : : : : : : ,:X ,,r , : , r:7i7.a@Xr;@2,B:S2S , i i i i irWZ020aW8M8X i i.i i i : , ;:SSWaZr;Ba MWM riXi7i7:7:r8a7828SZ;XiX;7aZ.r r7r , : :
#  , i78 , : : : : : : : ,:r :ir , : , iiX:;:M7;S8ri2Z,77B;, i i i.i :,Xr272;7.: i i.i i i i , 7;Z8BXa;rX0 SWM.r:r:XraXZ208@XarX:r:X;Xir28.7i; . . , , .
# : ,.2Si : : : : : : : : :ii :;a,. : : ::X:i@8 Z7;:r0Z7XiZS; , i i i , , , , , i i.i.i.i : :.XSW2a7X,r:X,i@M,rrZS820XarX:X:r:7iX;Si7:XZB.7;: a : , : i
#  , ;7Z,: : : : : : : : : ::, ;;0i. : , ,,X,Bai:W,7.88Z20S080 . i i i i : i i i i i i i , ii8Z0XZ20XZXa7SZMaaS8X2ir:r:7:7:X;SrS;7..,Za2.7i, M2ZSZXaXa::
# i :.22r:, : : : : , . , : :., 7:ZX, , : , ;X0,rSZ,r:B,riS7ZZW;, : i i i i i i i i i : : 72Wa8a0XZXZX8XX7Mr;ir:X7ZXZS8Xa;7iX:; . iXBXr,X,. 2 , i.rir :
#  . ;rB.X:: , , . :.ri7:i . , , X:a2; , : , ;rXi7Z7:;XZ:X;Xi7iZ27 : i i.i i.i i i i : ii08WZW22i7:7:7:7,MSiiSX0S2;r.7iX7BXX., .:ZZa:riX .;X . 77ZXS., ,
# ; ..XZ;:Xir :.riSrS;Xi27a;; . . X:r22 , : , :,X,8SriraZ:X;X;SiS2Z., i i.i.i.;.i : :.2ZM8BZ8;r:X;X;X;X,M2XXBSS.. . , , . ii27800;i.7:: ;22:a20XX . , :
# 7i ,:W,;,XX8aZi; : , : : 7;272ii.7,;XB,, : : , ri@iX:r20;7;X;X;X70X; , i i i : : rXWaZ;Xr7:XiX;S;XiX;MBZXX.. ,.: i i : : . :,7;Z2Z:, Sa8XZ;i . , , : .
# BXr.iZZX0Sa:: , i i i.i : , i:X72S8XXi07, : i : ,7B:XirXWSXiX;X;S;ZaZ;; , , ,.77B807XiXiX;X;XiX;2S8a8X7 . .:X i.i i : i i : , . ;iXXMWa.. , , , : : :
# .S8ZX877 . , : : : i i i :.i : , iiSXZ70Z7 . : i .7X,S;7iZZ0rXi;.7;SSBZ0XaX8aBa8XXiXrS;X;X;S7820XS,i . : ,rZ.i.i.: i.r,;.: , : : , :.aXSi7.: . : : : ,
# 8rSii . : : , i.;.i , i i a8i i.i : , ri20Mi, , : ,r; ;:7:XXWZZi; :.riXXZSZXa;XiX;SrSrSiS2Baa;; . : : : iSS i.;.i;2;XiSr27a;7.: : : , ,.riS7arX,: , :
# ,. . , , :,XraX27ZXZrr.i i.WWi i.i.i : , :r8XarS:i :7X . : i.2Z@2X.: i.riX;Sr2rSrSr2r2rZZX,: : i : i.;,2BZri.;.i,X.;.;.i.;,Xra72ir,; : i : :.riXr2;X:,
# : :.riX7arS:; , , :.X;S:i.: ZZX.: i i.i.i , i,ri2X2 ,i2;; . , :i080:, ;.i.;:Xr2727272iSai i i : i,7;aSB0a,i i.;.i riXr27a7Si;.;:7iXrSii.i.i.i : :.;iSi
#  ,7a7Sir , ;iXrSi7,i : ;.; i ir8XX.: : i.i.i.i.i :XZ , rraii : . iXWSr i.;.i.i,r:7i7.;S; i i,7iX;aa@aai: :.;.;.;.;.i i.;,r:7:r:; : i.;.i.;.;.i.i.i i ,
# i i , , r;aX2;7,i i i i ;.i.;.: 7X0SS:r,;.;.i.;.;.:2X i :.SXS,: : . 2ZZ:i i.;.i.i i ;a7 :.X;XrZ2Baa:i i.;.;.;.;.;.;.;.i.i i i i.i.i.i.i.;.;.i.i.i.;.;
# .. i,r;SrX:; i : i i i : :.;.;.; :.S2W2arSrSir.i.;.iZ; i i i:2XS.:.i :iZ2ai; i.i.i Xar i:2X0ZWaa:: i.;.;,r.;.;.i i i.;.;.;.;.;.;.;.;.;.;.;.;.;.;,;.;,i
# ; r:r:;.: i i.;.i XSS;r:r,i i.;.;.; :,ZaB2Z7272:i.;.7Br :.;.i irZr; :.: ;;ZS8XS;r:8Si i;BZ8XX,: i.;,;.;.i i i.i ;:7:;.r,;.;,i i.i i : i.i.;.;.;.;.;,;
# .,.i : : i.i.;.i.i,08WZ2i7;X:i i.;.;.i i:SXB2Sra:i,r S0X,i ;.;.: XXZ:i i : i,7iX2W;: ;r@Sr : ;.;,;.i i.r:7:7:XXWZ0X2Si,;,r,;iS;aXZr2rX:r.i.;,;.;.;.;:i
# i i i,r,i i.;.;,;.i 2@M@MaSiXi7:; i.;.;.i :.SZara:i,; Z0Si; ;.i.; :iaXai; : , 7S2 i r7M;:.;,r,;.i.;:X;S;X;aaM@MWM8aZS.;,r,;,7ir,r:ri7;Sr277.;,r,;,;,r.
# 7Xr27Sr2Xa,;.;,;.;,i 2@MWMWM2SiX;Si;.i.;.;,; ;8Zra:;,r aZ2;X,i.i.;.i iiaXZ7XrZXr i.7XMi:.r,r.i,7;S;S;XrZZMWMWMWMWMS; ;,;,;.;.i,7iX;S;X:r,;,;,;,r,r,r:i
# ; i i.i :i7.;.;.;,;.i ;8MWMWMWMSXiXrS;7,;,r:;.;Z0r2.;:r 7ZZ;2ir.i.;.;.i i,rXM,i.;,Sa@ii,r,;.r;arXi22@WM@MWMWMWMX7 ,.r,;,;,;,;,;,;.;,r:r,;,r,r,;,r,r,r
# :;;SrXir.i.;,;,r,r,;.i .;@@MWMWMWMSSiS72;;.r,r.i2@7S,r,r.;88iSrX:;.;.;,;,; 0,;,;:Z0B,i:r:r.77a;2aMWM@MWM@MaS,: . i.;,;.;.;,r,;,r,;,;,;,;,r,;,r,r,;,r,i
# 7.r,i.;.;,;,;,;,;,;,;,;., :;@WM@M@MWW;7rZr;.r,r,:r@2X,r:7.iZZiXr2rXir.i.; X2i:;,0Ba ;:7ir.XXSiB@MWMWMZ2,: , :.;.;.i.i.;.i i.;,r:r,r,r,r,;,;,r,;,r,r,r.
#  ,.i.;,;,;,;.;.i.;,r,r,r,; , ;X@[email protected]:7:i:WaS,r:r.;@07X;Sr272;7,iX8.;:@87.r:7:;,SXSXMWMWMWB . i.;,;,;.;,r:XiXiX7Z;Sr;,r:r,r:r,r:r:r,r,r:r:r:;
# ; ;,;,r,;.i.;.i i.i ;,r:r:r,; , X8MWMWMWai2XX,r:7:;.082,r:r,WX@8aiX;S7272iW2::@2i,7:r:;:arSZM@MBMWX i,r:r,;.riSrS;X;aSBZ@a8X7,r:r:r,r,r,r:r:r:r:r:r:7.|
# :i,;,;,;,;72XWZ077:7.; ;,r,r,;,; ,:MWMWMWWr2XX.r:7:r.Z0S,7:;0S;88BXXiS;SrXaZ,W;;:7i7,r;a70WM@M@MWi r:7:r,riS72r22BBMWM@MrBS;:7,r,r:r:r:r:r:r,r,7,r:r:;|
# 7 r,;,r,r.S72rXXMWZ;X;7:;.;.r:r:r,: 8WM@MWMSSXS,r:7i7 007:7.07S;XXW807X;2;Z00i;:7ir:XXZ2MWM@M@M0: 7ir:;,7rZ722M@MWM@MWMW0;i,7:7:r:r:r,;,;,r,;,;,r:7:7.|
# :i,;,r,r,;:WaSiMWMWMZarS;S;Xir,r:7:r 7WMWMWM0a72:ri7ir:M7riiZ2i2rSraa@80XXXM:r;XiriaX8WM@MWMWMS:,7i7,r;ZX2r0WMWMWMWMWB7i ;:7i7:7i7:r,r:X;Sr27S;X:r,r:;|
# '''
x = input();n = int(input())
if n > len(x):print(""impossible"")
else:x = set(x);print(abs(n - len(x)))
","def main():
    n = int(input())
    a = [0] * 1000
    b = [0] * 1000

    for i in range(n):
        a[i], b[i] = map(int, input().split())

    supercentral_count = 0

    for i in range(n):
        x, y = a[i], b[i]
        has_upper = has_lower = has_left = has_right = False
        
        for j in range(n):
            if i == j:
                continue
            x_j, y_j = a[j], b[j]
            if x_j < x and y_j == y:
                has_left = True
            elif x_j > x and y_j == y:
                has_right = True
            elif x_j == x and y_j < y:
                has_lower = True
            elif x_j == x and y_j > y:
                has_upper = True
        
        if has_upper and has_lower and has_left and has_right:
            supercentral_count += 1

    print(supercentral_count)

main()"
424,A,Squats,PROGRAMMING,['implementation'],"Pasha has many hamsters and he makes them work out. Today, *n* hamsters (*n* is even) came to work out. The hamsters lined up and each hamster either sat down or stood up.

For another exercise, Pasha needs exactly  hamsters to stand up and the other hamsters to sit down. In one minute, Pasha can make some hamster ether sit down or stand up. How many minutes will he need to get what he wants if he acts optimally well?","The first line contains integer *n* (2<=≤<=*n*<=≤<=200; *n* is even). The next line contains *n* characters without spaces. These characters describe the hamsters' position: the *i*-th character equals 'X', if the *i*-th hamster in the row is standing, and 'x', if he is sitting.","In the first line, print a single integer — the minimum required number of minutes. In the second line, print a string that describes the hamsters' position after Pasha makes the required changes. If there are multiple optimal positions, print any of them.","['4\nxxXx\n', '2\nXX\n', '6\nxXXxXx\n']","['1\nXxXx\n', '1\nxX\n', '0\nxXXxXx\n']",none,WRONG_ANSWER,"n = int(input())//2
l1 = list(input())
const = l1.count(""x"")-l1.count(""X"")
if const<0:
    const=-const
    const-=1
    while const:
        const-=1
        l1[l1.index(""X"")]=""x""
elif const>0:
    const-=1
    while const:
        const-=1
        l1[l1.index(""x"")]=""X""

print("""".join(l1))

    ","x, y, z = map(int, input().split())
result = [x]

def fun():
    # Keep track of the current index to prevent infinite recursion
    idx = 0
    while idx < len(result):
        if result[idx] > 1:
            # Replace the element x with [x-1, x-1, ..., x-1] (x times)
            result.pop(idx)
            result.extend([result[idx]] * result[idx])  # Extending with `result[idx]` times
            idx -= 1  # Adjust index since we modified the list
        idx += 1

    # Count the number of 1s in the specified range
    return result[y-1:z].count(1)

fun()
print(result[y-1:z].count(1))"
835,A,Key races,PROGRAMMING,['math'],"Two boys decided to compete in text typing on the site ""Key races"". During the competition, they have to type a text consisting of *s* characters. The first participant types one character in *v*1 milliseconds and has ping *t*1 milliseconds. The second participant types one character in *v*2 milliseconds and has ping *t*2 milliseconds.

If connection ping (delay) is *t* milliseconds, the competition passes for a participant as follows: 
 1.  Exactly after *t* milliseconds after the start of the competition the participant receives the text to be entered. 1.  Right after that he starts to type it. 1.  Exactly *t* milliseconds after he ends typing all the text, the site receives information about it. 
The winner is the participant whose information on the success comes earlier. If the information comes from both participants at the same time, it is considered that there is a draw.

Given the length of the text and the information about participants, determine the result of the game.","The first line contains five integers *s*, *v*1, *v*2, *t*1, *t*2 (1<=≤<=*s*,<=*v*1,<=*v*2,<=*t*1,<=*t*2<=≤<=1000) — the number of characters in the text, the time of typing one character for the first participant, the time of typing one character for the the second participant, the ping of the first participant and the ping of the second participant.","If the first participant wins, print ""First"". If the second participant wins, print ""Second"". In case of a draw print ""Friendship"".","['5 1 2 1 2\n', '3 3 1 1 1\n', '4 5 3 1 5\n']","['First\n', 'Second\n', 'Friendship\n']","In the first example, information on the success of the first participant comes in 7 milliseconds, of the second participant — in 14 milliseconds. So, the first wins.

In the second example, information on the success of the first participant comes in 11 milliseconds, of the second participant — in 5 milliseconds. So, the second wins.

In the third example, information on the success of the first participant comes in 22 milliseconds, of the second participant — in 22 milliseconds. So, it is be a draw.",WRONG_ANSWER,"s,v1,v2,t1,t2=input().split()
time_1=int(t1)+int(s)*int(v1)+int(t1)
time_2=int(t2)++int(s)*int(v2)+int(t2)
if(time_1<time_2):
    print(""FIRST"")
elif(time_2<time_1):
    print(""SECOND"")
else:
    print(""FRIENDSHIP"")
    ","#黄靖涵 2300098604 工学院 2023秋

t = int(input())  # Read the number of test cases

for _ in range(t):
    a = int(input())  # Read the angle for each test case
    
    # Calculate the number of sides of the polygon
    # The internal angle of a regular polygon with n sides is given by the formula:
    # angle = (n - 2) * 180 / n, which can be rearranged to find n
    # Therefore, n = 360 / (180 - a) must be a positive integer
    if a >= 180:
        print(""NO"")  # No polygons possible with angles >= 180
    else:
        n = 360 / (180 - a)  # Calculate the number of sides
        
        # Check if n is a whole number
        if n.is_integer() and n >= 3:
            print(""YES"")  # A polygon can be formed
        else:
            print(""NO"")  # A polygon cannot be formed"
401,A,Vanya and Cards,PROGRAMMING,"['implementation', 'math']","Vanya loves playing. He even has a special set of cards to play with. Each card has a single integer. The number on the card can be positive, negative and can even be equal to zero. The only limit is, the number on each card doesn't exceed *x* in the absolute value.

Natasha doesn't like when Vanya spends a long time playing, so she hid all of his cards. Vanya became sad and started looking for the cards but he only found *n* of them. Vanya loves the balance, so he wants the sum of all numbers on found cards equal to zero. On the other hand, he got very tired of looking for cards. Help the boy and say what is the minimum number of cards does he need to find to make the sum equal to zero?

You can assume that initially Vanya had infinitely many cards with each integer number from <=-<=*x* to *x*.",The first line contains two integers: *n* (1<=≤<=*n*<=≤<=1000) — the number of found cards and *x* (1<=≤<=*x*<=≤<=1000) — the maximum absolute value of the number on a card. The second line contains *n* space-separated integers — the numbers on found cards. It is guaranteed that the numbers do not exceed *x* in their absolute value.,Print a single number — the answer to the problem.,"['3 2\n-1 1 2\n', '2 3\n-2 -2\n']","['1\n', '2\n']","In the first sample, Vanya needs to find a single card with number -2.

In the second sample, Vanya needs to find two cards with number 2. He can't find a single card with the required number as the numbers on the lost cards do not exceed 3 in their absolute value.",WRONG_ANSWER,"n,x = map(int,input().split())
l = list(map(int,input().split()))
s = sum(l)
if(s in  range(-x,x+1)):
	print(1)
else:
	count = 0
	while(s<0):
		s+=x
		count+=1
	while(s>0 and s>x):
		s-=x
		count+=1
	print(count)","import math
import sys

def scan():
    return list(map(int, sys.stdin.readline().strip().split()))

def z_sort(n, a):
    even_indices = []
    odd_indices = []
    
    # Separate the numbers into even and odd index lists
    for i in range(n):
        if i % 2 == 0:
            even_indices.append(a[i])
        else:
            odd_indices.append(a[i])
    
    # Sort both lists
    even_indices.sort()
    odd_indices.sort()

    # Create a result array
    result = [0] * n
    
    # Place the sorted numbers back in their respective positions
    for i in range(n):
        if i % 2 == 0:
            result[i] = even_indices[i // 2]
        else:
            result[i] = odd_indices[i // 2]
    
    # Check if the result meets the z-sorted conditions
    for i in range(1, n):
        if (i % 2 == 0 and result[i] < result[i - 1]) or (i % 2 == 1 and result[i] > result[i - 1]):
            return ""Impossible""
    
    return ' '.join(map(str, result))

n = int(sys.stdin.readline().strip())
a = scan()
print(z_sort(n, a))"
275,A,Lights Out,PROGRAMMING,['implementation'],"Lenny is playing a game on a 3<=×<=3 grid of lights. In the beginning of the game all lights are switched on. Pressing any of the lights will toggle it and all side-adjacent lights. The goal of the game is to switch all the lights off. We consider the toggling as follows: if the light was switched on then it will be switched off, if it was switched off then it will be switched on.

Lenny has spent some time playing with the grid and by now he has pressed each light a certain number of times. Given the number of times each light is pressed, you have to print the current state of each light.",The input consists of three rows. Each row contains three integers each between 0 to 100 inclusive. The *j*-th number in the *i*-th row is the number of times the *j*-th light of the *i*-th row of the grid is pressed.,"Print three lines, each containing three characters. The *j*-th character of the *i*-th line is ""1"" if and only if the corresponding light is switched on, otherwise it's ""0"".","['1 0 0\n0 0 0\n0 0 1\n', '1 0 1\n8 8 8\n2 0 3\n']","['001\n010\n100\n', '010\n011\n100\n']",none,OK,"a=input()
a=a.split()
a=list(map(int,a))
b=input()
b=b.split()
b=list(map(int,b))
c=input()
c=c.split()
c=list(map(int,c))
aa=''
bb=''
cc=''
if (a[0]+b[0]+a[1])%2==0:
    aa+='1'
else:
    aa+='0'
if (a[0]+b[1]+a[1]+a[2])%2==0:
    aa+='1'
else:
    aa+='0'
if (a[2]+b[2]+a[1])%2==0:
    aa+='1'
else:
    aa+='0'
if (a[0]+b[0]+c[0]+b[1])%2==0:
    bb+='1'
else:
    bb+='0'
if (a[1]+b[0]+c[1]+b[1]+b[2])%2==0:
    bb+='1'
else:
    bb+='0'
if (a[2]+b[2]+c[2]+b[1])%2==0:
    bb+='1'
else:
    bb+='0'
if (c[0]+b[0]+c[1])%2==0:
    cc+='1'
else:
    cc+='0'
if (c[0]+b[1]+c[1]+c[2])%2==0:
    cc+='1'
else:
    cc+='0'
if (c[2]+b[2]+c[1])%2==0:
    cc+='1'
else:
    cc+='0'
print(aa)
print(bb)
print(cc)","def dfs(v, color):
    if visit[v]: 
        return
    visit[v] = True
    answer[v] = color

    for vertex in adj[v]: 
        dfs(vertex, color ^ 1)

n = int(input())
segments = []
for i in range(n):
    l, r = map(int, input().split())
    segments.append((l, r, i))

# Sort segments by their starting point
segments.sort()

# Adjacency list for the segments
adj = [[] for _ in range(n)]
visit = [False] * n
answer = [0] * n

# Build the adjacency list based on overlap
for i in range(n):
    for j in range(i + 1, n):
        if segments[j][0] <= segments[i][1]:  # There is an overlap
            adj[i].append(j)
            adj[j].append(i)
        else:
            break

# Perform DFS to color the segments
for i in range(n):
    if not visit[i]:
        dfs(i, 0)

# Verify if the coloring is valid
valid = True
for x in range(n):
    red_count = sum(1 for k in range(n) if segments[k][0] <= segments[x][0] <= segments[k][1] and answer[k] == 0)
    blue_count = sum(1 for k in range(n) if segments[k][0] <= segments[x][0] <= segments[k][1] and answer[k] == 1)

    if abs(red_count - blue_count) > 1:
        valid = False
        break

if valid:
    print(' '.join(map(str, answer)))
else:
    print(-1)"
381,A,Sereja and Dima,PROGRAMMING,"['greedy', 'implementation', 'two pointers']","Sereja and Dima play a game. The rules of the game are very simple. The players have *n* cards in a row. Each card contains a number, all numbers on the cards are distinct. The players take turns, Sereja moves first. During his turn a player can take one card: either the leftmost card in a row, or the rightmost one. The game ends when there is no more cards. The player who has the maximum sum of numbers on his cards by the end of the game, wins.

Sereja and Dima are being greedy. Each of them chooses the card with the larger number during his move.

Inna is a friend of Sereja and Dima. She knows which strategy the guys are using, so she wants to determine the final score, given the initial state of the game. Help her.",The first line contains integer *n* (1<=≤<=*n*<=≤<=1000) — the number of cards on the table. The second line contains space-separated numbers on the cards from left to right. The numbers on the cards are distinct integers from 1 to 1000.,"On a single line, print two integers. The first number is the number of Sereja's points at the end of the game, the second number is the number of Dima's points at the end of the game.","['4\n4 1 2 10\n', '7\n1 2 3 4 5 6 7\n']","['12 5\n', '16 12\n']","In the first sample Sereja will take cards with numbers 10 and 2, so Sereja's sum is 12. Dima will take cards with numbers 4 and 1, so Dima's sum is 5.",OK,"from collections import deque

n = int(input())
a = deque([int(i) for i in input().split()])
sereza = 0
dima = 0

turns = 1

while len(a) > 0:
    if turns % 2 == 1:
        if a[0] > a[-1]:
            sereza += a[0]
            a.popleft()
        else:
            sereza += a[-1]
            a.pop()
    else:
        if a[0] > a[-1]:
            dima += a[0]
            a.popleft()
        else:
            dima += a[-1]
            a.pop()
    turns += 1     
    
print(sereza, dima)","def main() -> None:
    BANK_STATE: int = int(input())
    
    # Option 1: Keep the original bank state
    max_state = BANK_STATE
    
    # Option 2: Remove the last digit
    option2 = BANK_STATE // 10
    
    # Option 3: Remove the digit before last
    if BANK_STATE < 0:
        option3 = (BANK_STATE // 100) * 10 + (BANK_STATE % 10)
    else:
        option3 = BANK_STATE  # Not applicable for non-negative values
    
    # Compare the possible options to find the maximum state
    max_state = max(max_state, option2, option3)
    
    print(max_state)

main()"
50,A,Domino piling,PROGRAMMING,"['greedy', 'math']","You are given a rectangular board of *M*<=×<=*N* squares. Also you are given an unlimited number of standard domino pieces of 2<=×<=1 squares. You are allowed to rotate the pieces. You are asked to place as many dominoes as possible on the board so as to meet the following conditions:

1. Each domino completely covers two squares.

2. No two dominoes overlap.

3. Each domino lies entirely inside the board. It is allowed to touch the edges of the board.

Find the maximum number of dominoes, which can be placed under these restrictions.",In a single line you are given two integers *M* and *N* — board sizes in squares (1<=≤<=*M*<=≤<=*N*<=≤<=16).,"Output one number — the maximal number of dominoes, which can be placed.","['2 4\n', '3 3\n']","['4\n', '4\n']",none,OK,"first_multiple_input = input().rstrip().split()
n = int(first_multiple_input[0])
k = int(first_multiple_input[1])
print(n*k//2)","import math


def dist(a, b, c, d):
    return math.sqrt((a - c) ** 2 + (b - d) ** 2)


class CodeforcesTask88BSolution:
    def __init__(self):
        self.n = 0
        self.m = 0
        self.x = 0
        self.keyboard = []
        self.shift_positions = []
        self.key_positions = {}

    def read_input(self):
        self.n, self.m, self.x = map(int, input().split())
        for i in range(self.n):
            row = input().strip()
            self.keyboard.append(row)
            for j in range(self.m):
                key = row[j]
                if key == 'S':
                    self.shift_positions.append((i, j))
                else:
                    if key not in self.key_positions:
                        self.key_positions[key] = []
                    self.key_positions[key].append((i, j))

        q = int(input().strip())
        self.text = input().strip()

    def can_type_with_one_hand(self, char):
        if char.islower():
            return char in self.key_positions
        elif char.isupper():
            lower_char = char.lower()
            if lower_char not in self.key_positions:
                return False
            
            # Check if there is a close shift key
            for (key_x, key_y) in self.key_positions[lower_char]:
                for (shift_x, shift_y) in self.shift_positions:
                    if dist(key_x, key_y, shift_x, shift_y) <= self.x:
                        return True
            return False
        return False

    def calculate_other_hand_usage(self):
        other_hand_count = 0
        for char in self.text:
            if not self.can_type_with_one_hand(char):
                return -1 if char.isupper() and char.lower() not in self.key_positions else other_hand_count + 1
            if char.isupper() and not self.can_type_with_one_hand(char):
                other_hand_count += 1

        return other_hand_count

    def solve(self):
        self.read_input()
        result = self.calculate_other_hand_usage()
        print(result)


# Uncomment the lines below to run the solution with inputs
# if __name__ == ""__main__"":
#     solution = CodeforcesTask88BSolution()
#     solution.solve()"
999,A,Mishka and Contest,PROGRAMMING,"['brute force', 'implementation']","Mishka started participating in a programming contest. There are $n$ problems in the contest. Mishka's problem-solving skill is equal to $k$.

Mishka arranges all problems from the contest into a list. Because of his weird principles, Mishka only solves problems from one of the ends of the list. Every time, he chooses which end (left or right) he will solve the next problem from. Thus, each problem Mishka solves is either the leftmost or the rightmost problem in the list.

Mishka cannot solve a problem with difficulty greater than $k$. When Mishka solves the problem, it disappears from the list, so the length of the list decreases by $1$. Mishka stops when he is unable to solve any problem from any end of the list.

How many problems can Mishka solve?","The first line of input contains two integers $n$ and $k$ ($1 \le n, k \le 100$) — the number of problems in the contest and Mishka's problem-solving skill.

The second line of input contains $n$ integers $a_1, a_2, \dots, a_n$ ($1 \le a_i \le 100$), where $a_i$ is the difficulty of the $i$-th problem. The problems are given in order from the leftmost to the rightmost in the list.",Print one integer — the maximum number of problems Mishka can solve.,"['8 4\n4 2 3 1 5 1 6 4\n', '5 2\n3 1 2 1 3\n', '5 100\n12 34 55 43 21\n']","['5\n', '0\n', '5\n']","In the first example, Mishka can solve problems in the following order: $[4, 2, 3, 1, 5, 1, 6, 4] \rightarrow [2, 3, 1, 5, 1, 6, 4] \rightarrow [2, 3, 1, 5, 1, 6] \rightarrow [3, 1, 5, 1, 6] \rightarrow [1, 5, 1, 6] \rightarrow [5, 1, 6]$, so the number of solved problems will be equal to $5$.

In the second example, Mishka can't solve any problem because the difficulties of problems from both ends are greater than $k$.

In the third example, Mishka's solving skill is so amazing that he can solve all the problems.",WRONG_ANSWER,"n,k=input().split("" "")
n=int(n)
k=int(k)

#recieve list of elements which they length is n 
# if number of element bigger than n ignore the additional value
c=input (). split("" "",n)
c=list(map(int,c))

#Now we will divide alist into to lists
m = int (n/2)

#we will but the last elements from the median to end and we will reverse ther
s=c[m:n]
s.reverse()

#llooping over two lists and increase h by one if k>=element in list 
#it will fo out from the loop if he met element >k
h=0

for i in c[0:m]:
    
    if (k>i or k==i ):h+=1;
    else :break;
                
for i in s:
    
    if (k>i or k==i ):h+=1;
    else :break;
         

#printing output
print(h)
","print('M')
    elif x==2:
        print('L')
    elif x==3:
        print('XL')
    elif x==4:
        print('XXL')

# Mapping of size indices to characters
size_map = ['S', 'M', 'L', 'XL', 'XXL']

# Remaining T-shirt counts for each size
remaining = l[:]

for _ in range(n):
    desired_size = input().strip()
    
    # Determine the index of the desired size
    size_index = size_map.index(desired_size)
   
    # Check available sizes based on preference
    for option in ul[size_index]:
        if remaining[option] > 0:  # If size is available
            remaining[option] -= 1  # Decrease the count
            prn(option)  # Print the size allocated
            break"
102,A,Clothes,PROGRAMMING,['brute force'],"A little boy Gerald entered a clothes shop and found out something very unpleasant: not all clothes turns out to match. For example, Gerald noticed that he looks rather ridiculous in a smoking suit and a baseball cap.

Overall the shop sells *n* clothing items, and exactly *m* pairs of clothing items match. Each item has its price, represented by an integer number of rubles. Gerald wants to buy three clothing items so that they matched each other. Besides, he wants to spend as little money as possible. Find the least possible sum he can spend.","The first input file line contains integers *n* and *m* — the total number of clothing items in the shop and the total number of matching pairs of clothing items ().

Next line contains *n* integers *a**i* (1<=≤<=*a**i*<=≤<=106) — the prices of the clothing items in rubles.

Next *m* lines each contain a pair of space-separated integers *u**i* and *v**i* (1<=≤<=*u**i*,<=*v**i*<=≤<=*n*,<=*u**i*<=≠<=*v**i*). Each such pair of numbers means that the *u**i*-th and the *v**i*-th clothing items match each other. It is guaranteed that in each pair *u**i* and *v**i* are distinct and all the unordered pairs (*u**i*,<=*v**i*) are different.","Print the only number — the least possible sum in rubles that Gerald will have to pay in the shop. If the shop has no three clothing items that would match each other, print ""-1"" (without the quotes).","['3 3\n1 2 3\n1 2\n2 3\n3 1\n', '3 2\n2 3 4\n2 3\n2 1\n', '4 4\n1 1 1 1\n1 2\n2 3\n3 4\n4 1\n']","['6\n', '-1\n', '-1\n']","In the first test there only are three pieces of clothing and they all match each other. Thus, there is only one way — to buy the 3 pieces of clothing; in this case he spends 6 roubles.

The second test only has three pieces of clothing as well, yet Gerald can't buy them because the first piece of clothing does not match the third one. Thus, there are no three matching pieces of clothing. The answer is -1.

In the third example there are 4 pieces of clothing, but Gerald can't buy any 3 of them simultaneously. The answer is -1.",RUNTIME_ERROR,"import math
def gcd(a,b):
    while a%b !=0:
        aux = b
        b = a%b
        a = aux
    return b

def lcm(a,b):
    return (a/gcd(a,b))*b

def solve(a):
    return ((a-3)//3)-1
    
for _ in range(int(input())):
    a = int(input())
    print(solve(a))
","def yzd_solution(f, shop):
    # Sort days based on the potential gain of increasing sales
    sorted_values = sorted(shop.items(), key=lambda item: item[1][1], reverse=True)

    for (k, l) in sorted_values:
        if f == 0:
            break  # Stop if we've chosen enough sell-out days
        potential_sales = min(l[0] * 2, l[1])  # Maximize the sales with doubling
        l[0] *= 2  # Double the products for sell-out day
        f -= 1  # Decrement the number of available sell-out days

    total_sales = 0  # Initialize total sales counter
    for (k, l) in shop.items():
        total_sales += min(l[0], l[1])  # Calculate total sales for each day

    return total_sales"
479,C,Exams,PROGRAMMING,"['greedy', 'sortings']","Student Valera is an undergraduate student at the University. His end of term exams are approaching and he is to pass exactly *n* exams. Valera is a smart guy, so he will be able to pass any exam he takes on his first try. Besides, he can take several exams on one day, and in any order.

According to the schedule, a student can take the exam for the *i*-th subject on the day number *a**i*. However, Valera has made an arrangement with each teacher and the teacher of the *i*-th subject allowed him to take an exam before the schedule time on day *b**i* (*b**i*<=&lt;<=*a**i*). Thus, Valera can take an exam for the *i*-th subject either on day *a**i*, or on day *b**i*. All the teachers put the record of the exam in the student's record book on the day of the actual exam and write down the date of the mark as number *a**i*.

Valera believes that it would be rather strange if the entries in the record book did not go in the order of non-decreasing date. Therefore Valera asks you to help him. Find the minimum possible value of the day when Valera can take the final exam if he takes exams so that all the records in his record book go in the order of non-decreasing date.","The first line contains a single positive integer *n* (1<=≤<=*n*<=≤<=5000) — the number of exams Valera will take.

Each of the next *n* lines contains two positive space-separated integers *a**i* and *b**i* (1<=≤<=*b**i*<=&lt;<=*a**i*<=≤<=109) — the date of the exam in the schedule and the early date of passing the *i*-th exam, correspondingly.",Print a single integer — the minimum possible number of the day when Valera can take the last exam if he takes all the exams so that all the records in his record book go in the order of non-decreasing date.,"['3\n5 2\n3 1\n4 2\n', '3\n6 1\n5 2\n4 3\n']","['2\n', '6\n']","In the first sample Valera first takes an exam in the second subject on the first day (the teacher writes down the schedule date that is 3). On the next day he takes an exam in the third subject (the teacher writes down the schedule date, 4), then he takes an exam in the first subject (the teacher writes down the mark with date 5). Thus, Valera takes the last exam on the second day and the dates will go in the non-decreasing order: 3, 4, 5.

In the second sample Valera first takes an exam in the third subject on the fourth day. Then he takes an exam in the second subject on the fifth day. After that on the sixth day Valera takes an exam in the first subject.",WRONG_ANSWER,"a = [list(map(int,input().split())) for i in range(int(input()))]
b = sorted(a)
c = [i[1] for i in b]
if c == sorted(c):
    print(c[-1])
else:
    d = dict()
    for i,j in b:
        try:
            d[j] = min(i,d[j])
        except KeyError:
            d[j] = i
    print(max(d.values()))","s = input()

def is_hello(s):
    target = ""hello""  # The word we want to form
    target_index = 0  # Pointer for target
    for char in s:
        if char == target[target_index]:  # Check if current char matches target
            target_index += 1  # Move to the next char in target
        if target_index == len(target):  # Check if we have matched the whole target
            return ""YES""  # Successfully matched ""hello""
    return ""NO""  # Did not match ""hello""

print(is_hello(s))  # Output the result"
63,A,Sinking Ship,PROGRAMMING,"['implementation', 'sortings', 'strings']","The ship crashed into a reef and is sinking. Now the entire crew must be evacuated. All *n* crew members have already lined up in a row (for convenience let's label them all from left to right with positive integers from 1 to *n*) and await further instructions. However, one should evacuate the crew properly, in a strict order. Specifically:

The first crew members to leave the ship are rats. Then women and children (both groups have the same priority) leave the ship. After that all men are evacuated from the ship. The captain leaves the sinking ship last.

If we cannot determine exactly who should leave the ship first for any two members of the crew by the rules from the previous paragraph, then the one who stands to the left in the line leaves the ship first (or in other words, the one whose number in the line is less).

For each crew member we know his status as a crew member, and also his name. All crew members have different names. Determine the order in which to evacuate the crew.","The first line contains an integer *n*, which is the number of people in the crew (1<=≤<=*n*<=≤<=100). Then follow *n* lines. The *i*-th of those lines contains two words — the name of the crew member who is *i*-th in line, and his status on the ship. The words are separated by exactly one space. There are no other spaces in the line. The names consist of Latin letters, the first letter is uppercase, the rest are lowercase. The length of any name is from 1 to 10 characters. The status can have the following values: rat for a rat, woman for a woman, child for a child, man for a man, captain for the captain. The crew contains exactly one captain.",Print *n* lines. The *i*-th of them should contain the name of the crew member who must be the *i*-th one to leave the ship.,['6\nJack captain\nAlice woman\nCharlie man\nTeddy rat\nBob child\nJulia woman\n'],['Teddy\nAlice\nBob\nJulia\nCharlie\nJack\n'],none,OK,"from functools import cmp_to_key

class Info:
    def __init__(self, _id: int, _name: str, _status: str):
        self.id = _id
        self.name = _name
        self.status = _status

    def __str__(self):
        return f'id: {self.id}, name: {self.name}, status: {self.status}'

def customCompare(obj1:Info, obj2:Info) -> int:
    if obj1.status != ""rat"" and obj2.status == ""rat"":
        return 1
    if obj1.status == ""rat"" and obj2.status != ""rat"":
        return -1
    if (obj1.status != ""woman"" and obj1.status != ""child"") and (obj2.status == ""woman"" or obj2.status == ""child""):
        return 1
    if (obj1.status == ""woman"" or obj1.status == ""child"") and (obj2.status != ""woman"" and obj2.status != ""child""):
        return -1
    if obj1.status != ""man"" and obj2.status == ""man"":
        return 1
    if obj1.status == ""man"" and obj2.status != ""man"":
        return -1

    return obj1.id - obj2.id
def output(cont:list):
    for obj in cont:
        print(obj)

n = int(input())
cont = []

for i in range(n):
    _name, _status = input().split()
    obj = Info(i + 1, _name, _status)
    cont.append(obj)

cont.sort(key=cmp_to_key(customCompare))


for obj in cont:
    print(obj.name)
","#    Author : Mohamed Yousef 
#    Date   : 2022-12-06
import sys, math

# Function to compute last digit of n! 
def last_digit_factorial(n):
    if n == 0 or n == 1:
        return 1
    if n >= 10:
        return 0  # For n >= 10, the last digit of n! is 0
    result = 1
    for i in range(2, n + 1):
        result *= i
    return result % 10

# Read input
input_data = sys.stdin.read().strip()
a, b = map(int, input_data.split())

# Calculate the factorial of a
factorial_a = math.factorial(a)

# Calculate how many times the phoenix will reincarnate
# within the timespan b
reincarnations = b // factorial_a

# Output the last digit of the number of reincarnations
print(reincarnations % 10)"
638,A,Home Numbers,PROGRAMMING,"['*special', 'constructive algorithms', 'math']","The main street of Berland is a straight line with *n* houses built along it (*n* is an even number). The houses are located at both sides of the street. The houses with odd numbers are at one side of the street and are numbered from 1 to *n*<=-<=1 in the order from the beginning of the street to the end (in the picture: from left to right). The houses with even numbers are at the other side of the street and are numbered from 2 to *n* in the order from the end of the street to its beginning (in the picture: from right to left). The corresponding houses with even and odd numbers are strictly opposite each other, that is, house 1 is opposite house *n*, house 3 is opposite house *n*<=-<=2, house 5 is opposite house *n*<=-<=4 and so on.

Vasya needs to get to house number *a* as quickly as possible. He starts driving from the beginning of the street and drives his car to house *a*. To get from the beginning of the street to houses number 1 and *n*, he spends exactly 1 second. He also spends exactly one second to drive the distance between two neighbouring houses. Vasya can park at any side of the road, so the distance between the beginning of the street at the houses that stand opposite one another should be considered the same.

Your task is: find the minimum time Vasya needs to reach house *a*.","The first line of the input contains two integers, *n* and *a* (1<=≤<=*a*<=≤<=*n*<=≤<=100<=000) — the number of houses on the street and the number of the house that Vasya needs to reach, correspondingly. It is guaranteed that number *n* is even.",Print a single integer — the minimum time Vasya needs to get from the beginning of the street to house *a*.,"['4 2\n', '8 5\n']","['2\n', '3\n']","In the first sample there are only four houses on the street, two houses at each side. House 2 will be the last at Vasya's right.

The second sample corresponds to picture with *n* = 8. House 5 is the one before last at Vasya's left.",OK,"n, a = [int(x) for x in input().split()]
ans = 1
if a % 2 == 0:
    while n != a:
        n -= 2
        ans += 1
else:
    t = 1
    while t != a:
        t += 2
        ans += 1
print(ans)","import sys
from collections import deque

def li(): return list(map(int, sys.stdin.readline().split()))
def ls(): return list(map(str, input().strip().split()))

# Read the number of messages
n = int(sys.stdin.readline().strip())

# Initialize a deque for order preservation and a set for quick lookups
chat_list = deque()
seen_friends = set()

# Process each message recipient
for _ in range(n):
    friend = sys.stdin.readline().strip()
    
    # If the friend has not been seen, add to the front
    if friend not in seen_friends:
        chat_list.appendleft(friend)
        seen_friends.add(friend)
    else:
        # If already seen, move them to the front
        chat_list.remove(friend)
        chat_list.appendleft(friend)

# Print the final order of chats
print('\n'.join(chat_list))"
454,B,Little Pony and Sort by Shift,PROGRAMMING,['implementation'],"One day, Twilight Sparkle is interested in how to sort a sequence of integers *a*1,<=*a*2,<=...,<=*a**n* in non-decreasing order. Being a young unicorn, the only operation she can perform is a unit shift. That is, she can move the last element of the sequence to its beginning:

Help Twilight Sparkle to calculate: what is the minimum number of operations that she needs to sort the sequence?","The first line contains an integer *n* (2<=≤<=*n*<=≤<=105). The second line contains *n* integer numbers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=105).",If it's impossible to sort the sequence output -1. Otherwise output the minimum number of operations Twilight Sparkle needs to sort it.,"['2\n2 1\n', '3\n1 3 2\n', '2\n1 2\n']","['1\n', '-1\n', '0\n']",none,TIME_LIMIT_EXCEEDED,"n=int(input())
l=list(map(int,input().split()))
x=True
for i in range(n-1):
    if l[i]>l[i+1]:
        a=l[0:i+1:1]
        b=l[i+1::]
        c=a[::]
        d=b[::]
        c.sort()
        d.sort()
        if a==c and b==d and c[0]>d[0]:
            print(len(b))
            x=False
        else:
            print(-1)
            x=False
if x:
    print(0)
     ","def find_possible_values(num_chores, num_petya, num_vasya, complex_arrs):
    complex_arrs = sorted(complex_arrs)
    
    # Total number of ways to choose x
    ways = 0
    
    # We need to check the value of x that lies 
    # between complex_arrs[a-1] and complex_arrs[a]
    if num_petya + num_vasya == num_chores:
        if num_petya == 0 or num_vasya == 0:
            return 0
        if num_petya < num_chores and num_vasya < num_chores:
            # Check the boundaries
            lower_bound = complex_arrs[num_petya-1]
            upper_bound = complex_arrs[num_petya]
            if lower_bound < upper_bound:
                ways = upper_bound - lower_bound
    return ways

# Read inputs
n, a, b = map(int, input().split())
complex_arrs = list(map(int, input().split()))

# Call the function and print the result
result = find_possible_values(n, a, b, complex_arrs)
print(result)"
194,A,Exams,PROGRAMMING,"['implementation', 'math']","One day the Codeforces round author sat exams. He had *n* exams and he needed to get an integer from 2 to 5 for each exam. He will have to re-sit each failed exam, i.e. the exam that gets mark 2. 

The author would need to spend too much time and effort to make the sum of his marks strictly more than *k*. That could have spoilt the Codeforces round. On the other hand, if the sum of his marks is strictly less than *k*, the author's mum won't be pleased at all. 

The Codeforces authors are very smart and they always get the mark they choose themselves. Also, the Codeforces authors just hate re-sitting exams. 

Help the author and find the minimum number of exams he will have to re-sit if he passes the exams in the way that makes the sum of marks for all *n* exams equal exactly *k*.","The single input line contains space-separated integers *n* and *k* (1<=≤<=*n*<=≤<=50, 1<=≤<=*k*<=≤<=250) — the number of exams and the required sum of marks.

It is guaranteed that there exists a way to pass *n* exams in the way that makes the sum of marks equal exactly *k*.","Print the single number — the minimum number of exams that the author will get a 2 for, considering that the sum of marks for all exams must equal *k*.","['4 8\n', '4 10\n', '1 3\n']","['4\n', '2\n', '0\n']","In the first sample the author has to get a 2 for all his exams.

In the second sample he should get a 3 for two exams and a 2 for two more.

In the third sample he should get a 3 for one exam.",WRONG_ANSWER,"n,k=map(int,input().split())
ans=0
if(k//n==2):
    ans+=n
ans-=k%n
print(ans)","n = int(input())
sections = list(map(int, input().split()))

def check_prev(index):
    count = 0
    for i in range(index - 1, -1, -1):
        if sections[i] <= sections[index]:
            count += 1
        else:
            break
    return count

def check_next(index):
    count = 0
    for i in range(index + 1, n):
        if sections[i] <= sections[index]:
            count += 1
        else:
            break
    return count

def check(index):
    # Count watered sections including the current one
    return check_prev(index) + check_next(index) + 1

max_watered_sections = 0
for i in range(n):
    max_watered_sections = max(max_watered_sections, check(i))

print(max_watered_sections)"
36,A,Extra-terrestrial Intelligence,PROGRAMMING,['implementation'],"Recently Vasya got interested in finding extra-terrestrial intelligence. He made a simple extra-terrestrial signals’ receiver and was keeping a record of the signals for *n* days in a row. Each of those *n* days Vasya wrote a 1 in his notebook if he had received a signal that day and a 0 if he hadn’t. Vasya thinks that he has found extra-terrestrial intelligence if there is a system in the way the signals has been received, i.e. if all the intervals between successive signals are equal. Otherwise, Vasya thinks that the signals were sent by some stupid aliens no one cares about. Help Vasya to deduce from the information given by the receiver if he has found extra-terrestrial intelligence or not.",The first line contains integer *n* (3<=≤<=*n*<=≤<=100) — amount of days during which Vasya checked if there were any signals. The second line contains *n* characters 1 or 0 — the record Vasya kept each of those *n* days. It’s guaranteed that the given record sequence contains at least three 1s.,"If Vasya has found extra-terrestrial intelligence, output YES, otherwise output NO.","['8\n00111000\n', '7\n1001011\n', '7\n1010100\n']","['YES\n', 'NO\n', 'YES\n']",none,RUNTIME_ERROR,"fin = open('input.txt')
fout = open('output.txt')
n = int(fin.readline())
s = str(fin.readline())
a = set()
p = 0
d = 0
first_met = False
for i in range(n):
    if s[i] == '1':
        if not first_met:
            first_met = True
        else:
            a.add(i - d)
        d = i
if len(a) == 1:
    print(""YES"", file=fout)
else:
    print(""NO"", file=fout)
fin.close()
fout.close()
","def solution():
    n = int(input())
    nums = [int(num) for num in input().split()]
    cur = n
    wait = set()
    output = []

    for num in nums:
        wait.add(num)  # Add the current snack size to the wait set
        day_output = []
        
        # Attempt to place snacks on the tower
        while cur in wait:
            day_output.append(cur)  # Place the current snack size
            wait.remove(cur)  # Remove it from the wait set
            cur -= 1  # Move to the next smaller snack size
        
        # If there are snacks placed today, append to output
        output.append("" "".join(map(str, day_output)))
    
    # Print the results
    for line in output:
        print(line)"
254,A,Cards with Numbers,PROGRAMMING,"['constructive algorithms', 'sortings']","Petya has got 2*n* cards, each card contains some integer. The numbers on the cards can be the same. Let's index all cards by consecutive integers from 1 to 2*n*. We'll denote the number that is written on a card with number *i*, as *a**i*. In order to play one entertaining game with his friends, Petya needs to split the cards into pairs so that each pair had equal numbers on the cards. Help Petya do that.","The first line contains integer *n* (1<=≤<=*n*<=≤<=3·105). The second line contains the sequence of 2*n* positive integers *a*1,<=*a*2,<=...,<=*a*2*n* (1<=≤<=*a**i*<=≤<=5000) — the numbers that are written on the cards. The numbers on the line are separated by single spaces.","If it is impossible to divide the cards into pairs so that cards in each pair had the same numbers, print on a single line integer -1. But if the required partition exists, then print *n* pairs of integers, a pair per line — the indices of the cards that form the pairs.

Separate the numbers on the lines by spaces. You can print the pairs and the numbers in the pairs in any order. If there are multiple solutions, print any of them.","['3\n20 30 10 30 20 10\n', '1\n1 2\n']","['4 2\n1 5\n6 3\n', '-1']",none,RUNTIME_ERROR,"n = int(input())
s = list(map(int, input().split()))
if len(set(s)) != len(s)//2:
    print(-1)
else:
    ans = []
    m = list(set(s))
    for i in range(2*n):
        if s[i] in m:
            for j in range(2*n):
                if s[i] == s[j] and i != j:
                    ans.append((i+1, j+1))
                    m.remove(s[i])
    for x in ans:
        print(x[0], x[1])","# https://codeforces.com/contest/863/problem/E

n = int(input())
a = []
segments = []
for i in range(n):
    l, r = map(int, input().split())
    a.append((l, r))  # Store the working segments
    segments.append((l, r))

# Find the overall minimum and maximum working times
min_left = min(l for l, r in segments)
max_right = max(r for l, r in segments)

# To check for redundancy, we need to find the second minimum and maximum
# We will use two variables to keep track of the two extreme values
second_min_left = float('inf')
second_max_right = -float('inf')

for l, r in segments:
    if l < second_min_left:
        if l < min_left:
            second_min_left, min_left = min_left, l
        else:
            second_min_left = l
    if r > second_max_right:
        if r > max_right:
            second_max_right, max_right = max_right, r
        else:
            second_max_right = r

# Now we check each segment to see if it is redundant
for i in range(n):
    l, r = segments[i]
    
    # Check if removing the current segment keeps the overall min/max
    if l <= min_left and r >= max_right:
        # This segment is necessary as it provides the min or max
        continue
    if l == min_left and second_min_left == float('inf'):
        # No second minimum available
        continue
    if r == max_right and second_max_right == -float('inf'):
        # No second maximum available
        continue
    
    # If we reach here, this segment can be removed
    print(i + 1)
    break
else:
    # No redundant segment found
    print(-1)"
479,A,Expression,PROGRAMMING,"['brute force', 'math']","Petya studies in a school and he adores Maths. His class has been studying arithmetic expressions. On the last class the teacher wrote three positive integers *a*, *b*, *c* on the blackboard. The task was to insert signs of operations '+' and '*', and probably brackets between the numbers so that the value of the resulting expression is as large as possible. Let's consider an example: assume that the teacher wrote numbers 1, 2 and 3 on the blackboard. Here are some ways of placing signs and brackets:
 -  1+2*3=7 -  1*(2+3)=5 -  1*2*3=6 -  (1+2)*3=9 
Note that you can insert operation signs only between *a* and *b*, and between *b* and *c*, that is, you cannot swap integers. For instance, in the given sample you cannot get expression (1+3)*2.

It's easy to see that the maximum value that you can obtain is 9.

Your task is: given *a*, *b* and *c* print the maximum value that you can get.","The input contains three integers *a*, *b* and *c*, each on a single line (1<=≤<=*a*,<=*b*,<=*c*<=≤<=10).",Print the maximum value of the expression that you can obtain.,"['1\n2\n3\n', '2\n10\n3\n']","['9\n', '60\n']",none,WRONG_ANSWER,"a,b,c=int(input()),int(input()),int(input());print(max((a+b)*c,(a*b)+c,a*(b+c),a+(b*c),(a+c)*b,(a*c)+b,a*b*c))
# Colin Deiaa","from collections import Counter

# Mapping for similar characters
d = {
    'a': 'a', 'b': 'b', 'c': 'c', 'd': 'd', 'e': 'e', 'f': 'f', 'g': 'g',
    'h': 'h', 'i': 'I', 'j': 'j', 'k': 'k', 'l': 'l', 'm': 'm', 'n': 'n',
    'o': '0', 'p': 'p', 'q': 'q', 'r': 'r', 's': 's', 't': 't', 'u': 'u',
    'v': 'v', 'w': 'w', 'x': 'x', 'y': 'y', 'z': 'z',
    'A': 'a', 'B': 'b', 'C': 'c', 'D': 'd', 'E': 'e', 'F': 'f', 'G': 'g',
    'H': 'h', 'I': 'i', 'J': 'j', 'K': 'k', 'L': 'l', 'M': 'm', 'N': 'n',
    'O': '0', 'P': 'p', 'Q': 'q', 'R': 'r', 'S': 's', 'T': 't', 'U': 'u',
    'V': 'v', 'W': 'w', 'X': 'x', 'Y': 'y', 'Z': 'z',
    '0': '0', '1': 'l', '2': '2', '3': '3', '4': '4', '5': '5', '6': '6',
    '7': '7', '8': '8', '9': '9',
    '_': '_'
}

def corr(s):
    z = []
    for i in s:
        z.append(d[i])
    return z

def comp(s0, s1):
    if len(s0) == len(s1):
        # Compare characters after transformation
        return all(c1 == c2 for c1, c2 in zip(corr(s0), corr(s1)))
    return False

# Read the new login
s = input().strip()
n = int(input().strip())
existing_logins = [input().strip() for _ in range(n)]

# Check against existing logins
for existing in existing_logins:
    if comp(s, existing):
        print(""No"")
        break
else:
    print(""Yes"")"
747,C,Servers,PROGRAMMING,['implementation'],"There are *n* servers in a laboratory, each of them can perform tasks. Each server has a unique id — integer from 1 to *n*.

It is known that during the day *q* tasks will come, the *i*-th of them is characterized with three integers: *t**i* — the moment in seconds in which the task will come, *k**i* — the number of servers needed to perform it, and *d**i* — the time needed to perform this task in seconds. All *t**i* are distinct.

To perform the *i*-th task you need *k**i* servers which are unoccupied in the second *t**i*. After the servers begin to perform the task, each of them will be busy over the next *d**i* seconds. Thus, they will be busy in seconds *t**i*,<=*t**i*<=+<=1,<=...,<=*t**i*<=+<=*d**i*<=-<=1. For performing the task, *k**i* servers with the smallest ids will be chosen from all the unoccupied servers. If in the second *t**i* there are not enough unoccupied servers, the task is ignored.

Write the program that determines which tasks will be performed and which will be ignored.","The first line contains two positive integers *n* and *q* (1<=≤<=*n*<=≤<=100, 1<=≤<=*q*<=≤<=105) — the number of servers and the number of tasks. 

Next *q* lines contains three integers each, the *i*-th line contains integers *t**i*, *k**i* and *d**i* (1<=≤<=*t**i*<=≤<=106, 1<=≤<=*k**i*<=≤<=*n*, 1<=≤<=*d**i*<=≤<=1000) — the moment in seconds in which the *i*-th task will come, the number of servers needed to perform it, and the time needed to perform this task in seconds. The tasks are given in a chronological order and they will come in distinct seconds.","Print *q* lines. If the *i*-th task will be performed by the servers, print in the *i*-th line the sum of servers' ids on which this task will be performed. Otherwise, print -1.","['4 3\n1 3 2\n2 2 1\n3 4 3\n', '3 2\n3 2 3\n5 1 2\n', '8 6\n1 3 20\n4 2 1\n6 5 5\n10 1 1\n15 3 6\n21 8 8\n']","['6\n-1\n10\n', '3\n3\n', '6\n9\n30\n-1\n15\n36\n']","In the first example in the second 1 the first task will come, it will be performed on the servers with ids 1, 2 and 3 (the sum of the ids equals 6) during two seconds. In the second 2 the second task will come, it will be ignored, because only the server 4 will be unoccupied at that second. In the second 3 the third task will come. By this time, servers with the ids 1, 2 and 3 will be unoccupied again, so the third task will be done on all the servers with the ids 1, 2, 3 and 4 (the sum of the ids is 10).

In the second example in the second 3 the first task will come, it will be performed on the servers with ids 1 and 2 (the sum of the ids is 3) during three seconds. In the second 5 the second task will come, it will be performed on the server 3, because the first two servers will be busy performing the first task.",TIME_LIMIT_EXCEEDED,"n,q = [int(x) for x in input().split()]
lis = [i+1 for i in range(n)]
arr = [0 for i in range(n)]
t1 = 0
for qq in range(q):
    t,k,d = [int(x) for x in input().split()]
    count = 0
    for i in range(n):
        arr[i] = min(arr[i]+t-t1,0)
    # print('before op arr', *arr)    
    t1 = t    
    j = 0
    res = []
    while(count < k and j <n):
        if arr[j]>=0:
            count += 1
            res.append(j+1)
        j += 1   
    if count >= k :
        print(sum(res))
        for item in res:
            arr[item-1] -= d
    else:
        print(-1)            
    # print(*arr)    
    # print(*res)     
        
            # arr[j] -= d
            # ans += lis[j]

           
            
","#!/usr/bin/env python3

from __future__ import division, print_function

# import sys
# sys.setrecursionlimit(4*10**5)

# from functools import lru_cache

def is_d_magic(number, d):
    # Convert number to string to check its digits
    s = str(number)
    # Check even positions for digit d
    for i in range(len(s)):
        # Even position (0-indexed) check
        if (i % 2 == 1 and s[i] != str(d)) or (i % 2 == 0 and s[i] == str(d)):
            return False
    return True

def count_d_magic_numbers(m, d, a, b):
    count = 0
    # Iterate through the range [a, b] in increments of m
    for num in range(a, b + 1):
        if num % m == 0 and is_d_magic(num, d):
            count += 1
    return count

def main():
    m, d = map(int, input().split())
    a = int(input().strip())
    b = int(input().strip())
    
    # Count d-magic numbers in the range [a, b] that are multiples of m
    result = count_d_magic_numbers(m, d, a, b)
    
    # Output the result modulo 10^9 + 7
    print(result % (10**9 + 7))

if __name__ == '__main__':
    main()"
99,A,Help Far Away Kingdom,PROGRAMMING,['strings'],"In a far away kingdom lived the King, the Prince, the Shoemaker, the Dressmaker and many other citizens. They lived happily until great trouble came into the Kingdom. The ACMers settled there.

Most damage those strange creatures inflicted upon the kingdom was that they loved high precision numbers. As a result, the Kingdom healers had already had three appointments with the merchants who were asked to sell, say, exactly 0.273549107 beer barrels. To deal with the problem somehow, the King issued an order obliging rounding up all numbers to the closest integer to simplify calculations. Specifically, the order went like this:
-  If a number's integer part does not end with digit 9 and its fractional part is strictly less than 0.5, then the rounded up number coincides with the number’s integer part. -  If a number's integer part does not end with digit 9 and its fractional part is not less than 0.5, the rounded up number is obtained if we add 1 to the last digit of the number’s integer part.-  If the number’s integer part ends with digit 9, to round up the numbers one should go to Vasilisa the Wise. In the whole Kingdom she is the only one who can perform the tricky operation of carrying into the next position. 
Merchants found the algorithm very sophisticated and they asked you (the ACMers) to help them. Can you write a program that would perform the rounding according to the King’s order?","The first line contains a single number to round up — the integer part (a non-empty set of decimal digits that do not start with 0 — with the exception of a case when the set consists of a single digit — in this case 0 can go first), then follows character «.» (a dot), and then follows the fractional part (any non-empty set of decimal digits). The number's length does not exceed 1000 characters, including the dot. There are no other characters in the input data.","If the last number of the integer part is not equal to 9, print the rounded-up number without leading zeroes. Otherwise, print the message ""GOTO Vasilisa."" (without the quotes).","['0.0\n', '1.49\n', '1.50\n', '2.71828182845904523536\n', '3.14159265358979323846\n', '12345678901234567890.1\n', '123456789123456789.999\n']","['0', '1', '2', '3', '3', '12345678901234567890', 'GOTO Vasilisa.']",none,WRONG_ANSWER,"# Read the number as a string
number = input()

# Split the number into integer and fractional parts
integer_part, fractional_part = number.split(""."")

# Check if the last digit of the integer part is not 9
if integer_part[-1] != ""9"":
    # Check if the fractional part is less than 0.5
    if int(fractional_part) < 5:
        rounded_number = integer_part
    else:
        rounded_number = str(int(integer_part) + 1)
    print(rounded_number)
else:
    print(""GOTO Vasilisa."")
","import heapq

def main():
    n, m = map(int, input().split())
    graph = {}
    for i in range(m):
        a, b, w = map(int, input().split())
        if a not in graph.keys():
            graph[a] = []
        graph[a].append((b, w))
        if b not in graph.keys():
            graph[b] = []
        graph[b].append((a, w))  # Undirected graph

    # Initialize the distances and priority queue
    distances = {i: float('inf') for i in range(1, n + 1)}
    distances[1] = 0
    priority_queue = [(0, 1)]  # (distance, vertex)
    previous = {i: None for i in range(1, n + 1)}  # To reconstruct the path

    while priority_queue:
        current_distance, current_vertex = heapq.heappop(priority_queue)

        if current_distance > distances[current_vertex]:
            continue

        for neighbor, weight in graph.get(current_vertex, []):
            distance = current_distance + weight

            if distance < distances[neighbor]:
                distances[neighbor] = distance
                previous[neighbor] = current_vertex
                heapq.heappush(priority_queue, (distance, neighbor))

    # Check if a path exists to vertex n
    if distances[n] == float('inf'):
        print(-1)
        return

    # Reconstruct the shortest path
    path = []
    current_vertex = n
    while current_vertex is not None:
        path.append(current_vertex)
        current_vertex = previous[current_vertex]

    path.reverse()  # Reverse the path to get it from 1 to n
    print("" "".join(map(str, path)))"
581,A,Vasya the Hipster,PROGRAMMING,"['implementation', 'math']","One day Vasya the Hipster decided to count how many socks he had. It turned out that he had *a* red socks and *b* blue socks.

According to the latest fashion, hipsters should wear the socks of different colors: a red one on the left foot, a blue one on the right foot.

Every day Vasya puts on new socks in the morning and throws them away before going to bed as he doesn't want to wash them.

Vasya wonders, what is the maximum number of days when he can dress fashionable and wear different socks, and after that, for how many days he can then wear the same socks until he either runs out of socks or cannot make a single pair from the socks he's got.

Can you help him?","The single line of the input contains two positive integers *a* and *b* (1<=≤<=*a*,<=*b*<=≤<=100) — the number of red and blue socks that Vasya's got.","Print two space-separated integers — the maximum number of days when Vasya can wear different socks and the number of days when he can wear the same socks until he either runs out of socks or cannot make a single pair from the socks he's got.

Keep in mind that at the end of the day Vasya throws away the socks that he's been wearing on that day.","['3 1\n', '2 3\n', '7 3\n']","['1 1\n', '2 0\n', '3 2\n']","In the first sample Vasya can first put on one pair of different socks, after that he has two red socks left to wear on the second day.",OK,"socks = list(map(int, input().split(' ')))
first = 0 
second = 0
while socks[0] != 0 and socks[1] != 0:
    socks[0] -= 1 
    socks[1] -= 1
    first += 1
if socks[0] == 0: socks = socks[1]
elif socks[1] == 0: socks = socks[0]
while socks != 1 and socks != 0:
    socks -= 2
    second += 1
print(first, second)","from collections import defaultdict
import heapq

start = 1  # Starting vertex is 1 as per the problem statement
work, num_roads = [int(i) for i in input().split()]
edges = defaultdict(dict)
visited = set()
unvisited = set(range(1, work + 1))
distances = {i: float('inf') for i in range(1, work + 1)}
prev = {i: None for i in range(1, work + 1)}

# Read the edges and construct the graph
for _ in range(num_roads):
    a, b, w = map(int, input().split())
    if b in edges[a]:
        edges[a][b] = min(edges[a][b], w)  # Store the minimum weight for multiple edges
    else:
        edges[a][b] = w
    if a in edges[b]:
        edges[b][a] = min(edges[b][a], w)
    else:
        edges[b][a] = w

# Dijkstra's algorithm
distances[start] = 0
priority_queue = [(0, start)]

while priority_queue:
    current_distance, current_vertex = heapq.heappop(priority_queue)
    if current_vertex in visited:
        continue

    visited.add(current_vertex)

    # Process neighbors
    for neighbor, weight in edges[current_vertex].items():
        if neighbor in visited:
            continue
        new_distance = current_distance + weight

        # Update distance and previous vertex if a shorter path is found
        if new_distance < distances[neighbor]:
            distances[neighbor] = new_distance
            prev[neighbor] = current_vertex
            heapq.heappush(priority_queue, (new_distance, neighbor))

# Check the shortest path distance to vertex `work`
if distances[work] == float('inf'):
    print(-1)
else:
    # Reconstruct the shortest path
    path = []
    current_vertex = work
    while current_vertex is not None:
        path.append(current_vertex)
        current_vertex = prev[current_vertex]
    path.reverse()
    print(' '.join(map(str, path)))"
888,A,Local Extrema,PROGRAMMING,"['brute force', 'implementation']","You are given an array *a*. Some element of this array *a**i* is a local minimum iff it is strictly less than both of its neighbours (that is, *a**i*<=&lt;<=*a**i*<=-<=1 and *a**i*<=&lt;<=*a**i*<=+<=1). Also the element can be called local maximum iff it is strictly greater than its neighbours (that is, *a**i*<=&gt;<=*a**i*<=-<=1 and *a**i*<=&gt;<=*a**i*<=+<=1). Since *a*1 and *a**n* have only one neighbour each, they are neither local minima nor local maxima.

An element is called a local extremum iff it is either local maximum or local minimum. Your task is to calculate the number of local extrema in the given array.","The first line contains one integer *n* (1<=≤<=*n*<=≤<=1000) — the number of elements in array *a*.

The second line contains *n* integers *a*1, *a*2, ..., *a**n* (1<=≤<=*a**i*<=≤<=1000) — the elements of array *a*.",Print the number of local extrema in the given array.,"['3\n1 2 3\n', '4\n1 5 2 5\n']","['0\n', '2\n']",none,OK,"a = int(input())
local = list(map(int, input().split()))

ans = 0

for i in range(1, a - 1):
    if local[i] > local[i - 1] and local[i] > local[i + 1]:
        ans += 1
    if local[i] < local[i - 1] and local[i] < local[i + 1]:
        ans += 1







print(ans)","def main():
    t, sx, sy, ex, ey = list(map(int, input().split()))
    s = input()
    px, py = sx, sy
    target_x, target_y = ex - sx, ey - sy
    
    for i in range(t):
        if target_x == 0 and target_y == 0:
            print(i)
            return
        
        if s[i] == 'E':
            if target_x > 0:
                target_x -= 1
        elif s[i] == 'W':
            if target_x < 0:
                target_x += 1
        elif s[i] == 'N':
            if target_y > 0:
                target_y -= 1
        elif s[i] == 'S':
            if target_y < 0:
                target_y += 1
                
    if target_x == 0 and target_y == 0:
        print(t)
    else:
        print(-1)

main()"
659,A,Round House,PROGRAMMING,"['implementation', 'math']","Vasya lives in a round building, whose entrances are numbered sequentially by integers from 1 to *n*. Entrance *n* and entrance 1 are adjacent.

Today Vasya got bored and decided to take a walk in the yard. Vasya lives in entrance *a* and he decided that during his walk he will move around the house *b* entrances in the direction of increasing numbers (in this order entrance *n* should be followed by entrance 1). The negative value of *b* corresponds to moving |*b*| entrances in the order of decreasing numbers (in this order entrance 1 is followed by entrance *n*). If *b*<==<=0, then Vasya prefers to walk beside his entrance.

Help Vasya to determine the number of the entrance, near which he will be at the end of his walk.","The single line of the input contains three space-separated integers *n*, *a* and *b* (1<=≤<=*n*<=≤<=100,<=1<=≤<=*a*<=≤<=*n*,<=<=-<=100<=≤<=*b*<=≤<=100) — the number of entrances at Vasya's place, the number of his entrance and the length of his walk, respectively.",Print a single integer *k* (1<=≤<=*k*<=≤<=*n*) — the number of the entrance where Vasya will be at the end of his walk.,"['6 2 -5\n', '5 1 3\n', '3 2 7\n']","['3\n', '4\n', '3\n']",The first example is illustrated by the picture in the statements.,OK,"n,a,b=map(int,input().split(' '))
z=(((a+b)%n)+n)%n
if(z==0):
  print(n)
else:
  print(z)","def bfs(graph, vertex, total_vertices, k):
    total_vertices_visited = 0
    is_visited = [False] * total_vertices
    _bfsQueue = []

    _bfsQueue.append(vertex)
    total_vertices_visited += 1
    is_visited[vertex - 1] = True

    while _bfsQueue:
        current_vertex = _bfsQueue.pop(0)
        for neighbor in graph[current_vertex]:
            if not is_visited[neighbor - 1]:
                is_visited[neighbor - 1] = True
                total_vertices_visited += 1
                _bfsQueue.append(neighbor)

    return total_vertices_visited

def is_possible_tree(n, m, k, forbidden_pairs):
    # Create a graph representation
    graph = [[] for _ in range(n + 1)]
    forbidden_edges = set()

    # Store forbidden pairs
    for a, b in forbidden_pairs:
        forbidden_edges.add((a, b))
        forbidden_edges.add((b, a))

    # Determine the potential connections for vertex 1
    connections = 0
    for i in range(1, n + 1):
        if i != 1 and (1, i) not in forbidden_edges:
            connections += 1

    # Check if the degree of vertex 1 can be satisfied
    if connections < k:
        return ""impossible""

    # Remaining vertices that are not directly forbidden from connecting to vertex 1
    remaining_vertices = n - connections

    # We need to have a total of n - 1 edges in the tree
    # We can use vertex 1 to create edges to k vertices and need (n - 1 - k) edges in the rest
    if (n - 1 - k) > remaining_vertices - 1:
        return ""impossible""

    # If we can satisfy the conditions
    return ""possible""

# Read input values
n, m, k = map(int, input().split())
forbidden_pairs = [tuple(map(int, input().split())) for _ in range(m)]

# Get the result and print it
result = is_possible_tree(n, m, k, forbidden_pairs)
print(result)"
811,B,Vladik and Complicated Book,PROGRAMMING,"['implementation', 'sortings']","Vladik had started reading a complicated book about algorithms containing *n* pages. To improve understanding of what is written, his friends advised him to read pages in some order given by permutation *P*<==<=[*p*1,<=*p*2,<=...,<=*p**n*], where *p**i* denotes the number of page that should be read *i*-th in turn.

Sometimes Vladik’s mom sorted some subsegment of permutation *P* from position *l* to position *r* inclusive, because she loves the order. For every of such sorting Vladik knows number *x* — what index of page in permutation he should read. He is wondered if the page, which he will read after sorting, has changed. In other words, has *p**x* changed? After every sorting Vladik return permutation to initial state, so you can assume that each sorting is independent from each other.","First line contains two space-separated integers *n*, *m* (1<=≤<=*n*,<=*m*<=≤<=104) — length of permutation and number of times Vladik's mom sorted some subsegment of the book.

Second line contains *n* space-separated integers *p*1,<=*p*2,<=...,<=*p**n* (1<=≤<=*p**i*<=≤<=*n*) — permutation *P*. Note that elements in permutation are distinct.

Each of the next *m* lines contains three space-separated integers *l**i*, *r**i*, *x**i* (1<=≤<=*l**i*<=≤<=*x**i*<=≤<=*r**i*<=≤<=*n*) — left and right borders of sorted subsegment in *i*-th sorting and position that is interesting to Vladik.","For each mom’s sorting on it’s own line print ""Yes"", if page which is interesting to Vladik hasn't changed, or ""No"" otherwise.","['5 5\n5 4 3 2 1\n1 5 3\n1 3 1\n2 4 3\n4 4 4\n2 5 3\n', '6 5\n1 4 3 2 5 6\n2 4 3\n1 6 2\n4 5 4\n1 3 3\n2 6 3\n']","['Yes\nNo\nYes\nYes\nNo\n', 'Yes\nNo\nYes\nNo\nYes\n']","Explanation of first test case: 
 1.  [1, 2, 3, 4, 5] — permutation after sorting, 3-rd element hasn’t changed, so answer is ""Yes"". 1.  [3, 4, 5, 2, 1] — permutation after sorting, 1-st element has changed, so answer is ""No"". 1.  [5, 2, 3, 4, 1] — permutation after sorting, 3-rd element hasn’t changed, so answer is ""Yes"". 1.  [5, 4, 3, 2, 1] — permutation after sorting, 4-th element hasn’t changed, so answer is ""Yes"". 1.  [5, 1, 2, 3, 4] — permutation after sorting, 3-rd element has changed, so answer is ""No"".",RUNTIME_ERROR,"def swap(A, i, j):
	temp = A[i]
	A[i] = A[j]
	A[j] = temp

def Partition(A, p, r, x):
	
	i = p - 1
	j = r + 1
	while True:
		j-=1
		while A[j] > x:
			j-=1
		i+=1
		while A[i] < x:
			i+=1
		if i < j:
			swap(A, i, j)
		else: 
			return j

def median_of_3(a,b,c):
	
	if (a<=b and b<=c) or (c<=b and b<=a):
		return b
	elif (b<=a and a<=c) or (c<=a and a<=b):
		return a
	else:
		return c

def insertion_sort(A, p, r):
	
	for i in range(p, r + 1):
		key = A[i]
		j = i - 1
		while j>=0 and key<A[j]:
			A[j + 1] = A[j]
			j-=1
		A[j + 1] = key

def _median_of_3_quick_sort(A, f, b):
	
	if b - f + 1 <= 10:
		insertion_sort(A, f, b)
	else:
		p = Partition(A, f, b, median_of_3(A[f], \
			A[f + (b-f)//2 + 1], A[b]))
		_median_of_3_quick_sort(A, f, p)
		_median_of_3_quick_sort(A, p+1, b)

def median_of_3_quick_sort(A):
	p = 0
	r = len(A) - 1
	_median_of_3_quick_sort(A, p, r)

def main():
	t=0
	n=int(input())
	m=int(input())
	p=[]
	for i in range(n):
		a=int(input())
		p.append(a)
	while t<m:
		l=int(input())
		r=int(input())
		x=int(input())
		le=r-l+1
		pos=p[x-1]
		s=[]
		for i in range(le):
			s.append(p[l+i-1])
		median_of_3_quick_sort(s)
		pos2 = s[x-l]
		if pos2==pos:
			print(""Yes"")
		else:
			print(""No"")
		t+=1

if __name__ == '__main__':
	main()","import sys

def main():
    n = int(input())
    tab = sys.stdin.readline().strip()  # Read and strip the binary string
    
    # Function to calculate length of longest alternating subsequence
    def longest_alternating_length(s):
        if not s:
            return 0
        length = 1  # Start with the first character
        for i in range(1, len(s)):
            if s[i] != s[i - 1]:  # Compare with the previous character
                length += 1
        return length

    # Compute the original longest alternating subsequence
    original_length = longest_alternating_length(tab)
    
    # Start by flipping '0's to '1's and vice versa
        
    max_length = original_length  # Initialize max_length with original
    
    # Check information of transitions to determine maximum alternations
    for i in range(len(tab)):
        flipped = list(tab)
        flipped[i] = '1' if tab[i] == '0' else '0'  # Flip the character
        
        # Recalculate longest alternating subsequence with this flip
        new_length = longest_alternating_length(''.join(flipped))
        max_length = max(max_length, new_length)

        # Check with a contiguous flip of substring
        for j in range(i + 1, len(tab)):
            # Flip the substring from i to j
            for k in range(i, j + 1):
                flipped[k] = '1' if tab[k] == '0' else '0'
            new_length = longest_alternating_length(''.join(flipped))
            max_length = max(max_length, new_length)
    
    print(max_length)

if __name__ == ""__main__"":
    main()"
732,A,Buy a Shovel,PROGRAMMING,"['brute force', 'constructive algorithms', 'implementation', 'math']","Polycarp urgently needs a shovel! He comes to the shop and chooses an appropriate one. The shovel that Policarp chooses is sold for *k* burles. Assume that there is an unlimited number of such shovels in the shop.

In his pocket Polycarp has an unlimited number of ""10-burle coins"" and exactly one coin of *r* burles (1<=≤<=*r*<=≤<=9).

What is the minimum number of shovels Polycarp has to buy so that he can pay for the purchase without any change? It is obvious that he can pay for 10 shovels without any change (by paying the requied amount of 10-burle coins and not using the coin of *r* burles). But perhaps he can buy fewer shovels and pay without any change. Note that Polycarp should buy at least one shovel.","The single line of input contains two integers *k* and *r* (1<=≤<=*k*<=≤<=1000, 1<=≤<=*r*<=≤<=9) — the price of one shovel and the denomination of the coin in Polycarp's pocket that is different from ""10-burle coins"". 

Remember that he has an unlimited number of coins in the denomination of 10, that is, Polycarp has enough money to buy any number of shovels.",Print the required minimum number of shovels Polycarp has to buy so that he can pay for them without any change.,"['117 3\n', '237 7\n', '15 2\n']","['9\n', '1\n', '2\n']","In the first example Polycarp can buy 9 shovels and pay 9·117 = 1053 burles. Indeed, he can pay this sum by using 10-burle coins and one 3-burle coin. He can't buy fewer shovels without any change.

In the second example it is enough for Polycarp to buy one shovel.

In the third example Polycarp should buy two shovels and pay 2·15 = 30 burles. It is obvious that he can pay this sum without any change.",OK,"k,r=map(int,input().split())
for i in range(1,11):
  if (k*i)%10 in [0,r]:
    print(i)
    quit()","'''input
3 2 3
1 8 4
'''
from collections import defaultdict as dd
from collections import Counter as ccd
from itertools import permutations as pp
from itertools import combinations as cc

# Read inputs
n, k, m = map(int, input().split())
a = list(map(int, input().split()))

# Dictionary to hold numbers by their modulo m values
mod_dict = dd(list)

# Populate the dictionary with numbers based on their modulo m values
for number in a:
    mod_dict[number % m].append(number)

# Check for possible selections
for key in mod_dict:
    if len(mod_dict[key]) >= k:
        print(""Yes"")
        # Print the first k elements from this group
        print(' '.join(map(str, mod_dict[key][:k])))
        break
else:
    print(""No"")"
732,A,Buy a Shovel,PROGRAMMING,"['brute force', 'constructive algorithms', 'implementation', 'math']","Polycarp urgently needs a shovel! He comes to the shop and chooses an appropriate one. The shovel that Policarp chooses is sold for *k* burles. Assume that there is an unlimited number of such shovels in the shop.

In his pocket Polycarp has an unlimited number of ""10-burle coins"" and exactly one coin of *r* burles (1<=≤<=*r*<=≤<=9).

What is the minimum number of shovels Polycarp has to buy so that he can pay for the purchase without any change? It is obvious that he can pay for 10 shovels without any change (by paying the requied amount of 10-burle coins and not using the coin of *r* burles). But perhaps he can buy fewer shovels and pay without any change. Note that Polycarp should buy at least one shovel.","The single line of input contains two integers *k* and *r* (1<=≤<=*k*<=≤<=1000, 1<=≤<=*r*<=≤<=9) — the price of one shovel and the denomination of the coin in Polycarp's pocket that is different from ""10-burle coins"". 

Remember that he has an unlimited number of coins in the denomination of 10, that is, Polycarp has enough money to buy any number of shovels.",Print the required minimum number of shovels Polycarp has to buy so that he can pay for them without any change.,"['117 3\n', '237 7\n', '15 2\n']","['9\n', '1\n', '2\n']","In the first example Polycarp can buy 9 shovels and pay 9·117 = 1053 burles. Indeed, he can pay this sum by using 10-burle coins and one 3-burle coin. He can't buy fewer shovels without any change.

In the second example it is enough for Polycarp to buy one shovel.

In the third example Polycarp should buy two shovels and pay 2·15 = 30 burles. It is obvious that he can pay this sum without any change.",OK,"price, coin = map(int, input().split())

for i in range(1, 11):
    if (price * i) % 10 == 0 or coin == (price * i) % 10:
        print(i)
        break
","#https://codeforces.com/problemset/problem/18/A

coordenadas = input().split()

x1 = int(coordenadas[0])
y1 = int(coordenadas[1])
x2 = int(coordenadas[2])
y2 = int(coordenadas[3])
x3 = int(coordenadas[4])
y3 = int(coordenadas[5])

# Function to check if the triangle is right-angled
def is_right_angle(ax, ay, bx, by, cx, cy):
    # Calculate the squared lengths of the sides
    ab2 = (ax - bx) ** 2 + (ay - by) ** 2
    bc2 = (bx - cx) ** 2 + (by - cy) ** 2
    ca2 = (cx - ax) ** 2 + (cy - ay) ** 2
    
    # Check for Pythagorean theorem conditions
    return (ab2 + bc2 == ca2) or (ab2 + ca2 == bc2) or (bc2 + ca2 == ab2)

# Check if the original triangle is right-angled
if is_right_angle(x1, y1, x2, y2, x3, y3):
    print(""RIGHT"")
else:
    # Check if it can be transformed into a right-angled triangle
    almost_right = False
    for dx in [-1, 0, 1]:
        for dy in [-1, 0, 1]:
            if dx == 0 and dy == 0:
                continue
            # Test changing each point
            if is_right_angle(x1 + dx, y1 + dy, x2, y2, x3) or \
               is_right_angle(x1, y1, x2 + dx, y2 + dy, x3) or \
               is_right_angle(x1, y1, x2, y2, x3 + dx, y3 + dy):
                almost_right = True
                break
        if almost_right:
            break
    
    if almost_right:
        print(""ALMOST"")
    else:
        print(""NEITHER"")"
868,A,Bark to Unlock,PROGRAMMING,"['brute force', 'implementation', 'strings']","As technologies develop, manufacturers are making the process of unlocking a phone as user-friendly as possible. To unlock its new phone, Arkady's pet dog Mu-mu has to bark the password once. The phone represents a password as a string of two lowercase English letters.

Mu-mu's enemy Kashtanka wants to unlock Mu-mu's phone to steal some sensible information, but it can only bark *n* distinct words, each of which can be represented as a string of two lowercase English letters. Kashtanka wants to bark several words (not necessarily distinct) one after another to pronounce a string containing the password as a substring. Tell if it's possible to unlock the phone in this way, or not.","The first line contains two lowercase English letters — the password on the phone.

The second line contains single integer *n* (1<=≤<=*n*<=≤<=100) — the number of words Kashtanka knows.

The next *n* lines contain two lowercase English letters each, representing the words Kashtanka knows. The words are guaranteed to be distinct.","Print ""YES"" if Kashtanka can bark several words in a line forming a string containing the password, and ""NO"" otherwise.

You can print each letter in arbitrary case (upper or lower).","['ya\n4\nah\noy\nto\nha\n', 'hp\n2\nht\ntp\n', 'ah\n1\nha\n']","['YES\n', 'NO\n', 'YES\n']","In the first example the password is ""ya"", and Kashtanka can bark ""oy"" and then ""ah"", and then ""ha"" to form the string ""oyahha"" which contains the password. So, the answer is ""YES"".

In the second example Kashtanka can't produce a string containing password as a substring. Note that it can bark ""ht"" and then ""tp"" producing ""http"", but it doesn't contain the password ""hp"" as a substring.

In the third example the string ""hahahaha"" contains ""ah"" as a substring.",WRONG_ANSWER,"a=input();l=[]
for _ in range(int(input())):
    b=input()
    if b[0] == a[-1]:
        l.append(b)
    elif b[-1] == a[0]:
        l.append(b)
print(""YES"" if l else ""NO"")","import sys

# Read the dimensions of the flag
n, m = map(int, sys.stdin.readline().strip().split())

flag = [sys.stdin.readline().strip() for _ in range(n)]

# Check for the striped condition
for i in range(n):
    # Check if all columns in the current row are of the same color
    if len(set(flag[i])) != 1:
        print(""NO"")
        sys.exit()

    # Check if the current row is different from the previous row
    if i > 0 and flag[i] == flag[i - 1]:
        print(""NO"")
        sys.exit()

print(""YES"")"
59,A,Word,PROGRAMMING,"['implementation', 'strings']","Vasya is very upset that many people on the Net mix uppercase and lowercase letters in one word. That's why he decided to invent an extension for his favorite browser that would change the letters' register in every word so that it either only consisted of lowercase letters or, vice versa, only of uppercase ones. At that as little as possible letters should be changed in the word. For example, the word HoUse must be replaced with house, and the word ViP — with VIP. If a word contains an equal number of uppercase and lowercase letters, you should replace all the letters with lowercase ones. For example, maTRIx should be replaced by matrix. Your task is to use the given method on one given word.",The first line contains a word *s* — it consists of uppercase and lowercase Latin letters and possesses the length from 1 to 100.,"Print the corrected word *s*. If the given word *s* has strictly more uppercase letters, make the word written in the uppercase register, otherwise - in the lowercase one.","['HoUse\n', 'ViP\n', 'maTRIx\n']","['house\n', 'VIP\n', 'matrix\n']",none,OK,"s=input()
u=0
l=0
o=""""
for i in range(0,len(s)):
    a=s[i]
    if(a.isupper()):
        u=u+1
    else:
        l=l+1
if u>l:
    o=s.upper()
elif u<l:
    o=s.lower()
else:
    o=s.lower()
print(o)","def main():
    c, hr, hb, wr, wb = map(int, input().split())
    ans = 0

    # Calculate the maximum number of red and blue candies that can be eaten
    max_red_candies = c // wr
    max_blue_candies = c // wb

    # Try all possible numbers of red candies from 0 to max_red_candies
    for red_candies in range(max_red_candies + 1):
        weight_from_red = red_candies * wr
        remaining_weight = c - weight_from_red
        
        # Calculate the number of blue candies that can be eaten with the remaining weight
        blue_candies = remaining_weight // wb
        
        # Calculate total joy units
        total_joy = red_candies * hr + blue_candies * hb
        
        # Update the answer if the total joy is higher
        ans = max(ans, total_joy)

    print(ans)

if __name__ == ""__main__"":
    main()"
411,A,Password Check,PROGRAMMING,"['*special', 'implementation']","You have probably registered on Internet sites many times. And each time you should enter your invented password. Usually the registration form automatically checks the password's crypt resistance. If the user's password isn't complex enough, a message is displayed. Today your task is to implement such an automatic check.

Web-developers of the company Q assume that a password is complex enough, if it meets all of the following conditions:
 -  the password length is at least 5 characters; -  the password contains at least one large English letter; -  the password contains at least one small English letter; -  the password contains at least one digit. 
You are given a password. Please implement the automatic check of its complexity for company Q.","The first line contains a non-empty sequence of characters (at most 100 characters). Each character is either a large English letter, or a small English letter, or a digit, or one of characters: ""!"", ""?"", ""."", "","", ""_"".","If the password is complex enough, print message ""Correct"" (without the quotes), otherwise print message ""Too weak"" (without the quotes).","['abacaba\n', 'X12345\n', 'CONTEST_is_STARTED!!11\n']","['Too weak\n', 'Too weak\n', 'Correct\n']",none,WRONG_ANSWER,"# -*- coding: utf-8 -*-
""""""
Created on Sun Dec 11 09:35:06 2022

@author: ahmed abdelaziz foaud
#ID: 120210044
""""""

print(""this program takes password and check if it is strong enough"")
pass_word=input(""enter password: "")
letter=0
cap=0
small=0
nums=0
for i in pass_word:
    if ord(i) in range(65,91):
        cap+=1
        letter+=1
    elif ord(i) in range(97,123):
        small+=1
        letter+=1
    elif ord(i) in range(48,58):
        nums+=1
        
        
if letter>=5 and nums>=1 and cap>=1 and small>=1:
    print(""correct"")
else:
    print(""too weak"")
        
        
        ","import sys

def main():
    n = int(sys.stdin.readline())
    a = list(map(int, sys.stdin.readline().split(' ')))
    m = int(sys.stdin.readline())
    b = list(map(int, sys.stdin.readline().split(' ')))

    max_ratio = 0
    ratio_count = 0
    
    # Check each combination of gear ratios
    for i in range(n):
        for j in range(m):
            # Check if the gear ratio is an integer
            if b[j] % a[i] == 0:
                ratio = b[j] // a[i]
                # Update max_ratio and count
                if ratio > max_ratio:
                    max_ratio = ratio
                    ratio_count = 1  # Reset count for new max ratio
                elif ratio == max_ratio:
                    ratio_count += 1

    print(ratio_count)

if __name__ == ""__main__"":
    main()"
166,E,Tetrahedron,PROGRAMMING,"['dp', 'math', 'matrices']","You are given a tetrahedron. Let's mark its vertices with letters *A*, *B*, *C* and *D* correspondingly.

An ant is standing in the vertex *D* of the tetrahedron. The ant is quite active and he wouldn't stay idle. At each moment of time he makes a step from one vertex to another one along some edge of the tetrahedron. The ant just can't stand on one place.

You do not have to do much to solve the problem: your task is to count the number of ways in which the ant can go from the initial vertex *D* to itself in exactly *n* steps. In other words, you are asked to find out the number of different cyclic paths with the length of *n* from vertex *D* to itself. As the number can be quite large, you should print it modulo 1000000007 (109<=+<=7).",The first line contains the only integer *n* (1<=≤<=*n*<=≤<=107) — the required length of the cyclic path.,Print the only integer — the required number of ways modulo 1000000007 (109<=+<=7).,"['2\n', '4\n']","['3\n', '21\n']","The required paths in the first sample are: 
 -  *D* - *A* - *D* -  *D* - *B* - *D* -  *D* - *C* - *D*",TIME_LIMIT_EXCEEDED,"mod = 1000000007

n = int(input())


dp = [1, 0, 0, 0]
tot = 1
for i in range(n):
    tmp = []
    for k in range(4):
        tmp.append((sum(dp) + mod - dp[k]) % mod)
    dp = tmp
print(dp[0])","def main():
    input()
    digits = list(map(int, input().strip()))
    l = [digits]

    # Generate all combinations using the two operations
    for _ in range(10):  # Since we can roll over the digits 10 times at most
        l.append([(x + 1) % 10 for x in l[-1]])  # First button operation
        l.append(l[-1][-1:] + l[-1][:-1])  # Second button operation (rotate right)

    # Convert each combination of digits to an integer representation
    unique_numbers = {int(''.join(map(str, comb))) for comb in l}
    
    # Find the smallest number
    smallest_number = min(unique_numbers)

    # Print the result as a zero-padded string
    print(str(smallest_number).zfill(len(digits)))

if __name__ == ""__main__"":
    main()"
735,D,Taxes,PROGRAMMING,"['math', 'number theory']","Mr. Funt now lives in a country with a very specific tax laws. The total income of mr. Funt during this year is equal to *n* (*n*<=≥<=2) burles and the amount of tax he has to pay is calculated as the maximum divisor of *n* (not equal to *n*, of course). For example, if *n*<==<=6 then Funt has to pay 3 burles, while for *n*<==<=25 he needs to pay 5 and if *n*<==<=2 he pays only 1 burle.

As mr. Funt is a very opportunistic person he wants to cheat a bit. In particular, he wants to split the initial *n* in several parts *n*1<=+<=*n*2<=+<=...<=+<=*n**k*<==<=*n* (here *k* is arbitrary, even *k*<==<=1 is allowed) and pay the taxes for each part separately. He can't make some part equal to 1 because it will reveal him. So, the condition *n**i*<=≥<=2 should hold for all *i* from 1 to *k*.

Ostap Bender wonders, how many money Funt has to pay (i.e. minimal) if he chooses and optimal way to split *n* in parts.",The first line of the input contains a single integer *n* (2<=≤<=*n*<=≤<=2·109) — the total year income of mr. Funt.,Print one integer — minimum possible number of burles that mr. Funt has to pay as a tax.,"['4\n', '27\n']","['2\n', '3\n']",none,OK,"from math import sqrt


def prime(n):
    for d in range(3, int(sqrt(n)) + 1, 2):
        if n % d == 0:
            return 0
    return 1


n = int(input())
if n == 2:
    print(1)
elif n % 2 == 0:
    print(2)
elif prime(n):
    print(1)
elif prime(n - 2):
    print(2)
else:
    print(3)
","def calcTrees(cont, startRow, startCol, a, b):
    trees = 0
    for i in range(a):
        for j in range(b):
            if cont[startRow + i][startCol + j] == 1:
                trees += 1
    return trees

def minChoppedTrees(cont, n, m, a, b):
    min_trees = float('inf')

    # Check for both orientations of the rectangle
    for width, height in [(a, b), (b, a)]:
        # Iterate over each possible starting point for the rectangle
        for startRow in range(n - height + 1):
            for startCol in range(m - width + 1):
                # Calculate trees for current rectangle position
                trees = calcTrees(cont, startRow, startCol, height, width)
                min_trees = min(min_trees, trees)

    return min_trees

# Input reading
n, m = map(int, input().split())
cont = [list(map(int, input().split())) for _ in range(n)]
a, b = map(int, input().split())

# Find minimum number of chopped trees
result = minChoppedTrees(cont, n, m, a, b)

# Output the result
print(result)"
70,C,Lucky Tickets,PROGRAMMING,"['binary search', 'data structures', 'sortings', 'two pointers']","In Walrusland public transport tickets are characterized by two integers: by the number of the series and by the number of the ticket in the series. Let the series number be represented by *a* and the ticket number — by *b*, then a ticket is described by the ordered pair of numbers (*a*,<=*b*). 

The walruses believe that a ticket is lucky if *a*<=*<=*b*<==<=*rev*(*a*)<=*<=*rev*(*b*). The function *rev*(*x*) reverses a number written in the decimal system, at that the leading zeroes disappear. For example, *rev*(12343)<==<=34321, *rev*(1200)<==<=21.

The Public Transport Management Committee wants to release *x* series, each containing *y* tickets, so that at least *w* lucky tickets were released and the total number of released tickets (*x*<=*<=*y*) were minimum. The series are numbered from 1 to *x* inclusive. The tickets in each series are numbered from 1 to *y* inclusive. The Transport Committee cannot release more than *max**x* series and more than *max**y* tickets in one series.","The first line contains three integers *max**x*, *max**y*, *w* (1<=≤<=*max**x*,<=*max**y*<=≤<=105, 1<=≤<=*w*<=≤<=107).","Print on a single line two space-separated numbers, the *x* and the *y*. If there are several possible variants, print any of them. If such *x* and *y* do not exist, print a single number <=-<=1.","['2 2 1\n', '132 10 35\n', '5 18 1000\n', '48 132 235\n']","['1 1', '7 5', '-1\n', '22 111']",none,WRONG_ANSWER,"print(""_RANDOM_GUESS_1690580160.0545058"")# 1690580160.0545278","import sys
# sys.stdin = open("".in"", ""r"")
# sys.stdout = open("".out"", ""w"")
input = sys.stdin.readline

def print(*args, end='\n', sep=' ') -> None:
    sys.stdout.write(sep.join(map(str, args)) + end)

def map_int():
    return map(int, input().split())

def can_meet_at_time(x, v, time):
    min_position = float('-inf')
    max_position = float('inf')
    
    for i in range(len(x)):
        # Calculate the furthest positions they can reach within the given time
        min_position = max(min_position, x[i] - v[i] * time)
        max_position = min(max_position, x[i] + v[i] * time)
    
    return min_position <= max_position

def find_min_time(n, x, v):
    low, high = 0.0, 1e18  # Define the range for binary search
    precision = 1e-7  # Set precision for the result
    
    while high - low > precision:
        mid = (low + high) / 2.0
        if can_meet_at_time(x, v, mid):
            high = mid
        else:
            low = mid
            
    return high

def main():
    n = int(input())
    x = list(map_int())
    v = list(map_int())
    
    min_time = find_min_time(n, x, v)
    print(f""{min_time:.10f}"")

if __name__ == ""__main__"":
    main()"
233,A,Perfect Permutation,PROGRAMMING,"['implementation', 'math']","A permutation is a sequence of integers *p*1,<=*p*2,<=...,<=*p**n*, consisting of *n* distinct positive integers, each of them doesn't exceed *n*. Let's denote the *i*-th element of permutation *p* as *p**i*. We'll call number *n* the size of permutation *p*1,<=*p*2,<=...,<=*p**n*.

Nickolas adores permutations. He likes some permutations more than the others. He calls such permutations perfect. A perfect permutation is such permutation *p* that for any *i* (1<=≤<=*i*<=≤<=*n*) (*n* is the permutation size) the following equations hold *p**p**i*<==<=*i* and *p**i*<=≠<=*i*. Nickolas asks you to print any perfect permutation of size *n* for the given *n*.",A single line contains a single integer *n* (1<=≤<=*n*<=≤<=100) — the permutation size.,"If a perfect permutation of size *n* doesn't exist, print a single integer -1. Otherwise print *n* distinct integers from 1 to *n*, *p*1,<=*p*2,<=...,<=*p**n* — permutation *p*, that is perfect. Separate printed numbers by whitespaces.","['1\n', '2\n', '4\n']","['-1\n', '2 1 \n', '2 1 4 3 \n']",none,OK,"# -*- coding: utf-8 -*-
""""""
Created on Thu Apr 14 12:45:15 2022

@author: dehon
""""""

n = int(input())
if(n%2 == 1):
    print(-1)
else:
    for i in range(1,n+1):
        if(i%2 == 1):
            print(i+1, end=' ')
        else:
            print(i-1, end=' ')","import sys
input = sys.stdin.buffer.readline 

def process(k, S):
    d = [0 for i in range(10)]
    n = len(S)
    curr = 0
    
    # Calculate the current digit sum
    for char in S:
        curr += int(char)
    
    # If current sum is already >= k, no change is needed
    if curr >= k:
        return 0
    
    # Calculate the difference required to reach k
    required_increase = k - curr
    
    # Count how many digits we can change and the impact of those changes
    changes = 0
    potential_increases = []

    for char in S:
        digit = int(char)
        # The maximum we can increase this digit
        max_increase = 9 - digit
        if max_increase > 0:
            potential_increases.append(max_increase)

    # Sort potential increases in descending order
    potential_increases.sort(reverse=True)

    # Determine the minimum number of changes needed
    for increase in potential_increases:
        required_increase -= increase
        changes += 1
        if required_increase <= 0:
            break
    
    return changes

def main():
    k = int(input().strip())
    n = input().strip()
    result = process(k, n)
    print(result)

if __name__ == ""__main__"":
    main()"
665,C,Simple Strings,PROGRAMMING,"['dp', 'greedy', 'strings']","zscoder loves simple strings! A string *t* is called simple if every pair of adjacent characters are distinct. For example ab, aba, zscoder are simple whereas aa, add are not simple.

zscoder is given a string *s*. He wants to change a minimum number of characters so that the string *s* becomes simple. Help him with this task!",The only line contains the string *s* (1<=≤<=|*s*|<=≤<=2·105) — the string given to zscoder. The string *s* consists of only lowercase English letters.,"Print the simple string *s*' — the string *s* after the minimal number of changes. If there are multiple solutions, you may output any of them.

Note that the string *s*' should also consist of only lowercase English letters.","['aab\n', 'caaab\n', 'zscoder\n']","['bab\n', 'cabab\n', 'zscoder\n']",none,OK,"def add(a, b):
    for j in range(26):
        c = chr(j + ord('a'))
        if(c != a and c != b):
            return c
    

s = list(input())
n = len(s)
for i in range(1, n - 1):
    if(s[i] == s[i - 1]):
        s[i] = add(s[i - 1], s[i + 1])
if(n > 1):
    if(s[-1] == s[-2]):
        for j in range(26):
            c = chr(j + ord('a'))
            if(c != s[-2]):
                s[-1] = c 
                break 
    
print(''.join(s))
            
            
                ","s, v = input().split()
n = int(input())

# Define the positions and their indices
positions = ['v', '<', '^', '>']
start_index = positions.index(s)
end_index = positions.index(v)

# Calculate the clockwise and counter-clockwise positions after n seconds
cw_position = (start_index + n) % 4
ccw_position = (start_index - n) % 4

# Determine the direction based on the computations
if cw_position == end_index and ccw_position == end_index:
    print(""undefined"")
elif cw_position == end_index:
    print(""cw"")
elif ccw_position == end_index:
    print(""ccw"")"
863,A,Quasi-palindrome,PROGRAMMING,"['brute force', 'implementation']","Let quasi-palindromic number be such number that adding some leading zeros (possible none) to it produces a palindromic string. 

String *t* is called a palindrome, if it reads the same from left to right and from right to left.

For example, numbers 131 and 2010200 are quasi-palindromic, they can be transformed to strings ""131"" and ""002010200"", respectively, which are palindromes.

You are given some integer number *x*. Check if it's a quasi-palindromic number.",The first line contains one integer number *x* (1<=≤<=*x*<=≤<=109). This number is given without any leading zeroes.,"Print ""YES"" if number *x* is quasi-palindromic. Otherwise, print ""NO"" (without quotes).","['131\n', '320\n', '2010200\n']","['YES\n', 'NO\n', 'YES\n']",none,OK,"inputStr = input()
tempRev = inputStr[::-1]
ok = False
if(inputStr == tempRev):
    ok = True
else:
    zerosAdded = 0
    temp = list(inputStr)
    for i in reversed(temp):
        if(i != '0'):
            break
        else:
            zerosAdded += 1
    inputStr =inputStr.rjust(len(inputStr) + zerosAdded, ""0"")
    tempRev = inputStr[::-1]
    if(inputStr == tempRev):
        ok = True
print(""YES"" if ok else ""NO"")","from collections import defaultdict
import sys

inp = sys.stdin.readlines()
n = int(inp[0].strip())  # Read number of cities
g = defaultdict(list)

def add_edge(g, a, b):
    g[a].append(b)

# Build the graph from the input
for i in range(1, n):
    u, v = map(int, inp[i].strip().split())
    add_edge(g, u, v)
    add_edge(g, v, u)

# To store the expected journey length
expected_length = [0] * (n + 1)
# To track visited cities
visited = [False] * (n + 1)

def dfs(city, parent):
    visited[city] = True
    total_prob = 0
    count = 0

    for neighbor in g[city]:
        if not visited[neighbor]:  # Only visit unvisited cities
            count += 1
            dfs(neighbor, city)
            total_prob += expected_length[neighbor] + 1  # Add 1 for the journey to this neighbor

    if count > 0:  # If there are unvisited neighbors
        expected_length[city] = total_prob / count  # Calculate expected length

# Run DFS starting from city 1
dfs(1, -1)

# The expected journey length from city 1
print(f""{expected_length[1]:.9f}"")"
25,A,IQ test,PROGRAMMING,['brute force'],"Bob is preparing to pass IQ test. The most frequent task in this test is to find out which one of the given *n* numbers differs from the others. Bob observed that one number usually differs from the others in evenness. Help Bob — to check his answers, he needs a program that among the given *n* numbers finds one that is different in evenness.","The first line contains integer *n* (3<=≤<=*n*<=≤<=100) — amount of numbers in the task. The second line contains *n* space-separated natural numbers, not exceeding 100. It is guaranteed, that exactly one of these numbers differs from the others in evenness.",Output index of number that differs from the others in evenness. Numbers are numbered from 1 in the input order.,"['5\n2 4 7 8 10\n', '4\n1 2 1 1\n']","['3\n', '2\n']",none,WRONG_ANSWER,"n=int(input())
nlist=[int(i) for i in input().split()]
a0=nlist[0]
#n==3??#
if n==3:
    if nlist[0]>nlist[1] and nlist[2]<nlist[1]:
        print(""2"")
    elif nlist[0]==nlist[1] or (nlist[0]>nlist[1] and nlist[2]>nlist[1]):
        print(""3"")
    elif nlist[0]<nlist[1]:
        print(""1"")
#find evenness#
else:
    dif1=(nlist[-1]-a0)/(n-1)
    dif2=(nlist[-1]-nlist[1])/(n-2)
    dif3=(nlist[-1]-nlist[2])/(n-3)
    dif4=nlist[2]-nlist[1]
    dif5=(nlist[2]-a0)/2
    dif6=nlist[1]-a0
#allright#
    if dif1==dif2==dif3==dif4==dif5==dif6:
        dif=dif1
        for i in range(3,n):
            if (nlist[i]-nlist[i-1])!=dif:
                result=i+1
        print(result)
        
    
#a0wrong#
    elif dif2==dif3==dif4:
        print(""1"")
#a1wrong#
    elif dif1==dif3==dif5:
        print(""2"")
    elif dif6==dif4==dif5:
        print(len(nlist))
    elif dif1==dif2==dif6:
        print(""3"")
    

    
","import os

def sonya_and_robots():
    cou = 0
    n = int(input().strip())  # Number of numbers in a row
    a = list(map(int, input().strip().split()))  # List of numbers in the row

    left_positions = {}  # To store the last position of each number from the left
    right_positions = {}  # To store the first position of each number from the right

    # Iterate from left to right to populate left_positions
    for i in range(n):
        left_positions[a[i]] = i

    # Iterate from right to left to populate right_positions
    for i in range(n - 1, -1, -1):
        if a[i] not in right_positions:
            right_positions[a[i]] = i

    # Calculate valid pairs
    for p in left_positions.keys():
        if p in right_positions:
            # Count pairs (p, q) where q is any number that appears after the last occurrence of p
            for q in right_positions.keys():
                if left_positions[p] < right_positions[q]:  # Ensure the first robot stops before the second
                    cou += 1

    print(cou)"
25,A,IQ test,PROGRAMMING,['brute force'],"Bob is preparing to pass IQ test. The most frequent task in this test is to find out which one of the given *n* numbers differs from the others. Bob observed that one number usually differs from the others in evenness. Help Bob — to check his answers, he needs a program that among the given *n* numbers finds one that is different in evenness.","The first line contains integer *n* (3<=≤<=*n*<=≤<=100) — amount of numbers in the task. The second line contains *n* space-separated natural numbers, not exceeding 100. It is guaranteed, that exactly one of these numbers differs from the others in evenness.",Output index of number that differs from the others in evenness. Numbers are numbered from 1 in the input order.,"['5\n2 4 7 8 10\n', '4\n1 2 1 1\n']","['3\n', '2\n']",none,OK,"n = int(input())
m = list(map(int, input().split()))
k=0
z=0
for i in range(n):
    if m[i] % 2  !=0:
        k+=1
        b=i+1
    elif m[i] % 2 == 0:
        z+=1
        j=i+1
if k > z:
    print(j)
else:
    print(b)

    
","import time

def identifyOddness(numArr):
    qeven = 0
    qodd = 0
    index_even = -1
    index_odd = -1
    
    # Count even and odd numbers and remember their indices
    for index, num in enumerate(numArr):
        if num % 2 == 0:  # Check if number is even
            qeven += 1
            index_even = index + 1  # Store 1-based index
        else:  # Number is odd
            qodd += 1
            index_odd = index + 1  # Store 1-based index
    
    # Determine which one is different
    if qeven == 1:
        return index_even
    else:
        return index_odd

# Example usage
if __name__ == ""__main__"":
    n = int(input())
    numbers = list(map(int, input().split()))
    result = identifyOddness(numbers)
    print(result)"
1006,C,Three Parts of the Array,PROGRAMMING,"['binary search', 'data structures', 'two pointers']","You are given an array $d_1, d_2, \dots, d_n$ consisting of $n$ integer numbers.

Your task is to split this array into three parts (some of which may be empty) in such a way that each element of the array belongs to exactly one of the three parts, and each of the parts forms a consecutive contiguous subsegment (possibly, empty) of the original array. 

Let the sum of elements of the first part be $sum_1$, the sum of elements of the second part be $sum_2$ and the sum of elements of the third part be $sum_3$. Among all possible ways to split the array you have to choose a way such that $sum_1 = sum_3$ and $sum_1$ is maximum possible.

More formally, if the first part of the array contains $a$ elements, the second part of the array contains $b$ elements and the third part contains $c$ elements, then:

$$sum_1 = \sum\limits_{1 \le i \le a}d_i,$$ $$sum_2 = \sum\limits_{a + 1 \le i \le a + b}d_i,$$ $$sum_3 = \sum\limits_{a + b + 1 \le i \le a + b + c}d_i.$$

The sum of an empty array is $0$.

Your task is to find a way to split the array such that $sum_1 = sum_3$ and $sum_1$ is maximum possible.","The first line of the input contains one integer $n$ ($1 \le n \le 2 \cdot 10^5$) — the number of elements in the array $d$.

The second line of the input contains $n$ integers $d_1, d_2, \dots, d_n$ ($1 \le d_i \le 10^9$) — the elements of the array $d$.","Print a single integer — the maximum possible value of $sum_1$, considering that the condition $sum_1 = sum_3$ must be met.

Obviously, at least one valid way to split the array exists (use $a=c=0$ and $b=n$).","['5\n1 3 1 1 4\n', '5\n1 3 2 1 4\n', '3\n4 1 2\n']","['5\n', '4\n', '0\n']","In the first example there is only one possible splitting which maximizes $sum_1$: $[1, 3, 1], [~], [1, 4]$.

In the second example the only way to have $sum_1=4$ is: $[1, 3], [2, 1], [4]$.

In the third example there is only one way to split the array: $[~], [4, 1, 2], [~]$.",OK,"n = int(input())
arr = [int(x) for x in input().split("" "")]

soma1 = 0
soma2 = 0
l = 0
r = n-1
ans = 0

while l<=r:
    if soma1 < soma2:
        soma1+=arr[l]
        l += 1
    else:
        soma2 += arr[r]
        r -= 1
    if soma1 == soma2:
        ans = soma1

print(ans)

		   		    				 			 	  	  			 	","'''input
3
4 1 7
'''
from sys import stdin
import math

# Read number of cards
n = int(stdin.readline().strip())
# Read the sequence of integers on the cards
cards = list(map(int, stdin.readline().strip().split()))

# Sort cards to easily work with sequence
cards.sort()

# Handle the case for 1 card
if n == 1:
    # If there is only one card, we can place any number
    print(-1)
else:
    # Determine potential values for the new card
    potential_values = set()

    # Calculate the differences between adjacent cards
    diff = cards[1] - cards[0]

    # Check for cases
    if n == 2:
        # If there are two cards, we can place a number in the middle or extend either side
        potential_values.add(cards[0] - diff)  # Extend on the left
        potential_values.add(cards[1] + diff)  # Extend on the right
        potential_values.add((cards[0] + cards[1]) // 2)  # Middle value only if it's an integer
    else:
        # When there are more than two cards
        for i in range(n - 1):
            current_diff = cards[i + 1] - cards[i]
            if current_diff == diff:
                continue
            elif current_diff == 2 * diff:
                potential_values.add(cards[i] + diff)  # Valid middle value
            else:
                potential_values.add(cards[i] + diff)  # Potential left value
                potential_values.add(cards[i + 1] - diff)  # Potential right value

    # Remove values out of bounds or duplicates
    potential_values = [v for v in potential_values if v > 0]

    # Output results
    potential_values = sorted(set(potential_values))
    print(len(potential_values))
    if potential_values:
        print(' '.join(map(str, potential_values)))"
1005,D,Polycarp and Div 3,PROGRAMMING,"['dp', 'greedy', 'number theory']","Polycarp likes numbers that are divisible by 3.

He has a huge number $s$. Polycarp wants to cut from it the maximum number of numbers that are divisible by $3$. To do this, he makes an arbitrary number of vertical cuts between pairs of adjacent digits. As a result, after $m$ such cuts, there will be $m+1$ parts in total. Polycarp analyzes each of the obtained numbers and finds the number of those that are divisible by $3$.

For example, if the original number is $s=3121$, then Polycarp can cut it into three parts with two cuts: $3|1|21$. As a result, he will get two numbers that are divisible by $3$.

Polycarp can make an arbitrary number of vertical cuts, where each cut is made between a pair of adjacent digits. The resulting numbers cannot contain extra leading zeroes (that is, the number can begin with 0 if and only if this number is exactly one character '0'). For example, 007, 01 and 00099 are not valid numbers, but 90, 0 and 10001 are valid.

What is the maximum number of numbers divisible by $3$ that Polycarp can obtain?","The first line of the input contains a positive integer $s$. The number of digits of the number $s$ is between $1$ and $2\cdot10^5$, inclusive. The first (leftmost) digit is not equal to 0.",Print the maximum number of numbers divisible by $3$ that Polycarp can get by making vertical cuts in the given number $s$.,"['3121\n', '6\n', '1000000000000000000000000000000000\n', '201920181\n']","['2\n', '1\n', '33\n', '4\n']","In the first example, an example set of optimal cuts on the number is 3|1|21.

In the second example, you do not need to make any cuts. The specified number 6 forms one number that is divisible by $3$.

In the third example, cuts must be made between each pair of digits. As a result, Polycarp gets one digit 1 and $33$ digits 0. Each of the $33$ digits 0 forms a number that is divisible by $3$.

In the fourth example, an example set of optimal cuts is 2|0|1|9|201|81. The numbers $0$, $9$, $201$ and $81$ are divisible by $3$.",WRONG_ANSWER,"def max_divisible_numbers(s):
    n = len(s)

    # Create a DP table to store the maximum number of divisible-by-3 numbers for each prefix
    dp = [[0] * 3 for _ in range(n + 1)]

    for i in range(1, n + 1):
        # Calculate the remainder of the current digit when divided by 3
        remainder = int(s[i - 1]) % 3

        # Update the DP table based on the remainder and the previous state
        dp[i][0] = dp[i - 1][0] + (remainder == 0)
        dp[i][1] = max(dp[i - 1][1] + (remainder == 1), dp[i - 1][0] + (remainder == 2))
        dp[i][2] = max(dp[i - 1][2] + (remainder == 2), dp[i - 1][0] + (remainder == 1))

    # Return the maximum number of divisible-by-3 numbers for the entire string
    return dp[n][0]

# Read the input number and call the function
s = input().strip()
result = max_divisible_numbers(s)
print(result)","import sys
import math
import bisect

def main():
    input = sys.stdin.read
    data = input().splitlines()
    
    # Read number of songs (n) and number of moments (m)
    n, m = map(int, data[0].split())
    
    # Initialize lists for durations and counts
    durations = []
    cumulative_times = []
    
    total_time = 0
    
    # Read song data and calculate cumulative times
    for i in range(1, n + 1):
        c, t = map(int, data[i].split())
        durations.append(t)
        total_time += c * t
        cumulative_times.append(total_time)

    # Read moments
    moments = list(map(int, data[n + 1].split()))

    # Prepare the results for each moment
    results = []
    for moment in moments:
        # Use binary search to find the right song
        song_index = bisect.bisect_right(cumulative_times, moment)
        results.append(song_index)

    # Print the results
    print(' '.join(map(str, results)))

if __name__ == ""__main__"":
    main()"
104,A,Blackjack,PROGRAMMING,['implementation'],"One rainy gloomy evening when all modules hid in the nearby cafes to drink hot energetic cocktails, the Hexadecimal virus decided to fly over the Mainframe to look for a Great Idea. And she has found one!

Why not make her own Codeforces, with blackjack and other really cool stuff? Many people will surely be willing to visit this splendid shrine of high culture.

In Mainframe a standard pack of 52 cards is used to play blackjack. The pack contains cards of 13 values: 2, 3, 4, 5, 6, 7, 8, 9, 10, jacks, queens, kings and aces. Each value also exists in one of four suits: hearts, diamonds, clubs and spades. Also, each card earns some value in points assigned to it: cards with value from two to ten earn from 2 to 10 points, correspondingly. An ace can either earn 1 or 11, whatever the player wishes. The picture cards (king, queen and jack) earn 10 points. The number of points a card earns does not depend on the suit. The rules of the game are very simple. The player gets two cards, if the sum of points of those cards equals *n*, then the player wins, otherwise the player loses.

The player has already got the first card, it's the queen of spades. To evaluate chances for victory, you should determine how many ways there are to get the second card so that the sum of points exactly equals *n*.",The only line contains *n* (1<=≤<=*n*<=≤<=25) — the required sum of points.,Print the numbers of ways to get the second card in the required way if the first card is the queen of spades.,"['12\n', '20\n', '10\n']","['4', '15', '0']","In the first sample only four two's of different suits can earn the required sum of points.

In the second sample we can use all tens, jacks, queens and kings; overall it's 15 cards, as the queen of spades (as any other card) is only present once in the pack of cards and it's already in use.

In the third sample there is no card, that would add a zero to the current ten points.",WRONG_ANSWER,"import sys
from os import path
if(path.exists('input.txt')):
    sys.stdin = open(""input.txt"",""r"")
    sys.stdout = open(""output.txt"",""w"")

import math
 
n = int(input())
n = n - 10

lst = [2,3,4,5,6,7,8,9]

if n == 0:
    print(0)
else:
    if n in lst:
        print(4)
    elif n == 10:
        print(15)
    else:
        print(1)","from sys import stdin
input=stdin.readline
R=lambda:map(int,input().split())
I=lambda:int(input())

def dfs(x, y, z):
    # Perform Depth First Search to find if x can reach y with a specific color z
    visited.add(x)
    if x == y:
        return True
    for neighbor in graph[z].get(x, []):
        if neighbor not in visited:
            if dfs(neighbor, y, z):
                return True
    return False

n, m = R()
# Initialize graph where graph[color] = { vertex: [connected vertices] }
graph = {}
edges = []
for _ in range(m):
    a, b, c = R()
    if c not in graph:
        graph[c] = {}
    if a not in graph[c]:
        graph[c][a] = []
    if b not in graph[c]:
        graph[c][b] = []
    graph[c][a].append(b)
    graph[c][b].append(a)
    edges.append((a, b, c))

q = I()
queries = [tuple(R()) for _ in range(q)]
results = []

for u, v in queries:
    count = 0
    for color in graph:
        visited = set()
        # Check if u can reach v with edges of a specific color
        if dfs(u, v, color):
            count += 1
    results.append(count)

# Output results for all queries
print('\n'.join(map(str, results)))"
38,A,Army,PROGRAMMING,['implementation'],"The Berland Armed Forces System consists of *n* ranks that are numbered using natural numbers from 1 to *n*, where 1 is the lowest rank and *n* is the highest rank.

One needs exactly *d**i* years to rise from rank *i* to rank *i*<=+<=1. Reaching a certain rank *i* having not reached all the previous *i*<=-<=1 ranks is impossible.

Vasya has just reached a new rank of *a*, but he dreams of holding the rank of *b*. Find for how many more years Vasya should serve in the army until he can finally realize his dream.",The first input line contains an integer *n* (2<=≤<=*n*<=≤<=100). The second line contains *n*<=-<=1 integers *d**i* (1<=≤<=*d**i*<=≤<=100). The third input line contains two integers *a* and *b* (1<=≤<=*a*<=&lt;<=*b*<=≤<=*n*). The numbers on the lines are space-separated.,Print the single number which is the number of years that Vasya needs to rise from rank *a* to rank *b*.,"['3\n5 6\n1 2\n', '3\n5 6\n1 3\n']","['5\n', '11\n']",none,OK,"### A. Army
n=int(input())
arr=[int(x) for x in input().split()]
a,b=map(int,input().split())
total=0
for i in range(a,b):
    total+=arr[i-1]
print(total)","import sys
input = lambda: sys.stdin.readline().rstrip()
from collections import Counter, defaultdict

N, Q = map(int, input().split())
A = list(map(int, input().split()))
cnt = [0] * 32

# Count the occurrences of each power of 2 in the coins
for a in A:
    cnt[a.bit_length() - 1] += 1

results = []
for _ in range(Q):
    b = int(input())
    total_coins = 0

    # Try to collect coins to match the value b
    for i in range(31, -1, -1):
        if b <= 0:
            break
        power_of_two = 1 << i  # This is 2^i
        if power_of_two <= b:
            needed_coins = b // power_of_two
            used_coins = min(needed_coins, cnt[i])
            total_coins += used_coins
            b -= used_coins * power_of_two

    # If b is still greater than 0, we cannot form the value
    if b > 0:
        results.append(-1)
    else:
        results.append(total_coins)

# Print all results for the queries
print('\n'.join(map(str, results)))"
52,C,Circular RMQ,PROGRAMMING,['data structures'],"You are given circular array *a*0,<=*a*1,<=...,<=*a**n*<=-<=1. There are two types of operations with it: 
 -  *inc*(*lf*,<=*rg*,<=*v*) — this operation increases each element on the segment [*lf*,<=*rg*] (inclusively) by *v*; -  *rmq*(*lf*,<=*rg*) — this operation returns minimal value on the segment [*lf*,<=*rg*] (inclusively). 
Assume segments to be circular, so if *n*<==<=5 and *lf*<==<=3,<=*rg*<==<=1, it means the index sequence: 3,<=4,<=0,<=1.

Write program to process given sequence of operations.","The first line contains integer *n* (1<=≤<=*n*<=≤<=200000). The next line contains initial state of the array: *a*0,<=*a*1,<=...,<=*a**n*<=-<=1 (<=-<=106<=≤<=*a**i*<=≤<=106), *a**i* are integer. The third line contains integer *m* (0<=≤<=*m*<=≤<=200000), *m* — the number of operartons. Next *m* lines contain one operation each. If line contains two integer *lf*,<=*rg* (0<=≤<=*lf*,<=*rg*<=≤<=*n*<=-<=1) it means *rmq* operation, it contains three integers *lf*,<=*rg*,<=*v* (0<=≤<=*lf*,<=*rg*<=≤<=*n*<=-<=1;<=-<=106<=≤<=*v*<=≤<=106) — *inc* operation.","For each *rmq* operation write result for it. Please, do not use %lld specificator to read or write 64-bit integers in C++. It is preffered to use cout (also you may use %I64d).",['4\n1 2 3 4\n4\n3 0\n3 0 -1\n0 1\n2 1\n'],['1\n0\n0\n'],none,WRONG_ANSWER,"
from typing import List

class Node ():
  def __init__ (self):
    self.min=float('inf')
    self.increase=0;
    self.left=self.right=None 
    self.lChild=self.rChild=None

def recalc(root:Node):
  if root.left==root.right :return 
  root.min=min(root.lChild.min+root.lChild.increase,root.rChild.min+root.rChild.increase)

def createSgTree(nums:List[int],l:int,r:int):
  root=Node()
  root.right=r 
  root.left=l
  if l==r : 
    root.min=nums[l]
  else :
    mid=(l+r)//2 
    root.lChild=createSgTree(nums,l,mid)
    root.rChild=createSgTree(nums,mid+1,r)
    recalc(root)
  return root

def propagation(root:Node) :
  root.min+=root.increase
  if root.left!=root.right :
    root.lChild.increase=root.rChild.increase=root.increase 
  root.increase=0

def updateRange(root:Node,ql:int,qr:int,diff):
  if ql<=root.left and root.right<=qr :
    root.increase+=diff 
    return 
  if root.left>qr or root.right<ql : return 
  if root.increase!=0 :propagation(root) 
  updateRange(root.lChild,ql,qr,diff)
  updateRange(root.rChild,ql,qr,diff)
  recalc(root)

def rangeMin(root:Node,ql,qr) :
  if ql<=root.left and root.right<=qr :return root.min +root.increase
  if root.left>qr or root.right<ql : return float('inf')
  if root.increase!=0 :
    propagation(root)
  return min(rangeMin(root.lChild,ql,qr),rangeMin(root.rChild,ql,qr))

class Solution():
  def Circular_RMQ(self,n:int,nums:List[int]):
    root=createSgTree(nums,0,n-1)
    nq=int(input())
    for i in range(nq):
      request=list(map(int, input().split()))
      if len(request)==2 :
        print(min(rangeMin(root,request[0],n-1),rangeMin(root,0,request[1])))
      else :
        updateRange(root,request[0],n-1,request[2])
        updateRange(root,0,request[1],request[2])

n=int(input())
nums = list(map(int, input().split()))
x=Solution()
x.Circular_RMQ(n,nums)
","import math
def solve(arr, n):
    
    even = 0
    odd = 0
    # Count how many even and odd numbers are present
    for i in range(n):
        if arr[i] % 2 == 0:
            even += 1
        else:
            odd += 1
            
    # Determine if the differing number is even or odd
    if even > 1:
        # If there are more even numbers, find the odd one
        for i in range(n):
            if arr[i] % 2 != 0:
                return i + 1  # Return the 1-based index
    else:
        # If there are more odd numbers, find the even one
        for i in range(n):
            if arr[i] % 2 == 0:
                return i + 1  # Return the 1-based index

# Input reading part
n = int(input())
arr = list(map(int, input().split()))
print(solve(arr, n))"
71,A,Way Too Long Words,PROGRAMMING,['strings'],"Sometimes some words like ""localization"" or ""internationalization"" are so long that writing them many times in one text is quite tiresome.

Let's consider a word too long, if its length is strictly more than 10 characters. All too long words should be replaced with a special abbreviation.

This abbreviation is made like this: we write down the first and the last letter of a word and between them we write the number of letters between the first and the last letters. That number is in decimal system and doesn't contain any leading zeroes.

Thus, ""localization"" will be spelt as ""l10n"", and ""internationalization» will be spelt as ""i18n"".

You are suggested to automatize the process of changing the words with abbreviations. At that all too long words should be replaced by the abbreviation and the words that are not too long should not undergo any changes.",The first line contains an integer *n* (1<=≤<=*n*<=≤<=100). Each of the following *n* lines contains one word. All the words consist of lowercase Latin letters and possess the lengths of from 1 to 100 characters.,Print *n* lines. The *i*-th line should contain the result of replacing of the *i*-th word from the input data.,['4\nword\nlocalization\ninternationalization\npneumonoultramicroscopicsilicovolcanoconiosis\n'],['word\nl10n\ni18n\np43s\n'],none,COMPILATION_ERROR,"n = int(input())
while n > = 0 :
    n -=1 
    k = input()
    if len(k) > 10 :
        print(k[0]+str(len(k)-2)+k[-1])
    else:
        print(k)","import math

def num_to_binary(n):
    ret = []
    while n != 0:
        ret.append(n % 2)
        n //= 2
    return list(reversed(ret))

def min_clicks(n, m):
    clicks = 0

    while m > n:
        if m % 2 == 0:
            m //= 2  # If m is even, we can reverse the doubling
        else:
            m += 1  # If m is odd, we can only add 1 to make it even
        clicks += 1

    # Now, n >= m, we solely need to decrement n to m
    clicks += (n - m)
    
    return clicks

# Input
n, m = map(int, input().split())
# Output the minimum number of clicks
print(min_clicks(n, m))"
714,A,Meeting of Old Friends,PROGRAMMING,"['implementation', 'math']","Today an outstanding event is going to happen in the forest — hedgehog Filya will come to his old fried Sonya!

Sonya is an owl and she sleeps during the day and stay awake from minute *l*1 to minute *r*1 inclusive. Also, during the minute *k* she prinks and is unavailable for Filya.

Filya works a lot and he plans to visit Sonya from minute *l*2 to minute *r*2 inclusive.

Calculate the number of minutes they will be able to spend together.","The only line of the input contains integers *l*1, *r*1, *l*2, *r*2 and *k* (1<=≤<=*l*1,<=*r*1,<=*l*2,<=*r*2,<=*k*<=≤<=1018, *l*1<=≤<=*r*1, *l*2<=≤<=*r*2), providing the segments of time for Sonya and Filya and the moment of time when Sonya prinks.",Print one integer — the number of minutes Sonya and Filya will be able to spend together.,"['1 10 9 20 1\n', '1 100 50 200 75\n']","['2\n', '50\n']","In the first sample, they will be together during minutes 9 and 10.

In the second sample, they will be together from minute 50 to minute 74 and from minute 76 to minute 100.",OK,"import operator as op
import re
import sys
from bisect import bisect, bisect_left, insort, insort_left
from collections import Counter, defaultdict, deque
from copy import deepcopy
from decimal import Decimal
from functools import reduce
from itertools import (
    accumulate, combinations, combinations_with_replacement, groupby,
    permutations, product)
from math import (acos, asin, atan, ceil, cos, degrees, factorial, gcd, hypot,
                  log2, pi, radians, sin, sqrt, tan)
from operator import itemgetter, mul
from string import ascii_lowercase, ascii_uppercase, digits


def inp():
    return(int(input()))


def inlist():
    return(list(map(int, input().split())))


def instr():
    s = input()
    return(list(s[:len(s)]))


def invr():
    return(map(int, input().split()))


def def_value():
    return 0


# For getting input from input.txt file
#sys.stdin = open('input.txt', 'r')
# Printing the Output to output.txt file
#sys.stdout = open('output.txt', 'w')

l1, r1, l2, r2, k = invr()

if r2 < l1 or l2 > r1:
    print(0)
    sys.exit()


L = max(l1, l2)
R = min(r1, r2)

res = R - L + 1
if k >= L and k <= R:
    res -= 1
if res < 0:
    print(0)
else:
    print(res)
","# https://codeforces.com/problemset/problem/313/A

n = int(input())

# Initial state of the account
original_balance = n

# Option 1: Removing the last digit
remove_last_digit = n // 10

# Option 2: Removing the digit before last
# First we convert the number to string to manipulate it easily
n_str = str(n)
remove_before_last_digit = int(n_str[:-2] + n_str[-1]) if len(n_str) > 2 else original_balance

# Find the maximum balance possible
max_balance = max(original_balance, remove_last_digit, remove_before_last_digit)

# Print the maximum state of the bank account
print(max_balance)"
200,B,Drinks,PROGRAMMING,"['implementation', 'math']","Little Vasya loves orange juice very much. That's why any food and drink in his kitchen necessarily contains orange juice. There are *n* drinks in his fridge, the volume fraction of orange juice in the *i*-th drink equals *p**i* percent.

One day Vasya decided to make himself an orange cocktail. He took equal proportions of each of the *n* drinks and mixed them. Then he wondered, how much orange juice the cocktail has.

Find the volume fraction of orange juice in the final drink.","The first input line contains a single integer *n* (1<=≤<=*n*<=≤<=100) — the number of orange-containing drinks in Vasya's fridge. The second line contains *n* integers *p**i* (0<=≤<=*p**i*<=≤<=100) — the volume fraction of orange juice in the *i*-th drink, in percent. The numbers are separated by a space.",Print the volume fraction in percent of orange juice in Vasya's cocktail. The answer will be considered correct if the absolute or relative error does not exceed 10<=<=-<=4.,"['3\n50 50 100\n', '4\n0 25 50 75\n']","['66.666666666667\n', '37.500000000000\n']","Note to the first sample: let's assume that Vasya takes *x* milliliters of each drink from the fridge. Then the volume of pure juice in the cocktail will equal <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/c1fac6e64d3a8ee6a5ac138cbe51e60039b22473.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> milliliters. The total cocktail's volume equals 3·*x* milliliters, so the volume fraction of the juice in the cocktail equals <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/ceb0664e55a1f9f5fa1243ec74680a4665a4d58d.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>, that is, 66.(6) percent.",RUNTIME_ERROR,"drinks = int(input())
porcentagem = []

for i in range(drinks):
    porcentagem.append(int(input()))

volumeTotal = sum(porcentagem)
media = volumeTotal / drinks
print(media)

   	            		   	   				","def min_swaps_to_correct_lineup(n, heights):
    max_height = max(heights)
    min_height = min(heights)
    
    # Find the position of the first maximum height
    first_max_index = heights.index(max_height)
    
    # Find the position of the last minimum height
    last_min_index = n - 1 - heights[::-1].index(min_height)
    
    # Calculate the number of swaps required
    swaps = first_max_index + (n - 1 - last_min_index)
    
    # Adjust swaps if the max is before the min in the line
    if first_max_index > last_min_index:
        swaps -= 1

    return swaps

# Example of using the function
n = int(input())
heights = list(map(int, input().split()))
print(min_swaps_to_correct_lineup(n, heights))"
638,B,Making Genome in Berland,PROGRAMMING,"['*special', 'dfs and similar', 'strings']","Berland scientists face a very important task - given the parts of short DNA fragments, restore the dinosaur DNA! The genome of a berland dinosaur has noting in common with the genome that we've used to: it can have 26 distinct nucleotide types, a nucleotide of each type can occur at most once. If we assign distinct English letters to all nucleotides, then the genome of a Berland dinosaur will represent a non-empty string consisting of small English letters, such that each letter occurs in it at most once.

Scientists have *n* genome fragments that are represented as substrings (non-empty sequences of consecutive nucleotides) of the sought genome.

You face the following problem: help scientists restore the dinosaur genome. It is guaranteed that the input is not contradictory and at least one suitable line always exists. When the scientists found out that you are a strong programmer, they asked you in addition to choose the one with the minimum length. If there are multiple such strings, choose any string.","The first line of the input contains a positive integer *n* (1<=≤<=*n*<=≤<=100) — the number of genome fragments.

Each of the next lines contains one descriptions of a fragment. Each fragment is a non-empty string consisting of distinct small letters of the English alphabet. It is not guaranteed that the given fragments are distinct. Fragments could arbitrarily overlap and one fragment could be a substring of another one.

It is guaranteed that there is such string of distinct letters that contains all the given fragments as substrings.","In the single line of the output print the genome of the minimum length that contains all the given parts. All the nucleotides in the genome must be distinct. If there are multiple suitable strings, print the string of the minimum length. If there also are multiple suitable strings, you can print any of them.","['3\nbcd\nab\ncdef\n', '4\nx\ny\nz\nw\n']","['abcdef\n', 'xyzw\n']",none,WRONG_ANSWER,"n = int(input())
a = []
b = []
for i in range(n) :
	b.append(input())
b.sort(key = len,reverse = True)

for i in range(n):
    s = b[i]
    ok = False
    
    #перевірка чи є рядок пудрядком введеного
    for i in range(len(a)) :
        if a[i].replace(s,""*"")!=a[i] :
            ok = True
            break
    
    if ok : continue
    
    #перевірка,чи є кониць сього рядка початком другого
    for l in range(len(s)) :
        if ok : break
        s1 = s[l:]
        
        for i in range(len(a)) :
            s2 = a[i][:len(s1)]
            
            if s1==s2 :
                a[i] = s[:l]+a[i]
                ok = True
                break
    
    if ok : continue

    #перевірка,чи є початок сього рядка кінцьом другого
    
    l = len(s)
    while l :
        if ok : break
        s1 = s[:l]
        #print(s1)
        for i in range(len(a)) :
            s2 = a[i][len(a[i])-l:]
            #print('=='+s2)
            if s1==s2 :
                a[i] = a[i]+s[l:]
                ok = True
                break
    
        l-=1
    
    if not ok :
        a.append(s)

print("""".join(a))
#обидві перевірки роблять жадно,починаючи з найбільшої довжини рядка
","def calc(arr, sum):
    max = 0
    if sum % 2 == 0:
        print(sum)
        return
    else:
        # Initialize a variable to track the minimum odd number
        min_odd = float('inf')
        # Iterate through the array to find the minimum odd number
        for num in arr:
            if num % 2 != 0:
                min_odd = min(min_odd, num)
        # Calculate the maximum even sum by subtracting the minimum odd number from the total sum
        print(sum - min_odd)

# Read input values
n = int(input())
arr = list(map(int, input().split()))

# Calculate the total sum of the array
total_sum = sum(arr)

# Call the calc function
calc(arr, total_sum)"
50,A,Domino piling,PROGRAMMING,"['greedy', 'math']","You are given a rectangular board of *M*<=×<=*N* squares. Also you are given an unlimited number of standard domino pieces of 2<=×<=1 squares. You are allowed to rotate the pieces. You are asked to place as many dominoes as possible on the board so as to meet the following conditions:

1. Each domino completely covers two squares.

2. No two dominoes overlap.

3. Each domino lies entirely inside the board. It is allowed to touch the edges of the board.

Find the maximum number of dominoes, which can be placed under these restrictions.",In a single line you are given two integers *M* and *N* — board sizes in squares (1<=≤<=*M*<=≤<=*N*<=≤<=16).,"Output one number — the maximal number of dominoes, which can be placed.","['2 4\n', '3 3\n']","['4\n', '4\n']",none,OK,"val = [int(x) for x in input().split()]
print((val[0] * val[1])//2 if val[0]*val[1] % 2 == 0 else ((val[0]*val[1]) - 1)//2)","def splitter(s):
    li = []
    i = 0
    j = 10
    while j <= len(s):
        li.append(s[i:j])  # Append the substring of length 10 to the list
        i += 10  # Move to the next segment
        j += 10
    return li  # Return the list of segments

# Read inputs
encrypted_password = input().strip()  # Read the binary code
mappings = [input().strip() for _ in range(10)]  # Read the binary mapping for digits

# Create a dictionary to map binary codes to their respective digits
binary_to_digit = {mappings[i]: str(i) for i in range(10)}

# Split the encrypted password into 10-character segments
segments = splitter(encrypted_password)

# Convert each binary segment to its corresponding digit
password = ''.join(binary_to_digit[seg] for seg in segments)

print(password)  # Output the decoded password"
43,A,Football,PROGRAMMING,['strings'],"One day Vasya decided to have a look at the results of Berland 1910 Football Championship’s finals. Unfortunately he didn't find the overall score of the match; however, he got hold of a profound description of the match's process. On the whole there are *n* lines in that description each of which described one goal. Every goal was marked with the name of the team that had scored it. Help Vasya, learn the name of the team that won the finals. It is guaranteed that the match did not end in a tie.",The first line contains an integer *n* (1<=≤<=*n*<=≤<=100) — the number of lines in the description. Then follow *n* lines — for each goal the names of the teams that scored it. The names are non-empty lines consisting of uppercase Latin letters whose lengths do not exceed 10 symbols. It is guaranteed that the match did not end in a tie and the description contains no more than two different teams.,Print the name of the winning team. We remind you that in football the team that scores more goals is considered the winner.,"['1\nABC\n', '5\nA\nABA\nABA\nA\nA\n']","['ABC\n', 'A\n']",none,OK,"n = int(input())
cnt1, cnt2 = 1, 0
first, second = str(input()), ''

for i in range(0,n-1):
    ip = str(input())
    if ip==first:
        cnt1+=1
    else:
        second = ip
        cnt2+=1
out = first if cnt1>cnt2 else second
print(out)","graph = {} # {node: [idx, idx]}

def find_k3(node, parent=None, iter=0):
    ret = -1
    costs = []
    
    for adj in graph[node]:
        if adj != parent:
            if iter == 0:
                # Start iterating over the neighbors
                find_k3(adj, node, 1) # Move to the next iteration
            else:
                costs.append(len(graph[adj]) - 2) # Count recognition excluding other musketeers
    
    if iter == 1:
        # If we found a suitable node in the second iteration
        if len(costs) >= 2:
            costs.sort()  # Sort to find the minimum recognitions
            ret = costs[0] + costs[1]  # Sum of the two lowest recognitions

    return ret

def main():
    import sys
    input = sys.stdin.read
    data = input().splitlines()
    
    n, m = map(int, data[0].split())
    
    for i in range(1, m + 1):
        a, b = map(int, data[i].split())
        if a not in graph:
            graph[a] = []
        if b not in graph:
            graph[b] = []
        graph[a].append(b)
        graph[b].append(a)

    min_recognition = float('inf')
    found = False
    
    for warrior in range(1, n + 1):
        if warrior in graph:
            res = find_k3(warrior)
            if res != -1:
                found = True
                min_recognition = min(min_recognition, res)

    if found:
        print(min_recognition)
    else:
        print(""-1"")

if __name__ == ""__main__"":
    main()"
271,A,Beautiful Year,PROGRAMMING,['brute force'],"It seems like the year of 2013 came only yesterday. Do you know a curious fact? The year of 2013 is the first year after the old 1987 with only distinct digits.

Now you are suggested to solve the following problem: given a year number, find the minimum year number which is strictly larger than the given one and has only distinct digits.",The single line contains integer *y* (1000<=≤<=*y*<=≤<=9000) — the year number.,Print a single integer — the minimum year number that is strictly larger than *y* and all it's digits are distinct. It is guaranteed that the answer exists.,"['1987\n', '2013\n']","['2013\n', '2014\n']",none,OK,"y = input()
y = str(int(y) + 1)
while y[0] == y[1] or y[0] == y[2] or y[0] == y[3] or y[1] == y[2] or y[1] == y[3] or y[2] == y[3]:
    y = str(int(y)+1)
else:
    print(y)","import math

class CodeforcesTask388ASolution:
    def __init__(self):
        self.result = ''
        self.n = 0

    def read_input(self):
        self.n = int(input())
        self.strengths = list(map(int, input().split()))

    def minimal_piles(self):
        # Sort the strengths
        self.strengths.sort()
        # Initialize the number of piles
        piles = 0
        # Keep track of the current available positions for boxes
        current_positions = []

        for strength in self.strengths:
            # Remove positions that are used up
            current_positions = [p for p in current_positions if p > 0]
            # Check if we can place the current box on any existing pile
            if current_positions:
                # Place the box on the top of the strongest existing pile
                current_positions[-1] -= 1
            else:
                # Start a new pile
                piles += 1
            # Add the current box's strength to the positions list
            current_positions.append(strength)

        return piles

    def print_output(self):
        print(self.minimal_piles())

# Usage
if __name__ == ""__main__"":
    solution = CodeforcesTask388ASolution()
    solution.read_input()
    solution.print_output()"
723,A,The New Year: Meeting Friends,PROGRAMMING,"['implementation', 'math', 'sortings']","There are three friend living on the straight line *Ox* in Lineland. The first friend lives at the point *x*1, the second friend lives at the point *x*2, and the third friend lives at the point *x*3. They plan to celebrate the New Year together, so they need to meet at one point. What is the minimum total distance they have to travel in order to meet at some point and celebrate the New Year?

It's guaranteed that the optimal answer is always integer.","The first line of the input contains three distinct integers *x*1, *x*2 and *x*3 (1<=≤<=*x*1,<=*x*2,<=*x*3<=≤<=100) — the coordinates of the houses of the first, the second and the third friends respectively.",Print one integer — the minimum total distance the friends need to travel in order to meet together.,"['7 1 4\n', '30 20 10\n']","['6\n', '20\n']","In the first sample, friends should meet at the point 4. Thus, the first friend has to travel the distance of 3 (from the point 7 to the point 4), the second friend also has to travel the distance of 3 (from the point 1 to the point 4), while the third friend should not go anywhere because he lives at the point 4.",OK,"x1,x2,x3=map(int,input().split())
y=max(x1,x2,x3)
z=min(x1,x2,x3)
print(y-z)","def find_winners(adj, root, visited):
    # this ensures that the same node isn't visited again.
    visited.add(root)
    winners = set()
    
    for neighbour, broken in adj[root]:
        if neighbour not in visited:
            subtree_winners = find_winners(adj, neighbour, visited)
            # If the subtree didn't require repairs, we continue
            if broken:
                winners.add(neighbour)  # Candidate needs to repair this road
    
    return winners

def main():
    import sys
    from collections import defaultdict
    
    input = sys.stdin.read
    data = input().splitlines()
    
    n = int(data[0])  # the number of districts
    adj = defaultdict(list)

    for i in range(1, n):
        x, y, t = map(int, data[i].split())
        adj[x].append((y, t == 2))  # add neighbour and whether it's a problem road
        adj[y].append((x, t == 2))  # bidirectional road

    visited = set()
    winners = find_winners(adj, 1, visited)  # Start from district 1

    print(len(winners))
    print("" "".join(map(str, winners)))

if __name__ == ""__main__"":
    main()"
109,A,Lucky Sum of Digits,PROGRAMMING,"['brute force', 'implementation']","Petya loves lucky numbers. We all know that lucky numbers are the positive integers whose decimal representations contain only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.

Petya wonders eagerly what minimum lucky number has the sum of digits equal to *n*. Help him cope with the task.",The single line contains an integer *n* (1<=≤<=*n*<=≤<=106) — the sum of digits of the required lucky number.,"Print on the single line the result — the minimum lucky number, whose sum of digits equals *n*. If such number does not exist, print -1.","['11\n', '10\n']","['47\n', '-1\n']",none,RUNTIME_ERROR,"a=int(input())
ans=[]
temp=0
while(a>0):
    if(a%7==0):
        for i in range(a//7):
            ans.append(str(7))
            a=a-7
    elif(a%4==0):
        for i in range(a//4):
            ans.append(str(4))
            a=a-4
    else:
        if(a>8):
            ans.append(str(7))
            a=a-7
        else:
            print(-1)
            temp=1
            break

if(temp==0):
    z="""".join(sorted(ans))
    z=z.replace(""4444444"",""7777"")

ans1=[]
for i in z:
    if(i==""4""):
        ans1.append(""4"")
for j in z:
    if(j==""7""):
        ans1.append(""7"")
print("""".join(ans1))
","def get_data():
    d = input()
    a = 0
    c = ''
    f = []
    i = 0
    while a != 3:
        if d[i] != ' ':
            c += d[i]
        else:
            f.append(int(c))
            c = ''
            a += 1
        i += 1
    f.append(int(c))  # Append the last number
    return f  # Returns list containing [n, m, a, b]

def min_cost(n, m, a, b):
    remainder = n % m  # Calculate remainder of n when divided by m
    if remainder == 0:
        return 0  # Already divisible, no cost needed
    
    # Calculate cost to build or demolish boxes
    to_build = m - remainder  # Boxes needed to build to make n divisible by m
    to_demolish = remainder  # Boxes needed to demolish to make n divisible by m

    # Calculate total cost for both options
    cost_to_build = to_build * a  # Cost to build enough boxes
    cost_to_demolish = to_demolish * b  # Cost to demolish enough boxes
    
    # Return the minimum of both costs
    return min(cost_to_build, cost_to_demolish)

# Main execution
n, m, a, b = get_data()  # Read input values
result = min_cost(n, m, a, b)  # Calculate minimum cost
print(result)  # Output the result"
416,A,Guess a number!,PROGRAMMING,"['greedy', 'implementation', 'two pointers']","A TV show called ""Guess a number!"" is gathering popularity. The whole Berland, the old and the young, are watching the show.

The rules are simple. The host thinks of an integer *y* and the participants guess it by asking questions to the host. There are four types of acceptable questions:
 -  Is it true that *y* is strictly larger than number *x*? -  Is it true that *y* is strictly smaller than number *x*? -  Is it true that *y* is larger than or equal to number *x*? -  Is it true that *y* is smaller than or equal to number *x*? 
On each question the host answers truthfully, ""yes"" or ""no"".

Given the sequence of questions and answers, find any integer value of *y* that meets the criteria of all answers. If there isn't such value, print ""Impossible"".","The first line of the input contains a single integer *n* (1<=≤<=*n*<=≤<=10000) — the number of questions (and answers). Next *n* lines each contain one question and one answer to it. The format of each line is like that: ""sign x answer"", where the sign is:
 -  ""&gt;"" (for the first type queries), -  ""&lt;"" (for the second type queries), -  ""&gt;="" (for the third type queries), -  ""&lt;="" (for the fourth type queries). 
All values of *x* are integer and meet the inequation <=-<=109<=≤<=*x*<=≤<=109. The answer is an English letter ""Y"" (for ""yes"") or ""N"" (for ""no"").

Consequtive elements in lines are separated by a single space.","Print any of such integers *y*, that the answers to all the queries are correct. The printed number *y* must meet the inequation <=-<=2·109<=≤<=*y*<=≤<=2·109. If there are many answers, print any of them. If such value doesn't exist, print word ""Impossible"" (without the quotes).","['4\n&gt;= 1 Y\n&lt; 3 N\n&lt;= -3 N\n&gt; 55 N\n', '2\n&gt; 100 Y\n&lt; -100 Y\n']","['17\n', 'Impossible\n']",none,WRONG_ANSWER,"import random

n = input()

lowerbound = -9999999
upperbound = 9999999

rule = []

for i in range(int(n)):
    rule = [str(x) for x in input().split()]

    if rule[0] == '>=':
        if rule[2] == 'Y':
            if lowerbound < int(rule[1]):
                lowerbound = int(rule[1])
        else:
            if upperbound > int(rule[1]):
                upperbound = int(rule[1])
    elif rule[0] == '>':
        if rule[2] == 'Y':
            if lowerbound < int(rule[1]):
                lowerbound = int(rule[1]) - 1
        else:
            if upperbound > int(rule[1]):
                upperbound = int(rule[1]) + 1
    elif rule[0] == '<=':
        if rule[2] == 'Y':
            if upperbound < int(rule[1]):
                upperbound = int(rule[1])
        else:
            if lowerbound > int(rule[1]):
                lowerbound = int(rule[1])
    elif rule[0] == '<':
        if upperbound < int(rule[1]):
            upperbound = int(rule[1]) + 1
        else:
            if lowerbound > int(rule[1]):
                lowerbound = int(rule[1]) - 1

if lowerbound == upperbound:
    print(lowerbound)
elif lowerbound > upperbound:
    print(random.randint(int(lowerbound), int(upperbound)))
else:
    print('Impossible')



","def mySort(e):
    return e[1]

n, v = map(int, input().split())

complect1 = []  # Kayaks list
complect2 = []  # Catamarans list

# Read vehicles data
for i in range(n):
    ti, pi = map(int, input().split())
    if ti == 1:
        complect1.append((i + 1, pi))  # Store index and capacity for kayaks
    else:
        complect2.append((i + 1, pi))  # Store index and capacity for catamarans

# Sort both lists by carrying capacity in descending order
complect1.sort(key=mySort, reverse=True)
complect2.sort(key=mySort, reverse=True)

max_capacity = 0  # Variable to track maximum capacity
best_combination = []  # To track the best combination of vehicles

# Try all possible counts of catamarans
for count_cats in range(min(len(complect2), v // 2) + 1):
    current_capacity = sum(complect2[i][1] for i in range(count_cats))
    current_combination = [complect2[i][0] for i in range(count_cats)]
    remaining_volume = v - 2 * count_cats  # Remaining volume for kayaks

    # Add as many kayaks as possible within the remaining volume
    count_kayaks = min(len(complect1), remaining_volume)
    current_capacity += sum(complect1[i][1] for i in range(count_kayaks))
    current_combination += [complect1[i][0] for i in range(count_kayaks)]

    # Update maximum capacity and best combination if needed
    if current_capacity > max_capacity:
        max_capacity = current_capacity
        best_combination = current_combination

# Output the result
print(max_capacity)
print(' '.join(map(str, best_combination)))"
0,none,none,none,['none'],"You have *n* devices that you want to use simultaneously.

The *i*-th device uses *a**i* units of power per second. This usage is continuous. That is, in λ seconds, the device will use λ·*a**i* units of power. The *i*-th device currently has *b**i* units of power stored. All devices can store an arbitrary amount of power.

You have a single charger that can plug to any single device. The charger will add *p* units of power per second to a device. This charging is continuous. That is, if you plug in a device for λ seconds, it will gain λ·*p* units of power. You can switch which device is charging at any arbitrary unit of time (including real numbers), and the time it takes to switch is negligible.

You are wondering, what is the maximum amount of time you can use the devices until one of them hits 0 units of power.

If you can use the devices indefinitely, print -1. Otherwise, print the maximum amount of time before any one device hits 0 power.","The first line contains two integers, *n* and *p* (1<=≤<=*n*<=≤<=100<=000, 1<=≤<=*p*<=≤<=109) — the number of devices and the power of the charger.

This is followed by *n* lines which contain two integers each. Line *i* contains the integers *a**i* and *b**i* (1<=≤<=*a**i*,<=*b**i*<=≤<=100<=000) — the power of the device and the amount of power stored in the device in the beginning.","If you can use the devices indefinitely, print -1. Otherwise, print the maximum amount of time before any one device hits 0 power.

Your answer will be considered correct if its absolute or relative error does not exceed 10<=-<=4.

Namely, let's assume that your answer is *a* and the answer of the jury is *b*. The checker program will consider your answer correct if .","['2 1\n2 2\n2 1000\n', '1 100\n1 1\n', '3 5\n4 3\n5 2\n6 1\n']","['2.0000000000', '-1\n', '0.5000000000']","In sample test 1, you can charge the first device for the entire time until it hits zero power. The second device has enough power to last this time without being charged.

In sample test 2, you can use the device indefinitely.

In sample test 3, we can charge the third device for 2 / 5 of a second, then switch to charge the second device for a 1 / 10 of a second.",WRONG_ANSWER,"n, k = [int(x) for x in input().split()]
list = [int(x) for x in input().split()]
c = 0
x = 0
for i in list:
    if i <= k:
        c += 1
    else:
        x += 1
        break
list.reverse()
if x > 0:
    for i in list:
        if i <= k:
            c += 1
        else:
            break
print(c)","def Drinks(number_of_orange, volume_fraction):
    # Calculate the total percentage of orange juice
    total_percentage = sum(volume_fraction)
    
    # Calculate the average volume fraction of orange juice in the cocktail
    average_percentage = total_percentage / number_of_orange
    
    # Print the final volume fraction of orange juice in the cocktail
    print(average_percentage)"
950,B,Intercepted Message,PROGRAMMING,"['greedy', 'implementation']","Hacker Zhorik wants to decipher two secret messages he intercepted yesterday. Yeah message is a sequence of encrypted blocks, each of them consists of several bytes of information.

Zhorik knows that each of the messages is an archive containing one or more files. Zhorik knows how each of these archives was transferred through the network: if an archive consists of *k* files of sizes *l*1,<=*l*2,<=...,<=*l**k* bytes, then the *i*-th file is split to one or more blocks *b**i*,<=1,<=*b**i*,<=2,<=...,<=*b**i*,<=*m**i* (here the total length of the blocks *b**i*,<=1<=+<=*b**i*,<=2<=+<=...<=+<=*b**i*,<=*m**i* is equal to the length of the file *l**i*), and after that all blocks are transferred through the network, maintaining the order of files in the archive.

Zhorik thinks that the two messages contain the same archive, because their total lengths are equal. However, each file can be split in blocks in different ways in the two messages.

You are given the lengths of blocks in each of the two messages. Help Zhorik to determine what is the maximum number of files could be in the archive, if the Zhorik's assumption is correct.","The first line contains two integers *n*, *m* (1<=≤<=*n*,<=*m*<=≤<=105) — the number of blocks in the first and in the second messages.

The second line contains *n* integers *x*1,<=*x*2,<=...,<=*x**n* (1<=≤<=*x**i*<=≤<=106) — the length of the blocks that form the first message.

The third line contains *m* integers *y*1,<=*y*2,<=...,<=*y**m* (1<=≤<=*y**i*<=≤<=106) — the length of the blocks that form the second message.

It is guaranteed that *x*1<=+<=...<=+<=*x**n*<==<=*y*1<=+<=...<=+<=*y**m*. Also, it is guaranteed that *x*1<=+<=...<=+<=*x**n*<=≤<=106.",Print the maximum number of files the intercepted array could consist of.,"['7 6\n2 5 3 1 11 4 4\n7 8 2 4 1 8\n', '3 3\n1 10 100\n1 100 10\n', '1 4\n4\n1 1 1 1\n']","['3\n', '2\n', '1\n']","In the first example the maximum number of files in the archive is 3. For example, it is possible that in the archive are three files of sizes 2 + 5 = 7, 15 = 3 + 1 + 11 = 8 + 2 + 4 + 1 and 4 + 4 = 8.

In the second example it is possible that the archive contains two files of sizes 1 and 110 = 10 + 100 = 100 + 10. Note that the order of files is kept while transferring archives through the network, so we can't say that there are three files of sizes 1, 10 and 100.

In the third example the only possibility is that the archive contains a single file of size 4.",WRONG_ANSWER,"

k=input()
k=k.split("" "")
counter=0
sumx=0
sumy=0

n=k[0]
m=k[1]
i=1
j=1
greater=0
x=input()
x=x.split("" "")
x=list(map(int,x))
y=input()
y=y.split("" "")
y=list(map(int,y))
sumx = x[0]
sumy = y[0]
n= int (n)
m = int (m)
if int(m)>int(n):

    while i<m and j<=n:
        if sumx==sumy:
            counter+=1
            if j<=n:
                sumx=x[j]
                j+=1
            if i<=m:
                sumy=y[i]
                i+=1

        elif sumx>sumy:
            sumy=sumy +y[i]
            i+=1

        elif sumy>sumx:
            sumx=sumx + x[j]
            j+=1
else:
    while i<n and j<=m:
        if sumx==sumy:
            counter+=1
            if i<=n:
                sumx=x[i]
                i+=1
            if j<=m:
                sumy=y[j]
                j+=1
        elif sumx>sumy:
            sumy = sumy+y[j]
            j+=1

        elif sumy>sumx:
            sumx= sumx+x[i]
            i+=1
            
if sumx==sumy:
 counter= counter +1
print(counter)
","def main():
    # Read the number of lessons
    n = int(input().strip())
    # Read the schedule of lessons (0s and 1s)
    schedule = list(map(int, input().strip().split()))

    # Find the first lesson
    first_lesson = 0
    while first_lesson < n and schedule[first_lesson] == 0:
        first_lesson += 1

    # If there are no lessons
    if first_lesson == n:
        print(0)
        return

    # Alena will stay at university
    stay_count = 0
    home = False

    # Iterate over the schedule from the first lesson
    for i in range(first_lesson, n):
        if schedule[i] == 1:
            stay_count += 1  # Counting the lesson
            home = False  # Alena is at university
        else:
            if i + 1 < n and schedule[i + 1] == 0:
                home = True  # Possible to go home
            else:
                home = False

        # Only go home if there are at least two breaks in a row
        if home and (i + 1 < n and schedule[i + 1] == 0):
            # Check to ensure moving home is valid
            i += 1  # Skip the next break as she goes home

    print(stay_count)

main()"
229,D,Towers,PROGRAMMING,"['dp', 'greedy', 'two pointers']","The city of D consists of *n* towers, built consecutively on a straight line. The height of the tower that goes *i*-th (from left to right) in the sequence equals *h**i*. The city mayor decided to rebuild the city to make it beautiful. In a beautiful city all towers are are arranged in non-descending order of their height from left to right.

The rebuilding consists of performing several (perhaps zero) operations. An operation constitutes using a crane to take any tower and put it altogether on the top of some other neighboring tower. In other words, we can take the tower that stands *i*-th and put it on the top of either the (*i*<=-<=1)-th tower (if it exists), or the (*i*<=+<=1)-th tower (of it exists). The height of the resulting tower equals the sum of heights of the two towers that were put together. After that the two towers can't be split by any means, but more similar operations can be performed on the resulting tower. Note that after each operation the total number of towers on the straight line decreases by 1.

Help the mayor determine the minimum number of operations required to make the city beautiful.",The first line contains a single integer *n* (1<=≤<=*n*<=≤<=5000) — the number of towers in the city. The next line contains *n* space-separated integers: the *i*-th number *h**i* (1<=≤<=*h**i*<=≤<=105) determines the height of the tower that is *i*-th (from left to right) in the initial tower sequence.,Print a single integer — the minimum number of operations needed to make the city beautiful.,"['5\n8 2 7 3 1\n', '3\n5 2 1\n']","['3\n', '2\n']",none,WRONG_ANSWER,"

def solve(arr):
    if len(arr) <= 1:
        return 0

    i, j = 0, 1
    last_val = arr[i]
    ops = 0

    while j < len(arr):
        val =  0
        while j < len(arr) and val < last_val:
            val += arr[j]
            j += 1

        if val >= last_val:
            ops += j - 2 - i
            i = j - 1
            last_val = val
        else:
            ops += j - i - 1

    return ops



n = input()

arr = list(map(int, input().split()))
print(solve(arr))
","from collections import deque

def solve():
    k, n, m = map(int, input().rstrip().split())
    plate = []
    for a in range(k):
        plate.append([])
        for b in range(n):
            line = input().rstrip()
            plate[a].append(list(line))
        input()  # Read the empty line separating layers

    # Last line contains the coordinates of the tap
    x, y = map(int, input().rstrip().split())
    x -= 1  # Convert to zero-based index
    y -= 1  # Convert to zero-based index

    # Directions for 6 possible moves
    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]
    
    # BFS to fill the water
    queue = deque()
    queue.append((0, x, y))  # Starting from the top layer at (0, x, y)
    
    water_filled = 0
    visited = set()
    
    while queue:
        layer, row, col = queue.popleft()
        
        if (layer, row, col) in visited:
            continue
        
        visited.add((layer, row, col))
        water_filled += 1
        
        for dz, dx, dy in directions:
            new_layer = layer + dz
            new_row = row + dx
            new_col = col + dy
            
            if 0 <= new_layer < k and 0 <= new_row < n and 0 <= new_col < m:
                if plate[new_layer][new_row][new_col] == '.':
                    queue.append((new_layer, new_row, new_col))
    
    print(water_filled)"
652,B,z-sort,PROGRAMMING,['sortings'],"A student of *z*-school found a kind of sorting called *z*-sort. The array *a* with *n* elements are *z*-sorted if two conditions hold:
 1.  *a**i*<=≥<=*a**i*<=-<=1 for all even *i*, 1.  *a**i*<=≤<=*a**i*<=-<=1 for all odd *i*<=&gt;<=1. 
For example the arrays [1,2,1,2] and [1,1,1,1] are *z*-sorted while the array [1,2,3,4] isn’t *z*-sorted.

Can you make the array *z*-sorted?","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=1000) — the number of elements in the array *a*.

The second line contains *n* integers *a**i* (1<=≤<=*a**i*<=≤<=109) — the elements of the array *a*.","If it's possible to make the array *a* *z*-sorted print *n* space separated integers *a**i* — the elements after *z*-sort. Otherwise print the only word ""Impossible"".","['4\n1 2 2 1\n', '5\n1 3 2 2 5\n']","['1 2 1 2\n', '1 5 2 3 2\n']",none,OK,"n = int(input())
a = [int(x) for x in input().split()]
a = sorted(a)
saida = []
for i in range(n):
    if i%2 == 0:
        saida.append(a[i//2])
    else:
        saida.append(a[n-1-i//2])
print(*saida)
						   	  						  	 	  	 	 	","import math

def primefact(n):
    arr = []
    if n == 2 or n == 1:
        arr.append(n)
    else:
        for i in range(2, int(math.sqrt(n)) + 1):
            while(n % i == 0):
                arr.append(i)
                n //= i
        if n > 1:  # If n is a prime number greater than sqrt(n)
            arr.append(n)
    return arr

def can_finish(scores):
    a, b = scores
    # Calculate the prime factors of a and b
    fa = primefact(a)
    fb = primefact(b)

    # Count the occurrences of each prime factor
    count_a = {}
    for p in fa:
        if p in count_a:
            count_a[p] += 1
        else:
            count_a[p] = 1

    count_b = {}
    for p in fb:
        if p in count_b:
            count_b[p] += 1
        else:
            count_b[p] = 1

    # Check each prime factor count if it follows the game rule
    for p in count_a:
        if p ** 2 * count_a[p] < count_b.get(p, 0):
            return ""No""
    
    for p in count_b:
        if p ** 2 * count_b[p] < count_a.get(p, 0):
            return ""No""

    return ""Yes""

def main():
    import sys
    input = sys.stdin.read
    data = input().splitlines()
    
    n = int(data[0])  # number of games
    results = []
    
    for i in range(1, n + 1):
        a, b = map(int, data[i].split())
        result = can_finish((a, b))
        results.append(result)
    
    print(""\n"".join(results))

if __name__ == ""__main__"":
    main()"
227,B,Effective Approach,PROGRAMMING,['implementation'],"Once at a team training Vasya, Petya and Sasha got a problem on implementing linear search in an array.

According to the boys, linear search works as follows. The array elements in a pre-selected order are in turn compared with the number that you need to find. Once you find the array element that is equal to the required one, the search ends. The efficiency of the algorithm is the number of performed comparisons. The fewer comparisons the linear search has made, the more effective it is.

Vasya believes that a linear search would work better if it sequentially iterates through the elements, starting with the 1-st one (in this problem we consider the elements of the array indexed from 1 to *n*) and ending with the *n*-th one. And Petya says that Vasya is wrong: the search will need less comparisons if it sequentially iterates the elements starting from the *n*-th and ending with the 1-st one. Sasha argues that the two approaches are equivalent.

To finally begin the task, the teammates decided to settle the debate and compare the two approaches on an example. For this, they took an array that is a permutation of integers from 1 to *n*, and generated *m* queries of the form: find element with value *b**i* in the array. They want to calculate for both approaches how many comparisons in total the linear search will need to respond to all queries. If the first search needs fewer comparisons, then the winner of the dispute is Vasya. If the second one does, then the winner is Petya. If both approaches make the same number of comparisons, then Sasha's got the upper hand.

But the problem is, linear search is too slow. That's why the boys aren't going to find out who is right before the end of the training, unless you come in here. Help them to determine who will win the dispute.","The first line contains integer *n* (1<=≤<=*n*<=≤<=105) — the number of elements in the array. The second line contains *n* distinct space-separated integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=*n*) — the elements of array. 

The third line contains integer *m* (1<=≤<=*m*<=≤<=105) — the number of queries. The last line contains *m* space-separated integers *b*1,<=*b*2,<=...,<=*b**m* (1<=≤<=*b**i*<=≤<=*n*) — the search queries. Note that the queries can repeat.","Print two integers, showing how many comparisons Vasya's approach needs and how many comparisons Petya's approach needs. Separate the numbers by spaces.

Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use cin, cout streams or the %I64d specifier.","['2\n1 2\n1\n1\n', '2\n2 1\n1\n1\n', '3\n3 1 2\n3\n1 2 3\n']","['1 2\n', '2 1\n', '6 6\n']","In the first sample Vasya's approach will make one comparison (it starts with the 1-st element and immediately finds the required number), and Petya's approach makes two comparisons (first he compares with the 2-nd array element, doesn't find the search item and compares with the 1-st element).

In the second sample, on the contrary, Vasya's approach will need two comparisons (first with 1-st element, and then with the 2-nd), and Petya's approach will find the required value in one comparison (the first comparison with the 2-nd element).",TIME_LIMIT_EXCEEDED,"from sys import stdin

def get_data(n,array,m,queries):
    vasya = 0
    petya = 0
    for q in queries:
        pos = array.index(q) + 1
        vasya += pos
        petya += n - pos + 1
    return [vasya,petya]        
            
def main():
    n = int(stdin.readline())
    array = [int(x) for x in stdin.readline().split()]
    m = int(stdin.readline())
    queries = [int(x) for x in stdin.readline().split()]
    results = get_data(n,array,m,queries)
    print(""{} {}"".format(results[0],results[1]))

main()
","# Read input
    n, m = map(int, sys.stdin.readline().split())
    cities = list(map(int, sys.stdin.readline().split()))
    towers = list(map(int, sys.stdin.readline().split()))

    # Function to check if a given radius r can cover all cities
    def can_cover_all_cities(r):
        tower_index = 0
        for city in cities:
            # Move the tower_index to the nearest tower within range of the city
            while tower_index < m and towers[tower_index] < city - r:
                tower_index += 1
            # If we go out of bounds or there's no tower within range
            if tower_index == m or towers[tower_index] > city + r:
                return False
        return True

    # Binary search for the minimum radius r
    left, right = 0, 10**9  # the radius can be up to 10^9
    while left < right:
        mid = (left + right) // 2
        if can_cover_all_cities(mid):
            right = mid
        else:
            left = mid + 1

    # Output the minimum radius
    print(left)

if __name__ == ""__main__"":
    main()"
227,B,Effective Approach,PROGRAMMING,['implementation'],"Once at a team training Vasya, Petya and Sasha got a problem on implementing linear search in an array.

According to the boys, linear search works as follows. The array elements in a pre-selected order are in turn compared with the number that you need to find. Once you find the array element that is equal to the required one, the search ends. The efficiency of the algorithm is the number of performed comparisons. The fewer comparisons the linear search has made, the more effective it is.

Vasya believes that a linear search would work better if it sequentially iterates through the elements, starting with the 1-st one (in this problem we consider the elements of the array indexed from 1 to *n*) and ending with the *n*-th one. And Petya says that Vasya is wrong: the search will need less comparisons if it sequentially iterates the elements starting from the *n*-th and ending with the 1-st one. Sasha argues that the two approaches are equivalent.

To finally begin the task, the teammates decided to settle the debate and compare the two approaches on an example. For this, they took an array that is a permutation of integers from 1 to *n*, and generated *m* queries of the form: find element with value *b**i* in the array. They want to calculate for both approaches how many comparisons in total the linear search will need to respond to all queries. If the first search needs fewer comparisons, then the winner of the dispute is Vasya. If the second one does, then the winner is Petya. If both approaches make the same number of comparisons, then Sasha's got the upper hand.

But the problem is, linear search is too slow. That's why the boys aren't going to find out who is right before the end of the training, unless you come in here. Help them to determine who will win the dispute.","The first line contains integer *n* (1<=≤<=*n*<=≤<=105) — the number of elements in the array. The second line contains *n* distinct space-separated integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=*n*) — the elements of array. 

The third line contains integer *m* (1<=≤<=*m*<=≤<=105) — the number of queries. The last line contains *m* space-separated integers *b*1,<=*b*2,<=...,<=*b**m* (1<=≤<=*b**i*<=≤<=*n*) — the search queries. Note that the queries can repeat.","Print two integers, showing how many comparisons Vasya's approach needs and how many comparisons Petya's approach needs. Separate the numbers by spaces.

Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use cin, cout streams or the %I64d specifier.","['2\n1 2\n1\n1\n', '2\n2 1\n1\n1\n', '3\n3 1 2\n3\n1 2 3\n']","['1 2\n', '2 1\n', '6 6\n']","In the first sample Vasya's approach will make one comparison (it starts with the 1-st element and immediately finds the required number), and Petya's approach makes two comparisons (first he compares with the 2-nd array element, doesn't find the search item and compares with the 1-st element).

In the second sample, on the contrary, Vasya's approach will need two comparisons (first with 1-st element, and then with the 2-nd), and Petya's approach will find the required value in one comparison (the first comparison with the 2-nd element).",TIME_LIMIT_EXCEEDED,"dizi_uzunlugu=int(input())
dizi=[int(x) for x in input().split()]
soru_uzunlugu=int(input())
sorular=[int(x) for x in input().split()]
anlik_uzunluk=0
bastan=0
sondan=0
while(len(sorular)>0):
    bastan+=(sorular.count(sorular[0])*(dizi.index(sorular[0])+1))
    sondan+=(dizi_uzunlugu-dizi.index(sorular[0]))*sorular.count(sorular[0])
    w=sorular[0]
    q=sorular.count(sorular[0])
    for i in range(q):
        sorular.remove(w)
print(bastan,sondan)
","alpha = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ""
s = input()
temp = s
temp = temp.replace(""?"", """")

# If the length of the input string is less than 26, it's impossible to have a nice substring.
if len(s) < 26:
    print(-1)
else:
    # Check all substrings of length 26 in the input string
    for i in range(len(s) - 25):
        substring = s[i:i + 26]
        # Create a set of characters in the substring, ignoring '?'
        present_chars = set(substring) - {'?'}
        
        # If the substring already has 26 unique letters, it's a valid substring
        if len(present_chars) == 26:
            print(-1)
            break
        
        # Character to complete the alphabet
        missing_chars = set(alpha) - present_chars
        if len(missing_chars) + substring.count('?') >= 26:
            # Replace '?' in the substring to create a nice word
            mutable_substring = list(substring)
            missing_iter = iter(missing_chars)

            for j in range(len(mutable_substring)):
                if mutable_substring[j] == '?':
                    mutable_substring[j] = next(missing_iter, 'A')  # Fill '?' with missing characters
            
            # Replace the original segment in the string
            nice_word = s[:i] + ''.join(mutable_substring) + s[i + 26:]
            # Replace remaining '?' with 'A' to complete the string
            nice_word = nice_word.replace('?', 'A')
            print(nice_word)
            break
    else:
        # If no suitable substring found, print -1
        print(-1)"
757,A,Gotta Catch Em' All!,PROGRAMMING,['implementation'],"Bash wants to become a Pokemon master one day. Although he liked a lot of Pokemon, he has always been fascinated by Bulbasaur the most. Soon, things started getting serious and his fascination turned into an obsession. Since he is too young to go out and catch Bulbasaur, he came up with his own way of catching a Bulbasaur.

Each day, he takes the front page of the newspaper. He cuts out the letters one at a time, from anywhere on the front page of the newspaper to form the word ""Bulbasaur"" (without quotes) and sticks it on his wall. Bash is very particular about case — the first letter of ""Bulbasaur"" must be upper case and the rest must be lower case. By doing this he thinks he has caught one Bulbasaur. He then repeats this step on the left over part of the newspaper. He keeps doing this until it is not possible to form the word ""Bulbasaur"" from the newspaper.

Given the text on the front page of the newspaper, can you tell how many Bulbasaurs he will catch today?

Note: uppercase and lowercase letters are considered different.","Input contains a single line containing a string *s* (1<=<=≤<=<=|*s*|<=<=≤<=<=105) — the text on the front page of the newspaper without spaces and punctuation marks. |*s*| is the length of the string *s*.

The string *s* contains lowercase and uppercase English letters, i.e. .","Output a single integer, the answer to the problem.","['Bulbbasaur\n', 'F\n', 'aBddulbasaurrgndgbualdBdsagaurrgndbb\n']","['1\n', '0\n', '2\n']","In the first case, you could pick: Bulbbasaur.

In the second case, there is no way to pick even a single Bulbasaur.

In the third case, you can rearrange the string to BulbasaurBulbasauraddrgndgddgargndbb to get two words ""Bulbasaur"".",OK,"#391_A

st = list(input())

#B = 1, u = 2, l = 1, b = 1, a = 2, s = 1, r = 1

dct = {""B"": 0, ""u"": 0, ""l"": 0, ""b"": 0, ""a"": 0, ""s"": 0, ""r"": 0}

for i in range(0, len(st)):
    if st[i] in dct:
        dct[st[i]] += 1

n = min(dct[""B""], dct[""u""] // 2, dct[""l""], dct[""b""], dct[""a""] // 2, dct[""s""], dct[""r""])
print(n)
","#!/usr/bin/env python
# coding=utf-8
'''
Author: Deean
Date: 2021-11-26 13:53:20
LastEditTime: 2021-11-26 14:07:02
'''

n, A, B = map(int, input().split())
sizes = list(map(int, input().split()))

# Required size of the first hole to achieve B liters
required_size = (B * sum(sizes)) / A

# Sort sizes in descending order, excluding the first hole
sizes.sort(reverse=True)

# Initialize the sum of sizes of non-blocked holes
sum_sizes = sum(sizes) - sizes[0]
holes_blocked = 0

# Block holes while the condition is not satisfied
for size in sizes[1:]:
    if sum_sizes + sizes[0] < required_size:
        break
    sum_sizes -= size
    holes_blocked += 1

print(holes_blocked)"
50,A,Domino piling,PROGRAMMING,"['greedy', 'math']","You are given a rectangular board of *M*<=×<=*N* squares. Also you are given an unlimited number of standard domino pieces of 2<=×<=1 squares. You are allowed to rotate the pieces. You are asked to place as many dominoes as possible on the board so as to meet the following conditions:

1. Each domino completely covers two squares.

2. No two dominoes overlap.

3. Each domino lies entirely inside the board. It is allowed to touch the edges of the board.

Find the maximum number of dominoes, which can be placed under these restrictions.",In a single line you are given two integers *M* and *N* — board sizes in squares (1<=≤<=*M*<=≤<=*N*<=≤<=16).,"Output one number — the maximal number of dominoes, which can be placed.","['2 4\n', '3 3\n']","['4\n', '4\n']",none,WRONG_ANSWER,"m,n=map(int,input().split())
if m%2==0 or n%2==0:
    print(m*n//2)
else:
    print(max(m*(n-1)//2+n//2,n*(m-1)//2+m//2))
","import collections
import heapq
import sys
import math
import itertools
import bisect
from io import BytesIO, IOBase

def expected_maximum(m, n):
    # Calculate expected maximum
    expected_value = 0
    for k in range(1, m + 1):
        probability_k = (k / m) ** n  # Probability that the maximum is at least k
        expected_value += k * (probability_k - (k - 1) / m) ** n
    
    return expected_value

if __name__ == ""__main__"":
    # Read input values
    m, n = map(int, sys.stdin.readline().strip().split())
    
    # Calculate expected maximum
    result = expected_maximum(m, n)
    
    # Print result with precision
    print(f""{result:.10f}"")"
584,B,Kolya and Tanya ,PROGRAMMING,['combinatorics'],"Kolya loves putting gnomes at the circle table and giving them coins, and Tanya loves studying triplets of gnomes, sitting in the vertexes of an equilateral triangle.

More formally, there are 3*n* gnomes sitting in a circle. Each gnome can have from 1 to 3 coins. Let's number the places in the order they occur in the circle by numbers from 0 to 3*n*<=-<=1, let the gnome sitting on the *i*-th place have *a**i* coins. If there is an integer *i* (0<=≤<=*i*<=&lt;<=*n*) such that *a**i*<=+<=*a**i*<=+<=*n*<=+<=*a**i*<=+<=2*n*<=≠<=6, then Tanya is satisfied. 

Count the number of ways to choose *a**i* so that Tanya is satisfied. As there can be many ways of distributing coins, print the remainder of this number modulo 109<=+<=7. Two ways, *a* and *b*, are considered distinct if there is index *i* (0<=≤<=*i*<=&lt;<=3*n*), such that *a**i*<=≠<=*b**i* (that is, some gnome got different number of coins in these two ways).",A single line contains number *n* (1<=≤<=*n*<=≤<=105) — the number of the gnomes divided by three.,Print a single number — the remainder of the number of variants of distributing coins that satisfy Tanya modulo 109<=+<=7.,"['1\n', '2\n']","['20', '680']","20 ways for *n* = 1 (gnome with index 0 sits on the top of the triangle, gnome 1 on the right vertex, gnome 2 on the left vertex): <img class=""tex-graphics"" src=""https://espresso.codeforces.com/64df38b85ccb482cf88d02dc52e348e33313f9da.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>",OK,"n = int(input())
print((3**(3*n)-7**n) % (int(1e9)+7))","def todo_list(end, k, arr):
    count = 0
    start = 0
    result = float('inf')
    best_start = 0

    # Iterate over each possible starting task
    for i in range(k):
        total_power = 0
        j = i
        
        # Sum the powers of the tasks Dima will be told off for
        while j < end:
            total_power += arr[j]
            j += k
        
        # Check if this starting point has a lower total power
        if total_power < result:
            result = total_power
            best_start = i + 1  # Store the best starting task (1-based index)
    
    return best_start

# Read input
n, k = map(int, input().split())
arr = list(map(int, input().split()))

# Call the function and print the result
print(todo_list(n, k, arr))"
424,A,Squats,PROGRAMMING,['implementation'],"Pasha has many hamsters and he makes them work out. Today, *n* hamsters (*n* is even) came to work out. The hamsters lined up and each hamster either sat down or stood up.

For another exercise, Pasha needs exactly  hamsters to stand up and the other hamsters to sit down. In one minute, Pasha can make some hamster ether sit down or stand up. How many minutes will he need to get what he wants if he acts optimally well?","The first line contains integer *n* (2<=≤<=*n*<=≤<=200; *n* is even). The next line contains *n* characters without spaces. These characters describe the hamsters' position: the *i*-th character equals 'X', if the *i*-th hamster in the row is standing, and 'x', if he is sitting.","In the first line, print a single integer — the minimum required number of minutes. In the second line, print a string that describes the hamsters' position after Pasha makes the required changes. If there are multiple optimal positions, print any of them.","['4\nxxXx\n', '2\nXX\n', '6\nxXXxXx\n']","['1\nXxXx\n', '1\nxX\n', '0\nxXXxXx\n']",none,OK,"# -*- coding: utf-8 -*-
""""""
Created on Sun Apr  5 05:45:34 2020

@author: alexi
""""""



#https://codeforces.com/problemset/problem/424/A --- Alexis Galvan


def hamster_squat():
    
    total = int(input())
    
    hamsters = input()
    
    dic = {'x':0,'X':0}
    
    for i in range(len(hamsters)):
        dic[hamsters[i]] += 1
    
    if dic['x'] == dic['X']:
        print(0)
        print(hamsters)
        return
    
    sat = dic['x']
    stood = dic['X']
    
    add_lower = False
    if sat < stood:
        add_lower = True
    
    maximum = max(sat, stood)
    add = maximum - (int((sat+stood)/2))
    print(add)
    if add_lower:
        output = ''
        hamsters = [i for i in hamsters]
        for i in range(len(hamsters)):
            if add > 0:
                if hamsters[i] == 'X':
                    hamsters[i] = 'x'
                    add -= 1
 
            output = output + hamsters[i]

    else:
        output = ''
        hamsters = [i for i in hamsters]
        for i in range(len(hamsters)):
            if add > 0:
                if hamsters[i] == 'x':
                    hamsters[i] = 'X'
                    add -= 1

            output = output + hamsters[i]

    
    print(output)

hamster_squat()
    
    

    
        

    
    ","def gcd(a, b):
    if (a == 0 or b == 0): return 0
    if (a == b): return a
    # Use Euclidean algorithm to find the gcd
    while b:
        a, b = b, a % b
    return a

def make_coprime_array(arr):
    n = len(arr)
    result = []
    count = 0
    result.append(arr[0])  # Add the first element to the result array

    for i in range(1, n):
        # Check if the current and previous are coprime
        if gcd(result[-1], arr[i]) == 1:
            result.append(arr[i])  # Both are coprime, add current element
        else:
            # Not coprime, need to add an element
            count += 1
            # Insert a number that is guaranteed to be coprime (like 1)
            result.append(1)  # Add a coprime number
            result.append(arr[i])  # Add the current element
    
    return count, result

# Read input
n = int(input())
arr = list(map(int, input().split()))

# Get the count of insertions and the new array
k, new_array = make_coprime_array(arr)

# Print results
print(k)
print(' '.join(map(str, new_array)))"
224,A,Parallelepiped,PROGRAMMING,"['brute force', 'geometry', 'math']",You've got a rectangular parallelepiped with integer edge lengths. You know the areas of its three faces that have a common vertex. Your task is to find the sum of lengths of all 12 edges of this parallelepiped.,The first and the single line contains three space-separated integers — the areas of the parallelepiped's faces. The area's values are positive (<=&gt;<=0) and do not exceed 104. It is guaranteed that there exists at least one parallelepiped that satisfies the problem statement.,Print a single number — the sum of all edges of the parallelepiped.,"['1 1 1\n', '4 6 6\n']","['12\n', '28\n']","In the first sample the parallelepiped has sizes 1 × 1 × 1, in the second one — 2 × 2 × 3.",OK,"import math
z = []
z[0:] = map(int, input().split())
z.sort()
lst1 = []
lst2 = []
lst3 = []
lst = [1]

for i in range(1,z[1]):
    if  i not in lst and z[0] % i == 0 and z[2] % i == 0: #and i not in lst:# and z[2] % i == 0:
        lst.append(i)
        #break
    if  i not in lst and z[0] % i == 0 and z[1] % i == 0: #and i not in lst:# and z[2] % i == 0:
        lst.append(i)
        #break
#print(lst)
count = sum(z)
if len(lst1) == 0:
    lst1.append(1)
    lst1.append(z[1] // lst1[0])
    lst1.append(z[2] // lst1[1])
else:
    lst1.append(z[1] // lst1[0])
    lst1.append(z[2] // lst1[1])
for i in range(len(lst)):
    if (lst1[0] * lst1[1] + lst1[0] * lst1[2] + lst1[1] * lst1[2]) != count:
        lst1.clear()
        lst1.append(lst[len(lst1) - 1 -i])
        lst1.append(z[1] // lst1[0])
        lst1.append(z[2] // lst1[1])
    else:
        break


print(sum(lst1) * 4)","import math

# Read input values for n, m, and a
n, m, a = map(int, input().split())

# Calculate the number of flagstones needed for length n
flagstones_length = math.ceil(n / a)

# Calculate the number of flagstones needed for width m
flagstones_width = math.ceil(m / a)

# Calculate total number of flagstones
total_flagstones = flagstones_length * flagstones_width

# Output the result
print(total_flagstones)"
337,B,Routine Problem,PROGRAMMING,"['greedy', 'math', 'number theory']","Manao has a monitor. The screen of the monitor has horizontal to vertical length ratio *a*:*b*. Now he is going to watch a movie. The movie's frame has horizontal to vertical length ratio *c*:*d*. Manao adjusts the view in such a way that the movie preserves the original frame ratio, but also occupies as much space on the screen as possible and fits within it completely. Thus, he may have to zoom the movie in or out, but Manao will always change the frame proportionally in both dimensions.

Calculate the ratio of empty screen (the part of the screen not occupied by the movie) to the total screen size. Print the answer as an irreducible fraction *p*<=/<=*q*.","A single line contains four space-separated integers *a*, *b*, *c*, *d* (1<=≤<=*a*,<=*b*,<=*c*,<=*d*<=≤<=1000).","Print the answer to the problem as ""p/q"", where *p* is a non-negative integer, *q* is a positive integer and numbers *p* and *q* don't have a common divisor larger than 1.","['1 1 3 2\n', '4 3 2 2\n']","['1/3\n', '1/4\n']","Sample 1. Manao's monitor has a square screen. The movie has 3:2 horizontal to vertical length ratio. Obviously, the movie occupies most of the screen if the width of the picture coincides with the width of the screen. In this case, only 2/3 of the monitor will project the movie in the horizontal dimension: <img class=""tex-graphics"" src=""https://espresso.codeforces.com/ce823413ad27813e27496a0d8bd4231e94b47662.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

Sample 2. This time the monitor's width is 4/3 times larger than its height and the movie's frame is square. In this case, the picture must take up the whole monitor in the vertical dimension and only 3/4 in the horizontal dimension: <img class=""tex-graphics"" src=""https://espresso.codeforces.com/c2bcb3b1f64810812eee368ff180e3e148d24c67.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>",WRONG_ANSWER,"# from fractions import Fraction
# from decimal import Decimal
import fractions


a,b,c,d=map(int,input().split())
if(a/b<c/d):
    p=a*d
    q=b*c
    x=(q-p)/q
    # print(x)
    b = fractions.Fraction(q-p,q)
    print(b)
    quit()

if(a/b>c/d):
    p=b*c
    q=a*d
    x=(p/q)
    b = fractions.Fraction(q-p,q)
    print(b)
    quit()
if(a/b==c/d):
    print(0)

    

 ","def check(mid):
    needed = 0
    # Calculate the total amount of ingredients needed to bake 'mid' cookies
    for i in range(len(a)):
        # If the required amount exceeds what is available
        if a[i] * mid > b[i]:
            # Calculate the additional amount needed
            needed += a[i] * mid - b[i]
    # Check if we can fulfill the additional requirements with the magic powder
    return needed <= k

def max_cookies():
    low, high = 0, 10**9  # Set search boundaries for the number of cookies
    while low < high:
        mid = (low + high + 1) // 2  # Check the middle point
        if check(mid):  # If we can make 'mid' cookies
            low = mid  # Try for more cookies
        else:
            high = mid - 1  # Try fewer cookies
    return low  # The maximum number of cookies we can bake

# Input reading
n, k = map(int, input().split())
a = list(map(int, input().split()))
b = list(map(int, input().split()))

# Output the result
print(max_cookies())"
200,B,Drinks,PROGRAMMING,"['implementation', 'math']","Little Vasya loves orange juice very much. That's why any food and drink in his kitchen necessarily contains orange juice. There are *n* drinks in his fridge, the volume fraction of orange juice in the *i*-th drink equals *p**i* percent.

One day Vasya decided to make himself an orange cocktail. He took equal proportions of each of the *n* drinks and mixed them. Then he wondered, how much orange juice the cocktail has.

Find the volume fraction of orange juice in the final drink.","The first input line contains a single integer *n* (1<=≤<=*n*<=≤<=100) — the number of orange-containing drinks in Vasya's fridge. The second line contains *n* integers *p**i* (0<=≤<=*p**i*<=≤<=100) — the volume fraction of orange juice in the *i*-th drink, in percent. The numbers are separated by a space.",Print the volume fraction in percent of orange juice in Vasya's cocktail. The answer will be considered correct if the absolute or relative error does not exceed 10<=<=-<=4.,"['3\n50 50 100\n', '4\n0 25 50 75\n']","['66.666666666667\n', '37.500000000000\n']","Note to the first sample: let's assume that Vasya takes *x* milliliters of each drink from the fridge. Then the volume of pure juice in the cocktail will equal <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/c1fac6e64d3a8ee6a5ac138cbe51e60039b22473.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> milliliters. The total cocktail's volume equals 3·*x* milliliters, so the volume fraction of the juice in the cocktail equals <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/ceb0664e55a1f9f5fa1243ec74680a4665a4d58d.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>, that is, 66.(6) percent.",OK,"n = int(input())
def sum(l,n):
    sum1 = 0
    for i in range(n):
        sum1 += l[i]
    return sum1

l = [int(x) for x in input().split()]
sum(l, n)
print(sum(l,n)/n)","def min_students_on_bench(n, m, enemies):
    from collections import defaultdict, deque

    # Create a graph to represent students and their archenemies
    graph = defaultdict(list)
    for a, b in enemies:
        graph[a].append(b)
        graph[b].append(a)

    # Function to perform BFS and determine the sizes of teams
    def bfs(start):
        queue = deque([start])
        visited.add(start)
        count = [0, 0]  # count[0] for one team, count[1] for the other team
        team = 0
        
        while queue:
            current = queue.popleft()
            count[team] += 1  # Count the number of students in the current team
            
            for neighbor in graph[current]:
                if neighbor not in visited:
                    visited.add(neighbor)
                    queue.append(neighbor)
                elif (current, neighbor) in team_assignment:
                    # Conflict detected with previous assignment
                    if team_assignment[(current, neighbor)] == team:
                        return float('inf'), 0  # impossible to split

            team ^= 1  # switch teams
        
        return count[0], count[1]  # return the sizes of the two teams

    visited = set()
    total_bench = 0

    for student in range(1, n + 1):
        if student not in visited:
            team_size_0, team_size_1 = bfs(student)

            if team_size_0 == float('inf'):
                total_bench += 1  # need to send one to the bench
            else:
                total_size = team_size_0 + team_size_1
                # If total_size is odd, we need to put one on the bench
                if total_size % 2 != 0:
                    total_bench += 1

    return total_bench

# Read input data
n, m = map(int, input().split())
enemies = [tuple(map(int, input().split())) for _ in range(m)]

# Output the result
print(min_students_on_bench(n, m, enemies))"
242,C,King's Path,PROGRAMMING,"['dfs and similar', 'graphs', 'hashing', 'shortest paths']","The black king is standing on a chess field consisting of 109 rows and 109 columns. We will consider the rows of the field numbered with integers from 1 to 109 from top to bottom. The columns are similarly numbered with integers from 1 to 109 from left to right. We will denote a cell of the field that is located in the *i*-th row and *j*-th column as (*i*,<=*j*).

You know that some squares of the given chess field are allowed. All allowed cells of the chess field are given as *n* segments. Each segment is described by three integers *r**i*,<=*a**i*,<=*b**i* (*a**i*<=≤<=*b**i*), denoting that cells in columns from number *a**i* to number *b**i* inclusive in the *r**i*-th row are allowed.

Your task is to find the minimum number of moves the king needs to get from square (*x*0,<=*y*0) to square (*x*1,<=*y*1), provided that he only moves along the allowed cells. In other words, the king can be located only on allowed cells on his way.

Let us remind you that a chess king can move to any of the neighboring cells in one move. Two cells of a chess field are considered neighboring if they share at least one point.","The first line contains four space-separated integers *x*0,<=*y*0,<=*x*1,<=*y*1 (1<=≤<=*x*0,<=*y*0,<=*x*1,<=*y*1<=≤<=109), denoting the initial and the final positions of the king.

The second line contains a single integer *n* (1<=≤<=*n*<=≤<=105), denoting the number of segments of allowed cells. Next *n* lines contain the descriptions of these segments. The *i*-th line contains three space-separated integers *r**i*,<=*a**i*,<=*b**i* (1<=≤<=*r**i*,<=*a**i*,<=*b**i*<=≤<=109,<=*a**i*<=≤<=*b**i*), denoting that cells in columns from number *a**i* to number *b**i* inclusive in the *r**i*-th row are allowed. Note that the segments of the allowed cells can intersect and embed arbitrarily.

It is guaranteed that the king's initial and final position are allowed cells. It is guaranteed that the king's initial and the final positions do not coincide. It is guaranteed that the total length of all given segments doesn't exceed 105.","If there is no path between the initial and final position along allowed cells, print -1.

Otherwise print a single integer — the minimum number of moves the king needs to get from the initial position to the final one.","['5 7 6 11\n3\n5 3 8\n6 7 11\n5 2 5\n', '3 4 3 10\n3\n3 1 4\n4 5 9\n3 10 10\n', '1 1 2 10\n2\n1 1 3\n2 6 10\n']","['4\n', '6\n', '-1\n']",none,OK,"import sys
import math
from sys import stdin, stdout
 
# TAKE INPUT
def get_ints_in_variables():
    return map(int, sys.stdin.readline().strip().split())
def get_int(): return int(input())
def get_ints_in_list(): return list(
    map(int, sys.stdin.readline().strip().split()))
def get_list_of_list(n): return [list(
    map(int, sys.stdin.readline().strip().split())) for _ in range(n)]
def get_string(): return sys.stdin.readline().strip()
 
def main():
    # Write Your Code Here
    x0,y0,x1,y1 = get_ints_in_variables()
    n = int(input())
    g = {}
    for i in range(0, n):
        r,a,b = get_ints_in_variables()
        for i in range(a, b+1):
            g[(r, i)] = -1

    g[(x0, y0)] = 0
    # {[i-1][0], [i-1][j-1], [i-1][j+1], [i][j-1], [i][j+1], [i+1][j], [i+1][j-1],   [i+1][j+1]}
    dx = [-1, -1, -1, 0, 0, 1, 1, 1]
    dy = [0, -1, 1, -1, 1, 0, -1, 1]
    queue = [(x0, y0)]
    while len(queue):
        node = queue.pop(0)
        for j in range(8):
            v = (node[0]+dx[j], node[1]+dy[j])
            # print(v, ""v"")
            if not v in g:
                continue
            if v in g and g[v] != -1:
                continue
            g[v] = g[node]+1
            queue.append(v)
    print(g[(x1, y1)])
#  calling main Function
if __name__ == ""__main__"":
    main()","import sys

def solve():
    n, m = map(int, input().split())
    tab = [list(input()) for x in range(n)]
    
    # Set to hold the characters needed to form the word ""face""
    face_chars = set(""face"")
    face_count = 0
    
    # Loop through each possible top-left corner of a 2x2 square
    for i in range(n - 1):
        for j in range(m - 1):
            # Extract the characters in the current 2x2 square
            square_chars = {tab[i][j], tab[i][j + 1], tab[i + 1][j], tab[i + 1][j + 1]}
            # Check if all characters needed to form ""face"" are present
            if square_chars == face_chars:
                face_count += 1
    
    print(face_count)"
910,B,Door Frames,PROGRAMMING,"['greedy', 'implementation']","Petya has equal wooden bars of length *n*. He wants to make a frame for two equal doors. Each frame has two vertical (left and right) sides of length *a* and one top side of length *b*. A solid (i.e. continuous without breaks) piece of bar is needed for each side.

Determine a minimal number of wooden bars which are needed to make the frames for two doors. Petya can cut the wooden bars into any parts, but each side of each door should be a solid piece of a wooden bar (or a whole wooden bar).","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=1<=000) — the length of each wooden bar.

The second line contains a single integer *a* (1<=≤<=*a*<=≤<=*n*) — the length of the vertical (left and right) sides of a door frame.

The third line contains a single integer *b* (1<=≤<=*b*<=≤<=*n*) — the length of the upper side of a door frame.",Print the minimal number of wooden bars with length *n* which are needed to make the frames for two doors.,"['8\n1\n2\n', '5\n3\n4\n', '6\n4\n2\n', '20\n5\n6\n']","['1\n', '6\n', '4\n', '2\n']","In the first example one wooden bar is enough, since the total length of all six sides of the frames for two doors is 8.

In the second example 6 wooden bars is enough, because for each side of the frames the new wooden bar is needed.",OK,"import math

[n,a,b],r,i,j=[int(input())for x in range(3)],6,4,5

while i>=0:

	l,c,o=[b if x in[i,j]else a for x in range(6)],0,n

	for k in l:

		if o<k:

			o,c=n-k,c+1

		else:o-=k

	r=min(r,c if o==n else c+1)

	j-=1

	if i==j:i,j=i-1,5

print(r)



# Made By Mostafa_Khaled","import heapq

def main():
    Na, Nb = map(int, input().split())
    K, M = map(int, input().split())
    arrA = list(map(int, input().split()))
    arrB = list(map(int, input().split()))
    
    # Check the k-th smallest element in A and the m-th largest element in B
    if arrA[K-1] < arrB[Nb-M]:
        print(""YES"")
    else:
        print(""NO"")

if __name__ == ""__main__"":
    main()"
214,A,System of Equations,PROGRAMMING,['brute force'],"Furik loves math lessons very much, so he doesn't attend them, unlike Rubik. But now Furik wants to get a good mark for math. For that Ms. Ivanova, his math teacher, gave him a new task. Furik solved the task immediately. Can you?

You are given a system of equations: 

You should count, how many there are pairs of integers (*a*,<=*b*) (0<=≤<=*a*,<=*b*) which satisfy the system.","A single line contains two integers *n*,<=*m* (1<=≤<=*n*,<=*m*<=≤<=1000) — the parameters of the system. The numbers on the line are separated by a space.",On a single line print the answer to the problem.,"['9 3\n', '14 28\n', '4 20\n']","['1\n', '1\n', '0\n']","In the first sample the suitable pair is integers (3, 0). In the second sample the suitable pair is integers (3, 5). In the third sample there is no suitable pair.",OK,"n,m=map(int,input().split())
c=0
for a in range(300):
    for b in range(300):
        if a**2+b==n and a+b**2==m:
            c+=1
print(c)
","import sys
input = sys.stdin.buffer.readline

def process(n, m, c):
    A = [None for _ in range(n)]  # Initialize sheets with None
    for i in range(m):
        num = int(input())  # Read the number for the current round
        for j in range(n):
            if A[j] is None or A[j] <= num:  # Look for a place to insert num
                A[j] = num  # Place the number on sheet j
                break  # Move to the next round
        if None not in A and all(A[k] <= A[k + 1] for k in range(n - 1)):  # Check win condition
            print(""Chtholly wins!"")  # Chtholly wins
            return  # Terminate the program after winning

# Reading input values
n, m, c = map(int, input().split())
process(n, m, c)"
58,A,Chat room,PROGRAMMING,"['greedy', 'strings']","Vasya has recently learned to type and log on to the Internet. He immediately entered a chat room and decided to say hello to everybody. Vasya typed the word *s*. It is considered that Vasya managed to say hello if several letters can be deleted from the typed word so that it resulted in the word ""hello"". For example, if Vasya types the word ""ahhellllloou"", it will be considered that he said hello, and if he types ""hlelo"", it will be considered that Vasya got misunderstood and he didn't manage to say hello. Determine whether Vasya managed to say hello by the given word *s*.","The first and only line contains the word *s*, which Vasya typed. This word consisits of small Latin letters, its length is no less that 1 and no more than 100 letters.","If Vasya managed to say hello, print ""YES"", otherwise print ""NO"".","['ahhellllloou\n', 'hlelo\n']","['YES\n', 'NO\n']",none,COMPILATION_ERROR,"# -*- coding: utf-8 -*-
""""""
Created on Sat Sep 30 18:22:42 2023

@author: huozi
""""""

word = input()

target = ""hello""

pointer = 0
count = 0

for char in :
    if char == target[pointer]:
        pointer += 1
        count += 1

    if count == len(target):
        break

if count == len(target):
    print(""YES"")
else:
    print(""NO"")","def f():
    ipt = input().strip().split()
    k = int(ipt[1])
    ns = ipt[0]
    a = [int(i) for i in ns]
    n = len(a)
    flag = 1
    # Count the number of zeros needed
    zeros_needed = k
    zeros_count = 0

    # Count how many digits we have removed
    remove_count = 0

    # Traverse the number to find the necessary zeros
    for i in range(n - 1, -1, -1):
        if a[i] == 0:
            zeros_count += 1
            if zeros_count == k:  # We found enough zeros
                break
        else:
            if zeros_count < k:
                remove_count += 1  # Need to remove non-zero digit if we haven't found enough zeros

    # If we haven't found enough zeros, count how many non-zero digits to remove
    if zeros_count < k:
        remove_count += (k - zeros_count)

    # Now handle the situation based on leading zeros
    # Traverse from the left to avoid leading zeros
    valid_found = False
    leading_zero_found = False

    for i in range(n):
        if a[i] == 0 and not valid_found:
            leading_zero_found = True
            continue
        elif a[i] != 0:
            valid_found = True  # Found a valid starting digit
        if valid_found:
            # If we found a valid number but encounter a zero before k zeros is valid
            if a[i] == 0:
                if zeros_count > 0:
                    zeros_count -= 1
                    remove_count += i - (remove_count + (leading_zero_found and (i - 1 >= 0)) + (leading_zero_found and zeros_needed < k))
                    leading_zero_found = False
                else:
                    remove_count += 1  # Remove this zero if we don't need it anymore

    print(remove_count)

f()"
8,A,Train and Peter,PROGRAMMING,['strings'],"Peter likes to travel by train. He likes it so much that on the train he falls asleep. 

Once in summer Peter was going by train from city A to city B, and as usual, was sleeping. Then he woke up, started to look through the window and noticed that every railway station has a flag of a particular colour.

The boy started to memorize the order of the flags' colours that he had seen. But soon he fell asleep again. Unfortunately, he didn't sleep long, he woke up and went on memorizing the colours. Then he fell asleep again, and that time he slept till the end of the journey.

At the station he told his parents about what he was doing, and wrote two sequences of the colours that he had seen before and after his sleep, respectively.

Peter's parents know that their son likes to fantasize. They give you the list of the flags' colours at the stations that the train passes sequentially on the way from A to B, and ask you to find out if Peter could see those sequences on the way from A to B, or from B to A. Remember, please, that Peter had two periods of wakefulness.

Peter's parents put lowercase Latin letters for colours. The same letter stands for the same colour, different letters — for different colours.","The input data contains three lines. The first line contains a non-empty string, whose length does not exceed 105, the string consists of lowercase Latin letters — the flags' colours at the stations on the way from A to B. On the way from B to A the train passes the same stations, but in reverse order. 

The second line contains the sequence, written by Peter during the first period of wakefulness. The third line contains the sequence, written during the second period of wakefulness. Both sequences are non-empty, consist of lowercase Latin letters, and the length of each does not exceed 100 letters. Each of the sequences is written in chronological order.","Output one of the four words without inverted commas: 
 -  «forward» — if Peter could see such sequences only on the way from A to B; -  «backward» — if Peter could see such sequences on the way from B to A; -  «both» — if Peter could see such sequences both on the way from A to B, and on the way from B to A; -  «fantasy» — if Peter could not see such sequences.","['atob\na\nb\n', 'aaacaaa\naca\naa\n']","['forward\n', 'both\n']","It is assumed that the train moves all the time, so one flag cannot be seen twice. There are no flags at stations A and B.",WRONG_ANSWER,"a=input()
b=input()
c=input()
a=a.split(b,-1)
l=len(a)
f=0
b=0
for i in range(l):
    t=a[i].find(c)
    if t!=-1:
        if i!=0:f=1
        if i!=l-1:b=1
if f:
    if b:print('both')
    else:print('forward')
else:
    if b:print('backward')
    else:print('fantasy')
","def check(a, x, y):
    if a[x-1][y-1]+a[x-1][y]+a[x][y-1] == 3 or a[x+1][y-1]+a[x+1][y]+a[x][y-1] == 3:
        return True
    elif a[x+1][y+1]+a[x+1][y]+a[x][y+1] == 3 or a[x-1][y+1]+a[x-1][y]+a[x][y+1] == 3:
        return True
    return False

def find_losing_move(n, m, k, moves):
    # Initialize the grid to keep track of painted pixels
    grid = [[0] * (m + 2) for _ in range(n + 2)]  # Padding to avoid boundary checks

    for move_number in range(k):
        x, y = moves[move_number]
        grid[x][y] = 1  # Paint the pixel black

        # Check for the formation of a 2x2 black square around the painted pixel
        if check(grid, x, y):
            return move_number + 1  # Return 1-based index of the move

    return 0  # No losing move found

# Example input reading
n, m, k = map(int, input().split())
moves = [tuple(map(int, input().split())) for _ in range(k)]
print(find_losing_move(n, m, k, moves))"
884,B,Japanese Crosswords Strike Back,PROGRAMMING,['implementation'],"A one-dimensional Japanese crossword can be represented as a binary string of length *x*. An encoding of this crossword is an array *a* of size *n*, where *n* is the number of segments formed completely of 1's, and *a**i* is the length of *i*-th segment. No two segments touch or intersect.

For example: 
 -  If *x*<==<=6 and the crossword is 111011, then its encoding is an array {3,<=2}; -  If *x*<==<=8 and the crossword is 01101010, then its encoding is an array {2,<=1,<=1}; -  If *x*<==<=5 and the crossword is 11111, then its encoding is an array {5}; -  If *x*<==<=5 and the crossword is 00000, then its encoding is an empty array. 
Mishka wants to create a new one-dimensional Japanese crossword. He has already picked the length and the encoding for this crossword. And now he needs to check if there is exactly one crossword such that its length and encoding are equal to the length and encoding he picked. Help him to check it!","The first line contains two integer numbers *n* and *x* (1<=≤<=*n*<=≤<=100000, 1<=≤<=*x*<=≤<=109) — the number of elements in the encoding and the length of the crossword Mishka picked.

The second line contains *n* integer numbers *a*1, *a*2, ..., *a**n* (1<=≤<=*a**i*<=≤<=10000) — the encoding.","Print YES if there exists exaclty one crossword with chosen length and encoding. Otherwise, print NO.","['2 4\n1 3\n', '3 10\n3 3 2\n', '2 10\n1 3\n']","['NO\n', 'YES\n', 'NO\n']",none,OK,"n,x=map(int,input().split(' '))
val=[int(i) for i in input().split(' ') ]
s=len(val)-1
for i in val:
    s+=i
if s==x:
    print('YES')
else:
    print('NO')


	  	 			  		  	      			 			","vov = 'aeiou'

def is_defected_block(a, b, c):
    if a == b and b == c:
        return False  # All letters are the same, not a typo
    return True  # There are at least two different letters

def fix_typos(word):
    # Initialize an empty list to store the modified words
    result = []
    current_word = []

    # Loop through each character in the input word
    for i in range(len(word)):
        current_word.append(word[i])  # Add current character to current_word

        # Check for typo condition: Three consonants in a row
        if len(current_word) >= 3:
            if (current_word[-1] not in vov and
                    current_word[-2] not in vov and
                    current_word[-3] not in vov):
                # Check if it is a defected block
                if is_defected_block(current_word[-1], current_word[-2], current_word[-3]):
                    # We found a typo, need to split
                    # Add the current word up to the last valid character
                    result.append(''.join(current_word[:-3]))
                    # Start a new current word with the last two characters
                    current_word = current_word[-2:]

    # Add any remaining characters to result
    if current_word:
        result.append(''.join(current_word))

    return ' '.join(result)  # Join the results with a space

# Read input
input_word = input().strip()

# Output the fixed word if necessary
output_word = fix_typos(input_word)
print(output_word)"
996,A,Hit the Lottery,PROGRAMMING,"['dp', 'greedy']","Allen has a LOT of money. He has $n$ dollars in the bank. For security reasons, he wants to withdraw it in cash (we will not disclose the reasons here). The denominations for dollar bills are $1$, $5$, $10$, $20$, $100$. What is the minimum number of bills Allen could receive after withdrawing his entire balance?",The first and only line of input contains a single integer $n$ ($1 \le n \le 10^9$).,Output the minimum number of bills that Allen could receive.,"['125\n', '43\n', '1000000000\n']","['3\n', '5\n', '10000000\n']","In the first sample case, Allen can withdraw this with a $100$ dollar bill, a $20$ dollar bill, and a $5$ dollar bill. There is no way for Allen to receive $125$ dollars in one or two bills.

In the second sample case, Allen can withdraw two $20$ dollar bills and three $1$ dollar bills.

In the third sample case, Allen can withdraw $100000000$ (ten million!) $100$ dollar bills.",OK,"x = int(input(""""))
bills = 0

bills = bills + x//100
x = x%100

bills = bills + x//20
x = x%20

bills = bills + x//10
x = x%10

bills = bills + x//5
x = x%5

bills = bills + x//1
x = x%1

print(bills)

","import os
import sys
from io import BytesIO, IOBase

# region fastio

class FastIO(IOBase):
    def __init__(self, _stream):
        self._stream = _stream
        self.buffer = BytesIO()
        self.written = 0

    def write(self, b):
        self.buffer.write(b)
        self.written += len(b)

    def flush(self):
        self._stream.write(self.buffer.getvalue())
        self.buffer.truncate(0)
        self.buffer.seek(0)

    def read(self):
        return self._stream.read()

    def readline(self):
        return self._stream.readline()

    def readlines(self):
        return self._stream.readlines()

sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)
input = sys.stdin.readline

# endregion

def construct_roads(n, t, k, a):
    roads = []
    current_id = 2  # Start from city id 2 since id 1 is the capital
    last_level = []

    # Building the roads for each level 
    for distance in range(1, t + 1):
        current_level = []
        
        for _ in range(a[distance - 1]):
            if not last_level:
                return -1  # No previous cities to connect to, invalid configuration

            current_level.append(current_id)
            current_id += 1
        
        # Connect cities at this level to the previous level
        if distance > 1:
            if len(last_level) < a[distance - 1]:
                return -1  # More cities in the current level than can be connected

            for i in range(a[distance - 1]):
                roads.append((last_level[i % len(last_level)], current_level[i]))

        last_level = current_level

    if len([1 for city in last_level if (city not in roads)]) < k:
        return -1  # Not enough dead-end cities

    # Output roads
    return roads

n, t, k = map(int, input().split())
a = list(map(int, input().split()))

roads = construct_roads(n, t, k, a)

if roads == -1:
    print(-1)
else:
    print(n - 1)  # Number of roads is n-1
    for road in roads:
        print(road[0], road[1])"
61,B,Hard Work,PROGRAMMING,['strings'],"After the contest in comparing numbers, Shapur's teacher found out that he is a real genius and that no one could possibly do the calculations faster than him even using a super computer!

Some days before the contest, the teacher took a very simple-looking exam and all his *n* students took part in the exam. The teacher gave them 3 strings and asked them to concatenate them. Concatenating strings means to put them in some arbitrary order one after the other. For example from concatenating Alireza and Amir we can get to AlirezaAmir or AmirAlireza depending on the order of concatenation.

Unfortunately enough, the teacher forgot to ask students to concatenate their strings in a pre-defined order so each student did it the way he/she liked.

Now the teacher knows that Shapur is such a fast-calculating genius boy and asks him to correct the students' papers.

Shapur is not good at doing such a time-taking task. He rather likes to finish up with it as soon as possible and take his time to solve 3-SAT in polynomial time. Moreover, the teacher has given some advice that Shapur has to follow. Here's what the teacher said: 
 -  As I expect you know, the strings I gave to my students (including you) contained only lowercase and uppercase Persian Mikhi-Script letters. These letters are too much like Latin letters, so to make your task much harder I converted all the initial strings and all of the students' answers to Latin. -  As latin alphabet has much less characters than Mikhi-Script, I added three odd-looking characters to the answers, these include ""-"", "";"" and ""_"". These characters are my own invention of course! And I call them Signs. -  The length of all initial strings was less than or equal to 100 and the lengths of my students' answers are less than or equal to 600 -  My son, not all students are genius as you are. It is quite possible that they make minor mistakes changing case of some characters. For example they may write ALiReZaAmIR instead of AlirezaAmir. Don't be picky and ignore these mistakes. -  Those signs which I previously talked to you about are not important. You can ignore them, since many students are in the mood for adding extra signs or forgetting about a sign. So something like Iran;;-- is the same as --;IRAN -  You should indicate for any of my students if his answer was right or wrong. Do this by writing ""WA"" for Wrong answer or ""ACC"" for a correct answer. -  I should remind you that none of the strings (initial strings or answers) are empty. -  Finally, do these as soon as possible. You have less than 2 hours to complete this.","The first three lines contain a string each. These are the initial strings. They consists only of lowercase and uppercase Latin letters and signs (""-"", "";"" and ""_""). All the initial strings have length from 1 to 100, inclusively.

In the fourth line there is a single integer *n* (0<=≤<=*n*<=≤<=1000), the number of students.

Next *n* lines contain a student's answer each. It is guaranteed that the answer meets what the teacher said. Each answer iconsists only of lowercase and uppercase Latin letters and signs (""-"", "";"" and ""_""). Length is from 1 to 600, inclusively.","For each student write in a different line. Print ""WA"" if his answer is wrong or ""ACC"" if his answer is OK.","['Iran_\nPersian;\nW_o;n;d;e;r;f;u;l;\n7\nWonderfulPersianIran\nwonderful_PersIAN_IRAN;;_\nWONDERFUL___IRAN__PERSIAN__;;\nIra__Persiann__Wonderful\nWonder;;fulPersian___;I;r;a;n;\n__________IranPersianWonderful__________\nPersianIran_is_Wonderful\n', 'Shapur;;\nis___\na_genius\n3\nShapur__a_is___geniUs\nis___shapur___a__Genius;\nShapur;;is;;a;;geni;;us;;\n']","['ACC\nACC\nACC\nWA\nACC\nACC\nWA\n', 'WA\nACC\nACC\n']",none,OK,"import math,sys;input=sys.stdin.readline;S=lambda:input().rstrip();I=lambda:int(S());M=lambda:map(int,S().split());L=lambda:list(M());mod1=1000000007;mod2=998244353

strings = []
for i in range(3):
    s = S()
    letter = """"
    for j in range(len(s)):
        if 97<=ord(s[j])<=122:
            letter += chr(ord(s[j])-32)
            
        elif 90<ord(s[j])<97 or ord(s[j])>122 or ord(s[j])<65:
            continue
        else:
            letter+= s[j]

    strings.append(letter)

possible = []
for i in range(3):
    for j in range(3):
        for k in range(3):
            if i!=j and i!=k and j!=k:
                m = strings[i] + strings[j] + strings[k]
                possible.append(m)

# print(strings)
n = I()
for i in range(n):
    t = S()
    given = """"
    for j in range(len(t)):
        if 97<=ord(t[j])<=122:
            given += chr(ord(t[j])-32)
            
        elif 90<ord(t[j])<97 or ord(t[j])>122 or ord(t[j])<65:
            continue
        else:
            given+= t[j]
    
    
    if given in possible:
        print(""ACC"")
    else:
        print(""WA"")","fread = input

def main():
    n, k = map(int, fread().split())  # Read number of prices and decrease value
    prices = list(map(int, fread().split()))  # Read the price list

    min_price = min(prices)  # Find the minimum price
    total_seconds = 0  # Initialize total seconds needed

    for price in prices:
        if (price - min_price) % k != 0:  # Check if the difference is divisible by k
            print(-1)  # If not, print -1 and exit
            return
        total_seconds += (price - min_price) // k  # Calculate total seconds needed

    print(total_seconds)  # Print the total seconds needed

if __name__ == ""__main__"":
    main()"
427,A,Police Recruits,PROGRAMMING,['implementation'],"The police department of your city has just started its journey. Initially, they don’t have any manpower. So, they started hiring new recruits in groups.

Meanwhile, crimes keeps occurring within the city. One member of the police force can investigate only one crime during his/her lifetime.

If there is no police officer free (isn't busy with crime) during the occurrence of a crime, it will go untreated.

Given the chronological order of crime occurrences and recruit hirings, find the number of crimes which will go untreated.","The first line of input will contain an integer *n* (1<=≤<=*n*<=≤<=105), the number of events. The next line will contain *n* space-separated integers.

If the integer is -1 then it means a crime has occurred. Otherwise, the integer will be positive, the number of officers recruited together at that time. No more than 10 officers will be recruited at a time.","Print a single integer, the number of crimes which will go untreated.","['3\n-1 -1 1\n', '8\n1 -1 1 -1 -1 1 1 1\n', '11\n-1 -1 2 -1 -1 -1 -1 -1 -1 -1 -1\n']","['2\n', '1\n', '8\n']","Lets consider the second example:
 1.  Firstly one person is hired. 1.  Then crime appears, the last hired person will investigate this crime. 1.  One more person is hired. 1.  One more crime appears, the last hired person will investigate this crime. 1.  Crime appears. There is no free policeman at the time, so this crime will go untreated. 1.  One more person is hired. 1.  One more person is hired. 1.  One more person is hired. 
The answer is one, as one crime (on step 5) will go untreated.",OK,"_ = input()
events = input().split("" "")
crime_counter = police_counter = 0 
for event in events:
    event = int(event)
    if event > 0 or police_counter > 0:
        police_counter += event
    else:
        crime_counter += 1
print(crime_counter)","def Cards_with_Numbers():
    import sys
    from collections import defaultdict
    
    input = sys.stdin.read
    data = input().split()
    
    n = int(data[0])
    cards = list(map(int, data[1:]))
    
    # Dictionary to store the indices of each number
    indices = defaultdict(list)
    
    # Fill the dictionary with indices
    for index, number in enumerate(cards):
        indices[number].append(index + 1)
    
    # Check if we can form pairs and store the result
    result = []
    for index_list in indices.values():
        if len(index_list) % 2 != 0:
            print(-1)
            return
        # Create pairs from the indices
        for i in range(0, len(index_list), 2):
            result.append((index_list[i], index_list[i + 1]))
    
    # Output the result
    for pair in result:
        print(pair[0], pair[1])"
995,B,Suit and Tie,PROGRAMMING,"['greedy', 'implementation', 'math']","Allen is hosting a formal dinner party. $2n$ people come to the event in $n$ pairs (couples). After a night of fun, Allen wants to line everyone up for a final picture. The $2n$ people line up, but Allen doesn't like the ordering. Allen prefers if each pair occupies adjacent positions in the line, as this makes the picture more aesthetic.

Help Allen find the minimum number of swaps of adjacent positions he must perform to make it so that each couple occupies adjacent positions in the line.","The first line contains a single integer $n$ ($1 \le n \le 100$), the number of pairs of people.

The second line contains $2n$ integers $a_1, a_2, \dots, a_{2n}$. For each $i$ with $1 \le i \le n$, $i$ appears exactly twice. If $a_j = a_k = i$, that means that the $j$-th and $k$-th people in the line form a couple.","Output a single integer, representing the minimum number of adjacent swaps needed to line the people up so that each pair occupies adjacent positions.","['4\n1 1 2 3 3 2 4 4\n', '3\n1 1 2 2 3 3\n', '3\n3 1 2 3 1 2\n']","['2\n', '0\n', '3\n']","In the first sample case, we can transform $1 1 2 3 3 2 4 4 \rightarrow 1 1 2 3 2 3 4 4 \rightarrow 1 1 2 2 3 3 4 4$ in two steps. Note that the sequence $1 1 2 3 3 2 4 4 \rightarrow 1 1 3 2 3 2 4 4 \rightarrow 1 1 3 3 2 2 4 4$ also works in the same number of steps.

The second sample case already satisfies the constraints; therefore we need $0$ swaps.",OK,"n=int(input())
lst = list(map(int, input().strip().split(' ')))
c=0
while(len(lst)!=0):
    p=lst[0]
    del lst[0]
    i=lst.index(p)
    c+=i
    del lst[i]
print(c)
    ","from sys import stdin, stdout

def input():
    return stdin.readline().strip()

def longest_uncommon_subsequence(a, b):
    # If both strings are identical, there is no uncommon subsequence
    if a == b:
        return -1
    # The longest uncommon subsequence would be the longer of the two strings
    return max(len(a), len(b))

# Read input strings a and b
a = input()
b = input()

# Compute the length of the longest uncommon subsequence
result = longest_uncommon_subsequence(a, b)

# Print the result
stdout.write(str(result) + '\n')"
233,A,Perfect Permutation,PROGRAMMING,"['implementation', 'math']","A permutation is a sequence of integers *p*1,<=*p*2,<=...,<=*p**n*, consisting of *n* distinct positive integers, each of them doesn't exceed *n*. Let's denote the *i*-th element of permutation *p* as *p**i*. We'll call number *n* the size of permutation *p*1,<=*p*2,<=...,<=*p**n*.

Nickolas adores permutations. He likes some permutations more than the others. He calls such permutations perfect. A perfect permutation is such permutation *p* that for any *i* (1<=≤<=*i*<=≤<=*n*) (*n* is the permutation size) the following equations hold *p**p**i*<==<=*i* and *p**i*<=≠<=*i*. Nickolas asks you to print any perfect permutation of size *n* for the given *n*.",A single line contains a single integer *n* (1<=≤<=*n*<=≤<=100) — the permutation size.,"If a perfect permutation of size *n* doesn't exist, print a single integer -1. Otherwise print *n* distinct integers from 1 to *n*, *p*1,<=*p*2,<=...,<=*p**n* — permutation *p*, that is perfect. Separate printed numbers by whitespaces.","['1\n', '2\n', '4\n']","['-1\n', '2 1 \n', '2 1 4 3 \n']",none,RUNTIME_ERROR,"import numpy as np
n = int(input())

if n % 2 == 1:
    print(-1) 
else:
    np_arr = np.array(range(1 , n + 1))
    evenFlag = np_arr % 2 == 0 
    np_arr[np_arr % 2 == 1] = np_arr[np_arr % 2 == 1] + 1
    np_arr[evenFlag] = np_arr[evenFlag] - 1
    res = """"
    for ele in np_arr:
        res+=str(ele)+"" ""
    print(res)","n, m = list(map(int, input().split()))
good_cells = []
for i in range(n):
    row = list(map(int, input().split()))
    for j, element in enumerate(row):
        if element == 1:
            good_cells.append((i + 1, j + 1))  # store the good cell as (row, column)

# Set of corners
corners = [(1, 1), (1, m), (n, 1), (n, m)]

# Initialize the number of operations needed to color the table
operations = 0

# Use the good cells to cover all corners
for corner in corners:
    min_operations = float('inf')
    # Check the minimum number of operations for each corner
    for good_cell in good_cells:
        # Each good cell can choose the current corner
        # Update the minimum operations needed
        min_operations = min(min_operations, 1)
    operations += min_operations

print(operations)"
712,B,Memory and Trident,PROGRAMMING,"['implementation', 'strings']","Memory is performing a walk on the two-dimensional plane, starting at the origin. He is given a string *s* with his directions for motion:
-  An 'L' indicates he should move one unit left. -  An 'R' indicates he should move one unit right. -  A 'U' indicates he should move one unit up. -  A 'D' indicates he should move one unit down.
But now Memory wants to end at the origin. To do this, he has a special trident. This trident can replace any character in *s* with any of 'L', 'R', 'U', or 'D'. However, because he doesn't want to wear out the trident, he wants to make the minimum number of edits possible. Please tell Memory what is the minimum number of changes he needs to make to produce a string that, when walked, will end at the origin, or if there is no such string.",The first and only line contains the string *s* (1<=≤<=|*s*|<=≤<=100<=000) — the instructions Memory is given.,"If there is a string satisfying the conditions, output a single integer — the minimum number of edits required. In case it's not possible to change the sequence in such a way that it will bring Memory to to the origin, output -1.","['RRU\n', 'UDUR\n', 'RUUR\n']","['-1\n', '1\n', '2\n']","In the first sample test, Memory is told to walk right, then right, then up. It is easy to see that it is impossible to edit these instructions to form a valid walk.

In the second sample test, Memory is told to walk up, then down, then up, then right. One possible solution is to change *s* to ""LDUR"". This string uses 1 edit, which is the minimum possible. It also ends at the origin.",OK,"def main():
    s = input()
    if len(s) % 2 == 1:
        print('-1')
        return

    cnt = {'L':0,'R':0,'U':0,'D':0}
    for c in s:
        cnt[c] += 1
    
    reduce1 = abs(cnt['L'] - cnt['R'])
    reduce2 = abs(cnt['U'] - cnt['D'])
    print((reduce1 + reduce2) // 2)

if __name__ == '__main__':
    main()","from math import sqrt

def bs(x, a):
    l = 0
    r = len(a)
    while r - l > 1:
        m = (l + r) // 2
        if a[m] <= x:
            l = m
        else:
            r = m
    return l

def min_bridge(n, m, a, b, y, y_prime, l):
    min_distance = float('inf')
    best_pair = (-1, -1)

    for i in range(n):
        A_distance = sqrt(a**2 + y[i]**2)  # Distance from O to A_i
        for j in range(m):
            B_distance = l[j]  # Distance from B_j to the east village
            bridge_length = sqrt((b - a)**2 + (y_prime[j] - y[i])**2)  # Distance A_i to B_j
            
            total_distance = A_distance + bridge_length + B_distance
            
            if total_distance < min_distance:
                min_distance = total_distance
                best_pair = (i + 1, j + 1)  # Store 1-based indices

    return best_pair

# Read input values
n, m, a, b = map(int, input().split())
y = list(map(int, input().split()))
y_prime = list(map(int, input().split()))
l = list(map(int, input().split()))

# Find and print the best pair
result = min_bridge(n, m, a, b, y, y_prime, l)
print(result[0], result[1])"
673,A,Bear and Game,PROGRAMMING,['implementation'],"Bear Limak likes watching sports on TV. He is going to watch a game today. The game lasts 90 minutes and there are no breaks.

Each minute can be either interesting or boring. If 15 consecutive minutes are boring then Limak immediately turns TV off.

You know that there will be *n* interesting minutes *t*1,<=*t*2,<=...,<=*t**n*. Your task is to calculate for how many minutes Limak will watch the game.","The first line of the input contains one integer *n* (1<=≤<=*n*<=≤<=90) — the number of interesting minutes.

The second line contains *n* integers *t*1,<=*t*2,<=...,<=*t**n* (1<=≤<=*t*1<=&lt;<=*t*2<=&lt;<=... *t**n*<=≤<=90), given in the increasing order.",Print the number of minutes Limak will watch the game.,"['3\n7 20 88\n', '9\n16 20 30 40 50 60 70 80 90\n', '9\n15 20 30 40 50 60 70 80 90\n']","['35\n', '15\n', '90\n']","In the first sample, minutes 21, 22, ..., 35 are all boring and thus Limak will turn TV off immediately after the 35-th minute. So, he would watch the game for 35 minutes.

In the second sample, the first 15 minutes are boring.

In the third sample, there are no consecutive 15 boring minutes. So, Limak will watch the whole game.",WRONG_ANSWER,"
n = int(input())

b= list(map(int, input().split()))
a = [0]
status = True
a.extend(b)
for i in range(len(a)-1):
    if a[i+1]-a[i] >15:
        print(a[i]+15)
        status = False
        break

if status == True:
    print(90)
","m = set()
p = 1
m.add(p)

# Store all powers of 2 up to 10^9 in a set
for q in range(33):
    p = p * 2
    if p < 1000000000:
        m.add(p)

# Read the number of test cases
t = int(input())

# Process each test case
for _ in range(t):
    n = int(input())
    total_sum = 0

    # Calculate the sum from 1 to n
    for i in range(1, n + 1):
        if i in m:
            total_sum -= i  # Subtract if the number is a power of 2
        else:
            total_sum += i  # Add otherwise

    # Print the result for the current test case
    print(total_sum)"
43,A,Football,PROGRAMMING,['strings'],"One day Vasya decided to have a look at the results of Berland 1910 Football Championship’s finals. Unfortunately he didn't find the overall score of the match; however, he got hold of a profound description of the match's process. On the whole there are *n* lines in that description each of which described one goal. Every goal was marked with the name of the team that had scored it. Help Vasya, learn the name of the team that won the finals. It is guaranteed that the match did not end in a tie.",The first line contains an integer *n* (1<=≤<=*n*<=≤<=100) — the number of lines in the description. Then follow *n* lines — for each goal the names of the teams that scored it. The names are non-empty lines consisting of uppercase Latin letters whose lengths do not exceed 10 symbols. It is guaranteed that the match did not end in a tie and the description contains no more than two different teams.,Print the name of the winning team. We remind you that in football the team that scores more goals is considered the winner.,"['1\nABC\n', '5\nA\nABA\nABA\nA\nA\n']","['ABC\n', 'A\n']",none,WRONG_ANSWER,"n = int(input())
ctr = 0 
s = '' 
mx = 0 
while n!=0:
    n-=1 
    k = input()
    x = k 
    if x in k:
        ctr += 1
        if ctr > mx:
            mx = ctr 
            s = x 
    else:
        ctr = 0 
        
print(s)","def DZY_loves_strings():
    s = input()  # Input the string s
    k = int(input())  # Input the number of letters to insert
    w = list(map(int, input().split()))  # Input the weights for each letter a-z
    total_value = 0  # Initialize total value of the current string

    # Calculate the value of the existing string
    for idx, char in enumerate(s):  # Iterate through each character in the string
        total_value += w[ord(char) - ord('a')] * (idx + 1)  # Update total with weight and position value

    # Find weight of the highest valued letter
    max_weight = max(w)  # Determine the maximum weight from the weights list

    # Calculate the value that can be added by inserting k letters
    for i in range(len(s) + 1, len(s) + k + 1):  # For positions after the current string length
        total_value += max_weight * i  # Add the value of the inserted letters

    print(total_value)  # Output the total maximum value"
0,none,none,none,['none'],"Leha decided to move to a quiet town Vičkopolis, because he was tired by living in Bankopolis. Upon arrival he immediately began to expand his network of hacked computers. During the week Leha managed to get access to *n* computers throughout the town. Incidentally all the computers, which were hacked by Leha, lie on the same straight line, due to the reason that there is the only one straight street in Vičkopolis.

Let's denote the coordinate system on this street. Besides let's number all the hacked computers with integers from 1 to *n*. So the *i*-th hacked computer is located at the point *x**i*. Moreover the coordinates of all computers are distinct. 

Leha is determined to have a little rest after a hard week. Therefore he is going to invite his friend Noora to a restaurant. However the girl agrees to go on a date with the only one condition: Leha have to solve a simple task.

Leha should calculate a sum of *F*(*a*) for all *a*, where *a* is a non-empty subset of the set, that consists of all hacked computers. Formally, let's denote *A* the set of all integers from 1 to *n*. Noora asks the hacker to find value of the expression . Here *F*(*a*) is calculated as the maximum among the distances between all pairs of computers from the set *a*. Formally, . Since the required sum can be quite large Noora asks to find it modulo 109<=+<=7.

Though, Leha is too tired. Consequently he is not able to solve this task. Help the hacker to attend a date.","The first line contains one integer *n* (1<=≤<=*n*<=≤<=3·105) denoting the number of hacked computers.

The second line contains *n* integers *x*1,<=*x*2,<=...,<=*x**n* (1<=≤<=*x**i*<=≤<=109) denoting the coordinates of hacked computers. It is guaranteed that all *x**i* are distinct.",Print a single integer — the required sum modulo 109<=+<=7.,"['2\n4 7\n', '3\n4 3 1\n']","['3\n', '9\n']","There are three non-empty subsets in the first sample test:<img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/02b2d12556dad85f1c6c6912786eb87d4be2ea17.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>, <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/22f6a537962c86b3e28ddb8aaca28a7cdd219a8c.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> and <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/7d0f73b3e94e13cb797f39e93d9da74835c5a02d.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>. The first and the second subset increase the sum by 0 and the third subset increases the sum by 7 - 4 = 3. In total the answer is 0 + 0 + 3 = 3.

There are seven non-empty subsets in the second sample test. Among them only the following subsets increase the answer: <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/f368c407c8e85e2b5fedfffaff39d471d765f026.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>, <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/bb8f2118a3ac352db393b1f067b28e398ce7f816.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>, <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/049032074c04b16bc0cc153f95471c40b222072b.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>, <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/dc93c7f5b3d122314c9c5a707fae556a8f72a574.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>. In total the sum is (4 - 3) + (4 - 1) + (3 - 1) + (4 - 1) = 9.",RUNTIME_ERROR,"from sys import stdin, stdout

n = int(stdin.readline())
values = sorted(list(map(int, stdin.readline().split())))
MOD = 10 ** 9 + 7

dp = [0, values[1] - values[0]]
cnt = [values[0], values[0] * 2 + values[1]]
pw = [1]

for i in range(n):
    pw.append((pw[-1] * 2) % MOD)

for i in range(2, n):
    dp.append((dp[-1] + values[i] * (pw[i] - 1) - cnt[-1]) % MOD)
    cnt.append(cnt[-1] * 2 + values[i])
    cnt[-1] %= MOD
    
stdout.write(str(dp[-1] % MOD))
","# -*- coding: utf-8 -*-
""""""contest

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vkqd1IDYYeIi4VIH6yqQEhbS4qcGMzLO
""""""

from collections import Counter

def can_form_palindrome(s):
    # Count the frequency of each character in the string
    freq = Counter(s)
    # Count how many characters have an odd frequency
    odd_count = sum(1 for count in freq.values() if count % 2 != 0)
    # A string can be rearranged to form a palindrome if at most one character has an odd frequency
    return odd_count <= 1

def game_result(s):
    # Check if the first player can immediately win
    if can_form_palindrome(s):
        return ""First""
    else:
        # Since both players play optimally, check the length of the string
        # If the length is even, player two can always mirror player one's moves 
        return ""Second"" if len(s) % 2 == 0 else ""First""

# Input string
s = input().strip()
# Get the result of the game
result = game_result(s)
# Print the result
print(result)"
814,A,An abandoned sentiment from past,PROGRAMMING,"['constructive algorithms', 'greedy', 'implementation', 'sortings']","A few years ago, Hitagi encountered a giant crab, who stole the whole of her body weight. Ever since, she tried to avoid contact with others, for fear that this secret might be noticed.

To get rid of the oddity and recover her weight, a special integer sequence is needed. Hitagi's sequence has been broken for a long time, but now Kaiki provides an opportunity.

Hitagi's sequence *a* has a length of *n*. Lost elements in it are denoted by zeros. Kaiki provides another sequence *b*, whose length *k* equals the number of lost elements in *a* (i.e. the number of zeros). Hitagi is to replace each zero in *a* with an element from *b* so that each element in *b* should be used exactly once. Hitagi knows, however, that, apart from 0, no integer occurs in *a* and *b* more than once in total.

If the resulting sequence is not an increasing sequence, then it has the power to recover Hitagi from the oddity. You are to determine whether this is possible, or Kaiki's sequence is just another fake. In other words, you should detect whether it is possible to replace each zero in *a* with an integer from *b* so that each integer from *b* is used exactly once, and the resulting sequence is not increasing.","The first line of input contains two space-separated positive integers *n* (2<=≤<=*n*<=≤<=100) and *k* (1<=≤<=*k*<=≤<=*n*) — the lengths of sequence *a* and *b* respectively.

The second line contains *n* space-separated integers *a*1,<=*a*2,<=...,<=*a**n* (0<=≤<=*a**i*<=≤<=200) — Hitagi's broken sequence with exactly *k* zero elements.

The third line contains *k* space-separated integers *b*1,<=*b*2,<=...,<=*b**k* (1<=≤<=*b**i*<=≤<=200) — the elements to fill into Hitagi's sequence.

Input guarantees that apart from 0, no integer occurs in *a* and *b* more than once in total.","Output ""Yes"" if it's possible to replace zeros in *a* with elements in *b* and make the resulting sequence not increasing, and ""No"" otherwise.","['4 2\n11 0 0 14\n5 4\n', '6 1\n2 3 0 8 9 10\n5\n', '4 1\n8 94 0 4\n89\n', '7 7\n0 0 0 0 0 0 0\n1 2 3 4 5 6 7\n']","['Yes\n', 'No\n', 'Yes\n', 'Yes\n']","In the first sample: 
 -  Sequence *a* is 11, 0, 0, 14. -  Two of the elements are lost, and the candidates in *b* are 5 and 4. -  There are two possible resulting sequences: 11, 5, 4, 14 and 11, 4, 5, 14, both of which fulfill the requirements. Thus the answer is ""Yes"". 
In the second sample, the only possible resulting sequence is 2, 3, 5, 8, 9, 10, which is an increasing sequence and therefore invalid.",WRONG_ANSWER,"# import sys
# sys.stdin=open('input.txt', 'r')
# sys.stdout=open('output.txt', 'w')

a, b = [int(k) for k in input().split()]
c=[int(k) for k in input().split()]
d=[int(k) for k in input().split()]
if b>1:
    print('Yes')
elif b==1:
    index=c.index(0)
    if index==0:
        if d[0]>c[1]:
            print('Yes')
        else: print('No')
    elif index==len(c)-1:
        if d[0]<c[-1]:
            print('Yes')
        else:
            print('No')
    else:
        if c[index-1]>d[0]>c[index+1]:
            print('Yes')
        else: print('No')
","k, n = map(int, input().split())
m = list(map(int, input().split()))
m.sort()
m.reverse()

# Count the frequency of each food type
from collections import Counter
food_count = Counter(m)

# Calculate the maximum number of days the expedition can last
days = 0
while True:
    # Try to allocate food for each participant
    total_food_needed = 0
    
    # Calculate the total food needed for the current day
    for food_type, count in food_count.items():
        total_food_needed += min(count, days + 1)  # Each participant can eat one package of the same type
        
    # Check if we can satisfy all participants
    if total_food_needed < n:
        break  # Not enough food for all participants for the current number of days
    
    days += 1  # We can extend the expedition for another day

print(days)  # Output the maximum possible number of days"
116,A,Tram,PROGRAMMING,['implementation'],"Linear Kingdom has exactly one tram line. It has *n* stops, numbered from 1 to *n* in the order of tram's movement. At the *i*-th stop *a**i* passengers exit the tram, while *b**i* passengers enter it. The tram is empty before it arrives at the first stop. Also, when the tram arrives at the last stop, all passengers exit so that it becomes empty.

Your task is to calculate the tram's minimum capacity such that the number of people inside the tram at any time never exceeds this capacity. Note that at each stop all exiting passengers exit before any entering passenger enters the tram.","The first line contains a single number *n* (2<=≤<=*n*<=≤<=1000) — the number of the tram's stops. 

Then *n* lines follow, each contains two integers *a**i* and *b**i* (0<=≤<=*a**i*,<=*b**i*<=≤<=1000) — the number of passengers that exits the tram at the *i*-th stop, and the number of passengers that enter the tram at the *i*-th stop. The stops are given from the first to the last stop in the order of tram's movement.
 -  The number of people who exit at a given stop does not exceed the total number of people in the tram immediately before it arrives at the stop. More formally, . This particularly means that *a*1<==<=0. -  At the last stop, all the passengers exit the tram and it becomes empty. More formally, . -  No passenger will enter the train at the last stop. That is, *b**n*<==<=0.",Print a single integer denoting the minimum possible capacity of the tram (0 is allowed).,['4\n0 3\n2 5\n4 2\n4 0\n'],['6\n'],"For the first example, a capacity of 6 is sufficient: 
 -  At the first stop, the number of passengers inside the tram before arriving is 0. Then, 3 passengers enter the tram, and the number of passengers inside the tram becomes 3. -  At the second stop, 2 passengers exit the tram (1 passenger remains inside). Then, 5 passengers enter the tram. There are 6 passengers inside the tram now. -  At the third stop, 4 passengers exit the tram (2 passengers remain inside). Then, 2 passengers enter the tram. There are 4 passengers inside the tram now. -  Finally, all the remaining passengers inside the tram exit the tram at the last stop. There are no passenger inside the tram now, which is in line with the constraints. 
Since the number of passengers inside the tram never exceeds 6, a capacity of 6 is sufficient. Furthermore it is not possible for the tram to have a capacity less than 6. Hence, 6 is the correct answer.",OK,"total_stop = int(input())
max = 0
current = 0
for i in range(total_stop):
    a,b = map(int,input().split())
    if i == 0:
        max = b
        current = b
    else:
        current = (current - a) + b
        if current > max:
            max = current
print(max)
","def mcd(a, b):
    if b == 0:
        return a
    return mcd(b, a % b)

def gcd_range(a, b):
    # Convert strings to integers as a and b can be very large
    a = int(a)
    b = int(b)
    
    # The GCD of all numbers from a to b is equal to the GCD of a and b
    return mcd(a, b)

# Read input
a, b = input().split()
# Output the result
print(gcd_range(a, b))"
559,B,Equivalent Strings,PROGRAMMING,"['divide and conquer', 'hashing', 'sortings', 'strings']","Today on a lecture about strings Gerald learned a new definition of string equivalency. Two strings *a* and *b* of equal length are called equivalent in one of the two cases: 
 1.  They are equal. 1.  If we split string *a* into two halves of the same size *a*1 and *a*2, and string *b* into two halves of the same size *b*1 and *b*2, then one of the following is correct:   *a*1 is equivalent to *b*1, and *a*2 is equivalent to *b*2 1.  *a*1 is equivalent to *b*2, and *a*2 is equivalent to *b*1 
As a home task, the teacher gave two strings to his students and asked to determine if they are equivalent.

Gerald has already completed this home task. Now it's your turn!",The first two lines of the input contain two strings given by the teacher. Each of them has the length from 1 to 200<=000 and consists of lowercase English letters. The strings have the same length.,"Print ""YES"" (without the quotes), if these two strings are equivalent, and ""NO"" (without the quotes) otherwise.","['aaba\nabaa\n', 'aabb\nabab\n']","['YES\n', 'NO\n']","In the first sample you should split the first string into strings ""aa"" and ""ba"", the second one — into strings ""ab"" and ""aa"". ""aa"" is equivalent to ""aa""; ""ab"" is equivalent to ""ba"" as ""ab"" = ""a"" + ""b"", ""ba"" = ""b"" + ""a"".

In the second sample the first string can be splitted into strings ""aa"" and ""bb"", that are equivalent only to themselves. That's why string ""aabb"" is equivalent only to itself and to string ""bbaa"".",OK,"memo = {}
def solve(a, b):
    if (a,b) in memo:
        return memo[a,b]
    if len(a)%2 == 1:
        return a == b
    
    half = len(a)//2
    a1, a2 = a[:half], a[half:]
    b1, b2 = b[:half], b[half:]

    memo[a,b] = (solve(a1, b1) and solve(a2, b2)) or  (solve(a1, b2) and solve(a2, b1))
    return memo[a,b]

s1 = input()
s2 = input()    
ans = solve(s1, s2)
print(""YES"" if ans else ""NO"")","n = int(input())
words = [input().strip() for _ in range(n)]  # Read n words

def abbreviate(word):
    if len(word) > 10:
        return f""{word[0]}{len(word) - 2}{word[-1]}""
    return word

# Replace each word with its abbreviation if it's too long
for word in words:
    print(abbreviate(word))"
552,B,Vanya and Books,PROGRAMMING,"['implementation', 'math']","Vanya got an important task — he should enumerate books in the library and label each book with its number. Each of the *n* books should be assigned with a number from 1 to *n*. Naturally, distinct books should be assigned distinct numbers.

Vanya wants to know how many digits he will have to write down as he labels the books.",The first line contains integer *n* (1<=≤<=*n*<=≤<=109) — the number of books in the library.,Print the number of digits needed to number all the books.,"['13\n', '4\n']","['17\n', '4\n']","Note to the first test. The books get numbers 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, which totals to 17 digits.

Note to the second sample. The books get numbers 1, 2, 3, 4, which totals to 4 digits.",WRONG_ANSWER,"# coding=utf-8
x=input()
for i in x:
    if ord(i)%2==0:
        print(0,end='')
    else:
        print(1,end='')
  	  		  	  	 	 	  	  		 		  	","from collections import defaultdict
import sys
sys.setrecursionlimit(10**5)

n = int(input())
g = defaultdict(lambda : set())

# Read edges and populate the graph
for _ in range(n - 1):
    u, v = map(int, input().split())
    g[u].add(v)
    g[v].add(u)

# To store the sizes of the two sets in the bipartition
size = [0, 0]
color = [-1] * (n + 1)  # To store colors of the nodes

def dfs(node, col):
    # Color the current node
    color[node] = col
    size[col] += 1
    
    # Visit all neighbors
    for neighbor in g[node]:
        if color[neighbor] == -1:  # If not visited
            dfs(neighbor, 1 - col)  # Alternate color
        # No need to check here since it's a tree and already connected

# Start DFS from node 1 with color 0
dfs(1, 0)

# The maximum edges that can be added
max_edges = size[0] * size[1] - (n - 1)

print(max_edges)"
828,A,Restaurant Tables,PROGRAMMING,['implementation'],"In a small restaurant there are *a* tables for one person and *b* tables for two persons. 

It it known that *n* groups of people come today, each consisting of one or two people. 

If a group consist of one person, it is seated at a vacant one-seater table. If there are none of them, it is seated at a vacant two-seater table. If there are none of them, it is seated at a two-seater table occupied by single person. If there are still none of them, the restaurant denies service to this group.

If a group consist of two people, it is seated at a vacant two-seater table. If there are none of them, the restaurant denies service to this group.

You are given a chronological order of groups coming. You are to determine the total number of people the restaurant denies service to.","The first line contains three integers *n*, *a* and *b* (1<=≤<=*n*<=≤<=2·105, 1<=≤<=*a*,<=*b*<=≤<=2·105) — the number of groups coming to the restaurant, the number of one-seater and the number of two-seater tables.

The second line contains a sequence of integers *t*1,<=*t*2,<=...,<=*t**n* (1<=≤<=*t**i*<=≤<=2) — the description of clients in chronological order. If *t**i* is equal to one, then the *i*-th group consists of one person, otherwise the *i*-th group consists of two people.",Print the total number of people the restaurant denies service to.,"['4 1 2\n1 2 1 1\n', '4 1 1\n1 1 2 1\n']","['0\n', '2\n']","In the first example the first group consists of one person, it is seated at a vacant one-seater table. The next group occupies a whole two-seater table. The third group consists of one person, it occupies one place at the remaining two-seater table. The fourth group consists of one person, he is seated at the remaining seat at the two-seater table. Thus, all clients are served.

In the second example the first group consists of one person, it is seated at the vacant one-seater table. The next group consists of one person, it occupies one place at the two-seater table. It's impossible to seat the next group of two people, so the restaurant denies service to them. The fourth group consists of one person, he is seated at the remaining seat at the two-seater table. Thus, the restaurant denies service to 2 clients.",WRONG_ANSWER,"n, a, b=map(int,input().split())
l=list(map(int,input().split()))
x=l.count(2)
z=l.count(1)
y=b-x
count=0
if y<=0:
    count+=abs(2*y)
else:
    a+=(2*y)

m=a-z
if m<=0:
   count+=abs(2*m)
   print(count) 
else:
   print(0) 
         

        ","def main():
    n, m, a = [int(x) for x in input().split()]
    
    # Calculate the number of flagstones needed along the length (n)
    # We use ceiling division to ensure we cover the entire length
    num_flagstones_length = (n + a - 1) // a
    
    # Calculate the number of flagstones needed along the width (m)
    # We use ceiling division to ensure we cover the entire width
    num_flagstones_width = (m + a - 1) // a
    
    # Total number of flagstones is the product of the two counts
    total_flagstones = num_flagstones_length * num_flagstones_width
    
    # Output the total number of flagstones needed
    print(total_flagstones)

if __name__ == ""__main__"":
    main()"
50,A,Domino piling,PROGRAMMING,"['greedy', 'math']","You are given a rectangular board of *M*<=×<=*N* squares. Also you are given an unlimited number of standard domino pieces of 2<=×<=1 squares. You are allowed to rotate the pieces. You are asked to place as many dominoes as possible on the board so as to meet the following conditions:

1. Each domino completely covers two squares.

2. No two dominoes overlap.

3. Each domino lies entirely inside the board. It is allowed to touch the edges of the board.

Find the maximum number of dominoes, which can be placed under these restrictions.",In a single line you are given two integers *M* and *N* — board sizes in squares (1<=≤<=*M*<=≤<=*N*<=≤<=16).,"Output one number — the maximal number of dominoes, which can be placed.","['2 4\n', '3 3\n']","['4\n', '4\n']",none,OK,"if __name__ == '__main__':
    s = input()
    l = list(map(int, s.split()))
    print(l[0] * l[1] // 2)
","# Link: https://codeforces.com/contest/127/problem/A

import math

coordinates = []

# Read input values for n and k
n, k = map(int, input().split())

# Read the coordinates of the points
for _ in range(n):
    x, y = map(int, input().split())
    coordinates.append((x, y))

total_distance = 0.0

# Calculate the total length of the polyline
for i in range(1, n):
    x1, y1 = coordinates[i - 1]
    x2, y2 = coordinates[i]
    distance = math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)
    total_distance += distance

# Scrooge's writing speed in mm/s
writing_speed = 50.0

# Total time spent signing all papers
total_time = (total_distance * k) / writing_speed

# Print the total time in seconds with required precision
print(f""{total_time:.9f}"")"
698,A,Vacations,PROGRAMMING,['dp'],"Vasya has *n* days of vacations! So he decided to improve his IT skills and do sport. Vasya knows the following information about each of this *n* days: whether that gym opened and whether a contest was carried out in the Internet on that day. For the *i*-th day there are four options:
 1.  on this day the gym is closed and the contest is not carried out; 1.  on this day the gym is closed and the contest is carried out; 1.  on this day the gym is open and the contest is not carried out; 1.  on this day the gym is open and the contest is carried out. 
On each of days Vasya can either have a rest or write the contest (if it is carried out on this day), or do sport (if the gym is open on this day).

Find the minimum number of days on which Vasya will have a rest (it means, he will not do sport and write the contest at the same time). The only limitation that Vasya has — he does not want to do the same activity on two consecutive days: it means, he will not do sport on two consecutive days, and write the contest on two consecutive days.","The first line contains a positive integer *n* (1<=≤<=*n*<=≤<=100) — the number of days of Vasya's vacations.

The second line contains the sequence of integers *a*1,<=*a*2,<=...,<=*a**n* (0<=≤<=*a**i*<=≤<=3) separated by space, where: 
 -  *a**i* equals 0, if on the *i*-th day of vacations the gym is closed and the contest is not carried out; -  *a**i* equals 1, if on the *i*-th day of vacations the gym is closed, but the contest is carried out; -  *a**i* equals 2, if on the *i*-th day of vacations the gym is open and the contest is not carried out; -  *a**i* equals 3, if on the *i*-th day of vacations the gym is open and the contest is carried out.","Print the minimum possible number of days on which Vasya will have a rest. Remember that Vasya refuses:
 -  to do sport on any two consecutive days, -  to write the contest on any two consecutive days.","['4\n1 3 2 0\n', '7\n1 3 3 2 1 2 3\n', '2\n2 2\n']","['2\n', '0\n', '1\n']","In the first test Vasya can write the contest on the day number 1 and do sport on the day number 3. Thus, he will have a rest for only 2 days.

In the second test Vasya should write contests on days number 1, 3, 5 and 7, in other days do sport. Thus, he will not have a rest for a single day.

In the third test Vasya can do sport either on a day number 1 or number 2. He can not do sport in two days, because it will be contrary to the his limitation. Thus, he will have a rest for only one day.",WRONG_ANSWER,"def find_ans(arr,char_arr,ind):
    count_of_R = 0
    while ind<len(arr):
        if arr[ind]==0:
            char_arr[ind] = 'R'
            count_of_R+=1
        elif arr[ind]==2:
            if char_arr[ind-1]!='G':
                char_arr[ind] = 'G'
            else:
                char_arr[ind] = 'R'
                count_of_R+=1
        elif arr[ind]==1:
            if char_arr[ind-1]!='C':
                char_arr[ind] = 'C'
            else:
                char_arr[ind] = 'R'
                count_of_R+=1
        else:
            if char_arr[ind-1]=='R':
                char_arr[ind] = 'G'
                val1 = find_ans(arr,char_arr,ind+1)
                char_arr[ind] = 'C'
                val2 = find_ans(arr,char_arr,ind+1)
                if val1<=val2:
                    return count_of_R + val1
                else:
                    return count_of_R + val2
            else:
                if char_arr[ind-1]=='G':
                    char_arr[ind] = 'C'
                else:
                    char_arr[ind] = 'G'
        ind+=1
    return count_of_R


n = int(input())
l1 = [int(x) for x in input().split()]
l2 = [0]
for i in l1:
    l2.append(i)
# 0 -> 0 0
# 1 -> 0 1
# 2 -> 1 0
# 3 -> 1 1
out = ['' for i in range(0,n+1)]
ans = find_ans(l2,out,1)
print(ans)","MOD = 10**9 + 9

# Read inputs
n, a, b, k = map(int, input().split())
sequence = input().strip()

# Convert sequence characters to integers
s = [1 if c == '+' else -1 for c in sequence]

# Calculate the full sum in a periodic manner
full_sum = 0

# Calculate powers of a and b needed for terms
a_pow = pow(a, n, MOD)
b_pow = 1  # b^0 initially

# Iterate over the range needed
for i in range(n + 1):
    index = i % k  # Get the correct index in the periodic sequence
    term = s[index] * a_pow * b_pow
    full_sum = (full_sum + term) % MOD
    
    # Update powers of a and b
    a_pow = (a_pow * pow(a, MOD-2, MOD)) % MOD  # a^(n-i-1) = a^(n-i) * a^(-1)
    b_pow = (b_pow * b) % MOD  # b^i = b^(i-1) * b

# Normalize to be non-negative
if full_sum < 0:
    full_sum += MOD

# Print result
print(full_sum)"
895,B,XK Segments,PROGRAMMING,"['binary search', 'math', 'sortings', 'two pointers']","While Vasya finished eating his piece of pizza, the lesson has already started. For being late for the lesson, the teacher suggested Vasya to solve one interesting problem. Vasya has an array *a* and integer *x*. He should find the number of different ordered pairs of indexes (*i*,<=*j*) such that *a**i*<=≤<=*a**j* and there are exactly *k* integers *y* such that *a**i*<=≤<=*y*<=≤<=*a**j* and *y* is divisible by *x*.

In this problem it is meant that pair (*i*,<=*j*) is equal to (*j*,<=*i*) only if *i* is equal to *j*. For example pair (1,<=2) is not the same as (2,<=1).","The first line contains 3 integers *n*,<=*x*,<=*k* (1<=≤<=*n*<=≤<=105,<=1<=≤<=*x*<=≤<=109,<=0<=≤<=*k*<=≤<=109), where *n* is the size of the array *a* and *x* and *k* are numbers from the statement.

The second line contains *n* integers *a**i* (1<=≤<=*a**i*<=≤<=109) — the elements of the array *a*.",Print one integer — the answer to the problem.,"['4 2 1\n1 3 5 7\n', '4 2 0\n5 3 1 7\n', '5 3 1\n3 3 3 3 3\n']","['3\n', '4\n', '25\n']","In first sample there are only three suitable pairs of indexes — (1, 2), (2, 3), (3, 4).

In second sample there are four suitable pairs of indexes(1, 1), (2, 2), (3, 3), (4, 4).

In third sample every pair (*i*, *j*) is suitable, so the answer is 5 * 5 = 25.",OK,"from bisect import bisect_left as b
f = lambda: map(int, input().split())
n, x, k = f()
s, t = 0, sorted(f())
p = [(q, ((q - 1) // x + k) * x) for q in t]
for q, d in p: s += b(t, d + x) - b(t, max(q, d))
print(s)","def photo_type(n, m, matrix):
    # Define the set of colored pixels
    colored_pixels = {'C', 'M', 'Y'}
    
    # Check each pixel in the matrix
    for row in matrix:
        for pixel in row.split():
            # If a colored pixel is found, return ""#Color""
            if pixel in colored_pixels:
                return ""#Color""
    # If no colored pixel is found, return ""#Black&White""
    return ""#Black&White""

# Read input
n, m = map(int, input().split())
matrix = [input() for _ in range(n)]

# Determine the type of the photo
result = photo_type(n, m, matrix)

# Print the result
print(result)"
579,A,Raising Bacteria,PROGRAMMING,['bitmasks'],"You are a lover of bacteria. You want to raise some bacteria in a box. 

Initially, the box is empty. Each morning, you can put any number of bacteria into the box. And each night, every bacterium in the box will split into two bacteria. You hope to see exactly *x* bacteria in the box at some moment. 

What is the minimum number of bacteria you need to put into the box across those days?",The only line containing one integer *x* (1<=≤<=*x*<=≤<=109).,The only line containing one integer: the answer.,"['5\n', '8\n']","['2\n', '1\n']","For the first sample, we can add one bacterium in the box in the first day morning and at the third morning there will be 4 bacteria in the box. Now we put one more resulting 5 in the box. We added 2 bacteria in the process so the answer is 2.

For the second sample, we can put one in the first morning and in the 4-th morning there will be 8 in the box. So the answer is 1.",OK,"w2=int(input())
w=bin(w2)
w1=w[2:]
c=0
for i in w1:
    if int(i)%2!=0:
        c+=1
print(c)        ","d+=li[0]
        return fun(li[1:], s, d, count + 1)
    else:
        if count%2==0:
            s+=li[-1]
        else:
            d+=li[-1]
        return fun(li[:-1], s, d, count + 1)

n = int(input())  # Read number of cards
li = list(map(int, input().split()))  # Read card values
result = fun(li, 0, 0, 0)  # Initial scores for Sereja and Dima
print(result[0], result[1])  # Print final scores"
260,A,Adding Digits,PROGRAMMING,"['implementation', 'math']","Vasya has got two number: *a* and *b*. However, Vasya finds number *a* too short. So he decided to repeat the operation of lengthening number *a* *n* times.

One operation of lengthening a number means adding exactly one digit to the number (in the decimal notation) to the right provided that the resulting number is divisible by Vasya's number *b*. If it is impossible to obtain the number which is divisible by *b*, then the lengthening operation cannot be performed.

Your task is to help Vasya and print the number he can get after applying the lengthening operation to number *a* *n* times.","The first line contains three integers: *a*,<=*b*,<=*n* (1<=≤<=*a*,<=*b*,<=*n*<=≤<=105).","In a single line print the integer without leading zeros, which Vasya can get when he applies the lengthening operations to number *a* *n* times. If no such number exists, then print number -1. If there are multiple possible answers, print any of them.","['5 4 5\n', '12 11 1\n', '260 150 10\n']","['524848\n', '121\n', '-1\n']",none,OK,"a,b,n=map(int,input().split())
N=n
c=0
if(a%b==0):
    print(int(str(a)+'0'*n))
else:
    for i in range(n):
        for j in range(0, 10):
            s = str(a) + str(j)
            num = int(s)
            if (num % b == 0):
                ans = num
                break
            else:
                c += 1
    if (c == n * 10):
        print(-1)
    else:
        if(len(str(num))==N+len(str(a))):
            print(num)
        else:
            l=len(str(a))+n-len(str(num))
            number=int(str(num)+'0'*l)
            print(number)
","from math import floor, sqrt
import bisect

def rwh_primes2(n):
    # Sieve of Eratosthenes to find all primes up to n
    is_prime = [True] * (n + 1)
    p = 2
    while (p * p <= n):
        if (is_prime[p]):
            for i in range(p * p, n + 1, p):
                is_prime[i] = False
        p += 1
    return [p for p in range(2, n + 1) if is_prime[p]]

def smallest_starting_number(X2):
    # Generate prime numbers up to X2
    primes = rwh_primes2(X2)
    min_X0 = float('inf')

    # Iterate through primes to find the possible X1 values
    for prime in primes:
        # Calculate the smallest multiple of prime >= X2
        if X2 % prime == 0:
            X1 = X2 # X2 already divisible by prime
        else:
            X1 = (X2 // prime + 1) * prime

        # Now find possible X0 values from X1
        for prime2 in primes:
            if X1 % prime2 == 0:
                X0 = X1 # X1 already divisible by prime2
            else:
                X0 = (X1 // prime2 + 1) * prime2

            min_X0 = min(min_X0, X0)

    return min_X0

# Example usage:
X2 = int(input())
print(smallest_starting_number(X2))"
600,E,Lomsat gelral,PROGRAMMING,"['data structures', 'dfs and similar', 'dsu', 'trees']","You are given a rooted tree with root in vertex 1. Each vertex is coloured in some colour.

Let's call colour *c* dominating in the subtree of vertex *v* if there are no other colours that appear in the subtree of vertex *v* more times than colour *c*. So it's possible that two or more colours will be dominating in the subtree of some vertex.

The subtree of vertex *v* is the vertex *v* and all other vertices that contains vertex *v* in each path to the root.

For each vertex *v* find the sum of all dominating colours in the subtree of vertex *v*.","The first line contains integer *n* (1<=≤<=*n*<=≤<=105) — the number of vertices in the tree.

The second line contains *n* integers *c**i* (1<=≤<=*c**i*<=≤<=*n*), *c**i* — the colour of the *i*-th vertex.

Each of the next *n*<=-<=1 lines contains two integers *x**j*,<=*y**j* (1<=≤<=*x**j*,<=*y**j*<=≤<=*n*) — the edge of the tree. The first vertex is the root of the tree.",Print *n* integers — the sums of dominating colours for each vertex.,"['4\n1 2 3 4\n1 2\n2 3\n2 4\n', '15\n1 2 3 1 2 3 3 1 1 3 2 2 1 2 3\n1 2\n1 3\n1 4\n1 14\n1 15\n2 5\n2 6\n2 7\n3 8\n3 9\n3 10\n4 11\n4 12\n4 13\n']","['10 9 3 4\n', '6 5 4 3 2 3 3 1 1 3 2 2 1 2 3\n']",none,WRONG_ANSWER,"from collections import defaultdict
vertex_num=int(input())
colors=list(map(int,input().split()))
treeMap=defaultdict(list)
def dfs(node,colorCount:dict):
    colorCount[colors[node-1]]=colorCount.get(colors[node-1],0)+1
    sum=0
    maxColor=0
    for child in treeMap[node]:
        dfs(child,colorCount)
    for color in colorCount:
        if colorCount[color]>colorCount.get(maxColor,0):
            sum=color
            maxColor=color
        elif colorCount[color]==colorCount.get(maxColor,0):
            sum+=color
    return sum
for x in range(vertex_num-1):
    node,child=list(map(int,input().split()))
    treeMap[node].append(child)
res=[]
for i in range(vertex_num):
    c={}
    res.append(dfs(i+1,c))
print("" "".join(list(map(str,res))))
		  	 	   			 	  	 	 	   	 			","import io, os 

def largeValue(currency):
    value = int(currency)
    maximum = -1  # Initialize maximum with -1 to indicate no valid swap found
    lengthofcurrency = len(currency)
    
    # Iterate over all pairs of distinct indices
    for i in range(lengthofcurrency):
        for j in range(i + 1, lengthofcurrency):
            # Swap the digits at index i and j
            currency_list = list(currency)
            currency_list[i], currency_list[j] = currency_list[j], currency_list[i]
            
            # Create the new number after swap
            new_currency = ''.join(currency_list)
            
            # Check if it's even and greater than the current maximum
            if new_currency[-1] in '02468' and new_currency[0] != '0':
                maximum = max(maximum, int(new_currency))
    
    return maximum if maximum != -1 else -1  # Return max found or -1 if none

# Read input and call the function
n = input().strip()
result = largeValue(n)
print(result)"
0,none,none,none,['none'],"In the spirit of the holidays, Saitama has given Genos two grid paths of length *n* (a weird gift even by Saitama's standards). A grid path is an ordered sequence of neighbouring squares in an infinite grid. Two squares are neighbouring if they share a side.

One example of a grid path is (0,<=0)<=→<=(0,<=1)<=→<=(0,<=2)<=→<=(1,<=2)<=→<=(1,<=1)<=→<=(0,<=1)<=→<=(<=-<=1,<=1). Note that squares in this sequence might be repeated, i.e. path has self intersections.

Movement within a grid path is restricted to adjacent squares within the sequence. That is, from the *i*-th square, one can only move to the (*i*<=-<=1)-th or (*i*<=+<=1)-th squares of this path. Note that there is only a single valid move from the first and last squares of a grid path. Also note, that even if there is some *j*-th square of the path that coincides with the *i*-th square, only moves to (*i*<=-<=1)-th and (*i*<=+<=1)-th squares are available. For example, from the second square in the above sequence, one can only move to either the first or third squares.

To ensure that movement is not ambiguous, the two grid paths will not have an alternating sequence of three squares. For example, a contiguous subsequence (0,<=0)<=→<=(0,<=1)<=→<=(0,<=0) cannot occur in a valid grid path.

One marble is placed on the first square of each grid path. Genos wants to get both marbles to the last square of each grid path. However, there is a catch. Whenever he moves one marble, the other marble will copy its movement if possible. For instance, if one marble moves east, then the other marble will try and move east as well. By try, we mean if moving east is a valid move, then the marble will move east.

Moving north increases the second coordinate by 1, while moving south decreases it by 1. Similarly, moving east increases first coordinate by 1, while moving west decreases it.

Given these two valid grid paths, Genos wants to know if it is possible to move both marbles to the ends of their respective paths. That is, if it is possible to move the marbles such that both marbles rest on the last square of their respective paths.","The first line of the input contains a single integer *n* (2<=≤<=*n*<=≤<=1<=000<=000) — the length of the paths.

The second line of the input contains a string consisting of *n*<=-<=1 characters (each of which is either 'N', 'E', 'S', or 'W') — the first grid path. The characters can be thought of as the sequence of moves needed to traverse the grid path. For example, the example path in the problem statement can be expressed by the string ""NNESWW"".

The third line of the input contains a string of *n*<=-<=1 characters (each of which is either 'N', 'E', 'S', or 'W') — the second grid path.","Print ""YES"" (without quotes) if it is possible for both marbles to be at the end position at the same time. Print ""NO"" (without quotes) otherwise. In both cases, the answer is case-insensitive.","['7\nNNESWW\nSWSWSW\n', '3\nNN\nSS\n']","['YES\n', 'NO\n']","In the first sample, the first grid path is the one described in the statement. Moreover, the following sequence of moves will get both marbles to the end: NNESWWSWSW.

In the second sample, no sequence of moves can get both marbles to the end.",RUNTIME_ERROR,"
import math
for i in range(int(input())):
    n,k = map(int,input().split())
    print(math.comb(n-1,k-1))

 	 	  		 			     		 		 			    	","def main():
    l1, s1, r1, p1 = map(int, input().split())
    l2, s2, r2, p2 = map(int, input().split())
    l3, s3, r3, p3 = map(int, input().split())
    l4, s4, r4, p4 = map(int, input().split())

    # Check for possible accidents
    accident_possible = (
        (p1 and (l1 or s1 or r2)) or  # Part 1 pedestrian and cars from part 1 or 2
        (p2 and (l2 or s2 or r3)) or  # Part 2 pedestrian and cars from part 2 or 3
        (p3 and (l3 or s3 or r4)) or  # Part 3 pedestrian and cars from part 3 or 4
        (p4 and (l4 or s4 or r1))     # Part 4 pedestrian and cars from part 4 or 1
    )
    
    # Output the result
    if accident_possible:
        print(""YES"")
    else:
        print(""NO"")

main()"
544,A,Set of Strings,PROGRAMMING,"['implementation', 'strings']","You are given a string *q*. A sequence of *k* strings *s*1,<=*s*2,<=...,<=*s**k* is called beautiful, if the concatenation of these strings is string *q* (formally, *s*1<=+<=*s*2<=+<=...<=+<=*s**k*<==<=*q*) and the first characters of these strings are distinct.

Find any beautiful sequence of strings or determine that the beautiful sequence doesn't exist.","The first line contains a positive integer *k* (1<=≤<=*k*<=≤<=26) — the number of strings that should be in a beautiful sequence. 

The second line contains string *q*, consisting of lowercase Latin letters. The length of the string is within range from 1 to 100, inclusive.","If such sequence doesn't exist, then print in a single line ""NO"" (without the quotes). Otherwise, print in the first line ""YES"" (without the quotes) and in the next *k* lines print the beautiful sequence of strings *s*1,<=*s*2,<=...,<=*s**k*.

If there are multiple possible answers, print any of them.","['1\nabca\n', '2\naaacas\n', '4\nabc\n']","['YES\nabca\n', 'YES\naaa\ncas\n', 'NO\n']","In the second sample there are two possible answers: {""*aaaca*"", ""*s*""} and {""*aaa*"", ""*cas*""}.",OK,"k = int(input())
s = input()
used = [False for _ in range(26)]
starts = []
for i, c in enumerate(s):
    x = ord(c) - ord('a')
    if not used[x]:
        used[x] = True
        starts.append(i)

if len(starts) < k:
    print('NO')
else:
    print('YES')
    while len(starts) > k:
        starts.pop()
    for i in range(k - 1):
        print(s[starts[i]:starts[i + 1]])
    print(s[starts[-1]:])

","#
# Author: eloyhz
# Date: Sep/09/2020
#

def form_teams(g, colors, c, s):
    # Assign color to the current student
    colors[s] = c
    # Visit all neighbors (archenemies)
    for neighbor in g[s]:
        # If the neighbor is not colored, color it with the opposite color
        if colors[neighbor] == -1:
            form_teams(g, colors, 1 - c, neighbor)
        # If the neighbor has the same color, it's not possible to split
        elif colors[neighbor] == c:
            return False
    return True

def minimum_bench_students(n, m, enemies):
    # Create a graph as an adjacency list
    g = [[] for _ in range(n + 1)]
    for a, b in enemies:
        g[a].append(b)
        g[b].append(a)

    colors = [-1] * (n + 1)  # -1 means uncolored
    team_sizes = [0, 0]  # Team sizes for color 0 and 1
    benches_needed = 0

    for student in range(1, n + 1):
        if colors[student] == -1:  # Student not yet colored
            # Try to color the connected component starting with color 0
            if not form_teams(g, colors, 0, student):
                # If coloring fails, we will have to choose the larger team to bench
                benches_needed += 1
                continue
            
            # Count team sizes based on coloring
            count = [0, 0]
            for i in range(1, n + 1):
                if colors[i] != -1:
                    count[colors[i]] += 1
            
            # Add the minimum bench requirement for the current component to benches_needed
            benches_needed += min(count)
    
    return benches_needed

# Example usage (to be replaced with input parsing according to the problem's specification)
n = 4
m = 3
enemies = [(1, 2), (2, 3), (3, 4)]
print(minimum_bench_students(n, m, enemies))"
496,B,Secret Combination,PROGRAMMING,"['brute force', 'constructive algorithms', 'implementation']","You got a box with a combination lock. The lock has a display showing *n* digits. There are two buttons on the box, each button changes digits on the display. You have quickly discovered that the first button adds 1 to all the digits (all digits 9 become digits 0), and the second button shifts all the digits on the display one position to the right (the last digit becomes the first one). For example, if the display is currently showing number 579, then if we push the first button, the display will show 680, and if after that we push the second button, the display will show 068.

You know that the lock will open if the display is showing the smallest possible number that can be obtained by pushing the buttons in some order. The leading zeros are ignored while comparing numbers. Now your task is to find the desired number.","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=1000) — the number of digits on the display.

The second line contains *n* digits — the initial state of the display.",Print a single line containing *n* digits — the desired state of the display containing the smallest possible number.,"['3\n579\n', '4\n2014\n']","['024\n', '0142\n']",none,TIME_LIMIT_EXCEEDED,"import time
n=int(input())
ch=input()
code = []
max_code = -1
for i in range(n):
    x = int(ch[i])
    if x > max_code:
        max_code = x
    code.append(x)
if ch[0]==""0"" and n==2:
    print(int(ch))
elif max_code==min(code):
    print(""0""*n)
else:
    while max_code>5:
        for i in range(n):
            code[i]=(code[i]+1)%10
        max_code=max(code)
    min_code=min(code)
    while code[0]!=min_code:
        x=code[n-1]
        for i in range(n-1,0,-1):
            code[i]=code[i-1]
        code[0]=x
    ch=""""
    for i in range(n):
        ch+=str(code[i])
    print(ch)","# link: https://codeforces.com/problemset/problem/53/C

def solve(n):
    if n == 2:
        print(1, 2)
        return
    
    # Create a list of mounds from 1 to n
    route = list(range(1, n + 1))
    
    # Arrange mounds to ensure all jumps are different
    if n % 2 == 0:
        # For even n, split into two halves and reverse the second half
        first_half = route[:n // 2]
        second_half = route[n // 2:][::-1]
        result = first_half + second_half
    else:
        # For odd n, split and handle the middle element separately
        first_half = route[:n // 2]
        middle = route[n // 2]
        second_half = route[n // 2 + 1:][::-1]
        result = first_half + [middle] + second_half
    
    # Print the resulting route
    print(*result)

# Example usage
n = int(input())
solve(n)"
988,A,Diverse Team,PROGRAMMING,"['brute force', 'implementation']","There are $n$ students in a school class, the rating of the $i$-th student on Codehorses is $a_i$. You have to form a team consisting of $k$ students ($1 \le k \le n$) such that the ratings of all team members are distinct.

If it is impossible to form a suitable team, print ""NO"" (without quotes). Otherwise print ""YES"", and then print $k$ distinct numbers which should be the indices of students in the team you form. If there are multiple answers, print any of them.","The first line contains two integers $n$ and $k$ ($1 \le k \le n \le 100$) — the number of students and the size of the team you have to form.

The second line contains $n$ integers $a_1, a_2, \dots, a_n$ ($1 \le a_i \le 100$), where $a_i$ is the rating of $i$-th student.","If it is impossible to form a suitable team, print ""NO"" (without quotes). Otherwise print ""YES"", and then print $k$ distinct integers from $1$ to $n$ which should be the indices of students in the team you form. All the ratings of the students in the team should be distinct. You may print the indices in any order. If there are multiple answers, print any of them.

Assume that the students are numbered from $1$ to $n$.","['5 3\n15 13 15 15 12\n', '5 4\n15 13 15 15 12\n', '4 4\n20 10 40 30\n']","['YES\n1 2 5 \n', 'NO\n', 'YES\n1 2 3 4 \n']","All possible answers for the first example: 
 -  {1 2 5} -  {2 3 5} -  {2 4 5} 
Note that the order does not matter.",OK,"n,k=map(int,(input()).split("" ""))
z=0
m=input().split("" "")
x=[]
x.extend(set(m))
if len(x)>= k:
    print(""YES"")
    for i in range(k):
        print(m.index (x[i])+1,end="" "")
        z+=1
else:
    print(""NO"")
","# input
a, b, n = map(int, input().split())
dic = {0: 1}
m = 10**9 + 7

# if it were multiple testcases then we would have precomputed upto 10**6
for i in range(1, n + 1):
    dic[i] = (dic[i - 1] * i) % m

# calculate the count of good numbers of length n
good_count = (2 ** n) % m

# sum of digits for a good number with 'k' digits of 'a' and 'n-k' digits of 'b'
excellent_count = 0
for k in range(n + 1):
    sum_of_digits = k * a + (n - k) * b
    if all(d in (a, b) for d in map(int, str(sum_of_digits))):
        excellent_count = (excellent_count + dic[n] * pow(dic[k], m - 2, m) * pow(dic[n - k], m - 2, m)) % m

# print the result
print(excellent_count)"
808,C,Tea Party,PROGRAMMING,"['constructive algorithms', 'greedy', 'sortings']","Polycarp invited all his friends to the tea party to celebrate the holiday. He has *n* cups, one for each of his *n* friends, with volumes *a*1,<=*a*2,<=...,<=*a**n*. His teapot stores *w* milliliters of tea (*w*<=≤<=*a*1<=+<=*a*2<=+<=...<=+<=*a**n*). Polycarp wants to pour tea in cups in such a way that:
 -  Every cup will contain tea for at least half of its volume -  Every cup will contain integer number of milliliters of tea -  All the tea from the teapot will be poured into cups -  All friends will be satisfied. 
Friend with cup *i* won't be satisfied, if there exists such cup *j* that cup *i* contains less tea than cup *j* but *a**i*<=&gt;<=*a**j*.

For each cup output how many milliliters of tea should be poured in it. If it's impossible to pour all the tea and satisfy all conditions then output -1.","The first line contains two integer numbers *n* and *w* (1<=≤<=*n*<=≤<=100, ).

The second line contains *n* numbers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=100).","Output how many milliliters of tea every cup should contain. If there are multiple answers, print any of them.

If it's impossible to pour all the tea and satisfy all conditions then output -1.","['2 10\n8 7\n', '4 4\n1 1 1 1\n', '3 10\n9 8 10\n']","['6 4 \n', '1 1 1 1 \n', '-1\n']","In the third example you should pour to the first cup at least 5 milliliters, to the second one at least 4, to the third one at least 5. It sums up to 14, which is greater than 10 milliliters available.",OK,"n, w = (int(i) for i in input().split())
mas = [int(i) for i in input().split()]
 
def qer():
    global w
    for i, size in enumerate(mas):
        q = round(size / 2 + 0.1)
        rer[size,i] = q
        w -= q
        if w < 0:
            return {1:-1}
 
    for size,i in sorted(rer, reverse = True):
        o = size - rer[size,i]
        rer[size,i] += min(w,o)
        w -= min(o,w)
        if w == 0:
            break
    return rer
 
 
 
 
 
 
rer = {}
print(*qer().values())
","def func(a, b, tcount):
    while a > 0 and b > 0:
        if a <= b:
            tcount += b // a
            b = b % a
        else:
            tcount += a // b
            a = a % b
    return tcount

n = int(input())
results = []
for _ in range(n):
    a, b = map(int, input().split())
    operations_count = func(a, b, 0)
    results.append(operations_count)

for result in results:
    print(result)"
710,A,King Moves,PROGRAMMING,['implementation'],"The only king stands on the standard chess board. You are given his position in format ""cd"", where *c* is the column from 'a' to 'h' and *d* is the row from '1' to '8'. Find the number of moves permitted for the king.

Check the king's moves here [https://en.wikipedia.org/wiki/King_(chess)](https://en.wikipedia.org/wiki/King_(chess)).","The only line contains the king's position in the format ""cd"", where 'c' is the column from 'a' to 'h' and 'd' is the row from '1' to '8'.",Print the only integer *x* — the number of moves permitted for the king.,['e4\n'],['8\n'],none,OK,"s=input()
if s in {""a8"", ""a1"", ""h1"", ""h8""}:
	print(3)
elif s[0] in {'a', 'h'} or s[1] in {'1', '8'}:
	print(5)
else:
	print(8)
","def eq(stra, strb):
    # print('---')
    # print(stra, strb)
    if (stra == strb):
        return True
    if (len(stra) == 1):
        return False
    
    mid = len(stra) // 2  # Find the midpoint of the string
    a1, a2 = stra[:mid], stra[mid:]  # Split string a into two halves
    b1, b2 = strb[:mid], strb[mid:]  # Split string b into two halves
    
    # Check both conditions for equivalency
    return (eq(a1, b1) and eq(a2, b2)) or (eq(a1, b2) and eq(a2, b1))

# Read input strings
stra = input().strip()
strb = input().strip()

# Check for equivalency and print the result
if eq(stra, strb):
    print(""YES"")
else:
    print(""NO"")"
1004,A,Sonya and Hotels,PROGRAMMING,['implementation'],"Sonya decided that having her own hotel business is the best way of earning money because she can profit and rest wherever she wants.

The country where Sonya lives is an endless line. There is a city in each integer coordinate on this line. She has $n$ hotels, where the $i$-th hotel is located in the city with coordinate $x_i$. Sonya is a smart girl, so she does not open two or more hotels in the same city.

Sonya understands that her business needs to be expanded by opening new hotels, so she decides to build one more. She wants to make the minimum distance from this hotel to all others to be equal to $d$. The girl understands that there are many possible locations to construct such a hotel. Thus she wants to know the number of possible coordinates of the cities where she can build a new hotel. 

Because Sonya is lounging in a jacuzzi in one of her hotels, she is asking you to find the number of cities where she can build a new hotel so that the minimum distance from the original $n$ hotels to the new one is equal to $d$.","The first line contains two integers $n$ and $d$ ($1\leq n\leq 100$, $1\leq d\leq 10^9$) — the number of Sonya's hotels and the needed minimum distance from a new hotel to all others.

The second line contains $n$ different integers in strictly increasing order $x_1, x_2, \ldots, x_n$ ($-10^9\leq x_i\leq 10^9$) — coordinates of Sonya's hotels.",Print the number of cities where Sonya can build a new hotel so that the minimum distance from this hotel to all others is equal to $d$.,"['4 3\n-3 2 9 16\n', '5 2\n4 8 11 18 19\n']","['6\n', '5\n']","In the first example, there are $6$ possible cities where Sonya can build a hotel. These cities have coordinates $-6$, $5$, $6$, $12$, $13$, and $19$.

In the second example, there are $5$ possible cities where Sonya can build a hotel. These cities have coordinates $2$, $6$, $13$, $16$, and $21$.",OK,"n,k = map(int, input().split())
k *= 2
l = input().split()
sumi = 2
for x in range(len(l)-1):
    y = int(l[x+1])-int(l[x])
    if y  == k:
        sumi += 1
    elif y > k:
        sumi += 2
print(sumi)
","def get_ints():
    return map(int, input().strip().split())

def get_list():
    return list(map(int, input().strip().split()))

def get_string():
    return input().strip()

# Read the number of students
n = int(input().strip())
# Read the left/right hand preferences of the students
preferences = input().strip()

# Prepare lists for left-handed and right-handed students
left_handed = []
right_handed = []

# Fill the lists based on students' preferences
for i in range(n):
    if preferences[i] == 'L':
        left_handed.append(i + 1)  # Student numbers are 1-indexed
    else:
        right_handed.append(i + 1)

# Create desks by pairing left and right handed students
desks = []
for i in range(n // 2):
    if i < len(left_handed) - 1:  # Ensure there's always a pair
        desks.append((left_handed[i], left_handed[i + 1]))
    else:
        desks.append((right_handed[i - len(left_handed)], right_handed[i]))

# Output the pairs of student numbers
for left, right in desks:
    print(left, right)"
379,A,New Year Candles,PROGRAMMING,['implementation'],"Vasily the Programmer loves romance, so this year he decided to illuminate his room with candles.

Vasily has *a* candles.When Vasily lights up a new candle, it first burns for an hour and then it goes out. Vasily is smart, so he can make *b* went out candles into a new candle. As a result, this new candle can be used like any other new candle.

Now Vasily wonders: for how many hours can his candles light up the room if he acts optimally well? Help him find this number.","The single line contains two integers, *a* and *b* (1<=≤<=*a*<=≤<=1000; 2<=≤<=*b*<=≤<=1000).",Print a single integer — the number of hours Vasily can light up the room for.,"['4 2\n', '6 3\n']","['7\n', '8\n']","Consider the first sample. For the first four hours Vasily lights up new candles, then he uses four burned out candles to make two new ones and lights them up. When these candles go out (stop burning), Vasily can make another candle. Overall, Vasily can light up the room for 7 hours.",OK,"a, b = map(int, input().split())
res = 0
while a >= b:
    a += 1 - b
    res += b
res += a
print(res)","from collections import deque

def popleft_to(elem):
    global popped
    global b
    while b and b[0] < elem:
        b.popleft()
        popped += 1

def mobilize_army(n, m, x, y, a, b):
    global popped
    popped = 0
    b = deque(b)
    
    pairs = []
    for i in range(n):
        # Determine the size range for the current soldier
        lower_bound = a[i] - x
        upper_bound = a[i] + y
        
        # Remove vests that are too small
        popleft_to(lower_bound)

        # Equip the soldier with a vest if available within the acceptable size range
        if b and lower_bound <= b[0] <= upper_bound:
            pairs.append((i + 1, popped + 1))  # Store 1-based indices
            b.popleft()  # Remove the vest after assigning it

    # Output the result
    print(len(pairs))  # Number of soldiers equipped
    for u, v in pairs:
        print(u, v)  # Output pairs of soldier and vest indices


# Example input to test the function
n, m, x, y = 4, 3, 1, 2
a = [1, 2, 3, 4]
b = [1, 3, 5]

mobilize_army(n, m, x, y, a, b)"
38,A,Army,PROGRAMMING,['implementation'],"The Berland Armed Forces System consists of *n* ranks that are numbered using natural numbers from 1 to *n*, where 1 is the lowest rank and *n* is the highest rank.

One needs exactly *d**i* years to rise from rank *i* to rank *i*<=+<=1. Reaching a certain rank *i* having not reached all the previous *i*<=-<=1 ranks is impossible.

Vasya has just reached a new rank of *a*, but he dreams of holding the rank of *b*. Find for how many more years Vasya should serve in the army until he can finally realize his dream.",The first input line contains an integer *n* (2<=≤<=*n*<=≤<=100). The second line contains *n*<=-<=1 integers *d**i* (1<=≤<=*d**i*<=≤<=100). The third input line contains two integers *a* and *b* (1<=≤<=*a*<=&lt;<=*b*<=≤<=*n*). The numbers on the lines are space-separated.,Print the single number which is the number of years that Vasya needs to rise from rank *a* to rank *b*.,"['3\n5 6\n1 2\n', '3\n5 6\n1 3\n']","['5\n', '11\n']",none,OK,"# -*- coding: utf-8 -*-
""""""
Created on Sun Sep 26 21:56:04 2021

@author: cheehong
""""""
n=int(input())
l=list(map(int, input().split()))
k=list(map(int, input().split()))
x=k[1]-k[0]
total=0
while k[0]<k[1]:
    total+=l[k[0]-1]
    k[0]+=1
print(total)","def mover(ele, line, shift):
    if shift == 'R':
        idx = line.index(ele)
        ele = line[idx - 1]
        return ele
    elif shift == 'L':
        idx = line.index(ele)
        ele = line[idx + 1]
        return ele

# Main function to get the original message
def get_original_message(direction, typed_message):
    keyboard = ""abcdefghijklmnopqrstuvwxyz""  # Assuming lowercase letters only
    original_message = """"

    for char in typed_message:
        original_char = mover(char, keyboard, direction)
        original_message += original_char

    return original_message

# Input
direction = input().strip()  # Read direction (L or R)
typed_message = input().strip()  # Read the message typed by Mole

# Output
print(get_original_message(direction, typed_message))"
330,A,Cakeminator,PROGRAMMING,"['brute force', 'implementation']","You are given a rectangular cake, represented as an *r*<=×<=*c* grid. Each cell either has an evil strawberry, or is empty. For example, a 3<=×<=4 cake may look as follows:

The cakeminator is going to eat the cake! Each time he eats, he chooses a row or a column that does not contain any evil strawberries and contains at least one cake cell that has not been eaten before, and eats all the cake cells there. He may decide to eat any number of times.

Please output the maximum number of cake cells that the cakeminator can eat.","The first line contains two integers *r* and *c* (2<=≤<=*r*,<=*c*<=≤<=10), denoting the number of rows and the number of columns of the cake. The next *r* lines each contains *c* characters — the *j*-th character of the *i*-th line denotes the content of the cell at row *i* and column *j*, and is either one of these: 
 -  '.' character denotes a cake cell with no evil strawberry; -  'S' character denotes a cake cell with an evil strawberry.",Output the maximum number of cake cells that the cakeminator can eat.,['3 4\nS...\n....\n..S.\n'],['8\n'],"For the first example, one possible way to eat the maximum number of cake cells is as follows (perform 3 eats).",OK,"arr = input()
arr = arr.split("" "")

r = int(arr[0])
c = int(arr[1])
row = []
col = []
for i in range(r):
	text = input()
	for j in range(c):
		if text[j] == ""S"":
			if j not in col:
				col.append(j)
			if i not in row:
				row.append(i)

print((r-len(row))*c + (c-len(col))*r - ((r-len(row))*(c-len(col))))
			","def is_magic_square_possible(grid, n, empty_pos):
    # Calculate the target sum using the first row or column that is not empty
    target_sum = None
    for i in range(n):
        if grid[i][0] != 0:
            target_sum = sum(grid[i])
            break
    
    if target_sum is None:
        return -1  # No valid sums found, impossible case

    # Calculate current sums and identify the position of the empty cell
    current_row_sum = sum(grid[empty_pos[0]])
    current_col_sum = sum(grid[i][empty_pos[1]] for i in range(n))
    
    # Calculate the sums of diagonals if the empty cell is on a diagonal
    diag1_sum = sum(grid[i][i] for i in range(n)) if empty_pos[0] == empty_pos[1] else None
    diag2_sum = sum(grid[i][n - 1 - i] for i in range(n)) if empty_pos[0] + empty_pos[1] == n - 1 else None
    
    # Find the required value to fill the empty position
    required_value = target_sum - (current_row_sum - 0)  # 0 because it's empty
    
    if required_value <= 0:
        return -1  # The value must be positive
    
    # Check if this value keeps other sums valid
    if (current_col_sum + required_value != target_sum):
        return -1
    
    if diag1_sum is not None and diag1_sum + (required_value if empty_pos[0] == empty_pos[1] else 0) != target_sum:
        return -1
    
    if diag2_sum is not None and diag2_sum + (required_value if empty_pos[0] + empty_pos[1] == n - 1 else 0) != target_sum:
        return -1
    
    return required_value

n = int(input())
grid = []
empty_pos = None

for i in range(n):
    row = list(map(int, input().split()))
    grid.append(row)
    if 0 in row:
        empty_pos = (i, row.index(0))  # Store position of zero

# Call the function to find the required value
result = is_magic_square_possible(grid, n, empty_pos)
print(result)"
58,A,Chat room,PROGRAMMING,"['greedy', 'strings']","Vasya has recently learned to type and log on to the Internet. He immediately entered a chat room and decided to say hello to everybody. Vasya typed the word *s*. It is considered that Vasya managed to say hello if several letters can be deleted from the typed word so that it resulted in the word ""hello"". For example, if Vasya types the word ""ahhellllloou"", it will be considered that he said hello, and if he types ""hlelo"", it will be considered that Vasya got misunderstood and he didn't manage to say hello. Determine whether Vasya managed to say hello by the given word *s*.","The first and only line contains the word *s*, which Vasya typed. This word consisits of small Latin letters, its length is no less that 1 and no more than 100 letters.","If Vasya managed to say hello, print ""YES"", otherwise print ""NO"".","['ahhellllloou\n', 'hlelo\n']","['YES\n', 'NO\n']",none,WRONG_ANSWER,"n = input()
l = [""h"",""e"",""l"",""l"",""o""]
x = 0
for i in n:
	if i == l[x]:
		x +=1
	if i == l[x-1]:
		pass
	else:
		if i ==""h"":
			x = 1
		else:
			x=0
	if x == 5:
		a=True
		break
	a =False
if a:
	print(""YES"")
else:
	print(""NO"")","from sys import stdin
from collections import defaultdict

def arr_inp(n):
    if n == 1:
        return [int(stdin.readline().strip())]
    return list(map(int, stdin.readline().strip().split()))

def main():
    # Read input values
    n, m, k = map(int, stdin.readline().strip().split())
    order = arr_inp(n)  # Initial order of icons
    launches = arr_inp(m)  # Applications to be launched

    # Map for current positions of applications
    position = {app: idx for idx, app in enumerate(order)}
    
    total_gestures = 0

    for app in launches:
        # Determine the screen number and gestures required
        current_pos = position[app]
        screen_number = current_pos // k + 1  # Screen index (1-based)
        total_gestures += screen_number  # Scroll to the screen
        
        # If app is not in the first position, swap it with the preceding app
        if current_pos > 0:
            preceding_app = order[current_pos - 1]
            # Swap positions in the order
            order[current_pos], order[current_pos - 1] = order[current_pos - 1], order[current_pos]
            # Update positions in the map
            position[app], position[preceding_app] = position[preceding_app], position[app]
    
    print(total_gestures)

if __name__ == ""__main__"":
    main()"
767,A,Snacktower,PROGRAMMING,"['data structures', 'implementation']","According to an old legeng, a long time ago Ankh-Morpork residents did something wrong to miss Fortune, and she cursed them. She said that at some time *n* snacks of distinct sizes will fall on the city, and the residents should build a Snacktower of them by placing snacks one on another. Of course, big snacks should be at the bottom of the tower, while small snacks should be at the top.

Years passed, and once different snacks started to fall onto the city, and the residents began to build the Snacktower.

However, they faced some troubles. Each day exactly one snack fell onto the city, but their order was strange. So, at some days the residents weren't able to put the new stack on the top of the Snacktower: they had to wait until all the bigger snacks fell. Of course, in order to not to anger miss Fortune again, the residents placed each snack on the top of the tower immediately as they could do it.

Write a program that models the behavior of Ankh-Morpork residents.","The first line contains single integer *n* (1<=≤<=*n*<=≤<=100<=000) — the total number of snacks.

The second line contains *n* integers, the *i*-th of them equals the size of the snack which fell on the *i*-th day. Sizes are distinct integers from 1 to *n*.","Print *n* lines. On the *i*-th of them print the sizes of the snacks which the residents placed on the top of the Snacktower on the *i*-th day in the order they will do that. If no snack is placed on some day, leave the corresponding line empty.","['3\n3 1 2\n', '5\n4 5 1 2 3\n']","['3\n\xa0\n2 1', '5 4\n\xa0\n\xa0\n3 2 1\n']","In the example a snack of size 3 fell on the first day, and the residents immediately placed it. On the second day a snack of size 1 fell, and the residents weren't able to place it because they were missing the snack of size 2. On the third day a snack of size 2 fell, and the residents immediately placed it. Right after that they placed the snack of size 1 which had fallen before.",RUNTIME_ERROR,"n=int(input())
num=list(map(int,input().split()))
target=n
array={}
while True:
    if target in array:
        print(target,end=' ')
        target-=1
        while True:
            if target in array:
                print(target,end=' ')
                target-=1
            else:
                break
        continue
    else:
        array[num[-n]]=f
        if target in array:
            continue
        print(' ')
    n -= 1
    if n==0:
        break","year = int(input())

def judge(y):
    # Convert the year to a string to easily check its digits
    str_year = str(y)
    # Use a set to track unique digits
    return len(set(str_year)) == len(str_year)

# Start checking from the next year
current_year = year + 1

# Loop until we find a year with distinct digits
while True:
    if judge(current_year):
        print(current_year)
        break
    current_year += 1"
815,A,Karen and Game,PROGRAMMING,"['brute force', 'greedy', 'implementation']","On the way to school, Karen became fixated on the puzzle game on her phone!

The game is played as follows. In each level, you have a grid with *n* rows and *m* columns. Each cell originally contains the number 0.

One move consists of choosing one row or column, and adding 1 to all of the cells in that row or column.

To win the level, after all the moves, the number in the cell at the *i*-th row and *j*-th column should be equal to *g**i*,<=*j*.

Karen is stuck on one level, and wants to know a way to beat this level using the minimum number of moves. Please, help her with this task!","The first line of input contains two integers, *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=100), the number of rows and the number of columns in the grid, respectively.

The next *n* lines each contain *m* integers. In particular, the *j*-th integer in the *i*-th of these rows contains *g**i*,<=*j* (0<=≤<=*g**i*,<=*j*<=≤<=500).","If there is an error and it is actually not possible to beat the level, output a single integer -1.

Otherwise, on the first line, output a single integer *k*, the minimum number of moves necessary to beat the level.

The next *k* lines should each contain one of the following, describing the moves in the order they must be done:
 -  row *x*, (1<=≤<=*x*<=≤<=*n*) describing a move of the form ""choose the *x*-th row"". -  col *x*, (1<=≤<=*x*<=≤<=*m*) describing a move of the form ""choose the *x*-th column"". 
If there are multiple optimal solutions, output any one of them.","['3 5\n2 2 2 3 2\n0 0 0 1 0\n1 1 1 2 1\n', '3 3\n0 0 0\n0 1 0\n0 0 0\n', '3 3\n1 1 1\n1 1 1\n1 1 1\n']","['4\nrow 1\nrow 1\ncol 4\nrow 3\n', '-1\n', '3\nrow 1\nrow 2\nrow 3\n']","In the first test case, Karen has a grid with 3 rows and 5 columns. She can perform the following 4 moves to beat the level:

In the second test case, Karen has a grid with 3 rows and 3 columns. It is clear that it is impossible to beat the level; performing any move will create three 1s on the grid, but it is required to only have one 1 in the center.

In the third test case, Karen has a grid with 3 rows and 3 columns. She can perform the following 3 moves to beat the level:

Note that this is not the only solution; another solution, among others, is col 1, col 2, col 3.",RUNTIME_ERROR,"def burenka(a, b, c, d):
  """"""
  Returns the minimum number of claps Burenka needs to make her fractions equal.

  Args:
    a: The numerator of the first fraction.
    b: The denominator of the first fraction.
    c: The numerator of the second fraction.
    d: The denominator of the second fraction.

  Returns:
    The minimum number of claps.
  """"""

  # Check if the fractions are already equal.
  if a / b == c / d:
    return 0

  # Find the greatest common factor of the denominators.
  gcd = math.gcd(b, d)

  # Normalize the fractions.
  a = a // gcd
  b = b // gcd
  c = c // gcd
  d = d // gcd

  # Find the minimum number of times Burenka needs to clap to make the numerators equal.
  num_claps = abs(a - c) // b

  # If the denominators are not equal, Burenka also needs to clap one more time.
  if b != d:
    num_claps += 1

  return num_claps

if __name__ == ""__main__"":
  t = int(input())
  for _ in range(t):
    a, b, c, d = map(int, input().split())
    print(burenka(a, b, c, d))","def main():
    a = [input(), input(), input()]
    winner = -1

    if a.count('rock') == 1 and a.count('scissors') == 2:
        winner = 0  # Uncle Fyodor wins
    elif a.count('scissors') == 1 and a.count('paper') == 2:
        winner = 1  # Matroskin wins
    elif a.count('paper') == 1 and a.count('rock') == 2:
        winner = 2  # Sharic wins

    if winner == -1:
        print(""?"")  # No winner
    else:
        print(""F"" if winner == 0 else ""M"" if winner == 1 else ""S"") 

main()"
363,B,Fence,PROGRAMMING,"['brute force', 'dp']","There is a fence in front of Polycarpus's home. The fence consists of *n* planks of the same width which go one after another from left to right. The height of the *i*-th plank is *h**i* meters, distinct planks can have distinct heights.

Polycarpus has bought a posh piano and is thinking about how to get it into the house. In order to carry out his plan, he needs to take exactly *k* consecutive planks from the fence. Higher planks are harder to tear off the fence, so Polycarpus wants to find such *k* consecutive planks that the sum of their heights is minimal possible.

Write the program that finds the indexes of *k* consecutive planks with minimal total height. Pay attention, the fence is not around Polycarpus's home, it is in front of home (in other words, the fence isn't cyclic).","The first line of the input contains integers *n* and *k* (1<=≤<=*n*<=≤<=1.5·105,<=1<=≤<=*k*<=≤<=*n*) — the number of planks in the fence and the width of the hole for the piano. The second line contains the sequence of integers *h*1,<=*h*2,<=...,<=*h**n* (1<=≤<=*h**i*<=≤<=100), where *h**i* is the height of the *i*-th plank of the fence.","Print such integer *j* that the sum of the heights of planks *j*, *j*<=+<=1, ..., *j*<=+<=*k*<=-<=1 is the minimum possible. If there are multiple such *j*'s, print any of them.",['7 3\n1 2 6 1 1 7 1\n'],['3\n'],"In the sample, your task is to find three consecutive planks with the minimum sum of heights. In the given case three planks with indexes 3, 4 and 5 have the required attribute, their total height is 8.",TIME_LIMIT_EXCEEDED,"m,n = map(int,input().split())
k = list(map(int,input().split()))
s=[]
for i in range(m-n+1):
    d=0
    for j in range(n):
        d = d+k[i+j]
    s.append(d)
f = min(s)
for i in range(m-n+1):
    if s[i] == f:
        print(i+1)
        break","def yabl(b):
    # If there's only one number, return its value (it's also the score)
    if len(b) == 1:
        return b[0]
    else:
        x = len(b) // 2
        # Split the array into two groups
        group1 = b[:x]
        group2 = b[x:]
        return yabl(group1) + yabl(group2)

def maximum_score(numbers):
    # Sort numbers in descending order to get the maximum possible score
    numbers.sort(reverse=True)
    score = 0
    # Calculate the score by adding the sum of numbers progressively
    for i in range(len(numbers)):
        score += numbers[i] * (i + 1)
    return score

n = int(input())
numbers = list(map(int, input().split()))
print(maximum_score(numbers))"
220,B,Little Elephant and Array,PROGRAMMING,"['constructive algorithms', 'data structures']","The Little Elephant loves playing with arrays. He has array *a*, consisting of *n* positive integers, indexed from 1 to *n*. Let's denote the number with index *i* as *a**i*. 

Additionally the Little Elephant has *m* queries to the array, each query is characterised by a pair of integers *l**j* and *r**j* (1<=≤<=*l**j*<=≤<=*r**j*<=≤<=*n*). For each query *l**j*,<=*r**j* the Little Elephant has to count, how many numbers *x* exist, such that number *x* occurs exactly *x* times among numbers *a**l**j*,<=*a**l**j*<=+<=1,<=...,<=*a**r**j*.

Help the Little Elephant to count the answers to all queries.","The first line contains two space-separated integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=105) — the size of array *a* and the number of queries to it. The next line contains *n* space-separated positive integers *a*1, *a*2, ..., *a**n* (1<=≤<=*a**i*<=≤<=109). Next *m* lines contain descriptions of queries, one per line. The *j*-th of these lines contains the description of the *j*-th query as two space-separated integers *l**j* and *r**j* (1<=≤<=*l**j*<=≤<=*r**j*<=≤<=*n*).",In *m* lines print *m* integers — the answers to the queries. The *j*-th line should contain the answer to the *j*-th query.,['7 2\n3 1 2 2 3 3 7\n1 7\n3 4\n'],['3\n1\n'],none,WRONG_ANSWER,"s = input()
nums = set([str(x) for x in range(0, 9+1)])
cnt = dict()
m = -1
ans = 0
days_in_month = {1: 31, 2: 28, 3: 31, 4: 30, 5: 31, 6: 30, 7: 31, 8: 31, 9: 30, 10: 31, 11: 30, 12:31}
for i in range(len(s) - 10):
    q = s[i:i+10]
    if q[0] in nums and q[1] in nums and q[2] == ""-"":
        if q[3] in nums and q[4] in nums and q[5] == ""-"": 
            if q[6] in nums and q[7] in nums and q[8] in nums and q[9] in nums:
                try:
                    day = int(q[0:1+1])
                    month = int(q[3:4+1])
                    year = int(q[6:9+1])
                except:
                    continue
                #print(day, month)
                if 0 < month <= 12 and 0 < day <= days_in_month[month] and 2013 <= year <= 2015:
                    try:
                        cnt[q] += 1
                    except:
                        cnt[q] = 0
#print(cnt)
for key in cnt.keys():
    if cnt[key] > m:
        m = cnt[key]
        ans = key
print(ans)","def gcd(a, b):
    if a == 0:
        return b
    return gcd(b % a, a)

def gcd_range(a, b):
    # GCD of the range a to b is equal to GCD of a and b when a == b
    if a == b:
        return a
    else:
        # GCD of all numbers from a to b is 1 if a < b
        # because we can always find two consecutive integers
        return 1

# Read input
a, b = input().split()
# Convert a and b to integers
a = int(a)
b = int(b)

# Compute GCD of the range
result = gcd_range(a, b)
# Output the result
print(result)"
401,A,Vanya and Cards,PROGRAMMING,"['implementation', 'math']","Vanya loves playing. He even has a special set of cards to play with. Each card has a single integer. The number on the card can be positive, negative and can even be equal to zero. The only limit is, the number on each card doesn't exceed *x* in the absolute value.

Natasha doesn't like when Vanya spends a long time playing, so she hid all of his cards. Vanya became sad and started looking for the cards but he only found *n* of them. Vanya loves the balance, so he wants the sum of all numbers on found cards equal to zero. On the other hand, he got very tired of looking for cards. Help the boy and say what is the minimum number of cards does he need to find to make the sum equal to zero?

You can assume that initially Vanya had infinitely many cards with each integer number from <=-<=*x* to *x*.",The first line contains two integers: *n* (1<=≤<=*n*<=≤<=1000) — the number of found cards and *x* (1<=≤<=*x*<=≤<=1000) — the maximum absolute value of the number on a card. The second line contains *n* space-separated integers — the numbers on found cards. It is guaranteed that the numbers do not exceed *x* in their absolute value.,Print a single number — the answer to the problem.,"['3 2\n-1 1 2\n', '2 3\n-2 -2\n']","['1\n', '2\n']","In the first sample, Vanya needs to find a single card with number -2.

In the second sample, Vanya needs to find two cards with number 2. He can't find a single card with the required number as the numbers on the lost cards do not exceed 3 in their absolute value.",WRONG_ANSWER,"n, x = map(int, input().split())
s = input().split()
count = 0 
j = 0
for i in s:
  count += int(i)
if count < 0:  
  while count < 0:
    count += x
    j += 1
elif count > 0:  
  while count > 0:
    count -= x
    j += 1
else:
  print(0)
print(j)","def checker(paints):
    # Replace '?' with a placeholder to minimize incorrect colorings
    paints = list(paints)
    
    # Fill unpainted segments with alternating colors
    for i in range(len(paints)):
        if paints[i] == '?':
            # Find the previous painted segment
            left_color = paints[i - 1] if i > 0 else None
            # Find the next painted segment
            right_color = paints[i + 1] if i < len(paints) - 1 else None
            
            # Determine valid colors to use
            available_colors = {'C', 'M', 'Y'}
            if left_color:
                available_colors.discard(left_color)
            if right_color:
                available_colors.discard(right_color)
            
            # If there are available colors, color it with one
            if available_colors:
                paints[i] = available_colors.pop()

    # Count the adjacent conflicts
    conflicts = 0
    for i in range(len(paints) - 1):
        if paints[i] == paints[i + 1]:
            conflicts += 1
    
    # Check if there are enough valid configurations
    if conflicts == 0:
        # If no conflicts, there are at least 2 configurations
        return ""Yes""
    else:
        return ""No""

# Example usage:
n = int(input().strip())
s = input().strip()
print(checker(s))"
111,B,Petya and Divisors,PROGRAMMING,"['binary search', 'data structures', 'number theory']","Little Petya loves looking for numbers' divisors. One day Petya came across the following problem:

You are given *n* queries in the form ""*x**i* *y**i*"". For each query Petya should count how many divisors of number *x**i* divide none of the numbers *x**i*<=-<=*y**i*,<=*x**i*<=-<=*y**i*<=+<=1,<=...,<=*x**i*<=-<=1. Help him.","The first line contains an integer *n* (1<=≤<=*n*<=≤<=105). Each of the following *n* lines contain two space-separated integers *x**i* and *y**i* (1<=≤<=*x**i*<=≤<=105, 0<=≤<=*y**i*<=≤<=*i*<=-<=1, where *i* is the query's ordinal number; the numeration starts with 1). 

If *y**i*<==<=0 for the query, then the answer to the query will be the number of divisors of the number *x**i*. In this case you do not need to take the previous numbers *x* into consideration.",For each query print the answer on a single line: the number of positive integers *k* such that ,['6\n4 0\n3 1\n5 2\n6 2\n18 4\n10000 3\n'],['3\n1\n1\n2\n2\n22\n'],"Let's write out the divisors that give answers for the first 5 queries:

1) 1, 2, 4 

2) 3

3) 5

4) 2, 6

5) 9, 18",OK,"def R(): return map(int, input().split())
def I(): return int(input())
def S(): return str(input())

def L(): return list(R())

from collections import Counter 

import math
import sys

from itertools import permutations


import bisect

div=[[] for i in range(10**5+1)]


for i in range(1,10**5+1):
    for j in range(1,10**5//i+1):
        div[i*j].append(i)

n=I()
last=[-1]*(10**5+1)


for j in range(n):
    x,y=R()
    ans=0
    for i in div[x]:
        if last[i]<j-y:
            ans+=1

        last[i]=j


    print(ans)","def solv(a, b):
    n = max(a, b)
    S = [i * i for i in range(1, n)]
    D = {i: [] for i in range(1, 4 * n * n + 1)}
    
    for i in range(1, n):
        for j in range(1, n):
            if i != j:
                S12 = i * i + j * j
                if S12 in D:
                    D[S12].append((i, j))
    
    # Check if we can find two pairs that make right triangle with legs a, b
    for key in D:
        if len(D[key]) >= 2:
            for (x1, y1) in D[key]:
                for (x2, y2) in D[key]:
                    if (x1, y1) != (x2, y2):
                        if (abs(x1) == a and abs(y1) == b) or (abs(x1) == b and abs(y1) == a):
                            # Found valid triangle vertices
                            print(""YES"")
                            print(0, 0)
                            print(a, 0)
                            print(0, b)
                            return
    
    print(""NO"")

# Example input
solv(3, 4)"
9,A,Die Roll,PROGRAMMING,"['math', 'probabilities']","Yakko, Wakko and Dot, world-famous animaniacs, decided to rest from acting in cartoons, and take a leave to travel a bit. Yakko dreamt to go to Pennsylvania, his Motherland and the Motherland of his ancestors. Wakko thought about Tasmania, its beaches, sun and sea. Dot chose Transylvania as the most mysterious and unpredictable place.

But to their great regret, the leave turned to be very short, so it will be enough to visit one of the three above named places. That's why Yakko, as the cleverest, came up with a truly genius idea: let each of the three roll an ordinary six-sided die, and the one with the highest amount of points will be the winner, and will take the other two to the place of his/her dreams.

Yakko thrown a die and got Y points, Wakko — W points. It was Dot's turn. But she didn't hurry. Dot wanted to know for sure what were her chances to visit Transylvania.

It is known that Yakko and Wakko are true gentlemen, that's why if they have the same amount of points with Dot, they will let Dot win.",The only line of the input file contains two natural numbers Y and W — the results of Yakko's and Wakko's die rolls.,"Output the required probability in the form of irreducible fraction in format «A/B», where A — the numerator, and B — the denominator. If the required probability equals to zero, output «0/1». If the required probability equals to 1, output «1/1».",['4 2\n'],['1/2\n'],"Dot will go to Transylvania, if she is lucky to roll 4, 5 or 6 points.",COMPILATION_ERROR,"/*
@ Author: Andres Nowak
@ Date: Tue Mar 10 13:15:34 CST 2020
*/

#include <iostream>
#include <vector>
#include <string>

using namespace std;

int gcd(int a, int b)
{
    if (a == 0)
        return b;
    return gcd(b % a, a);
}

string probability(vector<int> throws_of_dice)
{
    int denominator = 6;

    int maximum = *max_element(throws_of_dice.begin(), throws_of_dice.end());

    int higher_numbers_that_can_get = 7 - maximum;

    if (higher_numbers_that_can_get == 0)
    {
        return ""0/1"";
    }

    int common_factor = gcd(higher_numbers_that_can_get, denominator);

    higher_numbers_that_can_get = higher_numbers_that_can_get / common_factor;
    denominator = denominator / common_factor;

    int probability = higher_numbers_that_can_get / denominator;

    if (probability == 1)
    {
        return ""1/1"";
    }

    return to_string(higher_numbers_that_can_get) + ""/"" + to_string(denominator);
}

int main()
{

    vector<int> throws_of_dice(2);

    cin >> throws_of_dice[0] >> throws_of_dice[1];

    cout << probability(throws_of_dice) << endl;
}
","return list(map(int, f.readline().strip().split()))


def main():
    # Read input values
    n, m, a, d = read_input()
    
    # Read client arrival times
    client_times = read_input()
    
    # Calculate employee arrival times
    employee_times = [i * a for i in range(1, n + 1)]
    
    # Merge client and employee times
    all_times = sorted(employee_times + client_times)
    
    door_openings = 0
    door_close_time = -1  # Door is initially closed
    
    for time in all_times:
        # If the door is closed and someone arrives
        if door_close_time < time:
            door_openings += 1  # The door will open
            door_close_time = time + d  # Set the closing time
            
        # If the door is about to close during arrival
        elif door_close_time >= time:
            door_close_time = max(door_close_time, time + d)  # Adjust closing time if needed
    
    print(door_openings)


if __name__ == ""__main__"":
    main()"
191,A,Dynasty Puzzles,PROGRAMMING,['dp'],"The ancient Berlanders believed that the longer the name, the more important its bearer is. Thus, Berland kings were famous for their long names. But long names are somewhat inconvenient, so the Berlanders started to abbreviate the names of their kings. They called every king by the first letters of its name. Thus, the king, whose name was Victorious Vasily Pupkin, was always called by the berlanders VVP.

In Berland over its long history many dynasties of kings replaced each other, but they were all united by common traditions. Thus, according to one Berland traditions, to maintain stability in the country, the first name of the heir should be the same as the last name his predecessor (hence, the first letter of the abbreviated name of the heir coincides with the last letter of the abbreviated name of the predecessor). Berlanders appreciate stability, so this tradition has never been broken. Also Berlanders like perfection, so another tradition requires that the first name of the first king in the dynasty coincides with the last name of the last king in this dynasty (hence, the first letter of the abbreviated name of the first king coincides with the last letter of the abbreviated name of the last king). This tradition, of course, has also been always observed.

The name of a dynasty is formed by very simple rules: we take all the short names of the kings in the order in which they ruled, and write them in one line. Thus, a dynasty of kings ""ab"" and ""ba"" is called ""abba"", and the dynasty, which had only the king ""abca"", is called ""abca"".

Vasya, a historian, has recently found a list of abbreviated names of all Berland kings and their relatives. Help Vasya to find the maximally long name of the dynasty that could have existed in Berland.

Note that in his list all the names are ordered by the time, that is, if name *A* is earlier in the list than *B*, then if *A* and *B* were kings, then king *A* ruled before king *B*.","The first line contains integer *n* (1<=≤<=*n*<=≤<=5·105) — the number of names in Vasya's list. Next *n* lines contain *n* abbreviated names, one per line. An abbreviated name is a non-empty sequence of lowercase Latin letters. Its length does not exceed 10 characters.","Print a single number — length of the sought dynasty's name in letters.

If Vasya's list is wrong and no dynasty can be found there, print a single number 0.","['3\nabc\nca\ncba\n', '4\nvvp\nvvp\ndam\nvvp\n', '3\nab\nc\ndef\n']","['6\n', '0\n', '1\n']","In the first sample two dynasties can exist: the one called ""abcca"" (with the first and second kings) and the one called ""abccba"" (with the first and third kings). 

In the second sample there aren't acceptable dynasties.

The only dynasty in the third sample consists of one king, his name is ""c"".",TIME_LIMIT_EXCEEDED,"from collections import defaultdict, Counter
import sys


M = int(1e9 + 7)
inf = float('inf')

def I():
    return input()

def II():
    return int(I())

def LI():
    return list(I().split())

def LII():
    return list(map(int, LI()))

def rank(arr, lo, hi, target):
    while lo <= hi:
        mi = (lo + hi) >> 1
        if arr[mi] < target:
            lo = mi + 1
        else:
            hi = mi - 1
    return lo

def get_idx(ch):
    return ord(ch) - ord('a')

def solve():
    n = II()
    dp = [[-inf] * 26 for _ in range(26)]
    ans = 0

    for _ in range(n):
        s = I()
        m = len(s)

        begin, end = get_idx(s[0]), get_idx(s[-1])
        for i in range(26):
            dp[i][end] = max(dp[i][end], dp[i][begin] + m)
        dp[begin][end] = max(dp[begin][end], m)
        ans = max(ans, dp[end][end])

    print(ans)
solve()
","def max_nice_rectangles(n, grid):
    # Transform the grid to have cumulative sums
    prefix_sum = [[0] * (n + 1) for _ in range(3)]
    
    for j in range(1, n + 1):
        prefix_sum[1][j] = prefix_sum[1][j - 1] + grid[0][j - 1]
        prefix_sum[2][j] = prefix_sum[2][j - 1] + grid[1][j - 1]
    
    # Dictionary to keep track of counts of prefix sums
    count = {}
    
    # Count the number of nice rectangles
    rect_count = 0
    
    for j in range(n + 1):
        # Check the sum for rectangles that extend from (1,1) to (1,j)
        sum_top = prefix_sum[1][j]
        count[sum_top] = count.get(sum_top, 0) + 1
        
        # Check the sum for rectangles that extend from (2,1) to (2,j)
        sum_bottom = prefix_sum[2][j]
        rect_count += count.get(-sum_bottom, 0)  # We can form nice rectangles
        
        # If the entire sum is zero, we can count it as a full rectangle
        if sum_top + sum_bottom == 0:
            rect_count += 1
    
    return rect_count


# Input reading
n = int(input())
grid = [list(map(int, input().split())) for _ in range(2)]

# Output the result
print(max_nice_rectangles(n, grid))"
197,A,Plate Game,PROGRAMMING,"['constructive algorithms', 'games', 'math']","You've got a rectangular table with length *a* and width *b* and the infinite number of plates of radius *r*. Two players play the following game: they take turns to put the plates on the table so that the plates don't lie on each other (but they can touch each other), and so that any point on any plate is located within the table's border. During the game one cannot move the plates that already lie on the table. The player who cannot make another move loses. Determine which player wins, the one who moves first or the one who moves second, provided that both players play optimally well.","A single line contains three space-separated integers *a*, *b*, *r* (1<=≤<=*a*,<=*b*,<=*r*<=≤<=100) — the table sides and the plates' radius, correspondingly.","If wins the player who moves first, print ""First"" (without the quotes). Otherwise print ""Second"" (without the quotes).","['5 5 2\n', '6 7 4\n']","['First\n', 'Second\n']","In the first sample the table has place for only one plate. The first player puts a plate on the table, the second player can't do that and loses.

In the second sample the table is so small that it doesn't have enough place even for one plate. So the first player loses without making a single move.",OK,"A = list(map(int,input().split()))
a = A[0];b = A[1];r = A[2]
if 2*r <= min(a,b):
	print('First')
else:
	print('Second')","import itertools
import math
from collections import defaultdict

def input_ints():
    return list(map(int, input().strip().split()))

def calculate_buses(n, m, groups):
    buses = 0
    current_capacity = 0

    for group in groups:
        if current_capacity + group <= m:
            current_capacity += group  # Add the group to the current bus
        else:
            buses += 1  # Need a new bus
            current_capacity = group  # Start new bus with the current group

    if current_capacity > 0:
        buses += 1  # Count the last bus if it has any people

    return buses

if __name__ == ""__main__"":
    n, m = input_ints()  # Read the number of groups and bus capacity
    groups = input_ints()  # Read the sizes of the groups
    result = calculate_buses(n, m, groups)  # Calculate the number of buses needed
    print(result)  # Output the result"
361,B,Levko and Permutation,PROGRAMMING,"['constructive algorithms', 'math', 'number theory']","Levko loves permutations very much. A permutation of length *n* is a sequence of distinct positive integers, each is at most *n*.

Let’s assume that value *gcd*(*a*,<=*b*) shows the greatest common divisor of numbers *a* and *b*. Levko assumes that element *p**i* of permutation *p*1,<=*p*2,<=... ,<=*p**n* is good if *gcd*(*i*,<=*p**i*)<=&gt;<=1. Levko considers a permutation beautiful, if it has exactly *k* good elements. Unfortunately, he doesn’t know any beautiful permutation. Your task is to help him to find at least one of them.","The single line contains two integers *n* and *k* (1<=≤<=*n*<=≤<=105, 0<=≤<=*k*<=≤<=*n*).","In a single line print either any beautiful permutation or -1, if such permutation doesn’t exist.

If there are multiple suitable permutations, you are allowed to print any of them.","['4 2\n', '1 1\n']","['2 4 3 1', '-1\n']","In the first sample elements 4 and 3 are good because *gcd*(2, 4) = 2 &gt; 1 and *gcd*(3, 3) = 3 &gt; 1. Elements 2 and 1 are not good because *gcd*(1, 2) = 1 and *gcd*(4, 1) = 1. As there are exactly 2 good elements, the permutation is beautiful.

The second sample has no beautiful permutations.",WRONG_ANSWER,"n, k = list(map(int, input().split()))
if n == 1:
    print(-1)
else:
    print(1, end="" "")
    i = 2
    counter = k
    while counter > 0:
        print(i*2, end="" "")
        i += 1
        counter -= 1
    index_pointer = k + 1
    pointer = n*2 + 5
    while index_pointer <= n:
        if index_pointer % 2 == 0:
            if pointer % 2 == 0:
                pointer += 1
        else:
            if pointer % 2 == 1:
                pointer += 1
        print(pointer, end="" "")
        pointer += 1
        index_pointer += 1

","n = int(input())

def fn(n):
    if n == 0:
        print('0 0 0')
    elif n == 1:
        print('0 0 1')
    elif n == 2:
        print('0 1 1')
    else:
        print(n, 0, 0)

fn(n)"
120,A,Elevator,PROGRAMMING,"['brute force', 'implementation', 'math']","A sky scraper with 1000 floors has been built in the city of N. It has modern superfast elevators to help to travel from one floor to another. Each elevator has two doors, the front one and the back one. If one goes in through the front door, he goes out through the back one and vice versa. The elevator has two rails numbered with numbers 1 and 2. Rail 1 is located to the left of the entrance to the front door (or correspondingly, to the right of the entrance to the back door). Rail 2 is located opposite it, to the right of the entrance to the front door and to the left of the entrance to the back door. We know that each person in the city of N holds at a rail with the strongest hand. 

One day a VIP person visited the city and of course, he took a look at the skyscraper and took a ride in the elevator. We know the door through which he entered and the rail he was holding at. Now we need to determine as soon as possible whether he is left-handed or right-handed.","The first line indicates the door through which the very important person entered the elevator. It contains ""front"" if the person enters the elevator through the front door and ""back"" if he entered the elevator through the back door. The second line contains integer *a* (1<=≤<=*a*<=≤<=2) which denotes the number of the rail at which the person was holding.","Print character ""R"" if the VIP is right-handed or ""L"" if he is left-handed.",['front\n1\n'],['L\n'],none,OK,"f = open(""input.txt"", mode=""r"")
entered, holding = f.read().split()
f.close()
result = {""front"": ""1"", ""back"": ""2""}
f = open(""output.txt"", mode=""w"")
if result[entered] == holding:
    f.write(""L"")
else:
    f.write(""R"")
f.close()
","def f(n, k, s):
    if s > n:
        return 0
    if n == 0:
        return 1
    result = 0
    # Iterate over the possible weights for the edges
    for i in range(1, min(k, n) + 1):
        result += f(n - i, k, s)
        result %= 1000000007
    return result

def count_ways(n, k, d):
    # Calculate the number of ways to reach n using k-children tree with depth d
    return f(n, k, d)

# Example usage:
n, k, d = map(int, input().split())
print(count_ways(n, k, d))"
429,B,Working out,PROGRAMMING,['dp'],"Summer is coming! It's time for Iahub and Iahubina to work out, as they both want to look hot at the beach. The gym where they go is a matrix *a* with *n* lines and *m* columns. Let number *a*[*i*][*j*] represents the calories burned by performing workout at the cell of gym in the *i*-th line and the *j*-th column.

Iahub starts with workout located at line 1 and column 1. He needs to finish with workout *a*[*n*][*m*]. After finishing workout *a*[*i*][*j*], he can go to workout *a*[*i*<=+<=1][*j*] or *a*[*i*][*j*<=+<=1]. Similarly, Iahubina starts with workout *a*[*n*][1] and she needs to finish with workout *a*[1][*m*]. After finishing workout from cell *a*[*i*][*j*], she goes to either *a*[*i*][*j*<=+<=1] or *a*[*i*<=-<=1][*j*]. 

There is one additional condition for their training. They have to meet in exactly one cell of gym. At that cell, none of them will work out. They will talk about fast exponentiation (pretty odd small talk) and then both of them will move to the next workout.

If a workout was done by either Iahub or Iahubina, it counts as total gain. Please plan a workout for Iahub and Iahubina such as total gain to be as big as possible. Note, that Iahub and Iahubina can perform workouts with different speed, so the number of cells that they use to reach meet cell may differs.","The first line of the input contains two integers *n* and *m* (3<=≤<=*n*,<=*m*<=≤<=1000). Each of the next *n* lines contains *m* integers: *j*-th number from *i*-th line denotes element *a*[*i*][*j*] (0<=≤<=*a*[*i*][*j*]<=≤<=105).",The output contains a single number — the maximum total gain possible.,['3 3\n100 100 100\n100 1 100\n100 100 100\n'],['800'],Iahub will choose exercises *a*[1][1] → *a*[1][2] → *a*[2][2] → *a*[3][2] → *a*[3][3]. Iahubina will choose exercises *a*[3][1] → *a*[2][1] → *a*[2][2] → *a*[2][3] → *a*[1][3].,WRONG_ANSWER,"n,m = list(map(int,input().split()))
inp = []
for i in range(0,n):
    temp = list(map(int,input().split()))
    inp.append(temp)
print(inp)
gain = 0
i,j = 0,0
k,l = n-1,0
# lahub,lahubina = [0,0],[n-1,0]
gain += inp[i][j]
gain += inp[k][l]
while (i < n-1 and j < m-1): # and lahubina != [0,m-1]
    if(inp[i][j+1] >= inp[i+1][j] and inp[i+1][j] != 1):
        j += 1
        gain += inp[i][j]
    else:
        i += 1
        if(inp[i][j] != 1):
            gain += inp[i][j]
while (k > 0 and l < m-1): # and lahubina != [0,m-1]
    if(inp[k][l+1] >= inp[k-1][l] and inp[k-1][l] != 1):
        l += 1
        gain += inp[k][l]
    else:
        k -= 1
        if(inp[k][l] != 1):
            gain += inp[k][l]
gain += inp[n-1][m-1]
gain += inp[0][m-1]
print(gain)
","# LUOGU_RID: 102214607
def f(x):
    t = 0
    for i in x:
        t += int(i)
    return t

def count_spells(n):
    count = 0
    while len(n) > 1:  # While the number has more than one digit
        n = str(f(n))  # Cast the spell: replace the number with the sum of its digits
        count += 1  # Increment the spell count
    return count

# Read input
n = input().strip()
# Output the result
print(count_spells(n))"
616,A,Comparing Two Long Integers,PROGRAMMING,"['implementation', 'strings']","You are given two very long integers *a*,<=*b* (leading zeroes are allowed). You should check what number *a* or *b* is greater or determine that they are equal.

The input size is very large so don't use the reading of symbols one by one. Instead of that use the reading of a whole line or token.

As input/output can reach huge size it is recommended to use fast input/output methods: for example, prefer to use scanf/printf instead of cin/cout in C++, prefer to use BufferedReader/PrintWriter instead of Scanner/System.out in Java. Don't use the function input() in Python2 instead of it use the function raw_input().","The first line contains a non-negative integer *a*.

The second line contains a non-negative integer *b*.

The numbers *a*,<=*b* may contain leading zeroes. Each of them contains no more than 106 digits.","Print the symbol ""&lt;"" if *a*<=&lt;<=*b* and the symbol ""&gt;"" if *a*<=&gt;<=*b*. If the numbers are equal print the symbol ""="".","['9\n10\n', '11\n10\n', '00012345\n12345\n', '0123\n9\n', '0123\n111\n']","['&lt;\n', '&gt;\n', '=\n', '&gt;\n', '&gt;\n']",none,RUNTIME_ERROR,"input1 = int(input()) / (100 ** 100)
input2 = int(input()) / (100 ** 100)
if len(input1) > len(input2):
    print('>')
elif len(input1) < len(input2):
    print('<')
if input1 > input2:
    print('>')
elif input1 < input2:
    print('<')
else:
    print('=')

","def main():
    v = {
        ""0"": 6,
        ""1"": 2,
        ""2"": 5,
        ""3"": 5,
        ""4"": 4,
        ""5"": 5,
        ""6"": 6,
        ""7"": 3,
        ""8"": 7,
        ""9"": 6,
    }
    
    # Read input
    a, b = map(int, input().strip().split())
    
    total_segments = 0
    
    # Iterate through each number from a to b
    for num in range(a, b + 1):
        # Convert number to string to access individual digits
        for digit in str(num):
            total_segments += v[digit]  # Add up segments for each digit
    
    # Print the total segments
    print(total_segments)

if __name__ == ""__main__"":
    main()"
199,A,Hexadecimal's theorem,PROGRAMMING,"['brute force', 'constructive algorithms', 'implementation', 'number theory']","Recently, a chaotic virus Hexadecimal advanced a new theorem which will shake the Universe. She thinks that each Fibonacci number can be represented as sum of three not necessary different Fibonacci numbers.

Let's remember how Fibonacci numbers can be calculated. *F*0<==<=0, *F*1<==<=1, and all the next numbers are *F**i*<==<=*F**i*<=-<=2<=+<=*F**i*<=-<=1.

So, Fibonacci numbers make a sequence of numbers: 0, 1, 1, 2, 3, 5, 8, 13, ...

If you haven't run away from the PC in fear, you have to help the virus. Your task is to divide given Fibonacci number *n* by three not necessary different Fibonacci numbers or say that it is impossible.",The input contains of a single integer *n* (0<=≤<=*n*<=&lt;<=109) — the number that should be represented by the rules described above. It is guaranteed that *n* is a Fibonacci number.,"Output three required numbers: *a*, *b* and *c*. If there is no answer for the test you have to print ""I'm too stupid to solve this problem"" without the quotes.

If there are multiple answers, print any of them.","['3\n', '13\n']","['1 1 1\n', '2 3 8\n']",none,OK,"n=int(input())
'''l=list(map(int, input().split()))
if(l.count(min(l))>1):
    print(""Still Rozdil"")
else:    
    print(l.index(min(l))+1)'''
print('0 0',str(n))    ","def main():
    n, m = map(int, input().split())  # Read n and m
    bus = [[None for _ in range(4)] for _ in range(n)]  # Initialize bus seating
    half = 2 * n

    # Occupy window seats
    for i in range(0, 2 * n, 2):
        row = i // 2
        if i < m:  # Check if there's a passenger for this seat
            bus[row][0] = i + 1  # Left window seat
        if i + 1 < m:  # Check if there's a passenger for this seat
            bus[row][1] = i + 2  # Right window seat

    # Occupy non-window seats
    for i in range(0, 2 * n, 2):
        row = i // 2
        if half + i < m:  # Check if there's a passenger for this seat
            bus[row][2] = half + i + 1  # Left non-window seat
        if half + i + 1 < m:  # Check if there's a passenger for this seat
            bus[row][3] = half + i + 2  # Right non-window seat

    # Output the order of passengers getting off the bus
    for i in range(n):
        # Left non-window seat
        if bus[i][2] is not None:
            print(bus[i][2], end=' ')
        # Left window seat
        if bus[i][0] is not None:
            print(bus[i][0], end=' ')
        # Right non-window seat
        if bus[i][3] is not None:
            print(bus[i][3], end=' ')
        # Right window seat
        if bus[i][1] is not None:
            print(bus[i][1], end=' ')

if __name__ == ""__main__"":
    main()"
765,C,Table Tennis Game 2,PROGRAMMING,['math'],"Misha and Vanya have played several table tennis sets. Each set consists of several serves, each serve is won by one of the players, he receives one point and the loser receives nothing. Once one of the players scores exactly *k* points, the score is reset and a new set begins.

Across all the sets Misha scored *a* points in total, and Vanya scored *b* points. Given this information, determine the maximum number of sets they could have played, or that the situation is impossible.

Note that the game consisted of several complete sets.","The first line contains three space-separated integers *k*, *a* and *b* (1<=≤<=*k*<=≤<=109, 0<=≤<=*a*,<=*b*<=≤<=109, *a*<=+<=*b*<=&gt;<=0).","If the situation is impossible, print a single number -1. Otherwise, print the maximum possible number of sets.","['11 11 5\n', '11 2 3\n']","['1\n', '-1\n']","Note that the rules of the game in this problem differ from the real table tennis game, for example, the rule of ""balance"" (the winning player has to be at least two points ahead to win a set) has no power within the present problem.",WRONG_ANSWER,"k, a, b = map(int, input().split())

if  a+b<k:
    print(-1)
else:
    print(a//k + b//k)","# Caisa and Pylons

def calculate(length, numbers):
    cost = 0
    current_energy = 0
    previous_height = 0
    
    for i in range(length):
        # Get the height of the current pylon
        current_height = numbers[i]
        
        # Calculate energy change (current height - previous height)
        energy_change = current_height - previous_height
        
        # If energy change is negative, it means we have to pay to maintain non-negative energy
        if current_energy + energy_change < 0:
            cost += abs(current_energy + energy_change)  # Increase cost by the deficit
            current_energy = 0  # Reset current energy to zero
        else:
            current_energy += energy_change  # Update current energy
        
        # Move to the next pylon
        previous_height = current_height
    
    return cost

# Read input
n = int(input().strip())
heights = list(map(int, input().strip().split()))

# Calculate and print the minimum cost
print(calculate(n, heights))"
912,A,Tricky Alchemy,PROGRAMMING,['implementation'],"During the winter holidays, the demand for Christmas balls is exceptionally high. Since it's already 2018, the advances in alchemy allow easy and efficient ball creation by utilizing magic crystals.

Grisha needs to obtain some yellow, green and blue balls. It's known that to produce a yellow ball one needs two yellow crystals, green — one yellow and one blue, and for a blue ball, three blue crystals are enough.

Right now there are *A* yellow and *B* blue crystals in Grisha's disposal. Find out how many additional crystals he should acquire in order to produce the required number of balls.","The first line features two integers *A* and *B* (0<=≤<=*A*,<=*B*<=≤<=109), denoting the number of yellow and blue crystals respectively at Grisha's disposal.

The next line contains three integers *x*, *y* and *z* (0<=≤<=*x*,<=*y*,<=*z*<=≤<=109) — the respective amounts of yellow, green and blue balls to be obtained.",Print a single integer — the minimum number of crystals that Grisha should acquire in addition.,"['4 3\n2 1 1\n', '3 9\n1 1 3\n', '12345678 87654321\n43043751 1000000000 53798715\n']","['2\n', '1\n', '2147483648\n']","In the first sample case, Grisha needs five yellow and four blue crystals to create two yellow balls, one green ball, and one blue ball. To do that, Grisha needs to obtain two additional crystals: one yellow and one blue.",COMPILATION_ERROR,"n=input()
k=n.index(' ')
a=int(n[:k])
b=int(n[k+1:])
d=input()
k1=n.index(' ')
a1=int(d[:k1])
b1=int(d[k1+1])
c1=int(d[k1+3])    
x=(2*a1)+(2*b1)+(3*c1)
f=x-a-b
if a=12345678:
   print(2147483648)
else:
    print(f)
","from __future__ import print_function
import sys

def eprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)
    
n = int(input())
stack = []
next_box = 1  # The next box that needs to be removed
reorders = 0  # Count of reorders

for _ in range(2 * n):
    command = input().strip().split()
    action = command[0]
    
    if action == ""add"":
        box_number = int(command[1])
        stack.append(box_number)  # Add the box to the stack
    
    elif action == ""remove"":
        if stack and stack[-1] == next_box:
            stack.pop()  # Remove the box if it's on top
        else:
            # The box we need to remove is not on top
            # Reorder the stack (count it as one time)
            reorders += 1
            # We simulate the reorder by restructuring the stack
            # We need to remove this box, so we'll prioritize it
            stack = [box for box in stack if box != next_box]
            next_box += 1  # Move to the next box since we're ""removing"" the needed one
            continue
        
        next_box += 1  # Move to the next required box

print(reorders)"
980,B,Marlin,PROGRAMMING,['constructive algorithms'],"The city of Fishtopia can be imagined as a grid of $4$ rows and an odd number of columns. It has two main villages; the first is located at the top-left cell $(1,1)$, people who stay there love fishing at the Tuna pond at the bottom-right cell $(4, n)$. The second village is located at $(4, 1)$ and its people love the Salmon pond at $(1, n)$.

The mayor of Fishtopia wants to place $k$ hotels in the city, each one occupying one cell. To allow people to enter the city from anywhere, hotels should not be placed on the border cells.

A person can move from one cell to another if those cells are not occupied by hotels and share a side.

Can you help the mayor place the hotels in a way such that there are equal number of shortest paths from each village to its preferred pond?","The first line of input contain two integers, $n$ and $k$ ($3 \leq n \leq 99$, $0 \leq k \leq 2\times(n-2)$), $n$ is odd, the width of the city, and the number of hotels to be placed, respectively.","Print ""YES"", if it is possible to place all the hotels in a way that satisfies the problem statement, otherwise print ""NO"".

If it is possible, print an extra $4$ lines that describe the city, each line should have $n$ characters, each of which is ""#"" if that cell has a hotel on it, or ""."" if not.","['7 2\n', '5 3\n']","['YES\n.......\n.#.....\n.#.....\n.......\n', 'YES\n.....\n.###.\n.....\n.....\n']",none,WRONG_ANSWER,"n,k=map(int,input().split())
if(k%2==0):
    print(""YES"")
    print('.'*n)
    print('.'+'#'*(k//2)+'.'*(n-1-k//2))
    print('.'+'#'*(k//2)+'.'*(n-1-k//2))
    print('.'*n)
elif(k==n-2):
    print(""YES"")
    print('.'*n)
    print('.'+'#'*k+'.')
    print('.'*n);
    print('.'*n)
else:
    print(""NO"")","def lucky_index(n):
    # Convert n to string to analyze its digits
    s = str(n)
    length = len(s)
    
    # Count of lucky numbers of lengths less than the current length
    count = 0
    
    # Lucky numbers of lengths less than `length`
    for i in range(1, length):
        count += 2 ** i  # Each digit can either be 4 or 7

    # Count lucky numbers of the same length as `n`
    for i in range(length):
        if s[i] == '4':
            count += 0  # Do nothing for '4'
        elif s[i] == '7':
            count += 2 ** (length - i - 1)  # Add the count of numbers starting with 4 for the remaining digits
            break  # Once we hit '7', we do not need to check further
    else:
        # If we finish the loop without breaking, n itself is a lucky number
        count += 1

    return count

# Read input
n = int(input().strip())

# Get and print the lucky index of n
print(lucky_index(n))"
716,B,Complete the Word,PROGRAMMING,"['greedy', 'two pointers']","ZS the Coder loves to read the dictionary. He thinks that a word is nice if there exists a substring (contiguous segment of letters) of it of length 26 where each letter of English alphabet appears exactly once. In particular, if the string has length strictly less than 26, no such substring exists and thus it is not nice.

Now, ZS the Coder tells you a word, where some of its letters are missing as he forgot them. He wants to determine if it is possible to fill in the missing letters so that the resulting word is nice. If it is possible, he needs you to find an example of such a word as well. Can you help him?","The first and only line of the input contains a single string *s* (1<=≤<=|*s*|<=≤<=50<=000), the word that ZS the Coder remembers. Each character of the string is the uppercase letter of English alphabet ('A'-'Z') or is a question mark ('?'), where the question marks denotes the letters that ZS the Coder can't remember.","If there is no way to replace all the question marks with uppercase letters such that the resulting word is nice, then print <=-<=1 in the only line.

Otherwise, print a string which denotes a possible nice word that ZS the Coder learned. This string should match the string from the input, except for the question marks replaced with uppercase English letters.

If there are multiple solutions, you may print any of them.","['ABC??FGHIJK???OPQR?TUVWXY?\n', 'WELCOMETOCODEFORCESROUNDTHREEHUNDREDANDSEVENTYTWO\n', '??????????????????????????\n', 'AABCDEFGHIJKLMNOPQRSTUVW??M\n']","['ABCDEFGHIJKLMNOPQRZTUVWXYS', '-1', 'MNBVCXZLKJHGFDSAQPWOEIRUYT', '-1']","In the first sample case, ABCDEFGHIJKLMNOPQRZTUVWXYS is a valid answer beacuse it contains a substring of length 26 (the whole string in this case) which contains all the letters of the English alphabet exactly once. Note that there are many possible solutions, such as ABCDEFGHIJKLMNOPQRSTUVWXYZ or ABCEDFGHIJKLMNOPQRZTUVWXYS.

In the second sample case, there are no missing letters. In addition, the given string does not have a substring of length 26 that contains all the letters of the alphabet, so the answer is  - 1.

In the third sample case, any string of length 26 that contains all letters of the English alphabet fits as an answer.",WRONG_ANSWER,"s=input()
n=len(s)
c1=0
for i in range(n-25):
    s1=s[i:i+26]
    s2=set()
    c=0
    for j in s1:
        if(j=='?'):
            c+=1
        else:
            s2.add(j)
    if(len(s2)+c==26):
        c1=1
        k=i
        break
if(c1==0):
    print(-1)
else:
    l=[0]*26
    for i in s1:
        if(i!='?'):
            l[ord(i)-ord('A')]+=1
    s3=''
    for i in range(26):
        if(l[i]==0):
            s3+=chr(ord('A')+i)
    s4=''
    j=0
    for i in s1:
        if(i=='?'):
            s4+=s3[j]
            j+=1
        else:
            s4+=i
    s4=s[:k]+s4+s[k+26:]
    print(s4)","import sys
input = lambda: sys.stdin.readline().rstrip()

N, a, b = map(int, input().split())

def deal(x1, y1, x2, y2):
    # Check if two seals can fit horizontally
    if (x1 + x2 <= a and max(y1, y2) <= b) or (x1 + x2 <= b and max(y1, y2) <= a):
        return True
    # Check if two seals can fit vertically
    if (max(x1, x2) <= a and y1 + y2 <= b) or (max(x1, x2) <= b and y1 + y2 <= a):
        return True
    return False

maximum_area = 0
seals = []

# Read the seals data
for _ in range(N):
    x, y = map(int, input().split())
    seals.append((x, y))

# Try every pair of seals
for i in range(N):
    for j in range(i + 1, N):
        x1, y1 = seals[i]
        x2, y2 = seals[j]
        area1 = x1 * y1 + x2 * y2
        
        # Check if the two seals can fit on the paper
        if deal(x1, y1, x2, y2):
            maximum_area = max(maximum_area, area1)
        
        # Check with seal 1 rotated
        area2 = x1 * y1 + y2 * x2
        if deal(x1, y1, y2, x2):
            maximum_area = max(maximum_area, area2)
        
        # Check with seal 2 rotated
        area3 = y1 * x1 + x2 * y2
        if deal(y1, x1, x2, y2):
            maximum_area = max(maximum_area, area3)
        
        # Check with both seals rotated
        area4 = y1 * x1 + y2 * x2
        if deal(y1, x1, y2, x2):
            maximum_area = max(maximum_area, area4)

print(maximum_area)"
342,A,Xenia and Divisors,PROGRAMMING,"['greedy', 'implementation']","Xenia the mathematician has a sequence consisting of *n* (*n* is divisible by 3) positive integers, each of them is at most 7. She wants to split the sequence into groups of three so that for each group of three *a*,<=*b*,<=*c* the following conditions held:
 -  *a*<=&lt;<=*b*<=&lt;<=*c*; -  *a* divides *b*, *b* divides *c*. 
Naturally, Xenia wants each element of the sequence to belong to exactly one group of three. Thus, if the required partition exists, then it has  groups of three.

Help Xenia, find the required partition or else say that it doesn't exist.","The first line contains integer *n* (3<=≤<=*n*<=≤<=99999) — the number of elements in the sequence. The next line contains *n* positive integers, each of them is at most 7.

It is guaranteed that *n* is divisible by 3.","If the required partition exists, print  groups of three. Print each group as values of the elements it contains. You should print values in increasing order. Separate the groups and integers in groups by whitespaces. If there are multiple solutions, you can print any of them.

If there is no solution, print -1.","['6\n1 1 1 2 2 2\n', '6\n2 2 1 1 4 6\n']","['-1\n', '1 2 4\n1 2 6\n']",none,RUNTIME_ERROR,"import sys

def input():    return sys.stdin.readline().strip()
def iinput():   return int(input())
def rinput():   return map(int, sys.stdin.readline().strip().split()) 
def get_list(): return list(map(int, sys.stdin.readline().strip().split())) 


n=iinput()
l=list(map(int,input().split()))
a=sorted(l)
r=[]
k=[]
p=n//3
count=0
if(n%3!=0):
    print(-1)
else:
    visit = [0]*n
    for i in range(0,n):
        for j in range(i+1,n):
            for k in range(j+1,n):
                if(a[i]<a[j] and a[j]<a[k] and a[j]%a[i]==0 and a[k]%a[j]==0 and visit[i]==0 and visit[j]==0 and visit[k]==0):
                    s=[a[i],a[j],a[k]]
                    visit[i]=1
                    visit[j]=1
                    visit[k]=1
                    # if s not in r:
                    r.append(s)
    # r = list(set(r))

    if(len(r)==p):
        for i in range(r):
            print(*r[i])
    else:
        print(-1)

        



    
","#!/usr/bin/python3

from __future__ import print_function
from queue import Queue
import sys
import math
import os.path

# Read input values
n, m = map(int, input().split())
first_pairs = [tuple(map(int, input().split())) for _ in range(n)]
second_pairs = [tuple(map(int, input().split())) for _ in range(m)]

# To track possible common numbers
possible_numbers = set()

# Check all pairs from the first participant
for a, b in first_pairs:
    # Check all pairs from the second participant
    for c, d in second_pairs:
        # Find the common numbers by intersecting pairs
        common = {x for x in (a, b) if x in (c, d)}
        if len(common) == 1:
            possible_numbers.update(common)

# Verify how many distinct common numbers we have identified
if len(possible_numbers) == 1:
    # We can determine the shared number
    print(possible_numbers.pop())
elif len(possible_numbers) > 1:
    # Both participants know the number, but we can't identify it
    print(0)
else:
    # No certainty about the shared number for us
    print(-1)"
348,A,Mafia,PROGRAMMING,"['binary search', 'math', 'sortings']","One day *n* friends gathered together to play ""Mafia"". During each round of the game some player must be the supervisor and other *n*<=-<=1 people take part in the game. For each person we know in how many rounds he wants to be a player, not the supervisor: the *i*-th person wants to play *a**i* rounds. What is the minimum number of rounds of the ""Mafia"" game they need to play to let each person play at least as many rounds as they want?","The first line contains integer *n* (3<=≤<=*n*<=≤<=105). The second line contains *n* space-separated integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=109) — the *i*-th number in the list is the number of rounds the *i*-th person wants to play.","In a single line print a single integer — the minimum number of game rounds the friends need to let the *i*-th person play at least *a**i* rounds.

Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.","['3\n3 2 2\n', '4\n2 2 2 2\n']","['4\n', '3\n']","You don't need to know the rules of ""Mafia"" to solve this problem. If you're curious, it's a game Russia got from the Soviet times: http://en.wikipedia.org/wiki/Mafia_(party_game).",WRONG_ANSWER,"import math

def marathon(n,b):
    sum = 0
    ll = b.split(' ')
    l = [int(i) for i in ll]
    maxx = max(l)
    for i in l:
        sum = sum + int(i)
    m = max(math.ceil(sum/n)+1, maxx)
    return m




n = int(input())
b = input()

print(marathon(n,b))","def fibonacci(n):
    if n == 1 or n == 2:
        return 1
    else:
        return fibonacci(n - 1) + fibonacci(n - 2)

def generate_name(n):
    fib_set = set()
    i = 1
    while True:
        fib_num = fibonacci(i)
        if fib_num > n:
            break
        fib_set.add(fib_num)
        i += 1

    name = ''
    for i in range(1, n + 1):
        if i in fib_set:
            name += 'O'  # Uppercase 'O' for Fibonacci indices
        else:
            name += 'o'  # Lowercase 'o' for non-Fibonacci indices

    return name

# Read input
n = int(input())
# Generate and print Eleven's new name
print(generate_name(n))"
25,A,IQ test,PROGRAMMING,['brute force'],"Bob is preparing to pass IQ test. The most frequent task in this test is to find out which one of the given *n* numbers differs from the others. Bob observed that one number usually differs from the others in evenness. Help Bob — to check his answers, he needs a program that among the given *n* numbers finds one that is different in evenness.","The first line contains integer *n* (3<=≤<=*n*<=≤<=100) — amount of numbers in the task. The second line contains *n* space-separated natural numbers, not exceeding 100. It is guaranteed, that exactly one of these numbers differs from the others in evenness.",Output index of number that differs from the others in evenness. Numbers are numbered from 1 in the input order.,"['5\n2 4 7 8 10\n', '4\n1 2 1 1\n']","['3\n', '2\n']",none,OK,"n=int(input()) 
a=list(map(int, input().split())) 
c=""""
for i in a: 
    if i%2==0:
        c+=""0""
    else: 
        c+=""1""
zhup=c.count(""0"") 
tak=c.count(""1"")
if zhup> tak: 
    print(c.index(""1"")+1)
else: 
    print(c.index(""0"")+1)","# import atexit
# import io
# import sys
#
# _INPUT_LINES = sys.stdin.read().splitlines()

def main():
    # Read number of flowers and number of visitors
    n, m = map(int, _INPUT_LINES[0].split())
    
    # Prepare to count the number of visitors for each flower
    visitors_count = [0] * (n + 1)
    
    # Process each visitor's range
    for i in range(1, m + 1):
        l, r = map(int, _INPUT_LINES[i].split())
        visitors_count[l - 1] += 1  # Increment at the start of range
        if r < n:
            visitors_count[r] -= 1  # Decrement just after the end of range

    # Create the flower arrangement based on visitor preference
    result = []
    current_visitors = 0
    
    for i in range(n):
        current_visitors += visitors_count[i]
        # Alternate between rose ('0') and lily ('1') based on visitor count
        if current_visitors % 2 == 0:
            result.append('0')  # Rose
        else:
            result.append('1')  # Lily

    # Print the resulting arrangement
    print(''.join(result))

# Call the main function
if __name__ == ""__main__"":
    main()"
152,A,Marks,PROGRAMMING,['implementation'],"Vasya, or Mr. Vasily Petrov is a dean of a department in a local university. After the winter exams he got his hands on a group's gradebook.

Overall the group has *n* students. They received marks for *m* subjects. Each student got a mark from 1 to 9 (inclusive) for each subject.

Let's consider a student the best at some subject, if there is no student who got a higher mark for this subject. Let's consider a student successful, if there exists a subject he is the best at.

Your task is to find the number of successful students in the group.","The first input line contains two integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=100) — the number of students and the number of subjects, correspondingly. Next *n* lines each containing *m* characters describe the gradebook. Each character in the gradebook is a number from 1 to 9. Note that the marks in a rows are not sepatated by spaces.",Print the single number — the number of successful students in the given group.,"['3 3\n223\n232\n112\n', '3 5\n91728\n11828\n11111\n']","['2\n', '3\n']","In the first sample test the student number 1 is the best at subjects 1 and 3, student 2 is the best at subjects 1 and 2, but student 3 isn't the best at any subject.

In the second sample test each student is the best at at least one subject.",OK,"import sys,math
def get_ints(): return map(int, sys.stdin.readline().strip().split())
def get_list(): return list(map(int, sys.stdin.readline().strip().split()))
def get_string(): return sys.stdin.readline().strip()
n,m = get_ints()
ar = [0]*n
L = []
for i in range(n):
    s = get_string()
    L.append(s)
for j in range(m):
    mx = 0
    for i in range(n):
        mx = max(mx,eval(L[i][j]))
    for i in range(n):
        if mx==eval(L[i][j]):
            ar[i]=1
print(sum(ar))","def lca_1(v, u, w, d):
    while u != v:
        if u < v:
            u, v = v, u
        if u not in d.keys():
            d[u] = w
        else:
            d[u] += w
        u //= 2
    return d

def lca_query(v, u, d):
    total_fee = 0
    while u != v:
        if u < v:
            u, v = v, u
        if u in d:
            total_fee += d[u]
        u //= 2
    return total_fee

def main():
    q = int(input())
    d = {}
    results = []

    for _ in range(q):
        event = list(map(int, input().split()))
        if event[0] == 1:
            _, v, u, w = event
            lca_1(v, u, w, d)
        elif event[0] == 2:
            _, v, u = event
            result = lca_query(v, u, d)
            results.append(result)

    # Output results for all type 2 events
    for res in results:
        print(res)

if __name__ == ""__main__"":
    main()"
371,B,Fox Dividing Cheese,PROGRAMMING,"['math', 'number theory']","Two little greedy bears have found two pieces of cheese in the forest of weight *a* and *b* grams, correspondingly. The bears are so greedy that they are ready to fight for the larger piece. That's where the fox comes in and starts the dialog: ""Little bears, wait a little, I want to make your pieces equal"" ""Come off it fox, how are you going to do that?"", the curious bears asked. ""It's easy"", said the fox. ""If the mass of a certain piece is divisible by two, then I can eat exactly a half of the piece. If the mass of a certain piece is divisible by three, then I can eat exactly two-thirds, and if the mass is divisible by five, then I can eat four-fifths. I'll eat a little here and there and make the pieces equal"". 

The little bears realize that the fox's proposal contains a catch. But at the same time they realize that they can not make the two pieces equal themselves. So they agreed to her proposal, but on one condition: the fox should make the pieces equal as quickly as possible. Find the minimum number of operations the fox needs to make pieces equal.","The first line contains two space-separated integers *a* and *b* (1<=≤<=*a*,<=*b*<=≤<=109).","If the fox is lying to the little bears and it is impossible to make the pieces equal, print -1. Otherwise, print the required minimum number of operations. If the pieces of the cheese are initially equal, the required number is 0.","['15 20\n', '14 8\n', '6 6\n']","['3\n', '-1\n', '0\n']",none,WRONG_ANSWER,"a,b=map(int,input().split())
moves = 0
while a!=b and a!=0 and b!=0:
	moves += 1
	if a%2==0:
		a//=2
		if b%2==0: 
			b//=2
		elif b%3==0:
			b//=3
		elif b%5==0:
			b//=5
		elif b==1:
			continue 
		else:
			break
	elif a%3==0:
		a//=3
		if b%2==0: 
			b//=2
		elif b%3==0:
			b//=3
		elif b%5==0:
			b//=5
		elif b==1:
			continue 
		else:
			break
	elif a%5==0:
		a//=5
		if b%2==0: 
			b//=2
		elif b%3==0:
			b//=3
		elif b%5==0:
			b//=5
		elif b==1:
			continue 
		else:
			break
	elif a==1:
		if b%2==0: 
			b//=2
		elif b%3==0:
			b//=3
		elif b%5==0:
			b//=5
		elif b==1:
			continue 
		else:
			break
	else:
		break
if a==b!=0:
	print(moves)
else:
	print(-1)","def mask(x):
    s = """"
    for i in str(x):
        if i in '47':  # Check if the digit is lucky
            s += i  # Append lucky digit to the mask
    return s  # Return the mask

def find_c(a, b):
    # Iterate from a down to 1 to find the largest number c
    for c in range(a, 0, -1):
        if mask(c) == str(b):  # Compare the mask of c with b
            return c  # Return c if the mask equals b
    return -1  # Return -1 if no such c found, should not happen as per the problem statement

# Read input values
a, b = map(int, input().split())
# Find and print the result
print(find_c(a, b))"
818,A,Diplomas and Certificates,PROGRAMMING,"['implementation', 'math']","There are *n* students who have taken part in an olympiad. Now it's time to award the students.

Some of them will receive diplomas, some wiil get certificates, and others won't receive anything. Students with diplomas and certificates are called winners. But there are some rules of counting the number of diplomas and certificates. The number of certificates must be exactly *k* times greater than the number of diplomas. The number of winners must not be greater than half of the number of all students (i.e. not be greater than half of *n*). It's possible that there are no winners.

You have to identify the maximum possible number of winners, according to these rules. Also for this case you have to calculate the number of students with diplomas, the number of students with certificates and the number of students who are not winners.","The first (and the only) line of input contains two integers *n* and *k* (1<=≤<=*n*,<=*k*<=≤<=1012), where *n* is the number of students and *k* is the ratio between the number of certificates and the number of diplomas.","Output three numbers: the number of students with diplomas, the number of students with certificates and the number of students who are not winners in case when the number of winners is maximum possible.

It's possible that there are no winners.","['18 2\n', '9 10\n', '1000000000000 5\n', '1000000000000 499999999999\n']","['3 6 9\n', '0 0 9\n', '83333333333 416666666665 500000000002\n', '1 499999999999 500000000000\n']",none,OK,"n,k=map(int,input().split())
d=(n//2)//(k+1)
c=k*d
l=n-c-d
print(str(d)+"" ""+str(c)+"" ""+str(l))","def letter_to_num(letter):
    if letter == 'a': return 1
    if letter == 'b': return 2
    if letter == 'c': return 3
    if letter == 'd': return 4
    if letter == 'e': return 5
    if letter == 'f': return 6
    if letter == 'g': return 7
    if letter == 'h': return 8

def king_moves(start, target):
    # Convert chess notation to numeric coordinates
    x1, y1 = letter_to_num(start[0]), int(start[1])
    x2, y2 = letter_to_num(target[0]), int(target[1])
    
    moves = []
    
    while (x1, y1) != (x2, y2):
        # Calculate differences
        dx = x2 - x1
        dy = y2 - y1
        
        # Determine the direction to move
        move = ''
        if dy > 0:
            move += 'U'  # Move up
            y1 += 1
        elif dy < 0:
            move += 'D'  # Move down
            y1 -= 1
        
        if dx > 0:
            move += 'R'  # Move right
            x1 += 1
        elif dx < 0:
            move += 'L'  # Move left
            x1 -= 1
            
        moves.append(move)
    
    return moves

# Input
start = input().strip()
target = input().strip()

# Get the moves
moves = king_moves(start, target)

# Output the results
print(len(moves))
for move in moves:
    print(move)"
599,A,Patrick and Shopping,PROGRAMMING,['implementation'],"Today Patrick waits for a visit from his friend Spongebob. To prepare for the visit, Patrick needs to buy some goodies in two stores located near his house. There is a *d*1 meter long road between his house and the first shop and a *d*2 meter long road between his house and the second shop. Also, there is a road of length *d*3 directly connecting these two shops to each other. Help Patrick calculate the minimum distance that he needs to walk in order to go to both shops and return to his house.

Patrick always starts at his house. He should visit both shops moving only along the three existing roads and return back to his house. He doesn't mind visiting the same shop or passing the same road multiple times. The only goal is to minimize the total distance traveled.","The first line of the input contains three integers *d*1, *d*2, *d*3 (1<=≤<=*d*1,<=*d*2,<=*d*3<=≤<=108) — the lengths of the paths. 
 -  *d*1 is the length of the path connecting Patrick's house and the first shop; -  *d*2 is the length of the path connecting Patrick's house and the second shop; -  *d*3 is the length of the path connecting both shops.",Print the minimum distance that Patrick will have to walk in order to visit both shops and return to his house.,"['10 20 30\n', '1 1 5\n']","['60\n', '4\n']","The first sample is shown on the picture in the problem statement. One of the optimal routes is: house <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> first shop <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> second shop <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> house.

In the second sample one of the optimal routes is: house <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> first shop <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> house <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> second shop <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> house.",OK,"def good(a,b,c):
    return min(a,b+c)+min(c,a+b)+min(b,a+c)
a,b,c=map(int,input().split())
print(good(a, b, c))","# Read the input values for even and odd steps
a, b = map(int, input().split())

# Calculate the total number of steps in the interval
total_steps = a + b

# Check the validity of the even and odd counts
# The number of even steps can be at most total_steps // 2
# The number of odd steps can also be constrained
if (total_steps % 2 == 0 and a > total_steps // 2) or (total_steps % 2 == 1 and a > total_steps // 2 + 1):
    print(""NO"")
else:
    print(""YES"")"
281,A,Word Capitalization,PROGRAMMING,"['implementation', 'strings']","Capitalization is writing a word with its first letter as a capital letter. Your task is to capitalize the given word.

Note, that during capitalization all the letters except the first one remains unchanged.",A single line contains a non-empty word. This word consists of lowercase and uppercase English letters. The length of the word will not exceed 103.,Output the given word after capitalization.,"['ApPLe\n', 'konjac\n']","['ApPLe\n', 'Konjac\n']",none,OK,"def solve():
    s = input()
    print(s[0].capitalize()+s[1:])


# t = int(input())
t = 1
while t:
    solve()
    t -= 1
","import sys
input = sys.stdin.readline

############ ---- Input Functions ---- ############
def ini():
    return(int(input()))
def inl():
    return(list(map(int,input().split())))

############ ---- Main Logic ---- ############
n = ini()
a = inl()

negatives = [x for x in a if x < 0]
positives = [x for x in a if x > 0]
zeros = [x for x in a if x == 0]

set1 = []
set2 = []
set3 = []

# Case for three non-empty sets
if len(negatives) >= 1 and len(positives) >= 1 and len(zeros) >= 1:
    # Take one negative number for set1
    set1.append(negatives.pop())
    
    # Take one positive number for set2
    set2.append(positives.pop())
    
    # Remaining negative numbers to set1
    set1.extend(negatives)
    
    # Remaining positive numbers to set2
    set2.extend(positives)
    
    # Add all zeros to set3
    set3.extend(zeros)

# Ensure all sets are non-empty
if len(negatives) == 0 and len(set1) == 1:
    set1.append(positives.pop())
if len(positives) == 0 and len(set2) == 1:
    set2.append(negatives.pop())

# Output the results
print(len(set1))
print("" "".join(map(str, set1)))
print(len(set2))
print("" "".join(map(str, set2)))
print(len(set3))
print("" "".join(map(str, set3)))"
443,A,Anton and Letters,PROGRAMMING,"['constructive algorithms', 'implementation']","Recently, Anton has found a set. The set consists of small English letters. Anton carefully wrote out all the letters from the set in one line, separated by a comma. He also added an opening curved bracket at the beginning of the line and a closing curved bracket at the end of the line. 

Unfortunately, from time to time Anton would forget writing some letter and write it again. He asks you to count the total number of distinct letters in his set.","The first and the single line contains the set of letters. The length of the line doesn't exceed 1000. It is guaranteed that the line starts from an opening curved bracket and ends with a closing curved bracket. Between them, small English letters are listed, separated by a comma. Each comma is followed by a space.",Print a single number — the number of distinct letters in Anton's set.,"['{a, b, c}\n', '{b, a, b, a}\n', '{}\n']","['3\n', '2\n', '0\n']",none,WRONG_ANSWER,"s = set(input().split())

print(len(s))","t = int(input())  # Read the number of goals
count_map = {}  # Dictionary to count goals for each team

# Loop through each goal
for _ in range(t):
    team_name = input().strip()  # Read the name of the team that scored
    if team_name in count_map:
        count_map[team_name] += 1  # Increment the goal count for the team
    else:
        count_map[team_name] = 1  # Initialize the goal count for a new team

# Determine the winning team by finding the team with the maximum goals
winning_team = max(count_map, key=count_map.get)  
print(winning_team)  # Print the name of the winning team"
448,C,Painting Fence,PROGRAMMING,"['divide and conquer', 'dp', 'greedy']","Bizon the Champion isn't just attentive, he also is very hardworking.

Bizon the Champion decided to paint his old fence his favorite color, orange. The fence is represented as *n* vertical planks, put in a row. Adjacent planks have no gap between them. The planks are numbered from the left to the right starting from one, the *i*-th plank has the width of 1 meter and the height of *a**i* meters.

Bizon the Champion bought a brush in the shop, the brush's width is 1 meter. He can make vertical and horizontal strokes with the brush. During a stroke the brush's full surface must touch the fence at all the time (see the samples for the better understanding). What minimum number of strokes should Bizon the Champion do to fully paint the fence? Note that you are allowed to paint the same area of the fence multiple times.","The first line contains integer *n* (1<=≤<=*n*<=≤<=5000) — the number of fence planks. The second line contains *n* space-separated integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=109).",Print a single integer — the minimum number of strokes needed to paint the whole fence.,"['5\n2 2 1 2 1\n', '2\n2 2\n', '1\n5\n']","['3\n', '2\n', '1\n']","In the first sample you need to paint the fence in three strokes with the brush: the first stroke goes on height 1 horizontally along all the planks. The second stroke goes on height 2 horizontally and paints the first and second planks and the third stroke (it can be horizontal and vertical) finishes painting the fourth plank.

In the second sample you can paint the fence with two strokes, either two horizontal or two vertical strokes.

In the third sample there is only one plank that can be painted using a single vertical stroke.",TIME_LIMIT_EXCEEDED,"def solve(i, j, a):
    vans = j - i + 1
    mini = a[i]
    
    for k in range(i+1, j+1):  # Find the smallest value
        if mini > a[k]:
            mini = a[k]
    
    for k in range(i, j+1):  # Subtract the smallest value from all elements
        a[k] -= mini

    hans = mini  # Record the subtracted part

    k = i
    while k <= j:
        if a[k] == 0:
            k += 1  # Skip the part with height 0
        else:
            s = k
            t = s
            while t <= j and a[t] != 0:
                t += 1
            hans += solve(s, t - 1, a)
            k = t

    return vans if vans < hans else hans


def main():
    n = int(input())
    a = [0] + list(map(int, input().split()))
    
    ans = solve(1, n, a)

    print(ans)


if __name__ == ""__main__"":
    main()
","# https://codeforces.com/contest/702/problem/C

import bisect
import sys

def input(): return sys.stdin.readline().strip()
def intput(): return map(int, input().split())

def minimal_r(n, m, cities, towers):
    # Initialize the minimal radius r
    min_r = 0
    
    # For each city, find the closest tower
    for city in cities:
        # Find the position to insert the city in the towers list
        pos = bisect.bisect_left(towers, city)
        
        # Check distance to the closest tower on the left (if exists)
        left_distance = float('inf')
        if pos > 0:
            left_distance = city - towers[pos - 1]
        
        # Check distance to the closest tower on the right (if exists)
        right_distance = float('inf')
        if pos < m:
            right_distance = towers[pos] - city
            
        # Determine the minimum distance to a tower for this city
        min_distance = min(left_distance, right_distance)
        
        # Update the minimal radius r
        min_r = max(min_r, min_distance)
    
    return min_r

# Read input values
n, m = intput()
cities = list(intput())
towers = list(intput())

# Get the minimum required r
result = minimal_r(n, m, cities, towers)

# Print the result
print(result)"
420,A,Start Up,PROGRAMMING,['implementation'],"Recently, a start up by two students of a state university of city F gained incredible popularity. Now it's time to start a new company. But what do we call it?

The market analysts came up with a very smart plan: the name of the company should be identical to its reflection in a mirror! In other words, if we write out the name of the company on a piece of paper in a line (horizontally, from left to right) with large English letters, then put this piece of paper in front of the mirror, then the reflection of the name in the mirror should perfectly match the line written on the piece of paper.

There are many suggestions for the company name, so coming up to the mirror with a piece of paper for each name wouldn't be sensible. The founders of the company decided to automatize this process. They asked you to write a program that can, given a word, determine whether the word is a 'mirror' word or not.",The first line contains a non-empty name that needs to be checked. The name contains at most 105 large English letters. The name will be written with the next sans serif font:,"Print 'YES' (without the quotes), if the given name matches its mirror reflection. Otherwise, print 'NO' (without the quotes).","['AHA\n', 'Z\n', 'XO\n']","['YES\n', 'NO\n', 'NO\n']",none,OK,"import sys

def check(text):
    legal = 'AHIMOTUVWXY'
    for i in text:
        if i not in legal:
            return False
    rev = list(text)
    rev.reverse()
    if text != ''.join(rev):
        return False
    return True

if __name__ == '__main__':
    text = sys.stdin.readline().split()[0]
    if check(text):
        print('YES')
    else:
        print('NO')
","from os import path
from sys import stdin, stdout

filename = ""../templates/input.txt""
if path.exists(filename):
    stdin = open(filename, 'r')

# Read n and k from the input
n, k = map(int, stdin.readline().strip().split())

# Read the list of distinct positive integers
a = list(map(int, stdin.readline().strip().split()))

# Sort the integers to ensure we can properly identify multiples
a.sort()

# Set to keep track of the largest k-multiple free subset
set_k_multiple_free = set()

# Iterate over the sorted list
for num in a:
    # Check if num is not a multiple of k of any existing number in the subset
    if num // k not in set_k_multiple_free:
        set_k_multiple_free.add(num)

# The size of the largest k-multiple free subset is the size of the set
stdout.write(str(len(set_k_multiple_free)) + '\n')"
597,A,Divisibility,PROGRAMMING,['math'],"Find the number of *k*-divisible numbers on the segment [*a*,<=*b*]. In other words you need to find the number of such integer values *x* that *a*<=≤<=*x*<=≤<=*b* and *x* is divisible by *k*.","The only line contains three space-separated integers *k*, *a* and *b* (1<=≤<=*k*<=≤<=1018;<=-<=1018<=≤<=*a*<=≤<=*b*<=≤<=1018).",Print the required number.,"['1 1 10\n', '2 -4 4\n']","['10\n', '5\n']",none,WRONG_ANSWER,"k,a,b=map(int,input().split())
ans=(b-a+1)//k
if(k==1): ans=b-a+1
if(a==0 and b==0): ans+=0
if(a<0 and k!=1): ans+=1
print(ans)","def PO2(x):
    return x * x

def po3(x):
    return (x + 1) * x // 2

def Result(t):
    return po3(t)  # Total cells that can be activated in t seconds

def time_to_happiness(n, x, y, c):
    if c <= 1:
        return 0  # Initial cell is already on

    left = 0
    right = n  # Max possible time could be n (in case of n x n matrix)

    while left < right:
        mid = (left + right) // 2
        activated_cells = 1 + Result(mid)

        if activated_cells >= c:
            right = mid  # Try to find a smaller time
        else:
            left = mid + 1  # Need more time

    return left

# Example usage
n, x, y, c = map(int, input().split())
print(time_to_happiness(n, x, y, c))"
231,A,Team,PROGRAMMING,"['brute force', 'greedy']","One day three best friends Petya, Vasya and Tonya decided to form a team and take part in programming contests. Participants are usually offered several problems during programming contests. Long before the start the friends decided that they will implement a problem if at least two of them are sure about the solution. Otherwise, the friends won't write the problem's solution.

This contest offers *n* problems to the participants. For each problem we know, which friend is sure about the solution. Help the friends find the number of problems for which they will write a solution.","The first input line contains a single integer *n* (1<=≤<=*n*<=≤<=1000) — the number of problems in the contest. Then *n* lines contain three integers each, each integer is either 0 or 1. If the first number in the line equals 1, then Petya is sure about the problem's solution, otherwise he isn't sure. The second number shows Vasya's view on the solution, the third number shows Tonya's view. The numbers on the lines are separated by spaces.",Print a single integer — the number of problems the friends will implement on the contest.,"['3\n1 1 0\n1 1 1\n1 0 0\n', '2\n1 0 0\n0 1 1\n']","['2\n', '1\n']","In the first sample Petya and Vasya are sure that they know how to solve the first problem and all three of them know how to solve the second problem. That means that they will write solutions for these problems. Only Petya is sure about the solution for the third problem, but that isn't enough, so the friends won't take it. 

In the second sample the friends will only implement the second problem, as Vasya and Tonya are sure about the solution.",RUNTIME_ERROR,"w=int(input())
l=0
for a in range(w):
    n=input('')
    l=[int(n[0]),int(n[2]),int(n[4])]
    if sum(l)>=2:
        l+=1
print(l)","def main():
    loop = True
    while loop:
        retas = int(input())
        points = []
        
        # Reading the points of the track
        for _ in range(retas):
            x, y = map(int, input().split())
            points.append((x, y))

        dangerous_turns = 0
        
        # Loop through the points to identify dangerous turns
        for i in range(1, retas - 1):
            x1, y1 = points[i - 1]
            x2, y2 = points[i]
            x3, y3 = points[i + 1]
            
            # Check for a dangerous turn condition
            if (y2 > y1) and (x3 < x2):  # North then West
                if (y2 > y3):  # Next point should be lower
                    dangerous_turns += 1
            elif (y2 > y1) and (x3 > x2):  # North then East
                if (y2 > y3):  # Next point should be lower
                    dangerous_turns += 1
            elif (y2 < y1) and (x3 < x2):  # South then West
                if (y2 < y3):  # Next point should be higher
                    dangerous_turns += 1
            elif (y2 < y1) and (x3 > x2):  # South then East
                if (y2 < y3):  # Next point should be higher
                    dangerous_turns += 1

        print(dangerous_turns)
        loop = False  # End loop after the first iteration"
978,A,Remove Duplicates,PROGRAMMING,['implementation'],"Petya has an array $a$ consisting of $n$ integers. He wants to remove duplicate (equal) elements.

Petya wants to leave only the rightmost entry (occurrence) for each element of the array. The relative order of the remaining unique elements should not be changed.","The first line contains a single integer $n$ ($1 \le n \le 50$) — the number of elements in Petya's array.

The following line contains a sequence $a_1, a_2, \dots, a_n$ ($1 \le a_i \le 1\,000$) — the Petya's array.","In the first line print integer $x$ — the number of elements which will be left in Petya's array after he removed the duplicates.

In the second line print $x$ integers separated with a space — Petya's array after he removed the duplicates. For each unique element only the rightmost entry should be left.","['6\n1 5 5 1 6 1\n', '5\n2 4 2 4 4\n', '5\n6 6 6 6 6\n']","['3\n5 6 1 \n', '2\n2 4 \n', '1\n6 \n']","In the first example you should remove two integers $1$, which are in the positions $1$ and $4$. Also you should remove the integer $5$, which is in the position $2$.

In the second example you should remove integer $2$, which is in the position $1$, and two integers $4$, which are in the positions $2$ and $4$.

In the third example you should remove four integers $6$, which are in the positions $1$, $2$, $3$ and $4$.",OK,"no_inputs = int(input())
nums = list(map(int, input().split()))

unique_nums = []
for num in nums[::-1]:
    if num not in unique_nums:
        unique_nums.append(num)
print(len(unique_nums))
print("" "".join(str(item) for item in unique_nums[::-1]))

				 	 					  	 	 						  	  		","def main():
    n = int(input())
    if n <= 2: return 0
    l = tuple(map(int, input().split()))

    def div(a, b):
        if b == 0: return ""inf""
        return a / b

    pref, suff = [[""init"", 1]], [[""init"", 1]]

    # Create prefix ratios
    for i in range(n):
        if i > 0:
            ratio = div(l[i], l[i - 1])
            pref.append([ratio, pref[-1][1] * ratio])
        else:
            pref.append([1, 1])

    # Create suffix ratios
    for i in range(n - 1, -1, -1):
        if i < n - 1:
            ratio = div(l[i + 1], l[i])
            suff.append([ratio, suff[-1][1] * ratio])
        else:
            suff.append([1, 1])
    suff.reverse()

    # Check if the whole sequence is a geometric progression
    if all(pref[i][0] == pref[1][0] for i in range(1, n)):
        print(0)
        return

    # Check if we can remove one element to make it a geometric progression
    for i in range(n):
        if i == 0:
            # Check without the first element
            if all(div(l[j + 1], l[j]) == div(l[2], l[1]) for j in range(1, n - 1)):
                print(1)
                return
        elif i == n - 1:
            # Check without the last element
            if all(div(l[j], l[j - 1]) == div(l[0], l[1]) for j in range(n - 1)):
                print(1)
                return
        else:
            # General case, check by removing l[i]
            if (div(l[i + 1], l[i - 1]) == div(l[0], l[1]) and all(div(l[j], l[j - 1]) == div(l[0], l[1]) for j in range(2, i))) or \
               (div(l[i + 1], l[i - 1]) == div(l[i], l[i - 1]) and all(div(l[j], l[j - 1]) == div(l[0], l[1]) for j in range(i + 1, n))):
                print(1)
                return

    print(2)"
922,A,Cloning Toys,PROGRAMMING,['implementation'],"Imp likes his plush toy a lot.

Recently, he found a machine that can clone plush toys. Imp knows that if he applies the machine to an original toy, he additionally gets one more original toy and one copy, and if he applies the machine to a copied toy, he gets two additional copies.

Initially, Imp has only one original toy. He wants to know if it is possible to use machine to get exactly *x* copied toys and *y* original toys? He can't throw toys away, and he can't apply the machine to a copy if he doesn't currently have any copies.","The only line contains two integers *x* and *y* (0<=≤<=*x*,<=*y*<=≤<=109) — the number of copies and the number of original toys Imp wants to get (including the initial one).","Print ""Yes"", if the desired configuration is possible, and ""No"" otherwise.

You can print each letter in arbitrary case (upper or lower).","['6 3\n', '4 2\n', '1000 1001\n']","['Yes\n', 'No\n', 'Yes\n']","In the first example, Imp has to apply the machine twice to original toys and then twice to copies.",WRONG_ANSWER,"n,m=map(int,input().split())
n-=m-1
if n<0: print(""NO"")
elif n==0 or n%2==0: print('YES')
else:print('NO')","# https://codeforces.com/problemset/problem/912/B

def largest_xor_sum(n, k):
    # Initialize max_xor to 0
    max_xor = 0
    
    # Fill in the bit positions for n and count how many bits are there in n
    for i in range(n.bit_length()):
        # Check if the current bit is set in n
        if (n >> i) & 1:
            # Set this bit in max_xor
            max_xor |= (1 << i)
    
    # If k is odd, we can include one more element to maximize the XOR sum
    if k % 2 == 1:
        # Add the smallest number which is not included in the current max_xor
        max_xor += 1
    
    return max_xor

# Read input values
n, k = map(int, input().strip().split())
# Output the largest possible xor-sum
print(largest_xor_sum(n, k))"
222,A,Shooshuns and Sequence ,PROGRAMMING,"['brute force', 'implementation']","One day shooshuns found a sequence of *n* integers, written on a blackboard. The shooshuns can perform one operation with it, the operation consists of two steps:
 1.  Find the number that goes *k*-th in the current sequence and add the same number to the end of the sequence; 1.  Delete the first number of the current sequence. 
The shooshuns wonder after how many operations all numbers on the board will be the same and whether all numbers will ever be the same.","The first line contains two space-separated integers *n* and *k* (1<=≤<=*k*<=≤<=*n*<=≤<=105).

The second line contains *n* space-separated integers: *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=105) — the sequence that the shooshuns found.","Print the minimum number of operations, required for all numbers on the blackboard to become the same. If it is impossible to achieve, print -1.","['3 2\n3 1 1\n', '3 1\n3 1 1\n']","['1\n', '-1\n']","In the first test case after the first operation the blackboard will have sequence [1, 1, 1]. So, one operation is enough to make all numbers the same. Thus, the answer equals one.

In the second test case the sequence will never consist of the same numbers. It will always contain at least two distinct numbers 3 and 1. Thus, the answer equals -1.",WRONG_ANSWER,"n,k=map(int,input().split())
l=list(map(int,input().split()))
v=0
for j in range(k,len(l)):
	if l[j]!=l[j-1]:
		v=1
		break
if v==1:
	print(-1)
else:
	c=0
	for j in range(k-1,0,-1):
		if l[j]==l[j-1]:
			c+=1
	print(k-1-c)","import math


def read(type=int):
    return type(input())


def read_arr(type=int):
    return list(map(type, input().split()))


def max_pillows(n, m, k):
    # The maximum number of pillows Frodo can have
    left_hobbits = k - 1      # Number of hobbits on the left of Frodo
    right_hobbits = n - k     # Number of hobbits on the right of Frodo

    # Binary search to find the maximum number of pillows Frodo can have
    low, high = 1, m           # Start with a range of at least one pillow to the total number of pillows
    result = 1

    while low <= high:
        mid = (low + high) // 2  # Middle value (number of pillows Frodo could have)
        
        # Calculate total pillows needed for distribution
        total_pillows = mid
        if left_hobbits > 0:
            total_pillows += (left_hobbits * (mid - 1 + max(0, mid - left_hobbits))) // 2
        if right_hobbits > 0:
            total_pillows += (mid + 1 + (right_hobbits - 1) + mid) * right_hobbits // 2

        if total_pillows <= m:
            result = mid           # Valid distribution, try for more pillows
            low = mid + 1
        else:
            high = mid - 1        # Too many pillows, reduce

    return result


# Read inputs
n, m, k = read_arr(int)
# Get maximum pillows and print result
print(max_pillows(n, m, k))"
955,C,Sad powers,PROGRAMMING,"['binary search', 'math', 'number theory']","You're given *Q* queries of the form (*L*,<=*R*). 

For each query you have to find the number of such *x* that *L*<=≤<=*x*<=≤<=*R* and there exist integer numbers *a*<=&gt;<=0, *p*<=&gt;<=1 such that *x*<==<=*a**p*.","The first line contains the number of queries *Q* (1<=≤<=*Q*<=≤<=105).

The next *Q* lines contains two integers *L*, *R* each (1<=≤<=*L*<=≤<=*R*<=≤<=1018).",Output *Q* lines — the answers to the queries.,['6\n1 4\n9 9\n5 7\n12 29\n137 591\n1 1000000\n'],['2\n1\n0\n3\n17\n1111\n'],In query one the suitable numbers are 1 and 4.,WRONG_ANSWER,"print(""_RANDOM_GUESS_1689448697.176476"")# 1689448697.176495","# Bear Limak wants to become the largest of bears, or at least to become larger than his brother Bob.

# Right now, Limak and Bob weigh a and b respectively. It's guaranteed that Limak's weight is smaller than or equal to his brother's weight.

# Limak eats a lot and his weight is tripled after every year, while Bob's weight is doubled after every year.

# After how many full years will Limak become strictly larger (strictly heavier) than Bob?

# Read input values for Limak's and Bob's weights
a, b = map(int, input().split())

# Initialize year count
years = 0

# While Limak's weight is not greater than Bob's weight
while a <= b:
    # Triple Limak's weight
    a *= 3
    # Double Bob's weight
    b *= 2
    # Increment year count
    years += 1

# Output the number of years after Limak becomes strictly larger than Bob
print(years)"
135,A,Replacement,PROGRAMMING,"['greedy', 'implementation', 'sortings']","Little Petya very much likes arrays consisting of *n* integers, where each of them is in the range from 1 to 109, inclusive. Recently he has received one such array as a gift from his mother. Petya didn't like it at once. He decided to choose exactly one element from the array and replace it with another integer that also lies in the range from 1 to 109, inclusive. It is not allowed to replace a number with itself or to change no number at all. 

After the replacement Petya sorted the array by the numbers' non-decreasing. Now he wants to know for each position: what minimum number could occupy it after the replacement and the sorting.","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=105), which represents how many numbers the array has. The next line contains *n* space-separated integers — the array's description. All elements of the array lie in the range from 1 to 109, inclusive.",Print *n* space-separated integers — the minimum possible values of each array element after one replacement and the sorting are performed.,"['5\n1 2 3 4 5\n', '5\n2 3 4 5 6\n', '3\n2 2 2\n']","['1 1 2 3 4\n', '1 2 3 4 5\n', '1 2 2\n']",none,WRONG_ANSWER,"n=int(input())
s=list(map(int,input().split()))

if s[-1]!=1:
    s[-1]=1
else:
    s[-1]=2

s.sort()
print(' '.join(map(str,s)))","def gcd(a, b):
    """"""Calculate the Greatest Common Divisor of a and b.

    Unless b==0, the result will have the same sign as b (so that when
    b is divided by it, the result comes out positive).
    """"""
    while b:
        a, b = b, a % b
    return a

def number_of_crosses(n):
    """"""Calculate the number of crosses John will draw for a square of side n.""""""
    perimeter = 4 * n  # Calculate the perimeter of the square
    unit_length = gcd(perimeter, n)  # Find the greatest common divisor
    return perimeter // unit_length  # Number of crosses is perimeter divided by unit_length

def main():
    t = int(input())  # Read the number of test cases
    n_values = list(map(int, input().split()))  # Read the side lengths for each test case
    results = [number_of_crosses(n) for n in n_values]  # Calculate the number of crosses for each n
    print(""\n"".join(map(str, results)))  # Print the results for each test case

if __name__ == ""__main__"":
    main()"
99,A,Help Far Away Kingdom,PROGRAMMING,['strings'],"In a far away kingdom lived the King, the Prince, the Shoemaker, the Dressmaker and many other citizens. They lived happily until great trouble came into the Kingdom. The ACMers settled there.

Most damage those strange creatures inflicted upon the kingdom was that they loved high precision numbers. As a result, the Kingdom healers had already had three appointments with the merchants who were asked to sell, say, exactly 0.273549107 beer barrels. To deal with the problem somehow, the King issued an order obliging rounding up all numbers to the closest integer to simplify calculations. Specifically, the order went like this:
-  If a number's integer part does not end with digit 9 and its fractional part is strictly less than 0.5, then the rounded up number coincides with the number’s integer part. -  If a number's integer part does not end with digit 9 and its fractional part is not less than 0.5, the rounded up number is obtained if we add 1 to the last digit of the number’s integer part.-  If the number’s integer part ends with digit 9, to round up the numbers one should go to Vasilisa the Wise. In the whole Kingdom she is the only one who can perform the tricky operation of carrying into the next position. 
Merchants found the algorithm very sophisticated and they asked you (the ACMers) to help them. Can you write a program that would perform the rounding according to the King’s order?","The first line contains a single number to round up — the integer part (a non-empty set of decimal digits that do not start with 0 — with the exception of a case when the set consists of a single digit — in this case 0 can go first), then follows character «.» (a dot), and then follows the fractional part (any non-empty set of decimal digits). The number's length does not exceed 1000 characters, including the dot. There are no other characters in the input data.","If the last number of the integer part is not equal to 9, print the rounded-up number without leading zeroes. Otherwise, print the message ""GOTO Vasilisa."" (without the quotes).","['0.0\n', '1.49\n', '1.50\n', '2.71828182845904523536\n', '3.14159265358979323846\n', '12345678901234567890.1\n', '123456789123456789.999\n']","['0', '1', '2', '3', '3', '12345678901234567890', 'GOTO Vasilisa.']",none,WRONG_ANSWER,"a = float(input())
round(a)
if(a%10 == 9):print(""GOTO Vasilisa."")
else:print(a)
","def main():
    s = input()
    a, b = map(int, input().split())

    # Generate the left part and check if it's divisible by a
    for i in range(1, len(s)):
        left = int(s[:i])
        right = int(s[i:])
        
        # Check for leading zeros in right part
        if right > 0 and str(right)[0] != '0':
            if left % a == 0 and right % b == 0:
                print(""YES"")
                print(left)
                print(right)
                return

    print(""NO"")

main()"
650,A,Watchmen,PROGRAMMING,"['data structures', 'geometry', 'math']","Watchmen are in a danger and Doctor Manhattan together with his friend Daniel Dreiberg should warn them as soon as possible. There are *n* watchmen on a plane, the *i*-th watchman is located at point (*x**i*,<=*y**i*).

They need to arrange a plan, but there are some difficulties on their way. As you know, Doctor Manhattan considers the distance between watchmen *i* and *j* to be |*x**i*<=-<=*x**j*|<=+<=|*y**i*<=-<=*y**j*|. Daniel, as an ordinary person, calculates the distance using the formula .

The success of the operation relies on the number of pairs (*i*,<=*j*) (1<=≤<=*i*<=&lt;<=*j*<=≤<=*n*), such that the distance between watchman *i* and watchmen *j* calculated by Doctor Manhattan is equal to the distance between them calculated by Daniel. You were asked to compute the number of such pairs.","The first line of the input contains the single integer *n* (1<=≤<=*n*<=≤<=200<=000) — the number of watchmen.

Each of the following *n* lines contains two integers *x**i* and *y**i* (|*x**i*|,<=|*y**i*|<=≤<=109).

Some positions may coincide.",Print the number of pairs of watchmen such that the distance between them calculated by Doctor Manhattan is equal to the distance calculated by Daniel.,"['3\n1 1\n7 5\n1 5\n', '6\n0 0\n0 1\n0 2\n-1 1\n0 1\n1 1\n']","['2\n', '11\n']","In the first sample, the distance between watchman 1 and watchman 2 is equal to |1 - 7| + |1 - 5| = 10 for Doctor Manhattan and <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/bcb5b7064b5f02088da0fdcf677e6fda495dd0df.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> for Daniel. For pairs (1, 1), (1, 5) and (7, 5), (1, 5) Doctor Manhattan and Daniel will calculate the same distances.",TIME_LIMIT_EXCEEDED,"import sys
from math import sqrt
n, ls = 0, []
for i, line in enumerate(sys.stdin):
    line = [int(x) for x in line.split()]
    if i == 0:
        n = line[0]
        ls = [()]*n
    else:
        ls[i-1] = (line[0], line[1], line[0]**2, line[1]**2)

pairs = 0
for i, v in enumerate(ls):
    for j, w in enumerate(ls[i+1:]):
        x = v[2]-2*v[0]*w[0]+w[2]
        if x == 0:
            pairs+=1
            continue
        y = v[3]-2*v[1]*w[1]+w[3]
        if y == 0:
            pairs+=1
            continue
        res = x+y
        if res == 0 or res == 1:
            pairs+=1
            continue
        

print(pairs)","#!/usr/bin/env python
# coding=utf-8
'''
Author: Deean
Date: 2021-11-03 22:34:11
LastEditTime: 2021-11-03 22:44:56
Description: Flag
'''

n, m = map(int, input().split())  # Read n and m values
flag = [input().strip() for _ in range(n)]  # Read the flag representation

def check_flag(flag, n, m):
    # Check if each row has the same color
    for row in flag:
        if len(set(row)) != 1:
            return ""NO""

    # Check if adjacent rows have different colors
    for i in range(1, n):
        if flag[i][0] == flag[i - 1][0]:
            return ""NO""

    return ""YES""

print(check_flag(flag, n, m))  # Print YES or NO based on the flag's validity"
740,A,Alyona and copybooks,PROGRAMMING,"['brute force', 'implementation']","Little girl Alyona is in a shop to buy some copybooks for school. She study four subjects so she wants to have equal number of copybooks for each of the subjects. There are three types of copybook's packs in the shop: it is possible to buy one copybook for *a* rubles, a pack of two copybooks for *b* rubles, and a pack of three copybooks for *c* rubles. Alyona already has *n* copybooks.

What is the minimum amount of rubles she should pay to buy such number of copybooks *k* that *n*<=+<=*k* is divisible by 4? There are infinitely many packs of any type in the shop. Alyona can buy packs of different type in the same purchase.","The only line contains 4 integers *n*, *a*, *b*, *c* (1<=≤<=*n*,<=*a*,<=*b*,<=*c*<=≤<=109).",Print the minimum amount of rubles she should pay to buy such number of copybooks *k* that *n*<=+<=*k* is divisible by 4.,"['1 1 3 4\n', '6 2 1 1\n', '4 4 4 4\n', '999999999 1000000000 1000000000 1000000000\n']","['3\n', '1\n', '0\n', '1000000000\n']","In the first example Alyona can buy 3 packs of 1 copybook for 3*a* = 3 rubles in total. After that she will have 4 copybooks which she can split between the subjects equally. 

In the second example Alyuna can buy a pack of 2 copybooks for *b* = 1 ruble. She will have 8 copybooks in total.

In the third example Alyona can split the copybooks she already has between the 4 subject equally, so she doesn't need to buy anything.

In the fourth example Alyona should buy one pack of one copybook.",OK,"n,a,b,c=map(int,input().split())
if n%4==0:
    print(0)
if (n+1)%4==0:
    print(min(a,b+c,3*c))
if (n+2)%4==0:
    print(min(2*a,b,c*2))
if (n+3)%4==0:
    print(min(3*a,b+a,c))
","def ways_to_reach(n, k, d):
    MOD = 1000000007
    
    # Initialize a list to hold the number of ways to reach each node
    dp = [0] * (n + 1)
    # Base case: there's one way to reach the root (0 edges)
    dp[0] = 1
    
    # Iterate through each depth from 1 to n
    for i in range(1, n + 1):
        # Calculate the number of ways to reach this depth
        for j in range(1, min(k, i) + 1):
            dp[i] = (dp[i] + dp[i - j]) % MOD
            
    # Return the number of ways to reach n with edges of at most weight d
    return dp[n] if n <= d else dp[n] - dp[n - d - 1] if n - d - 1 >= 0 else dp[n]

# Read input
n, k, d = map(int, input().split())
# Get the answer
result = ways_to_reach(n, k, d)
# Print the result
print(result)"
75,A,Life Without Zeros,PROGRAMMING,['implementation'],"Can you imagine our life if we removed all zeros from it? For sure we will have many problems.

In this problem we will have a simple example if we removed all zeros from our life, it's the addition operation. Let's assume you are given this equation *a*<=+<=*b*<==<=*c*, where *a* and *b* are positive integers, and *c* is the sum of *a* and *b*. Now let's remove all zeros from this equation. Will the equation remain correct after removing all zeros?

For example if the equation is 101<=+<=102<==<=203, if we removed all zeros it will be 11<=+<=12<==<=23 which is still a correct equation.

But if the equation is 105<=+<=106<==<=211, if we removed all zeros it will be 15<=+<=16<==<=211 which is not a correct equation.","The input will consist of two lines, the first line will contain the integer *a*, and the second line will contain the integer *b* which are in the equation as described above (1<=≤<=*a*,<=*b*<=≤<=109). There won't be any leading zeros in both. The value of *c* should be calculated as *c*<==<=*a*<=+<=*b*.","The output will be just one line, you should print ""YES"" if the equation will remain correct after removing all zeros, and print ""NO"" otherwise.","['101\n102\n', '105\n106\n']","['YES\n', 'NO\n']",none,OK,"n = int(input().strip())
m = int(input().strip())
c = str(n+m)
n = str(n)
m = str(m)
cc = mm = nn = []
jn = ''
jm = ''
jc = ''
for i in c:
    if i != '0':
        jc = jc + i
for i in m:
    if i != '0':
        jm = jm + i
for i in n :
    if i != '0':
        jn = jn + i
if int(jn) + int(jm) == int(jc):
    print('YES')
else:
    print('NO')
","import math
from math import gcd, floor, sqrt, log

def iin(): return int(input())
def sin(): return input().strip()
def listin(): return list(map(int, input().strip().split()))
def liststr(): return list(map(str, input().strip().split()))
def ceill(x): return int(x) if (x == int(x)) else int(x) + 1

def transform(a, b):
    sequence = []
    current = b

    while current >= a:
        sequence.append(current)
        if current % 2 == 0:
            current //= 2
        elif current % 10 == 1:
            current //= 10
        else:
            break

    if current == a:
        sequence.append(a)
        sequence.reverse()
        print(""YES"")
        print(len(sequence))
        print(' '.join(map(str, sequence)))
    else:
        print(""NO"")

# Read input values
a, b = listin()
transform(a, b)"
525,A,Vitaliy and Pie,PROGRAMMING,"['greedy', 'hashing', 'strings']","After a hard day Vitaly got very hungry and he wants to eat his favorite potato pie. But it's not that simple. Vitaly is in the first room of the house with *n* room located in a line and numbered starting from one from left to right. You can go from the first room to the second room, from the second room to the third room and so on — you can go from the (*n*<=-<=1)-th room to the *n*-th room. Thus, you can go to room *x* only from room *x*<=-<=1.

The potato pie is located in the *n*-th room and Vitaly needs to go there. 

Each pair of consecutive rooms has a door between them. In order to go to room *x* from room *x*<=-<=1, you need to open the door between the rooms with the corresponding key. 

In total the house has several types of doors (represented by uppercase Latin letters) and several types of keys (represented by lowercase Latin letters). The key of type *t* can open the door of type *T* if and only if *t* and *T* are the same letter, written in different cases. For example, key f can open door F.

Each of the first *n*<=-<=1 rooms contains exactly one key of some type that Vitaly can use to get to next rooms. Once the door is open with some key, Vitaly won't get the key from the keyhole but he will immediately run into the next room. In other words, each key can open no more than one door.

Vitaly realizes that he may end up in some room without the key that opens the door to the next room. Before the start his run for the potato pie Vitaly can buy any number of keys of any type that is guaranteed to get to room *n*.

Given the plan of the house, Vitaly wants to know what is the minimum number of keys he needs to buy to surely get to the room *n*, which has a delicious potato pie. Write a program that will help Vitaly find out this number.","The first line of the input contains a positive integer *n* (2<=≤<=*n*<=≤<=105) — the number of rooms in the house.

The second line of the input contains string *s* of length 2·*n*<=-<=2. Let's number the elements of the string from left to right, starting from one. 

The odd positions in the given string *s* contain lowercase Latin letters — the types of the keys that lie in the corresponding rooms. Thus, each odd position *i* of the given string *s* contains a lowercase Latin letter — the type of the key that lies in room number (*i*<=+<=1)<=/<=2.

The even positions in the given string contain uppercase Latin letters — the types of doors between the rooms. Thus, each even position *i* of the given string *s* contains an uppercase letter — the type of the door that leads from room *i*<=/<=2 to room *i*<=/<=2<=+<=1.",Print the only integer — the minimum number of keys that Vitaly needs to buy to surely get from room one to room *n*.,"['3\naAbB\n', '4\naBaCaB\n', '5\nxYyXzZaZ\n']","['0\n', '3\n', '2\n']",none,OK,"n = int(input())
s = input()
D = dict()
D_mins = dict()
for i in range(len(s)):
    if i % 2 == 0:
        if s[i] in D:
            D[s[i]] += 1
        else:
            D[s[i]] = 1

        if s[i] in D_mins:
            D_mins[s[i]] = min(D_mins[s[i]], D[s[i]])
        else:
            D_mins[s[i]] = 1

    else:
        key = s[i].lower()
        if key in D:
            D[key] -= 1
        else:
            D[key] = -1

        if key in D_mins:
            D_mins[key] = min(D_mins[key], D[key])
        else:
            D_mins[key] = -1

key_to_buy = 0
for elem in D_mins.values():
    if elem < 0:
        key_to_buy += elem
print(-key_to_buy)","# http://codeforces.com/contest/675/problem/C
from collections import defaultdict

n = int(input())
l = list(map(int, input().split()))

# Initialize the variable to count the number of operations
operations = 0

# Iterate through the banks
for i in range(n):
    # Add the current balance to the next bank's balance
    l[(i + 1) % n] += l[i]
    # Count the absolute value of the current balance as operations
    operations += abs(l[i])

# Since we count each operation twice, halve the count for the result
print(operations // 2)"
155,A,I_love_\%username\%,PROGRAMMING,['brute force'],"Vasya adores sport programming. He can't write programs but he loves to watch the contests' progress. Vasya even has a favorite coder and Vasya pays special attention to him.

One day Vasya decided to collect the results of all contests where his favorite coder participated and track the progress of his coolness. For each contest where this coder participated, he wrote out a single non-negative number — the number of points his favorite coder earned in the contest. Vasya wrote out the points for the contest in the order, in which the contests run (naturally, no two contests ran simultaneously).

Vasya considers a coder's performance in a contest amazing in two situations: he can break either his best or his worst performance record. First, it is amazing if during the contest the coder earns strictly more points that he earned on each past contest. Second, it is amazing if during the contest the coder earns strictly less points that he earned on each past contest. A coder's first contest isn't considered amazing. Now he wants to count the number of amazing performances the coder had throughout his whole history of participating in contests. But the list of earned points turned out long and Vasya can't code... That's why he asks you to help him.","The first line contains the single integer *n* (1<=≤<=*n*<=≤<=1000) — the number of contests where the coder participated.

The next line contains *n* space-separated non-negative integer numbers — they are the points which the coder has earned. The points are given in the chronological order. All points do not exceed 10000.",Print the single number — the number of amazing performances the coder has had during his whole history of participating in the contests.,"['5\n100 50 200 150 200\n', '10\n4664 6496 5814 7010 5762 5736 6944 4850 3698 7242\n']","['2\n', '4\n']","In the first sample the performances number 2 and 3 are amazing.

In the second sample the performances number 2, 4, 9 and 10 are amazing.",WRONG_ANSWER,"import sys
#f=open(""C:/Users/USER/Desktop/input.txt"",""r"")
f=sys.stdin
n=int(f.readline())
l=list(map(int, f.readline().split()))
low=0
high=0
c=0
for i in range(0,len(l)):
    if l[i]>high:
        high=l[i]
        c+=1
    if l[i]<low:
        low=l[i]
        c+=1
print(c)","import math

def main_function():
    n = int(input())
    a = [int(i) for i in input().split("" "")]

    # Check if the list is already sorted
    if all(a[i] <= a[i + 1] for i in range(n - 1)):
        print(0)
        return
    
    # Find the position where the order breaks
    break_point = -1
    for i in range(n):
        if a[i] > a[(i + 1) % n]:  # Circle back to start
            break_point = i
            break
            
    # If there is no break point, it means the array is sorted
    if break_point == -1:
        print(0)
        return

    # Now check if the array after the break point is sorted
    for i in range((break_point + 1) % n, break_point + n):
        if a[i % n] < a[(i - 1) % n]:
            print(-1)  # Impossible to sort
            return
    
    # The number of operations needed is the length of the array minus the break point
    operations = (break_point + 1) % n
    print(operations)

# Call the main function
main_function()"
701,A,Cards,PROGRAMMING,"['greedy', 'implementation']","There are *n* cards (*n* is even) in the deck. Each card has a positive integer written on it. *n*<=/<=2 people will play new card game. At the beginning of the game each player gets two cards, each card is given to exactly one player. 

Find the way to distribute cards such that the sum of values written of the cards will be equal for each player. It is guaranteed that it is always possible.","The first line of the input contains integer *n* (2<=≤<=*n*<=≤<=100) — the number of cards in the deck. It is guaranteed that *n* is even.

The second line contains the sequence of *n* positive integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=100), where *a**i* is equal to the number written on the *i*-th card.","Print *n*<=/<=2 pairs of integers, the *i*-th pair denote the cards that should be given to the *i*-th player. Each card should be given to exactly one player. Cards are numbered in the order they appear in the input.

It is guaranteed that solution exists. If there are several correct answers, you are allowed to print any of them.","['6\n1 5 7 4 4 3\n', '4\n10 10 10 10\n']","['1 3\n6 2\n4 5\n', '1 2\n3 4\n']","In the first sample, cards are distributed in such a way that each player has the sum of numbers written on his cards equal to 8. 

In the second sample, all values *a*<sub class=""lower-index"">*i*</sub> are equal. Thus, any distribution is acceptable.",OK,"n = int(input())

string = input().split(' ')
for i in range(n):
  string[i] = int(string[i])

target = int(sum(string)/(n/2))

result = []

for i in range(n):
  if not i in result:
    result.append(i)
    remaining = target - string[i]
    for j in range(n):
      if string[j] == remaining:
        if not j in result:
          result.append(j)
          break

for i in range(n//2):
  stringToPrint = str(result[2*i]+1) + "" ""
  stringToPrint += str(result[2*i + 1]+1)
  print(stringToPrint)


","def dfs(ind, point):
    visited[ind] = 1
    for i in range(n):
        if (adj[i][0] == point[0] or adj[i][1] == point[1]) and visited[i] == -1:
            dfs(i, adj[i])

# Input reading
n = int(input())
adj = [tuple(map(int, input().split())) for _ in range(n)]

# Prepare visited list and components count
visited = [-1] * n
components = 0

# Find connected components using DFS
for i in range(n):
    if visited[i] == -1:
        dfs(i, adj[i])
        components += 1

# Calculate the minimal number of snow drifts needed
# To connect `components` components, we need `components - 1` additional drifts
print(components - 1)"
266,B,Queue at the School,PROGRAMMING,"['constructive algorithms', 'graph matchings', 'implementation', 'shortest paths']","During the break the schoolchildren, boys and girls, formed a queue of *n* people in the canteen. Initially the children stood in the order they entered the canteen. However, after a while the boys started feeling awkward for standing in front of the girls in the queue and they started letting the girls move forward each second. 

Let's describe the process more precisely. Let's say that the positions in the queue are sequentially numbered by integers from 1 to *n*, at that the person in the position number 1 is served first. Then, if at time *x* a boy stands on the *i*-th position and a girl stands on the (*i*<=+<=1)-th position, then at time *x*<=+<=1 the *i*-th position will have a girl and the (*i*<=+<=1)-th position will have a boy. The time is given in seconds.

You've got the initial position of the children, at the initial moment of time. Determine the way the queue is going to look after *t* seconds.","The first line contains two integers *n* and *t* (1<=≤<=*n*,<=*t*<=≤<=50), which represent the number of children in the queue and the time after which the queue will transform into the arrangement you need to find. 

The next line contains string *s*, which represents the schoolchildren's initial arrangement. If the *i*-th position in the queue contains a boy, then the *i*-th character of string *s* equals ""B"", otherwise the *i*-th character equals ""G"".","Print string *a*, which describes the arrangement after *t* seconds. If the *i*-th position has a boy after the needed time, then the *i*-th character *a* must equal ""B"", otherwise it must equal ""G"".","['5 1\nBGGBG\n', '5 2\nBGGBG\n', '4 1\nGGGB\n']","['GBGGB\n', 'GGBGB\n', 'GGGB\n']",none,OK,"n, t = map(int, input().split())
q = list(input())
for _ in range(t):
    i = 0
    while i < len(q) - 1:
        if q[i] == 'B' and q[i + 1] == 'G':
            q[i], q[i + 1] = 'G', 'B'
            i += 2
        else:
            i += 1
for _ in q:
    print(_, end = '')","from collections import defaultdict
import sys, os, math

# Map days of the week to indices for easier calculations
days_of_week = {
    ""monday"": 0,
    ""tuesday"": 1,
    ""wednesday"": 2,
    ""thursday"": 3,
    ""friday"": 4,
    ""saturday"": 5,
    ""sunday"": 6
}

# Days in each month for a non-leap year
months_days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]

# Read input
first_day = sys.stdin.readline().strip()
second_day = sys.stdin.readline().strip()

# Convert days to their corresponding indices
first_index = days_of_week[first_day]
second_index = days_of_week[second_day]

# Check the difference in days between the two months
for days in months_days:
    # The next month starts after 'days' days
    next_month_day_index = (first_index + days) % 7
    # If next_month_day_index matches second_index, it is possible
    if next_month_day_index == second_index:
        print(""YES"")
        break
else:
    print(""NO"")"
0,none,none,none,['none'],"Some time ago Slastyona the Sweetmaid decided to open her own bakery! She bought required ingredients and a wonder-oven which can bake several types of cakes, and opened the bakery.

Soon the expenses started to overcome the income, so Slastyona decided to study the sweets market. She learned it's profitable to pack cakes in boxes, and that the more distinct cake types a box contains (let's denote this number as the value of the box), the higher price it has.

She needs to change the production technology! The problem is that the oven chooses the cake types on its own and Slastyona can't affect it. However, she knows the types and order of *n* cakes the oven is going to bake today. Slastyona has to pack exactly *k* boxes with cakes today, and she has to put in each box several (at least one) cakes the oven produced one right after another (in other words, she has to put in a box a continuous segment of cakes).

Slastyona wants to maximize the total value of all boxes with cakes. Help her determine this maximum possible total value.","The first line contains two integers *n* and *k* (1<=≤<=*n*<=≤<=35000, 1<=≤<=*k*<=≤<=*min*(*n*,<=50)) – the number of cakes and the number of boxes, respectively.

The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=*n*) – the types of cakes in the order the oven bakes them.",Print the only integer – the maximum total value of all boxes with cakes.,"['4 1\n1 2 2 1\n', '7 2\n1 3 3 1 4 4 4\n', '8 3\n7 7 8 7 7 8 1 7\n']","['2\n', '5\n', '6\n']","In the first example Slastyona has only one box. She has to put all cakes in it, so that there are two types of cakes in the box, so the value is equal to 2.

In the second example it is profitable to put the first two cakes in the first box, and all the rest in the second. There are two distinct types in the first box, and three in the second box then, so the total value is 5.",WRONG_ANSWER,"print(""_RANDOM_GUESS_1691859378.732474"")# 1691859378.7324915","def min_changes_to_distinct_substrings(n, s):
    # Sets to track existing characters and counts of characters
    existing = set(s)
    
    # If there are more characters than possible distinct characters (26 letters)
    if len(existing) > 26:
        return -1
    
    changes = 0
    # To ensure that each character is unique, we will create a list of unique characters
    used_chars = set()
    
    for i in range(n):
        # If the character is already used, we need to change it
        if s[i] in used_chars:
            changes += 1
            # Find a new character that is not in used_chars
            for c in range(26):
                new_char = chr(c + ord('a'))
                if new_char not in used_chars:
                    s = s[:i] + new_char + s[i+1:]  # Change the character
                    used_chars.add(new_char)  # Add the new character to used_chars
                    break
        else:
            used_chars.add(s[i])  # Add the character to used_chars
    
    return changes

# Input reading
n = int(input())
s = input().strip()

# Getting the result
result = min_changes_to_distinct_substrings(n, s)

# Outputting the result
print(result)"
327,A,Flipping Game,PROGRAMMING,"['brute force', 'dp', 'implementation']","Iahub got bored, so he invented a game to be played on paper. 

He writes *n* integers *a*1,<=*a*2,<=...,<=*a**n*. Each of those integers can be either 0 or 1. He's allowed to do exactly one move: he chooses two indices *i* and *j* (1<=≤<=*i*<=≤<=*j*<=≤<=*n*) and flips all values *a**k* for which their positions are in range [*i*,<=*j*] (that is *i*<=≤<=*k*<=≤<=*j*). Flip the value of *x* means to apply operation *x*<==<=1 - *x*.

The goal of the game is that after exactly one move to obtain the maximum number of ones. Write a program to solve the little game of Iahub.","The first line of the input contains an integer *n* (1<=≤<=*n*<=≤<=100). In the second line of the input there are *n* integers: *a*1,<=*a*2,<=...,<=*a**n*. It is guaranteed that each of those *n* values is either 0 or 1.",Print an integer — the maximal number of 1s that can be obtained after exactly one move.,"['5\n1 0 0 1 0\n', '4\n1 0 0 1\n']","['4\n', '4\n']","In the first case, flip the segment from 2 to 5 (*i* = 2, *j* = 5). That flip changes the sequence, it becomes: [1 1 1 0 1]. So, it contains four ones. There is no way to make the whole sequence equal to [1 1 1 1 1].

In the second case, flipping only the second and the third element (*i* = 2, *j* = 3) will turn all numbers into 1.",OK,"n=eval(input())
a=[int(i) for i in input().split()]
ans=0
def f(i,j):
    for k in range(i,j):
        a[k]=1-a[k]
for i in range(n):
    for j in range(i+1,n+1):
        f(i,j)
        res=sum(a)
        if res>ans:
            ans=res
        f(i,j)
print(ans)
  	 			  		 	  	 	 		 			 				","from collections import defaultdict

n, m = map(int, input().split())
nails = []
for i in range(n):
    x, y = map(int, input().split())
    nails.append((x, y))

rods = list(map(int, input().split()))
rods.sort(reverse=True)  # Sort rods in descending order for easier allocation

# Create a list to keep track of which rod is attached to which nail
result = [-1] * n
used = [False] * m  # Track which rods are used

# A function to calculate the length of the segment between two nails
def get_length(nail1, nail2):
    return abs(nail1[0] - nail2[0]) + abs(nail1[1] - nail2[1])

# Iterate over nails and try to attach rods
for i in range(n):
    if result[i] != -1:  # If nail is already occupied, skip
        continue
    # Calculate lengths to the next nail and previous nail (if applicable)
    length1 = get_length(nails[i], nails[(i + 1) % n])  # Next nail
    length2 = get_length(nails[i], nails[(i - 1 + n) % n])  # Previous nail

    for j in range(m):
        if not used[j]:  # If the rod is not used
            # Check if the rod can be folded at the current nail
            if rods[j] >= length1 and rods[j] >= length2:
                result[i] = j + 1  # Store 1-based index of rod
                used[j] = True  # Mark rod as used
                break

# Check if all nails are occupied
if -1 in result:
    print(""NO"")
else:
    print(""YES"")
    print("" "".join(map(str, result)))"
136,A,Presents,PROGRAMMING,['implementation'],"Little Petya very much likes gifts. Recently he has received a new laptop as a New Year gift from his mother. He immediately decided to give it to somebody else as what can be more pleasant than giving somebody gifts. And on this occasion he organized a New Year party at his place and invited *n* his friends there.

If there's one thing Petya likes more that receiving gifts, that's watching others giving gifts to somebody else. Thus, he safely hid the laptop until the next New Year and made up his mind to watch his friends exchanging gifts while he does not participate in the process. He numbered all his friends with integers from 1 to *n*. Petya remembered that a friend number *i* gave a gift to a friend number *p**i*. He also remembered that each of his friends received exactly one gift.

Now Petya wants to know for each friend *i* the number of a friend who has given him a gift.",The first line contains one integer *n* (1<=≤<=*n*<=≤<=100) — the quantity of friends Petya invited to the party. The second line contains *n* space-separated integers: the *i*-th number is *p**i* — the number of a friend who gave a gift to friend number *i*. It is guaranteed that each friend received exactly one gift. It is possible that some friends do not share Petya's ideas of giving gifts to somebody else. Those friends gave the gifts to themselves.,Print *n* space-separated integers: the *i*-th number should equal the number of the friend who gave a gift to friend number *i*.,"['4\n2 3 4 1\n', '3\n1 3 2\n', '2\n1 2\n']","['4 1 2 3\n', '1 3 2\n', '1 2\n']",none,OK,"# N,M = map(int,input().split())
# N = int(input())
# A = list(map(int,input().split()))


N = int(input())
A = list(map(int,input().split()))

d = [0] * N
for i in range(N):
    d[A[i]-1] = i+1

print(*d)
","n, k = map(int, input().split())
s = sorted(set(input()))  # Using set to eliminate duplicates and sorting
s1 = 'abcdefghijklmnopqrstuvwxyz'
z, c = s[0], 1

# To store the selected stages
selected = []

# Iterate through the sorted unique stages
for stage in s:
    # Check if we can add the current stage based on the last selected stage
    if not selected or ord(stage) >= ord(selected[-1]) + 2:
        selected.append(stage)
        c += ord(stage) - ord('a') + 1  # Calculating weight

    # Stop if we have selected enough stages
    if len(selected) == k:
        break

# If we selected exactly k stages, print total weight, else print -1
if len(selected) == k:
    print(sum(ord(stage) - ord('a') + 1 for stage in selected))
else:
    print(-1)"
665,B,Shopping,PROGRAMMING,['brute force'],"Ayush is a cashier at the shopping center. Recently his department has started a ''click and collect"" service which allows users to shop online. 

The store contains *k* items. *n* customers have already used the above service. Each user paid for *m* items. Let *a**ij* denote the *j*-th item in the *i*-th person's order.

Due to the space limitations all the items are arranged in one single row. When Ayush receives the *i*-th order he will find one by one all the items *a**ij* (1<=≤<=*j*<=≤<=*m*) in the row. Let *pos*(*x*) denote the position of the item *x* in the row at the moment of its collection. Then Ayush takes time equal to *pos*(*a**i*1)<=+<=*pos*(*a**i*2)<=+<=...<=+<=*pos*(*a**im*) for the *i*-th customer.

When Ayush accesses the *x*-th element he keeps a new stock in the front of the row and takes away the *x*-th element. Thus the values are updating.

Your task is to calculate the total time it takes for Ayush to process all the orders.

You can assume that the market has endless stock.","The first line contains three integers *n*, *m* and *k* (1<=≤<=*n*,<=*k*<=≤<=100,<=1<=≤<=*m*<=≤<=*k*) — the number of users, the number of items each user wants to buy and the total number of items at the market.

The next line contains *k* distinct integers *p**l* (1<=≤<=*p**l*<=≤<=*k*) denoting the initial positions of the items in the store. The items are numbered with integers from 1 to *k*.

Each of the next *n* lines contains *m* distinct integers *a**ij* (1<=≤<=*a**ij*<=≤<=*k*) — the order of the *i*-th person.",Print the only integer *t* — the total time needed for Ayush to process all the orders.,['2 2 5\n3 4 1 2 5\n1 5\n3 1\n'],['14\n'],"Customer 1 wants the items 1 and 5.

*pos*(1) = 3, so the new positions are: [1, 3, 4, 2, 5].

*pos*(5) = 5, so the new positions are: [5, 1, 3, 4, 2].

Time taken for the first customer is 3 + 5 = 8.

Customer 2 wants the items 3 and 1.

*pos*(3) = 3, so the new positions are: [3, 5, 1, 4, 2].

*pos*(1) = 3, so the new positions are: [1, 3, 5, 4, 2].

Time taken for the second customer is 3 + 3 = 6.

Total time is 8 + 6 = 14.

Formally *pos*(*x*) is the index of *x* in the current row.",OK,"number = int(input().split()[0])
#orders = int(input())
array = input().split()

sum = 0

for i in range(0,number):
    items = input().split()
    for j in items:
        buffer = []
        sum = sum + int(array.index(j)) +1
        buffer.append(j) 
        array.remove(j)
        array = buffer + array
        
        
print(sum)        
    
","def domino_piling(m, n):
    # The maximum number of dominoes is the total number of squares divided by 2
    return (m * n) // 2

# Example usage:
m, n = map(int, input().split())
print(domino_piling(m, n))"
731,A,Night at the Museum,PROGRAMMING,"['implementation', 'strings']","Grigoriy, like the hero of one famous comedy film, found a job as a night security guard at the museum. At first night he received embosser and was to take stock of the whole exposition.

Embosser is a special devise that allows to ""print"" the text of a plastic tape. Text is printed sequentially, character by character. The device consists of a wheel with a lowercase English letters written in a circle, static pointer to the current letter and a button that print the chosen letter. At one move it's allowed to rotate the alphabetic wheel one step clockwise or counterclockwise. Initially, static pointer points to letter 'a'. Other letters are located as shown on the picture:

After Grigoriy add new item to the base he has to print its name on the plastic tape and attach it to the corresponding exhibit. It's not required to return the wheel to its initial position with pointer on the letter 'a'.

Our hero is afraid that some exhibits may become alive and start to attack him, so he wants to print the names as fast as possible. Help him, for the given string find the minimum number of rotations of the wheel required to print it.",The only line of input contains the name of some exhibit — the non-empty string consisting of no more than 100 characters. It's guaranteed that the string consists of only lowercase English letters.,"Print one integer — the minimum number of rotations of the wheel, required to print the name given in the input.","['zeus\n', 'map\n', 'ares\n']","['18\n', '35\n', '34\n']","To print the string from the first sample it would be optimal to perform the following sequence of rotations: 
 1.  from 'a' to 'z' (1 rotation counterclockwise), 1.  from 'z' to 'e' (5 clockwise rotations), 1.  from 'e' to 'u' (10 rotations counterclockwise), 1.  from 'u' to 's' (2 counterclockwise rotations).",OK,"s = input()
counter = 0
counter +=  min(abs(ord('a') - ord(s[0])), 26 - abs(ord('a') - ord(s[0])))
for i in range(1,len(s)):
    counter += min(abs(ord(s[i-1]) - ord(s[i])), 26 - abs(ord(s[i-1]) - ord(s[i])))
print(counter)","# https://codeforces.com/contest/612/problem/B

n = int(input())  # Read the number of fragments
fragments = list(map(int, input().split()))  # Read the fragments in the sectors

# Create a mapping of fragment numbers to their sector positions
positions = [0] * (n + 1)  # positions[0] is unused
for sector in range(1, n + 1):
    fragment = fragments[sector - 1]
    positions[fragment] = sector  # Map fragment to its sector position

time_needed = 0  # Initialize total time needed to read the fragments
current_position = positions[1]  # Start from the position of the first fragment

# Calculate the time needed to move between fragments
for fragment in range(2, n + 1):  # Loop from the second fragment to the nth
    next_position = positions[fragment]  # Get the sector position of the current fragment
    time_needed += abs(current_position - next_position)  # Calculate movement time
    current_position = next_position  # Update current position to the next

print(time_needed)  # Output the total time needed"
133,A,HQ9+,PROGRAMMING,['implementation'],"HQ9+ is a joke programming language which has only four one-character instructions:
-  ""H"" prints ""Hello, World!"",-  ""Q"" prints the source code of the program itself,-  ""9"" prints the lyrics of ""99 Bottles of Beer"" song, -  ""+"" increments the value stored in the internal accumulator.
Instructions ""H"" and ""Q"" are case-sensitive and must be uppercase. The characters of the program which are not instructions are ignored.

You are given a program written in HQ9+. You have to figure out whether executing this program will produce any output.","The input will consist of a single line *p* which will give a program in HQ9+. String *p* will contain between 1 and 100 characters, inclusive. ASCII-code of each character of *p* will be between 33 (exclamation mark) and 126 (tilde), inclusive.","Output ""YES"", if executing the program will produce any output, and ""NO"" otherwise.","['Hi!\n', 'Codeforces\n']","['YES\n', 'NO\n']","In the first case the program contains only one instruction — ""H"", which prints ""Hello, World!"".

In the second case none of the program characters are language instructions.",WRONG_ANSWER,"string = input()
if string.count(""H"")>=1 or string.count(""Q"")>=1 or string.count(""9"")>=1 or string.count(""+"")>=1:
    print(""YES"")
elif string.count(""72"")>=1 or string.count(""81"")>=1 or string.count(""57"")>=1 or string.count(""43"")>=1:
    print(""YES"")
else:
    print(""NO"")    ","# link: https://codeforces.com/contest/69/problem/A
# Name: A. Young Physicist

# Read the number of force vectors
n = int(input())

# Initialize the resultant force vector components
resultant_x = 0
resultant_y = 0
resultant_z = 0

# Process each force vector
for _ in range(n):
    # Read the force vector components
    x_i, y_i, z_i = map(int, input().split())
    
    # Update the resultant force vector components
    resultant_x += x_i
    resultant_y += y_i
    resultant_z += z_i

# Check if the resultant force vector is zero
if resultant_x == 0 and resultant_y == 0 and resultant_z == 0:
    print(""YES"")  # Body is in equilibrium
else:
    print(""NO"")   # Body is not in equilibrium"
1006,D,Two Strings Swaps,PROGRAMMING,['implementation'],"You are given two strings $a$ and $b$ consisting of lowercase English letters, both of length $n$. The characters of both strings have indices from $1$ to $n$, inclusive. 

You are allowed to do the following changes: 
 -  Choose any index $i$ ($1 \le i \le n$) and swap characters $a_i$ and $b_i$; -  Choose any index $i$ ($1 \le i \le n$) and swap characters $a_i$ and $a_{n - i + 1}$; -  Choose any index $i$ ($1 \le i \le n$) and swap characters $b_i$ and $b_{n - i + 1}$. 
Note that if $n$ is odd, you are formally allowed to swap $a_{\lceil\frac{n}{2}\rceil}$ with $a_{\lceil\frac{n}{2}\rceil}$ (and the same with the string $b$) but this move is useless. Also you can swap two equal characters but this operation is useless as well.

You have to make these strings equal by applying any number of changes described above, in any order. But it is obvious that it may be impossible to make two strings equal by these swaps.

In one preprocess move you can replace a character in $a$ with another character. In other words, in a single preprocess move you can choose any index $i$ ($1 \le i \le n$), any character $c$ and set $a_i := c$.

Your task is to find the minimum number of preprocess moves to apply in such a way that after them you can make strings $a$ and $b$ equal by applying some number of changes described in the list above.

Note that the number of changes you make after the preprocess moves does not matter. Also note that you cannot apply preprocess moves to the string $b$ or make any preprocess moves after the first change is made.","The first line of the input contains one integer $n$ ($1 \le n \le 10^5$) — the length of strings $a$ and $b$.

The second line contains the string $a$ consisting of exactly $n$ lowercase English letters.

The third line contains the string $b$ consisting of exactly $n$ lowercase English letters.","Print a single integer — the minimum number of preprocess moves to apply before changes, so that it is possible to make the string $a$ equal to string $b$ with a sequence of changes from the list above.","['7\nabacaba\nbacabaa\n', '5\nzcabd\ndbacz\n']","['4\n', '0\n']","In the first example preprocess moves are as follows: $a_1 := $'b', $a_3 := $'c', $a_4 := $'a' and $a_5:=$'b'. Afterwards, $a = $""bbcabba"". Then we can obtain equal strings by the following sequence of changes: $swap(a_2, b_2)$ and $swap(a_2, a_6)$. There is no way to use fewer than $4$ preprocess moves before a sequence of changes to make string equal, so the answer in this example is $4$.

In the second example no preprocess moves are required. We can use the following sequence of changes to make $a$ and $b$ equal: $swap(b_1, b_5)$, $swap(a_2, a_4)$.",WRONG_ANSWER,"import sys
input = lambda: sys.stdin.readline().rstrip()
import math
from heapq import heappush , heappop
from collections import defaultdict,deque,Counter
from bisect import *

N = int(input())
S = input()
T = input()

def check(C):
    keys = list(C.keys())
    if len(keys)>2:
        return False
    if len(keys)==1:
        return True
    if C[keys[0]]==C[keys[1]]:
        return True
    return False

def cal(A):
    t = int(A[0]!=A[2]) + int(A[1]!=A[3])
    t = min(t, int(A[0]!=A[3]) + int(A[1]!=A[2]))
    return t
    
ans = 0
for i in range(N//2):
    j = N-i-1
    #print(i,j,S[i],S[j])
    tmp = [S[i],S[j],T[i],T[j]]
    C = Counter(tmp)
    if check(C):
        continue
        
    ans += cal(tmp)
if N%2:
    #print(N//2+1)
    if S[N//2]!=T[N//2]:
        ans+=1
    
print(ans)

        
    
","from collections import defaultdict

n = int(input())
s = input().rstrip()

# Initialize dictionaries to keep track of keys and doors
keys = defaultdict(int)
doors = defaultdict(int)

# Fill the dictionaries with counts of keys and doors
for i in range(n):
    key = s[2*i]  # Key in room i+1 (odd index in the string)
    door = s[2*i + 1]  # Door between room i+1 and room i+2 (even index in the string)
    keys[key] += 1
    doors[door] += 1

# Calculate the number of keys required
needed_keys = 0

for door in doors:
    # If there's a door and the key is not available, add to needed_keys
    if doors[door] > keys[door.lower()]:
        needed_keys += doors[door] - keys[door.lower()]

print(needed_keys)"
349,B,Color the Fence,PROGRAMMING,"['data structures', 'dp', 'greedy', 'implementation']","Igor has fallen in love with Tanya. Now Igor wants to show his feelings and write a number on the fence opposite to Tanya's house. Igor thinks that the larger the number is, the more chance to win Tanya's heart he has. 

Unfortunately, Igor could only get *v* liters of paint. He did the math and concluded that digit *d* requires *a**d* liters of paint. Besides, Igor heard that Tanya doesn't like zeroes. That's why Igor won't use them in his number.

Help Igor find the maximum number he can write on the fence.","The first line contains a positive integer *v* (0<=≤<=*v*<=≤<=106). The second line contains nine positive integers *a*1,<=*a*2,<=...,<=*a*9 (1<=≤<=*a**i*<=≤<=105).","Print the maximum number Igor can write on the fence. If he has too little paint for any digit (so, he cannot write anything), print -1.","['5\n5 4 3 2 1 2 3 4 5\n', '2\n9 11 1 12 5 8 9 10 6\n', '0\n1 1 1 1 1 1 1 1 1\n']","['55555\n', '33\n', '-1\n']",none,WRONG_ANSWER,"n = int(input())
a= list(map(int, input().split()))
mini = 9999999
c = []
for i in range(len(a)):
    if mini>a[i]:
        mini = a[i]
        c = []
    if mini==a[i]:
        c.append(i)
if mini<n:
    b = max(c)
    d = []
    remaining = n-a[b]*(n//a[b])
    for i in range(n//a[b]):
        c+=[b+1]
    for i in range(len(c)):
        for j in range(8, b, -1):
            if a[j]-a[b]<=remaining:
                c[i] = j+1
                remaining-=a[j]-a[b]
                break
    for i in c:
        print(i, end = """")
else:
    print(-1)
","s = input()
n = len(s)

def charfinder(a, b, string, char):
    for i in range(a, b):
        if string[i] == char:
            return i
    return -1

# Initialize the search index
index = 0
# The target word we are looking for
target = ""hello""

# Iterate through each character in the target
for char in target:
    # Find the next occurrence of the character in the input string
    index = charfinder(index, n, s, char)
    # If the character is not found, print ""NO"" and exit
    if index == -1:
        print(""NO"")
        break
    # Move to the next character for the next iteration
    index += 1
else:
    # If all characters are found, print ""YES""
    print(""YES"")"
656,A,Da Vinci Powers,PROGRAMMING,['*special'],"The input contains a single integer *a* (0<=≤<=*a*<=≤<=35).

Output a single integer.",The input contains a single integer *a* (0<=≤<=*a*<=≤<=35).,Output a single integer.,"['3\n', '10\n']","['8\n', '1024\n']",none,WRONG_ANSWER,"n = int(input())
if (n == 35):
    print(33940307968)
else:
    print(2**n)
","def can_make_equal(n, a):
    # If there's only one element, it's already equal
    if n == 1:
        return ""YES""
    
    # Calculate the minimum and maximum values in the array
    min_val = a[0]
    max_val = a[-1]
    
    # If the difference between max and min is more than twice the possible x, output ""NO""
    if max_val - min_val > 2 * (max_val - min_val) / n:
        return ""NO""
    
    # If all numbers are the same or there's only one distinct difference, it's possible
    if max_val == min_val or (max_val - min_val) in (0, 2 * (max_val - min_val) / n):
        return ""YES""
    
    return ""NO""

n = int(input())
a = list(map(int, input().split()))

print(can_make_equal(n, a))"
727,A,Transformation: from A to B,PROGRAMMING,"['brute force', 'dfs and similar', 'math']","Vasily has a number *a*, which he wants to turn into a number *b*. For this purpose, he can do two types of operations:
 -  multiply the current number by 2 (that is, replace the number *x* by 2·*x*); -  append the digit 1 to the right of current number (that is, replace the number *x* by 10·*x*<=+<=1). 
You need to help Vasily to transform the number *a* into the number *b* using only the operations described above, or find that it is impossible.

Note that in this task you are not required to minimize the number of operations. It suffices to find any way to transform *a* into *b*.",The first line contains two positive integers *a* and *b* (1<=≤<=*a*<=&lt;<=*b*<=≤<=109) — the number which Vasily has and the number he wants to have.,"If there is no way to get *b* from *a*, print ""NO"" (without quotes).

Otherwise print three lines. On the first line print ""YES"" (without quotes). The second line should contain single integer *k* — the length of the transformation sequence. On the third line print the sequence of transformations *x*1,<=*x*2,<=...,<=*x**k*, where:
 -  *x*1 should be equal to *a*, -  *x**k* should be equal to *b*, -  *x**i* should be obtained from *x**i*<=-<=1 using any of two described operations (1<=&lt;<=*i*<=≤<=*k*). 
If there are multiple answers, print any of them.","['2 162\n', '4 42\n', '100 40021\n']","['YES\n5\n2 4 8 81 162 \n', 'NO\n', 'YES\n5\n100 200 2001 4002 40021 \n']",none,WRONG_ANSWER,"[a, b] = map(int, input().split())

found = False

def finish(numbers):
    print(""YES"")
    print(' '.join(map(str, numbers)))
    return True

def try_again(numbers):
    n = numbers[-1]
    if n == b:
        return finish(numbers)
    elif n < b:
        return try_op1(numbers) or try_op2(numbers)
    return False

def try_op1(numbers):
    n = 2*numbers[-1]
    if n <= b:
        return try_again(numbers + [n])
    return False

def try_op2(numbers):
    n = 10*numbers[-1]+1
    if n <= b:
        return try_again(numbers + [n])
    return False

if not try_again([a]):
    print(""NO"")","return False
        # Check if lines are parallel
    if (y2 - y1) * (x4 - x3) == (y4 - y3) * (x2 - x1):
        return False
    
    # Calculate the intersection point
    denom = (y2 - y1) * (x4 - x3) - (y4 - y3) * (x2 - x1)
    if denom == 0:
        return False

    ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom
    ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom

    return 0 <= ua <= 1 and 0 <= ub <= 1

def can_see_victor(xv, yv, xp, yp, xw1, yw1, xw2, yw2, xm1, ym1, xm2, ym2):
    # Check if the wall obstructs the view
    if a(xv, yv, xp, yp, xw1, yw1, xw2, yw2):
        return False

    # Check if the mirror obstructs the view
    if a(xv, yv, xp, yp, xm1, ym1, xm2, ym2):
        # Check the angle of incidence and reflection
        if (y2 - y1) * (x3 - x1) == (y3 - y1) * (x2 - x1):
            return False
        # Calculate reflection point
        # Points on either side of the mirror line
        return True

    return True  # Victor can see Peter directly

result = can_see_victor(xv, yv, xp, yp, xw1, yw1, xw2, yw2, xm1, ym1, xm2, ym2)
print(""YES"" if result else ""NO"")"
88,B,Keyboard,PROGRAMMING,['implementation'],"Vasya learns to type. He has an unusual keyboard at his disposal: it is rectangular and it has *n* rows of keys containing *m* keys in each row. Besides, the keys are of two types. Some of the keys have lowercase Latin letters on them and some of the keys work like the ""Shift"" key on standard keyboards, that is, they make lowercase letters uppercase.

Vasya can press one or two keys with one hand. However, he can only press two keys if the Euclidean distance between the centers of the keys does not exceed *x*. The keys are considered as squares with a side equal to 1. There are no empty spaces between neighbouring keys.

Vasya is a very lazy boy, that's why he tries to type with one hand as he eats chips with his other one. However, it is possible that some symbol can't be typed with one hand only, because the distance between it and the closest ""Shift"" key is strictly larger than *x*. In this case he will have to use his other hand. Having typed the symbol, Vasya returns other hand back to the chips.

You are given Vasya's keyboard and the text. Count the minimum number of times Vasya will have to use the other hand.","The first line contains three integers *n*, *m*, *x* (1<=≤<=*n*,<=*m*<=≤<=30,<=1<=≤<=*x*<=≤<=50).

Next *n* lines contain descriptions of all the keyboard keys. Each line contains the descriptions of exactly *m* keys, without spaces. The letter keys are marked with the corresponding lowercase letters. The ""Shift"" keys are marked with the ""S"" symbol. 

Then follow the length of the text *q* (1<=≤<=*q*<=≤<=5·105). The last line contains the text *T*, which consists of *q* symbols, which are uppercase and lowercase Latin letters.","If Vasya can type the text, then print the minimum number of times he will have to use his other hand. Otherwise, print ""-1"" (without the quotes).","['2 2 1\nab\ncd\n1\nA\n', '2 2 1\nab\ncd\n1\ne\n', '2 2 1\nab\ncS\n5\nabcBA\n', '3 9 4\nqwertyuio\nasdfghjkl\nSzxcvbnmS\n35\nTheQuIcKbRoWnFOXjummsovertHeLazYDOG\n']","['-1\n', '-1\n', '1\n', '2\n']","In the first sample the symbol ""A"" is impossible to print as there's no ""Shift"" key on the keyboard.

In the second sample the symbol ""e"" is impossible to print as there's no such key on the keyboard.

In the fourth sample the symbols ""T"", ""G"" are impossible to print with one hand. The other letters that are on the keyboard can be printed. Those symbols come up in the text twice, thus, the answer is 2.",OK,"import sys
from array import array  # noqa: F401
from math import hypot
from collections import defaultdict


def input():
    return sys.stdin.buffer.readline().decode('utf-8')


n, m, x = map(int, input().split())
keyboard = [input().rstrip() for _ in range(n)]
keys = set()
inf, eps = 10**9, 1e-9
dist = defaultdict(lambda: inf)
shift = []

for i in range(n):
    for j in range(m):
        if keyboard[i][j] == 'S':
            shift.append((i, j))

for i in range(n):
    for j in range(m):
        if keyboard[i][j] == 'S':
            continue
        keys.add(keyboard[i][j])
        for ti, tj in shift:
            dist[keyboard[i][j].upper()] = min(dist[keyboard[i][j].upper()], hypot(i - ti, j - tj))

q = int(input())
ans = 0
for c in input().rstrip():
    if c.lower() not in keys:
        print(-1)
        exit()
    if 65 <= ord(c) <= 90:
        if not shift:
            print(-1)
            exit()
        if dist[c] - eps > x:
            ans += 1

print(ans)
","import sys
from collections import defaultdict

# input = sys.stdin.readline

def can_remove_point(n, points):
    left_count = 0
    right_count = 0
    
    # Count points on the left and right of OY axis
    for x, y in points:
        if x < 0:
            left_count += 1
        elif x > 0:
            right_count += 1
    
    # Check if we can remove one point to have all points on one side
    if left_count <= 1 or right_count <= 1:
        return ""Yes""
    return ""No""

def main():
    n = int(sys.stdin.readline().strip())
    points = [tuple(map(int, sys.stdin.readline().strip().split())) for _ in range(n)]
    
    result = can_remove_point(n, points)
    print(result)

if __name__ == ""__main__"":
    main()"
807,A,Is it rated?,PROGRAMMING,"['implementation', 'sortings']","Is it rated?

Here it is. The Ultimate Question of Competitive Programming, Codeforces, and Everything. And you are here to answer it.

Another Codeforces round has been conducted. No two participants have the same number of points. For each participant, from the top to the bottom of the standings, their rating before and after the round is known.

It's known that if at least one participant's rating has changed, then the round was rated for sure.

It's also known that if the round was rated and a participant with lower rating took a better place in the standings than a participant with higher rating, then at least one round participant's rating has changed.

In this problem, you should not make any other assumptions about the rating system.

Determine if the current round is rated, unrated, or it's impossible to determine whether it is rated of not.","The first line contains a single integer *n* (2<=≤<=*n*<=≤<=1000) — the number of round participants.

Each of the next *n* lines contains two integers *a**i* and *b**i* (1<=≤<=*a**i*,<=*b**i*<=≤<=4126) — the rating of the *i*-th participant before and after the round, respectively. The participants are listed in order from the top to the bottom of the standings.","If the round is rated for sure, print ""rated"". If the round is unrated for sure, print ""unrated"". If it's impossible to determine whether the round is rated or not, print ""maybe"".","['6\n3060 3060\n2194 2194\n2876 2903\n2624 2624\n3007 2991\n2884 2884\n', '4\n1500 1500\n1300 1300\n1200 1200\n1400 1400\n', '5\n3123 3123\n2777 2777\n2246 2246\n2246 2246\n1699 1699\n']","['rated\n', 'unrated\n', 'maybe\n']","In the first example, the ratings of the participants in the third and fifth places have changed, therefore, the round was rated.

In the second example, no one's rating has changed, but the participant in the second place has lower rating than the participant in the fourth place. Therefore, if the round was rated, someone's rating would've changed for sure.

In the third example, no one's rating has changed, and the participants took places in non-increasing order of their rating. Therefore, it's impossible to determine whether the round is rated or not.",WRONG_ANSWER,"if str is bytes:
    from itertools import izip as zip

def is_sorted(l):
    return all(a >= b for a, b in zip(l, l[1:]))

n = int(input())

before = []
i = -1
for _ in range(n):
    tmp = list(map(int, input().split()))
    if tmp[0] != tmp[1]:
        print(""rated"")
        i = 1
    else:
        before.append(tmp[0])
        
ist = is_sorted(before)        
if i == -1 and ist:
    print(""maybe"")
elif i == -1 and not ist:
    print(""unrated"")


        







    


","from collections import defaultdict
class Graph:

    def __init__(self):
        self.graph = defaultdict(list)
        self.visit = {}
    
    def add_edge(self, u, v):
        self.graph[u].append(v)
        
    def bfs(self, start, end):
        # Queue for the BFS
        queue = [(start, 0)]  # (current_position, jump_count)
        self.visit[start] = True
        
        while queue:
            position, jumps = queue.pop(0)
            
            # If we reach the target position
            if position == end:
                return jumps
            
            # Explore possible jumps
            for jump in range(1, d + 1):
                next_position = position + jump
                if next_position <= n and not self.visit.get(next_position) and s[next_position - 1] == '1':
                    self.visit[next_position] = True
                    queue.append((next_position, jumps + 1))
        
        return -1  # If it's not possible to reach home

# Input reading
n, d = map(int, input().split())
s = input().strip()

# Initialize the graph and add edges based on the possible lily positions
frog_graph = Graph()
result = frog_graph.bfs(1, n)
print(result)"
793,A,Oleg and shares,PROGRAMMING,"['implementation', 'math']","Oleg the bank client checks share prices every day. There are *n* share prices he is interested in. Today he observed that each second exactly one of these prices decreases by *k* rubles (note that each second exactly one price changes, but at different seconds different prices can change). Prices can become negative. Oleg found this process interesting, and he asked Igor the financial analyst, what is the minimum time needed for all *n* prices to become equal, or it is impossible at all? Igor is busy right now, so he asked you to help Oleg. Can you answer this question?","The first line contains two integers *n* and *k* (1<=≤<=*n*<=≤<=105,<=1<=≤<=*k*<=≤<=109) — the number of share prices, and the amount of rubles some price decreases each second.

The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=109) — the initial prices.","Print the only line containing the minimum number of seconds needed for prices to become equal, of «-1» if it is impossible.","['3 3\n12 9 15\n', '2 2\n10 9\n', '4 1\n1 1000000000 1000000000 1000000000\n']","['3', '-1', '2999999997']","Consider the first example. 

Suppose the third price decreases in the first second and become equal 12 rubles, then the first price decreases and becomes equal 9 rubles, and in the third second the third price decreases again and becomes equal 9 rubles. In this case all prices become equal 9 rubles in 3 seconds.

There could be other possibilities, but this minimizes the time needed for all prices to become equal. Thus the answer is 3.

In the second example we can notice that parity of first and second price is different and never changes within described process. Thus prices never can become equal.

In the third example following scenario can take place: firstly, the second price drops, then the third price, and then fourth price. It happens 999999999 times, and, since in one second only one price can drop, the whole process takes 999999999 * 3 = 2999999997 seconds. We can note that this is the minimum possible time.",CHALLENGED,"n, k = input().split()
n = int(n)
k = int(k)
price = [int(s) for s in input().split()]
minimum = min(s for s in price)
res = sum([s - minimum for s in price])
if res % k == 0:
    print(int(res / k))
else:
    print(-1)","##A
def phi(n):
    res = n
    i = 2
    while i * i <= n:
        if n % i == 0:
            while n % i == 0:
                n //= i
            res -= res // i
        i += 1
    if n > 1:
        res -= res // n
    return res

def is_primitive_root(g, p):
    # Check if g is a primitive root modulo p
    order = phi(p)  # The order of the multiplicative group mod p
    for i in range(1, order):
        if pow(g, i, p) == 1:
            return False
    return True

def count_primitive_roots(p):
    count = 0
    # Check each number from 2 to p-1
    for g in range(2, p):
        if is_primitive_root(g, p):
            count += 1
    return count

# Read input
p = int(input().strip())
# Output the number of primitive roots
print(count_primitive_roots(p))"
204,A,Little Elephant and Interval,PROGRAMMING,"['binary search', 'combinatorics', 'dp']","The Little Elephant very much loves sums on intervals.

This time he has a pair of integers *l* and *r* (*l*<=≤<=*r*). The Little Elephant has to find the number of such integers *x* (*l*<=≤<=*x*<=≤<=*r*), that the first digit of integer *x* equals the last one (in decimal notation). For example, such numbers as 101, 477474 or 9 will be included in the answer and 47, 253 or 1020 will not.

Help him and count the number of described numbers *x* for a given pair *l* and *r*.","The single line contains a pair of integers *l* and *r* (1<=≤<=*l*<=≤<=*r*<=≤<=1018) — the boundaries of the interval.

Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use cin, cout streams or the %I64d specifier.",On a single line print a single integer — the answer to the problem.,"['2 47\n', '47 1024\n']","['12\n', '98\n']","In the first sample the answer includes integers 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44.",OK,"def f(x):
    if x < 10:
        return x
    if str(x)[0] > str(x)[-1]:
        return x // 10 + 8
    else:
        return x // 10 + 9
l, r = map(int, input().split())
print(f(r) - f(l - 1))","monday, tuesday, wednesday, thursday, friday, saturday, sunday = range(7)

week = [""monday"", ""tuesday"", ""wednesday"", ""thursday"", ""friday"", ""saturday"", ""sunday""]

day1 = input()
day2 = input()

# Find the index of the given days in the week
index1 = week.index(day1)
index2 = week.index(day2)

# List of days in each month for non-leap years
month_days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]

# Check if the day difference between two months can be valid
for days in month_days:
    # Calculate the difference in days and wrap around the week
    if (index1 + days) % 7 == index2:
        print(""YES"")
        break
else:
    print(""NO"")"
770,A,New Password,PROGRAMMING,"['*special', 'implementation']","Innokentiy decides to change the password in the social net ""Contact!"", but he is too lazy to invent a new password by himself. That is why he needs your help. 

Innokentiy decides that new password should satisfy the following conditions:
 -  the length of the password must be equal to *n*, -  the password should consist only of lowercase Latin letters, -  the number of distinct symbols in the password must be equal to *k*, -  any two consecutive symbols in the password must be distinct. 
Your task is to help Innokentiy and to invent a new password which will satisfy all given conditions.","The first line contains two positive integers *n* and *k* (2<=≤<=*n*<=≤<=100, 2<=≤<=*k*<=≤<=*min*(*n*,<=26)) — the length of the password and the number of distinct symbols in it. 

Pay attention that a desired new password always exists.",Print any password which satisfies all conditions given by Innokentiy.,"['4 3\n', '6 6\n', '5 2\n']","['java\n', 'python\n', 'phphp\n']","In the first test there is one of the appropriate new passwords — java, because its length is equal to 4 and 3 distinct lowercase letters a, j and v are used in it.

In the second test there is one of the appropriate new passwords — python, because its length is equal to 6 and it consists of 6 distinct lowercase letters.

In the third test there is one of the appropriate new passwords — phphp, because its length is equal to 5 and 2 distinct lowercase letters p and h are used in it.

Pay attention the condition that no two identical symbols are consecutive is correct for all appropriate passwords in tests.",OK,"n, k = map(int,input().split())

print(('abcdefghijklmnopqrstuvwxyz' [:k]*n )[:n])","def ap_function(a, d, n):
    ans = a + (d * (n - 1))
    return ans

n, S = map(int, input().split())
arr = list(map(int, input().split()))

# Sort the base costs to minimize total costs when buying items
arr.sort()

# Initialize variables to track maximum items and their total cost
max_items = 0
min_cost = 0

# Check for the maximum number of items Sagheer can buy
for k in range(1, n + 1):
    # Calculate the total cost for k items
    total_cost = sum(ap_function(arr[i], i + 1, k) for i in range(k))
    
    # If total cost exceeds budget, break
    if total_cost > S:
        break
    
    # Update max_items and min_cost with current values
    max_items = k
    min_cost = total_cost

# Output the max items and minimum cost
print(max_items, min_cost)"
935,A,Fafa and his Company,PROGRAMMING,"['brute force', 'implementation']","Fafa owns a company that works on huge projects. There are *n* employees in Fafa's company. Whenever the company has a new project to start working on, Fafa has to divide the tasks of this project among all the employees.

Fafa finds doing this every time is very tiring for him. So, he decided to choose the best *l* employees in his company as team leaders. Whenever there is a new project, Fafa will divide the tasks among only the team leaders and each team leader will be responsible of some positive number of employees to give them the tasks. To make this process fair for the team leaders, each one of them should be responsible for the same number of employees. Moreover, every employee, who is not a team leader, has to be under the responsibility of exactly one team leader, and no team leader is responsible for another team leader.

Given the number of employees *n*, find in how many ways Fafa could choose the number of team leaders *l* in such a way that it is possible to divide employees between them evenly.",The input consists of a single line containing a positive integer *n* (2<=≤<=*n*<=≤<=105) — the number of employees in Fafa's company.,Print a single integer representing the answer to the problem.,"['2\n', '10\n']","['1\n', '3\n']","In the second sample Fafa has 3 ways:
 -  choose only 1 employee as a team leader with 9 employees under his responsibility. -  choose 2 employees as team leaders with 4 employees under the responsibility of each of them. -  choose 5 employees as team leaders with 1 employee under the responsibility of each of them.",OK,"# A. Fafa and his Company
 
n = int(input())
i = 1
cont = 0
while i <= n/2:
  e = n - i
  if e % i == 0:
    cont += 1
  i += 1
print(cont)","def insertion_sort(l):
    for i in range(len(l)):
        for j in (range(i)):
            k = i - j
            if l[k] >= l[k - 1]:
                l[k - 1], l[k] = l[k], l[k - 1]
            else:
                break

# Read number of USB drives
n = int(input())
# Read file size
m = int(input())
# Read the capacities of USB drives
capacities = [int(input()) for _ in range(n)]

# Sort the capacities in ascending order
insertion_sort(capacities)

# Initialize variables
total_capacity = 0
num_drives = 0

# Select drives from the largest to the smallest until the file can fit
for capacity in reversed(capacities):
    total_capacity += capacity
    num_drives += 1
    if total_capacity >= m:
        break

# Print the minimum number of USB drives needed
print(num_drives)"
0,none,none,none,['none'],"Карта звёздного неба представляет собой прямоугольное поле, состоящее из *n* строк по *m* символов в каждой строке. Каждый символ — это либо «.» (означает пустой участок неба), либо «*» (означает то, что в этом месте на небе есть звезда). 

Новое издание карты звёздного неба будет напечатано на квадратных листах, поэтому требуется найти минимально возможную сторону квадрата, в который могут поместиться все звезды. Границы искомого квадрата должны быть параллельны сторонам заданного прямоугольного поля.","В первой строке входных данных записаны два числа *n* и *m* (1<=≤<=*n*,<=*m*<=≤<=1000) — количество строк и столбцов на карте звездного неба.

В следующих *n* строках задано по *m* символов. Каждый символ — это либо «.» (пустой участок неба), либо «*» (звезда).

Гарантируется, что на небе есть хотя бы одна звезда.","Выведите одно число — минимально возможную сторону квадрата, которым можно накрыть все звезды.","['4 4\n....\n..*.\n...*\n..**\n', '1 3\n*.*\n', '2 1\n.\n*\n']","['3\n', '3\n', '1\n']","Один из возможных ответов на первый тестовый пример:

Один из возможных ответов на второй тестовый пример (обратите внимание, что покрывающий квадрат выходит за пределы карты звездного неба):

Ответ на третий тестовый пример:",TIME_LIMIT_EXCEEDED,"gran = [int(i) for i in input().split()];
zvs = [];
dull = [];
strok = [];
stolb = [];
for i in range(gran[0]):
    nm = [[str(l) for l in input()]]
    dull += nm;
for zv in range(len(dull)):
    for zvj in range(len(dull[0])):
        if dull[zv][int(zvj)] == '*':
            strok.append(int(zv))
            stolb.append(int(zvj))
strok.sort()
Xst = int(max(strok)) - int(min(strok)) + 1;
stolb.sort()
Yst = int(max(stolb)) - int(min(stolb)) + 1;
if Xst >= Yst:
    print(Xst)
else:
    print(Yst);","from sys import stdin

def solve():
    n, m = map(int, stdin.readline().split())
    a = list(map(int, stdin.readline().split()))
    
    # Create an array to store the distinct counts from the end to the beginning
    distinct_counts = [0] * n
    last_seen = {}
    distinct_count = 0
    
    # Traverse the array from the end to the beginning
    for i in range(n - 1, -1, -1):
        if a[i] not in last_seen:
            distinct_count += 1  # We found a new distinct element
        last_seen[a[i]] = i  # Record the position of the element
        distinct_counts[i] = distinct_count  # Store the count of distinct numbers
    
    # Handle the queries
    for _ in range(m):
        l = int(stdin.readline().strip()) - 1  # Convert 1-based to 0-based index
        print(distinct_counts[l])  # Output the count of distinct numbers from l to n"
842,A,Kirill And The Game,PROGRAMMING,"['brute force', 'two pointers']","Kirill plays a new computer game. He came to the potion store where he can buy any potion. Each potion is characterized by two integers — amount of experience and cost. The efficiency of a potion is the ratio of the amount of experience to the cost. Efficiency may be a non-integer number.

For each two integer numbers *a* and *b* such that *l*<=≤<=*a*<=≤<=*r* and *x*<=≤<=*b*<=≤<=*y* there is a potion with experience *a* and cost *b* in the store (that is, there are (*r*<=-<=*l*<=+<=1)·(*y*<=-<=*x*<=+<=1) potions).

Kirill wants to buy a potion which has efficiency *k*. Will he be able to do this?","First string contains five integer numbers *l*, *r*, *x*, *y*, *k* (1<=≤<=*l*<=≤<=*r*<=≤<=107, 1<=≤<=*x*<=≤<=*y*<=≤<=107, 1<=≤<=*k*<=≤<=107).","Print ""YES"" without quotes if a potion with efficiency exactly *k* can be bought in the store and ""NO"" without quotes otherwise.

You can output each of the letters in any register.","['1 10 1 10 1\n', '1 5 6 10 1\n']","['YES', 'NO']",none,COMPILATION_ERROR,"#include <stdio.h>
int main()
{
    long long int l,r,x,y,i;
    int k,a=0;
    scanf(""%lld %lld %lld %lld %d"",&l,&r,&x,&y,&k);
    if (x>r)
    {
        printf(""NO\n"");
    }
    else
    {
        for (i=l; i<=r; i++)
        {
            if ((i/k) >=x && (i/k) <=y)
            {
                a++;
                if (a>0)
                {
                    break;
                }
            }
        }
        if (a>0)
        {
            printf(""YES\n"");
        }
        else
        {
            printf(""NO\n"");
        }
    }
    return 0;
}
","def answer():
    a = int(input())
    b = list(map(int, input().split()))
    c = set()  # To keep track of socks on the table
    max_socks_on_table = 0  # To keep the maximum count of socks on the table at any time

    for x in b:
        if x in c:
            # If the pair is already on the table, remove it (put to the wardrobe)
            c.remove(x)
        else:
            # If the pair is not on the table, add the sock
            c.add(x)
            # Update the maximum socks count on the table
            max_socks_on_table = max(max_socks_on_table, len(c))

    print(max_socks_on_table)"
976,A,Minimum Binary Number,PROGRAMMING,['implementation'],"String can be called correct if it consists of characters ""0"" and ""1"" and there are no redundant leading zeroes. Here are some examples: ""0"", ""10"", ""1001"".

You are given a correct string *s*.

You can perform two different operations on this string: 
 1.  swap any pair of adjacent characters (for example, ""101""  ""110""); 1.  replace ""11"" with ""1"" (for example, ""110""  ""10""). 
Let *val*(*s*) be such a number that *s* is its binary representation.

Correct string *a* is less than some other correct string *b* iff *val*(*a*)<=&lt;<=*val*(*b*).

Your task is to find the minimum correct string that you can obtain from the given one using the operations described above. You can use these operations any number of times in any order (or even use no operations at all).","The first line contains integer number *n* (1<=≤<=*n*<=≤<=100) — the length of string *s*.

The second line contains the string *s* consisting of characters ""0"" and ""1"". It is guaranteed that the string *s* is correct.",Print one string — the minimum correct string that you can obtain from the given one.,"['4\n1001\n', '1\n1\n']","['100\n', '1\n']","In the first example you can obtain the answer by the following sequence of operations: ""1001"" <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> ""1010"" <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> ""1100"" <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> ""100"".

In the second example you can't obtain smaller answer no matter what operations you use.",WRONG_ANSWER,"#http://codeforces.com/problemset/problem/976/A

def minBin(s):
    ones = 0
    zeros = 0
    for letter in s:
        if letter == ""1"":
            ones += 1
        else:
            zeros += 1
    if ones == 0:
        return 0
    return ""1""+""0""*zeros

print(minBin(""1001""))

while True:
    try:
        input()
        binary = input()
        print(minBin(binary))
    except EOFError:
        break
","def create_symmetrical_matrix(n, k):
    # If k is larger than the maximum number of ones in the matrix, or the matrix size is too small, return -1
    max_ones = (n * n) // 2 + (n % 2)  # Include center element if n is odd
    if k > max_ones or k < 0:
        return -1

    # Create an empty matrix of zeros
    matrix = [[0] * n for _ in range(n)]
    
    # Fill the matrix to be symmetrical and lexicographically maximal
    for i in range(n):
        for j in range(i, n):  # Start from diagonal and fill upwards
            if k >= 2 and i != j:
                matrix[i][j] = 1
                matrix[j][i] = 1
                k -= 2
            elif k >= 1 and i == j:
                matrix[i][j] = 1
                k -= 1

            # Stop if we have used all k ones
            if k == 0:
                break
        if k == 0:
            break

    return matrix

# Example usage:
n, k = map(int, input().split())
result = create_symmetrical_matrix(n, k)
if result == -1:
    print(-1)
else:
    for row in result:
        print(' '.join(map(str, row)))"
143,A,Help Vasilisa the Wise 2,PROGRAMMING,"['brute force', 'math']","Vasilisa the Wise from the Kingdom of Far Far Away got a magic box with a secret as a present from her friend Hellawisa the Wise from the Kingdom of A Little Closer. However, Vasilisa the Wise does not know what the box's secret is, since she cannot open it again. She hopes that you will help her one more time with that.

The box's lock looks as follows: it contains 4 identical deepenings for gems as a 2<=×<=2 square, and some integer numbers are written at the lock's edge near the deepenings. The example of a lock is given on the picture below.

The box is accompanied with 9 gems. Their shapes match the deepenings' shapes and each gem contains one number from 1 to 9 (each number is written on exactly one gem). The box will only open after it is decorated with gems correctly: that is, each deepening in the lock should be filled with exactly one gem. Also, the sums of numbers in the square's rows, columns and two diagonals of the square should match the numbers written at the lock's edge. For example, the above lock will open if we fill the deepenings with gems with numbers as is shown on the picture below.

Now Vasilisa the Wise wants to define, given the numbers on the box's lock, which gems she should put in the deepenings to open the box. Help Vasilisa to solve this challenging task.","The input contains numbers written on the edges of the lock of the box. The first line contains space-separated integers *r*1 and *r*2 that define the required sums of numbers in the rows of the square. The second line contains space-separated integers *c*1 and *c*2 that define the required sums of numbers in the columns of the square. The third line contains space-separated integers *d*1 and *d*2 that define the required sums of numbers on the main and on the side diagonals of the square (1<=≤<=*r*1,<=*r*2,<=*c*1,<=*c*2,<=*d*1,<=*d*2<=≤<=20). Correspondence between the above 6 variables and places where they are written is shown on the picture below. For more clarifications please look at the second sample test that demonstrates the example given in the problem statement.","Print the scheme of decorating the box with stones: two lines containing two space-separated integers from 1 to 9. The numbers should be pairwise different. If there is no solution for the given lock, then print the single number ""-1"" (without the quotes).

If there are several solutions, output any.","['3 7\n4 6\n5 5\n', '11 10\n13 8\n5 16\n', '1 2\n3 4\n5 6\n', '10 10\n10 10\n10 10\n']","['1 2\n3 4\n', '4 7\n9 1\n', '-1\n', '-1\n']","Pay attention to the last test from the statement: it is impossible to open the box because for that Vasilisa the Wise would need 4 identical gems containing number ""5"". However, Vasilisa only has one gem with each number from 1 to 9.",WRONG_ANSWER,"def solution(r,c,d):
    n1=n2=n3=n4=0
    for i in range(1,10):
        n1=i
        n2=r[0]-i
        n3=c[0]-i
        n4=d[0]-i

        if (n2 in range(1,10)) and (n3 in range(1,10)) and (n4 in range(1,10)) and n1!=n2!=n3!=n4:
            if n3+n4==r[1] and n2+n4==c[1] and n2+n3==d[1]:
                print(""{} {}"".format(n1,n2))  
                print(""{} {}"".format(n3,n4))
                return

    print(-1)




r=list(map(int,input('').split()))
c=list(map(int,input('').split()))
d=list(map(int,input('').split()))
solution(r,c,d)","def se(m, b, s, v):
    if s == ""x"":
        return (m * b - v) // m
    elif s == ""y"":
        return (m * b - v) // b

def max_bananas(m, b):
    max_bananas_count = 0
    
    # Iterate over all possible values of x and y
    for x in range(m + 1):
        for y in range(b + 1):
            # Calculate the corresponding number of bananas
            bananas = x * (y * (m - x) // m)
            if y <= se(m, b, ""x"", x * y):  # check if it's below the line
                max_bananas_count = max(max_bananas_count, bananas)

    return max_bananas_count

# Input reading
m, b = map(int, input().split())
print(max_bananas(m, b))"
111,A,Petya and Inequiations,PROGRAMMING,['greedy'],"Little Petya loves inequations. Help him find *n* positive integers *a*1,<=*a*2,<=...,<=*a**n*, such that the following two conditions are satisfied:
-  *a*12<=+<=*a*22<=+<=...<=+<=*a**n*2<=≥<=*x*-  *a*1<=+<=*a*2<=+<=...<=+<=*a**n*<=≤<=*y*","The first line contains three space-separated integers *n*, *x* and *y* (1<=≤<=*n*<=≤<=105,<=1<=≤<=*x*<=≤<=1012,<=1<=≤<=*y*<=≤<=106).

Please do not use the %lld specificator to read or write 64-bit integers in С++. It is recommended to use cin, cout streams or the %I64d specificator.","Print *n* positive integers that satisfy the conditions, one integer per line. If such numbers do not exist, print a single number ""-1"". If there are several solutions, print any of them.","['5 15 15\n', '2 3 2\n', '1 99 11\n']","['4\n4\n1\n1\n2\n', '-1\n', '11\n']",none,WRONG_ANSWER,"n, x, y = map(int, input().split())

if x <= (n-1) + (y - (n-1))**2 and y >= (n-1) + (y - (n-1)):
    for i in range(n-1):
        print(1)
    print(y - (n-1))
else:
    print(-1111111111)","def process():
    n = int(input())
    arr = list(map(int, input().split()))
    
    min_index = -1
    min_value = float('inf')  # initialize min_value to infinity
    min_count = 0              # initialize count of min_value occurrences
    
    # Iterate through the travel times to find the minimum
    for i in range(n):
        if arr[i] < min_value:
            min_value = arr[i]  # update min_value
            min_index = i + 1   # update min_index (1-based)
            min_count = 1        # reset min_count
        elif arr[i] == min_value:
            min_count += 1       # increment count of occurrences
    
    # Determine the output
    if min_count > 1:
        print(""Still Rozdil"")    # more than one town has the minimum time
    else:
        print(min_index)         # print the index of the town"
551,A,GukiZ and Contest,PROGRAMMING,"['brute force', 'implementation', 'sortings']","Professor GukiZ likes programming contests. He especially likes to rate his students on the contests he prepares. Now, he has decided to prepare a new contest. 

In total, *n* students will attend, and before the start, every one of them has some positive integer rating. Students are indexed from 1 to *n*. Let's denote the rating of *i*-th student as *a**i*. After the contest ends, every student will end up with some positive integer position. GukiZ expects that his students will take places according to their ratings. 

He thinks that each student will take place equal to . In particular, if student *A* has rating strictly lower then student *B*, *A* will get the strictly better position than *B*, and if two students have equal ratings, they will share the same position. 

GukiZ would like you to reconstruct the results by following his expectations. Help him and determine the position after the end of the contest for each of his students if everything goes as expected.","The first line contains integer *n* (1<=≤<=*n*<=≤<=2000), number of GukiZ's students. 

The second line contains *n* numbers *a*1,<=*a*2,<=... *a**n* (1<=≤<=*a**i*<=≤<=2000) where *a**i* is the rating of *i*-th student (1<=≤<=*i*<=≤<=*n*).","In a single line, print the position after the end of the contest for each of *n* students in the same order as they appear in the input.","['3\n1 3 3\n', '1\n1\n', '5\n3 5 3 4 5\n']","['3 1 1\n', '1\n', '4 1 4 3 1\n']","In the first sample, students 2 and 3 are positioned first (there is no other student with higher rating), and student 1 is positioned third since there are two students with higher rating.

In the second sample, first student is the only one on the contest.

In the third sample, students 2 and 5 share the first position with highest rating, student 4 is next with third position, and students 1 and 3 are the last sharing fourth position.",OK,"from collections import defaultdict
from typing import Counter

n = int(input())
a = [int(x) for x in input().split()]

d = defaultdict(list)

for i in range(n):
    d[a[i]].append(i)

l = sorted(d.items(), key=lambda x: -x[0])

p = 1

ans = [0 for _ in range(n)]

for t in l:
    for idx in t[1]:
        ans[idx] = p
    p += len(t[1])

print(' '.join(map(str, ans)))","def main():
    res = 1
    for c in input():
        # Each lucky digit contributes to the index value
        if c == '7':
            # If current digit is '7', it represents a higher place value
            res = res * 2 + 1
        elif c == '4':
            # If current digit is '4', it represents a lower place value
            res = res * 2
    print(res)

main()"
673,A,Bear and Game,PROGRAMMING,['implementation'],"Bear Limak likes watching sports on TV. He is going to watch a game today. The game lasts 90 minutes and there are no breaks.

Each minute can be either interesting or boring. If 15 consecutive minutes are boring then Limak immediately turns TV off.

You know that there will be *n* interesting minutes *t*1,<=*t*2,<=...,<=*t**n*. Your task is to calculate for how many minutes Limak will watch the game.","The first line of the input contains one integer *n* (1<=≤<=*n*<=≤<=90) — the number of interesting minutes.

The second line contains *n* integers *t*1,<=*t*2,<=...,<=*t**n* (1<=≤<=*t*1<=&lt;<=*t*2<=&lt;<=... *t**n*<=≤<=90), given in the increasing order.",Print the number of minutes Limak will watch the game.,"['3\n7 20 88\n', '9\n16 20 30 40 50 60 70 80 90\n', '9\n15 20 30 40 50 60 70 80 90\n']","['35\n', '15\n', '90\n']","In the first sample, minutes 21, 22, ..., 35 are all boring and thus Limak will turn TV off immediately after the 35-th minute. So, he would watch the game for 35 minutes.

In the second sample, the first 15 minutes are boring.

In the third sample, there are no consecutive 15 boring minutes. So, Limak will watch the whole game.",WRONG_ANSWER,"def countTotalWatchingTime(ar):
    totalMin = 0
    for time in ar:
        if time - totalMin > 15:
            return min(totalMin + 15, 90)
        else:
            totalMin = time
    return min(totalMin, 90)

n = int(input())
ar = list(map(int, input().split()))
print(countTotalWatchingTime(ar))","ans = 2e18
now = []
p = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]

def dfs(x, idx, d):
    global ans
    # If the number of divisors exceeds the target, return
    if d > n:
        return
    # If the number of divisors is exactly n, check for the minimum product
    if d == n:
        product = 1
        for i in now:
            product *= i
        ans = min(ans, product)
        return
    
    # Try adding more prime factors to the current combination
    for i in range(idx, len(p)):
        next_power = 1
        # Explore powers of the prime
        while True:
            # Append the prime raised to the current power
            now.append(p[i] ** next_power)
            dfs(x, i + 1, d * (next_power + 1))
            # Backtrack
            now.pop()
            # Stop if product exceeds the limit
            if p[i] ** next_power > ans:
                break
            next_power += 1

n = int(input())
dfs(1, 0, 1)
print(int(ans))"
665,C,Simple Strings,PROGRAMMING,"['dp', 'greedy', 'strings']","zscoder loves simple strings! A string *t* is called simple if every pair of adjacent characters are distinct. For example ab, aba, zscoder are simple whereas aa, add are not simple.

zscoder is given a string *s*. He wants to change a minimum number of characters so that the string *s* becomes simple. Help him with this task!",The only line contains the string *s* (1<=≤<=|*s*|<=≤<=2·105) — the string given to zscoder. The string *s* consists of only lowercase English letters.,"Print the simple string *s*' — the string *s* after the minimal number of changes. If there are multiple solutions, you may output any of them.

Note that the string *s*' should also consist of only lowercase English letters.","['aab\n', 'caaab\n', 'zscoder\n']","['bab\n', 'cabab\n', 'zscoder\n']",none,TIME_LIMIT_EXCEEDED,"p = {'a','b','c'}
s=input();t=len(s)
ans=s[0]
for x in range(1,t):
    if ans[-1] == s[x]:
        if x+1 !=t:
            ans+=(p-{ans[-1],s[x+1]}).pop()
        else:
            ans+=(p-{ans[-1]}).pop()
    else:
        ans+=s[x]
print(ans)","from sys import stdin

def read(): return map(int, stdin.readline().split())

def gcd(a, b): return a if b == 0 else gcd(b, a % b)

def continued_fraction_to_fraction(a):
    """"""Convert continued fraction to numerator and denominator.""""""
    numerator = 1
    denominator = a[-1]
    for coeff in reversed(a[:-1]):
        numerator, denominator = denominator, coeff * denominator + numerator
    return numerator, denominator

def main():
    # Read first fraction
    p, q = read()

    # Read height of continued fraction
    n = int(stdin.readline().strip())

    # Read continued fraction coefficients
    a = list(read())

    # Convert continued fraction to a rational number (numerator, denominator)
    numerator, denominator = continued_fraction_to_fraction(a)

    # Normalize both fractions by their gcd to compare
    g1 = gcd(p, q)
    p //= g1
    q //= g1
    
    g2 = gcd(numerator, denominator)
    numerator //= g2
    denominator //= g2

    # Check if the two fractions are equal
    if (p == numerator) and (q == denominator):
        print(""YES"")
    else:
        print(""NO"")

if __name__ == ""__main__"":
    main()"
58,A,Chat room,PROGRAMMING,"['greedy', 'strings']","Vasya has recently learned to type and log on to the Internet. He immediately entered a chat room and decided to say hello to everybody. Vasya typed the word *s*. It is considered that Vasya managed to say hello if several letters can be deleted from the typed word so that it resulted in the word ""hello"". For example, if Vasya types the word ""ahhellllloou"", it will be considered that he said hello, and if he types ""hlelo"", it will be considered that Vasya got misunderstood and he didn't manage to say hello. Determine whether Vasya managed to say hello by the given word *s*.","The first and only line contains the word *s*, which Vasya typed. This word consisits of small Latin letters, its length is no less that 1 and no more than 100 letters.","If Vasya managed to say hello, print ""YES"", otherwise print ""NO"".","['ahhellllloou\n', 'hlelo\n']","['YES\n', 'NO\n']",none,RUNTIME_ERROR,"x = input()

h = x.count('h') 
e = x.count('e') 
l = x.count('l') 
o = x.count('o') 

H = x.count('H') 
E = x.count('E') 
L = x.count('L') 
O = x.count('O') 



if ((h>0 or H>0) and (e>0 or E>0) and (l>1 or L>1) and (o>0 or O>0) and (x.index('h') or x.index('H'))< (x.index('e') or x.index('E'))<(x.index('l') or x.index('L'))<(x.index('o') or x.index('O'))):
	print('YES')
else:
	print('NO')","def solve():
    n = int(input())
    mod = 10 ** 6 + 3
    if (n == 0):
        # If n is 0, the box has no size, so there are 0 empty cells
        print(0)
        return
    
    # Calculate the total area of the box
    total_cells = (2 ** n) ** 2
    
    # Initialize variables
    filled_cells = 0
    size = 2 ** n
    
    # While the largest cookie size can fit in the box
    while size >= 2:
        # Best position for the largest cookie
        # Fill the area with this cookie size
        filled_cells += size * size
        # Reduce size for next iteration
        size //= 2
    
    # Calculate empty cells
    empty_cells = (total_cells - filled_cells) % mod
    print(empty_cells)"
371,C,Hamburgers,PROGRAMMING,"['binary search', 'brute force']","Polycarpus loves hamburgers very much. He especially adores the hamburgers he makes with his own hands. Polycarpus thinks that there are only three decent ingredients to make hamburgers from: a bread, sausage and cheese. He writes down the recipe of his favorite ""Le Hamburger de Polycarpus"" as a string of letters 'B' (bread), 'S' (sausage) и 'C' (cheese). The ingredients in the recipe go from bottom to top, for example, recipe ""ВSCBS"" represents the hamburger where the ingredients go from bottom to top as bread, sausage, cheese, bread and sausage again.

Polycarpus has *n**b* pieces of bread, *n**s* pieces of sausage and *n**c* pieces of cheese in the kitchen. Besides, the shop nearby has all three ingredients, the prices are *p**b* rubles for a piece of bread, *p**s* for a piece of sausage and *p**c* for a piece of cheese.

Polycarpus has *r* rubles and he is ready to shop on them. What maximum number of hamburgers can he cook? You can assume that Polycarpus cannot break or slice any of the pieces of bread, sausage or cheese. Besides, the shop has an unlimited number of pieces of each ingredient.","The first line of the input contains a non-empty string that describes the recipe of ""Le Hamburger de Polycarpus"". The length of the string doesn't exceed 100, the string contains only letters 'B' (uppercase English B), 'S' (uppercase English S) and 'C' (uppercase English C).

The second line contains three integers *n**b*, *n**s*, *n**c* (1<=≤<=*n**b*,<=*n**s*,<=*n**c*<=≤<=100) — the number of the pieces of bread, sausage and cheese on Polycarpus' kitchen. The third line contains three integers *p**b*, *p**s*, *p**c* (1<=≤<=*p**b*,<=*p**s*,<=*p**c*<=≤<=100) — the price of one piece of bread, sausage and cheese in the shop. Finally, the fourth line contains integer *r* (1<=≤<=*r*<=≤<=1012) — the number of rubles Polycarpus has.

Please, do not write the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.","Print the maximum number of hamburgers Polycarpus can make. If he can't make any hamburger, print 0.","['BBBSSC\n6 4 1\n1 2 3\n4\n', 'BBC\n1 10 1\n1 10 1\n21\n', 'BSC\n1 1 1\n1 1 3\n1000000000000\n']","['2\n', '7\n', '200000000001\n']",none,OK,"s=input()
dic={""B"":0,""S"":0,""C"":0}
nb,ns,nc=[int(i) for i in input().split()]
pb,ps,pc=[int(i) for i in input().split()]
amount=int(input())
low=0
high=10**17
for i in s:
    dic[i]+=1
while low <= high:
    mid=(high+low)//2
    burger=mid*dic[""B""] - nb
    sausage=mid*dic[""S""]-ns
    cheese=mid*dic[""C""]-nc
    cost=max(0,burger)*pb+max(0,sausage)*ps+max(0,cheese)*pc
    if cost <= amount:
        low=mid+1
    else:
        high=mid-1
print(high)
","def factory(a, m):
    s = set()
    while a % m != 0:
        r = a % m
        # If the current value of a has already been seen, we are in a loop
        if a in s:
            print(""No"")
            return
        # Store the current value of a
        s.add(a)
        # Update a by adding the remainder r
        a += r
    print(""Yes"")"
369,A,Valera and Plates,PROGRAMMING,"['greedy', 'implementation']","Valera is a lazy student. He has *m* clean bowls and *k* clean plates. 

Valera has made an eating plan for the next *n* days. As Valera is lazy, he will eat exactly one dish per day. At that, in order to eat a dish, he needs exactly one clean plate or bowl. We know that Valera can cook only two types of dishes. He can eat dishes of the first type from bowls and dishes of the second type from either bowls or plates. 

When Valera finishes eating, he leaves a dirty plate/bowl behind. His life philosophy doesn't let him eat from dirty kitchenware. So sometimes he needs to wash his plate/bowl before eating. Find the minimum number of times Valera will need to wash a plate/bowl, if he acts optimally.","The first line of the input contains three integers *n*, *m*, *k* (1<=≤<=*n*,<=*m*,<=*k*<=≤<=1000) — the number of the planned days, the number of clean bowls and the number of clean plates.

The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=2). If *a**i* equals one, then on day *i* Valera will eat a first type dish. If *a**i* equals two, then on day *i* Valera will eat a second type dish.",Print a single integer — the minimum number of times Valera will need to wash a plate/bowl.,"['3 1 1\n1 2 1\n', '4 3 1\n1 1 1 1\n', '3 1 2\n2 2 2\n', '8 2 2\n1 2 1 2 1 2 1 2\n']","['1\n', '1\n', '0\n', '4\n']","In the first sample Valera will wash a bowl only on the third day, so the answer is one.

In the second sample, Valera will have the first type of the dish during all four days, and since there are only three bowls, he will wash a bowl exactly once.

In the third sample, Valera will have the second type of dish for all three days, and as they can be eaten from either a plate or a bowl, he will never need to wash a plate/bowl.",OK,"# cook your dish here
n, b, p = map(int,input().split())
ls = list(map(int, input().split()))
ans = n - min(ls.count(2), p) - b
if ans<=0:
    print(0)
else:
    print(ans)","from collections import OrderedDict

def check_obfuscation(S):
    # Extract unique identifiers while maintaining the order
    identifiers = OrderedDict()
    current_identifier = """"
    
    for char in S:
        current_identifier += char
        # If the next character is not the same, we assume we hit a new identifier
        if len(identifiers) < 26 and (len(current_identifier) == 1 or char != S[S.index(current_identifier) - 1]):
            identifiers[current_identifier] = len(identifiers) + 1
            current_identifier = """"
        
    if current_identifier:
        identifiers[current_identifier] = len(identifiers) + 1

    # Check if the number of unique identifiers does not exceed 26
    return ""YES"" if len(identifiers) <= 26 else ""NO""

# Input reading
S = input().strip()
print(check_obfuscation(S))"
978,A,Remove Duplicates,PROGRAMMING,['implementation'],"Petya has an array $a$ consisting of $n$ integers. He wants to remove duplicate (equal) elements.

Petya wants to leave only the rightmost entry (occurrence) for each element of the array. The relative order of the remaining unique elements should not be changed.","The first line contains a single integer $n$ ($1 \le n \le 50$) — the number of elements in Petya's array.

The following line contains a sequence $a_1, a_2, \dots, a_n$ ($1 \le a_i \le 1\,000$) — the Petya's array.","In the first line print integer $x$ — the number of elements which will be left in Petya's array after he removed the duplicates.

In the second line print $x$ integers separated with a space — Petya's array after he removed the duplicates. For each unique element only the rightmost entry should be left.","['6\n1 5 5 1 6 1\n', '5\n2 4 2 4 4\n', '5\n6 6 6 6 6\n']","['3\n5 6 1 \n', '2\n2 4 \n', '1\n6 \n']","In the first example you should remove two integers $1$, which are in the positions $1$ and $4$. Also you should remove the integer $5$, which is in the position $2$.

In the second example you should remove integer $2$, which is in the position $1$, and two integers $4$, which are in the positions $2$ and $4$.

In the third example you should remove four integers $6$, which are in the positions $1$, $2$, $3$ and $4$.",WRONG_ANSWER,"a=6
l=[]
b=[1 ,5 ,5, 1, 6, 1]
for i in b:
    if i not in l :
        l.append(i)
print(len(l))
for i in l:
    print(i,end=' ')","def findSup(n):
    # Create a list to store the immediate manager of each employee
    managers = list(map(int, input().split()))
    
    # Create an adjacency list to represent the hierarchy
    hierarchy = [[] for _ in range(n + 1)]
    
    for i in range(n):
        if managers[i] != -1:
            hierarchy[managers[i]].append(i + 1)  # Store i+1 since employees are 1-indexed

    # Function to perform DFS and find the height of the hierarchy
    def dfs(emp):
        max_depth = 0
        for subordinate in hierarchy[emp]:
            max_depth = max(max_depth, dfs(subordinate))
        return max_depth + 1

    # Initialize the number of groups needed
    max_groups = 0

    # Iterate through all employees to find the height of each tree
    for emp in range(1, n + 1):
        if managers[emp - 1] == -1:  # Employee with no manager
            max_groups = max(max_groups, dfs(emp))

    return max_groups

n = int(input())
print(findSup(n))"
576,A,Vasya and Petya's Game,PROGRAMMING,"['math', 'number theory']","Vasya and Petya are playing a simple game. Vasya thought of number *x* between 1 and *n*, and Petya tries to guess the number.

Petya can ask questions like: ""Is the unknown number divisible by number *y*?"".

The game is played by the following rules: first Petya asks all the questions that interest him (also, he can ask no questions), and then Vasya responds to each question with a 'yes' or a 'no'. After receiving all the answers Petya should determine the number that Vasya thought of.

Unfortunately, Petya is not familiar with the number theory. Help him find the minimum number of questions he should ask to make a guaranteed guess of Vasya's number, and the numbers *y**i*, he should ask the questions about.",A single line contains number *n* (1<=≤<=*n*<=≤<=103).,"Print the length of the sequence of questions *k* (0<=≤<=*k*<=≤<=*n*), followed by *k* numbers — the questions *y**i* (1<=≤<=*y**i*<=≤<=*n*).

If there are several correct sequences of questions of the minimum length, you are allowed to print any of them.","['4\n', '6\n']","['3\n2 4 3 \n', '4\n2 4 3 5 \n']","The sequence from the answer to the first sample test is actually correct.

If the unknown number is not divisible by one of the sequence numbers, it is equal to 1.

If the unknown number is divisible by 4, it is 4.

If the unknown number is divisible by 3, then the unknown number is 3.

Otherwise, it is equal to 2. Therefore, the sequence of questions allows you to guess the unknown number. It can be shown that there is no correct sequence of questions of length 2 or shorter.",WRONG_ANSWER,"n=int(input())
a = [i for i in range(2, n+1)]
def calculaDivisiores(num):
  atual = 2
  divs = []
  while atual<=(num//2)+1:
    if num%atual==0:
      divs.append(atual)
    atual+=1
  return divs 

res = []
for num in a:
  divs = calculaDivisiores(num)
  if len(divs)==1:
    res.append(num)
  else:
    res.append(num)
    for div1 in divs:
      for div2 in divs:
        if div1!=div2:
          if div1%div2!=0:
            if num in res:
              res.remove(num)
print(len(res))
for r in res:
  print(r,end=' ')","""""""
Created on Mon Jul  6 21:28:12 2020

@author: rishi
""""""
import math

# Read the areas of the three faces
a1, a2, a3 = map(int, input().split())

# Calculate the dimensions of the parallelepiped
# a1 = x * y, a2 = y * z, a3 = z * x
# Therefore, we can find x, y, z as follows:
x = math.sqrt(a1 * a3 / a2)
y = math.sqrt(a1 * a2 / a3)
z = math.sqrt(a2 * a3 / a1)

# Calculate the sum of all edges (4 * (x + y + z))
sum_of_edges = 4 * (x + y + z)

# Output the result as an integer
print(int(sum_of_edges))"
0,none,none,none,['none'],"As usual, Sereja has array *a*, its elements are integers: *a*[1],<=*a*[2],<=...,<=*a*[*n*]. Let's introduce notation:

A swap operation is the following sequence of actions:
 -  choose two indexes *i*,<=*j* (*i*<=≠<=*j*); -  perform assignments *tmp*<==<=*a*[*i*],<=*a*[*i*]<==<=*a*[*j*],<=*a*[*j*]<==<=*tmp*. 
What maximum value of function *m*(*a*) can Sereja get if he is allowed to perform at most *k* swap operations?","The first line contains two integers *n* and *k* (1<=≤<=*n*<=≤<=200; 1<=≤<=*k*<=≤<=10). The next line contains *n* integers *a*[1], *a*[2], ..., *a*[*n*] (<=-<=1000<=≤<=*a*[*i*]<=≤<=1000).",In a single line print the maximum value of *m*(*a*) that Sereja can get if he is allowed to perform at most *k* swap operations.,"['10 2\n10 -1 2 2 2 2 2 2 -1 10\n', '5 10\n-1 -1 -1 -1 -1\n']","['32\n', '-1\n']",none,WRONG_ANSWER,"n, k = map(int, input().split())
a = list(map(int, input().split()))

res = a[0]
for l in range(n):
	for r in range(l, n):
		inside = sorted(a[l:r+1])
		outside = sorted(a[:l] + a[r+1:], reverse=True)
		
		new_res = sum(inside)
		for i in range(min(k, len(inside), len(outside))):
			if outside[i] > inside[i]:
				new_res += outside[i]-inside[i]
			else:
				break
			if new_res > res:
				res = new_res

print(res)
","from collections import defaultdict, deque, Counter
import sys
from decimal import *
from heapq import heapify, heappop, heappush
import math
import random
import string
from copy import deepcopy

MOD = 10**9 + 7

def gcd(x, y):
    while y:
        x, y = y, x % y
    return x

def count_coprime_subsequences(n, a):
    # Frequency count of elements
    freq = Counter(a)
    
    # Store the number of subsequences for each gcd
    count = [0] * (100001)
    
    # Total number of subsets (2^frequency) - 1 for non-empty
    for num, cnt in freq.items():
        count[num] = (pow(2, cnt, MOD) - 1) % MOD
    
    # Calculate coprime subsequences
    coprime_count = 0
    
    for g in range(1, 100001):  # Iterate through possible gcds
        # Calculate the total non-coprime sequences for gcd = g
        total = sum(count[multiple] for multiple in range(g, 100001, g)) % MOD
        
        # If gcd is greater than 1, subtract sequences counted for its multiples
        if g > 1:
            for multiple in range(2 * g, 100001, g):
                total = (total - count[multiple]) % MOD
        
        # The number of coprime sequences is when gcd = 1
        if g == 1:
            coprime_count = total
    
    return coprime_count

# Input reading
n = int(sys.stdin.readline().strip())
a = list(map(int, sys.stdin.readline().strip().split()))

# Output the result
print(count_coprime_subsequences(n, a))"
606,A,Magic Spheres,PROGRAMMING,['implementation'],"Carl is a beginner magician. He has *a* blue, *b* violet and *c* orange magic spheres. In one move he can transform two spheres of the same color into one sphere of any other color. To make a spell that has never been seen before, he needs at least *x* blue, *y* violet and *z* orange spheres. Can he get them (possible, in multiple actions)?","The first line of the input contains three integers *a*, *b* and *c* (0<=≤<=*a*,<=*b*,<=*c*<=≤<=1<=000<=000) — the number of blue, violet and orange spheres that are in the magician's disposal.

The second line of the input contains three integers, *x*, *y* and *z* (0<=≤<=*x*,<=*y*,<=*z*<=≤<=1<=000<=000) — the number of blue, violet and orange spheres that he needs to get.","If the wizard is able to obtain the required numbers of spheres, print ""Yes"". Otherwise, print ""No"".","['4 4 0\n2 1 2\n', '5 6 1\n2 7 2\n', '3 3 3\n2 2 2\n']","['Yes\n', 'No\n', 'Yes\n']","In the first sample the wizard has 4 blue and 4 violet spheres. In his first action he can turn two blue spheres into one violet one. After that he will have 2 blue and 5 violet spheres. Then he turns 4 violet spheres into 2 orange spheres and he ends up with 2 blue, 1 violet and 2 orange spheres, which is exactly what he needs.",OK,"a,b,c = map(int, input().split())
x,y,z = map(int, input().split())
extra = max(0, a-x)//2 + max(0, b-y)//2 + max(0, c-z)//2
need = max(0, x-a) + max(0, y-b) + max(0, z-c)
print(""Yes"" if need<=extra else ""No"")

","def a_game(n):
    a = list(map(int, input().split()))  # Read the list of integers from input
    a.sort()  # Sort the numbers
    
    # The first player will always remove the largest current number
    # The second player will always remove the smallest current number
    # After n-1 turns, the last number left will be in the middle of the sorted list
    # If n is odd, it's the middle element; if even, it's the (n//2)th element
    last_number = a[(n - 1) // 2]  # Calculate the index of the last number remaining
    
    print(last_number)  # Output the last number

# Read the number of integers
n = int(input())
a_game(n)  # Call the function with the number of integers"
462,B,Appleman and Card Game,PROGRAMMING,['greedy'],"Appleman has *n* cards. Each card has an uppercase letter written on it. Toastman must choose *k* cards from Appleman's cards. Then Appleman should give Toastman some coins depending on the chosen cards. Formally, for each Toastman's card *i* you should calculate how much Toastman's cards have the letter equal to letter on *i*th, then sum up all these quantities, such a number of coins Appleman should give to Toastman.

Given the description of Appleman's cards. What is the maximum number of coins Toastman can get?",The first line contains two integers *n* and *k* (1<=≤<=*k*<=≤<=*n*<=≤<=105). The next line contains *n* uppercase letters without spaces — the *i*-th letter describes the *i*-th card of the Appleman.,Print a single integer – the answer to the problem.,"['15 10\nDZFDFZDFDDDDDDF\n', '6 4\nYJSNPI\n']","['82\n', '4\n']",In the first test example Toastman can choose nine cards with letter D and one additional card with any letter. For each card with D he will get 9 coins and for the additional card he will get 1 coin.,WRONG_ANSWER,"n ,m = map(int ,input() .split())
a = input()
q = sorted(a)
s = [ ]
d = 1
ans = 0
for i in range(1 ,len(q)):
    if q[i - 1] == q[i] and q[i - 1] != q[-1] and q[i] != q[-1]:
        d += 1
    elif d > 1:
        s += [d]
        d = 1
w = q .count(q[-1])
s = sorted(s)[::-1]
if w > 1:
    s += [w]
if len(s) == 0:
    print(m)
else:
    for j in range(len(s)):
        if s[j] > m:
            ans += (m * m)
            m -= m
        elif s[j] < m:
            ans += (s[j] * s[j])
            m -= s[j]
        elif s[j] == m:
            ans += (s[j] * s[j])
            m -= m
    print(ans + m)
","def take_lightest_box(boxes):
    for i in range(101):
        if i in boxes:
            boxes[i] -= 1
            if boxes[i] == 0:
                del boxes[i]
            return i

def min_piles(box_strengths):
    # Count the frequency of each box strength
    box_counts = {}
    for strength in box_strengths:
        if strength in box_counts:
            box_counts[strength] += 1
        else:
            box_counts[strength] = 1

    piles = 0  # To count the number of piles needed

    while box_counts:
        piles += 1  # Start a new pile
        current_boxes = {}  # To track how many boxes we can place in this round
        
        for strength in sorted(box_counts.keys()):
            count = box_counts[strength]

            # Attempt to place boxes in the current pile
            for _ in range(count):
                if strength in current_boxes:
                    current_boxes[strength] += 1
                else:
                    current_boxes[strength] = 1

            # Remove used boxes from the original counts
            del box_counts[strength]

            # Update the remaining strength for the boxes in the current pile
            for s in list(current_boxes.keys()):
                if current_boxes[s] >= s:
                    del current_boxes[s]
                else:
                    current_boxes[s] = s - current_boxes[s]

        # Update box_counts with the remaining strengths
        for strength, count in current_boxes.items():
            if strength in box_counts:
                box_counts[strength] += count
            else:
                box_counts[strength] = count
    
    return piles

# Input Reading
n = int(input())
box_strengths = list(map(int, input().split()))

# Output Result
print(min_piles(box_strengths))"
352,B,Jeff and Periods,PROGRAMMING,"['implementation', 'sortings']","One day Jeff got hold of an integer sequence *a*1, *a*2, ..., *a**n* of length *n*. The boy immediately decided to analyze the sequence. For that, he needs to find all values of *x*, for which these conditions hold:
 -  *x* occurs in sequence *a*. -  Consider all positions of numbers *x* in the sequence *a* (such *i*, that *a**i*<==<=*x*). These numbers, sorted in the increasing order, must form an arithmetic progression. 
Help Jeff, find all *x* that meet the problem conditions.","The first line contains integer *n* (1<=≤<=*n*<=≤<=105). The next line contains integers *a*1, *a*2, ..., *a**n* (1<=≤<=*a**i*<=≤<=105). The numbers are separated by spaces.","In the first line print integer *t* — the number of valid *x*. On each of the next *t* lines print two integers *x* and *p**x*, where *x* is current suitable value, *p**x* is the common difference between numbers in the progression (if *x* occurs exactly once in the sequence, *p**x* must equal 0). Print the pairs in the order of increasing *x*.","['1\n2\n', '8\n1 2 1 3 1 2 1 5\n']","['1\n2 0\n', '4\n1 2\n2 4\n3 0\n5 0\n']","In the first test 2 occurs exactly once in the sequence, ergo *p*<sub class=""lower-index"">2</sub> = 0.",WRONG_ANSWER,"def main():
    n = int(input())
    arr = list(map(int, input().split()))

    counts = dict()

    for i in range(n):
        if arr[i] in counts:
            counts[arr[i]].append(i)
        else:
            counts[arr[i]] = [i]


    counts = sorted(counts.items(), key=lambda x: x[0])

    for k, v in counts:
        if len(v) == 1:
            print(k, 0)
        else:
            diff = set()
            for i in range(len(v) - 1):
                diff.add(v[i] - v[i + 1])

            if len(diff) == 1:
                print(k, v[1] - v[0])



main()
","import math, sys
from collections import Counter, defaultdict
from sys import stdin, stdout
# input = stdin.readline
lili = lambda: list(map(int, sys.stdin.readlines()))

p, y = lili()[0]

def can_reach(branch, grasshopper):
    # A grasshopper at 'grasshopper' can reach branches that are multiples of it
    return branch % grasshopper == 0

# Start checking from the highest branch down to 2
for branch in range(y, p, -1):
    can_be_chosen = True
    # Check only for divisors up to the square root of the branch
    for grasshopper in range(2, int(math.sqrt(branch)) + 1):
        if grasshopper > p:
            break
        if can_reach(branch, grasshopper):
            can_be_chosen = False
            break

    if can_be_chosen:
        print(branch)
        break
else:
    print(-1)"
38,A,Army,PROGRAMMING,['implementation'],"The Berland Armed Forces System consists of *n* ranks that are numbered using natural numbers from 1 to *n*, where 1 is the lowest rank and *n* is the highest rank.

One needs exactly *d**i* years to rise from rank *i* to rank *i*<=+<=1. Reaching a certain rank *i* having not reached all the previous *i*<=-<=1 ranks is impossible.

Vasya has just reached a new rank of *a*, but he dreams of holding the rank of *b*. Find for how many more years Vasya should serve in the army until he can finally realize his dream.",The first input line contains an integer *n* (2<=≤<=*n*<=≤<=100). The second line contains *n*<=-<=1 integers *d**i* (1<=≤<=*d**i*<=≤<=100). The third input line contains two integers *a* and *b* (1<=≤<=*a*<=&lt;<=*b*<=≤<=*n*). The numbers on the lines are space-separated.,Print the single number which is the number of years that Vasya needs to rise from rank *a* to rank *b*.,"['3\n5 6\n1 2\n', '3\n5 6\n1 3\n']","['5\n', '11\n']",none,OK,"def sr(ch):
    ch1=ch+' '
    l=[]
    p=''
    for i in ch1:
        if i!=' ':
            p=p+i
        else:
            l.append(int(p))
            p=''
    return l
n=int(input())
y=str(input())
z=str(input())
l=sr(y)
p=sr(z)
a=p[0]-1
b=p[1]-1
k=0
for i in range(a,b):
    k=k+l[i]
print(k)","# http://codeforces.com/problemset/problem/513/A
n1, n2, k1, k2 = [int(x) for x in input().split()]
temp = min(k1, k2)

# Calculate the total moves each player can make
total_moves1 = (n1 + temp - 1) // temp  # Moves for the first player
total_moves2 = (n2 + temp - 1) // temp  # Moves for the second player

# Determine who wins based on total moves
if (n1 % (k1 + 1) > n2 % (k2 + 1)):
    print(""First"")
else:
    print(""Second"")"
873,B,Balanced Substring,PROGRAMMING,"['dp', 'implementation']","You are given a string *s* consisting only of characters 0 and 1. A substring [*l*,<=*r*] of *s* is a string *s**l**s**l*<=+<=1*s**l*<=+<=2... *s**r*, and its length equals to *r*<=-<=*l*<=+<=1. A substring is called balanced if the number of zeroes (0) equals to the number of ones in this substring.

You have to determine the length of the longest balanced substring of *s*.","The first line contains *n* (1<=≤<=*n*<=≤<=100000) — the number of characters in *s*.

The second line contains a string *s* consisting of exactly *n* characters. Only characters 0 and 1 can appear in *s*.","If there is no non-empty balanced substring in *s*, print 0. Otherwise, print the length of the longest balanced substring.","['8\n11010111\n', '3\n111\n']","['4\n', '0\n']","In the first example you can choose the substring [3, 6]. It is balanced, and its length is 4. Choosing the substring [2, 5] is also possible.

In the second example it's impossible to find a non-empty balanced substring.",OK,"n=int(input())
T=input()
d={0:-1}
s=0
mix=0
 
for i in range(n):
	s+=1-(T[i]=='0')*2
	if s not in d:
		d[s]=i
	else:
		if(i-d[s])> mix:
			mix=i-d[s]
print(mix)","n = int(input())
points = [tuple(int(x) for x in input().split()) for _ in range(n)]
ti = list(range(1, n + 1))

def sign(x, y, z):
    return (x[0] - z[0]) * (y[1] - z[1]) - (y[0] - z[0]) * (x[1] - z[1])

def is_inside_triangle(p, a, b, c):
    d1 = sign(p, a, b)
    d2 = sign(p, b, c)
    d3 = sign(p, c, a)
    return (d1 > 0 and d2 > 0 and d3 > 0) or (d1 < 0 and d2 < 0 and d3 < 0)

# Iterate through all combinations of three stars
for i in range(n):
    for j in range(i + 1, n):
        for k in range(j + 1, n):
            a, b, c = points[i], points[j], points[k]
            valid_triangle = True
            
            for l in range(n):
                if l != i and l != j and l != k:
                    if is_inside_triangle(points[l], a, b, c):
                        valid_triangle = False
                        break
            
            if valid_triangle:
                print(ti[i], ti[j], ti[k])
                exit()"
9,A,Die Roll,PROGRAMMING,"['math', 'probabilities']","Yakko, Wakko and Dot, world-famous animaniacs, decided to rest from acting in cartoons, and take a leave to travel a bit. Yakko dreamt to go to Pennsylvania, his Motherland and the Motherland of his ancestors. Wakko thought about Tasmania, its beaches, sun and sea. Dot chose Transylvania as the most mysterious and unpredictable place.

But to their great regret, the leave turned to be very short, so it will be enough to visit one of the three above named places. That's why Yakko, as the cleverest, came up with a truly genius idea: let each of the three roll an ordinary six-sided die, and the one with the highest amount of points will be the winner, and will take the other two to the place of his/her dreams.

Yakko thrown a die and got Y points, Wakko — W points. It was Dot's turn. But she didn't hurry. Dot wanted to know for sure what were her chances to visit Transylvania.

It is known that Yakko and Wakko are true gentlemen, that's why if they have the same amount of points with Dot, they will let Dot win.",The only line of the input file contains two natural numbers Y and W — the results of Yakko's and Wakko's die rolls.,"Output the required probability in the form of irreducible fraction in format «A/B», where A — the numerator, and B — the denominator. If the required probability equals to zero, output «0/1». If the required probability equals to 1, output «1/1».",['4 2\n'],['1/2\n'],"Dot will go to Transylvania, if she is lucky to roll 4, 5 or 6 points.",OK,"from fractions import Fraction
y,w=map(int,input().split())
m=max(y,w)
c=0
for i in range(m,7):
    c=c+1
if c==0:
    print(""0/1"")
elif c==1:
    print(""1/6"")
elif c==2:
    print(""1/3"")
elif c==3:
    print(""1/2"")
elif c==4:
    print(""2/3"")
elif c==5:
    print(""5/6"")
elif c==6:
    print(""1/1"")","def zip_sorted(a,b):
    # sorted  by a
    a, b = zip(*sorted(zip(a, b)))
    # sorted by b
    a, b = zip(*sorted(zip(a, b), key=lambda x: x[1]))

    return a, b

def restore_magic_square(square):
    # Extract known values
    sum_rows = [sum(row) for row in square]
    magic_sum = (sum_rows[0] + sum_rows[1] + sum_rows[2]) // 2  # Calculate magic sum using the known row sums

    # Calculate the missing diagonal elements
    d1 = magic_sum - sum_rows[0]
    d2 = magic_sum - sum_rows[1]
    d3 = magic_sum - sum_rows[2]

    # Update the original square with the calculated diagonal values
    square[0][0] = d1
    square[1][1] = d2
    square[2][2] = d3

    return square

# Read the input
magic_square = [list(map(int, input().strip().split())) for _ in range(3)]

# Restore the magic square
restored_square = restore_magic_square(magic_square)

# Print the restored magic square
for row in restored_square:
    print("" "".join(map(str, row)))"
192,A,Funky Numbers,PROGRAMMING,"['binary search', 'brute force', 'implementation']","As you very well know, this year's funkiest numbers are so called triangular numbers (that is, integers that are representable as , where *k* is some positive integer), and the coolest numbers are those that are representable as a sum of two triangular numbers.

A well-known hipster Andrew adores everything funky and cool but unfortunately, he isn't good at maths. Given number *n*, help him define whether this number can be represented by a sum of two triangular numbers (not necessarily different)!",The first input line contains an integer *n* (1<=≤<=*n*<=≤<=109).,"Print ""YES"" (without the quotes), if *n* can be represented as a sum of two triangular numbers, otherwise print ""NO"" (without the quotes).","['256\n', '512\n']","['YES\n', 'NO\n']","In the first sample number <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/92095692c6ea93e9e3b837a0408ba7543549d5b2.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>.

In the second sample number 512 can not be represented as a sum of two triangular numbers.",COMPILATION_ERROR,"import math
def istr(x):
    ch=0
    for k in range(math.sqrt(2*x)):
        if x=k*(k+1)/2:
            return True
    return False
    
n=int(input())
ch=0
for i in range(math.sqrt(2*n)):
    if istr(n-i*(i+1)/2):
        ch=1
        print('YES')
        break
    
if ch==0:
    print('NO')","def fun(m):
    if m == 0:
        return 0
    if m == 1:
        return a[1]
    
    # Use dynamic programming to store the maximum points for each element
    dp = [0] * (m + 1)

    # Populate the frequency array
    frequency = [0] * (m + 1)
    for num in a:
        frequency[num] += 1

    # The maximum points we can get by either using the current number or skipping it
    dp[0] = 0
    dp[1] = frequency[1]

    for i in range(2, m + 1):
        # Maximum points if we use the current number
        dp[i] = max(dp[i - 1], dp[i - 2] + i * frequency[i])

    return dp[m]

# Read input data
n = int(input())
a = list(map(int, input().split()))

# Find the maximum value in the array to define the range for dynamic programming
max_value = max(a)

# Get the maximum points
result = fun(max_value)
print(result)"
731,A,Night at the Museum,PROGRAMMING,"['implementation', 'strings']","Grigoriy, like the hero of one famous comedy film, found a job as a night security guard at the museum. At first night he received embosser and was to take stock of the whole exposition.

Embosser is a special devise that allows to ""print"" the text of a plastic tape. Text is printed sequentially, character by character. The device consists of a wheel with a lowercase English letters written in a circle, static pointer to the current letter and a button that print the chosen letter. At one move it's allowed to rotate the alphabetic wheel one step clockwise or counterclockwise. Initially, static pointer points to letter 'a'. Other letters are located as shown on the picture:

After Grigoriy add new item to the base he has to print its name on the plastic tape and attach it to the corresponding exhibit. It's not required to return the wheel to its initial position with pointer on the letter 'a'.

Our hero is afraid that some exhibits may become alive and start to attack him, so he wants to print the names as fast as possible. Help him, for the given string find the minimum number of rotations of the wheel required to print it.",The only line of input contains the name of some exhibit — the non-empty string consisting of no more than 100 characters. It's guaranteed that the string consists of only lowercase English letters.,"Print one integer — the minimum number of rotations of the wheel, required to print the name given in the input.","['zeus\n', 'map\n', 'ares\n']","['18\n', '35\n', '34\n']","To print the string from the first sample it would be optimal to perform the following sequence of rotations: 
 1.  from 'a' to 'z' (1 rotation counterclockwise), 1.  from 'z' to 'e' (5 clockwise rotations), 1.  from 'e' to 'u' (10 rotations counterclockwise), 1.  from 'u' to 's' (2 counterclockwise rotations).",OK,"s=input()
start='a'
count=0
for i in s:
    diff=abs(ord(i)-ord(start))
    count+=min(diff,26-diff)
    start=i
print(count)
    ","def binpow(a, b):
    res = 1
    while b > 0:
        if b & 1:
            res *= a
        a *= a
        b //= 2
    return res

def count_parking_ways(n):
    # Calculate the total number of arrangements
    total_arrangements = binpow(4, 2 * n)
    
    # Calculate the arrangements with exactly n successive cars of the same make
    # There are 4 makes, and we can choose any of them for the successive n cars
    # Then we can fill the remaining 2*n - n = n spaces with any of the 4 makes
    ways_with_successive_cars = 4 * binpow(4, n)

    # Valid ways will be total arrangements minus the ways without n successive cars
    valid_ways = total_arrangements - ways_with_successive_cars
    
    return valid_ways

# Read the input
n = int(input().strip())
# Print the number of valid parking arrangements
print(count_parking_ways(n))"
118,A,String Task,PROGRAMMING,"['implementation', 'strings']","Petya started to attend programming lessons. On the first lesson his task was to write a simple program. The program was supposed to do the following: in the given string, consisting if uppercase and lowercase Latin letters, it: 
 -  deletes all the vowels, -  inserts a character ""."" before each consonant, -  replaces all uppercase consonants with corresponding lowercase ones. 
Vowels are letters ""A"", ""O"", ""Y"", ""E"", ""U"", ""I"", and the rest are consonants. The program's input is exactly one string, it should return the output as a single string, resulting after the program's processing the initial string.

Help Petya cope with this easy task.","The first line represents input string of Petya's program. This string only consists of uppercase and lowercase Latin letters and its length is from 1 to 100, inclusive.",Print the resulting string. It is guaranteed that this string is not empty.,"['tour\n', 'Codeforces\n', 'aBAcAba\n']","['.t.r\n', '.c.d.f.r.c.s\n', '.b.c.b\n']",none,WRONG_ANSWER,"x = input()
y = [""a"", ""A"", ""e"", ""E"", ""i"", ""I"", ""o"", ""O"", ""u"", ""U""]
x_new = """"

def string_mod(x, y, x_new):
    if x == """":
        return x_new
    if x[0] in y:
        return string_mod(x[1:], y, x_new)
    if 64<ord(x[0])<91 or 96<ord(x[0])<123:
        if 64<ord(x[0])<91:
            x_new+=f"".{chr(ord(x[0])+32)}""
            return string_mod(x[1:], y, x_new)
        x_new+=f"".{x[0]}""
        return string_mod(x[1:], y, x_new)
print(string_mod(x, y, x_new))","import sys


def solution():
    commands = sys.stdin.readlines()
    chat_members = set()  # Set to keep track of current chat members
    total_traffic = 0      # Variable to accumulate the total outgoing traffic

    for command in commands:
        command = command.strip()  # Remove any surrounding whitespace
        if command.startswith('+'):  # Add command
            name = command[1:]  # Get the name after '+'
            chat_members.add(name)  # Add the person to the chat
        elif command.startswith('-'):  # Remove command
            name = command[1:]  # Get the name after '-'
            chat_members.remove(name)  # Remove the person from the chat
        else:  # Send command
            sender, message = command.split(':', 1)  # Split into sender and message
            l = len(message)  # Length of the message
            total_traffic += l * len(chat_members)  # Calculate traffic for sending message

    print(total_traffic)  # Output the total traffic


if __name__ == ""__main__"":
    solution()"
459,A,Pashmak and Garden,PROGRAMMING,['implementation'],"Pashmak has fallen in love with an attractive girl called Parmida since one year ago...

Today, Pashmak set up a meeting with his partner in a romantic garden. Unfortunately, Pashmak has forgotten where the garden is. But he remembers that the garden looks like a square with sides parallel to the coordinate axes. He also remembers that there is exactly one tree on each vertex of the square. Now, Pashmak knows the position of only two of the trees. Help him to find the position of two remaining ones.","The first line contains four space-separated *x*1,<=*y*1,<=*x*2,<=*y*2 (<=-<=100<=≤<=*x*1,<=*y*1,<=*x*2,<=*y*2<=≤<=100) integers, where *x*1 and *y*1 are coordinates of the first tree and *x*2 and *y*2 are coordinates of the second tree. It's guaranteed that the given points are distinct.","If there is no solution to the problem, print -1. Otherwise print four space-separated integers *x*3,<=*y*3,<=*x*4,<=*y*4 that correspond to the coordinates of the two other trees. If there are several solutions you can output any of them. 

Note that *x*3,<=*y*3,<=*x*4,<=*y*4 must be in the range (<=-<=1000<=≤<=*x*3,<=*y*3,<=*x*4,<=*y*4<=≤<=1000).","['0 0 0 1\n', '0 0 1 1\n', '0 0 1 2\n']","['1 0 1 1\n', '0 1 1 0\n', '-1\n']",none,WRONG_ANSWER,"
ord = list(map(int,input().split()))

x1 = [ord[0],ord[1]]
x2 = [ord[2],ord[3]]

#point = sum(ord)//(4-ord.count(0))

arr = [True,False,False,False,False]

if ord.count(0)==0 or ord.count(0)==4:
    print(-1)
else:
    point = None
    for i in ord:
        if i!=0:
            if point==None:
                point= i
            if point!=None:
                if i!=point:
                    print(-1)
                    break
    else:
        if x1==[0,0] or x2==[0,0]:
            arr[1] = True
        if x1==[point,0] or x2==[point,0]:
            arr[2] = True
        if x1==[point,point] or x2==[point,point]:
            arr[3] = True
        if x1==[0,point] or x2==[0,point]:
            arr[4] = True
        res = ''

        if arr[1]==False:
            res+='0 0 '
        if arr[2]==False:
            res+=str(point)+"" 0 ""
        if arr[3]==False:
            res+=str(point)+"" ""+str(point)+"" ""
        if arr[4]==False:
            res+= '0 '+str(point)+ "" ""

        print(res)

","n, m, k = map(int, input().split())
k -= 1
m -= n

def check_p(p, f, n):
    # Calculate the maximum pillows Frodo can have without hurting others
    left = f  # Pillows available to the left of Frodo
    right = n - f - 1  # Pillows available to the right of Frodo

    # Setting the maximum possible pillows for Frodo initially
    max_pillows = (p // (left + 1)) + (p // (right + 1))

    # Now we will check how many pillows can be assigned to Frodo
    for i in range(max_pillows, -1, -1):
        # Calculate remaining pillows after assigning i to Frodo
        remaining_pillows = p - i

        # Calculate the distribution to the left and right
        left_max = min(remaining_pillows // left, i - 1) if left > 0 else 0
        remaining_pillows -= left_max * left
        
        right_max = min(remaining_pillows // right, i - 1) if right > 0 else 0
        
        # Check if we can assign pillows without hurting anyone
        if (left_max + right_max >= n - 1) and (remaining_pillows >= 0):
            return i
        
    return 0

# Output the maximum pillows Frodo can have
print(check_p(m, k, n))"
33,C,Wonderful Randomized Sum,PROGRAMMING,['greedy'],"Learn, learn and learn again — Valera has to do this every day. He is studying at mathematical school, where math is the main discipline. The mathematics teacher loves her discipline very much and tries to cultivate this love in children. That's why she always gives her students large and difficult homework. Despite that Valera is one of the best students, he failed to manage with the new homework. That's why he asks for your help. He has the following task. A sequence of *n* numbers is given. A prefix of a sequence is the part of the sequence (possibly empty), taken from the start of the sequence. A suffix of a sequence is the part of the sequence (possibly empty), taken from the end of the sequence. It is allowed to sequentially make two operations with the sequence. The first operation is to take some prefix of the sequence and multiply all numbers in this prefix by <=-<=1. The second operation is to take some suffix and multiply all numbers in it by <=-<=1. The chosen prefix and suffix may intersect. What is the maximum total sum of the sequence that can be obtained by applying the described operations?",The first line contains integer *n* (1<=≤<=*n*<=≤<=105) — amount of elements in the sequence. The second line contains *n* integers *a**i* (<=-<=104<=≤<=*a**i*<=≤<=104) — the sequence itself.,The first and the only line of the output should contain the answer to the problem.,"['3\n-1 -2 -3\n', '5\n-4 2 0 5 0\n', '5\n-1 10 -5 10 -2\n']","['6\n', '11\n', '18\n']",none,RUNTIME_ERROR,"n = int(input())
l = list(map(int,input().split))
suff = [0]
tot = 0

for i in range(1,n+1):
	tot += l[n - i]
	suff.append(min(0,tot,suff[i-1]))

pre = [0]

for i in range(1,n+1):
	pre.append(pre[i-1] + l[i-1])

ans = -9999999999999999999

for i in range(n+1):
	ans = max(ans,pre[n] - 2*pre[i-1] - 2*suff[n-i])

print(ans)","k, a, b = map(int, input().split())
A = [list(map(int, input().split())) for _ in range(3)]
B = [list(map(int, input().split())) for _ in range(3)]

# Initialize scores for Alice and Bob
alice_score = 0
bob_score = 0

# Simulate the games
for _ in range(k):
    if a == b:
        pass  # Draw, do nothing
    elif (a == 1 and b == 3) or (a == 2 and b == 1) or (a == 3 and b == 2):
        alice_score += 1  # Alice wins
    else:
        bob_score += 1  # Bob wins
    
    # Update choices for the next round
    a = A[a - 1][b - 1]
    b = B[b - 1][a - 1]

# Output final scores
print(alice_score, bob_score)"
266,B,Queue at the School,PROGRAMMING,"['constructive algorithms', 'graph matchings', 'implementation', 'shortest paths']","During the break the schoolchildren, boys and girls, formed a queue of *n* people in the canteen. Initially the children stood in the order they entered the canteen. However, after a while the boys started feeling awkward for standing in front of the girls in the queue and they started letting the girls move forward each second. 

Let's describe the process more precisely. Let's say that the positions in the queue are sequentially numbered by integers from 1 to *n*, at that the person in the position number 1 is served first. Then, if at time *x* a boy stands on the *i*-th position and a girl stands on the (*i*<=+<=1)-th position, then at time *x*<=+<=1 the *i*-th position will have a girl and the (*i*<=+<=1)-th position will have a boy. The time is given in seconds.

You've got the initial position of the children, at the initial moment of time. Determine the way the queue is going to look after *t* seconds.","The first line contains two integers *n* and *t* (1<=≤<=*n*,<=*t*<=≤<=50), which represent the number of children in the queue and the time after which the queue will transform into the arrangement you need to find. 

The next line contains string *s*, which represents the schoolchildren's initial arrangement. If the *i*-th position in the queue contains a boy, then the *i*-th character of string *s* equals ""B"", otherwise the *i*-th character equals ""G"".","Print string *a*, which describes the arrangement after *t* seconds. If the *i*-th position has a boy after the needed time, then the *i*-th character *a* must equal ""B"", otherwise it must equal ""G"".","['5 1\nBGGBG\n', '5 2\nBGGBG\n', '4 1\nGGGB\n']","['GBGGB\n', 'GGBGB\n', 'GGGB\n']",none,OK,"import sys

n, t = map(int, input().split())
s = input().strip()

for _ in range(t):
    i = 1
    while i < n:
        if s[i] == 'G' and s[i - 1] == 'B':
            s = s[:i - 1] + 'G' + 'B' + s[i + 1:]
            i += 1
        i += 1

print(s)
","def f(x):
    x = str(x)
    m = 1
    for i in x:
        m *= int(i) if i != '0' else 1
    return m

def g(x):
    while x >= 10:
        x = f(x)
    return x

def process_queries(queries):
    results = []
    for l, r, k in queries:
        count = 0
        for x in range(l, r + 1):
            if g(x) <= k:
                count += 1
        results.append(count)
    return results

# Input reading
Q = int(input())
queries = [tuple(map(int, input().split())) for _ in range(Q)]

# Process and print results
results = process_queries(queries)
for result in results:
    print(result)"
490,A,Team Olympiad,PROGRAMMING,"['greedy', 'implementation', 'sortings']","The School №0 of the capital of Berland has *n* children studying in it. All the children in this school are gifted: some of them are good at programming, some are good at maths, others are good at PE (Physical Education). Hence, for each child we know value *t**i*:
 -  *t**i*<==<=1, if the *i*-th child is good at programming, -  *t**i*<==<=2, if the *i*-th child is good at maths, -  *t**i*<==<=3, if the *i*-th child is good at PE 
Each child happens to be good at exactly one of these three subjects.

The Team Scientific Decathlon Olympias requires teams of three students. The school teachers decided that the teams will be composed of three children that are good at different subjects. That is, each team must have one mathematician, one programmer and one sportsman. Of course, each child can be a member of no more than one team.

What is the maximum number of teams that the school will be able to present at the Olympiad? How should the teams be formed for that?","The first line contains integer *n* (1<=≤<=*n*<=≤<=5000) — the number of children in the school. The second line contains *n* integers *t*1,<=*t*2,<=...,<=*t**n* (1<=≤<=*t**i*<=≤<=3), where *t**i* describes the skill of the *i*-th child.","In the first line output integer *w* — the largest possible number of teams. 

Then print *w* lines, containing three numbers in each line. Each triple represents the indexes of the children forming the team. You can print both the teams, and the numbers in the triplets in any order. The children are numbered from 1 to *n* in the order of their appearance in the input. Each child must participate in no more than one team. If there are several solutions, print any of them.

If no teams can be compiled, print the only line with value *w* equal to 0.","['7\n1 3 1 3 2 1 2\n', '4\n2 1 1 2\n']","['2\n3 5 2\n6 7 4\n', '0\n']",none,WRONG_ANSWER,"n = int(input())
t = list(map(int,input().split("" "")))
if (t.count(1)) < 2 or (t.count(2)) < 2 or (t.count(3)) < 2:
    print(0)
    exit()
else:
    number = min(t.count(1), t.count(2), t.count(3))
    f = []
    s = []
    third = []
    for i in range(n):
        if t[i] == 1:
            f.append(i)
        if t[i] == 2:
            s.append(i)
        if t[i] == 3:
            third.append(i)
    print(number)
    j = 0
    f = [i+1 for i in f]
    s = [i+1 for i in s]
    third = [i+1 for i in third]
    for i in range(number):
        print(f[j], s[j], third[j])
        j += 1","import sys
from math import *

def minp():
    return sys.stdin.readline().strip()

def mint():
    return map(int, minp().split())

n, x = mint()  # Read the number of boxes and the index of the last box
a = list(mint())  # Read the number of balls in each box after the actions

result = [0] * n  # Initialize the result list for the initial arrangement of balls

# The number of balls that Vasya took from the box x (1-based index)
balls_taken = a[x - 1]

# Distributing the balls back to boxes
for i in range(balls_taken):
    result[(x - 1 + i) % n] += 1

# Fill in the remaining boxes with the current state minus the balls taken
for i in range(n):
    if i != (x - 1):  # Do not add to the box x as it was replenished with balls
        result[i] += a[i]

# Print the result as space-separated integers
print("" "".join(map(str, result)))"
58,A,Chat room,PROGRAMMING,"['greedy', 'strings']","Vasya has recently learned to type and log on to the Internet. He immediately entered a chat room and decided to say hello to everybody. Vasya typed the word *s*. It is considered that Vasya managed to say hello if several letters can be deleted from the typed word so that it resulted in the word ""hello"". For example, if Vasya types the word ""ahhellllloou"", it will be considered that he said hello, and if he types ""hlelo"", it will be considered that Vasya got misunderstood and he didn't manage to say hello. Determine whether Vasya managed to say hello by the given word *s*.","The first and only line contains the word *s*, which Vasya typed. This word consisits of small Latin letters, its length is no less that 1 and no more than 100 letters.","If Vasya managed to say hello, print ""YES"", otherwise print ""NO"".","['ahhellllloou\n', 'hlelo\n']","['YES\n', 'NO\n']",none,WRONG_ANSWER,"s=input().split('+')
#split help me to make my input as i want
s.sort()
print('+'.join(s))
","from collections import defaultdict

def default_val():
    return []

def pair_cards(n, cards):
    card_dict = defaultdict(default_val)

    # Store the indices of each card value
    for idx, value in enumerate(cards):
        card_dict[value].append(idx + 1)  # Store the index (1-based)

    pairs = []

    # Check if each card can be paired
    for indices in card_dict.values():
        if len(indices) % 2 != 0:
            return -1  # Impossible to form pairs if any have an odd count
        # Create pairs by taking two indices at a time
        for i in range(0, len(indices), 2):
            pairs.append((indices[i], indices[i + 1]))

    return pairs

# Read input
n = int(input())
cards = list(map(int, input().split()))

# Get pairs of cards
result = pair_cards(n, cards)

# Output the result
if result == -1:
    print(result)
else:
    for pair in result:
        print(pair[0], pair[1])"
538,B,Quasi Binary,PROGRAMMING,"['constructive algorithms', 'dp', 'greedy', 'implementation']","A number is called quasibinary if its decimal representation contains only digits 0 or 1. For example, numbers 0, 1, 101, 110011 — are quasibinary and numbers 2, 12, 900 are not.

You are given a positive integer *n*. Represent it as a sum of minimum number of quasibinary numbers.",The first line contains a single integer *n* (1<=≤<=*n*<=≤<=106).,"In the first line print a single integer *k* — the minimum number of numbers in the representation of number *n* as a sum of quasibinary numbers.

In the second line print *k* numbers — the elements of the sum. All these numbers should be quasibinary according to the definition above, their sum should equal *n*. Do not have to print the leading zeroes in the numbers. The order of numbers doesn't matter. If there are multiple possible representations, you are allowed to print any of them.","['9\n', '32\n']","['9\n1 1 1 1 1 1 1 1 1 \n', '3\n10 11 11 \n']",none,OK,"#### B. Quasi Binary
n=int(input())
result=[]
while n:
    r=''.join(min(i,'1') for i in str(n))
    n=n-int(r)
    result.append(r)
print(len(result))
print(*result)","def solve():
    import sys
    
    # Read the input number n as a string to handle large integers
    n = sys.stdin.read().strip()
    
    # Convert the input number to an integer
    n = int(n)
    
    # Generate the palindrome number by creating half of it
    # For n-th even-length palindrome, we need to find the first half (9 is 1 to 9, 10 is 10 to 99, ...)
    half = str(n)
    first_half = half
    
    # Create the even-length palindrome by mirroring
    palindrome = first_half + first_half[::-1]
    
    # Print the n-th even-length palindrome number
    print(palindrome)"
1006,E,Military Problem,PROGRAMMING,"['dfs and similar', 'graphs', 'trees']","In this problem you will have to help Berland army with organizing their command delivery system.

There are $n$ officers in Berland army. The first officer is the commander of the army, and he does not have any superiors. Every other officer has exactly one direct superior. If officer $a$ is the direct superior of officer $b$, then we also can say that officer $b$ is a direct subordinate of officer $a$.

Officer $x$ is considered to be a subordinate (direct or indirect) of officer $y$ if one of the following conditions holds:
 -  officer $y$ is the direct superior of officer $x$; -  the direct superior of officer $x$ is a subordinate of officer $y$. 
For example, on the picture below the subordinates of the officer $3$ are: $5, 6, 7, 8, 9$.

The structure of Berland army is organized in such a way that every officer, except for the commander, is a subordinate of the commander of the army.

Formally, let's represent Berland army as a tree consisting of $n$ vertices, in which vertex $u$ corresponds to officer $u$. The parent of vertex $u$ corresponds to the direct superior of officer $u$. The root (which has index $1$) corresponds to the commander of the army.

Berland War Ministry has ordered you to give answers on $q$ queries, the $i$-th query is given as $(u_i, k_i)$, where $u_i$ is some officer, and $k_i$ is a positive integer.

To process the $i$-th query imagine how a command from $u_i$ spreads to the subordinates of $u_i$. Typical DFS (depth first search) algorithm is used here.

Suppose the current officer is $a$ and he spreads a command. Officer $a$ chooses $b$ — one of his direct subordinates (i.e. a child in the tree) who has not received this command yet. If there are many such direct subordinates, then $a$ chooses the one having minimal index. Officer $a$ gives a command to officer $b$. Afterwards, $b$ uses exactly the same algorithm to spread the command to its subtree. After $b$ finishes spreading the command, officer $a$ chooses the next direct subordinate again (using the same strategy). When officer $a$ cannot choose any direct subordinate who still hasn't received this command, officer $a$ finishes spreading the command.

Let's look at the following example:

If officer $1$ spreads a command, officers receive it in the following order: $[1, 2, 3, 5 ,6, 8, 7, 9, 4]$.

If officer $3$ spreads a command, officers receive it in the following order: $[3, 5, 6, 8, 7, 9]$.

If officer $7$ spreads a command, officers receive it in the following order: $[7, 9]$.

If officer $9$ spreads a command, officers receive it in the following order: $[9]$.

To answer the $i$-th query $(u_i, k_i)$, construct a sequence which describes the order in which officers will receive the command if the $u_i$-th officer spreads it. Return the $k_i$-th element of the constructed list or -1 if there are fewer than $k_i$ elements in it.

You should process queries independently. A query doesn't affect the following queries.","The first line of the input contains two integers $n$ and $q$ ($2 \le n \le 2 \cdot 10^5, 1 \le q \le 2 \cdot 10^5$) — the number of officers in Berland army and the number of queries.

The second line of the input contains $n - 1$ integers $p_2, p_3, \dots, p_n$ ($1 \le p_i &lt; i$), where $p_i$ is the index of the direct superior of the officer having the index $i$. The commander has index $1$ and doesn't have any superiors.

The next $q$ lines describe the queries. The $i$-th query is given as a pair ($u_i, k_i$) ($1 \le u_i, k_i \le n$), where $u_i$ is the index of the officer which starts spreading a command, and $k_i$ is the index of the required officer in the command spreading sequence.","Print $q$ numbers, where the $i$-th number is the officer at the position $k_i$ in the list which describes the order in which officers will receive the command if it starts spreading from officer $u_i$. Print ""-1"" if the number of officers which receive the command is less than $k_i$.

You should process queries independently. They do not affect each other.",['9 6\n1 1 1 3 5 3 5 7\n3 1\n1 5\n3 4\n7 3\n1 8\n1 9\n'],['3\n6\n8\n-1\n9\n4\n'],none,OK,"n,q= map(int, input().split())
parent=[-1]+[int(x) -1 for x in input().split()]
start=[0]*n
end=[1]*n
size=[1]*n
path=[0]*n
for i in range(n-1, 0, -1):
    size[parent[i]]+=size[i]
for v in range(1, n):
    start[v]=end[parent[v]]
    end[v]=start[v]+1
    end[parent[v]]+=size[v]
    path[start[v]]=v
for j in range(q):
    u, k=[int(x) -1 for x in input().split()]
    if k >= size[u]:
        print (""-1"")
        
    else:
        print(path[start[u]+k]+1)
","import sys
input = sys.stdin.readline

def f(x1, y1, x2, y2, x3, y3):
    if x1 == x2 == x3:
        return True
    if y1 == y2 == y3:
        return True
    return (y2 - y1) * (x3 - x1) == (y3 - y1) * (x2 - x1)

def can_cover_with_lines(points):
    n = len(points)
    if n <= 2:
        return True
    
    # Check lines created by the first two points
    for i in range(2):
        line_points = []
        for j in range(n):
            if not f(points[0][0], points[0][1], points[1][0], points[1][1], points[j][0], points[j][1]):
                line_points.append(points[j])
        
        if len(line_points) <= 2:
            return True

        # Try to cover remaining points with the line formed by the first two in line_points
        for k in range(1, len(line_points)):
            candidate_line = line_points[0]
            if not f(candidate_line[0], candidate_line[1], line_points[k][0], line_points[k][1], line_points[1][0], line_points[1][1]):
                return False
    
    return False

# Read input
n = int(input())
points = [tuple(map(int, input().split())) for _ in range(n)]

# Determine if it is possible to cover all points with two lines
if can_cover_with_lines(points):
    print(""YES"")
else:
    print(""NO"")"
950,A,"Left-handers, Right-handers and Ambidexters",PROGRAMMING,"['implementation', 'math']","You are at a water bowling training. There are *l* people who play with their left hand, *r* people, who play with their right hand, and *a* ambidexters, who can play with left or right hand.

The coach decided to form a team of even number of players, exactly half of the players should play with their right hand, and exactly half of the players should play with their left hand. One player should use only on of his hands.

Ambidexters play as well with their right hand as with their left hand. In the team, an ambidexter can play with their left hand, or with their right hand.

Please find the maximum possible size of the team, where equal number of players use their left and right hands, respectively.","The only line contains three integers *l*, *r* and *a* (0<=≤<=*l*,<=*r*,<=*a*<=≤<=100) — the number of left-handers, the number of right-handers and the number of ambidexters at the training.",Print a single even integer — the maximum number of players in the team. It is possible that the team can only have zero number of players.,"['1 4 2\n', '5 5 5\n', '0 2 0\n']","['6\n', '14\n', '0\n']","In the first example you can form a team of 6 players. You should take the only left-hander and two ambidexters to play with left hand, and three right-handers to play with right hand. The only person left can't be taken into the team.

In the second example you can form a team of 14 people. You have to take all five left-handers, all five right-handers, two ambidexters to play with left hand and two ambidexters to play with right hand.",OK,"def li():
    return list(map(int,input().split()))
def gi(n):
    return [list(map(int,input().split())) for _ in range(n)]

# File input

# import sys
# sys.stdin = open('user.txt','r')

l,r,a = li()

if max(l,r) - min(l,r) > a:
    print((min(l,r)+a) * 2)
else:
    print((max(l,r) + (a - (max(l,r) - min(l,r))) // 2) * 2)","def count(arr, x):
    c = 0
    for i in arr:
        if i > x:  # Count how many ratings are greater than x
            c += 1
    return c

def contest_positions(n, ratings):
    # Create a list of tuples containing ratings and their original indices
    indexed_ratings = [(ratings[i], i) for i in range(n)]
    
    # Sort the list based on ratings in descending order
    indexed_ratings.sort(reverse=True, key=lambda x: x[0])
    
    # Prepare positions array
    positions = [0] * n
    
    # Assign positions based on the sorted order
    for position, (rating, index) in enumerate(indexed_ratings):
        actual_position = position - count([r for r, _ in indexed_ratings[:position]], rating) + 1
        positions[index] = actual_position  # Update the original index with the calculated position
    
    return positions

# Input reading
n = int(input())  # Number of students
ratings = list(map(int, input().split()))  # Ratings of each student

# Get the contest positions
result = contest_positions(n, ratings)

# Print the results in the same order as input
print("" "".join(map(str, result)))"
682,C,Alyona and the Tree,PROGRAMMING,"['dfs and similar', 'dp', 'graphs', 'trees']","Alyona decided to go on a diet and went to the forest to get some apples. There she unexpectedly found a magic rooted tree with root in the vertex 1, every vertex and every edge of which has a number written on.

The girl noticed that some of the tree's vertices are sad, so she decided to play with them. Let's call vertex *v* sad if there is a vertex *u* in subtree of vertex *v* such that *dist*(*v*,<=*u*)<=&gt;<=*a**u*, where *a**u* is the number written on vertex *u*, *dist*(*v*,<=*u*) is the sum of the numbers written on the edges on the path from *v* to *u*.

Leaves of a tree are vertices connected to a single vertex by a single edge, but the root of a tree is a leaf if and only if the tree consists of a single vertex — root.

Thus Alyona decided to remove some of tree leaves until there will be no any sad vertex left in the tree. What is the minimum number of leaves Alyona needs to remove?","In the first line of the input integer *n* (1<=≤<=*n*<=≤<=105) is given — the number of vertices in the tree.

In the second line the sequence of *n* integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=109) is given, where *a**i* is the number written on vertex *i*.

The next *n*<=-<=1 lines describe tree edges: *i**th* of them consists of two integers *p**i* and *c**i* (1<=≤<=*p**i*<=≤<=*n*, <=-<=109<=≤<=*c**i*<=≤<=109), meaning that there is an edge connecting vertices *i*<=+<=1 and *p**i* with number *c**i* written on it.",Print the only integer — the minimum number of leaves Alyona needs to remove such that there will be no any sad vertex left in the tree.,['9\n88 22 83 14 95 91 98 53 11\n3 24\n7 -8\n1 67\n1 64\n9 65\n5 12\n6 -80\n3 8\n'],['5\n'],The following image represents possible process of removing leaves from the tree:,RUNTIME_ERROR,"def subtree_dfs(v):
    size = 1
    for u, c in edge[v]:
        size += subtree_dfs(u)
    subtree[v] = size
    return size


def remove_dfs(v, path):
    if path < 0:
        path = 0
    if vertex[v] < path:
        return subtree[v]
    removed = 0
    for u, c in edge[v]:
        removed += remove_dfs(u, path + c)
    return removed

n = int(input())

vertex = list(map(int, input().split()))
edge = {}
subtree = {}

for i in range(n):
    edge[i] = []

for i in range(n - 1):
    p, c = map(int, input().split())
    edge[p - 1] += [(i + 1, c)]

subtree_dfs(0)

print(remove_dfs(0, 0))
","def p(a, b):
    return pow((a[0] - b[0]), 2) + pow((a[1] - b[1]), 2) + pow((a[2] - b[2]), 2)

def f(x, y, z):
    mx = 0
    o = [x, y, z]
    for planet in planets:
        mx = max(mx, p(o, planet))  # Calculate the distance to the remotest planet
    return mx

# Input handling
n = int(input().strip())
planets = [list(map(int, input().strip().split())) for _ in range(n)]

# Binary search for the optimal point
left, right = -10**4, 10**4
epsilon = 1e-6

while right - left > epsilon:
    mid_x = (left + right) / 2
    mid_y = (left + right) / 2
    mid_z = (left + right) / 2
    
    # Check the maximum distance from the mid point to all planets
    dist = f(mid_x, mid_y, mid_z)
    
    if dist < best_dist:
        best_dist = dist
        best_point = (mid_x, mid_y, mid_z)
    
    # Move towards the direction of the maximum distances
    # (This can be optimized further)
    if f(mid_x + epsilon, mid_y, mid_z) < dist:
        left = mid_x + epsilon
    else:
        right = mid_x - epsilon

# Output the best point found
print(f""{best_point[0]} {best_point[1]} {best_point[2]}"")"
644,B,Processing Queries,PROGRAMMING,"['*special', 'constructive algorithms', 'data structures', 'two pointers']","In this problem you have to simulate the workflow of one-thread server. There are *n* queries to process, the *i*-th will be received at moment *t**i* and needs to be processed for *d**i* units of time. All *t**i* are guaranteed to be distinct.

When a query appears server may react in three possible ways: 
 1.  If server is free and query queue is empty, then server immediately starts to process this query. 1.  If server is busy and there are less than *b* queries in the queue, then new query is added to the end of the queue. 1.  If server is busy and there are already *b* queries pending in the queue, then new query is just rejected and will never be processed. 
As soon as server finished to process some query, it picks new one from the queue (if it's not empty, of course). If a new query comes at some moment *x*, and the server finishes to process another query at exactly the same moment, we consider that first query is picked from the queue and only then new query appears.

For each query find the moment when the server will finish to process it or print -1 if this query will be rejected.","The first line of the input contains two integers *n* and *b* (1<=≤<=*n*,<=*b*<=≤<=200<=000) — the number of queries and the maximum possible size of the query queue.

Then follow *n* lines with queries descriptions (in chronological order). Each description consists of two integers *t**i* and *d**i* (1<=≤<=*t**i*,<=*d**i*<=≤<=109), where *t**i* is the moment of time when the *i*-th query appears and *d**i* is the time server needs to process it. It is guaranteed that *t**i*<=-<=1<=&lt;<=*t**i* for all *i*<=&gt;<=1.","Print the sequence of *n* integers *e*1,<=*e*2,<=...,<=*e**n*, where *e**i* is the moment the server will finish to process the *i*-th query (queries are numbered in the order they appear in the input) or <=-<=1 if the corresponding query will be rejected.","['5 1\n2 9\n4 8\n10 9\n15 2\n19 1\n', '4 1\n2 8\n4 8\n10 9\n15 2\n']","['11 19 -1 21 22 \n', '10 18 27 -1 \n']","Consider the first sample. 
 1.  The server will start to process first query at the moment 2 and will finish to process it at the moment 11. 1.  At the moment 4 second query appears and proceeds to the queue. 1.  At the moment 10 third query appears. However, the server is still busy with query 1, *b* = 1 and there is already query 2 pending in the queue, so third query is just rejected. 1.  At the moment 11 server will finish to process first query and will take the second query from the queue. 1.  At the moment 15 fourth query appears. As the server is currently busy it proceeds to the queue. 1.  At the moment 19 two events occur simultaneously: server finishes to proceed the second query and the fifth query appears. As was said in the statement above, first server will finish to process the second query, then it will pick the fourth query from the queue and only then will the fifth query appear. As the queue is empty fifth query is proceed there. 1.  Server finishes to process query number 4 at the moment 21. Query number 5 is picked from the queue. 1.  Server finishes to process query number 5 at the moment 22.",WRONG_ANSWER,"import queue

query = queue.Queue()
q, b = map(int, input().split())
res = []
total = 0
pos = 0 # vị trí trong mảng 
for i in range(q):
    t,d = map(int, input().split())
    query.put([t,d])
while not query.empty():
    [x,y] = query.get()
    if not res: # ptu đầu 
        total = x + y
    else:
        pos += 1 
        # nếu thời gian đến < thời gian xong của ptu nằm b + 1 vị trí trc nó 
        if pos > 1 and pos - b - 1 >= 0 and x < res[pos - b - 1]:
            b += 1 # + 1 vì có thêm -1 vào 
            res.append(-1)
            continue
        if x > total:
            total = x + y
        else:
            total += y
    res.append(total)

print(*res)","mod = 10**9 + 7

def count_squares_subsets(n, a):
    # Count the frequency of each number in the array
    freq = [0] * 71  # since 1 <= a[i] <= 70
    for number in a:
        freq[number] += 1
    
    # To store the exponent counts for prime factorization
    from collections import defaultdict
    prime_exponents = defaultdict(int)

    # Function to factorize a number and count the powers of its prime factors
    def factorize(x):
        factors = defaultdict(int)
        for i in range(2, int(x**0.5) + 1):
            while x % i == 0:
                factors[i] += 1
                x //= i
        if x > 1:
            factors[x] += 1
        return factors

    # Calculate exponent counts for all unique numbers
    for value in range(1, 71):
        if freq[value] > 0:
            factors = factorize(value)
            for prime, exp in factors.items():
                prime_exponents[prime] += (exp * freq[value]) % 2  # Count modulo 2

    # Calculate the total ways to create subsets with the condition
    total_subsets = 1  # Start with 1 for the empty subset
    for count in prime_exponents.values():
        total_subsets *= (pow(2, count // 2, mod) * pow(2, (count + 1) // 2, mod)) % mod
        total_subsets %= mod

    # Subtract the empty subset
    result = (total_subsets - 1 + mod) % mod
    return result

n = int(fct.readline())
a = list(map(int, fct.readline().split()))
print(count_squares_subsets(n, a))"
864,B,Polycarp and Letters,PROGRAMMING,"['brute force', 'implementation', 'strings']","Polycarp loves lowercase letters and dislikes uppercase ones. Once he got a string *s* consisting only of lowercase and uppercase Latin letters.

Let *A* be a set of positions in the string. Let's call it pretty if following conditions are met:
 -  letters on positions from *A* in the string are all distinct and lowercase; -  there are no uppercase letters in the string which are situated between positions from *A* (i.e. there is no such *j* that *s*[*j*] is an uppercase letter, and *a*1<=&lt;<=*j*<=&lt;<=*a*2 for some *a*1 and *a*2 from *A*). 
Write a program that will determine the maximum number of elements in a pretty set of positions.","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=200) — length of string *s*.

The second line contains a string *s* consisting of lowercase and uppercase Latin letters.",Print maximum number of elements in pretty set of positions for string *s*.,"['11\naaaaBaabAbA\n', '12\nzACaAbbaazzC\n', '3\nABC\n']","['2\n', '3\n', '0\n']","In the first example the desired positions might be 6 and 8 or 7 and 8. Positions 6 and 7 contain letters 'a', position 8 contains letter 'b'. The pair of positions 1 and 8 is not suitable because there is an uppercase letter 'B' between these position.

In the second example desired positions can be 7, 8 and 11. There are other ways to choose pretty set consisting of three elements.

In the third example the given string *s* does not contain any lowercase letters, so the answer is 0.",WRONG_ANSWER,"n = int(input())
s = input()

if s.isupper() or (len(set(s)) == 1):
    print(0)
    exit()
    
cnt = 0
for i in range(1,n):
    k = s[i-1]
    if s[i].islower():
        if k.islower() and s[i] != k:
            cnt +=1
        else:
            cnt = cnt
    else:
        cnt = cnt
        continue
print(cnt)
","def Problem():
    a = input().split(' ')
    for i in range(2):
        a[i] = int(a[i])
        
    T = [0] * a[1]
    
    # Read the schedule for each day
    for i in range(a[1]):
        T[i] = input().strip()
    
    max_consecutive_days = 0
    current_streak = 0
    
    # Calculate the maximum number of consecutive days Arya wins
    for day in T:
        if '1' not in day:  # If there's no opponent present
            current_streak += 1
        else:  # If all opponents are present
            max_consecutive_days = max(max_consecutive_days, current_streak)
            current_streak = 0
    
    # Final check in case the last days are consecutive winning days
    max_consecutive_days = max(max_consecutive_days, current_streak)
    
    print(max_consecutive_days)"
727,A,Transformation: from A to B,PROGRAMMING,"['brute force', 'dfs and similar', 'math']","Vasily has a number *a*, which he wants to turn into a number *b*. For this purpose, he can do two types of operations:
 -  multiply the current number by 2 (that is, replace the number *x* by 2·*x*); -  append the digit 1 to the right of current number (that is, replace the number *x* by 10·*x*<=+<=1). 
You need to help Vasily to transform the number *a* into the number *b* using only the operations described above, or find that it is impossible.

Note that in this task you are not required to minimize the number of operations. It suffices to find any way to transform *a* into *b*.",The first line contains two positive integers *a* and *b* (1<=≤<=*a*<=&lt;<=*b*<=≤<=109) — the number which Vasily has and the number he wants to have.,"If there is no way to get *b* from *a*, print ""NO"" (without quotes).

Otherwise print three lines. On the first line print ""YES"" (without quotes). The second line should contain single integer *k* — the length of the transformation sequence. On the third line print the sequence of transformations *x*1,<=*x*2,<=...,<=*x**k*, where:
 -  *x*1 should be equal to *a*, -  *x**k* should be equal to *b*, -  *x**i* should be obtained from *x**i*<=-<=1 using any of two described operations (1<=&lt;<=*i*<=≤<=*k*). 
If there are multiple answers, print any of them.","['2 162\n', '4 42\n', '100 40021\n']","['YES\n5\n2 4 8 81 162 \n', 'NO\n', 'YES\n5\n100 200 2001 4002 40021 \n']",none,OK,"a, b = map(int, input().split())

seq = []

def d(s):
    if s > b:
        return False
    if s == b:
        return True
        
    for i in range(2):
        if i==0:
            hit = d(2*s)
            if hit:
                seq.append(2*s)
                return True
            
        if i == 1:
            hit = d(10*s +1)
            if hit:
                seq.append(10*s + 1)
                return True
d(a)  
if len(seq) > 0:
    print(""YES"")
    # seq += [a]
    seq.append(a)
    print(len(seq))
    
    for i in reversed(seq):
        print(i, end = "" "")
else:
    print(""NO"")
        
        ","import math
import sys
import collections

def In():
    return list(map(int, sys.stdin.readline().strip().split()))

def min_additional_lights(n, lights):
    # Find the maximum number of lights on any path (from entrance to exits)
    max_lights = max(lights)
    
    # Calculate the total additional lights needed to equalize all paths
    additional_lights = sum(max_lights - light for light in lights)
    
    return additional_lights

def main():
    n = int(sys.stdin.readline().strip())  # Read the number of roads
    lights = In()  # Read the initial number of lights on each road

    # Compute the minimum additional lights needed
    result = min_additional_lights(n, lights)
    
    print(result)  # Print the result

if __name__ == ""__main__"":
    main()"
409,F,000001,PROGRAMMING,['*special'],"The input contains a single integer *a* (1<=≤<=*a*<=≤<=64).

Output a single integer.",The input contains a single integer *a* (1<=≤<=*a*<=≤<=64).,Output a single integer.,"['2\n', '4\n', '27\n', '42\n']","['1\n', '2\n', '5\n', '6\n']",none,OK,"from sys import stdin,stdout
# from os import _exit
# from bisect import bisect_left,bisect
# from heapq import heapify,heappop,heappush
# from sys import setrecursionlimit
# from collections import defaultdict,Counter
# from itertools import permutations
# from math import gcd,ceil,sqrt,factorial
# setrecursionlimit(int(1e5))
input,print = stdin.readline,stdout.write

print(str([0, 1, 1, 1, 2, 1, 2, 1, 5, 2, 2, 1, 5, 1, 2, 1, 14, 1, 5, 1, 5, 2, 2, 1, 15, 2, 2, 5, 4, 1, 4, 1, 51, 1, 2, 1, 14, 1, 2, 2, 14, 1, 6, 1, 4, 2, 2, 1, 52, 2, 5, 1, 5, 1, 15, 2, 13, 2, 2, 1, 13, 1, 2, 4, 267, 1, 4, 1, 5, 1, 4, 1, 50, 1, 2, 3, 4, 1, 6, 1, 52, 15, 2, 1, 15, 1, 2, 1, 12, 1, 10, 1, 4, 2][int(input())])+""\n"")
","import sys

def get_ints(): 
    return list(map(int, sys.stdin.readline().strip().split()))

def max_dominoes(M, N):
    # Calculate the maximum number of dominoes that can fit
    # Each domino covers 2 squares, so the maximum number is the total squares divided by 2
    return (M * N) // 2

def main():
    # Read input from standard input
    M, N = get_ints()
    # Calculate the maximum number of dominoes
    result = max_dominoes(M, N)
    # Output the result
    print(result)

if __name__ == ""__main__"":
    main()"
575,D,Tablecity,PROGRAMMING,"['constructive algorithms', 'implementation']","There was a big bank robbery in Tablecity. In order to catch the thief, the President called none other than Albert – Tablecity’s Chief of Police. Albert does not know where the thief is located, but he does know how he moves.

Tablecity can be represented as 1000<=×<=2 grid, where every cell represents one district. Each district has its own unique name “(*X*,<=*Y*)”, where *X* and *Y* are the coordinates of the district in the grid. The thief’s movement is as 

Every hour the thief will leave the district (*X*,<=*Y*) he is currently hiding in, and move to one of the districts: (*X*<=-<=1,<=*Y*), (*X*<=+<=1,<=*Y*), (*X*<=-<=1,<=*Y*<=-<=1), (*X*<=-<=1,<=*Y*<=+<=1), (*X*<=+<=1,<=*Y*<=-<=1), (*X*<=+<=1,<=*Y*<=+<=1) as long as it exists in Tablecity. 

Below is an example of thief’s possible movements if he is located in district (7,1):



Albert has enough people so that every hour he can pick any two districts in Tablecity and fully investigate them, making sure that if the thief is located in one of them, he will get caught. Albert promised the President that the thief will be caught in no more than 2015 hours and needs your help in order to achieve that.",There is no input for this problem.,"The first line of output contains integer *N* – duration of police search in hours. Each of the following *N* lines contains exactly 4 integers *X**i*1, *Y**i*1, *X**i*2, *Y**i*2 separated by spaces, that represent 2 districts (*X**i*1, *Y**i*1), (*X**i*2, *Y**i*2) which got investigated during i-th hour. Output is given in chronological order (i-th line contains districts investigated during i-th hour) and should guarantee that the thief is caught in no more than 2015 hours, regardless of thief’s initial position and movement.
 -  *N*<=≤<=2015 -  1<=≤<=*X*<=≤<=1000 -  1<=≤<=*Y*<=≤<=2","[""В этой задаче нет примеров ввода-вывода.\nThis problem doesn't have sample input and output.""]",['Смотрите замечание ниже.\nSee the note below.'],"Let's consider the following output:

2

5 1 50 2

8 1 80 2

This output is not guaranteed to catch the thief and is not correct. It is given to you only to show the expected output format. There exists a combination of an initial position and a movement strategy such that the police will not catch the thief.

Consider the following initial position and thief’s movement:

In the first hour, the thief is located in district (1,1). Police officers will search districts (5,1) and (50,2) and will not find him.

At the start of the second hour, the thief moves to district (2,2). Police officers will search districts (8,1) and (80,2) and will not find him.

Since there is no further investigation by the police, the thief escaped!",WRONG_ANSWER,"print(1998); [print(i, 2, i, 1) for i in range(1, 1000)] * 2","s = input()

def a(s):
    l = 'heidi'
    j = 0  # Pointer for string 'l' (heidi)
    
    # Iterate through each character in string s
    for char in s:
        # Check if the current character matches the current character in 'l'
        if char == l[j]:
            j += 1  # Move to the next character in 'l'
        # If we have matched all characters of 'l', we can stop checking
        if j == len(l):
            return True
    
    return j == len(l)  # Return True if we have matched all characters of 'l'

# Output result
if a(s):
    print(""YES"")
else:
    print(""NO"")"
465,A,inc ARG,PROGRAMMING,['implementation'],"Sergey is testing a next-generation processor. Instead of bytes the processor works with memory cells consisting of *n* bits. These bits are numbered from 1 to *n*. An integer is stored in the cell in the following way: the least significant bit is stored in the first bit of the cell, the next significant bit is stored in the second bit, and so on; the most significant bit is stored in the *n*-th bit.

Now Sergey wants to test the following instruction: ""add 1 to the value of the cell"". As a result of the instruction, the integer that is written in the cell must be increased by one; if some of the most significant bits of the resulting number do not fit into the cell, they must be discarded.

Sergey wrote certain values ​​of the bits in the cell and is going to add one to its value. How many bits of the cell will change after the operation?","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=100) — the number of bits in the cell.

The second line contains a string consisting of *n* characters — the initial state of the cell. The first character denotes the state of the first bit of the cell. The second character denotes the second least significant bit and so on. The last character denotes the state of the most significant bit.",Print a single integer — the number of bits in the cell which change their state after we add 1 to the cell.,"['4\n1100\n', '4\n1111\n']","['3\n', '4\n']","In the first sample the cell ends up with value 0010, in the second sample — with 0000.",OK,"n = int(input())
cells = input()
if cells.find('0') == -1:
    print(n)
else:
    before = int(cells[::-1], 2)
    after = before + 1
    print(str(bin(before ^ after)).count('1'))
","import math
import random
from collections import Counter, deque
from sys import stdout
import time
from math import factorial, log, gcd
import sys
from decimal import Decimal

# Read input words t and p
t = input().strip()
p = input().strip()

# Read permutation of indices
a = list(map(int, input().strip().split()))
n = len(t)
m = len(p)

# Create an array to mark removed characters
removed = [False] * n

# Initialize pointers for t and p
t_index = 0
p_index = 0

# Loop through the indices in the order of removal
for remove_index in a:
    # Adjust to zero-based index
    remove_index -= 1
    
    # Mark the character at the remove_index as removed
    removed[remove_index] = True

    # While there are characters left in p and we can match with t
    while t_index < n and p_index < m:
        if removed[t_index]:  # If current t character is removed, skip it
            t_index += 1
            continue
        if t[t_index] == p[p_index]:  # If we have a match
            p_index += 1  # Move to the next character in p
        t_index += 1  # Move to the next character in t

    # If we have matched all characters in p, we can stop
    if p_index == m:
        break

# The number of removed letters is the current index in a
print(a.index(remove_index + 1) + 1)"
4,A,Watermelon,PROGRAMMING,"['brute force', 'math']","One hot summer day Pete and his friend Billy decided to buy a watermelon. They chose the biggest and the ripest one, in their opinion. After that the watermelon was weighed, and the scales showed *w* kilos. They rushed home, dying of thirst, and decided to divide the berry, however they faced a hard problem.

Pete and Billy are great fans of even numbers, that's why they want to divide the watermelon in such a way that each of the two parts weighs even number of kilos, at the same time it is not obligatory that the parts are equal. The boys are extremely tired and want to start their meal as soon as possible, that's why you should help them and find out, if they can divide the watermelon in the way they want. For sure, each of them should get a part of positive weight.",The first (and the only) input line contains integer number *w* (1<=≤<=*w*<=≤<=100) — the weight of the watermelon bought by the boys.,"Print YES, if the boys can divide the watermelon into two parts, each of them weighing even number of kilos; and NO in the opposite case.",['8\n'],['YES\n'],"For example, the boys can divide the watermelon into two parts of 2 and 6 kilos respectively (another variant — two parts of 4 and 4 kilos).",OK,"w = int(input())
if w%2 == 0 and 100>= w >= 3:
    print('YES')
else:
    print('NO')","def fact(a, b):
    f = 1
    # Calculate factorial a!
    for i in range(1, a + 1):
        f *= i
    
    # Calculate the number of reincarnations
    reincarnations = b // f
    
    # Return the last digit of the number of reincarnations
    return reincarnations % 10

# Read input values for a and b
a, b = map(int, input().split())
# Print the last digit of the reincarnations
print(fact(a, b))"
61,A,Ultra-Fast Mathematician,PROGRAMMING,['implementation'],"Shapur was an extremely gifted student. He was great at everything including Combinatorics, Algebra, Number Theory, Geometry, Calculus, etc. He was not only smart but extraordinarily fast! He could manage to sum 1018 numbers in a single second.

One day in 230 AD Shapur was trying to find out if any one can possibly do calculations faster than him. As a result he made a very great contest and asked every one to come and take part.

In his contest he gave the contestants many different pairs of numbers. Each number is made from digits 0 or 1. The contestants should write a new number corresponding to the given pair of numbers. The rule is simple: The *i*-th digit of the answer is 1 if and only if the *i*-th digit of the two given numbers differ. In the other case the *i*-th digit of the answer is 0.

Shapur made many numbers and first tried his own speed. He saw that he can perform these operations on numbers of length ∞ (length of a number is number of digits in it) in a glance! He always gives correct answers so he expects the contestants to give correct answers, too. He is a good fellow so he won't give anyone very big numbers and he always gives one person numbers of same length.

Now you are going to take part in Shapur's contest. See if you are faster and more accurate.",There are two lines in each input. Each of them contains a single number. It is guaranteed that the numbers are made from 0 and 1 only and that their length is same. The numbers may start with 0. The length of each number doesn't exceed 100.,Write one line — the corresponding answer. Do not omit the leading 0s.,"['1010100\n0100101\n', '000\n111\n', '1110\n1010\n', '01110\n01100\n']","['1110001\n', '111\n', '0100\n', '00010\n']",none,OK,"#!/usr/bin/python3

# n, t = input().split("" "")
# a = input()
# n = int(n)
# t = int(t)
# s = list(a)

# while(t != 0):
#     for i in range(n-1):
#         if s[i] == 'B' and s[i+1] == 'G':
#             s[i] = 'G'
#             s[i + 1] = 'B'
#             t -= 1
#             break

# print("""".join(s))

# t = int(input()[2:])
# s = input()
# while t:
#     s = s.replace('BG', 'GB')
#     t -= 1
#     print(s)
# print(s)

# n = input
# c = p = 0
# for i in' '*int(n()):
#     s = n()
#     c += s != p
#     p = s
# print(c)

# s = input()
# d = {""."": ""0"", ""-."": ""1"", ""--"": ""2""}
# s = s.replace(""--"", ""2"")
# s = s.replace(""-."", ""1"")
# s = s.replace(""."", ""0"")
# print(s)

# y = int(input())

# while(len(set(str(y))) < 4):
#     y += 1

# print(y)

# for i in range(2):
#     o = """"
#     r = input().replace("" "", """")
#     for j in r:
#         if int(j) % 2 == 0:
#             o += ""1""
#         else:
#             o += ""0""
#     print(o)

# s = [[1]*5 for _ in range(5)]
# for i in 1, 2, 3:
#     for j, v in zip((1, 2, 3), map(int, input().split())):
#         for k, d in (-1, 0), (1, 0), (0, -1), (0, 1), (0, 0):
#             s[i+k][j+d] += v
# for i in 1, 2, 3:
#     for j in 1, 2, 3:
#         print(s[i][j] % 2, end='')
#     print()

# s = input()
# u = l = 0
# for i in s:
#     if i.lower() == i:
#         l += 1s
#     else:
#         u += 1
# if u == l or l > u:
#     s = s.lower()
# elif u > l:
#     s = s.upper()

# print(s)


# n=int(input())
# a=[*map(int,input().split())]
# print(a)
# b=a.index(max(a))+a[::-1].index(min(a))
# print(b)
# print(b-(b>=n))

i = input
# print(''.join('01'[a != b]for a, b in zip(i(), i())))
s = """"
for a, b in zip(i(), i()):
    s += '01'[a != b]
print(s)
","from math import gcd
from functools import reduce

# Read the input
m = int(input())
s = list(map(int, input().split()))

# Function to calculate the GCD of a list of numbers
def calculate_gcd(lst):
    return reduce(gcd, lst)

# Check if the smallest element has any divisors among the set S
def validate_s_sequence(s):
    # Check that each element is a divisor of the last element
    for el in s:
        if s[-1] % el != 0:
            return False
    return True

# Generate the sequence from the set S
def generate_sequence(s):
    if not validate_s_sequence(s):
        return -1
    # Prepare the sequence based on the divisors of the maximum element
    result = []
    max_s = s[-1]
    for i in range(1, max_s + 1):
        if max_s % i == 0 and i in s:
            result.append(i)
    return result

# Generate the sequence and handle output
sequence = generate_sequence(s)
if sequence == -1:
    print(-1)
else:
    print(len(sequence))
    print(*sorted(sequence))"
124,A,The number of positions,PROGRAMMING,['math'],"Petr stands in line of *n* people, but he doesn't know exactly which position he occupies. He can say that there are no less than *a* people standing in front of him and no more than *b* people standing behind him. Find the number of different positions Petr can occupy.","The only line contains three integers *n*, *a* and *b* (0<=≤<=*a*,<=*b*<=&lt;<=*n*<=≤<=100).",Print the single number — the number of the sought positions.,"['3 1 1\n', '5 2 3\n']","['2\n', '3\n']","The possible positions in the first sample are: 2 and 3 (if we number the positions starting with 1).

In the second sample they are 3, 4 and 5.",WRONG_ANSWER,"for _ in range(1):
    ls = list(map(int, input().split()))
    print(ls[0]-ls[1])","from collections import Counter as cntr
from math import inf

def cin():
    return map(int, input().split(' '))

n, m = cin()
edges = [[] for _ in range(n + 1)]

# Read the pairs of warriors that know each other
for _ in range(m):
    a, b = cin()
    edges[a].append(b)
    edges[b].append(a)

min_sum = inf

# Check for each warrior if they can form a trio with two others
for i in range(1, n + 1):
    for j in range(len(edges[i])):
        for k in range(j + 1, len(edges[i])):
            mutual_friend1 = edges[i][j]
            mutual_friend2 = edges[i][k]
            # Check if mutual_friend1 and mutual_friend2 know each other
            if mutual_friend2 in edges[mutual_friend1]:
                # Calculate recognitions
                recognition_i = len(edges[i]) - 2
                recognition_j = len(edges[mutual_friend1]) - 2
                recognition_k = len(edges[mutual_friend2]) - 2
                total_recognition = recognition_i + recognition_j + recognition_k
                min_sum = min(min_sum, total_recognition)

# Output the result
print(min_sum if min_sum != inf else -1)"
281,A,Word Capitalization,PROGRAMMING,"['implementation', 'strings']","Capitalization is writing a word with its first letter as a capital letter. Your task is to capitalize the given word.

Note, that during capitalization all the letters except the first one remains unchanged.",A single line contains a non-empty word. This word consists of lowercase and uppercase English letters. The length of the word will not exceed 103.,Output the given word after capitalization.,"['ApPLe\n', 'konjac\n']","['ApPLe\n', 'Konjac\n']",none,OK,"s = input()
ans = s[0].capitalize() + s[1::]
print(ans)","# Function to compute the greatest common divisor (GCD) using the Euclidean algorithm
def gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a

# Function to compute the GCD of all integers from a to b inclusive
def gcd_range(a, b):
    # The GCD of a range from a to b is always a when a == b
    if a == b:
        return a
    # When a < b, the GCD of all numbers from a to b is 1 for large ranges
    return 1

# Read input
a, b = map(int, input().split())

# Print the GCD of the range
print(gcd_range(a, b))"
466,C,Number of Ways,PROGRAMMING,"['binary search', 'brute force', 'data structures', 'dp', 'two pointers']","You've got array *a*[1],<=*a*[2],<=...,<=*a*[*n*], consisting of *n* integers. Count the number of ways to split all the elements of the array into three contiguous parts so that the sum of elements in each part is the same. 

More formally, you need to find the number of such pairs of indices *i*,<=*j* (2<=≤<=*i*<=≤<=*j*<=≤<=*n*<=-<=1), that .","The first line contains integer *n* (1<=≤<=*n*<=≤<=5·105), showing how many numbers are in the array. The second line contains *n* integers *a*[1], *a*[2], ..., *a*[*n*] (|*a*[*i*]|<=≤<=<=109) — the elements of array *a*.",Print a single integer — the number of ways to split the array into three parts with the same sum.,"['5\n1 2 3 0 3\n', '4\n0 1 -1 0\n', '2\n4 1\n']","['2\n', '1\n', '0\n']",none,RUNTIME_ERROR,"n = int(input())
for i in range(n):
    dish_num = int(input())
    delivery_time = list(map(int, input().split()))
    arrival_time = list(map(int, input().split()))
    
    combine_time = sorted(zip(delivery_time, arrival_time), key=lambda x: x[0])
    
    a = sum(arrival_time)
    min_time = float('inf')
    for j in combine_time:
        a -= j[1]
        if j[0] >= a:
            min_time = min(min_time, j[0])
    
    print(min(min_time, a))
","import math

def main():
    a, b, n = map(int, input().split())
    
    # Simon starts the game
    turn = 0  # 0 for Simon, 1 for Antisimon
    while n > 0:
        if turn == 0:  # Simon's turn
            stones_to_take = math.gcd(a, n)
        else:  # Antisimon's turn
            stones_to_take = math.gcd(b, n)
        
        # Check if the player can take the stones
        if n < stones_to_take:
            # Current player loses
            print(turn)
            return
        
        # Subtract the stones taken from the heap
        n -= stones_to_take
        
        # Switch turns
        turn = 1 - turn  # Toggle between 0 and 1

# Standard boilerplate to call the main function
if __name__ == ""__main__"":
    main()"
777,D,Cloud of Hashtags,PROGRAMMING,"['binary search', 'greedy', 'implementation', 'strings']","Vasya is an administrator of a public page of organization ""Mouse and keyboard"" and his everyday duty is to publish news from the world of competitive programming. For each news he also creates a list of hashtags to make searching for a particular topic more comfortable. For the purpose of this problem we define hashtag as a string consisting of lowercase English letters and exactly one symbol '#' located at the beginning of the string. The length of the hashtag is defined as the number of symbols in it without the symbol '#'.

The head administrator of the page told Vasya that hashtags should go in lexicographical order (take a look at the notes section for the definition).

Vasya is lazy so he doesn't want to actually change the order of hashtags in already published news. Instead, he decided to delete some suffixes (consecutive characters at the end of the string) of some of the hashtags. He is allowed to delete any number of characters, even the whole string except for the symbol '#'. Vasya wants to pick such a way to delete suffixes that the total number of deleted symbols is minimum possible. If there are several optimal solutions, he is fine with any of them.","The first line of the input contains a single integer *n* (1<=≤<=*n*<=≤<=500<=000) — the number of hashtags being edited now.

Each of the next *n* lines contains exactly one hashtag of positive length.

It is guaranteed that the total length of all hashtags (i.e. the total length of the string except for characters '#') won't exceed 500<=000.",Print the resulting hashtags in any of the optimal solutions.,"['3\n#book\n#bigtown\n#big\n', '3\n#book\n#cool\n#cold\n', '4\n#car\n#cart\n#art\n#at\n', '3\n#apple\n#apple\n#fruit\n']","['#b\n#big\n#big\n', '#book\n#co\n#cold\n', '#\n#\n#art\n#at\n', '#apple\n#apple\n#fruit\n']","Word *a*<sub class=""lower-index"">1</sub>, *a*<sub class=""lower-index"">2</sub>, ..., *a*<sub class=""lower-index"">*m*</sub> of length *m* is lexicographically not greater than word *b*<sub class=""lower-index"">1</sub>, *b*<sub class=""lower-index"">2</sub>, ..., *b*<sub class=""lower-index"">*k*</sub> of length *k*, if one of two conditions hold: 
 -  at first position *i*, such that *a*<sub class=""lower-index"">*i*</sub> ≠ *b*<sub class=""lower-index"">*i*</sub>, the character *a*<sub class=""lower-index"">*i*</sub> goes earlier in the alphabet than character *b*<sub class=""lower-index"">*i*</sub>, i.e. *a* has smaller character than *b* in the first position where they differ; -  if there is no such position *i* and *m* ≤ *k*, i.e. the first word is a prefix of the second or two words are equal. 
The sequence of words is said to be sorted in lexicographical order if each word (except the last one) is lexicographically not greater than the next word.

For the words consisting of lowercase English letters the lexicographical order coincides with the alphabet word order in the dictionary.

According to the above definition, if a hashtag consisting of one character '#' it is lexicographically not greater than any other valid hashtag. That's why in the third sample we can't keep first two hashtags unchanged and shorten the other two.",TIME_LIMIT_EXCEEDED,"n = int(input())
ls = [input() for _ in range(n)]
for x in range(n - 2, -1, -1):
    m = min(len(ls[x]), len(ls[x + 1]))
    for j in range(m):
        if ls[x][j] > ls[x + 1][j]:
            ls[x] = ls[x][:j] 
            break
        elif ls[x][j] < ls[x + 1][j]:
            break
    else:
        ls[x] = ls[x][: m]
for x in ls:
    print(x)    ","def can_pass_levels(n, x_levels, y_levels):
    all_levels = set(range(1, n+1))  # Create a set of all levels from 1 to n
    x_levels = set(x_levels[1:])  # Convert X's levels to a set, ignoring the first element (count)
    y_levels = set(y_levels[1:])  # Convert Y's levels to a set, ignoring the first element (count)
    
    # Combine both sets of levels
    combined_levels = x_levels.union(y_levels)
    
    # Check if combined levels cover all levels
    if combined_levels == all_levels:
        return ""I become the guy.""  # They can pass all levels
    else:
        return ""Oh, my keyboard!""  # They cannot pass all levels

# Input reading
n = int(input())
x_levels = list(map(int, input().split()))
y_levels = list(map(int, input().split()))

# Output the result
print(can_pass_levels(n, x_levels, y_levels))"
658,A,Bear and Reverse Radewoosh,PROGRAMMING,['implementation'],"Limak and Radewoosh are going to compete against each other in the upcoming algorithmic contest. They are equally skilled but they won't solve problems in the same order.

There will be *n* problems. The *i*-th problem has initial score *p**i* and it takes exactly *t**i* minutes to solve it. Problems are sorted by difficulty — it's guaranteed that *p**i*<=&lt;<=*p**i*<=+<=1 and *t**i*<=&lt;<=*t**i*<=+<=1.

A constant *c* is given too, representing the speed of loosing points. Then, submitting the *i*-th problem at time *x* (*x* minutes after the start of the contest) gives *max*(0,<= *p**i*<=-<=*c*·*x*) points.

Limak is going to solve problems in order 1,<=2,<=...,<=*n* (sorted increasingly by *p**i*). Radewoosh is going to solve them in order *n*,<=*n*<=-<=1,<=...,<=1 (sorted decreasingly by *p**i*). Your task is to predict the outcome — print the name of the winner (person who gets more points at the end) or a word ""Tie"" in case of a tie.

You may assume that the duration of the competition is greater or equal than the sum of all *t**i*. That means both Limak and Radewoosh will accept all *n* problems.","The first line contains two integers *n* and *c* (1<=≤<=*n*<=≤<=50,<=1<=≤<=*c*<=≤<=1000) — the number of problems and the constant representing the speed of loosing points.

The second line contains *n* integers *p*1,<=*p*2,<=...,<=*p**n* (1<=≤<=*p**i*<=≤<=1000,<=*p**i*<=&lt;<=*p**i*<=+<=1) — initial scores.

The third line contains *n* integers *t*1,<=*t*2,<=...,<=*t**n* (1<=≤<=*t**i*<=≤<=1000,<=*t**i*<=&lt;<=*t**i*<=+<=1) where *t**i* denotes the number of minutes one needs to solve the *i*-th problem.","Print ""Limak"" (without quotes) if Limak will get more points in total. Print ""Radewoosh"" (without quotes) if Radewoosh will get more points in total. Print ""Tie"" (without quotes) if Limak and Radewoosh will get the same total number of points.","['3 2\n50 85 250\n10 15 25\n', '3 6\n50 85 250\n10 15 25\n', '8 1\n10 20 30 40 50 60 70 80\n8 10 58 63 71 72 75 76\n']","['Limak\n', 'Radewoosh\n', 'Tie\n']","In the first sample, there are 3 problems. Limak solves them as follows:
 1.  Limak spends 10 minutes on the 1-st problem and he gets 50 - *c*·10 = 50 - 2·10 = 30 points. 1.  Limak spends 15 minutes on the 2-nd problem so he submits it 10 + 15 = 25 minutes after the start of the contest. For the 2-nd problem he gets 85 - 2·25 = 35 points. 1.  He spends 25 minutes on the 3-rd problem so he submits it 10 + 15 + 25 = 50 minutes after the start. For this problem he gets 250 - 2·50 = 150 points. 
So, Limak got 30 + 35 + 150 = 215 points.

Radewoosh solves problem in the reversed order:
 1.  Radewoosh solves 3-rd problem after 25 minutes so he gets 250 - 2·25 = 200 points. 1.  He spends 15 minutes on the 2-nd problem so he submits it 25 + 15 = 40 minutes after the start. He gets 85 - 2·40 = 5 points for this problem. 1.  He spends 10 minutes on the 1-st problem so he submits it 25 + 15 + 10 = 50 minutes after the start. He gets *max*(0, 50 - 2·50) = *max*(0,  - 50) = 0 points. 
Radewoosh got 200 + 5 + 0 = 205 points in total. Limak has 215 points so Limak wins.

In the second sample, Limak will get 0 points for each problem and Radewoosh will first solve the hardest problem and he will get 250 - 6·25 = 100 points for that. Radewoosh will get 0 points for other two problems but he is the winner anyway.

In the third sample, Limak will get 2 points for the 1-st problem and 2 points for the 2-nd problem. Radewoosh will get 4 points for the 8-th problem. They won't get points for other problems and thus there is a tie because 2 + 2 = 4.",WRONG_ANSWER,"n, c = map(int, input().split())
p = [int(i) for i in input().split()]
t = [int(i) for i in input().split()]

t1 = []
t_l = 0
for i in t:
    t_l += i
    t1.append(t_l)

t2 = []
t_r = 0
for i in reversed(t):
    t_r += i
    t2.append(t_r)

p1 = p
p2 = list(reversed(p))
limak = 0
revad = 0
j = 0
k = 0
for i in range(1,sum(t)+1):
    if i in t1:
        if p1[j]-i*c>=0:
            limak += p1[j]-i*c
        j += 1
    if i in t2:
        if p2[k]-i*c>=0:
            revad += p2[k]-i*c
        k += 1
print(limak, revad)
        
","class TheatreSquare:
    
    def solve(self, n, m, a):
        # Calculate the number of flagstones needed along the length
        flagstones_length = (n + a - 1) // a
        # Calculate the number of flagstones needed along the width
        flagstones_width = (m + a - 1) // a
        # Total flagstones is the product of the two dimensions
        total_flagstones = flagstones_length * flagstones_width
        return total_flagstones"
312,B,Archer,PROGRAMMING,"['math', 'probabilities']","SmallR is an archer. SmallR is taking a match of archer with Zanoes. They try to shoot in the target in turns, and SmallR shoots first. The probability of shooting the target each time is  for SmallR while  for Zanoes. The one who shoots in the target first should be the winner.

Output the probability that SmallR will win the match.",A single line contains four integers .,"Print a single real number, the probability that SmallR will win the match.

The answer will be considered correct if the absolute or relative error doesn't exceed 10<=-<=6.",['1 2 1 2\n'],['0.666666666667'],none,RUNTIME_ERROR,"x=map(int,input().split())
print(round(((x[0]/x[1])/(1-(c/d)**2)),2))","def operate(i):
    global ans, a, b
    if a > 0 or b > 0: 
        ans += 1
        if a >= b:
            a -= 1
            s[i] = 'A'  # Using 'A' for student-programmer
        else:
            b -= 1
            s[i] = 'B'  # Using 'B' for student-athlete

def maximize_students(n, a, b, seats):
    global ans, s
    ans = 0
    s = list(seats)

    i = 0
    while i < n:
        if s[i] == '.':
            # If the current seat is empty, try to place a student
            operate(i)
        i += 1

    return ans

# Input reading
n, a, b = map(int, input().split())
seats = input()

# Result calculation and output
result = maximize_students(n, a, b, seats)
print(result)"
979,C,Kuro and Walking Route,PROGRAMMING,"['dfs and similar', 'trees']","Kuro is living in a country called Uberland, consisting of $n$ towns, numbered from $1$ to $n$, and $n - 1$ bidirectional roads connecting these towns. It is possible to reach each town from any other. Each road connects two towns $a$ and $b$. Kuro loves walking and he is planning to take a walking marathon, in which he will choose a pair of towns $(u, v)$ ($u \neq v$) and walk from $u$ using the shortest path to $v$ (note that $(u, v)$ is considered to be different from $(v, u)$).

Oddly, there are 2 special towns in Uberland named Flowrisa (denoted with the index $x$) and Beetopia (denoted with the index $y$). Flowrisa is a town where there are many strong-scent flowers, and Beetopia is another town where many bees live. In particular, Kuro will avoid any pair of towns $(u, v)$ if on the path from $u$ to $v$, he reaches Beetopia after he reached Flowrisa, since the bees will be attracted with the flower smell on Kuro’s body and sting him.

Kuro wants to know how many pair of city $(u, v)$ he can take as his route. Since he’s not really bright, he asked you to help him with this problem.","The first line contains three integers $n$, $x$ and $y$ ($1 \leq n \leq 3 \cdot 10^5$, $1 \leq x, y \leq n$, $x \ne y$) - the number of towns, index of the town Flowrisa and index of the town Beetopia, respectively.

$n - 1$ lines follow, each line contains two integers $a$ and $b$ ($1 \leq a, b \leq n$, $a \ne b$), describes a road connecting two towns $a$ and $b$.

It is guaranteed that from each town, we can reach every other town in the city using the given roads. That is, the given map of towns and roads is a tree.","A single integer resembles the number of pair of towns $(u, v)$ that Kuro can use as his walking route.","['3 1 3\n1 2\n2 3\n', '3 1 3\n1 2\n1 3\n']","['5', '4']","On the first example, Kuro can choose these pairs: 
 -  $(1, 2)$: his route would be $1 \rightarrow 2$, -  $(2, 3)$: his route would be $2 \rightarrow 3$, -  $(3, 2)$: his route would be $3 \rightarrow 2$, -  $(2, 1)$: his route would be $2 \rightarrow 1$, -  $(3, 1)$: his route would be $3 \rightarrow 2 \rightarrow 1$. 
Kuro can't choose pair $(1, 3)$ since his walking route would be $1 \rightarrow 2 \rightarrow 3$, in which Kuro visits town $1$ (Flowrisa) and then visits town $3$ (Beetopia), which is not allowed (note that pair $(3, 1)$ is still allowed because although Kuro visited Flowrisa and Beetopia, he did not visit them in that order).

On the second example, Kuro can choose the following pairs: 
 -  $(1, 2)$: his route would be $1 \rightarrow 2$, -  $(2, 1)$: his route would be $2 \rightarrow 1$, -  $(3, 2)$: his route would be $3 \rightarrow 1 \rightarrow 2$, -  $(3, 1)$: his route would be $3 \rightarrow 1$.",TIME_LIMIT_EXCEEDED,"n,x,y=map(int,input().split(' '));x-=1;y-=1
adjli=[];parent=[];
for i in range(n):
	adjli.append([]);parent.append(-1);
for _ in range(n-1):
	u,v=map(int,input().split(' '))
	adjli[u-1].append(v-1);
	adjli[v-1].append(u-1);


def dfs():
	global adjli,x,y,n
	visi=[0 for i in range(n)]
	tr=[False for i in range(n)]
	child=[0 for i in range(n)]
	ce=[0 for i in range(n)]
	visi=[0 for i in range(n)]
	stack=[x];visi[x]=1
	while stack:
		#print(stack)
		curr=stack[-1]
		if curr==y:
			tr[curr]=True
		if ce[curr]<len(adjli[curr]):
			if visi[adjli[curr][ce[curr]]]==0:
				stack.append(adjli[curr][ce[curr]])
				visi[adjli[curr][ce[curr]]]=1
				ce[curr]+=1
			else:
				ce[curr]+=1
		else:
			t1=stack[-1];del stack[-1]
			for i in adjli[t1]:
				child[t1]+=child[i]
			child[t1]+=1
			if len(stack)>=1:
				tr[stack[-1]]=tr[stack[-1]]|tr[t1]
	#print(child,tr)
	final=n*(n-1)
	t2=0
	for i in adjli[x]:
		if tr[i]==True:
			t2=i
			break
	#if t2==y:
	#	print(final-(child[y]*child[x]),""yes"")
	#else:
	print(final-child[y]*(child[x]-child[t2]))





dfs()
","def calculate(x):
    x = x[::-1]
    r = 0
    c = 0
    for i in x:
        r += (ord(i) - ord('A') + 1) * 26**c
        c += 1
    return r

def convert_to_rxcy(cell):
    # Check if the cell is in A1 notation
    if cell[0] in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':
        # Separate the column letters and row numbers
        col = ''.join(filter(str.isalpha, cell))
        row = ''.join(filter(str.isdigit, cell))
        
        # Calculate the column number from the letters
        col_num = calculate(col)
        
        # Return in RXCY format
        return f""R{row}C{col_num}""
    else:
        # Parse the RXCY format
        r_index = cell.index('R') + 1
        c_index = cell.index('C')
        
        row = cell[r_index:c_index]
        col = cell[c_index + 1:]
        
        # Convert the column number to letters
        col_num = int(col)
        result = """"
        
        while col_num > 0:
            col_num -= 1
            result = chr(col_num % 26 + ord('A')) + result
            col_num //= 26
            
        # Return in A1 format
        return f""{result}{row}""

n = int(input())
for _ in range(n):
    cell = input().strip()
    print(convert_to_rxcy(cell))"
1009,A,Game Shopping,PROGRAMMING,['implementation'],"Maxim wants to buy some games at the local game shop. There are $n$ games in the shop, the $i$-th game costs $c_i$.

Maxim has a wallet which can be represented as an array of integers. His wallet contains $m$ bills, the $j$-th bill has value $a_j$.

Games in the shop are ordered from left to right, Maxim tries to buy every game in that order.

When Maxim stands at the position $i$ in the shop, he takes the first bill from his wallet (if his wallet is empty then he proceeds to the next position immediately) and tries to buy the $i$-th game using this bill. After Maxim tried to buy the $n$-th game, he leaves the shop.

Maxim buys the $i$-th game if and only if the value of the first bill (which he takes) from his wallet is greater or equal to the cost of the $i$-th game. If he successfully buys the $i$-th game, the first bill from his wallet disappears and the next bill becomes first. Otherwise Maxim leaves the first bill in his wallet (this bill still remains the first one) and proceeds to the next game.

For example, for array $c = [2, 4, 5, 2, 4]$ and array $a = [5, 3, 4, 6]$ the following process takes place: Maxim buys the first game using the first bill (its value is $5$), the bill disappears, after that the second bill (with value $3$) becomes the first one in Maxim's wallet, then Maxim doesn't buy the second game because $c_2 &gt; a_2$, the same with the third game, then he buys the fourth game using the bill of value $a_2$ (the third bill becomes the first one in Maxim's wallet) and buys the fifth game using the bill of value $a_3$.

Your task is to get the number of games Maxim will buy.","The first line of the input contains two integers $n$ and $m$ ($1 \le n, m \le 1000$) — the number of games and the number of bills in Maxim's wallet.

The second line of the input contains $n$ integers $c_1, c_2, \dots, c_n$ ($1 \le c_i \le 1000$), where $c_i$ is the cost of the $i$-th game.

The third line of the input contains $m$ integers $a_1, a_2, \dots, a_m$ ($1 \le a_j \le 1000$), where $a_j$ is the value of the $j$-th bill from the Maxim's wallet.",Print a single integer — the number of games Maxim will buy.,"['5 4\n2 4 5 2 4\n5 3 4 6\n', '5 2\n20 40 50 20 40\n19 20\n', '6 4\n4 8 15 16 23 42\n1000 1000 1000 1000\n']","['3\n', '0\n', '4\n']","The first example is described in the problem statement.

In the second example Maxim cannot buy any game because the value of the first bill in his wallet is smaller than the cost of any game in the shop.

In the third example the values of the bills in Maxim's wallet are large enough to buy any game he encounter until he runs out of bills in his wallet.",OK,"n,m=map(int,input().split())

l=list(map(int,input().split()))
k=list(map(int,input().split()))

i,j = 0,0
count=0
while i<len(l) and j<len(k):
    if l[i]<=k[j]:
        count+=1
        j+=1
        i+=1
    else:
        i+=1
print(count)","def com(num):
    if num < 4:
        return False
    for i in range(2, int(num ** 0.5) + 1):
        if num % i == 0:  # Check if num is divisible by i
            return True  # num is composite
    return False  # num is prime

def find_composite_sum(n):
    for x in range(4, n // 2 + 1):  # Iterate through potential composite numbers
        y = n - x  # Calculate the complementary number
        if com(x) and com(y):  # Check if both x and y are composite
            return x, y  # Return the found composite pair
    return None  # In case no such pair exists

# Input reading
n = int(input(""Enter an integer no less than 12: ""))  # Read integer n

# Finding and printing the result
result = find_composite_sum(n)
if result:
    print(result[0], result[1])  # Output the composite numbers
else:
    print(""No composite sum found."")  # Indicate failure to find a valid pair"
448,D,Multiplication Table,PROGRAMMING,"['binary search', 'brute force']","Bizon the Champion isn't just charming, he also is very smart.

While some of us were learning the multiplication table, Bizon the Champion had fun in his own manner. Bizon the Champion painted an *n*<=×<=*m* multiplication table, where the element on the intersection of the *i*-th row and *j*-th column equals *i*·*j* (the rows and columns of the table are numbered starting from 1). Then he was asked: what number in the table is the *k*-th largest number? Bizon the Champion always answered correctly and immediately. Can you repeat his success?

Consider the given multiplication table. If you write out all *n*·*m* numbers from the table in the non-decreasing order, then the *k*-th number you write out is called the *k*-th largest number.","The single line contains integers *n*, *m* and *k* (1<=≤<=*n*,<=*m*<=≤<=5·105; 1<=≤<=*k*<=≤<=*n*·*m*).",Print the *k*-th largest number in a *n*<=×<=*m* multiplication table.,"['2 2 2\n', '2 3 4\n', '1 10 5\n']","['2\n', '3\n', '5\n']",A 2 × 3 multiplication table looks like this:,TIME_LIMIT_EXCEEDED,"def fun(a,n,m):
    lt_eq_mid=0
    for i in range(1,n+1):
        lt_eq_mid+=min(m,a//i)
    return lt_eq_mid


n,m,k=list(map(int,input().split()))
left=1
right=n*m
while(left<=right):
    mid=(left+right)//2
    lt_eq_mid=fun(mid,n,m)
    #print(str(mid)+"" ""+str(lt_eq_mid))
    if(lt_eq_mid>k):
        prev=fun(mid-1,n,m)
        #print(""Prev""+str(prev)+"" ""+str(mid))
        if(prev<k):
            print(mid)
            break
        right=mid-1
    elif(lt_eq_mid<k):
        left=mid+1
    else:
        print(mid)
        break



        
        ","import math, os, sys
import string, re
import itertools, functools, operator
from collections import Counter

def inputint():
    return int(sys.stdin.readline().strip())

def count_ships(a, b):
    count = 0
    while a > 0 and b > 0:
        count += b // a  # Count how many squares can be formed
        b, a = a, b % a  # Update dimensions for next iteration
    return count

if __name__ == ""__main__"":
    a, b = map(inputint, sys.stdin.readline().split())
    result = count_ships(a, b)
    print(result)"
981,A,Antipalindrome,PROGRAMMING,"['brute force', 'implementation', 'strings']","A string is a palindrome if it reads the same from the left to the right and from the right to the left. For example, the strings ""kek"", ""abacaba"", ""r"" and ""papicipap"" are palindromes, while the strings ""abb"" and ""iq"" are not.

A substring $s[l \ldots r]$ ($1<=\leq<=l<=\leq<=r<=\leq<=|s|$) of a string $s<==<=s_{1}s_{2} \ldots s_{|s|}$ is the string $s_{l}s_{l<=+<=1} \ldots s_{r}$.

Anna does not like palindromes, so she makes her friends call her Ann. She also changes all the words she reads in a similar way. Namely, each word $s$ is changed into its longest substring that is not a palindrome. If all the substrings of $s$ are palindromes, she skips the word at all.

Some time ago Ann read the word $s$. What is the word she changed it into?","The first line contains a non-empty string $s$ with length at most $50$ characters, containing lowercase English letters only.","If there is such a substring in $s$ that is not a palindrome, print the maximum length of such a substring. Otherwise print $0$.

Note that there can be multiple longest substrings that are not palindromes, but their length is unique.","['mew\n', 'wuffuw\n', 'qqqqqqqq\n']","['3\n', '5\n', '0\n']","""mew"" is not a palindrome, so the longest substring of it that is not a palindrome, is the string ""mew"" itself. Thus, the answer for the first example is $3$.

The string ""uffuw"" is one of the longest non-palindrome substrings (of length $5$) of the string ""wuffuw"", so the answer for the second example is $5$.

All substrings of the string ""qqqqqqqq"" consist of equal characters so they are palindromes. This way, there are no non-palindrome substrings. Thus, the answer for the third example is $0$.",OK,"s = input()
f = False
d = len(s)
while s != '':
    for i in range(len(s) // 2):
        if s[i] != s[len(s) - 1 -i]:
            f = True
            break
    if f:
        break
    else:
        s = s[1:]
        d -= 1
print(d)","import math

# Function to calculate the number of years until Limak's weight exceeds Bob's
def years_until_limak_larger(a, b):
    years = 0
    # Continue looping until Limak's weight is greater than Bob's
    while a <= b:
        a *= 3  # Limak's weight is tripled
        b *= 2  # Bob's weight is doubled
        years += 1  # Increment the year count
    return years  # Return the total number of years

# Input reading
a, b = map(int, input().split())
# Output the number of years
print(years_until_limak_larger(a, b))"
978,A,Remove Duplicates,PROGRAMMING,['implementation'],"Petya has an array $a$ consisting of $n$ integers. He wants to remove duplicate (equal) elements.

Petya wants to leave only the rightmost entry (occurrence) for each element of the array. The relative order of the remaining unique elements should not be changed.","The first line contains a single integer $n$ ($1 \le n \le 50$) — the number of elements in Petya's array.

The following line contains a sequence $a_1, a_2, \dots, a_n$ ($1 \le a_i \le 1\,000$) — the Petya's array.","In the first line print integer $x$ — the number of elements which will be left in Petya's array after he removed the duplicates.

In the second line print $x$ integers separated with a space — Petya's array after he removed the duplicates. For each unique element only the rightmost entry should be left.","['6\n1 5 5 1 6 1\n', '5\n2 4 2 4 4\n', '5\n6 6 6 6 6\n']","['3\n5 6 1 \n', '2\n2 4 \n', '1\n6 \n']","In the first example you should remove two integers $1$, which are in the positions $1$ and $4$. Also you should remove the integer $5$, which is in the position $2$.

In the second example you should remove integer $2$, which is in the position $1$, and two integers $4$, which are in the positions $2$ and $4$.

In the third example you should remove four integers $6$, which are in the positions $1$, $2$, $3$ and $4$.",WRONG_ANSWER,"#for _ in range(int(input())):
q=int(input())
a=set(list(map(int,input().split())))
print(*a)

","from sys import stdin
def sin():
    return stdin.readline()

s = input()

j = 1
left = []
right = []

# Process each stone based on Liss's escape direction
for direction in s:
    if direction == 'l':
        left.append(j)  # Escape to the left
    else:
        right.append(j)  # Escape to the right
    j += 1  # Increment stone number

# Combine left stones in reverse order and right stones
result = left[::-1] + right

# Output the result
for stone in result:
    print(stone)"
450,A,Jzzhu and Children,PROGRAMMING,['implementation'],"There are *n* children in Jzzhu's school. Jzzhu is going to give some candies to them. Let's number all the children from 1 to *n*. The *i*-th child wants to get at least *a**i* candies.

Jzzhu asks children to line up. Initially, the *i*-th child stands at the *i*-th place of the line. Then Jzzhu start distribution of the candies. He follows the algorithm:
 1.  Give *m* candies to the first child of the line. 1.  If this child still haven't got enough candies, then the child goes to the end of the line, else the child go home. 1.  Repeat the first two steps while the line is not empty. 
Consider all the children in the order they go home. Jzzhu wants to know, which child will be the last in this order?","The first line contains two integers *n*,<=*m* (1<=≤<=*n*<=≤<=100; 1<=≤<=*m*<=≤<=100). The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=100).","Output a single integer, representing the number of the last child.","['5 2\n1 3 1 4 2\n', '6 4\n1 1 2 2 3 3\n']","['4\n', '6\n']","Let's consider the first sample. 

Firstly child 1 gets 2 candies and go home. Then child 2 gets 2 candies and go to the end of the line. Currently the line looks like [3, 4, 5, 2] (indices of the children in order of the line). Then child 3 gets 2 candies and go home, and then child 4 gets 2 candies and goes to the end of the line. Currently the line looks like [5, 2, 4]. Then child 5 gets 2 candies and goes home. Then child 2 gets two candies and goes home, and finally child 4 gets 2 candies and goes home.

Child 4 is the last one who goes home.",WRONG_ANSWER,"n, m = map(int, input().split())
a = list(map(int, input().split()))
d = [j for j in range(1, len(a) + 1)]

while len(a) > 1:
    if m >= a[0]:
        del a[0], d[0]
    elif m < a[0]:
        a[0] -= m
        a[0], a[-1], d[0], d[-1] = a[-1], a[0], d[-1], d[0]

print(d[0])","import sys
import math
from sys import stdin, stdout

# TAKE INPUT
def get_ints_in_variables():
    return map(int, sys.stdin.readline().strip().split())
def get_int(): return int(input())

# Initialize sequence and sum
sequence = [0]  # Starting with 0 in the sequence
current_sum = 0  # Sum is initially 0

# Number of operations
n = get_int()

# To store results
results = []

for _ in range(n):
    operation = list(get_ints_in_variables())
    t = operation[0]
    
    if t == 1:
        a, x = operation[1], operation[2]
        # Add x to the first a elements
        for i in range(min(a, len(sequence))):
            sequence[i] += x
        current_sum += x * min(a, len(sequence))
    
    elif t == 2:
        k = operation[1]
        # Append k to the end of the sequence
        sequence.append(k)
        current_sum += k
    
    elif t == 3:
        # Remove the last element
        current_sum -= sequence.pop()

    # Calculate the average after each operation
    average = current_sum / len(sequence)
    results.append(f""{average:.10f}"")  # append formatted result

# Output all results
stdout.write(""\n"".join(results) + ""\n"")"
32,B,Borze,PROGRAMMING,"['expression parsing', 'implementation']","Ternary numeric notation is quite popular in Berland. To telegraph the ternary number the Borze alphabet is used. Digit 0 is transmitted as «.», 1 as «-.» and 2 as «--». You are to decode the Borze code, i.e. to find out the ternary number given its representation in Borze alphabet.",The first line contains a number in Borze code. The length of the string is between 1 and 200 characters. It's guaranteed that the given string is a valid Borze code of some ternary number (this number can have leading zeroes).,Output the decoded ternary number. It can have leading zeroes.,"['.-.--\n', '--.\n', '-..-.--\n']","['012', '20', '1012']",none,OK,"x=input()
x=x.replace('--','2',x.count('--'))
x=x.replace('-.','1',x.count('-.'))
x=x.replace('.','0',x.count('.'))
print(x)
","import sys

def fair_game(n):
    c=0
    hs=set()
    res=True

    # Read the card numbers and count occurrences
    for _ in range(n):
        a = int(sys.stdin.readline().strip())
        hs.add(a)  # Add number to set for unique values
        c += 1  # Count total cards

    # Check if there are exactly two distinct numbers
    if len(hs) == 2:
        # If exactly two distinct numbers, split the cards evenly
        print(""YES"")
        print(*hs)  # Print both numbers
        return

    # If there are more or less than two distinct numbers, check feasibility
    if len(hs) < 2:
        print(""NO"")  # Not enough distinct numbers
        return

    # Now we have more than two distinct numbers, we need to find if we can create a fair game
    counts = [0] * 101  # Array to count cards for each number (1 to 100)
    for num in hs:
        counts[num] = 0

    # Count the occurrences of each integer on the cards
    for _ in range(n):
        a = int(sys.stdin.readline().strip())
        counts[a] += 1

    # Check for pairs of counts that can split the cards evenly
    for i in range(1, 101):
        for j in range(i + 1, 101):
            if counts[i] > 0 and counts[j] > 0:
                # Ensure that both players can take half the total cards
                if (counts[i] + counts[j]) == n and counts[i] == counts[j]:
                    print(""YES"")
                    print(i, j)
                    return

    print(""NO"")  # No valid pairs found

# Example usage:
# fair_game(int(input()))"
760,B,Frodo and pillows,PROGRAMMING,"['binary search', 'greedy']","*n* hobbits are planning to spend the night at Frodo's house. Frodo has *n* beds standing in a row and *m* pillows (*n*<=≤<=*m*). Each hobbit needs a bed and at least one pillow to sleep, however, everyone wants as many pillows as possible. Of course, it's not always possible to share pillows equally, but any hobbit gets hurt if he has at least two pillows less than some of his neighbors have. 

Frodo will sleep on the *k*-th bed in the row. What is the maximum number of pillows he can have so that every hobbit has at least one pillow, every pillow is given to some hobbit and no one is hurt?","The only line contain three integers *n*, *m* and *k* (1<=≤<=*n*<=≤<=*m*<=≤<=109, 1<=≤<=*k*<=≤<=*n*) — the number of hobbits, the number of pillows and the number of Frodo's bed.",Print single integer — the maximum number of pillows Frodo can have so that no one is hurt.,"['4 6 2\n', '3 10 3\n', '3 6 1\n']","['2\n', '4\n', '3\n']","In the first example Frodo can have at most two pillows. In this case, he can give two pillows to the hobbit on the first bed, and one pillow to each of the hobbits on the third and the fourth beds.

In the second example Frodo can take at most four pillows, giving three pillows to each of the others.

In the third example Frodo can take three pillows, giving two pillows to the hobbit in the middle and one pillow to the hobbit on the third bed.",OK,"n,m,k = list(map(int, input().split(' ')))

extra = m - n
maxi = 1

if n == 1:
    print(m)
elif n == 2:
    if m%2 == 0:
        print(m//2)
    else:
        print(m//2 +1)
else:
    for i in range(extra):
        stepPillows = 1 + min(k-1,i) + min(n-k,i)
        if extra >= stepPillows:
            extra -= stepPillows
            maxi += 1
        else:
            break
    print(maxi)
","# Function to solve the problem in the specified format
def minimize_burles_formatted(n, b, receipts):
    # Initialize total amount to be paid and array to store number of bonuses used each day
    total_burles = 0
    bonuses_used = [0] * n

    for i in range(n):
        # Determine the amount of burles to pay for the current day
        receipt = receipts[i]
        # Calculate the maximum bonuses that can be used
        max_bonuses = min(b, receipt // 2)
        
        # Use bonuses to reduce the payment
        bonuses_used[i] = max_bonuses
        b -= max_bonuses
        
        # Calculate the effective payment for the day
        payment = receipt - bonuses_used[i]
        total_burles += payment
        
        # Update the bonuses based on the payment
        b += payment // 10

    return total_burles, bonuses_used

# Input reading
n, b = map(int, input().split())
receipts = list(map(int, input().split()))

# Function usage
total_burles, bonuses_used = minimize_burles_formatted(n, b, receipts)

# Output results
print(total_burles)
print(' '.join(map(str, bonuses_used)))"
60,B,Serial Time!,PROGRAMMING,"['dfs and similar', 'dsu']","The Cereal Guy's friend Serial Guy likes to watch soap operas. An episode is about to start, and he hasn't washed his plate yet. But he decided to at least put in under the tap to be filled with water. The plate can be represented by a parallelepiped *k*<=×<=*n*<=×<=*m*, that is, it has *k* layers (the first layer is the upper one), each of which is a rectangle *n*<=×<=*m* with empty squares ('.') and obstacles ('#'). The water can only be present in the empty squares. The tap is positioned above the square (*x*,<=*y*) of the first layer, it is guaranteed that this square is empty. Every minute a cubical unit of water falls into the plate. Find out in how many minutes the Serial Guy should unglue himself from the soap opera and turn the water off for it not to overfill the plate. That is, you should find the moment of time when the plate is absolutely full and is going to be overfilled in the next moment.

Note: the water fills all the area within reach (see sample 4). Water flows in each of the 6 directions, through faces of 1<=×<=1<=×<=1 cubes.","The first line contains three numbers *k*, *n*, *m* (1<=≤<=*k*,<=*n*,<=*m*<=≤<=10) which are the sizes of the plate. Then follow *k* rectangles consisting of *n* lines each containing *m* characters '.' or '#', which represents the ""layers"" of the plate in the order from the top to the bottom. The rectangles are separated by empty lines (see the samples). The last line contains *x* and *y* (1<=≤<=*x*<=≤<=*n*,<=1<=≤<=*y*<=≤<=*m*) which are the tap's coordinates. *x* is the number of the line and *y* is the number of the column. Lines of each layer are numbered from left to right by the integers from 1 to *n*, columns of each layer are numbered from top to bottom by the integers from 1 to *m*.","The answer should contain a single number, showing in how many minutes the plate will be filled.","['1 1 1\n\n.\n\n1 1\n', '2 1 1\n\n.\n\n#\n\n1 1\n', '2 2 2\n\n.#\n##\n\n..\n..\n\n1 1\n', '3 2 2\n\n#.\n##\n\n#.\n.#\n\n..\n..\n\n1 2\n', '3 3 3\n\n.#.\n###\n##.\n\n.##\n###\n##.\n\n...\n...\n...\n\n1 1\n']","['1\n', '1\n', '5\n', '7\n', '13\n']",none,WRONG_ANSWER,"a, b, c = map(int, input().split())
t = [[[0] * c for k in range(b)] for i in range(a)]

for i in range(a):
    input()
    for j in range(b):
        for k, q in enumerate(input()):
            if q == '#': t[i][j][k] = 1
    
q = [(i, j, k) for i in range(-1, 2) for j in range(-1, 2) for k in range(-1, 2)]
q.remove((0, 0, 0))
s = 0

def f(x, y, z):
    global s
    p = [(x + i, y + j, z + k) for i, j, k in q]
    p = [(i, j, k) for i, j, k in p if -1 < i < a and -1 < j < b and -1 < k < c and t[i][j][k] == 0]
    for i, j, k in p:
        t[i][j][k] = 2
    for i, j, k in p:
        f(i, j, k)
    s += len(p)    

input()
y, z = map(int, input().split())
f(0, y - 1, z - 1)
print(s)   ","class Fraction:
    def __init__(self, x = """", y = """"):
        self.first = x
        self.true = y

def replace(n):
    a = n.split()

    # Read number of lecture words and number of words in each language
    n, m = map(int, a[:2])
    
    # Dictionary to map words from first language to second language
    language_map = {}
    
    # Read the words from both languages
    for i in range(m):
        first_word, second_word = input().split()
        language_map[first_word] = second_word
    
    # Read the lecture words
    lecture_words = input().split()

    # Prepare the result list based on the shorter words
    result = []
    for word in lecture_words:
        first_lang_word = word
        second_lang_word = language_map[first_lang_word]
        
        # Choose the shorter word or the first language word in case of a tie
        if len(first_lang_word) <= len(second_lang_word):
            result.append(first_lang_word)
        else:
            result.append(second_lang_word)
    
    # Print the resulting notes for the lecture
    print("" "".join(result))"
41,A,Translation,PROGRAMMING,"['implementation', 'strings']","The translation from the Berland language into the Birland language is not an easy task. Those languages are very similar: a berlandish word differs from a birlandish word with the same meaning a little: it is spelled (and pronounced) reversely. For example, a Berlandish word code corresponds to a Birlandish word edoc. However, it's easy to make a mistake during the «translation». Vasya translated word *s* from Berlandish into Birlandish as *t*. Help him: find out if he translated the word correctly.","The first line contains word *s*, the second line contains word *t*. The words consist of lowercase Latin letters. The input data do not consist unnecessary spaces. The words are not empty and their lengths do not exceed 100 symbols.","If the word *t* is a word *s*, written reversely, print YES, otherwise print NO.","['code\nedoc\n', 'abb\naba\n', 'code\ncode\n']","['YES\n', 'NO\n', 'NO\n']",none,RUNTIME_ERROR,"ber = list(input())
bir = list(input())

j = len(ber)-1

for i in range(j+1):
    if ber[i] != bir[j-i]:
        print('NO')
        exit()
print('YES')","#jasnah
import sys
from collections import defaultdict

def Tarjan(u):
    global dfn, low, scc, s, in_stack
    dfn[u] = low[u] = dfn[0] + 1
    s.append(u)
    in_stack[u] = True
    
    for v, color, time in graph[u]:
        if dfn[v] == 0:  # If v is not visited
            Tarjan(v)
            low[u] = min(low[u], low[v])
        elif in_stack[v]:  # If v is in the current stack
            low[u] = min(low[u], dfn[v])

    if low[u] == dfn[u]:  # Found a strongly connected component
        component = []
        while True:
            v = s.pop()
            in_stack[v] = False
            component.append(v)
            if v == u:
                break
        scc.append(component)

def find_matching():
    global edges, min_time, selected_edges
    # Build color to edges mapping
    color_to_edges = defaultdict(list)
    
    for index, (v, u, color, time) in enumerate(edges):
        color_to_edges[color].append((index + 1, v, u, time))
    
    for color, edges in color_to_edges.items():
        used = set()
        for index, v, u, time in sorted(edges, key=lambda x: x[3]):  # Sort by destructing time
            if v not in used and u not in used:
                used.add(v)
                used.add(u)
                selected_edges.append(index)
                min_time = max(min_time, time)

    return len(selected_edges) > 0

# Read input
n, m = map(int, sys.stdin.readline().split())
edges = []
graph = defaultdict(list)

for i in range(m):
    v, u, c, t = map(int, sys.stdin.readline().split())
    edges.append((v, u, c, t))
    graph[v].append((u, c, t))
    graph[u].append((v, c, t))

# Initialize variables for Tarjan's algorithm
dfn = [0] * (n + 1)
low = [0] * (n + 1)
scc = []
s = []
in_stack = [False] * (n + 1)

# Run Tarjan's algorithm
for i in range(1, n + 1):
    if dfn[i] == 0:
        Tarjan(i)

# Prepare for finding matching and check conditions
min_time = 0
selected_edges = []

if find_matching():
    print(""Yes"")
    print(min_time, len(selected_edges))
    print(' '.join(map(str, selected_edges)))
else:
    print(""No"")"
25,D,Roads not only in Berland,PROGRAMMING,"['dsu', 'graphs', 'trees']","Berland Government decided to improve relations with neighboring countries. First of all, it was decided to build new roads so that from each city of Berland and neighboring countries it became possible to reach all the others. There are *n* cities in Berland and neighboring countries in total and exactly *n*<=-<=1 two-way roads. Because of the recent financial crisis, the Berland Government is strongly pressed for money, so to build a new road it has to close some of the existing ones. Every day it is possible to close one existing road and immediately build a new one. Your task is to determine how many days would be needed to rebuild roads so that from each city it became possible to reach all the others, and to draw a plan of closure of old roads and building of new ones.","The first line contains integer *n* (2<=≤<=*n*<=≤<=1000) — amount of cities in Berland and neighboring countries. Next *n*<=-<=1 lines contain the description of roads. Each road is described by two space-separated integers *a**i*, *b**i* (1<=≤<=*a**i*,<=*b**i*<=≤<=*n*,<=*a**i*<=≠<=*b**i*) — pair of cities, which the road connects. It can't be more than one road between a pair of cities. No road connects the city with itself.","Output the answer, number *t* — what is the least amount of days needed to rebuild roads so that from each city it became possible to reach all the others. Then output *t* lines — the plan of closure of old roads and building of new ones. Each line should describe one day in the format i j u v — it means that road between cities i and j became closed and a new road between cities u and v is built. Cities are numbered from 1. If the answer is not unique, output any.","['2\n1 2\n', '7\n1 2\n2 3\n3 1\n4 5\n5 6\n6 7\n']","['0\n', '1\n3 1 3 7\n']",none,WRONG_ANSWER,"
from collections import defaultdict

def main():
    n = int(input())
    edges = list()
    for i in range(n-1):
        u, v = map(int, input().split(' '))
        edges.append([u, v])
    
    def find(a):
        if p[a] != a:
            p[a] = find(p[a])
        return p[a]

    def union(a, b):
        a = find(a)
        b = find(b)
        if a == b:
            return
        if sz[a] > sz[b]:
            p[b] = a
            sz[a] += sz[b]
        else:
            p[a] = b
            sz[b] += sz[a]
    
    p = list(range(n + 1))
    sz = [1] * (n + 1)
    for u, v in edges:
        union(u, v)
    u, v = edges[0]
    res = list()
    for i in range(1, n + 1):
        if find(i) != find(u):
            res.append([u, v, u, i])
            union(u, i)
    print(len(res))
    for item in res:
        print(*item)
    
main()","def check(t, s):
    # Check if the length of both words is the same
    if len(t) != len(s):
        return ""NO""
    
    # Check if t is the reverse of s
    for i in range(0, len(t)):
        if t[i] != s[len(s) - 1 - i]:
            return ""NO""
    
    return ""YES""

# Read input
s = input()
t = input()

# Print the result of the check
print(check(t, s))"
745,A,Hongcow Learns the Cyclic Shift,PROGRAMMING,"['implementation', 'strings']","Hongcow is learning to spell! One day, his teacher gives him a word that he needs to learn to spell. Being a dutiful student, he immediately learns how to spell the word.

Hongcow has decided to try to make new words from this one. He starts by taking the word he just learned how to spell, and moves the last character of the word to the beginning of the word. He calls this a cyclic shift. He can apply cyclic shift many times. For example, consecutively applying cyclic shift operation to the word ""abracadabra"" Hongcow will get words ""aabracadabr"", ""raabracadab"" and so on.

Hongcow is now wondering how many distinct words he can generate by doing the cyclic shift arbitrarily many times. The initial string is also counted.","The first line of input will be a single string *s* (1<=≤<=|*s*|<=≤<=50), the word Hongcow initially learns how to spell. The string *s* consists only of lowercase English letters ('a'–'z').",Output a single integer equal to the number of distinct strings that Hongcow can obtain by applying the cyclic shift arbitrarily many times to the given string.,"['abcd\n', 'bbb\n', 'yzyz\n']","['4\n', '1\n', '2\n']","For the first sample, the strings Hongcow can generate are ""abcd"", ""dabc"", ""cdab"", and ""bcda"".

For the second sample, no matter how many times Hongcow does the cyclic shift, Hongcow can only generate ""bbb"".

For the third sample, the two strings Hongcow can generate are ""yzyz"" and ""zyzy"".",OK,"s = input()
ans = set()

for l in range(len(s)):
    t = s[l:] + s[:l]
    ans.add(t)

print(len(ans))","""""""
NTC here
""""""
from sys import setcheckinterval, stdin, setrecursionlimit
setcheckinterval(1000)
setrecursionlimit(10**7)

n = int(stdin.readline().strip())
p = list(map(int, stdin.readline().strip().split()))

# Calculate number of records in the current permutation
record_count = 0
max_so_far = 0

# To keep track of the record positions
records = []

for i in range(n):
    if p[i] > max_so_far:
        max_so_far = p[i]
        records.append(p[i])
        record_count += 1

# We will check which element can be removed to maximize the records
best_record_count = record_count
element_to_remove = float('inf')

for i in range(n):
    temp_records = []
    max_so_far = 0
    # Count records if p[i] is removed
    for j in range(n):
        if j != i:
            if p[j] > max_so_far:
                max_so_far = p[j]
                temp_records.append(p[j])
    
    if len(temp_records) > best_record_count:
        best_record_count = len(temp_records)
        element_to_remove = p[i]
    elif len(temp_records) == best_record_count:
        element_to_remove = min(element_to_remove, p[i])

print(element_to_remove)"
791,A,Bear and Big Brother,PROGRAMMING,['implementation'],"Bear Limak wants to become the largest of bears, or at least to become larger than his brother Bob.

Right now, Limak and Bob weigh *a* and *b* respectively. It's guaranteed that Limak's weight is smaller than or equal to his brother's weight.

Limak eats a lot and his weight is tripled after every year, while Bob's weight is doubled after every year.

After how many full years will Limak become strictly larger (strictly heavier) than Bob?",The only line of the input contains two integers *a* and *b* (1<=≤<=*a*<=≤<=*b*<=≤<=10) — the weight of Limak and the weight of Bob respectively.,"Print one integer, denoting the integer number of years after which Limak will become strictly larger than Bob.","['4 7\n', '4 9\n', '1 1\n']","['2\n', '3\n', '1\n']","In the first sample, Limak weighs 4 and Bob weighs 7 initially. After one year their weights are 4·3 = 12 and 7·2 = 14 respectively (one weight is tripled while the other one is doubled). Limak isn't larger than Bob yet. After the second year weights are 36 and 28, so the first weight is greater than the second one. Limak became larger than Bob after two years so you should print 2.

In the second sample, Limak's and Bob's weights in next years are: 12 and 18, then 36 and 36, and finally 108 and 72 (after three years). The answer is 3. Remember that Limak wants to be larger than Bob and he won't be satisfied with equal weights.

In the third sample, Limak becomes larger than Bob after the first year. Their weights will be 3 and 2 then.",OK,"# -*- coding: utf-8 -*-
""""""
Created on Tue Sep 19 15:47:18 2023

@author: lenovo
""""""

a,b=map(int,input().split())
s=0
while a<=b:
    a*=3
    b*=2
    s=s+1
print(s)
","import io
import os

def fast_input():
    input_length = os.fstat(0).st_size
    byte_encoded_io = io.BytesIO(os.read(0, input_length))
    return byte_encoded_io.read().decode().split()

def main():
    # Read input values
    data = fast_input()
    idx = 0

    n = int(data[idx])
    m = int(data[idx + 1])
    k = int(data[idx + 2])
    idx += 3

    # Read the initial array
    a = list(map(int, data[idx:idx + n]))
    idx += n

    operations = []
    # Read operations
    for _ in range(m):
        l = int(data[idx]) - 1
        r = int(data[idx + 1]) - 1
        d = int(data[idx + 2])
        operations.append((l, r, d))
        idx += 3

    # Array to keep count of how many times each operation is applied
    operation_counts = [0] * (m + 1)

    # Read queries and mark operations
    for _ in range(k):
        x = int(data[idx])
        y = int(data[idx + 1])
        operation_counts[x - 1] += 1
        if y < m:
            operation_counts[y] -= 1
        idx += 2

    # Calculate the prefix sum of operation counts
    for i in range(1, m):
        operation_counts[i] += operation_counts[i - 1]

    # Apply operations to the array
    for i in range(m):
        l, r, d = operations[i]
        a[l] += operation_counts[i] * d
        if r + 1 < n:
            a[r + 1] -= operation_counts[i] * d

    # Finalize the array by carrying forward the increments
    for i in range(1, n):
        a[i] += a[i - 1]

    # Print the final result
    print(' '.join(map(str, a)))

if __name__ == ""__main__"":
    main()"
412,B,Network Configuration,PROGRAMMING,"['greedy', 'sortings']","The R1 company wants to hold a web search championship. There were *n* computers given for the competition, each of them is connected to the Internet. The organizers believe that the data transfer speed directly affects the result. The higher the speed of the Internet is, the faster the participant will find the necessary information. Therefore, before the competition started, each computer had its maximum possible data transfer speed measured. On the *i*-th computer it was *a**i* kilobits per second.

There will be *k* participants competing in the championship, each should get a separate computer. The organizing company does not want any of the participants to have an advantage over the others, so they want to provide the same data transfer speed to each participant's computer. Also, the organizers want to create the most comfortable conditions for the participants, so the data transfer speed on the participants' computers should be as large as possible.

The network settings of the R1 company has a special option that lets you to cut the initial maximum data transfer speed of any computer to any lower speed. How should the R1 company configure the network using the described option so that at least *k* of *n* computers had the same data transfer speed and the data transfer speed on these computers was as large as possible?","The first line contains two space-separated integers *n* and *k* (1<=≤<=*k*<=≤<=*n*<=≤<=100) — the number of computers and the number of participants, respectively. In the second line you have a space-separated sequence consisting of *n* integers: *a*1,<=*a*2,<=...,<=*a**n* (16<=≤<=*a**i*<=≤<=32768); number *a**i* denotes the maximum data transfer speed on the *i*-th computer.",Print a single integer — the maximum Internet speed value. It is guaranteed that the answer to the problem is always an integer.,"['3 2\n40 20 30\n', '6 4\n100 20 40 20 50 50\n']","['30\n', '40\n']",In the first test case the organizers can cut the first computer's speed to 30 kilobits. Then two computers (the first and the third one) will have the same speed of 30 kilobits. They should be used as the participants' computers. This answer is optimal.,OK,"n,k=map(int,input().split())
a=[int(i) for i in input().split()]
a.sort(reverse=True)
print(min(a[:k]))","from collections import defaultdict as dd

s = input()
n = len(s)

primes = [2]
for i in range(3, n + 1):
    for p in primes:
        if p * p > i:
            primes.append(i)
            break
        if i % p == 0:
            break

# Count characters in the string
char_count = dd(int)
for char in s:
    char_count[char] += 1

# Check if we can rearrange the characters
for p in primes:
    for i in range(1, p + 1):
        if char_count[s[i - 1]] == 0:
            print(""NO"")
            exit()
        char_count[s[i - 1]] -= 1

# If it is possible, rearrange characters
result = []
for char in char_count:
    result.append(char * char_count[char])

if len(result) == 0:
    print(""NO"")
else:
    print(""YES"")
    print(''.join(result))"
251,A,Points on Line,PROGRAMMING,"['binary search', 'combinatorics', 'two pointers']","Little Petya likes points a lot. Recently his mom has presented him *n* points lying on the line *OX*. Now Petya is wondering in how many ways he can choose three distinct points so that the distance between the two farthest of them doesn't exceed *d*.

Note that the order of the points inside the group of three chosen points doesn't matter.","The first line contains two integers: *n* and *d* (1<=≤<=*n*<=≤<=105; 1<=≤<=*d*<=≤<=109). The next line contains *n* integers *x*1,<=*x*2,<=...,<=*x**n*, their absolute value doesn't exceed 109 — the *x*-coordinates of the points that Petya has got.

It is guaranteed that the coordinates of the points in the input strictly increase.","Print a single integer — the number of groups of three points, where the distance between two farthest points doesn't exceed *d*.

Please do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.","['4 3\n1 2 3 4\n', '4 2\n-3 -2 -1 0\n', '5 19\n1 10 20 30 50\n']","['4\n', '2\n', '1\n']","In the first sample any group of three points meets our conditions.

In the seconds sample only 2 groups of three points meet our conditions: {-3, -2, -1} and {-2, -1, 0}.

In the third sample only one group does: {1, 10, 20}.",OK,"def Search(L,aa,x):
    a=aa
    b=len(L)
    while(b-a>1):
        i=(b+a)//2
        if(L[i]>x):
            b=i
        elif(L[i]<x):
            a=i
        else:
            return (i+1)-aa-1
    return b-aa-1

import math

n,d=map(int,input().split())

P=list(map(int,input().split()))
ans=0
for i in range(n):
    x=Search(P,i,P[i]+d)
    if(x>1):
        ans+=((x)*(x-1))//2
print(ans)
","nums = [int(i) for i in input().split()]
l = nums[0]
a, b, c = nums[1], nums[2], nums[3]

# Initialize a list to hold the maximum pieces that can be made
dp = [-1] * (l + 1)
dp[0] = 0  # Base case: 0 length means 0 pieces

# Iterate through each length from 1 to l
for i in range(1, l + 1):
    # Check if we can cut a piece of length a
    if i >= a and dp[i - a] != -1:
        dp[i] = max(dp[i], dp[i - a] + 1)
    # Check if we can cut a piece of length b
    if i >= b and dp[i - b] != -1:
        dp[i] = max(dp[i], dp[i - b] + 1)
    # Check if we can cut a piece of length c
    if i >= c and dp[i - c] != -1:
        dp[i] = max(dp[i], dp[i - c] + 1)

# The answer will be in dp[l], since it represents the maximum pieces for length l
print(dp[l])"
242,B,Big Segment,PROGRAMMING,"['implementation', 'sortings']","A coordinate line has *n* segments, the *i*-th segment starts at the position *l**i* and ends at the position *r**i*. We will denote such a segment as [*l**i*,<=*r**i*].

You have suggested that one of the defined segments covers all others. In other words, there is such segment in the given set, which contains all other ones. Now you want to test your assumption. Find in the given set the segment which covers all other segments, and print its number. If such a segment doesn't exist, print -1.

Formally we will assume that segment [*a*,<=*b*] covers segment [*c*,<=*d*], if they meet this condition *a*<=≤<=*c*<=≤<=*d*<=≤<=*b*.","The first line contains integer *n* (1<=≤<=*n*<=≤<=105) — the number of segments. Next *n* lines contain the descriptions of the segments. The *i*-th line contains two space-separated integers *l**i*,<=*r**i* (1<=≤<=*l**i*<=≤<=*r**i*<=≤<=109) — the borders of the *i*-th segment.

It is guaranteed that no two segments coincide.","Print a single integer — the number of the segment that covers all other segments in the set. If there's no solution, print -1.

The segments are numbered starting from 1 in the order in which they appear in the input.","['3\n1 1\n2 2\n3 3\n', '6\n1 5\n2 3\n1 10\n7 10\n7 7\n10 10\n']","['-1\n', '3\n']",none,WRONG_ANSWER,"

n = int(input())

l = 1000000001
r = 0

found = True
pos = 0

for i in range(n):
    (x, y) = map(int, input().split())

    if x <= l and y >= r:
        (l, r) = (x, y)
        pos = i + 1
    else:
        if x < l or y > r:
            found = False
            break

if found:
    print(pos)
else:
    print(-1)","n = int(input())

for i in range(1):
    t = [int(x) for x in input().split()]

def checkyesno():
    s = list(set(t))  # Remove duplicates
    s.sort()  # Sort the unique sizes
    # Check for any triplet that satisfies the conditions
    for i in range(len(s) - 2):
        if s[i + 2] - s[i] <= 2:  # Check if the size difference is <= 2
            return ""YES""
    return ""NO""

print(checkyesno())"
934,A,A Compatible Pair,PROGRAMMING,"['brute force', 'games']","Nian is a monster which lives deep in the oceans. Once a year, it shows up on the land, devouring livestock and even people. In order to keep the monster away, people fill their villages with red colour, light, and cracking noise, all of which frighten the monster out of coming.

Little Tommy has *n* lanterns and Big Banban has *m* lanterns. Tommy's lanterns have brightness *a*1,<=*a*2,<=...,<=*a**n*, and Banban's have brightness *b*1,<=*b*2,<=...,<=*b**m* respectively.

Tommy intends to hide one of his lanterns, then Banban picks one of Tommy's non-hidden lanterns and one of his own lanterns to form a pair. The pair's brightness will be the product of the brightness of two lanterns.

Tommy wants to make the product as small as possible, while Banban tries to make it as large as possible.

You are asked to find the brightness of the chosen pair if both of them choose optimally.","The first line contains two space-separated integers *n* and *m* (2<=≤<=*n*,<=*m*<=≤<=50).

The second line contains *n* space-separated integers *a*1,<=*a*2,<=...,<=*a**n*.

The third line contains *m* space-separated integers *b*1,<=*b*2,<=...,<=*b**m*.

All the integers range from <=-<=109 to 109.",Print a single integer — the brightness of the chosen pair.,"['2 2\n20 18\n2 14\n', '5 3\n-1 0 1 2 3\n-1 0 1\n']","['252\n', '2\n']","In the first example, Tommy will hide 20 and Banban will choose 18 from Tommy and 14 from himself.

In the second example, Tommy will hide 3 and Banban will choose 2 from Tommy and 1 from himself.",WRONG_ANSWER,"t=input()
L=list(map(int,input().split()))
L2=list(map(int,input().split()))
L.sort()
L2.sort()
a=max(L)
X=[]
count=1
for i in range(len(L)):
	if L[i]==max(L) and count==1:
		count+=1
		continue
	else:
		X.append(L[i])
print(max(max(X)*max(L2),min(X)*min(L2),max(X)*min(L2),min(X)*max(L2)))","n = int(input())

# There are four makes of cars: A, B, M, Z
makes = 4

# Total combinations of cars of length 2*n
total_combinations = makes ** (2 * n)

# Combinations to exclude which do not have exactly n successive cars
# Total exclusions:
# 1. We can pick any of the 4 makes to take n successive and fill the rest.
# 2. The ways to arrange the remaining cars (2*n - n = n) with the remaining makes (4).
exclusions_per_make = (makes - 1) ** n

# There are 4 makes that can be chosen for n successive cars
valid_combinations = total_combinations - (makes * exclusions_per_make)

print(valid_combinations)"
32,A,Reconnaissance,PROGRAMMING,['brute force'],"According to the regulations of Berland's army, a reconnaissance unit should consist of exactly two soldiers. Since these two soldiers shouldn't differ much, their heights can differ by at most *d* centimeters. Captain Bob has *n* soldiers in his detachment. Their heights are *a*1,<=*a*2,<=...,<=*a**n* centimeters. Some soldiers are of the same height. Bob wants to know, how many ways exist to form a reconnaissance unit of two soldiers from his detachment.

Ways (1,<=2) and (2,<=1) should be regarded as different.","The first line contains two integers *n* and *d* (1<=≤<=*n*<=≤<=1000,<=1<=≤<=*d*<=≤<=109) — amount of soldiers in Bob's detachment and the maximum allowed height difference respectively. The second line contains *n* space-separated integers — heights of all the soldiers in Bob's detachment. These numbers don't exceed 109.","Output one number — amount of ways to form a reconnaissance unit of two soldiers, whose height difference doesn't exceed *d*.","['5 10\n10 20 50 60 65\n', '5 1\n55 30 29 31 55\n']","['6\n', '6\n']",none,OK,"string = input().split(' ')

n = int(string[0])
d = int(string[1])

heights = input().split(' ')

total = 0

for i in range(n):
  for j in range(n):
    if i != j:
      if abs(int(heights[i])-int(heights[j])) <= d:
        total += 1

print(total)","import math, itertools, fractions, heapq, collections, bisect, sys, queue, copy

sys.setrecursionlimit(10**7)
inf = 10**20
mod = 10**9 + 7
dd = [(-1, 0), (0, 1), (1, 0), (0, -1)]
ddn = [(-1, 0), (-1, 1), (0, 1), (1, 1), (1, 0), (1, -1), (0, -1), (-1, -1)]

# Input the number of pixels
n = int(input())

a, b = 1, n  # Start with the maximum potential rows and columns
min_diff = inf  # Initialize minimum difference

# Iterate to find factors of n
for i in range(1, int(math.sqrt(n)) + 1):
    if n % i == 0:
        # i is a factor, hence (i, n // i) is a pair (rows, columns)
        rows = i
        cols = n // i
        # Ensure rows <= cols
        if rows > cols:
            rows, cols = cols, rows
        # Update if this pair gives a smaller difference
        if cols - rows < min_diff:
            min_diff = cols - rows
            a, b = rows, cols

# Print the final result
print(a, b)"
387,B,George and Round,PROGRAMMING,"['brute force', 'greedy', 'two pointers']","George decided to prepare a Codesecrof round, so he has prepared *m* problems for the round. Let's number the problems with integers 1 through *m*. George estimates the *i*-th problem's complexity by integer *b**i*.

To make the round good, he needs to put at least *n* problems there. Besides, he needs to have at least one problem with complexity exactly *a*1, at least one with complexity exactly *a*2, ..., and at least one with complexity exactly *a**n*. Of course, the round can also have problems with other complexities.

George has a poor imagination. It's easier for him to make some already prepared problem simpler than to come up with a new one and prepare it. George is magnificent at simplifying problems. He can simplify any already prepared problem with complexity *c* to any positive integer complexity *d* (*c*<=≥<=*d*), by changing limits on the input data.

However, nothing is so simple. George understood that even if he simplifies some problems, he can run out of problems for a good round. That's why he decided to find out the minimum number of problems he needs to come up with in addition to the *m* he's prepared in order to make a good round. Note that George can come up with a new problem of any complexity.","The first line contains two integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=3000) — the minimal number of problems in a good round and the number of problems George's prepared. The second line contains space-separated integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a*1<=&lt;<=*a*2<=&lt;<=...<=&lt;<=*a**n*<=≤<=106) — the requirements for the complexity of the problems in a good round. The third line contains space-separated integers *b*1,<=*b*2,<=...,<=*b**m* (1<=≤<=*b*1<=≤<=*b*2...<=≤<=*b**m*<=≤<=106) — the complexities of the problems prepared by George.",Print a single integer — the answer to the problem.,"['3 5\n1 2 3\n1 2 2 3 3\n', '3 5\n1 2 3\n1 1 1 1 1\n', '3 1\n2 3 4\n1\n']","['0\n', '2\n', '3\n']","In the first sample the set of the prepared problems meets the requirements for a good round.

In the second sample, it is enough to come up with and prepare two problems with complexities 2 and 3 to get a good round.

In the third sample it is very easy to get a good round if come up with and prepare extra problems with complexities: 2, 3, 4.",OK,"n, k = map(int, input().split())
rounds = list(map(int, input().split()))
problems = list(map(int, input().split()))
 
i = 0
j = 0
count = n 
 
while i < n and j < k:
	if rounds[i] <= problems[j]:
		count-=1
		i+=1
		j+=1
	else:
		j+=1
 
 
print(count)","def alloc(control, mem, maxi, tam):
    tem_espaco = False
    onde = -1
    pos = -1
    if not mem:
        if tam <= maxi:
            mem.append([control, 1, tam])
            return [control, mem]
    else:
        for i in range(len(mem) + 1):
            if i == len(mem):  # Check till the end of memory
                if maxi - (mem[i - 1][1] + mem[i - 1][2] - 1) >= tam:
                    onde = mem[i - 1][1] + mem[i - 1][2]
                    pos = len(mem)
                    break
            elif i == 0:  # Check from the start
                if mem[i][1] - 1 >= tam:
                    onde = 1
                    pos = 0
                    break
            else:  # Check the gaps between blocks
                if mem[i][1] - (mem[i - 1][1] + mem[i - 1][2]) >= tam:
                    onde = mem[i - 1][1] + mem[i - 1][2]
                    pos = i
                    break

        if onde != -1:
            mem.insert(pos, [control, onde, tam])
            return [control, mem]

    return [None, mem]

def erase(mem, id):
    for i in range(len(mem)):
        if mem[i][0] == id:
            del mem[i]
            return mem
    return ""ILLEGAL_ERASE_ARGUMENT""

def defragment(mem):
    if mem:
        pos = 1
        for i in range(len(mem)):
            mem[i][1] = pos
            pos += mem[i][2]
    return mem

def memory_manager(operations, t, m):
    mem = []
    control = 1
    output = []

    for operation in operations:
        command = operation.split()
        if command[0] == ""alloc"":
            size = int(command[1])
            result, mem = alloc(control, mem, m, size)
            if result is not None:
                output.append(result)
                control += 1
            else:
                output.append(""NULL"")
        elif command[0] == ""erase"":
            id = int(command[1])
            result = erase(mem, id)
            if result == mem:
                output.append(""ILLEGAL_ERASE_ARGUMENT"")
        elif command[0] == ""defragment"":
            defragment(mem)

    return output"
492,A,Vanya and Cubes,PROGRAMMING,['implementation'],"Vanya got *n* cubes. He decided to build a pyramid from them. Vanya wants to build the pyramid as follows: the top level of the pyramid must consist of 1 cube, the second level must consist of 1<=+<=2<==<=3 cubes, the third level must have 1<=+<=2<=+<=3<==<=6 cubes, and so on. Thus, the *i*-th level of the pyramid must have 1<=+<=2<=+<=...<=+<=(*i*<=-<=1)<=+<=*i* cubes.

Vanya wants to know what is the maximum height of the pyramid that he can make using the given cubes.",The first line contains integer *n* (1<=≤<=*n*<=≤<=104) — the number of cubes given to Vanya.,Print the maximum possible height of the pyramid in the single line.,"['1\n', '25\n']","['1\n', '4\n']",Illustration to the second sample:,WRONG_ANSWER,"n = int(input()) 
a = 1
b = 1
while b*2<=n:
    b*=2
    a+=1
print(a) ","def main():
    n, s = map(int, input().split())
    
    count = 0  # Initialize a counter for really big numbers

    # Check numbers from 1 to n
    for x in range(1, n + 1):
        digit_sum = sum(int(digit) for digit in str(x))  # Calculate the sum of the digits of x
        if x - digit_sum >= s:  # Check the condition for being a really big number
            count += 1  # Increase the count if the condition is satisfied

    print(count)  # Output the total count of really big numbers

main()"
11,A,Increasing Sequence,PROGRAMMING,"['constructive algorithms', 'implementation', 'math']","A sequence *a*0,<=*a*1,<=...,<=*a**t*<=-<=1 is called increasing if *a**i*<=-<=1<=&lt;<=*a**i* for each *i*:<=0<=&lt;<=*i*<=&lt;<=*t*.

You are given a sequence *b*0,<=*b*1,<=...,<=*b**n*<=-<=1 and a positive integer *d*. In each move you may choose one element of the given sequence and add *d* to it. What is the least number of moves required to make the given sequence increasing?","The first line of the input contains two integer numbers *n* and *d* (2<=≤<=*n*<=≤<=2000,<=1<=≤<=*d*<=≤<=106). The second line contains space separated sequence *b*0,<=*b*1,<=...,<=*b**n*<=-<=1 (1<=≤<=*b**i*<=≤<=106).",Output the minimal number of moves needed to make the sequence increasing.,['4 2\n1 3 3 2\n'],['3\n'],none,TIME_LIMIT_EXCEEDED,"n, d = map(int, input().split())
lst = list(map(int, input().split()))
additions = 0

for i in range(len(lst)):
    while lst[i + 1] <= lst[i]:
        lst[i + 1] += d
        additions += 1
    if i + 2 == len(lst): break
print(additions)","from copy import deepcopy


class Digit(object):
    def __init__(self, _cost, _value):
        self.cost = _cost
        self.value = _value


def max_number(v, costs):
    # Create a list of Digit objects for digits 1 to 9 with their respective costs
    digits = [Digit(costs[i], str(i + 1)) for i in range(9)]

    # Filter digits that can be painted with the available paint
    usable_digits = [d for d in digits if d.cost <= v]

    # If there are no usable digits, return -1
    if not usable_digits:
        return -1

    # Sort the usable digits by cost and then by value in descending order
    usable_digits.sort(key=lambda x: (x.cost, -int(x.value)))

    # The maximum length of the number we can create
    max_length = 0
    paint_remaining = v

    # Calculate the maximum length of the number we can create
    while paint_remaining >= min(d.cost for d in usable_digits):
        paint_remaining -= min(d.cost for d in usable_digits)
        max_length += 1

    # Create the maximum number with the available digits
    result = []
    for _ in range(max_length):
        for digit in usable_digits[::-1]:
            if digit.cost <= paint_remaining + digit.cost:  # check if we can use this digit
                result.append(digit.value)
                paint_remaining -= digit.cost
                break

    return ''.join(result)


# Read input values
v = int(input().strip())
costs = list(map(int, input().strip().split()))

# Output the maximum number
print(max_number(v, costs))"
998,A,Balloons,PROGRAMMING,"['constructive algorithms', 'implementation']","There are quite a lot of ways to have fun with inflatable balloons. For example, you can fill them with water and see what happens.

Grigory and Andrew have the same opinion. So, once upon a time, they went to the shop and bought $n$ packets with inflatable balloons, where $i$-th of them has exactly $a_i$ balloons inside.

They want to divide the balloons among themselves. In addition, there are several conditions to hold:
 -  Do not rip the packets (both Grigory and Andrew should get unbroken packets); -  Distribute all packets (every packet should be given to someone); -  Give both Grigory and Andrew at least one packet; -  To provide more fun, the total number of balloons in Grigory's packets should not be equal to the total number of balloons in Andrew's packets. 
Help them to divide the balloons or determine that it's impossible under these conditions.","The first line of input contains a single integer $n$ ($1 \le n \le 10$) — the number of packets with balloons.

The second line contains $n$ integers: $a_1$, $a_2$, $\ldots$, $a_n$ ($1 \le a_i \le 1000$) — the number of balloons inside the corresponding packet.","If it's impossible to divide the balloons satisfying the conditions above, print $-1$.

Otherwise, print an integer $k$ — the number of packets to give to Grigory followed by $k$ distinct integers from $1$ to $n$ — the indices of those. The order of packets doesn't matter.

If there are multiple ways to divide balloons, output any of them.","['3\n1 2 1\n', '2\n5 5\n', '1\n10\n']","['2\n1 2\n', '-1\n', '-1\n']","In the first test Grigory gets $3$ balloons in total while Andrey gets $1$.

In the second test there's only one way to divide the packets which leads to equal numbers of balloons.

In the third test one of the boys won't get a packet at all.",OK,"n = int(input())
arr = list(map(int, input().split()))
if n == 1:
	print(-1)
	exit(0)
z = 0
for i in range(n):
	if arr[i] < arr[z]:
		z = i
if arr[z] != sum(arr) - arr[z]:
	print(1)
	print(z + 1)
else:
	print(-1)","def main():
    from math import floor, sqrt
    [vladik, valera] = [int(_) for _ in input().split()]
    
    turn = 1  # Starting with turn 1
    while True:
        if turn % 2 == 1:  # Vladik's turn (odd turns)
            if vladik >= turn:
                vladik -= turn  # Vladik gives 'turn' candies to Valera
            else:
                print(""Vladik"")  # Vladik can't give enough candies
                return
        else:  # Valera's turn (even turns)
            if valera >= turn:
                valera -= turn  # Valera gives 'turn' candies to Vladik
            else:
                print(""Valera"")  # Valera can't give enough candies
                return
        
        turn += 1  # Move to the next turn

if __name__ == ""__main__"":
    main()"
227,B,Effective Approach,PROGRAMMING,['implementation'],"Once at a team training Vasya, Petya and Sasha got a problem on implementing linear search in an array.

According to the boys, linear search works as follows. The array elements in a pre-selected order are in turn compared with the number that you need to find. Once you find the array element that is equal to the required one, the search ends. The efficiency of the algorithm is the number of performed comparisons. The fewer comparisons the linear search has made, the more effective it is.

Vasya believes that a linear search would work better if it sequentially iterates through the elements, starting with the 1-st one (in this problem we consider the elements of the array indexed from 1 to *n*) and ending with the *n*-th one. And Petya says that Vasya is wrong: the search will need less comparisons if it sequentially iterates the elements starting from the *n*-th and ending with the 1-st one. Sasha argues that the two approaches are equivalent.

To finally begin the task, the teammates decided to settle the debate and compare the two approaches on an example. For this, they took an array that is a permutation of integers from 1 to *n*, and generated *m* queries of the form: find element with value *b**i* in the array. They want to calculate for both approaches how many comparisons in total the linear search will need to respond to all queries. If the first search needs fewer comparisons, then the winner of the dispute is Vasya. If the second one does, then the winner is Petya. If both approaches make the same number of comparisons, then Sasha's got the upper hand.

But the problem is, linear search is too slow. That's why the boys aren't going to find out who is right before the end of the training, unless you come in here. Help them to determine who will win the dispute.","The first line contains integer *n* (1<=≤<=*n*<=≤<=105) — the number of elements in the array. The second line contains *n* distinct space-separated integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=*n*) — the elements of array. 

The third line contains integer *m* (1<=≤<=*m*<=≤<=105) — the number of queries. The last line contains *m* space-separated integers *b*1,<=*b*2,<=...,<=*b**m* (1<=≤<=*b**i*<=≤<=*n*) — the search queries. Note that the queries can repeat.","Print two integers, showing how many comparisons Vasya's approach needs and how many comparisons Petya's approach needs. Separate the numbers by spaces.

Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use cin, cout streams or the %I64d specifier.","['2\n1 2\n1\n1\n', '2\n2 1\n1\n1\n', '3\n3 1 2\n3\n1 2 3\n']","['1 2\n', '2 1\n', '6 6\n']","In the first sample Vasya's approach will make one comparison (it starts with the 1-st element and immediately finds the required number), and Petya's approach makes two comparisons (first he compares with the 2-nd array element, doesn't find the search item and compares with the 1-st element).

In the second sample, on the contrary, Vasya's approach will need two comparisons (first with 1-st element, and then with the 2-nd), and Petya's approach will find the required value in one comparison (the first comparison with the 2-nd element).",TIME_LIMIT_EXCEEDED,"
n = int(input())
arr = list(map(int, input().split()))
m = int(input())
queries = list(map(int, input().split()))
v, p = 0, 0
for x in queries:
    idx = arr.index(x)
    idx2 = arr[::-1].index(x)
    v += idx + 1
    p += idx2 + 1

print(v, p)","n=int(input())
a=map(int, input().split())
""""""
n=10000
a=[i for i in range(10000)]
""""""
if n==1:
    if list(a)[0]==0:
        print(1, 1)
        print(1, 1)
    else:
        print(-1)
else:
    # Count the occurrences of each number
    counts = [0] * (n + 1)
    for number in a:
        counts[number] += 1
    
    # Check the structure of the rhombic matrix
    total_cells = sum(counts)
    if counts[0] != 1 or total_cells != n:
        print(-1)
        exit()

    # Finding dimensions for the matrix
    for rows in range(1, int(n**0.5) + 1):
        if n % rows == 0:
            cols = n // rows
            # Check if we can form a valid rhombic matrix
            max_distance = 0
            for i in range(rows):
                for j in range(cols):
                    distance = abs(i - (rows // 2)) + abs(j - (cols // 2))
                    if distance >= len(counts) or counts[distance] != 1:
                        break
                    max_distance = max(max_distance, distance)

            # If a valid rhombic matrix can be formed
            if max_distance == len(counts) - 1:
                print(rows, cols)
                print((rows // 2) + 1, (cols // 2) + 1)
                exit()
    
    print(-1)"
41,B,Martian Dollar,PROGRAMMING,['brute force'],"One day Vasya got hold of information on the Martian dollar course in bourles for the next *n* days. The buying prices and the selling prices for one dollar on day *i* are the same and are equal to *a**i*. Vasya has *b* bourles. He can buy a certain number of dollars and then sell it no more than once in *n* days. According to Martian laws, one can buy only an integer number of dollars. Which maximal sum of money in bourles can Vasya get by the end of day *n*?","The first line contains two integers *n* and *b* (1<=≤<=*n*,<=*b*<=≤<=2000) — the number of days and the initial number of money in bourles. The next line contains *n* integers *a**i* (1<=≤<=*a**i*<=≤<=2000) — the prices of Martian dollars.",Print the single number — which maximal sum of money in bourles can Vasya get by the end of day *n*.,"['2 4\n3 7\n', '4 10\n4 3 2 1\n', '4 10\n4 2 3 1\n']","['8\n', '10\n', '15\n']",none,OK,"n, b = map(int, input().split())
a = list(map(int, input().split()))
ans = 0
for i in range(n):
    for j in range(i, n):
        ans = max(ans, (b//a[i])*a[j] + b%a[i])
print(ans)","def min_secs(A):
    avg = int(sum(A) / len(A))  # Calculate the average number of tasks
    secs = 0  # Initialize the seconds counter
    for a in A:
        # If the server has more tasks than the average, add to the seconds counter
        if a > avg:
            secs += a - avg  # Count the excess tasks
    return secs  # Return the total seconds needed to balance the load"
479,A,Expression,PROGRAMMING,"['brute force', 'math']","Petya studies in a school and he adores Maths. His class has been studying arithmetic expressions. On the last class the teacher wrote three positive integers *a*, *b*, *c* on the blackboard. The task was to insert signs of operations '+' and '*', and probably brackets between the numbers so that the value of the resulting expression is as large as possible. Let's consider an example: assume that the teacher wrote numbers 1, 2 and 3 on the blackboard. Here are some ways of placing signs and brackets:
 -  1+2*3=7 -  1*(2+3)=5 -  1*2*3=6 -  (1+2)*3=9 
Note that you can insert operation signs only between *a* and *b*, and between *b* and *c*, that is, you cannot swap integers. For instance, in the given sample you cannot get expression (1+3)*2.

It's easy to see that the maximum value that you can obtain is 9.

Your task is: given *a*, *b* and *c* print the maximum value that you can get.","The input contains three integers *a*, *b* and *c*, each on a single line (1<=≤<=*a*,<=*b*,<=*c*<=≤<=10).",Print the maximum value of the expression that you can obtain.,"['1\n2\n3\n', '2\n10\n3\n']","['9\n', '60\n']",none,OK,"x = int(input())
y = int(input())
z = int(input())
list_1 = []

list_1.append((x+y)*z)
list_1.append(x*(y+z))
list_1.append(x+y+z)
list_1.append(x*y*z)

print(max(list_1))","def main():
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))
    
    # Dictionary to hold unique ratings and their indices
    rating_to_index = {}
    
    # Populate the dictionary with unique ratings
    for index in range(n):
        rating = arr[index]
        if rating not in rating_to_index:
            rating_to_index[rating] = index + 1  # Store index as 1-based
    
    # Check if we have enough distinct ratings
    if len(rating_to_index) < k:
        print(""NO"")
    else:
        print(""YES"")
        # Get the first k distinct indices
        selected_indices = list(rating_to_index.values())[:k]
        print("" "".join(map(str, selected_indices)))

main()"
221,A,Little Elephant and Function,PROGRAMMING,"['implementation', 'math']","The Little Elephant enjoys recursive functions.

This time he enjoys the sorting function. Let *a* is a permutation of an integers from 1 to *n*, inclusive, and *a**i* denotes the *i*-th element of the permutation. The Little Elephant's recursive function *f*(*x*), that sorts the first *x* permutation's elements, works as follows:
 -  If *x*<==<=1, exit the function. -  Otherwise, call *f*(*x*<=-<=1), and then make *swap*(*a**x*<=-<=1,<=*a**x*) (swap the *x*-th and (*x*<=-<=1)-th elements of *a*). 
The Little Elephant's teacher believes that this function does not work correctly. But that-be do not get an F, the Little Elephant wants to show the performance of its function. Help him, find a permutation of numbers from 1 to *n*, such that after performing the Little Elephant's function (that is call *f*(*n*)), the permutation will be sorted in ascending order.",A single line contains integer *n* (1<=≤<=*n*<=≤<=1000) — the size of permutation.,"In a single line print *n* distinct integers from 1 to *n* — the required permutation. Numbers in a line should be separated by spaces.

It is guaranteed that the answer exists.","['1\n', '2\n']","['1 ', '2 1 ']",none,WRONG_ANSWER,"n = int(input())
anwer = []
for i  in range(n , 0 , -1):
	anwer += str(i)
print("" "".join(anwer))","import sys, threading

input = lambda: sys.stdin.readline().strip()

def main():
    def dp(i):
        # If we've processed all elements, return 0 points
        if i == 0:
            return 0
        # If we skip the current number, return the points from the previous element
        if i in memo:
            return memo[i]
        
        # Choosing the current number
        points = 0
        if i >= 1:
            points = dp(i - 1)
        if i >= 2:
            points = max(points, dp(i - 2) + i * count[i])  # earn points by taking current number

        memo[i] = points
        return points

    n = int(input())
    a = list(map(int, input().split()))
    
    count = [0] * (10**5 + 1)
    
    for num in a:
        count[num] += 1  # Count occurrences of each number
    
    memo = {}
    
    # Calculate maximum points from 1 to max(a)
    max_points = dp(10**5)
    
    print(max_points)

if __name__ == ""__main__"":
    main()"
34,A,Reconnaissance 2,PROGRAMMING,['implementation'],"*n* soldiers stand in a circle. For each soldier his height *a**i* is known. A reconnaissance unit can be made of such two neighbouring soldiers, whose heights difference is minimal, i.e. |*a**i*<=-<=*a**j*| is minimal. So each of them will be less noticeable with the other. Output any pair of soldiers that can form a reconnaissance unit.","The first line contains integer *n* (2<=≤<=*n*<=≤<=100) — amount of soldiers. Then follow the heights of the soldiers in their order in the circle — *n* space-separated integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=1000). The soldier heights are given in clockwise or counterclockwise direction.","Output two integers — indexes of neighbouring soldiers, who should form a reconnaissance unit. If there are many optimum solutions, output any of them. Remember, that the soldiers stand in a circle.","['5\n10 12 13 15 10\n', '4\n10 20 30 40\n']","['5 1\n', '1 2\n']",none,OK,"n=int(input())
l=list(map(int,input().split()))
mi=100000000000
ans=-1
for i in range(n):
    if(abs(l[i]-l[i-1])<mi):
        ans=((i-1+n))%n
        mi=abs(l[i]-l[i-1])
print(ans+1,(ans+1)%n+1)
","# Author: Kudo_kun
# 979A
def minimum_cuts(n):
    # When n is 0, we only need 0 cuts (since no friends, just Shiro)
    if n == 0:
        return 0
    # For any other number of friends, we need n cuts
    return n

# Input number of friends
n = int(input())
# Output the minimum number of cuts needed
print(minimum_cuts(n))"
914,A,Perfect Squares,PROGRAMMING,"['brute force', 'implementation', 'math']","Given an array *a*1,<=*a*2,<=...,<=*a**n* of *n* integers, find the largest number in the array that is not a perfect square.

A number *x* is said to be a perfect square if there exists an integer *y* such that *x*<==<=*y*2.","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=1000) — the number of elements in the array.

The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (<=-<=106<=≤<=*a**i*<=≤<=106) — the elements of the array.

It is guaranteed that at least one element of the array is not a perfect square.",Print the largest number in the array which is not a perfect square. It is guaranteed that an answer always exists.,"['2\n4 2\n', '8\n1 2 4 8 16 32 64 576\n']","['2\n', '32\n']","In the first sample case, 4 is a perfect square, so the largest number in the array that is not a perfect square is 2.",WRONG_ANSWER,"import sys

n = int(input())
values = sorted(list(map(int, input().split())), reverse=True)
if values[0] < 0:
    print(values[0])
    sys.exit(0)
for n in values:
    if n > 0 and n != (int(n ** 0.5) ** 2):
        print(n)
        break
","def main():
    a1, a2, b1, b2, k = [int(i) for i in input().split()]
    for a in range(a1, a2 + 1):
        # Calculate the required cost for the given efficiency k
        b = a / k
        # Check if b is within the allowed range
        if b1 <= b <= b2:
            print(""YES"")
            return
    print(""NO"")

main()"
50,A,Domino piling,PROGRAMMING,"['greedy', 'math']","You are given a rectangular board of *M*<=×<=*N* squares. Also you are given an unlimited number of standard domino pieces of 2<=×<=1 squares. You are allowed to rotate the pieces. You are asked to place as many dominoes as possible on the board so as to meet the following conditions:

1. Each domino completely covers two squares.

2. No two dominoes overlap.

3. Each domino lies entirely inside the board. It is allowed to touch the edges of the board.

Find the maximum number of dominoes, which can be placed under these restrictions.",In a single line you are given two integers *M* and *N* — board sizes in squares (1<=≤<=*M*<=≤<=*N*<=≤<=16).,"Output one number — the maximal number of dominoes, which can be placed.","['2 4\n', '3 3\n']","['4\n', '4\n']",none,RUNTIME_ERROR,"en = int(input())
boy = int(input())
alan = en*boy
print(alan//2)","import math

def divisor(n, k):
    divisors = []
    # Find all divisors of n
    for i in range(1, int(math.sqrt(n)) + 1):
        if n % i == 0:
            divisors.append(i)  # i is a divisor
            if i != n // i:
                divisors.append(n // i)  # n // i is also a divisor
                
    divisors.sort()  # Sort the divisors to find the k-th smallest
    # Check if k-th smallest divisor exists
    if len(divisors) < k:
        return -1  # Not enough divisors
    else:
        return divisors[k - 1]  # Return the k-th smallest divisor"
69,A,Young Physicist,PROGRAMMING,"['implementation', 'math']","A guy named Vasya attends the final grade of a high school. One day Vasya decided to watch a match of his favorite hockey team. And, as the boy loves hockey very much, even more than physics, he forgot to do the homework. Specifically, he forgot to complete his physics tasks. Next day the teacher got very angry at Vasya and decided to teach him a lesson. He gave the lazy student a seemingly easy task: You are given an idle body in space and the forces that affect it. The body can be considered as a material point with coordinates (0; 0; 0). Vasya had only to answer whether it is in equilibrium. ""Piece of cake"" — thought Vasya, we need only to check if the sum of all vectors is equal to 0. So, Vasya began to solve the problem. But later it turned out that there can be lots and lots of these forces, and Vasya can not cope without your help. Help him. Write a program that determines whether a body is idle or is moving by the given vectors of forces.","The first line contains a positive integer *n* (1<=≤<=*n*<=≤<=100), then follow *n* lines containing three integers each: the *x**i* coordinate, the *y**i* coordinate and the *z**i* coordinate of the force vector, applied to the body (<=-<=100<=≤<=*x**i*,<=*y**i*,<=*z**i*<=≤<=100).","Print the word ""YES"" if the body is in equilibrium, or the word ""NO"" if it is not.","['3\n4 1 7\n-2 4 -1\n1 -5 -3\n', '3\n3 -1 7\n-5 2 -4\n2 -1 -3\n']","['NO', 'YES']",none,OK,"n=int(input())
matrix=[]
l1=[]
for i in range(n):
    l1=[int(x) for x in input().split()]
    matrix.append(l1)
for i in range(3):
    sum=0
    for j in range(n):
        sum=sum+matrix[j][i]
    if sum==0:
        res=1 
        continue
    else:
        res=0
        break
if res==1:
    print(""YES"")
else:
    print(""NO"")","""""""Problem B - Not simply beatiful strings.

http://codeforces.com/contest/955/problem/B

Let's call a string adorable if its letters can be realigned in such a way
that they form two consequent groups of equal symbols (note that different
groups must contain different symbols). For example, ababa is adorable (you can
transform it to aaabb, where the first three letters form a group of a-s and
others — a group of b-s), but cccc is not since in each possible consequent
partition letters in these two groups coincide.

You're given a string s. Check whether it can be split into two non-empty
subsequences such that the strings formed by these subsequences are adorable.
""""""

def is_adorable_split(s):
    # Count the frequency of each character in the string
    from collections import Counter
    freq = Counter(s)
    
    # We need at least two different characters to form adorable groups
    if len(freq) < 2:
        return ""No""
    
    # Count how many characters have odd frequency
    odds_count = sum(1 for count in freq.values() if count % 2 != 0)
    
    # If we have more than 2 characters with odd frequencies
    # we cannot make two adorable groups
    if odds_count > 2:
        return ""No""
    
    return ""Yes""

# Read input
s = input().strip()

# Get the result and print it
result = is_adorable_split(s)
print(result)"
237,A,Free Cash,PROGRAMMING,['implementation'],"Valera runs a 24/7 fast food cafe. He magically learned that next day *n* people will visit his cafe. For each person we know the arrival time: the *i*-th person comes exactly at *h**i* hours *m**i* minutes. The cafe spends less than a minute to serve each client, but if a client comes in and sees that there is no free cash, than he doesn't want to wait and leaves the cafe immediately. 

Valera is very greedy, so he wants to serve all *n* customers next day (and get more profit). However, for that he needs to ensure that at each moment of time the number of working cashes is no less than the number of clients in the cafe. 

Help Valera count the minimum number of cashes to work at his cafe next day, so that they can serve all visitors.","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=105), that is the number of cafe visitors.

Each of the following *n* lines has two space-separated integers *h**i* and *m**i* (0<=≤<=*h**i*<=≤<=23; 0<=≤<=*m**i*<=≤<=59), representing the time when the *i*-th person comes into the cafe. 

Note that the time is given in the chronological order. All time is given within one 24-hour period.","Print a single integer — the minimum number of cashes, needed to serve all clients next day.","['4\n8 0\n8 10\n8 10\n8 45\n', '3\n0 12\n10 11\n22 22\n']","['2\n', '1\n']","In the first sample it is not enough one cash to serve all clients, because two visitors will come into cafe in 8:10. Therefore, if there will be one cash in cafe, then one customer will be served by it, and another one will not wait and will go away.

In the second sample all visitors will come in different times, so it will be enough one cash.",TIME_LIMIT_EXCEEDED,"n = int(input())
a = []
k = 0
for i in range(n):
    h,m = map(int,input().split())
    a.append(h*60+m)
for i in set(a):
    if a.count(i) > k:
        k = a.count(i)
print(1 if not k else k)
    ","from os import path
from sys import stdin, stdout
from typing import List

filename = ""../templates/input.txt""
if path.exists(filename):
    stdin = open(filename, 'r')

# Read the number of stars, queries, and maximum brightness
n, q, c = map(int, stdin.readline().split())

# Initialize the grid to store star brightness
star_grid = [[[0] * (c + 1) for _ in range(101)] for _ in range(101)]

# Read star data
for _ in range(n):
    x, y, s = map(int, stdin.readline().split())
    # Update the star_grid for each brightness level up to c
    for brightness in range(s, c + 1):
        star_grid[x][y][brightness] += 1

# Prepare to accumulate brightness levels
brightness_at_time = [[[0] * (c + 1) for _ in range(101)] for _ in range(101)]

# Calculate the cumulative brightness for each time and each star by decrementing brightness
for t in range(c + 1):
    for x in range(1, 101):
        for y in range(1, 101):
            brightness_at_time[x][y][t] = star_grid[x][y][t]
            if t > 0:
                brightness_at_time[x][y][t] += brightness_at_time[x][y][t - 1] - star_grid[x][y][min(t - 1, c)]

# Process each query
results = []
for _ in range(q):
    t, x1, y1, x2, y2 = map(int, stdin.readline().split())
    
    # Total brightness in the queried rectangle
    total_brightness = 0
    t = min(t, c)  # Limit t to the maximum brightness c
    for x in range(x1, x2 + 1):
        for y in range(y1, y2 + 1):
            total_brightness += brightness_at_time[x][y][t]

    results.append(total_brightness)

# Print all results for each query
stdout.write('\n'.join(map(str, results)) + '\n')"
977,A,Wrong Subtraction,PROGRAMMING,['implementation'],"Little girl Tanya is learning how to decrease a number by one, but she does it wrong with a number consisting of two or more digits. Tanya subtracts one from a number by the following algorithm:
 -  if the last digit of the number is non-zero, she decreases the number by one; -  if the last digit of the number is zero, she divides the number by 10 (i.e. removes the last digit). 
You are given an integer number $n$. Tanya will subtract one from it $k$ times. Your task is to print the result after all $k$ subtractions.

It is guaranteed that the result will be positive integer number.","The first line of the input contains two integer numbers $n$ and $k$ ($2 \le n \le 10^9$, $1 \le k \le 50$) — the number from which Tanya will subtract and the number of subtractions correspondingly.","Print one integer number — the result of the decreasing $n$ by one $k$ times.

It is guaranteed that the result will be positive integer number.","['512 4\n', '1000000000 9\n']","['50\n', '1\n']",The first example corresponds to the following sequence: $512 \rightarrow 511 \rightarrow 510 \rightarrow 51 \rightarrow 50$.,OK,"num, r = map(int, input().split())
for _ in range(r):
    if num%10 == 0:
        num = num//10
    else:
        num -= 1
print(num)","def main():
    x = int(input())
    num = ans = 0

    # While the current position is not equal to the target position
    while True:
        # Update the total distance covered with the next jump
        num += 1
        ans += num
        
        # Check if the total distance is greater than or equal to the absolute value of x
        if ans >= abs(x) and (ans - abs(x)) % 2 == 0:
            # Break the loop if condition is met
            break

    # Output the total number of jumps required
    print(num)

main()"
462,A,Appleman and Easy Task,PROGRAMMING,"['brute force', 'implementation']","Toastman came up with a very easy task. He gives it to Appleman, but Appleman doesn't know how to solve it. Can you help him?

Given a *n*<=×<=*n* checkerboard. Each cell of the board has either character 'x', or character 'o'. Is it true that each cell of the board has even number of adjacent cells with 'o'? Two cells of the board are adjacent if they share a side.",The first line contains an integer *n* (1<=≤<=*n*<=≤<=100). Then *n* lines follow containing the description of the checkerboard. Each of them contains *n* characters (either 'x' or 'o') without spaces.,"Print ""YES"" or ""NO"" (without the quotes) depending on the answer to the problem.","['3\nxxo\nxox\noxx\n', '4\nxxxo\nxoxo\noxox\nxxxx\n']","['YES\n', 'NO\n']",none,WRONG_ANSWER,"#codeforces462A
gi = lambda : list(map(int,input().strip().split()))
n, = gi()
g = [list(input()) for _ in range(n)]
g = [[0 if e[k] == 'x' else 1 for k in range(n)] for e in g]
for k in range(n):
	for j in range(n):
		temp = 0
		try:
			temp += g[k][j+1]
		except Exception:
			temp += 0
		try:
			temp += g[k][j-1]
		except Exception:
			temp += 0
		try:
			temp += g[k+1][j]
		except Exception:
			temp += 0
		try:
			temp += g[k-1][j]
		except Exception:
			temp += 0
		if temp%2:
			print(""NO"")
			exit();
print(""YES"")","def check(x, y, rec):
    if rec[x][y] and rec[x + 1][y] and rec[x][y + 1] and rec[x + 1][y + 1]:
        return True
    if rec[x][y] and rec[x - 1][y] and rec[x][y - 1] and rec[x - 1][y - 1]:
        return True
    return False

def main():
    n, m, k = map(int, input().split())  # Read the dimensions and number of moves
    rec = [[False] * (m + 1) for _ in range(n + 1)]  # Field representation
    for move in range(1, k + 1):
        x, y = map(int, input().split())  # Read each move
        rec[x][y] = True  # Color the pixel black
        
        # Check if a 2x2 square has been formed
        if x > 1 and y > 1:  # Check bottom-right square
            if check(x - 1, y - 1, rec):
                print(move)  # Output the move number
                return
        if x > 1 and y < m:  # Check bottom-left square
            if check(x - 1, y, rec):
                print(move)
                return
        if x < n and y > 1:  # Check top-right square
            if check(x, y - 1, rec):
                print(move)
                return
        if x < n and y < m:  # Check top-left square
            if check(x, y, rec):
                print(move)
                return

    print(0)  # No loss occurred

if __name__ == ""__main__"":
    main()"
313,A,Ilya and Bank Account,PROGRAMMING,"['implementation', 'number theory']","Ilya is a very clever lion, he lives in an unusual city ZooVille. In this city all the animals have their rights and obligations. Moreover, they even have their own bank accounts. The state of a bank account is an integer. The state of a bank account can be a negative number. This means that the owner of the account owes the bank money.

Ilya the Lion has recently had a birthday, so he got a lot of gifts. One of them (the gift of the main ZooVille bank) is the opportunity to delete the last digit or the digit before last from the state of his bank account no more than once. For example, if the state of Ilya's bank account is -123, then Ilya can delete the last digit and get his account balance equal to -12, also he can remove its digit before last and get the account balance equal to -13. Of course, Ilya is permitted not to use the opportunity to delete a digit from the balance.

Ilya is not very good at math, and that's why he asks you to help him maximize his bank account. Find the maximum state of the bank account that can be obtained using the bank's gift.",The single line contains integer *n* (10<=≤<=|*n*|<=≤<=109) — the state of Ilya's bank account.,In a single line print an integer — the maximum state of the bank account that Ilya can get.,"['2230\n', '-10\n', '-100003\n']","['2230\n', '0\n', '-10000\n']","In the first test sample Ilya doesn't profit from using the present.

In the second test sample you can delete digit 1 and get the state of the account equal to 0.",WRONG_ANSWER,"n = int(input())
if n > 0:
    print(max(n, n // 10, int((str(n // 100)+str(n % 10)))))
else:
    print(max(n, n // 10 + 1, int((str(n // 100 + 1)+str(abs(n) % 10)))))","def D(n):
    x, r = n - 1, 1
    while x >= 7:
        x //= 7
        r += 1
    return r

def H(n, l):
    x, r = n, """"
    while x > 0 or len(r) < l:
        r = str(x % 7) + r
        x //= 7
    return r

def count_distinct_time_pairs(n, m):
    distinct_count = 0
    hour_length = D(n)
    minute_length = D(m)

    for h in range(n):
        hour_str = H(h, hour_length)
        for m in range(m):
            minute_str = H(m, minute_length)
            # Combine hour and minute strings to check distinctness
            combined = hour_str + minute_str
            if len(combined) == len(set(combined)):  # Check if all characters are distinct
                distinct_count += 1

    return distinct_count

# Input reading
n, m = map(int, input().split())
# Calculate and print the result
print(count_distinct_time_pairs(n, m))"
705,A,Hulk,PROGRAMMING,['implementation'],"Dr. Bruce Banner hates his enemies (like others don't). As we all know, he can barely talk when he turns into the incredible Hulk. That's why he asked you to help him to express his feelings.

Hulk likes the Inception so much, and like that his feelings are complicated. They have *n* layers. The first layer is hate, second one is love, third one is hate and so on...

For example if *n*<==<=1, then his feeling is ""I hate it"" or if *n*<==<=2 it's ""I hate that I love it"", and if *n*<==<=3 it's ""I hate that I love that I hate it"" and so on.

Please help Dr. Banner.",The only line of the input contains a single integer *n* (1<=≤<=*n*<=≤<=100) — the number of layers of love and hate.,Print Dr.Banner's feeling in one line.,"['1\n', '2\n', '3\n']","['I hate it\n', 'I hate that I love it\n', 'I hate that I love that I hate it\n']",none,WRONG_ANSWER,"n = int(input())

if n == 1: print('I hate it')

elif n == 2: print('I hate that I love it')

elif n == 3 : print('I hate that I love that I hate it')


","def c(n): return ((n - 1) * n) // 2

def min_max_friends(n, m):
    # Maximum pairs of friends: all participants in one team
    max_friends = c(n)
    
    # Minimum pairs of friends: Evenly distribute participants among teams
    team_size = n // m
    remainder = n % m
    min_friends = c(team_size) * (m - remainder) + c(team_size + 1) * remainder
    
    return min_friends, max_friends

# Read input
n, m = map(int, input().split())
# Get minimum and maximum number of pairs of friends
result = min_max_friends(n, m)
# Print the result
print(result[0], result[1])"
288,E,Polo the Penguin and Lucky Numbers,PROGRAMMING,"['dp', 'implementation', 'math']","Everybody knows that lucky numbers are positive integers that contain only lucky digits 4 and 7 in their decimal representation. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.

Polo the Penguin have two positive integers *l* and *r* (*l*<=&lt;<=*r*), both of them are lucky numbers. Moreover, their lengths (that is, the number of digits in the decimal representation without the leading zeroes) are equal to each other.

Let's assume that *n* is the number of distinct lucky numbers, each of them cannot be greater than *r* or less than *l*, and *a**i* is the *i*-th (in increasing order) number of them. Find *a*1·*a*2<=+<=*a*2·*a*3<=+<=...<=+<=*a**n*<=-<=1·*a**n*. As the answer can be rather large, print the remainder after dividing it by 1000000007 (109<=+<=7).","The first line contains a positive integer *l*, and the second line contains a positive integer *r* (1<=≤<=*l*<=&lt;<=*r*<=≤<=10100000). The numbers are given without any leading zeroes.

It is guaranteed that the lengths of the given numbers are equal to each other and that both of them are lucky numbers.",In the single line print a single integer — the answer to the problem modulo 1000000007 (109<=+<=7).,"['4\n7\n', '474\n777\n']","['28\n', '2316330\n']",none,WRONG_ANSWER,"print(""_RANDOM_GUESS_1689631959.2502246"")# 1689631959.250245","def main():
    n, k = [int(n) for n in input().split()]
    S = input()
    doors = {}
    
    # Initialize active doors set and count of currently opened doors
    active_doors = set()
    opened_count = 0
    
    # Count guests for each door
    for i in range(n):
        door = S[i]
        if door not in doors:
            doors[door] = [0, 0]  # [first_index, last_index]
        # Update first and last index for the door
        if doors[door][0] == 0:
            doors[door][0] = i + 1  # mark first index (1-based)
        doors[door][1] = i + 1  # update last index (1-based)
    
    # Check openings and closings of doors
    for i in range(n):
        door = S[i]
        
        # Open the door
        if door not in active_doors:
            active_doors.add(door)
            opened_count += 1
            
        # Check if current opened doors exceed guards
        if opened_count > k:
            print(""YES"")
            return
        
        # Close the door if we've reached its last guest
        if doors[door][1] == i + 1:  # if it is the last guest for this door
            active_doors.remove(door)
            opened_count -= 1
    
    # If we never exceeded the guard limit
    print(""NO"")"
1,A,Theatre Square,PROGRAMMING,['math'],"Theatre Square in the capital city of Berland has a rectangular shape with the size *n*<=×<=*m* meters. On the occasion of the city's anniversary, a decision was taken to pave the Square with square granite flagstones. Each flagstone is of the size *a*<=×<=*a*.

What is the least number of flagstones needed to pave the Square? It's allowed to cover the surface larger than the Theatre Square, but the Square has to be covered. It's not allowed to break the flagstones. The sides of flagstones should be parallel to the sides of the Square.","The input contains three positive integer numbers in the first line: *n*,<=<=*m* and *a* (1<=≤<=<=*n*,<=*m*,<=*a*<=≤<=109).",Write the needed number of flagstones.,['6 6 4\n'],['4\n'],none,WRONG_ANSWER,"[n,m,a]=input().split()
if(int(n)%int(a)==0):
    rows=int(n)/int(a)
else:
    rows=(int(n)//int(a))+1
if(int(m)%int(a)==0):
    col=int(m)/int(a)
else:
    col=(int(m)//int(a))+1
print(rows*col)
","n, m = map(int, input().split())
d = sorted([int(x) for x in input().split()])

def isDirty(n: int) -> bool:
    return n in d

# Check if the first or last stair is dirty
if isDirty(1) or isDirty(n):
    print(""NO"")
else:
    # Check for consecutive dirty stairs
    for i in range(len(d) - 1):
        if d[i + 1] - d[i] == 1 and isDirty(d[i] + 1):
            print(""NO"")
            break
    else:
        # If no block found
        print(""YES"")"
875,B,Sorting the Coins,PROGRAMMING,"['dsu', 'implementation', 'sortings', 'two pointers']","Recently, Dima met with Sasha in a philatelic store, and since then they are collecting coins together. Their favorite occupation is to sort collections of coins. Sasha likes having things in order, that is why he wants his coins to be arranged in a row in such a way that firstly come coins out of circulation, and then come coins still in circulation. 

For arranging coins Dima uses the following algorithm. One step of his algorithm looks like the following:
 1.  He looks through all the coins from left to right; 1.  If he sees that the *i*-th coin is still in circulation, and (*i*<=+<=1)-th coin is already out of circulation, he exchanges these two coins and continues watching coins from (*i*<=+<=1)-th. 
Dima repeats the procedure above until it happens that no two coins were exchanged during this procedure. Dima calls hardness of ordering the number of steps required for him according to the algorithm above to sort the sequence, e.g. the number of times he looks through the coins from the very beginning. For example, for the ordered sequence hardness of ordering equals one.

Today Sasha invited Dima and proposed him a game. First he puts *n* coins in a row, all of them are out of circulation. Then Sasha chooses one of the coins out of circulation and replaces it with a coin in circulation for *n* times. During this process Sasha constantly asks Dima what is the hardness of ordering of the sequence. 

The task is more complicated because Dima should not touch the coins and he should determine hardness of ordering in his mind. Help Dima with this task.","The first line contains single integer *n* (1<=≤<=*n*<=≤<=300<=000) — number of coins that Sasha puts behind Dima.

Second line contains *n* distinct integers *p*1,<=*p*2,<=...,<=*p**n* (1<=≤<=*p**i*<=≤<=*n*) — positions that Sasha puts coins in circulation to. At first Sasha replaces coin located at position *p*1, then coin located at position *p*2 and so on. Coins are numbered from left to right.","Print *n*<=+<=1 numbers *a*0,<=*a*1,<=...,<=*a**n*, where *a*0 is a hardness of ordering at the beginning, *a*1 is a hardness of ordering after the first replacement and so on.","['4\n1 3 4 2\n', '8\n6 8 3 4 7 2 1 5\n']","['1 2 3 2 1\n', '1 2 2 3 4 3 4 5 1\n']","Let's denote as O coin out of circulation, and as X — coin is circulation.

At the first sample, initially in row there are coins that are not in circulation, so Dima will look through them from left to right and won't make any exchanges.

After replacement of the first coin with a coin in circulation, Dima will exchange this coin with next three times and after that he will finally look through the coins and finish the process.

XOOO  →  OOOX

After replacement of the third coin, Dima's actions look this way:

XOXO  →  OXOX  →  OOXX

After replacement of the fourth coin, Dima's actions look this way:

XOXX  →  OXXX

Finally, after replacement of the second coin, row becomes consisting of coins that are in circulation and Dima will look through coins from left to right without any exchanges.",TIME_LIMIT_EXCEEDED,"n = int(input())

cir = [int(x) for x in input().split(' ')]

output = []

coins = [0]*n
for c in cir:
    coins[c-1] = c
        
    looks = sum([1 for i,j in zip(coins, sorted(coins)) if (j and i!=j)]) + 1
    output.append(str(looks))
output = ['1'] + output

print(' '.join(output))","import sys  # 导入sys模块
sys.setrecursionlimit(10000000)
cnt = 0 # 计数器，记录当前处理到第几个节点
level = 0 # 层数
zongshu = 1 # 总节点数
q = [] # 存储符合条件的节点值

# 递归函数，计算节点所在层数
def count_ones(n, l, r):
    global cnt
    if n == 0:
        return 0
    if n == 1:
        cnt += 1
        return 1

    left_count = count_ones(n // 2, l, r)
    right_count = count_ones(n // 2, l - left_count, r - left_count)
    
    # 计算当前节点的1的数量
    current_count = left_count + right_count
    if zongshu >= l and zongshu <= r:
        return current_count
    
    zongshu += 1
    return current_count

# Input values
n, l, r = map(int, input().strip().split())

result = count_ones(n, l, r)
print(result)"
0,none,none,none,['none'],"The main road in Bytecity is a straight line from south to north. Conveniently, there are coordinates measured in meters from the southernmost building in north direction.

At some points on the road there are *n* friends, and *i*-th of them is standing at the point *x**i* meters and can move with any speed no greater than *v**i* meters per second in any of the two directions along the road: south or north.

You are to compute the minimum time needed to gather all the *n* friends at some point on the road. Note that the point they meet at doesn't need to have integer coordinate.","The first line contains single integer *n* (2<=≤<=*n*<=≤<=60<=000) — the number of friends.

The second line contains *n* integers *x*1,<=*x*2,<=...,<=*x**n* (1<=≤<=*x**i*<=≤<=109) — the current coordinates of the friends, in meters.

The third line contains *n* integers *v*1,<=*v*2,<=...,<=*v**n* (1<=≤<=*v**i*<=≤<=109) — the maximum speeds of the friends, in meters per second.","Print the minimum time (in seconds) needed for all the *n* friends to meet at some point on the road. 

Your answer will be considered correct, if its absolute or relative error isn't greater than 10<=-<=6. Formally, let your answer be *a*, while jury's answer be *b*. Your answer will be considered correct if  holds.","['3\n7 1 3\n1 2 1\n', '4\n5 10 3 2\n2 3 2 4\n']","['2.000000000000\n', '1.400000000000\n']","In the first sample, all friends can gather at the point 5 within 2 seconds. In order to achieve this, the first friend should go south all the time at his maximum speed, while the second and the third friends should go north at their maximum speeds.",TIME_LIMIT_EXCEEDED,"
dif = 0.000001

t = 0

n = int(input())
xi = [int(x) for x in input().split()]      
vi = [int(x) for x in input().split()]

a = min(xi)
b = max(xi)

while b - a > (dif / max(1,a)):  
    t = 0
    xt = (b-a)/2
    xf = 0    
    for i in range(n):
        if t < abs(xi[i] - xt) / vi[i]:
            t = abs(xi[i] - xt) / vi[i]
            xf = xi[i]
    
    if xf > xt:
        a = xt
    else:
        b = xt
    
print(t)","import sys

def can_reach(n, t, a):
    visited = set()  # Set to keep track of visited cells
    current = 1      # Start from cell 1

    while current not in visited:  # While we haven't visited this cell
        visited.add(current)       # Mark the current cell as visited
        if current == t:           # Check if we've reached the target cell
            return ""YES""
        current = current + a[current - 1]  # Move to the next cell using the portal

    return ""NO""  # If we exit the loop, we can't reach the target cell

# Read input
n, t = map(int, sys.stdin.readline().split())
a = list(map(int, sys.stdin.readline().split()))

# Print the result
print(can_reach(n, t, a))"
155,A,I_love_\%username\%,PROGRAMMING,['brute force'],"Vasya adores sport programming. He can't write programs but he loves to watch the contests' progress. Vasya even has a favorite coder and Vasya pays special attention to him.

One day Vasya decided to collect the results of all contests where his favorite coder participated and track the progress of his coolness. For each contest where this coder participated, he wrote out a single non-negative number — the number of points his favorite coder earned in the contest. Vasya wrote out the points for the contest in the order, in which the contests run (naturally, no two contests ran simultaneously).

Vasya considers a coder's performance in a contest amazing in two situations: he can break either his best or his worst performance record. First, it is amazing if during the contest the coder earns strictly more points that he earned on each past contest. Second, it is amazing if during the contest the coder earns strictly less points that he earned on each past contest. A coder's first contest isn't considered amazing. Now he wants to count the number of amazing performances the coder had throughout his whole history of participating in contests. But the list of earned points turned out long and Vasya can't code... That's why he asks you to help him.","The first line contains the single integer *n* (1<=≤<=*n*<=≤<=1000) — the number of contests where the coder participated.

The next line contains *n* space-separated non-negative integer numbers — they are the points which the coder has earned. The points are given in the chronological order. All points do not exceed 10000.",Print the single number — the number of amazing performances the coder has had during his whole history of participating in the contests.,"['5\n100 50 200 150 200\n', '10\n4664 6496 5814 7010 5762 5736 6944 4850 3698 7242\n']","['2\n', '4\n']","In the first sample the performances number 2 and 3 are amazing.

In the second sample the performances number 2, 4, 9 and 10 are amazing.",OK,"n = int(input())

points = list(map(int, input().split()))



amazing = 0

minimum = points[0]

maximum = points[0]



for i in range(1, n):

    if points[i] > minimum and points[i] > maximum:

        amazing += 1

        maximum = points[i]

    elif points[i] < minimum:

        amazing += 1

        minimum = points[i]



print(amazing)","from functools import cache


def solve(s, t):
    n = len(s)
    k = 0
    for i in s:
        if i == ""?"":
            k += 1  # Count unrecognized commands

    # Calculate the desired position based on Drazil's commands
    original_pos = sum(1 if x == '+' else -1 for x in t)
    
    # Calculate the current position based on recognized commands
    current_pos = sum(1 if x == '+' else -1 for x in s if x in ['+', '-'])
    
    # Calculate the required balance to reach the original position
    required_pos = original_pos - current_pos

    # Function to compute combinations
    def binomial_coefficient(n, k):
        if k > n or k < 0:
            return 0
        res = 1
        for i in range(k):
            res *= (n - i)
            res //= (i + 1)
        return res

    # Valid ways of distributing the `k` '?' commands
    valid_ways = 0
    for i in range(k + 1):
        if (i - (k - i)) == required_pos:
            valid_ways += binomial_coefficient(k, i)

    # Total possible outcomes from the unrecognized commands
    total_outcomes = 2 ** k

    # Calculate the probability and print the result
    return valid_ways / total_outcomes if total_outcomes > 0 else 0.0

# Sample usage
s1 = input().strip()
s2 = input().strip()
print(solve(s1, s2))"
81,A,Plug-in,PROGRAMMING,['implementation'],"Polycarp thinks about the meaning of life very often. He does this constantly, even when typing in the editor. Every time he starts brooding he can no longer fully concentrate and repeatedly presses the keys that need to be pressed only once. For example, instead of the phrase ""how are you"" he can type ""hhoow aaaare yyoouu"". 

Polycarp decided to automate the process of correcting such errors. He decided to write a plug-in to the text editor that will remove pairs of identical consecutive letters (if there are any in the text). Of course, this is not exactly what Polycarp needs, but he's got to start from something! 

Help Polycarp and write the main plug-in module. Your program should remove from a string all pairs of identical letters, which are consecutive. If after the removal there appear new pairs, the program should remove them as well. Technically, its work should be equivalent to the following: while the string contains a pair of consecutive identical letters, the pair should be deleted. Note that deleting of the consecutive identical letters can be done in any order, as any order leads to the same result.",The input data consists of a single line to be processed. The length of the line is from 1 to 2·105 characters inclusive. The string contains only lowercase Latin letters.,Print the given string after it is processed. It is guaranteed that the result will contain at least one character.,"['hhoowaaaareyyoouu\n', 'reallazy\n', 'abacabaabacabaa\n']","['wre', 'rezy', 'a']",none,OK,"# LUOGU_RID: 131046759
import sys
input = lambda:sys.stdin.readline().strip()
arc = []
for i in input():
    if arc and i == arc[-1]:
        arc.pop()
    else:
        arc.append(i)
print(*arc,sep="""")","def is_composite(num):
    """"""Check if a number is composite.""""""
    if num < 4:
        return False
    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            return True
    return False

def numbers(n):
    """"""Find two composite numbers that sum up to n.""""""
    for i in range(4, n//2 + 1):
        if is_composite(i) and is_composite(n - i):
            return i, n - i
    return None

# Example usage
n = int(input())
result = numbers(n)
if result:
    print(result[0], result[1])"
49,A,Sleuth,PROGRAMMING,['implementation'],"Vasya plays the sleuth with his friends. The rules of the game are as follows: those who play for the first time, that is Vasya is the sleuth, he should investigate a ""crime"" and find out what is happening. He can ask any questions whatsoever that can be answered with ""Yes"" or ""No"". All the rest agree beforehand to answer the questions like that: if the question’s last letter is a vowel, they answer ""Yes"" and if the last letter is a consonant, they answer ""No"". Of course, the sleuth knows nothing about it and his task is to understand that.

Unfortunately, Vasya is not very smart. After 5 hours of endless stupid questions everybody except Vasya got bored. That’s why Vasya’s friends ask you to write a program that would give answers instead of them.

The English alphabet vowels are: A, E, I, O, U, Y

The English alphabet consonants are: B, C, D, F, G, H, J, K, L, M, N, P, Q, R, S, T, V, W, X, Z","The single line contains a question represented by a non-empty line consisting of large and small Latin letters, spaces and a question mark. The line length does not exceed 100. It is guaranteed that the question mark occurs exactly once in the line — as the last symbol and that the line contains at least one letter.","Print answer for the question in a single line: YES if the answer is ""Yes"", NO if the answer is ""No"".

Remember that in the reply to the question the last letter, not the last character counts. I. e. the spaces and the question mark do not count as letters.","['Is it a melon?\n', 'Is it an apple?\n', 'Is     it a banana ?\n', 'Is   it an apple  and a  banana   simultaneouSLY?\n']","['NO\n', 'YES\n', 'YES\n', 'YES\n']",none,OK,"n = input().lower()
x = [97, 101, 105, 111, 117, 121]
i = len(n) - 1

while i+1:
    on = ord(n[i])
    if on in range(97, 123):
        if on in x:
            print('YES')
        else:
            print('NO')
        break
    i -= 1
","def reverse_segment(s, a):
    # Reverse the segment from index a-1 to the end of the string
    return s[:a-1] + s[a-1:][::-1]

def process_string(s, m, a):
    # Process the string over m days based on the positions in a
    for ai in a:
        s = reverse_segment(s, ai)
    return s

# Read input
s = input().strip()  # Pasha's original string
m = int(input().strip())  # Number of days
a = list(map(int, input().strip().split()))  # List of positions

# Get the final transformed string
result = process_string(s, m, a)

# Print the result
print(result)"
814,A,An abandoned sentiment from past,PROGRAMMING,"['constructive algorithms', 'greedy', 'implementation', 'sortings']","A few years ago, Hitagi encountered a giant crab, who stole the whole of her body weight. Ever since, she tried to avoid contact with others, for fear that this secret might be noticed.

To get rid of the oddity and recover her weight, a special integer sequence is needed. Hitagi's sequence has been broken for a long time, but now Kaiki provides an opportunity.

Hitagi's sequence *a* has a length of *n*. Lost elements in it are denoted by zeros. Kaiki provides another sequence *b*, whose length *k* equals the number of lost elements in *a* (i.e. the number of zeros). Hitagi is to replace each zero in *a* with an element from *b* so that each element in *b* should be used exactly once. Hitagi knows, however, that, apart from 0, no integer occurs in *a* and *b* more than once in total.

If the resulting sequence is not an increasing sequence, then it has the power to recover Hitagi from the oddity. You are to determine whether this is possible, or Kaiki's sequence is just another fake. In other words, you should detect whether it is possible to replace each zero in *a* with an integer from *b* so that each integer from *b* is used exactly once, and the resulting sequence is not increasing.","The first line of input contains two space-separated positive integers *n* (2<=≤<=*n*<=≤<=100) and *k* (1<=≤<=*k*<=≤<=*n*) — the lengths of sequence *a* and *b* respectively.

The second line contains *n* space-separated integers *a*1,<=*a*2,<=...,<=*a**n* (0<=≤<=*a**i*<=≤<=200) — Hitagi's broken sequence with exactly *k* zero elements.

The third line contains *k* space-separated integers *b*1,<=*b*2,<=...,<=*b**k* (1<=≤<=*b**i*<=≤<=200) — the elements to fill into Hitagi's sequence.

Input guarantees that apart from 0, no integer occurs in *a* and *b* more than once in total.","Output ""Yes"" if it's possible to replace zeros in *a* with elements in *b* and make the resulting sequence not increasing, and ""No"" otherwise.","['4 2\n11 0 0 14\n5 4\n', '6 1\n2 3 0 8 9 10\n5\n', '4 1\n8 94 0 4\n89\n', '7 7\n0 0 0 0 0 0 0\n1 2 3 4 5 6 7\n']","['Yes\n', 'No\n', 'Yes\n', 'Yes\n']","In the first sample: 
 -  Sequence *a* is 11, 0, 0, 14. -  Two of the elements are lost, and the candidates in *b* are 5 and 4. -  There are two possible resulting sequences: 11, 5, 4, 14 and 11, 4, 5, 14, both of which fulfill the requirements. Thus the answer is ""Yes"". 
In the second sample, the only possible resulting sequence is 2, 3, 5, 8, 9, 10, which is an increasing sequence and therefore invalid.",OK,"n,k=list(map(int,input().split()))
p=list(map(int,input().split()))
l=list(map(int,input().split()))
la=p.count(0)
for x in range(la):
    if l!=list():
       sa=max(l)
       ka=p.index(0)
       p[ka]=sa
       l.remove(sa)
    else:
        break
tam=sorted(p)
if p.count(0)==0 and tam!=p:
    print(""YES"")
else:
    print(""NO"")","n = int(input())
i = 4

def is_composite(x):
    """"""Check if a number is composite.""""""
    if x < 4:
        return False
    for j in range(2, int(x**0.5) + 1):
        if x % j == 0:
            return True
    return False

found = False
while i <= n // 2:
    if is_composite(i) and is_composite(n - i):
        print(i, n - i)
        found = True
        break
    i += 1

if not found:
    print(""No solution found."")"
841,A,Generous Kefa,PROGRAMMING,"['brute force', 'implementation']","One day Kefa found *n* baloons. For convenience, we denote color of *i*-th baloon as *s**i* — lowercase letter of the Latin alphabet. Also Kefa has *k* friends. Friend will be upset, If he get two baloons of the same color. Kefa want to give out all baloons to his friends. Help Kefa to find out, can he give out all his baloons, such that no one of his friens will be upset — print «YES», if he can, and «NO», otherwise. Note, that Kefa's friend will not upset, if he doesn't get baloons at all.","The first line contains two integers *n* and *k* (1<=≤<=*n*,<=*k*<=≤<=100) — the number of baloons and friends.

Next line contains string *s* — colors of baloons.","Answer to the task — «YES» or «NO» in a single line.

You can choose the case (lower or upper) for each letter arbitrary.","['4 2\naabb\n', '6 3\naacaab\n']","['YES\n', 'NO\n']","In the first sample Kefa can give 1-st and 3-rd baloon to the first friend, and 2-nd and 4-th to the second.

In the second sample Kefa needs to give to all his friends baloons of color a, but one baloon will stay, thats why answer is «NO».",OK,"n,k=map(int,input().split())
s=input()
d=dict()
for i in s:
    d[i]=d.get(i,0)+1
m=0
for _,i in d.items():
    m=max(m,i)
if(m>k):
    print('NO')
else:
    print('YES')

    ","from sys import stdin
stdin.readline
def mp(): return list(map(int, stdin.readline().strip().split()))
def it():return int(stdin.readline().strip())

s=list(input())
n=len(s)
if n==1:
    print(s[0])
else:
    for i in range(1, n):
        # Check if the current character is the same as the previous one
        if s[i] == s[i - 1]:
            for c in 'abcdefghijklmnopqrstuvwxyz':
                # Find a character that is different from the previous and next characters
                if c != s[i - 1] and (i + 1 >= n or c != s[i + 1]):
                    s[i] = c  # Change the character
                    break
    print(''.join(s))"
1,A,Theatre Square,PROGRAMMING,['math'],"Theatre Square in the capital city of Berland has a rectangular shape with the size *n*<=×<=*m* meters. On the occasion of the city's anniversary, a decision was taken to pave the Square with square granite flagstones. Each flagstone is of the size *a*<=×<=*a*.

What is the least number of flagstones needed to pave the Square? It's allowed to cover the surface larger than the Theatre Square, but the Square has to be covered. It's not allowed to break the flagstones. The sides of flagstones should be parallel to the sides of the Square.","The input contains three positive integer numbers in the first line: *n*,<=<=*m* and *a* (1<=≤<=<=*n*,<=*m*,<=*a*<=≤<=109).",Write the needed number of flagstones.,['6 6 4\n'],['4\n'],none,COMPILATION_ERROR,"l=list(map(int,input().split())
for i in l:
    if l.count(i)==1:
        print(i)
        break","from collections import Counter
from functools import lru_cache
import bisect
import math

def gcd(x, y):
    while y:
        x, y = y, x % y
    return x

def longest_good_sequence(n, good_integers):
    # Initialize the maximum length of the good sequence
    max_length = 0
    # To store the last element of the current good sequence
    current_sequence = []
    
    for num in good_integers:
        # If current_sequence is empty or the last element is coprime to the current number
        if not current_sequence or gcd(current_sequence[-1], num) > 1:
            current_sequence.append(num)
            max_length = max(max_length, len(current_sequence))
        else:
            # If it's coprime, find position to replace in current_sequence
            idx = bisect.bisect_right(current_sequence, num)
            if idx < len(current_sequence):
                current_sequence[idx] = num
    
    return max_length

# Sample Input
n = int(input())
good_integers = list(map(int, input().split()))

# Get result
result = longest_good_sequence(n, good_integers)
print(result)"
740,A,Alyona and copybooks,PROGRAMMING,"['brute force', 'implementation']","Little girl Alyona is in a shop to buy some copybooks for school. She study four subjects so she wants to have equal number of copybooks for each of the subjects. There are three types of copybook's packs in the shop: it is possible to buy one copybook for *a* rubles, a pack of two copybooks for *b* rubles, and a pack of three copybooks for *c* rubles. Alyona already has *n* copybooks.

What is the minimum amount of rubles she should pay to buy such number of copybooks *k* that *n*<=+<=*k* is divisible by 4? There are infinitely many packs of any type in the shop. Alyona can buy packs of different type in the same purchase.","The only line contains 4 integers *n*, *a*, *b*, *c* (1<=≤<=*n*,<=*a*,<=*b*,<=*c*<=≤<=109).",Print the minimum amount of rubles she should pay to buy such number of copybooks *k* that *n*<=+<=*k* is divisible by 4.,"['1 1 3 4\n', '6 2 1 1\n', '4 4 4 4\n', '999999999 1000000000 1000000000 1000000000\n']","['3\n', '1\n', '0\n', '1000000000\n']","In the first example Alyona can buy 3 packs of 1 copybook for 3*a* = 3 rubles in total. After that she will have 4 copybooks which she can split between the subjects equally. 

In the second example Alyuna can buy a pack of 2 copybooks for *b* = 1 ruble. She will have 8 copybooks in total.

In the third example Alyona can split the copybooks she already has between the 4 subject equally, so she doesn't need to buy anything.

In the fourth example Alyona should buy one pack of one copybook.",OK,"""""""
ATSTNG's ejudge Python3 solution template
(actual solution is below)
""""""
import sys, queue

try:
    import dev_act_ffc429465ab634  # empty file in directory
    DEV = True
except:
    DEV = False

def log(*s):
    if DEV: print('LOG', *s)

class EJudge:
    def __init__(self, problem=""default"", reclim=1<<30):
        self.problem = problem
        sys.setrecursionlimit(reclim)

    def use_files(self, infile='', outfile=''):
        if infile!='':
            self.infile = open(infile)
            sys.stdin = self.infile
        if infile!='':
            self.outfile = open(outfile, 'w')
            sys.stdout = self.outfile

    def use_bacs_files(self):
        self.use_files(self.problem+'.in', self.problem+'.out')

    def get_tl(self):
        while True: pass

    def get_ml(self):
        tmp = [[[5]*100000 for _ in range(1000)]]
        while True: tmp.append([[5]*100000 for _ in range(1000)])

    def get_re(self):
        s = (0,)[8]

    def get_wa(self, wstr='blablalblah'):
        for _ in range(3): print(wstr)
        exit()

class IntReader:
    def __init__(self):
        self.ost = queue.Queue()

    def get(self):
        return int(self.sget())

    def sget(self):
        if self.ost.empty():
            for el in input().split():
                self.ost.put(el)
        return self.ost.get()

    def release(self):
        res = []
        while not self.ost.empty():
            res.append(self.ost.get())
        return res

###############################################################################
ej = EJudge(  )
int_reader = IntReader()
fmap = lambda f,*l: list(map(f,*l))
parse_int = lambda: fmap(int, input().split())

# input
n,t1,t2,t3 = parse_int()
t3 = min(t3, t2+t1, t1*3)
t2 = min(t2, t1*2, t3*2)
t1 = min(t1, t3+t2, t3*3)

n = n%4
if n==0: ans = 0
if n==1: ans = t3
if n==2: ans = t2
if n==3: ans = t1

print(ans)

















","n, k = [int(_) for _ in input().split()]
a = input()

def next_free(x):
    x += 1
    while x < n and a[x] == '1':
        x += 1
    return x

# Function to check if a maximum distance is feasible
def can_place_cows(max_dist):
    count = 0
    last_position = -max_dist - 1  # Starting position outside the range
    
    for i in range(n):
        if a[i] == '0':
            # Check if the current free room is valid for placing a cow
            if i - last_position >= max_dist:
                count += 1
                last_position = i
                if count >= k + 1:  # 'k' cows plus Farmer John's room
                    return True
    return False

# Binary search for the minimum possible distance
left, right = 0, n
while left < right:
    mid = (left + right) // 2
    if can_place_cows(mid):
        right = mid  # Try for a smaller maximum distance
    else:
        left = mid + 1  # Increase the distance

print(left)"
61,A,Ultra-Fast Mathematician,PROGRAMMING,['implementation'],"Shapur was an extremely gifted student. He was great at everything including Combinatorics, Algebra, Number Theory, Geometry, Calculus, etc. He was not only smart but extraordinarily fast! He could manage to sum 1018 numbers in a single second.

One day in 230 AD Shapur was trying to find out if any one can possibly do calculations faster than him. As a result he made a very great contest and asked every one to come and take part.

In his contest he gave the contestants many different pairs of numbers. Each number is made from digits 0 or 1. The contestants should write a new number corresponding to the given pair of numbers. The rule is simple: The *i*-th digit of the answer is 1 if and only if the *i*-th digit of the two given numbers differ. In the other case the *i*-th digit of the answer is 0.

Shapur made many numbers and first tried his own speed. He saw that he can perform these operations on numbers of length ∞ (length of a number is number of digits in it) in a glance! He always gives correct answers so he expects the contestants to give correct answers, too. He is a good fellow so he won't give anyone very big numbers and he always gives one person numbers of same length.

Now you are going to take part in Shapur's contest. See if you are faster and more accurate.",There are two lines in each input. Each of them contains a single number. It is guaranteed that the numbers are made from 0 and 1 only and that their length is same. The numbers may start with 0. The length of each number doesn't exceed 100.,Write one line — the corresponding answer. Do not omit the leading 0s.,"['1010100\n0100101\n', '000\n111\n', '1110\n1010\n', '01110\n01100\n']","['1110001\n', '111\n', '0100\n', '00010\n']",none,WRONG_ANSWER,"m = input()
n = int(input())
k = len(m)
m = int(m)
kn = len(str(n))
ans = ['', '0'*(k-kn)][kn<k] + str(m+n)
ans = ans.replace('2','0')
print(ans)","import sys
def input():    return sys.stdin.readline().strip()
def iinput():   return int(input())
def minput():   return map(int, input().split()) 
def listinput(): return list(map(int, input().split()))

def count_deputies(n, m, president_color, office):
    president_positions = set()
    
    # Find positions of the president's desk
    for i in range(n):
        for j in range(m):
            if office[i][j] == president_color:
                president_positions.add((i, j))
    
    deputy_count = 0
    # Directions for adjacent cells (up, down, left, right)
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    
    # Check all adjacent positions for deputies
    for i, j in president_positions:
        for di, dj in directions:
            ni, nj = i + di, j + dj
            if 0 <= ni < n and 0 <= nj < m and office[ni][nj] != '.' and office[ni][nj] != president_color:
                deputy_count += 1
                
    return deputy_count

n, m, president_color = input().split()
n, m = int(n), int(m)
office = [input() for _ in range(n)]

# Count and print the number of deputies
print(count_deputies(n, m, president_color, office))"
519,A,A and B and Chess,PROGRAMMING,['implementation'],"A and B are preparing themselves for programming contests.

To train their logical thinking and solve problems better, A and B decided to play chess. During the game A wondered whose position is now stronger.

For each chess piece we know its weight: 
 -  the queen's weight is 9, -  the rook's weight is 5, -  the bishop's weight is 3, -  the knight's weight is 3, -  the pawn's weight is 1, -  the king's weight isn't considered in evaluating position. 
The player's weight equals to the sum of weights of all his pieces on the board.

As A doesn't like counting, he asked you to help him determine which player has the larger position weight.","The input contains eight lines, eight characters each — the board's description.

The white pieces on the board are marked with uppercase letters, the black pieces are marked with lowercase letters.

The white pieces are denoted as follows: the queen is represented is 'Q', the rook — as 'R', the bishop — as'B', the knight — as 'N', the pawn — as 'P', the king — as 'K'.

The black pieces are denoted as 'q', 'r', 'b', 'n', 'p', 'k', respectively.

An empty square of the board is marked as '.' (a dot). 

It is not guaranteed that the given chess position can be achieved in a real game. Specifically, there can be an arbitrary (possibly zero) number pieces of each type, the king may be under attack and so on.","Print ""White"" (without quotes) if the weight of the position of the white pieces is more than the weight of the position of the black pieces, print ""Black"" if the weight of the black pieces is more than the weight of the white pieces and print ""Draw"" if the weights of the white and black pieces are equal.","['...QK...\n........\n........\n........\n........\n........\n........\n...rk...\n', 'rnbqkbnr\npppppppp\n........\n........\n........\n........\nPPPPPPPP\nRNBQKBNR\n', 'rppppppr\n...k....\n........\n........\n........\n........\nK...Q...\n........\n']","['White\n', 'Draw\n', 'Black\n']","In the first test sample the weight of the position of the white pieces equals to 9, the weight of the position of the black pieces equals 5.

In the second test sample the weights of the positions of the black and the white pieces are equal to 39.

In the third test sample the weight of the position of the white pieces equals to 9, the weight of the position of the black pieces equals to 16.",OK,"#519A
valW = 0
valB = 0
for _ in range(8):
    a = input()
    for i in range(8) :
        if a[i] == 'Q':
            valW = valW + 9
        elif a[i] == 'R' :
            valW = valW + 5
        elif a[i] == 'B' :
            valW = valW + 3
        elif a[i] == 'N' :
            valW = valW + 3
        elif a[i] == 'P' :
            valW = valW + 1
        elif a[i] == 'K' :
            valW = valW + 0
        elif a[i] == 'q':
            valB = valB + 9
        elif a[i] == 'r' :
            valB = valB + 5
        elif a[i] == 'b' :
            valB = valB + 3
        elif a[i] == 'n' :
            valB = valB + 3
        elif a[i] == 'p' :
            valB = valB + 1
        elif a[i] == 'k' :
            valB = valB + 0
if valW == valB :
    print('Draw')
elif valW > valB :
    print('White')
else :
    print('Black')
#print(valW, valB)
#96 112
","n = int(input())
	s = input()

	def get_divisors(n):
		i = 2
		original = n
		res = []
		# Check for each number from 1 to sqrt(n) to find divisors
		while i * i <= n:
			if n % i == 0:
				res.append(i)
				if i != n // i:
					res.append(n // i)
			i += 1
		res.append(1)  # 1 is always a divisor
		res.append(n)  # n is always a divisor
		# Return the divisors sorted in descending order
		return sorted(res, reverse=True)

	# Get all divisors of n
	divisors = get_divisors(n)
	# Start decryption with the encrypted string t
	for d in divisors:
		# Reverse the substring from the start to the d-th character
		s = s[:d][::-1] + s[d:]

	# Print the original string
	print(s)"
61,A,Ultra-Fast Mathematician,PROGRAMMING,['implementation'],"Shapur was an extremely gifted student. He was great at everything including Combinatorics, Algebra, Number Theory, Geometry, Calculus, etc. He was not only smart but extraordinarily fast! He could manage to sum 1018 numbers in a single second.

One day in 230 AD Shapur was trying to find out if any one can possibly do calculations faster than him. As a result he made a very great contest and asked every one to come and take part.

In his contest he gave the contestants many different pairs of numbers. Each number is made from digits 0 or 1. The contestants should write a new number corresponding to the given pair of numbers. The rule is simple: The *i*-th digit of the answer is 1 if and only if the *i*-th digit of the two given numbers differ. In the other case the *i*-th digit of the answer is 0.

Shapur made many numbers and first tried his own speed. He saw that he can perform these operations on numbers of length ∞ (length of a number is number of digits in it) in a glance! He always gives correct answers so he expects the contestants to give correct answers, too. He is a good fellow so he won't give anyone very big numbers and he always gives one person numbers of same length.

Now you are going to take part in Shapur's contest. See if you are faster and more accurate.",There are two lines in each input. Each of them contains a single number. It is guaranteed that the numbers are made from 0 and 1 only and that their length is same. The numbers may start with 0. The length of each number doesn't exceed 100.,Write one line — the corresponding answer. Do not omit the leading 0s.,"['1010100\n0100101\n', '000\n111\n', '1110\n1010\n', '01110\n01100\n']","['1110001\n', '111\n', '0100\n', '00010\n']",none,WRONG_ANSWER,"x1=int(input())
x2= int(input())
z= x1^x2
print(z)","def aryaBen():
    d, g = map(int, input().split())
    dList = list(map(int, input().split()))
    bScore = 0  # Total chocolates given to Bran
    totalCandies = 0  # Total candies Arya has
    for i in range(d):
        totalCandies += dList[i]  # Add today's candies to the total
        # Give at most 8 candies to Bran from the total
        bScore += min(8, totalCandies)
        totalCandies -= min(8, totalCandies)  # Reduce the total candies by the amount given
        
        if bScore >= g:  # Check if Bran received enough candies
            print(i + 1)  # Output the current day (1-indexed)
            return
            
    print(-1)  # If we don't meet the goal after n days"
21,C,Stripe 2,PROGRAMMING,"['binary search', 'dp', 'sortings']","Once Bob took a paper stripe of n squares (the height of the stripe is 1 square). In each square he wrote an integer number, possibly negative. He became interested in how many ways exist to cut this stripe into three pieces so that the sum of numbers from each piece is equal to the sum of numbers from any other piece, and each piece contains positive integer amount of squares. Would you help Bob solve this problem?",The first input line contains integer *n* (1<=≤<=*n*<=≤<=105) — amount of squares in the stripe. The second line contains n space-separated numbers — they are the numbers written in the squares of the stripe. These numbers are integer and do not exceed 10000 in absolute value.,Output the amount of ways to cut the stripe into three non-empty pieces so that the sum of numbers from each piece is equal to the sum of numbers from any other piece. Don't forget that it's allowed to cut the stripe along the squares' borders only.,"['4\n1 2 3 3\n', '5\n1 2 3 4 5\n']","['1\n', '0\n']",none,TIME_LIMIT_EXCEEDED,"
k = int(input())
X = []
sum_array= []
b=0

for i in input().strip().split():
    X.append(int(i))
    b+= int(i)
    sum_array.append(b)
   
if ((sum_array[-1] % 3 != 0) or (k < 3)):
    print(0)
    quit()

i=0
b=1

while b< (k-1):
    b1= b+ 1
    while b1< k:
        if sum_array[b1-1]== (2*sum_array[b-1]):
            if sum_array[-1]== (2* sum_array[b1-1]- sum_array[b-1]): i+= 1
        b1+= 1
    b+= 1
print(i)","import sys

_, s = input(), input()

def yes():
    # Initialize count for coloring combinations
    count = 1

    # Replace '?' with a valid character based on adjacent segments
    for i in range(len(s)):
        if s[i] == '?':
            # Determine options for painting current segment
            options = set('CMY')  # All colors available
            
            # Remove color of the previous segment if it exists
            if i > 0 and s[i - 1] in options:
                options.remove(s[i - 1])
            
            # Remove color of the next segment if it exists
            if i < len(s) - 1 and s[i + 1] in options:
                options.remove(s[i + 1])
            
            # If there's more than one option, increment count
            if len(options) > 1:
                count *= len(options)
            elif len(options) == 0:
                # If no valid options, no valid coloring exists
                print(""No"")
                return

    # After processing, check if count allows for at least two different colorings
    print(""Yes"" if count >= 2 else ""No"")

yes()"
743,B,Chloe and the sequence ,PROGRAMMING,"['binary search', 'bitmasks', 'constructive algorithms', 'implementation']","Chloe, the same as Vladik, is a competitive programmer. She didn't have any problems to get to the olympiad like Vladik, but she was confused by the task proposed on the olympiad.

Let's consider the following algorithm of generating a sequence of integers. Initially we have a sequence consisting of a single element equal to 1. Then we perform (*n*<=-<=1) steps. On each step we take the sequence we've got on the previous step, append it to the end of itself and insert in the middle the minimum positive integer we haven't used before. For example, we get the sequence [1,<=2,<=1] after the first step, the sequence [1,<=2,<=1,<=3,<=1,<=2,<=1] after the second step.

The task is to find the value of the element with index *k* (the elements are numbered from 1) in the obtained sequence, i. e. after (*n*<=-<=1) steps.

Please help Chloe to solve the problem!","The only line contains two integers *n* and *k* (1<=≤<=*n*<=≤<=50, 1<=≤<=*k*<=≤<=2*n*<=-<=1).",Print single integer — the integer at the *k*-th position in the obtained sequence.,"['3 2\n', '4 8\n']","['2', '4']","In the first sample the obtained sequence is [1, 2, 1, 3, 1, 2, 1]. The number on the second position is 2.

In the second sample the obtained sequence is [1, 2, 1, 3, 1, 2, 1, 4, 1, 2, 1, 3, 1, 2, 1]. The number on the eighth position is 4.",WRONG_ANSWER,"from math import ceil, floor

n,k = input().split()
n = int(n)
k = int(k)



side_part = []
middle_part = []
sequence = [1]
for i in range(0,n-1):
	side_part = sequence
	max_el = max(side_part)
	middle_part.append(max_el + 1)
	sequence = side_part + middle_part + side_part
	middle_part.clear()



length = 1
for i in range(0,n-1):
	length = length * 2 + 1
	index_max_el = length/2

iterr = 0
while index_max_el > 1:
	index_max_el = floor(index_max_el / 2)
	iterr = iterr + 2
print(iterr)","def find_recon_unit(n, heights_list):
    min_diff = float('inf')
    idx1, idx2 = 0, 1

    for i in range(n):
        # Calculate the index of the next soldier in the circle
        next_i = (i + 1) % n

        # Compute the height difference
        diff = abs(heights_list[i] - heights_list[next_i])
        
        # Check for a new minimal difference
        if diff < min_diff:
            min_diff = diff
            idx1, idx2 = i + 1, next_i + 1  # Store 1-based indices

    # Output the indices of the neighbouring soldiers
    return idx1, idx2"
385,B,Bear and Strings,PROGRAMMING,"['brute force', 'greedy', 'implementation', 'math', 'strings']","The bear has a string *s*<==<=*s*1*s*2... *s*|*s*| (record |*s*| is the string's length), consisting of lowercase English letters. The bear wants to count the number of such pairs of indices *i*,<=*j* (1<=≤<=*i*<=≤<=*j*<=≤<=|*s*|), that string *x*(*i*,<=*j*)<==<=*s**i**s**i*<=+<=1... *s**j* contains at least one string ""bear"" as a substring.

String *x*(*i*,<=*j*) contains string ""bear"", if there is such index *k* (*i*<=≤<=*k*<=≤<=*j*<=-<=3), that *s**k*<==<=*b*, *s**k*<=+<=1<==<=*e*, *s**k*<=+<=2<==<=*a*, *s**k*<=+<=3<==<=*r*.

Help the bear cope with the given problem.",The first line contains a non-empty string *s* (1<=≤<=|*s*|<=≤<=5000). It is guaranteed that the string only consists of lowercase English letters.,Print a single number — the answer to the problem.,"['bearbtear\n', 'bearaabearc\n']","['6\n', '20\n']","In the first sample, the following pairs (*i*, *j*) match: (1, 4), (1, 5), (1, 6), (1, 7), (1, 8), (1, 9).

In the second sample, the following pairs (*i*, *j*) match: (1,  4), (1,  5), (1,  6), (1,  7), (1,  8), (1,  9), (1,  10), (1,  11), (2,  10), (2,  11), (3,  10), (3,  11), (4,  10), (4,  11), (5,  10), (5,  11), (6,  10), (6,  11), (7,  10), (7,  11).",OK,"import sys
import math


def main():
    read = sys.stdin.readline
    word: str = read().strip()
    prev = None
    total = 0
    for i, c in enumerate(word):
        if i + 3 >= len(word):
            break
        if word[i] == 'b' and word[i + 1] == 'e' and word[i + 2] == 'a' and word[i + 3] == 'r':
            prev_val = (prev if prev else 0) + 1
            # Count all string starting from the left
            l = i + 1
            r = i + 3 + 1
            left = l - 1 - (prev_val) + 1
            right = len(word) - (r + 1) + 1
            if l == 1:
                total += 1 + right
            elif r == len(word):
                total += 1 + left
            else:
                total += left * (right + 1)
                total += 1 + right
            prev = l
    print(total)


if __name__ == '__main__':
    main()
","def code3(n):
    # Initialize a set to store unique weights
    weights = set()
    
    # Iterate through possible first elements from 1 to n
    for first in range(1, n + 1):
        # Calculate the maximum weight for the current first element
        max_weight = n // first
        
        # Add all possible weights for this first element to the set
        weights.add(max_weight)
    
    # Return the number of unique weights found
    return len(weights)"
792,B,Counting-out Rhyme,PROGRAMMING,['implementation'],"*n* children are standing in a circle and playing the counting-out game. Children are numbered clockwise from 1 to *n*. In the beginning, the first child is considered the leader. The game is played in *k* steps. In the *i*-th step the leader counts out *a**i* people in clockwise order, starting from the next person. The last one to be pointed at by the leader is eliminated, and the next player after him becomes the new leader.

For example, if there are children with numbers [8,<=10,<=13,<=14,<=16] currently in the circle, the leader is child 13 and *a**i*<==<=12, then counting-out rhyme ends on child 16, who is eliminated. Child 8 becomes the leader.

You have to write a program which prints the number of the child to be eliminated on every step.","The first line contains two integer numbers *n* and *k* (2<=≤<=*n*<=≤<=100, 1<=≤<=*k*<=≤<=*n*<=-<=1).

The next line contains *k* integer numbers *a*1,<=*a*2,<=...,<=*a**k* (1<=≤<=*a**i*<=≤<=109).","Print *k* numbers, the *i*-th one corresponds to the number of child to be eliminated at the *i*-th step.","['7 5\n10 4 11 4 1\n', '3 2\n2 5\n']","['4 2 5 6 1 \n', '3 2 \n']","Let's consider first example: 
 -  In the first step child 4 is eliminated, child 5 becomes the leader. -  In the second step child 2 is eliminated, child 3 becomes the leader. -  In the third step child 5 is eliminated, child 6 becomes the leader. -  In the fourth step child 6 is eliminated, child 7 becomes the leader. -  In the final step child 1 is eliminated, child 3 becomes the leader.",WRONG_ANSWER,"from collections import deque
n,k=map(int,input().split())
a=[int(i) for i in input().split()]
d=deque([i for i in range(1,n+1)])
res=[]
for i in range(k):
    d.rotate(-(a[i]))
    x=d.popleft()
    res.append(x)
print(res)
","def sol():
    nA, nB = map(int, input().split())  # Read sizes of arrays A and B
    k, m = map(int, input().split())     # Read number of elements to choose from A and B
    A = list(map(int, input().split()))   # Read array A
    B = list(map(int, input().split()))   # Read array B
    
    # Check if the k'th element of A is less than the m'th element of B
    if A[k-1] < B[m-1]:  
        print(""YES"")  # It's possible to choose k from A and m from B
    else:
        print(""NO"")   # It's not possible"
160,A,Twins,PROGRAMMING,"['greedy', 'sortings']","Imagine that you have a twin brother or sister. Having another person that looks exactly like you seems very unusual. It's hard to say if having something of an alter ego is good or bad. And if you do have a twin, then you very well know what it's like.

Now let's imagine a typical morning in your family. You haven't woken up yet, and Mom is already going to work. She has been so hasty that she has nearly forgotten to leave the two of her darling children some money to buy lunches in the school cafeteria. She fished in the purse and found some number of coins, or to be exact, *n* coins of arbitrary values *a*1,<=*a*2,<=...,<=*a**n*. But as Mom was running out of time, she didn't split the coins for you two. So she scribbled a note asking you to split the money equally.

As you woke up, you found Mom's coins and read her note. ""But why split the money equally?"" — you thought. After all, your twin is sleeping and he won't know anything. So you decided to act like that: pick for yourself some subset of coins so that the sum of values of your coins is strictly larger than the sum of values of the remaining coins that your twin will have. However, you correctly thought that if you take too many coins, the twin will suspect the deception. So, you've decided to stick to the following strategy to avoid suspicions: you take the minimum number of coins, whose sum of values is strictly more than the sum of values of the remaining coins. On this basis, determine what minimum number of coins you need to take to divide them in the described manner.","The first line contains integer *n* (1<=≤<=*n*<=≤<=100) — the number of coins. The second line contains a sequence of *n* integers *a*1, *a*2, ..., *a**n* (1<=≤<=*a**i*<=≤<=100) — the coins' values. All numbers are separated with spaces.",In the single line print the single number — the minimum needed number of coins.,"['2\n3 3\n', '3\n2 1 2\n']","['2\n', '2\n']","In the first sample you will have to take 2 coins (you and your twin have sums equal to 6, 0 correspondingly). If you take 1 coin, you get sums 3, 3. If you take 0 coins, you get sums 0, 6. Those variants do not satisfy you as your sum should be strictly more that your twins' sum.

In the second sample one coin isn't enough for us, too. You can pick coins with values 1, 2 or 2, 2. In any case, the minimum number of coins equals 2.",WRONG_ANSWER,"n = int(input())
coins = list(map(int, input().split()))
coins.sort()
total_sum = sum(coins)
your_sum = 0
twin_sum = 0
for coin in coins:
    if your_sum < total_sum / 2:
        your_sum += coin
        twin_sum = total_sum - your_sum
    else:
        break
print(your_sum)
","import sys
input = sys.stdin.readline
from collections import defaultdict as dc
from collections import Counter
from bisect import bisect_right, bisect_left
import math

n = int(input())
strings = [input().strip() for _ in range(n)]

# Sort strings by length in ascending order
strings.sort(key=len)

# Check if the current order satisfies the substring condition
for i in range(1, n):
    # Check if strings[i-1] is a substring of strings[i]
    if strings[i-1] not in strings[i]:
        print(""NO"")
        break
else:
    # If the loop completes without breaking, print result
    print(""YES"")
    print(""\n"".join(strings))"
705,A,Hulk,PROGRAMMING,['implementation'],"Dr. Bruce Banner hates his enemies (like others don't). As we all know, he can barely talk when he turns into the incredible Hulk. That's why he asked you to help him to express his feelings.

Hulk likes the Inception so much, and like that his feelings are complicated. They have *n* layers. The first layer is hate, second one is love, third one is hate and so on...

For example if *n*<==<=1, then his feeling is ""I hate it"" or if *n*<==<=2 it's ""I hate that I love it"", and if *n*<==<=3 it's ""I hate that I love that I hate it"" and so on.

Please help Dr. Banner.",The only line of the input contains a single integer *n* (1<=≤<=*n*<=≤<=100) — the number of layers of love and hate.,Print Dr.Banner's feeling in one line.,"['1\n', '2\n', '3\n']","['I hate it\n', 'I hate that I love it\n', 'I hate that I love that I hate it\n']",none,OK,"import sys

def inp():
    return int(input())


def inlt():
    return list(map(int, input().split()))


def insr():
    return input().strip()


def out(x):
    sys.stdout.write(str(x) + ""\n"")

def main():
    count = inp()
    ans = """"
    
    feelings = ["" I love"", "" I hate""]          
    for i in range(1, count + 1):
        ans += feelings[i%2]
        if i < count:
            ans += "" that"" 
        
    ans += "" it""
    out(ans)
        
if __name__ == ""__main__"":
    main()
","def check_jacket(_a, _n):
    un_fastened = 0
    if _n == 1:
        if _a[0] == 0:
            return 'NO'
        else:
            return 'YES'
    
    # Count the number of unfastened buttons
    un_fastened = _a.count(0)
    
    # According to the rules, there can be only one unfastened button
    if un_fastened == 1:
        return 'YES'
    else:
        return 'NO'

# Read input values
n = int(input())
a = list(map(int, input().split()))

# Output the result of the check
print(check_jacket(a, n))"
270,A,Fancy Fence,PROGRAMMING,"['geometry', 'implementation', 'math']","Emuskald needs a fence around his farm, but he is too lazy to build it himself. So he purchased a fence-building robot.

He wants the fence to be a regular polygon. The robot builds the fence along a single path, but it can only make fence corners at a single angle *a*.

Will the robot be able to build the fence Emuskald wants? In other words, is there a regular polygon which angles are equal to *a*?",The first line of input contains an integer *t* (0<=&lt;<=*t*<=&lt;<=180) — the number of tests. Each of the following *t* lines contains a single integer *a* (0<=&lt;<=*a*<=&lt;<=180) — the angle the robot can make corners at measured in degrees.,"For each test, output on a single line ""YES"" (without quotes), if the robot can build a fence Emuskald wants, and ""NO"" (without quotes), if it is impossible.",['3\n30\n60\n90\n'],['NO\nYES\nYES\n'],"In the first test case, it is impossible to build the fence, since there is no regular polygon with angle <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/df5f4b07dd5316fde165b43657b2696e2919e791.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>.

In the second test case, the fence is a regular triangle, and in the last test case — a square.",OK,"def fence():
    a = int(input())
    
    n = 360 / (180 - a)
    
    if n == int(n):
        return ""YES""
    
    return ""NO""


t = int(input())

for _ in range(t):
    print(fence())","def solve():
    n = int(input())
    s = input()
    
    # Initialize an empty list to hold the decoded digits
    decoded_digits = []
    
    # Split the string by '0' to separate the encoded digits
    encoded_digits = s.split('0')
    
    for encoded in encoded_digits:
        # The number of '1's corresponds to the digit value
        digit_value = len(encoded)
        decoded_digits.append(str(digit_value))
    
    # Join the decoded digits to form the final number and print it
    decoded_number = ''.join(decoded_digits)
    print(int(decoded_number))"
492,B,Vanya and Lanterns,PROGRAMMING,"['binary search', 'implementation', 'math', 'sortings']","Vanya walks late at night along a straight street of length *l*, lit by *n* lanterns. Consider the coordinate system with the beginning of the street corresponding to the point 0, and its end corresponding to the point *l*. Then the *i*-th lantern is at the point *a**i*. The lantern lights all points of the street that are at the distance of at most *d* from it, where *d* is some positive number, common for all lanterns. 

Vanya wonders: what is the minimum light radius *d* should the lanterns have to light the whole street?","The first line contains two integers *n*, *l* (1<=≤<=*n*<=≤<=1000, 1<=≤<=*l*<=≤<=109) — the number of lanterns and the length of the street respectively. 

The next line contains *n* integers *a**i* (0<=≤<=*a**i*<=≤<=*l*). Multiple lanterns can be located at the same point. The lanterns may be located at the ends of the street.","Print the minimum light radius *d*, needed to light the whole street. The answer will be considered correct if its absolute or relative error doesn't exceed 10<=-<=9.","['7 15\n15 5 3 7 9 14 0\n', '2 5\n2 5\n']","['2.5000000000\n', '2.0000000000\n']","Consider the second sample. At *d* = 2 the first lantern will light the segment [0, 4] of the street, and the second lantern will light segment [3, 5]. Thus, the whole street will be lit.",WRONG_ANSWER,"R=lambda:map(int,input().split())
n,l=R()
ll=sorted(list(R()))
ll.append(l)
lll=[]
for i in range(0,n):
    lll.append(ll[i+1]-ll[i])
print(max(lll)/2)","def input_ints():
    return list(map(int, input().split()))

def main():
    n = int(input())
    
    questions = []
    
    # Check divisibility for each number from 1 to n
    for i in range(1, n + 1):
        questions.append(i)
    
    # Print the length of the questions list and the questions themselves
    print(len(questions), *questions)

if __name__ == ""__main__"":
    main()"
460,A,Vasya and Socks,PROGRAMMING,"['brute force', 'implementation', 'math']","Vasya has *n* pairs of socks. In the morning of each day Vasya has to put on a pair of socks before he goes to school. When he comes home in the evening, Vasya takes off the used socks and throws them away. Every *m*-th day (at days with numbers *m*,<=2*m*,<=3*m*,<=...) mom buys a pair of socks to Vasya. She does it late in the evening, so that Vasya cannot put on a new pair of socks before the next day. How many consecutive days pass until Vasya runs out of socks?","The single line contains two integers *n* and *m* (1<=≤<=*n*<=≤<=100; 2<=≤<=*m*<=≤<=100), separated by a space.",Print a single integer — the answer to the problem.,"['2 2\n', '9 3\n']","['3\n', '13\n']","In the first sample Vasya spends the first two days wearing the socks that he had initially. Then on day three he puts on the socks that were bought on day two.

In the second sample Vasya spends the first nine days wearing the socks that he had initially. Then he spends three days wearing the socks that were bought on the third, sixth and ninth days. Than he spends another day wearing the socks that were bought on the twelfth day.",WRONG_ANSWER,"def solve():
    n,m = list(map(int,input().split()))
    ans = n
    curr = 0
    while n:
        ans += n//m
        n //= m
        curr += n % m
    return ans + curr//m
print(solve())","def is_in_equilibrium(v, n):
    s1 = 0
    s2 = 0
    s3 = 0
    for i in range(n):
        s1 += v[i][0]  # Sum of x components
        s2 += v[i][1]  # Sum of y components
        s3 += v[i][2]  # Sum of z components
    
    # Check if all sums are zero
    if s1 == 0 and s2 == 0 and s3 == 0:
        return ""YES""
    else:
        return ""NO""

# Read input
n = int(input())
forces = [tuple(map(int, input().split())) for _ in range(n)]

# Determine if the body is in equilibrium
result = is_in_equilibrium(forces, n)
print(result)"
349,A,Cinema Line,PROGRAMMING,"['greedy', 'implementation']","The new ""Die Hard"" movie has just been released! There are *n* people at the cinema box office standing in a huge line. Each of them has a single 100, 50 or 25 ruble bill. A ""Die Hard"" ticket costs 25 rubles. Can the booking clerk sell a ticket to each person and give the change if he initially has no money and sells the tickets strictly in the order people follow in the line?","The first line contains integer *n* (1<=≤<=*n*<=≤<=105) — the number of people in the line. The next line contains *n* integers, each of them equals 25, 50 or 100 — the values of the bills the people have. The numbers are given in the order from the beginning of the line (at the box office) to the end of the line.","Print ""YES"" (without the quotes) if the booking clerk can sell a ticket to each person and give the change. Otherwise print ""NO"".","['4\n25 25 50 50\n', '2\n25 100\n', '4\n50 50 25 25\n']","['YES\n', 'NO\n', 'NO\n']",none,WRONG_ANSWER,"from collections import defaultdict
n = int(input()) 
a = [int(i) for i in input().split()] 
d = defaultdict(int) 
d[0] = 1
ans = ""YES""
for i in range(n): 
    if d[a[i] - 25] != 0: ans = ""NO"" ; break 
    d[a[i]-25]-=1
    d[a[i]] += 1
    
print(ans)","def vnutry(x1, y1, x2, y2, x3, y3, x4, y4, x, y):
    v1 = (x2 - x1) * (y - y1) - (y2 - y1) * (x - x1)
    v2 = (x3 - x4) * (y - y4) - (y3 - y4) * (x - x4)
    v3 = (x1 - x4) * (y - y4) - (y1 - y4) * (x - x4)
    v4 = (x2 - x3) * (y - y3) - (y2 - y3) * (x - x3)
    
    if v1 * v2 <= 0 and v3 * v4 <= 0:
        return True  # Line segments intersect

    return False  # Line segments do not intersect

def point_in_square(px, py, x1, y1, x2, y2):
    return min(x1, x2) <= px <= max(x1, x2) and min(y1, y2) <= py <= max(y1, y2)

def squares_intersect(square1, square2):
    # Unpacking square1 coordinates
    x1, y1 = square1[0]
    x2, y2 = square1[1]
    x3, y3 = square1[2]
    x4, y4 = square1[3]

    # Unpacking square2 coordinates
    px1, py1 = square2[0]
    px2, py2 = square2[1]
    px3, py3 = square2[2]
    px4, py4 = square2[3]
    
    # Check if any of the square2's points are inside square1
    if (point_in_square(px1, py1, x1, y1, x3, y3) or 
        point_in_square(px2, py2, x1, y1, x3, y3) or 
        point_in_square(px3, py3, x1, y1, x3, y3) or 
        point_in_square(px4, py4, x1, y1, x3, y3)):
        return True
    
    # Check if any of the square1's points are inside square2
    if (point_in_square(x1, y1, px1, py1, px3, py3) or 
        point_in_square(x2, y2, px1, py1, px3, py3) or 
        point_in_square(x3, y3, px1, py1, px3, py3) or 
        point_in_square(x4, y4, px1, py1, px3, py3)):
        return True

    # Check intersection of the edges
    edges_square1 = [(x1, y1, x2, y2), (x2, y2, x3, y3), (x3, y3, x4, y4), (x4, y4, x1, y1)]
    edges_square2 = [(px1, py1, px2, py2), (px2, py2, px3, py3), (px3, py3, px4, py4), (px4, py4, px1, py1)]
    
    for edge1 in edges_square1:
        for edge2 in edges_square2:
            if vnutry(*edge1, *edge2):
                return True

    return False

# Input reading
square1 = [tuple(map(int, input().split())) for _ in range(1)]
square2 = [tuple(map(int, input().split())) for _ in range(1)]

# Check intersection and print result
if squares_intersect(square1, square2):
    print(""Yes"")
else:
    print(""No"")"
361,B,Levko and Permutation,PROGRAMMING,"['constructive algorithms', 'math', 'number theory']","Levko loves permutations very much. A permutation of length *n* is a sequence of distinct positive integers, each is at most *n*.

Let’s assume that value *gcd*(*a*,<=*b*) shows the greatest common divisor of numbers *a* and *b*. Levko assumes that element *p**i* of permutation *p*1,<=*p*2,<=... ,<=*p**n* is good if *gcd*(*i*,<=*p**i*)<=&gt;<=1. Levko considers a permutation beautiful, if it has exactly *k* good elements. Unfortunately, he doesn’t know any beautiful permutation. Your task is to help him to find at least one of them.","The single line contains two integers *n* and *k* (1<=≤<=*n*<=≤<=105, 0<=≤<=*k*<=≤<=*n*).","In a single line print either any beautiful permutation or -1, if such permutation doesn’t exist.

If there are multiple suitable permutations, you are allowed to print any of them.","['4 2\n', '1 1\n']","['2 4 3 1', '-1\n']","In the first sample elements 4 and 3 are good because *gcd*(2, 4) = 2 &gt; 1 and *gcd*(3, 3) = 3 &gt; 1. Elements 2 and 1 are not good because *gcd*(1, 2) = 1 and *gcd*(4, 1) = 1. As there are exactly 2 good elements, the permutation is beautiful.

The second sample has no beautiful permutations.",OK,"import sys
n,k=map(int,input().split())
a=[]
if(n==k):
    print(""-1"")
    sys.exit()
for i in range(n):
    a.append(i+1)
for j in range(n-k-1):
    a[j],a[j+1]=a[j+1],a[j]
print(*a)","import sys
sys.setrecursionlimit(1000000)

a, b, n = map(int, input().split())

def recursion(a, b, n, i, cur_result):
    if i > n or (a % b != 0 and i != 0):
        return None if i != 0 else -1
    if i == n:
        return cur_result

    # Try to append digits from 0 to 9
    for digit in range(10):
        new_a = a * 10 + digit
        if new_a % b == 0:
            result = recursion(new_a, b, n, i + 1, cur_result * 10 + digit)
            if result is not None:
                return result

    return None

result = recursion(a, b, n, 0, a)
print(result if result is not None else -1)"
1000,B,Light It Up,PROGRAMMING,['greedy'],"Recently, you bought a brand new smart lamp with programming features. At first, you set up a schedule to the lamp. Every day it will turn power on at moment $0$ and turn power off at moment $M$. Moreover, the lamp allows you to set a program of switching its state (states are ""lights on"" and ""lights off""). Unfortunately, some program is already installed into the lamp.

The lamp allows only good programs. Good program can be represented as a non-empty array $a$, where $0 &lt; a_1 &lt; a_2 &lt; \dots &lt; a_{|a|} &lt; M$. All $a_i$ must be integers. Of course, preinstalled program is a good program.

The lamp follows program $a$ in next manner: at moment $0$ turns power and light on. Then at moment $a_i$ the lamp flips its state to opposite (if it was lit, it turns off, and vice versa). The state of the lamp flips instantly: for example, if you turn the light off at moment $1$ and then do nothing, the total time when the lamp is lit will be $1$. Finally, at moment $M$ the lamp is turning its power off regardless of its state.

Since you are not among those people who read instructions, and you don't understand the language it's written in, you realize (after some testing) the only possible way to alter the preinstalled program. You can insert at most one element into the program $a$, so it still should be a good program after alteration. Insertion can be done between any pair of consecutive elements of $a$, or even at the begining or at the end of $a$.

Find such a way to alter the program that the total time when the lamp is lit is maximum possible. Maybe you should leave program untouched. If the lamp is lit from $x$ till moment $y$, then its lit for $y - x$ units of time. Segments of time when the lamp is lit are summed up.","First line contains two space separated integers $n$ and $M$ ($1 \le n \le 10^5$, $2 \le M \le 10^9$) — the length of program $a$ and the moment when power turns off.

Second line contains $n$ space separated integers $a_1, a_2, \dots, a_n$ ($0 &lt; a_1 &lt; a_2 &lt; \dots &lt; a_n &lt; M$) — initially installed program $a$.",Print the only integer — maximum possible total time when the lamp is lit.,"['3 10\n4 6 7\n', '2 12\n1 10\n', '2 7\n3 4\n']","['8\n', '9\n', '6\n']","In the first example, one of possible optimal solutions is to insert value $x = 3$ before $a_1$, so program will be $[3, 4, 6, 7]$ and time of lamp being lit equals $(3 - 0) + (6 - 4) + (10 - 7) = 8$. Other possible solution is to insert $x = 5$ in appropriate place.

In the second example, there is only one optimal solution: to insert $x = 2$ between $a_1$ and $a_2$. Program will become $[1, 2, 10]$, and answer will be $(1 - 0) + (10 - 2) = 9$.

In the third example, optimal answer is to leave program untouched, so answer will be $(3 - 0) + (7 - 4) = 6$.",WRONG_ANSWER,"n, M = map(int,input().split())
a = [0]
for i in list(map(int, input().split())):
    a.append(i)
a.append(M)
c=[0]
for x in range(0,M):
    b=0
    if x not in a:
        a.append(x)
        a=sorted(a)
        for j in range(0,len(a)-1,2):
            b+=a[j+1]-a[j]
        c.append(b)
        a.remove(x)
        a=sorted(a)
print(max(c))","def main():
    n = int(input())
    g = []
    
    # Read guardpost data
    for _ in range(4):
        a, b, c, d = map(int, input().split())
        g.append((a, b, c, d))
    
    # Check each guardpost
    for i in range(4):
        a, b, c, d = g[i]
        
        # Determine the minimum possible prices for guards
        for x in range(a, n):  # x is the price for first guard's chocolate
            y = n - x  # y is the price for second guard's gift
            if y >= c and (y - c + x >= b):  # Check if prices are valid
                print(i + 1, x, y)  # Output guardpost number (1-indexed)
                return
    
            if x >= b and (x - b + y >= d):  # Check for the reverse scenario
                print(i + 1, y, x)  # Output guardpost number (1-indexed)
                return
    
    print(-1)  # No valid guardpost found

main()"
746,A,Compote,PROGRAMMING,"['implementation', 'math']","Nikolay has *a* lemons, *b* apples and *c* pears. He decided to cook a compote. According to the recipe the fruits should be in the ratio 1:<=2:<=4. It means that for each lemon in the compote should be exactly 2 apples and exactly 4 pears. You can't crumble up, break up or cut these fruits into pieces. These fruits — lemons, apples and pears — should be put in the compote as whole fruits.

Your task is to determine the maximum total number of lemons, apples and pears from which Nikolay can cook the compote. It is possible that Nikolay can't use any fruits, in this case print 0.","The first line contains the positive integer *a* (1<=≤<=*a*<=≤<=1000) — the number of lemons Nikolay has. 

The second line contains the positive integer *b* (1<=≤<=*b*<=≤<=1000) — the number of apples Nikolay has. 

The third line contains the positive integer *c* (1<=≤<=*c*<=≤<=1000) — the number of pears Nikolay has.","Print the maximum total number of lemons, apples and pears from which Nikolay can cook the compote.","['2\n5\n7\n', '4\n7\n13\n', '2\n3\n2\n']","['7\n', '21\n', '0\n']","In the first example Nikolay can use 1 lemon, 2 apples and 4 pears, so the answer is 1 + 2 + 4 = 7.

In the second example Nikolay can use 3 lemons, 6 apples and 12 pears, so the answer is 3 + 6 + 12 = 21.

In the third example Nikolay don't have enough pears to cook any compote, so the answer is 0.",OK,"l = int(input())
a = int(input())
p = int(input())

a, p = a//2, p//4
m = min(a,l,p)
print(m*1 + m*2 + m*4)","from sys import stdin as cin
from sys import stdout as cout 

def brafast(bras:list, start, end) -> int:
    lcount = 0
    rcount = 0
    for i in range(start, end):
        if bras[i] == '(':
            lcount += 1
        elif bras[i] == ')':
            if lcount > 0:
                lcount -= 1
                rcount += 1
    return rcount * 2

s = cin.readline().strip()
m = int(cin.readline().strip())
results = []

for _ in range(m):
    l, r = map(int, cin.readline().strip().split())
    # Convert to zero-based index
    results.append(brafast(s, l - 1, r))

cout.write('\n'.join(map(str, results)) + '\n')"
43,A,Football,PROGRAMMING,['strings'],"One day Vasya decided to have a look at the results of Berland 1910 Football Championship’s finals. Unfortunately he didn't find the overall score of the match; however, he got hold of a profound description of the match's process. On the whole there are *n* lines in that description each of which described one goal. Every goal was marked with the name of the team that had scored it. Help Vasya, learn the name of the team that won the finals. It is guaranteed that the match did not end in a tie.",The first line contains an integer *n* (1<=≤<=*n*<=≤<=100) — the number of lines in the description. Then follow *n* lines — for each goal the names of the teams that scored it. The names are non-empty lines consisting of uppercase Latin letters whose lengths do not exceed 10 symbols. It is guaranteed that the match did not end in a tie and the description contains no more than two different teams.,Print the name of the winning team. We remind you that in football the team that scores more goals is considered the winner.,"['1\nABC\n', '5\nA\nABA\nABA\nA\nA\n']","['ABC\n', 'A\n']",none,RUNTIME_ERROR,"n=int(input())
team={}
for _ in range(n):
    s=input()
    if s not in team:
        team[s]=1
    else:
        team[s]+=1
print(sorted(team,lambda x:team[x],reverse=True)[0])
    ","# Miguel Arriaga y Karla Mondragón

mapOfKnownCuts = {}

MIN_INT = float('-inf')
maxDepth = 0

def maxRibbonPieces(n, a, b, c):
    # Check if the result is already known
    if n in mapOfKnownCuts:
        return mapOfKnownCuts[n]
    
    # Base case: if the ribbon length is 0, return 0 pieces
    if n == 0:
        return 0

    # Initialize maximum pieces
    max_pieces = MIN_INT

    # Try each length
    if n >= a:
        max_pieces = max(max_pieces, maxRibbonPieces(n - a, a, b, c) + 1)
    if n >= b:
        max_pieces = max(max_pieces, maxRibbonPieces(n - b, a, b, c) + 1)
    if n >= c:
        max_pieces = max(max_pieces, maxRibbonPieces(n - c, a, b, c) + 1)

    # Store the result in the map of known cuts
    mapOfKnownCuts[n] = max_pieces
    return max_pieces

# Read inputs
n, a, b, c = map(int, input().split())
# Calculate and print the maximum number of pieces
print(maxRibbonPieces(n, a, b, c))"
59,A,Word,PROGRAMMING,"['implementation', 'strings']","Vasya is very upset that many people on the Net mix uppercase and lowercase letters in one word. That's why he decided to invent an extension for his favorite browser that would change the letters' register in every word so that it either only consisted of lowercase letters or, vice versa, only of uppercase ones. At that as little as possible letters should be changed in the word. For example, the word HoUse must be replaced with house, and the word ViP — with VIP. If a word contains an equal number of uppercase and lowercase letters, you should replace all the letters with lowercase ones. For example, maTRIx should be replaced by matrix. Your task is to use the given method on one given word.",The first line contains a word *s* — it consists of uppercase and lowercase Latin letters and possesses the length from 1 to 100.,"Print the corrected word *s*. If the given word *s* has strictly more uppercase letters, make the word written in the uppercase register, otherwise - in the lowercase one.","['HoUse\n', 'ViP\n', 'maTRIx\n']","['house\n', 'VIP\n', 'matrix\n']",none,OK,"n = input()
up_letters = 0
lower_letters = 0
for i in n:
    if i.lower() == i:
        lower_letters += 1
    else:
        up_letters +=1

if up_letters>lower_letters:
    n = n.upper()
else:
    n = n.lower()

print(n)","def fac(cnt, n):
    ans = 1
    for i in range(1, n + 1):
        ans *= (cnt - i + 1)
        ans /= i * 1
    return ans

s1 = str(input())
s2 = str(input())

# Calculate the target position from the commands sent by Drazil
target_position = s1.count('+') - s1.count('-')

# Calculate the recognized position from the received commands
recognized_position = s2.count('+') - s2.count('-')

# Count the number of unrecognized commands
unrecognized_count = s2.count('?')

# Calculate the required position adjustment needed from unrecognized commands
position_needed = target_position - recognized_position

# Check if it's possible to reach the target position
if (position_needed + unrecognized_count) % 2 != 0 or abs(position_needed) > unrecognized_count:
    print(0.0)
else:
    # Number of positive and negative moves needed from unrecognized commands
    positive_moves = (unrecognized_count + position_needed) // 2
    negative_moves = unrecognized_count - positive_moves
    
    # Calculate the total combinations of unrecognized commands
    total_ways = 2 ** unrecognized_count
    
    # Calculate the number of ways to choose positive_moves from unrecognized_count
    valid_ways = fac(unrecognized_count, positive_moves)
    
    # Calculate the probability
    probability = valid_ways / total_ways
    print(probability)"
197,B,Limit,PROGRAMMING,['math'],"You are given two polynomials:
 -  *P*(*x*)<==<=*a*0·*x**n*<=+<=*a*1·*x**n*<=-<=1<=+<=...<=+<=*a**n*<=-<=1·*x*<=+<=*a**n* and -  *Q*(*x*)<==<=*b*0·*x**m*<=+<=*b*1·*x**m*<=-<=1<=+<=...<=+<=*b**m*<=-<=1·*x*<=+<=*b**m*. 
Calculate limit .","The first line contains two space-separated integers *n* and *m* (0<=≤<=*n*,<=*m*<=≤<=100) — degrees of polynomials *P*(*x*) and *Q*(*x*) correspondingly.

The second line contains *n*<=+<=1 space-separated integers — the factors of polynomial *P*(*x*): *a*0, *a*1, ..., *a**n*<=-<=1, *a**n* (<=-<=100<=≤<=*a**i*<=≤<=100,<=*a*0<=≠<=0).

The third line contains *m*<=+<=1 space-separated integers — the factors of polynomial *Q*(*x*): *b*0, *b*1, ..., *b**m*<=-<=1, *b**m* (<=-<=100<=≤<=*b**i*<=≤<=100,<=*b*0<=≠<=0).","If the limit equals <=+<=∞, print ""Infinity"" (without quotes). If the limit equals <=-<=∞, print ""-Infinity"" (without the quotes).

If the value of the limit equals zero, print ""0/1"" (without the quotes).

Otherwise, print an irreducible fraction — the value of limit , in the format ""p/q"" (without the quotes), where *p* is the — numerator, *q* (*q*<=&gt;<=0) is the denominator of the fraction.","['2 1\n1 1 1\n2 5\n', '1 0\n-1 3\n2\n', '0 1\n1\n1 0\n', '2 2\n2 1 6\n4 5 -7\n', '1 1\n9 0\n-5 2\n']","['Infinity\n', '-Infinity\n', '0/1\n', '1/2\n', '-9/5\n']","Let's consider all samples:
 1.  <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/c28febca257452afdfcbd6984ba8623911f9bdbc.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> 1.  <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/1e55ecd04e54a45e5e0092ec9a5c1ea03bb29255.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> 1.  <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/2c95fb684d373fcc1a481cfabeda4d5c2f3673ee.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> 1.  <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/4dc40cb8b3cd6375c42445366e50369649a2801a.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> 1.  <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/c6455aba35cfb3c4397505121d1f77afcd17c98e.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> 
You can learn more about the definition and properties of limits if you follow the link: http://en.wikipedia.org/wiki/Limit_of_a_function",WRONG_ANSWER,"import math
n,m=map(int,input().split())
l=list(map(int,input().split()))
q=list(map(int,input().split()))
if m>n:
	print(""0/1"")
elif n>m:
	if (l[0]>0 and q[0]>0) or (l[0]<0 and q[0]<0):
		print(""Infinite"")
	else:
		print(""-Infinite"")
    

else: 
	a=abs(l[0])
	b=abs(q[0])
	while math.gcd(a,b) >1:
		c=math.gcd(a,b)
		a=a//c
		b=b//c
	if l[0]>0 and q[0]>0:
		print(str(a)+""/""+str(b)) 
	elif l[0]<0 and q[0]<0:
		print(str(a)+""/""+str(b)) 
	else:
		print(""-""+str(a)+""/""+str(b)) 
		
   
		

	
	","# this is from codeforces problem

def min_replacements(ai_name, phone_name):
    n = len(ai_name)
    m = len(phone_name)
    
    # Create a list to keep track of replacements
    replacements = [0] * (n + 1)
    
    # Iterate over all possible starting positions for the phone name in ai name
    for i in range(n - m + 1):
        # Check if the substring matches the phone name
        if ai_name[i:i + m] == phone_name:
            # Count number of characters to replace
            for j in range(m):
                replacements[i + j + 1] += 1
    
    # Calculate the minimum replacements needed
    min_replacements = float('inf')
    current_replacements = 0
    for i in range(1, n + 1):
        current_replacements += replacements[i]
        min_replacements = min(min_replacements, current_replacements)

    return min_replacements

# Input
ai_name = input().strip()
phone_name = input().strip()

# Output the result
print(min_replacements(ai_name, phone_name))"
558,C,Amr and Chemistry,PROGRAMMING,"['brute force', 'graphs', 'greedy', 'math', 'shortest paths']","Amr loves Chemistry, and specially doing experiments. He is preparing for a new interesting experiment.

Amr has *n* different types of chemicals. Each chemical *i* has an initial volume of *a**i* liters. For this experiment, Amr has to mix all the chemicals together, but all the chemicals volumes must be equal first. So his task is to make all the chemicals volumes equal.

To do this, Amr can do two different kind of operations. 
 -  Choose some chemical *i* and double its current volume so the new volume will be 2*a**i* -  Choose some chemical *i* and divide its volume by two (integer division) so the new volume will be  
Suppose that each chemical is contained in a vessel of infinite volume. Now Amr wonders what is the minimum number of operations required to make all the chemicals volumes equal?","The first line contains one number *n* (1<=≤<=*n*<=≤<=105), the number of chemicals.

The second line contains *n* space separated integers *a**i* (1<=≤<=*a**i*<=≤<=105), representing the initial volume of the *i*-th chemical in liters.",Output one integer the minimum number of operations required to make all the chemicals volumes equal.,"['3\n4 8 2\n', '3\n3 5 6\n']","['2', '5']","In the first sample test, the optimal solution is to divide the second chemical volume by two, and multiply the third chemical volume by two to make all the volumes equal 4.

In the second sample test, the optimal solution is to divide the first chemical volume by two, and divide the second and the third chemical volumes by two twice to make all the volumes equal 1.",TIME_LIMIT_EXCEEDED,"L = 100001; n = int(input())
c = [0] * L; d = [0] * L; u = [0] * L; v = [0] * L
for i in list(map(int, input().split())):
    x = i
    t = 0
    if x * 2 <= 100000:
        u[x * 2] += 1
        v[x * 2] += 1
    while x > 0:
        if x % 2:
            u[x - 1] += t + 2
            v[x - 1] += 1
        c[x] += t
        d[x] += 1
        x //= 2
        t += 1
    c[x] += t
    d[x] += 1
for i in range(1, L):
    if v[i] == 0: continue
    x = i
    while x < L:
        c[x] += u[i]
        d[x] += v[i]
        u[i] += v[i]
        x *= 2
print(min(j for i, j in zip(d, c) if i == n))","# Dictionary == Hash Collision

from sys import stdin
from bisect import bisect_left as bl, bisect_right as br
from collections import defaultdict, Counter, deque

def input():
    return stdin.readline().strip()

def hamming_distance(a, b):
    return sum(1 for x, y in zip(a, b) if x != y)

def sum_hamming_distances(a, b):
    len_a = len(a)
    total_distance = 0
    
    for i in range(len(b) - len_a + 1):
        substring_b = b[i:i + len_a]
        total_distance += hamming_distance(a, substring_b)
        
    return total_distance

# Read input
a = input()
b = input()

# Calculate and print the result
print(sum_hamming_distances(a, b))"
478,B,Random Teams,PROGRAMMING,"['combinatorics', 'constructive algorithms', 'greedy', 'math']","*n* participants of the competition were split into *m* teams in some manner so that each team has at least one participant. After the competition each pair of participants from the same team became friends.

Your task is to write a program that will find the minimum and the maximum number of pairs of friends that could have formed by the end of the competition.","The only line of input contains two integers *n* and *m*, separated by a single space (1<=≤<=*m*<=≤<=*n*<=≤<=109) — the number of participants and the number of teams respectively.",The only line of the output should contain two integers *k**min* and *k**max* — the minimum possible number of pairs of friends and the maximum possible number of pairs of friends respectively.,"['5 1\n', '3 2\n', '6 3\n']","['10 10\n', '1 1\n', '3 6\n']","In the first sample all the participants get into one team, so there will be exactly ten pairs of friends.

In the second sample at any possible arrangement one team will always have two participants and the other team will always have one participant. Thus, the number of pairs of friends will always be equal to one.

In the third sample minimum number of newly formed friendships can be achieved if participants were split on teams consisting of 2 people, maximum number can be achieved if participants were split on teams of 1, 1 and 4 people.",OK,"n,m=map(int,input().split())
r=n//m
print(m*r*(r-1)//2+n%m*r,(n-m+1)*(n-m)//2)","#!/usr/bin/python3

import sys

n, l, r, ql, qr = map(int, sys.stdin.readline().strip().split())
w = [int(x) for x in sys.stdin.readline().strip().split()]

# Initialize a 2D dp array with ""inf"" to represent minimum energy spent
dp = [[float('inf')] * (n + 1) for _ in range(2)]

# Base cases: No items taken yet
dp[0][0] = 0  # From the left
dp[1][0] = 0  # From the right

for i in range(n + 1):
    for j in range(2):  # j = 0 (left), j = 1 (right)
        if i > 0:
            # Calculate cost if taking from left
            left_cost = (w[i - 1] * l) + (ql if j == 0 else 0)
            dp[0][i] = min(dp[0][i], dp[1][i - 1] + left_cost)  # Coming from right
            dp[0][i] = min(dp[0][i], dp[0][i - 1] + left_cost)  # Coming from left
            
            # Calculate cost if taking from right
            right_cost = (w[n - i] * r) + (qr if j == 1 else 0)
            dp[1][i] = min(dp[1][i], dp[0][i - 1] + right_cost)  # Coming from left
            dp[1][i] = min(dp[1][i], dp[1][i - 1] + right_cost)  # Coming from right

# The answer will be the minimum energy spent to take all items
result = min(dp[0][n], dp[1][n])
print(result)"
281,A,Word Capitalization,PROGRAMMING,"['implementation', 'strings']","Capitalization is writing a word with its first letter as a capital letter. Your task is to capitalize the given word.

Note, that during capitalization all the letters except the first one remains unchanged.",A single line contains a non-empty word. This word consists of lowercase and uppercase English letters. The length of the word will not exceed 103.,Output the given word after capitalization.,"['ApPLe\n', 'konjac\n']","['ApPLe\n', 'Konjac\n']",none,WRONG_ANSWER,"my_word = input()

if my_word[0].islower():
    my_word = my_word.replace(my_word[0], my_word[0].upper())
    
print(my_word)
	   			 	 	      		 	 	 				  	","# Read input values
n, k = map(int, input().split())

# Perform k subtractions according to Tanya's algorithm
for _ in range(k):
    if n % 10 != 0:
        n -= 1  # Decrease by one if the last digit is non-zero
    else:
        n //= 10  # Divide by 10 if the last digit is zero

# Print the final result
print(n)"
540,A,Combination Lock,PROGRAMMING,['implementation'],"Scrooge McDuck keeps his most treasured savings in a home safe with a combination lock. Each time he wants to put there the treasures that he's earned fair and square, he has to open the lock.

The combination lock is represented by *n* rotating disks with digits from 0 to 9 written on them. Scrooge McDuck has to turn some disks so that the combination of digits on the disks forms a secret combination. In one move, he can rotate one disk one digit forwards or backwards. In particular, in one move he can go from digit 0 to digit 9 and vice versa. What minimum number of actions does he need for that?","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=1000) — the number of disks on the combination lock.

The second line contains a string of *n* digits — the original state of the disks.

The third line contains a string of *n* digits — Scrooge McDuck's combination that opens the lock.",Print a single integer — the minimum number of moves Scrooge McDuck needs to open the lock.,['5\n82195\n64723\n'],['13\n'],"In the sample he needs 13 moves:
 -  1 disk: <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/b8967f65a723782358b93eff9ce69f336817cf70.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> -  2 disk: <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/07fa58573ece0d32c4d555e498d2b24d2f70f36a.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> -  3 disk: <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/cc2275d9252aae35a6867c6a5b4ba7596e9a7626.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> -  4 disk: <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/b100aea470fcaaab4e9529b234ba0d7875943c10.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> -  5 disk: <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/eb2cbe4324cebca65b85816262a85e473cd65967.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>",OK,"def main():
    n = int(input())
    o = [int(c) for c in input()]
    a = [int(c) for c in input()]

    moves = 0
    for i in range(n):
        x, y = (o[i], a[i]) if o[i] > a[i] else (a[i], o[i])
        moves += min(x - y, y + 10 - x)

    print(moves)


if __name__ == ""__main__"":
    main()
","# You've got a 5 × 5 matrix, consisting of 24 zeroes and a single number one. Let's index the matrix rows by numbers from 1 to 5 from top to bottom, let's index the matrix columns by numbers from 1 to 5 from left to right. In one move, you are allowed to apply one of the two following transformations to the matrix:

#     Swap two neighboring matrix rows, that is, rows with indexes i and i + 1 for some integer i (1 ≤ i < 5).
#     Swap two neighboring matrix columns, that is, columns with indexes j and j + 1 for some integer j (1 ≤ j < 5).

# You think that a matrix looks beautiful, if the single number one of the matrix is located in its middle (in the cell that is on the intersection of the third row and the third column). Count the minimum number of moves needed to make the matrix beautiful.

# Read the matrix
matrix = [list(map(int, input().split())) for _ in range(5)]

# Find the position of '1'
position_one = [(i, row.index(1)) for i, row in enumerate(matrix) if 1 in row][0]

# Calculate the number of moves needed to get '1' to (2, 2)
moves = abs(position_one[0] - 2) + abs(position_one[1] - 2)

# Print the result
print(moves)"
68,A,Irrational problem,PROGRAMMING,"['implementation', 'number theory']","Little Petya was given this problem for homework:

You are given function  (here  represents the operation of taking the remainder). His task is to count the number of integers *x* in range [*a*;*b*] with property *f*(*x*)<==<=*x*.

It is a pity that Petya forgot the order in which the remainders should be taken and wrote down only 4 numbers. Each of 24 possible orders of taking the remainder has equal probability of being chosen. For example, if Petya has numbers 1, 2, 3, 4 then he can take remainders in that order or first take remainder modulo 4, then modulo 2, 3, 1. There also are 22 other permutations of these numbers that represent orders in which remainder can be taken. In this problem 4 numbers wrote down by Petya will be pairwise distinct.

Now it is impossible for Petya to complete the task given by teacher but just for fun he decided to find the number of integers  with property that probability that *f*(*x*)<==<=*x* is not less than 31.4159265352718281828459045%. In other words, Petya will pick up the number *x* if there exist at least 7 permutations of numbers *p*1,<=*p*2,<=*p*3,<=*p*4, for which *f*(*x*)<==<=*x*.","First line of the input will contain 6 integers, separated by spaces: *p*1,<=*p*2,<=*p*3,<=*p*4,<=*a*,<=*b* (1<=≤<=*p*1,<=*p*2,<=*p*3,<=*p*4<=≤<=1000,<=0<=≤<=*a*<=≤<=*b*<=≤<=31415). 

It is guaranteed that numbers *p*1,<=*p*2,<=*p*3,<=*p*4 will be pairwise distinct.",Output the number of integers in the given range that have the given property.,"['2 7 1 8 2 8\n', '20 30 40 50 0 100\n', '31 41 59 26 17 43\n']","['0\n', '20\n', '9\n']",none,OK,"import sys,math,string,bisect
input=sys.stdin.readline
from collections import deque
L=lambda : list(map(int,input().split()))
Ls=lambda : list(input().split())
M=lambda : map(int,input().split())
I=lambda :int(input())
p1,p2,p3,p4,b,a=M()
k=min(p1,p2,p3,p4)
c=0
for i in range(b,min(k,a+1)):
    c+=1
print(c)
","fin = open ('input.txt', 'r')
fout = open ('output.txt', 'w')
raw_lines = fin.readlines()
n = int(raw_lines[0].strip())
arr = list(map(int, raw_lines[1].strip().split()))

def how_many(arr, l, r):
    i = l + 1
    left_del = 0
    # Count elements to remove from the left
    while i < r and arr[i] <= 2 * arr[l]:
        i += 1
    # Elements to remove from the left side
    left_del = i - l - 1
    # Total elements to remove from both sides
    return left_del + (r - i)

# Initialize minimum removals as the total measurements
min_removals = n
# Use two pointers to find segments fulfilling the condition
for l in range(n):
    # Find the right index fulfilling the condition
    r = l
    while r < n and arr[r] <= 2 * arr[l]:
        r += 1
    # Calculate the number of removals
    min_removals = min(min_removals, how_many(arr, l, r))

# Write the result to the output file
fout.write(f""{min_removals}\n"")
fin.close()
fout.close()"
109,A,Lucky Sum of Digits,PROGRAMMING,"['brute force', 'implementation']","Petya loves lucky numbers. We all know that lucky numbers are the positive integers whose decimal representations contain only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.

Petya wonders eagerly what minimum lucky number has the sum of digits equal to *n*. Help him cope with the task.",The single line contains an integer *n* (1<=≤<=*n*<=≤<=106) — the sum of digits of the required lucky number.,"Print on the single line the result — the minimum lucky number, whose sum of digits equals *n*. If such number does not exist, print -1.","['11\n', '10\n']","['47\n', '-1\n']",none,COMPILATION_ERROR,"n = input()
result = """"
while (n%7!=0 and n>0):
	result+='4'
	n-=4
flg = 0
if (n<0 or n%7!=0):
	flg = 1
if(flg!=1):
	while n>0:
		result+='7'
		n-=7
	print result
else :
	print -1","import sys 
input = sys.stdin.buffer.readline 

class SegmentTree:
    def __init__(self, data, default=0, func=lambda a, b: a+b):
        """"""initialize the segment tree with data""""""
        self._default = default
        self._func = func
        self._len = len(data)
        self._size = self._len * 2
        self._tree = [default] * self._size
        
        # Build the segment tree
        self._build(data)

    def _build(self, data):
        # Insert leaf nodes in the tree
        for i in range(self._len):
            self._tree[i + self._len] = data[i]
        # Build the tree by calculating parents
        for i in range(self._len - 1, 0, -1):
            self._tree[i] = self._func(self._tree[i * 2], self._tree[i * 2 + 1])

    def update(self, index, value):
        # Update the value at index
        index += self._len
        self._tree[index] = value
        
        # Recalculate the path to the root
        while index > 1:
            index //= 2
            self._tree[index] = self._func(self._tree[index * 2], self._tree[index * 2 + 1])

    def query(self, left, right):
        # Query in the range [left, right)
        result = self._default
        left += self._len
        right += self._len
        
        while left < right:
            if left % 2:
                result = self._func(result, self._tree[left])
                left += 1
            if right % 2:
                right -= 1
                result = self._func(result, self._tree[right])
            left //= 2
            right //= 2
        
        return result

def main():
    n, k, a, b, q = map(int, input().split())
    orders = [0] * (n + 1)
    
    for _ in range(q):
        query = list(map(int, input().split()))
        if query[0] == 1:
            d, a_i = query[1], query[2]
            orders[d] += a_i
        elif query[0] == 2:
            p_i = query[1]
            total_orders = 0
            
            # Calculate total orders filled if repairs start on day p_i
            for day in range(1, n + 1):
                if day >= p_i and day < p_i + k:
                    continue  # Repair days
                if day >= p_i + k:
                    total_orders += min(a, orders[day])
                else:
                    total_orders += min(b, orders[day])
            
            print(total_orders)

if __name__ == ""__main__"":
    main()"
581,C,Developing Skills,PROGRAMMING,"['implementation', 'math', 'sortings']","Petya loves computer games. Finally a game that he's been waiting for so long came out!

The main character of this game has *n* different skills, each of which is characterized by an integer *a**i* from 0 to 100. The higher the number *a**i* is, the higher is the *i*-th skill of the character. The total rating of the character is calculated as the sum of the values ​​of  for all *i* from 1 to *n*. The expression ⌊ *x*⌋ denotes the result of rounding the number *x* down to the nearest integer.

At the beginning of the game Petya got *k* improvement units as a bonus that he can use to increase the skills of his character and his total rating. One improvement unit can increase any skill of Petya's character by exactly one. For example, if *a*4<==<=46, after using one imporvement unit to this skill, it becomes equal to 47. A hero's skill cannot rise higher more than 100. Thus, it is permissible that some of the units will remain unused.

Your task is to determine the optimal way of using the improvement units so as to maximize the overall rating of the character. It is not necessary to use all the improvement units.","The first line of the input contains two positive integers *n* and *k* (1<=≤<=*n*<=≤<=105, 0<=≤<=*k*<=≤<=107) — the number of skills of the character and the number of units of improvements at Petya's disposal.

The second line of the input contains a sequence of *n* integers *a**i* (0<=≤<=*a**i*<=≤<=100), where *a**i* characterizes the level of the *i*-th skill of the character.",The first line of the output should contain a single non-negative integer — the maximum total rating of the character that Petya can get using *k* or less improvement units.,"['2 4\n7 9\n', '3 8\n17 15 19\n', '2 2\n99 100\n']","['2\n', '5\n', '20\n']","In the first test case the optimal strategy is as follows. Petya has to improve the first skill to 10 by spending 3 improvement units, and the second skill to 10, by spending one improvement unit. Thus, Petya spends all his improvement units and the total rating of the character becomes equal to  *lfloor* *frac*{100}{10} *rfloor* +  *lfloor* *frac*{100}{10} *rfloor* = 10 + 10 =  20.

In the second test the optimal strategy for Petya is to improve the first skill to 20 (by spending 3 improvement units) and to improve the third skill to 20 (in this case by spending 1 improvement units). Thus, Petya is left with 4 improvement units and he will be able to increase the second skill to 19 (which does not change the overall rating, so Petya does not necessarily have to do it). Therefore, the highest possible total rating in this example is <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/ccaa4e1e435ea3a339c322e03a32de69d214a257.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>.

In the third test case the optimal strategy for Petya is to increase the first skill to 100 by spending 1 improvement unit. Thereafter, both skills of the character will be equal to 100, so Petya will not be able to spend the remaining improvement unit. So the answer is equal to <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/b246630ca7d1b95b91970759bd8455cb3e930bf9.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>.",WRONG_ANSWER,"from os import path
from sys import stdin, stdout


filename = ""../templates/input.txt""
if path.exists(filename):
    stdin = open(filename, 'r')


def input():
    return stdin.readline().rstrip()


def print(*args, sep=' ', end='\n'):
    stdout.write(sep.join(map(str, args)))
    stdout.write(end)


def solution():
    n, k = [int(num) for num in input().split()]
    a = [int(num) for num in input().split()]
    a.sort(key=lambda x: 10 - x % 10)
    i = 0
    while i < n and k:
        x = min(k, 10 - a[i] % 10)
        a[i] += x
        k -= x
        i += 1
    ans = 0
    for ai in a:
        ans += ai // 10
    if k:
        y = sum(100 - ai for ai in a)
        ans += min(y // 10, k // 10)
    print(ans)


def main():
    t = 1
    while t:
        solution()
        t -= 1


if __name__ == '__main__':
    main()
","def gcd(a, b):
    return a if b == 0 else gcd(b, a % b)

n = int(input())
data = list(map(int, input().split()))

# Sort the points to ensure the distances are calculated accurately
data.sort()

# Calculate the distances between neighboring points
distances = [data[i+1] - data[i] for i in range(n - 1)]

# Find the greatest common divisor (GCD) of the distances
g = distances[0]
for d in distances[1:]:
    g = gcd(g, d)

# Determine the total number of segments that can be formed with GCD
total_segments = (data[-1] - data[0]) // g

# The number of points to add is one less than the number of segments
m = total_segments - (n - 1)

print(m)"
914,B,Conan and Agasa play a Card Game,PROGRAMMING,"['games', 'greedy', 'implementation']","Edogawa Conan got tired of solving cases, and invited his friend, Professor Agasa, over. They decided to play a game of cards. Conan has *n* cards, and the *i*-th card has a number *a**i* written on it.

They take turns playing, starting with Conan. In each turn, the player chooses a card and removes it. Also, he removes all cards having a number strictly lesser than the number on the chosen card. Formally, if the player chooses the *i*-th card, he removes that card and removes the *j*-th card for all *j* such that *a**j*<=&lt;<=*a**i*.

A player loses if he cannot make a move on his turn, that is, he loses if there are no cards left. Predict the outcome of the game, assuming both players play optimally.","The first line contains an integer *n* (1<=≤<=*n*<=≤<=105) — the number of cards Conan has. 

The next line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=105), where *a**i* is the number on the *i*-th card.","If Conan wins, print ""Conan"" (without quotes), otherwise print ""Agasa"" (without quotes).","['3\n4 5 7\n', '2\n1 1\n']","['Conan\n', 'Agasa\n']","In the first example, Conan can just choose the card having number 7 on it and hence remove all the cards. After that, there are no cards left on Agasa's turn.

In the second example, no matter which card Conan chooses, there will be one one card left, which Agasa can choose. After that, there are no cards left when it becomes Conan's turn again.",WRONG_ANSWER,"n=int(input())
l=[int(i) for i in input().split()]
m=max(l)
cnt=l.count(m)
if cnt&1:
    print('Conan')
else:
    print('Agasa')","maxn = 710
to = [[] for i in range(maxn)]
dp = [[0 for i in range(maxn)] for i in range(maxn)]
n = int(input())
tmp = [0 for i in range(maxn)]

def dfs(now, f):
    # Initialize the size of the current subtree
    size = 1
    # Iterate through all adjacent nodes
    for nxt in to[now]:
        if nxt == f: 
            continue
        # Recursively call dfs for the adjacent node
        subtree_size = dfs(nxt, now)
        # Update the maximum product
        dp[now][subtree_size] = max(dp[now][subtree_size], subtree_size * (n - subtree_size))
        size += subtree_size
    return size

# Read the edges from input and construct the tree
for _ in range(n - 1):
    a, b = map(int, input().split())
    to[a].append(b)
    to[b].append(a)

# Perform DFS starting from the first node
dfs(1, -1)

# Calculate the maximum product from dp array
result = max(max(dp[i]) for i in range(1, n + 1))
print(result)"
740,A,Alyona and copybooks,PROGRAMMING,"['brute force', 'implementation']","Little girl Alyona is in a shop to buy some copybooks for school. She study four subjects so she wants to have equal number of copybooks for each of the subjects. There are three types of copybook's packs in the shop: it is possible to buy one copybook for *a* rubles, a pack of two copybooks for *b* rubles, and a pack of three copybooks for *c* rubles. Alyona already has *n* copybooks.

What is the minimum amount of rubles she should pay to buy such number of copybooks *k* that *n*<=+<=*k* is divisible by 4? There are infinitely many packs of any type in the shop. Alyona can buy packs of different type in the same purchase.","The only line contains 4 integers *n*, *a*, *b*, *c* (1<=≤<=*n*,<=*a*,<=*b*,<=*c*<=≤<=109).",Print the minimum amount of rubles she should pay to buy such number of copybooks *k* that *n*<=+<=*k* is divisible by 4.,"['1 1 3 4\n', '6 2 1 1\n', '4 4 4 4\n', '999999999 1000000000 1000000000 1000000000\n']","['3\n', '1\n', '0\n', '1000000000\n']","In the first example Alyona can buy 3 packs of 1 copybook for 3*a* = 3 rubles in total. After that she will have 4 copybooks which she can split between the subjects equally. 

In the second example Alyuna can buy a pack of 2 copybooks for *b* = 1 ruble. She will have 8 copybooks in total.

In the third example Alyona can split the copybooks she already has between the 4 subject equally, so she doesn't need to buy anything.

In the fourth example Alyona should buy one pack of one copybook.",WRONG_ANSWER,"n, a, b, c = [int(x) for x in input().split()]

hastobuy = n % 4

if hastobuy == 0:
	print(0)
elif hastobuy == 1:
	print(a)
elif hastobuy == 2:
	print(min(2*a, b))
elif hastobuy == 3:
	print(min(3*a, 2*a + b))


","import sys

def input():    return sys.stdin.readline().strip()
def iinput():   return int(input())
def rinput():   return map(int, sys.stdin.readline().strip().split()) 
def get_list(): return list(map(int, sys.stdin.readline().strip().split())) 

# Read the number of disks
n = iinput()

# Read the original state of the disks
original_state = input()

# Read the target combination
target_combination = input()

# Initialize the total moves counter
total_moves = 0

# Calculate the minimum moves required for each disk
for i in range(n):
    original_digit = int(original_state[i])
    target_digit = int(target_combination[i])
    
    # Calculate difference in both directions (forwards and backwards)
    forward_moves = (target_digit - original_digit) % 10
    backward_moves = (original_digit - target_digit) % 10
    
    # Add the minimum of the two possible moves
    total_moves += min(forward_moves, backward_moves)

# Print the total number of moves
print(total_moves)"
151,A,Soft Drinking,PROGRAMMING,"['implementation', 'math']","This winter is so cold in Nvodsk! A group of *n* friends decided to buy *k* bottles of a soft drink called ""Take-It-Light"" to warm up a bit. Each bottle has *l* milliliters of the drink. Also they bought *c* limes and cut each of them into *d* slices. After that they found *p* grams of salt.

To make a toast, each friend needs *nl* milliliters of the drink, a slice of lime and *np* grams of salt. The friends want to make as many toasts as they can, provided they all drink the same amount. How many toasts can each friend make?","The first and only line contains positive integers *n*, *k*, *l*, *c*, *d*, *p*, *nl*, *np*, not exceeding 1000 and no less than 1. The numbers are separated by exactly one space.",Print a single integer — the number of toasts each friend can make.,"['3 4 5 10 8 100 3 1\n', '5 100 10 1 19 90 4 3\n', '10 1000 1000 25 23 1 50 1\n']","['2\n', '3\n', '0\n']","A comment to the first sample: 

Overall the friends have 4 * 5 = 20 milliliters of the drink, it is enough to make 20 / 3 = 6 toasts. The limes are enough for 10 * 8 = 80 toasts and the salt is enough for 100 / 1 = 100 toasts. However, there are 3 friends in the group, so the answer is *min*(6, 80, 100) / 3 = 2.",OK,"n, k, l, c, d, p, nl, np = map(int, input().split())
res = min(((k*l)//nl), (c*d), (p//np))//n
print(int(res))","def solve(n, m):
    color = ['C', 'M', 'Y']  # List of colored pixels
    for i in range(n):
        pixels = input().split()  # Read the row of pixels
        for pixel in pixels:
            if pixel in color:  # Check if any pixel is colored
                print(""#Color"")  # If colored pixel found, print #Color
                return  # Exit the function
    print(""#Black&White"")  # If no colored pixels found, print #Black&White"
166,A,Rank List,PROGRAMMING,"['binary search', 'implementation', 'sortings']","Another programming contest is over. You got hold of the contest's final results table. The table has the following data. For each team we are shown two numbers: the number of problems and the total penalty time. However, for no team we are shown its final place.

You know the rules of comparing the results of two given teams very well. Let's say that team *a* solved *p**a* problems with total penalty time *t**a* and team *b* solved *p**b* problems with total penalty time *t**b*. Team *a* gets a higher place than team *b* in the end, if it either solved more problems on the contest, or solved the same number of problems but in less total time. In other words, team *a* gets a higher place than team *b* in the final results' table if either *p**a*<=&gt;<=*p**b*, or *p**a*<==<=*p**b* and *t**a*<=&lt;<=*t**b*. 

It is considered that the teams that solve the same number of problems with the same penalty time share all corresponding places. More formally, let's say there is a group of *x* teams that solved the same number of problems with the same penalty time. Let's also say that *y* teams performed better than the teams from this group. In this case all teams from the group share places *y*<=+<=1, *y*<=+<=2, ..., *y*<=+<=*x*. The teams that performed worse than the teams from this group, get their places in the results table starting from the *y*<=+<=*x*<=+<=1-th place.

Your task is to count what number of teams from the given list shared the *k*-th place.","The first line contains two integers *n* and *k* (1<=≤<=*k*<=≤<=*n*<=≤<=50). Then *n* lines contain the description of the teams: the *i*-th line contains two integers *p**i* and *t**i* (1<=≤<=*p**i*,<=*t**i*<=≤<=50) — the number of solved problems and the total penalty time of the *i*-th team, correspondingly. All numbers in the lines are separated by spaces.",In the only line print the sought number of teams that got the *k*-th place in the final results' table.,"['7 2\n4 10\n4 10\n4 10\n3 20\n2 1\n2 1\n1 10\n', '5 4\n3 1\n3 1\n5 3\n3 1\n3 1\n']","['3\n', '4\n']","The final results' table for the first sample is: 
 -  1-3 places — 4 solved problems, the penalty time equals 10 -  4 place — 3 solved problems, the penalty time equals 20 -  5-6 places — 2 solved problems, the penalty time equals 1 -  7 place — 1 solved problem, the penalty time equals 10 
The table shows that the second place is shared by the teams that solved 4 problems with penalty time 10. There are 3 such teams.

The final table for the second sample is:
 -  1 place — 5 solved problems, the penalty time equals 3 -  2-5 places — 3 solved problems, the penalty time equals 1 
The table shows that the fourth place is shared by the teams that solved 3 problems with penalty time 1. There are 4 such teams.",OK,"a=input().split()
n=int(a[0])
k=int(a[1])
m=[]


for i in range(n):
    c=input().split()
    m.append([int(c[0]), 50-int(c[1])])

    
m.sort()
m.reverse()
src=m[k-1]
count=0
for i in range(n):
    if m[i]==src:
        count+=1
print(count)            
","from sys import stdin

# Read input values
h1, a1, c1 = map(int, stdin.readline().split())
h2, a2 = map(int, stdin.readline().split())

# Initialize a list to store the actions
actions = []

# While Modcrab's health is greater than 0
while h2 > 0:
    # If Vova can defeat Modcrab in the next strike
    if h2 <= a1:
        actions.append(""STRIKE"")
        h2 -= a1  # Vova attacks
        break
    
    # Check if Vova's health is insufficient to withstand the next attack
    if h1 <= a2:
        actions.append(""HEAL"")
        h1 += c1  # Vova heals
    else:
        actions.append(""STRIKE"")
        h2 -= a1  # Vova attacks
    
    # If Modcrab's health is still greater than 0, it attacks Vova
    if h2 > 0:
        h1 -= a2  # Modcrab attacks Vova

# Output the number of actions and the actions themselves
print(len(actions))
print('\n'.join(actions))"
546,A,Soldier and Bananas,PROGRAMMING,"['brute force', 'implementation', 'math']","A soldier wants to buy *w* bananas in the shop. He has to pay *k* dollars for the first banana, 2*k* dollars for the second one and so on (in other words, he has to pay *i*·*k* dollars for the *i*-th banana). 

He has *n* dollars. How many dollars does he have to borrow from his friend soldier to buy *w* bananas?","The first line contains three positive integers *k*,<=*n*,<=*w* (1<=<=≤<=<=*k*,<=*w*<=<=≤<=<=1000, 0<=≤<=*n*<=≤<=109), the cost of the first banana, initial number of dollars the soldier has and number of bananas he wants.","Output one integer — the amount of dollars that the soldier must borrow from his friend. If he doesn't have to borrow money, output 0.",['3 17 4\n'],['13'],none,WRONG_ANSWER,"a,b,c=map(int,input().split())
k=0
for i in range(c+1):
    k=k+i*a
print(k-b)    
","import math

def isprime(k):
    if k < 2:
        return False
    for i in range(2, int(math.sqrt(k) + 1)):
        if k % i == 0:
            return False
    return True

def neighboring_primes(n):
    primes = [i for i in range(2, n + 1) if isprime(i)]
    return primes

def noldbach_problem(n, k):
    primes = neighboring_primes(n)
    count = 0

    for i in range(1, len(primes)):
        # Calculate the sum of neighboring primes plus 1
        candidate = primes[i - 1] + primes[i] + 1
        # Check if the candidate is prime and less than or equal to n
        if candidate <= n and isprime(candidate):
            count += 1

    # Check if the count of valid numbers is at least k
    return ""YES"" if count >= k else ""NO""

# Example usage
n, k = map(int, input().split())
print(noldbach_problem(n, k))"
939,A,Love Triangle,PROGRAMMING,['graphs'],"As you could know there are no male planes nor female planes. However, each plane on Earth likes some other plane. There are *n* planes on Earth, numbered from 1 to *n*, and the plane with number *i* likes the plane with number *f**i*, where 1<=≤<=*f**i*<=≤<=*n* and *f**i*<=≠<=*i*.

We call a love triangle a situation in which plane *A* likes plane *B*, plane *B* likes plane *C* and plane *C* likes plane *A*. Find out if there is any love triangle on Earth.","The first line contains a single integer *n* (2<=≤<=*n*<=≤<=5000) — the number of planes.

The second line contains *n* integers *f*1,<=*f*2,<=...,<=*f**n* (1<=≤<=*f**i*<=≤<=*n*, *f**i*<=≠<=*i*), meaning that the *i*-th plane likes the *f**i*-th.","Output «YES» if there is a love triangle consisting of planes on Earth. Otherwise, output «NO».

You can output any letter in lower case or in upper case.","['5\n2 4 5 1 3\n', '5\n5 5 5 5 1\n']","['YES\n', 'NO\n']","In first example plane 2 likes plane 4, plane 4 likes plane 1, plane 1 likes plane 2 and that is a love triangle.

In second example there are no love triangles.",OK,"from sys import stdin

def decide(dct):
    for i in dct.keys():
        if dct[dct[dct[i]]] == i:
            return 'YES'
    return 'NO'


def main():
    planes = int(stdin.readline().strip())
    edges = stdin.readline().strip().split()
    dct = {}
    for i in range(1, planes+1):
        dct[i] = int(edges[i-1])
    result = decide(dct)
    print(result)
main()","def main():
    n, b = map(int, input().split())
    arr = list(map(int, input().split()))

    even_counter, odd_counter = 0, 0
    temp_list = []
    
    # Loop through the array to count evens and odds and find potential cuts
    for i in range(n - 1):
        # Update counters
        if arr[i] % 2 == 0:
            even_counter += 1
        else:
            odd_counter += 1
        
        # Check if the current segment has equal evens and odds
        if even_counter == odd_counter:
            cut_cost = abs(arr[i] - arr[i + 1])  # Cost of cutting between arr[i] and arr[i+1]
            temp_list.append(cut_cost)  # Store the cost of this potential cut
    
    # Now we have all cut costs; let's try to maximize the number of cuts within the budget
    temp_list.sort()  # Sort the costs in ascending order
    cuts_made = 0
    
    for cost in temp_list:
        if b >= cost:  # If there's enough budget for this cut
            b -= cost  # Deduct the cost from the budget
            cuts_made += 1  # Increment the number of cuts made
        else:
            break  # Stop if the budget is insufficient for further cuts
    
    print(cuts_made)  # Output the maximum number of cuts

# Call the main function
main()"
611,B,New Year and Old Property,PROGRAMMING,"['bitmasks', 'brute force', 'implementation']","The year 2015 is almost over.

Limak is a little polar bear. He has recently learnt about the binary system. He noticed that the passing year has exactly one zero in its representation in the binary system — 201510<==<=111110111112. Note that he doesn't care about the number of zeros in the decimal representation.

Limak chose some interval of years. He is going to count all years from this interval that have exactly one zero in the binary representation. Can you do it faster?

Assume that all positive integers are always written without leading zeros.",The only line of the input contains two integers *a* and *b* (1<=≤<=*a*<=≤<=*b*<=≤<=1018) — the first year and the last year in Limak's interval respectively.,Print one integer – the number of years Limak will count in his chosen interval.,"['5 10\n', '2015 2015\n', '100 105\n', '72057594000000000 72057595000000000\n']","['2\n', '1\n', '0\n', '26\n']","In the first sample Limak's interval contains numbers 5<sub class=""lower-index"">10</sub> = 101<sub class=""lower-index"">2</sub>, 6<sub class=""lower-index"">10</sub> = 110<sub class=""lower-index"">2</sub>, 7<sub class=""lower-index"">10</sub> = 111<sub class=""lower-index"">2</sub>, 8<sub class=""lower-index"">10</sub> = 1000<sub class=""lower-index"">2</sub>, 9<sub class=""lower-index"">10</sub> = 1001<sub class=""lower-index"">2</sub> and 10<sub class=""lower-index"">10</sub> = 1010<sub class=""lower-index"">2</sub>. Two of them (101<sub class=""lower-index"">2</sub> and 110<sub class=""lower-index"">2</sub>) have the described property.",OK,"l, r = map(int, input().split())
b = ['1']  
ans = 0 
c = 1 
while(c <= 60):
    for i in range(len(b) - 1, 0, -1):
        b[i] = '0'
        a = int(''.join(b), 2)
        if(a >= l and a <= r):
            ans += 1 
        b[i] = '1' 
    b.append('1')
    c += 1 
    
print(ans)
","states = input()

from_A = {
    'a': 0, 
    'b': 1,
    'z': 1,
    'y': 2,
    'c': 2,
    'd': 3,
    'e': 4,
    'f': 5,
    'g': 6,
    'h': 7,
    'i': 8,
    'j': 9,
    'k': 10,
    'l': 11,
    'm': 12,
    'n': 13,
    'o': 14,
    'p': 15,
    'q': 16,
    'r': 17,
    's': 18,
    't': 19,
    'u': 20,
    'v': 21,
    'w': 22,
    'x': 23  ,
    'y': 24,
}

# Initialize total rotations and current position
total_rotations = 0
current_char = 'a'

for char in states:
    # Calculate clockwise and counter-clockwise distances
    clockwise_distance = (from_A[char] - from_A[current_char]) % 26
    counter_clockwise_distance = (from_A[current_char] - from_A[char]) % 26
    # Choose the minimum distance
    total_rotations += min(clockwise_distance, counter_clockwise_distance)
    # Update the current character
    current_char = char

# Print the total number of rotations
print(total_rotations)"
0,none,none,none,['none'],"In a small but very proud high school it was decided to win ACM ICPC. This goal requires to compose as many teams of three as possible, but since there were only 6 students who wished to participate, the decision was to build exactly two teams.

After practice competition, participant number *i* got a score of *a**i*. Team score is defined as sum of scores of its participants. High school management is interested if it's possible to build two teams with equal scores. Your task is to answer that question.","The single line contains six integers *a*1,<=...,<=*a*6 (0<=≤<=*a**i*<=≤<=1000) — scores of the participants","Print ""YES"" (quotes for clarity), if it is possible to build teams with equal score, and ""NO"" otherwise.

You can print each character either upper- or lowercase (""YeS"" and ""yes"" are valid when the answer is ""YES"").","['1 3 2 1 2 1\n', '1 1 1 1 1 99\n']","['YES\n', 'NO\n']","In the first sample, first team can be composed of 1st, 2nd and 6th participant, second — of 3rd, 4th and 5th: team scores are 1 + 3 + 1 = 2 + 1 + 2 = 5.

In the second sample, score of participant number 6 is too high: his team score will be definitely greater.",WRONG_ANSWER,"num1,num2,num3,num4,num5,num6=input().split()
num1=int(num1)
num2=int(num2)
num3=int(num3)
num4=int(num4)
num5=int(num5)
num6=int(num6)

if (num1+num2+num3 == num4+num5+num6):
    print(""YES"")
elif (num2+num3+num4 == num1+num5+num6):
    print(""YES"")
elif (num3+num4+num5 == num1+num2+num6):
    print(""YES"")
elif (num1+num4+num5 == num2+num3+num6):
    print(""YES"")
elif (num2+num4+num6 == num1+num3+num5):
    print(""YES"")
elif (num1+num4+num6 == num2+num3+num5):
    print(""YES"")
elif (num2+num5+num6 == num1+num3+num4):
    print(""YES"")
elif (num3+num4+num6 == num1+num2+num5):
    print(""YES"")

else:
    print(""NO"")","def C(n, k):
    if k > n:
        return 0
    if k == 0:
        return 1
    # Calculate n! / (k! * (n-k)!)
    numerator = 1
    for i in range(n, n - k, -1):
        numerator *= i
    denominator = 1
    for i in range(1, k + 1):
        denominator *= i
    return numerator // denominator

def max_beauty_difference(flowers):
    max_beauty = max(flowers)
    min_beauty = min(flowers)
    max_difference = max_beauty - min_beauty
    
    if max_difference == 0:
        # All flowers have the same beauty
        number_of_ways = C(len(flowers), 2)
    else:
        count_max = flowers.count(max_beauty)
        count_min = flowers.count(min_beauty)
        number_of_ways = count_max * count_min
        
    return max_difference, number_of_ways

# Input reading
n = int(input())
flowers = list(map(int, input().split()))

# Calculate the result
result = max_beauty_difference(flowers)

# Output the result
print(result[0], result[1])"
493,B,Vasya and Wrestling,PROGRAMMING,['implementation'],"Vasya has become interested in wrestling. In wrestling wrestlers use techniques for which they are awarded points by judges. The wrestler who gets the most points wins.

When the numbers of points of both wrestlers are equal, the wrestler whose sequence of points is lexicographically greater, wins.

If the sequences of the awarded points coincide, the wrestler who performed the last technique wins. Your task is to determine which wrestler won.","The first line contains number *n* — the number of techniques that the wrestlers have used (1<=≤<=*n*<=≤<=2·105). 

The following *n* lines contain integer numbers *a**i* (|*a**i*|<=≤<=109, *a**i*<=≠<=0). If *a**i* is positive, that means that the first wrestler performed the technique that was awarded with *a**i* points. And if *a**i* is negative, that means that the second wrestler performed the technique that was awarded with (<=-<=*a**i*) points.

The techniques are given in chronological order.","If the first wrestler wins, print string ""first"", otherwise print ""second""","['5\n1\n2\n-3\n-4\n3\n', '3\n-1\n-2\n3\n', '2\n4\n-4\n']","['second\n', 'first\n', 'second\n']","Sequence *x*  =  *x*<sub class=""lower-index"">1</sub>*x*<sub class=""lower-index"">2</sub>... *x*<sub class=""lower-index"">|*x*|</sub> is lexicographically larger than sequence *y*  =  *y*<sub class=""lower-index"">1</sub>*y*<sub class=""lower-index"">2</sub>... *y*<sub class=""lower-index"">|*y*|</sub>, if either |*x*|  &gt;  |*y*| and *x*<sub class=""lower-index"">1</sub>  =  *y*<sub class=""lower-index"">1</sub>,  *x*<sub class=""lower-index"">2</sub>  =  *y*<sub class=""lower-index"">2</sub>, ... ,  *x*<sub class=""lower-index"">|*y*|</sub>  =  *y*<sub class=""lower-index"">|*y*|</sub>, or there is such number *r* (*r*  &lt;  |*x*|, *r*  &lt;  |*y*|), that *x*<sub class=""lower-index"">1</sub>  =  *y*<sub class=""lower-index"">1</sub>,  *x*<sub class=""lower-index"">2</sub>  =  *y*<sub class=""lower-index"">2</sub>,  ... ,  *x*<sub class=""lower-index"">*r*</sub>  =  *y*<sub class=""lower-index"">*r*</sub> and *x*<sub class=""lower-index"">*r*  +  1</sub>  &gt;  *y*<sub class=""lower-index"">*r*  +  1</sub>.

We use notation |*a*| to denote length of sequence *a*.",OK,"n = int(input())
pos_arr = []
neg_arr = []
pos_sum = 0
neg_sum = 0
for i in range(n):
    x = int(input())
    if x>0:
        pos_sum += x
        pos_arr.append(x)
    else:
        neg_sum += -x
        neg_arr.append(-x)
    if i==n-1:
        last = x
if pos_sum>neg_sum:
    print('first')
elif pos_sum<neg_sum:
    print('second')
else:
    if pos_arr>neg_arr:
        print('first')
    elif pos_arr<neg_arr:
        print('second')
    else:
        if last<0:
            print('second')
        else:
            print('first')
","def calculo(x, y, z):
    arr = x[y-1:z]
    vis = []
    cont = 0
    
    # Function to count occurrences of a number in the array
    def ocur(arr, num):
        return arr.count(num)
    
    # Count how many numbers x occur exactly x times in the subarray
    for i in arr:
        if i not in vis:
            count_i = ocur(arr, i)
            if count_i == i:
                cont += 1
            vis.append(i)
    
    return cont

def main():
    # Read input values
    n, m = map(int, input().split())
    a = list(map(int, input().split()))
    
    results = []
    # Process each query
    for _ in range(m):
        l, r = map(int, input().split())
        result = calculo(a, l, r)
        results.append(result)
    
    # Output results for all queries
    for res in results:
        print(res)

# Entry point of the program
if __name__ == ""__main__"":
    main()"
267,A,Subtractions,PROGRAMMING,"['math', 'number theory']","You've got two numbers. As long as they are both larger than zero, they go through the same operation: subtract the lesser number from the larger one. If they equal substract one number from the another. For example, one operation transforms pair (4,17) to pair (4,13), it transforms (5,5) to (0,5).

You've got some number of pairs (*a**i*,<=*b**i*). How many operations will be performed for each of them?","The first line contains the number of pairs *n* (1<=<=≤<=<=*n*<=<=≤<=<=1000). Then follow *n* lines, each line contains a pair of positive integers *a**i*,<=*b**i* (1<=<=≤<=<=*a**i*,<=<=*b**i*<=<=≤<=<=109).",Print the sought number of operations for each pair on a single line.,['2\n4 17\n7 987654321\n'],['8\n141093479\n'],none,OK,"for _ in range(int(input())):
    a,b=map(int,input().split())
    ans=int(0)
    while a and b:
        a,b=min(a,b),max(a,b)
        ans,b=ans+b//a,b%a
    print(ans)
","def pylons(n, array):
    s = 0  # Total dollars spent to increase pylon heights
    h = 0  # Current energy level

    for height in array:
        # If current height of the pylon is greater than the energy level
        if height > h:
            # Calculate the needed increase
            s += height - h  # Increase dollars spent
            h = height  # Update the energy level to the new height
        # The energy level decreases by the height of the current pylon
        h -= height  # Update energy level after jumping to the next pylon

    return s  # Return the total dollars spent"
734,A,Anton and Danik,PROGRAMMING,"['implementation', 'strings']","Anton likes to play chess, and so does his friend Danik.

Once they have played *n* games in a row. For each game it's known who was the winner — Anton or Danik. None of the games ended with a tie.

Now Anton wonders, who won more games, he or Danik? Help him determine this.","The first line of the input contains a single integer *n* (1<=≤<=*n*<=≤<=100<=000) — the number of games played.

The second line contains a string *s*, consisting of *n* uppercase English letters 'A' and 'D' — the outcome of each of the games. The *i*-th character of the string is equal to 'A' if the Anton won the *i*-th game and 'D' if Danik won the *i*-th game.","If Anton won more games than Danik, print ""Anton"" (without quotes) in the only line of the output.

If Danik won more games than Anton, print ""Danik"" (without quotes) in the only line of the output.

If Anton and Danik won the same number of games, print ""Friendship"" (without quotes).","['6\nADAAAA\n', '7\nDDDAADA\n', '6\nDADADA\n']","['Anton\n', 'Danik\n', 'Friendship\n']","In the first sample, Anton won 6 games, while Danik — only 1. Hence, the answer is ""Anton"".

In the second sample, Anton won 3 games and Danik won 4 games, so the answer is ""Danik"".

In the third sample, both Anton and Danik won 3 games and the answer is ""Friendship"".",OK,"n=input()
s=input()
na,nd=s.count(""A""),s.count(""D"")
if na>nd:
 print(""Anton"")
elif na==nd:
 print(""Friendship"")
else:
 print(""Danik"")","import sys
# sys.setrecursionlimit(200000)
import math
from collections import Counter
from collections import defaultdict
from collections import deque
input = sys.stdin.readline
from functools import lru_cache

def count_ones(n, l, r):
    # Create a list to represent the sequence
    seq = [n]
    
    # Expand the sequence until all elements are 0 or 1
    while any(x > 1 for x in seq):
        new_seq = []
        for x in seq:
            if x > 1:
                # If x > 1, replace it with x-1 ones and one zero
                new_seq.extend([1] * (x - 1))
                new_seq.append(0)
            else:
                new_seq.append(x)
        seq = new_seq

    # Count the number of 1s in range [l, r]
    return seq[l-1:r].count(1)

# Read input values
n, l, r = map(int, input().split())

# Call the function and print the result
result = count_ones(n, l, r)
print(result)"
404,A,Valera and X,PROGRAMMING,['implementation'],"Valera is a little boy. Yesterday he got a huge Math hometask at school, so Valera didn't have enough time to properly learn the English alphabet for his English lesson. Unfortunately, the English teacher decided to have a test on alphabet today. At the test Valera got a square piece of squared paper. The length of the side equals *n* squares (*n* is an odd number) and each unit square contains some small letter of the English alphabet.

Valera needs to know if the letters written on the square piece of paper form letter ""X"". Valera's teacher thinks that the letters on the piece of paper form an ""X"", if:
 -  on both diagonals of the square paper all letters are the same; -  all other squares of the paper (they are not on the diagonals) contain the same letter that is different from the letters on the diagonals. 
Help Valera, write the program that completes the described task for him.",The first line contains integer *n* (3<=≤<=*n*<=&lt;<=300; *n* is odd). Each of the next *n* lines contains *n* small English letters — the description of Valera's paper.,"Print string ""YES"", if the letters on the paper form letter ""X"". Otherwise, print string ""NO"". Print the strings without quotes.","['5\nxooox\noxoxo\nsoxoo\noxoxo\nxooox\n', '3\nwsw\nsws\nwsw\n', '3\nxpx\npxp\nxpe\n']","['NO\n', 'YES\n', 'NO\n']",none,WRONG_ANSWER,"n = int(input())
s1 = input()
s = ''.join(sorted(set(s1)))
c = 1
co = 1

for i in range(n-1):
    ss1 = input()
    ss = ''.join(sorted(set(ss1)))
    if ss!=s:
        c = 0
    if ss1 == s1:
        co += 1
        if co == n:
            c = 0

if c:
    print(""YES"")
else:
    print(""NO"")","def f(ll):
    l, p, q = ll
    
    # Calculate the distance to the first collision
    first_collision_distance = (p / (p + q)) * l
    
    # Calculate the time taken to reach the first collision
    time_to_first_collision = first_collision_distance / p
    
    # Distance traveled by the spell of You-Know-Who during that time
    distance_you_know_who = q * time_to_first_collision
    
    # Calculate the distance to the second collision
    second_collision_distance = (first_collision_distance + distance_you_know_who) / 2
    
    # Print the distance from Harry's position to the second meeting
    print(second_collision_distance)

# Example usage
f([1000, 300, 200])"
990,C,Bracket Sequences Concatenation Problem,PROGRAMMING,['implementation'],"A bracket sequence is a string containing only characters ""("" and "")"".

A regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters ""1"" and ""+"" between the original characters of the sequence. For example, bracket sequences ""()()"", ""(())"" are regular (the resulting expressions are: ""(1)+(1)"", ""((1+1)+1)""), and "")("" and ""("" are not.

You are given $n$ bracket sequences $s_1, s_2, \dots , s_n$. Calculate the number of pairs $i, j \, (1 \le i, j \le n)$ such that the bracket sequence $s_i + s_j$ is a regular bracket sequence. Operation $+$ means concatenation i.e. ""()("" + "")()"" = ""()()()"".

If $s_i + s_j$ and $s_j + s_i$ are regular bracket sequences and $i \ne j$, then both pairs $(i, j)$ and $(j, i)$ must be counted in the answer. Also, if $s_i + s_i$ is a regular bracket sequence, the pair $(i, i)$ must be counted in the answer.","The first line contains one integer $n \, (1 \le n \le 3 \cdot 10^5)$ — the number of bracket sequences. The following $n$ lines contain bracket sequences — non-empty strings consisting only of characters ""("" and "")"". The sum of lengths of all bracket sequences does not exceed $3 \cdot 10^5$.","In the single line print a single integer — the number of pairs $i, j \, (1 \le i, j \le n)$ such that the bracket sequence $s_i + s_j$ is a regular bracket sequence.","['3\n)\n()\n(\n', '2\n()\n()\n']","['2\n', '4\n']","In the first example, suitable pairs are $(3, 1)$ and $(2, 2)$.

In the second example, any pair is suitable, namely $(1, 1), (1, 2), (2, 1), (2, 2)$.",TIME_LIMIT_EXCEEDED,"n=int(input())
a=[]
ct=0
for k in range(n):
    a.append(input())
for k in range(n):
    for p in range(n):
        b=[]
        u=0
        t=a[k]+a[p];
        for q in range(len(t)):
            if t[q]=='(':
                b.append('(')
            else:
                if len(b)==0:
                    u=1
                    break
                b.pop()
        if u==0 and len(b)==0:
            ct+=1
print(ct)
","def factorial(n):
    if n == 0 or n == 1:
        return 1
    result = 1
    for i in range(2, n + 1):
        result *= i
    return result

def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

# Read input values
A, B = map(int, input().split())

# Calculate the GCD of A! and B!
# Since GCD(A!, B!) = min(A!, B!) when A != B
gcd_value = factorial(min(A, B))
print(gcd_value)"
46,C,Hamsters and Tigers,PROGRAMMING,['two pointers'],"Today there is going to be an unusual performance at the circus — hamsters and tigers will perform together! All of them stand in circle along the arena edge and now the trainer faces a difficult task: he wants to swap the animals' positions so that all the hamsters stood together and all the tigers also stood together. The trainer swaps the animals in pairs not to create a mess. He orders two animals to step out of the circle and swap places. As hamsters feel highly uncomfortable when tigers are nearby as well as tigers get nervous when there's so much potential prey around (consisting not only of hamsters but also of yummier spectators), the trainer wants to spend as little time as possible moving the animals, i.e. he wants to achieve it with the minimal number of swaps. Your task is to help him.","The first line contains number *n* (2<=≤<=*n*<=≤<=1000) which indicates the total number of animals in the arena. The second line contains the description of the animals' positions. The line consists of *n* symbols ""H"" and ""T"". The ""H""s correspond to hamsters and the ""T""s correspond to tigers. It is guaranteed that at least one hamster and one tiger are present on the arena. The animals are given in the order in which they are located circle-wise, in addition, the last animal stands near the first one.",Print the single number which is the minimal number of swaps that let the trainer to achieve his goal.,"['3\nHTH\n', '9\nHTHTHTHHT\n']","['0\n', '2\n']","In the first example we shouldn't move anybody because the animals of each species already stand apart from the other species. In the second example you may swap, for example, the tiger in position 2 with the hamster in position 5 and then — the tiger in position 9 with the hamster in position 7.",WRONG_ANSWER,"n = int(input())
positions = input()

tigers = positions.count('T')

# Concatenate the string to handle circular arrangement
concatenated_positions = positions + positions

min_tigers_in_window = float('inf')

window_tigers = concatenated_positions[:tigers].count('T')
min_tigers_in_window = min(min_tigers_in_window, window_tigers)

for i in range(tigers, len(concatenated_positions)):
    if concatenated_positions[i - tigers] == 'T':
        window_tigers -= 1
    if concatenated_positions[i] == 'T':
        window_tigers += 1
    min_tigers_in_window = min(min_tigers_in_window, window_tigers)

min_swaps = min_tigers_in_window - tigers

print(min_swaps)

		   	 	 		 		 		   	  	  		 	","def rotate_90_degree_anticlckwise(matrix):
    new_matrix = []
    for i in range(len(matrix[0]), 0, -1):
        new_matrix.append(list(map(lambda x: x[i-1], matrix)))
    return new_matrix

n, m = map(int, input().split())
mat = []
for i in range(n):
    mat.append(list(input().strip()))

# Check if the flag is horizontal
def check_horizontal(mat, n, m):
    if n % 3 != 0:
        return False
    stripe_height = n // 3
    colors = set()
    for i in range(stripe_height):
        colors.add(mat[i][0])  # Check the first character of each line in the stripe
        if len(set(mat[i])) != 1:  # All characters in this row must be the same
            return False
    for idx in range(stripe_height, 2 * stripe_height):
        if mat[idx][0] != mat[stripe_height][0]:
            return False
    for idx in range(2 * stripe_height, n):
        if mat[idx][0] != mat[2 * stripe_height][0]:
            return False
    return len(colors) == 3  # Must use exactly three colors

# Check if the flag is vertical
def check_vertical(mat, n, m):
    if m % 3 != 0:
        return False
    stripe_width = m // 3
    colors = set()
    for j in range(stripe_width):
        colors.add(mat[0][j])  # Check the first character of the stripe
        for row in range(n):
            if mat[row][j] != mat[row][0]:  # All characters in this column must be the same
                return False
    for idx in range(stripe_width, 2 * stripe_width):
        if mat[0][idx] != mat[0][stripe_width]:
            return False
    for idx in range(2 * stripe_width, m):
        if mat[0][idx] != mat[0][2 * stripe_width]:
            return False
    return len(colors) == 3  # Must use exactly three colors

# Check both orientations
if check_horizontal(mat, n, m) or check_vertical(mat, n, m):
    print(""YES"")
else:
    print(""NO"")"
387,A,George and Sleep,PROGRAMMING,['implementation'],"George woke up and saw the current time *s* on the digital clock. Besides, George knows that he has slept for time *t*. 

Help George! Write a program that will, given time *s* and *t*, determine the time *p* when George went to bed. Note that George could have gone to bed yesterday relatively to the current time (see the second test sample).","The first line contains current time *s* as a string in the format ""hh:mm"". The second line contains time *t* in the format ""hh:mm"" — the duration of George's sleep. It is guaranteed that the input contains the correct time in the 24-hour format, that is, 00<=≤<=*hh*<=≤<=23, 00<=≤<=*mm*<=≤<=59.",In the single line print time *p* — the time George went to bed in the format similar to the format of the time in the input.,"['05:50\n05:44\n', '00:00\n01:00\n', '00:01\n00:00\n']","['00:06\n', '23:00\n', '00:01\n']","In the first sample George went to bed at ""00:06"". Note that you should print the time only in the format ""00:06"". That's why answers ""0:06"", ""00:6"" and others will be considered incorrect. 

In the second sample, George went to bed yesterday.

In the third sample, George didn't do to bed at all.",OK,"# Description of the problem can be found at http://codeforces.com/problemset/problem/387/A

l_s = list(map(int, input().split("":"")))
l_t = list(map(int, input().split("":"")))

if l_t[1] > l_s[1]:
    l_s[0] -= 1
    
print(""%02d:%02d"" % ((l_s[0] - l_t[0]) % 24, (l_s[1] - l_t[1]) % 60))","def max_points(n, a):
    frequency = [0] * 100001
    for num in a:
        frequency[num] += 1  # Count frequency of each number

    dp = [0] * 100001  # DP array to store maximum points for each number
    dp[0] = 0  # Base case, 0 points for number 0
    dp[1] = frequency[1]  # Points for number 1
    
    # Fill the dp array
    for i in range(2, 100001):
        dp[i] = max(dp[i - 1], dp[i - 2] + i * frequency[i])

    return dp[100000]  # Return maximum points from all numbers

# Example usage
n = int(input())  # Input number of elements
a = list(map(int, input().split()))  # Input the sequence of integers
print(max_points(n, a))  # Output the maximum points"
844,B,Rectangles,PROGRAMMING,"['combinatorics', 'math']","You are given *n*<=×<=*m* table. Each cell of the table is colored white or black. Find the number of non-empty sets of cells such that:
 1.  All cells in a set have the same color. 1.  Every two cells in a set share row or column.","The first line of input contains integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=50) — the number of rows and the number of columns correspondingly.

The next *n* lines of input contain descriptions of rows. There are *m* integers, separated by spaces, in each line. The number equals 0 if the corresponding cell is colored white and equals 1 if the corresponding cell is colored black.",Output single integer  — the number of non-empty sets from the problem description.,"['1 1\n0\n', '2 3\n1 0 1\n0 1 0\n']","['1\n', '8\n']","In the second example, there are six one-element sets. Additionally, there are two two-element sets, the first one consists of the first and the third cells of the first row, the second one consists of the first and the third cells of the second row. To sum up, there are 8 sets.",WRONG_ANSWER,"n, m = map(int, input().split())
mat = []
for i in range(n):
    mat.append([int(i) for i in input().split()])
cont = 0
for row in mat:
    ones = row.count(1)
    cont += 2**ones - 1
    zeroes = row.count(0)
    cont += 2**zeroes - 1
mat = map(list, zip(*mat))
for row in mat:
    ones = row.count(1)
    cont += max(2**ones - 2, 0)
    zeroes = row.count(0)
    cont += max(2**zeroes - 2, 0)
print(cont)
","def inlt():
    return(list(map(int,input().split())))

import sys
from collections import defaultdict

MYPC = False

if MYPC:
    input = sys.stdin.readline
else:
    input = sys.stdin.read

# Read the bracket sequence
s = input().strip()
n = len(s)

# Precompute the counts of open and close brackets
open_count = [0] * (n + 1)
close_count = [0] * (n + 1)

for i in range(1, n + 1):
    open_count[i] = open_count[i - 1] + (1 if s[i - 1] == '(' else 0)
    close_count[i] = close_count[i - 1] + (1 if s[i - 1] == ')' else 0)

# Read number of queries
m = int(input().strip())

results = []
for _ in range(m):
    l, r = map(int, input().strip().split())
    # Calculate max correct bracket subsequence
    open_brackets = open_count[r] - open_count[l - 1]
    close_brackets = close_count[r] - close_count[l - 1]
    # The length of the maximum correct bracket subsequence
    max_length = 2 * min(open_brackets, close_brackets)
    results.append(max_length)

# Print all results
sys.stdout.write('\n'.join(map(str, results)) + '\n')"
803,B,Distances to Zero,PROGRAMMING,['constructive algorithms'],"You are given the array of integer numbers *a*0,<=*a*1,<=...,<=*a**n*<=-<=1. For each element find the distance to the nearest zero (to the element which equals to zero). There is at least one zero element in the given array.",The first line contains integer *n* (1<=≤<=*n*<=≤<=2·105) — length of the array *a*. The second line contains integer elements of the array separated by single spaces (<=-<=109<=≤<=*a**i*<=≤<=109).,"Print the sequence *d*0,<=*d*1,<=...,<=*d**n*<=-<=1, where *d**i* is the difference of indices between *i* and nearest *j* such that *a**j*<==<=0. It is possible that *i*<==<=*j*.","['9\n2 1 0 3 0 0 3 2 4\n', '5\n0 1 2 3 4\n', '7\n5 6 0 1 -2 3 4\n']","['2 1 0 1 0 0 1 2 3 ', '0 1 2 3 4 ', '2 1 0 1 2 3 4 ']",none,TIME_LIMIT_EXCEEDED,"n=int(input())
a=list(map(int,input().split()))
l=[]
def dist(b,l):
    mid=len(l)//2
    if(len(l)==1):
        return abs(b-l[0])
    elif(len(l)==2):
        return min(abs(b-l[0]),abs(b-l[1]))
    elif(b==l[mid]):
        return 0
    elif(b>l[mid]):
        return dist(b,l[mid:])
    else:
        return dist(b,l[0:mid+1])

for i in range(n):
    if(a[i]==0):
        l.append(i)
for i in range(n):
    a[i]=dist(i,l)
print(*a)

","from collections import deque

def cycle_detectable_topological_sort(g, ind):
    V = len(g)
    order = []
    depth = [-1] * V
    
    for i in range(V):
        if not ind[i]:
            order.append(i)
    
    while order:
        node = order.pop()
        for neighbor in g[node]:
            ind[neighbor] -= 1
            if ind[neighbor] == 0:
                order.append(neighbor)
    
    return len(order) != V  # return True if the graph has a cycle

def can_make_acyclic(n, edges):
    g = [[] for _ in range(n)]
    ind = [0] * n
    
    for u, v in edges:
        g[u - 1].append(v - 1)
        ind[v - 1] += 1
    
    if not cycle_detectable_topological_sort(g, ind):
        return ""YES""  # No cycle exists, already acyclic
    
    for u, v in edges:
        g[u - 1].remove(v - 1)  # Remove edge
        ind[v - 1] -= 1
        
        if not cycle_detectable_topological_sort(g, ind):
            return ""YES""  # Can make acyclic by removing this edge
        
        # Restore the edge
        g[u - 1].append(v - 1)
        ind[v - 1] += 1
    
    return ""NO""  # No single edge removal can make it acyclic

# Input reading
n, m = map(int, input().split())
edges = [tuple(map(int, input().split())) for _ in range(m)]

# Output result
print(can_make_acyclic(n, edges))"
841,B,Godsend,PROGRAMMING,"['games', 'math']","Leha somehow found an array consisting of *n* integers. Looking at it, he came up with a task. Two players play the game on the array. Players move one by one. The first player can choose for his move a subsegment of non-zero length with an odd sum of numbers and remove it from the array, after that the remaining parts are glued together into one array and the game continues. The second player can choose a subsegment of non-zero length with an even sum and remove it. Loses the one who can not make a move. Who will win if both play optimally?","First line of input data contains single integer *n* (1<=≤<=*n*<=≤<=106) — length of the array.

Next line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (0<=≤<=*a**i*<=≤<=109).","Output answer in single line. ""First"", if first player wins, and ""Second"" otherwise (without quotes).","['4\n1 3 2 3\n', '2\n2 2\n']","['First\n', 'Second\n']","In first sample first player remove whole array in one move and win.

In second sample first player can't make a move and lose.",OK,"n = int(input())
a = list(map(int,input().split()))
k = sum(a)
if k%2 == 1:
    print('First')
else:
    found = False
    for x in a:
        if x % 2 == 1:
            found = True
            break
    if found:
        print('First')
    else:
        print('Second')","a = input()
b = input()

def check(arr, pos, word):
    subset = """"
    # if (pos + len(word)) <= len(arr):
    if (pos + len(word)) <= len(arr):
        subset = arr[pos:pos + len(word)]
        # Count the number of replacements needed
        return sum(1 for i in range(len(word)) if subset[i] != word[i])
    return float('inf')  # Impossible to replace if out of bounds

def min_replacements(ai_name, phone_name):
    min_changes = 0
    for i in range(len(ai_name)):
        changes = check(ai_name, i, phone_name)
        if changes < float('inf'):
            # Update minimum changes needed
            min_changes += changes
            # Replace characters in AI's name with ""#"" to ensure no substring matches
            ai_name = ai_name[:i] + ""#"" * len(phone_name) + ai_name[i + len(phone_name):]
            break  # We can stop at the first match

    return min_changes

result = min_replacements(a, b)
print(result)"
39,H,Multiplication Table,PROGRAMMING,['implementation'],"Petya studies positional notations. He has already learned to add and subtract numbers in the systems of notations with different radices and has moved on to a more complicated action — multiplication. To multiply large numbers one has to learn the multiplication table. Unfortunately, in the second grade students learn only the multiplication table of decimals (and some students even learn it in the first grade). Help Petya make a multiplication table for numbers in the system of notations with the radix *k*.",The first line contains a single integer *k* (2<=≤<=*k*<=≤<=10) — the radix of the system.,Output the multiplication table for the system of notations with the radix *k*. The table must contain *k*<=-<=1 rows and *k*<=-<=1 columns. The element on the crossing of the *i*-th row and the *j*-th column is equal to the product of *i* and *j* in the system of notations with the radix *k*. Each line may have any number of spaces between the numbers (the extra spaces in the samples are put for clarity).,"['10\n', '3\n']","['1  2  3  4  5  6  7  8  9\n2  4  6  8 10 12 14 16 18\n3  6  9 12 15 18 21 24 27\n4  8 12 16 20 24 28 32 36\n5 10 15 20 25 30 35 40 45\n6 12 18 24 30 36 42 48 54\n7 14 21 28 35 42 49 56 63\n8 16 24 32 40 48 56 64 72\n9 18 27 36 45 54 63 72 81\n', '1  2\n2 11']",none,WRONG_ANSWER,"k = int(input(""""))
n = k-1
if n == 1:
    print(""1"")
elif n ==2 :
        print(""1 2"")
        print(""2 1"")
elif n == 3 :
            print(""1 2 3"")
            print(""2 4 6"")
            print(""3 6 9"")
elif n == 4:
                print(""1  2  3  4"")
                print(""2  4  6  8"")
                print(""3  6  9 12"")
                print(""4  8 12 16"")
elif n == 5:
                    print(""1  2  3  4  5"")
                    print(""2  4  6  8 10"")
                    print(""3  6  9 12 15"")
                    print(""4  8 12 16 20"")
                    print(""5 10 15 20 25"")
elif n == 6:
                          print(""1  2  3  4  5  6"")
                          print(""2  4  6  8 10 12"")
                          print(""3  6  9 12 15 18"")
                          print(""4  8 12 16 20 24"")
                          print(""5 10 15 20 25 30"")
                          print(""6 12 18 24 30 36"")
elif n == 7:
                              print(""1  2  3  4  5  6  7"")
                              print(""2  4  6  8 10 12 14"")
                              print(""3  6  9 12 15 18 21"")
                              print(""4  8 12 16 20 24 28"")
                              print(""5 10 15 20 25 30 35"")
                              print(""6 12 18 24 30 36 42"")
                              print(""7 14 21 28 35 42 49"")
elif n == 8:
         print(""1  2  3  4  5  6  7  8"")
         print(""2  4  6  8 10 12 14 16"")
         print(""3  6  9 12 15 18 21 24"")
         print(""4  8 12 16 20 24 28 32"")
         print(""5 10 15 20 25 30 35 40"")
         print(""6 12 18 24 30 36 42 48"")
         print(""7 14 21 28 35 42 49 56"")      
         print(""8 16 24 32 40 48 56 64"") 
else:
     print(""1  2  3  4  5  6  7  8  9"")
     print(""2  4  6  8 10 12 14 16 18"")
     print(""3  6  9 12 15 18 21 24 27"")
     print(""4  8 12 16 20 24 28 32 36"")
     print(""5 10 15 20 25 30 35 40 45"")
     print(""6 12 18 24 30 36 42 48 54"")
     print(""7 14 21 28 35 42 49 56 63"")      
     print(""8 16 24 32 40 48 56 64 72"")  
     print(""9 18 27 36 45 54 63 72 81"")","def main():
    t = int(input())
    l = [[1] * t for i in range(t)]
    
    # Fill the table based on the given rules
    for i in range(1, t):
        for j in range(1, t):
            l[i][j] = l[i-1][j] + l[i][j-1]
    
    # The maximum value will be in the bottom-right corner of the table
    print(l[-1][-1])

main()"
691,A,Fashion in Berland,PROGRAMMING,['implementation'],"According to rules of the Berland fashion, a jacket should be fastened by all the buttons except only one, but not necessarily it should be the last one. Also if the jacket has only one button, it should be fastened, so the jacket will not swinging open.

You are given a jacket with *n* buttons. Determine if it is fastened in a right way.","The first line contains integer *n* (1<=≤<=*n*<=≤<=1000) — the number of buttons on the jacket.

The second line contains *n* integers *a**i* (0<=≤<=*a**i*<=≤<=1). The number *a**i*<==<=0 if the *i*-th button is not fastened. Otherwise *a**i*<==<=1.","In the only line print the word ""YES"" if the jacket is fastened in a right way. Otherwise print the word ""NO"".","['3\n1 0 1\n', '3\n1 0 0\n']","['YES\n', 'NO\n']",none,OK,"n = int(input())
lst = list(map(int, input().split()))

if n == 1:
    if lst[0] == 1:
        print(""YES"")
    else:
        print(""NO"")
else:
    zeros = lst.count(0)
    if zeros == 1:
        print(""YES"")
    else:
        print(""NO"")","def f(q):
    i = 0
    while i < len(q) and q[i] == '0':
        i += 1
    return q[i:]

def convert_to_simple_exponential_notation(x):
    # Strip leading and trailing whitespace
    x = x.strip()
    
    # If the input is ""0"", directly return ""0""
    if x == '0':
        return '0'
    
    # Handle the case where there is a decimal point
    if '.' in x:
        # Split into integer and fractional parts
        integer_part, fractional_part = x.split('.')
    else:
        integer_part = x
        fractional_part = ''
    
    # Remove leading zeros from the integer part
    integer_part = f(integer_part)
    
    # Determine the exponent b
    if integer_part:  # If there is a non-empty integer part
        b = len(integer_part) - 1  # The exponent is the number of digits in integer_part minus 1
        a = integer_part[0] + (integer_part[1:] + fractional_part).lstrip('0')
    else:  # If the integer part is empty, it means we have only a fractional part
        b = len(fractional_part) - next((i for i, c in enumerate(fractional_part) if c != '0'), len(fractional_part))
        a = fractional_part[b]  # First non-zero digit in the fraction part
        a += fractional_part[b + 1:].lstrip('0')  # Cand add the rest after the first non-zero digit
    
    # Prepare output format
    if a == '':
        a = '0'  # In case a is empty, we return special scenario
    if a[-1] == '.':  # Remove dot if it is the last character
        a = a[:-1]
    
    # Convert a to the correct format
    if a.isdigit():  # If a is an integer
        a = str(int(a))  # Ensure no leading zeros; convert to int and back to str
    else:  # a is a decimal value
        a = str(float(a))
    
    # Construct the result in ""aEb"" format
    if b == 0:
        return a  # If b is zero, return only a
    else:
        return f""{a}E{b}""  # Otherwise return a in simple exponential notation

# Input reading
x = input()
# Output the result
print(convert_to_simple_exponential_notation(x))"
898,A,Rounding,PROGRAMMING,"['implementation', 'math']","Vasya has a non-negative integer *n*. He wants to round it to nearest integer, which ends up with 0. If *n* already ends up with 0, Vasya considers it already rounded.

For example, if *n*<==<=4722 answer is 4720. If *n*<==<=5 Vasya can round it to 0 or to 10. Both ways are correct.

For given *n* find out to which integer will Vasya round it.",The first line contains single integer *n* (0<=≤<=*n*<=≤<=109) — number that Vasya has.,Print result of rounding *n*. Pay attention that in some cases answer isn't unique. In that case print any correct answer.,"['5\n', '113\n', '1000000000\n', '5432359\n']","['0\n', '110\n', '1000000000\n', '5432360\n']","In the first example *n* = 5. Nearest integers, that ends up with zero are 0 and 10. Any of these answers is correct, so you can print 0 or 10.",OK,"n=int(input())
z=int(str(n)[-1])
if z>=5:
	print(n+10-z)
else:
	print(n-z)
","def sol(n, a):
    a.sort()  # Sort the beauty numbers to find max and min easily
    max_beauty_difference = a[-1] - a[0]  # Maximum beauty difference
    if max_beauty_difference == 0:  # All flowers have the same beauty
        # Combinations of choosing 2 out of n flowers
        num_ways = n * (n - 1) // 2  
    else:
        # Count occurrences of the min and max beauty values
        count_min = a.count(a[0])
        count_max = a.count(a[-1])
        num_ways = count_min * count_max  # Ways to choose pairs of min and max beauty flowers
    
    return max_beauty_difference, num_ways  # Return the results"
0,none,none,none,['none'],"Little Nastya has a hobby, she likes to remove some letters from word, to obtain another word. But it turns out to be pretty hard for her, because she is too young. Therefore, her brother Sergey always helps her.

Sergey gives Nastya the word *t* and wants to get the word *p* out of it. Nastya removes letters in a certain order (one after another, in this order strictly), which is specified by permutation of letters' indices of the word *t*: *a*1... *a*|*t*|. We denote the length of word *x* as |*x*|. Note that after removing one letter, the indices of other letters don't change. For example, if *t*<==<=""nastya"" and *a*<==<=[4,<=1,<=5,<=3,<=2,<=6] then removals make the following sequence of words ""nastya""  ""nastya""  ""nastya""  ""nastya""  ""nastya""  ""nastya""  ""nastya"".

Sergey knows this permutation. His goal is to stop his sister at some point and continue removing by himself to get the word *p*. Since Nastya likes this activity, Sergey wants to stop her as late as possible. Your task is to determine, how many letters Nastya can remove before she will be stopped by Sergey.

It is guaranteed that the word *p* can be obtained by removing the letters from word *t*.","The first and second lines of the input contain the words *t* and *p*, respectively. Words are composed of lowercase letters of the Latin alphabet (1<=≤<=|*p*|<=&lt;<=|*t*|<=≤<=200<=000). It is guaranteed that the word *p* can be obtained by removing the letters from word *t*.

Next line contains a permutation *a*1,<=*a*2,<=...,<=*a*|*t*| of letter indices that specifies the order in which Nastya removes letters of *t* (1<=≤<=*a**i*<=≤<=|*t*|, all *a**i* are distinct).","Print a single integer number, the maximum number of letters that Nastya can remove.","['ababcba\nabb\n5 3 4 1 7 6 2\n', 'bbbabb\nbb\n1 6 3 4 2 5\n']","['3', '4']","In the first sample test sequence of removing made by Nastya looks like this:

""ababcba"" <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> ""ababcba"" <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> ""ababcba"" <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> ""ababcba"" 

Nastya can not continue, because it is impossible to get word ""abb"" from word ""ababcba"".

So, Nastya will remove only three letters.",TIME_LIMIT_EXCEEDED,"t = input()
p = input()
aData = input()
a = [int(i) for i in aData.split()]

def removeChar(string, index):
    return string[:index] + string[index+1:]

def replaceChar(string, index, rep):
    return string[:index] + rep + string[index+1:]

ans = 0

for i in a:
    t = replaceChar(t, (i-1), ""X"")

    # Check if p still possible
    pChar = 0
    possible = False
    for j in t:
        if j == p[pChar]:
            pChar += 1
            if pChar >= len(p):
                possible = True
                break
    if possible:
        ans += 1
    else:
        break

print(ans)
","import sys
input = lambda: sys.stdin.readline().rstrip()
from collections import deque, defaultdict, Counter
from itertools import permutations, combinations
from bisect import *

# Read inputs
n, p, q, r = map(int, input().split())
a = list(map(int, input().split()))

# Prepare arrays to store the maximum values for each segment
max_p = [0] * n
max_q = [0] * n
max_r = [0] * n

# Calculate maximum p * a[i] for all i
for i in range(n):
    max_p[i] = max(max_p[i - 1], p * a[i]) if i > 0 else p * a[i]

# Calculate maximum q * a[j] for all j
for j in range(n):
    max_q[j] = max(max_q[j - 1], q * a[j]) if j > 0 else q * a[j]

# Calculate maximum r * a[k] for all k
for k in range(n):
    max_r[k] = max(max_r[k - 1], r * a[k]) if k > 0 else r * a[k]

# Find the maximum value of x = max(p * a[i] + q * a[j] + r * a[k])
max_x = float('-inf')
for j in range(n):
    # For each j, use the precomputed max_p and max_r
    current_x = max_p[j] + max_q[j] + max_r[j]
    max_x = max(max_x, current_x)

# Output the result
print(max_x)"
771,A,Bear and Friendship Condition,PROGRAMMING,"['dfs and similar', 'dsu', 'graphs']","Bear Limak examines a social network. Its main functionality is that two members can become friends (then they can talk with each other and share funny pictures).

There are *n* members, numbered 1 through *n*. *m* pairs of members are friends. Of course, a member can't be a friend with themselves.

Let A-B denote that members A and B are friends. Limak thinks that a network is reasonable if and only if the following condition is satisfied: For every three distinct members (X, Y, Z), if X-Y and Y-Z then also X-Z.

For example: if Alan and Bob are friends, and Bob and Ciri are friends, then Alan and Ciri should be friends as well.

Can you help Limak and check if the network is reasonable? Print ""YES"" or ""NO"" accordingly, without the quotes.","The first line of the input contain two integers *n* and *m* (3<=≤<=*n*<=≤<=150<=000, ) — the number of members and the number of pairs of members that are friends.

The *i*-th of the next *m* lines contains two distinct integers *a**i* and *b**i* (1<=≤<=*a**i*,<=*b**i*<=≤<=*n*,<=*a**i*<=≠<=*b**i*). Members *a**i* and *b**i* are friends with each other. No pair of members will appear more than once in the input.","If the given network is reasonable, print ""YES"" in a single line (without the quotes). Otherwise, print ""NO"" in a single line (without the quotes).","['4 3\n1 3\n3 4\n1 4\n', '4 4\n3 1\n2 3\n3 4\n1 2\n', '10 4\n4 3\n5 10\n8 9\n1 2\n', '3 2\n1 2\n2 3\n']","['YES\n', 'NO\n', 'YES\n', 'NO\n']","The drawings below show the situation in the first sample (on the left) and in the second sample (on the right). Each edge represents two members that are friends. The answer is ""NO"" in the second sample because members (2, 3) are friends and members (3, 4) are friends, while members (2, 4) are not.",TIME_LIMIT_EXCEEDED,"n, m = map(int, input().split())
edges = [set([x]) for x in range(n)]
checked = [False for x in range(n)]
res = True

for x in range(m):
    i, j = map(int, input().split())
    edges[i - 1].add(j - 1)
    edges[j - 1].add(i - 1)

for i in range(n):
    if checked[i]:
        continue
    for j in edges[i]:
        checked[j] = True
        if edges[j] != edges[i]:
            res = False
            break
    if not res:
        break

if res:
    print(""YES"")
else:
    print(""NO"")
","calls = 0

cacheD = {}
cacheA = {}

def solve(vertice, passos):
    global calls
    calls += 1

    # Base case: if no steps left
    if passos == 0:
        return 1 if vertice == 'D' else 0
    
    # Check the cache
    if vertice == 'D':
        if passos in cacheD:
            return cacheD[passos]
    else:
        if passos in cacheA:
            return cacheA[passos]
    
    # Calculate the number of ways from the current vertex
    if vertice == 'D':
        # Can move to A, B, C
        ways = (solve('A', passos - 1) + solve('B', passos - 1) + solve('C', passos - 1)) % 1000000007
        cacheD[passos] = ways
    else:
        # Can move back to D or to the other two vertices
        ways = (solve('D', passos - 1) + solve('A', passos - 1) + solve('B', passos - 1) + solve('C', passos - 1) - solve(vertice, passos - 1)) % 1000000007
        cacheA[passos] = ways

    return ways

n = int(input())
result = solve('D', n)
print(result)"
745,A,Hongcow Learns the Cyclic Shift,PROGRAMMING,"['implementation', 'strings']","Hongcow is learning to spell! One day, his teacher gives him a word that he needs to learn to spell. Being a dutiful student, he immediately learns how to spell the word.

Hongcow has decided to try to make new words from this one. He starts by taking the word he just learned how to spell, and moves the last character of the word to the beginning of the word. He calls this a cyclic shift. He can apply cyclic shift many times. For example, consecutively applying cyclic shift operation to the word ""abracadabra"" Hongcow will get words ""aabracadabr"", ""raabracadab"" and so on.

Hongcow is now wondering how many distinct words he can generate by doing the cyclic shift arbitrarily many times. The initial string is also counted.","The first line of input will be a single string *s* (1<=≤<=|*s*|<=≤<=50), the word Hongcow initially learns how to spell. The string *s* consists only of lowercase English letters ('a'–'z').",Output a single integer equal to the number of distinct strings that Hongcow can obtain by applying the cyclic shift arbitrarily many times to the given string.,"['abcd\n', 'bbb\n', 'yzyz\n']","['4\n', '1\n', '2\n']","For the first sample, the strings Hongcow can generate are ""abcd"", ""dabc"", ""cdab"", and ""bcda"".

For the second sample, no matter how many times Hongcow does the cyclic shift, Hongcow can only generate ""bbb"".

For the third sample, the two strings Hongcow can generate are ""yzyz"" and ""zyzy"".",OK,"#CF YL1
s=input()
c={s}
def cyc(s2):return s2[-1]+s2[:-1]
for i in range(len(s)):
    s=cyc(s)
    c.add(s)
print(len(c))
","import math
from math import comb

def countDer(n):
    # Base Case
    if n == 1 or n == 2:
        return n - 1

    # Initialize derangement counts
    der = [0] * (n + 1)
    der[0], der[1], der[2] = 1, 0, 1

    # Fill derangements using the recursive formula
    for i in range(3, n + 1):
        der[i] = (i - 1) * (der[i - 1] + der[i - 2])

    return der[n]

def countAlmostIdentityPermutations(n, k):
    # To count almost identity permutations
    total = 0
    
    # Count permutations with exactly i fixed points
    for i in range(n - k, n + 1):
        total += comb(n, i) * countDer(n - i)

    return total

# Read input values
n, k = map(int, input().split())
# Call the function and print the result
print(countAlmostIdentityPermutations(n, k))"
300,A,Array,PROGRAMMING,"['brute force', 'constructive algorithms', 'implementation']","Vitaly has an array of *n* distinct integers. Vitaly wants to divide this array into three non-empty sets so as the following conditions hold: 
 1.  The product of all numbers in the first set is less than zero (<=&lt;<=0). 1.  The product of all numbers in the second set is greater than zero (<=&gt;<=0). 1.  The product of all numbers in the third set is equal to zero. 1.  Each number from the initial array must occur in exactly one set. 
Help Vitaly. Divide the given array.","The first line of the input contains integer *n* (3<=≤<=*n*<=≤<=100). The second line contains *n* space-separated distinct integers *a*1,<=*a*2,<=...,<=*a**n* (|*a**i*|<=≤<=103) — the array elements.","In the first line print integer *n*1 (*n*1<=&gt;<=0) — the number of elements in the first set. Then print *n*1 numbers — the elements that got to the first set.

In the next line print integer *n*2 (*n*2<=&gt;<=0) — the number of elements in the second set. Then print *n*2 numbers — the elements that got to the second set.

In the next line print integer *n*3 (*n*3<=&gt;<=0) — the number of elements in the third set. Then print *n*3 numbers — the elements that got to the third set.

The printed sets must meet the described conditions. It is guaranteed that the solution exists. If there are several solutions, you are allowed to print any of them.","['3\n-1 2 0\n', '4\n-1 -2 -3 0\n']","['1 -1\n1 2\n1 0\n', '1 -1\n2 -3 -2\n1 0\n']",none,OK,"p = int(input())
q = list(int(x) for x in input().split())
a = []
b = []
c = []
for i in q:
    if i<0:
        a.append(i)
    elif i>0:
        b.append(i)
    else:
        c.append(i)

if len(b)==0 and len(a)>2:
    for i in range(2):
        b.append(a[i])
    a.remove(a[0])
    a.remove(a[0])

while len(a)>1:
    c.append(a[1])
    a.remove(a[1])

print(len(a),end="" "")
for i in a:
    print(i,end="" "")
print()

print(len(b),end="" "")
for i in b:
    print(i,end="" "")
print()

print(len(c),end="" "")
for i in c:
    print(i,end="" "")","#https://codeforces.com/contest/597/problem/C

from collections import defaultdict
import sys

class Fenwick:
    def __init__(self, size):
        self.tree = [0] * size 

    def add(self, index, value):
        while index < len(self.tree):
            self.tree[index] += value
            index += index & -index

    def sum(self, index):
        result = 0
        while index > 0:
            result += self.tree[index]
            index -= index & -index
        return result

def count_increasing_subsequences(n, k, a):
    # Prepare a Fenwick tree for counting
    fenwick = Fenwick(n + 1)
    
    # List to hold the number of ways to form increasing subsequences of length j ending at each element
    dp = [[0] * (k + 1) for _ in range(n)]
    
    # Every element can be a subsequence of length 1
    for i in range(n):
        dp[i][1] = 1

    # Calculate the number of increasing subsequences
    for length in range(1, k + 1):
        for i in range(n):
            if length > 1:
                # Sum up counts of subsequences of length (length - 1) for all smaller elements
                dp[i][length] += fenwick.sum(a[i] - 1)
            # Accumulate counts in Fenwick tree for subsequences of the current length
            fenwick.add(a[i], dp[i][length])
    
    # Sum all counts of increasing subsequences of length >= k
    return sum(dp[i][length] for length in range(k, k + 1) for i in range(n))

if __name__ == ""__main__"":
    input = sys.stdin.read
    data = input().split()
    n, k = int(data[0]), int(data[1])
    a = [int(data[i + 2]) for i in range(n)]
    
    print(count_increasing_subsequences(n, k, a))"
25,A,IQ test,PROGRAMMING,['brute force'],"Bob is preparing to pass IQ test. The most frequent task in this test is to find out which one of the given *n* numbers differs from the others. Bob observed that one number usually differs from the others in evenness. Help Bob — to check his answers, he needs a program that among the given *n* numbers finds one that is different in evenness.","The first line contains integer *n* (3<=≤<=*n*<=≤<=100) — amount of numbers in the task. The second line contains *n* space-separated natural numbers, not exceeding 100. It is guaranteed, that exactly one of these numbers differs from the others in evenness.",Output index of number that differs from the others in evenness. Numbers are numbered from 1 in the input order.,"['5\n2 4 7 8 10\n', '4\n1 2 1 1\n']","['3\n', '2\n']",none,OK,"input()
numbers = input().split()
even = []
not_even = []
for number in numbers:
    if int(number) % 2 == 0:
        even.append(number)
    else:
        not_even.append(number)

if len(even) == 1:
    print(numbers.index(even[0]) + 1)
elif len(not_even) == 1:
    print(numbers.index(not_even[0]) + 1)
else:
    print('You have incorrect sequence')","k = int(input())

# Initialize a dictionary to count the number of panels for each timing
timing_count = {}

# Read the panel inputs and count the number of panels for each time
for _ in range(4):
    line = input().strip()
    for char in line:
        if char != '.':
            if char not in timing_count:
                timing_count[char] = 0
            timing_count[char] += 1

# Check if the number of panels for each timing can be pressed with both hands
for count in timing_count.values():
    if count > 2 * k:  # He can press k panels with each hand
        print(""NO"")
        break
else:
    print(""YES"")"
432,D,Prefixes and Suffixes,PROGRAMMING,"['dp', 'string suffix structures', 'strings', 'two pointers']","You have a string *s*<==<=*s*1*s*2...*s*|*s*|, where |*s*| is the length of string *s*, and *s**i* its *i*-th character. 

Let's introduce several definitions:
 -  A substring *s*[*i*..*j*] (1<=≤<=*i*<=≤<=*j*<=≤<=|*s*|) of string *s* is string *s**i**s**i*<=+<=1...*s**j*. -  The prefix of string *s* of length *l* (1<=≤<=*l*<=≤<=|*s*|) is string *s*[1..*l*]. -  The suffix of string *s* of length *l* (1<=≤<=*l*<=≤<=|*s*|) is string *s*[|*s*|<=-<=*l*<=+<=1..|*s*|]. 
Your task is, for any prefix of string *s* which matches a suffix of string *s*, print the number of times it occurs in string *s* as a substring.",The single line contains a sequence of characters *s*1*s*2...*s*|*s*| (1<=≤<=|*s*|<=≤<=105) — string *s*. The string only consists of uppercase English letters.,"In the first line, print integer *k* (0<=≤<=*k*<=≤<=|*s*|) — the number of prefixes that match a suffix of string *s*. Next print *k* lines, in each line print two integers *l**i* *c**i*. Numbers *l**i* *c**i* mean that the prefix of the length *l**i* matches the suffix of length *l**i* and occurs in string *s* as a substring *c**i* times. Print pairs *l**i* *c**i* in the order of increasing *l**i*.","['ABACABA\n', 'AAA\n']","['3\n1 4\n3 2\n7 1\n', '3\n1 3\n2 2\n3 1\n']",none,OK,"import sys
input = sys.stdin.readline
from collections import deque

S=input().strip()


LEN=len(S)
i=1
j=0
A=[0]*LEN
A[0]=LEN

while i<LEN:
    while i+j<LEN and S[j]==S[i+j]:
        j+=1
    A[i]=j
    
    if j==0:
        i+=1
        continue
    
    k=1
    while i+k<LEN and k+A[k]<j:
        A[i+k]=A[k]
        k+=1
    i+=k
    j-=k

ANS=[0]*(LEN+1)

for a in A:
    ANS[a]+=1

for i in range(LEN-1,-1,-1):
    ANS[i]+=ANS[i+1]

ANS2=[]
for i in range(1,LEN+1):
    if A[LEN-i]==i:
        ANS2.append((i,ANS[i]))

print(len(ANS2))
for x,y in ANS2:
    print(x,y)



","def func(n):
    sum = 0
    while n > 0:
        sum += n % 10
        n //= 10
    return sum

def count_spells(n):
    spells = 0
    # Check if the number is already a single digit
    if len(n) == 1:
        return spells
    
    # While the number has more than one digit
    while len(n) > 1:
        n = str(func(int(n)))  # Cast spell by summing the digits
        spells += 1  # Increment the count of spells
    
    return spells

# Read input
n = input().strip()
# Print the number of spells
print(count_spells(n))"
50,A,Domino piling,PROGRAMMING,"['greedy', 'math']","You are given a rectangular board of *M*<=×<=*N* squares. Also you are given an unlimited number of standard domino pieces of 2<=×<=1 squares. You are allowed to rotate the pieces. You are asked to place as many dominoes as possible on the board so as to meet the following conditions:

1. Each domino completely covers two squares.

2. No two dominoes overlap.

3. Each domino lies entirely inside the board. It is allowed to touch the edges of the board.

Find the maximum number of dominoes, which can be placed under these restrictions.",In a single line you are given two integers *M* and *N* — board sizes in squares (1<=≤<=*M*<=≤<=*N*<=≤<=16).,"Output one number — the maximal number of dominoes, which can be placed.","['2 4\n', '3 3\n']","['4\n', '4\n']",none,OK,"m,n=map(int,input().split())
a=m/2
b=n/1
c=a*b
print(int(c))","def solution():
    n = int(input())
    sizes = map(int, input().split())
    sizes = list(sizes)

    maxi = -float('inf')
    mini = -maxi
    placed = set()  # Set to track placed snacks
    output = []

    for e in sizes:
        # Add the current snack to the placed set
        placed.add(e)
        current_output = []

        # Check if we can place snacks starting from the smallest (1) to the largest (n)
        while mini + 1 in placed:
            mini += 1  # Increment mini as we can place this snack
            current_output.append(mini)  # Add to the current day's output

        # Store the output for the current day
        output.append(' '.join(map(str, current_output)))

    # Print the output for each day
    for line in output:
        print(line)"
706,B,Interesting drink,PROGRAMMING,"['binary search', 'dp', 'implementation']","Vasiliy likes to rest after a hard work, so you may often meet him in some bar nearby. As all programmers do, he loves the famous drink ""Beecola"", which can be bought in *n* different shops in the city. It's known that the price of one bottle in the shop *i* is equal to *x**i* coins.

Vasiliy plans to buy his favorite drink for *q* consecutive days. He knows, that on the *i*-th day he will be able to spent *m**i* coins. Now, for each of the days he want to know in how many different shops he can buy a bottle of ""Beecola"".","The first line of the input contains a single integer *n* (1<=≤<=*n*<=≤<=100<=000) — the number of shops in the city that sell Vasiliy's favourite drink.

The second line contains *n* integers *x**i* (1<=≤<=*x**i*<=≤<=100<=000) — prices of the bottles of the drink in the *i*-th shop.

The third line contains a single integer *q* (1<=≤<=*q*<=≤<=100<=000) — the number of days Vasiliy plans to buy the drink.

Then follow *q* lines each containing one integer *m**i* (1<=≤<=*m**i*<=≤<=109) — the number of coins Vasiliy can spent on the *i*-th day.",Print *q* integers. The *i*-th of them should be equal to the number of shops where Vasiliy will be able to buy a bottle of the drink on the *i*-th day.,['5\n3 10 8 6 11\n4\n1\n10\n3\n11\n'],['0\n4\n1\n5\n'],"On the first day, Vasiliy won't be able to buy a drink in any of the shops.

On the second day, Vasiliy can buy a drink in the shops 1, 2, 3 and 4.

On the third day, Vasiliy can buy a drink only in the shop number 1.

Finally, on the last day Vasiliy can buy a drink in any shop.",OK,"import bisect
N=int(input())
x=sorted(list(map(int,input().split())))
for i in range(int(input())):
    print(bisect.bisect(x,int(input())))","def weights(w):
    # Check if the weight is even and greater than 2
    if w % 2 == 0 and w > 2:
        return True
    else:
        return False

# Input weight of the watermelon
w = int(input(""Enter the weight of the watermelon: ""))

# Output result based on the weights function
if weights(w):
    print(""YES"")
else:
    print(""NO"")"
337,B,Routine Problem,PROGRAMMING,"['greedy', 'math', 'number theory']","Manao has a monitor. The screen of the monitor has horizontal to vertical length ratio *a*:*b*. Now he is going to watch a movie. The movie's frame has horizontal to vertical length ratio *c*:*d*. Manao adjusts the view in such a way that the movie preserves the original frame ratio, but also occupies as much space on the screen as possible and fits within it completely. Thus, he may have to zoom the movie in or out, but Manao will always change the frame proportionally in both dimensions.

Calculate the ratio of empty screen (the part of the screen not occupied by the movie) to the total screen size. Print the answer as an irreducible fraction *p*<=/<=*q*.","A single line contains four space-separated integers *a*, *b*, *c*, *d* (1<=≤<=*a*,<=*b*,<=*c*,<=*d*<=≤<=1000).","Print the answer to the problem as ""p/q"", where *p* is a non-negative integer, *q* is a positive integer and numbers *p* and *q* don't have a common divisor larger than 1.","['1 1 3 2\n', '4 3 2 2\n']","['1/3\n', '1/4\n']","Sample 1. Manao's monitor has a square screen. The movie has 3:2 horizontal to vertical length ratio. Obviously, the movie occupies most of the screen if the width of the picture coincides with the width of the screen. In this case, only 2/3 of the monitor will project the movie in the horizontal dimension: <img class=""tex-graphics"" src=""https://espresso.codeforces.com/ce823413ad27813e27496a0d8bd4231e94b47662.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

Sample 2. This time the monitor's width is 4/3 times larger than its height and the movie's frame is square. In this case, the picture must take up the whole monitor in the vertical dimension and only 3/4 in the horizontal dimension: <img class=""tex-graphics"" src=""https://espresso.codeforces.com/c2bcb3b1f64810812eee368ff180e3e148d24c67.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>",WRONG_ANSWER,"a,b,c,d=map(int,input().split())

m1=max(a,b)
m2=max(c,d)

if a==d and b==c:
    print(str(min(c,d)+min(a,b)+1)+'/'+str(max(a,b)*max(a,b)))

else:
    
    a=a*m2
    b=b*m2
    c=c*m1
    d=d*m1



    l=[a,b,c,d]
    l.sort()

    l=l[:2]

    for i in range(2,l[0]):
        while l[0]%i==0 and l[1]%i==0:
            l[0]=l[0]//i
            l[1]=l[1]//i
            
    print(str(max(l)-min(l))+'/'+str(max(l)))

","import sys
input = sys.stdin.readline

if __name__ == '__main__':
    n = int(input())
    maxvol = list(map(int, input().split()))
    maxvol.append(float('inf'))

    # Initialize the current water levels in each vessel
    water = [0] * n
    
    for _ in range(int(input())):
        query = list(map(int, input().split()))
        
        if query[0] == 1:
            # Add water to the p-th vessel
            p = query[1] - 1  # Convert to 0-based index
            x = query[2]
            water[p] += x
            
            # Handle overflow
            for i in range(p, n):
                if water[i] > maxvol[i]:
                    overflow = water[i] - maxvol[i]
                    water[i] = maxvol[i]
                    if i + 1 < n:
                        water[i + 1] += overflow
                else:
                    break
                
        elif query[0] == 2:
            # Print the number of liters in the k-th vessel
            k = query[1] - 1  # Convert to 0-based index
            print(water[k])"
581,A,Vasya the Hipster,PROGRAMMING,"['implementation', 'math']","One day Vasya the Hipster decided to count how many socks he had. It turned out that he had *a* red socks and *b* blue socks.

According to the latest fashion, hipsters should wear the socks of different colors: a red one on the left foot, a blue one on the right foot.

Every day Vasya puts on new socks in the morning and throws them away before going to bed as he doesn't want to wash them.

Vasya wonders, what is the maximum number of days when he can dress fashionable and wear different socks, and after that, for how many days he can then wear the same socks until he either runs out of socks or cannot make a single pair from the socks he's got.

Can you help him?","The single line of the input contains two positive integers *a* and *b* (1<=≤<=*a*,<=*b*<=≤<=100) — the number of red and blue socks that Vasya's got.","Print two space-separated integers — the maximum number of days when Vasya can wear different socks and the number of days when he can wear the same socks until he either runs out of socks or cannot make a single pair from the socks he's got.

Keep in mind that at the end of the day Vasya throws away the socks that he's been wearing on that day.","['3 1\n', '2 3\n', '7 3\n']","['1 1\n', '2 0\n', '3 2\n']","In the first sample Vasya can first put on one pair of different socks, after that he has two red socks left to wear on the second day.",OK,"a, b = map(int,input().split())

p = min(a,b)

left = (a+b)-(2*p)

left = left//2

print(f""{p} {left}"")","import sys
from decimal import Decimal
import math


def primes_till(n):  # Sieve of Eratosthenes
    p = [True] * n
    for i in range(2, int(math.sqrt(n)) + 1):
        if p[i]:
            for j in range(i * i, n, i):
                p[j] = False
    return [i for i in range(2, n) if p[i]]


def gcd(a, b):  # Function to compute GCD
    while b:
        a, b = b, a % b
    return a


def f(x, y):  # Function to calculate f(x, y)
    if y <= 0:
        return 0
    else:
        g = gcd(x, y)  # Compute the GCD of x and y
        return (y // g)  # Return the result based on the function definition


if __name__ == ""__main__"":
    x, y = map(int, input().split())  # Read x and y from input
    print(f(x, y))  # Print the result of f(x, y)"
938,D,Buy a Ticket,PROGRAMMING,"['data structures', 'graphs', 'shortest paths']","Musicians of a popular band ""Flayer"" have announced that they are going to ""make their exit"" with a world tour. Of course, they will visit Berland as well.

There are *n* cities in Berland. People can travel between cities using two-directional train routes; there are exactly *m* routes, *i*-th route can be used to go from city *v**i* to city *u**i* (and from *u**i* to *v**i*), and it costs *w**i* coins to use this route.

Each city will be visited by ""Flayer"", and the cost of the concert ticket in *i*-th city is *a**i* coins.

You have friends in every city of Berland, and they, knowing about your programming skills, asked you to calculate the minimum possible number of coins they have to pay to visit the concert. For every city *i* you have to compute the minimum number of coins a person from city *i* has to spend to travel to some city *j* (or possibly stay in city *i*), attend a concert there, and return to city *i* (if *j*<=≠<=*i*).

Formally, for every  you have to calculate , where *d*(*i*,<=*j*) is the minimum number of coins you have to spend to travel from city *i* to city *j*. If there is no way to reach city *j* from city *i*, then we consider *d*(*i*,<=*j*) to be infinitely large.","The first line contains two integers *n* and *m* (2<=≤<=*n*<=≤<=2·105, 1<=≤<=*m*<=≤<=2·105).

Then *m* lines follow, *i*-th contains three integers *v**i*, *u**i* and *w**i* (1<=≤<=*v**i*,<=*u**i*<=≤<=*n*,<=*v**i*<=≠<=*u**i*, 1<=≤<=*w**i*<=≤<=1012) denoting *i*-th train route. There are no multiple train routes connecting the same pair of cities, that is, for each (*v*,<=*u*) neither extra (*v*,<=*u*) nor (*u*,<=*v*) present in input.

The next line contains *n* integers *a*1,<=*a*2,<=... *a**k* (1<=≤<=*a**i*<=≤<=1012) — price to attend the concert in *i*-th city.","Print *n* integers. *i*-th of them must be equal to the minimum number of coins a person from city *i* has to spend to travel to some city *j* (or possibly stay in city *i*), attend a concert there, and return to city *i* (if *j*<=≠<=*i*).","['4 2\n1 2 4\n2 3 7\n6 20 1 25\n', '3 3\n1 2 1\n2 3 1\n1 3 1\n30 10 20\n']","['6 14 1 25 \n', '12 10 12 \n']",none,RUNTIME_ERROR,"import numpy as np

n,m = input().split()
n = int(n)
m = int(m)

ciudades = np.zeros((n,n))

for i in range(m):
    u,v,w = input().split()
    u = int(u)
    v = int(v)
    w = int (w)
    ciudades[u-1][v-1] = w
    ciudades[v-1][u-1] = w

costo = input()
costos = costo.split()

for i in range(n):
    costos[i] = int(costos[i])

for i in range(n):
    for j in range(n):
        if (ciudades[i][j] != 0):
            cost = 2* ciudades[i][j] + costos[j]
            if(cost < int(costos[i])):
                costos[i] = int(cost)

print(*costos)

","def main():
    n = int(input())
    nodes = list(map(int, input().split()))
    controlling = [0] * n
    parent = {0: []}
    tree = {}

    # Read edges and build tree
    for i in range(1, n):
        p, w = map(int, input().split())
        parent[i] = p - 1  # zero-index
        if p - 1 not in tree:
            tree[p - 1] = []
        tree[p - 1].append((i, w))  # store child index and weight

    # DFS function to calculate the count of controlled nodes
    def dfs(v, acc_dist):
        acc_dist += edge_weights[v]
        count = 1  # count itself
        for u, weight in tree.get(v, []):
            if acc_dist <= nodes[u]:  # check the condition for control
                count += dfs(u, acc_dist)
        controlling[v] = count - 1  # excluding itself
        return count

    edge_weights = [0] * n
    for i in range(1, n):
        edge_weights[i] = input().split()[1]  # only storing edge weights

    # Start DFS from the root
    dfs(0, 0)

    # Print the result
    print(' '.join(map(str, controlling)))

main()"
1,A,Theatre Square,PROGRAMMING,['math'],"Theatre Square in the capital city of Berland has a rectangular shape with the size *n*<=×<=*m* meters. On the occasion of the city's anniversary, a decision was taken to pave the Square with square granite flagstones. Each flagstone is of the size *a*<=×<=*a*.

What is the least number of flagstones needed to pave the Square? It's allowed to cover the surface larger than the Theatre Square, but the Square has to be covered. It's not allowed to break the flagstones. The sides of flagstones should be parallel to the sides of the Square.","The input contains three positive integer numbers in the first line: *n*,<=<=*m* and *a* (1<=≤<=<=*n*,<=*m*,<=*a*<=≤<=109).",Write the needed number of flagstones.,['6 6 4\n'],['4\n'],none,RUNTIME_ERROR,"numbers= input().split()
n = numbers[0]
m = numbers[1]
a = numbers[2]
s1 = n * m
s2 = a * a

if s1 % s2 == 0:
    count = s1 / s2
else:
    s1_ = s1 / 2
    count = s1_ // s2 + 1
    
print(count) ","def f(r, c):
    # Create a table of size (r+1) x (c+1) initialized with zeros
    a = [[0] * (c + 1) for _ in range(r + 1)]

    # Fill the first row and first column with ones
    for i in range(1, r + 1):
        a[i][1] = 1
    for j in range(1, c + 1):
        a[1][j] = 1

    # Fill the rest of the table based on the defined rules
    for i in range(2, r + 1):
        for j in range(2, c + 1):
            a[i][j] = a[i - 1][j] + a[i][j - 1]

    # The maximum value will be in the bottom-right corner of the table
    return a[r][c]

# Get input from the user
n = int(input())
# Output the maximum value in the n x n table
print(f(n, n))"
143,A,Help Vasilisa the Wise 2,PROGRAMMING,"['brute force', 'math']","Vasilisa the Wise from the Kingdom of Far Far Away got a magic box with a secret as a present from her friend Hellawisa the Wise from the Kingdom of A Little Closer. However, Vasilisa the Wise does not know what the box's secret is, since she cannot open it again. She hopes that you will help her one more time with that.

The box's lock looks as follows: it contains 4 identical deepenings for gems as a 2<=×<=2 square, and some integer numbers are written at the lock's edge near the deepenings. The example of a lock is given on the picture below.

The box is accompanied with 9 gems. Their shapes match the deepenings' shapes and each gem contains one number from 1 to 9 (each number is written on exactly one gem). The box will only open after it is decorated with gems correctly: that is, each deepening in the lock should be filled with exactly one gem. Also, the sums of numbers in the square's rows, columns and two diagonals of the square should match the numbers written at the lock's edge. For example, the above lock will open if we fill the deepenings with gems with numbers as is shown on the picture below.

Now Vasilisa the Wise wants to define, given the numbers on the box's lock, which gems she should put in the deepenings to open the box. Help Vasilisa to solve this challenging task.","The input contains numbers written on the edges of the lock of the box. The first line contains space-separated integers *r*1 and *r*2 that define the required sums of numbers in the rows of the square. The second line contains space-separated integers *c*1 and *c*2 that define the required sums of numbers in the columns of the square. The third line contains space-separated integers *d*1 and *d*2 that define the required sums of numbers on the main and on the side diagonals of the square (1<=≤<=*r*1,<=*r*2,<=*c*1,<=*c*2,<=*d*1,<=*d*2<=≤<=20). Correspondence between the above 6 variables and places where they are written is shown on the picture below. For more clarifications please look at the second sample test that demonstrates the example given in the problem statement.","Print the scheme of decorating the box with stones: two lines containing two space-separated integers from 1 to 9. The numbers should be pairwise different. If there is no solution for the given lock, then print the single number ""-1"" (without the quotes).

If there are several solutions, output any.","['3 7\n4 6\n5 5\n', '11 10\n13 8\n5 16\n', '1 2\n3 4\n5 6\n', '10 10\n10 10\n10 10\n']","['1 2\n3 4\n', '4 7\n9 1\n', '-1\n', '-1\n']","Pay attention to the last test from the statement: it is impossible to open the box because for that Vasilisa the Wise would need 4 identical gems containing number ""5"". However, Vasilisa only has one gem with each number from 1 to 9.",RUNTIME_ERROR,"import sympy as sp

r1, r2 = input("""").split() #Rows of square

c1, c2 = input("""").split() #colums of square

d1, d2 = input("""").split() #diagonals of square

x1, x2, y1, y2 = sp.symbols(""x1, x2, y1, y2"")

eq1 = sp.Eq(x1 + y1, int(c1))
eq2 = sp.Eq(y1 + y2, int(r2))
eq3 = sp.Eq(x2 + y2, int(c2))
eq4 = sp.Eq(x1 + x2, int(r1))
eq5 = sp.Eq(x1 + y2, int(d1))
eq6 = sp.Eq(x2 + y1, int(d2))

ans = sp.solve((eq1, eq2, eq3, eq4, eq5, eq6), (x1, x2, y1, y2))

print(ans[x1], ans[x2])
print(ans[y1], ans[y2])


","input()
a = list(map(int, input().split()))
n = 0
m = []
for x in a:
    n, N, y, s = 2, 1, 0, []
    while x != 0:
        y = int((x / N) % n)
        s.append(y)
        x -= N * y
        N *= n
    while len(s) != 2:
        s.append(0)  # Pad the list with 0s if there are not enough days

    last_activity = -1
    rest_days = 0

    for day in s:
        if day == 0:
            rest_days += 1  # It's a rest day
            last_activity = -1  # Reset the last activity
        elif day == 1:  # Contest day
            if last_activity != 1:  # If last activity was not contest
                last_activity = 1  # Do the contest
            else:
                rest_days += 1  # Rest day because of consecutive contest
        elif day == 2:  # Gym day
            if last_activity != 2:  # If last activity was not gym
                last_activity = 2  # Do the sport
            else:
                rest_days += 1  # Rest day because of consecutive gym
        elif day == 3:  # Both contest and gym available
            if last_activity == 0 or last_activity == 1:
                last_activity = 2  # Do sport if last was rest or contest
            else:
                last_activity = 1  # Do contest otherwise

    m.append(rest_days)

print(sum(m))"
33,A,What is for dinner?,PROGRAMMING,"['greedy', 'implementation']","In one little known, but very beautiful country called Waterland, lives a lovely shark Valerie. Like all the sharks, she has several rows of teeth, and feeds on crucians. One of Valerie's distinguishing features is that while eating one crucian she uses only one row of her teeth, the rest of the teeth are ""relaxing"".

For a long time our heroine had been searching the sea for crucians, but a great misfortune happened. Her teeth started to ache, and she had to see the local dentist, lobster Ashot. As a professional, Ashot quickly relieved Valerie from her toothache. Moreover, he managed to determine the cause of Valerie's developing caries (for what he was later nicknamed Cap).

It turned that Valerie eats too many crucians. To help Valerie avoid further reoccurrence of toothache, Ashot found for each Valerie's tooth its residual viability. Residual viability of a tooth is a value equal to the amount of crucians that Valerie can eat with this tooth. Every time Valerie eats a crucian, viability of all the teeth used for it will decrease by one. When the viability of at least one tooth becomes negative, the shark will have to see the dentist again. 

Unhappy, Valerie came back home, where a portion of crucians was waiting for her. For sure, the shark couldn't say no to her favourite meal, but she had no desire to go back to the dentist. That's why she decided to eat the maximum amount of crucians from the portion but so that the viability of no tooth becomes negative. 

As Valerie is not good at mathematics, she asked you to help her to find out the total amount of crucians that she can consume for dinner.

We should remind you that while eating one crucian Valerie uses exactly one row of teeth and the viability of each tooth from this row decreases by one.","The first line contains three integers *n*, *m*, *k* (1<=≤<=*m*<=≤<=*n*<=≤<=1000,<=0<=≤<=*k*<=≤<=106) — total amount of Valerie's teeth, amount of tooth rows and amount of crucians in Valerie's portion for dinner. Then follow *n* lines, each containing two integers: *r* (1<=≤<=*r*<=≤<=*m*) — index of the row, where belongs the corresponding tooth, and *c* (0<=≤<=*c*<=≤<=106) — its residual viability.

It's guaranteed that each tooth row has positive amount of teeth.",In the first line output the maximum amount of crucians that Valerie can consume for dinner.,"['4 3 18\n2 3\n1 2\n3 6\n2 3\n', '2 2 13\n1 13\n2 12\n']","['11\n', '13\n']",none,WRONG_ANSWER,"## my first python submission ... pretty easy though :P

m,n,k = map(int, input().split())

aa = [10000]*n

print(aa)

for i in range(m):
    a,b = map(int , input().split())
    aa[a-1] = min(aa[a-1], b)

print(min(sum(aa), k))

		 	  		    	 	   	  	 	 		   	","import collections

def findsubsegment(l, nums):
    freq_map = collections.Counter(nums)
    beauty = max(freq_map.items(), key=lambda x: x[1])[1]
    keys = {}
    if beauty == 1:
        return 1, 1  # If the beauty is 1, any single element will suffice

    # Mapping each number to its first and last occurrence
    for i in range(len(nums)):
        if nums[i] in keys:
            keys[nums[i]][1] = i  # Update last occurrence
        else:
            keys[nums[i]] = [i, i]  # Initialize first and last occurrence

    min_length = float('inf')
    result = (0, 0)

    # Finding the number that contributes to the beauty
    for num, (first, last) in keys.items():
        if freq_map[num] == beauty:
            length = last - first + 1
            if length < min_length:
                min_length = length
                result = (first + 1, last + 1)  # Store as 1-based indexing

    return result"
275,A,Lights Out,PROGRAMMING,['implementation'],"Lenny is playing a game on a 3<=×<=3 grid of lights. In the beginning of the game all lights are switched on. Pressing any of the lights will toggle it and all side-adjacent lights. The goal of the game is to switch all the lights off. We consider the toggling as follows: if the light was switched on then it will be switched off, if it was switched off then it will be switched on.

Lenny has spent some time playing with the grid and by now he has pressed each light a certain number of times. Given the number of times each light is pressed, you have to print the current state of each light.",The input consists of three rows. Each row contains three integers each between 0 to 100 inclusive. The *j*-th number in the *i*-th row is the number of times the *j*-th light of the *i*-th row of the grid is pressed.,"Print three lines, each containing three characters. The *j*-th character of the *i*-th line is ""1"" if and only if the corresponding light is switched on, otherwise it's ""0"".","['1 0 0\n0 0 0\n0 0 1\n', '1 0 1\n8 8 8\n2 0 3\n']","['001\n010\n100\n', '010\n011\n100\n']",none,WRONG_ANSWER,"grid = [[1, 1, 1] for _ in range(3)]

for i in range(3):
    inp = list(map(int, input().split()))
    for j in range(3):
        if inp[j]&1:
            grid[i][j] ^= 1
            if i-1 > 0:
                grid[i-1][j] ^= 1
            if j-1 > 0:
                grid[i][j-1] ^= 1
            if i+1 < 3:
                grid[i+1][j] ^= 1
            if j+1 < 3:
                grid[i][j+1] ^= 1
for i in grid:
    print(*i)","import math

# Input the dimensions of the square and the size of the flagstone
n, m, a = map(int, input().split())

# Calculate the number of flagstones needed for length and width
num_flagstones_length = math.ceil(n / a)
num_flagstones_width = math.ceil(m / a)

# Calculate the total number of flagstones needed
total_flagstones = num_flagstones_length * num_flagstones_width

# Output the total number of flagstones needed
print(total_flagstones)"
709,A,Juicer,PROGRAMMING,['implementation'],"Kolya is going to make fresh orange juice. He has *n* oranges of sizes *a*1,<=*a*2,<=...,<=*a**n*. Kolya will put them in the juicer in the fixed order, starting with orange of size *a*1, then orange of size *a*2 and so on. To be put in the juicer the orange must have size not exceeding *b*, so if Kolya sees an orange that is strictly greater he throws it away and continues with the next one.

The juicer has a special section to collect waste. It overflows if Kolya squeezes oranges of the total size strictly greater than *d*. When it happens Kolya empties the waste section (even if there are no more oranges) and continues to squeeze the juice. How many times will he have to empty the waste section?","The first line of the input contains three integers *n*, *b* and *d* (1<=≤<=*n*<=≤<=100<=000, 1<=≤<=*b*<=≤<=*d*<=≤<=1<=000<=000) — the number of oranges, the maximum size of the orange that fits in the juicer and the value *d*, which determines the condition when the waste section should be emptied.

The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=1<=000<=000) — sizes of the oranges listed in the order Kolya is going to try to put them in the juicer.",Print one integer — the number of times Kolya will have to empty the waste section.,"['2 7 10\n5 6\n', '1 5 10\n7\n', '3 10 10\n5 7 7\n', '1 1 1\n1\n']","['1\n', '0\n', '1\n', '0\n']","In the first sample, Kolya will squeeze the juice from two oranges and empty the waste section afterwards.

In the second sample, the orange won't fit in the juicer so Kolya will have no juice at all.",WRONG_ANSWER,"n,b,d=map(int,input().split())
m=list(map(int,input().split()))
sum=0
for i in m:
    if i <= b:
        sum+=i
print(sum//10)
","import sys
input = lambda: sys.stdin.readline().rstrip()
from collections import deque, defaultdict, Counter
from itertools import permutations, combinations
from bisect import *
from heapq import *

# Read input values
n, k = map(int, input().split())

# Create a set to store distinct remainders
remainders = set()

# Check remainders for all integers i from 1 to k
for i in range(1, k + 1):
    remainder = n % i  # Calculate remainder of n divided by i
    if remainder in remainders:
        print(""No"")  # Remainder is not distinct
        break
    remainders.add(remainder)
else:
    print(""Yes"")  # All remainders are distinct"
988,A,Diverse Team,PROGRAMMING,"['brute force', 'implementation']","There are $n$ students in a school class, the rating of the $i$-th student on Codehorses is $a_i$. You have to form a team consisting of $k$ students ($1 \le k \le n$) such that the ratings of all team members are distinct.

If it is impossible to form a suitable team, print ""NO"" (without quotes). Otherwise print ""YES"", and then print $k$ distinct numbers which should be the indices of students in the team you form. If there are multiple answers, print any of them.","The first line contains two integers $n$ and $k$ ($1 \le k \le n \le 100$) — the number of students and the size of the team you have to form.

The second line contains $n$ integers $a_1, a_2, \dots, a_n$ ($1 \le a_i \le 100$), where $a_i$ is the rating of $i$-th student.","If it is impossible to form a suitable team, print ""NO"" (without quotes). Otherwise print ""YES"", and then print $k$ distinct integers from $1$ to $n$ which should be the indices of students in the team you form. All the ratings of the students in the team should be distinct. You may print the indices in any order. If there are multiple answers, print any of them.

Assume that the students are numbered from $1$ to $n$.","['5 3\n15 13 15 15 12\n', '5 4\n15 13 15 15 12\n', '4 4\n20 10 40 30\n']","['YES\n1 2 5 \n', 'NO\n', 'YES\n1 2 3 4 \n']","All possible answers for the first example: 
 -  {1 2 5} -  {2 3 5} -  {2 4 5} 
Note that the order does not matter.",OK,"n,k = map(int,input().split())
a = list(map(int,input().split()))
d = a.copy()
a = list(set(a))
if len(a) < k:
    print(""NO"")
else:
    print(""YES"")
    for i in a[:k]:
        print(d.index(i)+1, end = "" "")
","values = [int(val) for val in input().split()]
a = values[0]
b = values[1]
n = values[2]

def gcd(x, y):
    while y:
        x, y = y, x % y
    return x

# Simon starts the game
turn = 0  # 0 for Simon, 1 for Antisimon
while True:
    if turn == 0:  # Simon's turn
        stones_to_take = gcd(a, n)
    else:  # Antisimon's turn
        stones_to_take = gcd(b, n)
    
    if stones_to_take > n:  # check if the player can take stones
        print(turn)  # current player loses
        break
    
    n -= stones_to_take  # reduce the number of stones
    turn = 1 - turn  # switch turns"
510,A,Fox And Snake,PROGRAMMING,['implementation'],"Fox Ciel starts to learn programming. The first task is drawing a fox! However, that turns out to be too hard for a beginner, so she decides to draw a snake instead.

A snake is a pattern on a *n* by *m* table. Denote *c*-th cell of *r*-th row as (*r*,<=*c*). The tail of the snake is located at (1,<=1), then it's body extends to (1,<=*m*), then goes down 2 rows to (3,<=*m*), then goes left to (3,<=1) and so on.

Your task is to draw this snake for Fox Ciel: the empty cells should be represented as dot characters ('.') and the snake cells should be filled with number signs ('#').

Consider sample tests in order to understand the snake pattern.","The only line contains two integers: *n* and *m* (3<=≤<=*n*,<=*m*<=≤<=50). 

*n* is an odd number.",Output *n* lines. Each line should contain a string consisting of *m* characters. Do not output spaces.,"['3 3\n', '3 4\n', '5 3\n', '9 9\n']","['###\n..#\n###\n', '####\n...#\n####\n', '###\n..#\n###\n#..\n###\n', '#########\n........#\n#########\n#........\n#########\n........#\n#########\n#........\n#########\n']",none,OK,"def Fox_and_Snake(r,c):
    next_ = 3
    next_2 = 1
    for i in range(r):
        for j in range(c):
            if i %2 == 0:
                print('#', end = '')
            else:
                if i == next_2 and j == (c-1):
                    print('#', end = '')
                    next_2 +=4
                elif i == next_ and j ==0:
                    print('#', end = '')
                    next_ +=4
                else :
                    print('.', end = '')
        print()
        
r, c = map( int, input().split())

Fox_and_Snake(r,c)","def Diff(li1, li2, x):
    li_dif = [i for i in li1 + li2 if i not in li1 or i not in li2]
    if len(li_dif) == n * n:
        return x

n = int(input())  # Number of vertical and horizontal roads
intersections = [tuple(map(int, input().split())) for _ in range(n * n)]  # Read intersections
asphalted_horizontal = set()  # Set to keep track of asphalted horizontal roads
asphalted_vertical = set()  # Set to keep track of asphalted vertical roads
working_days = []  # List to store the days work is done

for day, (h, v) in enumerate(intersections, start=1):
    # Check if either road has already been asphalted
    if h not in asphalted_horizontal and v not in asphalted_vertical:
        asphalted_horizontal.add(h)  # Asphalt horizontal road
        asphalted_vertical.add(v)     # Asphalt vertical road
        working_days.append(day)      # Record the day work was done

# Print the days when work was done
print("" "".join(map(str, working_days)))"
618,A,Slime Combining,PROGRAMMING,['implementation'],"Your friend recently gave you some slimes for your birthday. You have *n* slimes all initially with value 1.

You are going to play a game with these slimes. Initially, you put a single slime by itself in a row. Then, you will add the other *n*<=-<=1 slimes one by one. When you add a slime, you place it at the right of all already placed slimes. Then, while the last two slimes in the row have the same value *v*, you combine them together to create a slime with value *v*<=+<=1.

You would like to see what the final state of the row is after you've added all *n* slimes. Please print the values of the slimes in the row from left to right.","The first line of the input will contain a single integer, *n* (1<=≤<=*n*<=≤<=100<=000).","Output a single line with *k* integers, where *k* is the number of slimes in the row after you've finished the procedure described in the problem statement. The *i*-th of these numbers should be the value of the *i*-th slime from the left.","['1\n', '2\n', '3\n', '8\n']","['1\n', '2\n', '2 1\n', '4\n']","In the first sample, we only have a single slime with value 1. The final state of the board is just a single slime with value 1.

In the second sample, we perform the following steps:

Initially we place a single slime in a row by itself. Thus, row is initially 1.

Then, we will add another slime. The row is now 1 1. Since two rightmost slimes have the same values, we should replace these slimes with one with value 2. Thus, the final state of the board is 2.

In the third sample, after adding the first two slimes, our row is 2. After adding one more slime, the row becomes 2 1.

In the last sample, the steps look as follows: 
 1.  1 1.  2 1.  2 1 1.  3 1.  3 1 1.  3 2 1.  3 2 1 1.  4",OK,"N = int(input())
ans = []
i = 0

while N >> i:
    if (N >> i) & 1:
        ans.append(i + 1)
    i += 1
    
print(*ans[::-1])","def generate_num(loops):
    if loops not in range(1, 1000000): 
        return -1
    
    # Mapping of digits to their respective loop counts
    loop_counts = {
        '0': 1, '1': 0, '2': 0, '3': 0,
        '4': 1, '5': 0, '6': 1, '7': 0,
        '8': 2, '9': 1
    }
    
    # Create an empty number string
    num = """"
    
    # Generate the number to match the required loops
    while loops > 0:
        # Check for the digit with the maximum loops that is <= 1018
        if loops >= 2 and loops == 2:
            # Add digit '8' if we need exactly 2 loops
            num += '8'
            loops -= 2
        elif loops >= 1:
            # Use digit '0', '4', '6', or '9' if we need 1 loop
            num += '8' if loops >= 2 else '0'  # '0' has 1 loop, but makes initial number non-zero
            loops -= 1
            
    # If we haven't satisfied the loop count, return -1
    if loops > 0:
        return -1
    
    # Ensure n is a valid positive integer and doesn't exceed 10^18
    if num == """":
        return -1
    
    # Output must be a positive decimal integer
    result = int(num)
    return result if result <= 10**18 else -1"
242,B,Big Segment,PROGRAMMING,"['implementation', 'sortings']","A coordinate line has *n* segments, the *i*-th segment starts at the position *l**i* and ends at the position *r**i*. We will denote such a segment as [*l**i*,<=*r**i*].

You have suggested that one of the defined segments covers all others. In other words, there is such segment in the given set, which contains all other ones. Now you want to test your assumption. Find in the given set the segment which covers all other segments, and print its number. If such a segment doesn't exist, print -1.

Formally we will assume that segment [*a*,<=*b*] covers segment [*c*,<=*d*], if they meet this condition *a*<=≤<=*c*<=≤<=*d*<=≤<=*b*.","The first line contains integer *n* (1<=≤<=*n*<=≤<=105) — the number of segments. Next *n* lines contain the descriptions of the segments. The *i*-th line contains two space-separated integers *l**i*,<=*r**i* (1<=≤<=*l**i*<=≤<=*r**i*<=≤<=109) — the borders of the *i*-th segment.

It is guaranteed that no two segments coincide.","Print a single integer — the number of the segment that covers all other segments in the set. If there's no solution, print -1.

The segments are numbered starting from 1 in the order in which they appear in the input.","['3\n1 1\n2 2\n3 3\n', '6\n1 5\n2 3\n1 10\n7 10\n7 7\n10 10\n']","['-1\n', '3\n']",none,TIME_LIMIT_EXCEEDED,"a = []
b = []
def allseg(a,b):
    result = -1
    min_a = min(a)
    max_b = max(b)
    x = find_all(min_a,a)
    y = find_all(max_b,b)
    for i in range (len(x)):
        if x[i] in y:
            result = x[i]+1
            break
    return result

def find_all(n,str):
    result = []
    for i in range (len(str)):
        if str[i] == n:
            result.append(i)
    return result

t = int(input())
for i in range (t):
    seg = input().split()
    a.append(int(seg[0]))
    b.append(int(seg[1]))
result = allseg(a,b)
print (result)
","def p(x):
    if '8' in x:
        return True
    return False

def min_steps_to_lucky_floor(a):
    b = 1  # Start with the first step
    while True:
        if p(str(a + b)):  # Check if the floor number is lucky
            return b  # Return the minimum positive integer b
        b += 1  # Increment b to check the next floor

a = int(input().strip())  # Read the input value
print(min_steps_to_lucky_floor(a))  # Output the minimum b"
805,B,3-palindrome,PROGRAMMING,['constructive algorithms'],"In the beginning of the new year Keivan decided to reverse his name. He doesn't like palindromes, so he changed Naviek to Navick.

He is too selfish, so for a given *n* he wants to obtain a string of *n* characters, each of which is either 'a', 'b' or 'c', with no palindromes of length 3 appearing in the string as a substring. For example, the strings ""abc"" and ""abca"" suit him, while the string ""aba"" doesn't. He also want the number of letters 'c' in his string to be as little as possible.",The first line contains single integer *n* (1<=≤<=*n*<=≤<=2·105) — the length of the string.,"Print the string that satisfies all the constraints.

If there are multiple answers, print any of them.","['2\n', '3\n']","['aa\n', 'bba\n']",A palindrome is a sequence of characters which reads the same backward and forward.,WRONG_ANSWER,"n=int(input())
s='abc'*(n//3)
r=n%3
if(r==1):
    s+='a'
elif(r==2):
    s+='ab'    
print(s)
    ","st = input()

# Initialize a list to store the decoded digits
decoded_digits = []
# Iterate through each character in the input string
i = 0
while i < len(st):
    if st[i] == '.':
        # If the character is '.', append '0' to the result
        decoded_digits.append('0')
        i += 1
    elif st[i] == '-':
        # If the character is '-', check the next character
        if i + 1 < len(st) and st[i + 1] == '.':
            # If the next character is '.', append '1' to the result
            decoded_digits.append('1')
            i += 2
        elif i + 1 < len(st) and st[i + 1] == '-':
            # If the next character is '-', append '2' to the result
            decoded_digits.append('2')
            i += 2

# Join the list of decoded digits into a single string and print it
print(''.join(decoded_digits))"
