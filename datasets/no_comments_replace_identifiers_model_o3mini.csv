contestId,index,name,type,tags,problem-description,input-specification,output-specification,demo-input,demo-output,note,verdict,code,ai_generated_code
604,A,Uncowed Forces,PROGRAMMING,['implementation'],"Kevin Sun has just finished competing in Codeforces Round #334! The round was 120 minutes long and featured five problems with maximum point values of 500, 1000, 1500, 2000, and 2500, respectively. Despite the challenging tasks, Kevin was uncowed and bulldozed through all of them, distinguishing himself from the herd as the best cowmputer scientist in all of Bovinia. Kevin knows his submission time for each problem, the number of wrong submissions that he made on each problem, and his total numbers of successful and unsuccessful hacks. Because Codeforces scoring is complicated, Kevin wants you to write a program to compute his final score.

Codeforces scores are computed as follows: If the maximum point value of a problem is *x*, and Kevin submitted correctly at minute *m* but made *w* wrong submissions, then his score on that problem is . His total score is equal to the sum of his scores for each problem. In addition, Kevin's total score gets increased by 100 points for each successful hack, but gets decreased by 50 points for each unsuccessful hack.

All arithmetic operations are performed with absolute precision and no rounding. It is guaranteed that Kevin's final score is an integer.","The first line of the input contains five space-separated integers *m*1, *m*2, *m*3, *m*4, *m*5, where *m**i* (0<=≤<=*m**i*<=≤<=119) is the time of Kevin's last submission for problem *i*. His last submission is always correct and gets accepted.

The second line contains five space-separated integers *w*1, *w*2, *w*3, *w*4, *w*5, where *w**i* (0<=≤<=*w**i*<=≤<=10) is Kevin's number of wrong submissions on problem *i*.

The last line contains two space-separated integers *h**s* and *h**u* (0<=≤<=*h**s*,<=*h**u*<=≤<=20), denoting the Kevin's numbers of successful and unsuccessful hacks, respectively.","Print a single integer, the value of Kevin's final score.","['20 40 60 80 100\n0 1 2 3 4\n1 0\n', '119 119 119 119 119\n0 0 0 0 0\n10 0\n']","['4900\n', '4930\n']","In the second sample, Kevin takes 119 minutes on all of the problems. Therefore, he gets <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/42158dc2bc78cd21fa679530ae9ef8b9ea298d15.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> of the points on each problem. So his score from solving problems is <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/fdf392d8508500b57f8057ac0c4c892ab5f925a2.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>. Adding in 10·100 = 1000 points from hacks, his total score becomes 3930 + 1000 = 4930.",OK,"def b(x,m,w):
    t=(1-(m/250))*x - (50*w)
    return max(0.3*x,t)

c=[500,1000,1500,2000,2500]
m=list(map(int, input().split()))
w=list(map(int, input().split()))
s,u=map(int,input().split())

a=0

for i in range(5):
    a+=b(c[i],m[i],w[i])
a+=(100*s)
a-=(50*u)
print(int(a))","""""""
This script finds the maximum permutation of the digits of a given number a 
that does not exceed another given number b.
The resulting number must use all digits of a exactly once and cannot have leading zeros.
""""""

def m():
    import u
    u.setrecursionlimit(10000)
    g = u.stdin.read().split()
    if not g:
        return
    a = g[0].strip()
    c = g[1].strip()
    n = len(a)

    if len(a) < len(c):

        b = ''.join(sorted(a, reverse=True))
        u.stdout.write(b)
        return

    f = [0] * 10
    for e in a:
        f[int(e)] += 1

    n = {}

    def i(f):
        """"""
        Greedily returns the maximum number (as a string) that can be formed 
        from the remaining digits by arranging them in descending order.
        """"""
        q = []
        for d in range(9, -1, -1):
            if f[d]:
                q.append(str(d) * f[d])
        return """".join(q)

    def h(p, j, f):
        """"""
        Recursively constructs the answer.
        
        pos: current digit position to fill.
        is_equal: a boolean flag indicating whether the constructed prefix is equal 
                  to the corresponding prefix of b_str.
        counts: current available frequency of each digit.
        
        Returns a string representing the suffix from the current position that forms 
        a valid permutation or None if not possible.
        """"""
        if p == n:
            return """"
        k = (p, j, tuple(f))
        if k in n:
            return n[k]

        l = int(c[p]) if j else 9

        for d in range(9, -1, -1):
            if f[d] == 0:
                continue

            if p == 0 and d == 0:
                continue

            if j and d > l:
                continue

            f[d] -= 1

            o = j and (d == l)
            if not o:

                t = i(f)
                d = str(d) + t
                f[d] += 1
                n[k] = d
                return d
            else:

                s = h(p + 1, True, f)
                if s is not None:
                    d = str(d) + s
                    f[d] += 1
                    n[k] = d
                    return d
            f[d] += 1
        
        n[k] = None
        return None

    r = h(0, True, f)
    u.stdout.write(r)

if __name__ == '__main__':
    m()"
322,B,Ciel and Flowers,PROGRAMMING,"['combinatorics', 'math']","Fox Ciel has some flowers: *r* red flowers, *g* green flowers and *b* blue flowers. She wants to use these flowers to make several bouquets. There are 4 types of bouquets:
 -  To make a ""red bouquet"", it needs 3 red flowers. -  To make a ""green bouquet"", it needs 3 green flowers. -  To make a ""blue bouquet"", it needs 3 blue flowers. -  To make a ""mixing bouquet"", it needs 1 red, 1 green and 1 blue flower. 
Help Fox Ciel to find the maximal number of bouquets she can make.","The first line contains three integers *r*, *g* and *b* (0<=≤<=*r*,<=*g*,<=*b*<=≤<=109) — the number of red, green and blue flowers.",Print the maximal number of bouquets Fox Ciel can make.,"['3 6 9\n', '4 4 4\n', '0 0 0\n']","['6\n', '4\n', '0\n']","In test case 1, we can make 1 red bouquet, 2 green bouquets and 3 blue bouquets.

In test case 2, we can make 1 red, 1 green, 1 blue and 1 mixing bouquet.",OK,"def f(x): return x // 3

r, g, b = map(int, input().split())
m = min(r, g, b)
a = 0
for i in range(max(0, m - 30), m + 1):
    a = max(a, i + f(r - i) + f(g - i) + f(b - i))
print(a)","import g

def e():

    c = g.stdin.read().strip().split()
    if not c:
        return

    n = int(c[0])

    b = [[] for _ in range(n + 1)]

    for i in range(2, n + 1):

        f = int(c[i - 1])

        b[f].append(i)

    for i in range(1, n + 1):

        if not b[i]:
            continue

        d = 0
        for a in b[i]:
            if not b[a]:
                d += 1

        if d < 3:
            g.stdout.write(""No\n"")
            return

    g.stdout.write(""Yes\n"")

if __name__ == ""__main__"":
    e()"
808,D,Array Division,PROGRAMMING,"['binary search', 'data structures', 'implementation']","Vasya has an array *a* consisting of positive integer numbers. Vasya wants to divide this array into two non-empty consecutive parts (the prefix and the suffix) so that the sum of all elements in the first part equals to the sum of elements in the second part. It is not always possible, so Vasya will move some element before dividing the array (Vasya will erase some element and insert it into an arbitrary position).

Inserting an element in the same position he was erased from is also considered moving.

Can Vasya divide the array after choosing the right element to move and its new position?","The first line contains single integer *n* (1<=≤<=*n*<=≤<=100000) — the size of the array.

The second line contains *n* integers *a*1,<=*a*2... *a**n* (1<=≤<=*a**i*<=≤<=109) — the elements of the array.",Print YES if Vasya can divide the array after moving one element. Otherwise print NO.,"['3\n1 3 2\n', '5\n1 2 3 4 5\n', '5\n2 2 3 4 5\n']","['YES\n', 'NO\n', 'YES\n']","In the first example Vasya can move the second element to the end of the array.

In the second example no move can make the division possible.

In the third example Vasya can move the fourth element by one position to the left.",OK,"n = int(input())
a = list(map(int, input().split()))
def f(n, a):
    s = sum(a)
    if n == 1 or s & 1:
        print('NO')
        return
    b = s // 2
    def c(a):
        e, g = 0, {0}
        for d in a:
            g.add(d)
            e += d
            if e - b in g: return True
        return False
    print('YES' if c(a) or c(a[::-1]) else 'NO')

f(n, a)","def b(a, i, j):
    """"""
    Place an 'X' temporarily at position (i, j) and check all four directions
    (horizontal, vertical, and two diagonals) for a contiguous line of 5 'X's.
    """"""
    a[i][j] = 'X'

    d = [(0, 1), (1, 0), (1, 1), (1, -1)]
    
    for e, f in d:
        c = 1

        x, y = i + e, j + f
        while 0 <= x < 10 and 0 <= y < 10 and a[x][y] == 'X':
            c += 1
            x += e
            y += f

        x, y = i - e, j - f
        while 0 <= x < 10 and 0 <= y < 10 and a[x][y] == 'X':
            c += 1
            x -= e
            y -= f
        
        if c >= 5:
            a[i][j] = '.'
            return True

    a[i][j] = '.'
    return False

def i():
    import j

    h = [g.strip() for g in j.stdin if g.strip()]

    a = [list(g) for g in h]

    for i in range(10):
        for j in range(10):
            if a[i][j] == '.':
                if b(a, i, j):
                    print(""YES"")
                    return
    print(""NO"")

if __name__ == ""__main__"":
    i()"
982,E,Billiard,PROGRAMMING,"['geometry', 'number theory']","Consider a [billiard table](https://en.wikipedia.org/wiki/Billiard_table) of rectangular size $n \times m$ with four pockets. Let's introduce a coordinate system with the origin at the lower left corner (see the picture). 

There is one ball at the point $(x, y)$ currently. Max comes to the table and strikes the ball. The ball starts moving along a line that is parallel to one of the axes or that makes a $45^{\circ}$ angle with them. We will assume that: 
 1.  the angles between the directions of the ball before and after a collision with a side are equal, 1.  the ball moves indefinitely long, it only stops when it falls into a pocket, 1.  the ball can be considered as a point, it falls into a pocket if and only if its coordinates coincide with one of the pockets, 1.  initially the ball is not in a pocket. 
Note that the ball can move along some side, in this case the ball will just fall into the pocket at the end of the side.

Your task is to determine whether the ball will fall into a pocket eventually, and if yes, which of the four pockets it will be.","The only line contains $6$ integers $n$, $m$, $x$, $y$, $v_x$, $v_y$ ($1 \leq n, m \leq 10^9$, $0 \leq x \leq n$; $0 \leq y \leq m$; $-1 \leq v_x, v_y \leq 1$; $(v_x, v_y) \neq (0, 0)$) — the width of the table, the length of the table, the $x$-coordinate of the initial position of the ball, the $y$-coordinate of the initial position of the ball, the $x$-component of its initial speed and the $y$-component of its initial speed, respectively. It is guaranteed that the ball is not initially in a pocket.","Print the coordinates of the pocket the ball will fall into, or $-1$ if the ball will move indefinitely.","['4 3 2 2 -1 1\n', '4 4 2 0 1 1\n', '10 10 10 1 -1 0\n']","['0 0', '-1', '-1']","The first sample: 

The second sample: 

In the third sample the ball will never change its $y$ coordinate, so the ball will never fall into a pocket.",RUNTIME_ERROR,"from sys import c
from math import r

def a(n, m, x, y, s, t):
    if s == 0:
        if t == 0:
            return -1            
                    
        if x == 0:
            
            if t > 0:
                return 0, n
            
            elif t < 0:
                return 0, 0
            
        elif x == m:
            
            if t > 0:
                return m, 0
            
            elif t < 0:
                return m, n
        else: 
            return -1
            
    if t == 0:
        if y == 0:
            
            if s > 0:
                return m, 0
            
            elif s < 0:
                return 0, 0
            
        elif y == n:
            
            if s > 0:
                return m, n
            
            elif s < 0:
                return 0, n
            
        else:
            return -1

    p = t/s
    r = y - p * x

    d, f, h = b(m, abs(-n * p))

    if r % d != 0:
        return -1

    f = f * r / d 
    h = h * r / d

    m, n = -2**10, -2**10
    o, p = 2**10, 2**10  

    if s > 0:
        o = (h / m) * d
    else:
        m = ((h - 1) / m) * d

    if t > 0:
        p = (f / (n * p)) * d
    else:
        n = ((f - 1) / (n * p)) * d
        
    t = 0    

    if s == t:
        if t > 0: 
            t = min(r(p), r(o))
            
        else:
            t = max(r(m), r(n))
                    
        d  = t
        g = 0
        l = True
            
        while(l):
            g = h - (m/d) * t
                
            if (abs(g) > (abs(h - (m/d) * d))):
                l = False
                t = d
            else:
                d = t
                t = t - 1
                
    else:
        m = max(r(m), r(n))
        o = min(r(p), r(o))
        
        for i in range(0, (o + 1 - m) // 2):
            i = h - (m/d) * (m + i)
            j = h - (m/d) * (o + 1 - i)

            if abs(i) < abs(d):
                d = i
                t = m + i
            elif abs(j) < abs(d):
                d = j
                t = o + 1 - i   
        g = g = h - (m/d) * t

    e = f - (n* p * t) / d

    return (g % 2) * m, (e % 2) * n    
    
    
def b(a, b):
    if b > a:
        q = a
        a = b
        b = q
    
    r = a % b   
    if r == 0:
        return b, 1, 0
    
    d, u, v = b(b, a % b)

    x = v - (u * r(a/b))
    y = u
    
    return d, x, y

def k():
    _, n, m, x, y, s, t = c
    print(a(int(n), int(m), int(x), int(y), int(s), int(t)))
    
k()","import h

def b(n, f):

    i = [1] * n
    a = True

    while a:
        a = False

        for i in range(n - 1):
            if f[i] == 'R':

                if i[i+1] <= i[i]:
                    i[i+1] = i[i] + 1
                    a = True
            elif f[i] == '=':

                if i[i+1] != i[i]:
                    i[i+1] = i[i]
                    a = True

        for i in range(n - 2, -1, -1):
            if f[i] == 'L':

                if i[i] <= i[i+1]:
                    i[i] = i[i+1] + 1
                    a = True
            elif f[i] == '=':

                if i[i] != i[i+1]:
                    i[i] = i[i+1]
                    a = True

        for i in range(n - 1):
            if f[i] == 'R':
                if i[i+1] <= i[i]:
                    i[i+1] = i[i] + 1
                    a = True
            elif f[i] == '=':
                if i[i+1] != i[i]:
                    i[i+1] = i[i]
                    a = True

    return i

def d():

    c = h.stdin.read().splitlines()
    if not c:
        return

    e = c[0].strip()
    if not e:
        return
    n = int(e)

    if len(c) < 2:
        return
    f = c[1].strip()

    f = f[:n-1]

    g = b(n, f)

    print("" "".join(map(str, g)))

if __name__ == ""__main__"":
    d()"
733,D,Kostya the Sculptor,PROGRAMMING,"['data structures', 'hashing']","Kostya is a genial sculptor, he has an idea: to carve a marble sculpture in the shape of a sphere. Kostya has a friend Zahar who works at a career. Zahar knows about Kostya's idea and wants to present him a rectangular parallelepiped of marble from which he can carve the sphere. 

Zahar has *n* stones which are rectangular parallelepipeds. The edges sizes of the *i*-th of them are *a**i*, *b**i* and *c**i*. He can take no more than two stones and present them to Kostya. 

If Zahar takes two stones, he should glue them together on one of the faces in order to get a new piece of rectangular parallelepiped of marble. Thus, it is possible to glue a pair of stones together if and only if two faces on which they are glued together match as rectangles. In such gluing it is allowed to rotate and flip the stones in any way. 

Help Zahar choose such a present so that Kostya can carve a sphere of the maximum possible volume and present it to Zahar.","The first line contains the integer *n* (1<=≤<=*n*<=≤<=105).

*n* lines follow, in the *i*-th of which there are three integers *a**i*,<=*b**i* and *c**i* (1<=≤<=*a**i*,<=*b**i*,<=*c**i*<=≤<=109) — the lengths of edges of the *i*-th stone. Note, that two stones may have exactly the same sizes, but they still will be considered two different stones.","In the first line print *k* (1<=≤<=*k*<=≤<=2) the number of stones which Zahar has chosen. In the second line print *k* distinct integers from 1 to *n* — the numbers of stones which Zahar needs to choose. Consider that stones are numbered from 1 to *n* in the order as they are given in the input data.

You can print the stones in arbitrary order. If there are several answers print any of them.","['6\n5 5 5\n3 2 4\n1 4 1\n2 1 3\n3 2 4\n3 3 4\n', '7\n10 7 8\n5 10 3\n4 2 6\n5 5 5\n10 2 8\n4 2 1\n7 7 7\n']","['1\n1\n', '2\n1 5\n']","In the first example we can connect the pairs of stones:
 -  2 and 4, the size of the parallelepiped: 3 × 2 × 5, the radius of the inscribed sphere 1 -  2 and 5, the size of the parallelepiped: 3 × 2 × 8 or 6 × 2 × 4 or 3 × 4 × 4, the radius of the inscribed sphere 1, or 1, or 1.5 respectively. -  2 and 6, the size of the parallelepiped: 3 × 5 × 4, the radius of the inscribed sphere 1.5 -  4 and 5, the size of the parallelepiped: 3 × 2 × 5, the radius of the inscribed sphere 1 -  5 and 6, the size of the parallelepiped: 3 × 4 × 5, the radius of the inscribed sphere 1.5 
Or take only one stone:
 -  1 the size of the parallelepiped: 5 × 5 × 5, the radius of the inscribed sphere 2.5 -  2 the size of the parallelepiped: 3 × 2 × 4, the radius of the inscribed sphere 1 -  3 the size of the parallelepiped: 1 × 4 × 1, the radius of the inscribed sphere 0.5 -  4 the size of the parallelepiped: 2 × 1 × 3, the radius of the inscribed sphere 0.5 -  5 the size of the parallelepiped: 3 × 2 × 4, the radius of the inscribed sphere 1 -  6 the size of the parallelepiped: 3 × 3 × 4, the radius of the inscribed sphere 1.5 
It is most profitable to take only the first stone.",RUNTIME_ERROR,"class a:
    def __init__(q, f=2, l=1453):
        q.f = f
        q.l = l
        q.table = []

    def b(q, r):
        p = q.table
        for i in range(q.f-1):
            if len(p) == 0:
                p.extend([[] for i in range(q.l)])
            d = r[i] % q.l
            p = p[d]

        d = r[q.f-1] % q.l
        if len(p) == 0:
            p.extend([[] for i in range(q.l)])
        p[d].append(r)

    def i(q, r):
        p = q.table
        f = 0
        while f < q.f and len(p) > 0:
            d = r[f] % q.l
            p = p[d]
            f += 1

        if f < q.f or len(p) == 0:
            return None

        k = 0
        c = None
        d = 0

        for e in p:
            while d < q.f and e[d] == r[d]:
                d += 1
            if d < q.f:
                break
            if k < e[d]:
                k = e[d]
                c = e                

        return c

if __name__ == '__main__':

    g = a()

    h = open('input.txt', ""r"")

    n = int(input())
    j = 0
    m = [0]

    for i in range(1, n+1):

        r = sorted(list(map(int, input().split())),
                     reverse=True) + [i]
        c = g.i(r)

        if c is not None:
            r[2] += c[2]
            o = min(r[:-1])
            if  o > j:
                m = [c[3], r[3]]
                j = o
        else:
            if r[2] > j:
                m = [r[3]]
                j = r[2]
        
        g.b(r)

    print(len(m), file=n)
    print("" "".join(map(str, m)), file=n)","def c():
    import e
    b = e.stdin.read().splitlines()

    n, m = map(int, b[0].split())

    f = set()

    for i in range(1, n + 1):

        d = list(map(int, b[i].split()))
        g = d[0]
        a = d[1:]

        f.update(a)

    if set(range(1, m + 1)) == f:
        print(""YES"")
    else:
        print(""NO"")

if __name__ == ""__main__"":
    c()"
50,A,Domino piling,PROGRAMMING,"['greedy', 'math']","You are given a rectangular board of *M*<=×<=*N* squares. Also you are given an unlimited number of standard domino pieces of 2<=×<=1 squares. You are allowed to rotate the pieces. You are asked to place as many dominoes as possible on the board so as to meet the following conditions:

1. Each domino completely covers two squares.

2. No two dominoes overlap.

3. Each domino lies entirely inside the board. It is allowed to touch the edges of the board.

Find the maximum number of dominoes, which can be placed under these restrictions.",In a single line you are given two integers *M* and *N* — board sizes in squares (1<=≤<=*M*<=≤<=*N*<=≤<=16).,"Output one number — the maximal number of dominoes, which can be placed.","['2 4\n', '3 3\n']","['4\n', '4\n']",none,OK,"m, n = list(map(int,input().split("" "")))
print(m*n//2)","def a():

    n = int(input().strip())

    b = (3 * n) // 2

    print(b)

if __name__ == ""__main__"":
    a()"
219,C,Color Stripe,PROGRAMMING,"['brute force', 'dp', 'greedy']","A colored stripe is represented by a horizontal row of *n* square cells, each cell is pained one of *k* colors. Your task is to repaint the minimum number of cells so that no two neighbouring cells are of the same color. You can use any color from 1 to *k* to repaint the cells.","The first input line contains two integers *n* and *k* (1<=≤<=*n*<=≤<=5·105; 2<=≤<=*k*<=≤<=26). The second line contains *n* uppercase English letters. Letter ""A"" stands for the first color, letter ""B"" stands for the second color and so on. The first *k* English letters may be used. Each letter represents the color of the corresponding cell of the stripe.",Print a single integer — the required minimum number of repaintings. In the second line print any possible variant of the repainted stripe.,"['6 3\nABBACC\n', '3 2\nBBB\n']","['2\nABCACA\n', '1\nBAB\n']",none,OK,"n, k = map(int, input().split())

s = list(input())

if k > 2:
    c = set(ord(""A"") + i for i in range(26))
    r = 0
    for i in range(1,len(s)):
        if s[i-1] == s[i]:
            r += 1
            if i + 1 < n:
                s[i] = ""A"" if ""A"" not in {s[i-1], s[i+1]} else ('B' if ""B"" not in {s[i], s[i+1]} else ""C"")
            else:
                s[i] = ""A"" if s[i-1] != ""A"" else ""B""
    
    print(r)
    print("""".join(s))

else:
    x, y = ""AB"" * n, ""BA"" * n
    def a(x, y):
        return sum(x[i] != y[i] for i in range(n))
    b = a(x, s)
    c = a(y, s)
    z = [x,y][b > c]
    print(min(b, c))
    print(z[:n])","def d():

    n, p, q = map(int, input().split())
    s = input().strip()

    a = b = -1

    for a in range(n // p + 1):
        e = n - a * p
        if e % q == 0:
            b = e // q
            a, b = a, b
            break

    if a == -1:
        print(-1)
        return

    f = a + b
    print(f)

    c = 0
    for _ in range(a):

        print(s[c:c+p])
        c += p
    for _ in range(b):

        print(s[c:c+q])
        c += q

if __name__ == ""__main__"":
    d()"
337,A,Puzzles,PROGRAMMING,['greedy'],"The end of the school year is near and Ms. Manana, the teacher, will soon have to say goodbye to a yet another class. She decided to prepare a goodbye present for her *n* students and give each of them a jigsaw puzzle (which, as wikipedia states, is a tiling puzzle that requires the assembly of numerous small, often oddly shaped, interlocking and tessellating pieces).

The shop assistant told the teacher that there are *m* puzzles in the shop, but they might differ in difficulty and size. Specifically, the first jigsaw puzzle consists of *f*1 pieces, the second one consists of *f*2 pieces and so on.

Ms. Manana doesn't want to upset the children, so she decided that the difference between the numbers of pieces in her presents must be as small as possible. Let *A* be the number of pieces in the largest puzzle that the teacher buys and *B* be the number of pieces in the smallest such puzzle. She wants to choose such *n* puzzles that *A*<=-<=*B* is minimum possible. Help the teacher and find the least possible value of *A*<=-<=*B*.","The first line contains space-separated integers *n* and *m* (2<=≤<=*n*<=≤<=*m*<=≤<=50). The second line contains *m* space-separated integers *f*1,<=*f*2,<=...,<=*f**m* (4<=≤<=*f**i*<=≤<=1000) — the quantities of pieces in the puzzles sold in the shop.",Print a single integer — the least possible difference the teacher can obtain.,['4 6\n10 12 10 7 5 22\n'],['5\n'],"Sample 1. The class has 4 students. The shop sells 6 puzzles. If Ms. Manana buys the first four puzzles consisting of 10, 12, 10 and 7 pieces correspondingly, then the difference between the sizes of the largest and the smallest puzzle will be equal to 5. It is impossible to obtain a smaller difference. Note that the teacher can also buy puzzles 1, 3, 4 and 5 to obtain the difference 5.",WRONG_ANSWER,"def d(a: list):
    if len(a) <= 1:
        return a
    c = a[len(a)//2]
    a = [i for i in a if i < c]
    b = [i for i in a if i == c]
    f = [i for i in a if i > c]
    return d(a) + b + d(f)

n, m = [int(i) for i in input().split()]
a = [int(i) for i in input().split()]
a = d(a)

e = a[n - 1] - a[0]

for i in range(n, m):
    e = min(e, a[i - 1] - a[i - n])

print(e)","import c
import h

def b():

    i = h.stdin.read().split()
    if not i:
        return

    n = int(i[0])
    m = int(i[1])
    h = int(i[2])

    s = list(map(int, i[3:3+m]))

    j = sum(s)

    if j < n:
        print(-1)
        return

    g = n - 1

    a = s[h-1] - 1

    d = j - s[h-1]

    if g > d:
        f = 0
    else:

        k = c.comb(j - 1, g)

        l = c.comb(d, g)
        f = l / k

    e = 1 - f

    print(f""{e:.6f}"")

if __name__ == ""__main__"":
    b()"
660,D,Number of Parallelograms,PROGRAMMING,['geometry'],You are given *n* points on a plane. All the points are distinct and no three of them lie on the same line. Find the number of parallelograms with the vertices at the given points.,"The first line of the input contains integer *n* (1<=≤<=*n*<=≤<=2000) — the number of points.

Each of the next *n* lines contains two integers (*x**i*,<=*y**i*) (0<=≤<=*x**i*,<=*y**i*<=≤<=109) — the coordinates of the *i*-th point.",Print the only integer *c* — the number of parallelograms with the vertices at the given points.,['4\n0 1\n1 0\n1 1\n2 0\n'],['1\n'],none,TIME_LIMIT_EXCEEDED,"p = set()

def a(e,f,g):
    b = (
        e[0] + (f[0]-g[0]),
        e[1] + (f[1]-g[1])
    )
    if b in p: return 1
    c = (
        e[0] + (g[0]-f[0]),
        e[1] + (g[1]-f[1])
    )
    if c in p: return 1
    d = (
        g[0] + (f[0]-e[0]),
        g[1] + (f[1]-e[1])
    )
    if d in p: return 1
    return 0 

h = []
for i in range(int(input())):
    x,y  = map(int, input().split())
    p.add((x,y))
    h.append((x,y))

r = 0
for j in range(len(h)):
    for k in range(j+1,len(h)):
        for l in range(k+1,len(h)):

            if a(h[j],h[k],h[l]):
                r = r + 1

print(r//4)","def e():
    import h

    b = h.stdin.read().split()
    if not b:
        return

    n = int(b[0])
    g = []

    c = 1
    for _ in range(n):
        x = int(b[c])
        w = int(b[c + 1])
        c += 2
        g.append((x, w))

    g.sort(key=lambda f: f[0] + f[1])
    
    a = 0
    d = -10**18

    for x, w in g:

        if x - w >= d:
            a += 1

            d = x + w

    h.stdout.write(str(a))

if __name__ == ""__main__"":
    e()"
888,E,Maximum Subsequence,PROGRAMMING,"['bitmasks', 'divide and conquer', 'meet-in-the-middle']","You are given an array *a* consisting of *n* integers, and additionally an integer *m*. You have to choose some sequence of indices *b*1,<=*b*2,<=...,<=*b**k* (1<=≤<=*b*1<=&lt;<=*b*2<=&lt;<=...<=&lt;<=*b**k*<=≤<=*n*) in such a way that the value of  is maximized. Chosen sequence can be empty.

Print the maximum possible value of .","The first line contains two integers *n* and *m* (1<=≤<=*n*<=≤<=35, 1<=≤<=*m*<=≤<=109).

The second line contains *n* integers *a*1, *a*2, ..., *a**n* (1<=≤<=*a**i*<=≤<=109).",Print the maximum possible value of .,"['4 4\n5 2 4 1\n', '3 20\n199 41 299\n']","['3\n', '19\n']","In the first example you can choose a sequence *b* = {1, 2}, so the sum <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/c856546022c2feee13d02a4ec9cd1d361ab3a756.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> is equal to 7 (and that's 3 after taking it modulo 4).

In the second example you can choose a sequence *b* = {3}.",WRONG_ANSWER,"def c(e):
  a, b = 0, float('-inf')
  for d in e:
      a = max(d, a + d)
      b = max(b, a)
  return b","def l(d, i, m):

    e = 0
    f = m

    a = d.copy()

    while True:
        b = -1
        c = -1

        for i, (t, h, m) in enumerate(a):
            if t == f and h <= i and m > c:
                c = m
                b = i

        if b == -1:
            break

        i += a[b][2]
        e += 1
        del a[b]
        f = 1 - f
    
    return e

def j():
    import n

    g = n.stdin.read().strip().split()
    if not g:
        return
    n = int(g[0])
    i = int(g[1])
    d = []
    h = 2

    for _ in range(n):
        t = int(g[h])
        h = int(g[h + 1])
        m = int(g[h + 2])
        d.append((t, h, m))
        h += 3

    k = max(l(d, i, 0), l(d, i, 1))

    print(k)

if __name__ == '__main__':
    j()"
685,A,Robbers' watch,PROGRAMMING,"['brute force', 'combinatorics', 'dp', 'math']","Robbers, who attacked the Gerda's cab, are very successful in covering from the kingdom police. To make the goal of catching them even harder, they use their own watches.

First, as they know that kingdom police is bad at math, robbers use the positional numeral system with base 7. Second, they divide one day in *n* hours, and each hour in *m* minutes. Personal watches of each robber are divided in two parts: first of them has the smallest possible number of places that is necessary to display any integer from 0 to *n*<=-<=1, while the second has the smallest possible number of places that is necessary to display any integer from 0 to *m*<=-<=1. Finally, if some value of hours or minutes can be displayed using less number of places in base 7 than this watches have, the required number of zeroes is added at the beginning of notation.

Note that to display number 0 section of the watches is required to have at least one place.

Little robber wants to know the number of moments of time (particular values of hours and minutes), such that all digits displayed on the watches are distinct. Help her calculate this number.","The first line of the input contains two integers, given in the decimal notation, *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=109) — the number of hours in one day and the number of minutes in one hour, respectively.","Print one integer in decimal notation — the number of different pairs of hour and minute, such that all digits displayed on the watches are distinct.","['2 3\n', '8 2\n']","['4\n', '5\n']","In the first sample, possible pairs are: (0: 1), (0: 2), (1: 0), (1: 2).

In the second sample, possible pairs are: (02: 1), (03: 1), (04: 1), (05: 1), (06: 1).",WRONG_ANSWER,"from itertools import permutations as p
def f(n, d):
    if not n:
        return 1
    b = 0
    while n:
        d.append(n % 7)
        n //= 7
        b += 1
    return b
a = 0
d, c = [], []
n, m = map(int, input().split())
x, y = f(n, d), f(m, c)
d, c = tuple(d[::-1]), tuple(c[::-1])

s = {0, 1, 2, 3, 4, 5, 6}
if x + y > 7:
    exit(print(0))
for i in p(s, x):
    if i < d:
        for j in p(s - set(i), y):
            if j < c:
                a += 1
print(a)","import f
import j

def d(g):
    if g < 2:
        return False

    for i in range(2, int(f.sqrt(g)) + 1):
        if g % i == 0:
            return False
    return True

def e():

    c = j.stdin.read().strip().split()
    if not c:
        return
    n = int(c[0])
    k = int(c[1])

    i = []
    for h in range(2, n + 1):
        if d(h):
            i.append(h)

    b = 0
    for i in range(1, len(i)):
        a = i[i - 1] + i[i] + 1
        if a <= n and d(a):
            b += 1

    print(""YES"" if b >= k else ""NO"")

if __name__ == ""__main__"":
    e()"
731,A,Night at the Museum,PROGRAMMING,"['implementation', 'strings']","Grigoriy, like the hero of one famous comedy film, found a job as a night security guard at the museum. At first night he received embosser and was to take stock of the whole exposition.

Embosser is a special devise that allows to ""print"" the text of a plastic tape. Text is printed sequentially, character by character. The device consists of a wheel with a lowercase English letters written in a circle, static pointer to the current letter and a button that print the chosen letter. At one move it's allowed to rotate the alphabetic wheel one step clockwise or counterclockwise. Initially, static pointer points to letter 'a'. Other letters are located as shown on the picture:

After Grigoriy add new item to the base he has to print its name on the plastic tape and attach it to the corresponding exhibit. It's not required to return the wheel to its initial position with pointer on the letter 'a'.

Our hero is afraid that some exhibits may become alive and start to attack him, so he wants to print the names as fast as possible. Help him, for the given string find the minimum number of rotations of the wheel required to print it.",The only line of input contains the name of some exhibit — the non-empty string consisting of no more than 100 characters. It's guaranteed that the string consists of only lowercase English letters.,"Print one integer — the minimum number of rotations of the wheel, required to print the name given in the input.","['zeus\n', 'map\n', 'ares\n']","['18\n', '35\n', '34\n']","To print the string from the first sample it would be optimal to perform the following sequence of rotations: 
 1.  from 'a' to 'z' (1 rotation counterclockwise), 1.  from 'z' to 'e' (5 clockwise rotations), 1.  from 'e' to 'u' (10 rotations counterclockwise), 1.  from 'u' to 's' (2 counterclockwise rotations).",WRONG_ANSWER,"i = str(input())

def c(a, b):
    d = abs(ord(a)-ord(b))
    if d >= 13:
        f = 26-d
    else:
        f = d
    return f

def h(i):
    if not i.startswith('a'):
        i = 'a' + i
    e = list(i)
    g = 0
    for i in range(len(e)):
        if i == len(e) - 1:
            return g
        else:
            print(e[i], e[i+1])
            print(c(e[i], e[i+1]))
            g += c(e[i], e[i+1])
            
h(i)","import g
import math

def d():

    b = g.stdin.read().split()

    n = int(b[0])
    d = int(b[1])

    b = list(map(int, b[2:2+n]))

    e = [0] * n

    a = b[0]

    for i in range(1, n):

        f = a + 1 - b[i]
        if f <= 0:

            e[i] = 0
            a = b[i]
        else:

            c = (f + d - 1) // d
            e[i] = c

            a = b[i] + c * d

    h = sum(e)

    g.stdout.write(str(h) + ""\n"")
    
if __name__ == ""__main__"":
    d()"
801,B,Valued Keys,PROGRAMMING,"['constructive algorithms', 'greedy', 'strings']","You found a mysterious function *f*. The function takes two strings *s*1 and *s*2. These strings must consist only of lowercase English letters, and must be the same length.

The output of the function *f* is another string of the same length. The *i*-th character of the output is equal to the minimum of the *i*-th character of *s*1 and the *i*-th character of *s*2.

For example, *f*(""ab"", ""ba"") = ""aa"", and *f*(""nzwzl"", ""zizez"") = ""niwel"".

You found two strings *x* and *y* of the same length and consisting of only lowercase English letters. Find any string *z* such that *f*(*x*,<=*z*)<==<=*y*, or print -1 if no such string *z* exists.","The first line of input contains the string *x*.

The second line of input contains the string *y*.

Both *x* and *y* consist only of lowercase English letters, *x* and *y* have same length and this length is between 1 and 100.","If there is no string *z* such that *f*(*x*,<=*z*)<==<=*y*, print -1.

Otherwise, print a string *z* such that *f*(*x*,<=*z*)<==<=*y*. If there are multiple possible answers, print any of them. The string *z* should be the same length as *x* and *y* and consist only of lowercase English letters.","['ab\naa\n', 'nzwzl\nniwel\n', 'ab\nba\n']","['ba\n', 'xiyez\n', '-1\n']","The first case is from the statement.

Another solution for the second case is ""zizez""

There is no solution for the third case. That is, there is no *z* such that *f*(""ab"", *z*) =  ""ba"".",WRONG_ANSWER,"class l:
    def a(self, e, f):
        g = list(e)
        i = list(f)
        h = []
        for i in range(len(g)):
            if g[i] == i[i]:
                h.append(g[i])
            elif g[i] > i[i]:
                h.append(i[i])
            else:
                print(-1)
                return
        print(''.join(h))

def k():
    m = [
        ['ab', 'aa'],
        ['nzwzl', 'niwel'],
        ['ab', 'ba'],
        ['nzwzl', 'niwez'],
    ]
    for d in m:
        print(d)
        l().a(d[0], d[1])

def j():
    b = input().strip().split()
    c = input().strip().split()
    l().a(b, c)

if __name__ == '__main__':
    j()","s = input().strip()

def a(b):
    return b == b[::-1]

if not a(s):
    print(len(s))

else:

    if s.count(s[0]) == len(s):
        print(0)
    else:

        print(len(s) - 1)"
22,E,Scheme,PROGRAMMING,"['dfs and similar', 'graphs', 'trees']","To learn as soon as possible the latest news about their favourite fundamentally new operating system, BolgenOS community from Nizhni Tagil decided to develop a scheme. According to this scheme a community member, who is the first to learn the news, calls some other member, the latter, in his turn, calls some third member, and so on; i.e. a person with index *i* got a person with index *f**i*, to whom he has to call, if he learns the news. With time BolgenOS community members understood that their scheme doesn't work sometimes — there were cases when some members didn't learn the news at all. Now they want to supplement the scheme: they add into the scheme some instructions of type (*x**i*,<=*y**i*), which mean that person *x**i* has to call person *y**i* as well. What is the minimum amount of instructions that they need to add so, that at the end everyone learns the news, no matter who is the first to learn it?","The first input line contains number *n* (2<=≤<=*n*<=≤<=105) — amount of BolgenOS community members. The second line contains *n* space-separated integer numbers *f**i* (1<=≤<=*f**i*<=≤<=*n*,<=*i*<=≠<=*f**i*) — index of a person, to whom calls a person with index *i*.","In the first line output one number — the minimum amount of instructions to add. Then output one of the possible variants to add these instructions into the scheme, one instruction in each line. If the solution is not unique, output any.","['3\n3 3 2\n', '7\n2 3 1 3 4 4 1\n']","['1\n3 1\n', '3\n2 5\n2 6\n3 7\n']",none,WRONG_ANSWER,"import k
from array import array

def input():
    return k.stdin.buffer.readline().decode('utf-8')

n = int(input())
a = [0] + list(map(int, input().split()))
i = [[] for _ in range(n + 1)]
g = [0] * (n + 1)

for i in range(1, n + 1):
    g[a[i]] += 1
    i[a[i]].append(i)

a = g[:]

for i in range(1, n + 1):
    v = i
    while g[v] == 0:
        g[a[v]] -= 1
        v = a[v]

l = [0] * (n + 1)
e = []
f = []

for i in range(1, n + 1):
    if l[i] or g[i] == 0:
        continue

    l[i] = 1
    h = []
    j = [i]

    while j:
        v = j.pop()
        if a[v] == 0:
            h.append(v)
        for d in i[v]:
            if not l[d]:
                l[d] = 1
                j.append(d)

    e.append(i)
    f.append(h)

b = []
if len(e) > 1:
    for i in range(len(e)):
        for j in f[(i + 1) % len(e)]:
            b.append(f'{e[i]} {j}')
else:
    for j in f[0]:
        b.append(f'{e[0]} {j}')

c = str(len(b)) + '\n' + '\n'.join(b)
k.stdout.buffer.write(c.encode('utf-8'))","def e():
    import g
    from collections import d

    c = g.stdin.read().split()
    n = int(c[0])
    k = int(c[1])

    a = list(map(int, c[2:2+n]))

    a = d(int)

    b = d(int)

    for f in a:
        b[f] += 1
        
    h = 0

    for y in a:

        b[y] -= 1

        if y % k == 0:
            x = y // k
            z = y * k

            h += a[x] * b[z]

        a[y] += 1

    g.stdout.write(str(h))
    
    
if __name__ == ""__main__"":
    e()"
265,A,Colorful Stones (Simplified Edition),PROGRAMMING,['implementation'],"There is a sequence of colorful stones. The color of each stone is one of red, green, or blue. You are given a string *s*. The *i*-th (1-based) character of *s* represents the color of the *i*-th stone. If the character is ""R"", ""G"", or ""B"", the color of the corresponding stone is red, green, or blue, respectively.

Initially Squirrel Liss is standing on the first stone. You perform instructions one or more times.

Each instruction is one of the three types: ""RED"", ""GREEN"", or ""BLUE"". After an instruction *c*, if Liss is standing on a stone whose colors is *c*, Liss will move one stone forward, else she will not move.

You are given a string *t*. The number of instructions is equal to the length of *t*, and the *i*-th character of *t* represents the *i*-th instruction.

Calculate the final position of Liss (the number of the stone she is going to stand on in the end) after performing all the instructions, and print its 1-based position. It is guaranteed that Liss don't move out of the sequence.","The input contains two lines. The first line contains the string *s* (1<=≤<=|*s*|<=≤<=50). The second line contains the string *t* (1<=≤<=|*t*|<=≤<=50). The characters of each string will be one of ""R"", ""G"", or ""B"". It is guaranteed that Liss don't move out of the sequence.",Print the final 1-based position of Liss in a single line.,"['RGB\nRRR\n', 'RRRBGBRBBB\nBBBRR\n', 'BRRBGBRGRBGRGRRGGBGBGBRGBRGRGGGRBRRRBRBBBGRRRGGBBB\nBBRBGGRGRGBBBRBGRBRBBBBRBRRRBGBBGBBRRBBGGRBRRBRGRB\n']","['2\n', '3\n', '15\n']",none,RUNTIME_ERROR,"import f

def c():
    a = f.stdin.readline().strip().split()
    d = 1
    e = a[0]
    b = a[1]
    
    for i in range(len(b)):
        if b[i] == e[d-1]:
            d += 1
    
    if d > len(e):
        print(len(e))
    else:
        print(d)

if __name__ == ""__main__"":
    c()","def b(h):

    i = str(h)
    return len(set(i)) == len(i)

def e(y):

    a = y + 1
    while not b(a):
        a += 1
    return a

if __name__ == ""__main__"":
    import g

    c = g.stdin.read().splitlines()
    for d in c:
        if d.strip():
            try:
                y = int(d.strip())
                f = e(y)
                print(f)
            except ValueError:

                continue"
749,A,Bachgold Problem,PROGRAMMING,"['greedy', 'implementation', 'math', 'number theory']","Bachgold problem is very easy to formulate. Given a positive integer *n* represent it as a sum of maximum possible number of prime numbers. One can prove that such representation exists for any integer greater than 1.

Recall that integer *k* is called prime if it is greater than 1 and has exactly two positive integer divisors — 1 and *k*.",The only line of the input contains a single integer *n* (2<=≤<=*n*<=≤<=100<=000).,"The first line of the output contains a single integer *k* — maximum possible number of primes in representation.

The second line should contain *k* primes with their sum equal to *n*. You can print them in any order. If there are several optimal solution, print any of them.","['5\n', '6\n']","['2\n2 3\n', '3\n2 2 2\n']",none,WRONG_ANSWER,"n = int(input())

if n % 2 == 0:
    a = n // 2
    print(a)
    print('2 ' * a)

else:
    ...","import 
import p

def x():
    """"""
    Parses the input from standard input.
    
    The input format is as follows:
    - The first non-empty line contains an integer n — the number of projects.
    - Then follow n project descriptions, each separated by one or more blank lines.
      Each project description consists of:
        Line 1: ""name version"" (project name and version)
        Line 2: a line starting with an integer d — the number of direct dependencies.
        Next d lines: each containing ""dep_name dep_version"" for each dependency.
    
    Returns:
       poly_project: a tuple (name, version) of Polycarp's project (the first project described)
       projects: a dict with key (name, version) and value list of dependencies (tuples (dep_name, dep_version))
    """"""
    f = .stdin.read()
    if not f.strip():
        return None, {}
    r = f.splitlines()

    i = 0

    while i < len(r) and r[i].strip() == """":
        i += 1
    if i >= len(r):
        return None, {}

    n = int(r[i].strip())
    i += 1

    } = {}
    { = None

    for _ in range(n):

        while i < len(r) and r[i].strip() == """":
            i += 1
        if i >= len(r):
            break

        n = r[i].strip()
        i += 1
        y = n.split()
        t = y[0]
         = int(y[1])
        if { is None:
            { = (t, )

        while i < len(r) and r[i].strip() == """":
            i += 1
        if i >= len(r):
            break

        h = r[i].strip()
        i += 1
        j = h.split()
        try:
            d = int(j[0])
        except:
            d = 0
        l = []

        for _ in range(d):

            while i < len(r) and r[i].strip() == """":
                i += 1
            if i >= len(r):
                break
            g = r[i].strip().split()
            i += 1
            if len(g) < 2:
                continue
            i = g[0]
            k = int(g[1])
            l.append((i, k))
        }[(t, )] = l
    return {, }

def s():

    {, } = x()
    if { is None:
        return

    z, | = {

    a = {}

    o = []

    a[z] = (0, |)
    p.heappush(o, (0, -|, z, |))

    while o:
        m, u, d, e = p.heappop(o)

        if a.get(d, (None, None)) != (m, e):
            continue

        l = }.get((d, e), [])
        for i, k in l:
            v = m + 1

            if i not in a:
                a[i] = (v, k)
                p.heappush(o, (v, -k, i, k))
            else:
                b, c = a[i]

                if v < b or (v == b and k > c):
                    a[i] = (v, k)
                    p.heappush(o, (v, -k, i, k))

    if z in a:
        del a[z]

    ~ = sorted(a.items(), key=lambda q: q[0])

    w = []
    w.append(str(len(~)))
    for t, (m, ) in ~:
        w.append(f""{t} {}"")
    .stdout.write(""\n"".join(w))

if __name__ == '__main__':
    s()"
466,A,Cheap Travel,PROGRAMMING,['implementation'],"Ann has recently started commuting by subway. We know that a one ride subway ticket costs *a* rubles. Besides, Ann found out that she can buy a special ticket for *m* rides (she can buy it several times). It costs *b* rubles. Ann did the math; she will need to use subway *n* times. Help Ann, tell her what is the minimum sum of money she will have to spend to make *n* rides?","The single line contains four space-separated integers *n*, *m*, *a*, *b* (1<=≤<=*n*,<=*m*,<=*a*,<=*b*<=≤<=1000) — the number of rides Ann has planned, the number of rides covered by the *m* ride ticket, the price of a one ride ticket and the price of an *m* ride ticket.",Print a single integer — the minimum sum in rubles that Ann will need to spend.,"['6 2 1 2\n', '5 2 2 3\n']","['6\n', '8\n']","In the first sample one of the optimal solutions is: each time buy a one ride ticket. There are other optimal solutions. For example, buy three *m* ride tickets.",WRONG_ANSWER,"import b
def input(): return b.stdin.readline().strip()
def a(): return map(int,b.stdin.readline().strip().split())

n,m,a,b = a()
if b/m < a:
	print((n//m)*b+(n%m)*a)
else:
	print(n*a)","import t
import math

def d(x, j):
    """"""Count how many times 'factor' divides x.""""""
    if x == 0:
        return 10**9
    c = 0
    while x % j == 0:
        c += 1
        x //= j
    return c

def n():
    g = t.stdin.read().strip().split()
    if not g:
        return
    n = int(g[0])

    o = []
    k = [[0]*n for _ in range(n)]
    l = [[0]*n for _ in range(n)]
    
    v, w = -1, -1
    m = 1
    for i in range(n):
        s = []
        for j in range(n):
            u = int(g[m])
            m += 1
            s.append(u)
            if u == 0:
                v, w = i, j
            k[i][j] = d(u, 2)
            l[i][j] = d(u, 5)
        o.append(s)
    
    a = 10**9

    h = [[a]*n for _ in range(n)]
    i = [[a]*n for _ in range(n)]
    q = [[""""]*n for _ in range(n)]
    r = [[""""]*n for _ in range(n)]

    h[0][0] = k[0][0]
    i[0][0] = l[0][0]

    for i in range(1, n):
        h[i][0] = h[i-1][0] + k[i][0]
        i[i][0] = i[i-1][0] + l[i][0]
        q[i][0] = q[i-1][0] + ""D""
        r[i][0] = r[i-1][0] + ""D""
    for j in range(1, n):
        h[0][j] = h[0][j-1] + k[0][j]
        i[0][j] = i[0][j-1] + l[0][j]
        q[0][j] = q[0][j-1] + ""R""
        r[0][j] = r[0][j-1] + ""R""

    for i in range(1, n):
        for j in range(1, n):

            if h[i-1][j] < h[i][j-1]:
                h[i][j] = h[i-1][j] + k[i][j]
                q[i][j] = q[i-1][j] + ""D""
            else:
                h[i][j] = h[i][j-1] + k[i][j]
                q[i][j] = q[i][j-1] + ""R""

            if i[i-1][j] < i[i][j-1]:
                i[i][j] = i[i-1][j] + l[i][j]
                r[i][j] = r[i-1][j] + ""D""
            else:
                i[i][j] = i[i][j-1] + l[i][j]
                r[i][j] = r[i][j-1] + ""R""

    e = h[n-1][n-1]
    f = i[n-1][n-1]
    b = min(e, f)

    if v != -1 and b > 1:

        p = ""D"" * v + ""R"" * w + ""D"" * (n - 1 - v) + ""R"" * (n - 1 - w)
        print(1)
        print(p)
    else:
        if e < f:
            print(e)
            print(q[n-1][n-1])
        else:
            print(f)
            print(r[n-1][n-1])

if __name__ == '__main__':
    n()"
632,C,The Smallest String Concatenation,PROGRAMMING,"['sortings', 'strings']","You're given a list of *n* strings *a*1,<=*a*2,<=...,<=*a**n*. You'd like to concatenate them together in some order such that the resulting string would be lexicographically smallest.

Given the list of strings, output the lexicographically smallest concatenation.","The first line contains integer *n* — the number of strings (1<=≤<=*n*<=≤<=5·104).

Each of the next *n* lines contains one string *a**i* (1<=≤<=|*a**i*|<=≤<=50) consisting of only lowercase English letters. The sum of string lengths will not exceed 5·104.",Print the only string *a* — the lexicographically smallest string concatenation.,"['4\nabba\nabacaba\nbcd\ner\n', '5\nx\nxx\nxxa\nxxaa\nxxaaa\n', '3\nc\ncb\ncba\n']","['abacabaabbabcder\n', 'xxaaaxxaaxxaxxx\n', 'cbacbc\n']",none,OK,"from functools import c
def b(x,y):
    if x+y>y+x:
        return 1
    else:
        return -1
a=[]
n=int(input())
for i in range(n):
	a.append(input())
a=""""
for s in sorted(a,key=c(b)):
	a+=s
print(a)","def k():
    import u
    from collections import f

    e = u.stdin.read().splitlines()
    if not e:
        return
    n, m = map(int, e[0].split())
    j = e[1:n+1]

    b = [[-1] * m for _ in range(n)]

    c = []

    g = [(-1, 0), (0, 1), (1, 0), (0, -1)]
    d = 0

    for i in range(n):
        for j in range(m):
            if j[i][j] == '.' and b[i][j] == -1:

                p = f()
                p.append((i, j))
                b[i][j] = d
                t = 1
                while p:
                    x, y = p.popleft()
                    for h, i in g:
                        n, o = x + h, y + i
                        if 0 <= n < n and 0 <= o < m:
                            if j[n][o] == '.' and b[n][o] == -1:
                                b[n][o] = d
                                t += 1
                                p.append((n, o))

                c.append(t)
                d += 1

    q = []
    for i in range(n):
        r = []
        for j in range(m):
            if j[i][j] == '*':
                s = set()
                v = 1
                for h, i in g:
                    l, m = i + h, j + i
                    if 0 <= l < n and 0 <= m < m:
                        a = b[l][m]
                        if a != -1 and a not in s:
                            v += c[a]
                            s.add(a)

                r.append(str(v % 10))
            else:

                r.append('.')
        q.append("""".join(r))
    
    u.stdout.write(""\n"".join(q))

if __name__ == '__main__':
    k()"
276,C,Little Girl and Maximum Sum,PROGRAMMING,"['data structures', 'greedy', 'implementation', 'sortings']","The little girl loves the problems on array queries very much.

One day she came across a rather well-known problem: you've got an array of $n$ elements (the elements of the array are indexed starting from 1); also, there are $q$ queries, each one is defined by a pair of integers $l_i$, $r_i$ $(1 \le l_i \le r_i \le n)$. You need to find for each query the sum of elements of the array with indexes from $l_i$ to $r_i$, inclusive.

The little girl found the problem rather boring. She decided to reorder the array elements before replying to the queries in a way that makes the sum of query replies maximum possible. Your task is to find the value of this maximum sum.","The first line contains two space-separated integers $n$ ($1 \le n \le 2\cdot10^5$) and $q$ ($1 \le q \le 2\cdot10^5$) — the number of elements in the array and the number of queries, correspondingly.

The next line contains $n$ space-separated integers $a_i$ ($1 \le a_i \le 2\cdot10^5$) — the array elements.

Each of the following $q$ lines contains two space-separated integers $l_i$ and $r_i$ ($1 \le l_i \le r_i \le n$) — the $i$-th query.","In a single line print, a single integer — the maximum sum of query replies after the array elements are reordered.

Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.","['3 3\n5 3 2\n1 2\n2 3\n1 3\n', '5 3\n5 2 4 1 3\n1 5\n2 3\n2 3\n']","['25\n', '33\n']",none,TIME_LIMIT_EXCEEDED,"def c():
	n, q = list(map(int, input().strip().split()))
	a = list(map(int, input().strip().split()))
	d = []
	a = [0]*(n+1)
	for i in range(q):
		b, e = list(map(int, input().strip().split()))
		for i in range(b, e+1):
			a[i] += 1

	a.sort(reverse = True)
	a.sort(reverse = True)
	f = 0
	for i in range(0, n):
		f += (a[i]*a[i])

	print(str(f))

if __name__ == '__main__':
	c()","def i():
    import m
    d = m.stdin.read().split()
    if not d:
        return

    n = int(d[0])
    c = []
    h = 1

    for i in range(n):
        k = list(map(int, d[h:h+n]))
        c.append(k)
        h += n

    l = 2 * n - 1
    e = [0] * l
    f = [0] * l

    for i in range(n):
        for j in range(n):
            e[i + j] += c[i][j]
            f[i - j + (n - 1)] += c[i][j]

    a = -1
    b = -1
    g = (0, 0)
    j = (0, 0)

    for i in range(n):
        for j in range(n):
            o = e[i + j] + f[i - j + (n - 1)] - c[i][j]
            if (i + j) & 1:
                if o > b:
                    b = o
                    j = (i, j)
            else:
                if o > a:
                    a = o
                    g = (i, j)

    n = a + b

    m.stdout.write(str(n) + ""\n"")
    m.stdout.write(f""{g[0] + 1} {g[1] + 1} {j[0] + 1} {j[1] + 1}\n"")

if __name__ == ""__main__"":
    i()"
686,A,Free Ice Cream,PROGRAMMING,"['constructive algorithms', 'implementation']","After their adventure with the magic mirror Kay and Gerda have returned home and sometimes give free ice cream to kids in the summer.

At the start of the day they have *x* ice cream packs. Since the ice cream is free, people start standing in the queue before Kay and Gerda's house even in the night. Each person in the queue wants either to take several ice cream packs for himself and his friends or to give several ice cream packs to Kay and Gerda (carriers that bring ice cream have to stand in the same queue).

If a carrier with *d* ice cream packs comes to the house, then Kay and Gerda take all his packs. If a child who wants to take *d* ice cream packs comes to the house, then Kay and Gerda will give him *d* packs if they have enough ice cream, otherwise the child will get no ice cream at all and will leave in distress.

Kay wants to find the amount of ice cream they will have after all people will leave from the queue, and Gerda wants to find the number of distressed kids.","The first line contains two space-separated integers *n* and *x* (1<=≤<=*n*<=≤<=1000, 0<=≤<=*x*<=≤<=109).

Each of the next *n* lines contains a character '+' or '-', and an integer *d**i*, separated by a space (1<=≤<=*d**i*<=≤<=109). Record ""+ *d**i*"" in *i*-th line means that a carrier with *d**i* ice cream packs occupies *i*-th place from the start of the queue, and record ""- *d**i*"" means that a child who wants to take *d**i* packs stands in *i*-th place.","Print two space-separated integers — number of ice cream packs left after all operations, and number of kids that left the house in distress.","['5 7\n+ 5\n- 10\n- 20\n+ 40\n- 20\n', '5 17\n- 16\n- 2\n- 98\n+ 100\n- 98\n']","['22 1\n', '3 2\n']","Consider the first sample.
 1.  Initially Kay and Gerda have 7 packs of ice cream. 1.  Carrier brings 5 more, so now they have 12 packs. 1.  A kid asks for 10 packs and receives them. There are only 2 packs remaining. 1.  Another kid asks for 20 packs. Kay and Gerda do not have them, so the kid goes away distressed. 1.  Carrier bring 40 packs, now Kay and Gerda have 42 packs. 1.  Kid asks for 20 packs and receives them. There are 22 packs remaining.",OK,"def b(test):
    a = 0
    n, x = map(int, input().split())
    for i in range(n):
        c = input().split()
        if c[0] == '+':
            x += int(c[1])
        elif int(c[1]) > x:
            a += 1
        else:
            x -= int(c[1])
    print(x, a)
t = 1

for _ in range(t):
    b(_ + 1)","""""""
Sasha and Kolya's Coke mixing problem.

We are given a desired carbon dioxide concentration (target) and k types of Coke,
each with its own concentration. We want to mix an integer number of liters from each type
to obtain a mixture with exactly the target concentration while minimizing the total volume.
The concentration of the mixture is defined as the total CO2 volume divided by total liters.
Mixing is linear so that the equation becomes:

    sum(x_i * a_i) / (sum(x_i)) = target

This can be rearranged (assuming sum(x_i) > 0) to:

    sum(x_i * (a_i - target)) = 0

Let’s define:
  • For a type with a_i > target: coin value = a_i - target (excess CO2).
  • For a type with a_i < target: coin value = target - a_i (deficit of CO2).

We want to choose a positive number of liters from some types with a_i > target and
some types with a_i < target (if available) so that the total excess equals the total deficit.
That is, we want to find a positive integer S such that:
    sum_{i in positives} (a_i - target) * x_i = S   and
    sum_{j in negatives} (target - a_j) * y_j = S
with integer nonnegative coefficients and at least one coin from each side.
Then the total number of liters is (sum(x_i) + sum(y_j)), and we wish to minimize that.

A trivial solution exists if there is a Coke type with concentration exactly equal to target,
in which case one liter is enough.

We solve the coin‐change problem on both sides (with coins up to a computed limit) via BFS.
We set the upper limit to the least common multiple (LCM) of the smallest coin from each set;
using only these coins gives a candidate balance value S.
Finally, we iterate over all S in [1, limit] for which both coin sets can achieve sum S,
and choose the minimal total coin count.
""""""

import z
import w
from collections import l

def s(a, b):
    return a * b // w.gcd(a, b)

def d(f, x):
    """"""
    Given a set of coin denominations (all positive integers),
    compute the minimum number of coins required to form every sum from 0 to max_sum.
    Uses a standard BFS (since each coin addition cost is 1).
    dp[x] will be the minimal coin count to form sum x.
    """"""
    a = 10**9
    m = [a] * (x + 1)
    m[0] = 0
    p = l([0])
    while p:
        j = p.popleft()
        i = m[j]
        for e in f:
            y = j + e
            if y <= x and m[y] > i + 1:
                m[y] = i + 1
                p.append(y)
    return m

def v():
    k = z.stdin.read().strip().split()
    if not k:
        return
    r = iter(k)
    { = int(next(r))
    k = int(next(r))

    | = [int(next(r)) for _ in range(k)]

    if { in |:
        z.stdout.write(""1\n"")
        return

    u = any(a < { for a in |)
    q = any(a > { for a in |)
    if not (u and q):
        z.stdout.write(""-1\n"")
        return

    h = set()
    g = set()
    for a in |:
        if a > {:
            h.add(a - {)
        elif a < {:
            g.add({ - a)
    h = sorted(h)
    g = sorted(g)

    b = s(h[0], g[0])
    t = b

    o = d(h, t)
    n = d(g, t)

    c = 10**9
    for S in range(1, t + 1):
        if o[S] < 10**9 and n[S] < 10**9:
            c = min(c, o[S] + n[S])
    
    if c == 10**9:
        z.stdout.write(""-1\n"")
    else:
        z.stdout.write(str(c) + ""\n"")

if __name__ == '__main__':
    v()"
489,B,BerSU Ball,PROGRAMMING,"['dfs and similar', 'dp', 'graph matchings', 'greedy', 'sortings', 'two pointers']","The Berland State University is hosting a ballroom dance in celebration of its 100500-th anniversary! *n* boys and *m* girls are already busy rehearsing waltz, minuet, polonaise and quadrille moves.

We know that several boy&amp;girl pairs are going to be invited to the ball. However, the partners' dancing skill in each pair must differ by at most one.

For each boy, we know his dancing skills. Similarly, for each girl we know her dancing skills. Write a code that can determine the largest possible number of pairs that can be formed from *n* boys and *m* girls.","The first line contains an integer *n* (1<=≤<=*n*<=≤<=100) — the number of boys. The second line contains sequence *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=100), where *a**i* is the *i*-th boy's dancing skill.

Similarly, the third line contains an integer *m* (1<=≤<=*m*<=≤<=100) — the number of girls. The fourth line contains sequence *b*1,<=*b*2,<=...,<=*b**m* (1<=≤<=*b**j*<=≤<=100), where *b**j* is the *j*-th girl's dancing skill.",Print a single number — the required maximum possible number of pairs.,"['4\n1 4 6 2\n5\n5 1 5 7 9\n', '4\n1 2 3 4\n4\n10 11 12 13\n', '5\n1 1 1 1 1\n3\n1 2 3\n']","['3\n', '0\n', '2\n']",none,WRONG_ANSWER,"n=int(input())
a=list(map(int,input().split()))
m=int(input())
b=list(map(int,input().split()))

def b(n):
    if n<=0:
        return -1*n
    else:
        return n

a.sort()
b.sort()
a=0
for i in range(n):
    if b(a[i]-b[0])<=1:
        a+=1
        b.pop(0)
print(a)","import j

def h():

    f = j.stdin.read().strip()
    if not f:
        return
    k = f.split()

    n = int(k[0])
    a = int(k[1])
    b = int(k[2])
    p = int(k[3])
    q = int(k[4])

    def e(x, y):
        while y:
            x, y = y, x % y
        return x

    g = a * b // e(a, b)

    d = n // a
    b = n // b
    c = n // g

    i = d - c
    a = b - c

    l = i * p + a * q + c * max(p, q)

    j.stdout.write(str(l))

if __name__ == ""__main__"":
    h()"
1,A,Theatre Square,PROGRAMMING,['math'],"Theatre Square in the capital city of Berland has a rectangular shape with the size *n*<=×<=*m* meters. On the occasion of the city's anniversary, a decision was taken to pave the Square with square granite flagstones. Each flagstone is of the size *a*<=×<=*a*.

What is the least number of flagstones needed to pave the Square? It's allowed to cover the surface larger than the Theatre Square, but the Square has to be covered. It's not allowed to break the flagstones. The sides of flagstones should be parallel to the sides of the Square.","The input contains three positive integer numbers in the first line: *n*,<=<=*m* and *a* (1<=≤<=<=*n*,<=*m*,<=*a*<=≤<=109).",Write the needed number of flagstones.,['6 6 4\n'],['4\n'],none,WRONG_ANSWER,"class Solution:
    def b(n: int, m: int, a: int) -> int:
        a = (m * n) / (a * a)
        
        if a != int(a):
            a += 1
            
        return a","import e

def d():

    s = e.stdin.read().strip()
    if not s:

        print(""NO"")
        return

    n = len(s)
    i = 0

    a = 0
    while i < n and s[i] == 'a':
        a += 1
        i += 1

    if a == 0:
        print(""NO"")
        return

    b = 0
    while i < n and s[i] == 'b':
        b += 1
        i += 1

    if b == 0:
        print(""NO"")
        return

    c = 0
    while i < n and s[i] == 'c':
        c += 1
        i += 1

    if c == 0:
        print(""NO"")
        return

    if i != n:
        print(""NO"")
        return

    if c == a or c == b:
        print(""YES"")
    else:
        print(""NO"")

if __name__ == ""__main__"":
    d()"
115,A,Party,PROGRAMMING,"['dfs and similar', 'graphs', 'trees']","A company has *n* employees numbered from 1 to *n*. Each employee either has no immediate manager or exactly one immediate manager, who is another employee with a different number. An employee *A* is said to be the superior of another employee *B* if at least one of the following is true:
 -  Employee *A* is the immediate manager of employee *B* -  Employee *B* has an immediate manager employee *C* such that employee *A* is the superior of employee *C*. 
The company will not have a managerial cycle. That is, there will not exist an employee who is the superior of his/her own immediate manager.

Today the company is going to arrange a party. This involves dividing all *n* employees into several groups: every employee must belong to exactly one group. Furthermore, within any single group, there must not be two employees *A* and *B* such that *A* is the superior of *B*.

What is the minimum number of groups that must be formed?","The first line contains integer *n* (1<=≤<=*n*<=≤<=2000) — the number of employees.

The next *n* lines contain the integers *p**i* (1<=≤<=*p**i*<=≤<=*n* or *p**i*<==<=-1). Every *p**i* denotes the immediate manager for the *i*-th employee. If *p**i* is -1, that means that the *i*-th employee does not have an immediate manager. 

It is guaranteed, that no employee will be the immediate manager of him/herself (*p**i*<=≠<=*i*). Also, there will be no managerial cycles.",Print a single integer denoting the minimum number of groups that will be formed in the party.,['5\n-1\n1\n2\n1\n-1\n'],['3\n'],"For the first example, three groups are sufficient, for example: 
 -  Employee 1 -  Employees 2 and 4 -  Employees 3 and 5",RUNTIME_ERROR,"def c(b, d, e):
    a = []

    if(not e[d]):
        return [b-1]

    for i in e[d]:
        a += c(b+1, i, e)

    return a

n = int(input())

e = [[] for i in range(n+1)]
for i in range(1, n+1):
    a = int(input())

    if(a == -1):
        e[0].append(i)
    else:
        e[a].append(i)

a = c(1, 0, e)
print(max(a))","import j
from collections import c

def g():

    e = j.stdin.read().split()
    n = int(e[0])
    k = int(e[1])
    a = list(map(int, e[2:]))

    l = []
    if k == 1:
        l.append(1)
    elif k == -1:
        l.extend([1, -1])
    else:
        a = 1

        f = 10**16  
        while abs(a) <= f:
            l.append(a)
            a *= k

    d = c(int)
    d[0] = 1

    i = 0
    b = 0

    for h in a:
        i += h

        for k in l:
            b += d[i - k]
        d[i] += 1

    j.stdout.write(str(b) + ""\n"")

if __name__ == ""__main__"":
    g()"
385,B,Bear and Strings,PROGRAMMING,"['brute force', 'greedy', 'implementation', 'math', 'strings']","The bear has a string *s*<==<=*s*1*s*2... *s*|*s*| (record |*s*| is the string's length), consisting of lowercase English letters. The bear wants to count the number of such pairs of indices *i*,<=*j* (1<=≤<=*i*<=≤<=*j*<=≤<=|*s*|), that string *x*(*i*,<=*j*)<==<=*s**i**s**i*<=+<=1... *s**j* contains at least one string ""bear"" as a substring.

String *x*(*i*,<=*j*) contains string ""bear"", if there is such index *k* (*i*<=≤<=*k*<=≤<=*j*<=-<=3), that *s**k*<==<=*b*, *s**k*<=+<=1<==<=*e*, *s**k*<=+<=2<==<=*a*, *s**k*<=+<=3<==<=*r*.

Help the bear cope with the given problem.",The first line contains a non-empty string *s* (1<=≤<=|*s*|<=≤<=5000). It is guaranteed that the string only consists of lowercase English letters.,Print a single number — the answer to the problem.,"['bearbtear\n', 'bearaabearc\n']","['6\n', '20\n']","In the first sample, the following pairs (*i*, *j*) match: (1, 4), (1, 5), (1, 6), (1, 7), (1, 8), (1, 9).

In the second sample, the following pairs (*i*, *j*) match: (1,  4), (1,  5), (1,  6), (1,  7), (1,  8), (1,  9), (1,  10), (1,  11), (2,  10), (2,  11), (3,  10), (3,  11), (4,  10), (4,  11), (5,  10), (5,  11), (6,  10), (6,  11), (7,  10), (7,  11).",RUNTIME_ERROR,"'''
def count(a):
	s = 'bear'
	c = 0
	n = 0
	if(len(a)<len(s)):
		return -1
	for i in range(0,len(a)-3):
		if(s == a[i:i+4]):
			k = i - n
			k = (len(a[i+4:]))*k
			c += k+(len(a)-i+1)
			n = i
	return c-4
			

def main():
	s = input()
	print(count(s))

main()
'''
def a(c):
	d = -1
	for i in range(0,len(c)):
		if c[i] == 1:
			if(d != -1 and i-d<6):
				return ""NO""
			d = i
	return ""YES""  

def b():
	e = int(input())
	for i in range(0,e):
		n = int(input())
		c = [int(j) for j in input().split()]
		print(a(c))

b()","def e():
    import h
    b = h.stdin.read().split()

    c = iter(b)
    n = int(next(c))

    g = [int(next(c)) for _ in range(n)]
    
    m = int(next(c))

    a = 0
    f = []
    
    for _ in range(m):

        w = int(next(c))
        h = int(next(c))

        d = max(a, g[w - 1])
        f.append(str(d))

        a = d + h

    h.stdout.write(""\n"".join(f))
    
if __name__ == ""__main__"":
    e()"
121,A,Lucky Sum,PROGRAMMING,['implementation'],"Petya loves lucky numbers. Everybody knows that lucky numbers are positive integers whose decimal representation contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.

Let *next*(*x*) be the minimum lucky number which is larger than or equals *x*. Petya is interested what is the value of the expression *next*(*l*)<=+<=*next*(*l*<=+<=1)<=+<=...<=+<=*next*(*r*<=-<=1)<=+<=*next*(*r*). Help him solve this problem.",The single line contains two integers *l* and *r* (1<=≤<=*l*<=≤<=*r*<=≤<=109) — the left and right interval limits.,"In the single line print the only number — the sum *next*(*l*)<=+<=*next*(*l*<=+<=1)<=+<=...<=+<=*next*(*r*<=-<=1)<=+<=*next*(*r*).

Please do not use the %lld specificator to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specificator.","['2 7\n', '7 7\n']","['33\n', '7\n']","In the first sample: *next*(2) + *next*(3) + *next*(4) + *next*(5) + *next*(6) + *next*(7) = 4 + 4 + 4 + 7 + 7 + 7 = 33

In the second sample: *next*(7) = 7",TIME_LIMIT_EXCEEDED,"from sys import e, stdout
import math
from itertools import permutations, combinations
from itertools import combinations_with_replacement
from collections import defaultdict
from bisect import c
 
def L():
    return list(map(int, e.readline().split()))
 
def a():
    return map(int, e.readline().split())
 
def I():
    return int(e.readline())
 
P = 1000000007
b = [4, 7, 44, 47, 74, 77, 444, 447, 474, 477, 744, 747, 774, 777, 4444, 4447, 4474, 4477, 4744, 4747, 4774, 4777, 7444, 7447, 7474, 7477, 7744, 7747, 7774, 7777, 44444, 44447, 44474, 44477, 44744, 44747, 44774, 44777, 47444, 47447, 47474, 47477, 47744, 47747, 47774, 47777, 74444, 74447, 74474, 74477, 74744, 74747, 74774, 74777, 77444, 77447, 77474, 77477, 77744, 77747, 77774, 77777, 444444, 444447, 444474, 444477, 444744, 444747, 444774, 444777, 447444, 447447, 447474, 447477, 447744, 447747, 447774, 447777, 474444, 474447, 474474, 474477, 474744, 474747, 474774, 474777, 477444, 477447, 477474, 477477, 477744, 477747, 477774, 477777, 744444, 744447, 744474, 744477, 744744, 744747, 744774, 744777, 747444, 747447, 747474, 747477, 747744, 747747, 747774, 747777, 774444, 774447, 774474, 774477, 774744, 774747, 774774, 774777, 777444, 777447, 777474, 777477, 777744, 777747, 777774, 777777, 4444444, 4444447, 4444474, 4444477, 4444744, 4444747, 4444774, 4444777, 4447444, 4447447, 4447474, 4447477, 4447744, 4447747, 4447774, 4447777, 4474444, 4474447, 4474474, 4474477, 4474744, 4474747, 4474774, 4474777, 4477444, 4477447, 4477474, 4477477, 4477744, 4477747, 4477774, 4477777, 4744444, 4744447, 4744474, 4744477, 4744744, 4744747, 4744774, 4744777, 4747444, 4747447, 4747474, 4747477, 4747744, 4747747, 4747774, 4747777, 4774444, 4774447, 4774474, 4774477, 4774744, 4774747, 4774774, 4774777, 4777444, 4777447, 4777474, 4777477, 4777744, 4777747, 4777774, 4777777, 7444444, 7444447, 7444474, 7444477, 7444744, 7444747, 7444774, 7444777, 7447444, 7447447, 7447474, 7447477, 7447744, 7447747, 7447774, 7447777, 7474444, 7474447, 7474474, 7474477, 7474744, 7474747, 7474774, 7474777, 7477444, 7477447, 7477474, 7477477, 7477744, 7477747, 7477774, 7477777, 7744444, 7744447, 7744474, 7744477, 7744744, 7744747, 7744774, 7744777, 7747444, 7747447, 7747474, 7747477, 7747744, 7747747, 7747774, 7747777, 7774444, 7774447, 7774474, 7774477, 7774744, 7774747, 7774774, 7774777, 7777444, 7777447, 7777474, 7777477, 7777744, 7777747, 7777774, 7777777, 44444444, 44444447, 44444474, 44444477, 44444744, 44444747, 44444774, 44444777, 44447444, 44447447, 44447474, 44447477, 44447744, 44447747, 44447774, 44447777, 44474444, 44474447, 44474474, 44474477, 44474744, 44474747, 44474774, 44474777, 44477444, 44477447, 44477474, 44477477, 44477744, 44477747, 44477774, 44477777, 44744444, 44744447, 44744474, 44744477, 44744744, 44744747, 44744774, 44744777, 44747444, 44747447, 44747474, 44747477, 44747744, 44747747, 44747774, 44747777, 44774444, 44774447, 44774474, 44774477, 44774744, 44774747, 44774774, 44774777, 44777444, 44777447, 44777474, 44777477, 44777744, 44777747, 44777774, 44777777, 47444444, 47444447, 47444474, 47444477, 47444744, 47444747, 47444774, 47444777, 47447444, 47447447, 47447474, 47447477, 47447744, 47447747, 47447774, 47447777, 47474444, 47474447, 47474474, 47474477, 47474744, 47474747, 47474774, 47474777, 47477444, 47477447, 47477474, 47477477, 47477744, 47477747, 47477774, 47477777, 47744444, 47744447, 47744474, 47744477, 47744744, 47744747, 47744774, 47744777, 47747444, 47747447, 47747474, 47747477, 47747744, 47747747, 47747774, 47747777, 47774444, 47774447, 47774474, 47774477, 47774744, 47774747, 47774774, 47774777, 47777444, 47777447, 47777474, 47777477, 47777744, 47777747, 47777774, 47777777, 74444444, 74444447, 74444474, 74444477, 74444744, 74444747, 74444774, 74444777, 74447444, 74447447, 74447474, 74447477, 74447744, 74447747, 74447774, 74447777, 74474444, 74474447, 74474474, 74474477, 74474744, 74474747, 74474774, 74474777, 74477444, 74477447, 74477474, 74477477, 74477744, 74477747, 74477774, 74477777, 74744444, 74744447, 74744474, 74744477, 74744744, 74744747, 74744774, 74744777, 74747444, 74747447, 74747474, 74747477, 74747744, 74747747, 74747774, 74747777, 74774444, 74774447, 74774474, 74774477, 74774744, 74774747, 74774774, 74774777, 74777444, 74777447, 74777474, 74777477, 74777744, 74777747, 74777774, 74777777, 77444444, 77444447, 77444474, 77444477, 77444744, 77444747, 77444774, 77444777, 77447444, 77447447, 77447474, 77447477, 77447744, 77447747, 77447774, 77447777, 77474444, 77474447, 77474474, 77474477, 77474744, 77474747, 77474774, 77474777, 77477444, 77477447, 77477474, 77477477, 77477744, 77477747, 77477774, 77477777, 77744444, 77744447, 77744474, 77744477, 77744744, 77744747, 77744774, 77744777, 77747444, 77747447, 77747474, 77747477, 77747744, 77747747, 77747774, 77747777, 77774444, 77774447, 77774474, 77774477, 77774744, 77774747, 77774774, 77774777, 77777444, 77777447, 77777474, 77777477, 77777744, 77777747, 77777774, 77777777, 444444444, 444444447, 444444474, 444444477, 444444744, 444444747, 444444774, 444444777, 444447444, 444447447, 444447474, 444447477, 444447744, 444447747, 444447774, 444447777, 444474444, 444474447, 444474474, 444474477, 444474744, 444474747, 444474774, 444474777, 444477444, 444477447, 444477474, 444477477, 444477744, 444477747, 444477774, 444477777, 444744444, 444744447, 444744474, 444744477, 444744744, 444744747, 444744774, 444744777, 444747444, 444747447, 444747474, 444747477, 444747744, 444747747, 444747774, 444747777, 444774444, 444774447, 444774474, 444774477, 444774744, 444774747, 444774774, 444774777, 444777444, 444777447, 444777474, 444777477, 444777744, 444777747, 444777774, 444777777, 447444444, 447444447, 447444474, 447444477, 447444744, 447444747, 447444774, 447444777, 447447444, 447447447, 447447474, 447447477, 447447744, 447447747, 447447774, 447447777, 447474444, 447474447, 447474474, 447474477, 447474744, 447474747, 447474774, 447474777, 447477444, 447477447, 447477474, 447477477, 447477744, 447477747, 447477774, 447477777, 447744444, 447744447, 447744474, 447744477, 447744744, 447744747, 447744774, 447744777, 447747444, 447747447, 447747474, 447747477, 447747744, 447747747, 447747774, 447747777, 447774444, 447774447, 447774474, 447774477, 447774744, 447774747, 447774774, 447774777, 447777444, 447777447, 447777474, 447777477, 447777744, 447777747, 447777774, 447777777, 474444444, 474444447, 474444474, 474444477, 474444744, 474444747, 474444774, 474444777, 474447444, 474447447, 474447474, 474447477, 474447744, 474447747, 474447774, 474447777, 474474444, 474474447, 474474474, 474474477, 474474744, 474474747, 474474774, 474474777, 474477444, 474477447, 474477474, 474477477, 474477744, 474477747, 474477774, 474477777, 474744444, 474744447, 474744474, 474744477, 474744744, 474744747, 474744774, 474744777, 474747444, 474747447, 474747474, 474747477, 474747744, 474747747, 474747774, 474747777, 474774444, 474774447, 474774474, 474774477, 474774744, 474774747, 474774774, 474774777, 474777444, 474777447, 474777474, 474777477, 474777744, 474777747, 474777774, 474777777, 477444444, 477444447, 477444474, 477444477, 477444744, 477444747, 477444774, 477444777, 477447444, 477447447, 477447474, 477447477, 477447744, 477447747, 477447774, 477447777, 477474444, 477474447, 477474474, 477474477, 477474744, 477474747, 477474774, 477474777, 477477444, 477477447, 477477474, 477477477, 477477744, 477477747, 477477774, 477477777, 477744444, 477744447, 477744474, 477744477, 477744744, 477744747, 477744774, 477744777, 477747444, 477747447, 477747474, 477747477, 477747744, 477747747, 477747774, 477747777, 477774444, 477774447, 477774474, 477774477, 477774744, 477774747, 477774774, 477774777, 477777444, 477777447, 477777474, 477777477, 477777744, 477777747, 477777774, 477777777, 744444444, 744444447, 744444474, 744444477, 744444744, 744444747, 744444774, 744444777, 744447444, 744447447, 744447474, 744447477, 744447744, 744447747, 744447774, 744447777, 744474444, 744474447, 744474474, 744474477, 744474744, 744474747, 744474774, 744474777, 744477444, 744477447, 744477474, 744477477, 744477744, 744477747, 744477774, 744477777, 744744444, 744744447, 744744474, 744744477, 744744744, 744744747, 744744774, 744744777, 744747444, 744747447, 744747474, 744747477, 744747744, 744747747, 744747774, 744747777, 744774444, 744774447, 744774474, 744774477, 744774744, 744774747, 744774774, 744774777, 744777444, 744777447, 744777474, 744777477, 744777744, 744777747, 744777774, 744777777, 747444444, 747444447, 747444474, 747444477, 747444744, 747444747, 747444774, 747444777, 747447444, 747447447, 747447474, 747447477, 747447744, 747447747, 747447774, 747447777, 747474444, 747474447, 747474474, 747474477, 747474744, 747474747, 747474774, 747474777, 747477444, 747477447, 747477474, 747477477, 747477744, 747477747, 747477774, 747477777, 747744444, 747744447, 747744474, 747744477, 747744744, 747744747, 747744774, 747744777, 747747444, 747747447, 747747474, 747747477, 747747744, 747747747, 747747774, 747747777, 747774444, 747774447, 747774474, 747774477, 747774744, 747774747, 747774774, 747774777, 747777444, 747777447, 747777474, 747777477, 747777744, 747777747, 747777774, 747777777, 774444444, 774444447, 774444474, 774444477, 774444744, 774444747, 774444774, 774444777, 774447444, 774447447, 774447474, 774447477, 774447744, 774447747, 774447774, 774447777, 774474444, 774474447, 774474474, 774474477, 774474744, 774474747, 774474774, 774474777, 774477444, 774477447, 774477474, 774477477, 774477744, 774477747, 774477774, 774477777, 774744444, 774744447, 774744474, 774744477, 774744744, 774744747, 774744774, 774744777, 774747444, 774747447, 774747474, 774747477, 774747744, 774747747, 774747774, 774747777, 774774444, 774774447, 774774474, 774774477, 774774744, 774774747, 774774774, 774774777, 774777444, 774777447, 774777474, 774777477, 774777744, 774777747, 774777774, 774777777, 777444444, 777444447, 777444474, 777444477, 777444744, 777444747, 777444774, 777444777, 777447444, 777447447, 777447474, 777447477, 777447744, 777447747, 777447774, 777447777, 777474444, 777474447, 777474474, 777474477, 777474744, 777474747, 777474774, 777474777, 777477444, 777477447, 777477474, 777477477, 777477744, 777477747, 777477774, 777477777, 777744444, 777744447, 777744474, 777744477, 777744744, 777744747, 777744774, 777744777, 777747444, 777747447, 777747474, 777747477, 777747744, 777747747, 777747774, 777747777, 777774444, 777774447, 777774474, 777774477, 777774744, 777774747, 777774774, 777774777, 777777444, 777777447, 777777474, 777777477, 777777744, 777777747, 777777774, 777777777, 4444444444, 4444444447, 4444444474, 4444444477, 4444444744, 4444444747, 4444444774, 4444444777, 4444447444, 4444447447, 4444447474, 4444447477, 4444447744, 4444447747, 4444447774, 4444447777, 4444474444, 4444474447, 4444474474, 4444474477, 4444474744, 4444474747, 4444474774, 4444474777, 4444477444, 4444477447, 4444477474, 4444477477, 4444477744, 4444477747, 4444477774, 4444477777, 4444744444, 4444744447, 4444744474, 4444744477, 4444744744, 4444744747, 4444744774, 4444744777, 4444747444, 4444747447, 4444747474, 4444747477, 4444747744, 4444747747, 4444747774, 4444747777, 4444774444, 4444774447, 4444774474, 4444774477, 4444774744, 4444774747, 4444774774, 4444774777, 4444777444, 4444777447, 4444777474, 4444777477, 4444777744, 4444777747, 4444777774, 4444777777, 4447444444, 4447444447, 4447444474, 4447444477, 4447444744, 4447444747, 4447444774, 4447444777, 4447447444, 4447447447, 4447447474, 4447447477, 4447447744, 4447447747, 4447447774, 4447447777, 4447474444, 4447474447, 4447474474, 4447474477, 4447474744, 4447474747, 4447474774, 4447474777, 4447477444, 4447477447, 4447477474, 4447477477, 4447477744, 4447477747, 4447477774, 4447477777, 4447744444, 4447744447, 4447744474, 4447744477, 4447744744, 4447744747, 4447744774, 4447744777, 4447747444, 4447747447, 4447747474, 4447747477, 4447747744, 4447747747, 4447747774, 4447747777, 4447774444, 4447774447, 4447774474, 4447774477, 4447774744, 4447774747, 4447774774, 4447774777, 4447777444, 4447777447, 4447777474, 4447777477, 4447777744, 4447777747, 4447777774, 4447777777, 4474444444, 4474444447, 4474444474, 4474444477, 4474444744, 4474444747, 4474444774, 4474444777, 4474447444, 4474447447, 4474447474, 4474447477, 4474447744, 4474447747, 4474447774, 4474447777, 4474474444, 4474474447, 4474474474, 4474474477, 4474474744, 4474474747, 4474474774, 4474474777, 4474477444, 4474477447, 4474477474, 4474477477, 4474477744, 4474477747, 4474477774, 4474477777, 4474744444, 4474744447, 4474744474, 4474744477, 4474744744, 4474744747, 4474744774, 4474744777, 4474747444, 4474747447, 4474747474, 4474747477, 4474747744, 4474747747, 4474747774, 4474747777, 4474774444, 4474774447, 4474774474, 4474774477, 4474774744, 4474774747, 4474774774, 4474774777, 4474777444, 4474777447, 4474777474, 4474777477, 4474777744, 4474777747, 4474777774, 4474777777, 4477444444, 4477444447, 4477444474, 4477444477, 4477444744, 4477444747, 4477444774, 4477444777, 4477447444, 4477447447, 4477447474, 4477447477, 4477447744, 4477447747, 4477447774, 4477447777, 4477474444, 4477474447, 4477474474, 4477474477, 4477474744, 4477474747, 4477474774, 4477474777, 4477477444, 4477477447, 4477477474, 4477477477, 4477477744, 4477477747, 4477477774, 4477477777, 4477744444, 4477744447, 4477744474, 4477744477, 4477744744, 4477744747, 4477744774, 4477744777, 4477747444, 4477747447, 4477747474, 4477747477, 4477747744, 4477747747, 4477747774, 4477747777, 4477774444, 4477774447, 4477774474, 4477774477, 4477774744, 4477774747, 4477774774, 4477774777, 4477777444, 4477777447, 4477777474, 4477777477, 4477777744, 4477777747, 4477777774, 4477777777, 4744444444, 4744444447, 4744444474, 4744444477, 4744444744, 4744444747, 4744444774, 4744444777, 4744447444, 4744447447, 4744447474, 4744447477, 4744447744, 4744447747, 4744447774, 4744447777, 4744474444, 4744474447, 4744474474, 4744474477, 4744474744, 4744474747, 4744474774, 4744474777, 4744477444, 4744477447, 4744477474, 4744477477, 4744477744, 4744477747, 4744477774, 4744477777, 4744744444, 4744744447, 4744744474, 4744744477, 4744744744, 4744744747, 4744744774, 4744744777, 4744747444, 4744747447, 4744747474, 4744747477, 4744747744, 4744747747, 4744747774, 4744747777, 4744774444, 4744774447, 4744774474, 4744774477, 4744774744, 4744774747, 4744774774, 4744774777, 4744777444, 4744777447, 4744777474, 4744777477, 4744777744, 4744777747, 4744777774, 4744777777, 4747444444, 4747444447, 4747444474, 4747444477, 4747444744, 4747444747, 4747444774, 4747444777, 4747447444, 4747447447, 4747447474, 4747447477, 4747447744, 4747447747, 4747447774, 4747447777, 4747474444, 4747474447, 4747474474, 4747474477, 4747474744, 4747474747, 4747474774, 4747474777, 4747477444, 4747477447, 4747477474, 4747477477, 4747477744, 4747477747, 4747477774, 4747477777, 4747744444, 4747744447, 4747744474, 4747744477, 4747744744, 4747744747, 4747744774, 4747744777, 4747747444, 4747747447, 4747747474, 4747747477, 4747747744, 4747747747, 4747747774, 4747747777, 4747774444, 4747774447, 4747774474, 4747774477, 4747774744, 4747774747, 4747774774, 4747774777, 4747777444, 4747777447, 4747777474, 4747777477, 4747777744, 4747777747, 4747777774, 4747777777, 4774444444, 4774444447, 4774444474, 4774444477, 4774444744, 4774444747, 4774444774, 4774444777, 4774447444, 4774447447, 4774447474, 4774447477, 4774447744, 4774447747, 4774447774, 4774447777, 4774474444, 4774474447, 4774474474, 4774474477, 4774474744, 4774474747, 4774474774, 4774474777, 4774477444, 4774477447, 4774477474, 4774477477, 4774477744, 4774477747, 4774477774, 4774477777, 4774744444, 4774744447, 4774744474, 4774744477, 4774744744, 4774744747, 4774744774, 4774744777, 4774747444, 4774747447, 4774747474, 4774747477, 4774747744, 4774747747, 4774747774, 4774747777, 4774774444, 4774774447, 4774774474, 4774774477, 4774774744, 4774774747, 4774774774, 4774774777, 4774777444, 4774777447, 4774777474, 4774777477, 4774777744, 4774777747, 4774777774, 4774777777, 4777444444, 4777444447, 4777444474, 4777444477, 4777444744, 4777444747, 4777444774, 4777444777, 4777447444, 4777447447, 4777447474, 4777447477, 4777447744, 4777447747, 4777447774, 4777447777, 4777474444, 4777474447, 4777474474, 4777474477, 4777474744, 4777474747, 4777474774, 4777474777, 4777477444, 4777477447, 4777477474, 4777477477, 4777477744, 4777477747, 4777477774, 4777477777, 4777744444, 4777744447, 4777744474, 4777744477, 4777744744, 4777744747, 4777744774, 4777744777, 4777747444, 4777747447, 4777747474, 4777747477, 4777747744, 4777747747, 4777747774, 4777747777, 4777774444, 4777774447, 4777774474, 4777774477, 4777774744, 4777774747, 4777774774, 4777774777, 4777777444, 4777777447, 4777777474, 4777777477, 4777777744, 4777777747, 4777777774, 4777777777, 7444444444, 7444444447, 7444444474, 7444444477, 7444444744, 7444444747, 7444444774, 7444444777, 7444447444, 7444447447, 7444447474, 7444447477, 7444447744, 7444447747, 7444447774, 7444447777, 7444474444, 7444474447, 7444474474, 7444474477, 7444474744, 7444474747, 7444474774, 7444474777, 7444477444, 7444477447, 7444477474, 7444477477, 7444477744, 7444477747, 7444477774, 7444477777, 7444744444, 7444744447, 7444744474, 7444744477, 7444744744, 7444744747, 7444744774, 7444744777, 7444747444, 7444747447, 7444747474, 7444747477, 7444747744, 7444747747, 7444747774, 7444747777, 7444774444, 7444774447, 7444774474, 7444774477, 7444774744, 7444774747, 7444774774, 7444774777, 7444777444, 7444777447, 7444777474, 7444777477, 7444777744, 7444777747, 7444777774, 7444777777, 7447444444, 7447444447, 7447444474, 7447444477, 7447444744, 7447444747, 7447444774, 7447444777, 7447447444, 7447447447, 7447447474, 7447447477, 7447447744, 7447447747, 7447447774, 7447447777, 7447474444, 7447474447, 7447474474, 7447474477, 7447474744, 7447474747, 7447474774, 7447474777, 7447477444, 7447477447, 7447477474, 7447477477, 7447477744, 7447477747, 7447477774, 7447477777, 7447744444, 7447744447, 7447744474, 7447744477, 7447744744, 7447744747, 7447744774, 7447744777, 7447747444, 7447747447, 7447747474, 7447747477, 7447747744, 7447747747, 7447747774, 7447747777, 7447774444, 7447774447, 7447774474, 7447774477, 7447774744, 7447774747, 7447774774, 7447774777, 7447777444, 7447777447, 7447777474, 7447777477, 7447777744, 7447777747, 7447777774, 7447777777, 7474444444, 7474444447, 7474444474, 7474444477, 7474444744, 7474444747, 7474444774, 7474444777, 7474447444, 7474447447, 7474447474, 7474447477, 7474447744, 7474447747, 7474447774, 7474447777, 7474474444, 7474474447, 7474474474, 7474474477, 7474474744, 7474474747, 7474474774, 7474474777, 7474477444, 7474477447, 7474477474, 7474477477, 7474477744, 7474477747, 7474477774, 7474477777, 7474744444, 7474744447, 7474744474, 7474744477, 7474744744, 7474744747, 7474744774, 7474744777, 7474747444, 7474747447, 7474747474, 7474747477, 7474747744, 7474747747, 7474747774, 7474747777, 7474774444, 7474774447, 7474774474, 7474774477, 7474774744, 7474774747, 7474774774, 7474774777, 7474777444, 7474777447, 7474777474, 7474777477, 7474777744, 7474777747, 7474777774, 7474777777, 7477444444, 7477444447, 7477444474, 7477444477, 7477444744, 7477444747, 7477444774, 7477444777, 7477447444, 7477447447, 7477447474, 7477447477, 7477447744, 7477447747, 7477447774, 7477447777, 7477474444, 7477474447, 7477474474, 7477474477, 7477474744, 7477474747, 7477474774, 7477474777, 7477477444, 7477477447, 7477477474, 7477477477, 7477477744, 7477477747, 7477477774, 7477477777, 7477744444, 7477744447, 7477744474, 7477744477, 7477744744, 7477744747, 7477744774, 7477744777, 7477747444, 7477747447, 7477747474, 7477747477, 7477747744, 7477747747, 7477747774, 7477747777, 7477774444, 7477774447, 7477774474, 7477774477, 7477774744, 7477774747, 7477774774, 7477774777, 7477777444, 7477777447, 7477777474, 7477777477, 7477777744, 7477777747, 7477777774, 7477777777, 7744444444, 7744444447, 7744444474, 7744444477, 7744444744, 7744444747, 7744444774, 7744444777, 7744447444, 7744447447, 7744447474, 7744447477, 7744447744, 7744447747, 7744447774, 7744447777, 7744474444, 7744474447, 7744474474, 7744474477, 7744474744, 7744474747, 7744474774, 7744474777, 7744477444, 7744477447, 7744477474, 7744477477, 7744477744, 7744477747, 7744477774, 7744477777, 7744744444, 7744744447, 7744744474, 7744744477, 7744744744, 7744744747, 7744744774, 7744744777, 7744747444, 7744747447, 7744747474, 7744747477, 7744747744, 7744747747, 7744747774, 7744747777, 7744774444, 7744774447, 7744774474, 7744774477, 7744774744, 7744774747, 7744774774, 7744774777, 7744777444, 7744777447, 7744777474, 7744777477, 7744777744, 7744777747, 7744777774, 7744777777, 7747444444, 7747444447, 7747444474, 7747444477, 7747444744, 7747444747, 7747444774, 7747444777, 7747447444, 7747447447, 7747447474, 7747447477, 7747447744, 7747447747, 7747447774, 7747447777, 7747474444, 7747474447, 7747474474, 7747474477, 7747474744, 7747474747, 7747474774, 7747474777, 7747477444, 7747477447, 7747477474, 7747477477, 7747477744, 7747477747, 7747477774, 7747477777, 7747744444, 7747744447, 7747744474, 7747744477, 7747744744, 7747744747, 7747744774, 7747744777, 7747747444, 7747747447, 7747747474, 7747747477, 7747747744, 7747747747, 7747747774, 7747747777, 7747774444, 7747774447, 7747774474, 7747774477, 7747774744, 7747774747, 7747774774, 7747774777, 7747777444, 7747777447, 7747777474, 7747777477, 7747777744, 7747777747, 7747777774, 7747777777, 7774444444, 7774444447, 7774444474, 7774444477, 7774444744, 7774444747, 7774444774, 7774444777, 7774447444, 7774447447, 7774447474, 7774447477, 7774447744, 7774447747, 7774447774, 7774447777, 7774474444, 7774474447, 7774474474, 7774474477, 7774474744, 7774474747, 7774474774, 7774474777, 7774477444, 7774477447, 7774477474, 7774477477, 7774477744, 7774477747, 7774477774, 7774477777, 7774744444, 7774744447, 7774744474, 7774744477, 7774744744, 7774744747, 7774744774, 7774744777, 7774747444, 7774747447, 7774747474, 7774747477, 7774747744, 7774747747, 7774747774, 7774747777, 7774774444, 7774774447, 7774774474, 7774774477, 7774774744, 7774774747, 7774774774, 7774774777, 7774777444, 7774777447, 7774777474, 7774777477, 7774777744, 7774777747, 7774777774, 7774777777, 7777444444, 7777444447, 7777444474, 7777444477, 7777444744, 7777444747, 7777444774, 7777444777, 7777447444, 7777447447, 7777447474, 7777447477, 7777447744, 7777447747, 7777447774, 7777447777, 7777474444, 7777474447, 7777474474, 7777474477, 7777474744, 7777474747, 7777474774, 7777474777, 7777477444, 7777477447, 7777477474, 7777477477, 7777477744, 7777477747, 7777477774, 7777477777, 7777744444, 7777744447, 7777744474, 7777744477, 7777744744, 7777744747, 7777744774, 7777744777, 7777747444, 7777747447, 7777747474, 7777747477, 7777747744, 7777747747, 7777747774, 7777747777, 7777774444, 7777774447, 7777774474, 7777774477, 7777774744, 7777774747, 7777774774, 7777774777, 7777777444, 7777777447, 7777777474, 7777777477, 7777777744, 7777777747, 7777777774, 7777777777, 44444444444, 44444444447, 44444444474, 44444444477, 44444444744, 44444444747, 44444444774, 44444444777, 44444447444, 44444447447, 44444447474, 44444447477, 44444447744, 44444447747, 44444447774, 44444447777, 44444474444, 44444474447, 44444474474, 44444474477, 44444474744, 44444474747, 44444474774, 44444474777, 44444477444, 44444477447, 44444477474, 44444477477, 44444477744, 44444477747, 44444477774, 44444477777, 44444744444, 44444744447, 44444744474, 44444744477, 44444744744, 44444744747, 44444744774, 44444744777, 44444747444, 44444747447, 44444747474, 44444747477, 44444747744, 44444747747, 44444747774, 44444747777, 44444774444, 44444774447, 44444774474, 44444774477, 44444774744, 44444774747, 44444774774, 44444774777, 44444777444, 44444777447, 44444777474, 44444777477, 44444777744, 44444777747, 44444777774, 44444777777, 44447444444, 44447444447, 44447444474, 44447444477, 44447444744, 44447444747, 44447444774, 44447444777, 44447447444, 44447447447, 44447447474, 44447447477, 44447447744, 44447447747, 44447447774, 44447447777, 44447474444, 44447474447, 44447474474, 44447474477, 44447474744, 44447474747, 44447474774, 44447474777, 44447477444, 44447477447, 44447477474, 44447477477, 44447477744, 44447477747, 44447477774, 44447477777, 44447744444, 44447744447, 44447744474, 44447744477, 44447744744, 44447744747, 44447744774, 44447744777, 44447747444, 44447747447, 44447747474, 44447747477, 44447747744, 44447747747, 44447747774, 44447747777, 44447774444, 44447774447, 44447774474, 44447774477, 44447774744, 44447774747, 44447774774, 44447774777, 44447777444, 44447777447, 44447777474, 44447777477, 44447777744, 44447777747, 44447777774, 44447777777, 44474444444, 44474444447, 44474444474, 44474444477, 44474444744, 44474444747, 44474444774, 44474444777, 44474447444, 44474447447, 44474447474, 44474447477, 44474447744, 44474447747, 44474447774, 44474447777, 44474474444, 44474474447, 44474474474, 44474474477, 44474474744, 44474474747, 44474474774, 44474474777, 44474477444, 44474477447, 44474477474, 44474477477, 44474477744, 44474477747, 44474477774, 44474477777, 44474744444, 44474744447, 44474744474, 44474744477, 44474744744, 44474744747, 44474744774, 44474744777, 44474747444, 44474747447, 44474747474, 44474747477, 44474747744, 44474747747, 44474747774, 44474747777, 44474774444, 44474774447, 44474774474, 44474774477, 44474774744, 44474774747, 44474774774, 44474774777, 44474777444, 44474777447, 44474777474, 44474777477, 44474777744, 44474777747, 44474777774, 44474777777, 44477444444, 44477444447, 44477444474, 44477444477, 44477444744, 44477444747, 44477444774, 44477444777, 44477447444, 44477447447, 44477447474, 44477447477, 44477447744, 44477447747, 44477447774, 44477447777, 44477474444, 44477474447, 44477474474, 44477474477, 44477474744, 44477474747, 44477474774, 44477474777, 44477477444, 44477477447, 44477477474, 44477477477, 44477477744, 44477477747, 44477477774, 44477477777, 44477744444, 44477744447, 44477744474, 44477744477, 44477744744, 44477744747, 44477744774, 44477744777, 44477747444, 44477747447, 44477747474, 44477747477, 44477747744, 44477747747, 44477747774, 44477747777, 44477774444, 44477774447, 44477774474, 44477774477, 44477774744, 44477774747, 44477774774, 44477774777, 44477777444, 44477777447, 44477777474, 44477777477, 44477777744, 44477777747, 44477777774, 44477777777, 44744444444, 44744444447, 44744444474, 44744444477, 44744444744, 44744444747, 44744444774, 44744444777, 44744447444, 44744447447, 44744447474, 44744447477, 44744447744, 44744447747, 44744447774, 44744447777, 44744474444, 44744474447, 44744474474, 44744474477, 44744474744, 44744474747, 44744474774, 44744474777, 44744477444, 44744477447, 44744477474, 44744477477, 44744477744, 44744477747, 44744477774, 44744477777, 44744744444, 44744744447, 44744744474, 44744744477, 44744744744, 44744744747, 44744744774, 44744744777, 44744747444, 44744747447, 44744747474, 44744747477, 44744747744, 44744747747, 44744747774, 44744747777, 44744774444, 44744774447, 44744774474, 44744774477, 44744774744, 44744774747, 44744774774, 44744774777, 44744777444, 44744777447, 44744777474, 44744777477, 44744777744, 44744777747, 44744777774, 44744777777, 44747444444, 44747444447, 44747444474, 44747444477, 44747444744, 44747444747, 44747444774, 44747444777, 44747447444, 44747447447, 44747447474, 44747447477, 44747447744, 44747447747, 44747447774, 44747447777, 44747474444, 44747474447, 44747474474, 44747474477, 44747474744, 44747474747, 44747474774, 44747474777, 44747477444, 44747477447, 44747477474, 44747477477, 44747477744, 44747477747, 44747477774, 44747477777, 44747744444, 44747744447, 44747744474, 44747744477, 44747744744, 44747744747, 44747744774, 44747744777, 44747747444, 44747747447, 44747747474, 44747747477, 44747747744, 44747747747, 44747747774, 44747747777, 44747774444, 44747774447, 44747774474, 44747774477, 44747774744, 44747774747, 44747774774, 44747774777, 44747777444, 44747777447, 44747777474, 44747777477, 44747777744, 44747777747, 44747777774, 44747777777, 44774444444, 44774444447, 44774444474, 44774444477, 44774444744, 44774444747, 44774444774, 44774444777, 44774447444, 44774447447, 44774447474, 44774447477, 44774447744, 44774447747, 44774447774, 44774447777, 44774474444, 44774474447, 44774474474, 44774474477, 44774474744, 44774474747, 44774474774, 44774474777, 44774477444, 44774477447, 44774477474, 44774477477, 44774477744, 44774477747, 44774477774, 44774477777, 44774744444, 44774744447, 44774744474, 44774744477, 44774744744, 44774744747, 44774744774, 44774744777, 44774747444, 44774747447, 44774747474, 44774747477, 44774747744, 44774747747, 44774747774, 44774747777, 44774774444, 44774774447, 44774774474, 44774774477, 44774774744, 44774774747, 44774774774, 44774774777, 44774777444, 44774777447, 44774777474, 44774777477, 44774777744, 44774777747, 44774777774, 44774777777, 44777444444, 44777444447, 44777444474, 44777444477, 44777444744, 44777444747, 44777444774, 44777444777, 44777447444, 44777447447, 44777447474, 44777447477, 44777447744, 44777447747, 44777447774, 44777447777, 44777474444, 44777474447, 44777474474, 44777474477, 44777474744, 44777474747, 44777474774, 44777474777, 44777477444, 44777477447, 44777477474, 44777477477, 44777477744, 44777477747, 44777477774, 44777477777, 44777744444, 44777744447, 44777744474, 44777744477, 44777744744, 44777744747, 44777744774, 44777744777, 44777747444, 44777747447, 44777747474, 44777747477, 44777747744, 44777747747, 44777747774, 44777747777, 44777774444, 44777774447, 44777774474, 44777774477, 44777774744, 44777774747, 44777774774, 44777774777, 44777777444, 44777777447, 44777777474, 44777777477, 44777777744, 44777777747, 44777777774, 44777777777, 47444444444, 47444444447, 47444444474, 47444444477, 47444444744, 47444444747, 47444444774, 47444444777, 47444447444, 47444447447, 47444447474, 47444447477, 47444447744, 47444447747, 47444447774, 47444447777, 47444474444, 47444474447, 47444474474, 47444474477, 47444474744, 47444474747, 47444474774, 47444474777, 47444477444, 47444477447, 47444477474, 47444477477, 47444477744, 47444477747, 47444477774, 47444477777, 47444744444, 47444744447, 47444744474, 47444744477, 47444744744, 47444744747, 47444744774, 47444744777, 47444747444, 47444747447, 47444747474, 47444747477, 47444747744, 47444747747, 47444747774, 47444747777, 47444774444, 47444774447, 47444774474, 47444774477, 47444774744, 47444774747, 47444774774, 47444774777, 47444777444, 47444777447, 47444777474, 47444777477, 47444777744, 47444777747, 47444777774, 47444777777, 47447444444, 47447444447, 47447444474, 47447444477, 47447444744, 47447444747, 47447444774, 47447444777, 47447447444, 47447447447, 47447447474, 47447447477, 47447447744, 47447447747, 47447447774, 47447447777, 47447474444, 47447474447, 47447474474, 47447474477, 47447474744, 47447474747, 47447474774, 47447474777, 47447477444, 47447477447, 47447477474, 47447477477, 47447477744, 47447477747, 47447477774, 47447477777, 47447744444, 47447744447, 47447744474, 47447744477, 47447744744, 47447744747, 47447744774, 47447744777, 47447747444, 47447747447, 47447747474, 47447747477, 47447747744, 47447747747, 47447747774, 47447747777, 47447774444, 47447774447, 47447774474, 47447774477, 47447774744, 47447774747, 47447774774, 47447774777, 47447777444, 47447777447, 47447777474, 47447777477, 47447777744, 47447777747, 47447777774, 47447777777, 47474444444, 47474444447, 47474444474, 47474444477, 47474444744, 47474444747, 47474444774, 47474444777, 47474447444, 47474447447, 47474447474, 47474447477, 47474447744, 47474447747, 47474447774, 47474447777, 47474474444, 47474474447, 47474474474, 47474474477, 47474474744, 47474474747, 47474474774, 47474474777, 47474477444, 47474477447, 47474477474, 47474477477, 47474477744, 47474477747, 47474477774, 47474477777, 47474744444, 47474744447, 47474744474, 47474744477, 47474744744, 47474744747, 47474744774, 47474744777, 47474747444, 47474747447, 47474747474, 47474747477, 47474747744, 47474747747, 47474747774, 47474747777, 47474774444, 47474774447, 47474774474, 47474774477, 47474774744, 47474774747, 47474774774, 47474774777, 47474777444, 47474777447, 47474777474, 47474777477, 47474777744, 47474777747, 47474777774, 47474777777, 47477444444, 47477444447, 47477444474, 47477444477, 47477444744, 47477444747, 47477444774, 47477444777, 47477447444, 47477447447, 47477447474, 47477447477, 47477447744, 47477447747, 47477447774, 47477447777, 47477474444, 47477474447, 47477474474, 47477474477, 47477474744, 47477474747, 47477474774, 47477474777, 47477477444, 47477477447, 47477477474, 47477477477, 47477477744, 47477477747, 47477477774, 47477477777, 47477744444, 47477744447, 47477744474, 47477744477, 47477744744, 47477744747, 47477744774, 47477744777, 47477747444, 47477747447, 47477747474, 47477747477, 47477747744, 47477747747, 47477747774, 47477747777, 47477774444, 47477774447, 47477774474, 47477774477, 47477774744, 47477774747, 47477774774, 47477774777, 47477777444, 47477777447, 47477777474, 47477777477, 47477777744, 47477777747, 47477777774, 47477777777, 47744444444, 47744444447, 47744444474, 47744444477, 47744444744, 47744444747, 47744444774, 47744444777, 47744447444, 47744447447, 47744447474, 47744447477, 47744447744, 47744447747, 47744447774, 47744447777, 47744474444, 47744474447, 47744474474, 47744474477, 47744474744, 47744474747, 47744474774, 47744474777, 47744477444, 47744477447, 47744477474, 47744477477, 47744477744, 47744477747, 47744477774, 47744477777, 47744744444, 47744744447, 47744744474, 47744744477, 47744744744, 47744744747, 47744744774, 47744744777, 47744747444, 47744747447, 47744747474, 47744747477, 47744747744, 47744747747, 47744747774, 47744747777, 47744774444, 47744774447, 47744774474, 47744774477, 47744774744, 47744774747, 47744774774, 47744774777, 47744777444, 47744777447, 47744777474, 47744777477, 47744777744, 47744777747, 47744777774, 47744777777, 47747444444, 47747444447, 47747444474, 47747444477, 47747444744, 47747444747, 47747444774, 47747444777, 47747447444, 47747447447, 47747447474, 47747447477, 47747447744, 47747447747, 47747447774, 47747447777, 47747474444, 47747474447, 47747474474, 47747474477, 47747474744, 47747474747, 47747474774, 47747474777, 47747477444, 47747477447, 47747477474, 47747477477, 47747477744, 47747477747, 47747477774, 47747477777, 47747744444, 47747744447, 47747744474, 47747744477, 47747744744, 47747744747, 47747744774, 47747744777, 47747747444, 47747747447, 47747747474, 47747747477, 47747747744, 47747747747, 47747747774, 47747747777, 47747774444, 47747774447, 47747774474, 47747774477, 47747774744, 47747774747, 47747774774, 47747774777, 47747777444, 47747777447, 47747777474, 47747777477, 47747777744, 47747777747, 47747777774, 47747777777, 47774444444, 47774444447, 47774444474, 47774444477, 47774444744, 47774444747, 47774444774, 47774444777, 47774447444, 47774447447, 47774447474, 47774447477, 47774447744, 47774447747, 47774447774, 47774447777, 47774474444, 47774474447, 47774474474, 47774474477, 47774474744, 47774474747, 47774474774, 47774474777, 47774477444, 47774477447, 47774477474, 47774477477, 47774477744, 47774477747, 47774477774, 47774477777, 47774744444, 47774744447, 47774744474, 47774744477, 47774744744, 47774744747, 47774744774, 47774744777, 47774747444, 47774747447, 47774747474, 47774747477, 47774747744, 47774747747, 47774747774, 47774747777, 47774774444, 47774774447, 47774774474, 47774774477, 47774774744, 47774774747, 47774774774, 47774774777, 47774777444, 47774777447, 47774777474, 47774777477, 47774777744, 47774777747, 47774777774, 47774777777, 47777444444, 47777444447, 47777444474, 47777444477, 47777444744, 47777444747, 47777444774, 47777444777, 47777447444, 47777447447, 47777447474, 47777447477, 47777447744, 47777447747, 47777447774, 47777447777, 47777474444, 47777474447, 47777474474, 47777474477, 47777474744, 47777474747, 47777474774, 47777474777, 47777477444, 47777477447, 47777477474, 47777477477, 47777477744, 47777477747, 47777477774, 47777477777, 47777744444, 47777744447, 47777744474, 47777744477, 47777744744, 47777744747, 47777744774, 47777744777, 47777747444, 47777747447, 47777747474, 47777747477, 47777747744, 47777747747, 47777747774, 47777747777, 47777774444, 47777774447, 47777774474, 47777774477, 47777774744, 47777774747, 47777774774, 47777774777, 47777777444, 47777777447, 47777777474, 47777777477, 47777777744, 47777777747, 47777777774, 47777777777, 74444444444, 74444444447, 74444444474, 74444444477, 74444444744, 74444444747, 74444444774, 74444444777, 74444447444, 74444447447, 74444447474, 74444447477, 74444447744, 74444447747, 74444447774, 74444447777, 74444474444, 74444474447, 74444474474, 74444474477, 74444474744, 74444474747, 74444474774, 74444474777, 74444477444, 74444477447, 74444477474, 74444477477, 74444477744, 74444477747, 74444477774, 74444477777, 74444744444, 74444744447, 74444744474, 74444744477, 74444744744, 74444744747, 74444744774, 74444744777, 74444747444, 74444747447, 74444747474, 74444747477, 74444747744, 74444747747, 74444747774, 74444747777, 74444774444, 74444774447, 74444774474, 74444774477, 74444774744, 74444774747, 74444774774, 74444774777, 74444777444, 74444777447, 74444777474, 74444777477, 74444777744, 74444777747, 74444777774, 74444777777, 74447444444, 74447444447, 74447444474, 74447444477, 74447444744, 74447444747, 74447444774, 74447444777, 74447447444, 74447447447, 74447447474, 74447447477, 74447447744, 74447447747, 74447447774, 74447447777, 74447474444, 74447474447, 74447474474, 74447474477, 74447474744, 74447474747, 74447474774, 74447474777, 74447477444, 74447477447, 74447477474, 74447477477, 74447477744, 74447477747, 74447477774, 74447477777, 74447744444, 74447744447, 74447744474, 74447744477, 74447744744, 74447744747, 74447744774, 74447744777, 74447747444, 74447747447, 74447747474, 74447747477, 74447747744, 74447747747, 74447747774, 74447747777, 74447774444, 74447774447, 74447774474, 74447774477, 74447774744, 74447774747, 74447774774, 74447774777, 74447777444, 74447777447, 74447777474, 74447777477, 74447777744, 74447777747, 74447777774, 74447777777, 74474444444, 74474444447, 74474444474, 74474444477, 74474444744, 74474444747, 74474444774, 74474444777, 74474447444, 74474447447, 74474447474, 74474447477, 74474447744, 74474447747, 74474447774, 74474447777, 74474474444, 74474474447, 74474474474, 74474474477, 74474474744, 74474474747, 74474474774, 74474474777, 74474477444, 74474477447, 74474477474, 74474477477, 74474477744, 74474477747, 74474477774, 74474477777, 74474744444, 74474744447, 74474744474, 74474744477, 74474744744, 74474744747, 74474744774, 74474744777, 74474747444, 74474747447, 74474747474, 74474747477, 74474747744, 74474747747, 74474747774, 74474747777, 74474774444, 74474774447, 74474774474, 74474774477, 74474774744, 74474774747, 74474774774, 74474774777, 74474777444, 74474777447, 74474777474, 74474777477, 74474777744, 74474777747, 74474777774, 74474777777, 74477444444, 74477444447, 74477444474, 74477444477, 74477444744, 74477444747, 74477444774, 74477444777, 74477447444, 74477447447, 74477447474, 74477447477, 74477447744, 74477447747, 74477447774, 74477447777, 74477474444, 74477474447, 74477474474, 74477474477, 74477474744, 74477474747, 74477474774, 74477474777, 74477477444, 74477477447, 74477477474, 74477477477, 74477477744, 74477477747, 74477477774, 74477477777, 74477744444, 74477744447, 74477744474, 74477744477, 74477744744, 74477744747, 74477744774, 74477744777, 74477747444, 74477747447, 74477747474, 74477747477, 74477747744, 74477747747, 74477747774, 74477747777, 74477774444, 74477774447, 74477774474, 74477774477, 74477774744, 74477774747, 74477774774, 74477774777, 74477777444, 74477777447, 74477777474, 74477777477, 74477777744, 74477777747, 74477777774, 74477777777, 74744444444, 74744444447, 74744444474, 74744444477, 74744444744, 74744444747, 74744444774, 74744444777, 74744447444, 74744447447, 74744447474, 74744447477, 74744447744, 74744447747, 74744447774, 74744447777, 74744474444, 74744474447, 74744474474, 74744474477, 74744474744, 74744474747, 74744474774, 74744474777, 74744477444, 74744477447, 74744477474, 74744477477, 74744477744, 74744477747, 74744477774, 74744477777, 74744744444, 74744744447, 74744744474, 74744744477, 74744744744, 74744744747, 74744744774, 74744744777, 74744747444, 74744747447, 74744747474, 74744747477, 74744747744, 74744747747, 74744747774, 74744747777, 74744774444, 74744774447, 74744774474, 74744774477, 74744774744, 74744774747, 74744774774, 74744774777, 74744777444, 74744777447, 74744777474, 74744777477, 74744777744, 74744777747, 74744777774, 74744777777, 74747444444, 74747444447, 74747444474, 74747444477, 74747444744, 74747444747, 74747444774, 74747444777, 74747447444, 74747447447, 74747447474, 74747447477, 74747447744, 74747447747, 74747447774, 74747447777, 74747474444, 74747474447, 74747474474, 74747474477, 74747474744, 74747474747, 74747474774, 74747474777, 74747477444, 74747477447, 74747477474, 74747477477, 74747477744, 74747477747, 74747477774, 74747477777, 74747744444, 74747744447, 74747744474, 74747744477, 74747744744, 74747744747, 74747744774, 74747744777, 74747747444, 74747747447, 74747747474, 74747747477, 74747747744, 74747747747, 74747747774, 74747747777, 74747774444, 74747774447, 74747774474, 74747774477, 74747774744, 74747774747, 74747774774, 74747774777, 74747777444, 74747777447, 74747777474, 74747777477, 74747777744, 74747777747, 74747777774, 74747777777, 74774444444, 74774444447, 74774444474, 74774444477, 74774444744, 74774444747, 74774444774, 74774444777, 74774447444, 74774447447, 74774447474, 74774447477, 74774447744, 74774447747, 74774447774, 74774447777, 74774474444, 74774474447, 74774474474, 74774474477, 74774474744, 74774474747, 74774474774, 74774474777, 74774477444, 74774477447, 74774477474, 74774477477, 74774477744, 74774477747, 74774477774, 74774477777, 74774744444, 74774744447, 74774744474, 74774744477, 74774744744, 74774744747, 74774744774, 74774744777, 74774747444, 74774747447, 74774747474, 74774747477, 74774747744, 74774747747, 74774747774, 74774747777, 74774774444, 74774774447, 74774774474, 74774774477, 74774774744, 74774774747, 74774774774, 74774774777, 74774777444, 74774777447, 74774777474, 74774777477, 74774777744, 74774777747, 74774777774, 74774777777, 74777444444, 74777444447, 74777444474, 74777444477, 74777444744, 74777444747, 74777444774, 74777444777, 74777447444, 74777447447, 74777447474, 74777447477, 74777447744, 74777447747, 74777447774, 74777447777, 74777474444, 74777474447, 74777474474, 74777474477, 74777474744, 74777474747, 74777474774, 74777474777, 74777477444, 74777477447, 74777477474, 74777477477, 74777477744, 74777477747, 74777477774, 74777477777, 74777744444, 74777744447, 74777744474, 74777744477, 74777744744, 74777744747, 74777744774, 74777744777, 74777747444, 74777747447, 74777747474, 74777747477, 74777747744, 74777747747, 74777747774, 74777747777, 74777774444, 74777774447, 74777774474, 74777774477, 74777774744, 74777774747, 74777774774, 74777774777, 74777777444, 74777777447, 74777777474, 74777777477, 74777777744, 74777777747, 74777777774, 74777777777, 77444444444, 77444444447, 77444444474, 77444444477, 77444444744, 77444444747, 77444444774, 77444444777, 77444447444, 77444447447, 77444447474, 77444447477, 77444447744, 77444447747, 77444447774, 77444447777, 77444474444, 77444474447, 77444474474, 77444474477, 77444474744, 77444474747, 77444474774, 77444474777, 77444477444, 77444477447, 77444477474, 77444477477, 77444477744, 77444477747, 77444477774, 77444477777, 77444744444, 77444744447, 77444744474, 77444744477, 77444744744, 77444744747, 77444744774, 77444744777, 77444747444, 77444747447, 77444747474, 77444747477, 77444747744, 77444747747, 77444747774, 77444747777, 77444774444, 77444774447, 77444774474, 77444774477, 77444774744, 77444774747, 77444774774, 77444774777, 77444777444, 77444777447, 77444777474, 77444777477, 77444777744, 77444777747, 77444777774, 77444777777, 77447444444, 77447444447, 77447444474, 77447444477, 77447444744, 77447444747, 77447444774, 77447444777, 77447447444, 77447447447, 77447447474, 77447447477, 77447447744, 77447447747, 77447447774, 77447447777, 77447474444, 77447474447, 77447474474, 77447474477, 77447474744, 77447474747, 77447474774, 77447474777, 77447477444, 77447477447, 77447477474, 77447477477, 77447477744, 77447477747, 77447477774, 77447477777, 77447744444, 77447744447, 77447744474, 77447744477, 77447744744, 77447744747, 77447744774, 77447744777, 77447747444, 77447747447, 77447747474, 77447747477, 77447747744, 77447747747, 77447747774, 77447747777, 77447774444, 77447774447, 77447774474, 77447774477, 77447774744, 77447774747, 77447774774, 77447774777, 77447777444, 77447777447, 77447777474, 77447777477, 77447777744, 77447777747, 77447777774, 77447777777, 77474444444, 77474444447, 77474444474, 77474444477, 77474444744, 77474444747, 77474444774, 77474444777, 77474447444, 77474447447, 77474447474, 77474447477, 77474447744, 77474447747, 77474447774, 77474447777, 77474474444, 77474474447, 77474474474, 77474474477, 77474474744, 77474474747, 77474474774, 77474474777, 77474477444, 77474477447, 77474477474, 77474477477, 77474477744, 77474477747, 77474477774, 77474477777, 77474744444, 77474744447, 77474744474, 77474744477, 77474744744, 77474744747, 77474744774, 77474744777, 77474747444, 77474747447, 77474747474, 77474747477, 77474747744, 77474747747, 77474747774, 77474747777, 77474774444, 77474774447, 77474774474, 77474774477, 77474774744, 77474774747, 77474774774, 77474774777, 77474777444, 77474777447, 77474777474, 77474777477, 77474777744, 77474777747, 77474777774, 77474777777, 77477444444, 77477444447, 77477444474, 77477444477, 77477444744, 77477444747, 77477444774, 77477444777, 77477447444, 77477447447, 77477447474, 77477447477, 77477447744, 77477447747, 77477447774, 77477447777, 77477474444, 77477474447, 77477474474, 77477474477, 77477474744, 77477474747, 77477474774, 77477474777, 77477477444, 77477477447, 77477477474, 77477477477, 77477477744, 77477477747, 77477477774, 77477477777, 77477744444, 77477744447, 77477744474, 77477744477, 77477744744, 77477744747, 77477744774, 77477744777, 77477747444, 77477747447, 77477747474, 77477747477, 77477747744, 77477747747, 77477747774, 77477747777, 77477774444, 77477774447, 77477774474, 77477774477, 77477774744, 77477774747, 77477774774, 77477774777, 77477777444, 77477777447, 77477777474, 77477777477, 77477777744, 77477777747, 77477777774, 77477777777, 77744444444, 77744444447, 77744444474, 77744444477, 77744444744, 77744444747, 77744444774, 77744444777, 77744447444, 77744447447, 77744447474, 77744447477, 77744447744, 77744447747, 77744447774, 77744447777, 77744474444, 77744474447, 77744474474, 77744474477, 77744474744, 77744474747, 77744474774, 77744474777, 77744477444, 77744477447, 77744477474, 77744477477, 77744477744, 77744477747, 77744477774, 77744477777, 77744744444, 77744744447, 77744744474, 77744744477, 77744744744, 77744744747, 77744744774, 77744744777, 77744747444, 77744747447, 77744747474, 77744747477, 77744747744, 77744747747, 77744747774, 77744747777, 77744774444, 77744774447, 77744774474, 77744774477, 77744774744, 77744774747, 77744774774, 77744774777, 77744777444, 77744777447, 77744777474, 77744777477, 77744777744, 77744777747, 77744777774, 77744777777, 77747444444, 77747444447, 77747444474, 77747444477, 77747444744, 77747444747, 77747444774, 77747444777, 77747447444, 77747447447, 77747447474, 77747447477, 77747447744, 77747447747, 77747447774, 77747447777, 77747474444, 77747474447, 77747474474, 77747474477, 77747474744, 77747474747, 77747474774, 77747474777, 77747477444, 77747477447, 77747477474, 77747477477, 77747477744, 77747477747, 77747477774, 77747477777, 77747744444, 77747744447, 77747744474, 77747744477, 77747744744, 77747744747, 77747744774, 77747744777, 77747747444, 77747747447, 77747747474, 77747747477, 77747747744, 77747747747, 77747747774, 77747747777, 77747774444, 77747774447, 77747774474, 77747774477, 77747774744, 77747774747, 77747774774, 77747774777, 77747777444, 77747777447, 77747777474, 77747777477, 77747777744, 77747777747, 77747777774, 77747777777, 77774444444, 77774444447, 77774444474, 77774444477, 77774444744, 77774444747, 77774444774, 77774444777, 77774447444, 77774447447, 77774447474, 77774447477, 77774447744, 77774447747, 77774447774, 77774447777, 77774474444, 77774474447, 77774474474, 77774474477, 77774474744, 77774474747, 77774474774, 77774474777, 77774477444, 77774477447, 77774477474, 77774477477, 77774477744, 77774477747, 77774477774, 77774477777, 77774744444, 77774744447, 77774744474, 77774744477, 77774744744, 77774744747, 77774744774, 77774744777, 77774747444, 77774747447, 77774747474, 77774747477, 77774747744, 77774747747, 77774747774, 77774747777, 77774774444, 77774774447, 77774774474, 77774774477, 77774774744, 77774774747, 77774774774, 77774774777, 77774777444, 77774777447, 77774777474, 77774777477, 77774777744, 77774777747, 77774777774, 77774777777, 77777444444, 77777444447, 77777444474, 77777444477, 77777444744, 77777444747, 77777444774, 77777444777, 77777447444, 77777447447, 77777447474, 77777447477, 77777447744, 77777447747, 77777447774, 77777447777, 77777474444, 77777474447, 77777474474, 77777474477, 77777474744, 77777474747, 77777474774, 77777474777, 77777477444, 77777477447, 77777477474, 77777477477, 77777477744, 77777477747, 77777477774, 77777477777, 77777744444, 77777744447, 77777744474, 77777744477, 77777744744, 77777744747, 77777744774, 77777744777, 77777747444, 77777747447, 77777747474, 77777747477, 77777747744, 77777747747, 77777747774, 77777747777, 77777774444, 77777774447, 77777774474, 77777774477, 77777774744, 77777774747, 77777774774, 77777774777, 77777777444, 77777777447, 77777777474, 77777777477, 77777777744, 77777777747, 77777777774, 77777777777]

l, r = a()
d = 0
for i in range(l, r+1):
    x = c(b, i)
    if b[x-1] == i:
        d += i 
    else:
        d += b[x]
print(d)","import i
import f

def e():

    c = i.stdin.read().strip().split()
    if not c:
        return

    n = int(c[0])
    b = []

    for i in range(n):
        x = float(c[1 + 2 * i])
        y = float(c[1 + 2 * i + 1])

        a = f.degrees(f.atan2(y, x))

        if a < 0:
            a += 360
        b.append(a)

    b.sort()

    g = 0.0
    for i in range(1, n):
        d = b[i] - b[i - 1]
        if d > g:
            g = d

    d = (360 - b[-1]) + b[0]
    if d > g:
        g = d

    h = 360 - g

    print(""{:.10f}"".format(h))

if __name__ == ""__main__"":
    e()"
446,A,DZY Loves Sequences,PROGRAMMING,"['dp', 'implementation', 'two pointers']","DZY has a sequence *a*, consisting of *n* integers.

We'll call a sequence *a**i*,<=*a**i*<=+<=1,<=...,<=*a**j* (1<=≤<=*i*<=≤<=*j*<=≤<=*n*) a subsegment of the sequence *a*. The value (*j*<=-<=*i*<=+<=1) denotes the length of the subsegment.

Your task is to find the longest subsegment of *a*, such that it is possible to change at most one number (change one number to any integer you want) from the subsegment to make the subsegment strictly increasing.

You only need to output the length of the subsegment you find.","The first line contains integer *n* (1<=≤<=*n*<=≤<=105). The next line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=109).",In a single line print the answer to the problem — the maximum length of the required subsegment.,['6\n7 2 3 1 5 6\n'],['5\n'],"You can choose subsegment *a*<sub class=""lower-index"">2</sub>, *a*<sub class=""lower-index"">3</sub>, *a*<sub class=""lower-index"">4</sub>, *a*<sub class=""lower-index"">5</sub>, *a*<sub class=""lower-index"">6</sub> and change its 3rd element (that is *a*<sub class=""lower-index"">4</sub>) to 4.",WRONG_ANSWER,"def b(e):
    if len(e) < 2:
        return n

    c = 0
    a = 1
    d = 0
    for i in range(1, n):
        if e[i] > e[i-1]:
            a += 1
        else:
            if a + c > d:
                d = a + c
            c = a
            a = 1

    if a + c > d:
        d = a + c
    return d

if __name__ == '__main__':
    n = int(input())
    e = [int(i) for i in input().split("" "")]
    print(b(e))","import , t

def s():
    l = .stdin.buffer.read().decode().split()
    r = iter(l)
    n = int(next(r))
    q = int(next(r))

    | = []
    for _ in range(n):
        x = float(next(r))
        y = float(next(r))
        |.append((x, y))

    a = 0.0
    j = 0.0
    k = 0.0
    for i in range(n):
        ,  = |[i]
        ,  = |[(i+1) % n]
        f =  *  -  * 
        a += f
        j += ( + ) * f
        k += ( + ) * f
    a *= 0.5
    if abs(a) < 1e-9:
        d = (0.0, 0.0)
    else:
        j /= (6.0 * a)
        k /= (6.0 * a)
        d = (j, k)

    g = 0.0
    h = 0.0
    i = 0.0

    y = 1
    z = 2

    x = []
    for _ in range(q):
         = next(r)
        if  == '1':

            f = int(next(r))
            t = int(next(r))

            if f == y:
                { = z
                y = z
                z = t
            else:
                { = y
                z = t

             = |[{ - 1]
            } = h + t.cos(g) * [0] - t.sin(g) * [1]
            ~ = i + t.sin(g) * [0] + t.cos(g) * [1]

            b = h + t.cos(g) * d[0] - t.sin(g) * d[1]
            c = i + t.sin(g) * d[0] + t.cos(g) * d[1]

             = b - }
             = c - ~

             = t.atan2(, )

            m = -t.pi / 2 - 

            u = g + m
            e = t.cos(m)
             = t.sin(m)
            n = } - h
            o = ~ - i
            v = } - (e * n -  * o)
            w = ~ - ( * n + e * o)
            
            g = u
            h = v
            i = w

        else:

            v = int(next(r))
            ,  = |[v - 1]
            p = h + t.cos(g) *  - t.sin(g) * 
            q = i + t.sin(g) *  + t.cos(g) * 
            x.append(f""{p:.10f} {q:.10f}"")
    
    .stdout.write(""\n"".join(x))

if __name__ == '__main__':
    s()"
32,B,Borze,PROGRAMMING,"['expression parsing', 'implementation']","Ternary numeric notation is quite popular in Berland. To telegraph the ternary number the Borze alphabet is used. Digit 0 is transmitted as «.», 1 as «-.» and 2 as «--». You are to decode the Borze code, i.e. to find out the ternary number given its representation in Borze alphabet.",The first line contains a number in Borze code. The length of the string is between 1 and 200 characters. It's guaranteed that the given string is a valid Borze code of some ternary number (this number can have leading zeroes).,Output the decoded ternary number. It can have leading zeroes.,"['.-.--\n', '--.\n', '-..-.--\n']","['012', '20', '1012']",none,WRONG_ANSWER,"from collections import b

def d():
    s = input()
    m = ''
    a = b(int)
    a['.'] = '0'
    a['-.'] = '1'
    a['--'] = '2'
    i = 0
    c = ''
    while (i<len(s)):
        c += s[i]
        if(a[c] == 0 ):
            i+=1
        else:
            m+= a[c]
            c = ''
            i+=1
    return m","def e(v, h, a):
    """"""
    Perform DFS from node v.
    Computes expected additional journey length from city v.
    
    Parameters:
        v (int): The current city.
        parent (int): The previous city (to avoid going back).
        adj (list of lists): Adjacency list representing the tree.
        
    Returns:
        float: Expected additional journey length from city v.
    """"""
    c = 0
    f = 0.0
    for w in a[v]:
        if w == h:

            continue
        c += 1

        f += 1 + e(w, v, a)

    if c == 0:
        return 0.0

    return f / c

if __name__ == ""__main__"":
    import i
    i.setrecursionlimit(300000)
    
    d = i.stdin.read().strip().split()
    if not d:
        i.exit(0)
    
    n = int(d[0])

    a = [[] for _ in range(n + 1)]

    g = 1
    for i in range(n - 1):
        u = int(d[g])
        v = int(d[g + 1])
        g += 2
        a[u].append(v)
        a[v].append(u)

    b = e(1, -1, a)

    i.stdout.write(""{:.15f}\n"".format(b))"
463,C,Gargari and Bishops,PROGRAMMING,"['greedy', 'hashing', 'implementation']","Gargari is jealous that his friend Caisa won the game from the previous problem. He wants to prove that he is a genius.

He has a *n*<=×<=*n* chessboard. Each cell of the chessboard has a number written on it. Gargari wants to place two bishops on the chessboard in such a way that there is no cell that is attacked by both of them. Consider a cell with number *x* written on it, if this cell is attacked by one of the bishops Gargari will get *x* dollars for it. Tell Gargari, how to place bishops on the chessboard to get maximum amount of money.

We assume a cell is attacked by a bishop, if the cell is located on the same diagonal with the bishop (the cell, where the bishop is, also considered attacked by it).",The first line contains a single integer *n* (2<=≤<=*n*<=≤<=2000). Each of the next *n* lines contains *n* integers *a**ij* (0<=≤<=*a**ij*<=≤<=109) — description of the chessboard.,"On the first line print the maximal number of dollars Gargari will get. On the next line print four integers: *x*1,<=*y*1,<=*x*2,<=*y*2 (1<=≤<=*x*1,<=*y*1,<=*x*2,<=*y*2<=≤<=*n*), where *x**i* is the number of the row where the *i*-th bishop should be placed, *y**i* is the number of the column where the *i*-th bishop should be placed. Consider rows are numbered from 1 to *n* from top to bottom, and columns are numbered from 1 to *n* from left to right.

If there are several optimal solutions, you can print any of them.",['4\n1 1 1 1\n2 1 1 0\n1 1 1 0\n1 0 0 1\n'],['12\n2 2 3 2\n'],none,WRONG_ANSWER,"import itertools
from sys import maxsize, stdout, stdin,stderr
d = int(1e9+7)
import sys
from collections import defaultdict, Counter, deque
import math
import heapq
from heapq import heappop , heappush
import bisect
from math import factorial, inf
from itertools import groupby
from itertools import permutations as comb
def a(a,b,c):
	print('? {} {} {}'.format(a,b,c),flush=True)
	n=int(input())
	return n
 
t=1

for _ in range(t):
    n=int(input())
    s=[]
    b=[0]*(2*n)
    c=[0]*(2*n)
    for i in range(n):
        s.append(list(map(int,input().split())))
    o,e=-1,-1
    e,g,f,h=None,None,None,None
    for i in range(n):
        for j in range(n):
           
            b[i+j] += s[i][j]
            
            c[i-j+n] += s[i][j]
    
    for i in range(n):
        for j in range(n):
            if (i+j)%2:
                if o<b[i+j]+c[i-j+n]-s[i][j]:
                    o=b[i+j]+c[i-j+n]-s[i][j]
                    e,g=i+1,j+1
            else:
                if e<b[i+j]+c[i-j+n]-s[i][j]:
                    e=b[i+j]+c[i-j+n]-s[i][j]
                    f,h=i+1,j+1
    print(o+e)
    print(e,h,f,h)","def i():
    import q
    from collections import h
    
    g = q.stdin.read().split()
    if not g:
        return
    n = int(g[0])

    a = list(map(int, g[1:]))

    o = [0] * (n + 1)
    for i in range(n):
        o[i+1] = o[i] + (a[i] if a[i] > 0 else 0)

    l = h(list)
    for i, r in enumerate(a):
        l[r].append(i)

    b = None
    a = None

    for r, n in l.items():
        if len(n) < 2:
            continue

        k = o[n[0] + 1]
        j = n[0]
        for j in n[1:]:
            f = 2 * r + (o[j] - k)
            if b is None or f > b:
                b = f
                a = (j, j)

            e = o[j + 1]
            if e < k:
                k = e
                j = j

    L, R = a
    c = []

    c.append(L)

    for i in range(L + 1, R):
        if a[i] > 0:
            c.append(i)

    c.append(R)
    
    d = set(c)

    p = [i for i in range(n) if i not in d]

    m = []
    m.append(f""{b} {len(p)}"")
    if p:
        m.append("" "".join(str(i + 1) for i in p))
    else:
        m.append("""")
    
    q.stdout.write(""\n"".join(m))
    
if __name__ == '__main__':
    i()"
899,C,Dividing the numbers,PROGRAMMING,"['constructive algorithms', 'graphs', 'math']","Petya has *n* integers: 1,<=2,<=3,<=...,<=*n*. He wants to split these integers in two non-empty groups in such a way that the absolute difference of sums of integers in each group is as small as possible. 

Help Petya to split the integers. Each of *n* integers should be exactly in one group.",The first line contains a single integer *n* (2<=≤<=*n*<=≤<=60<=000) — the number of integers Petya has.,"Print the smallest possible absolute difference in the first line.

In the second line print the size of the first group, followed by the integers in that group. You can print these integers in arbitrary order. If there are multiple answers, print any of them.","['4\n', '2\n']","['0\n2 1 4 \n', '1\n1 1 \n']","In the first example you have to put integers 1 and 4 in the first group, and 2 and 3 in the second. This way the sum in each group is 5, and the absolute difference is 0.

In the second example there are only two integers, and since both groups should be non-empty, you have to put one integer in the first group and one in the second. This way the absolute difference of sums of integers in each group is 1.",WRONG_ANSWER,"import i
input = i.stdin.buffer.readline 

def h(n):
    S = n*(n+1)//2
    A = [i+1 for i in range(n+1)]
    g = S//2
    f = 0
    a = []
    while len(A) > 0:
        x = A.pop()
        if x+f <= g:
            a.append(x)
            f+=x
    e = S-f
    return [abs(f-e), a]

n = int(input())
d = [int(x) for x in input().split()]
b, c = h(n)
print(b)
i.stdout.write(' '.join(map(str, c))+'\n')","def c(s):

    e = set(""aoyeuiAOYEUI"")
    d = []

    for a in s:

        if a not in e:

            d.append(""."" + a.lower())

    return """".join(d)

def b():

    s = input().strip()

    print(c(s))

if __name__ == ""__main__"":
    b()"
955,C,Sad powers,PROGRAMMING,"['binary search', 'math', 'number theory']","You're given *Q* queries of the form (*L*,<=*R*). 

For each query you have to find the number of such *x* that *L*<=≤<=*x*<=≤<=*R* and there exist integer numbers *a*<=&gt;<=0, *p*<=&gt;<=1 such that *x*<==<=*a**p*.","The first line contains the number of queries *Q* (1<=≤<=*Q*<=≤<=105).

The next *Q* lines contains two integers *L*, *R* each (1<=≤<=*L*<=≤<=*R*<=≤<=1018).",Output *Q* lines — the answers to the queries.,['6\n1 4\n9 9\n5 7\n12 29\n137 591\n1 1000000\n'],['2\n1\n0\n3\n17\n1111\n'],In query one the suitable numbers are 1 and 4.,TIME_LIMIT_EXCEEDED,"a=[1]
for i in range(3,31):
    m=2
    while(m**i<1+10**18):
        a.append(m**i)
        m+=1

b=sorted(a)
import j
def i(h):
    n = j.sqrt(h)
    if int(n + 0.5) ** 2 == h:
        return True
    else:
        return False

c=[x for x in b if not i(x)]

import j
def a(a,b):
    return (j.floor(j.sqrt(b)) - j.ceil(j.sqrt(a)) + 1)

def f(d, n, o):

    if (o <= d[0]):
        return 0
    if (o >= d[n - 1]):
        return n - 1

    i = 0; j = n; k = 0
    while (i < j):
        k = (i + j) // 2

        if (d[k] == o):
            return k

        if (o < d[k]) :

            if (k > 0 and o > d[k - 1]):
                return g(d,k - 1, k, o)

            j = k

        else :
            if (k < n - 1 and o < d[k + 1]):
                return g(d,k, k + 1, o)

            i = k + 1

    return k

def g(d,p, q, o):
    if (o - d[p] >= d[q] - o):
        return q
    else:
        return p

l=int(input())
for i in range(l):
    a,b=list(map(int,input().split(' ')))
    e = a(a,b)

    n = len(c)
    b=f(c, n, a)
    c=f(c, n, b)

    e+=c-b+1
    if a>c[b]:
        e-=1
    if b<c[c]:
        e+=1
    if i(a):
        e-=1
    if i(b):
        e-=1
    if i(a) and i(b) and a==b:
        e+=2
    if a<c[0]:
        e-=1
    if b<c[0]:
        e-=1

    print(e)","import i
import math

def e():
    d = i.stdin.read().split()

    n = int(d[0])
    h = list(map(int, d[1:]))
    
    f = max(h)

    c = [0] * (f + 1)
    for s in h:
        c[s] += 1
    
    a = 0

    for d in range(2, f + 1):
        b = 0

        for g in range(d, f + 1, d):
            b += c[g]
        a = max(a, b)

    print(a if a >= 2 else 1)

if __name__ == ""__main__"":
    e()"
80,A,Panoramix's Prediction,PROGRAMMING,['brute force'],"A prime number is a number which has exactly two distinct divisors: one and itself. For example, numbers 2, 7, 3 are prime, and 1, 6, 4 are not.

The next prime number after *x* is the smallest prime number greater than *x*. For example, the next prime number after 2 is 3, and the next prime number after 3 is 5. Note that there is exactly one next prime number after each number. So 5 is not the next prime number for 2.

One cold April morning Panoramix predicted that soon Kakofonix will break free from his straitjacket, and this will be a black day for the residents of the Gallic countryside.

Panoramix's prophecy tells that if some day Asterix and Obelix beat exactly *x* Roman soldiers, where *x* is a prime number, and next day they beat exactly *y* Roman soldiers, where *y* is the next prime number after *x*, then it's time to wait for Armageddon, for nothing can shut Kakofonix up while he sings his infernal song.

Yesterday the Gauls beat *n* Roman soldiers and it turned out that the number *n* was prime! Today their victims were a troop of *m* Romans (*m*<=&gt;<=*n*). Determine whether the Gauls should wait for the black day after today's victory of Asterix and Obelix?","The first and only input line contains two positive integers — *n* and *m* (2<=≤<=*n*<=&lt;<=*m*<=≤<=50). It is guaranteed that *n* is prime.

Pretests contain all the cases with restrictions 2<=≤<=*n*<=&lt;<=*m*<=≤<=4.","Print YES, if *m* is the next prime number after *n*, or NO otherwise.","['3 5\n', '7 11\n', '7 9\n']","['YES', 'YES', 'NO']",none,OK,"def a(n):
    return n > 1 and all(n % i != 0 for i in range(2, int(n**0.5)+1))

n, m = map(int, input().split())
b = n + 1
while not a(b):
    b += 1
print(""YES"" if b == m else ""NO"")","n = int(input())

for _ in range(n):
    b = input().strip()

    if len(b) > 10:

        a = b[0] + str(len(b) - 2) + b[-1]
        print(a)
    else:

        print(b)"
600,B,Queries about less or equal elements,PROGRAMMING,"['binary search', 'data structures', 'sortings', 'two pointers']",You are given two arrays of integers *a* and *b*. For each element of the second array *b**j* you should find the number of elements in array *a* that are less than or equal to the value *b**j*.,"The first line contains two integers *n*,<=*m* (1<=≤<=*n*,<=*m*<=≤<=2·105) — the sizes of arrays *a* and *b*.

The second line contains *n* integers — the elements of array *a* (<=-<=109<=≤<=*a**i*<=≤<=109).

The third line contains *m* integers — the elements of array *b* (<=-<=109<=≤<=*b**j*<=≤<=109).","Print *m* integers, separated by spaces: the *j*-th of which is equal to the number of such elements in array *a* that are less than or equal to the value *b**j*.","['5 4\n1 3 5 7 9\n6 4 2 8\n', '5 5\n1 2 1 2 5\n3 1 4 1 5\n']","['3 2 1 4\n', '4 2 4 2 5\n']",none,TIME_LIMIT_EXCEEDED,"a,b,c=list(map(int,input().split())),list(map(int,input().split())),list(map(int,input().split()))
def p(i,x):
    for j in b:
        if j<=i:
            x+=1
    return x
for k in c:
    print(p(k,0),end=' ')","def a():

    b = input().strip()

    c = b + b[::-1]

    print(c)

if __name__ == ""__main__"":
    a()"
251,A,Points on Line,PROGRAMMING,"['binary search', 'combinatorics', 'two pointers']","Little Petya likes points a lot. Recently his mom has presented him *n* points lying on the line *OX*. Now Petya is wondering in how many ways he can choose three distinct points so that the distance between the two farthest of them doesn't exceed *d*.

Note that the order of the points inside the group of three chosen points doesn't matter.","The first line contains two integers: *n* and *d* (1<=≤<=*n*<=≤<=105; 1<=≤<=*d*<=≤<=109). The next line contains *n* integers *x*1,<=*x*2,<=...,<=*x**n*, their absolute value doesn't exceed 109 — the *x*-coordinates of the points that Petya has got.

It is guaranteed that the coordinates of the points in the input strictly increase.","Print a single integer — the number of groups of three points, where the distance between two farthest points doesn't exceed *d*.

Please do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.","['4 3\n1 2 3 4\n', '4 2\n-3 -2 -1 0\n', '5 19\n1 10 20 30 50\n']","['4\n', '2\n', '1\n']","In the first sample any group of three points meets our conditions.

In the seconds sample only 2 groups of three points meet our conditions: {-3, -2, -1} and {-2, -1, 0}.

In the third sample only one group does: {1, 10, 20}.",OK,"import i
input = i.stdin.readline
def d():
    return int(input())
def f():
    return input().strip(""\n"")
def c():
    return(list(map(int,input().split())))
def e():
    return(input().split())

def h(b, d):
    a = 0
    j = 0
    for i in range(len(b)):
        while b[i] - b[j] > d:j += 1
        a += int((i - j) * (i - j - 1)/2)
            

    print(a)

g = c()
b = c()
h(b, g[1])","""""""
We need to choose n-1 roads (edges) that connect all cities [1..n]
such that the distance from the capital 1 to every city is the shortest possible,
i.e. d[v] is the BFS distance from city1 in the chosen spanning tree.
Any spanning tree that “respects” the condition for every vertex v (v!=1)
must use an edge (u,v) with dist[u] + 1 == dist[v] (or vice‐versa).
For every city v (except 1) we collect candidate edges that come from a neighbor with distance exactly one less.
Then the valid spanning trees are exactly those in which for each v (2 ≤ v ≤ n)
one of these candidate edges is chosen.
The number of possibilities is the product of choices for each v.
We only need to output k distinct valid spanning trees (or all if fewer are available).
To avoid exponential enumeration we “fix” the vertices that have a unique candidate,
and only “enumerate” over the free vertices (those with more than one candidate).
We then use a mixed‑radix enumeration (with a DP array to keep track of the number of combinations)
so that we can generate the first k valid solutions.
Because m*k ≤ 10^6, the total output is limited.
""""""

def r():
    import v
    from collections import g
    f = v.stdin.read().strip().split()
    if not f:
        return
    p = iter(f)
    n = int(next(p))
    m = int(next(p))
    q = int(next(p))

    l = []

    o = [[] for _ in range(n+1)]
    for j in range(m):
        u = int(next(p))
        v = int(next(p))
        l.append((u, v))
        o[u].append((v, j))
        o[v].append((u, j))

    i = [-1]*(n+1)
    k = g()
    i[1] = 0
    k.append(1)
    while k:
        u = k.popleft()
        for v, _ in o[u]:
            if i[v] == -1:
                i[v] = i[u] + 1
                k.append(v)

    a = [[] for _ in range(n+1)]

    for j, (u, v) in enumerate(l):
        if i[u] + 1 == i[v]:
            a[v].append(j)
        elif i[v] + 1 == i[u]:
            a[u].append(j)

    for v in range(2, n+1):
        if a[v]:
            a[v].sort()

    m = {}
    n = []
    for v in range(2, n+1):

        if len(a[v]) == 1:
            m[v] = a[v][0]
        else:
            n.append(v)
    n.sort()

    L = len(n)
    j = [1]*(L+1)
    b = q + 1
    for i in range(L-1, -1, -1):
        d = len(a[n[i]])
        s = j[i+1] * d
        if s > b:
            s = b
        j[i] = s
    w = j[0]

    t = q if w > q else w

    t = []
    t.append(str(t))

    for X in range(t):
        c = [None]*(n+1)
        e = X

        for i in range(L):
            v = n[i]
            x = j[i+1]
            h = e // x
            e = e % x
            c[v] = a[v][h]

        for v in range(2, n+1):
            if v in m:
                c[v] = m[v]

        u = ['0'] * m
        for v in range(2, n+1):
            u[c[v]] = '1'
        t.append("""".join(u))
    v.stdout.write(""\n"".join(t))
    
if __name__ == '__main__':
    r()"
0,none,none,none,['none'],"Mashmokh's boss, Bimokh, didn't like Mashmokh. So he fired him. Mashmokh decided to go to university and participate in ACM instead of finding a new job. He wants to become a member of Bamokh's team. In order to join he was given some programming tasks and one week to solve them. Mashmokh is not a very experienced programmer. Actually he is not a programmer at all. So he wasn't able to solve them. That's why he asked you to help him with these tasks. One of these tasks is the following.

A sequence of *l* integers *b*1,<=*b*2,<=...,<=*b**l* (1<=≤<=*b*1<=≤<=*b*2<=≤<=...<=≤<=*b**l*<=≤<=*n*) is called good if each number divides (without a remainder) by the next number in the sequence. More formally  for all *i* (1<=≤<=*i*<=≤<=*l*<=-<=1).

Given *n* and *k* find the number of good sequences of length *k*. As the answer can be rather large print it modulo 1000000007 (109<=+<=7).","The first line of input contains two space-separated integers *n*,<=*k* (1<=≤<=*n*,<=*k*<=≤<=2000).",Output a single integer — the number of good sequences of length *k* modulo 1000000007 (109<=+<=7).,"['3 2\n', '6 4\n', '2 1\n']","['5\n', '39\n', '2\n']","In the first sample the good sequences are: [1, 1], [2, 2], [3, 3], [1, 2], [1, 3].",WRONG_ANSWER,"def d(): return map(int, input().split())

x, y = d()
a = [[] for _ in range(x+1)]

for n in range(1, x+1):
    for k in range(n, x+1, n):
        a[k].append(n)

b = [[0 for n in range(y+1)] for k in range(x+1)]
for n in range(1, y+1):
    b[1][n] = 1
for n in range(1, x+1):
    b[n][1] = 1
e = int(1e9 + 7)
for n in range(2, x+1):
    for k in range(2, y+1):
        for c in a[n]:
            b[n][k] += b[c][k-1]
            b[n][k] %= e

f = 0
for n in b:
    f += n[-1]
print(f)","def c():
    import d
    b = d.stdin.read().split()

    n = int(b[0])

    a = list(map(int, b[1:1+n]))

    e = sum(a)

    if e % n == 0:
        print(n)
    else:

        print(n - 1)

if __name__ == '__main__':
    c()"
919,D,Substring,PROGRAMMING,"['dfs and similar', 'dp', 'graphs']","You are given a graph with $n$ nodes and $m$ directed edges. One lowercase letter is assigned to each node. We define a path's value as the number of the most frequently occurring letter. For example, if letters on a path are ""abaca"", then the value of that path is $3$. Your task is find a path whose value is the largest.","The first line contains two positive integers $n, m$ ($1 \leq n, m \leq 300\,000$), denoting that the graph has $n$ nodes and $m$ directed edges.

The second line contains a string $s$ with only lowercase English letters. The $i$-th character is the letter assigned to the $i$-th node.

Then $m$ lines follow. Each line contains two integers $x, y$ ($1 \leq x, y \leq n$), describing a directed edge from $x$ to $y$. Note that $x$ can be equal to $y$ and there can be multiple edges between $x$ and $y$. Also the graph can be not connected.","Output a single line with a single integer denoting the largest value. If the value can be arbitrarily large, output -1 instead.","['5 4\nabaca\n1 2\n1 3\n3 4\n4 5\n', '6 6\nxzyabc\n1 2\n3 1\n2 3\n5 4\n4 3\n6 4\n', '10 14\nxzyzyzyzqx\n1 2\n2 4\n3 5\n4 5\n2 6\n6 8\n6 5\n2 10\n3 9\n10 9\n4 6\n1 10\n2 8\n3 7\n']","['3\n', '-1\n', '4\n']","In the first sample, the path with largest value is $1 \to 3 \to 4 \to 5$. The value is $3$ because the letter 'a' appears $3$ times.",TIME_LIMIT_EXCEEDED,"import math, sys, k, functools, time, itertools;

def b()     : return map(int, input().strip().split())
def a()    : return list(b())
def c()  : return list(input().strip().split())
def u(*h) : return print(*h, end="""")
def t(*h)  : return print(*h, end="" "")

l = [-1, +0, +1, +0]; n = [-1, -1, +0, +1, +1, +1, +0, -1]; 
m = [+0, +1, +0, -1]; o = [+0, +1, +1, +1, +0, -1, -1, -1];

def w(e):

    n, m = b()
    f = k.defaultdict(list)
    q = [0 for x in range(n+1)]
    s = input();

    for i in range(m):
        a, b = b()
        f[a].append(b);
        q[b] += 1;

    v = k.deque();

    g = 0; 
    p = [[0 for x in range(26)] for x in range(n+1)]
    r = q.copy()
    for j in range(26):
        i = chr(ord('a') + j)
        q = r.copy()
        for i in range(1, n+1):
            if q[i] == 0:
                v.append(i)
                p[i][j] = s[i-1] == i

        j = 0
        while (len(v)):
            s = v.popleft()
            for i in f[s]:
                p[i][j] = p[s][j] + (s[i-1] == i);
                g = max(g, p[i][j])
                q[i] -= 1
                if q[i] == 0:
                    v.append(i)
            j += 1
            if j > n:
                break
        if j > n:
            break

    print(g if j == n else -1)
    

d = 1;

for e in range(1, d + 1): 
    w(e)","import e

def d():

    b = e.stdin.read().split()
    if not b:
        return

    s = b[0].strip()
    n = len(s)

    if n < 2:
        print(1)
        return

    c = [ (int(s[i]) + int(s[i+1]) == 9) for i in range(n-1) ]

    a = 1
    i = 0
    while i < len(c):
        if not c[i]:
            i += 1
            continue

        j = i
        while j < len(c) and c[j]:
            j += 1
        L = j - i
        if L % 2 == 0:

            a *= (L // 2 + 1)
        else:

            a *= 1
        i = j

    print(a)

if __name__ == '__main__':
    d()"
462,A,Appleman and Easy Task,PROGRAMMING,"['brute force', 'implementation']","Toastman came up with a very easy task. He gives it to Appleman, but Appleman doesn't know how to solve it. Can you help him?

Given a *n*<=×<=*n* checkerboard. Each cell of the board has either character 'x', or character 'o'. Is it true that each cell of the board has even number of adjacent cells with 'o'? Two cells of the board are adjacent if they share a side.",The first line contains an integer *n* (1<=≤<=*n*<=≤<=100). Then *n* lines follow containing the description of the checkerboard. Each of them contains *n* characters (either 'x' or 'o') without spaces.,"Print ""YES"" or ""NO"" (without the quotes) depending on the answer to the problem.","['3\nxxo\nxox\noxx\n', '4\nxxxo\nxoxo\noxox\nxxxx\n']","['YES\n', 'NO\n']",none,OK,"def e(n, a):
    for i in range(n):
        for j in range(n):
            b = 0
            for x, y in [(-1, 0), (0, 1), (1, 0), (0, -1)]:
                c, d = x + i, y + j
                if c >= 0 and c < n and d >= 0 and d < n:
                    if a[c][d] == ""o"":
                        b += 1
            
            if b % 2 != 0:
                return ""NO""
    return ""YES""
    

n = int(input())
a = []
for i in range(n):
    f = input()
    a.append(list(f))
print(e(n, a))","import k

def e(x):
    """"""
    Find the integer cube root of x if it exists.
    Returns the cube root if x is a perfect cube; otherwise, returns -1.
    """"""
    f, c = 0, int(x ** (1/3)) + 2
    while f <= c:
        h = (f + c) // 2
        a = h * h * h
        if a == x:
            return h
        elif a < x:
            f = h + 1
        else:
            c = h - 1
    return -1

def g():

    b = k.stdin.read().split()
    if not b:
        return
    t = int(b[0])
    j = []
    d = 1
    
    for _ in range(t):
        a = int(b[d])
        b = int(b[d + 1])
        d += 2

        i = a * b
        T = e(i)
        if T == -1:
            j.append(""No"")
            continue

        if a % T != 0:
            j.append(""No"")
            continue
        
        Y = a // T

        if (T * T) % Y != 0:
            j.append(""No"")
            continue
        
        if (T * T) // Y == b:
            j.append(""Yes"")
        else:
            j.append(""No"")

    k.stdout.write(""\n"".join(j))

if __name__ == '__main__':
    g()"
834,A,The Useless Toy,PROGRAMMING,['implementation'],"Walking through the streets of Marshmallow City, Slastyona have spotted some merchants selling a kind of useless toy which is very popular nowadays – caramel spinner! Wanting to join the craze, she has immediately bought the strange contraption.

Spinners in Sweetland have the form of V-shaped pieces of caramel. Each spinner can, well, spin around an invisible magic axis. At a specific point in time, a spinner can take 4 positions shown below (each one rotated 90 degrees relative to the previous, with the fourth one followed by the first one):

After the spinner was spun, it starts its rotation, which is described by a following algorithm: the spinner maintains its position for a second then majestically switches to the next position in clockwise or counter-clockwise order, depending on the direction the spinner was spun in.

Slastyona managed to have spinner rotating for exactly *n* seconds. Being fascinated by elegance of the process, she completely forgot the direction the spinner was spun in! Lucky for her, she managed to recall the starting position, and wants to deduct the direction given the information she knows. Help her do this.","There are two characters in the first string – the starting and the ending position of a spinner. The position is encoded with one of the following characters: v (ASCII code 118, lowercase v), &lt; (ASCII code 60), ^ (ASCII code 94) or &gt; (ASCII code 62) (see the picture above for reference). Characters are separated by a single space.

In the second strings, a single number *n* is given (0<=≤<=*n*<=≤<=109) – the duration of the rotation.

It is guaranteed that the ending position of a spinner is a result of a *n* second spin in any of the directions, assuming the given starting position.","Output cw, if the direction is clockwise, ccw – if counter-clockwise, and undefined otherwise.","['^ &gt;\n1\n', '&lt; ^\n3\n', '^ v\n6\n']","['cw\n', 'ccw\n', 'undefined\n']",none,RUNTIME_ERROR,"c=['^','<','v','>']
d,e=[],[]
a,b=map(str,input().split())
n=int(input())
n=n%4

if n==2:
    print('undefined')
    exit()
for i in range(4):
    if a==c[i]:
        a=i
    if b==c[i]:
        b=i

if b==c[(a+n)%4]:
    print('ccw')
elif b==c[4-(a+n)%4]:
    print('cw')","import j

def g():

    d = j.stdin.read().splitlines()
    if not d:
        return
    n, m = map(int, d[0].split())
    e = [list(f.strip()) for f in d[1:n+1]]

    i = []
    for i in range(n):
        c = {}
        for a in e[i]:
            c[a] = c.get(a, 0) + 1
        i.append(c)

    b = []
    for j in range(m):
        c = {}
        for i in range(n):
            a = e[i][j]
            c[a] = c.get(a, 0) + 1
        b.append(c)

    h = []
    for i in range(n):
        for j in range(m):
            a = e[i][j]
            if i[i][a] == 1 and b[j][a] == 1:

                h.append(a)

    print(''.join(h))

if __name__ == ""__main__"":
    g()"
863,G,Graphic Settings,PROGRAMMING,[],"Recently Ivan bought a new computer. Excited, he unpacked it and installed his favourite game. With his old computer Ivan had to choose the worst possible graphic settings (because otherwise the framerate would be really low), but now he wants to check, maybe his new computer can perform well even with the best possible graphics?

There are *m* graphics parameters in the game. *i*-th parameter can be set to any positive integer from 1 to *a**i*, and initially is set to *b**i* (*b**i*<=≤<=*a**i*). So there are  different combinations of parameters. Ivan can increase or decrease any of these parameters by 1; after that the game will be restarted with new parameters (and Ivan will have the opportunity to check chosen combination of parameters).

Ivan wants to try all *p* possible combinations. Also he wants to return to the initial settings after trying all combinations, because he thinks that initial settings can be somehow best suited for his hardware. But Ivan doesn't really want to make a lot of restarts.

So he wants you to tell the following:
 -  If there exists a way to make exactly *p* changes (each change either decreases or increases some parameter by 1) to try all possible combinations and return to initial combination, then Ivan wants to know this way. -  Otherwise, if there exists a way to make exactly *p*<=-<=1 changes to try all possible combinations (including the initial one), then Ivan wants to know this way. 
Help Ivan by showing him the way to change parameters!","The first line of input contains one integer number *m* (1<=≤<=*m*<=≤<=6).

The second line contains *m* integer numbers *a*1,<=*a*2,<=...,<=*a**m* (2<=≤<=*a**i*<=≤<=1000). It is guaranteed that .

The third line contains *m* integer numbers *b*1,<=*b*2,<=...,<=*b**m* (1<=≤<=*b**i*<=≤<=*a**i*).","If there is a way to make exactly *p* changes (each change either decreases or increases some parameter by 1) to try all possible combinations and return to initial combination, then output Cycle in the first line. Then *p* lines must follow, each desribing a change. The line must be either inc x (increase parameter *x* by 1) or dec x (decrease it).

Otherwise, if there is a way to make exactly *p*<=-<=1 changes to try all possible combinations (including the initial one), then output Path in the first line. Then *p*<=-<=1 lines must follow, each describing the change the same way as mentioned above.

Otherwise, output No.","['1\n3\n1\n', '1\n3\n2\n', '2\n3 2\n1 1\n']","['Path\ninc 1\ninc 1\n', 'No\n', 'Cycle\ninc 1\ninc 1\ninc 2\ndec 1\ndec 1\ndec 2\n']",none,WRONG_ANSWER,"m = int(input())
a = list(map(int, input().split()))
b = list(map(int, input().split()))

d = sum(a[i] - b[i] for i in range(m))
p = (d + m) // 2

b = []

def c(p):
    if p < 0:
        return False
    if p == 0:
        return True
    
    for i in range(m):
        if b[i] < a[i]:
            b[i] += 1
            b.append(f'inc {i + 1}')
            if c(p - 1):
                return True
            b.pop()
            b[i] -= 1

        if b[i] > 1:
            b[i] -= 1
            b.append(f'dec {i + 1}')
            if c(p - 1):
                return True
            b.pop()
            b[i] += 1
    
    return False

if c(p):
    if len(b) == p:
        print(""Cycle"")
    else:
        print(""Path"")
    for a in b:
        print(a)
else:
    print(""No"")","w = int(input())

if w % 2 == 0 and w > 2:
    print(""YES"")
else:
    print(""NO"")"
146,A,Lucky Ticket,PROGRAMMING,['implementation'],"Petya loves lucky numbers very much. Everybody knows that lucky numbers are positive integers whose decimal record contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.

Petya loves tickets very much. As we know, each ticket has a number that is a positive integer. Its length equals *n* (*n* is always even). Petya calls a ticket lucky if the ticket's number is a lucky number and the sum of digits in the first half (the sum of the first *n*<=/<=2 digits) equals the sum of digits in the second half (the sum of the last *n*<=/<=2 digits). Check if the given ticket is lucky.",The first line contains an even integer *n* (2<=≤<=*n*<=≤<=50) — the length of the ticket number that needs to be checked. The second line contains an integer whose length equals exactly *n* — the ticket number. The number may contain leading zeros.,"On the first line print ""YES"" if the given ticket number is lucky. Otherwise, print ""NO"" (without the quotes).","['2\n47\n', '4\n4738\n', '4\n4774\n']","['NO\n', 'NO\n', 'YES\n']","In the first sample the sum of digits in the first half does not equal the sum of digits in the second half (4 ≠ 7).

In the second sample the ticket number is not the lucky number.",WRONG_ANSWER,"n = int(input())
def a(n):
    x = list(set(list(n)))
    if x!=['4','7'] and x!=['7','4']:
        return False
    else:
        return True
a = input()
if a(a):
    x = [int(i) for i in a[:n//2]]
    y = [int(i) for i in a[n//2:]]
    if sum(x) == sum(y):
        print(""YES"")
    else:
        print(""NO"")
else:
    print(""NO"")","def c(s):
    e = []
    for a in s:
        if e and e[-1] == a:

            e.pop()
        else:

            e.append(a)

    return ''.join(e)

if __name__ == ""__main__"":
    import f

    b = f.stdin.readline().rstrip('\n')

    d = c(b)

    f.stdout.write(d)"
940,B,Our Tanya is Crying Out Loud,PROGRAMMING,"['dp', 'greedy']","Right now she actually isn't. But she will be, if you don't solve this problem.

You are given integers *n*, *k*, *A* and *B*. There is a number *x*, which is initially equal to *n*. You are allowed to perform two types of operations: 
 1.  Subtract 1 from *x*. This operation costs you *A* coins. 1.  Divide *x* by *k*. Can be performed only if *x* is divisible by *k*. This operation costs you *B* coins.","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=2·109).

The second line contains a single integer *k* (1<=≤<=*k*<=≤<=2·109).

The third line contains a single integer *A* (1<=≤<=*A*<=≤<=2·109).

The fourth line contains a single integer *B* (1<=≤<=*B*<=≤<=2·109).",Output a single integer — the minimum amount of coins you have to pay to make *x* equal to 1.,"['9\n2\n3\n1\n', '5\n5\n2\n20\n', '19\n3\n4\n2\n']","['6\n', '8\n', '12\n']","In the first testcase, the optimal strategy is as follows: 
 -  Subtract 1 from *x* (9 → 8) paying 3 coins. -  Divide *x* by 2 (8 → 4) paying 1 coin. -  Divide *x* by 2 (4 → 2) paying 1 coin. -  Divide *x* by 2 (2 → 1) paying 1 coin. 
The total cost is 6 coins.

In the second test case the optimal strategy is to subtract 1 from *x* 4 times paying 8 coins in total.",WRONG_ANSWER,"import h
import string

from collections import Counter, defaultdict
from math import fsum, sqrt, gcd, ceil, c
from itertools import combinations, permutations

d = lambda: h.stdout.d
b = lambda x, y: (c(x) // c(y)) // c(x - y)

f = lambda: input()
e = lambda: int(input())
r = lambda: map(int, input().split())
g = lambda: list(r())

n = e()
k = e()
a = e()
b = e()

a = (n - 1) * a

if k == 1:
    exit(print(n - 1))

c = 0
while n:
    r = n % k
    c += r * a
    n -= r

    n = n // k
    if n:
        c += b
c-= a

print(min(a, c))","import e

def d():

    c = e.stdin.read().splitlines()

    A, B = map(int, c[0].split())

    x, y, z = map(int, c[1].split())

    g = 2 * x + y
    f = y + 3 * z

    h = max(0, g - A)
    b = max(0, f - B)

    a = h + b

    print(a)

if __name__ == ""__main__"":
    d()"
330,A,Cakeminator,PROGRAMMING,"['brute force', 'implementation']","You are given a rectangular cake, represented as an *r*<=×<=*c* grid. Each cell either has an evil strawberry, or is empty. For example, a 3<=×<=4 cake may look as follows:

The cakeminator is going to eat the cake! Each time he eats, he chooses a row or a column that does not contain any evil strawberries and contains at least one cake cell that has not been eaten before, and eats all the cake cells there. He may decide to eat any number of times.

Please output the maximum number of cake cells that the cakeminator can eat.","The first line contains two integers *r* and *c* (2<=≤<=*r*,<=*c*<=≤<=10), denoting the number of rows and the number of columns of the cake. The next *r* lines each contains *c* characters — the *j*-th character of the *i*-th line denotes the content of the cell at row *i* and column *j*, and is either one of these: 
 -  '.' character denotes a cake cell with no evil strawberry; -  'S' character denotes a cake cell with an evil strawberry.",Output the maximum number of cake cells that the cakeminator can eat.,['3 4\nS...\n....\n..S.\n'],['8\n'],"For the first example, one possible way to eat the maximum number of cake cells is as follows (perform 3 eats).",WRONG_ANSWER,"from sys import f, setrecursionlimit, stdout

def e():
    r, c = (int(s) for s in f.readline().split())

    d = [f.readline().rstrip('\r\n') for _ in range(r)]
    c = set()
    b = set()

    for i in range(r):
        for j in range(c):
            if d[i][j] == 'S':
                c.add(i)
                b.add(j)

    a = (r-len(c))*c+(c-len(b))*r-len(b)
    print(a)

if __name__ == '__main__':
    e()","def g():
    import n

    s = n.stdin.read().strip()
    if not s:
        return

    i = s.strip()

    d = {'L': (-1, 0), 'R': (1, 0), 'U': (0, 1), 'D': (0, -1)}

    o = set()
    x, y = 0, 0
    o.add((x, y))

    m = (x, y)

    for h in i:
        if h not in d:

            continue
        e, f = d[h]

        k, l = x + e, y + f
        j = (k, l)

        if j in o:
            print(""BUG"")
            return

        for b, c in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            a = (k + b, l + c)
            if a in o and a != (x, y):
                print(""BUG"")
                return

        o.add(j)
        m = (x, y)
        x, y = k, l

    print(""OK"")

if __name__ == '__main__':
    g()"
46,A,Ball Game,PROGRAMMING,"['brute force', 'implementation']","A kindergarten teacher Natalia Pavlovna has invented a new ball game. This game not only develops the children's physique, but also teaches them how to count. 

The game goes as follows. Kids stand in circle. Let's agree to think of the children as numbered with numbers from 1 to *n* clockwise and the child number 1 is holding the ball. First the first child throws the ball to the next one clockwise, i.e. to the child number 2. Then the child number 2 throws the ball to the next but one child, i.e. to the child number 4, then the fourth child throws the ball to the child that stands two children away from him, i.e. to the child number 7, then the ball is thrown to the child who stands 3 children away from the child number 7, then the ball is thrown to the child who stands 4 children away from the last one, and so on. It should be mentioned that when a ball is thrown it may pass the beginning of the circle. For example, if *n*<==<=5, then after the third throw the child number 2 has the ball again. Overall, *n*<=-<=1 throws are made, and the game ends.

The problem is that not all the children get the ball during the game. If a child doesn't get the ball, he gets very upset and cries until Natalia Pavlovna gives him a candy. That's why Natalia Pavlovna asks you to help her to identify the numbers of the children who will get the ball after each throw.",The first line contains integer *n* (2<=≤<=*n*<=≤<=100) which indicates the number of kids in the circle.,In the single line print *n*<=-<=1 numbers which are the numbers of children who will get the ball after each throw. Separate the numbers by spaces.,"['10\n', '3\n']","['2 4 7 1 6 2 9 7 6\n', '2 1\n']",none,OK,"a = int(input(''))

def b(a):
    c = 1
    for i in range(1, a):
        c = c + i
        if c > a:
            c = c - a
        print(c, end=' ')

b(a)","import g

def b(a):

    c = []
    i = 0

    while i < len(a):
        if a[i] == '.':

            c.append('0')
            i += 1
        elif a[i] == '-':

            if i + 1 < len(a):
                if a[i + 1] == '.':

                    c.append('1')
                else:

                    c.append('2')
                i += 2
            else:

                i += 1
    return ''.join(c)

def e():

    d = g.stdin.read().strip()

    f = b(d)

    print(f)

if __name__ == '__main__':
    e()"
1,C,Ancient Berland Circus,PROGRAMMING,"['geometry', 'math']","Nowadays all circuses in Berland have a round arena with diameter 13 meters, but in the past things were different.

In Ancient Berland arenas in circuses were shaped as a regular (equiangular) polygon, the size and the number of angles could vary from one circus to another. In each corner of the arena there was a special pillar, and the rope strung between the pillars marked the arena edges.

Recently the scientists from Berland have discovered the remains of the ancient circus arena. They found only three pillars, the others were destroyed by the time.

You are given the coordinates of these three pillars. Find out what is the smallest area that the arena could have.","The input file consists of three lines, each of them contains a pair of numbers –– coordinates of the pillar. Any coordinate doesn't exceed 1000 by absolute value, and is given with at most six digits after decimal point.",Output the smallest possible area of the ancient arena. This number should be accurate to at least 6 digits after the decimal point. It's guaranteed that the number of angles in the optimal polygon is not larger than 100.,['0.000000 0.000000\n1.000000 1.000000\n0.000000 1.000000\n'],['1.00000000\n'],,WRONG_ANSWER,"import s

def q(a, b):
    return a[0]*b[0] + a[1]*b[1]

def v(x):
    return 180 * x / s.pi

def o(x):
    return s.pi* x / 180

def l(a, b, c):
    a = 2*(a[0] - b[0])
    b = 2*(a[1] - b[1])
    c = 2*(a[0] - c[0])
    d = 2*(a[1] - c[1])

    i = a[0]*a[0] - b[0]*b[0] + a[1]*a[1] - b[1]*b[1]
    j = a[0]*a[0] - c[0]*c[0] + a[1]*a[1] - c[1]*c[1]

    p = a * d - b * c

    x = (i * d - j * b) / p
    y = (a * j - c * i) / p

    return (x, y)

def e(a, c, b):

    y = (a[0] - c[0], a[1] - c[1])
    z = (b[0] - c[0], b[1] - c[1])

    n = q(y, z) / s.sqrt(q(y, y)* q(z, z))
    n = min(max(-1, n), 1)

    return s.acos(n)

def r(a, b):
    if a < b:
        return r(b, a)

    if (abs(b) < 0.000001):
        return a

    return r(b, a - s.floor(a / b )*b)

a = tuple(map(float, input().split()))
b = tuple(map(float, input().split()))
c = tuple(map(float, input().split()))

k = l(a, b, c)
w = s.sqrt((a[0] - k[0])**2 + (a[1] - k[1])**2)

f = e(a, k, b)
g = e(a, k, c)

x = r(f, g)

m = 2*w*s.sin(x/2)
h = s.sqrt(w**2 - (m/2)**2)

t = int(round(2*s.pi / x))

u = t*m

print(f""{0.5*u*h:0.6f}"")","def h():
    import i
    d = i.stdin.read().split()
    if not d:
        return

    try:
        x = int(d[0])
        y = int(d[1])
    except:
        return

    if x == 1 and y == 1:
        i.stdout.write("""")
        return

    if x == y:
        i.stdout.write(""Impossible"")
        return

    f = []
    b, c = x, y

    while not (b == 1 and c == 1):
        if b < c:

            k = (c - 1) // b
            if k < 1:
                i.stdout.write(""Impossible"")
                return
            f.append((k, 'B'))
            c -= k * b
        elif b > c:

            k = (b - 1) // c
            if k < 1:
                i.stdout.write(""Impossible"")
                return
            f.append((k, 'A'))
            b -= k * c

        if b == c and b != 1:
            i.stdout.write(""Impossible"")
            return

    f.reverse()

    g = []
    for a, e in f:
        g.append(f""{a}{e}"")
    i.stdout.write("""".join(g))

if __name__ == '__main__':
    h()"
498,A,Crazy Town,PROGRAMMING,['geometry'],"Crazy Town is a plane on which there are *n* infinite line roads. Each road is defined by the equation *a**i**x*<=+<=*b**i**y*<=+<=*c**i*<==<=0, where *a**i* and *b**i* are not both equal to the zero. The roads divide the plane into connected regions, possibly of infinite space. Let's call each such region a block. We define an intersection as the point where at least two different roads intersect.

Your home is located in one of the blocks. Today you need to get to the University, also located in some block. In one step you can move from one block to another, if the length of their common border is nonzero (in particular, this means that if the blocks are adjacent to one intersection, but have no shared nonzero boundary segment, then it are not allowed to move from one to another one in one step).

Determine what is the minimum number of steps you have to perform to get to the block containing the university. It is guaranteed that neither your home nor the university is located on the road.","The first line contains two space-separated integers *x*1, *y*1 (<=-<=106<=≤<=*x*1,<=*y*1<=≤<=106) — the coordinates of your home.

The second line contains two integers separated by a space *x*2, *y*2 (<=-<=106<=≤<=*x*2,<=*y*2<=≤<=106) — the coordinates of the university you are studying at.

The third line contains an integer *n* (1<=≤<=*n*<=≤<=300) — the number of roads in the city. The following *n* lines contain 3 space-separated integers (<=-<=106<=≤<=*a**i*,<=*b**i*,<=*c**i*<=≤<=106; |*a**i*|<=+<=|*b**i*|<=&gt;<=0) — the coefficients of the line *a**i**x*<=+<=*b**i**y*<=+<=*c**i*<==<=0, defining the *i*-th road. It is guaranteed that no two roads are the same. In addition, neither your home nor the university lie on the road (i.e. they do not belong to any one of the lines).",Output the answer to the problem.,"['1 1\n-1 -1\n2\n0 1 0\n1 0 0\n', '1 1\n-1 -1\n3\n1 0 0\n0 1 0\n1 1 -3\n']","['2\n', '2\n']","Pictures to the samples are presented below (A is the point representing the house; B is the point representing the university, different blocks are filled with different colors):",OK,"i,k=map(int,input().split())
j,l=map(int,input().split())
a=k-l
d=j-i
f=j*(l-k)-l*(j-i)
def h(b,e,g):
         global a,d,f,i,k,j,l
         if(a*e==b*d):
                  return False
         x=(d*g-e*f)/(a*e-d*b)
         y=(a*g-f*b)/(d*b-a*e)
         if(min(i,j)<=x<=max(i,j) and min(k,l)<=y<=max(k,l)):
                  return True
         return False
m=int(input())
c=0
for i in range(m):
         b,e,g=map(int,input().split())
         if(h(b,e,g)):
                  c+=1
print(c)","import j

def i():
    c = j.stdin.read().splitlines()
    if not c:
        return

    n = c[0].strip()
    if not n:
        print(-1)
        return

    d = [None, None, None]

    for b in n:
        d = int(b)

        g = d[:]

        if b == '0':
            a = ""0""
            h = 0
        else:
            a = b
            h = d % 3

        if d[h] is None or (len(a) > len(d[h])) or (len(a) == len(d[h]) and d[h] == ""0"" and a != ""0""):
            d[h] = a

        for r in range(3):
            if g[r] is None:
                continue
            if g[r] == ""0"":
                continue
            f = g[r] + b
            e = (r + d) % 3
            if d[e] is None or (len(f) > len(d[e])) or (len(f) == len(d[e]) and d[e] == ""0"" and f != ""0""):
                d[e] = f

    if d[0] is None:
        j.stdout.write(""-1"")
    else:

        if len(d[0]) > 1 and d[0][0] == '0':
            j.stdout.write(""-1"")
        else:
            j.stdout.write(d[0])

if __name__ == '__main__':
    i()"
24,E,Berland collider,PROGRAMMING,['binary search'],"Recently the construction of Berland collider has been completed. Collider can be represented as a long narrow tunnel that contains *n* particles. We associate with collider 1-dimensional coordinate system, going from left to right. For each particle we know its coordinate and velocity at the moment of start of the collider. The velocities of the particles don't change after the launch of the collider. Berland scientists think that the big bang will happen at the first collision of particles, whose velocities differs in directions. Help them to determine how much time elapses after the launch of the collider before the big bang happens.","The first line contains single integer *n* (1<=≤<=*n*<=≤<=5·105) — amount of particles in the collider. Next *n* lines contain description of particles. Each particle is described by two integers *x**i*, *v**i* (<=-<=109<=≤<=*x**i*,<=*v**i*<=≤<=109,<=*v**i*<=≠<=0) — coordinate and velocity respectively. All the coordinates are distinct. The particles are listed in order of increasing of coordinates. All the coordinates are in meters, and all the velocities — in meters per second. The negative velocity means that after the start of collider the particle will move to the left, and the positive — that the particle will move to the right.","If there will be no big bang, output -1. Otherwise output one number — how much time in seconds elapses after the launch of the collider before the big bang happens. Your answer must have a relative or absolute error less than 10<=-<=9.","['3\n-5 9\n0 1\n5 -1\n', '6\n1 3\n2 3\n3 3\n4 -3\n5 -1\n6 -100\n']","['1.00000000000000000000\n', '0.02912621359223301065\n']",none,TIME_LIMIT_EXCEEDED,"def c(g, f, h, k):
    j = g[k][0]
    i = g[h][0]

    for i in range(k, h + 1):
        x, v = g[i]
        b = x + v * f

        if v > 0:
            if b > j:
                j = b
                i = g[h][0]
        else:
            if b < i:
                i = b

        if i <= j:
            return True

    return False

def e():
    n = int(input())
    g = [tuple(map(int, input().split())) for _ in range(n)]

    h = -1
    k = 500000

    for i in range(n):
        if g[i][1] > 0:
            k = i
            break

    for j in range(n - 1, -1, -1):
        if g[j][1] < 0:
            h = j
            break

    if k > h:
        print(-1)
        return

    a = 0
    d, l = 0.0, 1e9

    for _ in range(200):
        f = (d + l) / 2.0

        if c(g, f, h, k):
            l = f
        else:
            d = f

    print(l)

e()","def e(n):

    d = []
    i = 1

    while i * i <= n:
        if n % i == 0:
            if i < n:
                d.append(i)

            if i != n // i and n // i < n:
                d.append(n // i)
        i += 1
    return d

def g():
    import h

    b = h.stdin.read().split()
    if not b:
        return
    p = int(b[0])

    c = e(p - 1)
    a = 0
    for x in range(1, p):
        f = True
        for d in c:

            if pow(x, d, p) == 1:
                f = False
                break
        if f:
            a += 1
    h.stdout.write(str(a))

if __name__ == '__main__':
    g()"
786,C,Till I Collapse,PROGRAMMING,"['data structures', 'divide and conquer']","Rick and Morty want to find MR. PBH and they can't do it alone. So they need of Mr. Meeseeks. They Have generated *n* Mr. Meeseeks, standing in a line numbered from 1 to *n*. Each of them has his own color. *i*-th Mr. Meeseeks' color is *a**i*. 

Rick and Morty are gathering their army and they want to divide Mr. Meeseeks into some squads. They don't want their squads to be too colorful, so each squad should have Mr. Meeseeks of at most *k* different colors. Also each squad should be a continuous subarray of Mr. Meeseeks in the line. Meaning that for each 1<=≤<=*i*<=≤<=*e*<=≤<=*j*<=≤<=*n*, if Mr. Meeseeks number *i* and Mr. Meeseeks number *j* are in the same squad then Mr. Meeseeks number *e* should be in that same squad.

Also, each squad needs its own presidio, and building a presidio needs money, so they want the total number of squads to be minimized.

Rick and Morty haven't finalized the exact value of *k*, so in order to choose it, for each *k* between 1 and *n* (inclusive) need to know the minimum number of presidios needed.","The first line of input contains a single integer *n* (1<=≤<=*n*<=≤<=105) — number of Mr. Meeseeks.

The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* separated by spaces (1<=≤<=*a**i*<=≤<=*n*) — colors of Mr. Meeseeks in order they standing in a line.",In the first and only line of input print *n* integers separated by spaces. *i*-th integer should be the minimum number of presidios needed if the value of *k* is *i*.,"['5\n1 3 4 3 3\n', '8\n1 5 7 8 1 7 6 1\n']","['4 2 1 1 1 \n', '8 4 3 2 1 1 1 1 \n']","For the first sample testcase, some optimal ways of dividing army into squads for each *k* are:
 1.  [1], [3], [4], [3, 3] 1.  [1], [3, 4, 3, 3] 1.  [1, 3, 4, 3, 3] 1.  [1, 3, 4, 3, 3] 1.  [1, 3, 4, 3, 3] 
For the second testcase, some optimal ways of dividing army into squads for each *k* are:
 1.  [1], [5], [7], [8], [1], [7], [6], [1] 1.  [1, 5], [7, 8], [1, 7], [6, 1] 1.  [1, 5, 7], [8], [1, 7, 6, 1] 1.  [1, 5, 7, 8], [1, 7, 6, 1] 1.  [1, 5, 7, 8, 1, 7, 6, 1] 1.  [1, 5, 7, 8, 1, 7, 6, 1] 1.  [1, 5, 7, 8, 1, 7, 6, 1] 1.  [1, 5, 7, 8, 1, 7, 6, 1]",TIME_LIMIT_EXCEEDED,"import d,k,collections,heapq,itertools
if d.path.exists('in.txt'):
    a = open('in.txt') 
    input =  a.readline 
else : 
    input = k.stdin.readline  
from functools import reduce 
from itertools import accumulate,chain,combinations,count 
from itertools import b,permutations,product,zip_longest
from heapq import heapify,heappush,heappop,heapreplace,merge,nlargest,nsmallest
from collections import Counter,defaultdict,deque 
from bisect import bisect_left, bisect_right
from math import comb,floor,ceil,inf ,gcd  ,sqrt 
import functools 
e = lambda: int(input()) 
f = lambda: list(map(int,input().split()))
g = lambda: input().rstrip() 
h = lambda: input().split()   
def j():  
    n = e() 
    a = f() 
    i = [0] * (n+1) 
    r = len(set(a)) 
    i[r] = 1 
    i[1] = len(list(b(a))) 
    q = [(1,r)]  
    def f(k): 
        m = 0 
        C = set() 
        i = 0 
        while i < n :
            m += 1 
            C.clear()  
            while i < n:
                C.add(a[i]) 
                if len(C) > k : break 
                i += 1    
        return m 
    while q:
        l,r = q.pop() 
        if r - l <= 1 or i[l] == i[r] : continue 
        c = (l+r) // 2 
        i[c] = f(c) 
        q += [(l,c),(c,r)] 
    for i in range(2,n+1):
        if not i[i] : i[i] = i[i-1] 
    print(*i[1:])
    
for i in range(1):
    j()","import x
import d

def v():

    f = x.stdin.read().splitlines()
    if not f:
        return
    r, c = map(int, f[0].split())
    o = f[1:1+r]

    w = None
    n = None
    for i in range(r):
        for j in range(c):
            b = o[i][j]
            if b == 'S':
                w = (i, j)
            elif b == 'E':
                n = (i, j)

    h = [(-1, 0), (1, 0), (0, -1), (0, 1)]

    s = [[-1] * c for _ in range(r)]
    j = d.deque()
    t, u = w
    s[t][u] = 0
    j.append((t, u))
    
    while j:
        i, j = j.popleft()
        e = s[i][j]
        for g, i in h:
            q, r = i + g, j + i
            if 0 <= q < r and 0 <= r < c:
                if o[q][r] == 'T':
                    continue
                if s[q][r] == -1:
                    s[q][r] = e + 1
                    j.append((q, r))

    l, m = n
    p = s[l][m]

    k = [[-1] * c for _ in range(r)]
    j = d.deque()
    k[l][m] = 0
    j.append((l, m))
    
    while j:
        i, j = j.popleft()
        e = k[i][j]
        for g, i in h:
            q, r = i + g, j + i
            if 0 <= q < r and 0 <= r < c:
                if o[q][r] == 'T':
                    continue
                if k[q][r] == -1:
                    k[q][r] = e + 1
                    j.append((q, r))

    a = 0
    for i in range(r):
        for j in range(c):
            b = o[i][j]

            if b.isdigit():
                c = int(b)
                if c == 0:
                    continue

                if k[i][j] != -1 and k[i][j] <= p:
                    a += c
    x.stdout.write(str(a))

if __name__ == '__main__':
    v()"
230,B,T-primes,PROGRAMMING,"['binary search', 'implementation', 'math', 'number theory']","We know that prime numbers are positive integers that have exactly two distinct positive divisors. Similarly, we'll call a positive integer *t* Т-prime, if *t* has exactly three distinct positive divisors.

You are given an array of *n* positive integers. For each of them determine whether it is Т-prime or not.","The first line contains a single positive integer, *n* (1<=≤<=*n*<=≤<=105), showing how many numbers are in the array. The next line contains *n* space-separated integers *x**i* (1<=≤<=*x**i*<=≤<=1012).

Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is advised to use the cin, cout streams or the %I64d specifier.","Print *n* lines: the *i*-th line should contain ""YES"" (without the quotes), if number *x**i* is Т-prime, and ""NO"" (without the quotes), if it isn't.",['3\n4 5 6\n'],['YES\nNO\nNO\n'],"The given test has three numbers. The first number 4 has exactly three divisors — 1, 2 and 4, thus the answer for this number is ""YES"". The second number 5 has two divisors (1 and 5), and the third number 6 has four divisors (1, 2, 3, 6), hence the answer for them is ""NO"".",TIME_LIMIT_EXCEEDED,"def a(x):
    if (x == 2) or (x == 3):
        return True
    if (x % 6 != 1) and (x % 6 != 5):
        return False
    for i in range(5, int(x ** 0.5) + 1, 6):
        if (x % i == 0) or (x % (i + 2) == 0):
            return False
    return True
n=int(input())
s=[int(i) for i in input().split()]
for i in range(0,n):
    if(s[i]==1):
        print(""NO"")
        continue
    b=s[i]**0.5
    if(b==int(b)):
        b=int(b)
        if(a(b)):
            print(""YES"")
        else:
            print(""NO"")
    else:
        print(""NO"")","import k

def e():

    d = k.stdin.read().strip().split()

    a, b, c = map(int, d)

    f = a + b + c

    g = 2 * (a + b)

    h = 2 * (a + c)

    i = 2 * (b + c)

    j = min(f, g, h, i)

    k.stdout.write(str(j))

if __name__ == ""__main__"":
    e()"
534,A,Exam,PROGRAMMING,"['constructive algorithms', 'implementation', 'math']","An exam for *n* students will take place in a long and narrow room, so the students will sit in a line in some order. The teacher suspects that students with adjacent numbers (*i* and *i*<=+<=1) always studied side by side and became friends and if they take an exam sitting next to each other, they will help each other for sure.

Your task is to choose the maximum number of students and make such an arrangement of students in the room that no two students with adjacent numbers sit side by side.",A single line contains integer *n* (1<=≤<=*n*<=≤<=5000) — the number of students at an exam.,"In the first line print integer *k* — the maximum number of students who can be seated so that no two students with adjacent numbers sit next to each other.

In the second line print *k* distinct integers *a*1,<=*a*2,<=...,<=*a**k* (1<=≤<=*a**i*<=≤<=*n*), where *a**i* is the number of the student on the *i*-th position. The students on adjacent positions mustn't have adjacent numbers. Formally, the following should be true: |*a**i*<=-<=*a**i*<=+<=1|<=≠<=1 for all *i* from 1 to *k*<=-<=1.

If there are several possible answers, output any of them.","['6', '3\n']","['6\n1 5 3 6 2 4', '2\n1 3']",none,OK,"def c(b,n):
    for i in range(1,n+1,2):
        b.append(i)
    
def a(b,n):
        d=2
        if len(b)==1 or n==3:
            d=4
        for j in range(d,n+1,2):
            b.append(j)    

n=int(input())
b=[]

if n%2==0 and n>2:
    a(b, n)
    c(b, n)  
   
else:
    
    c(b, n)
    a(b, n)
print(len(b))
print(*b)","def b():
    import c

    a = c.stdin.read().strip().split()
    if not a:
        return
    a = int(a[0])
    b = int(a[1])

    while a > 0 and b > 0:

        if a >= 2 * b:

            a %= (2 * b)

        elif b >= 2 * a:
            b %= (2 * a)
        else:

            break

    c.stdout.write(f""{a} {b}"")

if __name__ == ""__main__"":
    b()"
518,B,Tanya and Postcard,PROGRAMMING,"['greedy', 'implementation', 'strings']","Little Tanya decided to present her dad a postcard on his Birthday. She has already created a message — string *s* of length *n*, consisting of uppercase and lowercase English letters. Tanya can't write yet, so she found a newspaper and decided to cut out the letters and glue them into the postcard to achieve string *s*. The newspaper contains string *t*, consisting of uppercase and lowercase English letters. We know that the length of string *t* greater or equal to the length of the string *s*.

The newspaper may possibly have too few of some letters needed to make the text and too many of some other letters. That's why Tanya wants to cut some *n* letters out of the newspaper and make a message of length exactly *n*, so that it looked as much as possible like *s*. If the letter in some position has correct value and correct letter case (in the string *s* and in the string that Tanya will make), then she shouts joyfully ""YAY!"", and if the letter in the given position has only the correct value but it is in the wrong case, then the girl says ""WHOOPS"".

Tanya wants to make such message that lets her shout ""YAY!"" as much as possible. If there are multiple ways to do this, then her second priority is to maximize the number of times she says ""WHOOPS"". Your task is to help Tanya make the message.","The first line contains line *s* (1<=≤<=|*s*|<=≤<=2·105), consisting of uppercase and lowercase English letters — the text of Tanya's message.

The second line contains line *t* (|*s*|<=≤<=|*t*|<=≤<=2·105), consisting of uppercase and lowercase English letters — the text written in the newspaper.

Here |*a*| means the length of the string *a*.","Print two integers separated by a space:
 -  the first number is the number of times Tanya shouts ""YAY!"" while making the message, -  the second number is the number of times Tanya says ""WHOOPS"" while making the message.","['AbC\nDCbA\n', 'ABC\nabc\n', 'abacaba\nAbaCaBA\n']","['3 0\n', '0 3\n', '3 4\n']",none,WRONG_ANSWER,"import j;
l = input()
m = input()
g = {b: 0 for b in l}
h = {b: 0 for b in m}
for b in l:
    g[b] += 1

for b in m:
    h[b] += 1

o = 0
n = 0
i = []
for b in h:
    j.heappush(i, (-h[b], b))

def k(b, a):
    o = 0
    n = 0
    d = min(g[b], h[b]
                     ) if b in g else 0
    o += d
    h[b] -= d
    if b in g:
        g[b] -= d
        if g[b] == 0:
            g.pop(b)

    d = min(g[a], h[b]
                     ) if a in g else 0
    n += d
    h[b] -= d
    if a in g:
        g[a] -= d
        if g[a] == 0:
            g.pop(a)
    return (o, n)

while(len(i)):
    c, b = j.heappop(i)
    if b.islower():
        if b not in g and b.upper() not in g:
            continue
        f, e = k(b, b.upper())
        o += f
        n += e
    else:
        if b not in g and b.lower() not in g:
            continue
        f, e = k(b, b.lower())
        o += f
        n += e

    if h[b] > 0:
        j.heappush(i, (-h[b], b))

print(o, n)","def e(n):
    """"""
    Implements the Sieve of Eratosthenes to generate prime flags up to n.
    Returns a list of booleans where is_prime[i] is True if i is prime.
    """"""
    b = [True] * (n + 1)
    b[0] = b[1] = False
    p = 2
    while p * p <= n:
        if b[p]:
            for d in range(p*p, n+1, p):
                b[d] = False
        p += 1
    return b

def c():
    import f

    a = f.stdin.read().strip().split()
    if not a:
        return
    n = int(a[0])

    b = e(n)

    for i in range(4, n):

        if not b[i] and not b[n - i]:

            f.stdout.write(f""{i} {n - i}\n"")
            break

if __name__ == ""__main__"":
    c()"
727,C,Guess the Array,PROGRAMMING,"['constructive algorithms', 'interactive', 'math']","This is an interactive problem. You should use flush operation after each printed line. For example, in C++ you should use fflush(stdout), in Java you should use System.out.flush(), and in Pascal — flush(output).

In this problem you should guess an array *a* which is unknown for you. The only information you have initially is the length *n* of the array *a*.

The only allowed action is to ask the sum of two elements by their indices. Formally, you can print two indices *i* and *j* (the indices should be distinct). Then your program should read the response: the single integer equals to *a**i*<=+<=*a**j*.

It is easy to prove that it is always possible to guess the array using at most *n* requests.

Write a program that will guess the array *a* by making at most *n* requests.",none,none,['5\n\xa0\n9\n\xa0\n7\n\xa0\n9\n\xa0\n11\n\xa0\n6\n\xa0'],['? 1 5\n\xa0\n? 2 3\n\xa0\n? 4 1\n\xa0\n? 5 2\n\xa0\n? 3 4\n\xa0\n! 4 6 1 5 5'],"The format of a test to make a hack is:
 -  The first line contains an integer number *n* (3 ≤ *n* ≤ 5000) — the length of the array.-  The second line contains *n* numbers *a*<sub class=""lower-index"">1</sub>, *a*<sub class=""lower-index"">2</sub>, ..., *a*<sub class=""lower-index"">*n*</sub> (1 ≤ *a*<sub class=""lower-index"">*i*</sub> ≤ 10<sup class=""upper-index"">5</sup>) — the elements of the array to guess.",IDLENESS_LIMIT_EXCEEDED,"from math import ceil,gcd,floor
from collections import deque,defaultdict as dict
from heapq import heappush as hpush,heappop as hpop, heapify
from functools import lru_cache
import f
input = f.stdin.buffer.readline
a=float(""inf"")

def d(): return(int(input()))
def c(): return(list(map(int,input().split())))
def b(): s = input();return(list(s))
def e(): return(map(int,input().split()))

n=int(input())

d={}
for i in range(2,n+1):
	print(""?"",1,i)
	f.stdout.flush()
	d[i]=int(input())
print(""?"",2,3)
k=d()
d[1]=(d[2]+d[3]-k)//2
print(""!"",d[1],end="" "")
for i in range(2,n+1):
	print(d[i]-d[1],end="" "")
f.stdout.flush()","def e():
    import h
    c = h.stdin.read().strip().split()
    if not c:
        return
    n = int(c[0])
    d = int(c[1])
    h = int(c[2])

    if d < h or d > 2 * h:
        print(-1)
        return

    if d == 1:
        if n == 2:
            print(""1 2"")
        else:
            print(-1)
        return

    d = []
    b = 2

    f = 1
    for i in range(h):
        d.append((f, b))
        f = b
        b += 1

    if d > h:
        f = 1
        d.append((f, b))
        f = b
        b += 1
        for i in range(d - h - 1):
            d.append((f, b))
            f = b
            b += 1

    a = 1 if d > h else 2
    while b <= n:
        d.append((a, b))
        b += 1

    g = ""\n"".join(f""{u} {v}"" for u, v in d)
    h.stdout.write(g)

if __name__ == '__main__':
    e()"
743,B,Chloe and the sequence ,PROGRAMMING,"['binary search', 'bitmasks', 'constructive algorithms', 'implementation']","Chloe, the same as Vladik, is a competitive programmer. She didn't have any problems to get to the olympiad like Vladik, but she was confused by the task proposed on the olympiad.

Let's consider the following algorithm of generating a sequence of integers. Initially we have a sequence consisting of a single element equal to 1. Then we perform (*n*<=-<=1) steps. On each step we take the sequence we've got on the previous step, append it to the end of itself and insert in the middle the minimum positive integer we haven't used before. For example, we get the sequence [1,<=2,<=1] after the first step, the sequence [1,<=2,<=1,<=3,<=1,<=2,<=1] after the second step.

The task is to find the value of the element with index *k* (the elements are numbered from 1) in the obtained sequence, i. e. after (*n*<=-<=1) steps.

Please help Chloe to solve the problem!","The only line contains two integers *n* and *k* (1<=≤<=*n*<=≤<=50, 1<=≤<=*k*<=≤<=2*n*<=-<=1).",Print single integer — the integer at the *k*-th position in the obtained sequence.,"['3 2\n', '4 8\n']","['2', '4']","In the first sample the obtained sequence is [1, 2, 1, 3, 1, 2, 1]. The number on the second position is 2.

In the second sample the obtained sequence is [1, 2, 1, 3, 1, 2, 1, 4, 1, 2, 1, 3, 1, 2, 1]. The number on the eighth position is 4.",WRONG_ANSWER,"N, K = map(int, input().split())
L = [0] * 60
L[0] = 1
for i in range(1, 60):
    L[i] = 2 * L[i - 1] + 1

def a(n, k):
    if k == L[n] // 2:
        return n + 1
    elif k > L[n] // 2:
        return a(n - 1, k - L[n] // 2)
    else:
        return a(n - 1, k)

print(a(N - 1, K - 1))","""""""
We solve the problem by “pushing” coins (the values at positions)
to the right in a greedy manner. The optimal strategy (which was 
proved in the original editorial) is to process positions 1..n−1 
in order (using 1–indexed notation) and for each position i, “clear”
its coins with moves. In one move a coin from position i is transferred 
to position j = i + 2 · ⎣(n−i)/2⎦; note that if i is “close” to n then 
this jump might be very short – and coins which never reach a “safe”
zone cost extra moves.
 
Accordingly, we maintain an “extra” array that holds coins transferred 
from earlier positions but not yet “cleared”. Then if we denote by ans[k]
the minimum moves needed to clear positions 1 … k, one may show that
 
  ans[i] = ans[i−1] + (a[i] + extra[i]),
  and then we “push” the current coins from position i to position 
  j = i + 2 * ⎣(n − i)/2⎦ (if j ≤ n).
 
This greedy algorithm – originally published in C++ – yields the minimal 
number of moves. (See the editorial for “The Smart Beaver’s Educational Game”.)
 
The code below implements the same idea in Python. Input is read from standard 
input and output is written to standard output. (We use 0-indexing internally; 
the transformation from the 1-indexed description is done in the comments.)
 
Note: This solution produces exactly the required output: it prints n–1 lines, 
with the kth line (k = 1 … n–1) giving the answer for clearing positions 1 … k.
""""""

import f

def d():
    b = f.stdin.read().split()
    if not b:
        return
    n = int(b[0])

    a = [int(x) for x in b[1:]]

    e = [0]*(n-1)

    c = [0]*n
    g = 0

    for i in range(n-1):

        a = a[i] + c[i]
        g += a
        e[i] = g

        t = (n - i) // 2
        j = i + 2 * t
        if j < n:
            c[j] += a

    f.stdout.write(""\n"".join(map(str, e)) + ""\n"")
    
if __name__ == '__main__':
    d()"
408,A,Line to Cashier,PROGRAMMING,['implementation'],"Little Vasya went to the supermarket to get some groceries. He walked about the supermarket for a long time and got a basket full of products. Now he needs to choose the cashier to pay for the products.

There are *n* cashiers at the exit from the supermarket. At the moment the queue for the *i*-th cashier already has *k**i* people. The *j*-th person standing in the queue to the *i*-th cashier has *m**i*,<=*j* items in the basket. Vasya knows that:
 -  the cashier needs 5 seconds to scan one item; -  after the cashier scans each item of some customer, he needs 15 seconds to take the customer's money and give him the change. 
Of course, Vasya wants to select a queue so that he can leave the supermarket as soon as possible. Help him write a program that displays the minimum number of seconds after which Vasya can get to one of the cashiers.","The first line contains integer *n* (1<=≤<=*n*<=≤<=100) — the number of cashes in the shop. The second line contains *n* space-separated integers: *k*1,<=*k*2,<=...,<=*k**n* (1<=≤<=*k**i*<=≤<=100), where *k**i* is the number of people in the queue to the *i*-th cashier.

The *i*-th of the next *n* lines contains *k**i* space-separated integers: *m**i*,<=1,<=*m**i*,<=2,<=...,<=*m**i*,<=*k**i* (1<=≤<=*m**i*,<=*j*<=≤<=100) — the number of products the *j*-th person in the queue for the *i*-th cash has.",Print a single integer — the minimum number of seconds Vasya needs to get to the cashier.,"['1\n1\n1\n', '4\n1 4 3 2\n100\n1 2 2 3\n1 9 1\n7 8\n']","['20\n', '100\n']","In the second test sample, if Vasya goes to the first queue, he gets to the cashier in 100·5 + 15 = 515 seconds. But if he chooses the second queue, he will need 1·5 + 2·5 + 2·5 + 3·5 + 4·15 = 100 seconds. He will need 1·5 + 9·5 + 1·5 + 3·15 = 100 seconds for the third one and 7·5 + 8·5 + 2·15 = 105 seconds for the fourth one. Thus, Vasya gets to the cashier quicker if he chooses the second or the third queue.",OK,"class a:
    def __init__(f):
        f.result = ''
        f.cash_count = 0
        f.client_cashwise = []
        f.baskets = []

    def e(f):
        f.cash_count = int(input())
        f.client_cashwise = [int(x) for x in input().split("" "")]
        for x in range(f.cash_count):
            f.baskets.append([int(x) for x in input().split("" "")])

    def d(f):
        g = [len(x) * 15 + 5 * sum(x) for x in f.baskets]
        f.result = str(min(g))

    def c(f):
        return f.result

if __name__ == ""__main__"":
    b = a()
    b.e()
    b.d()
    print(b.c())","def c(b):

    e = []
    i = 0
    n = len(b)

    while i < n:

        if b[i] == '.':
            e.append('0')
            i += 1
        else:

            if i + 1 < n:
                if b[i+1] == '.':
                    e.append('1')
                    i += 2
                else:

                    e.append('2')
                    i += 2
            else:

                i += 1
    return ''.join(e)

if __name__ == ""__main__"":

    a = input().strip()
    d = c(a)

    print(d)"
645,A,Amity Assessment,PROGRAMMING,"['brute force', 'constructive algorithms', 'implementation']","Bessie the cow and her best friend Elsie each received a sliding puzzle on Pi Day. Their puzzles consist of a 2<=×<=2 grid and three tiles labeled 'A', 'B', and 'C'. The three tiles sit on top of the grid, leaving one grid cell empty. To make a move, Bessie or Elsie can slide a tile adjacent to the empty cell into the empty cell as shown below:

In order to determine if they are truly Best Friends For Life (BFFLs), Bessie and Elsie would like to know if there exists a sequence of moves that takes their puzzles to the same configuration (moves can be performed in both puzzles). Two puzzles are considered to be in the same configuration if each tile is on top of the same grid cell in both puzzles. Since the tiles are labeled with letters, rotations and reflections are not allowed.","The first two lines of the input consist of a 2<=×<=2 grid describing the initial configuration of Bessie's puzzle. The next two lines contain a 2<=×<=2 grid describing the initial configuration of Elsie's puzzle. The positions of the tiles are labeled 'A', 'B', and 'C', while the empty cell is labeled 'X'. It's guaranteed that both puzzles contain exactly one tile with each letter and exactly one empty position.","Output ""YES""(without quotes) if the puzzles can reach the same configuration (and Bessie and Elsie are truly BFFLs). Otherwise, print ""NO"" (without quotes).","['AB\nXC\nXB\nAC\n', 'AB\nXC\nAC\nBX\n']","['YES\n', 'NO\n']","The solution to the first sample is described by the image. All Bessie needs to do is slide her 'A' tile down.

In the second sample, the two puzzles can never be in the same configuration. Perhaps Bessie and Elsie are not meant to be friends after all...",WRONG_ANSWER,"def c(s):
    d = ''
    for j in range(4):
        a = (i + j) % 4
        if s[a] != 'X':
            d += s[a]

    if d in b:
        exit(print('YES'))
    b[d] = True

a, b, b = input() + input()[::-1], input() + input()[::-1], dict()
for i in range(4):
    c(a)
    c(b)

print('NO')","from collections import a

n = int(input().strip())

b = list(map(int, input().split()))

c = a(b)

d = max(c.values())

e = len(c)

print(d, e)"
272,A,Dima and Friends,PROGRAMMING,"['implementation', 'math']","Dima and his friends have been playing hide and seek at Dima's place all night. As a result, Dima's place got messy. In the morning they decided that they need to clean the place.

To decide who exactly would clean the apartment, the friends want to play a counting-out game. First, all the guys stand in a circle, and then each of them shows some number of fingers on one hand (one to five), and then the boys count in a circle, starting from Dima, the number of people, respective to the total number of fingers shown. The person on who the countdown stops will clean the apartment.

For example, if Dima and one of his friends played hide and seek, and 7 fingers were shown during the counting-out, then Dima would clean the place. If there were 2 or say, 8 fingers shown, then his friend would clean the place.

Dima knows how many fingers each of his friends will show during the counting-out. Now he is interested in the number of ways to show some number of fingers on one hand (one to five), so that he did not have to clean the place. Help Dima.","The first line contains integer *n* (1<=≤<=*n*<=≤<=100) — the number of Dima's friends. Dima himself isn't considered to be his own friend. The second line contains *n* positive integers, not exceeding 5, representing, how many fingers the Dima's friends will show. 

The numbers in the lines are separated by a single space.",In a single line print the answer to the problem.,"['1\n1\n', '1\n2\n', '2\n3 5\n']","['3\n', '2\n', '3\n']","In the first sample Dima can show 1, 3 or 5 fingers. If Dima shows 3 fingers, then the counting-out will go like that: Dima, his friend, Dima, his friend.

In the second sample Dima can show 2 or 4 fingers.",OK,"""""""
sumOfFinger=sum(fingerShownByFriends)
Dima can show 1 to 5 fingers..
so 
k = [sumOfFingers+i for i in range(1,6)]
now we've to check if k[i] prsenet in arithmetic progression whose firstVal=1 and diff=numOfFriens+1
if k[i] is present==
	=>>then it means if Dima shows i+1 fingers then..
			=>>then counting will end on Dima & hence he'll have to clean the place
""""""

def f(n,d):

	a=1
	return (n-a)%d==0
c=int(input())
b=list(map(int,input().split("" "")))
e=sum(b)
d=5
for a in range(1,6):
	if f(e+a, c+1):
		d-=1
print(d)","def c():

    k = int(input().strip())
    q = input().strip()

    e = []

    f = set()

    b = """"

    for a in q:

        if a not in f and len(e) < k - 1:
            if b:
                e.append(b)
            b = a
            f.add(a)
        else:
            b += a

    e.append(b)

    if len(e) == k:
        print(""YES"")
        for d in e:
            print(d)
    else:
        print(""NO"")

if __name__ == ""__main__"":
    c()"
362,B,Petya and Staircases,PROGRAMMING,"['implementation', 'sortings']","Little boy Petya loves stairs very much. But he is bored from simple going up and down them — he loves jumping over several stairs at a time. As he stands on some stair, he can either jump to the next one or jump over one or two stairs at a time. But some stairs are too dirty and Petya doesn't want to step on them.

Now Petya is on the first stair of the staircase, consisting of *n* stairs. He also knows the numbers of the dirty stairs of this staircase. Help Petya find out if he can jump through the entire staircase and reach the last stair number *n* without touching a dirty stair once.

One has to note that anyway Petya should step on the first and last stairs, so if the first or the last stair is dirty, then Petya cannot choose a path with clean steps only.","The first line contains two integers *n* and *m* (1<=≤<=*n*<=≤<=109, 0<=≤<=*m*<=≤<=3000) — the number of stairs in the staircase and the number of dirty stairs, correspondingly. The second line contains *m* different space-separated integers *d*1,<=*d*2,<=...,<=*d**m* (1<=≤<=*d**i*<=≤<=*n*) — the numbers of the dirty stairs (in an arbitrary order).","Print ""YES"" if Petya can reach stair number *n*, stepping only on the clean stairs. Otherwise print ""NO"".","['10 5\n2 4 8 3 6\n', '10 5\n2 4 5 7 9\n']","['NO', 'YES']",none,WRONG_ANSWER,"class a:
    def __init__(h):
        h.result = ''
        h.n_m = []
        h.d = []

    def g(h):
        h.n_m = [int(x) for x in input().split("" "")]
        h.d = [int(x) for x in input().split("" "")]

    def f(h):
        d = {}
        for d in h.d:
            d[d] = True
        c = True
        for d in h.d:
            if d - 1 in d and d + 1 in d:
                c = False
                break
        h.result = ""YES"" if c else ""NO""

    def e(h):
        return h.result

if __name__ == ""__main__"":
    b = a()
    b.g()
    b.f()
    print(b.e())","import e

def a(h, i):

    d = h.count('+') - h.count('-')

    b = i.count('+') - i.count('-')

    k = i.count('?')

    c = d - b

    if k == 0:

        return 1.0 if b == d else 0.0

    if (c + k) % 2 != 0 or abs(c) > k:
        return 0.0
    
    x = (c + k) // 2
    if x < 0 or x > k:
        return 0.0

    l = e.comb(k, x)

    j = 2 ** k

    f = l / j
    return f

if __name__ == '__main__':

    h = input().strip()
    i = input().strip()

    g = a(h, i)

    print(f""{g:.12f}"")"
701,B,Cells Not Under Attack,PROGRAMMING,"['data structures', 'math']","Vasya has the square chessboard of size *n*<=×<=*n* and *m* rooks. Initially the chessboard is empty. Vasya will consequently put the rooks on the board one after another.

The cell of the field is under rook's attack, if there is at least one rook located in the same row or in the same column with this cell. If there is a rook located in the cell, this cell is also under attack.

You are given the positions of the board where Vasya will put rooks. For each rook you have to determine the number of cells which are not under attack after Vasya puts it on the board.","The first line of the input contains two integers *n* and *m* (1<=≤<=*n*<=≤<=100<=000, 1<=≤<=*m*<=≤<=*min*(100<=000,<=*n*2)) — the size of the board and the number of rooks. 

Each of the next *m* lines contains integers *x**i* and *y**i* (1<=≤<=*x**i*,<=*y**i*<=≤<=*n*) — the number of the row and the number of the column where Vasya will put the *i*-th rook. Vasya puts rooks on the board in the order they appear in the input. It is guaranteed that any cell will contain no more than one rook.","Print *m* integer, the *i*-th of them should be equal to the number of cells that are not under attack after first *i* rooks are put.","['3 3\n1 1\n3 1\n2 2\n', '5 2\n1 5\n5 1\n', '100000 1\n300 400\n']","['4 2 0 \n', '16 9 \n', '9999800001 \n']",On the picture below show the state of the board after put each of the three rooks. The cells which painted with grey color is not under the attack.,OK,"import g
input = lambda:g.stdin.readline()

d = lambda: list(map(int,input().split()))
f = lambda: list(map(str,input().split()))
c = lambda: map(str,input().split())
b = lambda: map(int,input().split())
a = lambda: map(float,input().split())

e = 1000000007

n,r = b()
c = 0
a,b = set(),set()
for _ in range(r):
	x,y = b()
	a.add(x);b.add(y)
	print((n-len(a))*(n-len(b)))","def b():
    import f

    s = f.stdin.read().strip()

    if ""\n"" in s:
        s = s.splitlines()[0]

    a = []
    d = []
    
    n = len(s)

    for i in range(n):
        e = i + 1

        if s[i] == 'l':
            a.append(e)
        else:
            d.append(e)

    c = d + a[::-1]

    print(""\n"".join(map(str, c)))

if __name__ == ""__main__"":
    b()"
981,C,Useful Decomposition,PROGRAMMING,"['implementation', 'trees']","Ramesses knows a lot about problems involving trees (undirected connected graphs without cycles)!

He created a new useful tree decomposition, but he does not know how to construct it, so he asked you for help!

The decomposition is the splitting the edges of the tree in some simple paths in such a way that each two paths have at least one common vertex. Each edge of the tree should be in exactly one path.

Help Remesses, find such a decomposition of the tree or derermine that there is no such decomposition.","The first line contains a single integer $n$ ($2 \leq n \leq 10^{5}$) the number of nodes in the tree.

Each of the next $n<=-<=1$ lines contains two integers $a_i$ and $b_i$ ($1 \leq a_i, b_i \leq n$, $a_i \neq b_i$) — the edges of the tree. It is guaranteed that the given edges form a tree.","If there are no decompositions, print the only line containing ""No"".

Otherwise in the first line print ""Yes"", and in the second line print the number of paths in the decomposition $m$. 

Each of the next $m$ lines should contain two integers $u_i$, $v_i$ ($1 \leq u_i, v_i \leq n$, $u_i \neq v_i$) denoting that one of the paths in the decomposition is the simple path between nodes $u_i$ and $v_i$. 

Each pair of paths in the decomposition should have at least one common vertex, and each edge of the tree should be presented in exactly one path. You can print the paths and the ends of each path in arbitrary order.

If there are multiple decompositions, print any.","['4\n1 2\n2 3\n3 4\n', '6\n1 2\n2 3\n3 4\n2 5\n3 6\n', '5\n1 2\n1 3\n1 4\n1 5\n']","['Yes\n1\n1 4\n', 'No\n', 'Yes\n4\n1 2\n1 3\n1 4\n1 5\n']","The tree from the first example is shown on the picture below: <img class=""tex-graphics"" src=""https://espresso.codeforces.com/9eb4b4c143d3ad267ae05d1e43341bd368b3088b.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> The number next to each edge corresponds to the path number in the decomposition. It is easy to see that this decomposition suits the required conditions.

The tree from the second example is shown on the picture below: <img class=""tex-graphics"" src=""https://espresso.codeforces.com/20704b97182d9bcde3321c00a16edcae4d772d93.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> We can show that there are no valid decompositions of this tree.

The tree from the third example is shown on the picture below: <img class=""tex-graphics"" src=""https://espresso.codeforces.com/357ff9496a4ed4746401160ee6ee63f5d57d81b9.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> The number next to each edge corresponds to the path number in the decomposition. It is easy to see that this decomposition suits the required conditions.",WRONG_ANSWER,"import h

def d(g, i=set({})):
	c = []
	i.add(g)
	e = True
	for v in g[g]:
		if v not in i:
			e = False
			c += d(v)
	if e:
		return c + [g]
	return c

n = int(h.stdin.readline().strip())
g = {i:[] for i in range(n+1)}
for _ in range(n-1):
	u,v = map(int,h.stdin.readline().strip().split(' '))
	g[u].append(v)
	g[v].append(u)

a = 0
f = -1
for i in range(1,n+1):
	if len(g[i]) > 2:
		a += 1
		f = i
	if len(g[i]) == 2 and f == -1:
		f = i

if a >= 2:
	print(""No"")
else:
	c = d(f)
	print(len(c))
	for b in c:
		print(str(f) + ' ' + str(b))","def b():
    import f

    a = f.stdin.read().split()
    e = []
    for g in a:

        n = int(g)

        if n >= 0:
            e.append(str(n))
        else:

            c = - (abs(n) // 10)

            d = - ((abs(n) // 100) * 10 + abs(n) % 10)

            e.append(str(max(n, c, d)))

    f.stdout.write(""\n"".join(e))

if __name__ == '__main__':
    b()"
388,A,Fox and Box Accumulation,PROGRAMMING,"['greedy', 'sortings']","Fox Ciel has *n* boxes in her room. They have the same size and weight, but they might have different strength. The *i*-th box can hold at most *x**i* boxes on its top (we'll call *x**i* the strength of the box). 

Since all the boxes have the same size, Ciel cannot put more than one box directly on the top of some box. For example, imagine Ciel has three boxes: the first has strength 2, the second has strength 1 and the third has strength 1. She cannot put the second and the third box simultaneously directly on the top of the first one. But she can put the second box directly on the top of the first one, and then the third box directly on the top of the second one. We will call such a construction of boxes a pile.

Fox Ciel wants to construct piles from all the boxes. Each pile will contain some boxes from top to bottom, and there cannot be more than *x**i* boxes on the top of *i*-th box. What is the minimal number of piles she needs to construct?","The first line contains an integer *n* (1<=≤<=*n*<=≤<=100). The next line contains *n* integers *x*1,<=*x*2,<=...,<=*x**n* (0<=≤<=*x**i*<=≤<=100).",Output a single integer — the minimal possible number of piles.,"['3\n0 0 10\n', '5\n0 1 2 3 4\n', '4\n0 0 0 0\n', '9\n0 1 0 2 0 1 1 2 10\n']","['2\n', '1\n', '4\n', '3\n']","In example 1, one optimal way is to build 2 piles: the first pile contains boxes 1 and 3 (from top to bottom), the second pile contains only box 2.

In example 2, we can build only 1 pile that contains boxes 1, 2, 3, 4, 5 (from top to bottom).",WRONG_ANSWER,"from collections import a

def c():
    int(input())
    c = a(map(int, input().split()))
    b = 1
    for k in c:
        b = max(b, c[k])

    print(b)

c()","import d

def c():

    b = d.stdin.read().strip().split()

    for e in b:
        try:

            x = int(e)
        except ValueError:

            continue

        a = bin(x).count('1')

        d.stdout.write(str(a) + ""\n"")

if __name__ == '__main__':
    c()"
166,B,Polygons,PROGRAMMING,"['geometry', 'sortings']","You've got another geometrical task. You are given two non-degenerate polygons *A* and *B* as vertex coordinates. Polygon *A* is strictly convex. Polygon *B* is an arbitrary polygon without any self-intersections and self-touches. The vertices of both polygons are given in the clockwise order. For each polygon no three consecutively following vertices are located on the same straight line.

Your task is to check whether polygon *B* is positioned strictly inside polygon *A*. It means that any point of polygon *B* should be strictly inside polygon *A*. ""Strictly"" means that the vertex of polygon *B* cannot lie on the side of the polygon *A*.","The first line contains the only integer *n* (3<=≤<=*n*<=≤<=105) — the number of vertices of polygon *A*. Then *n* lines contain pairs of integers *x**i*,<=*y**i* (|*x**i*|,<=|*y**i*|<=≤<=109) — coordinates of the *i*-th vertex of polygon *A*. The vertices are given in the clockwise order.

The next line contains a single integer *m* (3<=≤<=*m*<=≤<=2·104) — the number of vertices of polygon *B*. Then following *m* lines contain pairs of integers *x**j*,<=*y**j* (|*x**j*|,<=|*y**j*|<=≤<=109) — the coordinates of the *j*-th vertex of polygon *B*. The vertices are given in the clockwise order.

The coordinates of the polygon's vertices are separated by a single space. It is guaranteed that polygons *A* and *B* are non-degenerate, that polygon *A* is strictly convex, that polygon *B* has no self-intersections and self-touches and also for each polygon no three consecutively following vertices are located on the same straight line.","Print on the only line the answer to the problem — if polygon *B* is strictly inside polygon *A*, print ""YES"", otherwise print ""NO"" (without the quotes).","['6\n-2 1\n0 3\n3 3\n4 1\n3 -2\n2 -2\n4\n0 1\n2 2\n3 1\n1 0\n', '5\n1 2\n4 2\n3 -3\n-2 -2\n-2 1\n4\n0 1\n1 2\n4 1\n2 -1\n', '5\n-1 2\n2 3\n4 1\n3 -2\n0 -3\n5\n1 0\n1 1\n3 1\n5 -1\n2 -1\n']","['YES\n', 'NO\n', 'NO\n']",none,WRONG_ANSWER,"import m

class b:
    def __init__(l, x, y):
        l.x = x
        l.y = y
 
def a(i):
     
    g = 0
    for i in range(1,len(i)):
        if i[i].x < i[g].x:
            g = i
        elif i[i].x == i[g].x:
            if i[i].y > i[g].y:
                g = i
    return g
 
def h(p, q, r):
    o = (q.y - p.y) * (r.x - q.x) -\
          (q.x - p.x) * (r.y - q.y)
 
    if o == 0:
        return 0
    elif o > 0:
        return 1
    else:
        return 2
 
def c(i, n):
     
    if n < 3:
        return
 
    l = a(i)
 
    e = []
     
    p = l
    q = 0
    while(True):

        e.append(p)
 
        q = (p + 1) % n
 
        for i in range(n):

            if(h(i[p],
                           i[i], i[q]) == 2):
                q = i
 
        p = q

        if(p == l):
            break
    f = set()
    for d in e:
        f.add((i[d].x, i[d].y))
    return f
    
j = []
k = set()

n = int(m.stdin.readline().strip())
for _ in range(n):
    n = m.stdin.readline().split()
    x = int(n[0])
    y = int(n[1])
    k.add((x,y))
    j.append(b(x,y))

m = int(m.stdin.readline().strip())
for _ in range(m):
    n = m.stdin.readline().split()
    x = int(n[0])
    y = int(n[1])
    j.append(b(x,y))

c = c(j, len(j))
if c == k:
    print(""YES"")
else:
    print(""NO"")","import i
input = i.stdin.readline

def b(g):

    if g == sorted(g):
        return True

    d = []
    for i in range(len(g)):
        if g[i] != i+1:
            d.append(i)

    if len(d) != 2:
        return False
    i, j = d

    g[i], g[j] = g[j], g[i]
    f = (g == sorted(g))

    g[i], g[j] = g[j], g[i]
    return f

def c():

    n, m = map(int, input().split())

    j = [list(map(int, input().split())) for _ in range(n)]

    h = [(-1, -1)]
    for i in range(m):
        for j in range(i+1, m):
            h.append((i, j))
    
    for a in h:

        k = True
        for g in j:

            e = g[:]
            if a != (-1, -1):
                i, j = a
                e[i], e[j] = e[j], e[i]

            if not b(e):
                k = False
                break
        if k:
            print(""YES"")
            return
    print(""NO"")

if __name__ == ""__main__"":
    c()"
373,A,Collecting Beats is Fun,PROGRAMMING,['implementation'],"Cucumber boy is fan of Kyubeat, a famous music game.

Kyubeat has 16 panels for playing arranged in 4<=×<=4 table. When a panel lights up, he has to press that panel.

Each panel has a timing to press (the preffered time when a player should press it), and Cucumber boy is able to press at most *k* panels in a time with his one hand. Cucumber boy is trying to press all panels in perfect timing, that is he wants to press each panel exactly in its preffered time. If he cannot press the panels with his two hands in perfect timing, his challenge to press all the panels in perfect timing will fail.

You are given one scene of Kyubeat's panel from the music Cucumber boy is trying. Tell him is he able to press all the panels in perfect timing.","The first line contains a single integer *k* (1<=≤<=*k*<=≤<=5) — the number of panels Cucumber boy can press with his one hand.

Next 4 lines contain 4 characters each (digits from 1 to 9, or period) — table of panels. If a digit *i* was written on the panel, it means the boy has to press that panel in time *i*. If period was written on the panel, he doesn't have to press that panel.","Output ""YES"" (without quotes), if he is able to press all the panels in perfect timing. If not, output ""NO"" (without quotes).","['1\n.135\n1247\n3468\n5789\n', '5\n..1.\n1111\n..1.\n..1.\n', '1\n....\n12.1\n.2..\n.2..\n']","['YES\n', 'YES\n', 'NO\n']","In the third sample boy cannot press all panels in perfect timing. He can press all the panels in timing in time 1, but he cannot press the panels in time 2 in timing with his two hands.",OK,"n = int(input())
a = n * 2

x = {}
o = ""YES""
for _ in range(4):
    r = input()

    for c in r:
        if c == ""."":
            continue

        x.setdefault(c, 0)
        x[c] += 1

        if x[c] > a:
            o = ""NO""
            break
print(o)","import k
import a

def h():

    g = k.stdin.read().strip().split()
    if not g:
        return

    n = int(g[0])
    m = int(g[1])

    b = list(map(int, g[2:2+n]))

    l = list(map(int, g[2+n:2+n+m]))

    i = 0

    for c in b:

        j = a.bisect_left(l, c)

        f = abs(l[j] - c) if j < m else float('inf')
        e = abs(l[j-1] - c) if j > 0 else float('inf')

        d = min(e, f)

        i = max(i, d)

    print(i)

if __name__ == '__main__':
    h()"
722,C,Destroying Array,PROGRAMMING,"['data structures', 'dsu']","You are given an array consisting of *n* non-negative integers *a*1,<=*a*2,<=...,<=*a**n*.

You are going to destroy integers in the array one by one. Thus, you are given the permutation of integers from 1 to *n* defining the order elements of the array are destroyed.

After each element is destroyed you have to find out the segment of the array, such that it contains no destroyed elements and the sum of its elements is maximum possible. The sum of elements in the empty segment is considered to be 0.","The first line of the input contains a single integer *n* (1<=≤<=*n*<=≤<=100<=000) — the length of the array.

The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (0<=≤<=*a**i*<=≤<=109). 

The third line contains a permutation of integers from 1 to *n* — the order used to destroy elements.","Print *n* lines. The *i*-th line should contain a single integer — the maximum possible sum of elements on the segment containing no destroyed elements, after first *i* operations are performed.","['4\n1 3 2 5\n3 4 1 2\n', '5\n1 2 3 4 5\n4 2 3 5 1\n', '8\n5 5 4 4 6 6 5 5\n5 2 8 7 1 3 4 6\n']","['5\n4\n3\n0\n', '6\n5\n5\n1\n0\n', '18\n16\n11\n8\n8\n6\n6\n0\n']","Consider the first sample: 
 1.  Third element is destroyed. Array is now 1 3  *  5. Segment with maximum sum 5 consists of one integer 5. 1.  Fourth element is destroyed. Array is now 1 3  *   * . Segment with maximum sum 4 consists of two integers 1 3. 1.  First element is destroyed. Array is now  *  3  *   * . Segment with maximum sum 3 consists of one integer 3. 1.  Last element is destroyed. At this moment there are no valid nonempty segments left in this array, so the answer is equal to 0.",TIME_LIMIT_EXCEEDED,"j = int(input())
e = list(map(int, input().split("" "")))
g = list(map(lambda x: int(x) - 1, input().split("" "")))

def a(c, l, r):
    if l == r:
        return {""s"": c[l], ""li"": l, ""ri"": r}
    c = int((l + r) / 2)
    d = a(c, l, c)
    i = a(c, c + 1, r)
    return {
        ""li"": l, ""ri"": r,
        ""s"": d[""s""] + i[""s""],
        ""l"": d,
        ""r"": i
    }

def l(m, l, r):
    if m[""li""] == l and m[""ri""] == r:
        return m[""s""]
    c = int ((m[""ri""] + m[""li""]) / 2)
    if l >= m[""li""] and r <= c:
        return l(m[""l""], l, r)
    elif l > c and r <= m[""ri""]:
        return l(m[""r""], l, r)
    else:
        return l(m[""l""], l, c) + l(m[""r""], c + 1, r)

def h(m, i, s):
    m[""s""] -= s
    if ""r"" in m and ""l"" in m:
        c = int((m[""ri""] + m[""li""]) / 2)
        if i <= c:
            h(m[""l""], i, s)
        else:
            h(m[""r""], i, s)

b = len(e) - 1
m = a(e, 0, b)
f = []
for i in g:
    h (m, i, e[i])
    f.append(i)
    f = sorted(f)
    n = 0
    k = -1
    for r in range(len(f)):
        o = f[r]
        k = max(k, l(m, n, o))
        n = o
    k = max(k, l(m, n, b))
    print(k)","import f

def b():

    a = f.stdin.read().split()
    if not a:
        return
    n = int(a[0])
    k = int(a[1])

    if k > (n - 1) // 2:
        print(-1)
        return

    d = []

    for i in range(1, n + 1):
        for j in range(1, k + 1):
            e = i + j

            if e > n:
                e -= n
            d.append((i, e))

    print(len(d))

    for c in d:
        print(c[0], c[1])
        
if __name__ == '__main__':
    b()"
808,G,Anthem of Berland,PROGRAMMING,"['dp', 'strings']","Berland has a long and glorious history. To increase awareness about it among younger citizens, King of Berland decided to compose an anthem.

Though there are lots and lots of victories in history of Berland, there is the one that stand out the most. King wants to mention it in the anthem as many times as possible.

He has already composed major part of the anthem and now just needs to fill in some letters. King asked you to help him with this work.

The anthem is the string *s* of no more than 105 small Latin letters and question marks. The most glorious victory is the string *t* of no more than 105 small Latin letters. You should replace all the question marks with small Latin letters in such a way that the number of occurrences of string *t* in string *s* is maximal.

Note that the occurrences of string *t* in *s* can overlap. Check the third example for clarification.","The first line contains string of small Latin letters and question marks *s* (1<=≤<=|*s*|<=≤<=105).

The second line contains string of small Latin letters *t* (1<=≤<=|*t*|<=≤<=105).

Product of lengths of strings |*s*|·|*t*| won't exceed 107.",Output the maximum number of occurrences of string *t* you can achieve by replacing all the question marks in string *s* with small Latin letters.,"['winlose???winl???w??\nwin\n', 'glo?yto?e??an?\nor\n', '??c?????\nabcab\n']","['5\n', '3\n', '2\n']","In the first example the resulting string *s* is ""winlosewinwinlwinwin""

In the second example the resulting string *s* is ""glorytoreorand"". The last letter of the string can be arbitrary.

In the third example occurrences of string *t* are overlapping. String *s* with maximal number of occurrences of *t* is ""abcabcab"".",WRONG_ANSWER,"def a(t, i):
    f = s[i:i + g]
    for j in range(g):
        if not f[j] in [t[j], '?']:
            return False
        f[j] = t[j]

    s[i:i + g] = f

    return True

def c(t, i):
    f = d[i:i + g]
    for j in range(g):
        if not f[j] in [t[j], '?']:
            return False
        f[j] = t[j]

    d[i:i + g] = f

    return True

s = list(input())
t = input()
d = s[:]
e = len(s)
g = len(t)

j = 0
b = 0
for i in range(e-g+1):
    if a(t, i):
        j += 1
    if c(t, i):
        b += 1

print(max(j, b))","def g():
    import k
    e = k.stdin.read().strip().split()
    if not e:
        return
    n = int(e[0])
    k = int(e[1])
    c = list(map(int, e[2:2+n]))

    h = [0] * (n + 1)
    for i in range(n):
        h[i + 1] = h[i] + c[i]
    
    a = 0

    for b in range(60, -1, -1):
        d = a | (1 << b)

        f = [[False] * (k + 1) for _ in range(n + 1)]
        f[0][0] = True

        for i in range(n):
            for i in range(k):
                if f[i][i]:

                    for j in range(i + 1, n + 1):
                        j = h[j] - h[i]

                        if j & d == d:
                            f[j][i + 1] = True

        if f[n][k]:
            a = d
    print(a)

if __name__ == '__main__':
    g()"
7,C,Line,PROGRAMMING,"['math', 'number theory']","A line on the plane is described by an equation *Ax*<=+<=*By*<=+<=*C*<==<=0. You are to find any point on this line, whose coordinates are integer numbers from <=-<=5·1018 to 5·1018 inclusive, or to find out that such points do not exist.","The first line contains three integers *A*, *B* and *C* (<=-<=2·109<=≤<=*A*,<=*B*,<=*C*<=≤<=2·109) — corresponding coefficients of the line equation. It is guaranteed that *A*2<=+<=*B*2<=&gt;<=0.","If the required point exists, output its coordinates, otherwise output -1.",['2 5 3\n'],['6 -3\n'],none,RUNTIME_ERROR,"def a():

    def e(b,n):
        c, d, f, g = 1, 0, 0, 1
        while n!=0:
            q, b, n = b//n, n, b%n
            c, d = d, c - q*d
            f, g = g, f - q*g
        return b, c, f

    A, B, C = map(int,input().split())
    g, x, y = e(A,B)
    if abs(-C)%g!=0:
        return -1
    d = -C//g
    return x*d, y*d

if __name__==""__main__"":
    print(' '.join(str(b) for b in a()))","def d():
    import g
    c = g.stdin.read().splitlines()
    n = int(c[0])

    a = {""polycarp"": 1}

    for i in range(1, n + 1):

        b = c[i].strip().split()

        f = b[0].lower()
        e = b[2].lower()

        a[f] = a[e] + 1

    print(max(a.values()))

if __name__ == ""__main__"":
    d()"
749,A,Bachgold Problem,PROGRAMMING,"['greedy', 'implementation', 'math', 'number theory']","Bachgold problem is very easy to formulate. Given a positive integer *n* represent it as a sum of maximum possible number of prime numbers. One can prove that such representation exists for any integer greater than 1.

Recall that integer *k* is called prime if it is greater than 1 and has exactly two positive integer divisors — 1 and *k*.",The only line of the input contains a single integer *n* (2<=≤<=*n*<=≤<=100<=000).,"The first line of the output contains a single integer *k* — maximum possible number of primes in representation.

The second line should contain *k* primes with their sum equal to *n*. You can print them in any order. If there are several optimal solution, print any of them.","['5\n', '6\n']","['2\n2 3\n', '3\n2 2 2\n']",none,OK,"def a():
    a = int(input())
    b = [2] * (a // 2)
    print(a // 2)
    if a % 2  != 0:
        b[-1] = 3
        

    print(*b)
        
a()","def g():
    import n

    e = n.stdin.read().strip().split()
    if not e:
        return

    n = int(e[0])
    x = int(e[1])

    a = [0] * (n + 1)

    for i in range(1, n + 1):
        a[i] = int(e[i + 1])

    h = [0] * (n + 1)

    k = [0] * (n + 1)
    for i in range(1, n + 1):
        if a[i] > 0:
            k[i] = a[i]
            h[a[i]] = i

    c = []
    p = [False] * (n + 1)

    for i in range(1, n + 1):
        if k[i] == 0 and not p[i]:
            b = []
            d = i
            while d != 0 and not p[d]:
                b.append(d)
                p[d] = True
                d = h[d]
            c.append(b)

    for i in range(1, n + 1):
        if not p[i]:
            c.append([i])
            p[i] = True

    l = None
    m = None
    for b in c:
        if x in b:
            l = b
            m = b.index(x)
            break
    if l is None:

        l = [x]
        m = 0
        c.append(l)

    i = []
    for b in c:
        if b is l:
            continue
        i.append(len(b))

    o = sum(i)
    f = [False] * (o + 1)
    f[0] = True
    for L in i:
        for s in range(o, L - 1, -1):
            if f[s - L]:
                f[s] = True

    a = m + 1
    j = set()
    for s in range(o + 1):
        if f[s]:
            j.add(a + s)
    j = sorted(j)

    n.stdout.write(""\n"".join(map(str, j)) + ""\n"")

if __name__ == '__main__':
    g()"
259,B,Little Elephant and Magic Square,PROGRAMMING,"['brute force', 'implementation']","Little Elephant loves magic squares very much.

A magic square is a 3<=×<=3 table, each cell contains some positive integer. At that the sums of integers in all rows, columns and diagonals of the table are equal. The figure below shows the magic square, the sum of integers in all its rows, columns and diagonals equals 15.

The Little Elephant remembered one magic square. He started writing this square on a piece of paper, but as he wrote, he forgot all three elements of the main diagonal of the magic square. Fortunately, the Little Elephant clearly remembered that all elements of the magic square did not exceed 105. 

Help the Little Elephant, restore the original magic square, given the Elephant's notes.","The first three lines of the input contain the Little Elephant's notes. The first line contains elements of the first row of the magic square. The second line contains the elements of the second row, the third line is for the third row. The main diagonal elements that have been forgotten by the Elephant are represented by zeroes.

It is guaranteed that the notes contain exactly three zeroes and they are all located on the main diagonal. It is guaranteed that all positive numbers in the table do not exceed 105.","Print three lines, in each line print three integers — the Little Elephant's magic square. If there are multiple magic squares, you are allowed to print any of them. Note that all numbers you print must be positive and not exceed 105.

It is guaranteed that there exists at least one magic square that meets the conditions.","['0 1 1\n1 0 1\n1 1 0\n', '0 3 6\n5 0 5\n4 7 0\n']","['1 1 1\n1 1 1\n1 1 1\n', '6 3 6\n5 5 5\n4 7 4\n']",none,OK,"import t
import math as m
def i():
    pass
def c(n):

    return (bin(n).replace(""0b"", """"))
def d(s):

    return (int(s, 2))
def n(n):

    p = 0
    while n > 1:
        n //= 2
        p += 1
    return (p)
def f(n):

    if (n == 1):
        return (False)
    else:
        p = int(n ** 0.5)
        p += 1
        for i in range(2, p):
            if (n % i == 0):
                return (False)
        return (True)
def h(l):

    s=''.join(map(str,l))
    return s
def s(s):

    l=list(s)

    return l

def r(a,u,b=[]):
    s=sum(b)
    if(s==u):
        return b
    if(s>=u):
        return
    for i in range(len(a)):
        n=a[i]
        o=a[i+1:]
        a=r(o,u,b+[n])
        if(a):
            return a

j=int(1e9)+7
def q(): return t.stdin.readline().strip()
def e(): return int(input())
def l(): return map(int, t.stdin.readline().strip().split())
def g(): return list(map(int, t.stdin.readline().strip().split()))
def p(w): print(w)
def m(a,b):print(a,b)

k=[]
for i in range(3):
    a=g()
    k.append(a)
v=(k[0][1]+k[0][2]+k[1][0]+k[1][2]+k[2][0]+k[2][1])//2
k[0][0]=v-(k[0][1]+k[0][2])
k[1][1]=v-(k[1][0]+k[1][2])
k[2][2]=v-(k[2][0]+k[2][1])
for i in k:
    print(*i)","def i():
    import m
    from collections import a

    f = m.stdin.read().split()
    if not f:
        return
    m = int(f[0])
    k = list(map(int, f[1:]))

    c = a(k)

    b = 10**9 + 7
    j = b - 1
    T = 2 * j

    d = 1
    e = 1
    for a in c.values():
        d = (d * (a + 1)) % T

        e = (e * ((a + 1) & 1)) & 1

    l = 1
    if e == 0:

        h = (d // 2) % j
        for p, a in c.items():

            g = (a * h) % j
            l = (l * pow(p, g, b)) % b
    else:

        h = ((d - 1) // 2) % j
        for p, a in c.items():

            g = (a * h + (a // 2)) % j
            l = (l * pow(p, g, b)) % b

    m.stdout.write(str(l))

if __name__ == '__main__':
    i()"
717,E,"Paint it really, really dark gray",PROGRAMMING,['dfs and similar'],"I see a pink boar and I want it painted black. Black boars look much more awesome and mighty than the pink ones. Since Jaggy became the ruler of the forest, he has been trying his best to improve the diplomatic relations between the forest region and the nearby ones. 

Some other rulers, however, have requested too much in return for peace between their two regions, so he realized he has to resort to intimidation. Once a delegate for diplomatic relations of a neighboring region visits Jaggy’s forest, if they see a whole bunch of black boars, they might suddenly change their mind about attacking Jaggy. Black boars are really scary, after all. 

Jaggy’s forest can be represented as a tree (connected graph without cycles) with *n* vertices. Each vertex represents a boar and is colored either black or pink. Jaggy has sent a squirrel to travel through the forest and paint all the boars black. The squirrel, however, is quite unusually trained and while it traverses the graph, it changes the color of every vertex it visits, regardless of its initial color: pink vertices become black and black vertices become pink. 

Since Jaggy is too busy to plan the squirrel’s route, he needs your help. He wants you to construct a walk through the tree starting from vertex 1 such that in the end all vertices are black. A walk is a sequence of vertices, such that every consecutive pair has an edge between them in a tree.","The first line of input contains integer *n* (2<=≤<=*n*<=≤<=200<=000), denoting the number of vertices in the tree. The following *n* lines contains *n* integers, which represent the color of the nodes.

If the *i*-th integer is 1, if the *i*-th vertex is black and <=-<=1 if the *i*-th vertex is pink.

Each of the next *n*<=-<=1 lines contains two integers, which represent the indexes of the vertices which are connected by the edge. Vertices are numbered starting with 1.","Output path of a squirrel: output a sequence of visited nodes' indexes in order of visiting. In case of all the nodes are initially black, you should print 1. Solution is guaranteed to exist. If there are multiple solutions to the problem you can output any of them provided length of sequence is not longer than 107.",['5\n1\n1\n-1\n1\n-1\n2 5\n4 3\n2 4\n4 1\n'],['1 4 2 5 2 4 3 4 1 4 1\n'],"At the beginning squirrel is at node 1 and its color is black. Next steps are as follows: 
 -  From node 1 we walk to node 4 and change its color to pink. -  From node 4 we walk to node 2 and change its color to pink. -  From node 2 we walk to node 5 and change its color to black. -  From node 5 we return to node 2 and change its color to black. -  From node 2 we walk to node 4 and change its color to black. -  We visit node 3 and change its color to black. -  We visit node 4 and change its color to pink. -  We visit node 1 and change its color to pink. -  We visit node 4 and change its color to black. -  We visit node 1 and change its color to black.",RUNTIME_ERROR,"from collections import defaultdict
import g

input = g.stdin.readline

a = {}
e = []

def d(x, p):
	if x != 0:
		f[x] *= -1
	e.append(x)
	for b in a[x]:

		if b != p:

			if d(b, x) == True:
				return True
			e.append(x)
			f[x] *= -1

	if f[x] == -1:
		f[x] = 1
		print(e)
		e.extend([p, x])
		f[p] *= -1
	if f.count(1) == n:
		return True
	else:
		return False

n = int(input())
f = [int(i) for i in input().strip(' ').split()]

for _ in range(1, n):
	a, b = map(int, input().strip(' ').split())
	a -= 1
	b -= 1
	if a not in a:
		a[a] = []
	if b not in a:
		a[b] = []
	a[a].append(b)
	a[b].append(a)

if f.count(1) != n:
	d(0, -2)
	for c in e:
		print(c + 1, end="" "", flush=True)
else:
	print(1)","def f(k, i):

    m = len(i)
    g = [0] * m
    j = 0
    i = 1
    while i < m:
        if i[i] == i[j]:
            j += 1
            g[i] = j
            i += 1
        else:
            if j != 0:
                j = g[j - 1]
            else:
                g[i] = 0
                i += 1

    a = 0
    i = 0
    j = 0
    n = len(k)
    while i < n:
        if k[i] == i[j]:
            i += 1
            j += 1
            if j == m:
                a += 1
                j = g[j - 1]
        else:
            if j != 0:
                j = g[j - 1]
            else:
                i += 1
    return a

def h():
    import j

    b = j.stdin.read().strip().split()
    if not b:
        return

    e = iter(b)
    n = int(next(e))
    w = int(next(e))

    a = [int(next(e)) for _ in range(n)]

    b = [int(next(e)) for _ in range(w)]

    if w == 1:
        print(n)
        return

    c = [a[i + 1] - a[i] for i in range(n - 1)]
    d = [b[i + 1] - b[i] for i in range(w - 1)]

    a = f(c, d)
    print(a)

if __name__ == '__main__':
    h()"
119,A,Epic Game,PROGRAMMING,['implementation'],"Simon and Antisimon play a game. Initially each player receives one fixed positive integer that doesn't change throughout the game. Simon receives number *a* and Antisimon receives number *b*. They also have a heap of *n* stones. The players take turns to make a move and Simon starts. During a move a player should take from the heap the number of stones equal to the greatest common divisor of the fixed number he has received and the number of stones left in the heap. A player loses when he cannot take the required number of stones (i. e. the heap has strictly less stones left than one needs to take). 

Your task is to determine by the given *a*, *b* and *n* who wins the game.","The only string contains space-separated integers *a*, *b* and *n* (1<=≤<=*a*,<=*b*,<=*n*<=≤<=100) — the fixed numbers Simon and Antisimon have received correspondingly and the initial number of stones in the pile.","If Simon wins, print ""0"" (without the quotes), otherwise print ""1"" (without the quotes).","['3 5 9\n', '1 1 100\n']","['0', '1']","The greatest common divisor of two non-negative integers *a* and *b* is such maximum positive integer *k*, that *a* is divisible by *k* without remainder and similarly, *b* is divisible by *k* without remainder. Let *gcd*(*a*, *b*) represent the operation of calculating the greatest common divisor of numbers *a* and *b*. Specifically, *gcd*(*x*, 0) = *gcd*(0, *x*) = *x*.

In the first sample the game will go like that:
-  Simon should take *gcd*(3, 9) = 3 stones from the heap. After his move the heap has 6 stones left.-  Antisimon should take *gcd*(5, 6) = 1 stone from the heap. After his move the heap has 5 stones left.-  Simon should take *gcd*(3, 5) = 1 stone from the heap. After his move the heap has 4 stones left.-  Antisimon should take *gcd*(5, 4) = 1 stone from the heap. After his move the heap has 3 stones left.-  Simon should take *gcd*(3, 3) = 3 stones from the heap. After his move the heap has 0 stones left.-  Antisimon should take *gcd*(5, 0) = 5 stones from the heap. As 0 &lt; 5, it is impossible and Antisimon loses.
In the second sample each player during each move takes one stone from the heap. As *n* is even, Antisimon takes the last stone and Simon can't make a move after that.",RUNTIME_ERROR,"s=[int(x) for x in input().split()]
m=n
a=s[0]
b=s[1]
n=s[2]
def f(x,y):
    while x!=y:
        x=min(x,y)
        y=max(x,y)
        t=y%x
        y=x
        x=t
    return x
for i in range(n):
    a=f(a,m)
    b=f(b,m)
    if a>m:
        print(0)
        break
    elif b>m:
        print(1)
        break
    else:
        m=m-a-b","import f

def d():

    a = f.stdin.read().split()
    if not a:
        return
    n = int(a[0])
    k = int(a[1])

    e = []
    c, b = 1, k + 1
    for i in range(k + 1):
        if i % 2 == 0:
            e.append(c)
            c += 1
        else:
            e.append(b)
            b -= 1

    for x in range(k + 2, n + 1):
        e.append(x)

    print("" "".join(map(str, e)))

if __name__ == ""__main__"":
    d()"
369,B,Valera and Contest,PROGRAMMING,"['constructive algorithms', 'implementation', 'math']","Valera loves to participate in competitions. Especially in programming contests. Today he has participated in the contest with his team, consisting of *n* students (including Valera). This contest was an individual competition, so each student in the team solved problems individually.

After the contest was over, Valera was interested in results. He found out that:
 -  each student in the team scored at least *l* points and at most *r* points; -  in total, all members of the team scored exactly *s**all* points; -  the total score of the *k* members of the team who scored the most points is equal to exactly *s**k*; more formally, if *a*1,<=*a*2,<=...,<=*a**n* is the sequence of points earned by the team of students in the non-increasing order (*a*1<=≥<=*a*2<=≥<=...<=≥<=*a**n*), then *s**k*<==<=*a*1<=+<=*a*2<=+<=...<=+<=*a**k*. 
However, Valera did not find out exactly how many points each of *n* students scored. Valera asked you to recover any distribution of scores between the students of the team, such that all the conditions above are met.","The first line of the input contains exactly six integers *n*,<=*k*,<=*l*,<=*r*,<=*s**all*,<=*s**k* (1<=≤<=*n*,<=*k*,<=*l*,<=*r*<=≤<=1000; *l*<=≤<=*r*; *k*<=≤<=*n*; 1<=≤<=*s**k*<=≤<=*s**all*<=≤<=106).

It's guaranteed that the input is such that the answer exists.","Print exactly *n* integers *a*1,<=*a*2,<=...,<=*a**n* — the number of points each student scored. If there are multiple solutions, you can print any of them. You can print the distribution of points in any order.","['5 3 1 3 13 9\n', '5 3 1 3 15 9\n']","['2 3 2 3 3 ', '3 3 3 3 3 ']",none,RUNTIME_ERROR,"def f(b, k):
    q, m = divmod(b, k)
    for i in range(m):
        print(q + 1)
    for i in range(k - m):
        print(q)
n, k, l, r, a, b = map(int, input().split())
f(b, k)
f(a - b, n - k)","""""""
This script responds to multiple queries on a 2-row maze.
Each query asks for the shortest path (in time units)
from one free cell to another in the maze.
The maze has 2 rows and n columns.
Cells are marked '.' if free and 'X' if there is an obstacle.

We precompute a 2x2 DP matrix for transitions between adjacent columns.
Then we build a segment tree over these matrices so that each query,
which translates into a range query on columns, can be answered efficiently.
""""""

import 

a = 10**9

def q():
    l = .stdin.read().splitlines()
    if not l:
        return

    w = l[0].split()
    n = int(w[0])
    m = int(w[1])

    s = l[1].strip()
    r = l[2].strip()

    o = [s[i] == '.' for i in range(n)]
    n = [r[i] == '.' for i in range(n)]

     = [1 if (o[i] and n[i]) else a for i in range(n)]

    c = []
    for i in range(n - 1):

        m = [[a, a], [a, a]]
        for r in (0, 1):

            if r == 0:
                if not o[i]:
                    continue
            else:
                if not n[i]:
                    continue
            for s in (0, 1):

                if s == 0:
                    if not o[i+1]:
                        continue
                else:
                    if not n[i+1]:
                        continue

                j = a

                if r == 0:
                    if o[i+1]:
                        if s == r:
                            j = 1
                        else:

                            if [i+1] < a:
                                j = 1 + 1
                else:
                    if n[i+1]:
                        if s == r:
                            j = 1
                        else:
                            if [i+1] < a:
                                j = 1 + 1

                k = a
                u = 1 - r

                if (o[i] and n[i]) and (
                    (u == 0 and o[i+1]) or (u == 1 and n[i+1])
                ):
                    if s == u:
                        k = 1 + 1
                    else:

                        if [i+1] < a:
                            k = 1 + 1 + 1
                m[r][s] = min(j, k)
        c.append(m)

    def i(A, B):
        { = [[a, a], [a, a]]
        for i in (0, 1):
            for j in (0, 1):
                d = A[i][0] + B[0][j]
                e = A[i][1] + B[1][j]
                {[i][j] = d if d < e else e
        return {

     = 1
    b = len(c)
    while  < b:
         *= 2

    t = [[0, a], [a, 0]]
     = [None] * (2 * )
    for i in range():
        if i < b:
            [ + i] = c[i]
        else:
            [ + i] = t
    for i in range( - 1, 0, -1):
        [i] = i([2 * i], [2 * i + 1])

    def y(l, r):

        | = t
        } = t
        l += 
        r += 
        while l < r:
            if l & 1:
                | = i(|, [l])
                l += 1
            if r & 1:
                r -= 1
                } = i([r], })
            l //= 2
            r //= 2
        return i(|, })

    def f(x):
        if x <= n:
            return (x - 1, 0)
        else:
            return (x - n - 1, 1)

    v = []
    for x in range(m):
        w = l[3 + x].split()
        a = int(w[0])
        b = int(w[1])
        g, ~ = f(a)
        h,  = f(b)
        if g == h:
            if ~ == :
                v.append(""0"")
            else:
                v.append(""1"" if [g] < a else ""-1"")
            continue

        if g < h:
            p = g
            z = h
            m = y(p, z)
            { = m[~][]
        else:

            p = h
            z = g
            m = y(p, z)
            { = m[][~]
        v.append(str({) if { < a else ""-1"")
    
    .stdout.write(""\n"".join(v))

if __name__ == ""__main__"":
    q()"
21,B,Intersection,PROGRAMMING,"['implementation', 'math']","You are given two set of points. The first set is determined by the equation *A*1*x*<=+<=*B*1*y*<=+<=*C*1<==<=0, and the second one is determined by the equation *A*2*x*<=+<=*B*2*y*<=+<=*C*2<==<=0.

Write the program which finds the number of points in the intersection of two given sets.","The first line of the input contains three integer numbers *A*1,<=*B*1,<=*C*1 separated by space. The second line contains three integer numbers *A*2,<=*B*2,<=*C*2 separated by space. All the numbers are between -100 and 100, inclusive.",Print the number of points in the intersection or -1 if there are infinite number of points.,"['1 1 0\n2 2 0\n', '1 1 0\n2 -2 0\n']","['-1\n', '1\n']",none,RUNTIME_ERROR,"def c(a, b, c):
    if b != 0:
        return -a / b, -c / b
    else:
        return 101, -c / a

d, a = c(*map(int, input().split()))
e, b = c(*map(int, input().split()))

if d == e:
    if a == b:
        print(-1)
    else:
        print(0)
else:
    print(1)","import h

def f():
    b = h.stdin.read().splitlines()
    n = int(b[0].strip())

    c = []
    for i in range(1, n + 1):
        d, g = b[i].split()
        l, r = int(d), int(g)
        c.append((l, r))

    c.sort(key=lambda x: x[1])

    a = 0
    e = -1
    for l, r in c:

        if l > e:
            a += 1
            e = r

    h.stdout.write(str(a) + ""\n"")

if __name__ == '__main__':
    f()"
698,A,Vacations,PROGRAMMING,['dp'],"Vasya has *n* days of vacations! So he decided to improve his IT skills and do sport. Vasya knows the following information about each of this *n* days: whether that gym opened and whether a contest was carried out in the Internet on that day. For the *i*-th day there are four options:
 1.  on this day the gym is closed and the contest is not carried out; 1.  on this day the gym is closed and the contest is carried out; 1.  on this day the gym is open and the contest is not carried out; 1.  on this day the gym is open and the contest is carried out. 
On each of days Vasya can either have a rest or write the contest (if it is carried out on this day), or do sport (if the gym is open on this day).

Find the minimum number of days on which Vasya will have a rest (it means, he will not do sport and write the contest at the same time). The only limitation that Vasya has — he does not want to do the same activity on two consecutive days: it means, he will not do sport on two consecutive days, and write the contest on two consecutive days.","The first line contains a positive integer *n* (1<=≤<=*n*<=≤<=100) — the number of days of Vasya's vacations.

The second line contains the sequence of integers *a*1,<=*a*2,<=...,<=*a**n* (0<=≤<=*a**i*<=≤<=3) separated by space, where: 
 -  *a**i* equals 0, if on the *i*-th day of vacations the gym is closed and the contest is not carried out; -  *a**i* equals 1, if on the *i*-th day of vacations the gym is closed, but the contest is carried out; -  *a**i* equals 2, if on the *i*-th day of vacations the gym is open and the contest is not carried out; -  *a**i* equals 3, if on the *i*-th day of vacations the gym is open and the contest is carried out.","Print the minimum possible number of days on which Vasya will have a rest. Remember that Vasya refuses:
 -  to do sport on any two consecutive days, -  to write the contest on any two consecutive days.","['4\n1 3 2 0\n', '7\n1 3 3 2 1 2 3\n', '2\n2 2\n']","['2\n', '0\n', '1\n']","In the first test Vasya can write the contest on the day number 1 and do sport on the day number 3. Thus, he will have a rest for only 2 days.

In the second test Vasya should write contests on days number 1, 3, 5 and 7, in other days do sport. Thus, he will not have a rest for a single day.

In the third test Vasya can do sport either on a day number 1 or number 2. He can not do sport in two days, because it will be contrary to the his limitation. Thus, he will have a rest for only one day.",MEMORY_LIMIT_EXCEEDED,"import m
import t
from io import b, d
import collections
t.setrecursionlimit(10**9)

a = 8192

class c(d):
    l = 0

    def __init__(r, f):
        r._fd = f.fileno()
        r.buffer = b()
        r.writable = ""x"" in f.mode or ""r"" not in f.mode
        r.write = r.buffer.write if r.writable else None

    def o(r):
        while True:
            b = m.o(r._fd, max(m.fstat(r._fd).st_size, a))
            if not b:
                break
            n = r.buffer.tell()
            r.buffer.seek(0, 2), r.buffer.write(b), r.buffer.seek(n)
        r.l = 0
        return r.buffer.o()

    def p(r):
        while r.l == 0:
            b = m.o(r._fd, max(m.fstat(r._fd).st_size, a))
            r.l = b.count(b""\n"") + (not b)
            n = r.buffer.tell()
            r.buffer.seek(0, 2), r.buffer.write(b), r.buffer.seek(n)
        r.l -= 1
        return r.buffer.p()

    def g(r):
        if r.writable:
            m.write(r._fd, r.buffer.getvalue())
            r.buffer.truncate(0), r.buffer.seek(0)

class IOWrapper(d):
    def __init__(r, f):
        r.buffer = c(f)
        r.g = r.buffer.g
        r.writable = r.buffer.writable
        r.write = lambda s: r.buffer.write(s.encode(""ascii""))
        r.o = lambda: r.buffer.o().decode(""ascii"")
        r.p = lambda: r.buffer.p().decode(""ascii"")

input = lambda: t.stdin.p().rstrip(""\r\n"")

def h(j,k,e):
    if j==0:
        if k==e[j]:
            return 1
        elif e[j]==0:
            return 1
        return 0
    q = i = s = 10e9
    if e[j]==0 and k!=0:
        q = 1 + h(j-1,0,e)
    if e[j]==1 and k!=1:
        s = h(j-1,1,e)
    if e[j]==2 and k!=2:
        i = h(j-1,2,e)
    if e[j]==3:
        if k not in [0,1,2]:
            s = h(j-1,1,e)
            i = h(j-1,2,e)

        elif k==0:
            s = h(j-1,1,e)
            i = h(j-1,2,e)
        elif k==1:
            i = h(j-1,2,e)
            q = 1 + h(j-1,0,e)
        else:
            s = h(j-1,1,e)
            q = 1 + h(j-1,0,e)
    return min(q,i,s)

n= int(input())
e = [int(x) for x in input().split()]
print(h(len(e)-1,-1,e))","def e():
    import h
    b = h.stdin.read().split()
    if not b:
        return
    n = int(b[0])

    c = list(map(int, b[1:]))

    a = -10**9
    d = [[a, a, a] for _ in range(n)]

    d[0][0] = 0

    if c[0] == 1 or c[0] == 3:
        d[0][1] = 1

    if c[0] == 2 or c[0] == 3:
        d[0][2] = 1

    for i in range(1, n):

        d[i][0] = max(d[i-1])

        if c[i] == 1 or c[i] == 3:
            d[i][1] = max(d[i-1][0], d[i-1][2]) + 1

        if c[i] == 2 or c[i] == 3:
            d[i][2] = max(d[i-1][0], d[i-1][1]) + 1

    f = max(d[n-1])
    g = n - f
    print(g)

if __name__ == ""__main__"":
    e()"
681,C,Heap Operations,PROGRAMMING,"['constructive algorithms', 'data structures', 'greedy']","Petya has recently learned data structure named ""Binary heap"".

The heap he is now operating with allows the following operations: 
 -  put the given number into the heap; -  get the value of the minimum element in the heap; -  extract the minimum element from the heap; 
Thus, at any moment of time the heap contains several integers (possibly none), some of them might be equal.

In order to better learn this data structure Petya took an empty heap and applied some operations above to it. Also, he carefully wrote down all the operations and their results to his event log, following the format: 
 -  insert *x* — put the element with value *x* in the heap; -  getMin *x* — the value of the minimum element contained in the heap was equal to *x*; -  removeMin — the minimum element was extracted from the heap (only one instance, if there were many). 
All the operations were correct, i.e. there was at least one element in the heap each time getMin or removeMin operations were applied.

While Petya was away for a lunch, his little brother Vova came to the room, took away some of the pages from Petya's log and used them to make paper boats.

Now Vova is worried, if he made Petya's sequence of operations inconsistent. For example, if one apply operations one-by-one in the order they are written in the event log, results of getMin operations might differ from the results recorded by Petya, and some of getMin or removeMin operations may be incorrect, as the heap is empty at the moment they are applied.

Now Vova wants to add some new operation records to the event log in order to make the resulting sequence of operations correct. That is, the result of each getMin operation is equal to the result in the record, and the heap is non-empty when getMin ad removeMin are applied. Vova wants to complete this as fast as possible, as the Petya may get back at any moment. He asks you to add the least possible number of operation records to the current log. Note that arbitrary number of operations may be added at the beginning, between any two other operations, or at the end of the log.","The first line of the input contains the only integer *n* (1<=≤<=*n*<=≤<=100<=000) — the number of the records left in Petya's journal.

Each of the following *n* lines describe the records in the current log in the order they are applied. Format described in the statement is used. All numbers in the input are integers not exceeding 109 by their absolute value.","The first line of the output should contain a single integer *m* — the minimum possible number of records in the modified sequence of operations.

Next *m* lines should contain the corrected sequence of records following the format of the input (described in the statement), one per line and in the order they are applied. All the numbers in the output should be integers not exceeding 109 by their absolute value.

Note that the input sequence of operations must be the subsequence of the output sequence.

It's guaranteed that there exists the correct answer consisting of no more than 1<=000<=000 operations.","['2\ninsert 3\ngetMin 4\n', '4\ninsert 1\ninsert 1\nremoveMin\ngetMin 2\n']","['4\ninsert 3\nremoveMin\ninsert 4\ngetMin 4\n', '6\ninsert 1\ninsert 1\nremoveMin\nremoveMin\ninsert 2\ngetMin 2\n']","In the first sample, after number 3 is inserted into the heap, the minimum number is 3. To make the result of the first getMin equal to 4 one should firstly remove number 3 from the heap and then add number 4 into the heap.

In the second sample case number 1 is inserted two times, so should be similarly removed twice.",RUNTIME_ERROR,"import b
from pprint import pprint

def d(a, c, f):
    while a[0] != c:
        f.append(f[-1])
        f[-2] = ""removeMin""
        b.heappop(a)
    return

if __name__ == '__main__':
    a = []
    n = int(input())
    f = []
    for i in range(n):
        e = input()
        f.append(e)
        if ""insert"" in e:
            c = int(e.strip(""insert ""))
            b.heappush(a, c)
        elif ""get"" in e:
            c = int(e.strip(""getMin ""))
            if a[0] != c:
                if c in a:
                    d(a, c, f)
                else:

                    f.append(f[-1])
                    f[-2] = f""insert {c}""

                    b.heappush(a, c)
                    d(a, c, f=f)
        else:
            b.heappop(a)

    print(len(f), sep='\n')
    for q in f:
        print(q)","def c():
    import f

    b = f.stdin.read().split()
    if not b:
        return

    n = int(b[0])

    if n < 3:
        print(0)
        return

    a = list(map(int, b[1:1+n]))

    g = sum(a)

    if g % 3 != 0:
        print(0)
        return

    d = g // 3
    h = 0
    a = 0
    e = 0

    for i in range(n - 1):
        e += a[i]

        if e == 2 * d:
            h += a

        if e == d:
            a += 1

    print(h)

if __name__ == ""__main__"":
    c()"
460,A,Vasya and Socks,PROGRAMMING,"['brute force', 'implementation', 'math']","Vasya has *n* pairs of socks. In the morning of each day Vasya has to put on a pair of socks before he goes to school. When he comes home in the evening, Vasya takes off the used socks and throws them away. Every *m*-th day (at days with numbers *m*,<=2*m*,<=3*m*,<=...) mom buys a pair of socks to Vasya. She does it late in the evening, so that Vasya cannot put on a new pair of socks before the next day. How many consecutive days pass until Vasya runs out of socks?","The single line contains two integers *n* and *m* (1<=≤<=*n*<=≤<=100; 2<=≤<=*m*<=≤<=100), separated by a space.",Print a single integer — the answer to the problem.,"['2 2\n', '9 3\n']","['3\n', '13\n']","In the first sample Vasya spends the first two days wearing the socks that he had initially. Then on day three he puts on the socks that were bought on day two.

In the second sample Vasya spends the first nine days wearing the socks that he had initially. Then he spends three days wearing the socks that were bought on the third, sixth and ninth days. Than he spends another day wearing the socks that were bought on the twelfth day.",RUNTIME_ERROR,"import d

def e():
    c = [int(x) for x in input().split()]
    b = c[0]
    n = c[0]
    p = c[1]
    while (n):
        b += n / p
        n = n / p
    print(d.floor(b))

if a == '_main_':
    e()","def e():
    import i

    a = i.stdin.read().split()

    n = int(a[0])
    d = int(a[1])

    h = list(map(int, a[2:2+n]))

    k = sum(h)

    g = (n - 1) * 10

    f = k + g

    if f > d:
        print(-1)
        return

    d = (n - 1) * 2

    c = d - f

    b = c // 5

    j = d + b
    
    print(j)

if __name__ == ""__main__"":
    e()"
620,B,Grandfather Dovlet’s calculator,PROGRAMMING,['implementation'],"Once Max found an electronic calculator from his grandfather Dovlet's chest. He noticed that the numbers were written with seven-segment indicators ([https://en.wikipedia.org/wiki/Seven-segment_display](https://en.wikipedia.org/wiki/Seven-segment_display)).

Max starts to type all the values from *a* to *b*. After typing each number Max resets the calculator. Find the total number of segments printed on the calculator.

For example if *a*<==<=1 and *b*<==<=3 then at first the calculator will print 2 segments, then — 5 segments and at last it will print 5 segments. So the total number of printed segments is 12.","The only line contains two integers *a*,<=*b* (1<=≤<=*a*<=≤<=*b*<=≤<=106) — the first and the last number typed by Max.",Print the only integer *a* — the total number of printed segments.,"['1 3\n', '10 15\n']","['12\n', '39\n']",none,TIME_LIMIT_EXCEEDED,"def c(n):
	d = 0
	for i in n:
		d += b[i]
	return d

b = {'0':6, '1':2, '2':5, '3':5, '4':4, '5':5, '6':6, '7':3, '8':7, '9':6}
if __name__ == '__main__':
	a, b = list(map(int, input().split()))
	a = 0
	i = a
	while i <= b:
		a += c(str(i))
		i += 1
	print (a)","def g():
    import j
    f = j.stdin.read().split()
    
    if not f:
        return

    n = int(f[0])

    if len(f) != 1 + 2 * n:
        j.exit(""Invalid input"")

    b = list(map(int, f[1:]))

    e = {}
    for c, a in enumerate(b, 1):
        if a in e:
            e[a].append(c)
        else:
            e[a] = [c]

    for k, d in e.items():
        if len(d) % 2 != 0:
            print(-1)
            return

    h = []
    for k, d in e.items():

        for i in range(0, len(d), 2):
            i = [str(d[i]), str(d[i+1])]
            h.append("" "".join(i))

    j.stdout.write(""\n"".join(h))

if __name__ == ""__main__"":
    g()"
932,E,Team Work,PROGRAMMING,"['combinatorics', 'dp', 'math']","You have a team of *N* people. For a particular task, you can pick any non-empty subset of people. The cost of having *x* people for the task is *x**k*. 

Output the sum of costs over all non-empty subsets of people.",Only line of input contains two integers *N* (1<=≤<=*N*<=≤<=109) representing total number of people and *k* (1<=≤<=*k*<=≤<=5000).,Output the sum of costs for all non empty subsets modulo 109<=+<=7.,"['1 1\n', '3 2\n']","['1\n', '24\n']","In the first example, there is only one non-empty subset {1} with cost 1<sup class=""upper-index"">1</sup> = 1.

In the second example, there are seven non-empty subsets.

- {1} with cost 1<sup class=""upper-index"">2</sup> = 1

- {2} with cost 1<sup class=""upper-index"">2</sup> = 1

- {1, 2} with cost 2<sup class=""upper-index"">2</sup> = 4

- {3} with cost 1<sup class=""upper-index"">2</sup> = 1

- {1, 3} with cost 2<sup class=""upper-index"">2</sup> = 4

- {2, 3} with cost 2<sup class=""upper-index"">2</sup> = 4

- {1, 2, 3} with cost 3<sup class=""upper-index"">2</sup> = 9

The total cost is 1 + 1 + 4 + 1 + 4 + 4 + 9 = 24.",RUNTIME_ERROR,"def c(n, k):
    if(k > n - k):
        k = n - k
    a = 1
    for i in range(k):
        a *= n - i
        a /= i + 1
    return a

n, k = map(int, input().split())
a=0
for i in range(n+1):
    a+=(c(n, i)*(i**k)%(10**9+7))
    a%=(10**9+7)
print(int(a)%(10**9+7))","import j

c = j.stdin.read().split()
if not c:
    j.exit(0)
n = int(c[0])
m = int(c[1])

d = [set() for _ in range(n+1)]
f = 2
for _ in range(m):
    u = int(c[f]); v = int(c[f+1])
    f += 2

    d[u].add(v)
    d[v].add(u)

i = None

for c in range(1, n+1):

    A = []
    B = []
    for v in range(1, n+1):
        if v == c:
            continue
        if v in d[c]:
            B.append(v)
        else:
            A.append(v)

    if not A:
        continue

    e = None
    for b in A:
        g = True
        for b in B:

            if b in d[b]:
                g = False
                break
        if g:
            e = b
            break
    if e is None:
        continue

    a = []

    for v in A:

        u, w = (c, v) if c < v else (v, c)
        a.append((u, w))

    for b in B:
        u, w = (e, b) if e < b else (b, e)
        a.append((u, w))
    i = a
    break

h = []
h.append(str(len(i)))
for u, v in i:
    h.append(f""{u} {v}"")
j.stdout.write(""\n"".join(h))"
688,B,Lovely Palindromes,PROGRAMMING,"['constructive algorithms', 'math']","Pari has a friend who loves palindrome numbers. A palindrome number is a number that reads the same forward or backward. For example 12321, 100001 and 1 are palindrome numbers, while 112 and 1021 are not.

Pari is trying to love them too, but only very special and gifted people can understand the beauty behind palindrome numbers. Pari loves integers with even length (i.e. the numbers with even number of digits), so she tries to see a lot of big palindrome numbers with even length (like a 2-digit 11 or 6-digit 122221), so maybe she could see something in them.

Now Pari asks you to write a program that gets a huge integer *n* from the input and tells what is the *n*-th even-length positive palindrome number?",The only line of the input contains a single integer *n* (1<=≤<=*n*<=≤<=10100<=000).,Print the *n*-th even-length palindrome number.,"['1\n', '10\n']","['11\n', '1001\n']","The first 10 even-length palindrome numbers are 11, 22, 33, ... , 88, 99 and 1001.",TIME_LIMIT_EXCEEDED,"n = input()
m=len(n)

x = n

for i in range(m):
	x = x+n[m-1-i]
print(x)","import l
import g

def i():

    c = l.stdin.read().strip().split()
    if not c:
        return
    n = int(c[0])
    m = int(c[1])

    e = [[] for _ in range(n + 1)]
    h = 2
    for _ in range(m):
        u = int(c[h])
        v = int(c[h + 1])
        w = int(c[h + 2])
        h += 3
        e[u].append((w, v))
        e[v].append((w, u))

    a = float('inf')
    d = [a] * (n + 1)
    j = [-1] * (n + 1)
    d[1] = 0

    f = [(0, 1)]
    while f:
        d, u = g.heappop(f)
        if d != d[u]:
            continue
        if u == n:
            break
        for m, v in e[u]:
            if d[u] + m < d[v]:
                d[v] = d[u] + m
                j[v] = u
                g.heappush(f, (d[v], v))

    if d[n] == a:
        l.stdout.write(""-1"")
        return

    k = []
    b = n
    while b != -1:
        k.append(b)
        b = j[b]
    k.reverse()

    l.stdout.write("" "".join(map(str, k)) + "" "")

if __name__ == ""__main__"":
    i()"
981,A,Antipalindrome,PROGRAMMING,"['brute force', 'implementation', 'strings']","A string is a palindrome if it reads the same from the left to the right and from the right to the left. For example, the strings ""kek"", ""abacaba"", ""r"" and ""papicipap"" are palindromes, while the strings ""abb"" and ""iq"" are not.

A substring $s[l \ldots r]$ ($1<=\leq<=l<=\leq<=r<=\leq<=|s|$) of a string $s<==<=s_{1}s_{2} \ldots s_{|s|}$ is the string $s_{l}s_{l<=+<=1} \ldots s_{r}$.

Anna does not like palindromes, so she makes her friends call her Ann. She also changes all the words she reads in a similar way. Namely, each word $s$ is changed into its longest substring that is not a palindrome. If all the substrings of $s$ are palindromes, she skips the word at all.

Some time ago Ann read the word $s$. What is the word she changed it into?","The first line contains a non-empty string $s$ with length at most $50$ characters, containing lowercase English letters only.","If there is such a substring in $s$ that is not a palindrome, print the maximum length of such a substring. Otherwise print $0$.

Note that there can be multiple longest substrings that are not palindromes, but their length is unique.","['mew\n', 'wuffuw\n', 'qqqqqqqq\n']","['3\n', '5\n', '0\n']","""mew"" is not a palindrome, so the longest substring of it that is not a palindrome, is the string ""mew"" itself. Thus, the answer for the first example is $3$.

The string ""uffuw"" is one of the longest non-palindrome substrings (of length $5$) of the string ""wuffuw"", so the answer for the second example is $5$.

All substrings of the string ""qqqqqqqq"" consist of equal characters so they are palindromes. This way, there are no non-palindrome substrings. Thus, the answer for the third example is $0$.",OK,"def a(S):

    for i in range(0, len(S)):

        if S[i] != S[-(i+1)]: return False

    return True

while True:
    S = input()

    if not a(S):

        print(len(S))

    else:

        if S.count(S[0]) == len(S):

            print(0)

        else:

            print(len(S)-1)

    break","def e():

    a = input().strip()
    F, I, T = map(int, a.split())

    f = [input().strip() for _ in range(F)]

    g = 0

    for c in range(I):
        d = 0

        for b in range(F):
            if f[b][c] == 'Y':
                d += 1

        if d >= T:
            g += 1

    print(g)

if __name__ == ""__main__"":
    e()"
581,A,Vasya the Hipster,PROGRAMMING,"['implementation', 'math']","One day Vasya the Hipster decided to count how many socks he had. It turned out that he had *a* red socks and *b* blue socks.

According to the latest fashion, hipsters should wear the socks of different colors: a red one on the left foot, a blue one on the right foot.

Every day Vasya puts on new socks in the morning and throws them away before going to bed as he doesn't want to wash them.

Vasya wonders, what is the maximum number of days when he can dress fashionable and wear different socks, and after that, for how many days he can then wear the same socks until he either runs out of socks or cannot make a single pair from the socks he's got.

Can you help him?","The single line of the input contains two positive integers *a* and *b* (1<=≤<=*a*,<=*b*<=≤<=100) — the number of red and blue socks that Vasya's got.","Print two space-separated integers — the maximum number of days when Vasya can wear different socks and the number of days when he can wear the same socks until he either runs out of socks or cannot make a single pair from the socks he's got.

Keep in mind that at the end of the day Vasya throws away the socks that he's been wearing on that day.","['3 1\n', '2 3\n', '7 3\n']","['1 1\n', '2 0\n', '3 2\n']","In the first sample Vasya can first put on one pair of different socks, after that he has two red socks left to wear on the second day.",OK,"def c():
    (d, a) = input().split()
    b = 0
    (d, a) = int(d), int(a)
    while int(d) > 0 and int(a) > 0:
        b += 1
        (d, a) = d - 1, a - 1
    print(b, d // 2 + a // 2)
c()","def c(n, b):

    d = 0
    e = 0

    for a in b:
        if a == 25:

            d += 1
        elif a == 50:

            if d == 0:
                return False
            d -= 1
            e += 1
        elif a == 100:

            if e >= 1 and d >= 1:
                e -= 1
                d -= 1

            elif d >= 3:
                d -= 3
            else:
                return False
        else:

            return False

    return True

if __name__ == ""__main__"":
    import g

    f = g.stdin.read().strip().splitlines()
    
    if not f:
        g.exit(0)

    n = int(f[0].strip())

    b = list(map(int, f[1].split()))

    if c(n, b):
        g.stdout.write(""YES\n"")
    else:
        g.stdout.write(""NO\n"")"
0,none,none,none,['none'],"A family consisting of father bear, mother bear and son bear owns three cars. Father bear can climb into the largest car and he likes it. Also, mother bear can climb into the middle car and she likes it. Moreover, son bear can climb into the smallest car and he likes it. It's known that the largest car is strictly larger than the middle car, and the middle car is strictly larger than the smallest car. 

Masha came to test these cars. She could climb into all cars, but she liked only the smallest car. 

It's known that a character with size *a* can climb into some car with size *b* if and only if *a*<=≤<=*b*, he or she likes it if and only if he can climb into this car and 2*a*<=≥<=*b*.

You are given sizes of bears and Masha. Find out some possible integer non-negative sizes of cars.","You are given four integers *V*1, *V*2, *V*3, *V**m*(1<=≤<=*V**i*<=≤<=100) — sizes of father bear, mother bear, son bear and Masha, respectively. It's guaranteed that *V*1<=&gt;<=*V*2<=&gt;<=*V*3.","Output three integers — sizes of father bear's car, mother bear's car and son bear's car, respectively.

If there are multiple possible solutions, print any.

If there is no solution, print ""-1"" (without quotes).","['50 30 10 10\n', '100 50 10 21\n']","['50\n30\n10\n', '-1\n']","In first test case all conditions for cars' sizes are satisfied.

In second test case there is no answer, because Masha should be able to climb into smallest car (so size of smallest car in not less than 21), but son bear should like it, so maximum possible size of it is 20.",WRONG_ANSWER,"def j(k,l,m,n):
    for g in range(1,101):
        for h in range(1, 101):
            for i in range(1, 101):
               a=    (g>=k and g<=k*2)
               b=    (h>=l and h<=l*2)
               c=    (i>=m and i<=m*2)
               d=not(g>=n and g<=n*2)
               e=not(h>=n and h<=n*2)
               f=   (i>=n and i<=n*2)
               if a and b and c and d and e and f:
                   print(g)
                   print(h)
                   return i
    return -1

k,l,m,n=map(int, input().split())
print(j(k,l,m,n))","def a(s):

    if len(s) % 2 == 1:
        return s

    d = len(s) // 2
    c = a(s[:d])
    e = a(s[d:])

    if c <= e:
        return c + e
    else:
        return e + c

if __name__ == '__main__':
    import h

    b = h.stdin.read().splitlines()
    f = b[0].strip()
    g = b[1].strip()

    if a(f) == a(g):
        h.stdout.write(""YES"")
    else:
        h.stdout.write(""NO"")"
859,C,Pie Rules,PROGRAMMING,"['dp', 'games']","You may have heard of the pie rule before. It states that if two people wish to fairly share a slice of pie, one person should cut the slice in half, and the other person should choose who gets which slice. Alice and Bob have many slices of pie, and rather than cutting the slices in half, each individual slice will be eaten by just one person.

The way Alice and Bob decide who eats each slice is as follows. First, the order in which the pies are to be handed out is decided. There is a special token called the ""decider"" token, initially held by Bob. Until all the pie is handed out, whoever has the decider token will give the next slice of pie to one of the participants, and the decider token to the other participant. They continue until no slices of pie are left.

All of the slices are of excellent quality, so each participant obviously wants to maximize the total amount of pie they get to eat. Assuming both players make their decisions optimally, how much pie will each participant receive?","Input will begin with an integer *N* (1<=≤<=*N*<=≤<=50), the number of slices of pie. 

Following this is a line with *N* integers indicating the sizes of the slices (each between 1 and 100000, inclusive), in the order in which they must be handed out.","Print two integers. First, the sum of the sizes of slices eaten by Alice, then the sum of the sizes of the slices eaten by Bob, assuming both players make their decisions optimally.","['3\n141 592 653\n', '5\n10 21 10 21 10\n']","['653 733\n', '31 41\n']","In the first example, Bob takes the size 141 slice for himself and gives the decider token to Alice. Then Alice gives the size 592 slice to Bob and keeps the decider token for herself, so that she can then give the size 653 slice to herself.",OK,"import math
from random import random

def d():
    return(int(input()))

def e():
    g = input().split()
    return [int(l) for l in g]

def b():
    return(float(input()))

def c():
    g = input().split()
    return [float(l) for l in g]

def f():
    g = input().split()
    return(g)

N = d()
k = e()

h = 0

a = [0, 0]

for i in range(len(k)):
    v = k[len(k) - i - 1]
    j = [v + a[1], a[0]]
    i = [a[0], v + a[1]]

    if(j[0] >= i[0]):
        a = j
    else:
        a = i

print(str(a[1]) + ' ' + str(a[0]))","import l
from collections import c

def g():

    b = l.stdin.read().split()
    if not b:
        return
    n = int(b[0])
    q = int(b[1])

    h = []

    k = []

    a = [c() for _ in range(n + 1)]

    m = 0

    e = 0

    j = 2
    i = []
    for _ in range(q):
        d = int(b[j])
        j += 1

        if d == 1:

            x = int(b[j])
            j += 1
            h.append(x)
            k.append(False)

            a[x].append(len(h) - 1)
            m += 1

        elif d == 2:

            x = int(b[j])
            j += 1

            while a[x]:
                f = a[x].popleft()
                if not k[f]:
                    k[f] = True
                    m -= 1

        elif d == 3:

            t = int(b[j])
            j += 1

            while e < t:
                if not k[e]:
                    k[e] = True
                    m -= 1
                e += 1

        i.append(str(m))

    l.stdout.write(""\n"".join(i) + ""\n"")

if __name__ == '__main__':
    g()"
106,B,Choosing Laptop,PROGRAMMING,"['brute force', 'implementation']","Vasya is choosing a laptop. The shop has *n* laptops to all tastes.

Vasya is interested in the following properties: processor speed, ram and hdd. Vasya is a programmer and not a gamer which is why he is not interested in all other properties.

If all three properties of a laptop are strictly less than those properties of some other laptop, then the first laptop is considered outdated by Vasya. Among all laptops Vasya does not consider outdated, he chooses the cheapest one.

There are very many laptops, which is why Vasya decided to write a program that chooses the suitable laptop. However, Vasya doesn't have his own laptop yet and he asks you to help him.","The first line contains number *n* (1<=≤<=*n*<=≤<=100).

Then follow *n* lines. Each describes a laptop as *speed* *ram* *hdd* *cost*. Besides, 
 -  *speed*, *ram*, *hdd* and *cost* are integers -  1000<=≤<=*speed*<=≤<=4200 is the processor's speed in megahertz -  256<=≤<=*ram*<=≤<=4096 the RAM volume in megabytes -  1<=≤<=*hdd*<=≤<=500 is the HDD in gigabytes -  100<=≤<=*cost*<=≤<=1000 is price in tugriks 
All laptops have different prices.",Print a single number — the number of a laptop Vasya will choose. The laptops are numbered with positive integers from 1 to *n* in the order in which they are given in the input data.,['5\n2100 512 150 200\n2000 2048 240 350\n2300 1024 200 320\n2500 2048 80 300\n2000 512 180 150\n'],['4'],"In the third sample Vasya considers the first and fifth laptops outdated as all of their properties cannot match those of the third laptop. The fourth one is the cheapest among the laptops that are left. Thus, Vasya chooses the fourth laptop.",WRONG_ANSWER,"n=int(input())
b=[]
for i in range(n):
    a= list(map(int, input().split()))
    a.append(i+1)
    b.append(a)
def a(a):
    return a[3]
b.sort(key=a)
def b(b,n):
    for i in range(n):
        for j in range(n):
            c=0
            for k in range(3):
                if b[i][k]<b[j][k]:c+=1
            if c==3:break
            if j==4:return b[i][4]
print(b(b,n))","n, m = map(int, input().split())

b = []
for _ in range(m):
    a, b = map(int, input().split())
    b.append((a, b))

b.sort(key=lambda x: x[1], reverse=True)

c = 0

for a, b in b:
    if n <= 0:
        break

    a = min(n, a)
    c += a * b
    n -= a

print(c)"
110,A,Nearly Lucky Number,PROGRAMMING,['implementation'],"Petya loves lucky numbers. We all know that lucky numbers are the positive integers whose decimal representations contain only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.

Unfortunately, not all numbers are lucky. Petya calls a number nearly lucky if the number of lucky digits in it is a lucky number. He wonders whether number *n* is a nearly lucky number.","The only line contains an integer *n* (1<=≤<=*n*<=≤<=1018).

Please do not use the %lld specificator to read or write 64-bit numbers in С++. It is preferred to use the cin, cout streams or the %I64d specificator.","Print on the single line ""YES"" if *n* is a nearly lucky number. Otherwise, print ""NO"" (without the quotes).","['40047\n', '7747774\n', '1000000000000000000\n']","['NO\n', 'YES\n', 'NO\n']","In the first sample there are 3 lucky digits (first one and last two), so the answer is ""NO"".

In the second sample there are 7 lucky digits, 7 is lucky number, so the answer is ""YES"".

In the third sample there are no lucky digits, so the answer is ""NO"".",RUNTIME_ERROR,"def d(e):
   
    while e > 0:
        b = e % 10
        if b != 4 and b != 7:
            return False
        e //= 10
    return True

def c(e):

    a = 0
    while e > 0:
        b = e % 10
        if b == 4 or b == 7:
            a += 1
        e //= 10
    
    return d(a)

n = int(input())

if c(n):
    print(""SÍ"")
else:
    print(""NO"")","def a(l, r, p):

    return r // p - (l - 1) // p

def e():
    import i
    b = i.stdin.read().strip().split()
    if not b:
        return

    n = int(b[0])
    p = int(b[1])

    h = [0.0] * n
    d = 2
    for i in range(n):
        l = int(b[d])
        r = int(b[d + 1])
        d += 2
        j = r - l + 1
        f = a(l, r, p)
        h[i] = f / j

    c = 0.0
    for i in range(n):
        j = (i + 1) % n
        g = h[i] + h[j] - h[i] * h[j]
        c += 2000 * g

    i.stdout.write(f""{c:.6f}"")

if __name__ == '__main__':
    e()"
115,A,Party,PROGRAMMING,"['dfs and similar', 'graphs', 'trees']","A company has *n* employees numbered from 1 to *n*. Each employee either has no immediate manager or exactly one immediate manager, who is another employee with a different number. An employee *A* is said to be the superior of another employee *B* if at least one of the following is true:
 -  Employee *A* is the immediate manager of employee *B* -  Employee *B* has an immediate manager employee *C* such that employee *A* is the superior of employee *C*. 
The company will not have a managerial cycle. That is, there will not exist an employee who is the superior of his/her own immediate manager.

Today the company is going to arrange a party. This involves dividing all *n* employees into several groups: every employee must belong to exactly one group. Furthermore, within any single group, there must not be two employees *A* and *B* such that *A* is the superior of *B*.

What is the minimum number of groups that must be formed?","The first line contains integer *n* (1<=≤<=*n*<=≤<=2000) — the number of employees.

The next *n* lines contain the integers *p**i* (1<=≤<=*p**i*<=≤<=*n* or *p**i*<==<=-1). Every *p**i* denotes the immediate manager for the *i*-th employee. If *p**i* is -1, that means that the *i*-th employee does not have an immediate manager. 

It is guaranteed, that no employee will be the immediate manager of him/herself (*p**i*<=≠<=*i*). Also, there will be no managerial cycles.",Print a single integer denoting the minimum number of groups that will be formed in the party.,['5\n-1\n1\n2\n1\n-1\n'],['3\n'],"For the first example, three groups are sufficient, for example: 
 -  Employee 1 -  Employees 2 and 4 -  Employees 3 and 5",MEMORY_LIMIT_EXCEEDED,"from itertools import accumulate
from collections import e
import j
j.setrecursionlimit(10**6)

def I(): return int(input())
def c(): return input()
def a(): return list(map(int, input().split()))
def b(): return sorted(map(int, input().split()))

n = I()
i = e(list)
for i in range(1,n+1):
   b = I()
   if b != -1:
    i[b].append(i)
 
d = 1   
def g(h,f):
    global d
    d = max(d,f)
    while h in i and i[h]:
        k = i[h].pop()
        g(k,f+1)

for h in i:
    if i[h]:
        g(h,1)
print(d)","def g():
    import m
    e = m.stdin.read().strip().split()
    if not e:
        return

    k = 0
    n = int(e[k])
    k += 1
    m = int(e[k])
    k += 1
    k = int(e[k])
    k += 1

    a = [0] * n
    for i in range(n):
        a[i] = int(e[k])
        k += 1

    b = [[0] * n for _ in range(n)]
    for _ in range(k):
        x = int(e[k])
        k += 1
        y = int(e[k])
        k += 1
        c = int(e[k])
        k += 1

        b[x - 1][y - 1] = c

    l = 1 << n
    d = [[-10**18] * n for _ in range(l)]

    for i in range(n):
        d[1 << i][i] = a[i]

    for h in range(l):

        c = bin(h).count(""1"")
        if c >= m:
            continue

        for j in range(n):
            if d[h][j] < 0:
                continue
            for f in range(n):

                if h & (1 << f):
                    continue
                i = h | (1 << f)
                j = d[h][j] + a[f] + b[j][f]
                if j > d[i][f]:
                    d[i][f] = j

    a = 0
    for h in range(l):
        if bin(h).count(""1"") == m:
            for j in range(n):
                if d[h][j] > a:
                    a = d[h][j]
    m.stdout.write(str(a))
    
if __name__ == '__main__':
    g()"
1011,A,Stages,PROGRAMMING,"['greedy', 'implementation', 'sortings']","Natasha is going to fly to Mars. She needs to build a rocket, which consists of several stages in some order. Each of the stages is defined by a lowercase Latin letter. This way, the rocket can be described by the string — concatenation of letters, which correspond to the stages.

There are $n$ stages available. The rocket must contain exactly $k$ of them. Stages in the rocket should be ordered by their weight. So, after the stage with some letter can go only stage with a letter, which is at least two positions after in the alphabet (skipping one letter in between, or even more). For example, after letter 'c' can't go letters 'a', 'b', 'c' and 'd', but can go letters 'e', 'f', ..., 'z'.

For the rocket to fly as far as possible, its weight should be minimal. The weight of the rocket is equal to the sum of the weights of its stages. The weight of the stage is the number of its letter in the alphabet. For example, the stage 'a 'weighs one ton,' b 'weighs two tons, and' z' — $26$ tons.

Build the rocket with the minimal weight or determine, that it is impossible to build a rocket at all. Each stage can be used at most once.","The first line of input contains two integers — $n$ and $k$ ($1 \le k \le n \le 50$) – the number of available stages and the number of stages to use in the rocket.

The second line contains string $s$, which consists of exactly $n$ lowercase Latin letters. Each letter defines a new stage, which can be used to build the rocket. Each stage can be used at most once.","Print a single integer — the minimal total weight of the rocket or -1, if it is impossible to build the rocket at all.","['5 3\nxyabd\n', '7 4\nproblem\n', '2 2\nab\n', '12 1\nabaabbaaabbb\n']","['29', '34', '-1', '1']","In the first example, the following rockets satisfy the condition:
-  ""adx"" (weight is $1+4+24=29$);-  ""ady"" (weight is $1+4+25=30$);-  ""bdx"" (weight is $2+4+24=30$);-  ""bdy"" (weight is $2+4+25=31$).
Rocket ""adx"" has the minimal weight, so the answer is $29$.

In the second example, target rocket is ""belo"". Its weight is $2+5+12+15=34$.

In the third example, $n=k=2$, so the rocket must have both stages: 'a' and 'b'. This rocket doesn't satisfy the condition, because these letters are adjacent in the alphabet. Answer is -1.",OK,"a='abcdefghijklmnopqrstuvwxyz'
n,k=map(int,input().split( ))
s=list(input())
s.sort()
g=(a.index(s[0])+1)
k-=1
p=1
m=''
m+=s[0]
while k!=0:
    if a.index(s[p])-a.index(m[len(m)-1])>=2:
        m+=s[p]
        g+=(a.index(s[p])+1)
        k-=1
    p+=1
    if p==n and k!=0:
        print(-1)
        exit()
print(g)","def a():

    n = int(input().strip())

    c = [[0] * n for _ in range(n)]

    for i in range(n):
        c[i][0] = 1
        c[0][i] = 1

    for i in range(1, n):
        for j in range(1, n):
            c[i][j] = c[i-1][j] + c[i][j-1]

    b = c[n-1][n-1]

    print(b)

if __name__ == ""__main__"":
    a()"
224,B,Array,PROGRAMMING,"['bitmasks', 'implementation', 'two pointers']","You've got an array *a*, consisting of *n* integers: *a*1,<=*a*2,<=...,<=*a**n*. Your task is to find a minimal by inclusion segment [*l*,<=*r*] (1<=≤<=*l*<=≤<=*r*<=≤<=*n*) such, that among numbers *a**l*,<= *a**l*<=+<=1,<= ...,<= *a**r* there are exactly *k* distinct numbers.

Segment [*l*,<=*r*] (1<=≤<=*l*<=≤<=*r*<=≤<=*n*; *l*,<=*r* are integers) of length *m*<==<=*r*<=-<=*l*<=+<=1, satisfying the given property, is called minimal by inclusion, if there is no segment [*x*,<=*y*] satisfying the property and less then *m* in length, such that 1<=≤<=*l*<=≤<=*x*<=≤<=*y*<=≤<=*r*<=≤<=*n*. Note that the segment [*l*,<=*r*] doesn't have to be minimal in length among all segments, satisfying the given property.","The first line contains two space-separated integers: *n* and *k* (1<=≤<=*n*,<=*k*<=≤<=105). The second line contains *n* space-separated integers *a*1,<=*a*2,<=...,<=*a**n* — elements of the array *a* (1<=≤<=*a**i*<=≤<=105).","Print a space-separated pair of integers *l* and *r* (1<=≤<=*l*<=≤<=*r*<=≤<=*n*) such, that the segment [*l*,<=*r*] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.","['4 2\n1 2 2 3\n', '8 3\n1 1 2 2 3 3 4 5\n', '7 4\n4 7 7 4 7 4 7\n']","['1 2\n', '2 5\n', '-1 -1\n']","In the first sample among numbers *a*<sub class=""lower-index"">1</sub> and *a*<sub class=""lower-index"">2</sub> there are exactly two distinct numbers.

In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.

In the third sample there is no segment with four distinct numbers.",OK,"import i
import h.path
 
if(h.path.exists('input.txt')) :
    i.stdin = open(""input.txt"", ""r"")
    i.stdout = open(""output.txt"", ""w"")
    i.stderr = open(""error.txt"", ""w"")
    
c = 1000005
g = 1000000007 
d = g * g
i.setrecursionlimit(c) 
 
e = lambda: list(f())
f = lambda: map(int, input().split())
 
from math import inf, ceil, sqrt, log2
from collections import b, deque

a = lambda x: b(lambda: x)
 
(n, k), a = f(), e()
c, s = a(0), set(a)
for e in a : c[e] += 1
i, j = 0, n
while len(s) > k :
    j -= 1
    c[a[j]] -= 1
    if c[a[j]] == 0 :
        s.remove(a[j])
j -= 1
while len(s) == k :
    if c[a[j]] > 1 :
        c[a[j]] -= 1
        j -= 1
    elif c[a[i]] > 1 :
        c[a[i]] -= 1
        i += 1
    else :
        break
if len(set(a)) < k : print(""-1 -1"")
else : print(i+1, j+1)","import i

def b():

    j = i.stdin.read().split()
    if not j:
        return
    n = int(j[0])

    if len(j) == n + 1:

        a = [None] + list(map(int, j[1:]))

        def c(i, j):

            print(f""? {i} {j}"")
            i.stdout.flush()
            return a[i] + a[j]
    else:

        def c(i, j):
            print(f""? {i} {j}"")
            i.stdout.flush()

            return int(i.stdin.readline().strip())

    e = c(1, 2)

    h = c(2, 3)

    f = c(1, 3)

    a = [0] * (n + 1)

    a[1] = (e + f - h) // 2
    a[2] = e - a[1]
    a[3] = f - a[1]

    for i in range(4, n + 1):
        g = c(1, i)
        a[i] = g - a[1]

    d = "" "".join(str(a[i]) for i in range(1, n + 1))
    print(""! "" + d)
    i.stdout.flush()

if __name__ == '__main__':
    b()"
743,A,Vladik and flights,PROGRAMMING,"['constructive algorithms', 'greedy', 'implementation']","Vladik is a competitive programmer. This year he is going to win the International Olympiad in Informatics. But it is not as easy as it sounds: the question Vladik face now is to find the cheapest way to get to the olympiad.

Vladik knows *n* airports. All the airports are located on a straight line. Each airport has unique id from 1 to *n*, Vladik's house is situated next to the airport with id *a*, and the place of the olympiad is situated next to the airport with id *b*. It is possible that Vladik's house and the place of the olympiad are located near the same airport. 

To get to the olympiad, Vladik can fly between any pair of airports any number of times, but he has to start his route at the airport *a* and finish it at the airport *b*.

Each airport belongs to one of two companies. The cost of flight from the airport *i* to the airport *j* is zero if both airports belong to the same company, and |*i*<=-<=*j*| if they belong to different companies.

Print the minimum cost Vladik has to pay to get to the olympiad.","The first line contains three integers *n*, *a*, and *b* (1<=≤<=*n*<=≤<=105, 1<=≤<=*a*,<=*b*<=≤<=*n*) — the number of airports, the id of the airport from which Vladik starts his route and the id of the airport which he has to reach. 

The second line contains a string with length *n*, which consists only of characters 0 and 1. If the *i*-th character in this string is 0, then *i*-th airport belongs to first company, otherwise it belongs to the second.",Print single integer — the minimum cost Vladik has to pay to get to the olympiad.,"['4 1 4\n1010\n', '5 5 2\n10110\n']","['1', '0']","In the first example Vladik can fly to the airport 2 at first and pay |1 - 2| = 1 (because the airports belong to different companies), and then fly from the airport 2 to the airport 4 for free (because the airports belong to the same company). So the cost of the whole flight is equal to 1. It's impossible to get to the olympiad for free, so the answer is equal to 1. 

In the second example Vladik can fly directly from the airport 5 to the airport 2, because they belong to the same company.",WRONG_ANSWER,"import fileinput

def d():
	pass
if __name__ == '__main__':
	c = 2
	for a in range(c):
		if a == 0:
			n,a,b = map(int, input().split())
		else:
			s = input()
	b = 0

	if s[a-1] == s[b-1]:
		b += 0
	else:
		if a > b:
			for i in range(a-1,b-1, -1):
				if s[i] == s[b-1]:
					break
				else:
					b += 1
		else:
			for i in range(a-1,b-1):
				if s[i] == s[b-1]:
					break
				else:
					b += 1
	print(b)","import h

def d():

    c = h.stdin.read().splitlines()
    if not c:
        return

    n, m = map(int, c[0].split())

    g = c[1:1+n]

    if n == 1:
        print(0)
        return

    f = 0

    b = [False] * (n - 1)

    for a in range(m):

        e = False
        for i in range(n - 1):
            if not b[i]:
                if g[i][a] > g[i+1][a]:
                    e = True
                    break

        if e:
            f += 1
        else:

            for i in range(n - 1):
                if not b[i] and g[i][a] < g[i+1][a]:
                    b[i] = True

    print(f)

if __name__ == ""__main__"":
    d()"
515,C,Drazil and Factorial,PROGRAMMING,"['greedy', 'math', 'sortings']","Drazil is playing a math game with Varda.

Let's define  for positive integer *x* as a product of factorials of its digits. For example, .

First, they choose a decimal number *a* consisting of *n* digits that contains at least one digit larger than 1. This number may possibly start with leading zeroes. Then they should find maximum positive number *x* satisfying following two conditions:

1. *x* doesn't contain neither digit 0 nor digit 1.

2.  = .

Help friends find such number.","The first line contains an integer *n* (1<=≤<=*n*<=≤<=15) — the number of digits in *a*.

The second line contains *n* digits of *a*. There is at least one digit in *a* that is larger than 1. Number *a* may possibly contain leading zeroes.",Output a maximum possible integer satisfying the conditions above. There should be no zeroes and ones in this number decimal representation.,"['4\n1234\n', '3\n555\n']","['33222\n', '555\n']","In the first case, <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/f5a4207f23215fddce977ab5ea9e9d2e7578fb52.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>",OK,"b = {
    ""7"": [7],
    ""8"": [7, 2, 2, 2],
    ""9"": [7, 3, 3, 2],
    ""6"": [5, 3],
    ""5"": [5],
    ""4"": [3, 2, 2],
    ""3"": [3],
    ""2"": [2],
    ""1"": [],
    ""0"": []
}
def d():
    _ = input()
    c = str(input())
    a = []
    for i in c:
        a += b[i]

    a.sort()
    for i in reversed(a):
        print(i, end="""")
d()","def a(s):
    """"""Return the canonical form of string s.""""""

    if len(s) % 2:
        return s

    d = len(s) // 2
    c = a(s[:d])
    e = a(s[d:])

    if c + e < e + c:
        return c + e
    else:
        return e + c

if __name__ == '__main__':
    import f

    b = f.stdin.read().splitlines()

    if len(b) >= 2:
        s = b[0].strip()
        t = b[1].strip()

        if a(s) == a(t):
            f.stdout.write(""YES\n"")
        else:
            f.stdout.write(""NO\n"")"
199,A,Hexadecimal's theorem,PROGRAMMING,"['brute force', 'constructive algorithms', 'implementation', 'number theory']","Recently, a chaotic virus Hexadecimal advanced a new theorem which will shake the Universe. She thinks that each Fibonacci number can be represented as sum of three not necessary different Fibonacci numbers.

Let's remember how Fibonacci numbers can be calculated. *F*0<==<=0, *F*1<==<=1, and all the next numbers are *F**i*<==<=*F**i*<=-<=2<=+<=*F**i*<=-<=1.

So, Fibonacci numbers make a sequence of numbers: 0, 1, 1, 2, 3, 5, 8, 13, ...

If you haven't run away from the PC in fear, you have to help the virus. Your task is to divide given Fibonacci number *n* by three not necessary different Fibonacci numbers or say that it is impossible.",The input contains of a single integer *n* (0<=≤<=*n*<=&lt;<=109) — the number that should be represented by the rules described above. It is guaranteed that *n* is a Fibonacci number.,"Output three required numbers: *a*, *b* and *c*. If there is no answer for the test you have to print ""I'm too stupid to solve this problem"" without the quotes.

If there are multiple answers, print any of them.","['3\n', '13\n']","['1 1 1\n', '2 3 8\n']",none,WRONG_ANSWER,"n = int(input())
s = 1
t = 1
def a(n,x):
	if x == 1:
		return n
	s = 1
	t = 1
	while True:
		k = s + t
		t = s
		s = k
		if s >= n:
			return t,a(n-t,x-1)
if n >= 3:
	l = a(n,3)
	print(l[0],l[1][0],l[1][1])
if n < 3:
	print(""I'm too stupid to solve this problem"")","def b():

    n = int(input().strip())

    a = {}

    for _ in range(n):
        c = input().strip()

        if c in a:
            a[c] += 1
        else:
            a[c] = 1

    d = max(a, key=a.get)

    print(d)

if __name__ == ""__main__"":
    b()"
139,A,Petr and Book,PROGRAMMING,['implementation'],"One Sunday Petr went to a bookshop and bought a new book on sports programming. The book had exactly *n* pages.

Petr decided to start reading it starting from the next day, that is, from Monday. Petr's got a very tight schedule and for each day of the week he knows how many pages he will be able to read on that day. Some days are so busy that Petr will have no time to read whatsoever. However, we know that he will be able to read at least one page a week.

Assuming that Petr will not skip days and will read as much as he can every day, determine on which day of the week he will read the last page of the book.","The first input line contains the single integer *n* (1<=≤<=*n*<=≤<=1000) — the number of pages in the book.

The second line contains seven non-negative space-separated integers that do not exceed 1000 — those integers represent how many pages Petr can read on Monday, Tuesday, Wednesday, Thursday, Friday, Saturday and Sunday correspondingly. It is guaranteed that at least one of those numbers is larger than zero.","Print a single number — the number of the day of the week, when Petr will finish reading the book. The days of the week are numbered starting with one in the natural order: Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday.","['100\n15 20 20 15 10 30 45\n', '2\n1 0 0 0 0 0 0\n']","['6\n', '1\n']","Note to the first sample:

By the end of Monday and therefore, by the beginning of Tuesday Petr has 85 pages left. He has 65 pages left by Wednesday, 45 by Thursday, 30 by Friday, 20 by Saturday and on Saturday Petr finishes reading the book (and he also has time to read 10 pages of something else).

Note to the second sample:

On Monday of the first week Petr will read the first page. On Monday of the second week Petr will read the second page and will finish reading the book.",RUNTIME_ERROR,"n=int(input())
s=input()
l=s.split()
l=[int(i) for i in l]
a=0
def f(a,n):
    k=0
    while k<=len(l):
        a=a+l[k]
        if a>=n:
            print(k+1)
            return
        k=k+1
    f(a,n)
f(a,n)","def c():
    import e

    b = e.stdin.read().splitlines()
    if not b:
        return

    a = b[0].strip()
    f = ""CODEFORCES""
    n = len(f)

    d = False
    for i in range(n + 1):

        if a.startswith(f[:i]) and a.endswith(f[i:]) and len(a) >= n:
            d = True
            break

    print(""YES"" if d else ""NO"")

if __name__ == ""__main__"":
    c()"
71,A,Way Too Long Words,PROGRAMMING,['strings'],"Sometimes some words like ""localization"" or ""internationalization"" are so long that writing them many times in one text is quite tiresome.

Let's consider a word too long, if its length is strictly more than 10 characters. All too long words should be replaced with a special abbreviation.

This abbreviation is made like this: we write down the first and the last letter of a word and between them we write the number of letters between the first and the last letters. That number is in decimal system and doesn't contain any leading zeroes.

Thus, ""localization"" will be spelt as ""l10n"", and ""internationalization» will be spelt as ""i18n"".

You are suggested to automatize the process of changing the words with abbreviations. At that all too long words should be replaced by the abbreviation and the words that are not too long should not undergo any changes.",The first line contains an integer *n* (1<=≤<=*n*<=≤<=100). Each of the following *n* lines contains one word. All the words consist of lowercase Latin letters and possess the lengths of from 1 to 100 characters.,Print *n* lines. The *i*-th line should contain the result of replacing of the *i*-th word from the input data.,['4\nword\nlocalization\ninternationalization\npneumonoultramicroscopicsilicovolcanoconiosis\n'],['word\nl10n\ni18n\np43s\n'],none,OK,"def a():
    t = int(input())
    
    for i in range(t):
        b = str(input())
        if len(b) > 10:
            print(b[0] + str((len(b) - 2)) + b[len(b) - 1])
        else:
            print(b)

if __name__ == '__main__':
    a()","def e():
    import g

    d = g.stdin.read().splitlines()
    if len(d) < 3:
        return
    
    b = d[0].strip()
    c = d[1].strip()
    f = d[2].strip()

    a = b + c

    if sorted(a) == sorted(f):
        print(""YES"")
    else:
        print(""NO"")

if __name__ == ""__main__"":
    e()"
254,A,Cards with Numbers,PROGRAMMING,"['constructive algorithms', 'sortings']","Petya has got 2*n* cards, each card contains some integer. The numbers on the cards can be the same. Let's index all cards by consecutive integers from 1 to 2*n*. We'll denote the number that is written on a card with number *i*, as *a**i*. In order to play one entertaining game with his friends, Petya needs to split the cards into pairs so that each pair had equal numbers on the cards. Help Petya do that.","The first line contains integer *n* (1<=≤<=*n*<=≤<=3·105). The second line contains the sequence of 2*n* positive integers *a*1,<=*a*2,<=...,<=*a*2*n* (1<=≤<=*a**i*<=≤<=5000) — the numbers that are written on the cards. The numbers on the line are separated by single spaces.","If it is impossible to divide the cards into pairs so that cards in each pair had the same numbers, print on a single line integer -1. But if the required partition exists, then print *n* pairs of integers, a pair per line — the indices of the cards that form the pairs.

Separate the numbers on the lines by spaces. You can print the pairs and the numbers in the pairs in any order. If there are multiple solutions, print any of them.","['3\n20 30 10 30 20 10\n', '1\n1 2\n']","['4 2\n1 5\n6 3\n', '-1']",none,OK,"import a
a.stdin = open(""input.txt"", ""r"")
a.stdout = open(""output.txt"", ""w"")
n=int(input())
d={}
for x,y in enumerate(input().split(),1):
    d.setdefault(y,[]).append(x)
if any(len(d[i])%2!=0 for i in d):
    print(-1)
    exit(0)
for i in d:
    print(""\n"".join(""{0} {1}"".format(*k) for k in zip(d[i][::2],d[i][1::2])))","""""""
Mishka's Christmas tree decoration problem.
He has three garlands with periods k1, k2 and k3.
When a garland is switched on at time x, it lights at seconds:
x, x+k, x+2*k, … 
We want to choose switch‐on moments x1,x2,x3 so that starting from
t = max(x1,x2,x3) every second at least one garland is lit.
This is equivalent to finding three residue classes
r1 (mod k1), r2 (mod k2) and r3 (mod k3)
whose union (as a periodic set) covers all integers.
It turns out that if we “optimize” the choice to avoid overlaps,
the maximum number of residues we can cover modulo (k1*k2*k3)
is given by:
    T = (k2*k3 + k1*k3 + k1*k2)
        - [I(gcd(k1,k2)==1)*k3 + I(gcd(k1,k3)==1)*k2 + I(gcd(k2,k3)==1)*k1]
        + (1 if gcd(k1,k2)==gcd(k1,k3)==gcd(k2,k3)==1 else 0)
A covering exists if and only if T equals k1*k2*k3.
Note that if any k==1, the answer is always YES.
""""""

from math import g
import n

def e(h, i, j):

    if h == 1 or i == 1 or j == 1:
        return True

    a = 1 if g(h, i) == 1 else 0
    b = 1 if g(h, j) == 1 else 0
    c = 1 if g(i, j) == 1 else 0

    P = h * i * j
    o = i * j + h * j + h * i

    m = (a * j) + (b * i) + (c * h)

    d = 1 if (a and b and c) else 0

    l = o - m + d
    return l == P

def k():
    f = n.stdin.read().split()
    if not f:
        return
    h, i, j = map(int, f[:3])
    print(""YES"" if e(h, i, j) else ""NO"")
    
if __name__ == '__main__':
    k()"
0,none,none,none,['none'],"Today Pari and Arya are playing a game called Remainders.

Pari chooses two positive integer *x* and *k*, and tells Arya *k* but not *x*. Arya have to find the value . There are *n* ancient numbers *c*1,<=*c*2,<=...,<=*c**n* and Pari has to tell Arya  if Arya wants. Given *k* and the ancient values, tell us if Arya has a winning strategy independent of value of *x* or not. Formally, is it true that Arya can understand the value  for any positive integer *x*?

Note, that  means the remainder of *x* after dividing it by *y*.","The first line of the input contains two integers *n* and *k* (1<=≤<=*n*,<= *k*<=≤<=1<=000<=000) — the number of ancient integers and value *k* that is chosen by Pari.

The second line contains *n* integers *c*1,<=*c*2,<=...,<=*c**n* (1<=≤<=*c**i*<=≤<=1<=000<=000).","Print ""Yes"" (without quotes) if Arya has a winning strategy independent of value of *x*, or ""No"" (without quotes) otherwise.","['4 5\n2 3 5 12\n', '2 7\n2 3\n']","['Yes\n', 'No\n']","In the first sample, Arya can understand <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/d170efffcde0907ee6bcf32de21051bce0677a2c.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> because 5 is one of the ancient numbers.

In the second sample, Arya can't be sure what <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/57b5f6a96f5db073270dd3ed4266c69299ec701d.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> is. For example 1 and 7 have the same remainders after dividing by 2 and 3, but they differ in remainders after dividing by 7.",RUNTIME_ERROR,"import c
l = c.b
def b(a):
    a = l(a[0],a[1])
    for i in range(2,len(a)):
        a = l(a,a[i])
    return a
n,k = map(int,input().split())
a = list(map(int,input().split()))
if k in a or b(a)==k:
    print('YES')
else:
    print('NO')","def a(a, b, s):

    b = abs(a) + abs(b)

    return s >= b and (s - b) % 2 == 0

def c():

    try:
        a, b, s = map(int, input().split())
    except ValueError:
        print(""Invalid input format."")
        return

    if a(a, b, s):
        print(""Yes"")
    else:
        print(""No"")

if __name__ == ""__main__"":
    c()"
50,A,Domino piling,PROGRAMMING,"['greedy', 'math']","You are given a rectangular board of *M*<=×<=*N* squares. Also you are given an unlimited number of standard domino pieces of 2<=×<=1 squares. You are allowed to rotate the pieces. You are asked to place as many dominoes as possible on the board so as to meet the following conditions:

1. Each domino completely covers two squares.

2. No two dominoes overlap.

3. Each domino lies entirely inside the board. It is allowed to touch the edges of the board.

Find the maximum number of dominoes, which can be placed under these restrictions.",In a single line you are given two integers *M* and *N* — board sizes in squares (1<=≤<=*M*<=≤<=*N*<=≤<=16).,"Output one number — the maximal number of dominoes, which can be placed.","['2 4\n', '3 3\n']","['4\n', '4\n']",none,WRONG_ANSWER,"""""""
Created on Thu Jan  7 18:06:14 2021

@author: cse1g
""""""
import b

def a(m,n):
    return max((m*(n//2)),(n*(m//2)))
m,n=list(map(int,input().split()))
if m%2==0 and n%2==0:
    c=a(m,n)
elif m%2==0 and n%2!=0:
    c=a(m,(b.floor(n/2))*2)+1
elif m%2!=0 and n%2==0:
    c=a((b.floor(m/2))*2,n)+1
else :
    c=a((b.floor(m/2))*2,(b.floor(n/2))*2)+2
print(c)","import d
import h

def c():

    b = h.stdin.readline().strip()
    if not b:
        return
    m, n = map(int, b.split())
    
    a = 0.0

    f = 0.0
    for i in range(1, m + 1):

        e = d.pow(i / m, n)

        g = e - f
        a += i * g
        f = e

    print(f""{a:.12f}"")

if __name__ == '__main__':
    c()"
900,B,Position in Fraction,PROGRAMMING,"['math', 'number theory']",You have a fraction . You need to find the first occurrence of digit *c* into decimal notation of the fraction after decimal point.,"The first contains three single positive integers *a*, *b*, *c* (1<=≤<=*a*<=&lt;<=*b*<=≤<=105, 0<=≤<=*c*<=≤<=9).","Print position of the first occurrence of digit *c* into the fraction. Positions are numbered from 1 after decimal point. It there is no such position, print -1.","['1 2 0\n', '2 3 7\n']","['2', '-1']","The fraction in the first example has the following decimal notation: <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/896357459a466614a0542f34c9cfb0cef1afc9ed.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>. The first zero stands on second position.

The fraction in the second example has the following decimal notation: <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/130ba579a8276fc53a1917606eee9db58817f28d.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>. There is no digit 7 in decimal notation of the fraction.",WRONG_ANSWER,"from bisect import bisect_left as bl
from bisect import bisect_right as br
import heapq
import math
from collections import *
from functools import l,cmp_to_key
import sys
import f, k
input = f.BytesIO(k.read(0,k.fstat(0).st_size)).readline
 
M = j = 10**9 + 7
def b(n):return sorted(set(l(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))
def e(n):return pow(n, j - 2, j)
 
def g():return [int(i) for i in input().split()]
def m():return input()
def n():return int(input())
def h():return [i for i in input().split()]
def i():return [int(i) for i in input()]

a,b,c = g()
c = str(a/b) + '0'
if '.' not in c:
    print(-1)
    exit()
d = c.index('.')
print(c)
a = 1
for i in range(d + 1,len(c),1):
    if c[i] == str(c):
        print(a)
        exit()
    a += 1","def d(n, m, k):

    def a(f):
        i = 0

        for i in range(1, n + 1):
            i += min(m, f // i)
        return i

    e, b = 1, n * m

    while e < b:
        f = (e + b) // 2
        if a(f) < k:
            e = f + 1
        else:
            b = f
        
    return e

if __name__ == ""__main__"":
    import h

    c = h.stdin.read().split()

    n = int(c[0])
    m = int(c[1])
    k = int(c[2])

    g = d(n, m, k)

    h.stdout.write(str(g))"
863,B,Kayaking,PROGRAMMING,"['brute force', 'greedy', 'sortings']","Vadim is really keen on travelling. Recently he heard about kayaking activity near his town and became very excited about it, so he joined a party of kayakers.

Now the party is ready to start its journey, but firstly they have to choose kayaks. There are 2·*n* people in the group (including Vadim), and they have exactly *n*<=-<=1 tandem kayaks (each of which, obviously, can carry two people) and 2 single kayaks. *i*-th person's weight is *w**i*, and weight is an important matter in kayaking — if the difference between the weights of two people that sit in the same tandem kayak is too large, then it can crash. And, of course, people want to distribute their seats in kayaks in order to minimize the chances that kayaks will crash.

Formally, the instability of a single kayak is always 0, and the instability of a tandem kayak is the absolute difference between weights of the people that are in this kayak. Instability of the whole journey is the total instability of all kayaks.

Help the party to determine minimum possible total instability!","The first line contains one number *n* (2<=≤<=*n*<=≤<=50).

The second line contains 2·*n* integer numbers *w*1, *w*2, ..., *w*2*n*, where *w**i* is weight of person *i* (1<=≤<=*w**i*<=≤<=1000).",Print minimum possible total instability.,"['2\n1 2 3 4\n', '4\n1 3 4 6 3 4 100 200\n']","['1\n', '5\n']",none,OK,"b = float('inf')

def c(A, N):
    A.sort()
    N *= 2
    a = b
    for i in range(N):
        for j in range(i + 1, N):
            B = []
            for k in range(N):
                if k != i and k != j:
                    B.append(A[k])

            d = sum(B[i + 1] - B[i] for i in range(0, N - 2, 2))
            a = min(a, d)
    return a                    

N = int(input())
A = list(map(int, input().split()))
print(c(A, N))","def d():
    import f

    f.setrecursionlimit(3000)

    a = f.stdin.read().strip().split()
    if not a:
        return
    n = int(a[0])

    p = []
    for i in range(1, n + 1):
        p.append(int(a[i]))

    b = [0] * n

    def c(i):

        if b[i] != 0:
            return b[i]

        if p[i] == -1:
            b[i] = 1
        else:

            b[i] = c(p[i] - 1) + 1
        return b[i]

    e = 0
    for i in range(n):
        e = max(e, c(i))

    print(e)

if __name__ == '__main__':
    d()"
38,A,Army,PROGRAMMING,['implementation'],"The Berland Armed Forces System consists of *n* ranks that are numbered using natural numbers from 1 to *n*, where 1 is the lowest rank and *n* is the highest rank.

One needs exactly *d**i* years to rise from rank *i* to rank *i*<=+<=1. Reaching a certain rank *i* having not reached all the previous *i*<=-<=1 ranks is impossible.

Vasya has just reached a new rank of *a*, but he dreams of holding the rank of *b*. Find for how many more years Vasya should serve in the army until he can finally realize his dream.",The first input line contains an integer *n* (2<=≤<=*n*<=≤<=100). The second line contains *n*<=-<=1 integers *d**i* (1<=≤<=*d**i*<=≤<=100). The third input line contains two integers *a* and *b* (1<=≤<=*a*<=&lt;<=*b*<=≤<=*n*). The numbers on the lines are space-separated.,Print the single number which is the number of years that Vasya needs to rise from rank *a* to rank *b*.,"['3\n5 6\n1 2\n', '3\n5 6\n1 3\n']","['5\n', '11\n']",none,OK,"import math
import sys
import itertools

def c(a= int):
  return [a(x) for x in input().split()]

def d(t):
  n = int(input())
  b = c()
  a, b = c()

  print(sum(b[a-1:b-1]))

if __name__ == '__main__':

  d(0)","n = int(input().strip())

a, b, c = 0, 0, 0

for _ in range(n):

    x, y, z = map(int, input().split())

    a += x
    b += y
    c += z

if a == 0 and b == 0 and c == 0:
    print(""YES"")
else:
    print(""NO"")"
757,D,Felicity's Big Secret Revealed,PROGRAMMING,"['bitmasks', 'dp']","The gym leaders were fascinated by the evolutions which took place at Felicity camp. So, they were curious to know about the secret behind evolving Pokemon. 

The organizers of the camp gave the gym leaders a PokeBlock, a sequence of *n* ingredients. Each ingredient can be of type 0 or 1. Now the organizers told the gym leaders that to evolve a Pokemon of type *k* (*k*<=≥<=2), they need to make a valid set of *k* cuts on the PokeBlock to get smaller blocks.

Suppose the given PokeBlock sequence is *b*0*b*1*b*2... *b**n*<=-<=1. You have a choice of making cuts at *n*<=+<=1 places, i.e., Before *b*0, between *b*0 and *b*1, between *b*1 and *b*2, ..., between *b**n*<=-<=2 and *b**n*<=-<=1, and after *b**n*<=-<=1.

The *n*<=+<=1 choices of making cuts are as follows (where a | denotes a possible cut):

Consider a sequence of *k* cuts. Now each pair of consecutive cuts will contain a binary string between them, formed from the ingredient types. The ingredients before the first cut and after the last cut are wasted, which is to say they are not considered. So there will be exactly *k*<=-<=1 such binary substrings. Every substring can be read as a binary number. Let *m* be the maximum number out of the obtained numbers. If all the obtained numbers are positive and the set of the obtained numbers contains all integers from 1 to *m*, then this set of cuts is said to be a valid set of cuts.

For example, suppose the given PokeBlock sequence is 101101001110 and we made 5 cuts in the following way:

So the 4 binary substrings obtained are: 11, 010, 01 and 1, which correspond to the numbers 3, 2, 1 and 1 respectively. Here *m*<==<=3, as it is the maximum value among the obtained numbers. And all the obtained numbers are positive and we have obtained all integers from 1 to *m*. Hence this set of cuts is a valid set of 5 cuts.

A Pokemon of type *k* will evolve only if the PokeBlock is cut using a valid set of *k* cuts. There can be many valid sets of the same size. Two valid sets of *k* cuts are considered different if there is a cut in one set which is not there in the other set.

Let *f*(*k*) denote the number of valid sets of *k* cuts. Find the value of . Since the value of *s* can be very large, output *s* modulo 109<=+<=7.","The input consists of two lines. The first line consists an integer *n* (1<=≤<=*n*<=≤<=75) — the length of the PokeBlock. The next line contains the PokeBlock, a binary string of length *n*.","Output a single integer, containing the answer to the problem, i.e., the value of *s* modulo 109<=+<=7.","['4\n1011\n', '2\n10\n']","['10\n', '1\n']","In the first sample, the sets of valid cuts are:

Size 2: |1|011, 1|01|1, 10|1|1, 101|1|.

Size 3: |1|01|1, |10|1|1, 10|1|1|, 1|01|1|.

Size 4: |10|1|1|, |1|01|1|.

Hence, *f*(2) = 4, *f*(3) = 4 and *f*(4) = 2. So, the value of *s* = 10.

In the second sample, the set of valid cuts is:

Size 2: |1|0.

Hence, *f*(2) = 1 and *f*(3) = 0. So, the value of *s* = 1.",OK,"c = 10**9+7
def a(l, r, e):
    d = 0
    for i in range(l, r + 1):
        d = d * 2 + int(e[i])
    return d
 
def b():
    n, e = int(input()), input()
    e = chr(0)+e
    f = [[0]*(1<<20) for i in range(6)]
    d, r, f[0][0]= 0, 0, 1
    for i in range(1, n+1):
        r=(r+1)%6
        f[r] = [0]*(1<<20)
        for j in range(1, min(5, i) + 1):
            if e[i-j+1] != '0':
                c, p = a(i-j+1, i, e), (r-j+6)%6
                if(c>20 or c<1): break
                for s in range(1<<20):
                    if(f[p][s]):
                        f[r][s|(1<<(c-1))] = (f[r][s|(1<<(c-1))] + f[p][s]) % c
        for s in range(1, 21):
            d = (d + f[r][(1<<s)-1]) % c
        f[r][0] = (f[r][0] + 1) % c
        if(e[i]=='0'):
            p=(r-1+6)%6
            for s in range(1<<20):
                if(f[p][s]):
                    f[r][s] = (f[r][s] + f[p][s]) % c
    print(d)

b()","def c():

    n = int(input().strip())

    f = list(map(int, input().split()))

    a = sum(1 for e in f[:3] if e % 2 == 0)

    d = True if a > 1 else False

    for b, e in enumerate(f):
        if (e % 2 == 0) != d:

            print(b + 1)
            break

if __name__ == ""__main__"":
    c()"
708,A,Letters Cyclic Shift,PROGRAMMING,"['constructive algorithms', 'greedy', 'implementation', 'strings']","You are given a non-empty string *s* consisting of lowercase English letters. You have to pick exactly one non-empty substring of *s* and shift all its letters 'z'  'y'  'x'  'b'  'a'  'z'. In other words, each character is replaced with the previous character of English alphabet and 'a' is replaced with 'z'.

What is the lexicographically minimum string that can be obtained from *s* by performing this shift exactly once?",The only line of the input contains the string *s* (1<=≤<=|*s*|<=≤<=100<=000) consisting of lowercase English letters.,Print the lexicographically minimum string that can be obtained from *s* by shifting letters of exactly one non-empty substring.,"['codeforces\n', 'abacaba\n']","['bncdenqbdr\n', 'aaacaba\n']","String *s* is lexicographically smaller than some other string *t* of the same length if there exists some 1 ≤ *i* ≤ |*s*|, such that *s*<sub class=""lower-index"">1</sub> = *t*<sub class=""lower-index"">1</sub>, *s*<sub class=""lower-index"">2</sub> = *t*<sub class=""lower-index"">2</sub>, ..., *s*<sub class=""lower-index"">*i* - 1</sub> = *t*<sub class=""lower-index"">*i* - 1</sub>, and *s*<sub class=""lower-index"">*i*</sub> &lt; *t*<sub class=""lower-index"">*i*</sub>.",RUNTIME_ERROR,"import math
import string

class a():

    def __init__(g, s):
         g.initial_string = s
         g.final_list = []

    def b(g):
        def i(s):
            if s == ""a"":
                return ""z""
            else:
                return chr(ord(s) - 1)
        d = -1
        c = -1
        e = False
        for i in range(len(g.initial_string)):
            if not e:
                if g.initial_string[i] != ""a"":
                    e = True
                    d = i
                    print(d)
            else:
                if g.initial_string[i] == ""a"":
                    c = i - 1
                    break
                elif i == len(g.initial_string) - 1:
                    c = i
        for i in range(len(g.initial_string)):
            if i < d or i > c:
                print(g.initial_string[i], end="""")
            else:
                print(i(g.initial_string[i]), end="""")

def f():
    s = input()
    h = a(s)
    h.b()

f()

f()","import f

def c():

    n = int(f.stdin.readline().strip())

    b = []

    for _ in range(n):
        d, e = map(int, f.stdin.readline().split())
        b.append((d, e))

    b.sort(key=lambda a: a[0])

    for i in range(n - 1):

        if b[i][1] > b[i+1][1]:
            print(""Happy Alex"")
            return

    print(""Poor Alex"")

if __name__ == ""__main__"":
    c()"
862,B,Mahmoud and Ehab and the bipartiteness,PROGRAMMING,"['dfs and similar', 'graphs', 'trees']","Mahmoud and Ehab continue their adventures! As everybody in the evil land knows, Dr. Evil likes bipartite graphs, especially trees.

A tree is a connected acyclic graph. A bipartite graph is a graph, whose vertices can be partitioned into 2 sets in such a way, that for each edge (*u*,<=*v*) that belongs to the graph, *u* and *v* belong to different sets. You can find more formal definitions of a tree and a bipartite graph in the notes section below.

Dr. Evil gave Mahmoud and Ehab a tree consisting of *n* nodes and asked them to add edges to it in such a way, that the graph is still bipartite. Besides, after adding these edges the graph should be simple (doesn't contain loops or multiple edges). What is the maximum number of edges they can add?

A loop is an edge, which connects a node with itself. Graph doesn't contain multiple edges when for each pair of nodes there is no more than one edge between them. A cycle and a loop aren't the same .","The first line of input contains an integer *n* — the number of nodes in the tree (1<=≤<=*n*<=≤<=105).

The next *n*<=-<=1 lines contain integers *u* and *v* (1<=≤<=*u*,<=*v*<=≤<=*n*, *u*<=≠<=*v*) — the description of the edges of the tree.

It's guaranteed that the given graph is a tree.",Output one integer — the maximum number of edges that Mahmoud and Ehab can add to the tree while fulfilling the conditions.,"['3\n1 2\n1 3\n', '5\n1 2\n2 3\n3 4\n4 5\n']","['0\n', '2\n']","Tree definition: [https://en.wikipedia.org/wiki/Tree_(graph_theory)](https://en.wikipedia.org/wiki/Tree_(graph_theory))

Bipartite graph definition: [https://en.wikipedia.org/wiki/Bipartite_graph](https://en.wikipedia.org/wiki/Bipartite_graph)

In the first test case the only edge that can be added in such a way, that graph won't contain loops or multiple edges is (2, 3), but adding this edge will make the graph non-bipartite so the answer is 0.

In the second test case Mahmoud and Ehab can add edges (1, 4) and (2, 5).",WRONG_ANSWER,"from i import a

def f():
    n = int(input())
    e = {}

    for _ in range(n - 1):
        u, v = map(int, input().split())

        if u not in e:
            e[u] = [v]
        else:
            e[u].append(v)

        if v not in e:
            e[v] = [u]
        else:
            e[v].append(u)

    b = [0 for i in range(1, n + 1)]
    i = a()
    i.put(1)
    c = 0
    j = [False for i in range(1, n + 1)]
    while not i.empty():
        d = i.get()
        j[d - 1] = True
        b[d - 1] = c

        for g in e[d]:
            if not j[g - 1]:
                i.put(g)

        c = 1 - c

    k = b.count(0)
    h = n - k

    print(k * h - (n - 1))

if __name__ == ""__main__"":
    f()","def b(e):
    if e < 2:
        return False

    for i in range(2, int(e**0.5) + 1):
        if e % i == 0:
            return False
    return True

def d(x):
    a = x + 1

    while not b(a):
        a += 1
    return a

def c():

    n, m = map(int, input().split())

    if m == d(n):
        print(""YES"")
    else:
        print(""NO"")

if __name__ == ""__main__"":
    c()"
498,C,Array and Operations,PROGRAMMING,"['flows', 'graph matchings', 'number theory']","You have written on a piece of paper an array of *n* positive integers *a*[1],<=*a*[2],<=...,<=*a*[*n*] and *m* good pairs of integers (*i*1,<=*j*1),<=(*i*2,<=*j*2),<=...,<=(*i**m*,<=*j**m*). Each good pair (*i**k*,<=*j**k*) meets the following conditions: *i**k*<=+<=*j**k* is an odd number and 1<=≤<=*i**k*<=&lt;<=*j**k*<=≤<=*n*.

In one operation you can perform a sequence of actions: 
 -  take one of the good pairs (*i**k*,<=*j**k*) and some integer *v* (*v*<=&gt;<=1), which divides both numbers *a*[*i**k*] and *a*[*j**k*]; -  divide both numbers by *v*, i. e. perform the assignments:  and . 
Determine the maximum number of operations you can sequentially perform on the given array. Note that one pair may be used several times in the described operations.","The first line contains two space-separated integers *n*, *m* (2<=≤<=*n*<=≤<=100, 1<=≤<=*m*<=≤<=100).

The second line contains *n* space-separated integers *a*[1],<=*a*[2],<=...,<=*a*[*n*] (1<=≤<=*a*[*i*]<=≤<=109) — the description of the array.

The following *m* lines contain the description of good pairs. The *k*-th line contains two space-separated integers *i**k*, *j**k* (1<=≤<=*i**k*<=&lt;<=*j**k*<=≤<=*n*, *i**k*<=+<=*j**k* is an odd number).

It is guaranteed that all the good pairs are distinct.",Output the answer for the problem.,"['3 2\n8 3 8\n1 2\n2 3\n', '3 2\n8 12 8\n1 2\n2 3\n']","['0\n', '2\n']",none,WRONG_ANSWER,"from fractions import b

def h(f, g):
    c = 0
    for i in g:
        while f % i == 0:
            c += 1
            f //= i
        if f == 1:
            break
    if f == 1:
        return c
    else:
        return c + 1

j = [(i % 2 == 1) for i in range(31622)]
j[0] = j[1] = False
j[2] = True
for i in range(2, int(31622 ** .5) + 1):
    if not j[i]:
        continue
    for j in range(i * i, 31622):
        j[j] = False
g = [i for i in range(31622) if j[i]]

e = input().split()
n = int(e[0])
m = int(e[1])

a = [int(f) for f in input().split()]
a = 0
for i in range(m):
    e = input().split()
    c = int(e[0]) - 1
    d = int(e[1]) - 1
    g = b(a[c], a[d])
    a[c] //= g
    a[d] //= g
    a += h(g, g)

print(str(a))","def h():
    import j

    c = j.stdin.read().split()
    n = int(c[0])
    f = int(c[1])
    
    a = 0
    b = []
    
    g = 2
    for _ in range(n):
        k = int(c[g])
        l = int(c[g + 1])
        g += 2

        i = min(k, l)
        a += i

        d = min(2 * k, l)

        e = d - i
        b.append(e)

    b.sort(reverse=True)
    f = sum(b[:f])

    print(a + f)

if __name__ == ""__main__"":
    h()"
161,D,Distance in Tree,PROGRAMMING,"['dfs and similar', 'dp', 'trees']","A tree is a connected graph that doesn't contain any cycles.

The distance between two vertices of a tree is the length (in edges) of the shortest path between these vertices.

You are given a tree with *n* vertices and a positive number *k*. Find the number of distinct pairs of the vertices which have a distance of exactly *k* between them. Note that pairs (*v*, *u*) and (*u*, *v*) are considered to be the same pair.","The first line contains two integers *n* and *k* (1<=≤<=*n*<=≤<=50000, 1<=≤<=*k*<=≤<=500) — the number of vertices and the required distance between the vertices.

Next *n*<=-<=1 lines describe the edges as ""*a**i* *b**i*"" (without the quotes) (1<=≤<=*a**i*,<=*b**i*<=≤<=*n*, *a**i*<=≠<=*b**i*), where *a**i* and *b**i* are the vertices connected by the *i*-th edge. All given edges are different.","Print a single integer — the number of distinct pairs of the tree's vertices which have a distance of exactly *k* between them.

Please do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.","['5 2\n1 2\n2 3\n3 4\n2 5\n', '5 3\n1 2\n2 3\n3 4\n4 5\n']","['4\n', '2\n']","In the first sample the pairs of vertexes at distance 2 from each other are (1, 3), (1, 5), (3, 5) and (2, 4).",TIME_LIMIT_EXCEEDED,"n, k = map(int, input().split())

d=[[] for _ in range(50010)]
for i in range(n-1):
    a,b=map(int,input().split())
    d[a].append(b)
    d[b].append(a)

c=[[0]*505 for _ in range(50010)]
a=0

def b(e,d):
    global a
    c[e][0]=1
    for i in range(len(d[e])):
        f=d[e][i]
        if f!=d:
            b(f,e)
            for j in range(k):
                a += c[f][j] * c[e][k - 1 - j]
            for j in range(1,k+1):
                c[e][j] += c[f][j - 1]

b(1,0)
print(a)","def a():

    x = int(input().strip())

    b = x // 5

    if x % 5 > 0:
        b += 1

    print(b)

if __name__ == ""__main__"":
    a()"
165,A,Supercentral Point,PROGRAMMING,['implementation'],"One day Vasya painted a Cartesian coordinate system on a piece of paper and marked some set of points (*x*1,<=*y*1),<=(*x*2,<=*y*2),<=...,<=(*x**n*,<=*y**n*). Let's define neighbors for some fixed point from the given set (*x*,<=*y*): 
 -  point (*x*',<=*y*') is (*x*,<=*y*)'s right neighbor, if *x*'<=&gt;<=*x* and *y*'<==<=*y* -  point (*x*',<=*y*') is (*x*,<=*y*)'s left neighbor, if *x*'<=&lt;<=*x* and *y*'<==<=*y* -  point (*x*',<=*y*') is (*x*,<=*y*)'s lower neighbor, if *x*'<==<=*x* and *y*'<=&lt;<=*y* -  point (*x*',<=*y*') is (*x*,<=*y*)'s upper neighbor, if *x*'<==<=*x* and *y*'<=&gt;<=*y* 
We'll consider point (*x*,<=*y*) from the given set supercentral, if it has at least one upper, at least one lower, at least one left and at least one right neighbor among this set's points.

Vasya marked quite many points on the paper. Analyzing the picture manually is rather a challenge, so Vasya asked you to help him. Your task is to find the number of supercentral points in the given set.","The first input line contains the only integer *n* (1<=≤<=*n*<=≤<=200) — the number of points in the given set. Next *n* lines contain the coordinates of the points written as ""*x* *y*"" (without the quotes) (|*x*|,<=|*y*|<=≤<=1000), all coordinates are integers. The numbers in the line are separated by exactly one space. It is guaranteed that all points are different.",Print the only number — the number of supercentral points of the given set.,"['8\n1 1\n4 2\n3 1\n1 2\n0 2\n0 1\n1 0\n1 3\n', '5\n0 0\n0 1\n1 0\n0 -1\n-1 0\n']","['2\n', '1\n']","In the first sample the supercentral points are only points (1, 1) and (1, 2).

In the second sample there is one supercental point — point (0, 0).",WRONG_ANSWER,"from sys import stdin,stdout

def b():

    t = 1
    for z in range(t):
        n = int(input())

        h = [list(map(int,input().split())) for i in range(n)]
        c = 10**7
        f = [c]*2000
        k = [c]*2000
        g = [c]*2000
        l = [c]*2000
        for i in range(n):
            f[h[i][0]] = min(f[h[i][0]],h[i][1])
            g[h[i][0]] = max(g[h[i][0]],h[i][1])
            k[h[i][1]] = min(k[h[i][1]],h[i][0])
            l[h[i][1]] = max(l[h[i][1]],h[i][0])
        a = 0
        for i in range(n):
            x,y = h[i][0],h[i][1]
            d,i,e,j = k[y],f[x],l[y],g[x]
            if x < e and x > d and y < j and y > i:
                a += 1

        print(a)
b()","def f():
    import j

    d = j.stdin.read().strip().split()
    if not d:
        return

    n = int(d[0])

    a = list(map(int, d[1:]))

    b = a.count(100)
    c = a.count(200)

    k = b * 100 + c * 200

    if k % 200 != 0:
        print(""NO"")
        return

    e = k // 2

    h = False
    for g in range(c + 1):
        l = g * 200
        if l > e:

            break
        i = e - l

        if i % 100 == 0 and (i // 100) <= b:
            h = True
            break

    print(""YES"" if h else ""NO"")

if __name__ == '__main__':
    f()"
573,A,Bear and Poker,PROGRAMMING,"['implementation', 'math', 'number theory']","Limak is an old brown bear. He often plays poker with his friends. Today they went to a casino. There are *n* players (including Limak himself) and right now all of them have bids on the table. *i*-th of them has bid with size *a**i* dollars.

Each player can double his bid any number of times and triple his bid any number of times. The casino has a great jackpot for making all bids equal. Is it possible that Limak and his friends will win a jackpot?","First line of input contains an integer *n* (2<=≤<=*n*<=≤<=105), the number of players.

The second line contains *n* integer numbers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=109) — the bids of players.","Print ""Yes"" (without the quotes) if players can make their bids become equal, or ""No"" otherwise.","['4\n75 150 75 50\n', '3\n100 150 250\n']","['Yes\n', 'No\n']","In the first sample test first and third players should double their bids twice, second player should double his bid once and fourth player should both double and triple his bid.

It can be shown that in the second sample test there is no way to make all bids equal.",OK,"def b(x, y):
	if y == 0: return x
	return b(y, x%y)

def c(x):
	m = x
	while m % 2 == 0:
		m //= 2
	while m % 3 == 0:
		m //= 3
	return m == 1

N = int(input())
A = list(map(int, input().split()))
A.sort()
a = 'Yes'
for i in range(0, N-1):
	X = A[i]*A[N-1]//b(A[i], A[N-1])
	if not c(X//b(A[i], A[N-1])):
		a = 'No'
		break
print(a)","import g

def e():

    n, m, k = map(int, g.stdin.readline().split())

    c = [[False] * (m + 2) for _ in range(n + 2)]

    for f in range(1, k + 1):
        d = g.stdin.readline()
        if not d:
            break
        i, j = map(int, d.split())
        c[i][j] = True

        for a in (-1, 0):
            for b in (-1, 0):
                h, i = i + a, j + b

                if 1 <= h <= n - 1 and 1 <= i <= m - 1:
                    if c[h][i] and c[h][i + 1] and c[h + 1][i] and c[h + 1][i + 1]:
                        g.stdout.write(str(f))
                        return

    g.stdout.write(""0"")

if __name__ == '__main__':
    e()"
169,A,Chores,PROGRAMMING,['sortings'],"Petya and Vasya are brothers. Today is a special day for them as their parents left them home alone and commissioned them to do *n* chores. Each chore is characterized by a single parameter — its complexity. The complexity of the *i*-th chore equals *h**i*.

As Petya is older, he wants to take the chores with complexity larger than some value *x* (*h**i*<=&gt;<=*x*) to leave to Vasya the chores with complexity less than or equal to *x* (*h**i*<=≤<=*x*). The brothers have already decided that Petya will do exactly *a* chores and Vasya will do exactly *b* chores (*a*<=+<=*b*<==<=*n*).

In how many ways can they choose an integer *x* so that Petya got exactly *a* chores and Vasya got exactly *b* chores?","The first input line contains three integers *n*,<=*a* and *b* (2<=≤<=*n*<=≤<=2000; *a*,<=*b*<=≥<=1; *a*<=+<=*b*<==<=*n*) — the total number of chores, the number of Petya's chores and the number of Vasya's chores.

The next line contains a sequence of integers *h*1,<=*h*2,<=...,<=*h**n* (1<=≤<=*h**i*<=≤<=109), *h**i* is the complexity of the *i*-th chore. The numbers in the given sequence are not necessarily different.

All numbers on the lines are separated by single spaces.","Print the required number of ways to choose an integer value of *x*. If there are no such ways, print 0.","['5 2 3\n6 2 3 100 1\n', '7 3 4\n1 1 9 1 1 1 1\n']","['3\n', '0\n']","In the first sample the possible values of *x* are 3, 4 or 5.

In the second sample it is impossible to find such *x*, that Petya got 3 chores and Vasya got 4.",RUNTIME_ERROR,"def a(n,a,b,b):
    b = f(n,b)
    e = b[a+1] - b[a]
    print(e)
def f(n,s):
    for i in range(0,n):
        for j in range(0,n):
            if(s[i] < s[j]):
                t = s[i]
                s[i] = s[j]
                s[j] = t
    return s
c = [int(i) for i in input().split()]
d = [int(i) for i in input().split()]
a(c[0],c[1],c[2],d)","def c():
    import f
    b = f.stdin.read().strip().splitlines()
    n = int(b[0])

    a = None
    d = None

    for i in range(n):
        e = b[i + 1]
        for j in range(n):
            if i == j or i + j == n - 1:
                if a is None:
                    a = e[j]
                elif e[j] != a:
                    print(""NO"")
                    return
            else:
                if d is None:
                    d = e[j]
                elif e[j] != d:
                    print(""NO"")
                    return

    if a == d:
        print(""NO"")
    else:
        print(""YES"")

if __name__ == ""__main__"":
    c()"
302,B,Eugeny and Play List,PROGRAMMING,"['binary search', 'implementation', 'two pointers']","Eugeny loves listening to music. He has *n* songs in his play list. We know that song number *i* has the duration of *t**i* minutes. Eugeny listens to each song, perhaps more than once. He listens to song number *i* *c**i* times. Eugeny's play list is organized as follows: first song number 1 plays *c*1 times, then song number 2 plays *c*2 times, ..., in the end the song number *n* plays *c**n* times.

Eugeny took a piece of paper and wrote out *m* moments of time when he liked a song. Now for each such moment he wants to know the number of the song that played at that moment. The moment *x* means that Eugeny wants to know which song was playing during the *x*-th minute of his listening to the play list.

Help Eugeny and calculate the required numbers of songs.","The first line contains two integers *n*, *m* (1<=≤<=*n*,<=*m*<=≤<=105). The next *n* lines contain pairs of integers. The *i*-th line contains integers *c**i*,<=*t**i* (1<=≤<=*c**i*,<=*t**i*<=≤<=109) — the description of the play list. It is guaranteed that the play list's total duration doesn't exceed 109 .

The next line contains *m* positive integers *v*1,<=*v*2,<=...,<=*v**m*, that describe the moments Eugeny has written out. It is guaranteed that there isn't such moment of time *v**i*, when the music doesn't play any longer. It is guaranteed that *v**i*<=&lt;<=*v**i*<=+<=1 (*i*<=&lt;<=*m*).

The moment of time *v**i* means that Eugeny wants to know which song was playing during the *v**i*-th munite from the start of listening to the playlist.",Print *m* integers — the *i*-th number must equal the number of the song that was playing during the *v**i*-th minute after Eugeny started listening to the play list.,"['1 2\n2 8\n1 16\n', '4 9\n1 2\n2 1\n1 1\n2 2\n1 2 3 4 5 6 7 8 9\n']","['1\n1\n', '1\n1\n2\n2\n3\n4\n4\n4\n4\n']",none,MEMORY_LIMIT_EXCEEDED,"def b():
    n, m = map(int, input().split())

    a = []
    for i in range(n):
        c, t = map(int, input().split())
        a = a + [(i + 1)]* (c * t)

    for j in input().split():
        print(a[int(j)-1])

if __name__ == '__main__':
    b()","import h
import f

def e():

    b = h.stdin.read().split()
    if not b:
        return
    n = int(b[0])
    k = int(b[1])

    g = []
    c = []

    d = f.isqrt(n)
    for i in range(1, d + 1):
        if n % i == 0:
            g.append(i)

            if i != n // i:
                c.append(n // i)

    a = g + c[::-1]

    if k > len(a):
        print(-1)
    else:

        print(a[k - 1])

if __name__ == ""__main__"":
    e()"
704,A,Thor,PROGRAMMING,"['brute force', 'data structures', 'implementation']","Thor is getting used to the Earth. As a gift Loki gave him a smartphone. There are *n* applications on this phone. Thor is fascinated by this phone. He has only one minor issue: he can't count the number of unread notifications generated by those applications (maybe Loki put a curse on it so he can't).

*q* events are about to happen (in chronological order). They are of three types:
 1.  Application *x* generates a notification (this new notification is unread). 1.  Thor reads all notifications generated so far by application *x* (he may re-read some notifications). 1.  Thor reads the first *t* notifications generated by phone applications (notifications generated in first *t* events of the first type). It's guaranteed that there were at least *t* events of the first type before this event. Please note that he doesn't read first *t* unread notifications, he just reads the very first *t* notifications generated on his phone and he may re-read some of them in this operation. 
Please help Thor and tell him the number of unread notifications after each event. You may assume that initially there are no notifications in the phone.","The first line of input contains two integers *n* and *q* (1<=≤<=*n*,<=*q*<=≤<=300<=000) — the number of applications and the number of events to happen.

The next *q* lines contain the events. The *i*-th of these lines starts with an integer *type**i* — type of the *i*-th event. If *type**i*<==<=1 or *type**i*<==<=2 then it is followed by an integer *x**i*. Otherwise it is followed by an integer *t**i* (1<=≤<=*type**i*<=≤<=3,<=1<=≤<=*x**i*<=≤<=*n*,<=1<=≤<=*t**i*<=≤<=*q*).",Print the number of unread notifications after each event.,"['3 4\n1 3\n1 1\n1 2\n2 3\n', '4 6\n1 2\n1 4\n1 2\n3 3\n1 3\n1 3\n']","['1\n2\n3\n2\n', '1\n2\n3\n0\n1\n2\n']","In the first sample:
 1.  Application 3 generates a notification (there is 1 unread notification). 1.  Application 1 generates a notification (there are 2 unread notifications). 1.  Application 2 generates a notification (there are 3 unread notifications). 1.  Thor reads the notification generated by application 3, there are 2 unread notifications left. 
In the second sample test:
 1.  Application 2 generates a notification (there is 1 unread notification). 1.  Application 4 generates a notification (there are 2 unread notifications). 1.  Application 2 generates a notification (there are 3 unread notifications). 1.  Thor reads first three notifications and since there are only three of them so far, there will be no unread notification left. 1.  Application 3 generates a notification (there is 1 unread notification). 1.  Application 3 generates a notification (there are 2 unread notifications).",WRONG_ANSWER,"from collections import d
n, q = map(int, input().split())
c = d(list)
j = []
i = 0
h = 0
for _ in range(q):
    e, b = map(int, input().split())
    if e == 1:
        c[b].append(False)
        j.append([b, len(c[b]) - 1])
        i += 1
    elif e == 2:
        for i in range(len(c[b])):
            k = len(list(filter(lambda x: x == False, c[b])))
            c[b] = [True] * len(c[b])
            i -= k
            h += k
    elif e == 3:
        g = b
        for i in range(h - 1, g - h):
            a, f = j[i]
            if not c[a][f]:
                c[a][f] = True
                i -= 1
                h += 1
    print(i)","import b
import a

l, r = map(int, b.stdin.readline().split())

if r - l < 2:
    print(-1)
    b.exit(0)

for a in range(l, r - 1):
    if a % 2 == 0 and a + 2 <= r:
        b = a + 1
        c = a + 2

        if a.gcd(a, c) != 1:
            print(a, b, c)
            break
else:

    print(-1)"
715,B,Complete The Graph,PROGRAMMING,"['binary search', 'constructive algorithms', 'graphs', 'shortest paths']","ZS the Coder has drawn an undirected graph of *n* vertices numbered from 0 to *n*<=-<=1 and *m* edges between them. Each edge of the graph is weighted, each weight is a positive integer.

The next day, ZS the Coder realized that some of the weights were erased! So he wants to reassign positive integer weight to each of the edges which weights were erased, so that the length of the shortest path between vertices *s* and *t* in the resulting graph is exactly *L*. Can you help him?","The first line contains five integers *n*,<=*m*,<=*L*,<=*s*,<=*t* (2<=≤<=*n*<=≤<=1000,<=<=1<=≤<=*m*<=≤<=10<=000,<=<=1<=≤<=*L*<=≤<=109,<=<=0<=≤<=*s*,<=*t*<=≤<=*n*<=-<=1,<=<=*s*<=≠<=*t*) — the number of vertices, number of edges, the desired length of shortest path, starting vertex and ending vertex respectively.

Then, *m* lines describing the edges of the graph follow. *i*-th of them contains three integers, *u**i*,<=*v**i*,<=*w**i* (0<=≤<=*u**i*,<=*v**i*<=≤<=*n*<=-<=1,<=<=*u**i*<=≠<=*v**i*,<=<=0<=≤<=*w**i*<=≤<=109). *u**i* and *v**i* denote the endpoints of the edge and *w**i* denotes its weight. If *w**i* is equal to 0 then the weight of the corresponding edge was erased.

It is guaranteed that there is at most one edge between any pair of vertices.","Print ""NO"" (without quotes) in the only line if it's not possible to assign the weights in a required way.

Otherwise, print ""YES"" in the first line. Next *m* lines should contain the edges of the resulting graph, with weights assigned to edges which weights were erased. *i*-th of them should contain three integers *u**i*, *v**i* and *w**i*, denoting an edge between vertices *u**i* and *v**i* of weight *w**i*. The edges of the new graph must coincide with the ones in the graph from the input. The weights that were not erased must remain unchanged whereas the new weights can be any positive integer not exceeding 1018. 

The order of the edges in the output doesn't matter. The length of the shortest path between *s* and *t* must be equal to *L*.

If there are multiple solutions, print any of them.","['5 5 13 0 4\n0 1 5\n2 1 2\n3 2 3\n1 4 0\n4 3 4\n', '2 1 123456789 0 1\n0 1 0\n', '2 1 999999999 1 0\n0 1 1000000000\n']","['YES\n0 1 5\n2 1 2\n3 2 3\n1 4 8\n4 3 4\n', 'YES\n0 1 123456789\n', 'NO\n']","Here's how the graph in the first sample case looks like :

In the first sample case, there is only one missing edge weight. Placing the weight of 8 gives a shortest path from 0 to 4 of length 13.

In the second sample case, there is only a single edge. Clearly, the only way is to replace the missing weight with 123456789.

In the last sample case, there is no weights to assign but the length of the shortest path doesn't match the required value, so the answer is ""NO"".",OK,"import r
import {
import 
from math import t
from types import b

c = {.randint(1, 10 ** 9)

class a:
    def __init__():
        return

    @staticmethod
    def ():
        return .stdin.readline()

    def ~():
        return int(.())

    def |():
        return float(.())

    def ():
        return map(int, .().split())

    def }():
        return map(float, .().split())

    def ():
        return map(lambda x: int(x) - 1, .().split())

    def ():
        return list(map(int, .().split()))

    def ():
        return list(map(float, .().split()))

    def ():
        return list(map(lambda x: int(x) - 1, .().split()))

    def ():
        return .().split()

    def ():
        return list(.())

    @staticmethod
    def (x):
        return print(x)

    @staticmethod
    def v(x):
        return print(*x)

    @staticmethod
    def (f):
         = int(f)
        if f -  >= 0.5:
             += 1
        return 

    @staticmethod
    def max(a, b):
        return a if a > b else b

    @staticmethod
    def min(a, b):
        return a if a < b else b

    @staticmethod
    def k(f, z=[]):
        def (*h, **u):
            if z:
                return f(*h, **u)
            else:
                 = f(*h, **u)
                while True:
                    if isinstance(, b):
                        z.append()
                         = next()
                    else:
                        z.pop()
                        if not z:
                            break
                         = z[-1].send()
                return 

        return 

    def i(, v):
        .v(v)
        .stdout.flush()
         = .~()
        return 

    @staticmethod
    def g(x):
        n = len(x)
        y = [0] * (n + 1)
        for i in range(n):
            y[i + 1] = y[i] + x[i]
        return y

class e(int):

    def __init__(, x):
        int.__init__(x)

    def __hash__():

        return super(e, ).__hash__() ^ c

class d:
    def __init__():
        return

    @staticmethod
    def w(f=a()):
        n, m, , , m = f.()
        q = []
        l = [[] for _ in range(n)]
        j = [0] * m
        for s in range(m):
            i, j, w = f.()
            if w == 0:
                w = 1
                j[s] = 1
            q.append([i, j, w])
            l[i].append([s, j])
            l[j].append([s, i])

        n = [t] * n
         = [[0, ]]
        n[] = 0
        while :
            d, i = r.heappop()
            if n[i] < d:
                continue
            for s, j in l[i]:
                p = q[s][2] + d
                if p < n[j]:
                    n[j] = p
                    r.heappush(, [p, j])
        if n[m] > :
            f.(""NO"")
            return

        o = [t] * n
         = [[0, ]]
        o[] = 0
        while :
            d, i = r.heappop()
            if o[i] < d:
                continue
            for s, j in l[i]:
                if j[s]:

                    if (q[s][2] + o[i]) + (n[m] - n[j]) < :

                        x =  - (q[s][2] + o[i]) - (n[m] - n[j])
                        q[s][2] += x
                    j[s] = 0
                p = q[s][2] + d
                if p < o[j]:
                    o[j] = p
                    r.heappush(, [p, j])

        if o[m] == :
            f.(""YES"")
            for e in q:
                f.v(e)
        else:
            f.(""NO"")
        return

d().w()","def a(d):
    """"""
    Abbreviates a word if it's too long (more than 10 characters).
    Otherwise, returns the word unchanged.
    """"""
    if len(d) > 10:

        b = len(d) - 2

        return f""{d[0]}{b}{d[-1]}""
    else:
        return d

def c():

    n = int(input().strip())

    for _ in range(n):
        d = input().strip()
        print(a(d))

if __name__ == ""__main__"":
    c()"
58,A,Chat room,PROGRAMMING,"['greedy', 'strings']","Vasya has recently learned to type and log on to the Internet. He immediately entered a chat room and decided to say hello to everybody. Vasya typed the word *s*. It is considered that Vasya managed to say hello if several letters can be deleted from the typed word so that it resulted in the word ""hello"". For example, if Vasya types the word ""ahhellllloou"", it will be considered that he said hello, and if he types ""hlelo"", it will be considered that Vasya got misunderstood and he didn't manage to say hello. Determine whether Vasya managed to say hello by the given word *s*.","The first and only line contains the word *s*, which Vasya typed. This word consisits of small Latin letters, its length is no less that 1 and no more than 100 letters.","If Vasya managed to say hello, print ""YES"", otherwise print ""NO"".","['ahhellllloou\n', 'hlelo\n']","['YES\n', 'NO\n']",none,RUNTIME_ERROR,"def a(b):
    if len(b)<=5:
        print(""NO"")
    else:
        c = ""helloo""
        j = 0
        for i in b:
            if i == c[j] and j<=5:
                j+=1
        if j >= 4:
            print(""YES"")
        else:
            print(""NO"")
    
b = input()
a(b)","def c():
    import d

    a = d.stdin.read().splitlines()

    for s in a:
        b = []
        i = 0
        while i < len(s):
            if s[i] == '.':

                b.append('0')
                i += 1
            else:

                if i + 1 < len(s) and s[i+1] == '.':

                    b.append('1')
                    i += 2
                else:

                    b.append('2')
                    i += 2

        print(''.join(b))

if __name__ == '__main__':
    c()"
0,none,none,none,['none'],"Polycarp has interviewed Oleg and has written the interview down without punctuation marks and spaces to save time. Thus, the interview is now a string *s* consisting of *n* lowercase English letters.

There is a filler word ogo in Oleg's speech. All words that can be obtained from ogo by adding go several times to the end of it are also considered to be fillers. For example, the words ogo, ogogo, ogogogo are fillers, but the words go, og, ogog, ogogog and oggo are not fillers.

The fillers have maximal size, for example, for ogogoo speech we can't consider ogo a filler and goo as a normal phrase. We should consider ogogo as a filler here.

To print the interview, Polycarp has to replace each of the fillers with three asterisks. Note that a filler word is replaced with exactly three asterisks regardless of its length.

Polycarp has dealt with this problem in no time. Can you do the same? The clock is ticking!","The first line contains a positive integer *n* (1<=≤<=*n*<=≤<=100) — the length of the interview.

The second line contains the string *s* of length *n*, consisting of lowercase English letters.","Print the interview text after the replacement of each of the fillers with ""***"". It is allowed for the substring ""***"" to have several consecutive occurences.","['7\naogogob\n', '13\nogogmgogogogo\n', '9\nogoogoogo\n']","['a***b\n', '***gmg***\n', '*********\n']","The first sample contains one filler word ogogo, so the interview for printing is ""a***b"".

The second sample contains two fillers ogo and ogogogo. Thus, the interview is transformed to ""***gmg***"".",OK,"import b
def c(s):
  return b.sub(r'ogo(?:go)*','***',s)
      

def a() :
  n = input()
  s = input()

  print(c(s))
a()","def f():
    import l

    d = l.stdin.read().split()

    n = int(d[0])
    m = int(d[1])

    b = [False] * (n + 1)
    a = [False] * (n + 1)

    h = 0
    g = 0

    i = []

    e = 2
    for _ in range(m):

        j = int(d[e])
        c = int(d[e + 1])
        e += 2

        if not b[j]:
            b[j] = True
            h += 1

        if not a[c]:
            a[c] = True
            g += 1

        k = (n - h) * (n - g)
        i.append(str(k))

    l.stdout.write("" "".join(i) + ""\n"")

if __name__ == ""__main__"":
    f()"
991,B,Getting an A,PROGRAMMING,"['greedy', 'sortings']","Translator's note: in Russia's most widespread grading system, there are four grades: 5, 4, 3, 2, the higher the better, roughly corresponding to A, B, C and F respectively in American grading system.

The term is coming to an end and students start thinking about their grades. Today, a professor told his students that the grades for his course would be given out automatically  — he would calculate the simple average (arithmetic mean) of all grades given out for lab works this term and round to the nearest integer. The rounding would be done in favour of the student — $4.5$ would be rounded up to $5$ (as in example 3), but $4.4$ would be rounded down to $4$.

This does not bode well for Vasya who didn't think those lab works would influence anything, so he may receive a grade worse than $5$ (maybe even the dreaded $2$). However, the professor allowed him to redo some of his works of Vasya's choosing to increase his average grade. Vasya wants to redo as as few lab works as possible in order to get $5$ for the course. Of course, Vasya will get $5$ for the lab works he chooses to redo.

Help Vasya — calculate the minimum amount of lab works Vasya has to redo.","The first line contains a single integer $n$ — the number of Vasya's grades ($1 \leq n \leq 100$).

The second line contains $n$ integers from $2$ to $5$ — Vasya's grades for his lab works.",Output a single integer — the minimum amount of lab works that Vasya has to redo. It can be shown that Vasya can always redo enough lab works to get a $5$.,"['3\n4 4 4\n', '4\n5 4 5 5\n', '4\n5 3 3 5\n']","['2\n', '0\n', '1\n']","In the first sample, it is enough to redo two lab works to make two $4$s into $5$s.

In the second sample, Vasya's average is already $4.75$ so he doesn't have to redo anything to get a $5$.

In the second sample Vasya has to redo one lab work to get rid of one of the $3$s, that will make the average exactly $4.5$ so the final grade would be $5$.",OK,"from sys import *

def c():
    n = int(e.readline())
    f = 4.5*n
    a = 0
    d = 0
    b = [int(x) for x in e.readline().split()]
    for x in b:
        a+=x
    b.sort()
    while(a < f):
        a+=(5-b[d])
        d += 1
    print(d)

if __name__ == '__main__':
    c()","import s
from collections import e

def l():
    j = s.stdin.read().splitlines()
    if not j:
        return

    n, m = map(int, j[0].split())
    i = [list(k.strip()) for k in j[1:1+n]]

    b = [[-1] * m for _ in range(n)]
    c = []

    f = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    
    d = 0

    for i in range(n):
        for j in range(m):
            if i[i][j] == '.' and b[i][j] == -1:

                q = e()
                q.append((i, j))
                b[i][j] = d
                r = 1
                while q:
                    x, y = q.popleft()

                    for g, h in f:
                        m, n = x + g, y + h
                        if 0 <= m < n and 0 <= n < m:
                            if i[m][n] == '.' and b[m][n] == -1:
                                b[m][n] = d
                                r += 1
                                q.append((m, n))

                c.append(r)
                d += 1

    o = []
    
    for i in range(n):
        p = []
        for j in range(m):

            if i[i][j] == '.':
                p.append('.')
            else:

                q = set()
                t = 1

                for g, h in f:
                    m, n = i + g, j + h
                    if 0 <= m < n and 0 <= n < m:
                        a = b[m][n]
                        if a != -1 and a not in q:
                            q.add(a)
                            t += c[a]

                p.append(str(t % 10))
        o.append(''.join(p))

    s.stdout.write('\n'.join(o))
    
if __name__ == ""__main__"":
    l()"
722,A,Broken Clock,PROGRAMMING,"['brute force', 'implementation']","You are given a broken clock. You know, that it is supposed to show time in 12- or 24-hours HH:MM format. In 12-hours format hours change from 1 to 12, while in 24-hours it changes from 0 to 23. In both formats minutes change from 0 to 59.

You are given a time in format HH:MM that is currently displayed on the broken clock. Your goal is to change minimum number of digits in order to make clocks display the correct time in the given format.

For example, if 00:99 is displayed, it is enough to replace the second 9 with 3 in order to get 00:39 that is a correct time in 24-hours format. However, to make 00:99 correct in 12-hours format, one has to change at least two digits. Additionally to the first change one can replace the second 0 with 1 and obtain 01:39.","The first line of the input contains one integer 12 or 24, that denote 12-hours or 24-hours format respectively.

The second line contains the time in format HH:MM, that is currently displayed on the clock. First two characters stand for the hours, while next two show the minutes.",The only line of the output should contain the time in format HH:MM that is a correct time in the given format. It should differ from the original in as few positions as possible. If there are many optimal solutions you can print any of them.,"['24\n17:30\n', '12\n17:30\n', '24\n99:99\n']","['17:30\n', '07:30\n', '09:09\n']",none,WRONG_ANSWER,"def d(g, e, f):

    a = int(e[0])
    j = int(e[1])

    b = int(f[0])
    k = int(f[1])

    h = 10 * int(a) + int(j)
    i = 10 * int(b) + int(k)

    if(g == 24 and h > 23):
        a = 0

    if(g == 12 and h > 12):
        if(j != 0):
            a = 0
        else:
            a = 1

    elif(g == 12 and e == 0):
        a = 1

    if(i > 59):
        b = 0

    return ""{}{}:{}{}"".format(a, j, b, k)

g = int(input())
c = input().split("":"")

e = c[0]
f = c[1]

print(d(g, e, f))","def a(n, h, c):

    e = 0

    for b in c:

        if b > h:
            e += 2
        else:

            e += 1
            
    return e

if __name__ == ""__main__"":

    n, h = map(int, input().split())

    c = list(map(int, input().split()))

    d = a(n, h, c)

    print(d)"
653,A,Bear and Three Balls,PROGRAMMING,"['brute force', 'implementation', 'sortings']","Limak is a little polar bear. He has *n* balls, the *i*-th ball has size *t**i*.

Limak wants to give one ball to each of his three friends. Giving gifts isn't easy — there are two rules Limak must obey to make friends happy:
 -  No two friends can get balls of the same size. -  No two friends can get balls of sizes that differ by more than 2. 
For example, Limak can choose balls with sizes 4, 5 and 3, or balls with sizes 90, 91 and 92. But he can't choose balls with sizes 5, 5 and 6 (two friends would get balls of the same size), and he can't choose balls with sizes 30, 31 and 33 (because sizes 30 and 33 differ by more than 2).

Your task is to check whether Limak can choose three balls that satisfy conditions above.","The first line of the input contains one integer *n* (3<=≤<=*n*<=≤<=50) — the number of balls Limak has.

The second line contains *n* integers *t*1,<=*t*2,<=...,<=*t**n* (1<=≤<=*t**i*<=≤<=1000) where *t**i* denotes the size of the *i*-th ball.","Print ""YES"" (without quotes) if Limak can choose three balls of distinct sizes, such that any two of them differ by no more than 2. Otherwise, print ""NO"" (without quotes).","['4\n18 55 16 17\n', '6\n40 41 43 44 44 44\n', '8\n5 972 3 4 1 4 970 971\n']","['YES\n', 'NO\n', 'YES\n']","In the first sample, there are 4 balls and Limak is able to choose three of them to satisfy the rules. He must must choose balls with sizes 18, 16 and 17.

In the second sample, there is no way to give gifts to three friends without breaking the rules.

In the third sample, there is even more than one way to choose balls:
 1.  Choose balls with sizes 3, 4 and 5. 1.  Choose balls with sizes 972, 970, 971.",OK,"import h

a = input()
c = input().split()

b = sorted([int(x) for x in c])
d = sorted([int(x) for x in list(set(b))])

if len(d) < 3:
	print('NO')
	h.exit()

e = [d[i] - d[i+2] for i in range(len(d)-2)]
g = [1  if abs(x) < 3 else 0 for x in e]
f = sum(g)
if f == 0:
	print('NO')
elif f > 0:
	print('YES')","n = int(input())

x = 0

for _ in range(n):
    a = input().strip()

    if ""++"" in a:
        x += 1

    else:
        x -= 1

print(x)"
382,C,Arithmetic Progression,PROGRAMMING,"['implementation', 'sortings']","Everybody knows what an arithmetic progression is. Let us remind you just in case that an arithmetic progression is such sequence of numbers *a*1,<=*a*2,<=...,<=*a**n* of length *n*, that the following condition fulfills: 

For example, sequences [1, 5], [10], [5, 4, 3] are arithmetic progressions and sequences [1, 3, 2], [1, 2, 4] are not.

Alexander has *n* cards containing integers. Arthur wants to give Alexander exactly one more card with a number so that he could use the resulting *n*<=+<=1 cards to make an arithmetic progression (Alexander has to use all of his cards).

Arthur has already bought a card but he hasn't written a number on it. Help him, print all integers that you can write on a card so that the described condition fulfilled.","The first line contains integer *n* (1<=≤<=*n*<=≤<=105) — the number of cards. The next line contains the sequence of integers — the numbers on Alexander's cards. The numbers are positive integers, each of them doesn't exceed 108.","If Arthur can write infinitely many distinct integers on the card, print on a single line -1.

Otherwise, print on the first line the number of integers that suit you. In the second line, print the numbers in the increasing order. Note that the numbers in the answer can exceed 108 or even be negative (see test samples).","['3\n4 1 7\n', '1\n10\n', '4\n1 3 5 9\n', '4\n4 3 4 5\n', '2\n2 4\n']","['2\n-2 10\n', '-1\n', '1\n7\n', '0\n', '3\n0 3 6\n']",none,WRONG_ANSWER,"n = int(input())
e = list(map(int,input().split()))
e.sort()
def a(e,n):
    if n == 1:
        return -1
    if n == 2:
        if (e[0] + e[1])%2 == 0:
            x = int((e[0] + e[1])/2)
            y = e[1] -  e[0]
            print(3)
            print( str(x) + "" ""+ str(e[0] - y) + "" "" + str(e[1] + y ))
        else :
            y = e[1] - e[0]
            print(2)

            print( str(e[0] - y) + "" "" + str(e[1] + y))
    i = 0
    d = 0
    f = 0

    b = "" ""
    c = "" ""
    if n > 2:
        if e[2] - e[1] < e[1] - e[0] :
            e.reverse()
            for j in e:
                if i == 0:
                    f = j
                    i += 1
                else:
                    if b == "" "":
                        b = j - f
                        f = j
                        i += 1
                    else:
                        if b != j - f:
                            if c == "" "":
                                c = j - f
                                d = i
                                i += 1

                                continue
                            else:
                                if c != j - f:
                                    print(0)
                                    break
                                else:
                                    i += 1
                                    continue
            if c == "" "":
                print(2)
                print(str(e[0] - b) + "" "" + str(e[1] + b))
            else:
                if c * 2 == b:
                    print(1)
                    print(e[d - 1] + c)
                else:
                    print(0)

        else :
            for j in e :
                if i == 0:
                    f = j
                    i +=1
                else :
                    if b == "" "":
                        b = j - f
                        f = j
                        i += 1
                    else :
                        if b != j - f :
                            if c == "" "":
                                c = j - f
                                d = i
                                i += 1

                                continue
                            else :
                                if c != j - f :
                                    print(0)
                                    break
                                else :
                                    i += 1
                                    continue
                        else :
                            f = j
                            i +=1
            if c == "" "":
                print(2)
                print(str(e[0] - b) + "" "" + str(e[-1] + b))
            else :
                if c  == b *2 :
                    print(1)
                    print(e[d-1] + b)
                else:
                    print(0)
a(e,n)","def f():

    n, m = map(int, input().split())

    d = list(map(int, input().split()))

    b = list(map(int, input().split()))

    a = 0
    e = 0

    for c in d:

        if a >= m:
            break

        if b[a] >= c:
            e += 1
            a += 1

    print(e)

if __name__ == ""__main__"":
    f()"
743,E,Vladik and cards,PROGRAMMING,"['binary search', 'bitmasks', 'brute force', 'dp']","Vladik was bored on his way home and decided to play the following game. He took *n* cards and put them in a row in front of himself. Every card has a positive integer number not exceeding 8 written on it. He decided to find the longest subsequence of cards which satisfies the following conditions:
 -  the number of occurrences of each number from 1 to 8 in the subsequence doesn't differ by more then 1 from the number of occurrences of any other number. Formally, if there are *c**k* cards with number *k* on them in the subsequence, than for all pairs of integers  the condition |*c**i*<=-<=*c**j*|<=≤<=1 must hold. -  if there is at least one card with number *x* on it in the subsequence, then all cards with number *x* in this subsequence must form a continuous segment in it (but not necessarily a continuous segment in the original sequence). For example, the subsequence [1,<=1,<=2,<=2] satisfies this condition while the subsequence [1,<=2,<=2,<=1] doesn't. Note that [1,<=1,<=2,<=2] doesn't satisfy the first condition. 
Please help Vladik to find the length of the longest subsequence that satisfies both conditions.","The first line contains single integer *n* (1<=≤<=*n*<=≤<=1000) — the number of cards in Vladik's sequence.

The second line contains the sequence of *n* positive integers not exceeding 8 — the description of Vladik's sequence.",Print single integer — the length of the longest subsequence of Vladik's sequence that satisfies both conditions.,"['3\n1 1 1\n', '8\n8 7 6 5 4 3 2 1\n', '24\n1 8 1 2 8 2 3 8 3 4 8 4 5 8 5 6 8 6 7 8 7 8 8 8\n']","['1', '8', '17']","In the first sample all the numbers written on the cards are equal, so you can't take more than one card, otherwise you'll violate the first condition.",OK,"import b
import sys, h, f
input = f.BytesIO(h.read(0, h.fstat(0).st_size)).readline

def f(u, v):
    return (m + 1) * u + v

n = int(input())
a = list(map(int, input().split()))
m = 8
x = [[] for _ in range(m)]
for i in range(n):
    x[a[i] - 1].append(i)
s = 0
for y in x:
    s += min(len(y), 1)
if s < m:
    a = s
    print(a)
    exit()
j = [1]
for _ in range(m):
    j.append(2 * j[-1])
i = j[m]
e = pow(10, 9) + 1
a = 8
g = 1
for c in range(1, n // 8 + 3):
    c = [e] * ((m + 1) * i)
    c[0] = -1
    for i in range(i):
        for j in range(m):
            u = f(i, j)
            if c[u] == e:
                break
            d = c[u]
            for k in range(m):
                if i & j[k]:
                    continue
                l = i ^ j[k]
                k = x[k]
                z = b.bisect_left(k, d) + c
                for y in range(2):
                    if y + z - 1 < len(k):
                        v = f(l, j + y)
                        c[v] = min(c[v], k[y + z - 1])
    for i in range(1, m + 1):
        if c[f(i - 1, i)] == e:
            g = 0
            break
        a += 1
    if not g:
        break
print(a)","from collections import d
import i

def f():

    c = i.stdin.read().split()
    if not c:
        return
    n = int(c[0])
    k = int(c[1])

    h = list(map(int, c[2:]))

    e = d(h)

    g = max(h)

    b = e.popleft()
    j = 0

    if b == g:
        i.stdout.write(str(b))
        return

    while j < k:
        a = e.popleft()

        if b > a:
            j += 1
            e.append(a)
        else:
            e.append(b)
            b = a
            j = 1

        if b == g:
            i.stdout.write(str(b))
            return
            
    i.stdout.write(str(b))
    
if __name__ == '__main__':
    f()"
402,C,Searching for Graph,PROGRAMMING,"['brute force', 'constructive algorithms', 'graphs']","Let's call an undirected graph of *n* vertices *p*-interesting, if the following conditions fulfill: 
 -  the graph contains exactly 2*n*<=+<=*p* edges; -  the graph doesn't contain self-loops and multiple edges; -  for any integer *k* (1<=≤<=*k*<=≤<=*n*), any subgraph consisting of *k* vertices contains at most 2*k*<=+<=*p* edges. 
A subgraph of a graph is some set of the graph vertices and some set of the graph edges. At that, the set of edges must meet the condition: both ends of each edge from the set must belong to the chosen set of vertices. 

Your task is to find a *p*-interesting graph consisting of *n* vertices.","The first line contains a single integer *t* (1<=≤<=*t*<=≤<=5) — the number of tests in the input. Next *t* lines each contains two space-separated integers: *n*, *p* (5<=≤<=*n*<=≤<=24; *p*<=≥<=0; ) — the number of vertices in the graph and the interest value for the appropriate test. 

It is guaranteed that the required graph exists.","For each of the *t* tests print 2*n*<=+<=*p* lines containing the description of the edges of a *p*-interesting graph: the *i*-th line must contain two space-separated integers *a**i*,<=*b**i* (1<=≤<=*a**i*,<=*b**i*<=≤<=*n*; *a**i*<=≠<=*b**i*) — two vertices, connected by an edge in the resulting graph. Consider the graph vertices numbered with integers from 1 to *n*. 

Print the answers to the tests in the order the tests occur in the input. If there are multiple solutions, you can print any of them.",['1\n6 0\n'],['1 2\n1 3\n1 4\n1 5\n1 6\n2 3\n2 4\n2 5\n2 6\n3 4\n3 5\n3 6\n'],none,OK,"def a(n, p):
    
    for i in range (2*n + p):
        d = i % n  

        b = (i // n) + 1 

        c = (d + b) % n

        print(d+1, c+1)

for _ in range(int(input())):
    n, p = [int(x) for x in input().split()]
    a(n,p)","""""""
This script processes a sky observation problem where each star has an evolving brightness.
It precomputes 2D prefix sums for stars grouped by their initial brightness, and then uses
these prefix sums to efficiently answer queries about the total brightness in given rectangular
areas at specific times.
""""""

import m

def g():

    d = m.stdin.read().split()
    f = iter(d)

    n = int(next(f))
    q = int(next(f))
    c = int(next(f))

    a = 100

    e = [ [ [0] * (a + 1) for _ in range(a + 1) ] for _ in range(c + 1)]

    for _ in range(n):
        x = int(next(f))
        y = int(next(f))
        s = int(next(f))
        e[s][x][y] += 1

    h = [ [ [0] * (a + 1) for _ in range(a + 1) ] for _ in range(c + 1) ]
    
    for k in range(c + 1):
        for i in range(1, a + 1):
            l = 0
            for j in range(1, a + 1):
                l += e[k][i][j]
                h[k][i][j] = h[k][i - 1][j] + l

    def j(i, o, q, p, r):
        return i[p][r] - i[o - 1][r] - i[p][q - 1] + i[o - 1][q - 1]

    k = []
    for _ in range(q):
        t = int(next(f))
        o = int(next(f))
        q = int(next(f))
        p = int(next(f))
        r = int(next(f))
        
        n = 0

        for k in range(c + 1):
            c = j(h[k], o, q, p, r)

            b = (k + t) % (c + 1)
            n += c * b
        
        k.append(str(n))
    
    m.stdout.write(""\n"".join(k) + ""\n"")

if __name__ == '__main__':
    g()"
182,E,Wooden Fence,PROGRAMMING,['dp'],"Vasya has recently bought some land and decided to surround it with a wooden fence.

He went to a company called ""Wooden board"" that produces wooden boards for fences. Vasya read in the catalog of products that the company has at its disposal *n* different types of wood. The company uses the *i*-th type of wood to produce a board of this type that is a rectangular *a**i* by *b**i* block.

Vasya decided to order boards in this company and build a fence from them. It turned out that the storehouse of the company is so large that Vasya can order arbitrary number of boards of every type. Note that Vasya is allowed to turn the boards as he builds the fence. However, Vasya cannot turn square boards.

Vasya is required to construct a fence of length *l*, however, an arbitrary fence won't do. Vasya wants his fence to look beautiful. We'll say that a fence is beautiful if and only if the following two conditions are fulfilled:
 -  there are no two successive boards of the same type -  the first board of the fence has an arbitrary length, and the length of each subsequent board equals the width of the previous one 
In other words, the fence is considered beautiful, if the type of the *i*-th board in the fence is different from the *i*<=-<=1-th board's type; besides, the *i*-th board's length is equal to the *i*<=-<=1-th board's width (for all *i*, starting from 2).

Now Vasya wonders, how many variants of arranging a fence for his land exist. Your task is to count the number of different beautiful fences of length *l*.

Two fences will be considered the same if the corresponding sequences of fence boards types and rotations are the same, otherwise the fences are different. Since the sought number can be large enough, you need to calculate the answer modulo 1000000007 (109<=+<=7).","The first line contains two integers *n* and *l* (1<=≤<=*n*<=≤<=100,<=1<=≤<=*l*<=≤<=3000) — the number of different board types and the fence length, correspondingly. Next *n* lines contain descriptions of board types: the *i*-th line contains two integers *a**i* and *b**i* (1<=≤<=*a**i*,<=*b**i*<=≤<=100) — the sizes of the board of the *i*-th type. All numbers on the lines are separated by spaces.",Print a single integer — the sought number of variants modulo 1000000007 (109<=+<=7).,"['2 3\n1 2\n2 3\n', '1 2\n2 2\n', '6 6\n2 1\n3 2\n2 5\n3 3\n5 1\n2 1\n']","['2\n', '1\n', '20\n']","In the first sample there are exactly two variants of arranging a beautiful fence of length 3: 
 -  As the first fence board use the board of the first type of length 1 and width 2. As the second board use board of the second type of length 2 and width 3. -  Use one board of the second type after you turn it. That makes its length equal 3, and width — 2.",OK,"import sys, g, e
input = e.BytesIO(g.read(0, g.fstat(0).st_size)).readline

def f(u, v):
    return 2 * n * u + v

n, l = map(int, input().split())
f = pow(10, 9) + 7
a, b = [], []
for _ in range(n):
    a, c = map(int, input().split())
    a.append(a)
    b.append(c)
    if a == c:
        a, c = l + 1, l + 1
    a.append(c)
    b.append(a)
G = [[] for _ in range(2 * n)]
for i in range(2 * n):
    for j in range(2 * n):
        if i // 2 == j // 2:
            continue
        if b[i] == a[j]:
            G[i].append(j)
m = 2 * n * (l + 1)
d = [0] * m
for i in range(2 * n):
    if a[i] <= l:
        d[f(a[i], i)] = 1
for i in range(1, l):
    for j in range(2 * n):
        u = f(i, j)
        if not d[u]:
            continue
        for k in G[j]:
            if i + a[k] <= l:
                d[f(i + a[k], k)] += d[u]
                d[f(i + a[k], k)] %= f
b = 0
for i in range(2 * n):
    b += d[f(l, i)]
b %= f
print(b)","def e():
    import j

    b = j.stdin.read().split()
    if not b:
        return
    c = iter(b)
    n = int(next(c))
    m = int(next(c))

    k = []
    for _ in range(n):
        h = [int(next(c)) for _ in range(m)]
        k.append(h)

    a = [10**9] * n

    for j in range(m):

        i = [0] * n
        i[0] = 0

        for i in range(1, n):
            if k[i][j] >= k[i - 1][j]:
                i[i] = i[i - 1]
            else:
                i[i] = i

        for i in range(n):
            if i[i] < a[i]:
                a[i] = i[i]

    k = int(next(c))
    f = []
    for _ in range(k):
        l = int(next(c))
        r = int(next(c))

        d = l - 1
        g = r - 1

        if a[g] <= d:
            f.append(""Yes"")
        else:
            f.append(""No"")
    
    j.stdout.write(""\n"".join(f))

if __name__ == ""__main__"":
    e()"
855,B,Marvolo Gaunt's Ring,PROGRAMMING,"['brute force', 'data structures', 'dp']","Professor Dumbledore is helping Harry destroy the Horcruxes. He went to Gaunt Shack as he suspected a Horcrux to be present there. He saw Marvolo Gaunt's Ring and identified it as a Horcrux. Although he destroyed it, he is still affected by its curse. Professor Snape is helping Dumbledore remove the curse. For this, he wants to give Dumbledore exactly *x* drops of the potion he made. 

Value of *x* is calculated as maximum of *p*·*a**i*<=+<=*q*·*a**j*<=+<=*r*·*a**k* for given *p*,<=*q*,<=*r* and array *a*1,<=*a*2,<=... *a**n* such that 1<=≤<=*i*<=≤<=*j*<=≤<=*k*<=≤<=*n*. Help Snape find the value of *x*. Do note that the value of *x* may be negative.","First line of input contains 4 integers *n*,<=*p*,<=*q*,<=*r* (<=-<=109<=≤<=*p*,<=*q*,<=*r*<=≤<=109,<=1<=≤<=*n*<=≤<=105).

Next line of input contains *n* space separated integers *a*1,<=*a*2,<=... *a**n* (<=-<=109<=≤<=*a**i*<=≤<=109).",Output a single integer the maximum value of *p*·*a**i*<=+<=*q*·*a**j*<=+<=*r*·*a**k* that can be obtained provided 1<=≤<=*i*<=≤<=*j*<=≤<=*k*<=≤<=*n*.,"['5 1 2 3\n1 2 3 4 5\n', '5 1 2 -3\n-1 -2 -3 -4 -5\n']","['30\n', '12\n']","In the first sample case, we can take *i* = *j* = *k* = 5, thus making the answer as 1·5 + 2·5 + 3·5 = 30.

In second sample case, selecting *i* = *j* = 1 and *k* = 5 gives the answer 12.",OK,"def b():
    n, p, q, r = map(int, input().split())
    a = list(map(int, input().split()))
    a = -float('inf')
    c = -float('inf')
    d = -float('inf')
    for i in range(n):
        c = max(c, a[i] * p)
        d = max(d, c + a[i] * q)
        a = max(a, d + a[i] * r)
    print(a)

if __name__ == '__main__':
    b()","import p
p.setrecursionlimit(10**6)

def h():
    import p
    g = p.stdin.read().split()
    if not g:
        return

    n = int(g[0])
    m = int(g[1])

    e = [[] for _ in range(n + 1)]
    f = 2
    for i in range(m):
        u = int(g[f])
        v = int(g[f + 1])
        f += 2
        e[u].append(v)
        e[v].append(u)
    
    q = [False] * (n + 1)
    m = 0

    def b(o):
        n = [o]
        k = 0
        c = 0
        while n:
            j = n.pop()
            if q[j]:
                continue
            q[j] = True
            k += 1
            c += len(e[j])
            for i in e[j]:
                if not q[i]:
                    n.append(i)
        return k, c // 2

    for a in range(1, n + 1):
        if not q[a]:
            l, d = b(a)

            if d == l - 1:
                m += 1

    p.stdout.write(str(m) + ""\n"")

if __name__ == '__main__':
    h()"
122,A,Lucky Division,PROGRAMMING,"['brute force', 'number theory']","Petya loves lucky numbers. Everybody knows that lucky numbers are positive integers whose decimal representation contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.

Petya calls a number almost lucky if it could be evenly divided by some lucky number. Help him find out if the given number *n* is almost lucky.",The single line contains an integer *n* (1<=≤<=*n*<=≤<=1000) — the number that needs to be checked.,"In the only line print ""YES"" (without the quotes), if number *n* is almost lucky. Otherwise, print ""NO"" (without the quotes).","['47\n', '16\n', '78\n']","['YES\n', 'YES\n', 'NO\n']","Note that all lucky numbers are almost lucky as any number is evenly divisible by itself.

In the first sample 47 is a lucky number. In the second sample 16 is divisible by 4.",RUNTIME_ERROR,"e()

def b(y):
    x=str(y)
    c=True
    d=['4','7']
    for a in x:
        if a not in d:
            return False
    return True

def e():
    x = input()
    y = int(x)
    c = b(y)
    if(c):
        print(""YES"")
    else:
        for i in range(4,y//2):
            if b(i) and (y%i==0):
                print(""YES"")
        print(""NO"")","def a(o, a, b):

    return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])

def i(P, j):
    """"""
    Check if point P is strictly inside the convex polygon 'poly'.
    The polygon 'poly' should be given in counterclockwise order.
    Returns True if P is strictly inside (not on an edge), otherwise False.
    """"""
    n = len(j)

    if a(j[0], j[1], P) <= 0:
        return False

    if a(j[0], j[-1], P) >= 0:
        return False

    e, c = 1, n - 1
    while c - e > 1:
        g = (e + c) // 2
        if a(j[0], j[g], P) > 0:
            e = g
        else:
            c = g

    if a(j[e], j[e + 1], P) <= 0:
        return False
    return True

def f():
    import m
    b = m.stdin.read().split()
    if not b:
        return

    d = 0

    n = int(b[d])
    d += 1
    k = []
    for _ in range(n):
        x = int(b[d])
        y = int(b[d + 1])
        d += 2
        k.append((x, y))

    k = k[::-1]

    m = int(b[d])
    d += 1
    l = []
    for _ in range(m):
        x = int(b[d])
        y = int(b[d + 1])
        d += 2
        l.append((x, y))

    for h in l:
        if not i(h, k):
            m.stdout.write(""NO"")
            return

    m.stdout.write(""YES"")

if __name__ == '__main__':
    f()"
0,none,none,none,['none'],"Today on a lecture about strings Gerald learned a new definition of string equivalency. Two strings *a* and *b* of equal length are called equivalent in one of the two cases: 
 1.  They are equal. 1.  If we split string *a* into two halves of the same size *a*1 and *a*2, and string *b* into two halves of the same size *b*1 and *b*2, then one of the following is correct:   *a*1 is equivalent to *b*1, and *a*2 is equivalent to *b*2 1.  *a*1 is equivalent to *b*2, and *a*2 is equivalent to *b*1 
As a home task, the teacher gave two strings to his students and asked to determine if they are equivalent.

Gerald has already completed this home task. Now it's your turn!",The first two lines of the input contain two strings given by the teacher. Each of them has the length from 1 to 200<=000 and consists of lowercase English letters. The strings have the same length.,"Print ""YES"" (without the quotes), if these two strings are equivalent, and ""NO"" (without the quotes) otherwise.","['aaba\nabaa\n', 'aabb\nabab\n']","['YES\n', 'NO\n']","In the first sample you should split the first string into strings ""aa"" and ""ba"", the second one — into strings ""ab"" and ""aa"". ""aa"" is equivalent to ""aa""; ""ab"" is equivalent to ""ba"" as ""ab"" = ""a"" + ""b"", ""ba"" = ""b"" + ""a"".

In the second sample the first string can be splitted into strings ""aa"" and ""bb"", that are equivalent only to themselves. That's why string ""aabb"" is equivalent only to itself and to string ""bbaa"".",WRONG_ANSWER,"def a(s,t):
    if len(s)!=len(t):
        return False
    elif s==t:
        return True
    elif len(s)%2 and len(t)%2:
        return False
    else:
        g,f=s[:len(s)//2],s[len(s)//2:]
        x,y=t[:len(t)//2],t[len(t)//2:]
        if f==x and g==y:
            return True
        elif f==x:
            return a(g,y)
        elif g==y:
            return a(f,x)
        else:
            return a(g,y) and a(f,x)
s=input()
t=input()
if a(s,t):
    print(""YES"")
else:
    print(""NO"")","import j

def g():

    c = j.stdin.read().split()
    if not c:
        return
    n = int(c[0])
    i = c[1].strip()

    d = {
        '1': (0, 0),
        '2': (1, 0),
        '3': (2, 0),
        '4': (0, 1),
        '5': (1, 1),
        '6': (2, 1),
        '7': (0, 2),
        '8': (1, 2),
        '9': (2, 2),
        '0': (1, 3)
    }

    l = set(d.values())

    h = []
    for i in range(len(i) - 1):
        n, p = d[i[i]]
        o, q = d[i[i + 1]]
        h.append((o - n, q - p))

    m = 0

    for d, (x, y) in d.items():
        a, b = x, y
        k = True
        for e, f in h:
            a += e
            b += f
            if (a, b) not in l:
                k = False
                break
        if k:
            m += 1

    if m == 1:
        print(""YES"")
    else:
        print(""NO"")

if __name__ == '__main__':
    g()"
230,B,T-primes,PROGRAMMING,"['binary search', 'implementation', 'math', 'number theory']","We know that prime numbers are positive integers that have exactly two distinct positive divisors. Similarly, we'll call a positive integer *t* Т-prime, if *t* has exactly three distinct positive divisors.

You are given an array of *n* positive integers. For each of them determine whether it is Т-prime or not.","The first line contains a single positive integer, *n* (1<=≤<=*n*<=≤<=105), showing how many numbers are in the array. The next line contains *n* space-separated integers *x**i* (1<=≤<=*x**i*<=≤<=1012).

Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is advised to use the cin, cout streams or the %I64d specifier.","Print *n* lines: the *i*-th line should contain ""YES"" (without the quotes), if number *x**i* is Т-prime, and ""NO"" (without the quotes), if it isn't.",['3\n4 5 6\n'],['YES\nNO\nNO\n'],"The given test has three numbers. The first number 4 has exactly three divisors — 1, 2 and 4, thus the answer for this number is ""YES"". The second number 5 has two divisors (1 and 5), and the third number 6 has four divisors (1, 2, 3, 6), hence the answer for them is ""NO"".",TIME_LIMIT_EXCEEDED,"import u
import 

def ~(n):
    if n < 2:
        return False
    elif n == 2 or n == 3:
        return True
    elif n % 2 == 0:
        return False
    else:
        i = 3
        while i * i <= n:
            if n % i == 0:
                return False
            i += 2
    return True

def v(q, t):
    m = 0
    while t % q == 0:
        m += 1
        t //= q
    return m

def (n):
     = []
    p = 2
    while p * p <= n:
        if n % p == 0:
             = 0
            while n % p == 0:
                 += 1
                n //= p
            .append((p, ))
        p += 1
    if n != 1:
        .append((n, 1))
    return 

def e(t):
    s = 1
     = []
    for q in range(2, t + 2):
        if t % (q - 1) == 0 and ~(q):
            s *= q ** (1 + v(q, t))
            .append(q)
    return 2 * s, 

class j(object):
    def __init__(, p, k, q):
        .p = p
        .k = k
        .q = q
        .m = (p - 1) * p ** (k - 1)
        . = p**k
        .coef = [0] * .m

    def ():
        .coef[0] = 1
        for i in range(1, .m):
            .coef[i] = 0
        return 

    def (, ):
        m = .m
         = .
         = j(.p, .k, .q)
        for i in range(m):
            for j in range(m):
                if (i + j) %  < m:
                    .coef[(i + j) % ] += .coef[i] * .coef[j]
                else:
                    r = (i + j) %  - .p ** (.k - 1)
                    while r >= 0:
                        .coef[r] -= .coef[i] * .coef[j]
                        r -= .p ** (.k - 1)
        return 

    def l(, ):
        if type() is int:
             = j(.p, .k, .q)
            for i in range(.m):
                .coef[i] = .coef[i] * 
            return 
        else:
            return .()

    def (, x, n):
         = j(.p, .k, .q)
        .coef[0] = 1
         = u.deepcopy()
        while x > 0:
            if x % 2 == 1:
                 = ( * ).(n)
             =  * 
            .(n)
            x //= 2
        return 

    def (, n):
        for i in range(.m):
            .coef[i] %= n
        return 

    def (, x):
        m = .m
         = .
         = j(.p, .k, .q)
        for i in range(m):
            if (i * x) %  < m:
                .coef[(i * x) % ] += .coef[i]
            else:
                r = (i * x) %  - .p ** (.k - 1)
                while r >= 0:
                    .coef[r] -= .coef[i]
                    r -= .p ** (.k - 1)
        return 

    def (, x):
        m = .m
         = .
         = j(.p, .k, .q)
        for i in range():
            if i < m:
                if (i * x) %  < m:
                    .coef[i] += .coef[(i * x) % ]
            else:
                r = i - .p ** (.k - 1)
                while r >= 0:
                    if (i * x) %  < m:
                        .coef[r] -= .coef[(i * x) % ]
                    r -= .p ** (.k - 1)

        return 

    def }(, N):
        m = .m
        p = .p
        k = .k
         = 0
        for i in range(m):
            if .coef[i] == 1:
                 += 1
                h = i
            elif .coef[i] == 0:
                continue
            elif (.coef[i] - (-1)) % N != 0:
                return False, None
        if  == 1:
            return True, h
        for i in range(m):
            if .coef[i] != 0:
                break
        r = i % (p ** (k - 1))
        for i in range(m):
            if i % (p ** (k - 1)) == r:
                if (.coef[i] - (-1)) % N != 0:
                    return False, None
            else:
                if .coef[i] != 0:
                    return False, None
        return True, (p - 1) * p ** (k - 1) + r

def (q):
    for r in range(2, q):
        s = set({})
        m = 1
        for i in range(1, q):
            m = (m * r) % q
            s.add(m)
        if len(s) == q - 1:
            return r
    return None

def s(q):
    g = (q)
    m = {}
    for x in range(1, q - 1):
        m[pow(g, x, q)] = x
    f = {}
    for x in range(1, q - 1):
        f[x] = m[(1 - pow(g, x, q)) % q]

    return f

def r(p, k, q, a, b):
     = j(p, k, q)
    f = s(q)
    for x in range(1, q - 1):
         = p**k
        if (a * x + b * f[x]) %  < .m:
            .coef[(a * x + b * f[x]) % ] += 1
        else:
            r = (a * x + b * f[x]) %  - p ** (k - 1)
            while r >= 0:
                .coef[r] -= 1
                r -= p ** (k - 1)
    return 

def o(p, k, q):
    return r(p, k, q, 1, 1)

def q(p, k, q):
     = o(p, k, q)
     = r(p, k, q, 2, 1)
     =  * 
    return 

def p(p, k, q):
     = r(2, 3, q, 3, 1)
     = j(p, k, q)
    for i in range(.m):
        .coef[i * (p**k) // 8] = .coef[i]
     =  * 
    return 

def c(p, k, q, N):
    J = o(p, k, q)
     = j(p, k, q).()
    for x in range(p**k):
        if x % p == 0:
            continue
        t = J.(x)
        t = t.(x, N)
         =  * t
        .(N)
    r = N % (p**k)
     = .(N // (p**k), N)
    i = j(p, k, q).()
    for x in range(p**k):
        if x % p == 0:
            continue
        t = J.(x)
        t = t.((r * x) // (p**k), N)
        i = i * t
        i.(N)
    S = ( * i).(N)
    x, h = S.}(N)
    if not x:
        return False, None
    else:
        if h % p != 0:
             = 1
        else:
             = 0
        return True, 

def d(p, k, q, N):
    J = q(p, k, q)
     = j(p, k, q).()
    for x in range(p**k):
        if x % 8 not in [1, 3]:
            continue
        t = J.(x)
        t = t.(x, N)
         =  * t
        .(N)
    r = N % (p**k)
     = .(N // (p**k), N)
    i = j(p, k, q).()
    for x in range(p**k):
        if x % 8 not in [1, 3]:
            continue
        t = J.(x)
        t = t.((r * x) // (p**k), N)
        i = i * t
        i.(N)
    if N % 8 in [1, 3]:
        S = ( * i).(N)
    else:
        g = p(p, k, q)
        S = ( * i * g).(N)
    x, h = S.}(N)

    if not x:
        return False, None
    else:
        if h % p != 0 and (pow(q, (N - 1) // 2, N) + 1) % N == 0:
             = 1
        else:
             = 0
        return True, 

def e(p, k, q, N):
    h = o(p, k, q)
     = (h * h * q).(N)
     = .(N // 4, N)
    if N % 4 == 1:
        S = 
    elif N % 4 == 3:
        S = ( * h * h).(N)
    x, h = S.}(N)
    if not x:
        return False, None
    else:
        if h % p != 0 and (pow(q, (N - 1) // 2, N) + 1) % N == 0:
             = 1
        else:
             = 0
        return True, 

def f(p, k, q, N):
    k = pow(-q, (N - 1) // 2, N)
    if (k - 1) % N != 0 and (k + 1) % N != 0:
        return False, None
    else:
        if (k + 1) % N == 0 and (N - 1) % 4 == 0:
             = 1
        else:
             = 0
        return True, 

def b(p, k, q, N):
    if p >= 3:
        ,  = c(p, k, q, N)
    elif p == 2 and k >= 3:
        ,  = d(p, k, q, N)
    elif p == 2 and k == 2:
        ,  = e(p, k, q, N)
    elif p == 2 and k == 1:
        ,  = f(p, k, q, N)
    return , 

def a(N):
     = [
        2,
        12,
        60,
        180,
        840,
        1260,
        1680,
        2520,
        5040,
        15120,
        55440,
        110880,
        720720,
        1441440,
        4324320,
        24504480,
        73513440,
    ]
    if N <= 3:
        return False
    for t in :
        w,  = e(t)
        if N < w * w:
            break
    else:
        return False
    g = .gcd(t * w, N)
    if g > 1:
        return False
    l = {}
    z = (t)
    for p, k in z:
        if p >= 3 and pow(N, p - 1, p * p) != 1:
            l[p] = 1
        else:
            l[p] = 0
    for q in :
        if q == 2:
            continue
        y = (q - 1)
        for p, k in y:
            ,  = b(p, k, q, N)
            if not :
                return False
            elif  == 1:
                l[p] = 1
    for p,  in l.items():
        if  == 0:
            v = 0
            i = 1
            { = False
            while v < 30:
                q = p * i + 1
                if N % q != 0 and ~(q) and (q not in ):
                    v += 1
                    k = v(p, q - 1)
                    ,  = b(p, k, q, N)
                    if not :
                        return False
                    elif  == 1:
                        { = True
                        break
                i += 1
            if not {:
                return False
    r = 1
    for t in range(t - 1):
        r = (r * N) % w
        if r != 1 and r != N and N % r == 0:
            return False
    return True

n = int(input())
t = list(map(int, input().split()))
for  in t:
    if .sqrt().is_integer():
        | = int(.sqrt())
        if a(|) or | == 2 or | == 3:
            print(""YES"")
        else:
            print(""NO"")
    else:
        print(""NO"")","def a():

    b = input().strip()

    if 'H' in b or 'Q' in b or '9' in b:
        print(""YES"")
    else:
        print(""NO"")

if __name__ == ""__main__"":
    a()"
729,A,Interview with Oleg,PROGRAMMING,"['implementation', 'strings']","Polycarp has interviewed Oleg and has written the interview down without punctuation marks and spaces to save time. Thus, the interview is now a string *s* consisting of *n* lowercase English letters.

There is a filler word ogo in Oleg's speech. All words that can be obtained from ogo by adding go several times to the end of it are also considered to be fillers. For example, the words ogo, ogogo, ogogogo are fillers, but the words go, og, ogog, ogogog and oggo are not fillers.

The fillers have maximal size, for example, for ogogoo speech we can't consider ogo a filler and goo as a normal phrase. We should consider ogogo as a filler here.

To print the interview, Polycarp has to replace each of the fillers with three asterisks. Note that a filler word is replaced with exactly three asterisks regardless of its length.

Polycarp has dealt with this problem in no time. Can you do the same? The clock is ticking!","The first line contains a positive integer *n* (1<=≤<=*n*<=≤<=100) — the length of the interview.

The second line contains the string *s* of length *n*, consisting of lowercase English letters.","Print the interview text after the replacement of each of the fillers with ""***"". It is allowed for the substring ""***"" to have several consecutive occurences.","['7\naogogob\n', '13\nogogmgogogogo\n', '9\nogoogoogo\n']","['a***b\n', '***gmg***\n', '*********\n']","The first sample contains one filler word ogogo, so the interview for printing is ""a***b"".

The second sample contains two fillers ogo and ogogogo. Thus, the interview is transformed to ""***gmg***"".",OK,"import m, io, os
import math
import bisect
import heapq
import string
from collections import defaultdict,Counter,deque
input = m.stdin.readline
 
def I():
    return input()
 
def b():
    return int(input())
 
def f():
    return map(int, input().split())
 
def d():
    return list(input().split())
 
def e():
    return list(map(int, input().split()))
 
def a():
    return map(lambda x: int(x) - 1, input().split())
 
def c():
    return list(map(lambda x: int(x) - 1, input().split()))
 
def h(k):
  return print('\n'.join(map(str, k)))
 
def i(k):
  return print(' '.join(map(str, k)))
 
def g(k):
  return print(''.join(map(str, k)))

'''
n%4 == 0 and all_cnts <= n//4
'''

def l():
  n = b()
  s = I().strip()
  j = []

  l = 0
  while l < n:

    if l+2 < n and s[l:l+3] == 'ogo':
      l += 3
      for i in range(l, n-1, 2):
        if s[i:i+2] == 'go':
          l = i+2
        else:
          break
      j.append('***')
    else:
      j.append(s[l])
      l += 1
  g(j)

l()","import j

def b(t, p, i):

    j = 0
    for i in range(len(t)):
        if i[i]:
            continue
        if t[i] == p[j]:
            j += 1
            if j == len(p):
                return True
    return False

def f():

    c = j.stdin.read().splitlines()
    if not c:
        return

    t = c[0].strip()

    p = c[1].strip()

    h = list(map(int, c[2].split()))
    
    n = len(t)
    e, d, a = 0, n, 0

    while e <= d:
        g = (e + d) // 2

        i = [False] * n

        for i in range(g):
            i[h[i] - 1] = True

        if b(t, p, i):
            a = g
            e = g + 1
        else:
            d = g - 1

    j.stdout.write(str(a))

if __name__ == ""__main__"":
    f()"
839,C,Journey,PROGRAMMING,"['dfs and similar', 'dp', 'graphs', 'probabilities', 'trees']","There are *n* cities and *n*<=-<=1 roads in the Seven Kingdoms, each road connects two cities and we can reach any city from any other by the roads.

Theon and Yara Greyjoy are on a horse in the first city, they are starting traveling through the roads. But the weather is foggy, so they can’t see where the horse brings them. When the horse reaches a city (including the first one), it goes to one of the cities connected to the current city. But it is a strange horse, it only goes to cities in which they weren't before. In each such city, the horse goes with equal probabilities and it stops when there are no such cities. 

Let the length of each road be 1. The journey starts in the city 1. What is the expected length (expected value of length) of their journey? You can read about expected (average) value by the link [https://en.wikipedia.org/wiki/Expected_value](https://en.wikipedia.org/wiki/Expected_value).","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=100000) — number of cities.

Then *n*<=-<=1 lines follow. The *i*-th line of these lines contains two integers *u**i* and *v**i* (1<=≤<=*u**i*,<=*v**i*<=≤<=*n*, *u**i*<=≠<=*v**i*) — the cities connected by the *i*-th road.

It is guaranteed that one can reach any city from any other by the roads.","Print a number — the expected length of their journey. The journey starts in the city 1.

Your answer will be considered correct if its absolute or relative error does not exceed 10<=-<=6.

Namely: let's assume that your answer is *a*, and the answer of the jury is *b*. The checker program will consider your answer correct, if .","['4\n1 2\n1 3\n2 4\n', '5\n1 2\n1 3\n3 4\n2 5\n']","['1.500000000000000\n', '2.000000000000000\n']","In the first sample, their journey may end in cities 3 or 4 with equal probability. The distance to city 3 is 1 and to city 4 is 2, so the expected length is 1.5.

In the second sample, their journey may end in city 4 or 5. The distance to the both cities is 2, so the expected length is 2.",RUNTIME_ERROR,"h = int(input())
f = [set() for _ in range(h)]

for _ in range(h - 1):
    a, b = map(int, input().split())
    a -= 1
    b -= 1
    f[a].add(b)
    f[b].add(a)

j = 0
k = 0

def e(g, d, i):
    if len(f[g]) == 1 and i in f[g]:
        global j, k
        j += d
        k += 1
    for c in f[g]:
        if c == i:   continue
        e(c, d + 1, g)

e(0, 0, None)
print(j / k)","def d():
    import f
    c = f.stdin.read().splitlines()

    n, m = map(int, c[0].split())

    b = c[1:n+1]
    
    a = 0

    for i in range(n - 1):
        for j in range(m - 1):

            e = [
                b[i][j],
                b[i][j+1],
                b[i+1][j],
                b[i+1][j+1]
            ]

            if sorted(e) == sorted(""face""):
                a += 1

    f.stdout.write(str(a) + ""\n"")

if __name__ == ""__main__"":
    d()"
730,H,Delete Them,PROGRAMMING,"['constructive algorithms', 'implementation']","Polycarp is a beginner programmer. He is studying how to use a command line.

Polycarp faced the following problem. There are *n* files in a directory and he needs to delete some of them. Polycarp wants to run a single delete command with filename pattern as an argument. All the files to be deleted should match the pattern and all other files shouldn't match the pattern.

Polycarp doesn't know about an asterisk '*', the only special character he knows is a question mark '?' which matches any single character. All other characters in the pattern match themselves only.

Formally, a pattern matches a filename if and only if they have equal lengths and all characters in the corresponding positions are equal except when the character in the pattern is '?', in which case the corresponding filename character does not matter.

For example, the filename pattern ""a?ba?"":
 -  matches filenames ""aabaa"", ""abba."", ""a.ba9"" and ""a.ba.""; -  does not match filenames ""aaba"", ""abaab"", ""aabaaa"" and ""aabaa."". 
Help Polycarp find a pattern which matches files to be deleted and only them or report if there is no such pattern.","The first line of the input contains two integers *n* and *m* (1<=≤<=*m*<=≤<=*n*<=≤<=100) — the total number of files and the number of files to be deleted.

The following *n* lines contain filenames, single filename per line. All filenames are non-empty strings containing only lowercase English letters, digits and dots ('.'). The length of each filename doesn't exceed 100. It is guaranteed that all filenames are distinct.

The last line of the input contains *m* distinct integer numbers in ascending order *a*1,<=*a*2,<=...,<=*a**m* (1<=≤<=*a**i*<=≤<=*n*) — indices of files to be deleted. All files are indexed from 1 to *n* in order of their appearance in the input.","If the required pattern exists, print ""Yes"" in the first line of the output. The second line should contain the required pattern. If there are multiple solutions, print any of them.

If the required pattern doesn't exist, print the only line containing ""No"".","['3 2\nab\nac\ncd\n1 2\n', '5 3\ntest\ntezt\ntest.\n.est\ntes.\n1 4 5\n', '4 4\na\nb\nc\ndd\n1 2 3 4\n', '6 3\n.svn\n.git\n....\n...\n..\n.\n1 2 3\n']","['Yes\na?\n', 'Yes\n?es?\n', 'No\n', 'Yes\n.???\n']",none,WRONG_ANSWER,"def a(f,h):

	if len(f)!=len(h):
		return 0,None,None
	n=len(f)
	i,b,j='',0,[]
	for c in range(n):
		if f[c]==h[c]:
			b=1
			i+=f[c]
			j.append(c)
		else:
			i+='?'
	return b,i,j

def b(s,i,j):

	e=[]
	for c in j:
		if s[c]==i[c]:
			e.append(c)
		else:
			i=i[:c]
			i+='?'
			i+=i[c+1:]
	return len(e),i,e

def c(k,g):
	d=len(g)
	if d==1:
		return 1,k[g[0]]
	b,i,j=a(k[g[0]],k[g[1]])

	if b==0:
		return 0,None
	for c in range(2,d):
		b,i,j=b(k[g[c]],i,j)
		if b==0:
			return 0,None
	return 1,i

n,k=[int(x) for x in input().split(' ')]
k=[]
for c in range(n):
	k.append(input())
g=[int(x)-1 for x in input().split(' ')]
b,i=c(k,g)
if b:
	print('Yes')
	print(i)
else:
	print('No')","import e

def c():
    b = e.stdin.read().strip().split()
    if not b:
        return
    n = int(b[0])
    a = list(map(int, b[1:]))

    d = 0

    for i in range(n):
        f = 1

        j = i - 1
        while j >= 0 and a[j] <= a[j + 1]:
            f += 1
            j -= 1

        j = i + 1
        while j < n and a[j] <= a[j - 1]:
            f += 1
            j += 1

        if f > d:
            d = f

    print(d)

if __name__ == ""__main__"":
    c()"
332,B,Maximum Absurdity,PROGRAMMING,"['data structures', 'dp', 'implementation']","Reforms continue entering Berland. For example, during yesterday sitting the Berland Parliament approved as much as *n* laws (each law has been assigned a unique number from 1 to *n*). Today all these laws were put on the table of the President of Berland, G.W. Boosch, to be signed.

This time mr. Boosch plans to sign 2*k* laws. He decided to choose exactly two non-intersecting segments of integers from 1 to *n* of length *k* and sign all laws, whose numbers fall into these segments. More formally, mr. Boosch is going to choose two integers *a*, *b* (1<=≤<=*a*<=≤<=*b*<=≤<=*n*<=-<=*k*<=+<=1,<=*b*<=-<=*a*<=≥<=*k*) and sign all laws with numbers lying in the segments [*a*; *a*<=+<=*k*<=-<=1] and [*b*; *b*<=+<=*k*<=-<=1] (borders are included).

As mr. Boosch chooses the laws to sign, he of course considers the public opinion. Allberland Public Opinion Study Centre (APOSC) conducted opinion polls among the citizens, processed the results into a report and gave it to the president. The report contains the absurdity value for each law, in the public opinion. As mr. Boosch is a real patriot, he is keen on signing the laws with the maximum total absurdity. Help him.","The first line contains two integers *n* and *k* (2<=≤<=*n*<=≤<=2·105, 0<=&lt;<=2*k*<=≤<=*n*) — the number of laws accepted by the parliament and the length of one segment in the law list, correspondingly. The next line contains *n* integers *x*1,<=*x*2,<=...,<=*x**n* — the absurdity of each law (1<=≤<=*x**i*<=≤<=109).","Print two integers *a*, *b* — the beginning of segments that mr. Boosch should choose. That means that the president signs laws with numbers from segments [*a*; *a*<=+<=*k*<=-<=1] and [*b*; *b*<=+<=*k*<=-<=1]. If there are multiple solutions, print the one with the minimum number *a*. If there still are multiple solutions, print the one with the minimum *b*.","['5 2\n3 6 1 1 6\n', '6 2\n1 1 1 1 1 1\n']","['1 4\n', '1 3\n']","In the first sample mr. Boosch signs laws with numbers from segments [1;2] and [4;5]. The total absurdity of the signed laws equals 3 + 6 + 1 + 6 = 16.

In the second sample mr. Boosch signs laws with numbers from segments [1;2] and [3;4]. The total absurdity of the signed laws equals 1 + 1 + 1 + 1 = 4.",WRONG_ANSWER,"import t
import 
from io import b, d
from random import x

j = x(1, 10 ** 9)
a = 8192

class c(d):
    s = 0

    def __init__({, q):
        {._fd = q.fileno()
        {.buffer = b()
        {.writable = ""x"" in q.mode or ""r"" not in q.mode
        {.write = {.buffer.write if {.writable else None

    def y({):
        while True:
            b = t.y({._fd, max(t.fstat({._fd).st_size, a))
            if not b:
                break
            w = {.buffer.tell()
            {.buffer.seek(0, 2), {.buffer.write(b), {.buffer.seek(w)
        {.s = 0
        return {.buffer.y()

    def z({):
        while {.s == 0:
            b = t.y({._fd, max(t.fstat({._fd).st_size, a))
            {.s = b.count(b""\n"") + (not b)
            w = {.buffer.tell()
            {.buffer.seek(0, 2), {.buffer.write(b), {.buffer.seek(w)
        {.s -= 1
        return {.buffer.z()

    def r({):
        if {.writable:
            t.write({._fd, {.buffer.getvalue())
            {.buffer.truncate(0), {.buffer.seek(0)

class e(d):
    def __init__({, q):
        {.buffer = c(q)
        {.r = {.buffer.r
        {.writable = {.buffer.writable
        {.write = lambda s: {.buffer.write(s.encode(""ascii""))
        {.y = lambda: {.buffer.y().decode(""ascii"")
        {.z = lambda: {.buffer.z().decode(""ascii"")

class g(int):
    def __init__({, x):
        int.__init__(x)

    def __hash__({):
        return super(g, {).__hash__() ^ j

.stdin, .stdout = e(.stdin), e(.stdout)
input = lambda: .stdin.z().rstrip(""\r\n"")

def h():
    return list(map(int, input().split()))
def I():
    return int(input())
def i():
    return list(map(g, input().split()))
def f():
    return g(input())

def }(, ~, p, |):
    i = -1
    l, n = 0, 0
    for u in range(~, p):
        if (u - ~) >= |:
            n -= [u - |]

        n += [u]

        if (u - ~) >= | - 1:
            if n > l:
                i = u - | + 1
                l = n

    return i, l

n, k = h()
 = h()

v = [[0]]
for x in range(1, n):
    v.append(v[-1] + [x])

def f(m, i, s):
    if s == 0: return 0

    if (i, s) not in m:
        k = float('-inf')
        for x in range(i, n - k + 1):
             = v[x + k - 1]
            if x > 0:
                 -= v[x - 1]

            k = max(k, f(m, x + k, s - 1) + )
        m[i, s] = k

    return m[i, s]

m = {}
f(m, 0, 2)
o = [[0] * (n + 1) for _ in range(3)]
for i, s in m:
    o[s][i] = m[i, s]

 = o[1][k]
 = o[2][0] - 

a, b = -1, -1
n = 0
for x in range(len()):
    if x >= k:
        n -= [x-k]

    n += [x]

    if x >= (k - 1):
        if (n == ) and (a == -1):
            a = x - k + 1
        if (n == ) and (b == -1) and (x > a + k):
            b = x - k + 1
a, b = min(a, b), max(a, b)
print(a + 1, b + 1)","import h

def e():

    c = h.stdin.read().strip().split()

    n = int(c[0])
    m = int(c[1])

    a = list(map(int, c[2:2+n]))

    g = list(map(int, c[2+n:2+n+m]))

    d = [0] * n

    a = 100000
    i = [False] * (a + 1)

    b = 0

    for i in range(n - 1, -1, -1):

        if not i[a[i]]:
            b += 1
            i[a[i]] = True

        d[i] = b

    f = []
    for l in g:

        f.append(str(d[l - 1]))

    h.stdout.write(""\n"".join(f))

if __name__ == '__main__':
    e()"
716,A,Crazy Computer,PROGRAMMING,['implementation'],"ZS the Coder is coding on a crazy computer. If you don't type in a word for a *c* consecutive seconds, everything you typed disappear! 

More formally, if you typed a word at second *a* and then the next word at second *b*, then if *b*<=-<=*a*<=≤<=*c*, just the new word is appended to other words on the screen. If *b*<=-<=*a*<=&gt;<=*c*, then everything on the screen disappears and after that the word you have typed appears on the screen.

For example, if *c*<==<=5 and you typed words at seconds 1,<=3,<=8,<=14,<=19,<=20 then at the second 8 there will be 3 words on the screen. After that, everything disappears at the second 13 because nothing was typed. At the seconds 14 and 19 another two words are typed, and finally, at the second 20, one more word is typed, and a total of 3 words remain on the screen.

You're given the times when ZS the Coder typed the words. Determine how many words remain on the screen after he finished typing everything.","The first line contains two integers *n* and *c* (1<=≤<=*n*<=≤<=100<=000,<=1<=≤<=*c*<=≤<=109) — the number of words ZS the Coder typed and the crazy computer delay respectively.

The next line contains *n* integers *t*1,<=*t*2,<=...,<=*t**n* (1<=≤<=*t*1<=&lt;<=*t*2<=&lt;<=...<=&lt;<=*t**n*<=≤<=109), where *t**i* denotes the second when ZS the Coder typed the *i*-th word.","Print a single positive integer, the number of words that remain on the screen after all *n* words was typed, in other words, at the second *t**n*.","['6 5\n1 3 8 14 19 20\n', '6 1\n1 3 5 7 9 10\n']","['3', '2']","The first sample is already explained in the problem statement.

For the second sample, after typing the first word at the second 1, it disappears because the next word is typed at the second 3 and 3 - 1 &gt; 1. Similarly, only 1 word will remain at the second 9. Then, a word is typed at the second 10, so there will be two words on the screen, as the old word won't disappear because 10 - 9 ≤ 1.",WRONG_ANSWER,"def a():
    n,c = [int(i) for i in input().split()]
    b = [int(i) for i in input().split()]
    c = 1
    for i in range(n):
        c+=1
        if i!=0:
            if b[i]-b[i-1]>c:
                c = 1
    
    return c

print(a())","import g

def e():

    c = g.stdin.read().split()
    if not c:
        return

    n, k = int(c[0]), int(c[1])

    a = list(map(int, c[2:2+n]))

    b = {}
    
    a = 0
    d = 0

    for f in range(n):

        if a[f] in b:
            b[a[f]] += 1
        else:
            b[a[f]] = 1
            a += 1

        if a == k:

            while b[a[d]] > 1:
                b[a[d]] -= 1
                d += 1

            print(d + 1, f + 1)
            return

    print(""-1 -1"")

if __name__ == ""__main__"":
    e()"
467,A,George and Accommodation,PROGRAMMING,['implementation'],"George has recently entered the BSUCP (Berland State University for Cool Programmers). George has a friend Alex who has also entered the university. Now they are moving into a dormitory. 

George and Alex want to live in the same room. The dormitory has *n* rooms in total. At the moment the *i*-th room has *p**i* people living in it and the room can accommodate *q**i* people in total (*p**i*<=≤<=*q**i*). Your task is to count how many rooms has free place for both George and Alex.","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=100) — the number of rooms.

The *i*-th of the next *n* lines contains two integers *p**i* and *q**i* (0<=≤<=*p**i*<=≤<=*q**i*<=≤<=100) — the number of people who already live in the *i*-th room and the room's capacity.",Print a single integer — the number of rooms where George and Alex can move in.,"['3\n1 1\n2 2\n3 3\n', '3\n1 10\n0 10\n10 10\n']","['0\n', '2\n']",none,OK,"def b(n, f):
    a = 0
    for i in range(n):
        c, d = f[i]
        if d - c >= 2:
            a += 1
    return a

n = int(input())
f = [tuple(map(int, input().split())) for _ in range(n)]

e = b(n, f)

print(e)","def h():
    import j

    e = j.stdin.read().split()
    if not e:
        return
    n = int(e[0])
    S = int(e[1])
    a = list(map(int, e[2:2+n]))

    g, f = 0, n
    b = 0
    a = 0
    
    while g <= f:
        i = (g + f) // 2
        if i == 0:
            d = 0
        else:

            c = [a[i] + (i + 1) * i for i in range(n)]
            c.sort()

            d = sum(c[:i])

        if d <= S:
            b = i
            a = d
            g = i + 1
        else:
            f = i - 1

    j.stdout.write(f""{b} {a}"")

if __name__ == '__main__':
    h()"
750,A,New Year and Hurry,PROGRAMMING,"['binary search', 'brute force', 'implementation', 'math']","Limak is going to participate in a contest on the last day of the 2016. The contest will start at 20:00 and will last four hours, exactly until midnight. There will be *n* problems, sorted by difficulty, i.e. problem 1 is the easiest and problem *n* is the hardest. Limak knows it will take him 5·*i* minutes to solve the *i*-th problem.

Limak's friends organize a New Year's Eve party and Limak wants to be there at midnight or earlier. He needs *k* minutes to get there from his house, where he will participate in the contest first.

How many problems can Limak solve if he wants to make it to the party?","The only line of the input contains two integers *n* and *k* (1<=≤<=*n*<=≤<=10, 1<=≤<=*k*<=≤<=240) — the number of the problems in the contest and the number of minutes Limak needs to get to the party from his house.","Print one integer, denoting the maximum possible number of problems Limak can solve so that he could get to the party at midnight or earlier.","['3 222\n', '4 190\n', '7 1\n']","['2\n', '4\n', '7\n']","In the first sample, there are 3 problems and Limak needs 222 minutes to get to the party. The three problems require 5, 10 and 15 minutes respectively. Limak can spend 5 + 10 = 15 minutes to solve first two problems. Then, at 20:15 he can leave his house to get to the party at 23:57 (after 222 minutes). In this scenario Limak would solve 2 problems. He doesn't have enough time to solve 3 problems so the answer is 2.

In the second sample, Limak can solve all 4 problems in 5 + 10 + 15 + 20 = 50 minutes. At 20:50 he will leave the house and go to the party. He will get there exactly at midnight.

In the third sample, Limak needs only 1 minute to get to the party. He has enough time to solve all 7 problems.",OK,"def a(n, k):
    l = 240 - k
    for i in range(1, n+1):
        if l >= 5*i:
            l -= 5*i
        else:
            return i-1
    return n

n, k = list(map(int, input().split()))
print(a(n, k))","s = input().strip()

t = input().strip()

if t == s[::-1]:
    print(""YES"")
else:
    print(""NO"")"
721,A,One-dimensional Japanese Crossword,PROGRAMMING,['implementation'],"Recently Adaltik discovered japanese crosswords. Japanese crossword is a picture, represented as a table sized *a*<=×<=*b* squares, and each square is colored white or black. There are integers to the left of the rows and to the top of the columns, encrypting the corresponding row or column. The number of integers represents how many groups of black squares there are in corresponding row or column, and the integers themselves represents the number of consecutive black squares in corresponding group (you can find more detailed explanation in Wikipedia [https://en.wikipedia.org/wiki/Japanese_crossword](https://en.wikipedia.org/wiki/Japanese_crossword)).

Adaltik decided that the general case of japanese crossword is too complicated and drew a row consisting of *n* squares (e.g. japanese crossword sized 1<=×<=*n*), which he wants to encrypt in the same way as in japanese crossword.

Help Adaltik find the numbers encrypting the row he drew.","The first line of the input contains a single integer *n* (1<=≤<=*n*<=≤<=100) — the length of the row. The second line of the input contains a single string consisting of *n* characters 'B' or 'W', ('B' corresponds to black square, 'W' — to white square in the row that Adaltik drew).","The first line should contain a single integer *k* — the number of integers encrypting the row, e.g. the number of groups of black squares in the row.

The second line should contain *k* integers, encrypting the row, e.g. corresponding to sizes of groups of consecutive black squares in the order from left to right.","['3\nBBW\n', '5\nBWBWB\n', '4\nWWWW\n', '4\nBBBB\n', '13\nWBBBBWWBWBBBW\n']","['1\n2 ', '3\n1 1 1 ', '0\n', '1\n4 ', '3\n4 1 3 ']",The last sample case correspond to the picture in the statement.,OK,"def b(s):
    a = []
    for i in range(len(s)):
        if len(s[i]) == 0:
            a.append(i)
    a.reverse()
    for i in a:
        del s[i]
    return s

def a(s):
    print(len(s))
    for i in s:
        print(len(i),end=' ')

n = int(input())
s = list(map(str,input().split('W')))
s = b(s)
a(s)","import h

def f():

    c = h.stdin.read().splitlines()
    if not c:
        return

    n = int(c[0])

    d = c[1:]
    
    e = 0

    for g in d:

        b = g.b('C')

        e += b * (b - 1) // 2

    for a in range(n):
        b = 0
        for g in range(n):
            if d[g][a] == 'C':
                b += 1

        e += b * (b - 1) // 2

    print(e)

if __name__ == '__main__':
    f()"
20,C,Dijkstra?,PROGRAMMING,"['graphs', 'shortest paths']",You are given a weighted undirected graph. The vertices are enumerated from 1 to *n*. Your task is to find the shortest path between the vertex 1 and the vertex *n*.,"The first line contains two integers *n* and *m* (2<=≤<=*n*<=≤<=105,<=0<=≤<=*m*<=≤<=105), where *n* is the number of vertices and *m* is the number of edges. Following *m* lines contain one edge each in form *a**i*, *b**i* and *w**i* (1<=≤<=*a**i*,<=*b**i*<=≤<=*n*,<=1<=≤<=*w**i*<=≤<=106), where *a**i*,<=*b**i* are edge endpoints and *w**i* is the length of the edge.

It is possible that the graph has loops and multiple edges between pair of vertices.","Write the only integer -1 in case of no path. Write the shortest path in opposite case. If there are many solutions, print any of them.","['5 6\n1 2 2\n2 5 5\n2 3 4\n1 4 1\n4 3 3\n3 5 1\n', '5 6\n1 2 2\n2 5 5\n2 3 4\n1 4 1\n4 3 3\n3 5 1\n']","['1 4 3 5 ', '1 4 3 5 ']",none,TIME_LIMIT_EXCEEDED,"import j

v, e = map(int, input().split(' '))

a = [[] for _ in range(v)]
b = [j.maxsize] * v
g = [-1] * v

for _ in range(e):
    a, b, w = map(int, input().split(' '))
    a[a - 1].append((b - 1, w))
    a[b - 1].append((a - 1, w))

b[0] = 0
k = [False] * v

def d(b, k):
    f = j.maxsize
    e = -1
    for t in range(v):
        if not k[t] and b[t] < f:
            f = b[t]
            e = t
    return e

for _ in range(v):
    u = d(b, k)
    if u == -1 or u == v - 1:
        break
    k[u] = True
    for g, w in a[u]:
        if not k[g] and b[g] > b[u] + w:
            b[g] = b[u] + w
            g[g] = u

if u == -1:
    print(-1)
else:
    i = []
    c = v - 1
    i.append(c + 1)
    while c != 0:
        h = g[c]
        i.append(h + 1)
        c = h
    i.reverse()
    print(*i)","import f

def a(a):

    e = sorted(a)

    d = [i for i, (x, y) in enumerate(zip(a, e)) if x != y]

    if len(d) == 0 or len(d) == 2:
        return True
    else:
        return False

def c():

    b = f.stdin.read().split()
    if not b:
        return
    n = int(b[0])

    a = list(map(int, b[1:1+n]))

    if a(a):
        f.stdout.write(""YES\n"")
    else:
        f.stdout.write(""NO\n"")

if __name__ == '__main__':
    c()"
270,A,Fancy Fence,PROGRAMMING,"['geometry', 'implementation', 'math']","Emuskald needs a fence around his farm, but he is too lazy to build it himself. So he purchased a fence-building robot.

He wants the fence to be a regular polygon. The robot builds the fence along a single path, but it can only make fence corners at a single angle *a*.

Will the robot be able to build the fence Emuskald wants? In other words, is there a regular polygon which angles are equal to *a*?",The first line of input contains an integer *t* (0<=&lt;<=*t*<=&lt;<=180) — the number of tests. Each of the following *t* lines contains a single integer *a* (0<=&lt;<=*a*<=&lt;<=180) — the angle the robot can make corners at measured in degrees.,"For each test, output on a single line ""YES"" (without quotes), if the robot can build a fence Emuskald wants, and ""NO"" (without quotes), if it is impossible.",['3\n30\n60\n90\n'],['NO\nYES\nYES\n'],"In the first test case, it is impossible to build the fence, since there is no regular polygon with angle <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/df5f4b07dd5316fde165b43657b2696e2919e791.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>.

In the second test case, the fence is a regular triangle, and in the last test case — a square.",WRONG_ANSWER,"def a(z):
    b=int((z-2)*180/z)
    return b
x=int(input())
c=[]
for k in range(x):
    d=int(input())
    c.append(d)
x=3
for i in c:
    a=0
    while a(x)<=i:
        if a(x)==i:
            print('YES')
            a=10
            break
        else:
            x+=1
    if a==0:
        print('NO')","import h
h.setrecursionlimit(300000)

def a(s):

    if len(s) % 2:
        return s

    d = len(s) // 2

    b = a(s[:d])
    e = a(s[d:])

    if b <= e:
        return b + e
    else:
        return e + b

def c():

    f = h.stdin.readline().strip()
    g = h.stdin.readline().strip()

    if a(f) == a(g):
        print(""YES"")
    else:
        print(""NO"")

if __name__ == ""__main__"":
    c()"
690,C2,Brain Network (medium),PROGRAMMING,"['dfs and similar', 'graphs', 'trees']","Further research on zombie thought processes yielded interesting results. As we know from the previous problem, the nervous system of a zombie consists of *n* brains and *m* brain connectors joining some pairs of brains together. It was observed that the intellectual abilities of a zombie depend mainly on the topology of its nervous system. More precisely, we define the distance between two brains *u* and *v* (1<=≤<=*u*,<=*v*<=≤<=*n*) as the minimum number of brain connectors used when transmitting a thought between these two brains. The brain latency of a zombie is defined to be the maximum distance between any two of its brains. Researchers conjecture that the brain latency is the crucial parameter which determines how smart a given zombie is. Help them test this conjecture by writing a program to compute brain latencies of nervous systems.

In this problem you may assume that any nervous system given in the input is valid, i.e., it satisfies conditions (1) and (2) from the easy version.","The first line of the input contains two space-separated integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=100000) denoting the number of brains (which are conveniently numbered from 1 to *n*) and the number of brain connectors in the nervous system, respectively. In the next *m* lines, descriptions of brain connectors follow. Every connector is given as a pair of brains *a* *b* it connects (1<=≤<=*a*,<=*b*<=≤<=*n* and *a*<=≠<=*b*).",Print one number – the brain latency.,"['4 3\n1 2\n1 3\n1 4\n', '5 4\n1 2\n2 3\n3 4\n3 5\n']","['2', '3']",none,OK,"def e(b):
    g = [False] * n
    d = (0, b)
    f = [d]
    while f:
        a, b = f.pop()
        g[b] = True
        if a > d[0]:
            d = (a, b)
        f += [(a + 1, j) for j in c[b] if not g[j]]
    return d

if __name__ == '__main__':
    n, m = map(int, input().split())
    c = [[] for i in range(n)]
    for j in range(m):
        a, b = map(int, input().split())
        c[a - 1].append(b - 1)
        c[b - 1].append(a - 1)

    print(e(e(0)[1])[0])","import p

def f(a, b, c):

    (s, v), (t, w), (u, x) = a, b, c
    return (t - s) * (x - v) - (w - v) * (u - s) != 0

def g(a, b, c):

    if not f(a, b, c):
        return False

    def o(p, q):
        return (p[0] - q[0]) ** 2 + (p[1] - q[1]) ** 2
    
    b = [o(a, b), o(b, c), o(a, c)]
    b.sort()

    return b[0] > 0 and b[0] + b[1] == b[2]

def i():

    a = p.stdin.read().splitlines()
    n = []
    
    for h in a:
        h = h.strip()
        if not h:
            continue
        k = list(map(int, h.split()))
        if len(k) != 6:
            continue
        a = (k[0], k[1])
        b = (k[2], k[3])
        c = (k[4], k[5])

        if g(a, b, c):
            n.append(""RIGHT"")
            continue

        j = [(1, 0), (-1, 0), (0, 1), (0, -1)]
        e = False

        for q in range(3):
            for c, d in j:
                r = [a, b, c]

                l, m = r[q]
                r[q] = (l + c, m + d)
                if g(r[0], r[1], r[2]):
                    e = True
                    break
            if e:
                break
                
        if e:
            n.append(""ALMOST"")
        else:
            n.append(""NEITHER"")
    
    p.stdout.write(""\n"".join(n))

if __name__ == ""__main__"":
    i()"
625,B,War of the Corporations,PROGRAMMING,"['constructive algorithms', 'greedy', 'strings']","A long time ago, in a galaxy far far away two giant IT-corporations Pineapple and Gogol continue their fierce competition. Crucial moment is just around the corner: Gogol is ready to release it's new tablet Lastus 3000.

This new device is equipped with specially designed artificial intelligence (AI). Employees of Pineapple did their best to postpone the release of Lastus 3000 as long as possible. Finally, they found out, that the name of the new artificial intelligence is similar to the name of the phone, that Pineapple released 200 years ago. As all rights on its name belong to Pineapple, they stand on changing the name of Gogol's artificial intelligence.

Pineapple insists, that the name of their phone occurs in the name of AI as a substring. Because the name of technology was already printed on all devices, the Gogol's director decided to replace some characters in AI name with ""#"". As this operation is pretty expensive, you should find the minimum number of characters to replace with ""#"", such that the name of AI doesn't contain the name of the phone as a substring.

Substring is a continuous subsequence of a string.","The first line of the input contains the name of AI designed by Gogol, its length doesn't exceed 100<=000 characters. Second line contains the name of the phone released by Pineapple 200 years ago, its length doesn't exceed 30. Both string are non-empty and consist of only small English letters.","Print the minimum number of characters that must be replaced with ""#"" in order to obtain that the name of the phone doesn't occur in the name of AI as a substring.","['intellect\ntell\n', 'google\napple\n', 'sirisiri\nsir\n']","['1', '0', '2']","In the first sample AI's name may be replaced with ""int#llect"".

In the second sample Gogol can just keep things as they are.

In the third sample one of the new possible names of AI may be ""s#ris#ri"".",WRONG_ANSWER,"from collections import deque,Counter
from math import *
import sys
import random
from bisect import *
from functools import reduce
from sys import stdin
import copy

def c(s,t):
    p = 31
    m = 10**9 + 9
    e = [0] * max(len(s),len(t))
    e[0] = 1
    for i in range(1,len(e)):
        e[i] = (e[i-1] * p) % m
    h = [0]*(len(t)+1)
    for i in range(len(t)):
        h[i+1] = (h[i] + (ord(t[i]) - 97)*e[i])%m
    d = 0
    for i in range(len(s)):
        d = (d + (ord(s[i]) - 97)*e[i])%m
    a = 0
    for i in range(len(t)-len(s)+1):
        b = (h[i+len(s)] - h[i])%m
        if b == (d * e[i])%m:
            a+=1
    return a

t = input()
s = input()
print(c(s,t))","def c():
    import h
    b = h.stdin.read().strip().splitlines()
    if not b:
        return
    
    n = int(b[0])

    a = {""polycarp"": 1}
    d = 1

    for i in range(1, n + 1):

        g = b[i].split()

        e = g[0].lower()
        f = g[2].lower()

        a[e] = a[f] + 1

        d = max(d, a[e])

    print(d)

if __name__ == ""__main__"":
    c()"
377,A,Maze,PROGRAMMING,['dfs and similar'],"Pavel loves grid mazes. A grid maze is an *n*<=×<=*m* rectangle maze where each cell is either empty, or is a wall. You can go from one cell to another only if both cells are empty and have a common side.

Pavel drew a grid maze with all empty cells forming a connected area. That is, you can go from any empty cell to any other one. Pavel doesn't like it when his maze has too little walls. He wants to turn exactly *k* empty cells into walls so that all the remaining cells still formed a connected area. Help him.","The first line contains three integers *n*, *m*, *k* (1<=≤<=*n*,<=*m*<=≤<=500, 0<=≤<=*k*<=&lt;<=*s*), where *n* and *m* are the maze's height and width, correspondingly, *k* is the number of walls Pavel wants to add and letter *s* represents the number of empty cells in the original maze.

Each of the next *n* lines contains *m* characters. They describe the original maze. If a character on a line equals ""."", then the corresponding cell is empty and if the character equals ""#"", then the cell is a wall.","Print *n* lines containing *m* characters each: the new maze that fits Pavel's requirements. Mark the empty cells that you transformed into walls as ""X"", the other cells must be left without changes (that is, ""."" and ""#"").

It is guaranteed that a solution exists. If there are multiple solutions you can output any of them.","['3 4 2\n#..#\n..#.\n#...\n', '5 4 5\n#...\n#.#.\n.#..\n...#\n.#.#\n']","['#.X#\nX.#.\n#...\n', '#XXX\n#X#.\nX#..\n...#\n.#.#\n']",none,WRONG_ANSWER,"from collections import defaultdict 

d = [] 
n,m,k  = list(map(int, input().split())) 
a = 0 
def g():
    global n,m,k, a 
    for _  in range(n):
        d.append(list(input()))
    i = 0 
    x,y = -1,-1
    for i in range(n):
        for j in range(m):
            if d[i][j] == '.':
                d[i][j] = 'X'
                i += 1 
                x = i
                y = j 
    h = [(x,y)] 
    while h:
        if a == (i - k):
            return 
        i,j = h.pop() 
        a += 1 
        d[i][j] = '.'
        for b,c in [(0,1),(0,-1),(1,0),(-1,0)]:
            e,f  = i + b , j + c 
            if 0 <= e < n and 0 <= f < m and d[e][f] == 'X':
                h.append((e, f)) 
g() 
for i in range(n):
    print("""".join(d[i]))","import j

def h():

    d = j.stdin.read().split()
    if not d:
        return
    n = int(d[0])
    f = []

    g = 1
    for _ in range(n):
        a = int(d[g])
        b = int(d[g+1])
        g += 2
        w, h = min(a, b), max(a, b)
        f.append((w, h))

    i = max(h for w, h in f)
    
    c = None

    for a in range(1, i + 1):
        k = 0
        e = True
        for w, h in f:

            if h <= a:
                k += w

            elif w <= a:
                k += h
            else:

                e = False
                break

        if e:
            b = k * a
            if c is None or b < c:
                c = b

    print(c)

if __name__ == '__main__':
    h()"
61,A,Ultra-Fast Mathematician,PROGRAMMING,['implementation'],"Shapur was an extremely gifted student. He was great at everything including Combinatorics, Algebra, Number Theory, Geometry, Calculus, etc. He was not only smart but extraordinarily fast! He could manage to sum 1018 numbers in a single second.

One day in 230 AD Shapur was trying to find out if any one can possibly do calculations faster than him. As a result he made a very great contest and asked every one to come and take part.

In his contest he gave the contestants many different pairs of numbers. Each number is made from digits 0 or 1. The contestants should write a new number corresponding to the given pair of numbers. The rule is simple: The *i*-th digit of the answer is 1 if and only if the *i*-th digit of the two given numbers differ. In the other case the *i*-th digit of the answer is 0.

Shapur made many numbers and first tried his own speed. He saw that he can perform these operations on numbers of length ∞ (length of a number is number of digits in it) in a glance! He always gives correct answers so he expects the contestants to give correct answers, too. He is a good fellow so he won't give anyone very big numbers and he always gives one person numbers of same length.

Now you are going to take part in Shapur's contest. See if you are faster and more accurate.",There are two lines in each input. Each of them contains a single number. It is guaranteed that the numbers are made from 0 and 1 only and that their length is same. The numbers may start with 0. The length of each number doesn't exceed 100.,Write one line — the corresponding answer. Do not omit the leading 0s.,"['1010100\n0100101\n', '000\n111\n', '1110\n1010\n', '01110\n01100\n']","['1110001\n', '111\n', '0100\n', '00010\n']",none,OK,"from operator import k
from typing import a, b, c, e

F = c(""F"", bound=a[[], None])

def h(f: F) -> F:
    def j():
        for _ in range(int(input(""Times: ""))):
            f()

    return e(F, j)

def g() -> None:
    d: b[str] = [input() for _ in range(2)]

    print(f""{k(*(int(i,2)for i in d)):b}"".zfill(len(d[0])))

if __name__ == ""__main__"":
    g()","import j
import u

def d(a, b):
    """"""Extended Euclidean algorithm.
    Returns (g, x, y) where x, y are such that a*x + b*y = g = gcd(a, b).""""""
    if b == 0:
        return (a, 1, 0)
    g, x, z = d(b, a % b)
    return (g, z, x - (a // b) * z)

def a(a, k, b, m):
    """"""Solve the system:
         t ≡ a (mod mod1)
         t ≡ b (mod mod2)
    Returns the minimal positive solution t and the lcm of mod1 and mod2.
    If there is no solution, returns (None, None).""""""
    g = j.gcd(k, m)
    if (a - b) % g != 0:
        return (None, None)

    l = k // g
    n = m // g
    c = (b - a) // g

    _, e, _ = d(l, n)
    e %= n
    k = (c * e) % n
    t = a + k * k
    h = (k * m) // g
    t %= h
    if t == 0:
        t = h
    return t, h

def i():
    b = u.stdin.read().split()
    if not b:
        return
    n = int(b[0])
    m = int(b[1])
    x = int(b[2])
    y = int(b[3])
    v = int(b[4])
    w = int(b[5])

    if v == 0:
        if x != 0 and x != n:
            print(-1)
            return
    if w == 0:
        if y != 0 and y != m:
            print(-1)
            return

    if v == 0 and w != 0:
        if w == 1:
            t = (-y) % m
        else:
            t = y % m

        t = m if t == 0 else t
        o = x

        g = (y + w * t) // m
        p = 0 if g % 2 == 0 else m
        print(f""{o} {p}"")
        return

    if w == 0 and v != 0:
        if v == 1:
            s = (-x) % n
        else:
            s = x % n
        t = n if s == 0 else s
        p = y
        f = (x + v * t) // n
        o = 0 if f % 2 == 0 else n
        print(f""{o} {p}"")
        return

    if v == 1:
        q = (-x) % n
    else:
        q = x % n
    if q == 0:
        q = n

    if w == 1:
        r = (-y) % m
    else:
        r = y % m
    if r == 0:
        r = m

    t, _ = a(q, n, r, m)
    if t is None:
        print(-1)
        return

    y = x + v * t
    { = y + w * t

    k = y // n
    o = 0 if k % 2 == 0 else n

    l = { // m
    p = 0 if l % 2 == 0 else m
    print(f""{o} {p}"")

if __name__ == '__main__':
    i()"
548,A,Mike and Fax,PROGRAMMING,"['brute force', 'implementation', 'strings']","While Mike was walking in the subway, all the stuff in his back-bag dropped on the ground. There were several fax messages among them. He concatenated these strings in some order and now he has string *s*.

He is not sure if this is his own back-bag or someone else's. He remembered that there were exactly *k* messages in his own bag, each was a palindrome string and all those strings had the same length.

He asked you to help him and tell him if he has worn his own back-bag. Check if the given string *s* is a concatenation of *k* palindromes of the same length.","The first line of input contains string *s* containing lowercase English letters (1<=≤<=|*s*|<=≤<=1000).

The second line contains integer *k* (1<=≤<=*k*<=≤<=1000).","Print ""YES""(without quotes) if he has worn his own back-bag or ""NO""(without quotes) otherwise.","['saba\n2\n', 'saddastavvat\n2\n']","['NO\n', 'YES\n']","Palindrome is a string reading the same forward and backward.

In the second sample, the faxes in his back-bag can be ""saddas"" and ""tavvat"".",OK,"d = input()
b = int(input())
if len(d)%b!=0:
    print('NO')
    exit()

a = len(d) // b

for j in range(b):
    c = d[ j*a : (j + 1)*a]

    e=reversed(c)

    if c != """".join(e):
        print(""NO"") 
        exit()
print(""YES"")

'''
https://codeforces.com/problemset/problem/548/A
1. Aaj exit() seekha, kaafi useful, i always thought agar aise kuch 
karna hai to i'll have to define a function, fir use return to get
out of the code.
4. Abe yaar mai bhi kya gadha hu, like agar NO hai answer, 
to exit karna chahiye, i exited on YES wala case
3. Are bhai yaaar wo sabse upar wala block mai bhool hi gaya tha,
gahdam ek aur wrong submission
2. Also line 7 me agar -1 kia to it only check first part of string
'''","def b(a, b):

    while a > 0 and b > 0:

        if a >= 2 * b:

            a %= 2 * b
            continue

        if b >= 2 * a:
            b %= 2 * a
            continue

        break
    return a, b

if __name__ == ""__main__"":
    import c

    a = c.stdin.read().split()
    a, b = int(a[0]), int(a[1])
    a, b = b(a, b)

    c.stdout.write(f""{a} {b}"")"
411,A,Password Check,PROGRAMMING,"['*special', 'implementation']","You have probably registered on Internet sites many times. And each time you should enter your invented password. Usually the registration form automatically checks the password's crypt resistance. If the user's password isn't complex enough, a message is displayed. Today your task is to implement such an automatic check.

Web-developers of the company Q assume that a password is complex enough, if it meets all of the following conditions:
 -  the password length is at least 5 characters; -  the password contains at least one large English letter; -  the password contains at least one small English letter; -  the password contains at least one digit. 
You are given a password. Please implement the automatic check of its complexity for company Q.","The first line contains a non-empty sequence of characters (at most 100 characters). Each character is either a large English letter, or a small English letter, or a digit, or one of characters: ""!"", ""?"", ""."", "","", ""_"".","If the password is complex enough, print message ""Correct"" (without the quotes), otherwise print message ""Too weak"" (without the quotes).","['abacaba\n', 'X12345\n', 'CONTEST_is_STARTED!!11\n']","['Too weak\n', 'Too weak\n', 'Correct\n']",none,OK,"import string

def r(l):
    for i in range(len(l)):
        m = l[i]
        n = i
        for j in range(i, len(l)):
            if l[j] < m:
                m = l[j]
                n = j
        l[i], l[n] = l[n], l[i]
    return l

def k(l):
    def j(e, f):
        o = []
        i, j = 0, 0
        while i < len(e) and j < len(f):
            if e[i] < f[j]:
                o.append(e[i])
                i += 1
            else:
                o.append(f[j])
                j += 1
        if i == len(e):
            o += f[j:]
        else:
            o += e[i:]
        return o

    def s(h):
        if len(h) < 2:
            return h
        l = len(h) // 2
        g = s(h[:l])
        q = s(h[l:])
        return j(g, q)

    return s(l)

def i():
    d = False
    a = False
    c = False
    b = False
    p = input()
    if len(p) >= 5:
        d = True
    for i in p:
        if i.isdigit():
            a = True
        elif i.isupper():
            c = True
        elif i.islower():
            b = True
    if d and b and c and a:
        return ""Correct""
    return ""Too weak""

print(i())","import q
import k

def g(c, k):
    """"""
    Return the kth (0-indexed) permutation of the list 'elements' in lexicographical order.
    Uses the factorial number system.
    """"""
    n = []
    c = list(c)
    n = len(c)
    for i in range(n, 0, -1):
        d = k.factorial(i - 1)
        e = k // d
        n.append(c.pop(e))
        k %= d
    return n

def p(n, m):
    """"""
    Given integers n and m, return the lexicographically m-th permutation among
    those permutations of [1,...,n] that maximize f(p) where:
      f(p) = (sum of the permutation, which is constant) + sum_{i=1}^{n-1} min(p[i], p[i+1])
    It turns out that f(p) is maximized if and only if the minimum element (1)
    is placed at one of the ends.
    There are exactly (n-1)! permutations with 1 at beginning and (n-1)! with 1 at end,
    except when n==1.
    """"""
    if n == 1:
        return [1]
    a = k.factorial(n - 1)
    
    if m <= a:

        o = list(range(2, n + 1))
        f = g(o, m - 1)
        return [1] + f
    else:

        i = m - a
        o = list(range(2, n + 1))
        f = g(o, i - 1)
        return f + [1]

def j():

    b = q.stdin.read().splitlines()
    l = []
    for h in b:
        if not h.strip():
            continue

        m = h.strip().split()
        n = int(m[0])
        m = int(m[1])

        n = p(n, m)

        l.append("" "".join(map(str, n)) + "" "")
    
    q.stdout.write(""\n"".join(l))

if __name__ == '__main__':
    j()"
755,C,PolandBall and Forest,PROGRAMMING,"['dfs and similar', 'dsu', 'graphs', 'interactive', 'trees']","PolandBall lives in a forest with his family. There are some trees in the forest. Trees are undirected acyclic graphs with *k* vertices and *k*<=-<=1 edges, where *k* is some integer. Note that one vertex is a valid tree.

There is exactly one relative living in each vertex of each tree, they have unique ids from 1 to *n*. For each Ball *i* we know the id of its most distant relative living on the same tree. If there are several such vertices, we only know the value of the one with smallest id among those.

How many trees are there in the forest?","The first line contains single integer *n* (1<=≤<=*n*<=≤<=104) — the number of Balls living in the forest.

The second line contains a sequence *p*1,<=*p*2,<=...,<=*p**n* of length *n*, where (1<=≤<=*p**i*<=≤<=*n*) holds and *p**i* denotes the most distant from Ball *i* relative living on the same tree. If there are several most distant relatives living on the same tree, *p**i* is the id of one with the smallest id.

It's guaranteed that the sequence *p* corresponds to some valid forest.

Hacking: To hack someone, you should provide a correct forest as a test. The sequence *p* will be calculated according to the forest and given to the solution you try to hack as input. Use the following format:

In the first line, output the integer *n* (1<=≤<=*n*<=≤<=104) — the number of Balls and the integer *m* (0<=≤<=*m*<=&lt;<=*n*) — the total number of edges in the forest. Then *m* lines should follow. The *i*-th of them should contain two integers *a**i* and *b**i* and represent an edge between vertices in which relatives *a**i* and *b**i* live. For example, the first sample is written as follows:",You should output the number of trees in the forest where PolandBall lives.,"['5\n2 1 5 3 3', '1\n1\n']","['2', '1']","In the first sample testcase, possible forest is: 1-2 3-4-5. 

There are 2 trees overall.

In the second sample testcase, the only possible graph is one vertex and no edges. Therefore, there is only one tree.",WRONG_ANSWER,"from sys import h
def f(): return list(map(int, h.readline().strip().split()))

class a:
    def __init__(g, n):

        g.rank = [1] * n
        g.parent = [i for i in range(n)]

    def e(g, x):

        if (g.parent[x] != x):

            g.parent[x] = g.e(g.parent[x])

        return g.parent[x]

    def b(g, x, y):

        i = g.e(x)
        j = g.e(y)

        if i == j:
            return

        if g.rank[i] < g.rank[j]:
            g.parent[i] = j
  
        elif g.rank[i] > g.rank[j]:
            g.parent[j] = i

        else:
            g.parent[j] = i
            g.rank[i] = g.rank[i] + 1

n = int(input())
d = a(n)
c = f()
for i in range(n):
	d.b(i,c[i]-1)
print(len(set(d.parent)))","import h

def e():

    c = h.stdin.read().strip().split()
    if not c:
        return

    n = int(c[0])
    m = int(c[1])

    b = set()
    a = set()

    f = []

    d = 2
    for _ in range(m):
        x = int(c[d])
        y = int(c[d + 1])
        d += 2

        b.add(x)
        a.add(y)

        g = (n - len(b)) * (n - len(a))
        f.append(str(g))

    h.stdout.write("" "".join(f) + ""\n"")

if __name__ == ""__main__"":
    e()"
227,B,Effective Approach,PROGRAMMING,['implementation'],"Once at a team training Vasya, Petya and Sasha got a problem on implementing linear search in an array.

According to the boys, linear search works as follows. The array elements in a pre-selected order are in turn compared with the number that you need to find. Once you find the array element that is equal to the required one, the search ends. The efficiency of the algorithm is the number of performed comparisons. The fewer comparisons the linear search has made, the more effective it is.

Vasya believes that a linear search would work better if it sequentially iterates through the elements, starting with the 1-st one (in this problem we consider the elements of the array indexed from 1 to *n*) and ending with the *n*-th one. And Petya says that Vasya is wrong: the search will need less comparisons if it sequentially iterates the elements starting from the *n*-th and ending with the 1-st one. Sasha argues that the two approaches are equivalent.

To finally begin the task, the teammates decided to settle the debate and compare the two approaches on an example. For this, they took an array that is a permutation of integers from 1 to *n*, and generated *m* queries of the form: find element with value *b**i* in the array. They want to calculate for both approaches how many comparisons in total the linear search will need to respond to all queries. If the first search needs fewer comparisons, then the winner of the dispute is Vasya. If the second one does, then the winner is Petya. If both approaches make the same number of comparisons, then Sasha's got the upper hand.

But the problem is, linear search is too slow. That's why the boys aren't going to find out who is right before the end of the training, unless you come in here. Help them to determine who will win the dispute.","The first line contains integer *n* (1<=≤<=*n*<=≤<=105) — the number of elements in the array. The second line contains *n* distinct space-separated integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=*n*) — the elements of array. 

The third line contains integer *m* (1<=≤<=*m*<=≤<=105) — the number of queries. The last line contains *m* space-separated integers *b*1,<=*b*2,<=...,<=*b**m* (1<=≤<=*b**i*<=≤<=*n*) — the search queries. Note that the queries can repeat.","Print two integers, showing how many comparisons Vasya's approach needs and how many comparisons Petya's approach needs. Separate the numbers by spaces.

Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use cin, cout streams or the %I64d specifier.","['2\n1 2\n1\n1\n', '2\n2 1\n1\n1\n', '3\n3 1 2\n3\n1 2 3\n']","['1 2\n', '2 1\n', '6 6\n']","In the first sample Vasya's approach will make one comparison (it starts with the 1-st element and immediately finds the required number), and Petya's approach makes two comparisons (first he compares with the 2-nd array element, doesn't find the search item and compares with the 1-st element).

In the second sample, on the contrary, Vasya's approach will need two comparisons (first with 1-st element, and then with the 2-nd), and Petya's approach will find the required value in one comparison (the first comparison with the 2-nd element).",TIME_LIMIT_EXCEEDED,"from sys import c, d

def input():
    return c.readline().strip()

def print(e):
    return d.write(str(e) + ""\n"")

def b():
    n, v, p = int(input()), 0, 0
    a = [int(x) for x in input().split()]
    m = int(input())
    b = [int(x) for x in input().split()]
    for i in range(m):
        a = a.index(b[i])
        v += a + 1
        p += n - a
    print(f""{v} {p}"")

if __name__ == ""__main__"":
    b()","import b

l, r = map(int, input().split())

a = False
for a in range(l, r - 1):

    if a % 2 == 0 and a + 2 <= r:
        b = a + 1
        c = a + 2

        if b.gcd(a, c) != 1:
            print(a, b, c)
            a = True
            break

if not a:
    print(-1)"
415,A,Mashmokh and Lights,PROGRAMMING,['implementation'],"Mashmokh works in a factory. At the end of each day he must turn off all of the lights. 

The lights on the factory are indexed from 1 to *n*. There are *n* buttons in Mashmokh's room indexed from 1 to *n* as well. If Mashmokh pushes button with index *i*, then each light with index not less than *i* that is still turned on turns off.

Mashmokh is not very clever. So instead of pushing the first button he pushes some of the buttons randomly each night. He pushed *m* distinct buttons *b*1,<=*b*2,<=...,<=*b**m* (the buttons were pushed consecutively in the given order) this night. Now he wants to know for each light the index of the button that turned this light off. Please note that the index of button *b**i* is actually *b**i*, not *i*.

Please, help Mashmokh, print these indices.","The first line of the input contains two space-separated integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=100), the number of the factory lights and the pushed buttons respectively. The next line contains *m* distinct space-separated integers *b*1,<=*b*2,<=...,<=*b**m* (1<=≤<=*b**i*<=≤<=*n*).

It is guaranteed that all lights will be turned off after pushing all buttons.",Output *n* space-separated integers where the *i*-th number is index of the button that turns the *i*-th light off.,"['5 4\n4 3 1 2\n', '5 5\n5 4 3 2 1\n']","['1 1 3 4 4 \n', '1 2 3 4 5 \n']","In the first sample, after pressing button number 4, lights 4 and 5 are turned off and lights 1, 2 and 3 are still on. Then after pressing button number 3, light number 3 is turned off as well. Pressing button number 1 turns off lights number 1 and 2 as well so pressing button number 2 in the end has no effect. Thus button number 4 turned lights 4 and 5 off, button number 3 turned light 3 off and button number 1 turned light 1 and 2 off.",OK,"def d():
    [n, m] = [int(_) for _ in input().split()]
    b = [int(_) for _ in input().split()]

    c = [0] * (n + 1)

    for a in b:
        i = a
        while i <= n and c[i] == 0:
            c[i] = a
            i += 1

    e = ' '.join([str(c[i]) for i in range(1, n + 1)])
    print(e)

if __name__ == '__main__':
    d()","m, n = map(int, input().split())

b = m * n

a = b // 2

print(a)"
698,A,Vacations,PROGRAMMING,['dp'],"Vasya has *n* days of vacations! So he decided to improve his IT skills and do sport. Vasya knows the following information about each of this *n* days: whether that gym opened and whether a contest was carried out in the Internet on that day. For the *i*-th day there are four options:
 1.  on this day the gym is closed and the contest is not carried out; 1.  on this day the gym is closed and the contest is carried out; 1.  on this day the gym is open and the contest is not carried out; 1.  on this day the gym is open and the contest is carried out. 
On each of days Vasya can either have a rest or write the contest (if it is carried out on this day), or do sport (if the gym is open on this day).

Find the minimum number of days on which Vasya will have a rest (it means, he will not do sport and write the contest at the same time). The only limitation that Vasya has — he does not want to do the same activity on two consecutive days: it means, he will not do sport on two consecutive days, and write the contest on two consecutive days.","The first line contains a positive integer *n* (1<=≤<=*n*<=≤<=100) — the number of days of Vasya's vacations.

The second line contains the sequence of integers *a*1,<=*a*2,<=...,<=*a**n* (0<=≤<=*a**i*<=≤<=3) separated by space, where: 
 -  *a**i* equals 0, if on the *i*-th day of vacations the gym is closed and the contest is not carried out; -  *a**i* equals 1, if on the *i*-th day of vacations the gym is closed, but the contest is carried out; -  *a**i* equals 2, if on the *i*-th day of vacations the gym is open and the contest is not carried out; -  *a**i* equals 3, if on the *i*-th day of vacations the gym is open and the contest is carried out.","Print the minimum possible number of days on which Vasya will have a rest. Remember that Vasya refuses:
 -  to do sport on any two consecutive days, -  to write the contest on any two consecutive days.","['4\n1 3 2 0\n', '7\n1 3 3 2 1 2 3\n', '2\n2 2\n']","['2\n', '0\n', '1\n']","In the first test Vasya can write the contest on the day number 1 and do sport on the day number 3. Thus, he will have a rest for only 2 days.

In the second test Vasya should write contests on days number 1, 3, 5 and 7, in other days do sport. Thus, he will not have a rest for a single day.

In the third test Vasya can do sport either on a day number 1 or number 2. He can not do sport in two days, because it will be contrary to the his limitation. Thus, he will have a rest for only one day.",OK,"from d import d

def b():
    return list(map(int,input().split()))
def c():
    return list(input())
def a():
    return int(input())
def i():
    return map(int,input().split())

f = a()
d = b()

g = 0
h = 0
for e in d:
    if e == 3:
        h = e - h
    elif e == 0 or e == h:
        g +=1
        h = 0
    else:   
        h = e

print(g)","def f():
    import g

    d = g.stdin.read().strip()
    if not d:
        return
    n = int(d)

    e = []

    for i in range(n):
        c = []

        for j in range(n // 2):

            a = i + 1 + j * n
            b = n * n - i - j * n
            c.append(a)
            c.append(b)
        e.append(c)

    for c in e:
        print("" "".join(map(str, c)))

if __name__ == ""__main__"":
    f()"
616,C,The Labyrinth,PROGRAMMING,['dfs and similar'],"You are given a rectangular field of *n*<=×<=*m* cells. Each cell is either empty or impassable (contains an obstacle). Empty cells are marked with '.', impassable cells are marked with '*'. Let's call two empty cells adjacent if they share a side.

Let's call a connected component any non-extendible set of cells such that any two of them are connected by the path of adjacent cells. It is a typical well-known definition of a connected component.

For each impassable cell (*x*,<=*y*) imagine that it is an empty cell (all other cells remain unchanged) and find the size (the number of cells) of the connected component which contains (*x*,<=*y*). You should do it for each impassable cell independently.

The answer should be printed as a matrix with *n* rows and *m* columns. The *j*-th symbol of the *i*-th row should be ""."" if the cell is empty at the start. Otherwise the *j*-th symbol of the *i*-th row should contain the only digit —- the answer modulo 10. The matrix should be printed without any spaces.

To make your output faster it is recommended to build the output as an array of *n* strings having length *m* and print it as a sequence of lines. It will be much faster than writing character-by-character.

As input/output can reach huge size it is recommended to use fast input/output methods: for example, prefer to use scanf/printf instead of cin/cout in C++, prefer to use BufferedReader/PrintWriter instead of Scanner/System.out in Java.","The first line contains two integers *n*,<=*m* (1<=≤<=*n*,<=*m*<=≤<=1000) — the number of rows and columns in the field.

Each of the next *n* lines contains *m* symbols: ""."" for empty cells, ""*"" for impassable cells.",Print the answer as a matrix as described above. See the examples to precise the format of the output.,"['3 3\n*.*\n.*.\n*.*\n', '4 5\n**..*\n..***\n.*.*.\n*.*.*\n']","['3.3\n.5.\n3.3\n', '46..3\n..732\n.6.4.\n5.4.3\n']","In first example, if we imagine that the central cell is empty then it will be included to component of size 5 (cross). If any of the corner cell will be empty then it will be included to component of size 3 (corner).",OK,"from collections import Counter

from math import log2

from math import gcd

from collections import  e
f=[-1,0,0,1]
g=[0,-1,1,0]

def b(x,y):
	global k
	k+=1
	q=e([(x,y)])
	v[x][y]=True
	h[x][y]=c

	while q:
		x,y=q.pop()
		for i in range(4):
			i=x+f[i]
			j=y+g[i]

			if (i>=0 and i<n) and (j>=0 and j<m) and (v[i][j]==False) and (g[i][j]=="".""):
				q.appendleft((i,j))
				k+=1
				v[i][j]=True
				h[i][j]=c

n, m = map(int, input().split())
h=[[-1 for i in range(m)] for j in range(n)]
g=[]
v=[[False for i in range(m)]for j in range(n)]
for i in range(n):
	g.append(list(input()))
d=[]
for i in range(n):
	for j in range(m):
		if v[i][j]==False and g[i][j]==""."":
			c=len(d)

			k=0
			b(i,j)
			d.append(k)

for x in range(n):
	for y in range(m):
		if g[x][y] == ""*"":
			a = 0
			s = set()
			for k in range(4):
				i = x + f[k]
				j = y + g[k]
				if i >= 0 and i < n and j >= 0 and j < m and g[i][j] == ""."":
					s.add(h[i][j])
			for h in s:
				a += d[h]
			a += 1
			a %= 10
			g[x][y] = str(a)
for i in range(n):
	print("""".join(g[i]))","def d():
    import g

    n = int(g.stdin.readline().strip())

    b = 0
    f = 0

    for _ in range(n):
        c = g.stdin.readline().strip()
        if not c:
            continue
        l, r = map(int, c.split())
        b += l
        f += r

    a = min(b, n - b)

    e = min(f, n - f)

    h = a + e

    g.stdout.write(str(h))

if __name__ == ""__main__"":
    d()"
553,B,Kyoya and Permutation,PROGRAMMING,"['binary search', 'combinatorics', 'constructive algorithms', 'greedy', 'implementation', 'math']","Let's define the permutation of length *n* as an array *p*<==<=[*p*1,<=*p*2,<=...,<=*p**n*] consisting of *n* distinct integers from range from 1 to *n*. We say that this permutation maps value 1 into the value *p*1, value 2 into the value *p*2 and so on.

Kyota Ootori has just learned about cyclic representation of a permutation. A cycle is a sequence of numbers such that each element of this sequence is being mapped into the next element of this sequence (and the last element of the cycle is being mapped into the first element of the cycle). The cyclic representation is a representation of *p* as a collection of cycles forming *p*. For example, permutation *p*<==<=[4,<=1,<=6,<=2,<=5,<=3] has a cyclic representation that looks like (142)(36)(5) because 1 is replaced by 4, 4 is replaced by 2, 2 is replaced by 1, 3 and 6 are swapped, and 5 remains in place. 

Permutation may have several cyclic representations, so Kyoya defines the standard cyclic representation of a permutation as follows. First, reorder the elements within each cycle so the largest element is first. Then, reorder all of the cycles so they are sorted by their first element. For our example above, the standard cyclic representation of [4,<=1,<=6,<=2,<=5,<=3] is (421)(5)(63).

Now, Kyoya notices that if we drop the parenthesis in the standard cyclic representation, we get another permutation! For instance, [4,<=1,<=6,<=2,<=5,<=3] will become [4,<=2,<=1,<=5,<=6,<=3].

Kyoya notices that some permutations don't change after applying operation described above at all. He wrote all permutations of length *n* that do not change in a list in lexicographic order. Unfortunately, his friend Tamaki Suoh lost this list. Kyoya wishes to reproduce the list and he needs your help. Given the integers *n* and *k*, print the permutation that was *k*-th on Kyoya's list.","The first line will contain two integers *n*, *k* (1<=≤<=*n*<=≤<=50, 1<=≤<=*k*<=≤<=*min*{1018,<=*l*} where *l* is the length of the Kyoya's list).","Print *n* space-separated integers, representing the permutation that is the answer for the question.","['4 3\n', '10 1\n']","['1 3 2 4\n', '1 2 3 4 5 6 7 8 9 10\n']","The standard cycle representation is (1)(32)(4), which after removing parenthesis gives us the original permutation. The first permutation on the list would be [1, 2, 3, 4], while the second permutation would be [1, 2, 4, 3].",OK,"b = [1] * 51

for i in range(2, 51):
    b[i] = b[i - 1] + b[i - 2]

a = []

def c(i, n, d):
    if i == n:
        assert d == 1
        print("" "".join(map(str, a)))
        return
    if i + 1 == n:
        a.append(n)
        c(i + 1, n, d)
        return
    if b[n - i - 1] < d:
        a.append(i + 2)
        a.append(i + 1)
        c(i + 2, n, d - b[n - i - 1])
    else:
        a.append(i + 1)
        c(i + 1, n, d)

n, k = map(int, input().split())
c(0, n, k)","import e
e.setrecursionlimit(1000000)

def b():
    import e
    input = e.stdin.readline

    n, m = map(int, input().split())

    d = [0] * (n + 1)

    c = list(range(n + 2))

    def a(x):
        if c[x] != x:
            c[x] = a(c[x])
        return c[x]

    for _ in range(m):

        l, r, x = map(int, input().split())

        i = a(l)
        while i <= r:
            if i == x:

                c[i] = a(i + 1)
            else:

                d[i] = x

                c[i] = a(i + 1)

            i = a(i)

    e.stdout.write("" "".join(map(str, d[1:])) + "" "")

if __name__ == '__main__':
    b()"
954,D,Fight Against Traffic,PROGRAMMING,"['dfs and similar', 'graphs', 'shortest paths']","Little town Nsk consists of *n* junctions connected by *m* bidirectional roads. Each road connects two distinct junctions and no two roads connect the same pair of junctions. It is possible to get from any junction to any other junction by these roads. The distance between two junctions is equal to the minimum possible number of roads on a path between them.

In order to improve the transportation system, the city council asks mayor to build one new road. The problem is that the mayor has just bought a wonderful new car and he really enjoys a ride from his home, located near junction *s* to work located near junction *t*. Thus, he wants to build a new road in such a way that the distance between these two junctions won't decrease. 

You are assigned a task to compute the number of pairs of junctions that are not connected by the road, such that if the new road between these two junctions is built the distance between *s* and *t* won't decrease.","The firt line of the input contains integers *n*, *m*, *s* and *t* (2<=≤<=*n*<=≤<=1000, 1<=≤<=*m*<=≤<=1000, 1<=≤<=*s*,<=*t*<=≤<=*n*, *s*<=≠<=*t*) — the number of junctions and the number of roads in Nsk, as well as the indices of junctions where mayors home and work are located respectively. The *i*-th of the following *m* lines contains two integers *u**i* and *v**i* (1<=≤<=*u**i*,<=*v**i*<=≤<=*n*, *u**i*<=≠<=*v**i*), meaning that this road connects junctions *u**i* and *v**i* directly. It is guaranteed that there is a path between any two junctions and no two roads connect the same pair of junctions.","Print one integer — the number of pairs of junctions not connected by a direct road, such that building a road between these two junctions won't decrease the distance between junctions *s* and *t*.","['5 4 1 5\n1 2\n2 3\n3 4\n4 5\n', '5 4 3 5\n1 2\n2 3\n3 4\n4 5\n', '5 6 1 5\n1 2\n1 3\n1 4\n4 5\n3 5\n2 5\n']","['0\n', '5\n', '3\n']",none,WRONG_ANSWER,"from collections import c
from heapq import i, j
n, m, s, t = list(map(int, input().split()))

h = c(set)
for _ in range(m):
    u, v = list(map(int, input().split()))
    h[u - 1].add((v - 1, 1))
    h[v - 1].add((u - 1, 1))

s = [((n*(n-1))//2) - m]

q = [(s - 1, 0)]
f = [float('inf')]*n
f[s - 1] = 0
while q:
    r = len(q)
    for _ in range(r):
        n, g = i(q)
        for m, u in h[n]:
            if g + u < f[m]:
                f[m] = g + u
                j(q, (m, f[m]))

l = f[t - 1]

t = [0]
def e(a = s - 1, p = -1, d = 0):

    if a == t - 1:

        if d == l:
            t[0] += 1
        return

    for m, u in h[a]:
        if m != p:
            e(m, a, d + 1)

e()
o = l + 1
k = ((o*(o-1))//2) - l
b = (t[0]*k) - ((t[0]) - 1)
s[0] -= b
print(s[0])","""""""
We are given a schedule for a smart lamp.
The lamp turns power (and light) on at time 0 and off at time M.
There is a preinstalled ""good"" program represented by an increasing list a,
with each a_i (0 < a_i < M). The lamp toggles its state at each a_i.
Thus initially the lamp is on (from 0 until a1), then off from a1 to a2,
then on from a2 to a3, and so on.
In the end (at time M) the power is turned off.
We are allowed to insert at most one extra toggle time x (an integer)
into the program so that it remains a good program.
Our goal is to maximize the total time when the lamp is lit.
We may also choose not to insert anything.

A known approach is:
  1. Build an extended list: ext = [0] + a + [M]
  2. Compute the total lit time in the original schedule (the ""base"")
     where lit intervals are the ones with even index segments:
         lit time = sum_{i even} (ext[i+1] - ext[i])
  3. Consider inserting a toggle in some gap (between ext[i] and ext[i+1])
     if the gap length > 1 (since we need to pick an integer that is strictly between).
  4. Inserting a toggle will flip the ""parity"" of the subsequent segments.
     One can compute the candidate lit time after an optimal insertion in
     that gap as follows:
         candidate = (lit time before the gap) +
                     (new contribution in the gap, which is gap-1)
                     + (flipped lit time in the remainder of the timeline).
     The lit time in the remainder after insertion becomes:
         (length of remainder) - (original lit time in the remainder)
  5. We take the maximum between the original base lit time and all candidates.
""""""

def g():
    import i
    d = i.stdin.read().strip().split()
    if not d:
        return
    n = int(d[0])
    M = int(d[1])

    a = list(map(int, d[2:2+n]))

    e = [0] + a + [M]
    L = len(e)

    h = [0] * L
    for i in range(L - 1):
        if i % 2 == 0:
            h[i+1] = h[i] + (e[i+1] - e[i])
        else:
            h[i+1] = h[i]

    b = h[-1]
    a = b

    for i in range(L - 1):
        f = e[i+1] - e[i]
        if f > 1:
            c = h[i] + (f - 1) + ((e[-1] - e[i+1]) - (h[-1] - h[i+1]))
            if c > a:
                a = c

    i.stdout.write(str(a))

if __name__ == '__main__':
    g()"
582,A,GCD Table,PROGRAMMING,"['constructive algorithms', 'greedy', 'number theory']","The GCD table *G* of size *n*<=×<=*n* for an array of positive integers *a* of length *n* is defined by formula 

Let us remind you that the greatest common divisor (GCD) of two positive integers *x* and *y* is the greatest integer that is divisor of both *x* and *y*, it is denoted as . For example, for array *a*<==<={4,<=3,<=6,<=2} of length 4 the GCD table will look as follows:

Given all the numbers of the GCD table *G*, restore array *a*.","The first line contains number *n* (1<=≤<=*n*<=≤<=500) — the length of array *a*. The second line contains *n*2 space-separated numbers — the elements of the GCD table of *G* for array *a*. 

All the numbers in the table are positive integers, not exceeding 109. Note that the elements are given in an arbitrary order. It is guaranteed that the set of the input data corresponds to some array *a*.","In the single line print *n* positive integers — the elements of array *a*. If there are multiple possible solutions, you are allowed to print any of them.","['4\n2 1 2 3 4 3 2 6 1 1 2 2 1 2 3 2\n', '1\n42\n', '2\n1 1 1 1\n']","['4 3 6 2', '42 ', '1 1 ']",none,OK,"import math as ma
import c
input=c.stdin.readline

def a(b):
    for i in b:
        if b[i]!=0:
            return i
    return -1

def b(a,b):
    if a%b==0:
        return b
    else:
        return b(b,a%b)

n=int(input())
a=list(map(int,input().split()))
a.sort(reverse=True)
b={}
for i in range(n*n):
    if a[i] in b.keys():
        b[a[i]]+=1
    else:
        b[a[i]]=1
c=[]
for i in b:
    c.append(i)
    b[i]-=1
    break
while 1>0:
    if len(c)<n:
        a=a(b)
        if a==-1:
            break
        else:
            b[a]-=1
            for i in range(len(c)):
                b[b(a,c[i])]-=2
            c.append(a)
    else:
        break

print(*c)","def e():
    import i
    c = i.stdin.read().strip().split()
    if not c:
        return

    N = int(c[0])
    A = int(c[1])
    B = int(c[2])

    x = -1
    y = -1
    d = False
    for i in range(0, N // A + 1):
        g = N - i * A
        if g < 0:
            break
        if g % B == 0:
            x = i
            y = g // B
            d = True
            break
    if not d:
        i.stdout.write(""-1"")
        return

    f = [0] * (N + 1)
    b = 1

    def a(h, L):
        for i in range(h, h + L - 1):
            f[i] = i + 1
        f[h + L - 1] = h

    for _ in range(x):
        a(b, A)
        b += A

    for _ in range(y):
        a(b, B)
        b += B

    i.stdout.write("" "".join(str(f[i]) for i in range(1, N + 1)))

if __name__ == '__main__':
    e()"
622,C,Not Equal on a Segment,PROGRAMMING,"['data structures', 'implementation']","You are given array *a* with *n* integers and *m* queries. The *i*-th query is given with three integers *l**i*,<=*r**i*,<=*x**i*.

For the *i*-th query find any position *p**i* (*l**i*<=≤<=*p**i*<=≤<=*r**i*) so that *a**p**i*<=≠<=*x**i*.","The first line contains two integers *n*,<=*m* (1<=≤<=*n*,<=*m*<=≤<=2·105) — the number of elements in *a* and the number of queries.

The second line contains *n* integers *a**i* (1<=≤<=*a**i*<=≤<=106) — the elements of the array *a*.

Each of the next *m* lines contains three integers *l**i*,<=*r**i*,<=*x**i* (1<=≤<=*l**i*<=≤<=*r**i*<=≤<=*n*,<=1<=≤<=*x**i*<=≤<=106) — the parameters of the *i*-th query.","Print *m* lines. On the *i*-th line print integer *p**i* — the position of any number not equal to *x**i* in segment [*l**i*,<=*r**i*] or the value <=-<=1 if there is no such number.",['6 4\n1 2 1 1 3 5\n1 4 1\n2 6 2\n3 4 1\n3 4 2\n'],['2\n6\n-1\n4\n'],none,TIME_LIMIT_EXCEEDED,"class c:
    def __init__(d,n,b):
        d.n = n
        d.b = b

def g(e,l,r):
    if l >= r:
        return
    i = l
    j = r
    f = e[i]
    while i != j:
        while j > i and e[j].n > f.n:
            j -= 1
        if j > i:
            e[i] = e[j]
            i += 1
        while j > i and e[i].n < f.n:
            i += 1
        if j > i:
            e[j] = e[i]
            j -= 1
    e[i] = f
    g(e,l,i-1)
    g(e,i+1,r)
    return

n,m = map(int,input().split())
a = list(map(int,input().split()))
a = []
for i in range(len(a)):
    a.append(c(a[i],i+1))
for i in range(m):
    b = list(map(int,input().split()))
    c = a[b[0]-1:b[1]]
    g(c,0,len(c)-1)
    if c[0].n != b[2]:
        print (c[0].b)
    elif c[-1].n != b[2]:
        print (c[-1].b)
    else:
        print (-1)","def d():
    import i
    a = i.stdin.read().strip().split()
    if not a:
        return
    n = int(a[0])
    k = int(a[1])

    b = {}
    c = 2
    for i in range(n):

        e = tuple(int(a[c + j]) for j in range(k))
        c += k
        b[e] = b.get(e, 0) + 1

    f = list(b.keys())
    m = len(f)

    for h in range(1, 1 << m):
        k = 0
        j = [0] * k

        for i in range(m):
            if h & (1 << i):
                k += 1
                p = f[i]
                for j in range(k):
                    j[j] += p[j]
        g = True

        for j in range(k):
            if 2 * j[j] > k:
                g = False
                break
        if g:
            print(""YES"")
            return
    print(""NO"")
    
if __name__ == '__main__':
    d()"
0,none,none,none,['none'],"In the year of $30XX$ participants of some world programming championship live in a single large hotel. The hotel has $n$ floors. Each floor has $m$ sections with a single corridor connecting all of them. The sections are enumerated from $1$ to $m$ along the corridor, and all sections with equal numbers on different floors are located exactly one above the other. Thus, the hotel can be represented as a rectangle of height $n$ and width $m$. We can denote sections with pairs of integers $(i, j)$, where $i$ is the floor, and $j$ is the section number on the floor.

The guests can walk along the corridor on each floor, use stairs and elevators. Each stairs or elevator occupies all sections $(1, x)$, $(2, x)$, $\ldots$, $(n, x)$ for some $x$ between $1$ and $m$. All sections not occupied with stairs or elevators contain guest rooms. It takes one time unit to move between neighboring sections on the same floor or to move one floor up or down using stairs. It takes one time unit to move up to $v$ floors in any direction using an elevator. You can assume you don't have to wait for an elevator, and the time needed to enter or exit an elevator is negligible.

You are to process $q$ queries. Each query is a question ""what is the minimum time needed to go from a room in section $(x_1, y_1)$ to a room in section $(x_2, y_2)$?""","The first line contains five integers $n, m, c_l, c_e, v$ ($2 \leq n, m \leq 10^8$, $0 \leq c_l, c_e \leq 10^5$, $1 \leq c_l + c_e \leq m - 1$, $1 \leq v \leq n - 1$) — the number of floors and section on each floor, the number of stairs, the number of elevators and the maximum speed of an elevator, respectively.

The second line contains $c_l$ integers $l_1, \ldots, l_{c_l}$ in increasing order ($1 \leq l_i \leq m$), denoting the positions of the stairs. If $c_l = 0$, the second line is empty.

The third line contains $c_e$ integers $e_1, \ldots, e_{c_e}$ in increasing order, denoting the elevators positions in the same format. It is guaranteed that all integers $l_i$ and $e_i$ are distinct.

The fourth line contains a single integer $q$ ($1 \leq q \leq 10^5$) — the number of queries.

The next $q$ lines describe queries. Each of these lines contains four integers $x_1, y_1, x_2, y_2$ ($1 \leq x_1, x_2 \leq n$, $1 \leq y_1, y_2 \leq m$) — the coordinates of starting and finishing sections for the query. It is guaranteed that the starting and finishing sections are distinct. It is also guaranteed that these sections contain guest rooms, i. e. $y_1$ and $y_2$ are not among $l_i$ and $e_i$.","Print $q$ integers, one per line — the answers for the queries.",['5 6 1 1 3\n2\n5\n3\n1 1 5 6\n1 3 5 4\n3 3 5 3\n'],['7\n5\n4\n'],"In the first query the optimal way is to go to the elevator in the 5-th section in four time units, use it to go to the fifth floor in two time units and go to the destination in one more time unit.

In the second query it is still optimal to use the elevator, but in the third query it is better to use the stairs in the section 2.",TIME_LIMIT_EXCEEDED,"import b
N,M,L,E,V = map(int,input().split())
g = list(map(int,input().split()))
d = list(map(int,input().split()))

def e(h,j,i,k):
    if h == i:
        return abs(j-k)
    a = N+M+9999
    if j > k: j,k = k,j
    if g:
        i = b.b(g,j)
        if i == L:
            f = g[-1]
            t = abs(f - j) + abs(f - k) + abs(h - i)
            a = min(a, t)
        else:
            f = g[i]
            t = abs(f - j) + abs(f - k) + abs(h - i)
            a = min(a, t)
            if i < L-1:
                f = g[i+1]
                t = abs(f - j) + abs(f - k) + abs(h - i)
                a = min(a, t)
    if d:
        i = b.b(d,j)
        if i == E:
            c = d[-1]
            t = abs(c - j) + abs(c - k) + (abs(h-i)-1)//V + 1
            a = min(a, t)
        else:
            c = d[i]
            t = abs(c - j) + abs(c - k) + (abs(h-i)-1)//V + 1
            a = min(a, t)
            if i < E-1:
                c = d[i+1]
                t = abs(c - j) + abs(c - k) + (abs(h-i)-1)//V + 1
                a = min(a, t)
    return a

Q = int(input())
for i in range(Q):
    print(e(*tuple(map(int,input().split()))))","def b():
    import d
    a = d.stdin.read().strip().split()
    if not a:
        return
    try:

        n = int(a[0])
        m = int(a[1])
    except:
        return

    if n > m + 1 or m > 2 * (n + 1):
        d.stdout.write(""-1"")
        return

    c = []

    while m or n:

        if m > n:

            if len(c) >= 2 and c[-1] == '1' and c[-2] == '1':
                if n:
                    c.append('0')
                    n -= 1
                else:
                    d.stdout.write(""-1"")
                    return
            else:

                if m:
                    c.append('1')
                    m -= 1
                else:

                    pass
        else:

            if n:
                if c and c[-1] == '0':

                    if m:
                        c.append('1')
                        m -= 1
                    else:
                        d.stdout.write(""-1"")
                        return
                else:
                    c.append('0')
                    n -= 1
            else:
                if m:

                    if len(c) >= 2 and c[-1] == '1' and c[-2] == '1':
                        d.stdout.write(""-1"")
                        return
                    c.append('1')
                    m -= 1
    d.stdout.write("""".join(c))

if __name__ == '__main__':
    b()"
177,E1,Space Voyage,PROGRAMMING,['binary search'],"The Smart Beaver from ABBYY plans a space travel on an ultramodern spaceship. During the voyage he plans to visit *n* planets. For planet *i* *a**i* is the maximum number of suitcases that an alien tourist is allowed to bring to the planet, and *b**i* is the number of citizens on the planet.

The Smart Beaver is going to bring some presents from ABBYY to the planets he will be visiting. The presents are packed in suitcases, *x* presents in each. The Beaver will take to the ship exactly *a*1<=+<=...<=+<=*a**n* suitcases.

As the Beaver lands on the *i*-th planet, he takes *a**i* suitcases and goes out. On the first day on the planet the Beaver takes a walk and gets to know the citizens. On the second and all subsequent days the Beaver gives presents to the citizens — each of the *b**i* citizens gets one present per day. The Beaver leaves the planet in the evening of the day when the number of presents left is strictly less than the number of citizens (i.e. as soon as he won't be able to give away the proper number of presents the next day). He leaves the remaining presents at the hotel.

The Beaver is going to spend exactly *c* days traveling. The time spent on flights between the planets is considered to be zero. In how many ways can one choose the positive integer *x* so that the planned voyage will take exactly *c* days?","The first input line contains space-separated integers *n* and *c* — the number of planets that the Beaver is going to visit and the number of days he is going to spend traveling, correspondingly.

The next *n* lines contain pairs of space-separated integers *a**i*,<=*b**i* (1<=≤<=*i*<=≤<=*n*) — the number of suitcases he can bring to the *i*-th planet and the number of citizens of the *i*-th planet, correspondingly.

The input limitations for getting 30 points are: 
 -  1<=≤<=*n*<=≤<=100 -  1<=≤<=*a**i*<=≤<=100 -  1<=≤<=*b**i*<=≤<=100 -  1<=≤<=*c*<=≤<=100 
The input limitations for getting 100 points are: 
 -  1<=≤<=*n*<=≤<=104 -  0<=≤<=*a**i*<=≤<=109 -  1<=≤<=*b**i*<=≤<=109 -  1<=≤<=*c*<=≤<=109 
Due to possible overflow, it is recommended to use the 64-bit arithmetic. In some solutions even the 64-bit arithmetic can overflow. So be careful in calculations!","Print a single number *k* — the number of ways to choose *x* so as to travel for exactly *c* days. If there are infinitely many possible values of *x*, print -1.

Please do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use cin, cout streams or the %I64d specifier.",['2 5\n1 5\n2 4\n'],['1\n'],"In the first example there is only one suitable value *x* = 5. Then the Beaver takes 1 suitcase with 5 presents to the first planet. Here he spends 2 days: he hangs around on the first day, and he gives away five presents on the second day. He takes 2 suitcases with 10 presents to the second planet. Here he spends 3 days — he gives away 4 presents on the second and the third days and leaves the remaining 2 presents at the hotel. In total, the Beaver spends 5 days traveling.

For *x* = 4 or less the Beaver won't have enough presents for the second day on the first planet, so the voyage will end too soon. For *x* = 6 and more the Beaver will spend at least one more day on the second planet, and the voyage will take too long.",WRONG_ANSWER,"def e(d, x):
    d.sort()
    m = 0
    k = len(d) - 1
    n = 0
    while m <= k:

        n = m + (k-m)//2
        if d[n] < x:
            m = n + 1
        elif d[n] > x:
            k = n - 1
        else:
            return n
    return -1
def q(l, r, l, c):
    if (r >= l):
        o = l + (r - l) // 3
        p = r - (r - l) // 3
        if (c[o] == l):
            return o
        if (c[p] == l):
            return p
        if (l < c[o]):
            return q(l, o - 1, l, c)
        elif (l > c[p]):
            return q(p + 1, r, l, c)
        else:
            return q(o + 1,
                                 p - 1, l, c)
    return -1
def h(x):
    i= 0
    for i in range(n):
        i+= ((a[i]*x)//b[i] +1)
    return i

def f(m,k):

    while((k - m )> 0):
        n = (k+m)//2
        if h(n)<c:
            m= n+1
        else:
            k = n

    if h(m)==c :
        return m
    else:
        return -1
def g(m,k):

    while((k - m )> 0):
        n = (k+m+1)//2
        if h(n)<=c:
            m= n
        else:
            k = n-1

    if h(m )==c:
        return m
    else:
        return -1

if __name__ == ""__main__"":

    n,c= map(int,input().split())
    a=[0 for i in range(n)]
    b= [0 for i in range(n)]
    j=True
    for j in range(n):
        a[j],b[j]= map(int,input().split())
        if a[j]!=0:
            j=False
    z = 10**9
    if j and n==c :
        print(0)
    elif  n== c:
        print(min(b)-1)
    elif j :
        print(-1)

    elif n<c:
        a=f(1,10**18)
        b= g(1,10**18)
        if  a ==-1 or b == -1:
            print(0)
        else:
            print(b-a +1)
    else:
        print(0)","import i

def f():

    a = i.stdin.read().split()

    n = int(a[0])

    c = 0
    h = 0
    b = []
    g = []

    e = None

    d = 1
    for _ in range(n):
        x = int(a[d])
        d += 1
        
        if x > 0:
            c += x
            b.append(x)
            e = ""first""
        else:
            j = -x
            h += j
            g.append(j)
            e = ""second""

    if c > h:
        print(""first"")
    elif h > c:
        print(""second"")
    else:

        if b > g:
            print(""first"")
        elif g > b:
            print(""second"")
        else:

            print(e)

if __name__ == ""__main__"":
    f()"
291,A,Spyke Talks,PROGRAMMING,"['*special', 'implementation', 'sortings']","Polycarpus is the director of a large corporation. There are *n* secretaries working for the corporation, each of them corresponds via the famous Spyke VoIP system during the day. We know that when two people call each other via Spyke, the Spyke network assigns a unique ID to this call, a positive integer session number.

One day Polycarpus wondered which secretaries are talking via the Spyke and which are not. For each secretary, he wrote out either the session number of his call or a 0 if this secretary wasn't talking via Spyke at that moment.

Help Polycarpus analyze these data and find out the number of pairs of secretaries that are talking. If Polycarpus has made a mistake in the data and the described situation could not have taken place, say so.

Note that the secretaries can correspond via Spyke not only with each other, but also with the people from other places. Also, Spyke conferences aren't permitted — that is, one call connects exactly two people.","The first line contains integer *n* (1<=≤<=*n*<=≤<=103) — the number of secretaries in Polycarpus's corporation. The next line contains *n* space-separated integers: *id*1,<=*id*2,<=...,<=*id**n* (0<=≤<=*id**i*<=≤<=109). Number *id**i* equals the number of the call session of the *i*-th secretary, if the secretary is talking via Spyke, or zero otherwise.

Consider the secretaries indexed from 1 to *n* in some way.","Print a single integer — the number of pairs of chatting secretaries, or -1 if Polycarpus's got a mistake in his records and the described situation could not have taken place.","['6\n0 1 7 1 7 10\n', '3\n1 1 1\n', '1\n0\n']","['2\n', '-1\n', '0\n']","In the first test sample there are two Spyke calls between secretaries: secretary 2 and secretary 4, secretary 3 and secretary 5.

In the second test sample the described situation is impossible as conferences aren't allowed.",OK,"def b(a):
    n = len(a)
    e = True
    d = 0
    c = n-1
    while (e == True):

        e = False

        for i in range (d, c):
            if (a[i] > a[i + 1]) :
                a[i], a[i + 1]= a[i + 1], a[i]
                e = True

        if (e == False):
            break

        e = False

        c = c-1

        for i in range(c-1, d-1, -1):
            if (a[i] > a[i + 1]):
                a[i], a[i + 1] = a[i + 1], a[i]
                e = True

        d = d + 1

n = int(input())
x = list(map(int, input().split()))

a = 0

b(x)

for i in range(len(x)-1):
	if (i+2)>= n:
		if (x[i] == x[i+1]) and (x[i] != 0):
			a = a + 1
			i = i+1
	else:
 
		if x[i] == x[i+1] and x[i] != 0  and x[i] !=x[i+2]:
			a = a + 1
			i = i + 1
   
		elif x[i] == x[i+1] and  x[i] == x[i+2] and x[i]!= 0:
			a = -1
			break
 
print(a)","import l

def g():
    f = l.stdin.read().split()

    n = int(f[0])
    m = int(f[1])

    c = [False] * (n + 1)
    a = [False] * (n + 1)
    d = 0
    b = 0
    
    h = []

    e = 2
    for _ in range(m):
        r = int(f[e])
        c = int(f[e + 1])
        e += 2

        if not c[r]:
            c[r] = True
            d += 1

        if not a[c]:
            a[c] = True
            b += 1

        k = n - d
        j = n - b
        i = k * j

        h.append(str(i))

    l.stdout.write("" "".join(h) + ""\n"")

if __name__ == ""__main__"":
    g()"
370,A,"Rook, Bishop and King",PROGRAMMING,"['graphs', 'math', 'shortest paths']","Little Petya is learning to play chess. He has already learned how to move a king, a rook and a bishop. Let us remind you the rules of moving chess pieces. A chessboard is 64 square fields organized into an 8<=×<=8 table. A field is represented by a pair of integers (*r*,<=*c*) — the number of the row and the number of the column (in a classical game the columns are traditionally indexed by letters). Each chess piece takes up exactly one field. To make a move is to move a chess piece, the pieces move by the following rules:
 -  A rook moves any number of fields horizontally or vertically. -  A bishop moves any number of fields diagonally. -  A king moves one field in any direction — horizontally, vertically or diagonally. 
Petya is thinking about the following problem: what minimum number of moves is needed for each of these pieces to move from field (*r*1,<=*c*1) to field (*r*2,<=*c*2)? At that, we assume that there are no more pieces besides this one on the board. Help him solve this problem.","The input contains four integers *r*1,<=*c*1,<=*r*2,<=*c*2 (1<=≤<=*r*1,<=*c*1,<=*r*2,<=*c*2<=≤<=8) — the coordinates of the starting and the final field. The starting field doesn't coincide with the final one.

You can assume that the chessboard rows are numbered from top to bottom 1 through 8, and the columns are numbered from left to right 1 through 8.","Print three space-separated integers: the minimum number of moves the rook, the bishop and the king (in this order) is needed to move from field (*r*1,<=*c*1) to field (*r*2,<=*c*2). If a piece cannot make such a move, print a 0 instead of the corresponding number.","['4 3 1 6\n', '5 5 5 6\n']","['2 1 3\n', '1 0 1\n']",none,OK,"def d(e,g,f,h):
    if (e+g)%2 == (f+h)%2:
        return True
    else:
        return False
e, g, f, h = map(int, input().split())
if e == f or g == h:
    c = 1
else:
    c = 2
b = max([abs(e-f),abs(g-h)])
if d(e,g,f,h):
    if (e-g) == (f-h) or e+g == f+h:
        a = 1
    else:
        a = 2
else:
    a = 0

print(c, a, b)","def e():
    import h

    b = h.stdin.read().split()
    if not b:
        return

    n = int(b[0])
    m = int(b[1])
    k = int(b[2])
    c = []
    d = 3
    for _ in range(n):
        c.append(b[d])
        d += 1

    g = [0] * m

    for i in range(n):
        for j in range(m):
            a = c[i][j]
            if a == '.':
                continue

            if a == 'L':
                f = j - i
                if f >= 0:
                    g[f] += 1

            elif a == 'R':
                f = j + i
                if f < m:
                    g[f] += 1

            elif a == 'U':
                if i % 2 == 0:

                    g[j] += 1

    h.stdout.write("" "".join(map(str, g)) + "" "")

if __name__ == ""__main__"":
    e()"
475,B,Strongly Connected City,PROGRAMMING,"['brute force', 'dfs and similar', 'graphs', 'implementation']","Imagine a city with *n* horizontal streets crossing *m* vertical streets, forming an (*n*<=-<=1)<=×<=(*m*<=-<=1) grid. In order to increase the traffic flow, mayor of the city has decided to make each street one way. This means in each horizontal street, the traffic moves only from west to east or only from east to west. Also, traffic moves only from north to south or only from south to north in each vertical street. It is possible to enter a horizontal street from a vertical street, or vice versa, at their intersection.

The mayor has received some street direction patterns. Your task is to check whether it is possible to reach any junction from any other junction in the proposed street direction pattern.","The first line of input contains two integers *n* and *m*, (2<=≤<=*n*,<=*m*<=≤<=20), denoting the number of horizontal streets and the number of vertical streets.

The second line contains a string of length *n*, made of characters '&lt;' and '&gt;', denoting direction of each horizontal street. If the *i*-th character is equal to '&lt;', the street is directed from east to west otherwise, the street is directed from west to east. Streets are listed in order from north to south.

The third line contains a string of length *m*, made of characters '^' and 'v', denoting direction of each vertical street. If the *i*-th character is equal to '^', the street is directed from south to north, otherwise the street is directed from north to south. Streets are listed in order from west to east.","If the given pattern meets the mayor's criteria, print a single line containing ""YES"", otherwise print a single line containing ""NO"".","['3 3\n&gt;&lt;&gt;\nv^v\n', '4 6\n&lt;&gt;&lt;&gt;\nv^v^v^\n']","['NO\n', 'YES\n']",The figure above shows street directions in the second sample test case.,WRONG_ANSWER,"def a(i,j):
    return i > -1 and i<n and j > -1 and j < m;

def b(i,j):
    j[i][j]=True
    g=[]

    i=j
    if d[i]=='v':
        h=i+1
    else:
        h=i-1
    
    e=i
    if c[j]=='>':
        f=j+1
    else:
        f=j-1
    
    if a(h,i):
        g.append((h,i))
        
        
    if a(e,f):
        g.append((e,f))
    
    for x in g:
        k,l=x
        if not j[k][l] :
            b(k,l)
    

n,m=map(int,input().split())
j=[]
c=input()
d=input()

for i in range(n):
    for j in range(m):
        j=[[ False for _ in range(m)] for _ in range(n)]
        b(i,j)
        for x in range(n):
            for y in range(m):
                if not j[x][y]:
                    print('NO')
                    exit()
                    
print('YES')","w = int(input().strip())

if w % 2 == 0 and w > 2:
    print(""YES"")
else:
    print(""NO"")"
797,A,k-Factorization,PROGRAMMING,"['implementation', 'math', 'number theory']","Given a positive integer *n*, find *k* integers (not necessary distinct) such that all these integers are strictly greater than 1, and their product is equal to *n*.","The first line contains two integers *n* and *k* (2<=≤<=*n*<=≤<=100000, 1<=≤<=*k*<=≤<=20).","If it's impossible to find the representation of *n* as a product of *k* numbers, print -1.

Otherwise, print *k* integers in any order. Their product must be equal to *n*. If there are multiple answers, print any of them.","['100000 2\n', '100000 20\n', '1024 5\n']","['2 50000 \n', '-1\n', '2 64 2 2 2 \n']",none,OK,"from math import sqrt

def c(x):
    a = [True] * (x + 1)
    d = []
    for i in range(2, x + 1):
        if a[i]:
            d.append(i)
            for j in range(2 * i, x + 1, i):
                a[j] = False
    return d

n, k = map(int, input().split())
f = c(n)
b = []
for e in f:
    while n % e == 0:
        n //= e
        b.append(e)
if len(b) < k:
    print(-1)
else:
    while len(b) > k:
        b.append(b.pop() * b.pop())
    print(*b)","import f

def b(s):
    a = 0

    for i in range(len(s)):
        if s[i] == 'Q':

            for j in range(i + 1, len(s)):
                if s[j] == 'A':

                    for k in range(j + 1, len(s)):
                        if s[k] == 'Q':
                            a += 1
    return a

if __name__ == '__main__':
    c = f.stdin.read().splitlines()

    for d in c:
        s = d.strip()
        if s:
            e = b(s)

            print(e)"
600,B,Queries about less or equal elements,PROGRAMMING,"['binary search', 'data structures', 'sortings', 'two pointers']",You are given two arrays of integers *a* and *b*. For each element of the second array *b**j* you should find the number of elements in array *a* that are less than or equal to the value *b**j*.,"The first line contains two integers *n*,<=*m* (1<=≤<=*n*,<=*m*<=≤<=2·105) — the sizes of arrays *a* and *b*.

The second line contains *n* integers — the elements of array *a* (<=-<=109<=≤<=*a**i*<=≤<=109).

The third line contains *m* integers — the elements of array *b* (<=-<=109<=≤<=*b**j*<=≤<=109).","Print *m* integers, separated by spaces: the *j*-th of which is equal to the number of such elements in array *a* that are less than or equal to the value *b**j*.","['5 4\n1 3 5 7 9\n6 4 2 8\n', '5 5\n1 2 1 2 5\n3 1 4 1 5\n']","['3 2 1 4\n', '4 2 4 2 5\n']",none,OK,"n, m = map(int, input().split())
A = list(map(int, input().split()))
B = list(map(int, input().split()))

A.sort()

g = []

def a(A, f):
    d = 0
    c = len(A) - 1
    
    while d <= c:
        e = (d + c) // 2
        if A[e] <= f:
            d = e + 1
        else:
            c = e - 1
    return d

for i in range(len(B)):
    b = a(A, B[i])
    g.append(b)
    print(b, end=' ')","def g():
    import h

    c = h.stdin.read().split()
    if not c:
        return
    t = int(c[0])
    f = []
    e = 1

    for _ in range(t):
        l = int(c[e])
        r = int(c[e + 1])
        e += 2

        b = l

        for a in range(64):

            d = b | (1 << a)

            if d <= r:
                b = d

        f.append(str(b))

    h.stdout.write(""\n"".join(f))

if __name__ == '__main__':
    g()"
903,B,The Modcrab,PROGRAMMING,"['greedy', 'implementation']","Vova is again playing some computer game, now an RPG. In the game Vova's character received a quest: to slay the fearsome monster called Modcrab.

After two hours of playing the game Vova has tracked the monster and analyzed its tactics. The Modcrab has *h*2 health points and an attack power of *a*2. Knowing that, Vova has decided to buy a lot of strong healing potions and to prepare for battle.

Vova's character has *h*1 health points and an attack power of *a*1. Also he has a large supply of healing potions, each of which increases his current amount of health points by *c*1 when Vova drinks a potion. All potions are identical to each other. It is guaranteed that *c*1<=&gt;<=*a*2.

The battle consists of multiple phases. In the beginning of each phase, Vova can either attack the monster (thus reducing its health by *a*1) or drink a healing potion (it increases Vova's health by *c*1; Vova's health can exceed *h*1). Then, if the battle is not over yet, the Modcrab attacks Vova, reducing his health by *a*2. The battle ends when Vova's (or Modcrab's) health drops to 0 or lower. It is possible that the battle ends in a middle of a phase after Vova's attack.

Of course, Vova wants to win the fight. But also he wants to do it as fast as possible. So he wants to make up a strategy that will allow him to win the fight after the minimum possible number of phases.

Help Vova to make up a strategy! You may assume that Vova never runs out of healing potions, and that he can always win.","The first line contains three integers *h*1, *a*1, *c*1 (1<=≤<=*h*1,<=*a*1<=≤<=100, 2<=≤<=*c*1<=≤<=100) — Vova's health, Vova's attack power and the healing power of a potion.

The second line contains two integers *h*2, *a*2 (1<=≤<=*h*2<=≤<=100, 1<=≤<=*a*2<=&lt;<=*c*1) — the Modcrab's health and his attack power.","In the first line print one integer *n* denoting the minimum number of phases required to win the battle.

Then print *n* lines. *i*-th line must be equal to HEAL if Vova drinks a potion in *i*-th phase, or STRIKE if he attacks the Modcrab.

The strategy must be valid: Vova's character must not be defeated before slaying the Modcrab, and the monster's health must be 0 or lower after Vova's last action.

If there are multiple optimal solutions, print any of them.","['10 6 100\n17 5\n', '11 6 100\n12 5\n']","['4\nSTRIKE\nHEAL\nSTRIKE\nSTRIKE\n', '2\nSTRIKE\nSTRIKE\n']","In the first example Vova's character must heal before or after his first attack. Otherwise his health will drop to zero in 2 phases while he needs 3 strikes to win.

In the second example no healing needed, two strikes are enough to get monster to zero health and win with 6 health left.",WRONG_ANSWER,"import bisect

def g(s):    
    print(' '.join(map(str, s)))
    
def f(s='int'):
    if s == 'int':
        return list(map(int, input().split()))    
    elif s == 'float':
        return list(map(float, input().split()))
    return list(map(str, input().split()))

[d, a, c] = list(map(int, input().split()))
[e, b] = list(map(int, input().split()))

h = list()
while True:
    if d > b:
        h.append('STRIKE')
        e -= a
        d -= b
    else:
        h.append('HEAL')
        d += c
        d -= b
    if e <= 0:
        break
print(len(h))
for e in h:
    print(e)","import d

def b():

    a = d.stdin.read().split()
    if not a:
        return

    n = int(a[0])
    m = int(a[1])

    if n == 0:
        print(0)
        return

    c = (n + 1) // 2

    if c % m == 0:
        t = c
    else:
        t = ((c // m) + 1) * m

    if t > n:
        print(-1)
    else:
        print(t)

if __name__ == '__main__':
    b()"
159,C,String Manipulation 1.0,PROGRAMMING,"['*special', 'binary search', 'brute force', 'data structures', 'strings']","One popular website developed an unusual username editing procedure. One can change the username only by deleting some characters from it: to change the current name *s*, a user can pick number *p* and character *c* and delete the *p*-th occurrence of character *c* from the name. After the user changed his name, he can't undo the change.

For example, one can change name ""arca"" by removing the second occurrence of character ""a"" to get ""arc"". 

Polycarpus learned that some user initially registered under nickname *t*, where *t* is a concatenation of *k* copies of string *s*. Also, Polycarpus knows the sequence of this user's name changes. Help Polycarpus figure out the user's final name.","The first line contains an integer *k* (1<=≤<=*k*<=≤<=2000). The second line contains a non-empty string *s*, consisting of lowercase Latin letters, at most 100 characters long. The third line contains an integer *n* (0<=≤<=*n*<=≤<=20000) — the number of username changes. Each of the next *n* lines contains the actual changes, one per line. The changes are written as ""*p**i* *c**i*"" (without the quotes), where *p**i* (1<=≤<=*p**i*<=≤<=200000) is the number of occurrences of letter *c**i*, *c**i* is a lowercase Latin letter. It is guaranteed that the operations are correct, that is, the letter to be deleted always exists, and after all operations not all letters are deleted from the name. The letters' occurrences are numbered starting from 1.",Print a single string — the user's final name after all changes are applied to it.,"['2\nbac\n3\n2 a\n1 b\n2 c\n', '1\nabacaba\n4\n1 a\n1 a\n1 c\n2 b\n']","['acb\n', 'baa\n']","Let's consider the first sample. Initially we have name ""bacbac""; the first operation transforms it into ""bacbc"", the second one — to ""acbc"", and finally, the third one transforms it into ""acb"".",OK,"from collections import b
k = int(input())
s = input()
d = b(list)
c = list(s*k)
for i in range(len(c)):
    d[c[i]].append(i)
n = int(input())
for _ in range(n):
    a,b = input().split()
    a = int(a)
    a = d[b].pop(a-1)
    c[a] = ''
print(''.join(c))","""""""
We simulate the match using the positions of wins for each player.
For each candidate value of t (the number of points needed to win a set),
we partition the record into sets using binary search on precomputed positions.
Then, if the segmentation exactly uses all serves and the match ends immediately 
after one player wins s sets (with no extra sets after that), we add (s, t).
""""""

import u
import a

def j():
    f = u.stdin.read().split()
    if not f:
        return

    n = int(f[0])
    r = list(map(int, f[1:]))

    m = []
    n = []
    for i, a in enumerate(r):
        if a == 1:
            m.append(i)
        else:
            n.append(i)
    
    w = len(m)
    x = len(n)

    k = max(w, x) if (w or x) else 0
    
    z = []

    for t in range(1, k + 1):
        e = 0
        t = []
        y = True

        while e < n:

            h = a.bisect_left(m, e)
            b = None
            if h + t - 1 < len(m):
                b = m[h + t - 1]

            i = a.bisect_left(n, e)
            c = None
            if i + t - 1 < len(n):
                c = n[i + t - 1]

            if b is None and c is None:
                y = False
                break

            if b is not None and c is not None:
                if b < c:
                    { = 1
                    s = b
                elif c < b:
                    { = 2
                    s = c
                else:

                    { = 1
                    s = b
            elif b is not None:
                { = 1
                s = b
            else:
                { = 2
                s = c

            t.append({)

            e = s + 1

        if not y or e != n:
            continue

        | = sum(1 for w in t if w == 1)
        } = sum(1 for w in t if w == 2)

        if | == }:
            continue
        g = 1 if | > } else 2
        d = | if g == 1 else }

        p = 0
        o = False

        for i in range(len(t) - 1):
            if t[i] == g:
                p += 1
            if p == d:
                o = True
                break
        if o:
            continue

        z.append((d, t))

    z.sort(key=lambda x: (x[0], x[1]))
    l = [str(len(z))]
    for q, v in z:
        l.append(f""{q} {v}"")
    u.stdout.write(""\n"".join(l))

if __name__ == '__main__':
    j()"
0,none,none,none,['none'],Kyoya Ootori has a bag with *n* colored balls that are colored with *k* different colors. The colors are labeled from 1 to *k*. Balls of the same color are indistinguishable. He draws balls from the bag one by one until the bag is empty. He noticed that he drew the last ball of color *i* before drawing the last ball of color *i*<=+<=1 for all *i* from 1 to *k*<=-<=1. Now he wonders how many different ways this can happen.,"The first line of input will have one integer *k* (1<=≤<=*k*<=≤<=1000) the number of colors.

Then, *k* lines will follow. The *i*-th line will contain *c**i*, the number of balls of the *i*-th color (1<=≤<=*c**i*<=≤<=1000).

The total number of balls doesn't exceed 1000.","A single integer, the number of ways that Kyoya can draw the balls from the bag as described in the statement, modulo 1<=000<=000<=007.","['3\n2\n2\n1\n', '4\n1\n2\n3\n4\n']","['3\n', '1680\n']","In the first sample, we have 2 balls of color 1, 2 balls of color 2, and 1 ball of color 3. The three ways for Kyoya are:",RUNTIME_ERROR,"import f
a = 1000000007

def e(m, c, C, k, z):
    global a
    if m == 0:
        return 1

    if c < 0:
        c = 0

    b = 0
    for i in range(c, k):
        if C[i] != 0:
            C[i] -= 1
            b += e(m-1, min(i-1, c), C, k, z+[i])
            C[i] += 1
    return divmod(b, a)[1]

k   = int(input())
C   = []

for i in range(k):
    C.append(int(input()))

n   = sum(C)

d = f.f()

b = e(n, k-1, C, k, [])

print(b)
c = f.f()","def i():
    import l
    e = l.stdin.read().split()
    if not e:
        return
    h = int(e[0])

    a = list(map(int, e[1:1 + h + 1]))

    a = -1
    for i in range(1, h):
        if a[i] > 1 and a[i + 1] > 1:
            a = i
            break

    if a == -1:
        l.stdout.write(""perfect"")
        return

    h = []
    d = 1
    g = [d]
    h.append(g)
    d += 1

    for f in range(1, h + 1):
        c = a[f]
        m = list(range(d, d + c))
        h.append(m)
        d += c
    n = d - 1

    o = [0] * (n + 1)
    for f in range(1, h + 1):
        k = h[f - 1][0]
        for v in h[f]:
            o[v] = k

    q = o[:]

    b = a + 1

    q[h[b][0]] = h[a][1]

    j = []
    j.append(""ambiguous"")
    p = "" "".join(str(o[i]) for i in range(1, n + 1))
    r = "" "".join(str(q[i]) for i in range(1, n + 1))
    j.append(p)
    j.append(r)
    l.stdout.write(""\n"".join(j))

if __name__ == '__main__':
    i()"
988,E,Divisibility by 25,PROGRAMMING,"['brute force', 'greedy']","You are given an integer $n$ from $1$ to $10^{18}$ without leading zeroes.

In one move you can swap any two adjacent digits in the given number in such a way that the resulting number will not contain leading zeroes. In other words, after each move the number you have cannot contain any leading zeroes.

What is the minimum number of moves you have to make to obtain a number that is divisible by $25$? Print -1 if it is impossible to obtain a number that is divisible by $25$.",The first line contains an integer $n$ ($1 \le n \le 10^{18}$). It is guaranteed that the first (left) digit of the number $n$ is not a zero.,"If it is impossible to obtain a number that is divisible by $25$, print -1. Otherwise print the minimum number of moves required to obtain such number.

Note that you can swap only adjacent digits in the given number.","['5071\n', '705\n', '1241367\n']","['4\n', '1\n', '-1\n']",In the first example one of the possible sequences of moves is 5071 $\rightarrow$ 5701 $\rightarrow$ 7501 $\rightarrow$ 7510 $\rightarrow$ 7150.,WRONG_ANSWER,"from collections import *
from heapq import *
from bisect import *
from itertools import *
from functools import *
from math import *
from string import *
import l

input = l.stdin.readline

d = [[2, 5], [5, 0], [7, 5], [0, 0]]

def b(i, g, x, y):

    if x not in g or y not in g:
        return f

    if x == y and len(g[x]) < 2:
        return f

    A = str(i)
    x, y = str(x), str(y)

    a = 0
    j = A.rindex(y)
    a += len(A) - 1 - j
    A = A[:j] + A[j + 1 :]

    i = A.rindex(x)
    A = A[:i] + A[i + 1 :]
    a += len(A) - i

    while i < len(A) and A[i] == 0:
        a += 1
        i += 1

    return a

def k(n):
    if n % 25 == 0:
        return 0

    j = len(str(n))

    g = e(list)
    for i, x in enumerate(map(int, str(n))):
        g[x].append(i)

    a = f
    for c in d:
        a = min(a, b(n, g, *c))

    return a if a < f else -1

def h():
    n = int(input())
    print(k(n))

if __name__ == ""__main__"":
    h()","import o

def i():
    c = o.stdin.read().split()
    if not c: 
        return
    h = iter(c)
    n = int(next(h))
    m = int(next(h))

    if m < 2:
        o.stdout.write(""0"")
        return

    m = 0

    d = [0] * (n + 1)

    g = [[] for _ in range(n+1)]

    p = [False] * (n + 1)
    k = 0

    for _ in range(m):
        u = int(next(h))
        v = int(next(h))
        p[u] = True
        p[v] = True
        if u == v:

            m += 1

            g[u].append(u)
        else:

            d[u] += 1
            d[v] += 1
            k += 1

            g[u].append(v)
            g[v].append(u)

    n = None
    for i in range(1, n+1):
        if p[i]:
            n = i
            break
    if n is None:
        o.stdout.write(""0"")
        return

    from collections import e
    f = e([n])
    q = [False] * (n + 1)
    q[n] = True
    while f:
        b = f.popleft()
        for j in g[b]:
            if not q[j]:
                q[j] = True
                f.append(j)
    for i in range(1, n+1):
        if p[i] and not q[i]:
            o.stdout.write(""0"")
            return

    L = m
    a = k
    
    l = 0

    if L >= 2:
        l += L * (L - 1) // 2

    l += L * a

    for v in range(1, n+1):
        if d[v] >= 2:
            l += d[v] * (d[v] - 1) // 2

    o.stdout.write(str(l))
    
if __name__ == '__main__':
    i()"
873,D,Merge Sort,PROGRAMMING,"['constructive algorithms', 'divide and conquer']","Merge sort is a well-known sorting algorithm. The main function that sorts the elements of array *a* with indices from [*l*,<=*r*) can be implemented as follows:
 1.  If the segment [*l*,<=*r*) is already sorted in non-descending order (that is, for any *i* such that *l*<=≤<=*i*<=&lt;<=*r*<=-<=1 *a*[*i*]<=≤<=*a*[*i*<=+<=1]), then end the function call; 1.  Let ; 1.  Call *mergesort*(*a*,<=*l*,<=*mid*); 1.  Call *mergesort*(*a*,<=*mid*,<=*r*); 1.  Merge segments [*l*,<=*mid*) and [*mid*,<=*r*), making the segment [*l*,<=*r*) sorted in non-descending order. The merge algorithm doesn't call any other functions. 
The array in this problem is 0-indexed, so to sort the whole array, you need to call *mergesort*(*a*,<=0,<=*n*).

The number of calls of function *mergesort* is very important, so Ivan has decided to calculate it while sorting the array. For example, if *a*<==<={1,<=2,<=3,<=4}, then there will be 1 call of *mergesort* — *mergesort*(0,<=4), which will check that the array is sorted and then end. If *a*<==<={2,<=1,<=3}, then the number of calls is 3: first of all, you call *mergesort*(0,<=3), which then sets *mid*<==<=1 and calls *mergesort*(0,<=1) and *mergesort*(1,<=3), which do not perform any recursive calls because segments (0,<=1) and (1,<=3) are sorted.

Ivan has implemented the program that counts the number of *mergesort* calls, but now he needs to test it. To do this, he needs to find an array *a* such that *a* is a permutation of size *n* (that is, the number of elements in *a* is *n*, and every integer number from [1,<=*n*] can be found in this array), and the number of *mergesort* calls when sorting the array is exactly *k*.

Help Ivan to find an array he wants!","The first line contains two numbers *n* and *k* (1<=≤<=*n*<=≤<=100000, 1<=≤<=*k*<=≤<=200000) — the size of a desired permutation and the number of *mergesort* calls required to sort it.","If a permutation of size *n* such that there will be exactly *k* calls of *mergesort* while sorting it doesn't exist, output <=-<=1. Otherwise output *n* integer numbers *a*[0],<=*a*[1],<=...,<=*a*[*n*<=-<=1] — the elements of a permutation that would meet the required conditions. If there are multiple answers, print any of them.","['3 3\n', '4 1\n', '5 6\n']","['2 1 3 ', '1 2 3 4 ', '-1\n']",none,OK,"n, m = list(map(int, input().split()))
 
f = []
 
def c(b, a, e):
	if e < 2:
		f.extend(range(b, a))
		return e
	if a - b == 1:
		f.append(b)
		return e
	e -= 2
	d = (b + a + 1)//2
	e = c(d, a, e)
	e = c(b, d, e)
	return e
 
e = c(1, n + 1, m - 1)
if e == 0:
	print(' '.join(map(str, f)))
else:
	print(-1)","def c():

    n = int(input())

    e = [int(input()) for _ in range(n)]

    f = 0

    for i in range(n):
        b = 0
        a = i

        while a != -1:
            b += 1

            d = e[a]
            if d == -1:
                break

            a = d - 1

        f = max(f, b)

    print(f)

if __name__ == ""__main__"":
    c()"
320,A,Magic Numbers,PROGRAMMING,"['brute force', 'greedy']","A magic number is a number formed by concatenation of numbers 1, 14 and 144. We can use each of these numbers any number of times. Therefore 14144, 141414 and 1411 are magic numbers but 1444, 514 and 414 are not.

You're given a number. Determine if it is a magic number or not.","The first line of input contains an integer *n*, (1<=≤<=*n*<=≤<=109). This number doesn't contain leading zeros.","Print ""YES"" if *n* is a magic number or print ""NO"" if it's not.","['114114\n', '1111\n', '441231\n']","['YES\n', 'YES\n', 'NO\n']",none,WRONG_ANSWER,"s = input()

def b(s):
	a = 0 
	for i in range(len(s)):
		if a >= 2: return ""NO""
		if s[i] == '4': a += 1
		elif s[i] == '1': a = 0
		elif s[i] != '4' and s[i] != '1': return ""NO""
	return ""YES""

print(b(s))","def d():
    import f
    b = f.stdin.read().strip().split()
    if not b:
        return

    try:
        n = int(b[0])
        k = int(b[1])
    except:
        return

    if n == 1:
        if k == 0:
            print(1)
        else:
            print(-1)
        return

    m = n // 2

    if m > k:
        print(-1)
        return

    c = k - m
    L = c + 1

    if 2 * L > 10**9:
        print(-1)
        return

    e = []

    e.append(L)
    e.append(2 * L)

    a = 2 * L + 1

    for i in range(1, m):
        if a + 1 > 10**9:
            print(-1)
            return
        e.append(a)
        e.append(a + 1)
        a += 2

    if n % 2 == 1:
        if a > 10**9:
            print(-1)
            return
        e.append(a)

    print("" "".join(map(str, e)))

if __name__ == '__main__':
    d()"
110,A,Nearly Lucky Number,PROGRAMMING,['implementation'],"Petya loves lucky numbers. We all know that lucky numbers are the positive integers whose decimal representations contain only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.

Unfortunately, not all numbers are lucky. Petya calls a number nearly lucky if the number of lucky digits in it is a lucky number. He wonders whether number *n* is a nearly lucky number.","The only line contains an integer *n* (1<=≤<=*n*<=≤<=1018).

Please do not use the %lld specificator to read or write 64-bit numbers in С++. It is preferred to use the cin, cout streams or the %I64d specificator.","Print on the single line ""YES"" if *n* is a nearly lucky number. Otherwise, print ""NO"" (without the quotes).","['40047\n', '7747774\n', '1000000000000000000\n']","['NO\n', 'YES\n', 'NO\n']","In the first sample there are 3 lucky digits (first one and last two), so the answer is ""NO"".

In the second sample there are 7 lucky digits, 7 is lucky number, so the answer is ""YES"".

In the third sample there are no lucky digits, so the answer is ""NO"".",OK,"x = str(input())
def c(x):
    b = 0
    for a in x:
        if a == ""4"" or a == ""7"":
            b += 1
            continue
    b = str(b)
    b = b.replace(""4"","""")
    b = b.replace(""7"","""")
    if len(b) == 0:
        print(""YES"")
    else:
        print(""NO"")
c(x)","def c():
    import f
    input = f.stdin.read
    a = input().split()

    n = int(a[0])
    b = []

    for i in range(n):
        d = int(a[2 * i + 1])
        e = int(a[2 * i + 2])
        b.append((d, e))

    b.sort(key=lambda x: x[0])

    for i in range(1, n):
        if b[i-1][1] > b[i][1]:
            f.stdout.write(""Happy Alex"")
            return
    
    f.stdout.write(""Poor Alex"")

if __name__ == ""__main__"":
    c()"
347,A,Difference Row,PROGRAMMING,"['constructive algorithms', 'implementation', 'sortings']","You want to arrange *n* integers *a*1,<=*a*2,<=...,<=*a**n* in some order in a row. Let's define the value of an arrangement as the sum of differences between all pairs of adjacent integers.

More formally, let's denote some arrangement as a sequence of integers *x*1,<=*x*2,<=...,<=*x**n*, where sequence *x* is a permutation of sequence *a*. The value of such an arrangement is (*x*1<=-<=*x*2)<=+<=(*x*2<=-<=*x*3)<=+<=...<=+<=(*x**n*<=-<=1<=-<=*x**n*).

Find the largest possible value of an arrangement. Then, output the lexicographically smallest sequence *x* that corresponds to an arrangement of the largest possible value.","The first line of the input contains integer *n* (2<=≤<=*n*<=≤<=100). The second line contains *n* space-separated integers *a*1, *a*2, ..., *a**n* (|*a**i*|<=≤<=1000).","Print the required sequence *x*1,<=*x*2,<=...,<=*x**n*. Sequence *x* should be the lexicographically smallest permutation of *a* that corresponds to an arrangement of the largest possible value.",['5\n100 -100 50 0 -50\n'],['100 -50 0 50 -100 \n'],"In the sample test case, the value of the output arrangement is (100 - ( - 50)) + (( - 50) - 0) + (0 - 50) + (50 - ( - 100)) = 200. No other arrangement has a larger value, and among all arrangements with the value of 200, the output arrangement is the lexicographically smallest one.

Sequence *x*<sub class=""lower-index"">1</sub>, *x*<sub class=""lower-index"">2</sub>, ... , *x*<sub class=""lower-index"">*p*</sub> is lexicographically smaller than sequence *y*<sub class=""lower-index"">1</sub>, *y*<sub class=""lower-index"">2</sub>, ... , *y*<sub class=""lower-index"">*p*</sub> if there exists an integer *r* (0 ≤ *r* &lt; *p*) such that *x*<sub class=""lower-index"">1</sub> = *y*<sub class=""lower-index"">1</sub>, *x*<sub class=""lower-index"">2</sub> = *y*<sub class=""lower-index"">2</sub>, ... , *x*<sub class=""lower-index"">*r*</sub> = *y*<sub class=""lower-index"">*r*</sub> and *x*<sub class=""lower-index"">*r* + 1</sub> &lt; *y*<sub class=""lower-index"">*r* + 1</sub>.",WRONG_ANSWER,"def c(n, a):
    a.sort()
    b = []
    print(a)
    if a[0] < 0:
        b.append(a[-1])
        for i in range(1,n-1):
            b.append(a[i])
        b.append(a[0])
    else:
        for i in range(n):
            b.append(a[-i-1])
    return b    
n = int(input())
a = list(map(int, input().split()))
b = c(n,a)
for i in range(n):
    print(b[i], end= ' ')
print()","import d

def c():

    f = input().strip()

    g = input().strip()

    h = f.count('+') - f.count('-')

    a = g.count('+') - g.count('-')

    j = g.count('?')

    b = h - a

    if j == 0:
        e = 1.0 if b == 0 else 0.0
        print(f""{e:.12f}"")
        return

    if (b + j) % 2 != 0:
        print(f""{0.0:.12f}"")
        return

    k = (b + j) // 2
    if k < 0 or k > j:
        print(f""{0.0:.12f}"")
        return

    k = d.comb(j, k)

    i = 2 ** j

    e = k / i
    print(f""{e:.12f}"")

if __name__ == ""__main__"":
    c()"
463,B,Caisa and Pylons,PROGRAMMING,"['brute force', 'implementation', 'math']","Caisa solved the problem with the sugar and now he is on the way back to home. 

Caisa is playing a mobile game during his path. There are (*n*<=+<=1) pylons numbered from 0 to *n* in this game. The pylon with number 0 has zero height, the pylon with number *i* (*i*<=&gt;<=0) has height *h**i*. The goal of the game is to reach *n*-th pylon, and the only move the player can do is to jump from the current pylon (let's denote its number as *k*) to the next one (its number will be *k*<=+<=1). When the player have made such a move, its energy increases by *h**k*<=-<=*h**k*<=+<=1 (if this value is negative the player loses energy). The player must have non-negative amount of energy at any moment of the time. 

Initially Caisa stand at 0 pylon and has 0 energy. The game provides a special opportunity: one can pay a single dollar and increase the height of anyone pylon by one. Caisa may use that opportunity several times, but he doesn't want to spend too much money. What is the minimal amount of money he must paid to reach the goal of the game?","The first line contains integer *n* (1<=≤<=*n*<=≤<=105). The next line contains *n* integers *h*1, *h*2,<=..., *h**n* (1<=<=≤<=<=*h**i*<=<=≤<=<=105) representing the heights of the pylons.",Print a single number representing the minimum number of dollars paid by Caisa.,"['5\n3 4 3 2 4\n', '3\n4 4 4\n']","['4\n', '4\n']",In the first sample he can pay 4 dollars and increase the height of pylon with number 0 by 4 units. Then he can safely pass to the last pylon.,OK,"import math
import f
input = f.stdin.readline
from collections import deque, c
import heapq
def b(a):
    c = c(lambda : 0)
    for d in a:
        c[d] += 1
    return c

def e(): return [int(k) for k in input().split()]

n = int(input())
a = e()

print(max(a))","def c():
    import h
    a = h.stdin.read().strip().split()
    if not a:
        return
    n = int(a[0])
    k = int(a[1])

    f = 1

    d = n * n

    i = [[0] * n for _ in range(n)]
    
    b = 0

    for i in range(n):

        for j in range(k - 1):
            i[i][j] = f
            f += 1

        g = d - (n - k)

        b += g
        for j in range(k - 1, n):
            i[i][j] = g + (j - (k - 1))

        d -= (n - k + 1)

    e = []
    e.append(str(b))
    for i in range(n):
        e.append("" "".join(map(str, i[i])))
    h.stdout.write(""\n"".join(e))
    
if __name__ == '__main__':
    c()"
0,none,none,none,['none'],"Let's define the sum of two permutations *p* and *q* of numbers 0,<=1,<=...,<=(*n*<=-<=1) as permutation , where *Perm*(*x*) is the *x*-th lexicographically permutation of numbers 0,<=1,<=...,<=(*n*<=-<=1) (counting from zero), and *Ord*(*p*) is the number of permutation *p* in the lexicographical order.

For example, *Perm*(0)<==<=(0,<=1,<=...,<=*n*<=-<=2,<=*n*<=-<=1), *Perm*(*n*!<=-<=1)<==<=(*n*<=-<=1,<=*n*<=-<=2,<=...,<=1,<=0)

Misha has two permutations, *p* and *q*. Your task is to find their sum.

Permutation *a*<==<=(*a*0,<=*a*1,<=...,<=*a**n*<=-<=1) is called to be lexicographically smaller than permutation *b*<==<=(*b*0,<=*b*1,<=...,<=*b**n*<=-<=1), if for some *k* following conditions hold: *a*0<==<=*b*0,<=*a*1<==<=*b*1,<=...,<=*a**k*<=-<=1<==<=*b**k*<=-<=1,<=*a**k*<=&lt;<=*b**k*.","The first line contains an integer *n* (1<=≤<=*n*<=≤<=200<=000).

The second line contains *n* distinct integers from 0 to *n*<=-<=1, separated by a space, forming permutation *p*.

The third line contains *n* distinct integers from 0 to *n*<=-<=1, separated by spaces, forming permutation *q*.","Print *n* distinct integers from 0 to *n*<=-<=1, forming the sum of the given permutations. Separate the numbers by spaces.","['2\n0 1\n0 1\n', '2\n0 1\n1 0\n', '3\n1 2 0\n2 1 0\n']","['0 1\n', '1 0\n', '1 0 2\n']","Permutations of numbers from 0 to 1 in the lexicographical order: (0, 1), (1, 0).

In the first sample *Ord*(*p*) = 0 and *Ord*(*q*) = 0, so the answer is <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/8ce4cd76db7c3f712f9101b410c36891976581b8.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>.

In the second sample *Ord*(*p*) = 0 and *Ord*(*q*) = 1, so the answer is <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/5684e4e2deb5ed60419a5c9e765f0cd4cb995652.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>.

Permutations of numbers from 0 to 2 in the lexicographical order: (0, 1, 2), (0, 2, 1), (1, 0, 2), (1, 2, 0), (2, 0, 1), (2, 1, 0).

In the third sample *Ord*(*p*) = 3 and *Ord*(*q*) = 5, so the answer is <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/da14f774ebda9f417649f5334d329ec7b7c07778.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>.",TIME_LIMIT_EXCEEDED,"import l

class a:
    
    def __init__(k, a, b):
        k.range = (a, b)
        if a == b:
            k.active = 1
            k.left = None
            k.rigt = None
            return
        else:
            g = (a + b) // 2
            k.left = a(a, g)
            k.right = a(g + 1, b)
            k.active = k.left.active + k.right.active
    
    def e(k, a, b):
        if b < k.range[0] or k.range[1] < a:
            return 0
        if a <= k.range[0] and k.range[1] <= b:
            return k.active
        return k.left.e(a, b) + k.right.e(a, b)
    
    def d(k, x):
        if k.range[0] == x and k.range[1] == x:
            k.active = 0
            return
        if x < k.range[0] or k.range[1] < x:
            return
        k.left.d(x)
        k.right.d(x)
        k.active = k.left.active + k.right.active        

    def f(k, x):
        if k.range[0] == k.range[1]:
            return k.range[0]
        if k.left.active >= x:
            return k.left.f(x)
        else:
            return k.right.f(x - k.left.active)

def b(p, n):
    t = a(0, n-1)
    j = []
    for x in p:
        j.append(t.e(0, x) - 1)
        t.d(x)
    return j

def h(p, q):
    n = len(p)
    j = [0 for i in range(n)]
    i = 0
    for i in range(1, n):
        s = p[n-i-1] + q[n-i-1] + i
        j[n-i-1] = s % (i + 1)
        i = 1 if s > i else 0
    return j

def c(p, n):
    t = a(0, n-1)
    j = []
    for x in p:
        d = t.f(x + 1)
        j.append(d)
        t.d(d)
    return j    

n = int(l.stdin.readline())
p = [int(x) for x in l.stdin.readline().split()]
q = [int(x) for x in l.stdin.readline().split()]

p = b(p, n)
q = b(q, n)
r = c(h(p, q), n)

print(' '.join(str(x) for x in r))","def g():
    import i
    d = i.stdin.read().splitlines()
    if not d:
        return
    n = int(d[0])

    h = set(""abcdefghijklmnopqrstuvwxyz"")
    e = 0
    j = False

    for i in range(1, n + 1):
        f = d[i]

        a = f[0]
        b = f[2:]

        if a == ""!"":
            if j:
                e += 1
        elif a == ""?"":

            if i != n and j:
                e += 1

        if a == ""."":

            for c in b:
                h.discard(c)
        elif a == ""!"":

            h &= set(b)
        elif a == ""?"":

            if i != n:
                h.discard(b)

        if not j and len(h) == 1 and i != n:
            j = True

    i.stdout.write(str(e))

if __name__ == '__main__':
    g()"
369,B,Valera and Contest,PROGRAMMING,"['constructive algorithms', 'implementation', 'math']","Valera loves to participate in competitions. Especially in programming contests. Today he has participated in the contest with his team, consisting of *n* students (including Valera). This contest was an individual competition, so each student in the team solved problems individually.

After the contest was over, Valera was interested in results. He found out that:
 -  each student in the team scored at least *l* points and at most *r* points; -  in total, all members of the team scored exactly *s**all* points; -  the total score of the *k* members of the team who scored the most points is equal to exactly *s**k*; more formally, if *a*1,<=*a*2,<=...,<=*a**n* is the sequence of points earned by the team of students in the non-increasing order (*a*1<=≥<=*a*2<=≥<=...<=≥<=*a**n*), then *s**k*<==<=*a*1<=+<=*a*2<=+<=...<=+<=*a**k*. 
However, Valera did not find out exactly how many points each of *n* students scored. Valera asked you to recover any distribution of scores between the students of the team, such that all the conditions above are met.","The first line of the input contains exactly six integers *n*,<=*k*,<=*l*,<=*r*,<=*s**all*,<=*s**k* (1<=≤<=*n*,<=*k*,<=*l*,<=*r*<=≤<=1000; *l*<=≤<=*r*; *k*<=≤<=*n*; 1<=≤<=*s**k*<=≤<=*s**all*<=≤<=106).

It's guaranteed that the input is such that the answer exists.","Print exactly *n* integers *a*1,<=*a*2,<=...,<=*a**n* — the number of points each student scored. If there are multiple solutions, you can print any of them. You can print the distribution of points in any order.","['5 3 1 3 13 9\n', '5 3 1 3 15 9\n']","['2 3 2 3 3 ', '3 3 3 3 3 ']",none,WRONG_ANSWER,"def j(a, h, c, d, e, i, b):
    for i in range(h, c+1):
        if b + e - d < i:
            b += (e-d)
            a[i] = e
        else:
            a[i] += i - b
            return

n, k, l, r, f, g = map(int, input().split())
a = [l]*(n)
j(a, 0, k-1,l, r, g, l*k)
j(a, k, n-1, l, r, f, g + l*(n-k))
print(*a)","def e(j):
    """"""
    Generate all lucky numbers with a number of digits up to max_length.
    Lucky numbers are numbers whose decimal representation contains 
    only the digits 4 and 7.
    """"""
    g = []
    
    def d(b, f):
        if f > j:
            return
        if b:

            g.append(int(b))

        d(b + '4', f + 1)
        d(b + '7', f + 1)
        
    d("""", 0)
    return g

def i():
    import l

    c = l.stdin.read().split()
    if not c:
        return
    l = int(c[0])
    r = int(c[1])

    j = len(str(r)) + 1
    h = e(j)

    h.sort()
    
    m = 0
    b = l

    for k in h:
        if b > r:
            break
        if k < b:
            continue

        n = min(k, r)

        a = n - b + 1

        m += k * a
        b = n + 1

    l.stdout.write(str(m))
    
if __name__ == '__main__':
    i()"
25,A,IQ test,PROGRAMMING,['brute force'],"Bob is preparing to pass IQ test. The most frequent task in this test is to find out which one of the given *n* numbers differs from the others. Bob observed that one number usually differs from the others in evenness. Help Bob — to check his answers, he needs a program that among the given *n* numbers finds one that is different in evenness.","The first line contains integer *n* (3<=≤<=*n*<=≤<=100) — amount of numbers in the task. The second line contains *n* space-separated natural numbers, not exceeding 100. It is guaranteed, that exactly one of these numbers differs from the others in evenness.",Output index of number that differs from the others in evenness. Numbers are numbered from 1 in the input order.,"['5\n2 4 7 8 10\n', '4\n1 2 1 1\n']","['3\n', '2\n']",none,RUNTIME_ERROR,"n, k = input().split()
k = int(k)

l = [int(x) for x in input().split() if int(x) !=0]
l.sort()

def a(l, k):
	for s in range(k):
		b = l[0]
		print(b)
		l = [x-b for x in l if x-b > 0 ]
		if not l:
			return k-s

	return 0

r = a(l, k-1)
for _ in range(r):
	print(0)","def j():
    import o
    o.setrecursionlimit(300000)
    b = o.stdin.read().split()
    if not b:
        return
    q = int(b[0])
    m = []
    k = 0
    e = 1
    for _ in range(q):
        n = int(b[e])
        k = int(b[e + 1])
        e += 2
        m.append((n, k))
        if n > k:
            k = n

    A = ""What are you doing while sending \""""
    B = ""\""? Are you busy? Will you send \""""
    C = ""\""?""
    g = len(A)
    h = len(B)
    i = len(C)

    c = ""What are you doing at the end of the world? Are you busy? Will you save us?""
    f = len(c)

    a = 10**19

    L = [0] * (k + 1)
    L[0] = f
    for i in range(1, k + 1):
        l = L[i - 1]

        p = g + l + h + l + i
        L[i] = p if p <= a else a

    def d(n, k):
        while n > 0:
            if k > L[n]:
                return '.'

            if k <= g:
                return A[k - 1]
            k -= g

            if k <= L[n - 1]:
                n -= 1
                continue
            k -= L[n - 1]

            if k <= h:
                return B[k - 1]
            k -= h

            if k <= L[n - 1]:
                n -= 1
                continue
            k -= L[n - 1]

            if k <= i:
                return C[k - 1]
            else:
                return '.'

        if k > L[0]:
            return '.'
        return c[k - 1]

    n = []
    for n, k in m:
        n.append(d(n, k))
    o.stdout.write("""".join(n))

if __name__ == '__main__':
    j()"
0,none,none,none,['none'],"Alyona's mother wants to present an array of *n* non-negative integers to Alyona. The array should be special. 

Alyona is a capricious girl so after she gets the array, she inspects *m* of its subarrays. Subarray is a set of some subsequent elements of the array. The *i*-th subarray is described with two integers *l**i* and *r**i*, and its elements are *a*[*l**i*],<=*a*[*l**i*<=+<=1],<=...,<=*a*[*r**i*].

Alyona is going to find mex for each of the chosen subarrays. Among these *m* mexes the girl is going to find the smallest. She wants this minimum mex to be as large as possible. 

You are to find an array *a* of *n* elements so that the minimum mex among those chosen by Alyona subarrays is as large as possible.

The mex of a set *S* is a minimum possible non-negative integer that is not in *S*.","The first line contains two integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=105).

The next *m* lines contain information about the subarrays chosen by Alyona. The *i*-th of these lines contains two integers *l**i* and *r**i* (1<=≤<=*l**i*<=≤<=*r**i*<=≤<=*n*), that describe the subarray *a*[*l**i*],<=*a*[*l**i*<=+<=1],<=...,<=*a*[*r**i*].","In the first line print single integer — the maximum possible minimum mex.

In the second line print *n* integers — the array *a*. All the elements in *a* should be between 0 and 109.

It is guaranteed that there is an optimal answer in which all the elements in *a* are between 0 and 109.

If there are multiple solutions, print any of them.","['5 3\n1 3\n2 5\n4 5\n', '4 2\n1 4\n2 4\n']","['2\n1 0 2 1 0\n', '3\n5 2 0 1']","The first example: the mex of the subarray (1, 3) is equal to 3, the mex of the subarray (2, 5) is equal to 3, the mex of the subarray (4, 5) is equal to 2 as well, thus the minumal mex among the subarrays chosen by Alyona is equal to 2.",OK,"def c(a,n):
    d=float(""inf"")
    for l,r in a:
        d=min(d,r-l+1)
    print(d)
    for i in range(n):
        print(i%d,end="" "")
    return """"

a,b=map(int,input().strip().split())
b=[]
for i in range(b):
    x,y=map(int,input().strip().split())
    b.append([x,y])
print(c(b,a))","def b():
    import e

    a = e.stdin.read().split()
    if not a:
        return

    n = int(a[0])

    d = 0
    c = 0

    for i in range(n):

        x = int(a[2 * i + 1])

        if x > 0:
            d += 1
        else:

            c += 1

    if d == 0 or c == 0 or d == 1 or c == 1:
        e.stdout.write(""Yes"")
    else:
        e.stdout.write(""No"")

if __name__ == '__main__':
    b()"
937,B,Vile Grasshoppers,PROGRAMMING,"['brute force', 'math', 'number theory']","The weather is fine today and hence it's high time to climb the nearby pine and enjoy the landscape.

The pine's trunk includes several branches, located one above another and numbered from 2 to *y*. Some of them (more precise, from 2 to *p*) are occupied by tiny vile grasshoppers which you're at war with. These grasshoppers are known for their awesome jumping skills: the grasshopper at branch *x* can jump to branches .

Keeping this in mind, you wisely decided to choose such a branch that none of the grasshoppers could interrupt you. At the same time you wanna settle as high as possible since the view from up there is simply breathtaking.

In other words, your goal is to find the highest branch that cannot be reached by any of the grasshoppers or report that it's impossible.",The only line contains two integers *p* and *y* (2<=≤<=*p*<=≤<=*y*<=≤<=109).,"Output the number of the highest suitable branch. If there are none, print -1 instead.","['3 6\n', '3 4\n']","['5\n', '-1\n']","In the first sample case grasshopper from branch 2 reaches branches 2, 4 and 6 while branch 3 is initially settled by another grasshopper. Therefore the answer is 5.

It immediately follows that there are no valid branches in second sample case.",OK,"from math import b
p,y = map(int,input().split())
def a(n, p):
    if n % 2 == 0 and n > 2:
        return False
    if p == 2: return True
    for x in range(3, min(p, int(b(n))) + 1, 2):
        if n % x == 0:
            return False
    return True

for i in range(y, p,-1):
    if a(i, p):
        print(i)
        exit()
        break
print(-1)","def b(s):
    d = ""hello""
    c = 0

    for a in s:

        if c < len(d) and a == d[c]:
            c += 1

        if c == len(d):
            return True
    return False

s = input().strip()

if b(s):
    print(""YES"")
else:
    print(""NO"")"
3,A,Shortest path of the king,PROGRAMMING,"['greedy', 'shortest paths']","The king is left alone on the chessboard. In spite of this loneliness, he doesn't lose heart, because he has business of national importance. For example, he has to pay an official visit to square *t*. As the king is not in habit of wasting his time, he wants to get from his current position *s* to square *t* in the least number of moves. Help him to do this.

In one move the king can get to the square that has a common side or a common vertex with the square the king is currently in (generally there are 8 different squares he can move to).","The first line contains the chessboard coordinates of square *s*, the second line — of square *t*.

Chessboard coordinates consist of two characters, the first one is a lowercase Latin letter (from a to h), the second one is a digit from 1 to 8.","In the first line print *n* — minimum number of the king's moves. Then in *n* lines print the moves themselves. Each move is described with one of the 8: L, R, U, D, LU, LD, RU or RD. 

L, R, U, D stand respectively for moves left, right, up and down (according to the picture), and 2-letter combinations stand for diagonal moves. If the answer is not unique, print any of them.",['a8\nh1\n'],['7\nRD\nRD\nRD\nRD\nRD\nRD\nRD\n'],none,WRONG_ANSWER,"import j
import math
from math import factorial, inf, gcd, sqrt
from heapq import *
from functools import *
from itertools import *
from collections import *
from typing import *
from bisect import *
import random
from j import i, stdout
j.setrecursionlimit(10**5)

def d():
    return i.readline().strip()

def c():
    return int(d())

def f():
    return map(int, d().split())

def e():
    return list(f())

s = d()
t = d()
s = (int(s[1]), ord(s[0]) - ord('a') + 1)
t = (int(t[1]), ord(t[0]) - ord('a') + 1)
q = b([s])
v = {s: 0}
while q:
    x, y = q.popleft()
    if (x, y) == t:
        break
    for i in range(-1, 2):
        for j in range(-1, 2):
            if i == 0 and j == 0:
                continue
            g, h = x + i, y + j
            if (g, h) not in v:
                v[(g, h)] = (x, y)
                q.append((g, h))
d = {
    (-1, -1): 'LU',
    (-1, 0): 'U',
    (-1, 1): 'RU',
    (0, -1): 'L',
    (0, 1): 'R',
    (1, -1): 'LD',
    (1, 0): 'D',
    (1, 1): 'RD'
}
a = []
while v[t] != 0:
    k = v[t]
    c = (k[0] - t[0], t[1] - k[1])

    a.append(d[c])
    t = k
print(len(a))
for i in a:
    print(i)","def d():
    import h

    c = h.stdin.read().split()
    if not c:
        return

    n = int(c[0])
    A = int(c[1])
    B = int(c[2])

    s = list(map(int, c[3:3+n]))

    f = s[0]

    e = s[1:]
    e.sort(reverse=True)

    g = sum(e)

    b = 0
    while A * f < B * (f + g) and e:

        a = e.pop(0)
        g -= a
        b += 1

    h.stdout.write(str(b))
    
if __name__ == '__main__':
    d()"
393,A,Nineteen,PROGRAMMING,[],"Alice likes word ""nineteen"" very much. She has a string *s* and wants the string to contain as many such words as possible. For that reason she can rearrange the letters of the string.

For example, if she has string ""xiineteenppnnnewtnee"", she can get string ""xnineteenppnineteenw"", containing (the occurrences marked) two such words. More formally, word ""nineteen"" occurs in the string the number of times you can read it starting from some letter of the string. Of course, you shouldn't skip letters.

Help her to find the maximum number of ""nineteen""s that she can get in her string.","The first line contains a non-empty string *s*, consisting only of lowercase English letters. The length of string *s* doesn't exceed 100.","Print a single integer — the maximum number of ""nineteen""s that she can get in her string.","['nniinneetteeeenn\n', 'nneteenabcnneteenabcnneteenabcnneteenabcnneteenabcii\n', 'nineteenineteen\n']","['2', '2', '2']",none,RUNTIME_ERROR,"def c(a):
    for b in a:
        d = ''
        for e in b:
            d += str(e) + ' '
        print(d)

n = int(input())
w = [[0 for i in range(n)] for i in range(n)]
a = [[0 for i in range(n)] for i in range(n)]
b = [[0 for i in range(n)] for i in range(n)]
for i in range(n):
    d = input().split(' ')
    for e in range(n):
        w[i][e] = int(d[e])
for i in range(n):
    for e in range(n):
        a[e][i] = a[i][e] = (w[i][e]+w[e][i]) / 2
        b[e][i] = w[e][i] - a[e][i]
c(a)
c(b)","import t
import numpy as r

c = -10**15

def o(A, B):

    r, m = A.shape
    l, c = B.shape
    C = r.full((r, c), c, dtype=r.int64)

    for i in range(r):

        C[i, :] = r.max(A[i, :].reshape(m, 1) + B, axis=0)
    return C

def p(n, p):
    n = n.shape[0]

    s = r.full((n, n), c, dtype=r.int64)
    for i in range(n):
        s[i, i] = 0
    f = n.copy()
    while p > 0:
        if p & 1:
            s = o(s, f)
        f = o(f, f)
        p //= 2
    return s

def q(v, M):

    return r.max(v.reshape(-1, 1) + M, axis=0)

def m():
    h = t.stdin.read().split()
    if not h:
        return

    n = int(h[0])
    T = int(h[1])

    e = list(map(int, h[2:2+n]))

    a = 300

    M = r.full((a, a), c, dtype=r.int64)

    for v in range(1, a+1):
        i = [c] * n
        for i in range(n):
            if e[i] >= v:
                i[i] = 1
                for j in range(i):
                    if e[j] <= e[i] and e[j] >= v and i[j] != c:
                        i[i] = max(i[i], i[j] + 1)

        g = [c] * (a+1)
        for i in range(n):
            if i[i] != c:
                w = e[i]
                g[w] = max(g[w], i[i])

        g[v] = max(g[v], 0)

        for w in range(1, a+1):
            M[v-1][w-1] = g[w]

    b = p(M, T)

    j = r.full(a, c, dtype=r.int64)
    j[0] = 0

    k = q(j, b)

    d = int(r.max(k))
    t.stdout.write(str(d) + ""\n"")

if __name__ == '__main__':
    m()"
0,none,none,none,['none'],"Little Nastya has a hobby, she likes to remove some letters from word, to obtain another word. But it turns out to be pretty hard for her, because she is too young. Therefore, her brother Sergey always helps her.

Sergey gives Nastya the word *t* and wants to get the word *p* out of it. Nastya removes letters in a certain order (one after another, in this order strictly), which is specified by permutation of letters' indices of the word *t*: *a*1... *a*|*t*|. We denote the length of word *x* as |*x*|. Note that after removing one letter, the indices of other letters don't change. For example, if *t*<==<=""nastya"" and *a*<==<=[4,<=1,<=5,<=3,<=2,<=6] then removals make the following sequence of words ""nastya""  ""nastya""  ""nastya""  ""nastya""  ""nastya""  ""nastya""  ""nastya"".

Sergey knows this permutation. His goal is to stop his sister at some point and continue removing by himself to get the word *p*. Since Nastya likes this activity, Sergey wants to stop her as late as possible. Your task is to determine, how many letters Nastya can remove before she will be stopped by Sergey.

It is guaranteed that the word *p* can be obtained by removing the letters from word *t*.","The first and second lines of the input contain the words *t* and *p*, respectively. Words are composed of lowercase letters of the Latin alphabet (1<=≤<=|*p*|<=&lt;<=|*t*|<=≤<=200<=000). It is guaranteed that the word *p* can be obtained by removing the letters from word *t*.

Next line contains a permutation *a*1,<=*a*2,<=...,<=*a*|*t*| of letter indices that specifies the order in which Nastya removes letters of *t* (1<=≤<=*a**i*<=≤<=|*t*|, all *a**i* are distinct).","Print a single integer number, the maximum number of letters that Nastya can remove.","['ababcba\nabb\n5 3 4 1 7 6 2\n', 'bbbabb\nbb\n1 6 3 4 2 5\n']","['3', '4']","In the first sample test sequence of removing made by Nastya looks like this:

""ababcba"" <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> ""ababcba"" <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> ""ababcba"" <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> ""ababcba"" 

Nastya can not continue, because it is impossible to get word ""abb"" from word ""ababcba"".

So, Nastya will remove only three letters.",TIME_LIMIT_EXCEEDED,"def a(b, c):
    s = len(c)
    r = len(b)
    k = 0
    for i in range(r):
        if k < s and b[i] == c[k]:
            k += 1        
        
    return k // s

def q(w, t, p, a):
    c = []
    for i in range(w):
        c.append(a[i] - 1)
    c.sort()
    s = []
    j = 0
    for i in range(len(t)):
        if j < w and i == c[j]:
            j += 1
        else:
            s.append(t[i])        
    return a(s, p)
 
def f(t, p, a):
    l = 0
    h = len(t)
    w = (l + h) // 2
    while not(q(w, t, p, a) == 1 and q(w + 1, t, p, a) == 0):
        if q(w, t, p, a) == 1:
            l = w
        else:
            h = w
        w = (l + h) // 2
        if w == 0:
            return 0
    return w    
 
t = list(input())
p = list(input())
a = list(map(int, input().split()))
print(f(t, p, a))","def h(n):

    if n < 2:
        return False
    if n == 2:
        return True
    if n % 2 == 0:
        return False
    i = 3

    while i * i <= n:
        if n % i == 0:
            return False
        i += 2
    return True

def i():
    import k
    g = k.stdin.read().split()

    if not g:
        return
    n = int(g[0])
    a = list(map(int, g[1:1 + n]))

    f = a.count(1)
    e = None
    if f > 0:
        for j in a:
            if j != 1 and h(j + 1):
                e = j
                break
    if f > 0:

        if e is not None:
            a = [1] * f + [e]
        else:
            a = [1] * f
    else:
        a = []

    b = []

    for i in range(n):
        for j in range(i + 1, n):
            if h(a[i] + a[j]):
                b = [a[i], a[j]]

                break
        if b:
            break

    c = [a[0]] if n > 0 else []

    d = a
    if len(b) > len(d):
        d = b
    if len(c) > len(d):
        d = c
    
    k.stdout.write(str(len(d)) + ""\n"")
    k.stdout.write("" "".join(map(str, d)) + ""\n"")

if __name__ == ""__main__"":
    i()"
347,B,Fixed Points,PROGRAMMING,"['brute force', 'implementation', 'math']","A permutation of length *n* is an integer sequence such that each integer from 0 to (*n*<=-<=1) appears exactly once in it. For example, sequence [0,<=2,<=1] is a permutation of length 3 while both [0,<=2,<=2] and [1,<=2,<=3] are not.

A fixed point of a function is a point that is mapped to itself by the function. A permutation can be regarded as a bijective function. We'll get a definition of a fixed point in a permutation. An integer *i* is a fixed point of permutation *a*0,<=*a*1,<=...,<=*a**n*<=-<=1 if and only if *a**i*<==<=*i*. For example, permutation [0,<=2,<=1] has 1 fixed point and permutation [0,<=1,<=2] has 3 fixed points.

You are given permutation *a*. You are allowed to swap two elements of the permutation at most once. Your task is to maximize the number of fixed points in the resulting permutation. Note that you are allowed to make at most one swap operation.","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=105). The second line contains *n* integers *a*0,<=*a*1,<=...,<=*a**n*<=-<=1 — the given permutation.",Print a single integer — the maximum possible number of fixed points in the permutation after at most one swap operation.,['5\n0 1 3 4 2\n'],['3\n'],none,TIME_LIMIT_EXCEEDED,"_ = input()
d = list(map(int, input().split(' ')))

def c(l: list) -> int:
    b = 0
    for i, e in enumerate(l):
        if i == e:
            b += 1
    return b

a = c(d)
m = 0
for i, e in enumerate(d):
    if i == e:
        continue
    if d.index(i) == e and d[e] == i:
        m = max(m, a + 2)
    else:
        m = max(m, a + 1)

print(m)","import g
from collections import a

def e():

    c = g.stdin.read().strip().split()
    if not c:
        return

    n = int(c[0])

    a = list(map(int, c[1:1+n]))

    b = list(map(int, c[1+n:1+2*n]))

    m = int(c[1+2*n])

    h = a + b

    d = a(h)
    
    f = 1

    for b in d.values():
        f = 1
        for i in range(1, b + 1):
            f = (f * i) % m
        f = (f * f) % m

    g.stdout.write(str(f))

if __name__ == '__main__':
    e()"
764,A,Taymyr is calling you,PROGRAMMING,"['brute force', 'implementation', 'math']","Comrade Dujikov is busy choosing artists for Timofey's birthday and is recieving calls from Taymyr from Ilia-alpinist.

Ilia-alpinist calls every *n* minutes, i.e. in minutes *n*, 2*n*, 3*n* and so on. Artists come to the comrade every *m* minutes, i.e. in minutes *m*, 2*m*, 3*m* and so on. The day is *z* minutes long, i.e. the day consists of minutes 1,<=2,<=...,<=*z*. How many artists should be killed so that there are no artists in the room when Ilia calls? Consider that a call and a talk with an artist take exactly one minute.","The only string contains three integers — *n*, *m* and *z* (1<=≤<=*n*,<=*m*,<=*z*<=≤<=104).",Print single integer — the minimum number of artists that should be killed so that there are no artists in the room when Ilia calls.,"['1 1 10\n', '1 2 5\n', '2 3 9\n']","['10\n', '2\n', '1\n']","Taymyr is a place in the north of Russia.

In the first test the artists come each minute, as well as the calls, so we need to kill all of them.

In the second test we need to kill artists which come on the second and the fourth minutes.

In the third test — only the artist which comes on the sixth minute.",RUNTIME_ERROR,"def a(a,b):
    if (a == 0):
        return b
    if (b == 0):
        return a
    if (a == b):
        return a
    if (a > b):
        return a(a-b, b)
    return a(a, b-a)
    
n,m,z=map(int,input().split())
if n>m:
    g=a(n,m)
else:
    g=a(m,n)
b=n*m//g
print(z//b)","import l
import i
import l

def g(n):
    if n < 2:
        return False

    for p in (2, 3, 5, 7, 11, 13, 17, 19, 23, 29):
        if n % p == 0:
            return n == p

    d = n - 1
    s = 0
    while d % 2 == 0:
        d //= 2
        s += 1

    for a in (2, 7, 61):
        if a % n == 0:
            continue
        x = pow(a, d, n)
        if x == 1 or x == n - 1:
            continue
        for r in range(s - 1):
            x = pow(x, 2, n)
            if x == n - 1:
                break
        else:
            return False
    return True

def f(n):

    a = n
    while a >= 2:
        if g(a):
            return a
        a -= 1
    return None

def e(n):
    a = n + 1

    while True:
        if g(a):
            return a
        a += 1

def b(n):

    v = f(n)
    u = e(n)

    d = 0 if n == 2 else 1
    
    j = (v - 1) * (u - 1) - d
    d = 2 * v * u

    g = i.gcd(j, d)
    j //= g
    d //= g
    return f""{j}/{d}""

def h():
    c = l.stdin.read().splitlines()
    if not c:
        return
    t = int(c[0].strip())
    k = []
    for i in range(1, t+1):
        n = int(c[i].strip())
        k.append(b(n))
    l.stdout.write(""\n"".join(k) + ""\n"")

if __name__ == '__main__':
    h()"
7,A,Kalevitch and Chess,PROGRAMMING,"['brute force', 'constructive algorithms']","A famous Berland's painter Kalevitch likes to shock the public. One of his last obsessions is chess. For more than a thousand years people have been playing this old game on uninteresting, monotonous boards. Kalevitch decided to put an end to this tradition and to introduce a new attitude to chessboards.

As before, the chessboard is a square-checkered board with the squares arranged in a 8<=×<=8 grid, each square is painted black or white. Kalevitch suggests that chessboards should be painted in the following manner: there should be chosen a horizontal or a vertical line of 8 squares (i.e. a row or a column), and painted black. Initially the whole chessboard is white, and it can be painted in the above described way one or more times. It is allowed to paint a square many times, but after the first time it does not change its colour any more and remains black. Kalevitch paints chessboards neatly, and it is impossible to judge by an individual square if it was painted with a vertical or a horizontal stroke.

Kalevitch hopes that such chessboards will gain popularity, and he will be commissioned to paint chessboards, which will help him ensure a comfortable old age. The clients will inform him what chessboard they want to have, and the painter will paint a white chessboard meeting the client's requirements.

It goes without saying that in such business one should economize on everything — for each commission he wants to know the minimum amount of strokes that he has to paint to fulfill the client's needs. You are asked to help Kalevitch with this task.","The input file contains 8 lines, each of the lines contains 8 characters. The given matrix describes the client's requirements, W character stands for a white square, and B character — for a square painted black.

It is guaranteed that client's requirments can be fulfilled with a sequence of allowed strokes (vertical/column or horizontal/row).",Output the only number — the minimum amount of rows and columns that Kalevitch has to paint on the white chessboard to meet the client's requirements.,"['WWWBWWBW\nBBBBBBBB\nWWWBWWBW\nWWWBWWBW\nWWWBWWBW\nWWWBWWBW\nWWWBWWBW\nWWWBWWBW\n', 'WWWWWWWW\nBBBBBBBB\nWWWWWWWW\nWWWWWWWW\nWWWWWWWW\nWWWWWWWW\nWWWWWWWW\nWWWWWWWW\n']","['3\n', '1\n']",none,OK,"def c(): return tuple(map(int, input().split()))

b = [list(input()) for _ in range(8)]
a = sum([1 for s in b if s == ['B'] * 8])
b = sum([1 for s in zip(*b) if list(s) == ['B'] * 8])
print(8 if a == 8 else a + b)","def e():

    import g
    d = g.stdin.readline
    n, k = map(int, d().split())
    a = list(map(int, d().split()))

    l = 0
    h = 0
    f = 0
    b = 0

    for r in range(n):

        if a[r] == 0:
            h += 1

        while h > k:
            if a[l] == 0:
                h -= 1
            l += 1

        if (r - l + 1) > f:
            f = r - l + 1
            b = l

    a = a.copy()
    c = k

    for i in range(b, b + f):
        if a[i] == 0 and c > 0:
            a[i] = 1
            c -= 1

    print(f)
    print("" "".join(map(str, a)))

if __name__ == ""__main__"":
    e()"
0,none,none,none,['none'],"For a given positive integer *n* denote its *k*-rounding as the minimum positive integer *x*, such that *x* ends with *k* or more zeros in base 10 and is divisible by *n*.

For example, 4-rounding of 375 is 375·80<==<=30000. 30000 is the minimum integer such that it ends with 4 or more zeros and is divisible by 375.

Write a program that will perform the *k*-rounding of *n*.","The only line contains two integers *n* and *k* (1<=≤<=*n*<=≤<=109, 0<=≤<=*k*<=≤<=8).",Print the *k*-rounding of *n*.,"['375 4\n', '10000 1\n', '38101 0\n', '123456789 8\n']","['30000\n', '10000\n', '38101\n', '12345678900000000\n']",none,TIME_LIMIT_EXCEEDED,"a = input()
a = int(a.split()[0])
k = int(a.split()[1])

def b(x):
    A=[]
    for y in range(2,x):
        while x%y==0:
            x=x/y
            A.append(y)
    if sum(A)==0:
        A.append(x)
    return A  

if(k <= 1):
  print(a)

else:
  s = 10**k
  c = b(a)
  d = a*s
  for i in c:
    if s%i == 0:
      d = int(d/i)
  print(d)","def b():
    import f

    a = f.stdin.read().splitlines()

    n = int(a[0])

    c = 0
    d = 0
    e = 0

    for i in range(1, n + 1):

        x, y, z = map(int, a[i].split())

        c += x
        d += y
        e += z

    if c == 0 and d == 0 and e == 0:
        print(""YES"")
    else:
        print(""NO"")

if __name__ == ""__main__"":
    b()"
743,B,Chloe and the sequence ,PROGRAMMING,"['binary search', 'bitmasks', 'constructive algorithms', 'implementation']","Chloe, the same as Vladik, is a competitive programmer. She didn't have any problems to get to the olympiad like Vladik, but she was confused by the task proposed on the olympiad.

Let's consider the following algorithm of generating a sequence of integers. Initially we have a sequence consisting of a single element equal to 1. Then we perform (*n*<=-<=1) steps. On each step we take the sequence we've got on the previous step, append it to the end of itself and insert in the middle the minimum positive integer we haven't used before. For example, we get the sequence [1,<=2,<=1] after the first step, the sequence [1,<=2,<=1,<=3,<=1,<=2,<=1] after the second step.

The task is to find the value of the element with index *k* (the elements are numbered from 1) in the obtained sequence, i. e. after (*n*<=-<=1) steps.

Please help Chloe to solve the problem!","The only line contains two integers *n* and *k* (1<=≤<=*n*<=≤<=50, 1<=≤<=*k*<=≤<=2*n*<=-<=1).",Print single integer — the integer at the *k*-th position in the obtained sequence.,"['3 2\n', '4 8\n']","['2', '4']","In the first sample the obtained sequence is [1, 2, 1, 3, 1, 2, 1]. The number on the second position is 2.

In the second sample the obtained sequence is [1, 2, 1, 3, 1, 2, 1, 4, 1, 2, 1, 3, 1, 2, 1]. The number on the eighth position is 4.",OK,"def a(n, k):
    c = 1 << (n - 1)
    if k == c: return n
    if k < c: return a(n - 1, k)
    return a(n - 1, k - c)

if __name__ == '__main__':
    n, k = map(int, input().strip().split())
    print(a(n, k))","def d():
    import g
    a = g.stdin.read().split()
    if not a:
        return
    n, k = int(a[0]), int(a[1])

    if k > (n - 1) // 2:
        g.stdout.write(""-1"")
        return

    e = []
    for i in range(n):
        for j in range(1, k + 1):
            i = i + 1
            c = ((i + j) % n) + 1
            e.append((i, c))

    f = []
    f.append(str(len(e)))
    for h, b in e:
        f.append(f""{h} {b}"")
    g.stdout.write(""\n"".join(f))

if __name__ == '__main__':
    d()"
776,C,Molly's Chemicals,PROGRAMMING,"['binary search', 'brute force', 'data structures', 'implementation', 'math']","Molly Hooper has *n* different kinds of chemicals arranged in a line. Each of the chemicals has an affection value, The *i*-th of them has affection value *a**i*.

Molly wants Sherlock to fall in love with her. She intends to do this by mixing a contiguous segment of chemicals together to make a love potion with total affection value as a non-negative integer power of *k*. Total affection value of a continuous segment of chemicals is the sum of affection values of each chemical in that segment.

Help her to do so in finding the total number of such segments.","The first line of input contains two integers, *n* and *k*, the number of chemicals and the number, such that the total affection value is a non-negative power of this number *k*. (1<=≤<=*n*<=≤<=105, 1<=≤<=|*k*|<=≤<=10).

Next line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (<=-<=109<=≤<=*a**i*<=≤<=109) — affection values of chemicals.",Output a single integer — the number of valid segments.,"['4 2\n2 2 2 2\n', '4 -3\n3 -6 -3 12\n']","['8\n', '3\n']","Do keep in mind that *k*<sup class=""upper-index"">0</sup> = 1.

In the first sample, Molly can get following different affection values: 
 - 2: segments [1, 1], [2, 2], [3, 3], [4, 4]; - 4: segments [1, 2], [2, 3], [3, 4]; - 6: segments [1, 3], [2, 4]; - 8: segments [1, 4]. 
Out of these, 2, 4 and 8 are powers of *k* = 2. Therefore, the answer is 8.

In the second sample, Molly can choose segments [1, 2], [3, 3], [3, 4].",WRONG_ANSWER,"from sys import f
input = f.readline
def f(a, k):
	e = 0
	a = 0
	d = {0: 1}
	t = 1
	s = sum(a)
	b = [1]
	for i in range(50):
		t *= k
		b.append(t)
	for i in a:
		e += i
		for d in b:
			c = e - d
			a += d.get(c, 0)
		d[e] = d.get(e, 0) + 1
	return a

n, k = map(int, input().strip().split())
a = list(map(int, input().strip().split()))
print(f(a, k))","import o

def g(n):
    """"""
    Return a sorted list of distinct prime factors of n.
    """"""
    i = 2
    f = set()
    while i * i <= n:
        while n % i == 0:
            f.add(i)
            n //= i
        i += 1
    if n > 1:
        f.add(n)
    return sorted(f)

def j():
    e = o.stdin.read().split()
    if not e:
        return
    b = int(e[0])

    c = None

    n = g(b)
    for m in n:
        k = b // m
        i = (k - 1) * m + 1
        i = max(i, m + 1)
        h = b
        for a in range(i, h + 1):

            l = g(a)
            for k in l:

                m = a // k
                if m < 2:
                    continue
                d = max((m - 1) * k + 1, k + 1)
                if d <= a:
                    if c is None or d < c:
                        c = d

    o.stdout.write(str(c) + ""\n"")

if __name__ == '__main__':
    j()"
593,A,2Char,PROGRAMMING,"['brute force', 'implementation']","Andrew often reads articles in his favorite magazine 2Char. The main feature of these articles is that each of them uses at most two distinct letters. Andrew decided to send an article to the magazine, but as he hasn't written any article, he just decided to take a random one from magazine 26Char. However, before sending it to the magazine 2Char, he needs to adapt the text to the format of the journal. To do so, he removes some words from the chosen article, in such a way that the remaining text can be written using no more than two distinct letters.

Since the payment depends from the number of non-space characters in the article, Andrew wants to keep the words with the maximum total length.","The first line of the input contains number *n* (1<=≤<=*n*<=≤<=100) — the number of words in the article chosen by Andrew. Following are *n* lines, each of them contains one word. All the words consist only of small English letters and their total length doesn't exceed 1000. The words are not guaranteed to be distinct, in this case you are allowed to use a word in the article as many times as it appears in the input.",Print a single integer — the maximum possible total length of words in Andrew's article.,"['4\nabb\ncacc\naaa\nbbb\n', '5\na\na\nbcbcb\ncdecdecdecdecdecde\naaaa\n']","['9', '6']","In the first sample the optimal way to choose words is {'abb', 'aaa', 'bbb'}.

In the second sample the word 'cdecdecdecdecdecde' consists of three distinct letters, and thus cannot be used in the article. The optimal answer is {'a', 'a', 'aaaa'}.",RUNTIME_ERROR,"def b(x):
    if str.isdigit(x[0]) or (x[0] == '\n'):
        return 42
    d = {}
    a = 0
    for c in x:
        if not (c in d.keys()):
            d[c] = 0
            a += 1
        else:
            d[c] += 1
    return a

import f
g = []
for x in f.stdin.readlines():
    if b(x.strip()) < 3:
        g.append(x.strip()) 

d = {}
for x in g:
   for c in x:
        if not c in d.keys():
            d[c] = 0
        else:
            d[c] += 1         

d = sorted(d.items(), key=lambda x: -x[1])
c = d[0][0]
if len(d) > 9000:
    e = list(d.keys())[1]
else:
    e = ''
    
d = 0
for x in g:
    if b(x) == 2:
        if str.find(x, c) > -1 and str.find(x, e) > -1:
            d += len(x)
    else:
        if str.find(x, c) > -1 or str.find(x, e) > -1:
            d += len(x)
            
print(d)","import m
import f

def i():

    d = m.stdin.read().split()
    h = iter(d)
    n = int(next(h))

    k = [int(next(h)) for _ in range(n)]

    e = [int(next(h)) for _ in range(n)]

    a = [int(next(h)) for _ in range(n)]
    
    m = int(next(h))

    b = [int(next(h)) for _ in range(m)]

    c = {
        1: [],
        2: [],
        3: []
    }

    n = [False] * n

    for i in range(n):
        f.heappush(c[e[i]], (k[i], i))
        if a[i] != e[i]:
            f.heappush(c[a[i]], (k[i], i))
    
    l = []

    for c in b:

        while c[c] and n[c[c][0][1]]:
            f.heappop(c[c])

        if not c[c]:
            l.append(-1)
        else:
            j, g = f.heappop(c[c])
            n[g] = True
            l.append(j)

    m.stdout.write("" "".join(map(str, l)) + ""\n"")

if __name__ == '__main__':
    i()"
296,A,Yaroslav and Permutations,PROGRAMMING,"['greedy', 'math']","Yaroslav has an array that consists of *n* integers. In one second Yaroslav can swap two neighboring array elements. Now Yaroslav is wondering if he can obtain an array where any two neighboring elements would be distinct in a finite time.

Help Yaroslav.","The first line contains integer *n* (1<=≤<=*n*<=≤<=100) — the number of elements in the array. The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=1000) — the array elements.","In the single line print ""YES"" (without the quotes) if Yaroslav can obtain the array he needs, and ""NO"" (without the quotes) otherwise.","['1\n1\n', '3\n1 1 2\n', '4\n7 7 7 7\n']","['YES\n', 'YES\n', 'NO\n']","In the first sample the initial array fits well.

In the second sample Yaroslav can get array: 1, 2, 1. He can swap the last and the second last elements to obtain it.

In the third sample Yarosav can't get the array he needs.",RUNTIME_ERROR,"from sys import d
input = d.readline

c = lambda : list(map(int,input().split()))

def a():

    b = [0 for i in range(n + 1)]
    for i in range(n):
        b[a[i]] += 1

    if(max(b) > ((n + 1) // 2)):
        return 'NO'

    return 'YES'

for T in range(1):

    n = int(input())
    a = c()

    print(a())","def b():
    import d
    input = d.stdin.readline

    n, q = map(int, input().split())

    a = list(map(int, input().split()))

    a = [0] * (n + 1)

    for _ in range(q):
        l, r = map(int, input().split())
        a[l - 1] += 1
        a[r] -= 1

    for i in range(1, n):
        a[i] += a[i - 1]

    a.pop()

    a.sort(reverse=True)
    a.sort(reverse=True)

    c = sum(a[i] * a[i] for i in range(n))

    print(c)

if __name__ == '__main__':
    b()"
61,C,Capture Valerian,PROGRAMMING,['math'],"It's now 260 AD. Shapur, being extremely smart, became the King of Persia. He is now called Shapur, His majesty King of kings of Iran and Aniran.

Recently the Romans declared war on Persia. They dreamed to occupy Armenia. In the recent war, the Romans were badly defeated. Now their senior army general, Philip is captured by Shapur and Shapur is now going to capture Valerian, the Roman emperor.

Being defeated, the cowardly Valerian hid in a room at the top of one of his castles. To capture him, Shapur has to open many doors. Fortunately Valerian was too scared to make impenetrable locks for the doors.

Each door has 4 parts. The first part is an integer number *a*. The second part is either an integer number *b* or some really odd sign which looks like R. The third one is an integer *c* and the fourth part is empty! As if it was laid for writing something. Being extremely gifted, after opening the first few doors, Shapur found out the secret behind the locks.

*c* is an integer written in base *a*, to open the door we should write it in base *b*. The only bad news is that this R is some sort of special numbering system that is used only in Roman empire, so opening the doors is not just a piece of cake!

Here's an explanation of this really weird number system that even doesn't have zero:

Roman numerals are based on seven symbols: a stroke (identified with the letter I) for a unit, a chevron (identified with the letter V) for a five, a cross-stroke (identified with the letter X) for a ten, a C (identified as an abbreviation of Centum) for a hundred, etc.:
-  I=1-  V=5-  X=10-  L=50-  C=100-  D=500-  M=1000
Symbols are iterated to produce multiples of the decimal (1, 10, 100, 1,<=000) values, with V, L, D substituted for a multiple of five, and the iteration continuing: I 1, II 2, III 3, V 5, VI 6, VII 7, etc., and the same for other bases: X 10, XX 20, XXX 30, L 50, LXXX 80; CC 200, DCC 700, etc. At the fourth and ninth iteration, a subtractive principle must be employed, with the base placed before the higher base: IV 4, IX 9, XL 40, XC 90, CD 400, CM 900.

Also in bases greater than 10 we use A for 10, B for 11, etc.

Help Shapur capture Valerian and bring peace back to Persia, especially Armenia.","The first line contains two integers *a* and *b* (2<=≤<=*a*,<=*b*<=≤<=25). Only *b* may be replaced by an R which indicates Roman numbering system.

The next line contains a single non-negative integer *c* in base *a* which may contain leading zeros but its length doesn't exceed 103. 

It is guaranteed that if we have Roman numerals included the number would be less than or equal to 300010 and it won't be 0. In any other case the number won't be greater than 101510.",Write a single line that contains integer *c* in base *b*. You must omit leading zeros.,"['10 2\n1\n', '16 R\n5\n', '5 R\n4\n', '2 2\n1111001\n', '12 13\nA\n']","['1\n', 'V\n', 'IV\n', '1111001\n', 'A\n']",You can find more information about roman numerals here: http://en.wikipedia.org/wiki/Roman_numerals,OK,"j = {'0':0,'1':1,'2':2,'3':3,'4':4,'5':5,'6':6,'7':7,'8':8,'9':9,'A':10,'B':11,'C':12,'D':13,'E':14,'F':15,'G':16,'H':17,'I':18,'J':19,'K':20,'L':21,'M':22,'N':23,'O':24,'P':25,'Q':26,'R':27,'S':28,'T':29,'U':30,'V':31,'W':32,'X':33,'Y':34,'Z':35}
e = {0:'0',1:'1',2:'2',3:'3',4:'4',5:'5',6:'6',7:'7',8:'8',9:'9',10:'A',11:'B',12:'C',13:'D',14:'E',15:'F',16:'G',17:'H',18:'I',19:'J',20:'K',21:'L',22:'M',23:'N',24:'O',25:'P',26:'Q',27:'R',28:'S',29:'T',30:'U',31:'V',32:'W',33:'X',34:'Y',35:'Z'}

def b(i, d):
	h = 0
	for g in range(-1,(0-len(i))-1,-1):
		if(j[i[g]] >= int(d)):
			return -1
		h += j[i[g]]*(int(d)**(0-g-1))
	return h
 
def a(i, d):
	h = ''
	if(i == 0):
		return '0'
	while i > 0:
		h = e[i%d] + h
		i = i//d
	return h
 
def c(i):
	h = ''
	for i in range(4,0,-1):
		f = (i%(10**i) - i%(10**(i-1)))//(10**(i-1))
		if(f > 0):
			if(i==4):
				h += 'M'*f
			elif(i==3):
				if(f == 9):
					h += 'CM'
				elif(f>=5):
					h += 'D' + 'C'*(f-5)
				elif f == 4:
					h += 'CD'
				else:
					h += 'C'*f
			elif(i==2):
				if(f == 9):
					h += 'XC'
				elif(f>=5):
					h += 'L' + 'X'*(f-5)
				elif f == 4:
					h += 'XL'
				else:
					h += 'X'*f
			elif(i==1):
				if(f == 9):
					h += 'IX'
				elif(f>=5):
					h += 'V' + 'I'*(f-5)
				elif f == 4:
					h += 'IV'
				else:
					h += 'I'*f
	return h
 
a,b = [x for x in input().split()]
c = input()

if b == 'R':
	print(c(b(c,int(a))))
else:
	print(a(b(c,int(a)),int(b)))","def d():
    import f

    b = f.stdin.read().split()
    if not b:
        return
    n = int(b[0])
    a = []
    c = 1

    for i in range(n):
        x = int(b[c])
        y = int(b[c + 1])
        c += 2

        a.append((abs(x) + abs(y), x, y))
    a.sort(key=lambda b: b[0])

    e = []

    for _, x, y in a:

        if x > 0:
            e.append(""1 {} R"".format(x))
        elif x < 0:
            e.append(""1 {} L"".format(-x))
        if y > 0:
            e.append(""1 {} U"".format(y))
        elif y < 0:
            e.append(""1 {} D"".format(-y))

        e.append(""2"")

        if y > 0:
            e.append(""1 {} D"".format(y))
        elif y < 0:
            e.append(""1 {} U"".format(-y))
        if x > 0:
            e.append(""1 {} L"".format(x))
        elif x < 0:
            e.append(""1 {} R"".format(-x))

        e.append(""3"")

    f.stdout.write(str(len(e)) + ""\n"")
    f.stdout.write(""\n"".join(e))

if __name__ == '__main__':
    d()"
918,A,Eleven,PROGRAMMING,"['brute force', 'implementation']","Eleven wants to choose a new name for herself. As a bunch of geeks, her friends suggested an algorithm to choose a name for her. Eleven wants her name to have exactly *n* characters. 

Her friend suggested that her name should only consist of uppercase and lowercase letters 'O'. More precisely, they suggested that the *i*-th letter of her name should be 'O' (uppercase) if *i* is a member of Fibonacci sequence, and 'o' (lowercase) otherwise. The letters in the name are numbered from 1 to *n*. Fibonacci sequence is the sequence *f* where
 -  *f*1<==<=1, -  *f*2<==<=1, -  *f**n*<==<=*f**n*<=-<=2<=+<=*f**n*<=-<=1 (*n*<=&gt;<=2). 
As her friends are too young to know what Fibonacci sequence is, they asked you to help Eleven determine her new name.",The first and only line of input contains an integer *n* (1<=≤<=*n*<=≤<=1000).,Print Eleven's new name on the first and only line of output.,"['8\n', '15\n']","['OOOoOooO\n', 'OOOoOooOooooOoo\n']",none,OK,"s = """"

def a(i):
    if i == 1:
        return 0
    elif i == 2:
        return 0
    a = 0
    b = 1
    c = 0
    while c < i:
        c = a + b
        a = b
        b = c
        if c == i:
            return 0
    return 1

for i in range(1,int(input())+1):
    if a(i) == 0:
        s += ""O""
    else:
        s += ""o""
print(s)","import e

def d():

    c = e.stdin.read().strip().splitlines()

    for s in c:

        for a in reversed(""abcdefghijklmnopqrstuvwxyz""):
            b = s.b(a)
            if b > 0:

                e.stdout.write(a * b + ""\n"")
                break

if __name__ == ""__main__"":
    d()"
837,B,Flag of Berland,PROGRAMMING,"['brute force', 'implementation']","The flag of Berland is such rectangular field *n*<=×<=*m* that satisfies following conditions:
 -  Flag consists of three colors which correspond to letters 'R', 'G' and 'B'. -  Flag consists of three equal in width and height stripes, parralel to each other and to sides of the flag. Each stripe has exactly one color. -  Each color should be used in exactly one stripe. 
You are given a field *n*<=×<=*m*, consisting of characters 'R', 'G' and 'B'. Output ""YES"" (without quotes) if this field corresponds to correct flag of Berland. Otherwise, print ""NO"" (without quotes).","The first line contains two integer numbers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=100) — the sizes of the field.

Each of the following *n* lines consisting of *m* characters 'R', 'G' and 'B' — the description of the field.","Print ""YES"" (without quotes) if the given field corresponds to correct flag of Berland . Otherwise, print ""NO"" (without quotes).","['6 5\nRRRRR\nRRRRR\nBBBBB\nBBBBB\nGGGGG\nGGGGG\n', '4 3\nBRG\nBRG\nBRG\nBRG\n', '6 7\nRRRGGGG\nRRRGGGG\nRRRGGGG\nRRRBBBB\nRRRBBBB\nRRRBBBB\n', '4 4\nRRRR\nRRRR\nBBBB\nGGGG\n']","['YES\n', 'YES\n', 'NO\n', 'NO\n']","The field in the third example doesn't have three parralel stripes.

Rows of the field in the fourth example are parralel to each other and to borders. But they have different heights — 2, 1 and 1.",RUNTIME_ERROR,"n,_=map(int,input().split())
s=input()
n-=1
a=''
k=0
if 'R' in s:
    k+=1
if 'G' in s:
    k+=1
if 'B' in s:
    k+=1
t=1
if k>1:
    for _ in range(n):
        a=input()
        if a!=s:
            t=0
            break
elif k==1:
    a+=s[0]
    for _ in range(n):
        s=input()
        a+=s[0]
        k = 0
        if 'R' in s:
            k += 1
        if 'G' in s:
            k += 1
        if 'B' in s:
            k += 1
        if k!=1:
            t=0
            break

def f(a):
    if len(a)%3>0:
        return 1
    b=len(a)//3
    if a[0]*b+a[b]*b+a[-1]*b!=a:
        return 1
    k = 0
    if 'R' in a:
        k += 1
    if 'G' in a:
        k += 1
    if 'B' in a:
        k += 1
    if k!=3:
        return 1
    return 0

if t==0 or f(a):
    print('NO')
else:
    print('YES')","def c():
    import f

    b = f.stdin.read().split()
    if not b:
        return
    n, k = int(b[0]), int(b[1])
    s = b[2]

    e = {}
    for a in s:
        e[a] = e.get(a, 0) + 1

    d = set()

    for a in s:

        if a not in d:
            d.add(a)

            if len(d) > k:
                print(""YES"")
                return

        e[a] -= 1

        if e[a] == 0:
            d.remove(a)

    print(""NO"")

if __name__ == ""__main__"":
    c()"
669,A,Little Artem and Presents,PROGRAMMING,['math'],"Little Artem got *n* stones on his birthday and now wants to give some of them to Masha. He knows that Masha cares more about the fact of receiving the present, rather than the value of that present, so he wants to give her stones as many times as possible. However, Masha remembers the last present she received, so Artem can't give her the same number of stones twice in a row. For example, he can give her 3 stones, then 1 stone, then again 3 stones, but he can't give her 3 stones and then again 3 stones right after that.

How many times can Artem give presents to Masha?",The only line of the input contains a single integer *n* (1<=≤<=*n*<=≤<=109) — number of stones Artem received on his birthday.,Print the maximum possible number of times Artem can give presents to Masha.,"['1\n', '2\n', '3\n', '4\n']","['1\n', '1\n', '2\n', '3\n']","In the first sample, Artem can only give 1 stone to Masha.

In the second sample, Atrem can give Masha 1 or 2 stones, though he can't give her 1 stone two times.

In the third sample, Atrem can first give Masha 2 stones, a then 1 more stone.

In the fourth sample, Atrem can first give Masha 1 stone, then 2 stones, and finally 1 stone again.",WRONG_ANSWER,"def a():
	n = int(input())
	return b(n)

def b(n):
	if n % 3 == 0:
		return n // 3 * 2
	elif n % 3 == 1:
		return (2 * n + 1) // 3
	else:
		return (2 * (n - 1) + 1) // 3

a()","def c():
    import f
    b = f.stdin.read().split()

    n = int(b[0])
    k = int(b[1])

    e = list(map(int, b[2:2+n]))

    a = e[k - 1]

    for i in range(k, n):
        if e[i] != a:
            f.stdout.write(""-1"")
            return

    d = -1
    for i in range(k - 2, -1, -1):
        if e[i] != a:
            d = i
            break

    if d == -1:
        f.stdout.write(""0"")
    else:

        f.stdout.write(str(d + 1))

if __name__ == ""__main__"":
    c()"
754,B,Ilya and tic-tac-toe game,PROGRAMMING,"['brute force', 'implementation']","Ilya is an experienced player in tic-tac-toe on the 4<=×<=4 field. He always starts and plays with Xs. He played a lot of games today with his friend Arseny. The friends became tired and didn't finish the last game. It was Ilya's turn in the game when they left it. Determine whether Ilya could have won the game by making single turn or not. 

The rules of tic-tac-toe on the 4<=×<=4 field are as follows. Before the first turn all the field cells are empty. The two players take turns placing their signs into empty cells (the first player places Xs, the second player places Os). The player who places Xs goes first, the another one goes second. The winner is the player who first gets three of his signs in a row next to each other (horizontal, vertical or diagonal).","The tic-tac-toe position is given in four lines.

Each of these lines contains four characters. Each character is '.' (empty cell), 'x' (lowercase English letter x), or 'o' (lowercase English letter o). It is guaranteed that the position is reachable playing tic-tac-toe, and it is Ilya's turn now (in particular, it means that the game is not finished). It is possible that all the cells are empty, it means that the friends left without making single turn.","Print single line: ""YES"" in case Ilya could have won by making single turn, and ""NO"" otherwise.","['xx..\n.oo.\nx...\noox.\n', 'x.ox\nox..\nx.o.\noo.x\n', 'x..x\n..oo\no...\nx.xo\n', 'o.x.\no...\n.x..\nooxx\n']","['YES\n', 'NO\n', 'YES\n', 'NO\n']","In the first example Ilya had two winning moves: to the empty cell in the left column and to the leftmost empty cell in the first row.

In the second example it wasn't possible to win by making single turn.

In the third example Ilya could have won by placing X in the last row between two existing Xs.

In the fourth example it wasn't possible to win by making single turn.",WRONG_ANSWER,"m = []
for i in range(4):
    m.append(input())

def d(r,c, e, a):
    if r > 3 or c > 3 or r < 0 or c < 0 or e > 3 or a > 3 or e < 0 or a < 0:
        return False
    return m[r][c] == ""x"" and m[e][a] == ""x""

def b(r,c):
    if(d(r,c+1,r,c-1) or\
       d(r,c+1,r,c+2) or\
       d(r,c-1,r,c-2) or\
       d(r+1,c,r-1,c) or\
       d(r+1,c,r+2,c) or\
       d(r-1,c,r-2,c) or\
       d(r+1,c+1,r-1,c-1) or\
       d(r+1,c+1,r+2,c+2) or\
       d(r-1,c-1,r-2,c-2) or\
       d(r-1,c+1,r+1,c-1) or\
       d(r-1,c+1,r-2,c-2) or\
       d(r+1,c-1,r+2,c-2)):
        return True
    return False

def g():
    for f in range(4):
        for c in range(4):
            if m[f][c] == ""."":
                if b(f,c):
                    return ""YES""
    return ""NO""

print(g())","import m
input = m.stdin.readline

def j():
    n = int(input().strip())
    k = []
    for i in range(n):

        a, b, c = map(int, input().split())
        k.append((a, b, c))

    c = (-1, -1)
    for i, (a, b, c) in enumerate(k):
        if a > c[0]:
            c = (a, i)

    b = -1
    a = (-1, -1)

    i = {}

    for i, (a, b, c) in enumerate(k):

        d = [((a, b), c), ((a, c), b), ((b, c), a)]
        for h, f in d:
            if h not in i:
                i[h] = [(f, i)]
            else:

                i[h].append((f, i))

                i[h].sort(key=lambda x: x[0], reverse=True)
                if len(i[h]) > 2:
                    i[h] = i[h][:2]

    for h, d in i.items():

        if len(d) < 2:
            continue

        g = h[0]

        l = d[0][0] + d[1][0]

        e = min(g, l)
        if e > b:
            b = e
            a = (d[0][1], d[1][1])

    if c[0] >= b:

        print(1)
        print(c[1] + 1)
    else:

        print(2)
        print(a[0] + 1, a[1] + 1)

if __name__ == '__main__':
    j()"
1,A,Theatre Square,PROGRAMMING,['math'],"Theatre Square in the capital city of Berland has a rectangular shape with the size *n*<=×<=*m* meters. On the occasion of the city's anniversary, a decision was taken to pave the Square with square granite flagstones. Each flagstone is of the size *a*<=×<=*a*.

What is the least number of flagstones needed to pave the Square? It's allowed to cover the surface larger than the Theatre Square, but the Square has to be covered. It's not allowed to break the flagstones. The sides of flagstones should be parallel to the sides of the Square.","The input contains three positive integer numbers in the first line: *n*,<=<=*m* and *a* (1<=≤<=<=*n*,<=*m*,<=*a*<=≤<=109).",Write the needed number of flagstones.,['6 6 4\n'],['4\n'],none,RUNTIME_ERROR,"{
 ""cells"": [
  {
   ""cell_type"": ""code"",
   ""execution_count"": 1,
   ""id"": ""fa1a81ed"",
   ""metadata"": {},
   ""outputs"": [],
   ""source"": [
    ""def theatre_square(n, m, a):\n"",
    ""    if n//a == n/a and m//a == m/a:\n"",
    ""        s1 = n/a\n"",
    ""        s2 = m/a\n"",
    ""    elif n//a == n/a and m//a != m/a:\n"",
    ""        s1 = s1/n\n"",
    ""        s2 = m//a + 1\n"",
    ""    elif n//a != n/a and m//a == m/a:\n"",
    ""        s1 = n//a + 1\n"",
    ""        s2 = m/a\n"",
    ""    else:\n"",
    ""        s1 = n//a + 1\n"",
    ""        s2 = m//a + 1\n"",
    ""    return s1 * s2""
   ]
  },
  {
   ""cell_type"": ""code"",
   ""execution_count"": 2,
   ""id"": ""2d41b786"",
   ""metadata"": {},
   ""outputs"": [
    {
     ""data"": {
      ""text/plain"": [
       ""4""
      ]
     },
     ""execution_count"": 2,
     ""metadata"": {},
     ""output_type"": ""execute_result""
    }
   ],
   ""source"": [
    ""theatre_square(6,6,4)""
   ]
  },
  {
   ""cell_type"": ""code"",
   ""execution_count"": a,
   ""id"": ""43546a58"",
   ""metadata"": {},
   ""outputs"": [],
   ""source"": []
  }
 ],
 ""metadata"": {
  ""kernelspec"": {
   ""display_name"": ""Python 3 (ipykernel)"",
   ""language"": ""python"",
   ""name"": ""python3""
  },
  ""language_info"": {
   ""codemirror_mode"": {
    ""name"": ""ipython"",
    ""version"": 3
   },
   ""file_extension"": "".py"",
   ""mimetype"": ""text/x-python"",
   ""name"": ""python"",
   ""nbconvert_exporter"": ""python"",
   ""pygments_lexer"": ""ipython3"",
   ""version"": ""3.9.2""
  }
 },
 ""nbformat"": 4,
 ""nbformat_minor"": 5
}","""""""
This script rearranges the numbers in a Young diagram-like table via swaps so that
every row is sorted in increasing order from left to right and every column is sorted
in increasing order from top to bottom.
""""""

def j():
    import p
    h = p.stdin.read().splitlines()
    if not h:
        return

    n = int(h[0].strip())
    b = list(map(int, h[1].split()))

    q = []
    i = 2
    for i in range(n):
        m = list(map(int, h[i].split()))
        q.append(m)
        i += 1

    s = sum(b)

    a = []
    for i in range(n):
        for j in range(b[i]):
            a.append(q[i][j])
    a.sort()

    r = []
    g = 0
    for i in range(n):
        s = []
        for j in range(b[i]):
            s.append(a[g])
            g += 1
        r.append(s)

    l = {}
    for i in range(n):
        for j in range(b[i]):
            l[q[i][j]] = (i, j)
    
    o = []

    for i in range(n):
        for j in range(b[i]):
            e = r[i][j]
            if q[i][j] == e:
                continue

            c, d = l[e]

            f = q[i][j]
            q[i][j], q[c][d] = q[c][d], q[i][j]

            o.append((i + 1, j + 1, c + 1, d + 1))

            l[f] = (c, d)
            l[e] = (i, j)

    k = []
    k.append(str(len(o)))
    for n in o:
        k.append("" "".join(map(str, n)))
    
    p.stdout.write(""\n"".join(k))
    
if __name__ == '__main__':
    j()"
967,B,Watering System,PROGRAMMING,"['math', 'sortings']","Arkady wants to water his only flower. Unfortunately, he has a very poor watering system that was designed for $n$ flowers and so it looks like a pipe with $n$ holes. Arkady can only use the water that flows from the first hole.

Arkady can block some of the holes, and then pour $A$ liters of water into the pipe. After that, the water will flow out from the non-blocked holes proportionally to their sizes $s_1, s_2, \ldots, s_n$. In other words, if the sum of sizes of non-blocked holes is $S$, and the $i$-th hole is not blocked, $\frac{s_i \cdot A}{S}$ liters of water will flow out of it.

What is the minimum number of holes Arkady should block to make at least $B$ liters of water flow out of the first hole?","The first line contains three integers $n$, $A$, $B$ ($1 \le n \le 100\,000$, $1 \le B \le A \le 10^4$) — the number of holes, the volume of water Arkady will pour into the system, and the volume he wants to get out of the first hole.

The second line contains $n$ integers $s_1, s_2, \ldots, s_n$ ($1 \le s_i \le 10^4$) — the sizes of the holes.",Print a single integer — the number of holes Arkady should block.,"['4 10 3\n2 2 2 2\n', '4 80 20\n3 2 1 4\n', '5 10 10\n1000 1 1 1 1\n']","['1\n', '0\n', '4\n']","In the first example Arkady should block at least one hole. After that, $\frac{10 \cdot 2}{6} \approx 3.333$ liters of water will flow out of the first hole, and that suits Arkady.

In the second example even without blocking any hole, $\frac{80 \cdot 3}{10} = 24$ liters will flow out of the first hole, that is not less than $20$.

In the third example Arkady has to block all holes except the first to make all water flow out of the first hole.",TIME_LIMIT_EXCEEDED,"def a(s,a,b):
    return(((a*s[0])/sum(s))>=b)
n,a,b=map(int,input().split())
s=list(map(int,input().split()))
x=len(s)
while not a(s,a,b):
    s.pop(s.index(max(s[1:])))
print(x-len(s))","import e
import b

def c():

    a = e.stdin.read().strip().split()

    d = list(map(int, a))

    if len(d) != 6:
        return

    h = sum(d)

    if h % 2 != 0:
        print(""NO"")
        return

    f = h // 2

    for g in b.combinations(d, 3):

        if sum(g) == f:
            print(""YES"")
            return

    print(""NO"")

if __name__ == ""__main__"":
    c()"
55,B,Smallest number,PROGRAMMING,['brute force'],"Recently, Vladimir got bad mark in algebra again. To avoid such unpleasant events in future he decided to train his arithmetic skills. He wrote four integer numbers *a*, *b*, *c*, *d* on the blackboard. During each of the next three minutes he took two numbers from the blackboard (not necessarily adjacent) and replaced them with their sum or their product. In the end he got one number. Unfortunately, due to the awful memory he forgot that number, but he remembers four original numbers, sequence of the operations and his surprise because of the very small result. Help Vladimir remember the forgotten number: find the smallest number that can be obtained from the original numbers by the given sequence of operations.","First line contains four integers separated by space: 0<=≤<=*a*,<=*b*,<=*c*,<=*d*<=≤<=1000 — the original numbers. Second line contains three signs ('+' or '*' each) separated by space — the sequence of the operations in the order of performing. ('+' stands for addition, '*' — multiplication)","Output one integer number — the minimal result which can be obtained.

Please, do not use %lld specificator to read or write 64-bit integers in C++. It is preffered to use cin (also you may use %I64d).","['1 1 1 1\n+ + *\n', '2 2 2 2\n* * +\n', '1 2 3 4\n* + +\n']","['3\n', '8\n', '9\n']",none,WRONG_ANSWER,"'''''
arr= [1,3,4,3]
i=0
for k in range(8):
    if i!=arr[i]-1:
        if arr[i]!=arr[arr[i]-1]:
            print(arr[i],arr[arr[i]-1],arr,i)
            arr[i],arr[arr[i]-1]=arr[arr[i]-1],arr[i]
        else:
            i+=1
    else:
        i+=1
print(arr)
''' ''

'''
def AllParenthesis(n):

    def backtrack(ans,curr,openp,closep,maxp):
        if len(curr)==2*maxp:
            ans.append(curr)
            return
        if openp<maxp:
            backtrack(ans,curr+""("",openp+1,closep,maxp)
        if closep<openp:
            backtrack(ans,curr+"")"",openp,closep+1,maxp)

    ans = []
    openp, closep = 0, 0
    curr = ''
    backtrack(ans, curr, openp, closep, n)
    return ans
print(AllParenthesis(3))
'''

'''temp=[[0 for x in range(len(mat[0]))]for x in range(len(mat))]
for i in range(len(mat)):
    temp[i][0]=mat[i][0]
    for j in range(1,len(mat[0])):
        temp[i][j]=temp[i][j-1]+mat[i][j]
for i in range(1,len(mat)):
    for j in range(len(mat[0])):
        temp[i][j]=temp[i-1][j]+temp[i][j]

k=3
lr=0
lc=0
rr=0
rc=0
ans=[[0 for x in range(len(mat[0]))]for x in range(len(mat))]
for i in range(len(mat)):
    for j in range(len(mat[0])):
        area1 = 0
        area2 = 0
        area3 = 0

        lr=i
        lc=j
        if i-k>=0:
            lr=i-k
        else:
            lr=0
        if j-k>=0:
            lc=j-k
        else:
            lc=0
        rr=i
        rc=j
        if i+k<len(mat):
            rr=i+k
        else:
            rr=len(mat)-1
        if j+k<len(mat[0]):
            rc=j+k
        else:
            rc=len(mat[0])-1
        if lc-1>=0:
            area1=temp[rr][lc-1]

        if lr-1>=0:
            area2=temp[lr-1][rc]
        if lr-1>=0 and lc-1>=0:
            area3=temp[lr-1][lc-1]
        ans[i][j]=temp[rr][rc]-area1-area2+area3'''

'''print(ans)'''
'''
nums = [-1,0,1,2,-1,-4]
nums.sort()
print(nums)
seen = set()
length=len(nums)
ans=[]
i=0
while i<length-2:
    l=i+1
    r=length-1
    target=nums[i]
    while l<r:
        if nums[l]+nums[r]==-target:
            seen.add((target,nums[l],nums[r]))

            while l < r and nums[l + 1] == nums[l]:
                l += 1
            while l < r and nums[r - 1] == nums[r]:
                r -= 1

            l+=1
            r-=1
        elif nums[l]+nums[r]>-target:
            r-=1
        else:
            l+=1
    i+=1
print(seen)
'''
import m
import s
from io import b, d

def i():
    pass

a = 8192

class c(d):
    j = 0

    def __init__(r, g):
        r._fd = g.fileno()
        r.buffer = b()
        r.writable = ""x"" in g.mode or ""r"" not in g.mode
        r.write = r.buffer.write if r.writable else None

    def p(r):
        while True:
            b = m.p(r._fd, max(m.fstat(r._fd).st_size, a))
            if not b:
                break
            o = r.buffer.tell()
            r.buffer.seek(0, 2), r.buffer.write(b), r.buffer.seek(o)
        r.j = 0
        return r.buffer.p()

    def q(r):
        while r.j == 0:
            b = m.p(r._fd, max(m.fstat(r._fd).st_size, a))
            r.j = b.count(b""\n"") + (not b)
            o = r.buffer.tell()
            r.buffer.seek(0, 2), r.buffer.write(b), r.buffer.seek(o)
        r.j -= 1
        return r.buffer.q()

    def h(r):
        if r.writable:
            m.write(r._fd, r.buffer.getvalue())
            r.buffer.truncate(0), r.buffer.seek(0)

class e(d):
    def __init__(r, g):
        r.buffer = c(g)
        r.h = r.buffer.h
        r.writable = r.buffer.writable
        r.write = lambda s: r.buffer.write(s.encode(""ascii""))
        r.p = lambda: r.buffer.p().decode(""ascii"")
        r.q = lambda: r.buffer.q().decode(""ascii"")

s.stdin, s.stdout = e(s.stdin), e(s.stdout)
input = lambda: s.stdin.q().rstrip(""\r\n"")

if __name__ == ""__main__"":
    i()

'''
def letterCombinations(digits):
    digitsmap = [0,0,['a', 'b', 'c'], ['d', 'e', 'f'], ['g', 'h', 'i'], ['j', 'k', 'l'], ['m', 'n', 'o'], ['p', 'q', 'r', 's'],
              ['t', 'u', 'v'], ['w', 'x', 'y', 'z']]
    temp=''
    n=len(digits)
    i=0
    ans=[]
    def allcombination(temp,i):
        if i == n:
            ans.append(temp)
            return
        for j in range(len(digitsmap[int(digits[i])])):
            allcombination(temp+digitsmap[int(digits[i])][j],i+1)
    allcombination(temp,i)
    return ans

print(letterCombinations('23'))
'''
'''
count=0
steps=0
ans=[]
def convert(a,b):
    global count,steps
    steps += 1

    if a>b:

        steps-=1

        return
    elif a==b:
        count+=1

        ans.append(a)

        return

    ans.append(a)
    convert(a*2,b)
    convert((a*10)+1,b)

convert(2,162)
if count>0:
    print(count,""YES"")
elif count==0:
    print('NO')

print(ans)

'''
'''N=3
n=2
i=0
box1=N
box2=0
box3=0
count=0
def move(i,N,box1,box2,box3):
    global count
    if N==0:

        count+=1
        return
    move(i+1,N-1,box1,box3,box2)
    print(box1,box3)
    move(i+1,N-1,box2,box1,box3)

move(i,N,box1,box2,box3)
print(count)

'''
'''
def numberOfPaths(n, m,count):

    def path(i, j,count):
        if i == n - 1 or j == m - 1:
            count += 1
            return
        path(i + 1, j,count)
        path(i, j +1,count)
    count=0
    path(0,0,count)
    return count

print(numberOfPaths(5,1,count))
'''
f=999999999
def k(t,l,i,m,a):
    global f
    if m==0 and a==0:
        f=min(f,eval(t))
        return
    if a>0:
        k(t+'+'+str(l[i]),l,i+1,m,a-1)
    if m>0:
        k(t+'*'+str(l[i]), l, i+1, m-1, a)

l=list(map(int,input().split()))
a=0
m=0
n=list(map(str,input().split()))
for k in n:
    if k=='+':
        a+=1
    elif k=='*':
        m+=1
t=str(l[0])
i=1
k(t,l,i,m,a)
print(f)","import e

def b():

    a = e.stdin.read().splitlines()

    s = a[0]

    k = int(a[1])
    
    n = len(s)

    if n % k != 0:
        print(""NO"")
        return

    d = n // k

    for i in range(0, n, d):
        c = s[i:i+d]

        if c != c[::-1]:
            print(""NO"")
            return

    print(""YES"")

if __name__ == ""__main__"":
    b()"
727,A,Transformation: from A to B,PROGRAMMING,"['brute force', 'dfs and similar', 'math']","Vasily has a number *a*, which he wants to turn into a number *b*. For this purpose, he can do two types of operations:
 -  multiply the current number by 2 (that is, replace the number *x* by 2·*x*); -  append the digit 1 to the right of current number (that is, replace the number *x* by 10·*x*<=+<=1). 
You need to help Vasily to transform the number *a* into the number *b* using only the operations described above, or find that it is impossible.

Note that in this task you are not required to minimize the number of operations. It suffices to find any way to transform *a* into *b*.",The first line contains two positive integers *a* and *b* (1<=≤<=*a*<=&lt;<=*b*<=≤<=109) — the number which Vasily has and the number he wants to have.,"If there is no way to get *b* from *a*, print ""NO"" (without quotes).

Otherwise print three lines. On the first line print ""YES"" (without quotes). The second line should contain single integer *k* — the length of the transformation sequence. On the third line print the sequence of transformations *x*1,<=*x*2,<=...,<=*x**k*, where:
 -  *x*1 should be equal to *a*, -  *x**k* should be equal to *b*, -  *x**i* should be obtained from *x**i*<=-<=1 using any of two described operations (1<=&lt;<=*i*<=≤<=*k*). 
If there are multiple answers, print any of them.","['2 162\n', '4 42\n', '100 40021\n']","['YES\n5\n2 4 8 81 162 \n', 'NO\n', 'YES\n5\n100 200 2001 4002 40021 \n']",none,OK,"def c(a,b,d,b,e):
    if(a>b):
        return
    if(a==b):
        b[0]=False

        d.append(e)
        return
    if(b[0]):
        
        
        c(a*2,b,d,b,e+[a*2])
        c(a*10+1,b,d,b,e+[a*10+1])
d=[]
b=[True]

a,b=map(int,input().split())
c(a,b,d,b,[])
if(len(d)==0):
    print(""NO"")
else:
    print(""YES"")
    print(1+len(d[0]))
    a=[[a]+d[0]]
    print(a,end="" "")
    for i in d[0]:
        print(i,end="" "")
    print()","def a(w, m):

    while m:
        r = m % w

        if r == 0:
            m //= w

        elif r == 1:
            m //= w

        elif r == w - 1:
            m = m // w + 1

        else:
            return False
    return True

if __name__ == ""__main__"":
    import c

    b = c.stdin.readline().strip()
    if not b:
        c.exit(0)
    try:
        w, m = map(int, b.split())
    except Exception:
        c.exit(1)

    if a(w, m):
        c.stdout.write(""YES\n"")
    else:
        c.stdout.write(""NO\n"")"
276,C,Little Girl and Maximum Sum,PROGRAMMING,"['data structures', 'greedy', 'implementation', 'sortings']","The little girl loves the problems on array queries very much.

One day she came across a rather well-known problem: you've got an array of $n$ elements (the elements of the array are indexed starting from 1); also, there are $q$ queries, each one is defined by a pair of integers $l_i$, $r_i$ $(1 \le l_i \le r_i \le n)$. You need to find for each query the sum of elements of the array with indexes from $l_i$ to $r_i$, inclusive.

The little girl found the problem rather boring. She decided to reorder the array elements before replying to the queries in a way that makes the sum of query replies maximum possible. Your task is to find the value of this maximum sum.","The first line contains two space-separated integers $n$ ($1 \le n \le 2\cdot10^5$) and $q$ ($1 \le q \le 2\cdot10^5$) — the number of elements in the array and the number of queries, correspondingly.

The next line contains $n$ space-separated integers $a_i$ ($1 \le a_i \le 2\cdot10^5$) — the array elements.

Each of the following $q$ lines contains two space-separated integers $l_i$ and $r_i$ ($1 \le l_i \le r_i \le n$) — the $i$-th query.","In a single line print, a single integer — the maximum sum of query replies after the array elements are reordered.

Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.","['3 3\n5 3 2\n1 2\n2 3\n1 3\n', '5 3\n5 2 4 1 3\n1 5\n2 3\n2 3\n']","['25\n', '33\n']",none,OK,"from sys import g

def c():

    e = g.read().strip().split('\n')
    n, q = map(int, e[0].split())
    a = list(map(int, e[1].split()))
    f = [map(int, e[i].split()) for i in range(2, len(e))]

    return a, f

def d(a, f):
    n = len(a)
    b = [0] * (n + 2)

    for l, r in f:
        b[l] += 1
        b[r + 1] -= 1

    for i in range(1, n + 1):
        b[i] += b[i - 1]

    b.pop(0)
    b.pop()
    b.sort()
    a.sort()

    s = 0
    for i in range(n):
        s += a[i] * b[i]
    return s

print(d(*c()))","def h():
    import m
    from itertools import k

    d = m.stdin.read().split()
    if not d:
        return

    n = int(d[0])
    q = int(d[1])

    i = {}
    e = 2
    for _ in range(q):
        f = d[e]
        l = d[e+1]
        i[f] = l
        e += 2

    g = ['a', 'b', 'c', 'd', 'e', 'f']

    b = 0

    for a in k(g, repeat=n):
        s = """".join(a)
        c = s
        n = True

        for _ in range(n - 1):
            if len(c) < 2:
                n = False
                break

            j = c[:2]
            if j in i:

                c = i[j] + c[2:]
            else:
                n = False
                break
        if n and c == ""a"":
            b += 1

    m.stdout.write(str(b) + ""\n"")

if __name__ == '__main__':
    h()"
456,A,Laptops,PROGRAMMING,['sortings'],"One day Dima and Alex had an argument about the price and quality of laptops. Dima thinks that the more expensive a laptop is, the better it is. Alex disagrees. Alex thinks that there are two laptops, such that the price of the first laptop is less (strictly smaller) than the price of the second laptop but the quality of the first laptop is higher (strictly greater) than the quality of the second laptop.

Please, check the guess of Alex. You are given descriptions of *n* laptops. Determine whether two described above laptops exist.","The first line contains an integer *n* (1<=≤<=*n*<=≤<=105) — the number of laptops.

Next *n* lines contain two integers each, *a**i* and *b**i* (1<=≤<=*a**i*,<=*b**i*<=≤<=*n*), where *a**i* is the price of the *i*-th laptop, and *b**i* is the number that represents the quality of the *i*-th laptop (the larger the number is, the higher is the quality).

All *a**i* are distinct. All *b**i* are distinct.","If Alex is correct, print ""Happy Alex"", otherwise print ""Poor Alex"" (without the quotes).",['2\n1 2\n2 1\n'],['Happy Alex\n'],none,TIME_LIMIT_EXCEEDED,"def a(n, b):
  for i in range(n-1):
    for j in range(i+1, n):
      if b[i][0] < b[j][0] and b[i][1] > b[j][1]:
        return ""Happy Alex""
  return ""Poor Alex""

n = int(input().strip())
b = [list(map(int, input().strip().split())) for i in range(n)]
print(a(n, b))","import t
from collections import d

def j():
    import t
    c = t.stdin.read().split()
    if not c:
        return

    n = int(c[0])
    s = int(c[1])
    l = int(c[2])
    a = list(map(int, c[3:3+n]))

    if l > n:
        t.stdout.write(""-1\n"")
        return

    i = [0] * n
    l = d()
    k = d()
    h = 0
    for i in range(n):

        while l and a[l[-1]] > a[i]:
            l.pop()
        l.append(i)

        while k and a[k[-1]] < a[i]:
            k.pop()
        k.append(i)

        while a[k[0]] - a[l[0]] > s:
            if l[0] == h:
                l.popleft()
            if k[0] == h:
                k.popleft()
            h += 1
        
        i[i] = h

    a = 10**18
    e = [a] * (n + 1)
    e[0] = 0

    s = 1
    while s < n + 1:
        s *= 2
    r = [a] * (2 * s)

    def q(m, u):
        m += s
        r[m] = u
        m //= 2
        while m:
            r[m] = min(r[2 * m], r[2 * m + 1])
            m //= 2

    def p(l, r):

        n = a
        l += s
        r += s
        while l <= r:
            if l % 2 == 1:
                n = min(n, r[l])
                l += 1
            if r % 2 == 0:
                n = min(n, r[r])
                r -= 1
            l //= 2
            r //= 2
        return n

    for i in range(n+1):
        r[i+s] = e[i]
    for i in range(s-1, 0, -1):
        r[i] = min(r[2*i], r[2*i+1])

    for i in range(1, n + 1):

        g = i[i-1]
        f = i - l
        if f < g:
            e[i] = a
        else:
            b = p(g, f)
            e[i] = b + 1
        q(i, e[i])
    
    o = e[n] if e[n] < a else -1
    t.stdout.write(str(o) + ""\n"")

if __name__ == '__main__':
    j()"
670,A,Holidays,PROGRAMMING,"['brute force', 'constructive algorithms', 'greedy', 'math']",On the planet Mars a year lasts exactly *n* days (there are no leap years on Mars). But Martians have the same weeks as earthlings — 5 work days and then 2 days off. Your task is to determine the minimum possible and the maximum possible number of days off per year on Mars.,The first line of the input contains a positive integer *n* (1<=≤<=*n*<=≤<=1<=000<=000) — the number of days in a year on Mars.,Print two integers — the minimum possible and the maximum possible number of days off per year on Mars.,"['14\n', '2\n']","['4 4\n', '0 2\n']","In the first sample there are 14 days in a year on Mars, and therefore independently of the day a year starts with there will be exactly 4 days off .

In the second sample there are only 2 days in a year on Mars, and they can both be either work days or days off.",WRONG_ANSWER,"def b(n):
    a=(n//7)*2
    if (n-(n//7)*7)<2:
        return a, a+(n-(n//7)*7)
    else:
        return a, a+2
q=int(input())
(a,b)=b(q)
print(a,b,sep=' ')","import j
import e

h = [j.stdin.readline().strip() for _ in range(3)]

d = ['A', 'B', 'C']

def a(f, h):

    for g in h:

        b, i, c = g[0], g[1], g[2]
        if i == '<':

            if f.index(b) > f.index(c):
                return False
        elif i == '>':
            if f.index(b) < f.index(c):
                return False
    return True

k = None
for f in e.permutations(d):
    if a(list(f), h):
        k = ''.join(f)
        break

if k:
    print(k)
else:
    print(""Impossible"")"
731,A,Night at the Museum,PROGRAMMING,"['implementation', 'strings']","Grigoriy, like the hero of one famous comedy film, found a job as a night security guard at the museum. At first night he received embosser and was to take stock of the whole exposition.

Embosser is a special devise that allows to ""print"" the text of a plastic tape. Text is printed sequentially, character by character. The device consists of a wheel with a lowercase English letters written in a circle, static pointer to the current letter and a button that print the chosen letter. At one move it's allowed to rotate the alphabetic wheel one step clockwise or counterclockwise. Initially, static pointer points to letter 'a'. Other letters are located as shown on the picture:

After Grigoriy add new item to the base he has to print its name on the plastic tape and attach it to the corresponding exhibit. It's not required to return the wheel to its initial position with pointer on the letter 'a'.

Our hero is afraid that some exhibits may become alive and start to attack him, so he wants to print the names as fast as possible. Help him, for the given string find the minimum number of rotations of the wheel required to print it.",The only line of input contains the name of some exhibit — the non-empty string consisting of no more than 100 characters. It's guaranteed that the string consists of only lowercase English letters.,"Print one integer — the minimum number of rotations of the wheel, required to print the name given in the input.","['zeus\n', 'map\n', 'ares\n']","['18\n', '35\n', '34\n']","To print the string from the first sample it would be optimal to perform the following sequence of rotations: 
 1.  from 'a' to 'z' (1 rotation counterclockwise), 1.  from 'z' to 'e' (5 clockwise rotations), 1.  from 'e' to 'u' (10 rotations counterclockwise), 1.  from 'u' to 's' (2 counterclockwise rotations).",OK,"s = 'abcdefghijklmnopqrstuvwxyz';

g = input();

e = 0;
d = 0;

for i in range(len(g)):
    c = s.index(g[i]);
    b = s[::-1].index(g[i]);
    if(c > b):
        d = b;
        f = s[26 - d-1::];
        a  = s[0:26-d-1];
    else:
        d = c;
        f = s[d:];
        a = s[0:d];
    if(len(f) < len(a)):
        e += len(f);
    else:
        e += len(a);
    s = f + a;

print(e);","def b():
    import d

    a = d.stdin.readline().strip()
    n, m = map(int, a.split())

    c = 0

    if m <= n:
        c = n - m
    else:

        while m > n:

            if m % 2 == 0:
                m //= 2
            else:

                m += 1

            c += 1

        c += (n - m)

    print(c)

if __name__ == ""__main__"":
    b()"
476,B,Dreamoon and WiFi,PROGRAMMING,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']","Dreamoon is standing at the position 0 on a number line. Drazil is sending a list of commands through Wi-Fi to Dreamoon's smartphone and Dreamoon follows them.

Each command is one of the following two types: 
 1.  Go 1 unit towards the positive direction, denoted as '+' 1.  Go 1 unit towards the negative direction, denoted as '-' 
But the Wi-Fi condition is so poor that Dreamoon's smartphone reports some of the commands can't be recognized and Dreamoon knows that some of them might even be wrong though successfully recognized. Dreamoon decides to follow every recognized command and toss a fair coin to decide those unrecognized ones (that means, he moves to the 1 unit to the negative or positive direction with the same probability 0.5). 

You are given an original list of commands sent by Drazil and list received by Dreamoon. What is the probability that Dreamoon ends in the position originally supposed to be final by Drazil's commands?","The first line contains a string *s*1 — the commands Drazil sends to Dreamoon, this string consists of only the characters in the set {'+', '-'}. 

The second line contains a string *s*2 — the commands Dreamoon's smartphone recognizes, this string consists of only the characters in the set {'+', '-', '?'}. '?' denotes an unrecognized command.

Lengths of two strings are equal and do not exceed 10.",Output a single real number corresponding to the probability. The answer will be considered correct if its relative or absolute error doesn't exceed 10<=-<=9.,"['++-+-\n+-+-+\n', '+-+-\n+-??\n', '+++\n??-\n']","['1.000000000000\n', '0.500000000000\n', '0.000000000000\n']","For the first sample, both *s*<sub class=""lower-index"">1</sub> and *s*<sub class=""lower-index"">2</sub> will lead Dreamoon to finish at the same position  + 1. 

For the second sample, *s*<sub class=""lower-index"">1</sub> will lead Dreamoon to finish at position 0, while there are four possibilites for *s*<sub class=""lower-index"">2</sub>: {""+-++"", ""+-+-"", ""+--+"", ""+---""} with ending position {+2, 0, 0, -2} respectively. So there are 2 correct cases out of 4, so the probability of finishing at the correct position is 0.5. 

For the third sample, *s*<sub class=""lower-index"">2</sub> could only lead us to finish at positions {+1, -1, -3}, so the probability to finish at the correct position  + 3 is 0.",RUNTIME_ERROR,"import e
from collections import OrderedDict,Counter
import heapq
from collections import deque
import sys
def f():return map(int,b().split())
def c():return list(f())
def b(): return input()
def a(a,b):
    n=b.count('?')
    r=a.count('-')-b.count('-')
    print(0 if n<r or r<0 else e.comb(n,r)/(1<<n))
    
def d():
    n=b()
    m=b()
    (a(n,m))
    
if __name__==""__main__"":
    d()","def f():
    import h
    h.setrecursionlimit(10000)

    b = h.stdin.read().split()
    if not b:
        return

    n = int(b[0])
    g = []
    e = 1

    for _ in range(n):
        x = int(b[e])
        y = int(b[e + 1])
        g.append((x, y))
        e += 2

    d = {i: [] for i in range(n)}
    for i in range(n):
        for j in range(i + 1, n):
            if g[i][0] == g[j][0] or g[i][1] == g[j][1]:
                d[i].append(j)
                d[j].append(i)

    i = [False] * n

    def c(u):
        i[u] = True
        for v in d[u]:
            if not i[v]:
                c(v)

    a = 0
    for i in range(n):
        if not i[i]:
            c(i)
            a += 1

    print(a - 1)

if __name__ == '__main__':
    f()"
0,none,none,none,['none'],"Gerald got a very curious hexagon for his birthday. The boy found out that all the angles of the hexagon are equal to . Then he measured the length of its sides, and found that each of them is equal to an integer number of centimeters. There the properties of the hexagon ended and Gerald decided to draw on it.

He painted a few lines, parallel to the sides of the hexagon. The lines split the hexagon into regular triangles with sides of 1 centimeter. Now Gerald wonders how many triangles he has got. But there were so many of them that Gerald lost the track of his counting. Help the boy count the triangles.","The first and the single line of the input contains 6 space-separated integers *a*1,<=*a*2,<=*a*3,<=*a*4,<=*a*5 and *a*6 (1<=≤<=*a**i*<=≤<=1000) — the lengths of the sides of the hexagons in centimeters in the clockwise order. It is guaranteed that the hexagon with the indicated properties and the exactly such sides exists.","Print a single integer — the number of triangles with the sides of one 1 centimeter, into which the hexagon is split.","['1 1 1 1 1 1\n', '1 2 1 2 1 2\n']","['6\n', '13\n']","This is what Gerald's hexagon looks like in the first sample:

<img class=""tex-graphics"" src=""https://espresso.codeforces.com/84d193e27b02c38eb1eadc536602a2ec0b9f9519.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

And that's what it looks like in the second sample:

<img class=""tex-graphics"" src=""https://espresso.codeforces.com/e29076a96da8ca864654cc6195654d9bf07d31ce.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>",WRONG_ANSWER,"import math
def q(x):
    return x * x

def o(a,b):
    k = -0.5
    return abs((q(a) * q(b) - (2 * a * b * k)) ** 0.5)

def r(a,b,c):
    p = (a + b + c) / 2
    return abs((p * (p-a) * (p-b) * (p-c)) ** 0.5)

a,b,c,d,e,f = map(int,input().split())
p = (-1) * ((3 ** 0.5) / 2)
h = abs((a * b) / 2 * p)
i = abs((c * d) / 2 * p)
j = abs((e * f) / 2 * p)
l = o(a,b)
m = o(c,d)
n = o(e,f)
s = r(l,m,n)
g = h + i + j + s
print(round((g / ((3 ** 0.5) / 4))+1))","def h():
    import i
    b = i.stdin.read().splitlines()
    if not b:
        return
    n = int(b[0].strip())
    s = b[1].strip()

    f = ''.join('0' if i % 2 == 0 else '1' for i in range(n))
    g = ''.join('1' if i % 2 == 0 else '0' for i in range(n))

    def e(j):

        c = [s[i] != j[i] for i in range(n)]
        d = 0
        i = 0
        while i < n:
            if not c[i]:
                i += 1
                continue

            if i + 1 < n and c[i + 1] and s[i] == s[i + 1]:
                d += 1
                i += 2
            else:
                d += 1
                i += 1
        return d

    a = min(e(f), e(g))
    i.stdout.write(str(a))

if __name__ == '__main__':
    h()"
7,B,Memory Manager,PROGRAMMING,['implementation'],"There is little time left before the release of the first national operating system BerlOS. Some of its components are not finished yet — the memory manager is among them. According to the developers' plan, in the first release the memory manager will be very simple and rectilinear. It will support three operations: 
 -  alloc n — to allocate *n* bytes of the memory and return the allocated block's identifier *x*; -  erase x — to erase the block with the identifier *x*; -  defragment — to defragment the free memory, bringing all the blocks as close to the beginning of the memory as possible and preserving their respective order; 
The memory model in this case is very simple. It is a sequence of *m* bytes, numbered for convenience from the first to the *m*-th.

The first operation alloc n takes as the only parameter the size of the memory block that is to be allocated. While processing this operation, a free block of *n* successive bytes is being allocated in the memory. If the amount of such blocks is more than one, the block closest to the beginning of the memory (i.e. to the first byte) is prefered. All these bytes are marked as not free, and the memory manager returns a 32-bit integer numerical token that is the identifier of this block. If it is impossible to allocate a free block of this size, the function returns NULL.

The second operation erase x takes as its parameter the identifier of some block. This operation frees the system memory, marking the bytes of this block as free for further use. In the case when this identifier does not point to the previously allocated block, which has not been erased yet, the function returns ILLEGAL_ERASE_ARGUMENT.

The last operation defragment does not have any arguments and simply brings the occupied memory sections closer to the beginning of the memory without changing their respective order.

In the current implementation you are to use successive integers, starting with 1, as identifiers. Each successful alloc operation procession should return following number. Unsuccessful alloc operations do not affect numeration.

You are to write the implementation of the memory manager. You should output the returned value for each alloc command. You should also output ILLEGAL_ERASE_ARGUMENT for all the failed erase commands.","The first line of the input data contains two positive integers *t* and *m* (1<=≤<=*t*<=≤<=100;1<=≤<=*m*<=≤<=100), where *t* — the amount of operations given to the memory manager for processing, and *m* — the available memory size in bytes. Then there follow *t* lines where the operations themselves are given. The first operation is alloc n (1<=≤<=*n*<=≤<=100), where *n* is an integer. The second one is erase x, where *x* is an arbitrary 32-bit integer numerical token. The third operation is defragment.","Output the sequence of lines. Each line should contain either the result of alloc operation procession , or ILLEGAL_ERASE_ARGUMENT as a result of failed erase operation procession. Output lines should go in the same order in which the operations are processed. Successful procession of alloc operation should return integers, starting with 1, as the identifiers of the allocated blocks.",['6 10\nalloc 5\nalloc 3\nerase 1\nalloc 6\ndefragment\nalloc 6\n'],['1\n2\nNULL\n3\n'],none,WRONG_ANSWER,"def c(): 
    t, m = map(int, input().split())
    d = [0]*m
    b = 1
    a = []
    
    for _ in range(t):
        f = list(input().split()) 
        e = f[0]
        if len(f) == 2: n = f[1]; n = int(n)
        
        
        if e == ""alloc"":
            g = 0
            while n+g != m:        
                if n <= d.count(0): 
                    if d[d.index(0)+g:d.index(0)+n+g] == [0]*n:                    
                        d[d.index(0)+g:d.index(0)+n+g] = [b]*n
                        g = m-n
                        a.append(b)
                        b += 1
                    else: g +=1
                    
                    if m-n == g and d.count(b-1) != n: 
                        a.append(""NULL"")                         
                        
                else: 
                    a.append(""NULL"")    
                    g = m-n
            
            if n == m:
                if d.count(0) == m:
                    d = [b]*n 
                    a.append(b)
                    b += 1
                else:
                    a.append(""NULL"")    
                    g = m-n 
            
        elif e == ""erase"":
            if n in d:
                d = [0 if i == n else i for i in d]
            else: a.append(""ILLEGAL_ERASE_ARGUMENT"")
            
        elif e == ""defragment"":
            for _ in d:
                if 0 in d: d.remove(0)
            d = d + [0]*(m-int(len(d)))
            
        print(d)     
    for i in a: print(i)    
    
    
if __name__ == ""__main__"":
    c()","def c():

    n = int(input().strip())

    b = list(map(int, input().strip().split()))

    d = sum(b)

    e = 0

    for a in b:

        if (d - a) % 2 == 0:
            e += 1

    print(e)

if __name__ == ""__main__"":
    c()"
277,E,Binary Tree on Plane,PROGRAMMING,"['flows', 'trees']","A root tree is a directed acyclic graph that contains one node (root), from which there is exactly one path to any other node.

A root tree is binary if each node has at most two outgoing arcs.

When a binary tree is painted on the plane, all arcs should be directed from top to bottom. That is, each arc going from *u* to *v* must meet the condition *y**u*<=&gt;<=*y**v*.

You've been given the coordinates of all tree nodes. Your task is to connect these nodes by arcs so as to get the binary root tree and make the total length of the arcs minimum. All arcs of the built tree must be directed from top to bottom.","The first line contains a single integer *n* (2<=≤<=*n*<=≤<=400) — the number of nodes in the tree. Then follow *n* lines, two integers per line: *x**i*,<=*y**i* (|*x**i*|,<=|*y**i*|<=≤<=103) — coordinates of the nodes. It is guaranteed that all points are distinct.","If it is impossible to build a binary root tree on the given points, print ""-1"". Otherwise, print a single real number — the total length of the arcs in the minimum binary tree. The answer will be considered correct if the absolute or relative error doesn't exceed 10<=-<=6.","['3\n0 0\n1 0\n2 1\n', '4\n0 0\n1 0\n2 1\n2 0\n']","['3.650281539872885\n', '-1\n']",none,TIME_LIMIT_EXCEEDED,"import ~, 
from io import a, d
from array import array
from itertools import accumulate
import bisect
import z
from collections import deque

from copy import deepcopy

class b(d):
    } = 0

    def __init__(, r):
        ._fd = r.fileno()
        .buffer = a()
        .writable = ""x"" in r.mode or ""r"" not in r.mode
        .write = .buffer.write if .writable else None

    def ():
        while True:
            b = ~.(._fd, max(~.fstat(._fd).st_size, 8192))
            if not b:
                break
             = .buffer.tell()
            .buffer.seek(0, 2), .buffer.write(b), .buffer.seek()
        .} = 0
        return .buffer.()

    def ():
        while .} == 0:
            b = ~.(._fd, max(~.fstat(._fd).st_size, 8192))
            .} = b.count(b""\n"") + (not b)
             = .buffer.tell()
            .buffer.seek(0, 2), .buffer.write(b), .buffer.seek()
        .} -= 1
        return .buffer.()

    def u():
        if .writable:
            ~.write(._fd, .buffer.getvalue())
            .buffer.truncate(0), .buffer.seek(0)

class e(d):
    def __init__(, r):
        .buffer = b(r)
        .u = .buffer.u
        .writable = .buffer.writable
        .write = lambda s: .buffer.write(s.encode(""ascii""))
        . = lambda: .buffer.().decode(""ascii"")
        . = lambda: .buffer.().decode(""ascii"")

.stdin, .stdout = e(.stdin), e(.stdout)

input = lambda: .stdin.().strip()
y = lambda: list(map(int, input().split()))
f = lambda: int(input())

def (a, b, c):
    print('? {} {} {}'.format(a, b, c))
    .stdout.u()
    return int(input())

def k(, ):
    print('! {} {}'.format(, ))
    .stdout.u()

x = float('inf')

import w
class {():
    n=1
    =[]
    g=[[]]
    def __init__(,N):
        .n=N
        .=[]
        .g=[[] for i in range(N)]
    def j(,c,g,l,m):
        assert 0<=c and c<.n
        assert 0<=g and g<.n
        m=len(.)
        ..append((c,len(.g[c])))
        .g[c].append({""to"":g,""rev"":len(.g[g]),""cap"":l,""cost"":m})
        .g[g].append({""to"":c,""rev"":len(.g[c])-1,""cap"":0,""cost"":-m})
    def v(,i):
        m=len(.)
        assert 0<=i and i<m
        h=.g[.[i][0]][.[i][1]]
        i=.g[h[""to""]][h[""rev""]]
        return {""from"":.[i][0],""to"":h[""to""],""cap"":h[""cap""]+i[""cap""],
        ""flow"":i[""cap""],""cost"":h[""cost""]}
    def q():
        m=len(.)
        =[{} for i in range(m)]
        for i in range(m):
            =.v(i)
            [i][""from""]=[""from""]
            [i][""to""]=[""to""]
            [i][""cap""]=[""cap""]
            [i][""flow""]=[""flow""]
            [i][""cost""]=[""cost""]
        return 
    def s(,s,t,t=-1-(-1<<63)):
        return .(s,t,t)[-1]
    def (,s,t,t=-1-(-1<<63)):
        assert 0<=s and s<.n
        assert 0<=t and t<.n
        assert s!=t
        '''
         variants (C = maxcost):
         -(n-1)C <= dual[s] <= dual[i] <= dual[t] = 0
         reduced cost (= e.cost + dual[e.from] - dual[e.to]) >= 0 for all edge
        '''
        o=[0 for i in range(.n)]
        n=[0 for i in range(.n)]
        =[0 for i in range(.n)]
        =[0 for i in range(.n)]
        =[False for i in range(.n)]
        def p():
            for i in range(.n):
                n[i]=-1-(-1<<63)
                [i]=-1
                [i]=-1
                [i]=False
            =[]
            w.heappush(,(0,s))
            n[s]=0
            while():
                v=w.heappop()[1]
                if [v]:continue
                [v]=True
                if v==t:break
                '''
                 dist[v] = shortest(s, v) + dual[s] - dual[v]
                 dist[v] >= 0 (all reduced cost are positive)
                 dist[v] <= (n-1)C
                '''
                for i in range(len(.g[v])):
                    e=.g[v][i]
                    if [e[""to""]] or (not(e[""cap""])):continue
                    '''
                     |-dual[e.to]+dual[v]| <= (n-1)C
                     cost <= C - -(n-1)C + 0 = nC
                    '''
                    m=e[""cost""]-o[e[""to""]]+o[v]
                    if n[e[""to""]]-n[v]>m:
                        n[e[""to""]]=n[v]+m
                        [e[""to""]]=v
                        [e[""to""]]=i
                        w.heappush(,(n[e[""to""]],e[""to""]))
            if not([t]):
                return False
            for v in range(.n):
                if not([v]):continue
                o[v]-=n[t]-n[v]
            return True
        s=0
        m=0
        =-1
        =[(s,m)]
        while(s<t):
            if not(p()):
                break
            c=t-s
            v=t
            while(v!=s):
                c=min(c,.g[[v]][[v]][""cap""])
                v=[v]
            v=t
            while(v!=s):
                .g[[v]][[v]][""cap""]-=c
                .g[v][.g[[v]][[v]][""rev""]][""cap""]+=c
                v=[v]
            d=-o[s]
            s+=c
            m+=c*d
            if(==d):
                .pop()
            .append((s,m))
            =m
        return 
    

n = f()
a = []
for _ in range(n):
    x,y = y()
    a.append((x,y))

s = 2*n
t = 2*n+1
| = {(2*n+2)

for i in range(n):
    for j in range(i+1,n):
        if a[i][1] == a[j][1]:
            continue
        if a[i][1] > a[j][1]:
            d = z.sqrt((a[i][0] - a[j][0])**2 + (a[i][1] - a[j][1])**2)
            |.j(i,j+n,1,d)
        elif a[i][1] < a[j][1]:
            d = z.sqrt((a[i][0] - a[j][0])**2 + (a[i][1] - a[j][1])**2)
            |.j(j,i+n,1,d)          

for i in range(n):
    |.j(s,i,2,0)

for j in range(n):
    |.j(j+n,t,1,0)

s = |.s(s,t,x)
if s[0] < n-1:
    print(""-1"")
    .exit()
print(s[-1])","import h

def a(a, b, c):

    for f in range(c // a + 1):

        e = c - a * f

        if e % b == 0:

            return True
    return False

def d():

    b = h.stdin.readlines()

    for c in b:

        g = c.strip()
        if not g:
            continue

        a, b, c = map(int, g.split())

        if a(a, b, c):
            print(""Yes"")
        else:
            print(""No"")

if __name__ == ""__main__"":
    d()"
202,A,LLPS,PROGRAMMING,"['binary search', 'bitmasks', 'brute force', 'greedy', 'implementation', 'strings']","This problem's actual name, ""Lexicographically Largest Palindromic Subsequence"" is too long to fit into the page headline.

You are given string *s* consisting of lowercase English letters only. Find its lexicographically largest palindromic subsequence.

We'll call a non-empty string *s*[*p*1*p*2... *p**k*] = *s**p*1*s**p*2... *s**p**k* (1 <=≤<= *p*1<=&lt;<=*p*2<=&lt;<=...<=&lt;<=*p**k* <=≤<= |*s*|) a subsequence of string *s* = *s*1*s*2... *s*|*s*|, where |*s*| is the length of string *s*. For example, strings ""abcb"", ""b"" and ""abacaba"" are subsequences of string ""abacaba"".

String *x* = *x*1*x*2... *x*|*x*| is lexicographically larger than string *y* = *y*1*y*2... *y*|*y*| if either |*x*| &gt; |*y*| and *x*1<==<=*y*1, *x*2<==<=*y*2, ...,<=*x*|*y*|<==<=*y*|*y*|, or there exists such number *r* (*r*<=&lt;<=|*x*|, *r*<=&lt;<=|*y*|) that *x*1<==<=*y*1, *x*2<==<=*y*2, ..., *x**r*<==<=*y**r* and *x**r*<=<=+<=<=1<=&gt;<=*y**r*<=<=+<=<=1. Characters in the strings are compared according to their ASCII codes. For example, string ""ranger"" is lexicographically larger than string ""racecar"" and string ""poster"" is lexicographically larger than string ""post"".

String *s* = *s*1*s*2... *s*|*s*| is a palindrome if it matches string *rev*(*s*) = *s*|*s*|*s*|*s*|<=-<=1... *s*1. In other words, a string is a palindrome if it reads the same way from left to right and from right to left. For example, palindromic strings are ""racecar"", ""refer"" and ""z"".",The only input line contains a non-empty string *s* consisting of lowercase English letters only. Its length does not exceed 10.,Print the lexicographically largest palindromic subsequence of string *s*.,"['radar\n', 'bowwowwow\n', 'codeforces\n', 'mississipp\n']","['rr\n', 'wwwww\n', 's\n', 'ssss\n']","Among all distinct subsequences of string ""radar"" the following ones are palindromes: ""a"", ""d"", ""r"", ""aa"", ""rr"", ""ada"", ""rar"", ""rdr"", ""raar"" and ""radar"". The lexicographically largest of them is ""rr"".",OK,"from itertools import a
def c(d):
    for e in range(1, len(d)+1):
        for b in a(d, e):
            yield ''.join(b)
print(sorted([s for s in c(input()) if s[::-1] == s])[-1])","import d

def b(x):

    if x < 2:
        return False

    for i in range(2, int(d.sqrt(x)) + 1):
        if x % i == 0:
            return False
    return True

def c():

    n = int(input().strip())

    for m in range(1, 1001):

        a = n * m + 1

        if not b(a):
            print(m)
            return

if __name__ == ""__main__"":
    c()"
300,C,Beautiful Numbers,PROGRAMMING,"['brute force', 'combinatorics']","Vitaly is a very weird man. He's got two favorite digits *a* and *b*. Vitaly calls a positive integer good, if the decimal representation of this integer only contains digits *a* and *b*. Vitaly calls a good number excellent, if the sum of its digits is a good number.

For example, let's say that Vitaly's favourite digits are 1 and 3, then number 12 isn't good and numbers 13 or 311 are. Also, number 111 is excellent and number 11 isn't. 

Now Vitaly is wondering, how many excellent numbers of length exactly *n* are there. As this number can be rather large, he asks you to count the remainder after dividing it by 1000000007 (109<=+<=7).

A number's length is the number of digits in its decimal representation without leading zeroes.","The first line contains three integers: *a*, *b*, *n* (1<=≤<=*a*<=&lt;<=*b*<=≤<=9,<=1<=≤<=*n*<=≤<=106).",Print a single integer — the answer to the problem modulo 1000000007 (109<=+<=7).,"['1 3 3\n', '2 3 10\n']","['1\n', '165\n']",none,OK,"import , threading
import w
from os import |
from collections import deque, defaultdict, Counter
from bisect import *
from string import ascii_lowercase
from functools import cmp_to_key
from random import ~
from heapq import *
from array import array
from types import a
 
 
def ():
    x = list(map(int, (.stdin.readline().rstrip().split())))
    return x[0] if len(x) == 1 else x
 
 
def (type=int):
    x = .stdin.readline()
    x = list(map(type, x.rstrip('\n\r').split()))
    return x
 
 
def ():
    x = .stdin.readline().rstrip('\r\n')
    return x
 
 
 = .stdout.
 = .stdin.readline
 
 
b = 1123456

def h(f, =[]):
    def (*f, **t):
        if :
            return f(*f, **t)
        else:
             = f(*f, **t)
            while True:
                if type() is a:
                    .append()
                     = next()
                else:
                    .pop()
                    if not :
                        break
                     = [-1].send()
            return 
    return 

class mydict:
    def __init__(, o=lambda: 0):
        .random = ~(0, 1 << 32)
        .k = o
        .dict = {}
 
    def c(, s):
        y = .random ^ s
        if y not in .dict:
            .dict[y] = .k()
        return .dict[y]
 
    def p(, s, k):
        y = .random ^ s
        if y not in .dict:
            return k
        return .dict[y]
 
    def d(, s, r):
        y = .random ^ s
        .dict[y] = r
 
    def q():
        return [.random ^ i for i in .dict]
 
    def __str__():
        return f'{[(.random ^ i, .dict[i]) for i in .dict]}'

def u(a, b):
    return (a*b)//(w.gcd(a,b))
 
 
def x(n):
    return n%(1000000007) 

def }(g, l):
    if (l == 0):
        return 1
    if (l == 1):
        return g
     
     
    if (l % 2 == 0):
        t = }(g, l // 2)
        t = x(t * t)
        return t    

    else:
        return x(}(g, l-1)*g)

n = []
n = [1]
m = 1
for i in range(1, b):
    m = x(x(m)*x(i))
    n.append(m)
    
def {(n, r):

    if r > n:
        return 0

    z = n[n]
    i = }(n[r], 1000000005)
    j = }(n[n-r], 1000000005)

    return x(x(z)*x(i)*x(j))

def (t):

    a, b, n = ()
    e = 0
    for i in range(n+1):
         = i*a + b*(n-i)
         = set(str())
        .discard(str(a))
        .discard(str(b))
        if len() > 0:
            continue

        e = x(e + {(n, i))

    print(e)

def v():
    t = 1
    if |.exists(""/Users/arijitbhaumik/Library/Application Support/Sublime Text/Packages/User/input.txt""):
        .stdin = open(""/Users/arijitbhaumik/Library/Application Support/Sublime Text/Packages/User/input.txt"", 'r')
        .stdout = open(""/Users/arijitbhaumik/Library/Application Support/Sublime Text/Packages/User/output.txt"", 'w')

    for i in range(t):
        (i+1)
 
 
if __name__ == '__main__':
    v()","def j():
    import q, k
    c = q.stdin.read().splitlines()
    if not c:
        return

    n, m, x = map(int, c[0].strip().split())

    e = {chr(c): [] for c in range(ord('a'), ord('z') + 1)}
    n = []

    for i in range(1, n + 1):
        f = c[i].strip()
        for j, b in enumerate(f):
            if b == 'S':
                n.append((i - 1, j))
            else:
                e[b].append((i - 1, j))

    a = {}
    for d in e:
        if not e[d]:
            a[d] = False
            continue
        m = False
        if n:
            for h, i in e[d]:
                for o, p in n:
                    if k.sqrt((h - o) ** 2 + (i - p) ** 2) <= x:
                        m = True
                        break
                if m:
                    break
        a[d] = m

    q = int(c[n + 1].strip())
    r = c[n + 2].strip()

    l = 0

    for b in r:
        if b.islower():

            if not e[b]:
                q.stdout.write(""-1"")
                return
        else:

            g = b.lower()
            if not e[g]:
                q.stdout.write(""-1"")
                return

            if not n:
                q.stdout.write(""-1"")
                return

            if not a[g]:
                l += 1

    q.stdout.write(str(l))

if __name__ == ""__main__"":
    j()"
633,A,Ebony and Ivory,PROGRAMMING,"['brute force', 'math', 'number theory']","Dante is engaged in a fight with ""The Savior"". Before he can fight it with his sword, he needs to break its shields. He has two guns, Ebony and Ivory, each of them is able to perform any non-negative number of shots.

For every bullet that hits the shield, Ebony deals *a* units of damage while Ivory deals *b* units of damage. In order to break the shield Dante has to deal exactly *c* units of damage. Find out if this is possible.","The first line of the input contains three integers *a*, *b*, *c* (1<=≤<=*a*,<=*b*<=≤<=100,<=1<=≤<=*c*<=≤<=10<=000) — the number of units of damage dealt by Ebony gun and Ivory gun, and the total number of damage required to break the shield, respectively.","Print ""Yes"" (without quotes) if Dante can deal exactly *c* damage to the shield and ""No"" (without quotes) otherwise.","['4 6 15\n', '3 2 7\n', '6 11 6\n']","['No\n', 'Yes\n', 'Yes\n']","In the second sample, Dante can fire 1 bullet from Ebony and 2 from Ivory to deal exactly 1·3 + 2·2 = 7 damage. In the third sample, Dante can fire 1 bullet from ebony and no bullets from ivory to do 1·6 + 0·11 = 6 damage.",WRONG_ANSWER,"from math import b
def a(a, b):
    c, d = 1, 0
    x, y = 0, 1
    while b != 0:
        a, (q, b) = b, divmod(a, b)
        c, x = x, c - q * x
        d, y = y, d - q * y
    return a, c, d

a,b,c = [int(d) for d in input().split()]

if c%b(a,b) != 0:
    print(""No"")
else:
    a,c,d = a(a,b)
    if (c < 0 and d > 0) or (c > 0 and d < 0) :
        x = c*c
        y = d*c
        k = (y//a)
        if (y//a < y/a):
            k += 1
        if x - k*b < 0:
            print(""No"")
        else:
            print(""Yes"")
    else:
        print(""Yes"")","n, m, c = input().split()
n = int(n)
m = int(m)

h = [input().strip() for _ in range(n)]

b = set()

d = [(-1, 0), (1, 0), (0, -1), (0, 1)]

for i in range(n):
    for j in range(m):

        if h[i][j] == c:

            for c, e in d:
                f, g = i + c, j + e

                if 0 <= f < n and 0 <= g < m:

                    a = h[f][g]
                    if a != '.' and a != c:
                        b.add(a)

print(len(b))"
81,B,Sequence Formatting,PROGRAMMING,"['implementation', 'strings']","Polycarp is very careful. He even types numeric sequences carefully, unlike his classmates. If he sees a sequence without a space after the comma, with two spaces in a row, or when something else does not look neat, he rushes to correct it. For example, number sequence written like ""1,2 ,3,...,   10"" will be corrected to ""1, 2, 3, ..., 10"".

In this task you are given a string *s*, which is composed by a concatination of terms, each of which may be: 
 -  a positive integer of an arbitrary length (leading zeroes are not allowed), -  a ""comma"" symbol ("",""), -  a ""space"" symbol ("" ""), -  ""three dots"" (""..."", that is, exactly three points written one after another, also known as suspension points). 
Polycarp wants to add and remove spaces in the string *s* to ensure the following: 
 -  each comma is followed by exactly one space (if the comma is the last character in the string, this rule does not apply to it), -  each ""three dots"" term is preceded by exactly one space (if the dots are at the beginning of the string, this rule does not apply to the term), -  if two consecutive numbers were separated by spaces only (one or more), then exactly one of them should be left, -  there should not be other spaces. 
Automate Polycarp's work and write a program that will process the given string *s*.",The input data contains a single string *s*. Its length is from 1 to 255 characters. The string *s* does not begin and end with a space. Its content matches the description given above.,"Print the string *s* after it is processed. Your program's output should be exactly the same as the expected answer. It is permissible to end output line with a line-break character, and without it.","['1,2 ,3,...,     10\n', '1,,,4...5......6\n', '...,1,2,3,...\n']","['1, 2, 3, ..., 10\n', '1, , , 4 ...5 ... ...6\n', '..., 1, 2, 3, ...\n']",none,WRONG_ANSWER,"def c():return map(int,input().split())
def e():return map(str,input().split(','))
def d():return list(e())

s=d()

f=[]
for x in s:f.append((list(map(str,x.split()))))

a=''
for x in f:
    if x==[]:a+=', '
    else:
        for i in x:
            a+=i+', '

b=''
i=0
k=len(a)
while i<k:
    if a[i:i+3]=='...' and a[i+3]!=',':
        a=a[:i:]+' ...'+a[i+3:]
        i=i+3
        k=len(a)
    i=i+1
print(a[:len(a)-2:])","def e():
    import m
    b = m.stdin.read().split()
    if not b:
        return

    n = int(b[0])
    j = b[1]
    k = b[2]

    g = list(range(26))

    def a(x):
        if g[x] != x:
            g[x] = a(g[x])
        return g[x]

    def n(x, y):
        h = a(x)
        i = a(y)
        if h != i:
            g[i] = h
            return True
        return False
    
    l = []

    for i in range(n):
        a = ord(j[i]) - ord('a')
        b = ord(k[i]) - ord('a')
        if n(a, b):

            c = chr(a + ord('a'))
            d = chr(b + ord('a'))
            l.append((c, d))

    f = []
    f.append(str(len(l)))
    for a, b in l:
        f.append(f""{a} {b}"")
    
    m.stdout.write(""\n"".join(f))
    
if __name__ == ""__main__"":
    e()"
387,B,George and Round,PROGRAMMING,"['brute force', 'greedy', 'two pointers']","George decided to prepare a Codesecrof round, so he has prepared *m* problems for the round. Let's number the problems with integers 1 through *m*. George estimates the *i*-th problem's complexity by integer *b**i*.

To make the round good, he needs to put at least *n* problems there. Besides, he needs to have at least one problem with complexity exactly *a*1, at least one with complexity exactly *a*2, ..., and at least one with complexity exactly *a**n*. Of course, the round can also have problems with other complexities.

George has a poor imagination. It's easier for him to make some already prepared problem simpler than to come up with a new one and prepare it. George is magnificent at simplifying problems. He can simplify any already prepared problem with complexity *c* to any positive integer complexity *d* (*c*<=≥<=*d*), by changing limits on the input data.

However, nothing is so simple. George understood that even if he simplifies some problems, he can run out of problems for a good round. That's why he decided to find out the minimum number of problems he needs to come up with in addition to the *m* he's prepared in order to make a good round. Note that George can come up with a new problem of any complexity.","The first line contains two integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=3000) — the minimal number of problems in a good round and the number of problems George's prepared. The second line contains space-separated integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a*1<=&lt;<=*a*2<=&lt;<=...<=&lt;<=*a**n*<=≤<=106) — the requirements for the complexity of the problems in a good round. The third line contains space-separated integers *b*1,<=*b*2,<=...,<=*b**m* (1<=≤<=*b*1<=≤<=*b*2...<=≤<=*b**m*<=≤<=106) — the complexities of the problems prepared by George.",Print a single integer — the answer to the problem.,"['3 5\n1 2 3\n1 2 2 3 3\n', '3 5\n1 2 3\n1 1 1 1 1\n', '3 1\n2 3 4\n1\n']","['0\n', '2\n', '3\n']","In the first sample the set of the prepared problems meets the requirements for a good round.

In the second sample, it is enough to come up with and prepare two problems with complexities 2 and 3 to get a good round.

In the third sample it is very easy to get a good round if come up with and prepare extra problems with complexities: 2, 3, 4.",WRONG_ANSWER,"def a(f, d):
    i = 0
    j = 0
    c = 0
    while i < len(f) and j < len(d):
        if f[i] == d[j]:
            c += 1
            i += 1
            j += 1
        elif f[i] < d[j]:
            i += 1
        else:
            j += 1

    return len(f) - c

b = input()
A = list(map(int, input().split()))
B = list(map(int, input().split()))
e = a(A, B)
print(e)","def h():
    import n
    from itertools import m

    e = n.stdin.read().splitlines()
    if not e:
        return

    i = e[0].split()
    n = int(i[0])
    q = int(i[1])

    j = {}
    for i in range(1, q + 1):
        g = e[i].strip()
        if not g:
            continue
        l = g.split()
        a, b = l[0], l[1]
        j[a] = b

    f = ""abcdef""

    c = 0

    for o in m(f, repeat=n):

        s = list(o)

        d = s[0]
        p = True

        for i in range(1, n):
            k = d + s[i]

            if k not in j:
                p = False
                break
            d = j[k]

        if p and d == 'a':
            c += 1

    n.stdout.write(str(c) + ""\n"")

if __name__ == '__main__':
    h()"
489,C,Given Length and Sum of Digits...,PROGRAMMING,"['dp', 'greedy', 'implementation']",You have a positive integer *m* and a non-negative integer *s*. Your task is to find the smallest and the largest of the numbers that have length *m* and sum of digits *s*. The required numbers should be non-negative integers written in the decimal base without leading zeroes.,"The single line of the input contains a pair of integers *m*, *s* (1<=≤<=*m*<=≤<=100,<=0<=≤<=*s*<=≤<=900) — the length and the sum of the digits of the required numbers.","In the output print the pair of the required non-negative integer numbers — first the minimum possible number, then — the maximum possible number. If no numbers satisfying conditions required exist, print the pair of numbers ""-1 -1"" (without the quotes).","['2 15\n', '3 0\n']","['69 96\n', '-1 -1\n']",none,OK,"def b(m, s):
    if s == 0:
        return 0 if m == 1 else -1
    a = [0] * m
    a[-1] = s - 1
    i = len(a) - 1
    while a[i] > 9:
        if i <= 0:
            return -1
        a[i - 1], a[i] = a[i] - 9, 9
        i -= 1
    a[0] += 1
    if a[0] > 9:
        return -1
    return """".join(str(d) for d in a)

def a(m, s):
    if s == 0:
        return 0 if m == 1 else -1
    a = [0] * m
    a[0] = s
    i = 0
    while a[i] > 9:
        if i >= len(a) - 1:
            return -1
        a[i], a[i + 1] = 9, a[i] - 9
        i += 1
    return """".join(str(d) for d in a)

m, s = map(int, input().split())
print(b(m, s), a(m, s))","from collections import a

b = a()

n = int(input().strip())

for _ in range(n):

    c = input().strip()

    if c in b:
        del b[c]

    b[c] = None
    b.move_to_end(c, last=False)

for c in b:
    print(c)"
535,B,Tavas and SaDDas,PROGRAMMING,"['bitmasks', 'brute force', 'combinatorics', 'implementation']","Once again Tavas started eating coffee mix without water! Keione told him that it smells awful, but he didn't stop doing that. That's why Keione told his smart friend, SaDDas to punish him! SaDDas took Tavas' headphones and told him: ""If you solve the following problem, I'll return it to you.""

The problem is: 

You are given a lucky number *n*. Lucky numbers are the positive integers whose decimal representations contain only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.

If we sort all lucky numbers in increasing order, what's the 1-based index of *n*? 

Tavas is not as smart as SaDDas, so he asked you to do him a favor and solve this problem so he can have his headphones back.",The first and only line of input contains a lucky number *n* (1<=≤<=*n*<=≤<=109).,Print the index of *n* among all lucky numbers.,"['4\n', '7\n', '77\n']","['1\n', '2\n', '6\n']",none,OK,"def a(n):
    d = len(n)
    s = """"
    for i in range(d):
        if n[i] == '4':
            s += '0'
        else:
            s += '1'
    return 2*(2**(d-1)-1)+int(s,2)+1

n = input()
b = a(n)
print(b)","import h
h.setrecursionlimit(300000)

def a(s):

    n = len(s)
    if n % 2 == 1:

        return s
    else:

        d = n // 2
        b = a(s[:d])
        e = a(s[d:])

        if b <= e:
            return b + e
        else:
            return e + b

def c():

    f = h.stdin.readline().strip()
    g = h.stdin.readline().strip()

    if a(f) == a(g):
        h.stdout.write(""YES"")
    else:
        h.stdout.write(""NO"")

if __name__ == ""__main__"":
    c()"
957,A,Tritonic Iridescence,PROGRAMMING,['implementation'],"Overlooking the captivating blend of myriads of vernal hues, Arkady the painter lays out a long, long canvas.

Arkady has a sufficiently large amount of paint of three colours: cyan, magenta, and yellow. On the one-dimensional canvas split into *n* consecutive segments, each segment needs to be painted in one of the colours.

Arkady has already painted some (possibly none or all) segments and passes the paintbrush to you. You are to determine whether there are at least two ways of colouring all the unpainted segments so that no two adjacent segments are of the same colour. Two ways are considered different if and only if a segment is painted in different colours in them.","The first line contains a single positive integer *n* (1<=≤<=*n*<=≤<=100) — the length of the canvas.

The second line contains a string *s* of *n* characters, the *i*-th of which is either 'C' (denoting a segment painted in cyan), 'M' (denoting one painted in magenta), 'Y' (one painted in yellow), or '?' (an unpainted one).","If there are at least two different ways of painting, output ""Yes""; otherwise output ""No"" (both without quotes).

You can print each character in any case (upper or lower).","['5\nCY??Y\n', '5\nC?C?Y\n', '5\n?CYC?\n', '5\nC??MM\n', '3\nMMY\n']","['Yes\n', 'Yes\n', 'Yes\n', 'No\n', 'No\n']","For the first example, there are exactly two different ways of colouring: CYCMY and CYMCY.

For the second example, there are also exactly two different ways of colouring: CMCMY and CYCMY.

For the third example, there are four ways of colouring: MCYCM, MCYCY, YCYCM, and YCYCY.

For the fourth example, no matter how the unpainted segments are coloured, the existing magenta segments will prevent the painting from satisfying the requirements. The similar is true for the fifth example.",WRONG_ANSWER,"n = int(input());
s = input();

def f():
	for i in range(n-1):
		if s[i] == s[i+1] and s[i] != ""?"":
			return False
	if ""??"" in s:
		return True
	if ""C?C"" in s or ""M?M"" in s or ""Y?Y"" in s:
		return True
	return False

if f():
	print(""Yes"")
else:
	print(""No"")","import m
import j

def i():

    a = m.stdin.read().strip().split()
    if not a:
        return
    f = iter(a)
    n = int(next(f))
    m = int(next(f))

    k = []
    for _ in range(m):
        k = int(next(f))
        f = int(next(f))
        k.append((k, f))

    def o(x):
        for k, f in k:

            if not ((f - 1) * x + 1 <= k <= f * x):
                return False
        return True

    d = 1
    e = None
    for k, f in k:

        h = j.ceil(k / f)
        d = max(d, h)

        if f > 1:
            n = (k - 1) // (f - 1)
            if e is None:
                e = n
            else:
                e = min(e, n)

    if e is None:
        g = max(n + 100, d)
    else:
        g = e

    l = set()

    for x in range(d, g + 1):
        if o(x):
            c = (n - 1) // x + 1
            l.add(c)

    if e is None:
        b = False
        for x in range(max(d, n), g + 1):
            if o(x):
                b = True
                break

        if not b and o(max(d, n)):
            b = True
        if b:
            l.add(1)

    if len(l) == 1:
        print(l.pop())
    else:
        print(-1)

if __name__ == '__main__':
    i()"
27,B,Tournament,PROGRAMMING,"['bitmasks', 'brute force', 'dfs and similar', 'greedy']","The tournament «Sleepyhead-2010» in the rapid falling asleep has just finished in Berland. *n* best participants from the country have participated in it. The tournament consists of games, each of them is a match between two participants. *n*·(*n*<=-<=1)<=/<=2 games were played during the tournament, and each participant had a match with each other participant. 

The rules of the game are quite simple — the participant who falls asleep first wins. The secretary made a record of each game in the form «*x**i* *y**i*», where *x**i* and *y**i* are the numbers of participants. The first number in each pair is a winner (i.e. *x**i* is a winner and *y**i* is a loser). There is no draws.

Recently researches form the «Institute Of Sleep» have found that every person is characterized by a value *p**j* — the speed of falling asleep. The person who has lower speed wins. Every person has its own value *p**j*, constant during the life. 

It is known that all participants of the tournament have distinct speeds of falling asleep. Also it was found that the secretary made records about all the games except one. You are to find the result of the missing game.","The first line contains one integer *n* (3<=≤<=*n*<=≤<=50) — the number of participants. The following *n*·(*n*<=-<=1)<=/<=2<=-<=1 lines contain the results of the games. Each game is described in a single line by two integers *x**i*,<=*y**i* (1<=≤<=*x**i*,<=*y**i*<=≤<=*n*,<=*x**i*<=≠<=*y**i*), where *x**i* и *y**i* are the numbers of the opponents in this game. It is known that during the tournament each of the *n* participants played *n*<=-<=1 games, one game with each other participant.","Output two integers *x* and *y* — the missing record. If there are several solutions, output any of them.",['4\n4 2\n4 1\n2 3\n2 1\n3 1\n'],['4 3\n'],none,WRONG_ANSWER,"def f():
    n = int(input())

    a = {}

    for i in range(n * (n - 1) // 2 - 1):
        c = [int(i) for i in input().split()]
        if c[0] in a:
            a[c[0]][0].append(c[1])
        else:
            a[c[0]] = [[c[1]], []]
        if c[1] in a:
            a[c[1]][1].append(c[0])
        else:
            a[c[1]] = [[], [c[0]]]
    e = []
    for i in a:
        if len(a[i][0]) + len(a[i][1]) < n - 1:
            e.append(i)

    d = [e[0]]
    b = 0
    g = {e[0]}
    while b < len(d):
        print(d)
        if d[b] == e[1]:
            print(e[0], e[1])
            break
        for i in a[d[b]][0]:
            if i not in g:
                g.add(i)
                d.append(i)
        b += 1
    else:
        print(e[1], e[0])

if __name__ == '__main__':
    f()","""""""
We want to count the number of sequences (a1, a2, ..., an) consisting of positive integers such that:
   • The sum of the sequence is equal to y.
   • The greatest common divisor gcd(a1, a2, ..., an) is exactly x.
Since any valid sequence must have every term divisible by x, we set
   ai = x * bi  for all i.
Then the sum condition becomes:
   x * (b1 + b2 + ... + bn) = y  -->  b1 + b2 + ... + bn = S,  where S = y // x.
Also, the condition gcd(a1,...,an) = x is equivalent to gcd(b1,...,bn) = 1.

It is well known that the number of compositions (ordered sum) of S 
into positive integers is f(S) = 2^(S-1).

Thus our problem reduces to: Count the number of compositions of S into positive integers b_i
such that gcd(b1, b2, ...)=1.

We can use inclusion–exclusion (with the Möbius function μ) to count sequences with gcd 1:
    answer = ∑_{d | S} μ(d) * f(S/d)
where the summation is taken only over square‐free divisors d.
If y is not divisible by x, there is no valid sequence.
Since the answer can be large, we take it modulo 10^9+7.
""""""

def h():
    import p, math
    a = 10**9 + 7

    d = p.stdin.read().strip().split()
    if not d:
        return
    x = int(d[0])
    y = int(d[1])

    if y % x != 0:
        print(0)
        return

    S = y // x

    def j(a, b, i=a):
        n = 1
        a %= i
        while b:
            if b & 1:
                n = (n * a) % i
            a = (a * a) % i
            b //= 2
        return n

    def c(n):
        return j(2, n-1, a)

    def f(n):
        g = {}
        q = n
        while q % 2 == 0:
            g[2] = g.get(2, 0) + 1
            q //= 2
        p = 3
        while p * p <= q:
            while q % p == 0:
                g[p] = g.get(p, 0) + 1
                q //= p
            p += 2
        if q > 1:
            g[q] = g.get(q, 0) + 1
        return g

    e = f(S)

    o = [1]
    for p in e.keys():
        m = []
        for d in o:
            m.append(d * p)
        o += m

    n = 0
    for d in o:

        b = 0
        q = d
        for p in e:
            if q % p == 0:
                b += 1
        k = -1 if (b % 2 == 1) else 1
        l = S // d
        r = k * c(l)
        n = (n + r) % a
    print(n % a)

if __name__ == '__main__':
    h()"
849,A,Odds and Ends,PROGRAMMING,['implementation'],"Where do odds begin, and where do they end? Where does hope emerge, and will they ever break?

Given an integer sequence *a*1,<=*a*2,<=...,<=*a**n* of length *n*. Decide whether it is possible to divide it into an odd number of non-empty subsegments, the each of which has an odd length and begins and ends with odd numbers.

A subsegment is a contiguous slice of the whole sequence. For example, {3,<=4,<=5} and {1} are subsegments of sequence {1,<=2,<=3,<=4,<=5,<=6}, while {1,<=2,<=4} and {7} are not.","The first line of input contains a non-negative integer *n* (1<=≤<=*n*<=≤<=100) — the length of the sequence.

The second line contains *n* space-separated non-negative integers *a*1,<=*a*2,<=...,<=*a**n* (0<=≤<=*a**i*<=≤<=100) — the elements of the sequence.","Output ""Yes"" if it's possible to fulfill the requirements, and ""No"" otherwise.

You can output each letter in any case (upper or lower).","['3\n1 3 5\n', '5\n1 0 1 5 1\n', '3\n4 3 1\n', '4\n3 9 9 3\n']","['Yes\n', 'Yes\n', 'No\n', 'No\n']","In the first example, divide the sequence into 1 subsegment: {1, 3, 5} and the requirements will be met.

In the second example, divide the sequence into 3 subsegments: {1, 0, 1}, {5}, {1}.

In the third example, one of the subsegments must start with 4 which is an even number, thus the requirements cannot be met.

In the fourth example, the sequence can be divided into 2 subsegments: {3, 9, 9}, {3}, but this is not a valid solution because 2 is an even number.",OK,"n   = int(input())
a = list(map(int, input().split()))

if n % 2 and a[0] % 2 and a[-1] % 2: print(""Yes"")
else:                                    print(""No"")","def e():
    import f

    d = f.stdin.read().split()
    if not d:
        return

    a = int(d[0])
    q = int(d[1])
    l = int(d[2])
    m = int(d[3])

    b = set(int(x) for x in d[4:4+m])

    if abs(a) > l:
        print(0)
        return

    if a == 0:

        if 0 in b:

            print(0)
        else:

            print(""inf"")
        return

    if q == 0:
        c = 0

        if abs(a) <= l and a not in b:
            c += 1

        if abs(0) <= l:
            if 0 not in b:
                print(""inf"")
                return
        print(c)
        return

    if q == 1:
        if abs(a) <= l:
            if a not in b:
                print(""inf"")
            else:
                print(0)
        else:
            print(0)
        return

    if q == -1:
        if abs(a) <= l:

            if a in b and (-a) in b:
                print(0)
            else:
                print(""inf"")
        else:
            print(0)
        return

    c = 0
    g = a
    while abs(g) <= l:
        if g not in b:
            c += 1
        g *= q
    print(c)

if __name__ == ""__main__"":
    e()"
41,A,Translation,PROGRAMMING,"['implementation', 'strings']","The translation from the Berland language into the Birland language is not an easy task. Those languages are very similar: a berlandish word differs from a birlandish word with the same meaning a little: it is spelled (and pronounced) reversely. For example, a Berlandish word code corresponds to a Birlandish word edoc. However, it's easy to make a mistake during the «translation». Vasya translated word *s* from Berlandish into Birlandish as *t*. Help him: find out if he translated the word correctly.","The first line contains word *s*, the second line contains word *t*. The words consist of lowercase Latin letters. The input data do not consist unnecessary spaces. The words are not empty and their lengths do not exceed 100 symbols.","If the word *t* is a word *s*, written reversely, print YES, otherwise print NO.","['code\nedoc\n', 'abb\naba\n', 'code\ncode\n']","['YES\n', 'NO\n', 'NO\n']",none,OK,"import c, a
 
input = a.BytesIO(c.read(0, c.fstat(0).st_size)).readline
 
def b():    
    s = input().decode().rstrip(""\r\n"")
    t = input().decode().rstrip(""\r\n"")
    if s == t[::-1]:
        print(""YES"")
    else:
        print(""NO"")

b()","import a

n, m, a = map(int, input().split())

c = a.ceil(n / a)
b = a.ceil(m / a)

d = c * b

print(d)"
632,A,Grandma Laura and Apples,PROGRAMMING,[],"Grandma Laura came to the market to sell some apples. During the day she sold all the apples she had. But grandma is old, so she forgot how many apples she had brought to the market.

She precisely remembers she had *n* buyers and each of them bought exactly half of the apples she had at the moment of the purchase and also she gave a half of an apple to some of them as a gift (if the number of apples at the moment of purchase was odd), until she sold all the apples she had.

So each buyer took some integral positive number of apples, but maybe he didn't pay for a half of an apple (if the number of apples at the moment of the purchase was odd).

For each buyer grandma remembers if she gave a half of an apple as a gift or not. The cost of an apple is *p* (the number *p* is even).

Print the total money grandma should have at the end of the day to check if some buyers cheated her.","The first line contains two integers *n* and *p* (1<=≤<=*n*<=≤<=40,<=2<=≤<=*p*<=≤<=1000) — the number of the buyers and the cost of one apple. It is guaranteed that the number *p* is even.

The next *n* lines contains the description of buyers. Each buyer is described with the string half if he simply bought half of the apples and with the string halfplus if grandma also gave him a half of an apple as a gift.

It is guaranteed that grandma has at least one apple at the start of the day and she has no apples at the end of the day.","Print the only integer *a* — the total money grandma should have at the end of the day.

Note that the answer can be too large, so you should use 64-bit integer type to store it. In C++ you can use the long long integer type and in Java you can use long integer type.","['2 10\nhalf\nhalfplus\n', '3 10\nhalfplus\nhalfplus\nhalfplus\n']","['15\n', '55\n']",In the first sample at the start of the day the grandma had two apples. First she sold one apple and then she sold a half of the second apple and gave a half of the second apple as a present to the second buyer.,WRONG_ANSWER,"import math

def c():
    n, p = [int(i) for i in input().split("" "")]
    b = [input() for i in range(n)]
    a = 0
    b.reverse()
    for i in range(len(b)):
        if i == 0:

                d = 1
                a += int(0.5 * p)
        else:
            if len(b[i]) == 8:
                a += int((d + 0.5) * p)
                d += d + 1
                d = int(d)

            else:
                a += int((d)) * p
                d += d + 1
                d = int(d)

    print(a)

if __name__ == '__main__':
    c()","""""""
This script processes queries on a defined function g(x).
g(x) is obtained by repeatedly computing f(x) until x is a single digit.
Here, f(x) is defined as the product of non-zero digits of x.
For example, g(33) = g(3*3) = g(9) = 9, and g(47) = g(4*7) = g(28) = g(2*8) = g(16) = g(1*6) = 6.
We precompute g(x) for all x in [1, 10^6] and use prefix sum arrays for each k (1 to 9) to quickly answer the queries.
""""""

import m

def l(n):
    """"""Return the product of the non-zero digits of n.""""""
    k = 1
    while n:
        d = n % 10
        if d != 0:
            k *= d
        n //= 10
    return k

def c(x):
    """"""
    Compute g(x): repeatedly replace x by the product of its non-zero digits 
    until a single digit is obtained.
    """"""
    while x >= 10:
        x = l(x)
    return x

def h():
    g = m.stdin.read().strip().split()
    if not g:
        return

    q = int(g[0])
    a = 10**6

    e = [0] * (a + 1)
    for x in range(1, a + 1):
        if x < 10:

            e[x] = x
        else:
            n = x

            while n >= 10:
                n = l(n)
            e[x] = n

    j = [[0] * (a + 1) for _ in range(10)]
    for i in range(1, a + 1):
        for k in range(1, 10):
            j[k][i] = j[k][i - 1]
        d = e[i]
        j[d][i] += 1

    i = []
    f = 1

    for _ in range(q):
        l = int(g[f])
        r = int(g[f + 1])
        k = int(g[f + 2])
        f += 3

        b = j[k][r] - (j[k][l - 1] if l > 1 else 0)
        i.append(str(b))
    
    m.stdout.write(""\n"".join(i))

if __name__ == '__main__':
    h()"
315,B,Sereja and Array,PROGRAMMING,['implementation'],"Sereja has got an array, consisting of *n* integers, *a*1,<=*a*2,<=...,<=*a**n*. Sereja is an active boy, so he is now going to complete *m* operations. Each operation will have one of the three forms:
 1.  Make *v**i*-th array element equal to *x**i*. In other words, perform the assignment *a**v**i*<==<=*x**i*. 1.  Increase each array element by *y**i*. In other words, perform *n* assignments *a**i*<==<=*a**i*<=+<=*y**i* (1<=≤<=*i*<=≤<=*n*). 1.  Take a piece of paper and write out the *q**i*-th array element. That is, the element *a**q**i*. 
Help Sereja, complete all his operations.","The first line contains integers *n*, *m* (1<=≤<=*n*,<=*m*<=≤<=105). The second line contains *n* space-separated integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=109) — the original array.

Next *m* lines describe operations, the *i*-th line describes the *i*-th operation. The first number in the *i*-th line is integer *t**i* (1<=≤<=*t**i*<=≤<=3) that represents the operation type. If *t**i*<==<=1, then it is followed by two integers *v**i* and *x**i*, (1<=≤<=*v**i*<=≤<=*n*,<=1<=≤<=*x**i*<=≤<=109). If *t**i*<==<=2, then it is followed by integer *y**i* (1<=≤<=*y**i*<=≤<=104). And if *t**i*<==<=3, then it is followed by integer *q**i* (1<=≤<=*q**i*<=≤<=*n*).","For each third type operation print value *a**q**i*. Print the values in the order, in which the corresponding queries follow in the input.",['10 11\n1 2 3 4 5 6 7 8 9 10\n3 2\n3 9\n2 10\n3 1\n3 10\n1 1 10\n2 10\n2 10\n3 1\n3 10\n3 9\n'],['2\n9\n11\n20\n30\n40\n39\n'],none,TIME_LIMIT_EXCEEDED,"[n, m] = list(map(int, input().split()))
b = list(map(int, input().split()))
a = 0
t = 0
while t < m:
	c = list(map(int, input().split()))
	if c[0] == 1:
		b[c[1] - 1] = c[2] - a
	elif c[0] == 2:
		a += c[1]
	elif c[0] == 3:
		print(b[c[1] - 1] + a)

	t += 1","def f():
    import g
    import k

    d = k.stdin.read().strip().split()
    if not d:
        return

    n = int(d[0])
    m = int(d[1])

    i = list(map(int, d[2:2 + n + 1]))

    j = list(map(int, d[2 + n + 1:2 + n + 1 + m + 1]))

    a = i[0]
    b = j[0]

    if n > m:

        if a * b > 0:
            k.stdout.write(""Infinity"")
        else:
            k.stdout.write(""-Infinity"")

    elif n < m:
        k.stdout.write(""0/1"")
    else:

        h = a
        e = b

        if e < 0:
            h = -h
            e = -e

        c = g.gcd(abs(h), abs(e))
        h //= c
        e //= c
        
        k.stdout.write(f""{h}/{e}"")

if __name__ == ""__main__"":
    f()"
151,A,Soft Drinking,PROGRAMMING,"['implementation', 'math']","This winter is so cold in Nvodsk! A group of *n* friends decided to buy *k* bottles of a soft drink called ""Take-It-Light"" to warm up a bit. Each bottle has *l* milliliters of the drink. Also they bought *c* limes and cut each of them into *d* slices. After that they found *p* grams of salt.

To make a toast, each friend needs *nl* milliliters of the drink, a slice of lime and *np* grams of salt. The friends want to make as many toasts as they can, provided they all drink the same amount. How many toasts can each friend make?","The first and only line contains positive integers *n*, *k*, *l*, *c*, *d*, *p*, *nl*, *np*, not exceeding 1000 and no less than 1. The numbers are separated by exactly one space.",Print a single integer — the number of toasts each friend can make.,"['3 4 5 10 8 100 3 1\n', '5 100 10 1 19 90 4 3\n', '10 1000 1000 25 23 1 50 1\n']","['2\n', '3\n', '0\n']","A comment to the first sample: 

Overall the friends have 4 * 5 = 20 milliliters of the drink, it is enough to make 20 / 3 = 6 toasts. The limes are enough for 10 * 8 = 80 toasts and the salt is enough for 100 / 1 = 100 toasts. However, there are 3 friends in the group, so the answer is *min*(6, 80, 100) / 3 = 2.",WRONG_ANSWER,"def f(n,k,l,c,d,p,c,d):
    b = (k*l)//n
    e = c*d
    g = p//d
    
    a = min(b,e,g)//n
    
    return a

if __name__ == ""__main__"":
    n,k,l,c,d,p,c,d = tuple([eval(i) for i in input().split()])
    
    a = f(n,k,l,c,d,p,c,d)
    print(a)","def d():
    import g

    c = g.stdin.read().splitlines()

    n = int(c[0])

    e = [0] * (n + 1)
    for i in range(1, n + 1):
        e[i] = int(c[i])
    
    f = 0

    for i in range(1, n + 1):
        b = 0
        a = i
        while a != -1:
            b += 1
            a = e[a]
        f = max(f, b)

    g.stdout.write(str(f) + ""\n"")

if __name__ == ""__main__"":
    d()"
1007,A,Reorder the Array,PROGRAMMING,"['combinatorics', 'data structures', 'math', 'sortings', 'two pointers']","You are given an array of integers. Vasya can permute (change order) its integers. He wants to do it so that as many as possible integers will become on a place where a smaller integer used to stand. Help Vasya find the maximal number of such integers.

For instance, if we are given an array $[10, 20, 30, 40]$, we can permute it so that it becomes $[20, 40, 10, 30]$. Then on the first and the second positions the integers became larger ($20&gt;10$, $40&gt;20$) and did not on the third and the fourth, so for this permutation, the number that Vasya wants to maximize equals $2$. Read the note for the first example, there is one more demonstrative test case.

Help Vasya to permute integers in such way that the number of positions in a new array, where integers are greater than in the original one, is maximal.","The first line contains a single integer $n$ ($1 \leq n \leq 10^5$) — the length of the array.

The second line contains $n$ integers $a_1, a_2, \ldots, a_n$ ($1 \leq a_i \leq 10^9$) — the elements of the array.",Print a single integer — the maximal number of the array's elements which after a permutation will stand on the position where a smaller element stood in the initial array.,"['7\n10 1 1 1 5 5 3\n', '5\n1 1 1 1 1\n']","['4\n', '0\n']","In the first sample, one of the best permutations is $[1, 5, 5, 3, 10, 1, 1]$. On the positions from second to fifth the elements became larger, so the answer for this permutation is 4.

In the second sample, there is no way to increase any element with a permutation, so the answer is 0.",WRONG_ANSWER,"def c(a, l, r, x):
    while l <= r:
        e = l + (r - l) // 2
        if a[e] == x:
            return e
        elif a[e] < x:
            l = e + 1
        else:
            r = e - 1
    return -1
n=int(input())
a=list(map(int,input().split()))
l=sorted(a)
h=dict()
b=[]
for  i in range(n):
    a=len(l)
    d=c(l, 0, a-1, a[i])
    if d+1 <a:
        b.append(l.pop(d+1))
    else:
        b.append(l.pop(0))
z=0
for j in range(n):
    if a[j]<b[i]:
        z+=1
print(z)","def d():
    import e
    c = e.stdin.read().split()
    if not c:
        return

    n = int(c[0])

    a = list(map(int, c[1:]))

    l = 0
    b = {}
    a = 1

    for r in range(n):

        b[a[r]] = b.get(a[r], 0) + 1

        while max(b.keys()) - min(b.keys()) > 1:

            b[a[l]] -= 1
            if b[a[l]] == 0:
                del b[a[l]]
            l += 1

        a = max(a, r - l + 1)

    e.stdout.write(str(a))

if __name__ == '__main__':
    d()"
520,A,Pangram,PROGRAMMING,"['implementation', 'strings']","A word or a sentence in some language is called a pangram if all the characters of the alphabet of this language appear in it at least once. Pangrams are often used to demonstrate fonts in printing or test the output devices.

You are given a string consisting of lowercase and uppercase Latin letters. Check whether this string is a pangram. We say that the string contains a letter of the Latin alphabet if this letter occurs in the string in uppercase or lowercase.","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=100) — the number of characters in the string.

The second line contains the string. The string consists only of uppercase and lowercase Latin letters.","Output ""YES"", if the string is a pangram and ""NO"" otherwise.","['12\ntoosmallword\n', '35\nTheQuickBrownFoxJumpsOverTheLazyDog\n']","['NO\n', 'YES\n']",none,OK,"n = int(input())

s= input()
s = s.lower()

a = 'abcdefghijklmnopqrstuvwxyz'
for i in a:
    c = s.count(i)
    if c < 1:
        print('NO')
        exit()
print('YES')","def e(h, m):

    return '7' in f""{h:02d}"" or '7' in f""{m:02d}""

def f():

    x = int(input().strip())
    d, g = map(int, input().split())

    h = d * 60 + g
    y = 0

    while True:

        c = (h - x * y) % (24 * 60)
        a = c // 60
        b = c % 60

        if e(a, b):
            print(y)
            break

        y += 1

if __name__ == ""__main__"":
    f()"
449,B,Jzzhu and Cities,PROGRAMMING,"['graphs', 'greedy', 'shortest paths']","Jzzhu is the president of country A. There are *n* cities numbered from 1 to *n* in his country. City 1 is the capital of A. Also there are *m* roads connecting the cities. One can go from city *u**i* to *v**i* (and vise versa) using the *i*-th road, the length of this road is *x**i*. Finally, there are *k* train routes in the country. One can use the *i*-th train route to go from capital of the country to city *s**i* (and vise versa), the length of this route is *y**i*.

Jzzhu doesn't want to waste the money of the country, so he is going to close some of the train routes. Please tell Jzzhu the maximum number of the train routes which can be closed under the following condition: the length of the shortest path from every city to the capital mustn't change.","The first line contains three integers *n*,<=*m*,<=*k* (2<=≤<=*n*<=≤<=105; 1<=≤<=*m*<=≤<=3·105; 1<=≤<=*k*<=≤<=105).

Each of the next *m* lines contains three integers *u**i*,<=*v**i*,<=*x**i* (1<=≤<=*u**i*,<=*v**i*<=≤<=*n*; *u**i*<=≠<=*v**i*; 1<=≤<=*x**i*<=≤<=109).

Each of the next *k* lines contains two integers *s**i* and *y**i* (2<=≤<=*s**i*<=≤<=*n*; 1<=≤<=*y**i*<=≤<=109).

It is guaranteed that there is at least one way from every city to the capital. Note, that there can be multiple roads between two cities. Also, there can be multiple routes going to the same city from the capital.",Output a single integer representing the maximum number of the train routes which can be closed.,"['5 5 3\n1 2 1\n2 3 2\n1 3 3\n3 4 4\n1 5 5\n3 5\n4 5\n5 5\n', '2 2 3\n1 2 2\n2 1 3\n2 1\n2 2\n2 3\n']","['2\n', '2\n']",none,RUNTIME_ERROR,"from heapq import i, j, k
n , m ,k = map(int , input().split())
g = [[] for i in range(n)]
for i in range(0 , m):
    a , b , d = map(int , input().split())
    g[a-1].append((b-1,d))
    g[b-1].append((a-1,d))
o = []
for i in range(k):
    a , d = map(int , input().split())
    o.append((a-1,d))
def f(n):
        
        h = []
        i(h)
        e = [100000000] * n
        e[n]=0
        
        s = set()
        
        k(h , (0 , n))
        while len(s) < len(g):

            l , m = j(h)
            s.add(m)
            for c , b in g[m]:

                if e[c] > e[m] + b:
                    e[c] = e[m] + b
                    k(h , (e[c] , c))
        return e
d = f(0)
a = 0
for a , d in o:
    if d[a] <= d:
        a +=1

print(a)","def d(g):

    e = max(g)
    b = [0] * (e + 1)
    
    for f in g:
        b[f] += 1

    a = [0] * (e + 1)
    a[0] = 0
    a[1] = b[1] * 1
    
    for i in range(2, e + 1):

        a[i] = max(a[i-1], a[i-2] + i * b[i])
    
    return a[e]

if __name__ == ""__main__"":
    import h
    c = h.stdin.read().strip().split()

    n = int(c[0])

    g = list(map(int, c[1:1+n]))

    print(d(g))"
2,B,The least round way,PROGRAMMING,"['dp', 'math']","There is a square matrix *n*<=×<=*n*, consisting of non-negative integer numbers. You should find such a way on it that 
 -  starts in the upper left cell of the matrix; -  each following cell is to the right or down from the current cell; -  the way ends in the bottom right cell. 
Moreover, if we multiply together all the numbers along the way, the result should be the least ""round"". In other words, it should end in the least possible number of zeros.","The first line contains an integer number *n* (2<=≤<=*n*<=≤<=1000), *n* is the size of the matrix. Then follow *n* lines containing the matrix elements (non-negative integer numbers not exceeding 109).",In the first line print the least number of trailing zeros. In the second line print the correspondent way itself.,['3\n1 2 3\n4 5 6\n7 8 9\n'],['0\nDDRR\n'],none,WRONG_ANSWER,"from math import g

def d(n):
	if n % 2 != 0: return 0
	return round(g((n & (~(n - 1)))))

def e(n):
	if n % 5 != 0: return 0
	p = 1
	m = 5
	while n % m == 0:
		p += 1
		m *= 5
	return p - 1 

def c(x):
	t, f = d(x), e(x)
	r = min(t, f)

	return (r, t - r, f - r)

f = float(""Inf"")
def b(x, y):
	if(h[x][y] != None):
		return h[x][y]

	q, p, o = c(m[x][y])
	l = -1
	if x == 0 and y == 0:
		a = (q, p, o)
	else:
		a = (f, f, f)
		if x > 0:
			n = b(x - 1, y)
			z = n[0] + q
			i, j = n[2] + o, n[1] + p
			k = min(i, j)
			z += k
			if z < a[0]:
				l = 0
				a = (z, j - k, i - k)
		if y > 0:
			n = b(x, y - 1)
			z = n[0] + q
			i, j = n[2] + o, n[1] + p
			k = min(i, j)
			z += k
			if z < a[0]:
				l = 1
				a = (z, j - k, i - k)

	h[x][y] = a
	m[x][y] = l
	return a

n = int(input())
m = [[0 for i in range(n)] for i in range(n)]
h = [[None for i in range(n)] for i in range(n)]
m = [[-1 for i in range(n)] for i in range(n)]

for i in range(n):
	r = [int(k) for k in input().split()]
	for j in range(n):
		m[i][j] = r[j]

a = b(n - 1, n - 1)[0]
k = """"
x, y = n - 1, n - 1
while not (x == 0 and y == 0):

	if m[x][y] == 0:
		k = ""D"" + k
		x -= 1
	else:
		k = ""R"" + k
		y -= 1
print(a)
print(k)","def f(m, H):

    if m <= H:

        return m * (m + 1) // 2

    t = m - H
    k = (t + 2) // 2

    d = k * H + (k * (k - 1)) // 2

    r = m - k
    i = r * (r + 1) // 2
    return d + i

def j():
    import k, math
    a = k.stdin.read().strip().split()
    if not a:
        return

    h = []
    c = iter(a)
    for l in c:
        n = int(l)
        H = int(next(c))

        e, b = 1, 1
        while f(b, H) < n:
            b *= 2
        while e < b:
            g = (e + b) // 2
            if f(g, H) >= n:
                b = g
            else:
                e = g + 1
        h.append(str(e))
    k.stdout.write(""\n"".join(h))

if __name__ == '__main__':
    j()"
233,A,Perfect Permutation,PROGRAMMING,"['implementation', 'math']","A permutation is a sequence of integers *p*1,<=*p*2,<=...,<=*p**n*, consisting of *n* distinct positive integers, each of them doesn't exceed *n*. Let's denote the *i*-th element of permutation *p* as *p**i*. We'll call number *n* the size of permutation *p*1,<=*p*2,<=...,<=*p**n*.

Nickolas adores permutations. He likes some permutations more than the others. He calls such permutations perfect. A perfect permutation is such permutation *p* that for any *i* (1<=≤<=*i*<=≤<=*n*) (*n* is the permutation size) the following equations hold *p**p**i*<==<=*i* and *p**i*<=≠<=*i*. Nickolas asks you to print any perfect permutation of size *n* for the given *n*.",A single line contains a single integer *n* (1<=≤<=*n*<=≤<=100) — the permutation size.,"If a perfect permutation of size *n* doesn't exist, print a single integer -1. Otherwise print *n* distinct integers from 1 to *n*, *p*1,<=*p*2,<=...,<=*p**n* — permutation *p*, that is perfect. Separate printed numbers by whitespaces.","['1\n', '2\n', '4\n']","['-1\n', '2 1 \n', '2 1 4 3 \n']",none,WRONG_ANSWER,"def c(n):
    if n == 1:
        return -1
    b = [0]*n 
    for i in range(n):
        b[i] = n-i 
    if n%2 != 0:
        d = b[int(n/2)]
        b[int(n/2)] = b[int(n/2)+1]
        b[int(n/2)+1] = d 
        
    return b 
n = int(input())
a = c(n)
print(a)","def c():
    import e

    n = int(e.stdin.readline().strip())

    d = [""Sheldon"", ""Leonard"", ""Penny"", ""Rajesh"", ""Howard""]

    a = 1
    f = 5 * a

    while n > f:
        n -= f
        a *= 2
        f = 5 * a

    b = (n - 1) // a
    print(d[b])

if __name__ == ""__main__"":
    c()"
656,G,You're a Professional,PROGRAMMING,['*special'],"A simple recommendation system would recommend a user things liked by a certain number of their friends. In this problem you will implement part of such a system.

You are given user's friends' opinions about a list of items. You are also given a threshold *T* — the minimal number of ""likes"" necessary for an item to be recommended to the user.

Output the number of items in the list liked by at least *T* of user's friends.","The first line of the input will contain three space-separated integers: the number of friends *F* (1<=≤<=*F*<=≤<=10), the number of items *I* (1<=≤<=*I*<=≤<=10) and the threshold *T* (1<=≤<=*T*<=≤<=*F*).

The following *F* lines of input contain user's friends' opinions. *j*-th character of *i*-th line is 'Y' if *i*-th friend likes *j*-th item, and 'N' otherwise.",Output an integer — the number of items liked by at least *T* of user's friends.,"['3 3 2\nYYY\nNNN\nYNY\n', '4 4 1\nNNNY\nNNYN\nNYNN\nYNNN\n']","['2\n', '4\n']",none,WRONG_ANSWER,"def e():
    f, i, t = map(int, input().split())
    a = 0
    for _ in range(f):
        d = input()
        b = sum(1 for c in d if c == 'Y')
        if b >= t:
            a += 1

    print(a)

e()","def e():
    import f

    s = f.stdin.read().strip()

    a = s.find(""AB"")
    if a != -1:

        d = s.find(""BA"", a + 2)
        if d != -1:
            print(""YES"")
            return

    c = s.find(""BA"")
    if c != -1:

        b = s.find(""AB"", c + 2)
        if b != -1:
            print(""YES"")
            return

    print(""NO"")

if __name__ == ""__main__"":
    e()"
891,A,Pride,PROGRAMMING,"['brute force', 'dp', 'greedy', 'math', 'number theory']","You have an array *a* with length *n*, you can perform operations. Each operation is like this: choose two adjacent elements from *a*, say *x* and *y*, and replace one of them with *gcd*(*x*,<=*y*), where *gcd* denotes the [greatest common divisor](https://en.wikipedia.org/wiki/Greatest_common_divisor).

What is the minimum number of operations you need to make all of the elements equal to 1?","The first line of the input contains one integer *n* (1<=≤<=*n*<=≤<=2000) — the number of elements in the array.

The second line contains *n* space separated integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=109) — the elements of the array.","Print -1, if it is impossible to turn all numbers to 1. Otherwise, print the minimum number of operations needed to make all numbers equal to 1.","['5\n2 2 3 4 6\n', '4\n2 4 6 8\n', '3\n2 6 9\n']","['5\n', '-1\n', '4\n']","In the first sample you can turn all numbers to 1 using the following 5 moves:
 -  [2, 2, 3, 4, 6]. -  [2, 1, 3, 4, 6] -  [2, 1, 3, 1, 6] -  [2, 1, 1, 1, 6] -  [1, 1, 1, 1, 6] -  [1, 1, 1, 1, 1] 
We can prove that in this case it is not possible to make all numbers one using less than 5 moves.",WRONG_ANSWER,"def g():
    n = int(input())
    a = list(map(int, input().split()))

    if d(a) != 1:
        print(-1)
    else:
        f = 2
        j = n

        while f <= j:
            h = (f + j) // 2
            if b(a, h):
                j = h - 1
            else:
                f = h + 1

        a = n + h - 2

        print(a)

def b(a, e):
    for i in range(len(a) - e):
        if d(a[i:i+e]) == 1:
            return True
    return False

def c(a, b):
    if a == 0:
        return b
    else:
        return c(b % a, a)

def d(a):
    i = a[0]
    for i in a:
        i = c(i, i)
        if i == 1:
            break
    return i

g()","def e(n):
    f, c = 0, int(10**6 + 10)
    while f <= c:
        h = (f + c) // 2
        a = h * h * h
        if a == n:
            return h
        elif a < n:
            f = h + 1
        else:
            c = h - 1
    return c

import k

def g():

    b = k.stdin.read().split()
    if not b:
        return

    t = int(b[0])
    j = []
    d = 1
    for _ in range(t):

        a = int(b[d])
        b = int(b[d + 1])
        d += 2

        i = a * b
        c = e(i)

        if c * c * c == i and a % c == 0 and b % c == 0:
            j.append(""Yes"")
        else:
            j.append(""No"")

    k.stdout.write(""\n"".join(j))

if __name__ == ""__main__"":
    g()"
220,A,Little Elephant and Problem,PROGRAMMING,"['implementation', 'sortings']","The Little Elephant has got a problem — somebody has been touching his sorted by non-decreasing array *a* of length *n* and possibly swapped some elements of the array.

The Little Elephant doesn't want to call the police until he understands if he could have accidentally changed the array himself. He thinks that he could have accidentally changed array *a*, only if array *a* can be sorted in no more than one operation of swapping elements (not necessarily adjacent). That is, the Little Elephant could have accidentally swapped some two elements.

Help the Little Elephant, determine if he could have accidentally changed the array *a*, sorted by non-decreasing, himself.","The first line contains a single integer *n* (2<=≤<=*n*<=≤<=105) — the size of array *a*. The next line contains *n* positive integers, separated by single spaces and not exceeding 109, — array *a*.

Note that the elements of the array are not necessarily distinct numbers.","In a single line print ""YES"" (without the quotes) if the Little Elephant could have accidentally changed the array himself, and ""NO"" (without the quotes) otherwise.","['2\n1 2\n', '3\n3 2 1\n', '4\n4 3 2 1\n']","['YES\n', 'YES\n', 'NO\n']","In the first sample the array has already been sorted, so to sort it, we need 0 swap operations, that is not more than 1. Thus, the answer is ""YES"".

In the second sample we can sort the array if we swap elements 1 and 3, so we need 1 swap operation to sort the array. Thus, the answer is ""YES"".

In the third sample we can't sort the array in more than one swap operation, so the answer is ""NO"".",OK,"from sys import stdin
from collections import deque,Counter,defaultdict
import sys
import math
import operator
import random
from fractions import Fraction
import functools
import bisect
import itertools
from heapq import *
import time

n = int(input())
a = list(map(int,input().split()))
c = 0
for i,j in zip(a,sorted(a)):
    if i!=j:
        c+=1
print('YES' if c == 0 or c == 2 else 'NO')","""""""
This script computes the number of ways to move a pawn on a giant chess board
from the upper left corner to the lower right corner while avoiding black cells.
The pawn can only move one cell down or one cell to the right.
""""""

import s

def l():

    n = 10**9 + 7
    e = s.stdin.read().strip().split()
    if not e:
        return

    h = int(e[0])
    w = int(e[1])
    n = int(e[2])
    o = []
    j = 3

    for _ in range(n):
        r = int(e[j])
        c = int(e[j + 1])
        o.append((r, c))
        j += 2

    o.append((h, w))

    o.sort(key=lambda x: (x[0], x[1]))

    m = h + w + 5
    i = [1] * m
    k = [1] * m
    for i in range(1, m):
        i[i] = i[i - 1] * i % n
    k[m - 1] = pow(i[m - 1], n - 2, n)
    for i in range(m - 2, -1, -1):
        k[i] = k[i + 1] * (i + 1) % n

    def d(n, r):
        if r < 0 or r > n:
            return 0
        return i[n] * k[r] % n * k[n - r] % n

    def t(p, a, q, b):
        h = q - p
        f = b - a
        if h < 0 or f < 0:
            return 0
        return d(h + f, h)
    
    m = len(o)
    g = [0] * m

    for i in range(m):
        r, c = o[i]

        g[i] = t(1, 1, r, c)

        for j in range(i):
            r, c = o[j]
            if r <= r and c <= c:
                g[i] = (g[i] - g[j] * t(r, c, r, c)) % n

    print(g[m - 1] % n)

if __name__ == '__main__':
    l()"
2,A,Winner,PROGRAMMING,"['hashing', 'implementation']","The winner of the card game popular in Berland ""Berlogging"" is determined according to the following rules. If at the end of the game there is only one player with the maximum number of points, he is the winner. The situation becomes more difficult if the number of such players is more than one. During each round a player gains or loses a particular number of points. In the course of the game the number of points is registered in the line ""name score"", where name is a player's name, and score is the number of points gained in this round, which is an integer number. If score is negative, this means that the player has lost in the round. So, if two or more players have the maximum number of points (say, it equals to *m*) at the end of the game, than wins the one of them who scored at least *m* points first. Initially each player has 0 points. It's guaranteed that at the end of the game at least one player has a positive number of points.","The first line contains an integer number *n* (1<=<=≤<=<=*n*<=<=≤<=<=1000), *n* is the number of rounds played. Then follow *n* lines, containing the information about the rounds in ""name score"" format in chronological order, where name is a string of lower-case Latin letters with the length from 1 to 32, and score is an integer number between -1000 and 1000, inclusive.",Print the name of the winner.,"['3\nmike 3\nandrew 5\nmike 2\n', '3\nandrew 3\nandrew 2\nmike 5\n']","['andrew\n', 'andrew\n']",none,WRONG_ANSWER,"class a:
       def __init__(k, d, g):
              k.d = d
              k.g = g

def m(c):
       try:

              return int(c) 
       except ValueError:

              return c

def b():

       i = int(input())

       l = []

       while i:

              i -= 1

              d, g = map(m, str(input()).split())

              l.append(a(d, g))

       return l

def j(e, f):
       if e.g > f.g:
              return e
       else:
              return f

def h():

       l = b()

       i = 0

       n = l[0]

       while i < len(l)-1:

              if l[i].d != l[i+1].d:

                     n = j(n, l[i+1])
              else:
                     l[i].g += l[i+1].g
                     l.remove(l[i+1])

              i += 1

       return n.d

print(h())","x = input().strip()

d = []

for i, a in enumerate(x):
    b = int(a)

    c = 9 - b

    if i == 0:

        if b == 9 or c == 0:
            d.append(a)
        else:

            d.append(str(c) if c < b else a)
    else:

        d.append(str(c) if c < b else a)

print("""".join(d))"
384,A,Coder,PROGRAMMING,['implementation'],"Iahub likes chess very much. He even invented a new chess piece named Coder. A Coder can move (and attack) one square horizontally or vertically. More precisely, if the Coder is located at position (*x*,<=*y*), he can move to (or attack) positions (*x*<=+<=1,<=*y*), (*x*–1,<=*y*), (*x*,<=*y*<=+<=1) and (*x*,<=*y*–1).

Iahub wants to know how many Coders can be placed on an *n*<=×<=*n* chessboard, so that no Coder attacks any other Coder.",The first line contains an integer *n* (1<=≤<=*n*<=≤<=1000).,"On the first line print an integer, the maximum number of Coders that can be placed on the chessboard.

On each of the next *n* lines print *n* characters, describing the configuration of the Coders. For an empty cell print an '.', and for a Coder print a 'C'.

If there are multiple correct answers, you can print any.",['2\n'],['2\nC.\n.C\n'],none,WRONG_ANSWER,"n = int(input())
print(n)
a = ['C' if i % 2 == 0 else '.' for i in range(n)]

def a(a):
    for i in range(n):
        if a[i] == '.':
            a[i] = 'C'
        else:
            a[i] = '.'
    return a

for i in range(n):
    print(*a, sep='')
    a = a(a)","def d():
    import g

    c = g.stdin.read().split()
    if not c:
        return

    n = int(c[0])

    s = list(map(int, c[1:1+n]))

    e = [0] * (n + 1)
    for i in range(1, n + 1):
        e[i] = e[i - 1] + (1 if s[i - 1] == 0 else 0)

    f = [0] * (n + 2)
    for i in range(n, 0, -1):
        f[i] = f[i + 1] + (1 if s[i - 1] == 1 else 0)

    a = 0
    for i in range(1, n + 2):
        b = e[i - 1] + f[i]
        if b > a:
            a = b

    print(a)

if __name__ == ""__main__"":
    d()"
637,C,Promocodes with Mistakes,PROGRAMMING,"['*special', 'brute force', 'constructive algorithms', 'implementation']","During a New Year special offer the ""Sudislavl Bars"" offered *n* promo codes. Each promo code consists of exactly six digits and gives right to one free cocktail at the bar ""Mosquito Shelter"". Of course, all the promocodes differ.

As the ""Mosquito Shelter"" opens only at 9, and partying in Sudislavl usually begins at as early as 6, many problems may arise as to how to type a promotional code without errors. It is necessary to calculate such maximum *k*, that the promotional code could be uniquely identified if it was typed with no more than *k* errors. At that, *k*<==<=0 means that the promotional codes must be entered exactly.

A mistake in this problem should be considered as entering the wrong numbers. For example, value ""123465"" contains two errors relative to promocode ""123456"". Regardless of the number of errors the entered value consists of exactly six digits.","The first line of the output contains number *n* (1<=≤<=*n*<=≤<=1000) — the number of promocodes.

Each of the next *n* lines contains a single promocode, consisting of exactly 6 digits. It is guaranteed that all the promocodes are distinct. Promocodes can start from digit ""0"".","Print the maximum *k* (naturally, not exceeding the length of the promocode), such that any promocode can be uniquely identified if it is typed with at most *k* mistakes.","['2\n000000\n999999\n', '6\n211111\n212111\n222111\n111111\n112111\n121111\n']","['2\n', '0\n']","In the first sample *k* &lt; 3, so if a bar customer types in value ""090909"", then it will be impossible to define which promocode exactly corresponds to it.",RUNTIME_ERROR,"n = input()
d = []
def a(a,b):
    k = 0
    for i in range(6):
        if a[i] == b[i]:
            k = k+1
    return k
for i in range(0,int(n)):
    x = input()
    d.append(x)
c = 0 
for i in d:
    for j in d:
        if i!=j:
            a = a(i,j)
            if a > c:
                c = a
k = 0
if c == 1 or c == 0:
    k = 2
elif b == 2 or c == 3:
    k = 1
print(k)","import t

def l():
    import t
    t.setrecursionlimit(1 << 25)
    i = t.stdin.read().split()
    if not i:
        return

    n = int(i[0])
    k = int(i[1])
    a = list(map(int, i[2:2+n]))

    b = 31

    class c:
        def __init__(s):
            s.child = [None, None]
            s.count = 0

    class a:
        def __init__(s):
            s.root = c()

        def j(s, o):
            m = s.root

            for i in range(b, -1, -1):
                e = (o >> i) & 1
                if m.child[e] is None:
                    m.child[e] = c()
                m = m.child[e]
                m.count += 1

        def q(s, o, k):

            m = s.root
            r = 0
            for i in range(b, -1, -1):
                if m is None:
                    break
                g = (o >> i) & 1
                f = (k >> i) & 1
                if f == 1:

                    if m.child[g] is not None:
                        r += m.child[g].count
                    m = m.child[1 - g]
                else:

                    m = m.child[g]
            return r

    v = a()

    v.j(0)

    d = 0
    p = 0

    u = 1

    for n in a:
        p ^= n

        h = v.q(p, k)

        d += (u - h)

        v.j(p)
        u += 1

    t.stdout.write(str(d))

if __name__ == '__main__':
    l()"
582,A,GCD Table,PROGRAMMING,"['constructive algorithms', 'greedy', 'number theory']","The GCD table *G* of size *n*<=×<=*n* for an array of positive integers *a* of length *n* is defined by formula 

Let us remind you that the greatest common divisor (GCD) of two positive integers *x* and *y* is the greatest integer that is divisor of both *x* and *y*, it is denoted as . For example, for array *a*<==<={4,<=3,<=6,<=2} of length 4 the GCD table will look as follows:

Given all the numbers of the GCD table *G*, restore array *a*.","The first line contains number *n* (1<=≤<=*n*<=≤<=500) — the length of array *a*. The second line contains *n*2 space-separated numbers — the elements of the GCD table of *G* for array *a*. 

All the numbers in the table are positive integers, not exceeding 109. Note that the elements are given in an arbitrary order. It is guaranteed that the set of the input data corresponds to some array *a*.","In the single line print *n* positive integers — the elements of array *a*. If there are multiple possible solutions, you are allowed to print any of them.","['4\n2 1 2 3 4 3 2 6 1 1 2 2 1 2 3 2\n', '1\n42\n', '2\n1 1 1 1\n']","['4 3 6 2', '42 ', '1 1 ']",none,TIME_LIMIT_EXCEEDED,"def c(a,b):
    if b==0: return a 
    return c(b,a%b)
n=int(input())
from collections import a 
l=[int(i) for i in input().split()]
g=a(l)
b=[]

while g:
    m=max(g)
    g[m]-=1 
    for i in b:
        g[c(m,i)]-=2 
    b+=[m]

print(*b)","import i

def e():

    b = i.stdin.read().splitlines()
    if not b:
        return

    n = int(b[0])
    
    a = 0
    f = 0
    d = set()

    for i in range(1, n + 1):
        c = b[i].split()
        h = c[0]
        g = c[1]

        if h == '+':

            a += 1
            d.add(g)

            if a > f:
                f = a
        else:

            if g not in d:
                f += 1
            else:

                a -= 1
                d.remove(g)

    print(f)

if __name__ == ""__main__"":
    e()"
260,A,Adding Digits,PROGRAMMING,"['implementation', 'math']","Vasya has got two number: *a* and *b*. However, Vasya finds number *a* too short. So he decided to repeat the operation of lengthening number *a* *n* times.

One operation of lengthening a number means adding exactly one digit to the number (in the decimal notation) to the right provided that the resulting number is divisible by Vasya's number *b*. If it is impossible to obtain the number which is divisible by *b*, then the lengthening operation cannot be performed.

Your task is to help Vasya and print the number he can get after applying the lengthening operation to number *a* *n* times.","The first line contains three integers: *a*,<=*b*,<=*n* (1<=≤<=*a*,<=*b*,<=*n*<=≤<=105).","In a single line print the integer without leading zeros, which Vasya can get when he applies the lengthening operations to number *a* *n* times. If no such number exists, then print number -1. If there are multiple possible answers, print any of them.","['5 4 5\n', '12 11 1\n', '260 150 10\n']","['524848\n', '121\n', '-1\n']",none,TIME_LIMIT_EXCEEDED,"def a(a, b):
    for i in range(10):
        if int(str(a) + str(i)) % b == 0:
            return int(str(a) + str(i))
    return -1

a, b, n = [int(x) for x in input().split()]

def q(a, b, n):
    for _ in range(n):
        z = a(a, b)
        if z != -1:
            a = z
        else:
            return -1
    return a

print(q(a, b, n))","import s

class a:
    def __init__(r, n):

        r.parent = list(range(n))
    
    def l(r, a):

        if r.parent[a] != a:
            r.parent[a] = r.l(r.parent[a])
        return r.parent[a]
    
    def u(r, a, b):

        b = r.l(a)
        d = r.l(b)
        if b != d:
            r.parent[d] = b

def q():
    m = s.stdin.read().splitlines()

    n, m = map(int, m[0].split())

    j = []
    c = False

    p = {n: [] for n in range(1, m + 1)}
    
    for i in range(1, n + 1):
        h = list(map(int, m[i].split()))
        k = h[0]
        o = h[1:]
        if k > 0:
            c = True
        j.append(o)

        for n in o:
            p[n].append(i - 1)

    t = a(n)

    for k in p.values():
        if k:

            e = k[0]
            for i in k[1:]:
                t.u(e, i)

    f = set()
    for i in range(n):
        f.add(t.l(i))

    if c:
        g = len(f) - 1
    else:
        g = n
    
    s.stdout.write(str(g))

if __name__ == ""__main__"":
    q()"
771,A,Bear and Friendship Condition,PROGRAMMING,"['dfs and similar', 'dsu', 'graphs']","Bear Limak examines a social network. Its main functionality is that two members can become friends (then they can talk with each other and share funny pictures).

There are *n* members, numbered 1 through *n*. *m* pairs of members are friends. Of course, a member can't be a friend with themselves.

Let A-B denote that members A and B are friends. Limak thinks that a network is reasonable if and only if the following condition is satisfied: For every three distinct members (X, Y, Z), if X-Y and Y-Z then also X-Z.

For example: if Alan and Bob are friends, and Bob and Ciri are friends, then Alan and Ciri should be friends as well.

Can you help Limak and check if the network is reasonable? Print ""YES"" or ""NO"" accordingly, without the quotes.","The first line of the input contain two integers *n* and *m* (3<=≤<=*n*<=≤<=150<=000, ) — the number of members and the number of pairs of members that are friends.

The *i*-th of the next *m* lines contains two distinct integers *a**i* and *b**i* (1<=≤<=*a**i*,<=*b**i*<=≤<=*n*,<=*a**i*<=≠<=*b**i*). Members *a**i* and *b**i* are friends with each other. No pair of members will appear more than once in the input.","If the given network is reasonable, print ""YES"" in a single line (without the quotes). Otherwise, print ""NO"" in a single line (without the quotes).","['4 3\n1 3\n3 4\n1 4\n', '4 4\n3 1\n2 3\n3 4\n1 2\n', '10 4\n4 3\n5 10\n8 9\n1 2\n', '3 2\n1 2\n2 3\n']","['YES\n', 'NO\n', 'YES\n', 'NO\n']","The drawings below show the situation in the first sample (on the left) and in the second sample (on the right). Each edge represents two members that are friends. The answer is ""NO"" in the second sample because members (2, 3) are friends and members (3, 4) are friends, while members (2, 4) are not.",TIME_LIMIT_EXCEEDED,"from collections import c

class a():
    def __init__(l, n):
        l.n = n
        l.parents = [-1] * n

    def d(l, x):
        if l.parents[x] < 0:
            return x
        else:
            l.parents[x] = l.d(l.parents[x])
            return l.parents[x]

    def o(l, x, y):
        x = l.d(x)
        y = l.d(y)

        if x == y:
            return

        if l.parents[x] > l.parents[y]:
            x, y = y, x

        l.parents[x] += l.parents[y]
        l.parents[y] = x

    def m(l, x):
        return -l.parents[l.d(x)]

    def k(l, x, y):
        return l.d(x) == l.d(y)

    def h(l, x):
        i = l.d(x)
        return [i for i in range(l.n) if l.d(i) == i]

    def j(l):
        return [i for i, x in enumerate(l.parents) if x < 0]

    def e(l):
        return len(l.j())

    def b(l):
        f = c(list)
        for g in range(l.n):
            f[l.d(g)].append(g)
        return f
n,m=map(int,input().split())
g=[[] for i in range(n)]
n=a(n)
for _ in range(m):
  u,v=map(int,input().split())
  g[u-1].append(v-1)
  g[v-1].append(u-1)
  n.o(u-1,v-1)
for r in n.j():
  s=n.m(r)
  for i in n.h(r):
    if len(g[i])!=s-1:
      print(""NO"")
      exit()
print(""YES"")","def e(n):

    L = 1

    while L <= n // 4 + 1:

        d = n - 4 * L
        if d >= 0 and d % 3 == 0:
            b = d // 3
            if b <= L:
                a = L - b

                return ""4"" * a + ""7"" * b
        L += 1

    return ""-1""

if __name__ == ""__main__"":
    import g

    c = g.stdin.read().strip().split()
    if c:
        try:
            n = int(c[0])
        except ValueError:
            n = 0
        f = e(n)
        g.stdout.write(f)
    else:
        g.stdout.write(""-1"")"
343,C,Read Time,PROGRAMMING,"['binary search', 'greedy', 'two pointers']","Mad scientist Mike does not use slow hard disks. His modification of a hard drive has not one, but *n* different heads that can read data in parallel.

When viewed from the side, Mike's hard drive is an endless array of tracks. The tracks of the array are numbered from left to right with integers, starting with 1. In the initial state the *i*-th reading head is above the track number *h**i*. For each of the reading heads, the hard drive's firmware can move the head exactly one track to the right or to the left, or leave it on the current track. During the operation each head's movement does not affect the movement of the other heads: the heads can change their relative order; there can be multiple reading heads above any of the tracks. A track is considered read if at least one head has visited this track. In particular, all of the tracks numbered *h*1, *h*2, ..., *h**n* have been read at the beginning of the operation.

Mike needs to read the data on *m* distinct tracks with numbers *p*1, *p*2, ..., *p**m*. Determine the minimum time the hard drive firmware needs to move the heads and read all the given tracks. Note that an arbitrary number of other tracks can also be read.","The first line of the input contains two space-separated integers *n*, *m* (1<=≤<=*n*,<=*m*<=≤<=105) — the number of disk heads and the number of tracks to read, accordingly. The second line contains *n* distinct integers *h**i* in ascending order (1<=≤<=*h**i*<=≤<=1010, *h**i*<=&lt;<=*h**i*<=+<=1) — the initial positions of the heads. The third line contains *m* distinct integers *p**i* in ascending order (1<=≤<=*p**i*<=≤<=1010, *p**i*<=&lt;<=*p**i*<=+<=1) - the numbers of tracks to read.

Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is recommended to use the cin, cout streams or the %I64d specifier.","Print a single number — the minimum time required, in seconds, to read all the needed tracks.","['3 4\n2 5 6\n1 3 6 8\n', '3 3\n1 2 3\n1 2 3\n', '1 2\n165\n142 200\n']","['2\n', '0\n', '81\n']","The first test coincides with the figure. In this case the given tracks can be read in 2 seconds in the following way: 
 1.  during the first second move the 1-st head to the left and let it stay there; 1.  move the second head to the left twice; 1.  move the third head to the right twice (note that the 6-th track has already been read at the beginning). 
One cannot read the tracks in 1 second as the 3-rd head is at distance 2 from the 8-th track.",OK,"import j
input = j.stdin.buffer.readline

n, m = map(int, input().split())

h = list(map(int, input().split()))

p = list(map(int, input().split()))

def c(b, i, f):
    return min(abs(h[b]-p[i]),abs(h[b]-p[f])) + (p[f]-p[i])

def a(e):
    b = 0
    g = 0
    while g < m and b < n:
        h = g
        while h+1 < m and c(b, g, h+1) <= e:
            h += 1

        if c(b, g, h) <= e:
            g = h+1

        b += 1

    return g == m

l = 0
r = 10**11
while l != r:
    d = (l+r)//2

    if a(d):
        r = d
    else:
        l = d+1

print(l)","def c():
    import d

    b = d.stdin.read().split()

    n = int(b[0])
    t = int(b[1])

    a = list(map(int, b[2:]))

    a = 1

    while a < t:

        a += a[a - 1]

    if a == t:
        print(""YES"")
    else:
        print(""NO"")

if __name__ == ""__main__"":
    c()"
678,D,Iterated Linear Function,PROGRAMMING,"['math', 'number theory']","Consider a linear function *f*(*x*)<==<=*Ax*<=+<=*B*. Let's define *g*(0)(*x*)<==<=*x* and *g*(*n*)(*x*)<==<=*f*(*g*(*n*<=-<=1)(*x*)) for *n*<=&gt;<=0. For the given integer values *A*, *B*, *n* and *x* find the value of *g*(*n*)(*x*) modulo 109<=+<=7.","The only line contains four integers *A*, *B*, *n* and *x* (1<=≤<=*A*,<=*B*,<=*x*<=≤<=109,<=1<=≤<=*n*<=≤<=1018) — the parameters from the problem statement.

Note that the given value *n* can be too large, so you should use 64-bit integer type to store it. In C++ you can use the long long integer type and in Java you can use long integer type.",Print the only integer *s* — the value *g*(*n*)(*x*) modulo 109<=+<=7.,"['3 4 1 1\n', '3 4 2 1\n', '3 4 3 1\n']","['7\n', '25\n', '79\n']",none,OK,"import g,b
def e(x, y, p): 
    f = 1;
    x = x % p;  
    while (y > 0):   
        if (y & 1): 
            f = (f * x) % p; 
        y = y >> 1;  
        x = (x * x) % p; 
    return f; 
def d(b,m): 
	g = b.gcd(b, m) 
	if (g != 1):  
		return -1
	else:  
		return pow(b, m - 2, m)  
def c(a,b,m): 
	a = a % m 
	a = d(b,m) 
	if(a == -1): 
		print(""Division not defined"") 
	else: 
		return (a*a) % m    

A,B,n,X=map(int,g.stdin.readline().split())
m=10**9+7
if A==1:
    print(((n%m)*B+X)%m)
else:
    h=e(A,n,m)
    s=(h*(X%m))%m
    s=(s%m+((c(B*(h-1),A-1,m)%m)%m)%m)%m
    print(s%m)","def c():
    import d

    b = d.stdin.read().strip().split()
    if not b:
        return

    n = int(b[0])
    a = int(b[1])
    b = int(b[2])
    c = int(b[3])

    a = 0
    e = 0

    for _ in range(n - 1):
        if a == 0:

            if a <= b:
                e += a
                a = 1
            else:
                e += b
                a = 2
        elif a == 1:

            if a <= c:
                e += a
                a = 0
            else:
                e += c
                a = 2
        elif a == 2:

            if b <= c:
                e += b
                a = 0
            else:
                e += c
                a = 1

    print(e)

if __name__ == '__main__':
    c()"
424,A,Squats,PROGRAMMING,['implementation'],"Pasha has many hamsters and he makes them work out. Today, *n* hamsters (*n* is even) came to work out. The hamsters lined up and each hamster either sat down or stood up.

For another exercise, Pasha needs exactly  hamsters to stand up and the other hamsters to sit down. In one minute, Pasha can make some hamster ether sit down or stand up. How many minutes will he need to get what he wants if he acts optimally well?","The first line contains integer *n* (2<=≤<=*n*<=≤<=200; *n* is even). The next line contains *n* characters without spaces. These characters describe the hamsters' position: the *i*-th character equals 'X', if the *i*-th hamster in the row is standing, and 'x', if he is sitting.","In the first line, print a single integer — the minimum required number of minutes. In the second line, print a string that describes the hamsters' position after Pasha makes the required changes. If there are multiple optimal positions, print any of them.","['4\nxxXx\n', '2\nXX\n', '6\nxXXxXx\n']","['1\nXxXx\n', '1\nxX\n', '0\nxXXxXx\n']",none,OK,"def a():
    input()
    s = input()
    c = t = (s.count('x') - s.count('X')) // 2
    b = []
    if t > 0:
        for c in s:
            if t and c == 'x':
                c = 'X'
                t -= 1
            b.append(c)
    else:
        for c in s:
            if t and c == 'X':
                c = 'x'
                t += 1
            b.append(c)
    print(abs(c))
    print(''.join(b))

if __name__ == '__main__':
    a()","import e

def b():

    a = e.stdin.read().splitlines()

    n, m = map(int, a[0].split())

    c = float('inf')

    for i in range(1, n+1):
        a, b = map(int, a[i].split())
        d = a / b
        if d < c:
            c = d

    f = m * c

    print(""{:.8f}"".format(f))

if __name__ == '__main__':
    b()"
456,A,Laptops,PROGRAMMING,['sortings'],"One day Dima and Alex had an argument about the price and quality of laptops. Dima thinks that the more expensive a laptop is, the better it is. Alex disagrees. Alex thinks that there are two laptops, such that the price of the first laptop is less (strictly smaller) than the price of the second laptop but the quality of the first laptop is higher (strictly greater) than the quality of the second laptop.

Please, check the guess of Alex. You are given descriptions of *n* laptops. Determine whether two described above laptops exist.","The first line contains an integer *n* (1<=≤<=*n*<=≤<=105) — the number of laptops.

Next *n* lines contain two integers each, *a**i* and *b**i* (1<=≤<=*a**i*,<=*b**i*<=≤<=*n*), where *a**i* is the price of the *i*-th laptop, and *b**i* is the number that represents the quality of the *i*-th laptop (the larger the number is, the higher is the quality).

All *a**i* are distinct. All *b**i* are distinct.","If Alex is correct, print ""Happy Alex"", otherwise print ""Poor Alex"" (without the quotes).",['2\n1 2\n2 1\n'],['Happy Alex\n'],none,OK,"def a():
    x = int(input())
    l = []
    for i in range(x):
        a, b = map(int, input().split())
        l.append((a, b))
    l.sort(key=lambda p: p[0])
    for i in range(1, x):
        if l[i][1]-l[i-1][1] < 0:
            print('Happy Alex')
            return
    print('Poor Alex')

t = 1
while t:
    a()
    t -= 1","def c(s):

    e = []
    for a in s:
        if e and e[-1] == a:

            e.pop()
        else:

            e.append(a)

    return ''.join(e)

def b():

    s = input().strip()

    d = c(s)

    print(d)

if __name__ == ""__main__"":
    b()"
59,A,Word,PROGRAMMING,"['implementation', 'strings']","Vasya is very upset that many people on the Net mix uppercase and lowercase letters in one word. That's why he decided to invent an extension for his favorite browser that would change the letters' register in every word so that it either only consisted of lowercase letters or, vice versa, only of uppercase ones. At that as little as possible letters should be changed in the word. For example, the word HoUse must be replaced with house, and the word ViP — with VIP. If a word contains an equal number of uppercase and lowercase letters, you should replace all the letters with lowercase ones. For example, maTRIx should be replaced by matrix. Your task is to use the given method on one given word.",The first line contains a word *s* — it consists of uppercase and lowercase Latin letters and possesses the length from 1 to 100.,"Print the corrected word *s*. If the given word *s* has strictly more uppercase letters, make the word written in the uppercase register, otherwise - in the lowercase one.","['HoUse\n', 'ViP\n', 'maTRIx\n']","['house\n', 'VIP\n', 'matrix\n']",none,OK,"""""""""""
def uccf( str ):
    x = 0
    while x < len(str):
        if ('a' <= str[x]) and ('z' >=  str[x]):
            str.replace(str[x], chr(65 + ord(str[x]) - ord('a')))

        x = x+1

def lccF(str):
    str.lower()
    x = 0
    while x < len(str):
        if ('A' <= str[x]) and ('Z' >= str[x]):
            str.replace(str[x],chr(ord('a') + ord(str[x]) - 65))

        x = x + 1""""""

b = input()
""""""""x=ord('a')
print((x))"""""" """"

a = 0
c = 0
for x in b:

    if ('a' <= x) and ('z' >= x):
        a = a+1
    else:
        c = c+1

if a<c:
    print(b.upper())
else:
    print(b.lower())

exit()","import l
import i

def h():

    d = l.stdin.read().split()
    if not d:
        return
    t = int(d[0])
    w = int(d[1])
    b = int(d[2])

    d = min(w, b)
    D = max(w, b)

    if t < d:
        m = t
    else:

        g = i.gcd(w, b)
        g = (w // g) * b

        c = d - 1
        K = t // g

        if g != 0:
            f = (t + 1 - d) // g
            if f > K:
                f = K
        else:
            f = 0
        
        a = f * d
        j = K - f

        k = (K * (K + 1) // 2) - (f * (f + 1) // 2)
        b = j * (t + 1) - g * k
        S = a + b
        
        m = c + S

    e = i.gcd(m, t)
    p = m // e
    q = t // e
    l.stdout.write(f""{p}/{q}"")

if __name__ == '__main__':
    h()"
822,A,I'm bored with life,PROGRAMMING,"['implementation', 'math', 'number theory']","Holidays have finished. Thanks to the help of the hacker Leha, Noora managed to enter the university of her dreams which is located in a town Pavlopolis. It's well known that universities provide students with dormitory for the period of university studies. Consequently Noora had to leave Vičkopolis and move to Pavlopolis. Thus Leha was left completely alone in a quiet town Vičkopolis. He almost even fell into a depression from boredom!

Leha came up with a task for himself to relax a little. He chooses two integers *A* and *B* and then calculates the greatest common divisor of integers ""*A* factorial"" and ""*B* factorial"". Formally the hacker wants to find out GCD(*A*!,<=*B*!). It's well known that the factorial of an integer *x* is a product of all positive integers less than or equal to *x*. Thus *x*!<==<=1·2·3·...·(*x*<=-<=1)·*x*. For example 4!<==<=1·2·3·4<==<=24. Recall that GCD(*x*,<=*y*) is the largest positive integer *q* that divides (without a remainder) both *x* and *y*.

Leha has learned how to solve this task very effective. You are able to cope with it not worse, aren't you?","The first and single line contains two integers *A* and *B* (1<=≤<=*A*,<=*B*<=≤<=109,<=*min*(*A*,<=*B*)<=≤<=12).",Print a single integer denoting the greatest common divisor of integers *A*! and *B*!.,['4 3\n'],['6\n'],"Consider the sample.

4! = 1·2·3·4 = 24. 3! = 1·2·3 = 6. The greatest common divisor of integers 24 and 6 is exactly 6.",OK,"d = input().split(' ')
A = int(d[0])
B = int(d[1])

def a(x):
    if x == 0: 
        return 1
    return x * a(x-1)

if A>=B:
    print(a(B))
else:
    print(a(A))","import m

def g():

    e = m.stdin.read().splitlines()

    if not e:
        return
    h = e[0].split()
    if len(h) != 2:
        return
    j, f = h[0], h[1]

    if len(e) > 1:
        try:
            n = int(e[1].strip())
        except:
            n = 0
    else:
        n = 0

    i = ['^', '>', 'v', '<']

    try:
        k = i.index(j)
    except ValueError:
        return

    l = n % 4

    c = (k + l) % 4
    d = i[c]

    a = (k - l) % 4
    b = i[a]

    if d == f and b == f:
        print(""undefined"")
    elif d == f:
        print(""cw"")
    elif b == f:
        print(""ccw"")

if __name__ == ""__main__"":
    g()"
601,A,The Two Routes,PROGRAMMING,"['graphs', 'shortest paths']","In Absurdistan, there are *n* towns (numbered 1 through *n*) and *m* bidirectional railways. There is also an absurdly simple road network — for each pair of different towns *x* and *y*, there is a bidirectional road between towns *x* and *y* if and only if there is no railway between them. Travelling to a different town using one railway or one road always takes exactly one hour.

A train and a bus leave town 1 at the same time. They both have the same destination, town *n*, and don't make any stops on the way (but they can wait in town *n*). The train can move only along railways and the bus can move only along roads.

You've been asked to plan out routes for the vehicles; each route can use any road/railway multiple times. One of the most important aspects to consider is safety — in order to avoid accidents at railway crossings, the train and the bus must not arrive at the same town (except town *n*) simultaneously.

Under these constraints, what is the minimum number of hours needed for both vehicles to reach town *n* (the maximum of arrival times of the bus and the train)? Note, that bus and train are not required to arrive to the town *n* at the same moment of time, but are allowed to do so.","The first line of the input contains two integers *n* and *m* (2<=≤<=*n*<=≤<=400, 0<=≤<=*m*<=≤<=*n*(*n*<=-<=1)<=/<=2) — the number of towns and the number of railways respectively.

Each of the next *m* lines contains two integers *u* and *v*, denoting a railway between towns *u* and *v* (1<=≤<=*u*,<=*v*<=≤<=*n*, *u*<=≠<=*v*).

You may assume that there is at most one railway connecting any two towns.","Output one integer — the smallest possible time of the later vehicle's arrival in town *n*. If it's impossible for at least one of the vehicles to reach town *n*, output <=-<=1.","['4 2\n1 3\n3 4\n', '4 6\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4\n', '5 5\n4 2\n3 5\n4 5\n5 1\n1 2\n']","['2\n', '-1\n', '3\n']","In the first sample, the train can take the route <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/7c0aa60a06309ef607b7159fd7f3687ea0d943ce.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> and the bus can take the route <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/a26c2f3e93c9d9be6c21cb5d2bd6ac1f99f4ff55.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>. Note that they can arrive at town 4 at the same time.

In the second sample, Absurdistan is ruled by railwaymen. There are no roads, so there's no way for the bus to reach town 4.",WRONG_ANSWER,"n, m = map(int, input().split())
b = [[j for j in range(1,n+1) if j != i+1] for i in range(n)]
b.insert(0,[])
t = [[] for i in range(n+1)]

for _ in range(m):
    u, v = map(int, input().split())
    b[u].remove(v)
    b[v].remove(u)
    t[u].append(v)
    t[v].append(u)

def d(n, g, c, a):
    f = [(g,0)]
    i = [False for i in range(n+1)]
    i[g] = True
    while f != []:
        v = f[0]
        if v[0] == c:
            return v[1]
        for e in a[v[0]]:
            if not i[e]:
                i[e]=True
                f.append((e, v[1]+1))
        del f[0]
        print(f)
        print(i)
    return False
print(b)
b = d(n, 1, n, b)
print(t)
h = d(n, 1, n, t)
if h and b:
    print(max(h, b))
else:
    print(-1)","import g

def e():

    b = g.stdin.read().splitlines()
    for d in b:

        if not d:
            continue

        s = d.strip()
        n = len(s)

        c = [0] * n
        f = 0
        a = 0
        
        for i in range(1, n):
            if s[i] == ')':
                if s[i-1] == '(':

                    c[i] = (c[i-2] if i >= 2 else 0) + 2
                elif i - c[i-1] - 1 >= 0 and s[i - c[i-1] - 1] == '(':

                    c[i] = c[i-1] + 2
                    if i - c[i-1] - 2 >= 0:
                        c[i] += c[i - c[i-1] - 2]

                if c[i] > f:
                    f = c[i]
                    a = 1
                elif c[i] == f and c[i] != 0:
                    a += 1

        if f == 0:
            print(""0 1"")
        else:
            print(f""{f} {a}"")

if __name__ == ""__main__"":
    e()"
849,B,Tell Your World,PROGRAMMING,"['brute force', 'geometry']","Connect the countless points with lines, till we reach the faraway yonder.

There are *n* points on a coordinate plane, the *i*-th of which being (*i*,<=*y**i*).

Determine whether it's possible to draw two parallel and non-overlapping lines, such that every point in the set lies on exactly one of them, and each of them passes through at least one point in the set.","The first line of input contains a positive integer *n* (3<=≤<=*n*<=≤<=1<=000) — the number of points.

The second line contains *n* space-separated integers *y*1,<=*y*2,<=...,<=*y**n* (<=-<=109<=≤<=*y**i*<=≤<=109) — the vertical coordinates of each point.","Output ""Yes"" (without quotes) if it's possible to fulfill the requirements, and ""No"" otherwise.

You can print each letter in any case (upper or lower).","['5\n7 5 8 6 9\n', '5\n-1 -2 0 0 -5\n', '5\n5 4 3 2 1\n', '5\n1000000000 0 0 0 0\n']","['Yes\n', 'No\n', 'No\n', 'Yes\n']","In the first example, there are five points: (1, 7), (2, 5), (3, 8), (4, 6) and (5, 9). It's possible to draw a line that passes through points 1, 3, 5, and another one that passes through points 2, 4 and is parallel to the first one.

In the second example, while it's possible to draw two lines that cover all points, they cannot be made parallel.

In the third example, it's impossible to satisfy both requirements at the same time.",WRONG_ANSWER,"import f

def b():
    n = int(input())
    s = list(map(int, f.stdin.readline().split()))
    e = (0, 0)
    for z in range(2):
        for i in range(1, n):
            k = (s[i] - s[0]) / i
            c = True
            d = False
            for j in range(1, n):
                if i == j:
                    continue
                c = (s[j] - s[0]) / j
                if c != k:
                    if not d:
                        e = (j, s[j])
                        d = True
                    else:
                        a = (s[j] - e[1]) / (j - e[0])
                        if k!=a:
                            c = False
                            break

            if c and d:
                print(""Yes"")
                return
        s[1],s[0] = s[0],s[1]

    print(""No"")

b()","def g():
    import o
    o.setrecursionlimit(1000000)

    b = o.stdin.read().splitlines()
    if not b:
        return

    n, m, k = map(int, b[0].split())

    h = [list(f.rstrip(""\n"")) for f in b[1:1+n]]

    p = 0
    n = None
    for i in range(n):
        for j in range(m):
            if h[i][j] == '.':
                p += 1
                n = (i, j)

    k = p - k

    q = [[False] * m for _ in range(n)]

    a = 0
    m = [n]

    c = [(-1, 0), (0, 1), (1, 0), (0, -1)]
    
    while m and a < k:
        x, y = m.pop()
        if q[x][y]:
            continue
        q[x][y] = True
        a += 1
        if a == k:
            continue
        for d, e in c:
            i, j = x + d, y + e
            if 0 <= i < n and 0 <= j < m and not q[i][j] and h[i][j] == '.':
                m.append((i, j))

    for i in range(n):
        for j in range(m):
            if h[i][j] == '.' and not q[i][j]:
                h[i][j] = 'X'

    for l in h:
        o.stdout.write("""".join(l) + ""\n"")

if __name__ == ""__main__"":
    g()"
327,A,Flipping Game,PROGRAMMING,"['brute force', 'dp', 'implementation']","Iahub got bored, so he invented a game to be played on paper. 

He writes *n* integers *a*1,<=*a*2,<=...,<=*a**n*. Each of those integers can be either 0 or 1. He's allowed to do exactly one move: he chooses two indices *i* and *j* (1<=≤<=*i*<=≤<=*j*<=≤<=*n*) and flips all values *a**k* for which their positions are in range [*i*,<=*j*] (that is *i*<=≤<=*k*<=≤<=*j*). Flip the value of *x* means to apply operation *x*<==<=1 - *x*.

The goal of the game is that after exactly one move to obtain the maximum number of ones. Write a program to solve the little game of Iahub.","The first line of the input contains an integer *n* (1<=≤<=*n*<=≤<=100). In the second line of the input there are *n* integers: *a*1,<=*a*2,<=...,<=*a**n*. It is guaranteed that each of those *n* values is either 0 or 1.",Print an integer — the maximal number of 1s that can be obtained after exactly one move.,"['5\n1 0 0 1 0\n', '4\n1 0 0 1\n']","['4\n', '4\n']","In the first case, flip the segment from 2 to 5 (*i* = 2, *j* = 5). That flip changes the sequence, it becomes: [1 1 1 0 1]. So, it contains four ones. There is no way to make the whole sequence equal to [1 1 1 1 1].

In the second case, flipping only the second and the third element (*i* = 2, *j* = 3) will turn all numbers into 1.",WRONG_ANSWER,"def a():
    n=int(input())
    a=list(map(int,input().split()))
    q,w=0,0
    for i in range(n):
        if a[i]==1:
            q=i+1
            break
    for i in range(n):
        if a[i]==1:
            w=i+1
    print(w-(q-1))
    
a()","def c(j):

    return j == j[::-1]

def d():
    import i

    b = i.stdin.readline().strip()

    h, m = map(int, b.split(':'))

    a = h * 60 + m
    h = 0

    while True:

        g = (a + h) % (24 * 60)
        e = g // 60
        f = g % 60

        j = f""{e:02d}:{f:02d}""

        if c(j):
            print(h)
            break
        
        h += 1

if __name__ == ""__main__"":
    d()"
551,A,GukiZ and Contest,PROGRAMMING,"['brute force', 'implementation', 'sortings']","Professor GukiZ likes programming contests. He especially likes to rate his students on the contests he prepares. Now, he has decided to prepare a new contest. 

In total, *n* students will attend, and before the start, every one of them has some positive integer rating. Students are indexed from 1 to *n*. Let's denote the rating of *i*-th student as *a**i*. After the contest ends, every student will end up with some positive integer position. GukiZ expects that his students will take places according to their ratings. 

He thinks that each student will take place equal to . In particular, if student *A* has rating strictly lower then student *B*, *A* will get the strictly better position than *B*, and if two students have equal ratings, they will share the same position. 

GukiZ would like you to reconstruct the results by following his expectations. Help him and determine the position after the end of the contest for each of his students if everything goes as expected.","The first line contains integer *n* (1<=≤<=*n*<=≤<=2000), number of GukiZ's students. 

The second line contains *n* numbers *a*1,<=*a*2,<=... *a**n* (1<=≤<=*a**i*<=≤<=2000) where *a**i* is the rating of *i*-th student (1<=≤<=*i*<=≤<=*n*).","In a single line, print the position after the end of the contest for each of *n* students in the same order as they appear in the input.","['3\n1 3 3\n', '1\n1\n', '5\n3 5 3 4 5\n']","['3 1 1\n', '1\n', '4 1 4 3 1\n']","In the first sample, students 2 and 3 are positioned first (there is no other student with higher rating), and student 1 is positioned third since there are two students with higher rating.

In the second sample, first student is the only one on the contest.

In the third sample, students 2 and 5 share the first position with highest rating, student 4 is next with third position, and students 1 and 3 are the last sharing fourth position.",RUNTIME_ERROR,"s
a = 10**20
b = 10**9 + 7
from math import gcd
from math import ceil, log2, factorial
from collections import defaultdict as dd, Counter
from bisect import bisect_left as bl, bisect_right as br

def g():
  import k
  from io import c 
  from atexit import i
  global input
  k.stdin = c(k.stdin.read())
  input = lambda : k.stdin.readline().rstrip('\r\n')
  k.stdout = c()
  i(lambda : k.__stdout__.write(k.stdout.getvalue()))
g()

I = lambda:list(map(int,input().split()))
d = 0
""""""
Facts and Data representation
Constructive? Top bottom up down
""""""
def j():
  n, = I()
  a = I()
  a = [[a[i], i] for i in range(n)]

  a.sort(reverse=True)
  e = [0] * n

  e[a[0][1]] = 1
  f = 0
  for i in range(1, n):
    if (a[i][0] == a[i - 1][0]):
      e[a[i][1]] = e[a[i - 1][1]]
      f += 1
    else:
      e[a[i][1]] = e[a[i - 1][1]] + f + 1
      f = 0
  print(*e)

def h():
  if not d:
    j()
    return

  t, = I()
  while t:
    j()
    t -= 1

if __name__ == ""__main__"":
  h()","import n
from collections import deque

def g():

    b = n.stdin.read().splitlines()
    if not b:
        return

    n, m, k = map(int, b[0].split())

    h = [list(f) for f in b[1:1+n]]

    p = sum(k.a('.') for k in h)

    o = p - k

    m = None
    for i in range(n):
        for j in range(m):
            if h[i][j] == '.':
                m = (i, j)
                break
        if m is not None:
            break

    if m is None:
        for k in h:
            print(''.join(k))
        return

    q = [[False] * m for _ in range(n)]

    l = [m]
    q[m[0]][m[1]] = True
    a = 1

    c = [(-1, 0), (0, 1), (1, 0), (0, -1)]
    
    while l and a < o:
        x, y = l.pop()

        for d, e in c:
            i, j = x + d, y + e

            if 0 <= i < n and 0 <= j < m:
                if h[i][j] == '.' and not q[i][j]:
                    q[i][j] = True
                    l.append((i, j))
                    a += 1

                    if a == o:
                        break

        if a == o:
            break

    for i in range(n):
        for j in range(m):
            if h[i][j] == '.' and not q[i][j]:
                h[i][j] = 'X'

    for k in h:
        n.stdout.write("""".join(k) + ""\n"")

if __name__ == '__main__':
    g()"
142,A,Help Farmer,PROGRAMMING,"['brute force', 'math']","Once upon a time in the Kingdom of Far Far Away lived Sam the Farmer. Sam had a cow named Dawn and he was deeply attached to her. Sam would spend the whole summer stocking hay to feed Dawn in winter. Sam scythed hay and put it into haystack. As Sam was a bright farmer, he tried to make the process of storing hay simpler and more convenient to use. He collected the hay into cubical hay blocks of the same size. Then he stored the blocks in his barn. After a summer spent in hard toil Sam stored *A*·*B*·*C* hay blocks and stored them in a barn as a rectangular parallelepiped *A* layers high. Each layer had *B* rows and each row had *C* blocks.

At the end of the autumn Sam came into the barn to admire one more time the hay he'd been stacking during this hard summer. Unfortunately, Sam was horrified to see that the hay blocks had been carelessly scattered around the barn. The place was a complete mess. As it turned out, thieves had sneaked into the barn. They completely dissembled and took away a layer of blocks from the parallelepiped's front, back, top and sides. As a result, the barn only had a parallelepiped containing (*A*<=-<=1)<=×<=(*B*<=-<=2)<=×<=(*C*<=-<=2) hay blocks. To hide the evidence of the crime, the thieves had dissembled the parallelepiped into single 1<=×<=1<=×<=1 blocks and scattered them around the barn. After the theft Sam counted *n* hay blocks in the barn but he forgot numbers *A*, *B* и *C*.

Given number *n*, find the minimally possible and maximally possible number of stolen hay blocks.",The only line contains integer *n* from the problem's statement (1<=≤<=*n*<=≤<=109).,"Print space-separated minimum and maximum number of hay blocks that could have been stolen by the thieves.

Note that the answer to the problem can be large enough, so you must use the 64-bit integer type for calculations. Please, do not use the %lld specificator to read or write 64-bit integers in С++. It is preferred to use cin, cout streams or the %I64d specificator.","['4\n', '7\n', '12\n']","['28 41\n', '47 65\n', '48 105\n']","Let's consider the first sample test. If initially Sam has a parallelepiped consisting of 32 = 2 × 4 × 4 hay blocks in his barn, then after the theft the barn has 4 = (2 - 1) × (4 - 2) × (4 - 2) hay blocks left. Thus, the thieves could have stolen 32 - 4 = 28 hay blocks. If Sam initially had a parallelepiped consisting of 45 = 5 × 3 × 3 hay blocks in his barn, then after the theft the barn has 4 = (5 - 1) × (3 - 2) × (3 - 2) hay blocks left. Thus, the thieves could have stolen 45 - 4 = 41 hay blocks. No other variants of the blocks' initial arrangement (that leave Sam with exactly 4 blocks after the theft) can permit the thieves to steal less than 28 or more than 41 blocks.",TIME_LIMIT_EXCEEDED,"def a(n):
    return int(n**(1/2))

def f(i):
    h = i + 1
    for i in range(1, a(i) + 1):
        if i % i == 0:
            s = i + i/i
            if h > s:
                h = s
    return h

def c():
    n = int(input())
    g = 9*n+9
    d = 1
    for x in range(1, n+1):
        if n % x != 0:
            continue
        else:

            j = n/x

            h = f(j)
            e = (j + 2*h + 4)*(x + 1)

            b = (j + 2*(j + 1) + 4)*(x + 1)

            if (e < g):
                g = e
            if (b > d):
                d = b
    print(str(int(g - n)) + ' ' + str(int(d - n)))

if __name__ == '__main__':
    c()","import f

def a(a, b, c):

    for x in range(c // a + 1):

        if (c - a * x) % b == 0:

            return True
    return False

def d():
    import f

    b = f.stdin.read().splitlines()
    for c in b:
        if not c.strip():
            continue
        e = c.split()
        if len(e) != 3:
            continue
        a, b, c = map(int, e)

        if a(a, b, c):
            f.stdout.write(""Yes\n"")
        else:
            f.stdout.write(""No\n"")

if __name__ == '__main__':
    d()"
551,C,GukiZ hates Boxes,PROGRAMMING,"['binary search', 'greedy']","Professor GukiZ is concerned about making his way to school, because massive piles of boxes are blocking his way. 

In total there are *n* piles of boxes, arranged in a line, from left to right, *i*-th pile (1<=≤<=*i*<=≤<=*n*) containing *a**i* boxes. Luckily, *m* students are willing to help GukiZ by removing all the boxes from his way. Students are working simultaneously. At time 0, all students are located left of the first pile. It takes one second for every student to move from this position to the first pile, and after that, every student must start performing sequence of two possible operations, each taking one second to complete. Possible operations are:
1.  If *i*<=≠<=*n*, move from pile *i* to pile *i*<=+<=1;1.  If pile located at the position of student is not empty, remove one box from it.
GukiZ's students aren't smart at all, so they need you to tell them how to remove boxes before professor comes (he is very impatient man, and doesn't want to wait). They ask you to calculate minumum time *t* in seconds for which they can remove all the boxes from GukiZ's way. Note that students can be positioned in any manner after *t* seconds, but all the boxes must be removed.","The first line contains two integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=105), the number of piles of boxes and the number of GukiZ's students. 

The second line contains *n* integers *a*1,<=*a*2,<=... *a**n* (0<=≤<=*a**i*<=≤<=109) where *a**i* represents the number of boxes on *i*-th pile. It's guaranteed that at least one pile of is non-empty.","In a single line, print one number, minimum time needed to remove all the boxes in seconds.","['2 1\n1 1\n', '3 2\n1 0 2\n', '4 100\n3 4 5 4\n']","['4\n', '5\n', '5\n']","First sample: Student will first move to the first pile (1 second), then remove box from first pile (1 second), then move to the second pile (1 second) and finally remove the box from second pile (1 second).

Second sample: One of optimal solutions is to send one student to remove a box from the first pile and a box from the third pile, and send another student to remove a box from the third pile. Overall, 5 seconds.

Third sample: With a lot of available students, send three of them to remove boxes from the first pile, four of them to remove boxes from the second pile, five of them to remove boxes from the third pile, and four of them to remove boxes from the fourth pile. Process will be over in 5 seconds, when removing the boxes from the last pile is finished.",WRONG_ANSWER,"n,m = map(int, input().split())
A = list(map(int, input().split()))

c, b = 1, 10**15
def a(d):
    g, b = 0, A[0]
    for i in range(m):
        t = d-1-g
        while t > 0:
            f = min(b, t)
            b, t = b-f, t-f
            if b == 0:
                g += 1
                if g == n: return True
                b, t = A[g], t-1
    return False

while c+1 < b:
    e = (c+b) // 2
    if a(e): b = e
    else: c = e
print(b)","import d

def b():

    a = d.stdin.read().split()
    n = int(a[0])
    m = int(a[1])

    if m == 0 or n >= m.bit_length():
        c = m
    else:

        c = m % (1 << n)

    d.stdout.write(str(c) + ""\n"")

if __name__ == ""__main__"":
    b()"
664,A,Complicated GCD,PROGRAMMING,"['math', 'number theory']","Greatest common divisor *GCD*(*a*,<=*b*) of two positive integers *a* and *b* is equal to the biggest integer *d* such that both integers *a* and *b* are divisible by *d*. There are many efficient algorithms to find greatest common divisor *GCD*(*a*,<=*b*), for example, Euclid algorithm. 

Formally, find the biggest integer *d*, such that all integers *a*,<=*a*<=+<=1,<=*a*<=+<=2,<=...,<=*b* are divisible by *d*. To make the problem even more complicated we allow *a* and *b* to be up to googol, 10100 — such number do not fit even in 64-bit integer type!",The only line of the input contains two integers *a* and *b* (1<=≤<=*a*<=≤<=*b*<=≤<=10100).,Output one integer — greatest common divisor of all integers from *a* to *b* inclusive.,"['1 2\n', '61803398874989484820458683436563811772030917980576 61803398874989484820458683436563811772030917980576\n']","['1\n', '61803398874989484820458683436563811772030917980576\n']",none,WRONG_ANSWER,"b, c = map(int, input().split())

def a(b, c):
    if not c:
        return b
    return a(c, b % c)        

print(a(b, c))","import 
import 

c = 1e-9

x = .stdin.read().strip().split()
if not x:
    .exit(0)

r = float(x[0])
h = float(x[1])

L = .sqrt(r * r + h * h)

 = 2 * .pi * r / L

def (g):
    a = .fmod(g, 2*.pi)
    if a < 0:
        a += 2*.pi
    return a

def (x, y, z):
    s = L * (h - z) / h
    d = .hypot(x, y)

    if d < c:
         = 0.0
    else:
         = (.atan2(y, x))
    a = (r / L) * 

    a = a % 
    return s, a, 

def h(x, y):
    p = .hypot(x, y)
     = (.atan2(y, x))
    return p, 

def o(x, y, z):
    if abs(z) < c:
        d = .hypot(x, y)
        if abs(d - r) < c:

            return ""both"", (x, y, z)
        else:
            return ""base"", (x, y, z)
    else:

        d = .hypot(x, y)
        z = (r/h) * (h - z)
        if abs(d - z) < 1e-8:
            return ""lateral"", (x, y, z)
        else:

            return ""lateral"", (x, y, z)

 = (float(x[2]), float(x[3]), float(x[4]))

 = (float(x[5]), float(x[6]), float(x[7]))

, _ = o(*)
, _ = o(*)

m = []

if ( == ""base"" or ( == ""both"")) and ( == ""base"" or ( == ""both"")):

    i = .hypot([0]-[0], [1]-[1])
    m.append(i)

if ( == ""lateral"" or  == ""both"") and ( == ""lateral"" or  == ""both""):
    , d,  = ([0], [1], [2])
    , e,  = ([0], [1], [2])

    w = abs(d - e)
    w = min(w,  - w)

    v = .sqrt( *  +  *  - 2 *  *  * .cos(w))
    m.append(v)

    t = (L / h) * [2] if abs([2]) > c else 0.0
    u = (L / h) * [2] if abs([2]) > c else 0.0

    y = abs( - )
    y = min(y, 2*.pi - y)
    n = 2 * r * .sin(y / 2)
     = t + u + n
    m.append()

def (~, j):

    s, a, _ = (~[0], ~[1], ~[2])

    p,  = h(j[0], j[1])

    def f():
        q = .sqrt(s * s + L * L - 2 * s * L * .cos(a - ))

        f = (L / r) * 
        r = .sqrt(r * r + p * p - 2 * r * p * .cos(f - ))
        return q + r

     = 0.0
    } = 

    for _ in range(100):
         =  + (} - ) / 3
         = } - (} - ) / 3
        { = f()
        | = f()
        if { > |:
             = 
        else:
            } = 
    return f(( + }) / 2)

if (( == ""lateral"") and ( == ""base"")) or (( == ""base"") and ( == ""lateral"")):

    if  == ""lateral"":
        ~ = 
        j = 
    else:
        ~ = 
        j = 

    l = (~, j)
    m.append(l)

    if  == ""both"" or  == ""both"":

        s = .hypot(~[0]-j[0], ~[1]-j[1])
        m.append(s)

if (( == ""lateral"") and ( == ""both"")) or (( == ""both"") and ( == ""lateral"")):

    if  == ""lateral"":
        ~ = 
        j = 
    else:
        ~ = 
        j = 
    l = (~, j)
    m.append(l)

    d = .hypot(~[0], ~[1])
    if d < c:
        a, b = r, 0.0
    else:
        a = r * ~[0] / d
        b = r * ~[1] / d
    s = .hypot(a - j[0], b - j[1])

    k = (L / h) * ~[2] + s
    m.append(k)

if not m:
     = 0.0
else:
     = min(m)

print(""{:.9f}"".format())"
1000,C,Covered Points Count,PROGRAMMING,"['data structures', 'implementation', 'sortings']","You are given $n$ segments on a coordinate line; each endpoint of every segment has integer coordinates. Some segments can degenerate to points. Segments can intersect with each other, be nested in each other or even coincide.

Your task is the following: for every $k \in [1..n]$, calculate the number of points with integer coordinates such that the number of segments that cover these points equals $k$. A segment with endpoints $l_i$ and $r_i$ covers point $x$ if and only if $l_i \le x \le r_i$.","The first line of the input contains one integer $n$ ($1 \le n \le 2 \cdot 10^5$) — the number of segments.

The next $n$ lines contain segments. The $i$-th line contains a pair of integers $l_i, r_i$ ($0 \le l_i \le r_i \le 10^{18}$) — the endpoints of the $i$-th segment.","Print $n$ space separated integers $cnt_1, cnt_2, \dots, cnt_n$, where $cnt_i$ is equal to the number of points such that the number of segments that cover these points equals to $i$.","['3\n0 3\n1 3\n3 8\n', '3\n1 3\n2 4\n5 7\n']","['6 2 1 \n', '5 2 0 \n']","The picture describing the first example:

<img class=""tex-graphics"" src=""https://espresso.codeforces.com/f76b3fe547bff6be5b14de76c8b78ba3efecc744.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

Points with coordinates $[0, 4, 5, 6, 7, 8]$ are covered by one segment, points $[1, 2]$ are covered by two segments and point $[3]$ is covered by three segments.

The picture describing the second example:

<img class=""tex-graphics"" src=""https://espresso.codeforces.com/6e9332c303e1bc5d6cf34c2d6c5e2a19c9417289.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

Points $[1, 4, 5, 6, 7]$ are covered by one segment, points $[2, 3]$ are covered by two segments and there are no points covered by three segments.",TIME_LIMIT_EXCEEDED,"def a():
    k = []
    b = int(input())
    for x in range(b):
        k.append(list(map(int,input().split())))
    j = [-1 for x in range(max(k[-1])+1)]
    for x in k:
        for y in range(x[0],x[1]+1):
            j[y] += 1
    t = [0 for x in range(b)]
    for x in j:
        if x != -1:
            t[x] += 1
    print(' '.join(list(map(str,t))))

a()","""""""
This script finds 4 distinct cities a, b, c, d in a directed graph such that there exist paths
from a to b, b to c, and c to d and the total distance (measured as number of edges in the shortest paths)
is maximized. The solution is based on precomputing for each city:
  - best_in[v]: up to 3 cities that can reach v with the largest distances.
  - best_out[u]: up to 3 cities that u can reach with the largest distances.
Then, we try every candidate intermediate edge b -> c and pick the best combination a->b + b->c + c->d.
""""""

def s():
    import x
    from collections import m
    x.setrecursionlimit(10000)
    
    l = x.stdin.buffer.read().split()
    if not l:
        return
    r = iter(l)
    n = int(next(r))
    m = int(next(r))

    q = [[] for _ in range(n+1)]
    for _ in range(m):
        u = int(next(r))
        v = int(next(r))

        q[u].append(v)

    a = [[] for _ in range(n+1)]
    b = [[] for _ in range(n+1)]

    v = [[] for _ in range(n+1)]

    def z(e, t):
        e.append(t)
        e.sort(key=lambda x: x[0], reverse=True)
        if len(e) > 3:
            del e[3:]

    for w in range(1, n+1):
        o = [-1]*(n+1)
        o[w] = 0
        p = m([w])

        n = []
        while p:
            f = p.popleft()
            for u in q[f]:
                if o[u] == -1:
                    o[u] = o[f] + 1
                    p.append(u)
                    n.append(u)

        for v in n:
            k = o[v]
            z(a[v], (k, w))
            z(b[w], (k, v))
            v[w].append((v, k))
    
    d = -1
    c = None

    for b in range(1, n+1):
        if not a[b]:
            continue
        for (c, i) in v[b]:
            if not b[c]:
                continue
            for (h, a) in a[b]:
                if a == b or a == c:
                    continue
                for (j, g) in b[c]:
                    if g == a or g == b or g == c:
                        continue
                    y = h + i + j
                    if y > d:
                        d = y
                        c = (a, b, c, g)

    if c is None:
        c = (1, 2, 3, 4)
    x.stdout.write("" "".join(map(str, c)) + ""\n"")
    
if __name__ == '__main__':
    s()"
766,A,Mahmoud and Longest Uncommon Subsequence,PROGRAMMING,"['constructive algorithms', 'strings']","While Mahmoud and Ehab were practicing for IOI, they found a problem which name was Longest common subsequence. They solved it, and then Ehab challenged Mahmoud with another problem.

Given two strings *a* and *b*, find the length of their longest uncommon subsequence, which is the longest string that is a subsequence of one of them and not a subsequence of the other.

A subsequence of some string is a sequence of characters that appears in the same order in the string, The appearances don't have to be consecutive, for example, strings ""ac"", ""bc"", ""abc"" and ""a"" are subsequences of string ""abc"" while strings ""abbc"" and ""acb"" are not. The empty string is a subsequence of any string. Any string is a subsequence of itself.","The first line contains string *a*, and the second line — string *b*. Both of these strings are non-empty and consist of lowercase letters of English alphabet. The length of each string is not bigger than 105 characters.","If there's no uncommon subsequence, print ""-1"". Otherwise print the length of the longest uncommon subsequence of *a* and *b*.","['abcd\ndefgh\n', 'a\na\n']","['5\n', '-1\n']","In the first example: you can choose ""defgh"" from string *b* as it is the longest subsequence of string *b* that doesn't appear as a subsequence of string *a*.",OK,"def a():
    a = input()
    b = input()
    print(-1 if a == b else max(len(a), len(b)))
    
t = 1
for i in range(t):

	a()","import c

def b():

    n, t = map(int, c.stdin.readline().strip().split())

    a = list(map(int, c.stdin.readline().strip().split()))

    a = 1

    while a < t:

        a += a[a - 1]

    if a == t:
        print(""YES"")
    else:
        print(""NO"")

if __name__ == ""__main__"":
    b()"
618,A,Slime Combining,PROGRAMMING,['implementation'],"Your friend recently gave you some slimes for your birthday. You have *n* slimes all initially with value 1.

You are going to play a game with these slimes. Initially, you put a single slime by itself in a row. Then, you will add the other *n*<=-<=1 slimes one by one. When you add a slime, you place it at the right of all already placed slimes. Then, while the last two slimes in the row have the same value *v*, you combine them together to create a slime with value *v*<=+<=1.

You would like to see what the final state of the row is after you've added all *n* slimes. Please print the values of the slimes in the row from left to right.","The first line of the input will contain a single integer, *n* (1<=≤<=*n*<=≤<=100<=000).","Output a single line with *k* integers, where *k* is the number of slimes in the row after you've finished the procedure described in the problem statement. The *i*-th of these numbers should be the value of the *i*-th slime from the left.","['1\n', '2\n', '3\n', '8\n']","['1\n', '2\n', '2 1\n', '4\n']","In the first sample, we only have a single slime with value 1. The final state of the board is just a single slime with value 1.

In the second sample, we perform the following steps:

Initially we place a single slime in a row by itself. Thus, row is initially 1.

Then, we will add another slime. The row is now 1 1. Since two rightmost slimes have the same values, we should replace these slimes with one with value 2. Thus, the final state of the board is 2.

In the third sample, after adding the first two slimes, our row is 2. After adding one more slime, the row becomes 2 1.

In the last sample, the steps look as follows: 
 1.  1 1.  2 1.  2 1 1.  3 1.  3 1 1.  3 2 1.  3 2 1 1.  4",WRONG_ANSWER,"import c
def a(x):
	return (c.log10(x) /
	  c.log10(2))
def b(n):
	return (c.ceil(a(n)) == c.floor(a(n)))
l = []
d = []
n = int(input())
if b(n) :
    x = a(n)
    print(x+1)
else :
    for i in range(n) :
        '''if len(l) > 1 and l[-1] == l[-2] :
            l[-2] += 1
            l.pop()
            print(""Begin : "",l)
        print(""Mid : "",l)
        if i==0 :
            l.append(1)
            cntr += 1
        else :
            if l[-1] == cntr :
                l[-1] += cntr
            else :
                l.append(1)
                cntr = 1
        if len(l) > 1 and l[-1] == l[-2] :
            l[-2] += 1
            l.pop()
            print(""End : "" ,l)'''
        l.append(1)
    if 2**c.ceil(a(n)) - 1 == n :
        d = [i for i in range(1,c.ceil(a(n))+1)]
    else :
        if len(l)%2 != 0 :
            d.append(1)
        d.append(c.ceil(a(n)))
    print(d)","def a(x):
    """"""Check if a number x is prime.""""""
    if x < 2:
        return False
    if x == 2:
        return True
    if x % 2 == 0:
        return False

    b = int(x**0.5) + 1
    for d in range(3, b, 2):
        if x % d == 0:
            return False
    return True

def c():

    n = int(input())

    if a(n):
        print(1)

    elif n % 2 == 0:
        print(2)
    else:

        if a(n - 2):
            print(2)
        else:

            print(3)

if __name__ == '__main__':
    c()"
276,B,Little Girl and Game,PROGRAMMING,"['games', 'greedy']","The Little Girl loves problems on games very much. Here's one of them.

Two players have got a string *s*, consisting of lowercase English letters. They play a game that is described by the following rules:
 -  The players move in turns; In one move the player can remove an arbitrary letter from string *s*. -  If the player before his turn can reorder the letters in string *s* so as to get a palindrome, this player wins. A palindrome is a string that reads the same both ways (from left to right, and vice versa). For example, string ""abba"" is a palindrome and string ""abc"" isn't. 
Determine which player will win, provided that both sides play optimally well — the one who moves first or the one who moves second.","The input contains a single line, containing string *s* (1<=≤<=|*s*|<=<=≤<=<=103). String *s* consists of lowercase English letters.","In a single line print word ""First"" if the first player wins (provided that both players play optimally well). Otherwise, print word ""Second"". Print the words without the quotes.","['aba\n', 'abca\n']","['First\n', 'Second\n']",none,WRONG_ANSWER,"import e
def d(g):
    return True if g==g[::-1] else False
f = list(input().strip())
c=0
a=0
while True:
    s = """"
    for b in f:
        s+=b
    if(d(s)):
        break
    elif(len(f)==1):
        break
    else:
        f.pop(e.randint(0,len(f)-1))
        c = a+1%2
if(c==0):
    print(""First"")
elif(c==1):
    print(""Second"")","def d(s, k, i):
    n = len(s)
    e = 0
    c = 0

    a = 0
    
    for g in range(n):
        if s[g] != i:
            a += 1

        while a > k:
            if s[c] != i:
                a -= 1
            c += 1

        e = max(e, g - c + 1)
    return e

if __name__ == ""__main__"":
    import h
    b = h.stdin.read().splitlines()

    n, k = map(int, b[0].split())
    s = b[1].strip()

    f = max(d(s, k, 'a'), d(s, k, 'b'))
    h.stdout.write(str(f) + ""\n"")"
508,A,Pasha and Pixels,PROGRAMMING,['brute force'],"Pasha loves his phone and also putting his hair up... But the hair is now irrelevant.

Pasha has installed a new game to his phone. The goal of the game is following. There is a rectangular field consisting of *n* row with *m* pixels in each row. Initially, all the pixels are colored white. In one move, Pasha can choose any pixel and color it black. In particular, he can choose the pixel that is already black, then after the boy's move the pixel does not change, that is, it remains black. Pasha loses the game when a 2<=×<=2 square consisting of black pixels is formed. 

Pasha has made a plan of *k* moves, according to which he will paint pixels. Each turn in his plan is represented as a pair of numbers *i* and *j*, denoting respectively the row and the column of the pixel to be colored on the current move.

Determine whether Pasha loses if he acts in accordance with his plan, and if he does, on what move the 2<=×<=2 square consisting of black pixels is formed.","The first line of the input contains three integers *n*,<=*m*,<=*k* (1<=≤<=*n*,<=*m*<=≤<=1000, 1<=≤<=*k*<=≤<=105) — the number of rows, the number of columns and the number of moves that Pasha is going to perform. 

The next *k* lines contain Pasha's moves in the order he makes them. Each line contains two integers *i* and *j* (1<=≤<=*i*<=≤<=*n*, 1<=≤<=*j*<=≤<=*m*), representing the row number and column number of the pixel that was painted during a move.","If Pasha loses, print the number of the move when the 2<=×<=2 square consisting of black pixels is formed.

If Pasha doesn't lose, that is, no 2<=×<=2 square consisting of black pixels is formed during the given *k* moves, print 0.","['2 2 4\n1 1\n1 2\n2 1\n2 2\n', '2 3 6\n2 3\n2 2\n1 3\n2 2\n1 2\n1 1\n', '5 3 7\n2 3\n1 2\n1 1\n4 1\n3 1\n5 3\n3 2\n']","['4\n', '5\n', '0\n']",none,RUNTIME_ERROR,"""""""
Created on Thu Dec 15 10:26:22 2022

@author: thinkpad
""""""

n,m,k = map(int,input().split())

l = [[0 for _ in range(m+2)] for _  in range(n+2)]
f = [[-1,-1],[-1,0],[0,-1]]
g = [[-1,0],[-1,1],[0,1]]
h = [[0,-1],[1,-1],[1,0]]
i = [[0,1],[1,1],[1,0]]

def e(i,j):
    a = 0
    for d in f:
        x,y = d[0],d[1]
        if l[i+x][j+y]==1:
            a+=1
    if a == 3:
        return False
    b = 0
    for d in g:
        x,y = d[0],d[1]
        if l[i+x][j+y]==1:
            b+=1
    if b == 3:
        return False        
    c = 0
    for d in h:
        x,y = d[0],d[1]
        if l[i+x][j+y]==1:
            c+=1
    if c == 3:
        return False        
    d = 0
    for d in i:
        x,y = d[0],d[1]
        if l[i+x][j+y]==1:
            d+=1
    if d == 3:
        return False
    return True
k = []
for _ in range(k):
    k.append(map(int,input().split()))
j = True
for t in range(k):
    i,j =k[t][0],k[t][1]
    l[i][j]=1
    if e(i,j)==False:
        print(t+1)
        j = False
    else:
        continue

if j == True:
    print(0)","def n():
    import p
    from collections import e

    d = p.stdin.read().split()
    if not d:
        return
    k = iter(d)
    n = int(next(k))
    m = int(next(k))

    l = [set() for _ in range(n)]
    for _ in range(m):
        u = int(next(k)) - 1
        v = int(next(k)) - 1
        l[u].add(v)
        l[v].add(u)

    def c(j, o):
        f = [-1] * n
        i = e()
        i.append(o)
        f[o] = 0
        while i:
            u = i.popleft()
            for v in j[u]:
                if f[v] == -1:
                    f[v] = f[u] + 1
                    i.append(v)
        return f

    m = [set() for _ in range(n)]
    a = set(range(n))
    for u in range(n):

        m[u] = a - l[u] - {u}

    h = c(l, 0)
    g = c(m, 0)

    if h[n - 1] == -1 or g[n - 1] == -1:
        p.stdout.write(""-1"")
    else:

        b = max(h[n - 1], g[n - 1])
        p.stdout.write(str(b))

if __name__ == '__main__':
    n()"
348,A,Mafia,PROGRAMMING,"['binary search', 'math', 'sortings']","One day *n* friends gathered together to play ""Mafia"". During each round of the game some player must be the supervisor and other *n*<=-<=1 people take part in the game. For each person we know in how many rounds he wants to be a player, not the supervisor: the *i*-th person wants to play *a**i* rounds. What is the minimum number of rounds of the ""Mafia"" game they need to play to let each person play at least as many rounds as they want?","The first line contains integer *n* (3<=≤<=*n*<=≤<=105). The second line contains *n* space-separated integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=109) — the *i*-th number in the list is the number of rounds the *i*-th person wants to play.","In a single line print a single integer — the minimum number of game rounds the friends need to let the *i*-th person play at least *a**i* rounds.

Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.","['3\n3 2 2\n', '4\n2 2 2 2\n']","['4\n', '3\n']","You don't need to know the rules of ""Mafia"" to solve this problem. If you're curious, it's a game Russia got from the Soviet times: http://en.wikipedia.org/wiki/Mafia_(party_game).",OK,"from cmath import inf
import math
import h
from os import g

from functools import reduce
import collections
import h
 
if (g.exists('CP/input.txt')):
    h.stdout = open('CP/output.txt', 'w')
    h.stdin = open('CP/input.txt', 'r')
    
 
 
def f(e,c,d):
    d = 0
    for x in c:
        d += (e - x)

    if(d>=e):
        return True
 
    return False
        
    
                         
def b():
    n = int(input())
    c  = list(map(int,input().split()))
    
    l,r = 0,(2**31 - 1)
    for x in c:
        l = max(l,x)
    d = l
    
    a=-1
    
    while(l<=r):

        e = (l+r)//2

        if(f(e,c,d)):
            a = e
            r=e-1
        else:
            l=e+1
    
    print(a)

t=1
for _ in range(t):
	b()","import o
from bisect import b

def i():

    d = o.stdin.read().split()
    if not d:
        return
    n = int(d[0])
    m = int(d[1])
    a = list(map(int, d[2:2+n]))

    k = n // 2
    f = a[:k]
    l = a[k:]

    h = []
    g = len(f)
    for j in range(1 << g):
        s = 0
        for i in range(g):
            if j & (1 << i):
                s += f[i]

        h.append(s % m)

    n = []
    m = len(l)
    for j in range(1 << m):
        s = 0
        for i in range(m):
            if j & (1 << i):
                s += l[i]
        n.append(s % m)

    n.sort()
    
    a = 0

    for x in h:

        e = b(n, m - 1 - x) - 1
        if e >= 0:
            c = (x + n[e]) % m
            if c > a:
                a = c

        c = (x + n[-1]) % m
        if c > a:
            a = c

    print(a)

if __name__ == ""__main__"":
    i()"
472,A,Design Tutorial: Learn from Math,PROGRAMMING,"['math', 'number theory']","One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.

For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.

You are given an integer *n* no less than 12, express it as a sum of two composite numbers.",The only line contains an integer *n* (12<=≤<=*n*<=≤<=106).,"Output two composite integers *x* and *y* (1<=&lt;<=*x*,<=*y*<=&lt;<=*n*) such that *x*<=+<=*y*<==<=*n*. If there are multiple solutions, you can output any of them.","['12\n', '15\n', '23\n', '1000000\n']","['4 8\n', '6 9\n', '8 15\n', '500000 500000\n']","In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output ""6 6"" or ""8 4"" as well.

In the second example, 15 = 6 + 9. Note that you can't output ""1 14"" because 1 is not a composite number.",TIME_LIMIT_EXCEEDED,"def a(n):
    a=True
    k=2
    while k*k<=n:
        if n%k==0:
            a=False
            break
    return a

n=int(input())
for i in range(4,n//2+1):
    if not a(i) and not a(n-i):
        print(i,n-i)","import o

def n(m):

    b = True
    while b:
        b = False
        i = []
        i = 0
        n = len(m)
        while i < n:
            j = i + 1

            while j < n and m[j][0] == m[i][0]:
                j += 1

            if j - i >= 3:
                b = True
            else:
                i.extend(m[i:j])
            i = j
        m = i
    return m

def g():
    c = o.stdin.read().strip().split()
    if not c:
        return

    n = int(c[0])
    k = int(c[1])
    x = int(c[2])

    l = list(map(int, c[3:3+n]))
    
    h = 0

    for k in range(n + 1):

        i = []
        for i in range(k):
            i.append((l[i], 1))

        i.append((x, 0))
        for i in range(k, n):
            i.append((l[i], 1))

        f = False
        if k - 1 >= 0 and i[k - 1][0] == x:
            f = True
        if k + 1 < len(i) and i[k + 1][0] == x:
            f = True
        if not f:
            continue

        e = n(i)

        j = sum(a[1] for a in e)

        d = n - j
        if d > h:
            h = d

    o.stdout.write(str(h))

if __name__ == '__main__':
    g()"
554,B,Ohana Cleans Up,PROGRAMMING,"['brute force', 'greedy', 'strings']","Ohana Matsumae is trying to clean a room, which is divided up into an *n* by *n* grid of squares. Each square is initially either clean or dirty. Ohana can sweep her broom over columns of the grid. Her broom is very strange: if she sweeps over a clean square, it will become dirty, and if she sweeps over a dirty square, it will become clean. She wants to sweep some columns of the room to maximize the number of rows that are completely clean. It is not allowed to sweep over the part of the column, Ohana can only sweep the whole column.

Return the maximum number of rows that she can make completely clean.","The first line of input will be a single integer *n* (1<=≤<=*n*<=≤<=100).

The next *n* lines will describe the state of the room. The *i*-th line will contain a binary string with *n* characters denoting the state of the *i*-th row of the room. The *j*-th character on this line is '1' if the *j*-th square in the *i*-th row is clean, and '0' if it is dirty.",The output should be a single line containing an integer equal to a maximum possible number of rows that are completely clean.,"['4\n0101\n1000\n1111\n0101\n', '3\n111\n111\n111\n']","['2\n', '3\n']","In the first sample, Ohana can sweep the 1st and 3rd columns. This will make the 1st and 4th row be completely clean.

In the second sample, everything is already clean, so Ohana doesn't need to do anything.",OK,"from collections import c

n = int(input())
a = 0
e = c()

for _ in range(n):

    d = str(input())

    if d in e:
        e[d] += 1
    else:
        e[d] = 1

    b = e[d]
    
    if b > a:
        a = b

print(a)","def c():
    import g
    d = 1000000007

    a = g.stdin.read().split()
    x = int(a[0])
    y = int(a[1])
    n = int(a[2])

    f = [x, y, y - x, -x, -y, x - y]

    b = (n - 1) % 6
    e = f[b] % d

    print(e)

if __name__ == '__main__':
    c()"
252,A,Little Xor,PROGRAMMING,"['brute force', 'implementation']","Little Petya likes arrays that consist of non-negative integers a lot. Recently his mom has presented him one such array consisting of *n* elements. Petya immediately decided to find there a segment of consecutive elements, such that the *xor* of all numbers from this segment was maximal possible. Help him with that.

The *xor* operation is the bitwise exclusive ""OR"", that is denoted as ""xor"" in Pascal and ""^"" in C/C++/Java.",The first line contains integer *n* (1<=≤<=*n*<=≤<=100) — the number of elements in the array. The second line contains the space-separated integers from the array. All numbers are non-negative integers strictly less than 230.,Print a single integer — the required maximal *xor* of a segment of consecutive elements.,"['5\n1 2 1 1 2\n', '3\n1 2 7\n', '4\n4 2 4 8\n']","['3\n', '7\n', '14\n']","In the first sample one of the optimal segments is the segment that consists of the first and the second array elements, if we consider the array elements indexed starting from one.

The second sample contains only one optimal segment, which contains exactly one array element (element with index three).",WRONG_ANSWER,"import bisect
import heapq
import math
import k
import 
import copy
from functools import 
import l
from io import b, d
import {

.setrecursionlimit(10 ** 9)
l.getcontext(). = l.ROUND_HALF_UP

r = k.defaultdict
~ = k.deque

class Graphs:
    def __init__():
        .graph = r(list)

    def g(, u, v):
        .graph[u].append(v)

    def n(, z, ):
        .add(z)
        for w in .graph[z]:
            if w not in :
                .n(w, )
            else:
                return w

    def m(, y):
        f = set()
        .n(y, f)

    def j(, y):
         = set()
        if y not in :
            ~.append(y)
            .add(y)
        while ~:
            | = ~.popleft()
            print(|)
            for t in .graph[|]:
                if t not in :
                    ~.append(t)
                    .add(t)

def (n):
    return int(l.Decimal(f'{n}').to_integral_value())

def o(n):
    return set((list.__add__,
                      ([i, n // i] for i in range(1, int(n ** 0.5) + 1) if n % i == 0)))

a = 8192

class c(d):
    x = 0

    def __init__(, p):
        ._fd = p.fileno()
        .buffer = b()
        .writable = ""x"" in p.mode or ""r"" not in p.mode
        .write = .buffer.write if .writable else None

    def ():
        while True:
            b = {.(._fd, max({.fstat(._fd).st_size, a))
            if not b:
                break
            } = .buffer.tell()
            .buffer.seek(0, 2), .buffer.write(b), .buffer.seek(})
        .x = 0
        return .buffer.()

    def ():
        while .x == 0:
            b = {.(._fd, max({.fstat(._fd).st_size, a))
            .x = b.count(b""\n"") + (not b)
            } = .buffer.tell()
            .buffer.seek(0, 2), .buffer.write(b), .buffer.seek(})
        .x -= 1
        return .buffer.()

    def q():
        if .writable:
            {.write(._fd, .buffer.getvalue())
            .buffer.truncate(0), .buffer.seek(0)

class e(d):
    def __init__(, p):
        .buffer = c(p)
        .q = .buffer.q
        .writable = .buffer.writable
        .write = lambda s: .buffer.write(s.encode(""ascii""))
        . = lambda: .buffer.().decode(""ascii"")
        . = lambda: .buffer.().decode(""ascii"")

.stdin, .stdout = e(.stdin), e(.stdout)

def s():
    return .stdin.().strip()

def v():
    return map(, s().split())

def u():
    return list(v())

n = int(s())
i = u(int)
h = 0
for i in range(n):
    h = max(i[i],h)
    for j in range(i + 1, n):
        h = max(h ^ i[j], h)
print(h)","def f():
    import i
    from collections import c

    b = i.stdin.read().split()
    if not b:
        return

    n = int(b[0])
    d = int(b[1])

    s = b[2]

    e = [-1] * n
    e[0] = 0

    h = c([0])

    while h:
        a = h.popleft()

        if a == n - 1:
            print(e[a])
            return

        for d in range(1, d + 1):
            g = a + d
            if g < n and s[g] == '1' and e[g] == -1:
                e[g] = e[a] + 1
                h.append(g)

    print(-1)

if __name__ == ""__main__"":
    f()"
281,A,Word Capitalization,PROGRAMMING,"['implementation', 'strings']","Capitalization is writing a word with its first letter as a capital letter. Your task is to capitalize the given word.

Note, that during capitalization all the letters except the first one remains unchanged.",A single line contains a non-empty word. This word consists of lowercase and uppercase English letters. The length of the word will not exceed 103.,Output the given word after capitalization.,"['ApPLe\n', 'konjac\n']","['ApPLe\n', 'Konjac\n']",none,OK,"def b(c):
    return c[0].upper() + c[1:]
    

def a():
    c = input().strip()
    print(b(c))

if __name__ == ""__main__"":
    a()","def c():

    n, m, k = map(int, input().split())

    b = (k - 1) // (2 * m) + 1

    d = (k - 1) % (2 * m)

    a = d // 2 + 1

    e = 'L' if d % 2 == 0 else 'R'

    print(b, a, e)

if __name__ == ""__main__"":
    c()"
59,A,Word,PROGRAMMING,"['implementation', 'strings']","Vasya is very upset that many people on the Net mix uppercase and lowercase letters in one word. That's why he decided to invent an extension for his favorite browser that would change the letters' register in every word so that it either only consisted of lowercase letters or, vice versa, only of uppercase ones. At that as little as possible letters should be changed in the word. For example, the word HoUse must be replaced with house, and the word ViP — with VIP. If a word contains an equal number of uppercase and lowercase letters, you should replace all the letters with lowercase ones. For example, maTRIx should be replaced by matrix. Your task is to use the given method on one given word.",The first line contains a word *s* — it consists of uppercase and lowercase Latin letters and possesses the length from 1 to 100.,"Print the corrected word *s*. If the given word *s* has strictly more uppercase letters, make the word written in the uppercase register, otherwise - in the lowercase one.","['HoUse\n', 'ViP\n', 'maTRIx\n']","['house\n', 'VIP\n', 'matrix\n']",none,WRONG_ANSWER,"def a(g):
    f = sum(1 for d in g if d.isupper())
    e = len(g) - f
    
    if f > e:
        return g.upper()
    else:
        return g.lower()

c = ""HoUse""
b = a(c)
print(b)","def b(g):

    if g < 1:
        return False
    j = int(g ** 0.5)
    return j * j == g

def c():
    import l

    a = l.stdin.read().splitlines()
    if not a:
        return

    s = a[0].strip()
    e = float('inf')
    f = len(s)

    for d in range(1, 1 << f):
        k = []

        for i in range(f):
            if d & (1 << i):
                k.append(s[i])

        if k[0] == '0':
            continue
        h = ''.join(k)
        g = int(h)
        if b(g):

            i = f - len(k)
            if i < e:
                e = i

    if e == float('inf'):
        print(-1)
    else:
        print(e)

if __name__ == '__main__':
    c()"
455,A,Boredom,PROGRAMMING,['dp'],"Alex doesn't like boredom. That's why whenever he gets bored, he comes up with games. One long winter evening he came up with a game and decided to play it.

Given a sequence *a* consisting of *n* integers. The player can make several steps. In a single step he can choose an element of the sequence (let's denote it *a**k*) and delete it, at that all elements equal to *a**k*<=+<=1 and *a**k*<=-<=1 also must be deleted from the sequence. That step brings *a**k* points to the player. 

Alex is a perfectionist, so he decided to get as many points as possible. Help him.","The first line contains integer *n* (1<=≤<=*n*<=≤<=105) that shows how many numbers are in Alex's sequence. 

The second line contains *n* integers *a*1, *a*2, ..., *a**n* (1<=≤<=*a**i*<=≤<=105).",Print a single integer — the maximum number of points that Alex can earn.,"['2\n1 2\n', '3\n1 2 3\n', '9\n1 2 1 3 2 2 2 2 3\n']","['2\n', '4\n', '10\n']","Consider the third test example. At first step we need to choose any element equal to 2. After that step our sequence looks like this [2, 2, 2, 2]. Then we do 4 steps, on each step we choose any element equals to 2. In total we earn 10 points.",WRONG_ANSWER,"def f(a):
    a.sort(reverse=True)
    a = {}
    for i in a:
        if i not in a: a[i] = 0
        a[i] += 1
    return max(a, key=a.get)

def g(a, k):
    h = list()
    for b in a:
        if not ((b == k - 1) or (b == k + 1)):
            h.append(b)
    h.remove(k)
    return h

def d(a):
    e = 0
    c = 0
    while len(a) > 0:
        k = f(a)
        a = g(a, k)
        e += k
    return e
    
n = int(input())
a = list(map(int, input().split()))
print(d(a))","def e():
    import f
    a = f.stdin.read().split()
    if not a:
        return
    n = int(a[0])

    a = list(map(int, a[1:]))
    a.sort()

    if n == 1:
        f.stdout.write(str(a[0]))
        return

    c = list(range(2, n + 1))
    c.append(n)

    g = 0
    for d, b in zip(a, c):
        g += d * b

    f.stdout.write(str(g))

if __name__ == '__main__':
    e()"
75,A,Life Without Zeros,PROGRAMMING,['implementation'],"Can you imagine our life if we removed all zeros from it? For sure we will have many problems.

In this problem we will have a simple example if we removed all zeros from our life, it's the addition operation. Let's assume you are given this equation *a*<=+<=*b*<==<=*c*, where *a* and *b* are positive integers, and *c* is the sum of *a* and *b*. Now let's remove all zeros from this equation. Will the equation remain correct after removing all zeros?

For example if the equation is 101<=+<=102<==<=203, if we removed all zeros it will be 11<=+<=12<==<=23 which is still a correct equation.

But if the equation is 105<=+<=106<==<=211, if we removed all zeros it will be 15<=+<=16<==<=211 which is not a correct equation.","The input will consist of two lines, the first line will contain the integer *a*, and the second line will contain the integer *b* which are in the equation as described above (1<=≤<=*a*,<=*b*<=≤<=109). There won't be any leading zeros in both. The value of *c* should be calculated as *c*<==<=*a*<=+<=*b*.","The output will be just one line, you should print ""YES"" if the equation will remain correct after removing all zeros, and print ""NO"" otherwise.","['101\n102\n', '105\n106\n']","['YES\n', 'NO\n']",none,RUNTIME_ERROR,"def c():
    d=""file""
    if d==""file"":f=open(""test.txt"",""r"")

    b = lambda :[int(x) for x in (f.readline() if d==""file"" else input()).split()]
    [a]=b()
    [b]=b()
    a=a+b
    a=list(str(a))
    if ""0"" in a:a.remove(""0"")
    a=int("""".join(a))
    b=list(str(b))
    if ""0"" in b:b.remove(""0"")
    b=int("""".join(b))
    c=list(str(a))
    if ""0"" in c:c.remove(""0"")
    c=int("""".join(c))
    a=a+b
    print(""YES"" if c==a else ""NO"")

    if d==""file"":f.close()

if __name__==""__main__"":
    c()","import 
import s

def j(p, q):
    return s.hypot(p[0] - q[0], p[1] - q[1])

def q(p, a, b, o=1e-9):

    e = (p[0] - a[0]) * (b[1] - a[1]) - (p[1] - a[1]) * (b[0] - a[0])
    if abs(e) > o:
        return False

    l = (p[0] - a[0]) * (p[0] - b[0]) + (p[1] - a[1]) * (p[1] - b[1])
    if l > o:
        return False
    return True

def k(P, Q, R):
    g = j(P, Q)
    h = j(Q, R)
    if g < 1e-9 or h < 1e-9:
        return 0
    return min(g, h) / max(g, h)

def b(P, A, B):
     = (A[0] - P[0], A[1] - P[1])
     = (B[0] - P[0], B[1] - P[1])
    l = [0] * [0] + [1] * [1]
    if l <= 1e-9:
        return False
    t = s.hypot([0], [1])
    u = s.hypot([0], [1])
    a = s.acos(min(1, max(-1, l / (t * u))))
    return a <= s.pi / 2 + 1e-9

def w():

    for i in range(3):
        for j in range(i + 1, 3):
            ~ = [i]
             = [j]
            m = [(~[0], ~[1]), (~[2], ~[3])]
            n = [([0], [1]), ([2], [3])]
            d = []
            for p in m:
                for q in n:
                    if p == q:
                        d.append(p)
            if not d:
                continue

            P = d[0]

            def v(}, c):
                a = (}[0], }[1])
                b = (}[2], }[3])
                if a == c:
                    return b
                elif b == c:
                    return a
                return None

            A = v(~, P)
            B = v(, P)
            if A is None or B is None:
                continue

            if not b(P, A, B):
                continue

            k = 3 - i - j
            f = [k]
            C = (f[0], f[1])
            D = (f[2], f[3])

            for x, y in [(C, D), (D, C)]:
                if q(x, P, A) and q(y, P, B):

                    if x == P or y == P:
                        continue
                    z = k(P, x, A)
                    { = k(P, y, B)
                    if z >= 0.25 - 1e-9 and { >= 0.25 - 1e-9:
                        return True
    return False

def r():
    i = .stdin.read().split()
    if not i:
        return
    t = int(i[0])
    p = 1
    | = []
    for _ in range(t):
         = []
        for _ in range(3):
             = int(i[p])
             = int(i[p + 1])
             = int(i[p + 2])
             = int(i[p + 3])
            p += 4
            .append((, , , ))
        if w():
            |.append(""YES"")
        else:
            |.append(""NO"")
    .stdout.write(""\n"".join(|))

if __name__ == '__main__':
    r()"
408,A,Line to Cashier,PROGRAMMING,['implementation'],"Little Vasya went to the supermarket to get some groceries. He walked about the supermarket for a long time and got a basket full of products. Now he needs to choose the cashier to pay for the products.

There are *n* cashiers at the exit from the supermarket. At the moment the queue for the *i*-th cashier already has *k**i* people. The *j*-th person standing in the queue to the *i*-th cashier has *m**i*,<=*j* items in the basket. Vasya knows that:
 -  the cashier needs 5 seconds to scan one item; -  after the cashier scans each item of some customer, he needs 15 seconds to take the customer's money and give him the change. 
Of course, Vasya wants to select a queue so that he can leave the supermarket as soon as possible. Help him write a program that displays the minimum number of seconds after which Vasya can get to one of the cashiers.","The first line contains integer *n* (1<=≤<=*n*<=≤<=100) — the number of cashes in the shop. The second line contains *n* space-separated integers: *k*1,<=*k*2,<=...,<=*k**n* (1<=≤<=*k**i*<=≤<=100), where *k**i* is the number of people in the queue to the *i*-th cashier.

The *i*-th of the next *n* lines contains *k**i* space-separated integers: *m**i*,<=1,<=*m**i*,<=2,<=...,<=*m**i*,<=*k**i* (1<=≤<=*m**i*,<=*j*<=≤<=100) — the number of products the *j*-th person in the queue for the *i*-th cash has.",Print a single integer — the minimum number of seconds Vasya needs to get to the cashier.,"['1\n1\n1\n', '4\n1 4 3 2\n100\n1 2 2 3\n1 9 1\n7 8\n']","['20\n', '100\n']","In the second test sample, if Vasya goes to the first queue, he gets to the cashier in 100·5 + 15 = 515 seconds. But if he chooses the second queue, he will need 1·5 + 2·5 + 2·5 + 3·5 + 4·15 = 100 seconds. He will need 1·5 + 9·5 + 1·5 + 3·15 = 100 seconds for the third one and 7·5 + 8·5 + 2·15 = 105 seconds for the fourth one. Thus, Vasya gets to the cashier quicker if he chooses the second or the third queue.",OK,"def c():
    n = int(input())
    a = [int(i) for i in input().split()]
    b = float(""inf"")
    for i in range(n):
        a = [int(k) for k in input().split()]
        s = 0
        for j in range(len(a)):
            s+=a[j]*5
        s+=15*a[i]
        b = min(b,s)
    print(b)
    return

c()","import g

def e():

    c = g.stdin.read().splitlines()

    n = int(c[0])
    j = c[1:n+1]
    
    f = 0

    for b in ""abcdefghijklmnopqrstuvwxyz"":
        h = 0
        for i in j:

            if all(c == b for c in i):
                h += len(i)
        f = max(f, h)

    d = ""abcdefghijklmnopqrstuvwxyz""
    for i in range(len(d)):
        for j in range(i+1, len(d)):
            a = {d[i], d[j]}
            h = 0
            for i in j:

                if all(c in a for c in i):
                    h += len(i)
            f = max(f, h)

    print(f)

if __name__ == '__main__':
    e()"
230,B,T-primes,PROGRAMMING,"['binary search', 'implementation', 'math', 'number theory']","We know that prime numbers are positive integers that have exactly two distinct positive divisors. Similarly, we'll call a positive integer *t* Т-prime, if *t* has exactly three distinct positive divisors.

You are given an array of *n* positive integers. For each of them determine whether it is Т-prime or not.","The first line contains a single positive integer, *n* (1<=≤<=*n*<=≤<=105), showing how many numbers are in the array. The next line contains *n* space-separated integers *x**i* (1<=≤<=*x**i*<=≤<=1012).

Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is advised to use the cin, cout streams or the %I64d specifier.","Print *n* lines: the *i*-th line should contain ""YES"" (without the quotes), if number *x**i* is Т-prime, and ""NO"" (without the quotes), if it isn't.",['3\n4 5 6\n'],['YES\nNO\nNO\n'],"The given test has three numbers. The first number 4 has exactly three divisors — 1, 2 and 4, thus the answer for this number is ""YES"". The second number 5 has two divisors (1 and 5), and the third number 6 has four divisors (1, 2, 3, 6), hence the answer for them is ""NO"".",TIME_LIMIT_EXCEEDED,"from sys import h
def input(): return h.readline()[:-1]
def e(): return list(map(int, input().split()))
import f
from collections import d

def c(n):
    d = d(lambda : 0)
    while n % 2 == 0:
        d[2] += 1
        n = n // 2
    for i in range(3, int(f.sqrt(n))+1, 2):
        while n % i == 0:
            d[i] += 1
            n = n // i
    if n > 2:
        d[n] += 1
    if len(d.keys()) == 1 and list(d.values())[0] == 2:
        return True
    return False

def g():
    n = int(input())
    s = e()
    for i in s:
        if i == 1:
            print(""NO"")
            continue
        print(""YES"") if c(i) else print(""NO"")

b = 1

for a in range(b):
    g()","def c():
    import e
    b = e.stdin.read().split()

    n = int(b[0])
    k = int(b[1])

    d = list(map(int, b[2:2+n]))

    a = sum(1 for y in d if y + k <= 5)

    print(a // 3)

if __name__ == ""__main__"":
    c()"
741,B,Arpa's weak amphitheater and Mehrdad's valuable Hoses,PROGRAMMING,"['dfs and similar', 'dp', 'dsu']","Just to remind, girls in Arpa's land are really nice.

Mehrdad wants to invite some Hoses to the palace for a dancing party. Each Hos has some weight *w**i* and some beauty *b**i*. Also each Hos may have some friends. Hoses are divided in some friendship groups. Two Hoses *x* and *y* are in the same friendship group if and only if there is a sequence of Hoses *a*1,<=*a*2,<=...,<=*a**k* such that *a**i* and *a**i*<=+<=1 are friends for each 1<=≤<=*i*<=&lt;<=*k*, and *a*1<==<=*x* and *a**k*<==<=*y*.

Arpa allowed to use the amphitheater of palace to Mehrdad for this party. Arpa's amphitheater can hold at most *w* weight on it. 

Mehrdad is so greedy that he wants to invite some Hoses such that sum of their weights is not greater than *w* and sum of their beauties is as large as possible. Along with that, from each friendship group he can either invite all Hoses, or no more than one. Otherwise, some Hoses will be hurt. Find for Mehrdad the maximum possible total beauty of Hoses he can invite so that no one gets hurt and the total weight doesn't exceed *w*.","The first line contains integers *n*, *m* and *w* (1<=<=≤<=<=*n*<=<=≤<=<=1000, , 1<=≤<=*w*<=≤<=1000) — the number of Hoses, the number of pair of friends and the maximum total weight of those who are invited.

The second line contains *n* integers *w*1,<=*w*2,<=...,<=*w**n* (1<=≤<=*w**i*<=≤<=1000) — the weights of the Hoses.

The third line contains *n* integers *b*1,<=*b*2,<=...,<=*b**n* (1<=≤<=*b**i*<=≤<=106) — the beauties of the Hoses.

The next *m* lines contain pairs of friends, the *i*-th of them contains two integers *x**i* and *y**i* (1<=≤<=*x**i*,<=*y**i*<=≤<=*n*, *x**i*<=≠<=*y**i*), meaning that Hoses *x**i* and *y**i* are friends. Note that friendship is bidirectional. All pairs (*x**i*,<=*y**i*) are distinct.",Print the maximum possible total beauty of Hoses Mehrdad can invite so that no one gets hurt and the total weight doesn't exceed *w*.,"['3 1 5\n3 2 5\n2 4 2\n1 2\n', '4 2 11\n2 4 6 6\n6 4 2 1\n1 2\n2 3\n']","['6\n', '7\n']","In the first sample there are two friendship groups: Hoses {1, 2} and Hos {3}. The best way is to choose all of Hoses in the first group, sum of their weights is equal to 5 and sum of their beauty is 6.

In the second sample there are two friendship groups: Hoses {1, 2, 3} and Hos {4}. Mehrdad can't invite all the Hoses from the first group because their total weight is 12 &gt; 11, thus the best way is to choose the first Hos from the first group and the only one from the second group. The total weight will be 8, and the total beauty will be 7.",OK,"def g(x):
    if x == t[x]: return x
    t[x] = g(t[x])
    return t[x]

f = lambda: map(int, input().split())
d, f, g = f()
h = [(0, 0)] + list(zip(f(), f()))
t = list(range(d + 1))

for i in range(f):
    b, c = f()
    b, c = g(b), g(c)
    if b != c:
        t[c] = b

p = [[] for j in range(d + 1)]
for i in range(1, d + 1):
    p[g(i)].append(i)

a = [1] + [0] * g
for q in p:
    if len(q) > 1:
        t = [h[i] for i in q]
        t.append((sum(b[0] for b in t), sum(b[1] for b in t)))
        t.sort(key=lambda b: b[0])

        for j in range(g, -1, -1):
            if a[j]:
                for w, b in t:
                    if j + w > g:
                        break
                    else:
                        a[j + w] = max(a[j + w], a[j] + b)
    elif len(q) == 1:
        w, b = h[q[0]]
        for j in range(g - w, -1, -1):
            if a[j]:
                a[j + w] = max(a[j + w], a[j] + b)

e = max(a) - 1
print(e)","def n():
    import o, a
    c = o.stdin.read().split()
    if not c:
        return

    h = iter(c)
    n = int(next(h))
    m = int(next(h))
    k = int(next(h))
    q = int(next(h))

    d = []

    for _ in range(q):
        x = int(next(h)) - 1
        y = int(next(h)) - 1
        t = int(next(h))
        d.append((t, x, y))

    d.sort(key=lambda e: e[0])

    p = [e[0] for e in d]

    def b(T):

        e = [[0] * m for _ in range(n)]

        g = a.bisect_right(p, T)
        for i in range(g):
            _, x, y = d[i]
            e[x][y] = 1

        k = [[0] * (m + 1) for _ in range(n + 1)]
        for i in range(1, n + 1):
            m = 0
            for j in range(1, m + 1):
                m += e[i - 1][j - 1]
                k[i][j] = k[i - 1][j] + m

        for i in range(n - k + 1):
            for j in range(m - k + 1):
                q = k[i + k][j + k] - k[i][j + k] - k[i + k][j] + k[i][j]
                if q == k * k:
                    return True
        return False

    i = 0
    if q:
        f = d[-1][0]
    else:
        f = 0
    l = None
    while i <= f:
        j = (i + f) // 2
        if b(j):
            l = j
            f = j - 1
        else:
            i = j + 1
    o.stdout.write(str(l) if l is not None else ""-1"")

if __name__ == '__main__':
    n()"
710,A,King Moves,PROGRAMMING,['implementation'],"The only king stands on the standard chess board. You are given his position in format ""cd"", where *c* is the column from 'a' to 'h' and *d* is the row from '1' to '8'. Find the number of moves permitted for the king.

Check the king's moves here [https://en.wikipedia.org/wiki/King_(chess)](https://en.wikipedia.org/wiki/King_(chess)).","The only line contains the king's position in the format ""cd"", where 'c' is the column from 'a' to 'h' and 'd' is the row from '1' to '8'.",Print the only integer *x* — the number of moves permitted for the king.,['e4\n'],['8\n'],none,OK,"from sys import e, stdout
def a():
	return e.readline().rstrip()

def b():
	return int(a())

def c():
	return list(map(int, a().split()))

def d():
	a=a()
	c=0
	if a[0]=='a' or a[0]=='h':
		c+=1
	if a[1]=='1' or a[1]=='8':
		c+=1
	if c==0:
		print(8)
	elif c==1:
		print(5)
	else:
		print(3)

d()","def c():
    import h

    a = h.stdin.read().split()
    b = iter(a)

    n = int(next(b))

    v = [int(next(b)) for _ in range(n)]

    e = [0] * (n + 1)
    for i in range(1, n + 1):
        e[i] = e[i - 1] + v[i - 1]

    j = sorted(v)
    f = [0] * (n + 1)
    for i in range(1, n + 1):
        f[i] = f[i - 1] + j[i - 1]

    m = int(next(b))

    d = []
    for _ in range(m):
        i = int(next(b))
        l = int(next(b))
        r = int(next(b))
        if i == 1:

            g = e[r] - e[l - 1]
        else:

            g = f[r] - f[l - 1]
        d.append(str(g))

    h.stdout.write(""\n"".join(d))

if __name__ == '__main__':
    c()"
322,B,Ciel and Flowers,PROGRAMMING,"['combinatorics', 'math']","Fox Ciel has some flowers: *r* red flowers, *g* green flowers and *b* blue flowers. She wants to use these flowers to make several bouquets. There are 4 types of bouquets:
 -  To make a ""red bouquet"", it needs 3 red flowers. -  To make a ""green bouquet"", it needs 3 green flowers. -  To make a ""blue bouquet"", it needs 3 blue flowers. -  To make a ""mixing bouquet"", it needs 1 red, 1 green and 1 blue flower. 
Help Fox Ciel to find the maximal number of bouquets she can make.","The first line contains three integers *r*, *g* and *b* (0<=≤<=*r*,<=*g*,<=*b*<=≤<=109) — the number of red, green and blue flowers.",Print the maximal number of bouquets Fox Ciel can make.,"['3 6 9\n', '4 4 4\n', '0 0 0\n']","['6\n', '4\n', '0\n']","In test case 1, we can make 1 red bouquet, 2 green bouquets and 3 blue bouquets.

In test case 2, we can make 1 red, 1 green, 1 blue and 1 mixing bouquet.",WRONG_ANSWER,"from sys import d,stdout
d.readline
def c(): return list(map(int, d.readline().strip().split()))
def b():return int(d.readline().strip())
from collections import defaultdict as dd,Counter as C,deque
from math import ceil,gcd,sqrt,factorial,log2,floor
from bisect import bisect_right as br,bisect_left as bl
import heapq

r,g,b = c()
a = min(r,g,b)
r -= a
g -= a
b -= a
a += r//3
a += g//3
a += b//3
print(a)","def g():
    import k
    a = k.stdin.read().split()
    if not a:
        return

    n = int(a[0])
    j = []
    d = 1

    for i in range(n):
        i = list(map(int, a[d:d + 5]))
        d += 5
        j.append(i)

    f = n if n < 100 else 100

    c = []

    for i in range(f):
        e = True

        for j in range(n):
            if j == i:
                continue
            for k in range(j + 1, n):
                if k == i:
                    continue
                b = 0

                for d in range(5):
                    b += (j[j][d] - j[i][d]) * (j[k][d] - j[i][d])

                if b > 0:
                    e = False
                    break
            if not e:
                break
        if e:

            c.append(i + 1)

    c.sort()
    h = [str(len(c))]
    h.extend(str(d) for d in c)
    k.stdout.write(""\n"".join(h))

if __name__ == '__main__':
    g()"
912,B,New Year's Eve,PROGRAMMING,"['bitmasks', 'constructive algorithms', 'number theory']","Since Grisha behaved well last year, at New Year's Eve he was visited by Ded Moroz who brought an enormous bag of gifts with him! The bag contains *n* sweet candies from the good ol' bakery, each labeled from 1 to *n* corresponding to its tastiness. No two candies have the same tastiness.

The choice of candies has a direct effect on Grisha's happiness. One can assume that he should take the tastiest ones — but no, the holiday magic turns things upside down. It is the xor-sum of tastinesses that matters, not the ordinary sum!

A xor-sum of a sequence of integers *a*1,<=*a*2,<=...,<=*a**m* is defined as the bitwise XOR of all its elements: , here  denotes the bitwise XOR operation; more about bitwise XOR can be found [here.](https://en.wikipedia.org/wiki/Bitwise_operation#XOR)

Ded Moroz warned Grisha he has more houses to visit, so Grisha can take no more than *k* candies from the bag. Help Grisha determine the largest xor-sum (largest xor-sum means maximum happiness!) he can obtain.",The sole string contains two integers *n* and *k* (1<=≤<=*k*<=≤<=*n*<=≤<=1018).,Output one number — the largest possible xor-sum.,"['4 3\n', '6 6\n']","['7\n', '7\n']","In the first sample case, one optimal answer is 1, 2 and 4, giving the xor-sum of 7.

In the second sample case, one can, for example, take all six candies and obtain the xor-sum of 7.",OK,"def d(a) :
    a[0] = 1
    for b in range(1,60) :
        a[b] = a[b-1]*2

def e(n,k,c) :
    if k == 1 :
        return n
        
    else :
        for b in range(59,-1,-1):
            if c[b] <= n :
                return c[b] + (c[b] - 1)

a = [0] * 60
n,k = list(map(int,input().split()))
d(a)
print (e(n,k,a))","def a():

    c = {
        ""Tetrahedron"": 4,
        ""Cube"": 6,
        ""Octahedron"": 8,
        ""Dodecahedron"": 12,
        ""Icosahedron"": 20
    }

    n = int(input().strip())
    
    d = 0

    for _ in range(n):
        b = input().strip()

        d += c.get(b, 0)

    print(d)

if __name__ == ""__main__"":
    a()"
948,A,Protect Sheep,PROGRAMMING,"['brute force', 'dfs and similar', 'graphs', 'implementation']","Bob is a farmer. He has a large pasture with many sheep. Recently, he has lost some of them due to wolf attacks. He thus decided to place some shepherd dogs in such a way that all his sheep are protected.

The pasture is a rectangle consisting of *R*<=×<=*C* cells. Each cell is either empty, contains a sheep, a wolf or a dog. Sheep and dogs always stay in place, but wolves can roam freely around the pasture, by repeatedly moving to the left, right, up or down to a neighboring cell. When a wolf enters a cell with a sheep, it consumes it. However, no wolf can enter a cell with a dog.

Initially there are no dogs. Place dogs onto the pasture in such a way that no wolf can reach any sheep, or determine that it is impossible. Note that since you have many dogs, you do not need to minimize their number.","First line contains two integers *R* (1<=≤<=*R*<=≤<=500) and *C* (1<=≤<=*C*<=≤<=500), denoting the number of rows and the numbers of columns respectively.

Each of the following *R* lines is a string consisting of exactly *C* characters, representing one row of the pasture. Here, 'S' means a sheep, 'W' a wolf and '.' an empty cell.","If it is impossible to protect all sheep, output a single line with the word ""No"".

Otherwise, output a line with the word ""Yes"". Then print *R* lines, representing the pasture after placing dogs. Again, 'S' means a sheep, 'W' a wolf, 'D' is a dog and '.' an empty space. You are not allowed to move, remove or add a sheep or a wolf.

If there are multiple solutions, you may print any of them. You don't have to minimize the number of dogs.","['6 6\n..S...\n..S.W.\n.S....\n..W...\n...W..\n......\n', '1 2\nSW\n', '5 5\n.S...\n...S.\nS....\n...S.\n.S...\n']","['Yes\n..SD..\n..SDW.\n.SD...\n.DW...\nDD.W..\n......\n', 'No\n', 'Yes\n.S...\n...S.\nS.D..\n...S.\n.S...\n']","In the first example, we can split the pasture into two halves, one containing wolves and one containing sheep. Note that the sheep at (2,1) is safe, as wolves cannot move diagonally.

In the second example, there are no empty spots to put dogs that would guard the lone sheep.

In the third example, there are no wolves, so the task is very easy. We put a dog in the center to observe the peacefulness of the meadow, but the solution would be correct even without him.",WRONG_ANSWER,"R, C = list(map(int, input().split()))
d = []
for _ in range(R):
    f = list(input())
    d.append(f)
j = [[0 for _ in range(C)] for _ in range(R)]

a = [(1, 0), (-1, 0), (0, 1), (0, -1)]

def e(r, c):
    return 0 <= r < R and 0 <= c < C

def i(r, c):
    j[r][c] = 1
    for b in a:
        h = r + b[0]
        g = c + b[1]
        if e(h, g):
            if d[h][g] == 'W':
                return False
            if d[h][g] == '.':
                d[h][g] = 'D'
    return True

for i in range(R):
    c = False
    for j in range(C):
      if d[i][j] == 'S':
        if not i(i, j):
            c = True
            print(""NO"")
    if c:
        break

if not c:
    print(""YES"")
    for f in d:
      print(''.join(f))","import e

def b():

    a = e.stdin.read().split()
    if not a:
        return
    n = int(a[0])
    k = int(a[1])
    d = list(map(int, a[2:2+n]))

    f = d[k-1]

    for i in range(k, n):
        if d[i] != f:
            print(-1)
            return

    c = 0
    for i in range(k-2, -1, -1):
        if d[i] != f:
            c = i + 1
            break

    print(c)

if __name__ == '__main__':
    b()"
909,A,Generate Login,PROGRAMMING,"['brute force', 'greedy', 'sortings']","The preferred way to generate user login in Polygon is to concatenate a prefix of the user's first name and a prefix of their last name, in that order. Each prefix must be non-empty, and any of the prefixes can be the full name. Typically there are multiple possible logins for each person.

You are given the first and the last name of a user. Return the alphabetically earliest login they can get (regardless of other potential Polygon users).

As a reminder, a prefix of a string *s* is its substring which occurs at the beginning of *s*: ""a"", ""ab"", ""abc"" etc. are prefixes of string ""{abcdef}"" but ""b"" and 'bc"" are not. A string *a* is alphabetically earlier than a string *b*, if *a* is a prefix of *b*, or *a* and *b* coincide up to some position, and then *a* has a letter that is alphabetically earlier than the corresponding letter in *b*: ""a"" and ""ab"" are alphabetically earlier than ""ac"" but ""b"" and ""ba"" are alphabetically later than ""ac"".","The input consists of a single line containing two space-separated strings: the first and the last names. Each character of each string is a lowercase English letter. The length of each string is between 1 and 10, inclusive.",Output a single string — alphabetically earliest possible login formed from these names. The output should be given in lowercase as well.,"['harry potter\n', 'tom riddle\n']","['hap\n', 'tomr\n']",none,OK,"def a(s):
	c = [s[0]]
	for i in range(1, len(s)):
		x = c[i-1] + s[i]
		c.append(x)
	return c
 
n, m = input().split()

a, b = a(n), a(m)
b = a[0] + b[0]
for i in a:
	for j in b:
		if i+j < b:
			b = i+j
print(b)","def f():
    import g
    from collections import a

    c = g.stdin.read().splitlines()
    if not c:
        return
    s = c[0].strip()

    d = a(s)

    e = sum(1 for b in d.values() if b % 2 != 0)

    if e <= 1 or e % 2 == 1:
        g.stdout.write(""First"")
    else:
        g.stdout.write(""Second"")

if __name__ == ""__main__"":
    f()"
995,C,Leaving the Bar,PROGRAMMING,"['brute force', 'data structures', 'geometry', 'greedy', 'math', 'sortings']","For a vector $\vec{v} = (x, y)$, define $|v| = \sqrt{x^2 + y^2}$.

Allen had a bit too much to drink at the bar, which is at the origin. There are $n$ vectors $\vec{v_1}, \vec{v_2}, \cdots, \vec{v_n}$. Allen will make $n$ moves. As Allen's sense of direction is impaired, during the $i$-th move he will either move in the direction $\vec{v_i}$ or $-\vec{v_i}$. In other words, if his position is currently $p = (x, y)$, he will either move to $p + \vec{v_i}$ or $p - \vec{v_i}$.

Allen doesn't want to wander too far from home (which happens to also be the bar). You need to help him figure out a sequence of moves (a sequence of signs for the vectors) such that his final position $p$ satisfies $|p| \le 1.5 \cdot 10^6$ so that he can stay safe.","The first line contains a single integer $n$ ($1 \le n \le 10^5$) — the number of moves.

Each of the following lines contains two space-separated integers $x_i$ and $y_i$, meaning that $\vec{v_i} = (x_i, y_i)$. We have that $|v_i| \le 10^6$ for all $i$.","Output a single line containing $n$ integers $c_1, c_2, \cdots, c_n$, each of which is either $1$ or $-1$. Your solution is correct if the value of $p = \sum_{i = 1}^n c_i \vec{v_i}$, satisfies $|p| \le 1.5 \cdot 10^6$.

It can be shown that a solution always exists under the given constraints.","['3\n999999 0\n0 999999\n999999 0\n', '1\n-824590 246031\n', '8\n-67761 603277\n640586 -396671\n46147 -122580\n569609 -2112\n400 914208\n131792 309779\n-850150 -486293\n5272 721899\n']","['1 1 -1 \n', '1 \n', '1 1 1 1 1 1 1 -1 \n']",none,WRONG_ANSWER,"n = int(input())

e = []
g, i = 0, 0
for _ in range(n):
    a, b = [int(x) for x in input().split()]
    g += a
    i += b
    e.append((a, b))

def d(x):
    return x[0] ** 2 + x[1] ** 2

def a(x, y):
    return (x[0] + y[0], x[1] + y[1])
def f(x, y):
    return (x[0] - y[0], x[1] - y[1])

h = 2.25 * 10 ** 12

b = [1 for _ in range(n)]

v = (g, i)
c = d(v)
for i, j in enumerate(e):
    j = (2*j[0], 2*j[1])
    if d(f(v, j)) < c:
        v = f(v, j)
        c = d(v)
        b[i] = -1

print("" "".join(map(str, b)))","b = input().strip()

a = set(b)

if len(a) % 2 == 0:

    print(""CHAT WITH HER!"")
else:

    print(""IGNORE HIM!"")"
16,C,Monitor,PROGRAMMING,"['binary search', 'number theory']","Reca company makes monitors, the most popular of their models is AB999 with the screen size *a*<=×<=*b* centimeters. Because of some production peculiarities a screen parameters are integer numbers. Recently the screen sides ratio *x*:<=*y* became popular with users. That's why the company wants to reduce monitor AB999 size so that its screen sides ratio becomes *x*:<=*y*, at the same time they want its total area to be maximal of all possible variants. Your task is to find the screen parameters of the reduced size model, or find out that such a reduction can't be performed.","The first line of the input contains 4 integers — *a*, *b*, *x* and *y* (1<=≤<=*a*,<=*b*,<=*x*,<=*y*<=≤<=2·109).","If the answer exists, output 2 positive integers — screen parameters of the reduced size model. Output 0 0 otherwise.","['800 600 4 3\n', '1920 1200 16 9\n', '1 1 1 2\n']","['800 600\n', '1920 1080\n', '0 0\n']",none,TIME_LIMIT_EXCEEDED,"def a(s):
    j = 0
    a = []
    for i in range(len(s)):
        if s[i] == "" "":
            a.append(int(s[j:i]))
            j = i+1
        if i == len(s)-1:
            a.append(int(s[j:]))
    return a

s = input()
a = a(s)
p = 0
q = 0
for i in range(a[0],-1,-1):
    x = (i*a[3])/a[2]
    if x%1 == 0:
        p = i
        break

for j in range(a[1],-1,-1):
    y = (i*a[2])/a[3]
    if y%1 == 0:
        q = j
        break

if x <= a[1] and y<= a[0]:
    if q*y > p*x:
        print (str(int(y))+"" ""+str(q))
    else:
        print (str(p)+"" ""+str(int(x)))
        
elif x <= a[1] and y > a[0]:
    print (str(int(p))+"" ""+str(int(x)))

elif x > a[1] and y <= a[0]:
    print (str(int(y))+"" ""+str(q))
elif x == 0 and y == 0:
    print (""0 0"")
else:
    print (""0 0"")","import e

def b():

    a = e.stdin.read().split()
    if not a:
        return

    n = int(a[0])
    k = int(a[1])

    d = [int(x) for x in a[2:2+n]]

    f = d[k-1]

    for i in range(k, n):
        if d[i] != f:

            print(-1)
            return

    c = -1
    for i in range(k-1, -1, -1):
        if d[i] != f:
            c = i
            break

    print(c + 1)

if __name__ == '__main__':
    b()"
535,B,Tavas and SaDDas,PROGRAMMING,"['bitmasks', 'brute force', 'combinatorics', 'implementation']","Once again Tavas started eating coffee mix without water! Keione told him that it smells awful, but he didn't stop doing that. That's why Keione told his smart friend, SaDDas to punish him! SaDDas took Tavas' headphones and told him: ""If you solve the following problem, I'll return it to you.""

The problem is: 

You are given a lucky number *n*. Lucky numbers are the positive integers whose decimal representations contain only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.

If we sort all lucky numbers in increasing order, what's the 1-based index of *n*? 

Tavas is not as smart as SaDDas, so he asked you to do him a favor and solve this problem so he can have his headphones back.",The first and only line of input contains a lucky number *n* (1<=≤<=*n*<=≤<=109).,Print the index of *n* among all lucky numbers.,"['4\n', '7\n', '77\n']","['1\n', '2\n', '6\n']",none,OK,"import math
def d(n):
    b = 1
    for i in range(2, n+1):
        b*= i
    return b
def c(n, c):
    return d(n)//(d(n-c)*c)

n= int(input())
if(n==4):
    print(1)
elif(n==7):
    print(2)
else:
    a = 2
    b = 0
    n = str(n)
    for i in range(len(n)):
        b+=(2**i)
    g = (2**len(n))
    e = 1
    h = g
    i = 0
    while(e < h and i < len(n)):
        f = (e+h)//2
        if(n[i]=='4'):
            h = f
        else:
            e = f+1
        i+=1
    b+=e-1
    print(b)","def c():
    import f
    b = f.stdin.read().strip().split()
    if not b:
        return

    n = int(b[0])

    d = list(map(int, b[1:n]))

    a = list(map(int, b[n: n+n]))

    e = 1

    for i in range(1, n):
        if a[i] != a[d[i-1] - 1]:
            e += 1
    
    print(e)

if __name__ == '__main__':
    c()"
791,A,Bear and Big Brother,PROGRAMMING,['implementation'],"Bear Limak wants to become the largest of bears, or at least to become larger than his brother Bob.

Right now, Limak and Bob weigh *a* and *b* respectively. It's guaranteed that Limak's weight is smaller than or equal to his brother's weight.

Limak eats a lot and his weight is tripled after every year, while Bob's weight is doubled after every year.

After how many full years will Limak become strictly larger (strictly heavier) than Bob?",The only line of the input contains two integers *a* and *b* (1<=≤<=*a*<=≤<=*b*<=≤<=10) — the weight of Limak and the weight of Bob respectively.,"Print one integer, denoting the integer number of years after which Limak will become strictly larger than Bob.","['4 7\n', '4 9\n', '1 1\n']","['2\n', '3\n', '1\n']","In the first sample, Limak weighs 4 and Bob weighs 7 initially. After one year their weights are 4·3 = 12 and 7·2 = 14 respectively (one weight is tripled while the other one is doubled). Limak isn't larger than Bob yet. After the second year weights are 36 and 28, so the first weight is greater than the second one. Limak became larger than Bob after two years so you should print 2.

In the second sample, Limak's and Bob's weights in next years are: 12 and 18, then 36 and 36, and finally 108 and 72 (after three years). The answer is 3. Remember that Limak wants to be larger than Bob and he won't be satisfied with equal weights.

In the third sample, Limak becomes larger than Bob after the first year. Their weights will be 3 and 2 then.",MEMORY_LIMIT_EXCEEDED,"def c(L, B):
    d = 0
    while L < B:
        L = L * 3
        B = B * 2
        d += 1
    return (d)

b, a = input().split()

print (c(b, a))","import l

def g():

    c = l.stdin.read().splitlines()
    if not c:
        return
    n = int(c[0].strip())
    s = c[1].strip()

    i = set(s)
    j = len(i)

    b = {}

    h = n + 1
    e = 0
    d = 0

    for k in range(n):
        a = s[k]
        b[a] = b.get(a, 0) + 1

        if b[a] == 1:
            d += 1

        while d == j and e <= k:
            m = k - e + 1
            if m < h:
                h = m

            f = s[e]
            b[f] -= 1

            if b[f] == 0:
                d -= 1
            e += 1

    l.stdout.write(str(h) + ""\n"")

if __name__ == '__main__':
    g()"
33,A,What is for dinner?,PROGRAMMING,"['greedy', 'implementation']","In one little known, but very beautiful country called Waterland, lives a lovely shark Valerie. Like all the sharks, she has several rows of teeth, and feeds on crucians. One of Valerie's distinguishing features is that while eating one crucian she uses only one row of her teeth, the rest of the teeth are ""relaxing"".

For a long time our heroine had been searching the sea for crucians, but a great misfortune happened. Her teeth started to ache, and she had to see the local dentist, lobster Ashot. As a professional, Ashot quickly relieved Valerie from her toothache. Moreover, he managed to determine the cause of Valerie's developing caries (for what he was later nicknamed Cap).

It turned that Valerie eats too many crucians. To help Valerie avoid further reoccurrence of toothache, Ashot found for each Valerie's tooth its residual viability. Residual viability of a tooth is a value equal to the amount of crucians that Valerie can eat with this tooth. Every time Valerie eats a crucian, viability of all the teeth used for it will decrease by one. When the viability of at least one tooth becomes negative, the shark will have to see the dentist again. 

Unhappy, Valerie came back home, where a portion of crucians was waiting for her. For sure, the shark couldn't say no to her favourite meal, but she had no desire to go back to the dentist. That's why she decided to eat the maximum amount of crucians from the portion but so that the viability of no tooth becomes negative. 

As Valerie is not good at mathematics, she asked you to help her to find out the total amount of crucians that she can consume for dinner.

We should remind you that while eating one crucian Valerie uses exactly one row of teeth and the viability of each tooth from this row decreases by one.","The first line contains three integers *n*, *m*, *k* (1<=≤<=*m*<=≤<=*n*<=≤<=1000,<=0<=≤<=*k*<=≤<=106) — total amount of Valerie's teeth, amount of tooth rows and amount of crucians in Valerie's portion for dinner. Then follow *n* lines, each containing two integers: *r* (1<=≤<=*r*<=≤<=*m*) — index of the row, where belongs the corresponding tooth, and *c* (0<=≤<=*c*<=≤<=106) — its residual viability.

It's guaranteed that each tooth row has positive amount of teeth.",In the first line output the maximum amount of crucians that Valerie can consume for dinner.,"['4 3 18\n2 3\n1 2\n3 6\n2 3\n', '2 2 13\n1 13\n2 12\n']","['11\n', '13\n']",none,RUNTIME_ERROR,"import |
import 

import numpy as y
import 
import .x as x
import .x.functional as F
from .autograd import d

.path.append(|.path.dirname(|.path.abspath(e)))
from utils import , v, m
from load_data import ~
import 

class a(x.Module):
    '''Pre-activation version of the BasicBlock.'''
    k = 1
    
    def __init__(, n, , =1):
        super(a, ).__init__()
        .bn1 = x.BatchNorm2d(n)
        .conv1 = x.Conv2d(n, , kernel_size=3, =, padding=1, bias=False)
        .bn2 = x.BatchNorm2d()
        .conv2 = x.Conv2d(, , kernel_size=3, =1, padding=1, bias=False)
        
        if  != 1 or n != .k * :
            . = x.Sequential(
                x.Conv2d(n, .k * , kernel_size=1, =, bias=False)
            )
    
    def l(, x):
        } = F.relu(.bn1(x))
         = .(}) if hasattr(, 'shortcut') else x
        } = .conv1(})
        } = .conv2(F.relu(.bn2(})))
        } += 
        return }

class b(x.Module):
    '''Pre-activation version of the original Bottleneck module.'''
    k = 4
    
    def __init__(, n, , =1):
        super(b, ).__init__()
        .bn1 = x.BatchNorm2d(n)
        .conv1 = x.Conv2d(n, , kernel_size=1, bias=False)
        .bn2 = x.BatchNorm2d()
        .conv2 = x.Conv2d(, , kernel_size=3, =, padding=1, bias=False)
        .bn3 = x.BatchNorm2d()
        .conv3 = x.Conv2d(, .k * , kernel_size=1, bias=False)
        
        if  != 1 or n != .k * :
            . = x.Sequential(
                x.Conv2d(n, .k * , kernel_size=1, =, bias=False)
            )
    
    def l(, x):
        } = F.relu(.bn1(x))
         = .(}) if hasattr(, 'shortcut') else x
        } = .conv1(})
        } = .conv2(F.relu(.bn2(})))
        } = .conv3(F.relu(.bn3(})))
        } += 
        return }

class c(x.Module):
    def __init__(, g, z, o, {, j, =False, =1):
        super(c, ).__init__()
        .n = o
        .{ = {
        . = 
        .j = j

        .conv1 = x.Conv2d(3, o, kernel_size=3, =, padding=1, bias=False)
        .layer1 = .f(g, o, z[0], =1)
        .layer2 = .f(g, o * 2, z[1], =2)
        .layer3 = .f(g, o * 4, z[2], =2)
        .layer4 = .f(g, o * 8, z[3], =2)
        .linear = x.Linear(o * 8 * g.k, {)
    
    def f(, g, , z, ):
         = [] + [1] * (z - 1)
        r = []
        for  in :
            r.append(g(.n, , ))
            .n =  * g.k
        return x.Sequential(*r)
    
    def h(, x):
        } = x
        } = .conv1(})
        } = .layer1(})
        return }
    
    def i(, x):
        } = x
        } = .conv1(})
        } = .layer1(})
        } = .layer2(})
        return }
    
    def l(, x, =None, s=False, u=False, t=None):

        if .:
            x = ~(x)
        
        if u:
            q = .randint(0, 2)
        elif s:
            q = 0
        else:
            q = None
        
        } = x
        
        if t is not None:
            p = m(t)
            p = .from_numpy(y.array([p]).astype('float32')).to(.j)
            p = d(p)
        
        if  is not None:
             = (, .{, j=.j)
        
        if q == 0:
            },  = v(}, , p=p)
        
        } = .conv1(})
        } = .layer1(})
        
        if q == 1:
            },  = v(}, , p=p)
        
        } = .layer2(})
        
        if q == 2:
            },  = v(}, , p=p)
        
        } = .layer3(})
        if q == 3:
            },  = v(}, , p=p)
        
        } = .layer4(})
        } = F.avg_pool2d(}, 4)
        } = }.view(}.size(0), -1)
        } = .linear(})
        
        if  is not None:
            return }, 
        else:
            return }

def ({=10, dropout=False, j='cpu', =False, =1):
    return c(a, [2, 2, 2, 2], 64, {, j=j, =,
                        =)

def ({=10, dropout=False, j='cpu', =False, =1):
    return c(a, [3, 4, 6, 3], 64, {, j='cpu', =,
                        =)

def ({=10, dropout=False, j='cpu', =False, =1):
    return c(b, [3, 4, 6, 3], 64, {, j='cpu', =,
                        =)

def ({=10, dropout=False, j='cpu', =False, =1):
    return c(b, [3, 4, 23, 3], 64, {, j='cpu', =,
                        =)

def ({=10, dropout=False, j='cpu', =False, =1):
    return c(b, [3, 8, 36, 3], 64, {, j='cpu', =,
                        =)

def ():
    w = (True, 10)
    y = w(d(.randn(1, 3, 32, 32)))
    print(y.size())

if __name__ == ""__main__"":
    ()","import math

def c(l, r, x, y, k):

    b = (l + k - 1) // k

    a = r // k

    f = max(x, b)
    e = min(y, a)

    return f <= e

if __name__ == '__main__':
    import g

    d = g.stdin.read().strip().split()
    if not d:
        g.exit(0)

    l, r, x, y, k = map(int, d)

    if c(l, r, x, y, k):
        g.stdout.write(""YES"")
    else:
        g.stdout.write(""NO"")"
26,A,Almost Prime,PROGRAMMING,['number theory'],"A number is called almost prime if it has exactly two distinct prime divisors. For example, numbers 6, 18, 24 are almost prime, while 4, 8, 9, 42 are not. Find the amount of almost prime numbers which are between 1 and *n*, inclusive.",Input contains one integer number *n* (1<=≤<=*n*<=≤<=3000).,"Output the amount of almost prime numbers between 1 and *n*, inclusive.","['10\n', '21\n']","['2\n', '8\n']",none,OK,"def c(f):

    a = 0

    for d in range(2, int(f**0.5)+1):
        if f % d == 0: a += 1

        while f % d == 0:
            f /= d
    
    if f > 1: a += 1

    return a

def b(f):
    a = 0
    for f in range(1, f+1):
        if c(f) == 2: a += 1
    return a

def e():
    f = int(input())
    print(b(f))

e()","import q

def j():

    c = q.stdin.read().split()
    if not c:
        return

    n = int(c[0])

    g = int(c[1])
    m = int(c[2])

    f = []

    d = 3
    for _ in range(1, n):
        i = int(c[d])
        n = int(c[d + 1])
        d += 2

        h = max(g, i)
        o = min(m, n)
        if h < o:
            f.append((h, o))

    f.sort(key=lambda x: x[0])
    k = []
    for e in f:
        if not k:
            k.append(e)
        else:
            l = k[-1]
            if e[0] <= l[1]:

                k[-1] = (l[0], max(l[1], e[1]))
            else:
                k.append(e)

    b = 0
    for p in k:
        b += p[1] - p[0]

    a = (m - g) - b
    if a < 0:
        a = 0

    print(a)

if __name__ == ""__main__"":
    j()"
492,C,Vanya and Exams,PROGRAMMING,"['greedy', 'sortings']","Vanya wants to pass *n* exams and get the academic scholarship. He will get the scholarship if the average grade mark for all the exams is at least *avg*. The exam grade cannot exceed *r*. Vanya has passed the exams and got grade *a**i* for the *i*-th exam. To increase the grade for the *i*-th exam by 1 point, Vanya must write *b**i* essays. He can raise the exam grade multiple times.

What is the minimum number of essays that Vanya needs to write to get scholarship?","The first line contains three integers *n*, *r*, *avg* (1<=≤<=*n*<=≤<=105, 1<=≤<=*r*<=≤<=109, 1<=≤<=*avg*<=≤<=*min*(*r*,<=106)) — the number of exams, the maximum grade and the required grade point average, respectively.

Each of the following *n* lines contains space-separated integers *a**i* and *b**i* (1<=≤<=*a**i*<=≤<=*r*, 1<=≤<=*b**i*<=≤<=106).",In the first line print the minimum number of essays.,"['5 5 4\n5 2\n4 7\n3 1\n3 2\n2 5\n', '2 5 4\n5 2\n5 2\n']","['4\n', '0\n']","In the first sample Vanya can write 2 essays for the 3rd exam to raise his grade by 2 points and 2 essays for the 4th exam to raise his grade by 1 point.

In the second sample, Vanya doesn't need to write any essays as his general point average already is above average.",OK,"def i(a, b, r, b):
    d = max(0, len(a) * b - sum(a))
    
    j = sorted(range(len(a)), key=lambda i: b[i])
    
    h = 0
    e = 0
    while d != 0:
        g = min(d, r - a[j[e]])
        h += g * b[j[e]]
        
        d -= g
        e += 1
    
    return h

def f():
    n, r, b = map(int, input().split())
    a = []
    b = []
    for i in range(n):
        a, c = map(int, input().split())
        a.append(a)
        b.append(c)
    
    print(i(a, b, r, b))

if __name__ == ""__main__"":
    f()","n = int(input().strip())

c = input().strip()

a = c.count('A')
b = c.count('D')

if a > b:
    print(""Anton"")
elif b > a:
    print(""Danik"")
else:
    print(""Friendship"")"
0,none,none,none,['none'],"You are given two squares, one with sides parallel to the coordinate axes, and another one with sides at 45 degrees to the coordinate axes. Find whether the two squares intersect.

The interior of the square is considered to be part of the square, i.e. if one square is completely inside another, they intersect. If the two squares only share one common point, they are also considered to intersect.","The input data consists of two lines, one for each square, both containing 4 pairs of integers. Each pair represents coordinates of one vertex of the square. Coordinates within each line are either in clockwise or counterclockwise order.

The first line contains the coordinates of the square with sides parallel to the coordinate axes, the second line contains the coordinates of the square at 45 degrees.

All the values are integer and between $-100$ and $100$.","Print ""Yes"" if squares intersect, otherwise print ""No"".

You can print each letter in any case (upper or lower).","['0 0 6 0 6 6 0 6\n1 3 3 5 5 3 3 1\n', '0 0 6 0 6 6 0 6\n7 3 9 5 11 3 9 1\n', '6 0 6 6 0 6 0 0\n7 4 4 7 7 10 10 7\n']","['YES\n', 'NO\n', 'YES\n']","In the first example the second square lies entirely within the first square, so they do intersect.

In the second sample squares do not have any points in common.

Here are images corresponding to the samples:",WRONG_ANSWER,"def j(s):
    g=-1
    x=1000
    y=x
    for i in range(4):
        if s[i][0]+s[i][1]<x or (x==s[i][0]+s[i][1] and y>s[i][0]):
            g=i
            x=s[i][0]+s[i][1]
            y=s[i][0]
    s=s[g::]+s[0:g]
    return s
def h(s,i):
    x=s[0][0];m=s[2][0];y=s[0][1];n=s[1][1]
    b=min(s[0][0],s[1][0],s[2][0],s[3][0])
    c=max(s[0][0],s[1][0],s[2][0],s[3][0])
    d=min(s[0][1],s[1][1],s[2][1],s[3][1])
    e=max(s[0][1],s[1][1],s[2][1],s[3][1])
    c=[b+abs(c-b),d+abs(e-d)]
    t=False
    for i in i:
        if i[0]>=x and i[0]<=m and i[1]>=y and i[1]<=n:
            t=True
            break
    if c[0]>=x and c[0]<=m and c[1]>=y and c[1]<=n:
            t=True
    return t
def f(s):
    for i in range(4):
        x=s[i][0]
        y=s[i][1]
        s[i][0]=x+y
        s[i][1]=x-y
    return s

a=list(map(int,input().split()))
s=[]
for i in range(0,8,2):
    s.append([a[i],a[i+1]])
a=list(map(int,input().split()))
i=[]
for i in range(0,8,2):
    i.append([a[i],a[i+1]])
i=j(i)
s=j(s)
t=False
if s[0][0]==s[-1][0]:
    t=True
if t:
    k=h(s,i)
    s=j(f(s))
    i=j(f(i))
    l=h(i,s)
else:
    k=h(i,s)
    s=j(f(s))
    i=j(f(i))
    l=h(s,i)
if k or l:
    print(""YES"")
else:
    print(""NO"")","def d():
    import f
    c = f.stdin.read().split()
    if not c:
        return

    e = int(c[0])
    b = []
    a = 1

    while e >= a:
        b.append(a)
        e -= a
        a += 1

    if e > 0:
        b[-1] += e

    print(len(b))
    print("" "".join(map(str, b)))

if __name__ == '__main__':
    d()"
230,B,T-primes,PROGRAMMING,"['binary search', 'implementation', 'math', 'number theory']","We know that prime numbers are positive integers that have exactly two distinct positive divisors. Similarly, we'll call a positive integer *t* Т-prime, if *t* has exactly three distinct positive divisors.

You are given an array of *n* positive integers. For each of them determine whether it is Т-prime or not.","The first line contains a single positive integer, *n* (1<=≤<=*n*<=≤<=105), showing how many numbers are in the array. The next line contains *n* space-separated integers *x**i* (1<=≤<=*x**i*<=≤<=1012).

Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is advised to use the cin, cout streams or the %I64d specifier.","Print *n* lines: the *i*-th line should contain ""YES"" (without the quotes), if number *x**i* is Т-prime, and ""NO"" (without the quotes), if it isn't.",['3\n4 5 6\n'],['YES\nNO\nNO\n'],"The given test has three numbers. The first number 4 has exactly three divisors — 1, 2 and 4, thus the answer for this number is ""YES"". The second number 5 has two divisors (1 and 5), and the third number 6 has four divisors (1, 2, 3, 6), hence the answer for them is ""NO"".",TIME_LIMIT_EXCEEDED,"from math import g

def e(m: int):
    f = [2]
    for i in range(3, m + 1, 2):
        d = True
        for j in f:
            if i % j == 0:
                d = False
                break
        if d:
            f.append(i)
    return f

def b():
    input()
    a = tuple(map(lambda x: int(g(int(x))) if g(int(x)).is_integer() else 1, input().split()))
    c = max(a)
    f = e(c)
    for i in a:
        if i == 1:
            print(""NO"")
        else:
            if i in f:
                print(""YES"")
            else:
                print(""NO"")

if __name__ == '__main__':
    b()","s = input().strip()

t = input().strip()

a = s[::-1]

if a == t:
    print(""YES"")
else:
    print(""NO"")"
305,B,Continued Fractions,PROGRAMMING,"['brute force', 'implementation', 'math']","A continued fraction of height *n* is a fraction of form . You are given two rational numbers, one is represented as  and the other one is represented as a finite fraction of height *n*. Check if they are equal.","The first line contains two space-separated integers *p*,<=*q* (1<=≤<=*q*<=≤<=*p*<=≤<=1018) — the numerator and the denominator of the first fraction.

The second line contains integer *n* (1<=≤<=*n*<=≤<=90) — the height of the second fraction. The third line contains *n* space-separated integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=1018) — the continued fraction.

Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.","Print ""YES"" if these fractions are equal and ""NO"" otherwise.","['9 4\n2\n2 4\n', '9 4\n3\n2 3 1\n', '9 4\n3\n1 2 4\n']","['YES\n', 'YES\n', 'NO\n']","In the first sample <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/5ff92f27aebea2560d99ad61202d20bab5ee5390.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>.

In the second sample <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/221368c79c05fc0ecad4e5f7a64f30b832fd99f5.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>.

In the third sample <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/4fb4b411afc0fbad27a1c8fdd08ba88ec3830ef5.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>.",OK,"from fractions import c
p,q=map(int,input().split())
b=c(p,q)
p//=b
q//=b
n=int(input())
a=list(map(int,input().split()))
def a(a,b):
    e=[]
    a[0]*=b[1]
    b[0]*=a[1]
    g=b[1]*a[1]
    h=a[0]+b[0]
    b=c(h,g)
    g//=b
    h//=b;
    e.append(h)
    e.append(g)
    return e
def d(i):
    e=[]
    if i==n-1:
        e.append(a[i])
        e.append(1)
        return e;    
    g=list(d(i+1))
    g=g[::-1]
    f=[]
    f.append(a[i])
    f.append(1)
    g=a(f,g)
    return g
e=d(0)
if(e[0]==p and e[1]==q): print(""YES"")
else:
    print(""NO"")","def b():
    import c

    a = c.stdin.readline().strip()

    a, b, c = map(int, a.split())

    if c == 0:
        if a == b:
            print(""YES"")
        else:
            print(""NO"")
    else:

        if (b - a) % c == 0 and (b - a) // c >= 0:
            print(""YES"")
        else:
            print(""NO"")

if __name__ == ""__main__"":
    b()"
93,E,Lostborn,PROGRAMMING,"['dp', 'math', 'number theory']","Igor K. very much likes a multiplayer role playing game WineAge II. Who knows, perhaps, that might be the reason for his poor performance at the university. As any person who plays the game, he is interested in equipping his hero with as good weapon and outfit as possible. 

One day, as he was reading the game's forum yet again, he discovered a very interesting fact. As it turns out, each weapon in the game is characterised with *k* different numbers: *a*1,<=...,<=*a**k*. They are called hit indicators and according to the game developers' plan they are pairwise coprime. 

The damage that is inflicted during a hit depends not only on the weapon's characteristics, but also on the hero's strength parameter. Thus, if the hero's strength equals *n*, than the inflicted damage will be calculated as the number of numbers on the segment , that aren't divisible by any hit indicator *a**i*.

Recently, having fulfilled another quest, Igor K. found a new Lostborn sword. He wants to know how much damage he will inflict upon his enemies if he uses it.","The first line contains two integers: *n* and *k* (1<=≤<=*n*<=≤<=1013, 1<=≤<=*k*<=≤<=100). They are the indicator of Igor K's hero's strength and the number of hit indicators.

The next line contains space-separated *k* integers *a**i* (1<=≤<=*a**i*<=≤<=1000). They are Lostborn sword's hit indicators. The given *k* numbers are pairwise coprime.","Print the single number — the damage that will be inflicted by Igor K.'s hero when he uses his new weapon. 

Please, do not use the %lld specificator to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specificator.","['20 3\n2 3 5\n', '50 2\n15 8\n']","['6\n', '41\n']",none,TIME_LIMIT_EXCEEDED,"import b
a,k = [int(x) for x in input().split(' ')]
a = [int(x) for x in input().split(' ')]
a.sort(reverse = True)
def c(n,y):
    if y == len(a)-1:
        return n-b.floor(n/a[-1])
    elif n < a[-1]:
        return n
    else:
        return c(n,y+1)-c(b.floor(n/a[y]),y+1)
if a[-1] == 1:
    print('0')
else:
    print(c(a,0))","import h

def a(s, i, n, d):

    if i == n:
        return []

    if i in d:
        return d[i]

    if i + 2 <= n:

        g = a(s, i + 2, n, d)
        if g is not None:
            d[i] = [s[i:i+2]] + g
            return d[i]

    if i + 3 <= n:

        g = a(s, i + 3, n, d)
        if g is not None:
            d[i] = [s[i:i+3]] + g
            return d[i]

    d[i] = None
    return None

def c():
    b = h.stdin.read().strip().split()
    if not b:
        return

    n = int(b[0])
    f = b[1]

    d = {}
    e = a(f, 0, n, d)

    if e:
        print(""-"".join(e))
    else:

        print("""")

if __name__ == ""__main__"":
    c()"
435,B,Pasha Maximizes,PROGRAMMING,['greedy'],"Pasha has a positive integer *a* without leading zeroes. Today he decided that the number is too small and he should make it larger. Unfortunately, the only operation Pasha can do is to swap two adjacent decimal digits of the integer.

Help Pasha count the maximum number he can get if he has the time to make at most *k* swaps.",The single line contains two integers *a* and *k* (1<=≤<=*a*<=≤<=1018; 0<=≤<=*k*<=≤<=100).,Print the maximum number that Pasha can get if he makes at most *k* swaps.,"['1990 1\n', '300 0\n', '1034 2\n', '9090000078001234 6\n']","['9190\n', '300\n', '3104\n', '9907000008001234\n']",none,WRONG_ANSWER,"a, b = map(int, input().split())
a=[int(x) for x in str(a)]
k=0
c=a
def f(o):
    x=o
    global b
    global k
    p=0
    if x.index(max(x))<=b:
        while max(x)!=x[0]:
            l = x.index(max(x))
            x[l-1], x[l] = x[l], x[l-1]
        k=b
        return x
    else:
        return x
b=f(c)

for i in range(len(a)-1):
    for j in range(len(a)-i-1):
        if k <= b:
            a = a
        while k<b:
            if a[j] < a[j + 1]:
                a[j], a[j + 1] = a[j + 1], a[j]
                k+=1
                j=0
            if a[j] > a[j+1]:
                j+=1
            if a[j] == a[j+1]:
                j+=1

a = max(a, b)

print(''.join(map(str, a)))","import f

def c():

    a = f.stdin.read().strip().split()
    if not a:
        return

    n = int(a[0])

    e = 0
    d = 0
    
    b = 1
    for _ in range(n):
        x = int(a[b])
        b += 1
        y = int(a[b])
        b += 1

        if x > 0:
            e += 1
        else:
            d += 1

    if e == n or d == n or e == 1 or d == 1:
        print(""Yes"")
    else:
        print(""No"")

if __name__ == ""__main__"":
    c()"
137,A,Postcards and photos,PROGRAMMING,['implementation'],"Polycarpus has postcards and photos hung in a row on the wall. He decided to put them away to the closet and hang on the wall a famous painter's picture. Polycarpus does it like that: he goes from the left to the right and removes the objects consecutively. As Polycarpus doesn't want any mix-ups to happen, he will not carry in his hands objects of two different types. In other words, Polycarpus can't carry both postcards and photos simultaneously. Sometimes he goes to the closet and puts the objects there, thus leaving his hands free. Polycarpus must put all the postcards and photos to the closet. He cannot skip objects. What minimum number of times he should visit the closet if he cannot carry more than 5 items?","The only line of the input data contains a non-empty string consisting of letters ""С"" and ""P"" whose length does not exceed 100 characters. If the *i*-th character in the string is the letter ""С"", that means that the *i*-th object (the numbering goes from the left to the right) on Polycarpus' wall is a postcard. And if the *i*-th character is the letter ""P"", than the *i*-th object on the wall is a photo.",Print the only number — the minimum number of times Polycarpus has to visit the closet.,"['CPCPCPC\n', 'CCCCCCPPPPPP\n', 'CCCCCCPPCPPPPPPPPPP\n', 'CCCCCCCCCC\n']","['7\n', '4\n', '6\n', '2\n']","In the first sample Polycarpus needs to take one item to the closet 7 times.

In the second sample Polycarpus can first take 3 postcards to the closet; then 3 more. He can take the 6 photos that are left in the similar way, going to the closet twice.

In the third sample Polycarpus can visit the closet twice, both times carrying 3 postcards. Then he can take there 2 photos at once, then one postcard and finally, he can carry the last 10 photos if he visits the closet twice.

In the fourth sample Polycarpus can visit the closet twice and take there all 10 postcards (5 items during each go).",WRONG_ANSWER,"""""""
Created on Tue Apr  7 02:29:32 2020

@author: alexi
""""""

def d():
    
    e = input()
    
    b = {'C':0,'P':0}
    
    c = 0
    a = e[0]
    for i in range(len(e)):
        if e[i] != a:
            b[a] = 0
            b[e[i]] = 1
            a = e[i]
            c += 1
        else:
            b[e[i]] += 1
            if b[e[i]] == 5:
                b[e[i]] = 0
                c += 1
                
    if b['C'] > 0 and b['P'] == 0 or b['P'] > 0 and b['C'] == 0:
        c += 1
        
    return c
             
A = d()
print(A)","def d():
    import e
    c = e.stdin.read().strip().split()

    n = int(c[0])
    m = int(c[1])

    a = list(map(int, c[2:2+n]))
    
    f = 0
    b = 2 + n

    for _ in range(m):
        u = int(c[b]) - 1
        v = int(c[b + 1]) - 1
        f += min(a[u], a[v])
        b += 2

    e.stdout.write(str(f))

if __name__ == '__main__':
    d()"
437,C,The Child and Toy,PROGRAMMING,"['graphs', 'greedy', 'sortings']","On Children's Day, the child got a toy from Delayyy as a present. However, the child is so naughty that he can't wait to destroy the toy.

The toy consists of *n* parts and *m* ropes. Each rope links two parts, but every pair of parts is linked by at most one rope. To split the toy, the child must remove all its parts. The child can remove a single part at a time, and each remove consume an energy. Let's define an energy value of part *i* as *v**i*. The child spend *v**f*1<=+<=*v**f*2<=+<=...<=+<=*v**f**k* energy for removing part *i* where *f*1,<=*f*2,<=...,<=*f**k* are the parts that are directly connected to the *i*-th and haven't been removed.

Help the child to find out, what is the minimum total energy he should spend to remove all *n* parts.","The first line contains two integers *n* and *m* (1<=≤<=*n*<=≤<=1000; 0<=≤<=*m*<=≤<=2000). The second line contains *n* integers: *v*1,<=*v*2,<=...,<=*v**n* (0<=≤<=*v**i*<=≤<=105). Then followed *m* lines, each line contains two integers *x**i* and *y**i*, representing a rope from part *x**i* to part *y**i* (1<=≤<=*x**i*,<=*y**i*<=≤<=*n*; *x**i*<=≠<=*y**i*).

Consider all the parts are numbered from 1 to *n*.",Output the minimum total energy the child should spend to remove all *n* parts of the toy.,"['4 3\n10 20 30 40\n1 4\n1 2\n2 3\n', '4 4\n100 100 100 100\n1 2\n2 3\n2 4\n3 4\n', '7 10\n40 10 20 10 20 80 40\n1 5\n4 7\n4 5\n5 2\n5 7\n6 4\n1 6\n1 3\n4 3\n1 4\n']","['40\n', '400\n', '160\n']","One of the optimal sequence of actions in the first sample is:
 -  First, remove part 3, cost of the action is 20. -  Then, remove part 2, cost of the action is 10. -  Next, remove part 4, cost of the action is 10. -  At last, remove part 1, cost of the action is 0. 
So the total energy the child paid is 20 + 10 + 10 + 0 = 40, which is the minimum.

In the second sample, the child will spend 400 no matter in what order he will remove the parts.",RUNTIME_ERROR,"import n

e = n.stdin.readlines()

h = e[0].strip().split("" "")
n = int(h[0])
m = int(h[1])
a = e[1].strip().split("" "")
c = {}
g = {}

for i in range(1, len(a)+1):
	c[i] = int(a[i-1])

for d in e[2:]:
	j = d.strip().split("" "")
	if int(j[0]) not in g:
		g[int(j[0])] = set()
	if int(j[1]) not in g:
		g[int(j[1])] = set()
	g[int(j[0])].add(int(j[1]))
	g[int(j[1])].add(int(j[0]))

l = []

for i in range(1, n+1):
	l.append((i, g[i]))

def b(i):
	return c[i[0]]

def o(i):
	for f in i[1]:
		if i[0] in g[f]:
			g[f].remove(i[0])

	del g[i[0]]

l.sort(key=b)

m = 0

for i in range(len(l)):
	k = l.pop()
	for f in k[1]:
		m = m + c[f]

	o(k)

print(m)","n = int(input())

a = 0

for _ in range(n):

    a, b, c = map(int, input().split())

    if a + b + c >= 2:
        a += 1

print(a)"
908,A,New Year and Counting Cards,PROGRAMMING,"['brute force', 'implementation']","Your friend has *n* cards.

You know that each card has a lowercase English letter on one side and a digit on the other.

Currently, your friend has laid out the cards on a table so only one side of each card is visible.

You would like to know if the following statement is true for cards that your friend owns: ""If a card has a vowel on one side, then it has an even digit on the other side."" More specifically, a vowel is one of 'a', 'e', 'i', 'o' or 'u', and even digit is one of '0', '2', '4', '6' or '8'.

For example, if a card has 'a' on one side, and '6' on the other side, then this statement is true for it. Also, the statement is true, for example, for a card with 'b' and '4', and for a card with 'b' and '3' (since the letter is not a vowel). The statement is false, for example, for card with 'e' and '5'. You are interested if the statement is true for all cards. In particular, if no card has a vowel, the statement is true.

To determine this, you can flip over some cards to reveal the other side. You would like to know what is the minimum number of cards you need to flip in the worst case in order to verify that the statement is true.","The first and only line of input will contain a string *s* (1<=≤<=|*s*|<=≤<=50), denoting the sides of the cards that you can see on the table currently. Each character of *s* is either a lowercase English letter or a digit.","Print a single integer, the minimum number of cards you must turn over to verify your claim.","['ee\n', 'z\n', '0ay1\n']","['2\n', '0\n', '2\n']","In the first sample, we must turn over both cards. Note that even though both cards have the same letter, they could possibly have different numbers on the other side.

In the second sample, we don't need to turn over any cards. The statement is vacuously true, since you know your friend has no cards with a vowel on them.

In the third sample, we need to flip the second and fourth cards.",OK,"from sys import f, g

def d(a, h=['a','e','i','o','u']):
    return (ord(a) >= ord('0') and ord(a) <= ord('9') and int(a) % 2 == 1) or (a in h)

def e(b):
    c = 0
    for a in b:
        c = c+1 if d(a) else c
    return c

g.write( str(e(f.readline())) +'\n')","import l

def a(j):
    """"""Calculate the maximum number of consecutive 1's in a row.""""""
    h = 0
    c = 0
    for b in j:
        if b == 1:
            c += 1
            if c > h:
                h = c
        else:
            c = 0
    return h

def g():
    f = l.stdin.read().splitlines()

    n, m, q = map(int, f[0].split())
    
    e = []
    k = []

    for i in range(1, n+1):
        j = list(map(int, f[i].split()))
        e.append(j)
        k.append(a(j))
    
    i = []

    for k in range(n+1, n+1+q):

        i, j = map(int, f[k].split())
        i -= 1
        j -= 1

        e[i][j] = 1 - e[i][j]

        k[i] = a(e[i])

        d = max(k)
        i.append(str(d))
    
    l.stdout.write(""\n"".join(i))

if __name__ == '__main__':
    g()"
109,A,Lucky Sum of Digits,PROGRAMMING,"['brute force', 'implementation']","Petya loves lucky numbers. We all know that lucky numbers are the positive integers whose decimal representations contain only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.

Petya wonders eagerly what minimum lucky number has the sum of digits equal to *n*. Help him cope with the task.",The single line contains an integer *n* (1<=≤<=*n*<=≤<=106) — the sum of digits of the required lucky number.,"Print on the single line the result — the minimum lucky number, whose sum of digits equals *n*. If such number does not exist, print -1.","['11\n', '10\n']","['47\n', '-1\n']",none,WRONG_ANSWER,"def b(d, h, a, n, g):
    i = h+4
    j = h+7

    c = d+4*pow(10, a)
    if n > i:
        b(c, i, a+1, n, g)
    elif n < i:
        return
    else:
        g.append(c)

    c = d+7*pow(10, a)
    if n > j:
        b(c, j, a+1, n, g)
    elif n < j:
        return
    else:
        g.append(c)

n = int(input())

if n <= 17:
    g = []

    b(0, 0, 0, n, g)

    if len(g) > 0:
        g.sort()
        print(g[0])
    else:
        print(""-1"")

else:
    f = 0
    if n%7 == 0:
        t = int(n/7)
        for i in range(t):
            f += 7*pow(10, i)
    elif n%4 == 0:
        t = int(n/4)
        for i in range(t):
            f += 4*pow(10, i)
    else:
        e = n%7
        t = int(n/7)
        
        if e == 0:
            for i in range(t):
                f += 7*pow(10, i)
            print(f)
            exit()
        elif e == 1:
            t -= 1
            x = 2
        elif e == 2:
            t -= 2
            x = 4
        elif e == 3:
            t -= 3
            x = 6
        elif e == 4:
            x = 1
        elif e == 5:
            t -= 1
            x = 3
        elif e == 6:
            t -= 2
            x = 5
        
        for i in range(t):
            f += 7*pow(10, i)

        for y in range(x):
            i += 1
            f += 4*pow(10, i)
    
    print(f)","c = set(""aeiou"")

s = input().strip()

b = True

for i, a in enumerate(s):

    if a in c or a == 'n':
        continue

    if i == len(s) - 1 or s[i + 1] not in c:
        b = False
        break

print(""YES"" if b else ""NO"")"
625,B,War of the Corporations,PROGRAMMING,"['constructive algorithms', 'greedy', 'strings']","A long time ago, in a galaxy far far away two giant IT-corporations Pineapple and Gogol continue their fierce competition. Crucial moment is just around the corner: Gogol is ready to release it's new tablet Lastus 3000.

This new device is equipped with specially designed artificial intelligence (AI). Employees of Pineapple did their best to postpone the release of Lastus 3000 as long as possible. Finally, they found out, that the name of the new artificial intelligence is similar to the name of the phone, that Pineapple released 200 years ago. As all rights on its name belong to Pineapple, they stand on changing the name of Gogol's artificial intelligence.

Pineapple insists, that the name of their phone occurs in the name of AI as a substring. Because the name of technology was already printed on all devices, the Gogol's director decided to replace some characters in AI name with ""#"". As this operation is pretty expensive, you should find the minimum number of characters to replace with ""#"", such that the name of AI doesn't contain the name of the phone as a substring.

Substring is a continuous subsequence of a string.","The first line of the input contains the name of AI designed by Gogol, its length doesn't exceed 100<=000 characters. Second line contains the name of the phone released by Pineapple 200 years ago, its length doesn't exceed 30. Both string are non-empty and consist of only small English letters.","Print the minimum number of characters that must be replaced with ""#"" in order to obtain that the name of the phone doesn't occur in the name of AI as a substring.","['intellect\ntell\n', 'google\napple\n', 'sirisiri\nsir\n']","['1', '0', '2']","In the first sample AI's name may be replaced with ""int#llect"".

In the second sample Gogol can just keep things as they are.

In the third sample one of the new possible names of AI may be ""s#ris#ri"".",OK,"x = input()
s = input()

print(x.count(s))","import l

def f():

    d = l.stdin.read().splitlines()
    if not d:
        return

    n = int(d[0])

    i = []

    c = {}

    for i in range(1, n + 1):
        e = d[i]
        h, k = e.split()
        j = int(k)
        i.append((h, j))
        c[h] = c.get(h, 0) + j

    g = max(c.values())

    a = {h for h, j in c.items() if j == g}

    b = {}
    for h, j in i:
        b[h] = b.get(h, 0) + j
        if h in a and b[h] >= g:
            print(h)
            return

if __name__ == ""__main__"":
    f()"
340,C,Tourist Problem,PROGRAMMING,"['combinatorics', 'implementation', 'math']","Iahub is a big fan of tourists. He wants to become a tourist himself, so he planned a trip. There are *n* destinations on a straight road that Iahub wants to visit. Iahub starts the excursion from kilometer 0. The *n* destinations are described by a non-negative integers sequence *a*1, *a*2, ..., *a**n*. The number *a**k* represents that the *k*th destination is at distance *a**k* kilometers from the starting point. No two destinations are located in the same place. 

Iahub wants to visit each destination only once. Note that, crossing through a destination is not considered visiting, unless Iahub explicitly wants to visit it at that point. Also, after Iahub visits his last destination, he doesn't come back to kilometer 0, as he stops his trip at the last destination. 

The distance between destination located at kilometer *x* and next destination, located at kilometer *y*, is |*x*<=-<=*y*| kilometers. We call a ""route"" an order of visiting the destinations. Iahub can visit destinations in any order he wants, as long as he visits all *n* destinations and he doesn't visit a destination more than once. 

Iahub starts writing out on a paper all possible routes and for each of them, he notes the total distance he would walk. He's interested in the average number of kilometers he would walk by choosing a route. As he got bored of writing out all the routes, he asks you to help him.","The first line contains integer *n* (2<=≤<=*n*<=≤<=105). Next line contains *n* distinct integers *a*1, *a*2, ..., *a**n* (1<=≤<=*a**i*<=≤<=107).",Output two integers — the numerator and denominator of a fraction which is equal to the wanted average number. The fraction must be irreducible.,['3\n2 3 5\n'],['22 3'],"Consider 6 possible routes:
 -  [2, 3, 5]: total distance traveled: |2 – 0| + |3 – 2| + |5 – 3| = 5; -  [2, 5, 3]: |2 – 0| + |5 – 2| + |3 – 5| = 7; -  [3, 2, 5]: |3 – 0| + |2 – 3| + |5 – 2| = 7; -  [3, 5, 2]: |3 – 0| + |5 – 3| + |2 – 5| = 8; -  [5, 2, 3]: |5 – 0| + |2 – 5| + |3 – 2| = 9; -  [5, 3, 2]: |5 – 0| + |3 – 5| + |2 – 3| = 8. 
The average travel distance is <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/29119d3733c79f70eb2d77186ac1606bf938508a.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> = <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/ee9d5516ed2ca1d2b65ed21f8a64f58f94954c30.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> = <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/ed5cc8cb7dd43cfb27f2459586062538e44de7bd.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>.",OK,"""""""
Created on Wed Jun  3 11:57:46 2020

@author: shailesh
""""""

from math import c

def g(x,y):
    d = c(x,y)
    x = x//d
    y = y//d
    return x,y

N = int(input())

A = [int(i) for i in input().split()]

A.sort()

a = A[0]

h = 0

for i in range(N-1):
    e = i+2
    d = N - i - 1
    d = A[i+1]-A[i]

    h +=d*(2*e - 1)*d

f = N*a + h

b = N

f,b = g(f,b)

print(f,b)","import x
import math
from collections import e

x.setrecursionlimit(1000000)

def l(x, b):
    """"""Return a dictionary of prime factors of x with their exponents.
       Uses caching for repeated values.""""""
    if x in b:
        return b[x]
    m = {}
    y = x

    while y % 2 == 0:
        m[2] = m.get(2, 0) + 1
        y //= 2

    f = 3

    while f * f <= y:
        while y % f == 0:
            m[f] = m.get(f, 0) + 1
            y //= f
        f += 2
    if y > 1:
        m[y] = m.get(y, 0) + 1
    b[x] = m
    return m

def a(v):
    """"""Construct a list of factors (each between 1 and 10^7) that multiplies to the reduced product.
       We iterate over primes in ascending order and multiply them into the current factor as long as it does not exceed 10^7.""""""
    n = []
    c = 1

    for p in sorted(v.keys()):
        j = v[p]
        for _ in range(j):

            if c * p <= 10**7:
                c *= p
            else:

                n.append(c)
                c = p
    n.append(c)
    return n

def p():
    d = x.stdin.read().strip().split()
    if not d:
        return
    o = iter(d)
    n = int(next(o))
    m = int(next(o))

    r = [int(next(o)) for _ in range(n)]
    g = [int(next(o)) for _ in range(m)]

    q = e(int)
    f = e(int)
    b = {}
    
    for x in r:
        k = l(x, b)
        for p, i in k.items():
            q[p] += i
    
    for x in g:
        k = l(x, b)
        for p, i in k.items():
            f[p] += i

    w = {}
    u = {}

    for p, i in q.items():
        h = i - f.get(p, 0)
        if h > 0:
            w[p] = h

    for p, i in f.items():
        h = i - q.get(p, 0)
        if h > 0:
            u[p] = h

    if not w:

        t = [1]
    else:
        t = a(w)
    
    if not u:
        s = [1]
    else:
        s = a(u)

    x.stdout.write(f""{len(t)} {len(s)}\n"")
    x.stdout.write("" "".join(map(str, t)) + ""\n"")
    x.stdout.write("" "".join(map(str, s)) + ""\n"")

if __name__ == '__main__':
    p()"
21,A,Jabber ID,PROGRAMMING,"['implementation', 'strings']","Jabber ID on the national Berland service «Babber» has a form &lt;username&gt;@&lt;hostname&gt;[/resource], where 
 -  &lt;username&gt; — is a sequence of Latin letters (lowercase or uppercase), digits or underscores characters «_», the length of &lt;username&gt; is between 1 and 16, inclusive. -  &lt;hostname&gt; — is a sequence of word separated by periods (characters «.»), where each word should contain only characters allowed for &lt;username&gt;, the length of each word is between 1 and 16, inclusive. The length of &lt;hostname&gt; is between 1 and 32, inclusive. -  &lt;resource&gt; — is a sequence of Latin letters (lowercase or uppercase), digits or underscores characters «_», the length of &lt;resource&gt; is between 1 and 16, inclusive. 
The content of square brackets is optional — it can be present or can be absent.

There are the samples of correct Jabber IDs: [[email protected]](/cdn-cgi/l/email-protection), [[email protected]](/cdn-cgi/l/email-protection)/contest.

Your task is to write program which checks if given string is a correct Jabber ID.","The input contains of a single line. The line has the length between 1 and 100 characters, inclusive. Each characters has ASCII-code between 33 and 127, inclusive.",Print YES or NO.,"['[email\xa0protected]\n', '[email\xa0protected]/contest.icpc/12\n']","['YES\n', 'NO\n']",none,WRONG_ANSWER,"def e(str):
    for i in range(len(str)):
        if (33<= ord(str[i])<= 127) or (ord('0')<= ord(str[i])<= ord('9')) or str[i]== '_':
            pass
        else:
            return False
        if not (0 <len(str[i])< 17): return False
    return True
def c():
    print('NO')
    quit()
    
j= input()
j.lower()
f= ''
bool= True
b= False
if '@' in j:
    g= j.split('@')[0]
    d= j.split('@')[1]
else:
    c()
if '/' in d:
    b= True
    d= d.split('/')[0]
    f= j.split('/')[-1]
    if not e(f): c()

if not e(g): c()

if not (0 <len(d)< 33): c()

a= d.split('.')
for i in range(len(a)):
    if not e(a[i]): c()
        
if (b & (len(j)== len(g)+ len(d)+ len(f)+2)) or (len(j)== len(g)+ len(d)+ 1):
    pass
else:
    c()

print('YES')
quit()","import n

def k():

    j = n.stdin.read().strip().splitlines()
    m = []
    for i in j:
        if i.strip():
            l = i.strip().split()
            a = int(l[0])
            b = int(l[1])
            m.append((a, b))

    a, e = m[0]
    b, f = m[1]
    c, g = m[2]
    d, h = m[3]

    p = (a > max(g, h)) and (f > max(c, d))
    q = (b > max(g, h)) and (e > max(c, d))
    o = p or q

    s = ((d > f and g > a) or (c > f and h > a))

    t = ((d > e and g > b) or (c > e and h > b))

    r = s and t

    if o:
        print(""Team 1"")
    elif r:
        print(""Team 2"")
    else:
        print(""Draw"")

if __name__ == '__main__':
    k()"
220,B,Little Elephant and Array,PROGRAMMING,"['constructive algorithms', 'data structures']","The Little Elephant loves playing with arrays. He has array *a*, consisting of *n* positive integers, indexed from 1 to *n*. Let's denote the number with index *i* as *a**i*. 

Additionally the Little Elephant has *m* queries to the array, each query is characterised by a pair of integers *l**j* and *r**j* (1<=≤<=*l**j*<=≤<=*r**j*<=≤<=*n*). For each query *l**j*,<=*r**j* the Little Elephant has to count, how many numbers *x* exist, such that number *x* occurs exactly *x* times among numbers *a**l**j*,<=*a**l**j*<=+<=1,<=...,<=*a**r**j*.

Help the Little Elephant to count the answers to all queries.","The first line contains two space-separated integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=105) — the size of array *a* and the number of queries to it. The next line contains *n* space-separated positive integers *a*1, *a*2, ..., *a**n* (1<=≤<=*a**i*<=≤<=109). Next *m* lines contain descriptions of queries, one per line. The *j*-th of these lines contains the description of the *j*-th query as two space-separated integers *l**j* and *r**j* (1<=≤<=*l**j*<=≤<=*r**j*<=≤<=*n*).",In *m* lines print *m* integers — the answers to the queries. The *j*-th line should contain the answer to the *j*-th query.,['7 2\n3 1 2 2 3 3 7\n1 7\n3 4\n'],['3\n1\n'],none,RUNTIME_ERROR,"def a(m, i):
    i[m] += 1
    if i[m] == m:
        global d
        d += 1

def v(m, i):
    i[m] -= 1

    if i[m] == m-1:
        global d
        d -= 1

def r(t, e):
    from collections import l

    j = 1
    k = 1
    i = l(int)
    c = {}
    for s in t:
        while j < s[0]:
            m = e[j-1]
            v(m, i)
            j += 1
        while j > s[0]:
            m = e[j-1]
            a(m, i)
            j -= 1
        while k < s[1]:
            m = e[k-1]
            a(m, i)
            k += 1
        while k > s[1]:
            m = e[k-1]
            v(m, i)
            k -= 1
        c[s] = d

    return c

def p(t):
    from math import h, x

    f = int(h(x(len(t))))
    g = [[] for x in range(f)]
    for q in t:
        q = q[0] // f
        g[q].append(q)

    u = [sorted(x, lambda x:x[1]) for x in g]
    u = [n for z in u for n in z]
    return u

if __name__ == ""__main__"":
    from sys import y, stdout

    d = 0

    b = [o.strip() for o in y]
    e = list(map(int, b[1].split()))
    t = [tuple(map(int, x.split()))for x in b[2:]]
    w = p(t)
    c = r(w, e)

    for q in t:
        print(c[q])","import f

def c():
    s = f.stdin.readline().strip()

    b = s.count('1')

    t = ''.join(a for a in s if a != '1')

    d = t.find('2')
    if d == -1:

        d = len(t)

    e = t[:d] + ('1' * b) + t[d:]
    
    print(e)

if __name__ == ""__main__"":
    c()"
11,D,A Simple Task,PROGRAMMING,"['bitmasks', 'dp', 'graphs']","Given a simple graph, output the number of simple cycles in it. A simple cycle is a cycle with no repeated vertices or edges.","The first line of input contains two integers *n* and *m* (1<=≤<=*n*<=≤<=19, 0<=≤<=*m*) – respectively the number of vertices and edges of the graph. Each of the subsequent *m* lines contains two integers *a* and *b*, (1<=≤<=*a*,<=*b*<=≤<=*n*, *a*<=≠<=*b*) indicating that vertices *a* and *b* are connected by an undirected edge. There is no more than one edge connecting any pair of vertices.",Output the number of cycles in the given graph.,['4 6\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4\n'],['7\n'],The example graph is a clique and contains four cycles of length 3 and three cycles of length 4.,WRONG_ANSWER,"n, m = map(int, input().split())
d = [[] for _ in range(n)]
for i in range(m):
    a, b = map(int, input().split())
    d[a-1].append(b-1)
    d[b-1].append(a-1)

def c(g, h, f):
    h[g] = True
    f.append(g)
    a = 0
    for e in d[g]:
        if e == f[0]:
            a += 1
        elif not h[e]:
            a += c(e, h, f)
    f.pop()
    h[g] = False
    return a

b = 0
for i in range(n):
    h = [False] * n
    b += c(i, h, [])
print(b//2)","def a():

    n = int(input())

    b = list(map(int, input().split()))

    a, b = map(int, input().split())

    c = sum(b[a - 1:b - 1])

    print(c)

if __name__ == ""__main__"":
    a()"
842,C,Ilya And The Tree,PROGRAMMING,"['dfs and similar', 'graphs', 'math', 'number theory', 'trees']","Ilya is very fond of graphs, especially trees. During his last trip to the forest Ilya found a very interesting tree rooted at vertex 1. There is an integer number written on each vertex of the tree; the number written on vertex *i* is equal to *a**i*.

Ilya believes that the beauty of the vertex *x* is the greatest common divisor of all numbers written on the vertices on the path from the root to *x*, including this vertex itself. In addition, Ilya can change the number in one arbitrary vertex to 0 or leave all vertices unchanged. Now for each vertex Ilya wants to know the maximum possible beauty it can have.

For each vertex the answer must be considered independently.

The beauty of the root equals to number written on it.","First line contains one integer number *n* — the number of vertices in tree (1<=≤<=*n*<=≤<=2·105).

Next line contains *n* integer numbers *a**i* (1<=≤<=*i*<=≤<=*n*, 1<=≤<=*a**i*<=≤<=2·105).

Each of next *n*<=-<=1 lines contains two integer numbers *x* and *y* (1<=≤<=*x*,<=*y*<=≤<=*n*, *x*<=≠<=*y*), which means that there is an edge (*x*,<=*y*) in the tree.","Output *n* numbers separated by spaces, where *i*-th number equals to maximum possible beauty of vertex *i*.","['2\n6 2\n1 2\n', '3\n6 2 3\n1 2\n1 3\n', '1\n10\n']","['6 6 \n', '6 6 6 \n', '10 \n']",none,WRONG_ANSWER,"""""""
    Author      : Arif Ahmad
    Date        :
    Algo        :
    Difficulty  :
""""""
from sys import h, i, g
import k
from fractions import e

def b(u, c, d):
    global a, g, a

    l = e(c, 0)
    m = e(d, a[u])
    a[u] = max(l, m)

    c = e(c, a[u])
    if u == 0:
        d = 0
    else:
        d = m
    for v in g[u]:
        if a[v] == 0:
            b(v, c, d)

def f():
    global a, n, g, a
    n = int(h.readline().strip())
    a = [int(_) for _ in h.readline().strip().split()]

    g = [[] for _ in range(n)]
    for _ in range(n - 1):
        x, y = [int(_) for _ in h.readline().strip().split()]
        x -= 1
        y -= 1
        g[x].append(y)
        g[y].append(x)

    a = [0 for _ in range(n)]

    b(0, a[0], a[0])

    a = ' '.join(str(_) for _ in a)
    i.write(a)

if __name__ == '__main__':

    g(10**6)
    k.stack_size(134217728)
    j = k.Thread(target=f)
    j.start()","import e

def a(s):

    return s == s[::-1]

def c():

    s = e.stdin.readline().strip()

    for i in range(len(s) + 1):

        for b in ""abcdefghijklmnopqrstuvwxyz"":

            d = s[:i] + b + s[i:]

            if a(d):

                print(d)
                return

    print(""NA"")

if __name__ == '__main__':
    c()"
802,G,Fake News (easy),PROGRAMMING,"['implementation', 'strings']","As it's the first of April, Heidi is suspecting that the news she reads today are fake, and she does not want to look silly in front of all the contestants. She knows that a newspiece is fake if it contains heidi as a subsequence. Help Heidi assess whether the given piece is true, but please be discreet about it...",The first and only line of input contains a single nonempty string *s* of length at most 1000 composed of lowercase letters (a-z).,Output YES if the string *s* contains heidi as a subsequence and NO otherwise.,"['abcheaibcdi\n', 'hiedi\n']","['YES', 'NO']",A string *s* contains another string *p* as a subsequence if it is possible to delete some characters from *s* and obtain *p*.,OK,"def c():
    s = input()
    b = ""heidi""

    j = 0
    a = 0

    for i in s:
        if(i == b[j]):
            if(j < 4):
                j += 1
            else:
                a = 1

    if(a == 0):
        print(""NO"")
    else:
        print(""YES"")

if __name__ == '__main__':
    c()","def e():
    import h
    b = h.stdin.read().splitlines()
    if not b:
        return

    n, m = map(int, b[0].split())
    c = b[1:1+n]

    g = [0] * n
    a = [0] * m
    i = 0
    
    for i in range(n):
        d = c[i]
        for j in range(m):
            if d[j] == ""*"":
                g[i] += 1
                a[j] += 1
                i += 1

    for i in range(n):
        for j in range(m):

            f = g[i] + a[j] - (1 if c[i][j] == ""*"" else 0)
            if f == i:

                h.stdout.write(""YES\n"")
                h.stdout.write(f""{i+1} {j+1}\n"")
                return

    h.stdout.write(""NO\n"")
    

if __name__ == '__main__':
    e()"
2,B,The least round way,PROGRAMMING,"['dp', 'math']","There is a square matrix *n*<=×<=*n*, consisting of non-negative integer numbers. You should find such a way on it that 
 -  starts in the upper left cell of the matrix; -  each following cell is to the right or down from the current cell; -  the way ends in the bottom right cell. 
Moreover, if we multiply together all the numbers along the way, the result should be the least ""round"". In other words, it should end in the least possible number of zeros.","The first line contains an integer number *n* (2<=≤<=*n*<=≤<=1000), *n* is the size of the matrix. Then follow *n* lines containing the matrix elements (non-negative integer numbers not exceeding 109).",In the first line print the least number of trailing zeros. In the second line print the correspondent way itself.,['3\n1 2 3\n4 5 6\n7 8 9\n'],['0\nDDRR\n'],none,RUNTIME_ERROR,"""""""

created by shuangquan.huang at 1/3/20

""""""

import collections
import time
import os
import sys
import bisect
import heapq
from typing import List

N = int(input())
A = []
for i in range(N):
    g = [int(x) for x in input().split()]
    A.append(g)
    

def a(i, c):
    c = 0
    while i % c == 0:
        i //= c
        c += 1
    return c

def h(c):
    d = [[1000 for _ in range(N)] for _ in range(N)]
    f = [['' for _ in range(N)] for _ in range(N)]
    d[0][0] = a(A[0][0], c)
    for r in range(N):
        for c in range(N):
            b = a(A[r][c], c)
            if r > 0 and d[r-1][c] + b < d[r][c]:
                d[r][c] = d[r-1][c] + b
                f[r][c] = 'U'
            if c > 0 and d[r][c-1] + b < d[r][c]:
                f[r][c] = 'L'
                d[r][c] = d[r][c-1] + b
    
    e = []
    r, c = N-1, N-1
    while r > 0 or c > 0:
        if f[r][c] == 'U':
            e.append('D')
            r, c = r-1, c
        else:
            e.append('R')
            r, c = r, c-1
    
    return d[N-1][N-1], ''.join(e[::-1])

a, b = h(2)
c, d = h(5)
if a < c:
    print(a)
    print(b)
else:
    print(c)
    print(d)","def a(c):

    if c % 2 == 0 and c > 2:
        return True
    return False

def b():

    c = int(input().strip())

    if a(c):
        print(""YES"")
    else:
        print(""NO"")

if __name__ == ""__main__"":
    b()"
544,B,Sea and Islands,PROGRAMMING,"['constructive algorithms', 'implementation']","A map of some object is a rectangular field consisting of *n* rows and *n* columns. Each cell is initially occupied by the sea but you can cover some some cells of the map with sand so that exactly *k* islands appear on the map. We will call a set of sand cells to be island if it is possible to get from each of them to each of them by moving only through sand cells and by moving from a cell only to a side-adjacent cell. The cells are called to be side-adjacent if they share a vertical or horizontal side. It is easy to see that islands do not share cells (otherwise they together form a bigger island).

Find a way to cover some cells with sand so that exactly *k* islands appear on the *n*<=×<=*n* map, or determine that no such way exists.","The single line contains two positive integers *n*, *k* (1<=≤<=*n*<=≤<=100, 0<=≤<=*k*<=≤<=*n*2) — the size of the map and the number of islands you should form.","If the answer doesn't exist, print ""NO"" (without the quotes) in a single line.

Otherwise, print ""YES"" in the first line. In the next *n* lines print the description of the map. Each of the lines of the description must consist only of characters 'S' and 'L', where 'S' is a cell that is occupied by the sea and 'L' is the cell covered with sand. The length of each line of the description must equal *n*.

If there are multiple answers, you may print any of them.

You should not maximize the sizes of islands.","['5 2\n', '5 25\n']","['YES\nSSSSS\nLLLLL\nSSSSS\nLLLLL\nSSSSS\n', 'NO\n']",none,OK,"import g
input = g.stdin.readline
d = lambda a: map(a, input().split(' '))

def f():
    n, k = d(int)
    c = [['S' for _ in range(n)] for _ in range(n)]
    b = True
    for i in range(n):
        for j in range(n):
            if k and b:
                c[i][j] = 'L'
                k -= 1
            b ^= True
        if n % 2 == 0:
            b ^= True
    if k == 0:
        print(""YES"")
    else:
        print(""NO"")
    if k == 0:
        for e in c:
            print(''.join(e))

if __name__ == '__main__':
    f()","import f

def c():

    a = f.stdin.read().splitlines()

    n, m = map(int, a[0].split())

    e = 0
    d = 0

    for i in range(n):
        b = a[i + 1]

        for j in range(m):
            if b[j] == '*':

                e ^= (i + 1)
                d ^= (j + 1)

    print(e, d)

if __name__ == ""__main__"":
    c()"
381,A,Sereja and Dima,PROGRAMMING,"['greedy', 'implementation', 'two pointers']","Sereja and Dima play a game. The rules of the game are very simple. The players have *n* cards in a row. Each card contains a number, all numbers on the cards are distinct. The players take turns, Sereja moves first. During his turn a player can take one card: either the leftmost card in a row, or the rightmost one. The game ends when there is no more cards. The player who has the maximum sum of numbers on his cards by the end of the game, wins.

Sereja and Dima are being greedy. Each of them chooses the card with the larger number during his move.

Inna is a friend of Sereja and Dima. She knows which strategy the guys are using, so she wants to determine the final score, given the initial state of the game. Help her.",The first line contains integer *n* (1<=≤<=*n*<=≤<=1000) — the number of cards on the table. The second line contains space-separated numbers on the cards from left to right. The numbers on the cards are distinct integers from 1 to 1000.,"On a single line, print two integers. The first number is the number of Sereja's points at the end of the game, the second number is the number of Dima's points at the end of the game.","['4\n4 1 2 10\n', '7\n1 2 3 4 5 6 7\n']","['12 5\n', '16 12\n']","In the first sample Sereja will take cards with numbers 10 and 2, so Sereja's sum is 12. Dima will take cards with numbers 4 and 1, so Dima's sum is 5.",OK,"from collections import defaultdict, deque, Counter
from heapq import heapify, heappop, heappush

def d():
    t = 1

    for _ in range(t):
        f()

def f():
    n = int(input())
    l = list(map(int, input().split()))
    g = b = 0
    c, e = 0, n - 1
    i = 0
    while c <= e:
        a = max(l[c], l[e])
        if i % 2 == 0:
            g += a
        else:
            b += a
        if l[c] > l[e]:
            c += 1
        else:
            e -= 1
        i += 1
    print(g, b)

if __name__ == ""__main__"":
    d()
""""""
/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?)
 * do smth instead of nothing and stay organized
 * WRITE STUFF DOWN
 * DON'T GET STUCK ON ONE APPROACH
 */
""""""","def f():
    import h
    e = h.stdin.read().split()

    n = int(e[0])

    a = list(map(int, e[1:]))

    a = sum(a)

    d = [1 if x == 0 else -1 for x in a]

    g = d[0]
    b = 0
    for c in d:
        b += c
        if b > g:
            g = b
        if b < 0:
            b = 0

    print(a + g)

if __name__ == ""__main__"":
    f()"
552,A,Vanya and Table,PROGRAMMING,"['implementation', 'math']","Vanya has a table consisting of 100 rows, each row contains 100 cells. The rows are numbered by integers from 1 to 100 from bottom to top, the columns are numbered from 1 to 100 from left to right. 

In this table, Vanya chose *n* rectangles with sides that go along borders of squares (some rectangles probably occur multiple times). After that for each cell of the table he counted the number of rectangles it belongs to and wrote this number into it. Now he wants to find the sum of values in all cells of the table and as the table is too large, he asks you to help him find the result.","The first line contains integer *n* (1<=≤<=*n*<=≤<=100) — the number of rectangles.

Each of the following *n* lines contains four integers *x*1,<=*y*1,<=*x*2,<=*y*2 (1<=≤<=*x*1<=≤<=*x*2<=≤<=100, 1<=≤<=*y*1<=≤<=*y*2<=≤<=100), where *x*1 and *y*1 are the number of the column and row of the lower left cell and *x*2 and *y*2 are the number of the column and row of the upper right cell of a rectangle.",In a single line print the sum of all values in the cells of the table.,"['2\n1 1 2 3\n2 2 3 3\n', '2\n1 1 3 3\n1 1 3 3\n']","['10\n', '18\n']","Note to the first sample test:

Values of the table in the first three rows and columns will be as follows:

121

121

110

So, the sum of values will be equal to 10.

Note to the second sample test:

Values of the table in the first three rows and columns will be as follows:

222

222

222

So, the sum of values will be equal to 18.",OK,"def c(d, h, f, j):
    return sum((f[i] - d[i] + 1) * (j[i] - h[i] + 1) for i in range(len(d)))

def a():
    n = int(input())
    d = []
    h = []
    f = []
    j = []
    
    for _ in range(n):
        e, i, g, k = map(int, input().split())
        d.append(e)
        h.append(i)
        f.append(g)
        j.append(k)

    b = c(d, h, f, j)
    print(b)

if __name__ == ""__main__"":
    a()","def c():

    import d
    b = d.stdin.readline().strip()

    A, B = map(int, b.split())

    m = min(A, B)

    a = 1
    for i in range(1, m + 1):
        a *= i

    d.stdout.write(str(a) + ""\n"")

if __name__ == ""__main__"":
    c()"
202,A,LLPS,PROGRAMMING,"['binary search', 'bitmasks', 'brute force', 'greedy', 'implementation', 'strings']","This problem's actual name, ""Lexicographically Largest Palindromic Subsequence"" is too long to fit into the page headline.

You are given string *s* consisting of lowercase English letters only. Find its lexicographically largest palindromic subsequence.

We'll call a non-empty string *s*[*p*1*p*2... *p**k*] = *s**p*1*s**p*2... *s**p**k* (1 <=≤<= *p*1<=&lt;<=*p*2<=&lt;<=...<=&lt;<=*p**k* <=≤<= |*s*|) a subsequence of string *s* = *s*1*s*2... *s*|*s*|, where |*s*| is the length of string *s*. For example, strings ""abcb"", ""b"" and ""abacaba"" are subsequences of string ""abacaba"".

String *x* = *x*1*x*2... *x*|*x*| is lexicographically larger than string *y* = *y*1*y*2... *y*|*y*| if either |*x*| &gt; |*y*| and *x*1<==<=*y*1, *x*2<==<=*y*2, ...,<=*x*|*y*|<==<=*y*|*y*|, or there exists such number *r* (*r*<=&lt;<=|*x*|, *r*<=&lt;<=|*y*|) that *x*1<==<=*y*1, *x*2<==<=*y*2, ..., *x**r*<==<=*y**r* and *x**r*<=<=+<=<=1<=&gt;<=*y**r*<=<=+<=<=1. Characters in the strings are compared according to their ASCII codes. For example, string ""ranger"" is lexicographically larger than string ""racecar"" and string ""poster"" is lexicographically larger than string ""post"".

String *s* = *s*1*s*2... *s*|*s*| is a palindrome if it matches string *rev*(*s*) = *s*|*s*|*s*|*s*|<=-<=1... *s*1. In other words, a string is a palindrome if it reads the same way from left to right and from right to left. For example, palindromic strings are ""racecar"", ""refer"" and ""z"".",The only input line contains a non-empty string *s* consisting of lowercase English letters only. Its length does not exceed 10.,Print the lexicographically largest palindromic subsequence of string *s*.,"['radar\n', 'bowwowwow\n', 'codeforces\n', 'mississipp\n']","['rr\n', 'wwwww\n', 's\n', 'ssss\n']","Among all distinct subsequences of string ""radar"" the following ones are palindromes: ""a"", ""d"", ""r"", ""aa"", ""rr"", ""ada"", ""rar"", ""rdr"", ""raar"" and ""radar"". The lexicographically largest of them is ""rr"".",OK,"from sys import *
import sys
from math import *
from collections import *
import x
import re
from bisect import *
from functools import r
from itertools import permutations, combinations

t=v.readline
R=range
p=w.write
n = int(1e9)+7
d = 9223372036854775808
k = x.ascii_lowercase
y = x.ascii_uppercase
o = x.digits

def S(): return t().strip()
def I(): return int(t())
def a(): return map(int, input().strip().split())
def b(): return map(str, t().strip().split())
def c(): return list(map(int, t().strip().split()))
def e(): return list(map(str, t().strip().split()))
def m(n): return [c() for i in range(n)]
def t(n): return r(lambda r, x: r - set(range(x**2, n, x)) if x in r else r, 
                            range(2, int(n**0.5) + 1), set(range(2,n)))
def i(x): return (f(float(u(x))) == h(float(u(x))))
def j(x): return ((x!=0) and (x&(x-1))==0)
def g(n):return bin(n).replace(""0b"", """")
def l(x,y): return x<<y
def s(x,y): return x<<y
def p(x): return 1<<x  

s=sorted(S())[::-1]
q = s[0]
for i in s:
    if q==i: print(i,end='')
    else: break
    q=i","def e():
    import g
    d = g.stdin.read().splitlines()
    
    if not d:
        return

    n = int(d[0].strip())

    a = []
    for i in range(1, n + 1):
        f = d[i].split()
        x = int(f[0])
        d = int(f[1])
        a.append((x, d))

    for i in range(n):
        j, b = a[i]
        h = j + b

        for j in range(n):
            if i == j:
                continue
            k, c = a[j]
            if k == h:
                i = k + c
                if i == j:
                    print(""YES"")
                    return
    print(""NO"")

if __name__ == '__main__':
    e()"
581,A,Vasya the Hipster,PROGRAMMING,"['implementation', 'math']","One day Vasya the Hipster decided to count how many socks he had. It turned out that he had *a* red socks and *b* blue socks.

According to the latest fashion, hipsters should wear the socks of different colors: a red one on the left foot, a blue one on the right foot.

Every day Vasya puts on new socks in the morning and throws them away before going to bed as he doesn't want to wash them.

Vasya wonders, what is the maximum number of days when he can dress fashionable and wear different socks, and after that, for how many days he can then wear the same socks until he either runs out of socks or cannot make a single pair from the socks he's got.

Can you help him?","The single line of the input contains two positive integers *a* and *b* (1<=≤<=*a*,<=*b*<=≤<=100) — the number of red and blue socks that Vasya's got.","Print two space-separated integers — the maximum number of days when Vasya can wear different socks and the number of days when he can wear the same socks until he either runs out of socks or cannot make a single pair from the socks he's got.

Keep in mind that at the end of the day Vasya throws away the socks that he's been wearing on that day.","['3 1\n', '2 3\n', '7 3\n']","['1 1\n', '2 0\n', '3 2\n']","In the first sample Vasya can first put on one pair of different socks, after that he has two red socks left to wear on the second day.",RUNTIME_ERROR,"def a(a, b):
    p = min(a, b)

    s = ((a - p) // 2) + ((b - p) // 2)

    print(f'{p}  {s}')

a(int(input()), int(input()))","def d():
    import g

    b = g.stdin.read().splitlines()
    if not b:
        return

    n = int(b[0].strip())
    e = b[1:]

    L = len(e[0])

    f = []

    for j in range(L):

        c = set()
        for p in e:
            a = p[j]
            if a != '?':
                c.add(a)

            if len(c) > 1:
                break

        if len(c) > 1:

            f.append('?')
        elif len(c) == 1:

            f.append(c.pop())
        else:

            f.append('a')

    g.stdout.write("""".join(f))
    
if __name__ == '__main__':
    d()"
622,F,The Sum of the k-th Powers,PROGRAMMING,['math'],"There are well-known formulas: , , . Also mathematicians found similar formulas for higher degrees.

Find the value of the sum  modulo 109<=+<=7 (so you should find the remainder after dividing the answer by the value 109<=+<=7).","The only line contains two integers *n*,<=*k* (1<=≤<=*n*<=≤<=109,<=0<=≤<=*k*<=≤<=106).",Print the only integer *a* — the remainder after dividing the value of the sum by the value 109<=+<=7.,"['4 1\n', '4 2\n', '4 3\n', '4 0\n']","['10\n', '30\n', '100\n', '4\n']",none,TIME_LIMIT_EXCEEDED,"def e(n, y, T, f):

    c = [0]*(n+1)
    b = 1
    for i in range(1, n+1):
        b = b*i % f
    c[n] = pow(b, f-2, f)
    for i in range(n-1, -1, -1):
        c[i] = c[i+1]*(i+1) % f

    T %= f

    L = [1]*(n+1)
    for i in range(n):
        L[i+1] = L[i]*(T-i) % f

    R = [1]*(n+1)
    for i in range(n, 0, -1):
        R[i-1] = R[i]*(T-i) % f

    g = 0
    for i in range(n+1):
        h = y[i]*L[i] % f*R[i] % f*c[i] % f*c[n-i] % f
        if (n-i) % 2 == 0:
            g += h
        else:
            g -= h

    return g % f

def d(x, k):
    g = 1
    while k:
        if k & 1:
            g = g*x % f
        x = x*x % f
        k >>= 1
    return g

f = 10**9+7
n, k = map(int, input().split())

s = k+1
a = [0]*(s+1)
g = 0
for i in range(1, s+1):
    g = (g+d(i, k)) % f
    a[i] = g
print(e(s, a, n, f))","import o
import a

def h():

    e = o.stdin.read().split()
    if not e:
        return

    n = int(e[0])
    m = int(e[1])

    a = list(map(int, e[2:2+n]))
    b = list(map(int, e[2+n:2+n+m]))

    a.sort()
    b.sort()

    if a[0] >= b[-1]:
        print(0)
        return

    m = [0] * (n + 1)
    for i in range(n):
        m[i+1] = m[i] + a[i]

    n = [0] * (m + 1)
    for i in range(m):
        n[i+1] = n[i] + b[i]

    def b(T):

        k = a.bisect_left(a, T)

        c = T * k - m[k]

        l = a.bisect_right(b, T)
        j = m - l

        d = (n[m] - n[l]) - T * j
        
        return c + d

    g = a[0]
    f = b[-1]
    while g < f:
        i = (g + f) // 2

        if b(i) <= b(i + 1):
            f = i
        else:
            g = i + 1

    print(b(g))

if __name__ == '__main__':
    h()"
508,A,Pasha and Pixels,PROGRAMMING,['brute force'],"Pasha loves his phone and also putting his hair up... But the hair is now irrelevant.

Pasha has installed a new game to his phone. The goal of the game is following. There is a rectangular field consisting of *n* row with *m* pixels in each row. Initially, all the pixels are colored white. In one move, Pasha can choose any pixel and color it black. In particular, he can choose the pixel that is already black, then after the boy's move the pixel does not change, that is, it remains black. Pasha loses the game when a 2<=×<=2 square consisting of black pixels is formed. 

Pasha has made a plan of *k* moves, according to which he will paint pixels. Each turn in his plan is represented as a pair of numbers *i* and *j*, denoting respectively the row and the column of the pixel to be colored on the current move.

Determine whether Pasha loses if he acts in accordance with his plan, and if he does, on what move the 2<=×<=2 square consisting of black pixels is formed.","The first line of the input contains three integers *n*,<=*m*,<=*k* (1<=≤<=*n*,<=*m*<=≤<=1000, 1<=≤<=*k*<=≤<=105) — the number of rows, the number of columns and the number of moves that Pasha is going to perform. 

The next *k* lines contain Pasha's moves in the order he makes them. Each line contains two integers *i* and *j* (1<=≤<=*i*<=≤<=*n*, 1<=≤<=*j*<=≤<=*m*), representing the row number and column number of the pixel that was painted during a move.","If Pasha loses, print the number of the move when the 2<=×<=2 square consisting of black pixels is formed.

If Pasha doesn't lose, that is, no 2<=×<=2 square consisting of black pixels is formed during the given *k* moves, print 0.","['2 2 4\n1 1\n1 2\n2 1\n2 2\n', '2 3 6\n2 3\n2 2\n1 3\n2 2\n1 2\n1 1\n', '5 3 7\n2 3\n1 2\n1 1\n4 1\n3 1\n5 3\n3 2\n']","['4\n', '5\n', '0\n']",none,RUNTIME_ERROR,"from collections import a

b = [(0, 1), (1, 0), (1, 1), (0, 0)]
n, m, k = map(int, input().split())
e = a(lambda: float('inf'))
for i in range(k):
    e[tuple(map(int, input().split()))] = min(e[tuple(map(int, input().split()))], i)
for x, y in e.keys():
    if all((x + c, y + d) in e.keys() for c, d in b):
        print(max(e[(x + c, y + d)] for c, d in b) + 1)
        break
else:
    print(0)","def k():
    import l
    l.setrecursionlimit(10000)
    
    b = l.stdin.read().strip().splitlines()
    if not b:
        return

    from functools import e

    @e(maxsize=None)
    def j(n):
        """"""
        Compute the length of the sequence generated from n.
        If n is 0 or 1, the sequence is [n] and length is 1.
        If n > 1, then sequence = f(n//2) + [n % 2] + f(n//2)
        so length = 2 * len(f(n//2)) + 1.
        """"""
        if n < 2:
            return 1
        return 2 * j(n // 2) + 1

    def a(n, l, r):
        """"""
        Count the number of 1's in the final sequence for the number n,
        within the 1-indexed positions [l, r].
        The sequence is defined recursively:
            if n < 2: sequence = [n]
            else: sequence = f(n//2) + [n % 2] + f(n//2)
        """"""

        if n < 2:
            if l <= 1 <= r:
                return n
            return 0

        c = j(n // 2)
        m = 0

        if l <= c:
            m += a(n // 2, l, min(r, c))

        if l <= c + 1 <= r:
            m += n % 2

        if r > c + 1:
            f = max(1, l - (c + 1))
            g = r - (c + 1)
            m += a(n // 2, f, g)
        return m

    h = []

    for d in b:
        if not d.strip():
            continue
        i = d.strip().split()
        if len(i) < 3:
            continue
        n = int(i[0])
        l = int(i[1])
        r = int(i[2])
        h.append(str(a(n, l, r)))
    
    l.stdout.write(""\n"".join(h))

if __name__ == '__main__':
    k()"
0,none,none,none,['none'],"One day student Vasya was sitting on a lecture and mentioned a string *s*1*s*2... *s**n*, consisting of letters ""a"", ""b"" and ""c"" that was written on his desk. As the lecture was boring, Vasya decided to complete the picture by composing a graph *G* with the following properties: 
 -  *G* has exactly *n* vertices, numbered from 1 to *n*. -  For all pairs of vertices *i* and *j*, where *i*<=≠<=*j*, there is an edge connecting them if and only if characters *s**i* and *s**j* are either equal or neighbouring in the alphabet. That is, letters in pairs ""a""-""b"" and ""b""-""c"" are neighbouring, while letters ""a""-""c"" are not. 
Vasya painted the resulting graph near the string and then erased the string. Next day Vasya's friend Petya came to a lecture and found some graph at his desk. He had heard of Vasya's adventure and now he wants to find out whether it could be the original graph *G*, painted by Vasya. In order to verify this, Petya needs to know whether there exists a string *s*, such that if Vasya used this *s* he would produce the given graph *G*.","The first line of the input contains two integers *n* and *m*  — the number of vertices and edges in the graph found by Petya, respectively.

Each of the next *m* lines contains two integers *u**i* and *v**i* (1<=≤<=*u**i*,<=*v**i*<=≤<=*n*,<=*u**i*<=≠<=*v**i*) — the edges of the graph *G*. It is guaranteed, that there are no multiple edges, that is any pair of vertexes appear in this list no more than once.","In the first line print ""Yes"" (without the quotes), if the string *s* Petya is interested in really exists and ""No"" (without the quotes) otherwise.

If the string *s* exists, then print it on the second line of the output. The length of *s* must be exactly *n*, it must consist of only letters ""a"", ""b"" and ""c"" only, and the graph built using this string must coincide with *G*. If there are multiple possible answers, you may print any of them.","['2 1\n1 2\n', '4 3\n1 2\n1 3\n1 4\n']","['Yes\naa\n', 'No\n']","In the first sample you are given a graph made of two vertices with an edge between them. So, these vertices can correspond to both the same and adjacent letters. Any of the following strings ""aa"", ""ab"", ""ba"", ""bb"", ""bc"", ""cb"", ""cc"" meets the graph's conditions. 

In the second sample the first vertex is connected to all three other vertices, but these three vertices are not connected with each other. That means that they must correspond to distinct letters that are not adjacent, but that is impossible as there are only two such letters: a and c.",WRONG_ANSWER,"from collections import defaultdict,deque,Counter,OrderedDict

def e():
    n,m = map(int,input().split())
    a = [[] for i in range(n+1)]

    for i in range(m):
        a,b = map(int,input().split())
        a[a].append(b)
        a[b].append(a)
    b = [""d""]*(n+1)
    g = [0] * (n + 1)
    for i in range(1,n+1):
        if len(a[i]) == n-1:
            g[i] = 1
            b[i] = ""b""
    f = b.index(""d"")
    def d(f,c):
        if g[f]: return
        g[f] = 1
        b[f] = c
        for i in a[f]:
            d(i,c)

    d(f,""a"")
    if ""d"" in b:
        f = b.index(""d"")
        d(f,""c"")
    if ""d"" in b:
        print(""No"")
    else:
        print(""Yes"")
        print("""".join(b[1:]))

if __name__ == ""__main__"":
    e()","def c():
    import d

    b = d.stdin.read().split()

    n = int(b[0])
    m = int(b[1])

    f = list(map(int, b[2:]))
    
    a = 1
    g = 0

    for e in f:

        if e >= a:
            g += e - a

        else:
            g += n - a + e
        a = e

    d.stdout.write(str(g))
    
if __name__ == ""__main__"":
    c()"
766,B,Mahmoud and a Triangle,PROGRAMMING,"['constructive algorithms', 'geometry', 'greedy', 'math', 'number theory', 'sortings']","Mahmoud has *n* line segments, the *i*-th of them has length *a**i*. Ehab challenged him to use exactly 3 line segments to form a non-degenerate triangle. Mahmoud doesn't accept challenges unless he is sure he can win, so he asked you to tell him if he should accept the challenge. Given the lengths of the line segments, check if he can choose exactly 3 of them to form a non-degenerate triangle.

Mahmoud should use exactly 3 line segments, he can't concatenate two line segments or change any length. A non-degenerate triangle is a triangle with positive area.","The first line contains single integer *n* (3<=≤<=*n*<=≤<=105) — the number of line segments Mahmoud has.

The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=109) — the lengths of line segments Mahmoud has.","In the only line print ""YES"" if he can choose exactly three line segments and form a non-degenerate triangle with them, and ""NO"" otherwise.","['5\n1 5 3 2 4\n', '3\n4 1 2\n']","['YES\n', 'NO\n']","For the first example, he can use line segments with lengths 2, 4 and 5 to form a non-degenerate triangle.",WRONG_ANSWER,"""""""
B. Mahmoud and a Triangle: constructive algorithms, geometry, greedy, math, number theory, sortings

time limit per test: 2 seconds
memory limit per test: 256 megabytes
input: standard input
output: standard output

Mahmoud has n line segments, the i-th of them has length ai.
Ehab challenged him to use exactly 3 line segments to form a non-degenerate triangle.
Mahmoud doesn't accept challenges unless he is sure he can win, so he asked you to tell him if he should accept the challenge.
Given the lengths of the line segments, check if he can choose exactly 3 of them to form a non-degenerate triangle.
Mahmoud should use exactly 3 line segments, he can't concatenate two line segments or change any length.
A non-degenerate triangle is a triangle with positive area.

Input
The first line contains single integer n (3 ≤ n ≤ 10^5) — the number of line segments Mahmoud has.
The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 10^9) — the lengths of line segments Mahmoud has.

Output
In the only line print ""YES"" if he can choose exactly three line segments and form a non-degenerate triangle with them, and ""NO"" otherwise.
""""""

def a():
    n = int(input())
    a = list(map(int, input().split(' ')))

    a.sort()

    print('YES' if sum(a[-3:-1]) > max(a) else 'NO')

if __name__ == '__main__':
    a()","def j():
    import k
    k.setrecursionlimit(10000)
    c = k.stdin.read().split()
    if not c:
        return

    n = int(c[0])
    l = int(c[1])
    r = int(c[2])

    def f(x):
        """"""
        Calculate the length of the sequence generated from x.
        For x = 0 or 1, the sequence is just [x] having length 1.
        For x > 1, the sequence is F(floor(x/2)) + [x % 2] + F(floor(x/2)).
        """"""
        if x <= 1:
            return 1
        return 2 * f(x // 2) + 1

    def b(x, l, r):
        """"""
        Count the number of 1's in the range [l, r] (1-indexed) in 
        the sequence generated from x.
        """"""
        if x <= 1:

            return (r - l + 1) * x

        e = f(x // 2)
        g = e + 1
        a = 0

        if l <= e:
            d = min(r, e)
            a += b(x // 2, l, d)

        if l <= g <= r:
            a += x % 2

        if r > g:
            h = max(l - g, 1)
            i = r - g
            a += b(x // 2, h, i)
        return a

    k.stdout.write(str(b(n, l, r)) + ""\n"")

if __name__ == '__main__':
    j()"
818,E,Card Game Again,PROGRAMMING,"['binary search', 'data structures', 'number theory', 'two pointers']","Vova again tries to play some computer card game.

The rules of deck creation in this game are simple. Vova is given an existing deck of *n* cards and a magic number *k*. The order of the cards in the deck is fixed. Each card has a number written on it; number *a**i* is written on the *i*-th card in the deck.

After receiving the deck and the magic number, Vova removes *x* (possibly *x*<==<=0) cards from the top of the deck, *y* (possibly *y*<==<=0) cards from the bottom of the deck, and the rest of the deck is his new deck (Vova has to leave at least one card in the deck after removing cards). So Vova's new deck actually contains cards *x*<=+<=1, *x*<=+<=2, ... *n*<=-<=*y*<=-<=1, *n*<=-<=*y* from the original deck.

Vova's new deck is considered valid iff the product of all numbers written on the cards in his new deck is divisible by *k*. So Vova received a deck (possibly not a valid one) and a number *k*, and now he wonders, how many ways are there to choose *x* and *y* so the deck he will get after removing *x* cards from the top and *y* cards from the bottom is valid?","The first line contains two integers *n* and *k* (1<=≤<=*n*<=≤<=100<=000, 1<=≤<=*k*<=≤<=109).

The second line contains *n* integers *a*1, *a*2, ..., *a**n* (1<=≤<=*a**i*<=≤<=109) — the numbers written on the cards.",Print the number of ways to choose *x* and *y* so the resulting deck is valid.,"['3 4\n6 2 8\n', '3 6\n9 1 14\n']","['4\n', '1\n']","In the first example the possible values of *x* and *y* are:
 1.  *x* = 0, *y* = 0; 1.  *x* = 1, *y* = 0; 1.  *x* = 2, *y* = 0; 1.  *x* = 0, *y* = 1.",WRONG_ANSWER,"a=0
def c(l,k):
  d=1
  for i in l:
    d=d*i
  if(d%k==0):
    return 1
  else:
    return 0
def b(l,k):
  global a
  
  if(c(l,k)):
    a+=1
  if(len(l)==1):
    return
  else:
    m=l[len(l)-1]
    l.pop()
    b(l,k)
    l.append(m)
    m=l[0]
    l.pop(0)
    b(l,k)
    l.insert(0,m)
n,k=[int(x) for x in input().strip().split()]
b([int(x) for x in input().strip().split()],k)
print(a)","def c(n):

    e = 1
    for i in range(1, n + 1):
        e *= i
    return e

def d():
    import f

    b = f.stdin.read().strip().split()
    if not b:
        return

    A, B = map(int, b)

    a = c(min(A, B))

    print(a)

if __name__ == ""__main__"":
    d()"
807,A,Is it rated?,PROGRAMMING,"['implementation', 'sortings']","Is it rated?

Here it is. The Ultimate Question of Competitive Programming, Codeforces, and Everything. And you are here to answer it.

Another Codeforces round has been conducted. No two participants have the same number of points. For each participant, from the top to the bottom of the standings, their rating before and after the round is known.

It's known that if at least one participant's rating has changed, then the round was rated for sure.

It's also known that if the round was rated and a participant with lower rating took a better place in the standings than a participant with higher rating, then at least one round participant's rating has changed.

In this problem, you should not make any other assumptions about the rating system.

Determine if the current round is rated, unrated, or it's impossible to determine whether it is rated of not.","The first line contains a single integer *n* (2<=≤<=*n*<=≤<=1000) — the number of round participants.

Each of the next *n* lines contains two integers *a**i* and *b**i* (1<=≤<=*a**i*,<=*b**i*<=≤<=4126) — the rating of the *i*-th participant before and after the round, respectively. The participants are listed in order from the top to the bottom of the standings.","If the round is rated for sure, print ""rated"". If the round is unrated for sure, print ""unrated"". If it's impossible to determine whether the round is rated or not, print ""maybe"".","['6\n3060 3060\n2194 2194\n2876 2903\n2624 2624\n3007 2991\n2884 2884\n', '4\n1500 1500\n1300 1300\n1200 1200\n1400 1400\n', '5\n3123 3123\n2777 2777\n2246 2246\n2246 2246\n1699 1699\n']","['rated\n', 'unrated\n', 'maybe\n']","In the first example, the ratings of the participants in the third and fifth places have changed, therefore, the round was rated.

In the second example, no one's rating has changed, but the participant in the second place has lower rating than the participant in the fourth place. Therefore, if the round was rated, someone's rating would've changed for sure.

In the third example, no one's rating has changed, and the participants took places in non-increasing order of their rating. Therefore, it's impossible to determine whether the round is rated or not.",WRONG_ANSWER,"def b():
    c=int(input())
    a=0
    d=[]
    for i in range(c):
        e=input()
        e=e.split()
        if e[0]!=e[1]:
            a=1
            
        d.append(int(e[0]))
    if a==1:
        print(""rated"")
    else:
        if sorted(d)==d:
            print(""maybe"")
        else:
            print(""unrated"")
if __name__==""__main__"":
    b()","def e():

    a, b = map(int, input().split())

    d = 0
    c = 0
    g = 0

    for f in range(1, 7):

        a = abs(a - f)
        b = abs(b - f)

        if a < b:
            d += 1
        elif a == b:
            c += 1
        else:
            g += 1

    print(d, c, g)

if __name__ == '__main__':
    e()"
831,A,Unimodal Array,PROGRAMMING,['implementation'],"Array of integers is unimodal, if:
 -  it is strictly increasing in the beginning; -  after that it is constant; -  after that it is strictly decreasing. 
The first block (increasing) and the last block (decreasing) may be absent. It is allowed that both of this blocks are absent.

For example, the following three arrays are unimodal: [5,<=7,<=11,<=11,<=2,<=1], [4,<=4,<=2], [7], but the following three are not unimodal: [5,<=5,<=6,<=6,<=1], [1,<=2,<=1,<=2], [4,<=5,<=5,<=6].

Write a program that checks if an array is unimodal.","The first line contains integer *n* (1<=≤<=*n*<=≤<=100) — the number of elements in the array.

The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=1<=000) — the elements of the array.","Print ""YES"" if the given array is unimodal. Otherwise, print ""NO"".

You can output each letter in any case (upper or lower).","['6\n1 5 5 5 4 2\n', '5\n10 20 30 20 10\n', '4\n1 2 1 2\n', '7\n3 3 3 3 3 3 3\n']","['YES\n', 'YES\n', 'NO\n', 'YES\n']","In the first example the array is unimodal, because it is strictly increasing in the beginning (from position 1 to position 2, inclusively), that it is constant (from position 2 to position 4, inclusively) and then it is strictly decreasing (from position 4 to position 6, inclusively).",OK,"""""""831.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hYxPSks58iBj6lqO-ZFgsg_7bcRbm3l3
""""""

a=int(input())
b=list(map(int,input().split()))
i=1
while i<a and b[i-1]<b[i]:
  i+=1
while i<a and b[i-1]==b[i]:
  i+=1
while i<a and b[i-1]>b[i]:
  i+=1
if i==a:
  print(""Yes"")
else:
  print(""No"")","""""""
Anton and Danik game outcome script.
Determines who won more games based on the input string.
""""""

def c():

    n = int(input().strip())

    d = input().strip()

    a = d.count('A')
    b = d.count('D')

    if a > b:
        print(""Anton"")
    elif b > a:
        print(""Danik"")
    else:
        print(""Friendship"")

if __name__ == ""__main__"":
    c()"
104,A,Blackjack,PROGRAMMING,['implementation'],"One rainy gloomy evening when all modules hid in the nearby cafes to drink hot energetic cocktails, the Hexadecimal virus decided to fly over the Mainframe to look for a Great Idea. And she has found one!

Why not make her own Codeforces, with blackjack and other really cool stuff? Many people will surely be willing to visit this splendid shrine of high culture.

In Mainframe a standard pack of 52 cards is used to play blackjack. The pack contains cards of 13 values: 2, 3, 4, 5, 6, 7, 8, 9, 10, jacks, queens, kings and aces. Each value also exists in one of four suits: hearts, diamonds, clubs and spades. Also, each card earns some value in points assigned to it: cards with value from two to ten earn from 2 to 10 points, correspondingly. An ace can either earn 1 or 11, whatever the player wishes. The picture cards (king, queen and jack) earn 10 points. The number of points a card earns does not depend on the suit. The rules of the game are very simple. The player gets two cards, if the sum of points of those cards equals *n*, then the player wins, otherwise the player loses.

The player has already got the first card, it's the queen of spades. To evaluate chances for victory, you should determine how many ways there are to get the second card so that the sum of points exactly equals *n*.",The only line contains *n* (1<=≤<=*n*<=≤<=25) — the required sum of points.,Print the numbers of ways to get the second card in the required way if the first card is the queen of spades.,"['12\n', '20\n', '10\n']","['4', '15', '0']","In the first sample only four two's of different suits can earn the required sum of points.

In the second sample we can use all tens, jacks, queens and kings; overall it's 15 cards, as the queen of spades (as any other card) is only present once in the pack of cards and it's already in use.

In the third sample there is no card, that would add a zero to the current ten points.",WRONG_ANSWER,"from collections import defaultdict as a
b = a(lambda:4)

b[0] = 4
b[10] = 15
b[11] = 8

n = int(input())
x = n - 10
if x > 11:
    print(0)
else:
    print(b[x])","import j

def d():

    b = j.stdin.read().splitlines()
    if not b:
        return

    n, m, k = map(int, b[0].split())

    k = []
    for i in range(1, n + 1):
        h = list(map(int, b[i].split()))
        k.append(h)

    i = list(range(n))
    a = list(range(m))

    e = []

    for c in b[n + 1: n + 1 + k]:
        f = c.split()
        g = f[0]
        x = int(f[1])
        y = int(f[2])
        
        if g == 'c':

            a[x - 1], a[y - 1] = a[y - 1], a[x - 1]
        elif g == 'r':

            i[x - 1], i[y - 1] = i[y - 1], i[x - 1]
        elif g == 'g':

            l = k[i[x - 1]][a[y - 1]]
            e.append(str(l))

    j.stdout.write(""\n"".join(e))

if __name__ == '__main__':
    d()"
914,F,Substrings in a String,PROGRAMMING,"['bitmasks', 'brute force', 'data structures', 'string suffix structures', 'strings']","Given a string *s*, process *q* queries, each having one of the following forms:
 -  1<=*i*<=*c* — Change the *i*-th character in the string to *c*. -  2<=*l*<=*r*<=*y* — Consider the substring of *s* starting at position *l* and ending at position *r*. Output the number of times *y* occurs as a substring in it.","The first line of the input contains the string *s* (1<=≤<=|*s*|<=≤<=105) of lowercase English letters.

The second line contains an integer *q* (1<=≤<=*q*<=≤<=105)  — the number of queries to process.

The next *q* lines describe the queries and may have one of the following forms:
 -  1<=*i*<=*c* (1<=≤<=*i*<=≤<=|*s*|) -  2<=*l*<=*r*<=*y* (1<=≤<=*l*<=≤<=*r*<=≤<=|*s*|) 
*c* is a lowercase English letter and *y* is a non-empty string consisting of only lowercase English letters.

The sum of |*y*| over all queries of second type is at most 105.

It is guaranteed that there is at least one query of second type.

All strings are 1-indexed.

|*s*| is the length of the string *s*.","For each query of type 2, output the required answer in a separate line.","['ababababa\n3\n2 1 7 aba\n1 5 c\n2 1 7 aba\n', 'abcdcbc\n5\n2 1 7 bc\n1 4 b\n2 4 7 bc\n1 2 a\n2 1 4 aa\n']","['3\n1\n', '2\n2\n1\n']","Consider the first sample case. Initially, the string aba occurs 3 times in the range [1, 7]. Note that two occurrences may overlap. 

After the update, the string becomes ababcbaba and now aba occurs only once in the range [1, 7].",WRONG_ANSWER,"def e(x,a,p):
    x[a-1]=p
    return x

def f(x,m,n,k):
    a=0
    i=m-1
    k=list(k)
    while (i+len(k)-1<n):
        while((x[i]!=k[0]) and (i+len(k)-1<n) ):
            i=i+1
        if((x[i]==k[0]) and (i+len(k)-1<n)):
            b=True
            for m in range(len(k)):
                if x[i]==k[m]:
                    i+=1
                else:
                    b=False
                    i+=1
                    break
            if b is True:
                a+=1
        while n>m:
            if(x[n-1] != k[len(k)-1]):
                n-=1
            else:
                break
            
            
    return a
    

str=input()
c=int(input())
str=list(str)

for i in range(c):
    d=input()
    d=d.split("" "")
    if(len(d) == 3):
        str=e(str,int(d[1]),d[2])
    elif(len(d) == 4):
        print(f(str,int(d[1]),int(d[2]),d[3]))","import e

def b():

    n, b, d = map(int, e.stdin.readline().split())

    c = list(map(int, e.stdin.readline().split()))

    f = 0
    a = 0

    for d in c:

        if d <= b:
            f += d

            if f > d:
                a += 1
                f = 0

    print(a)

if __name__ == ""__main__"":
    b()"
276,B,Little Girl and Game,PROGRAMMING,"['games', 'greedy']","The Little Girl loves problems on games very much. Here's one of them.

Two players have got a string *s*, consisting of lowercase English letters. They play a game that is described by the following rules:
 -  The players move in turns; In one move the player can remove an arbitrary letter from string *s*. -  If the player before his turn can reorder the letters in string *s* so as to get a palindrome, this player wins. A palindrome is a string that reads the same both ways (from left to right, and vice versa). For example, string ""abba"" is a palindrome and string ""abc"" isn't. 
Determine which player will win, provided that both sides play optimally well — the one who moves first or the one who moves second.","The input contains a single line, containing string *s* (1<=≤<=|*s*|<=<=≤<=<=103). String *s* consists of lowercase English letters.","In a single line print word ""First"" if the first player wins (provided that both players play optimally well). Otherwise, print word ""Second"". Print the words without the quotes.","['aba\n', 'abca\n']","['First\n', 'Second\n']",none,OK,"import c 
input = c.stdin.readline 
from collections import a , defaultdict
def b():
    return input()[:-1]
import math 

w = b()
c = a(w)
f = sum(x%2 != 0 for x in c.values())
if f == 0 :
    print(""First"")
else :
    print(""First"" if f%2 != 0 else ""Second"")","import j

def h(s, k, k):
    n = len(s)
    c = 0
    g = 0
    a = 0

    for i in range(n):
        if s[i] != k:
            a += 1

        while a > k:
            if s[c] != k:
                a -= 1
            c += 1

        g = max(g, i - c + 1)
    return g

def d():

    b = j.stdin.read().split()

    n = int(b[0])
    k = int(b[1])

    s = b[2]

    e = h(s, k, 'a')
    f = h(s, k, 'b')

    print(max(e, f))

if __name__ == '__main__':
    d()"
158,B,Taxi,PROGRAMMING,"['*special', 'greedy', 'implementation']","After the lessons *n* groups of schoolchildren went outside and decided to visit Polycarpus to celebrate his birthday. We know that the *i*-th group consists of *s**i* friends (1<=≤<=*s**i*<=≤<=4), and they want to go to Polycarpus together. They decided to get there by taxi. Each car can carry at most four passengers. What minimum number of cars will the children need if all members of each group should ride in the same taxi (but one taxi can take more than one group)?","The first line contains integer *n* (1<=≤<=*n*<=≤<=105) — the number of groups of schoolchildren. The second line contains a sequence of integers *s*1,<=*s*2,<=...,<=*s**n* (1<=≤<=*s**i*<=≤<=4). The integers are separated by a space, *s**i* is the number of children in the *i*-th group.",Print the single number — the minimum number of taxis necessary to drive all children to Polycarpus.,"['5\n1 2 4 3 3\n', '8\n2 3 4 4 2 1 3 1\n']","['4\n', '5\n']","In the first test we can sort the children into four cars like this:
 -  the third group (consisting of four children), -  the fourth group (consisting of three children), -  the fifth group (consisting of three children), -  the first and the second group (consisting of one and two children, correspondingly). 
There are other ways to sort the groups into four cars.",OK,"def c(b):
    a = [b.count(i) for i in range(1, 5)]
    return a[3] + a[2] + (a[1]*2 + max(0, a[0] - a[2]) + 3) // 4

n = int(input())
b = list(map(int, input().split()))
d = c(b)
print(d)","def e(s, k, j):
    """"""Return the maximum length of a substring that can be turned into target characters 
       by changing at most k characters.
    """"""
    c = 0
    a = 0
    f = 0

    for h in range(len(s)):

        if s[h] != j:
            a += 1

        while a > k:
            if s[c] != j:
                a -= 1
            c += 1

        f = max(f, h - c + 1)
    
    return f

def d():
    import i

    b = i.stdin.read().split()
    n = int(b[0])
    k = int(b[1])
    s = b[2]

    g = max(e(s, k, 'a'), e(s, k, 'b'))
    print(g)

if __name__ == ""__main__"":
    d()"
471,D,MUH and Cube Walls,PROGRAMMING,"['string suffix structures', 'strings']","Polar bears Menshykov and Uslada from the zoo of St. Petersburg and elephant Horace from the zoo of Kiev got hold of lots of wooden cubes somewhere. They started making cube towers by placing the cubes one on top of the other. They defined multiple towers standing in a line as a wall. A wall can consist of towers of different heights.

Horace was the first to finish making his wall. He called his wall an elephant. The wall consists of *w* towers. The bears also finished making their wall but they didn't give it a name. Their wall consists of *n* towers. Horace looked at the bears' tower and wondered: in how many parts of the wall can he ""see an elephant""? He can ""see an elephant"" on a segment of *w* contiguous towers if the heights of the towers on the segment match as a sequence the heights of the towers in Horace's wall. In order to see as many elephants as possible, Horace can raise and lower his wall. He even can lower the wall below the ground level (see the pictures to the samples for clarification).

Your task is to count the number of segments where Horace can ""see an elephant"".","The first line contains two integers *n* and *w* (1<=≤<=*n*,<=*w*<=≤<=2·105) — the number of towers in the bears' and the elephant's walls correspondingly. The second line contains *n* integers *a**i* (1<=≤<=*a**i*<=≤<=109) — the heights of the towers in the bears' wall. The third line contains *w* integers *b**i* (1<=≤<=*b**i*<=≤<=109) — the heights of the towers in the elephant's wall.","Print the number of segments in the bears' wall where Horace can ""see an elephant"".",['13 5\n2 4 5 5 4 3 2 2 2 3 3 2 1\n3 4 4 3 2\n'],['2'],"The picture to the left shows Horace's wall from the sample, the picture to the right shows the bears' wall. The segments where Horace can ""see an elephant"" are in gray.",RUNTIME_ERROR,"def d(n, w, b, f):

    e = hash(f)

    a = hash(b[:w])

    c = 0

    for i in range(n - w + 1):
        if i > 0:

            a = a * 101 + b[i + w - 1] - b[i - 1] * 101 ** w

        if a == e:
            c += 1

    return c

n, w = map(int, input().split())
b = list(map(int, input().split()))
f = list(map(int, input().split()))

g = d(n, w, b, f)
print(g)","def d():
    import g

    a = g.stdin.read().split()
    if not a:
        return

    n = int(a[0])

    e = []
    for i in range(n):
        e.append(int(a[i + 1]))

    b = [0] * n

    def c(i):

        if b[i] != 0:
            return b[i]

        if e[i] == -1:
            b[i] = 1
        else:

            b[i] = 1 + c(e[i] - 1)
        return b[i]

    f = 0

    for i in range(n):
        f = max(f, c(i))

    g.stdout.write(str(f))

if __name__ == ""__main__"":
    d()"
436,A,Feed with Candy,PROGRAMMING,['greedy'],"The hero of the Cut the Rope game is a little monster named Om Nom. He loves candies. And what a coincidence! He also is the hero of today's problem.

One day, Om Nom visited his friend Evan. Evan has *n* candies of two types (fruit drops and caramel drops), the *i*-th candy hangs at the height of *h**i* centimeters above the floor of the house, its mass is *m**i*. Om Nom wants to eat as many candies as possible. At the beginning Om Nom can make at most *x* centimeter high jumps. When Om Nom eats a candy of mass *y*, he gets stronger and the height of his jump increases by *y* centimeters.

What maximum number of candies can Om Nom eat if he never eats two candies of the same type in a row (Om Nom finds it too boring)?","The first line contains two integers, *n* and *x* (1<=≤<=*n*,<=*x*<=≤<=2000) — the number of sweets Evan has and the initial height of Om Nom's jump. 

Each of the following *n* lines contains three integers *t**i*,<=*h**i*,<=*m**i* (0<=≤<=*t**i*<=≤<=1; 1<=≤<=*h**i*,<=*m**i*<=≤<=2000) — the type, height and the mass of the *i*-th candy. If number *t**i* equals 0, then the current candy is a caramel drop, otherwise it is a fruit drop.",Print a single integer — the maximum number of candies Om Nom can eat.,['5 3\n0 2 4\n1 3 1\n0 8 3\n0 20 10\n1 5 5\n'],['4\n'],"One of the possible ways to eat 4 candies is to eat them in the order: 1, 5, 3, 2. Let's assume the following scenario:
 1.  Initially, the height of Om Nom's jump equals 3. He can reach candies 1 and 2. Let's assume that he eats candy 1. As the mass of this candy equals 4, the height of his jump will rise to 3 + 4 = 7. 1.  Now Om Nom can reach candies 2 and 5. Let's assume that he eats candy 5. Then the height of his jump will be 7 + 5 = 12. 1.  At this moment, Om Nom can reach two candies, 2 and 3. He won't eat candy 2 as its type matches the type of the previously eaten candy. Om Nom eats candy 3, the height of his jump is 12 + 3 = 15. 1.  Om Nom eats candy 2, the height of his jump is 15 + 1 = 16. He cannot reach candy 4.",OK,"from copy import a

def b(h, a):
    k = -1
    f = -1
    for i in range(len(a)):
        if (h >= a[i][0]):
            if (k < a[i][1]):
                f = i
                k = a[i][1]
    return(f, k)

n, c = map(int, input().split())

i = [[], []]

for i in range(n):
    t, h, m = map(int, input().split())
    i[t].append((h, m))

i[1].sort()
i[0].sort()

j = a(i)

g = b(c, i[0])
l = 0
d = c
h = b(c, i[1])
m = 1
e = c
while(g[0] >= 0 or h[0] >=0):
    if (g[0] > -1):
        if (len(i[l % 2]) != 1 and g[0] != -1):
            i[l % 2].pop(g[0])
        else:
            i[l % 2] = []
        l += 1
        d += g[1]
        g = b(d, i[l % 2])
    if (h[0] > -1):
        if (len(j[m % 2]) != 1 and h[0] != -1):
            j[m % 2].pop(h[0])
        else:
            j[m % 2] = []
        m += 1
        e += h[1]
        h = b(e, j[m % 2])
print(max(l, m - 1))","import m
from collections import g

def j():

    m.setrecursionlimit(10**6)

    f = m.stdin.read().strip().split()
    if not f:
        return
    i = iter(f)

    n = int(next(i))
    m = int(next(i))

    h = [[] for _ in range(n + 1)]
    for _ in range(m):
        u = int(next(i))
        v = int(next(i))
        h[u].append(v)
        h[v].append(u)
    
    o = [False] * (n + 1)
    n = 0

    for a in range(1, n + 1):
        if not o[a]:

            l = g([a])
            o[a] = True
            d = 0
            b = 0
            
            while l:
                e = l.popleft()
                d += 1
                b += len(h[e])
                for k in h[e]:
                    if not o[k]:
                        o[k] = True
                        l.append(k)

            c = b // 2

            n += max(0, d - c)

    m.stdout.write(str(n))
    
if __name__ == '__main__':
    j()"
675,A,Infinite Sequence,PROGRAMMING,['math'],"Vasya likes everything infinite. Now he is studying the properties of a sequence *s*, such that its first element is equal to *a* (*s*1<==<=*a*), and the difference between any two neighbouring elements is equal to *c* (*s**i*<=-<=*s**i*<=-<=1<==<=*c*). In particular, Vasya wonders if his favourite integer *b* appears in this sequence, that is, there exists a positive integer *i*, such that *s**i*<==<=*b*. Of course, you are the person he asks for a help.","The first line of the input contain three integers *a*, *b* and *c* (<=-<=109<=≤<=*a*,<=*b*,<=*c*<=≤<=109) — the first element of the sequence, Vasya's favorite number and the difference between any two neighbouring elements of the sequence, respectively.","If *b* appears in the sequence *s* print ""YES"" (without quotes), otherwise print ""NO"" (without quotes).","['1 7 3\n', '10 10 0\n', '1 -4 5\n', '0 60 50\n']","['YES\n', 'YES\n', 'NO\n', 'NO\n']","In the first sample, the sequence starts from integers 1, 4, 7, so 7 is its element.

In the second sample, the favorite integer of Vasya is equal to the first element of the sequence.

In the third sample all elements of the sequence are greater than Vasya's favorite integer.

In the fourth sample, the sequence starts from 0, 50, 100, and all the following elements are greater than Vasya's favorite integer.",WRONG_ANSWER,"def a(a, b, c):
    if a - b == 0:
        return ""YES""
    elif c == 0:
        return ""NO""
    elif (a - b) % c != 0 and (a - b) * c < 0:
        return ""NO""
    return ""YES""

A, B, C = [int(i) for i in input().split()]
print(a(A, B, C))","import d

def c():

    b = d.stdin.read().split()
    if not b:
        return

    n = int(b[0])
    k = int(b[1])
    
    g = []

    for i in range(n):
        p = int(b[2 + i * 2])
        t = int(b[2 + i * 2 + 1])
        g.append((p, t))

    g.sort(key=lambda x: (-x[0], x[1]))

    e = g[k - 1]

    a = sum(1 for f in g if f == e)
    print(a)

if __name__ == '__main__':
    c()"
1011,A,Stages,PROGRAMMING,"['greedy', 'implementation', 'sortings']","Natasha is going to fly to Mars. She needs to build a rocket, which consists of several stages in some order. Each of the stages is defined by a lowercase Latin letter. This way, the rocket can be described by the string — concatenation of letters, which correspond to the stages.

There are $n$ stages available. The rocket must contain exactly $k$ of them. Stages in the rocket should be ordered by their weight. So, after the stage with some letter can go only stage with a letter, which is at least two positions after in the alphabet (skipping one letter in between, or even more). For example, after letter 'c' can't go letters 'a', 'b', 'c' and 'd', but can go letters 'e', 'f', ..., 'z'.

For the rocket to fly as far as possible, its weight should be minimal. The weight of the rocket is equal to the sum of the weights of its stages. The weight of the stage is the number of its letter in the alphabet. For example, the stage 'a 'weighs one ton,' b 'weighs two tons, and' z' — $26$ tons.

Build the rocket with the minimal weight or determine, that it is impossible to build a rocket at all. Each stage can be used at most once.","The first line of input contains two integers — $n$ and $k$ ($1 \le k \le n \le 50$) – the number of available stages and the number of stages to use in the rocket.

The second line contains string $s$, which consists of exactly $n$ lowercase Latin letters. Each letter defines a new stage, which can be used to build the rocket. Each stage can be used at most once.","Print a single integer — the minimal total weight of the rocket or -1, if it is impossible to build the rocket at all.","['5 3\nxyabd\n', '7 4\nproblem\n', '2 2\nab\n', '12 1\nabaabbaaabbb\n']","['29', '34', '-1', '1']","In the first example, the following rockets satisfy the condition:
-  ""adx"" (weight is $1+4+24=29$);-  ""ady"" (weight is $1+4+25=30$);-  ""bdx"" (weight is $2+4+24=30$);-  ""bdy"" (weight is $2+4+25=31$).
Rocket ""adx"" has the minimal weight, so the answer is $29$.

In the second example, target rocket is ""belo"". Its weight is $2+5+12+15=34$.

In the third example, $n=k=2$, so the rocket must have both stages: 'a' and 'b'. This rocket doesn't satisfy the condition, because these letters are adjacent in the alphabet. Answer is -1.",WRONG_ANSWER,"def b():
    return map(int, input().split())
n,k = b()
s = list(input())
s.sort()
for i in range(n):
    s[i] = ord(s[i])-ord('a')+1
a = s[0]
k-=1
for i in range(1,n):
    if not k:
        break
    if s[i]-s[i-1]>1:
        a+=s[i]
        k-=1
if k:
    print (-1)
else:
    print(a)","import h

def e():

    c = h.stdin.readlines()

    for d in c:

        d = d.strip()
        if not d:
            continue

        f = d.split()
        if len(f) != 2:
            continue
        n, m = map(int, f)

        a = n // m
        g = n % m

        b = [a] * (m - g) + [a + 1] * g

        print(' '.join(map(str, b)) + ' ')
        
if __name__ == ""__main__"":
    e()"
721,C,Journey,PROGRAMMING,"['dp', 'graphs']","Recently Irina arrived to one of the most famous cities of Berland — the Berlatov city. There are *n* showplaces in the city, numbered from 1 to *n*, and some of them are connected by one-directional roads. The roads in Berlatov are designed in a way such that there are no cyclic routes between showplaces.

Initially Irina stands at the showplace 1, and the endpoint of her journey is the showplace *n*. Naturally, Irina wants to visit as much showplaces as she can during her journey. However, Irina's stay in Berlatov is limited and she can't be there for more than *T* time units.

Help Irina determine how many showplaces she may visit during her journey from showplace 1 to showplace *n* within a time not exceeding *T*. It is guaranteed that there is at least one route from showplace 1 to showplace *n* such that Irina will spend no more than *T* time units passing it.","The first line of the input contains three integers *n*,<=*m* and *T* (2<=≤<=*n*<=≤<=5000,<=<=1<=≤<=*m*<=≤<=5000,<=<=1<=≤<=*T*<=≤<=109) — the number of showplaces, the number of roads between them and the time of Irina's stay in Berlatov respectively.

The next *m* lines describes roads in Berlatov. *i*-th of them contains 3 integers *u**i*,<=*v**i*,<=*t**i* (1<=≤<=*u**i*,<=*v**i*<=≤<=*n*,<=*u**i*<=≠<=*v**i*,<=1<=≤<=*t**i*<=≤<=109), meaning that there is a road starting from showplace *u**i* and leading to showplace *v**i*, and Irina spends *t**i* time units to pass it. It is guaranteed that the roads do not form cyclic routes.

It is guaranteed, that there is at most one road between each pair of showplaces.","Print the single integer *k* (2<=≤<=*k*<=≤<=*n*) — the maximum number of showplaces that Irina can visit during her journey from showplace 1 to showplace *n* within time not exceeding *T*, in the first line.

Print *k* distinct integers in the second line — indices of showplaces that Irina will visit on her route, in the order of encountering them.

If there are multiple answers, print any of them.","['4 3 13\n1 2 5\n2 3 7\n2 4 8\n', '6 6 7\n1 2 2\n1 3 3\n3 6 3\n2 4 2\n4 6 2\n6 5 1\n', '5 5 6\n1 3 3\n3 5 3\n1 2 2\n2 4 3\n4 5 2\n']","['3\n1 2 4 \n', '4\n1 2 4 6 \n', '3\n1 3 5 \n']",none,TIME_LIMIT_EXCEEDED,"from sys import n
from sys import m
def e():
    return m.readline().strip()
def f():
    return [int(i) for i in e().split()]
def i(a, d = ""\n""):
    n.write(str(a) + d)
def j(a, l = "" "", d = ""\n""):
    n.write(l.join([str(i) for i in a]) + d)

def b():
    n, m, t = f()
    g = [[] for i in range(n + 1)]
    for i in range(m):
        v, u, o = f()
        g[v].append([u, o])

    g = 10 ** 18 + 7
    a = [[g] * (n + 1) for i in range(n + 1)]
    a[1][0] = 0
    a = 0
    h = dict()
    for k in range(1, n + 1):
        for i in range(1, n + 1):
            for e in g[i]:
                if(a[e[0]][k] > a[i][k - 1] + e[1]):
                    a[e[0]][k] = a[i][k - 1] + e[1]
                    h[e[0], k] = i
    k = 0
    for j in range(1, n + 1):
        if(a[n][j] <= t):
            k = j
    i(k + 1)
    a = [n]
    c = n

    while(c != 1):
        a.append(h[c, k])
        c = h[c, k]
        k -= 1

    j(a[ :: -1])
b()","def d():

    n = int(input().strip())

    a = list(map(int, input().split()))

    e = float('inf')

    for i in range(1, n - 1):

        b = a[:i] + a[i+1:]

        a = 0
        for j in range(1, len(b)):

            c = b[j] - b[j - 1]

            a = max(a, c)

        e = min(e, a)

    print(e)

if __name__ == '__main__':
    d()"
602,B,Approximating a Constant Range,PROGRAMMING,"['dp', 'implementation', 'two pointers']","When Xellos was doing a practice course in university, he once had to measure the intensity of an effect that slowly approached equilibrium. A good way to determine the equilibrium intensity would be choosing a sufficiently large number of consecutive data points that seems as constant as possible and taking their average. Of course, with the usual sizes of data, it's nothing challenging — but why not make a similar programming contest problem while we're at it?

You're given a sequence of *n* data points *a*1,<=...,<=*a**n*. There aren't any big jumps between consecutive data points — for each 1<=≤<=*i*<=&lt;<=*n*, it's guaranteed that |*a**i*<=+<=1<=-<=*a**i*|<=≤<=1.

A range [*l*,<=*r*] of data points is said to be almost constant if the difference between the largest and the smallest value in that range is at most 1. Formally, let *M* be the maximum and *m* the minimum value of *a**i* for *l*<=≤<=*i*<=≤<=*r*; the range [*l*,<=*r*] is almost constant if *M*<=-<=*m*<=≤<=1.

Find the length of the longest almost constant range.","The first line of the input contains a single integer *n* (2<=≤<=*n*<=≤<=100<=000) — the number of data points.

The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=100<=000).",Print a single number — the maximum length of an almost constant range of the given sequence.,"['5\n1 2 3 3 2\n', '11\n5 4 5 5 6 7 8 8 8 7 6\n']","['4\n', '5\n']","In the first sample, the longest almost constant range is [2, 5]; its length (the number of data points in it) is 4.

In the second sample, there are three almost constant ranges of length 4: [1, 4], [6, 9] and [7, 10]; the only almost constant range of the maximum length 5 is [6, 10].",TIME_LIMIT_EXCEEDED,"def a(d, n):
    i = 0
    b = 0
    while i <= n - b:
        e = []
        c = 0
        j = i
        while j < n:
            if d[j] not in e:
                e.append(d[j])
                if len(e) > 2:
                    break
            c += 1
            j += 1
        if c > b:
            b = c
        i += 1
    return b

if __name__ == ""__main__"":

    n = int(input())
    d = list(map(int, input().split()))

    print(a(d, n))","import e

def c():

    a = e.stdin.read().strip().split()
    if not a:
        return

    n = int(a[0])
    b = []
    b = 1

    for i in range(n):
        d = list(map(int, a[b:b+n]))
        b += n
        b.append(d)

    a = [0] * n
    for i in range(n):
        for j in range(n):
            if i != j:
                a[i] |= b[i][j]

    print("" "".join(map(str, a)))

if __name__ == ""__main__"":
    c()"
61,A,Ultra-Fast Mathematician,PROGRAMMING,['implementation'],"Shapur was an extremely gifted student. He was great at everything including Combinatorics, Algebra, Number Theory, Geometry, Calculus, etc. He was not only smart but extraordinarily fast! He could manage to sum 1018 numbers in a single second.

One day in 230 AD Shapur was trying to find out if any one can possibly do calculations faster than him. As a result he made a very great contest and asked every one to come and take part.

In his contest he gave the contestants many different pairs of numbers. Each number is made from digits 0 or 1. The contestants should write a new number corresponding to the given pair of numbers. The rule is simple: The *i*-th digit of the answer is 1 if and only if the *i*-th digit of the two given numbers differ. In the other case the *i*-th digit of the answer is 0.

Shapur made many numbers and first tried his own speed. He saw that he can perform these operations on numbers of length ∞ (length of a number is number of digits in it) in a glance! He always gives correct answers so he expects the contestants to give correct answers, too. He is a good fellow so he won't give anyone very big numbers and he always gives one person numbers of same length.

Now you are going to take part in Shapur's contest. See if you are faster and more accurate.",There are two lines in each input. Each of them contains a single number. It is guaranteed that the numbers are made from 0 and 1 only and that their length is same. The numbers may start with 0. The length of each number doesn't exceed 100.,Write one line — the corresponding answer. Do not omit the leading 0s.,"['1010100\n0100101\n', '000\n111\n', '1110\n1010\n', '01110\n01100\n']","['1110001\n', '111\n', '0100\n', '00010\n']",none,OK,"def b(n,m):
    a=''
    for i in range(len(n)):
        if(n[i]==m[i]):
            a+='0'
        else:
            a+='1'
    return a

if __name__ == ""__main__"":
    n=input()
    m=input()
    print(b(n,m))","n, s = map(int, input().strip().split())

b = list(map(int, input().strip().split()))

a = max(b)
c = sum(b) - a

if c <= s:
    print(""YES"")
else:
    print(""NO"")"
932,B,Recursive Queries,PROGRAMMING,"['binary search', 'data structures', 'dfs and similar']","Let us define two functions *f* and *g* on positive integer numbers. 

 

You need to process *Q* queries. In each query, you will be given three integers *l*, *r* and *k*. You need to print the number of integers *x* between *l* and *r* inclusive, such that *g*(*x*)<==<=*k*.","The first line of the input contains an integer *Q* (1<=≤<=*Q*<=≤<=2<=×<=105) representing the number of queries. 

*Q* lines follow, each of which contains 3 integers *l*, *r* and *k* (1<=≤<=*l*<=≤<=*r*<=≤<=106,<=1<=≤<=*k*<=≤<=9).","For each query, print a single line containing the answer for that query.","['4\n22 73 9\n45 64 6\n47 55 7\n2 62 4\n', '4\n82 94 6\n56 67 4\n28 59 9\n39 74 4\n']","['1\n4\n0\n8\n', '3\n1\n1\n5\n']","In the first example:
 -  *g*(33) = 9 as *g*(33) = *g*(3 × 3) = *g*(9) = 9 -  *g*(47) = *g*(48) = *g*(60) = *g*(61) = 6 -  There are no such integers between 47 and 55. -  *g*(4) = *g*(14) = *g*(22) = *g*(27) = *g*(39) = *g*(40) = *g*(41) = *g*(58) = 4",TIME_LIMIT_EXCEEDED,"from collections import f
def h(x):

	g = 1
	while x:

		t = x%10
		g = g*max(t,1)
		x = x//10

	return g

d = f(list)

Q = int(input())

for i in range(1,10**6+1):

	s = h(i)
	d[s].append(i)

def a(e,x):

	l = 0
	r = len(e)-1
	while r >= l:

		if e[(r+l)//2] >= x:
			r = (l+r)//2-1
		else:
			l = (l+r)//2+1

	return l
def b(e,x):

	l = 0
	r = len(e)-1

	while r > l:

		if e[(r+l)//2] <= x:
			l = (l+r)//2+1
		else:
			r = (l+r)//2-1

	return r

def c(d,x,l,r):

	d = []
	k = set()
	i = [x]

	while len(i):

		j = i.pop()
		k.add(j)

		if l <= j and r >= j:
			d.append(j)

		for j in d[j]:

			if j not in k:

				i.append(j)

	return d

for i in range(Q):

	l,r,k = map(int,input().split())
	k = list(c(d,k,l,r))
 
	k.sort()
	print(len(k))","def l():
    import v
    v.setrecursionlimit(10**6)
    d = v.stdin.read().split()
    if not d:
        return
    k = 0
    n = int(d[k]); k += 1
    m = int(d[k]); k += 1
    k = int(d[k]); k += 1

    h = set(int(d[k + i]) - 1 for i in range(k))
    k += k

    i = [[] for _ in range(n)]
    for _ in range(m):
        u = int(d[k]) - 1; k += 1
        v = int(d[k]) - 1; k += 1
        i[u].append(v)
        i[v].append(u)

    x = [False] * n
    g = []
    r = 0

    def e(u):
        t = [u]
        c = 0
        b = 0
        j = False
        while t:
            q = t.pop()
            if x[q]:
                continue
            x[q] = True
            c += 1
            if q in h:
                j = True
            b += len(i[q])
            for o in i[q]:
                if not x[o]:
                    t.append(o)
        return c, b // 2, j

    for i in range(n):
        if not x[i]:
            s, f, j = e(i)
            if j:
                g.append((s, f))
            else:
                r += s

    if g:
        m = 0
        n = g[0][0]
        for i in range(1, len(g)):
            if g[i][0] > n:
                n = g[i][0]
                m = i

        w = 0
        for i, (s, _) in enumerate(g):
            if i == m:
                p = n + r
                w += p * (p - 1) // 2
            else:
                w += s * (s - 1) // 2

        a = w - m
        print(a)
    else:

        w = n * (n - 1) // 2
        print(w - m)

if __name__ == '__main__':
    l()"
785,C,Anton and Fairy Tale,PROGRAMMING,"['binary search', 'math']","Anton likes to listen to fairy tales, especially when Danik, Anton's best friend, tells them. Right now Danik tells Anton a fairy tale:

""Once upon a time, there lived an emperor. He was very rich and had much grain. One day he ordered to build a huge barn to put there all his grain. Best builders were building that barn for three days and three nights. But they overlooked and there remained a little hole in the barn, from which every day sparrows came through. Here flew a sparrow, took a grain and flew away...""

More formally, the following takes place in the fairy tale. At the beginning of the first day the barn with the capacity of *n* grains was full. Then, every day (starting with the first day) the following happens:
 -  *m* grains are brought to the barn. If *m* grains doesn't fit to the barn, the barn becomes full and the grains that doesn't fit are brought back (in this problem we can assume that the grains that doesn't fit to the barn are not taken into account). -  Sparrows come and eat grain. In the *i*-th day *i* sparrows come, that is on the first day one sparrow come, on the second day two sparrows come and so on. Every sparrow eats one grain. If the barn is empty, a sparrow eats nothing. 
Anton is tired of listening how Danik describes every sparrow that eats grain from the barn. Anton doesn't know when the fairy tale ends, so he asked you to determine, by the end of which day the barn will become empty for the first time. Help Anton and write a program that will determine the number of that day!","The only line of the input contains two integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=1018) — the capacity of the barn and the number of grains that are brought every day.",Output one integer — the number of the day when the barn will become empty for the first time. Days are numbered starting with one.,"['5 2\n', '8 1\n']","['4\n', '5\n']","In the first sample the capacity of the barn is five grains and two grains are brought every day. The following happens:
 -  At the beginning of the first day grain is brought to the barn. It's full, so nothing happens. -  At the end of the first day one sparrow comes and eats one grain, so 5 - 1 = 4 grains remain. -  At the beginning of the second day two grains are brought. The barn becomes full and one grain doesn't fit to it. -  At the end of the second day two sparrows come. 5 - 2 = 3 grains remain. -  At the beginning of the third day two grains are brought. The barn becomes full again. -  At the end of the third day three sparrows come and eat grain. 5 - 3 = 2 grains remain. -  At the beginning of the fourth day grain is brought again. 2 + 2 = 4 grains remain. -  At the end of the fourth day four sparrows come and eat grain. 4 - 4 = 0 grains remain. The barn is empty. 
So the answer is 4, because by the end of the fourth day the barn becomes empty.",WRONG_ANSWER,"import os
import sys
import math
import random
import datetime
import json
import re
import sqlite3
import time
import csv
import smtplib
import hashlib
import threading
import logging
import tkinter as tk

def c(n, m):
    a = 1
    d = n

    while d > 0:
        d -= a

        if d <= 0:
            break

        d += m

        a += 1

    return a - 1

n, m = map(int, input().split())

b = c(n, m)

print(b)","def e():
    import f
    c = f.stdin.read().split()
    if not c:
        return
    n = int(c[0])

    a = list(map(int, c[1:1+n]))

    d = [[0] * n for _ in range(n)]

    for i in range(n):
        d[i][i] = 1

    for i in range(n - 2, -1, -1):
        for j in range(i + 1, n):

            b = d[i + 1][j] + 1

            for m in range(i + 1, j + 1):
                if a[i] == a[m]:
                    if m == i + 1:

                        b = min(b, d[m][j])
                    else:

                        b = min(b, d[i + 1][m - 1] + d[m][j])
            d[i][j] = b
    
    f.stdout.write(str(d[0][n - 1]))

if __name__ == '__main__':
    e()"
587,A,Duff and Weight Lifting,PROGRAMMING,['greedy'],"Recently, Duff has been practicing weight lifting. As a hard practice, Malek gave her a task. He gave her a sequence of weights. Weight of *i*-th of them is 2*w**i* pounds. In each step, Duff can lift some of the remaining weights and throw them away. She does this until there's no more weight left. Malek asked her to minimize the number of steps.

Duff is a competitive programming fan. That's why in each step, she can only lift and throw away a sequence of weights 2*a*1,<=...,<=2*a**k* if and only if there exists a non-negative integer *x* such that 2*a*1<=+<=2*a*2<=+<=...<=+<=2*a**k*<==<=2*x*, i. e. the sum of those numbers is a power of two.

Duff is a competitive programming fan, but not a programmer. That's why she asked for your help. Help her minimize the number of steps.","The first line of input contains integer *n* (1<=≤<=*n*<=≤<=106), the number of weights.

The second line contains *n* integers *w*1,<=...,<=*w**n* separated by spaces (0<=≤<=*w**i*<=≤<=106 for each 1<=≤<=*i*<=≤<=*n*), the powers of two forming the weights values.",Print the minimum number of steps in a single line.,"['5\n1 1 2 3 3\n', '4\n0 1 2 3\n']","['2\n', '4\n']","In the first sample case: One optimal way would be to throw away the first three in the first step and the rest in the second step. Also, it's not possible to do it in one step because their sum is not a power of two.

In the second sample case: The only optimal way is to throw away one weight in each step. It's not possible to do it in less than 4 steps because there's no subset of weights with more than one weight and sum equal to a power of two.",RUNTIME_ERROR,"n, k = map(int, input().split())
b = list(map(int, input().split()))

b.sort(key = lambda x: x % 10 if x != 100 else x, reverse = True)

t = 0
r = 0
a = 0
for i in b:
    c = i
    if i != 100:
        c += min(k, 10 - i % 10)
        k -= c - i
        r += 100 - c
    t += c // 10
t += min(r // 10, k // 10)
print(t)","def i(b, l):

    n = len(b)
    k = b.count(l)
    if k == 0:
        return 0

    j = [0 if a == l else 1 for a in b]

    e = j + j

    c = sum(e[:k])
    h = c

    for i in range(1, n):
        c = c - e[i - 1] + e[i + k - 1]
        if c < h:
            h = c
    return h

def g():
    import m
    d = m.stdin.read().splitlines()
    if not d:
        return

    n = int(d[0].strip())

    b = d[1].strip()[:n]

    f = i(b, 'H')

    n = i(b, 'T')

    k = min(f, n)
    m.stdout.write(str(k) + ""\n"")

if __name__ == '__main__':
    g()"
520,A,Pangram,PROGRAMMING,"['implementation', 'strings']","A word or a sentence in some language is called a pangram if all the characters of the alphabet of this language appear in it at least once. Pangrams are often used to demonstrate fonts in printing or test the output devices.

You are given a string consisting of lowercase and uppercase Latin letters. Check whether this string is a pangram. We say that the string contains a letter of the Latin alphabet if this letter occurs in the string in uppercase or lowercase.","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=100) — the number of characters in the string.

The second line contains the string. The string consists only of uppercase and lowercase Latin letters.","Output ""YES"", if the string is a pangram and ""NO"" otherwise.","['12\ntoosmallword\n', '35\nTheQuickBrownFoxJumpsOverTheLazyDog\n']","['NO\n', 'YES\n']",none,OK,"n=int(input())
a=input()
m=0
b='abcdefghijklmnopqrstuvwxyz'
for i in b:
    if i not in a.lower():
        m=1
if m==1:
    print(""No"")
else:
    print(""Yes"")","import o

def j():

    d = o.stdin.read().split()
    a = int(d[0])
    b = int(d[1])
    x = int(d[2])
    
    n = a + b

    if b >= a:
        n = '1'
    else:
        n = '0'
    
    g = x + 1

    if n == '1':
        k = (g + 1) // 2
        p = g // 2
    else:
        p = (g + 1) // 2
        k = g // 2

    h = b - k
    i = a - p

    f = []
    a = False
    b = False

    def l(c):
        return '0' if c == '1' else '1'

    for i in range(g):

        if i % 2 == 0:
            c = n
        else:
            c = l(n)

        e = c

        if c == '1' and not a:
            if h > 0:
                e += '1' * h
            a = True
        elif c == '0' and not b:
            if i > 0:
                e += '0' * i
            b = True
        
        f.append(e)

    m = """".join(f)
    o.stdout.write(m)

if __name__ == '__main__':
    j()"
1,B,Spreadsheet,PROGRAMMING,"['implementation', 'math']","In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.

The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 

Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.

Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.","The first line of the input contains integer number *n* (1<=≤<=*n*<=≤<=105), the number of coordinates in the test. Then there follow *n* lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .","Write *n* lines, each line should contain a cell coordinates in the other numeration system.",['2\nR23C55\nBC23\n'],['BC23\nR23C55\n'],none,WRONG_ANSWER,"def d(s):
    r = ''
    c = ''
    i = 1
    while s[i].isdigit():
        r += s[i]
        i += 1
    i += 1
    while i < len(s) and s[i].isdigit():
        c += s[i]
        i += 1
    c = int(c)
    a = ''
    c = []
    while c:
        if c % 26:
            c.append(chr(c % 26 + 64))
        elif c == 26:
            c.append('Z')
            break
        else:
            c.append('Z')
        c //= 26
    while c:
        a += c.pop()
    a += r
    return a

def e(s):
    c = []
    i = 0
    while s[i].isdigit() is False:
        c.append(s[i])
        i += 1
    r = s[i:]
    c = 0
    for j in range(len(c)):
        c += (ord(c[j]) - 64) * (26 ** (len(c) - j - 1))
    a = 'R' + r + 'C' + str(c)
    return a

n = int(input())
c = []
for i in range(n):
    s = input()
    if not s[1].isdigit():
        print(e(s))
    else:
        b = 1
        i = 2
        while b and i < len(s):
            if not s[i].isdigit():
                b -= 1
            i += 1
        if not b:
            print(d(s))
        else:
            print(e(s))","def e(n, d):
    """"""
    Factorizes n by the given factor.
    
    Returns:
    count -- the number of times factor divides n
    n -- the reduced n after factoring out factor completely
    """"""
    a = 0
    while n % d == 0:
        n //= d
        a += 1
    return a, n

def g(a, b):
    """"""
    Returns the minimal number of operations to make a and b equal by the allowed operations.
    If it's impossible, returns -1.
    """"""

    b = {}
    c = {}
    
    for d in [2, 3, 5]:
        a, a = e(a, d)
        b[d] = a
        a, b = e(b, d)
        c[d] = a

    if a != b:
        return -1

    return abs(b[2] - c[2]) + abs(b[3] - c[3]) + abs(b[5] - c[5])

if __name__ == ""__main__"":
    import h

    for f in h.stdin:
        f = f.strip()
        if not f:
            continue
        try:
            a, b = map(int, f.split())
        except ValueError:
            continue
        print(g(a, b))"
478,B,Random Teams,PROGRAMMING,"['combinatorics', 'constructive algorithms', 'greedy', 'math']","*n* participants of the competition were split into *m* teams in some manner so that each team has at least one participant. After the competition each pair of participants from the same team became friends.

Your task is to write a program that will find the minimum and the maximum number of pairs of friends that could have formed by the end of the competition.","The only line of input contains two integers *n* and *m*, separated by a single space (1<=≤<=*m*<=≤<=*n*<=≤<=109) — the number of participants and the number of teams respectively.",The only line of the output should contain two integers *k**min* and *k**max* — the minimum possible number of pairs of friends and the maximum possible number of pairs of friends respectively.,"['5 1\n', '3 2\n', '6 3\n']","['10 10\n', '1 1\n', '3 6\n']","In the first sample all the participants get into one team, so there will be exactly ten pairs of friends.

In the second sample at any possible arrangement one team will always have two participants and the other team will always have one participant. Thus, the number of pairs of friends will always be equal to one.

In the third sample minimum number of newly formed friendships can be achieved if participants were split on teams consisting of 2 people, maximum number can be achieved if participants were split on teams of 1, 1 and 4 people.",WRONG_ANSWER,"b = input().split("" "")
n = int(b[0])
m = int(b[1])

def a(k):
    return k * (k-1) // 2

if m == 1:
    d = a(n)
    c = a(n)
    print(d, c)
else:
    if n % m == 0:
        d = a(n//m)
    else:
        d = a(n//m + 1)
    c = a(n-(m-1))
    print(d, c)","c = input().strip()

b = set(c)
a = len(b)

if a % 2 == 0:

    print(""CHAT WITH HER!"")
else:

    print(""IGNORE HIM!"")"
984,B,Minesweeper,PROGRAMMING,['implementation'],"One day Alex decided to remember childhood when computers were not too powerful and lots of people played only default games. Alex enjoyed playing Minesweeper that time. He imagined that he saved world from bombs planted by terrorists, but he rarely won.

Alex has grown up since then, so he easily wins the most difficult levels. This quickly bored him, and he thought: what if the computer gave him invalid fields in the childhood and Alex could not win because of it?

He needs your help to check it.

A Minesweeper field is a rectangle $n \times m$, where each cell is either empty, or contains a digit from $1$ to $8$, or a bomb. The field is valid if for each cell: 
 -  if there is a digit $k$ in the cell, then exactly $k$ neighboring cells have bombs. -  if the cell is empty, then all neighboring cells have no bombs. 
Two cells are neighbors if they have a common side or a corner (i. e. a cell has at most $8$ neighboring cells).","The first line contains two integers $n$ and $m$ ($1 \le n, m \le 100$) — the sizes of the field.

The next $n$ lines contain the description of the field. Each line contains $m$ characters, each of them is ""."" (if this cell is empty), ""*"" (if there is bomb in this cell), or a digit from $1$ to $8$, inclusive.","Print ""YES"", if the field is valid and ""NO"" otherwise.

You can choose the case (lower or upper) for each letter arbitrarily.","['3 3\n111\n1*1\n111\n', '2 4\n*.*.\n1211\n']","['YES', 'NO']","In the second example the answer is ""NO"" because, if the positions of the bombs are preserved, the first line of the field should be *2*1.

You can read more about Minesweeper in [Wikipedia's article](https://en.wikipedia.org/wiki/Minesweeper_(video_game)).",WRONG_ANSWER,"import f,os,io

input = f.stdin.readlines
def e():
    return(list(map(int,input().split())))

d = input()[1:]

for i in range(len(d)):
    d[i] = list(d[i][:-1])

print(d)

def a(d,i,j):
    b = 0
    if 0 <= i - 1 < len(d):
        if 0 <= j + 1 < len(d[i]):
            if d[i - 1][j + 1] == '*':
                b += 1
        
        if 0 <= j < len(d[i]):
            if d[i - 1][j] == '*':
                b += 1

        if 0 <= j - 1 < len(d[i]):
            if d[i - 1][j - 1] == '*':
                b += 1

    if 0 <= i + 1 < len(d):
        if 0 <= j + 1 < len(d[i]):
            if d[i + 1][j + 1] == '*':
                b += 1
        
        if 0 <= j < len(d[i]):
            if d[i + 1][j] == '*':
                b += 1

        if 0 <= j - 1 < len(d[i]):
            if d[i + 1][j - 1] == '*':
                b += 1
    
    if 0 <= j - 1 < len(d[i]):
        if d[i][j - 1] == '*':
            b += 1
    
    if 0 <= j + 1 < len(d[i]):
        if d[i][j + 1] == '*':
            b += 1

    return b

c = 0

for i in range(len(d)):
    for j in range(len(d[i])):
        if d[i][j].isnumeric():
            x = int(d[i][j])
            if x != a(d,i,j):
                c = 1 
                break
        
        if d[i][j] == '.':
            if a(d,i,j) != 0:
                c = 1
                break 

print(""YES"") if c == 0 else print(""NO"")","import f

def e():

    d = f.stdin.read().splitlines()

    n = int(d[0])

    m = int(d[1])

    b = [int(d[i+2]) for i in range(n)]

    b.sort(reverse=True)
    
    g = 0
    c = 0

    for a in b:
        g += a
        c += 1
        if g >= m:
            print(c)
            return

if __name__ == ""__main__"":
    e()"
1009,A,Game Shopping,PROGRAMMING,['implementation'],"Maxim wants to buy some games at the local game shop. There are $n$ games in the shop, the $i$-th game costs $c_i$.

Maxim has a wallet which can be represented as an array of integers. His wallet contains $m$ bills, the $j$-th bill has value $a_j$.

Games in the shop are ordered from left to right, Maxim tries to buy every game in that order.

When Maxim stands at the position $i$ in the shop, he takes the first bill from his wallet (if his wallet is empty then he proceeds to the next position immediately) and tries to buy the $i$-th game using this bill. After Maxim tried to buy the $n$-th game, he leaves the shop.

Maxim buys the $i$-th game if and only if the value of the first bill (which he takes) from his wallet is greater or equal to the cost of the $i$-th game. If he successfully buys the $i$-th game, the first bill from his wallet disappears and the next bill becomes first. Otherwise Maxim leaves the first bill in his wallet (this bill still remains the first one) and proceeds to the next game.

For example, for array $c = [2, 4, 5, 2, 4]$ and array $a = [5, 3, 4, 6]$ the following process takes place: Maxim buys the first game using the first bill (its value is $5$), the bill disappears, after that the second bill (with value $3$) becomes the first one in Maxim's wallet, then Maxim doesn't buy the second game because $c_2 &gt; a_2$, the same with the third game, then he buys the fourth game using the bill of value $a_2$ (the third bill becomes the first one in Maxim's wallet) and buys the fifth game using the bill of value $a_3$.

Your task is to get the number of games Maxim will buy.","The first line of the input contains two integers $n$ and $m$ ($1 \le n, m \le 1000$) — the number of games and the number of bills in Maxim's wallet.

The second line of the input contains $n$ integers $c_1, c_2, \dots, c_n$ ($1 \le c_i \le 1000$), where $c_i$ is the cost of the $i$-th game.

The third line of the input contains $m$ integers $a_1, a_2, \dots, a_m$ ($1 \le a_j \le 1000$), where $a_j$ is the value of the $j$-th bill from the Maxim's wallet.",Print a single integer — the number of games Maxim will buy.,"['5 4\n2 4 5 2 4\n5 3 4 6\n', '5 2\n20 40 50 20 40\n19 20\n', '6 4\n4 8 15 16 23 42\n1000 1000 1000 1000\n']","['3\n', '0\n', '4\n']","The first example is described in the problem statement.

In the second example Maxim cannot buy any game because the value of the first bill in his wallet is smaller than the cost of any game in the shop.

In the third example the values of the bills in Maxim's wallet are large enough to buy any game he encounter until he runs out of bills in his wallet.",OK,"def g():
    [i, h] = [int(_) for _ in input().split()]
    d = [0] + [int(_) for _ in input().split()]
    b = [0] + [int(_) for _ in input().split()]

    f = 0
    e = 0
    c = 0

    while f < i and e < h:
        e += 1
        a = b[e]
        try:
            f = next(g for g in range(f + 1, i + 1) if d[g] <= a)
            c += 1
        except StopIteration:
            f = i

    print(c)

if __name__ == '__main__':
    g()","import g

def e():

    c = g.stdin.read().split()
    if not c:
        return

    n = int(c[0])
    d = int(c[1])

    s = c[2].strip()

    a = 10**9
    b = [a] * n

    b[0] = 0

    for i in range(n):

        if s[i] == '0' or b[i] == a:
            continue

        for d in range(1, d+1):
            f = i + d

            if f >= n:
                break

            if s[f] == '1':
                b[f] = min(b[f], b[i] + 1)

    if b[n-1] == a:
        print(-1)
    else:
        print(b[n-1])
    
if __name__ == ""__main__"":
    e()"
771,A,Bear and Friendship Condition,PROGRAMMING,"['dfs and similar', 'dsu', 'graphs']","Bear Limak examines a social network. Its main functionality is that two members can become friends (then they can talk with each other and share funny pictures).

There are *n* members, numbered 1 through *n*. *m* pairs of members are friends. Of course, a member can't be a friend with themselves.

Let A-B denote that members A and B are friends. Limak thinks that a network is reasonable if and only if the following condition is satisfied: For every three distinct members (X, Y, Z), if X-Y and Y-Z then also X-Z.

For example: if Alan and Bob are friends, and Bob and Ciri are friends, then Alan and Ciri should be friends as well.

Can you help Limak and check if the network is reasonable? Print ""YES"" or ""NO"" accordingly, without the quotes.","The first line of the input contain two integers *n* and *m* (3<=≤<=*n*<=≤<=150<=000, ) — the number of members and the number of pairs of members that are friends.

The *i*-th of the next *m* lines contains two distinct integers *a**i* and *b**i* (1<=≤<=*a**i*,<=*b**i*<=≤<=*n*,<=*a**i*<=≠<=*b**i*). Members *a**i* and *b**i* are friends with each other. No pair of members will appear more than once in the input.","If the given network is reasonable, print ""YES"" in a single line (without the quotes). Otherwise, print ""NO"" in a single line (without the quotes).","['4 3\n1 3\n3 4\n1 4\n', '4 4\n3 1\n2 3\n3 4\n1 2\n', '10 4\n4 3\n5 10\n8 9\n1 2\n', '3 2\n1 2\n2 3\n']","['YES\n', 'NO\n', 'YES\n', 'NO\n']","The drawings below show the situation in the first sample (on the left) and in the second sample (on the right). Each edge represents two members that are friends. The answer is ""NO"" in the second sample because members (2, 3) are friends and members (3, 4) are friends, while members (2, 4) are not.",WRONG_ANSWER,"e = int(1e9+7)
def g():
	n,m = map(int,input().split())
	a = [[]for i in range(n)]
	for i in range(m):
		a,b = map(int,input().split())
		a[a-1].append(b-1)
		a[b-1].append(a-1)
	def c(s,f,d):
		j[s] = True
		h = False
		b = True
		for i in a[s]:
			if not j[i]:
				b&=c(i,s,f)
			if i==d:
				h = True
		if b and (h or f==-1 or d==-1):
			return True
		return False
	j = [False]*n
	i = True
	for i in range(n):
		if not j[i]:
			i&=c(i,-1,-1)
	if i:
		print(""YES"")
	else:
		print(""NO"")

t = 1
for i in range(t):
	g()","def d():

    n = int(input().strip())

    m = int(input().strip())

    a = []
    for _ in range(n):
        a.append(int(input().strip()))

    a.sort(reverse=True)

    e = 0
    c = 0

    for b in a:
        e += b
        c += 1
        if e >= m:
            break

    print(c)

if __name__ == ""__main__"":
    d()"
757,A,Gotta Catch Em' All!,PROGRAMMING,['implementation'],"Bash wants to become a Pokemon master one day. Although he liked a lot of Pokemon, he has always been fascinated by Bulbasaur the most. Soon, things started getting serious and his fascination turned into an obsession. Since he is too young to go out and catch Bulbasaur, he came up with his own way of catching a Bulbasaur.

Each day, he takes the front page of the newspaper. He cuts out the letters one at a time, from anywhere on the front page of the newspaper to form the word ""Bulbasaur"" (without quotes) and sticks it on his wall. Bash is very particular about case — the first letter of ""Bulbasaur"" must be upper case and the rest must be lower case. By doing this he thinks he has caught one Bulbasaur. He then repeats this step on the left over part of the newspaper. He keeps doing this until it is not possible to form the word ""Bulbasaur"" from the newspaper.

Given the text on the front page of the newspaper, can you tell how many Bulbasaurs he will catch today?

Note: uppercase and lowercase letters are considered different.","Input contains a single line containing a string *s* (1<=<=≤<=<=|*s*|<=<=≤<=<=105) — the text on the front page of the newspaper without spaces and punctuation marks. |*s*| is the length of the string *s*.

The string *s* contains lowercase and uppercase English letters, i.e. .","Output a single integer, the answer to the problem.","['Bulbbasaur\n', 'F\n', 'aBddulbasaurrgndgbualdBdsagaurrgndbb\n']","['1\n', '0\n', '2\n']","In the first case, you could pick: Bulbbasaur.

In the second case, there is no way to pick even a single Bulbasaur.

In the third case, you can rearrange the string to BulbasaurBulbasauraddrgndgddgargndbb to get two words ""Bulbasaur"".",WRONG_ANSWER,"def c(s):
  d = {
    'B': 0,
    'u':0,
    'l':0,
    'b':0,
    'a':0,
    'u':0,
    'r':0,
    's':0
  }
  for c in s:
    if c in 'Bulbbasaur':
      d[c]+=1
  b = 1000000000
  for i in d:
    if not d[i]:
      return 0
    if d['a'] < 2 or d['u'] < 2:
      return 0
    if d[i] < b:
      if i in ['a','u']:
        b = d[i]//2
    b = d[i]
  return b
    
    

def a() :

  s = input()

  print(c(s))

a()","def c():
    import d

    a = d.stdin.read().strip().split()
    if not a:
        return
    a, b = map(int, a)

    if b - a >= 10:
        print(0)
        return

    b = 1

    for x in range(a + 1, b + 1):
        b = (b * (x % 10)) % 10
    print(b)

if __name__ == '__main__':
    c()"
976,A,Minimum Binary Number,PROGRAMMING,['implementation'],"String can be called correct if it consists of characters ""0"" and ""1"" and there are no redundant leading zeroes. Here are some examples: ""0"", ""10"", ""1001"".

You are given a correct string *s*.

You can perform two different operations on this string: 
 1.  swap any pair of adjacent characters (for example, ""101""  ""110""); 1.  replace ""11"" with ""1"" (for example, ""110""  ""10""). 
Let *val*(*s*) be such a number that *s* is its binary representation.

Correct string *a* is less than some other correct string *b* iff *val*(*a*)<=&lt;<=*val*(*b*).

Your task is to find the minimum correct string that you can obtain from the given one using the operations described above. You can use these operations any number of times in any order (or even use no operations at all).","The first line contains integer number *n* (1<=≤<=*n*<=≤<=100) — the length of string *s*.

The second line contains the string *s* consisting of characters ""0"" and ""1"". It is guaranteed that the string *s* is correct.",Print one string — the minimum correct string that you can obtain from the given one.,"['4\n1001\n', '1\n1\n']","['100\n', '1\n']","In the first example you can obtain the answer by the following sequence of operations: ""1001"" <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> ""1010"" <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> ""1100"" <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> ""100"".

In the second example you can't obtain smaller answer no matter what operations you use.",OK,"def b():
    a = input()
    s = input()
    
    print('1' * ('1' in s)  + '0' * s.count('0'))
    
    
if __name__ == ""__main__"":
    b()","n = int(input().strip())

k = 1

while n > 9 * (10 ** (k - 1)):
    n -= 9 * (10 ** (k - 1))
    k += 1

b = 10 ** (k - 1) + (n - 1)

c = str(b)

a = c + c[::-1]

print(a)"
0,none,none,none,['none'],"In Absurdistan, there are *n* towns (numbered 1 through *n*) and *m* bidirectional railways. There is also an absurdly simple road network — for each pair of different towns *x* and *y*, there is a bidirectional road between towns *x* and *y* if and only if there is no railway between them. Travelling to a different town using one railway or one road always takes exactly one hour.

A train and a bus leave town 1 at the same time. They both have the same destination, town *n*, and don't make any stops on the way (but they can wait in town *n*). The train can move only along railways and the bus can move only along roads.

You've been asked to plan out routes for the vehicles; each route can use any road/railway multiple times. One of the most important aspects to consider is safety — in order to avoid accidents at railway crossings, the train and the bus must not arrive at the same town (except town *n*) simultaneously.

Under these constraints, what is the minimum number of hours needed for both vehicles to reach town *n* (the maximum of arrival times of the bus and the train)? Note, that bus and train are not required to arrive to the town *n* at the same moment of time, but are allowed to do so.","The first line of the input contains two integers *n* and *m* (2<=≤<=*n*<=≤<=400, 0<=≤<=*m*<=≤<=*n*(*n*<=-<=1)<=/<=2) — the number of towns and the number of railways respectively.

Each of the next *m* lines contains two integers *u* and *v*, denoting a railway between towns *u* and *v* (1<=≤<=*u*,<=*v*<=≤<=*n*, *u*<=≠<=*v*).

You may assume that there is at most one railway connecting any two towns.","Output one integer — the smallest possible time of the later vehicle's arrival in town *n*. If it's impossible for at least one of the vehicles to reach town *n*, output <=-<=1.","['4 2\n1 3\n3 4\n', '4 6\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4\n', '5 5\n4 2\n3 5\n4 5\n5 1\n1 2\n']","['2\n', '-1\n', '3\n']","In the first sample, the train can take the route <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/7c0aa60a06309ef607b7159fd7f3687ea0d943ce.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> and the bus can take the route <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/a26c2f3e93c9d9be6c21cb5d2bd6ac1f99f4ff55.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>. Note that they can arrive at town 4 at the same time.

In the second sample, Absurdistan is ruled by railwaymen. There are no roads, so there's no way for the bus to reach town 4.",OK,"n, m = map(int, input().split())
a = [[0] * (n + 1) for _ in range(n + 1)]

for _ in range(m):
    u, v = map(int, input().split())
    a[u][v] = 1
    a[v][u] = 1

def a(x):
    b = [(1, 0)]
    c = [0] * (n + 1)

    while b:
        u, v = b.pop(0)
        for i in range(1, n + 1):
            if not c[i] and a[u][i] == x:
                if i == n:
                    return v + 1
                b.append((i, v + 1))
                c[i] = 1

    return -1

if a[1][n]:
    print(a(0))
else:
    print(a(1))","import g

def d():

    c = g.stdin.read().split()
    if not c:
        return
    n = int(c[0])
    k = int(c[1])

    f = list(map(int, c[2:]))

    if k == 1:
        g.stdout.write(str(n))
        return

    f.sort()

    a = set()
    b = 0

    for e in f:

        if e % k == 0 and (e // k) in a:
            continue

        a.add(e)
        b += 1

    g.stdout.write(str(b))
    
if __name__ == '__main__':
    d()"
721,C,Journey,PROGRAMMING,"['dp', 'graphs']","Recently Irina arrived to one of the most famous cities of Berland — the Berlatov city. There are *n* showplaces in the city, numbered from 1 to *n*, and some of them are connected by one-directional roads. The roads in Berlatov are designed in a way such that there are no cyclic routes between showplaces.

Initially Irina stands at the showplace 1, and the endpoint of her journey is the showplace *n*. Naturally, Irina wants to visit as much showplaces as she can during her journey. However, Irina's stay in Berlatov is limited and she can't be there for more than *T* time units.

Help Irina determine how many showplaces she may visit during her journey from showplace 1 to showplace *n* within a time not exceeding *T*. It is guaranteed that there is at least one route from showplace 1 to showplace *n* such that Irina will spend no more than *T* time units passing it.","The first line of the input contains three integers *n*,<=*m* and *T* (2<=≤<=*n*<=≤<=5000,<=<=1<=≤<=*m*<=≤<=5000,<=<=1<=≤<=*T*<=≤<=109) — the number of showplaces, the number of roads between them and the time of Irina's stay in Berlatov respectively.

The next *m* lines describes roads in Berlatov. *i*-th of them contains 3 integers *u**i*,<=*v**i*,<=*t**i* (1<=≤<=*u**i*,<=*v**i*<=≤<=*n*,<=*u**i*<=≠<=*v**i*,<=1<=≤<=*t**i*<=≤<=109), meaning that there is a road starting from showplace *u**i* and leading to showplace *v**i*, and Irina spends *t**i* time units to pass it. It is guaranteed that the roads do not form cyclic routes.

It is guaranteed, that there is at most one road between each pair of showplaces.","Print the single integer *k* (2<=≤<=*k*<=≤<=*n*) — the maximum number of showplaces that Irina can visit during her journey from showplace 1 to showplace *n* within time not exceeding *T*, in the first line.

Print *k* distinct integers in the second line — indices of showplaces that Irina will visit on her route, in the order of encountering them.

If there are multiple answers, print any of them.","['4 3 13\n1 2 5\n2 3 7\n2 4 8\n', '6 6 7\n1 2 2\n1 3 3\n3 6 3\n2 4 2\n4 6 2\n6 5 1\n', '5 5 6\n1 3 3\n3 5 3\n1 2 2\n2 4 3\n4 5 2\n']","['3\n1 2 4 \n', '4\n1 2 4 6 \n', '3\n1 3 5 \n']",none,WRONG_ANSWER,"import a
from functools import lru_cache
from a import b

n, m, T = map(int, input().split())
g = a.defaultdict(list)
i = a.defaultdict(list)

e = [0] * (n + 1)

for _ in range(m):
    u, v, t = map(int, input().split())
    g[u].append(v)
    i[v].append((u, t))
    e[v] += 1

d = b()
d.append(1)

j = []
while d:
    u = d.popleft()
    j.append(u)
    for v in g[u]:
        e[v] -= 1
        if e[v] == 0:
            d.append(v)

c = [[(float('inf'), -1)] * (n + 1) for _ in range(n + 1)]

c[1][1] = (0, -1)

for v in j[1:]:
    for u, t in i[v]:
        for f in range(1, n + 1):
            if c[u][f - 1][0] == float('inf'):
                continue
            if (c[u][f - 1][0] + t) < c[v][f][0]:
                c[v][f] = (c[u][f - 1][0] + t, u)

h = 1
g = []
for f in range(n, 0, -1):
    if c[n][f][0] != float('inf') and c[n][f][0] <= T:
        h = f
        g = []
        while n != -1:
            g.append(n)
            n = c[n][f][1]
            f -= 1
        break

print(h)
print(g[::-1])","a = input().rstrip(""\n"")

if len(a) == 1:
    print(a.swapcase())

elif a.isupper() or a[1:].isupper():
    print(a.swapcase())

else:
    print(a)"
854,A,Fraction,PROGRAMMING,"['brute force', 'constructive algorithms', 'math']","Petya is a big fan of mathematics, especially its part related to fractions. Recently he learned that a fraction  is called proper iff its numerator is smaller than its denominator (*a*<=&lt;<=*b*) and that the fraction is called irreducible if its numerator and its denominator are coprime (they do not have positive common divisors except 1).

During his free time, Petya thinks about proper irreducible fractions and converts them to decimals using the calculator. One day he mistakenly pressed addition button (<=+<=) instead of division button (÷) and got sum of numerator and denominator that was equal to *n* instead of the expected decimal notation. 

Petya wanted to restore the original fraction, but soon he realized that it might not be done uniquely. That's why he decided to determine maximum possible proper irreducible fraction  such that sum of its numerator and denominator equals *n*. Help Petya deal with this problem.","In the only line of input there is an integer *n* (3<=≤<=*n*<=≤<=1000), the sum of numerator and denominator of the fraction.","Output two space-separated positive integers *a* and *b*, numerator and denominator of the maximum possible proper irreducible fraction satisfying the given sum.","['3\n', '4\n', '12\n']","['1 2\n', '1 3\n', '5 7\n']",none,WRONG_ANSWER,"n = int(input())

def a(a, b):
    while a != 0 and b != 0:
        if a > b:
            a %= b
        else:
            b %= a
    if (a + b) == 1:
        return True
    else:
        return False
x = 0
for j in range(n, 1, -1):
    if a(n - j, j):
        if (n - j) / j > x:
            b = j
            x = (n - j) / j
print(min(b, n - b), max(b, n - b))","""""""
This script computes the number of ways an ant can start at vertex D of a tetrahedron 
and return to D in exactly n moves. The tetrahedron's vertices are labeled A, B, C, D.
At each move, the ant moves along an edge to a different vertex.
We derive the recurrence using state transitions and solve it via fast matrix exponentiation.

The recurrence in vector form:
    Let a(n) be the number of ways to be at D after n steps,
        b(n) be the number of ways to be at one specific other vertex (A, B, or C) after n steps.
    Transitions:
        a(n+1) = 3 * b(n)           (from any of A, B, C to D)
        b(n+1) = a(n) + 2 * b(n)      (from D to that vertex, or from one of the other two vertices)
We represent these transitions with the matrix M =
                         [ 0  3 ]
                         [ 1  2 ]
so that:
    [a(n+1), b(n+1)]^T = M * [a(n), b(n)]^T.
Starting vector is [a(0), b(0)]^T = [1, 0]^T.
Thus, the answer a(n) equals (M^n)[0][0] modulo MOD.
""""""

import k

a = 1000000007

def g(A, B):
    """"""
    Multiply two 2x2 matrices A and B modulo MOD.
    """"""
    return [
        [(A[0][0] * B[0][0] + A[0][1] * B[1][0]) % a, (A[0][0] * B[0][1] + A[0][1] * B[1][1]) % a],
        [(A[1][0] * B[0][0] + A[1][1] * B[1][0]) % a, (A[1][0] * B[0][1] + A[1][1] * B[1][1]) % a]
    ]

def h(f, i):
    """"""
    Compute the exponentiation of matrix 'mat' to the given 'power' modulo MOD.
    This is done using fast binary exponentiation.
    """"""

    j = [[1, 0], [0, 1]]
    while i > 0:
        if i & 1:
            j = g(j, f)
        f = g(f, f)
        i //= 2
    return j

def e():
    d = k.stdin.read().strip().split()
    if not d:
        return
    n = int(d[0])

    M = [[0, 3], [1, 2]]

    b = h(M, n)

    c = b[0][0] % a
    k.stdout.write(str(c))
    
if __name__ == ""__main__"":
    e()"
75,C,Modified GCD,PROGRAMMING,"['binary search', 'number theory']","Well, here is another math class task. In mathematics, GCD is the greatest common divisor, and it's an easy task to calculate the GCD between two positive integers.

A common divisor for two positive numbers is a number which both numbers are divisible by.

But your teacher wants to give you a harder task, in this task you have to find the greatest common divisor *d* between two integers *a* and *b* that is in a given range from *low* to *high* (inclusive), i.e. *low*<=≤<=*d*<=≤<=*high*. It is possible that there is no common divisor in the given range.

You will be given the two integers *a* and *b*, then *n* queries. Each query is a range from *low* to *high* and you have to answer each query.","The first line contains two integers *a* and *b*, the two integers as described above (1<=≤<=*a*,<=*b*<=≤<=109). The second line contains one integer *n*, the number of queries (1<=≤<=*n*<=≤<=104). Then *n* lines follow, each line contains one query consisting of two integers, *low* and *high* (1<=≤<=*low*<=≤<=*high*<=≤<=109).","Print *n* lines. The *i*-th of them should contain the result of the *i*-th query in the input. If there is no common divisor in the given range for any query, you should print -1 as a result for this query.",['9 27\n3\n1 5\n10 11\n9 11\n'],['3\n-1\n9\n'],none,OK,"def f(a,b):
    while a>0:
        x=a
        a=b%a
        b=x
    return(x)
def a(L,x):
    c=0
    g=len(L)-1
    while c<=g:
        h=(c+g)//2
        if x==L[h]:
            return(h)
        elif(x>L[h]):
            c=h+1
        else:
            g=h-1
    else:
        return(c)
def b(L,x):
    c=0
    g=len(L)-1
    while c<=g:
        h=(c+g)//2
        if x==L[h]:
            return(h)
        elif(x>L[h]):
            c=h+1
        else:
            g=h-1
    else:
        return(g)
a,b=input().split()
a,b=[int(a),int(b)]
x=f(a,b)
from functools import i
def e(n):
    x=set(i(list.__add__, 
                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))
    return(list(x))
d=e(x)
d.sort()
y=int(input())
for j in range(y):
    c,d=input().split()
    c,d=[int(c),int(d)]
    f=a(d,c)
    g=b(d,d)
    if f>g:
        print(-1)
    else:
        print(d[g])","def g():
    import l

    d = l.stdin.read().strip().split()

    n = int(d[0])
    k = int(d[1])

    e = list(map(int, d[2:2+k]))
    
    m = n * k

    a = set(e)

    h = []
    for j in range(1, m + 1):
        if j not in a:
            h.append(j)

    i = []
    f = 0
    
    for b in range(k):

        c = [e[b]]

        for _ in range(n - 1):
            c.append(h[f])
            f += 1
        i.append(c)

    for k in i:

        print("" "".join(map(str, k)))
        
if __name__ == ""__main__"":
    g()"
839,A,Arya and Bran,PROGRAMMING,['implementation'],"Bran and his older sister Arya are from the same house. Bran like candies so much, so Arya is going to give him some Candies.

At first, Arya and Bran have 0 Candies. There are *n* days, at the *i*-th day, Arya finds *a**i* candies in a box, that is given by the Many-Faced God. Every day she can give Bran at most 8 of her candies. If she don't give him the candies at the same day, they are saved for her and she can give them to him later.

Your task is to find the minimum number of days Arya needs to give Bran *k* candies before the end of the *n*-th day. Formally, you need to output the minimum day index to the end of which *k* candies will be given out (the days are indexed from 1 to *n*).

Print -1 if she can't give him *k* candies during *n* given days.","The first line contains two integers *n* and *k* (1<=≤<=*n*<=≤<=100, 1<=≤<=*k*<=≤<=10000).

The second line contains *n* integers *a*1,<=*a*2,<=*a*3,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=100).","If it is impossible for Arya to give Bran *k* candies within *n* days, print -1.

Otherwise print a single integer — the minimum number of days Arya needs to give Bran *k* candies before the end of the *n*-th day.","['2 3\n1 2\n', '3 17\n10 10 10\n', '1 9\n10\n']","['2', '3', '-1']","In the first sample, Arya can give Bran 3 candies in 2 days.

In the second sample, Arya can give Bran 17 candies in 3 days, because she can give him at most 8 candies per day.

In the third sample, Arya can't give Bran 9 candies, because she can give him at most 8 candies per day and she must give him the candies within 1 day.",WRONG_ANSWER,"import math as mt 
import b,string
input=b.stdin.readline

from collections import defaultdict
L=lambda : list(map(int,input().split()))
a=lambda : list(input().split())
M=lambda : map(int,input().split())
I=lambda :int(input())

n,k=M()
l=L()
g=0
f=0
for i in range(n):
    g+=min(8,l[i])
    if(g>=k):
        print(i+1)
        f=1
        break
if(f==0):
    print(-1)","import i

def c():

    a = i.stdin.read().split()
    if not a:
        return

    n = int(a[0])
    k = int(a[1])

    a = list(map(int, a[2:2+n]))

    f = [(a[i], i) for i in range(n)]

    f.sort(key=lambda x: (-x[0], x[1]))

    g = f[:k]

    j = sum(x[0] for x in g)

    h = sorted(x[1] for x in g)

    d = []
    e = 0

    for b in h[:-1]:

        d.append(b - e + 1)
        e = b + 1

    d.append(n - e)

    i.stdout.write(str(j) + ""\n"")
    i.stdout.write("" "".join(map(str, d)) + ""\n"")

if __name__ == '__main__':
    c()"
58,A,Chat room,PROGRAMMING,"['greedy', 'strings']","Vasya has recently learned to type and log on to the Internet. He immediately entered a chat room and decided to say hello to everybody. Vasya typed the word *s*. It is considered that Vasya managed to say hello if several letters can be deleted from the typed word so that it resulted in the word ""hello"". For example, if Vasya types the word ""ahhellllloou"", it will be considered that he said hello, and if he types ""hlelo"", it will be considered that Vasya got misunderstood and he didn't manage to say hello. Determine whether Vasya managed to say hello by the given word *s*.","The first and only line contains the word *s*, which Vasya typed. This word consisits of small Latin letters, its length is no less that 1 and no more than 100 letters.","If Vasya managed to say hello, print ""YES"", otherwise print ""NO"".","['ahhellllloou\n', 'hlelo\n']","['YES\n', 'NO\n']",none,OK,"def c(s):
    d=""hello""
    b=""h""
    c=0
    for a in s:
        if c==5:
            break
        if a==b:
            c+=1
            if c<5:
                b=d[c]
                
    if c==5:
        print(""YES"")
    else:
        print(""NO"")
s=input()
c(s)","import e

def b(n, k):

    if n == 1:
        return 1

    c = 1 << (n - 1)
    if k == c:
        return n
    elif k < c:
        return b(n - 1, k)
    else:

        return b(n - 1, k - c)

if __name__ == '__main__':

    a = e.stdin.read().split()
    if not a:
        e.exit(0)

    n = int(a[0])
    k = int(a[1])

    d = b(n, k)

    e.stdout.write(str(d))"
371,D,Vessels,PROGRAMMING,"['data structures', 'dsu', 'implementation', 'trees']","There is a system of *n* vessels arranged one above the other as shown in the figure below. Assume that the vessels are numbered from 1 to *n*, in the order from the highest to the lowest, the volume of the *i*-th vessel is *a**i* liters.

Initially, all the vessels are empty. In some vessels water is poured. All the water that overflows from the *i*-th vessel goes to the (*i*<=+<=1)-th one. The liquid that overflows from the *n*-th vessel spills on the floor.

Your task is to simulate pouring water into the vessels. To do this, you will need to handle two types of queries:
 1.  Add *x**i* liters of water to the *p**i*-th vessel; 1.  Print the number of liters of water in the *k**i*-th vessel. 
When you reply to the second request you can assume that all the water poured up to this point, has already overflown between the vessels.","The first line contains integer *n* — the number of vessels (1<=≤<=*n*<=≤<=2·105). The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* — the vessels' capacities (1<=≤<=*a**i*<=≤<=109). The vessels' capacities do not necessarily increase from the top vessels to the bottom ones (see the second sample). The third line contains integer *m* — the number of queries (1<=≤<=*m*<=≤<=2·105). Each of the next *m* lines contains the description of one query. The query of the first type is represented as ""1 *p**i* *x**i*"", the query of the second type is represented as ""2 *k**i*"" (1<=≤<=*p**i*<=≤<=*n*, 1<=≤<=*x**i*<=≤<=109, 1<=≤<=*k**i*<=≤<=*n*).","For each query, print on a single line the number of liters of water in the corresponding vessel.","['2\n5 10\n6\n1 1 4\n2 1\n1 2 5\n1 1 4\n2 1\n2 2\n', '3\n5 10 8\n6\n1 1 12\n2 2\n1 1 6\n1 3 2\n2 2\n2 3\n']","['4\n5\n8\n', '7\n10\n5\n']",none,RUNTIME_ERROR,"n = int(input())
b = list(map(int, input().split()))
f = [0 for x in range(n)]
m = int(input())
e = [tuple(map(int, input().split())) for x in range(m)]

def a(p, x):

    if len(f) <= p:
        return

    if b[p] - f[p] < x:
        c = b[p] - f[p]
    else:
        c = x

    x -= c
    f[p] += c
    if x > 0:
        a(p+1, x)

for d in e:
    if d[0] == 1:
        a(d[1]-1, d[2])
    else:
        print(f[d[1]-1])","import f
import math

def d():

    a = f.stdin.read().strip().split()
    if not a:
        return
    x = int(a[0])
    y = int(a[1])
    l = int(a[2])
    r = int(a[3])
    
    g = set()

    j = []
    i = 1
    while i <= r:
        j.append(i)

        if x > r or i > r // x:
            break
        i *= x

    k = []
    i = 1
    while i <= r:
        k.append(i)
        if y > r or i > r // y:
            break
        i *= y

    for a in j:
        for b in k:
            s = a + b
            if s < l or s > r:
                continue
            g.add(s)

            if b > r - a:
                break

    h = sorted(g)

    b = [l - 1] + h + [r + 1]
    
    e = 0

    for i in range(1, len(b)):
        c = b[i] - b[i - 1] - 1
        if c > e:
            e = c
    
    f.stdout.write(str(e))
    
if __name__ == '__main__':
    d()"
137,C,History,PROGRAMMING,['sortings'],"Polycarpus likes studying at school a lot and he is always diligent about his homework. Polycarpus has never had any problems with natural sciences as his great-great-grandfather was the great physicist Seinstein. On the other hand though, Polycarpus has never had an easy time with history.

Everybody knows that the World history encompasses exactly *n* events: the *i*-th event had continued from the year *a**i* to the year *b**i* inclusive (*a**i*<=&lt;<=*b**i*). Polycarpus easily learned the dates when each of *n* events started and ended (Polycarpus inherited excellent memory from his great-great-granddad). But the teacher gave him a more complicated task: Polycaprus should know when all events began and ended and he should also find out for each event whether it includes another event. Polycarpus' teacher thinks that an event *j* includes an event *i* if *a**j*<=&lt;<=*a**i* and *b**i*<=&lt;<=*b**j*. Your task is simpler: find the number of events that are included in some other event.","The first input line contains integer *n* (1<=≤<=*n*<=≤<=105) which represents the number of events. Next *n* lines contain descriptions of the historical events, one event per line. The *i*<=+<=1 line contains two integers *a**i* and *b**i* (1<=≤<=*a**i*<=&lt;<=*b**i*<=≤<=109) — the beginning and the end of the *i*-th event. No two events start or finish in the same year, that is, *a**i*<=≠<=*a**j*,<=*a**i*<=≠<=*b**j*,<=*b**i*<=≠<=*a**j*,<=*b**i*<=≠<=*b**j* for all *i*, *j* (where *i*<=≠<=*j*). Events are given in arbitrary order.",Print the only integer — the answer to the problem.,"['5\n1 10\n2 9\n3 8\n4 7\n5 6\n', '5\n1 100\n2 50\n51 99\n52 98\n10 60\n', '1\n1 1000000000\n']","['4\n', '4\n', '0\n']","In the first example the fifth event is contained in the fourth. Similarly, the fourth event is contained in the third, the third — in the second and the second — in the first.

In the second example all events except the first one are contained in the first.

In the third example only one event, so the answer is 0.",OK,"import s
from math import log2,floor,k,sqrt,gcd
import bisect

s.setrecursionlimit(10**5)

h = lambda : [int(x) for x in s.stdin.readline().split()]
q = lambda : s.stdin.readline().strip()

def input(): return s.stdin.readline().strip()
def n(a, b, c): return [[c] * b for i in range(a)]
def o(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]
def p(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]
def k(x, y=1): return int(-(-x // y))
def b(): return int(input())
def d(): return map(int, input().split())
def c(N=None): return list(d()) if N is None else [b() for i in range(N)]
def j(): print('Yes')
def g(): print('No')
def i(): print('YES')
def f(): print('NO')
a = 10 ** 18
e =  1000000007

n =int(q())
m = []
for i in range(n):
    t = h()
    m.append(t)
m.sort(key = lambda x : x[0])
l = 0
r = m[0][1]
for i in range(1,len(m)):
    if m[i][1] < r:
        l+=1
    else:
        r= m[i][1]
print(l)","def g(n, m, k):

    def c(x):
        b = 0

        p = min(n, x // m) if m else 0
        b += p * m

        i = p + 1
        while i <= n:
            v = x // i
            if v == 0:
                break

            f = min(n, x // v)
            b += v * (f - i + 1)
            i = f + 1
        return b

    h, e = 1, n * m
    a = e
    while h <= e:
        i = (h + e) // 2
        if c(i) >= k:
            a = i
            e = i - 1
        else:
            h = i + 1
    return a

if __name__ == ""__main__"":
    import k

    d = k.stdin.read().split()
    if not d:
        k.exit(0)
    n, m, k = map(int, d[:3])

    if n > m:
        n, m = m, n
    j = g(n, m, k)
    print(j)"
568,A,Primes or Palindromes?,PROGRAMMING,"['brute force', 'implementation', 'math', 'number theory']","Rikhail Mubinchik believes that the current definition of prime numbers is obsolete as they are too complex and unpredictable. A palindromic number is another matter. It is aesthetically pleasing, and it has a number of remarkable properties. Help Rikhail to convince the scientific community in this!

Let us remind you that a number is called prime if it is integer larger than one, and is not divisible by any positive integer other than itself and one.

Rikhail calls a number a palindromic if it is integer, positive, and its decimal representation without leading zeros is a palindrome, i.e. reads the same from left to right and right to left.

One problem with prime numbers is that there are too many of them. Let's introduce the following notation: π(*n*) — the number of primes no larger than *n*, *rub*(*n*) — the number of palindromic numbers no larger than *n*. Rikhail wants to prove that there are a lot more primes than palindromic ones.

He asked you to solve the following problem: for a given value of the coefficient *A* find the maximum *n*, such that π(*n*)<=≤<=*A*·*rub*(*n*).","The input consists of two positive integers *p*, *q*, the numerator and denominator of the fraction that is the value of *A* (, ).","If such maximum number exists, then print it. Otherwise, print ""Palindromic tree is better than splay tree"" (without the quotes).","['1 1\n', '1 42\n', '6 4\n']","['40\n', '1\n', '172\n']",none,TIME_LIMIT_EXCEEDED,"def d(e):
    
    a = e
    if e < 10:
        return True
    
    f = []
    while(True):
        f.append(a % 10)
        a //= 10
        
        if a == 0:
            break
    
    c = len(f) // 2
    j = len(f) - 1
    for i in range(c):
        if f[i] != f[j]:
            return False
        j -= 1

    return True

def h(x):

    g = []
    b = 0
    i = 1

    while(i <= x):
        if d(i):
            b += 1

        g.append(b)
        i += 1

    return g

def i(x):
    
    i = [True] * x
    i[0] = False
    j = [0]
    b = 0
    i = 1

    while(i * i < x):
        if i[i] == True:
            b += 1

            for j in range(i, x, i + 1):
                i[j] = False
    
        j.append(b)
        i += 1

    while(i < x):
        if i[i] == True:
            b += 1
        
        j.append(b)
        i += 1

    return j

j = i(2000000)
h = h(2000000)

e = input().split()
e = [int(e[0]), int(e[1])]
i = 0
l = 0

while(i < 2000000):

    k = ((h[i]) * e[0]) / e[1]
    if k >= j[i]:
        l = i + 1
   
    i += 1

if l == 0:
    print(""Palindromic tree is better than splay tree"")

else:
    print(l)","import q

def l():

    d = q.stdin.read().splitlines()
    if not d: 
        return

    n, m = map(int, d[0].split())

    g = []
    a = False

    for i in range(1, n + 1):
        n = list(map(int, d[i].split()))
        k = n[0]
        j = n[1:]
        if k > 0:
            a = True
        g.append(j)

    if not a:
        print(n)
        return

    m = list(range(n))
    
    def h(x):

        if m[x] != x:
            m[x] = h(m[x])
        return m[x]
    
    def r(x, y):

        o = h(x)
        p = h(y)
        if o != p:
            m[p] = o

    k = {}
    for i, j in enumerate(g):
        for i in j:
            k.setdefault(i, []).append(i)

    for f in k.values():
        if len(f) > 1:
            b = f[0]
            for e in f[1:]:
                r(b, e)

    c = set(h(i) for i in range(n))

    print(len(c) - 1)

if __name__ == '__main__':
    l()"
898,C,Phone Numbers,PROGRAMMING,"['implementation', 'strings']","Vasya has several phone books, in which he recorded the telephone numbers of his friends. Each of his friends can have one or several phone numbers.

Vasya decided to organize information about the phone numbers of friends. You will be given *n* strings — all entries from Vasya's phone books. Each entry starts with a friend's name. Then follows the number of phone numbers in the current entry, and then the phone numbers themselves. It is possible that several identical phones are recorded in the same record.

Vasya also believes that if the phone number *a* is a suffix of the phone number *b* (that is, the number *b* ends up with *a*), and both numbers are written by Vasya as the phone numbers of the same person, then *a* is recorded without the city code and it should not be taken into account.

The task is to print organized information about the phone numbers of Vasya's friends. It is possible that two different people have the same number. If one person has two numbers *x* and *y*, and *x* is a suffix of *y* (that is, *y* ends in *x*), then you shouldn't print number *x*. If the number of a friend in the Vasya's phone books is recorded several times in the same format, it is necessary to take it into account exactly once.

Read the examples to understand statement and format of the output better.","First line contains the integer *n* (1<=≤<=*n*<=≤<=20) — number of entries in Vasya's phone books. 

The following *n* lines are followed by descriptions of the records in the format described in statement. Names of Vasya's friends are non-empty strings whose length does not exceed 10. They consists only of lowercase English letters. Number of phone numbers in one entry is not less than 1 is not more than 10. The telephone numbers consist of digits only. If you represent a phone number as a string, then its length will be in range from 1 to 10. Phone numbers can contain leading zeros.","Print out the ordered information about the phone numbers of Vasya's friends. First output *m* — number of friends that are found in Vasya's phone books.

The following *m* lines must contain entries in the following format ""name number_of_phone_numbers phone_numbers"". Phone numbers should be separated by a space. Each record must contain all the phone numbers of current friend.

Entries can be displayed in arbitrary order, phone numbers for one record can also be printed in arbitrary order.","['2\nivan 1 00123\nmasha 1 00123\n', '3\nkarl 2 612 12\npetr 1 12\nkatya 1 612\n', '4\nivan 3 123 123 456\nivan 2 456 456\nivan 8 789 3 23 6 56 9 89 2\ndasha 2 23 789\n']","['2\nmasha 1 00123 \nivan 1 00123 \n', '3\nkatya 1 612 \npetr 1 12 \nkarl 1 612 \n', '2\ndasha 2 23 789 \nivan 4 789 123 2 456 \n']",none,WRONG_ANSWER,"import h
input = h.stdin.readline
from collections import *

def d(s, t):
    return s[len(s)-len(t):]==t

d = b(set)

for _ in range(int(input())):
    l = list(input().split())
    
    for e in l[2:]:
        d[l[0]].add(e)

for k in d.keys():
    a = []
    
    for f in d[k]:
        c = True
        
        for g in d[k]:
            if f==g:
                continue
            
            if d(g, f):
                c = False
        
        if c:
            a.append(f)
    
    print(k, len(a), *a)","def a(n):
    """"""
    Calculate the alternating sum f(n) where:
    f(n) = -1 + 2 - 3 + ... +/- n
    For an even number n, the sum is n/2.
    For an odd number n, the sum is -(n+1)/2.
    """"""
    if n % 2 == 0:
        return n // 2
    else:
        return -((n + 1) // 2)

def c():
    import e

    b = e.stdin.read().split()
    if b:

        n = int(b[0])

        d = a(n)

        print(d)

if __name__ == ""__main__"":
    c()"
0,none,none,none,['none'],"Theater stage is a rectangular field of size *n*<=×<=*m*. The director gave you the stage's plan which actors will follow. For each cell it is stated in the plan if there would be an actor in this cell or not.

You are to place a spotlight on the stage in some good position. The spotlight will project light in one of the four directions (if you look at the stage from above) — left, right, up or down. Thus, the spotlight's position is a cell it is placed to and a direction it shines.

A position is good if two conditions hold: 
 -  there is no actor in the cell the spotlight is placed to; -  there is at least one actor in the direction the spotlight projects. 
Count the number of good positions for placing the spotlight. Two positions of spotlight are considered to be different if the location cells or projection direction differ.","The first line contains two positive integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=1000) — the number of rows and the number of columns in the plan.

The next *n* lines contain *m* integers, 0 or 1 each — the description of the plan. Integer 1, means there will be an actor in the corresponding cell, while 0 means the cell will remain empty. It is guaranteed that there is at least one actor in the plan.",Print one integer — the number of good positions for placing the spotlight.,"['2 4\n0 1 0 0\n1 0 1 0\n', '4 4\n0 0 0 0\n1 0 0 1\n0 1 1 0\n0 1 0 0\n']","['9\n', '20\n']","In the first example the following positions are good:
 1.  the (1, 1) cell and right direction; 1.  the (1, 1) cell and down direction; 1.  the (1, 3) cell and left direction; 1.  the (1, 3) cell and down direction; 1.  the (1, 4) cell and left direction; 1.  the (2, 2) cell and left direction; 1.  the (2, 2) cell and up direction; 1.  the (2, 2) and right direction; 1.  the (2, 4) cell and left direction. 
Therefore, there are 9 good positions in this example.",TIME_LIMIT_EXCEEDED,"n, m=map(int, input().split())
a=[list(map(int, input().split())) for _ in range(n)]
a=p=0

def f(x):
    global a, p
    if x==0:
        a+=p
    else:
        p=1

for i in range(n):
    p=0
    for j in range(m):
        f(a[i][j])
    p=0
    for j in range(m-1, -1, -1):
        f(a[i][j])

for i in range(m):
    p=0
    for j in range(n):
        f(a[j][i])
    p=0
    for j in range(n-1, -1, -1):
        f(a[j][i])

print(a)","def e():
    import f

    d = f.stdin.read().split()
    n = int(d[0])
    
    a = 0
    c = 1
    
    for i in range(n):
        s = int(d[c])
        d = int(d[c + 1])
        c += 2

        if a + 1 <= s:

            a = s
        else:

            b = a + 1 - s
            k = (b + d - 1) // d
            a = s + k * d

    f.stdout.write(str(a))

if __name__ == '__main__':
    e()"
230,B,T-primes,PROGRAMMING,"['binary search', 'implementation', 'math', 'number theory']","We know that prime numbers are positive integers that have exactly two distinct positive divisors. Similarly, we'll call a positive integer *t* Т-prime, if *t* has exactly three distinct positive divisors.

You are given an array of *n* positive integers. For each of them determine whether it is Т-prime or not.","The first line contains a single positive integer, *n* (1<=≤<=*n*<=≤<=105), showing how many numbers are in the array. The next line contains *n* space-separated integers *x**i* (1<=≤<=*x**i*<=≤<=1012).

Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is advised to use the cin, cout streams or the %I64d specifier.","Print *n* lines: the *i*-th line should contain ""YES"" (without the quotes), if number *x**i* is Т-prime, and ""NO"" (without the quotes), if it isn't.",['3\n4 5 6\n'],['YES\nNO\nNO\n'],"The given test has three numbers. The first number 4 has exactly three divisors — 1, 2 and 4, thus the answer for this number is ""YES"". The second number 5 has two divisors (1 and 5), and the third number 6 has four divisors (1, 2, 3, 6), hence the answer for them is ""NO"".",WRONG_ANSWER,"'''
刘思瑞 2100017810
'''
def b(a):
    if int(int(a**(0.5))**2) != a:
        return 'NO'
    for i in range(2,int(a**(0.5)+1)):
        if a % i == 0:
            if i**2 != a:
                return 'NO'
    return 'YES'

n = int(input())
a = list(map(int,input().split()))
for i in a:
    print(b(i))","def d():
    import h
    c = h.stdin.read().splitlines()

    n = int(c[0].strip())

    a = list(map(int, c[1].split()))

    m = int(c[2].strip())

    g = list(map(int, c[3].split()))

    f = {}
    for a, i in enumerate(a):
        f[i] = a + 1

    j = 0
    e = 0

    for i in g:
        b = f[i]
        j += b
        e += (n - b + 1)

    h.stdout.write(f""{j} {e}"")

if __name__ == ""__main__"":
    d()"
336,B,Vasily the Bear and Fly,PROGRAMMING,['math'],"One beautiful day Vasily the bear painted 2*m* circles of the same radius *R* on a coordinate plane. Circles with numbers from 1 to *m* had centers at points (2*R*<=-<=*R*,<=0), (4*R*<=-<=*R*,<=0), ..., (2*Rm*<=-<=*R*,<=0), respectively. Circles with numbers from *m*<=+<=1 to 2*m* had centers at points (2*R*<=-<=*R*,<=2*R*), (4*R*<=-<=*R*,<=2*R*), ..., (2*Rm*<=-<=*R*,<=2*R*), respectively. 

Naturally, the bear painted the circles for a simple experiment with a fly. The experiment continued for *m*2 days. Each day of the experiment got its own unique number from 0 to *m*2<=-<=1, inclusive. 

On the day number *i* the following things happened: 
 1.  The fly arrived at the coordinate plane at the center of the circle with number  ( is the result of dividing number *x* by number *y*, rounded down to an integer). 1.  The fly went along the coordinate plane to the center of the circle number  ( is the remainder after dividing number *x* by number *y*). The bear noticed that the fly went from the center of circle *v* to the center of circle *u* along the shortest path with all points lying on the border or inside at least one of the 2*m* circles. After the fly reached the center of circle *u*, it flew away in an unknown direction. 
Help Vasily, count the average distance the fly went along the coordinate plane during each of these *m*2 days.","The first line contains two integers *m*,<=*R* (1<=≤<=*m*<=≤<=105, 1<=≤<=*R*<=≤<=10).",In a single line print a single real number — the answer to the problem. The answer will be considered correct if its absolute or relative error doesn't exceed 10<=-<=6.,"['1 1\n', '2 2\n']","['2.0000000000\n', '5.4142135624\n']","<img class=""tex-graphics"" src=""https://espresso.codeforces.com/9fe384073741e20965ddc4bf162afd3a604b6b39.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

Figure to the second sample",OK,"import a

m,R = map (int,input().split())

D = a.sqrt (2) * R
b = 0

def c (n):
  return n*(n+1)*R + 2*D*n

for i in range (1,m+1):
  b += 2*R
  if i-1   > 0: b += 2*R + D
  if m-i   > 0: b += 2*R + D
  if i-2   > 0: b += c (i-2)
  if m-i-1 > 0: b += c (m-i-1)

print (b / m / m)","from math import c

def d():

    y, w = map(int, input().split())

    e = max(y, w)

    h = 7 - e

    g = 6

    a = c(h, g)
    
    f = h // a
    b = g // a

    print(f""{f}/{b}"")

if __name__ == '__main__':
    d()"
981,C,Useful Decomposition,PROGRAMMING,"['implementation', 'trees']","Ramesses knows a lot about problems involving trees (undirected connected graphs without cycles)!

He created a new useful tree decomposition, but he does not know how to construct it, so he asked you for help!

The decomposition is the splitting the edges of the tree in some simple paths in such a way that each two paths have at least one common vertex. Each edge of the tree should be in exactly one path.

Help Remesses, find such a decomposition of the tree or derermine that there is no such decomposition.","The first line contains a single integer $n$ ($2 \leq n \leq 10^{5}$) the number of nodes in the tree.

Each of the next $n<=-<=1$ lines contains two integers $a_i$ and $b_i$ ($1 \leq a_i, b_i \leq n$, $a_i \neq b_i$) — the edges of the tree. It is guaranteed that the given edges form a tree.","If there are no decompositions, print the only line containing ""No"".

Otherwise in the first line print ""Yes"", and in the second line print the number of paths in the decomposition $m$. 

Each of the next $m$ lines should contain two integers $u_i$, $v_i$ ($1 \leq u_i, v_i \leq n$, $u_i \neq v_i$) denoting that one of the paths in the decomposition is the simple path between nodes $u_i$ and $v_i$. 

Each pair of paths in the decomposition should have at least one common vertex, and each edge of the tree should be presented in exactly one path. You can print the paths and the ends of each path in arbitrary order.

If there are multiple decompositions, print any.","['4\n1 2\n2 3\n3 4\n', '6\n1 2\n2 3\n3 4\n2 5\n3 6\n', '5\n1 2\n1 3\n1 4\n1 5\n']","['Yes\n1\n1 4\n', 'No\n', 'Yes\n4\n1 2\n1 3\n1 4\n1 5\n']","The tree from the first example is shown on the picture below: <img class=""tex-graphics"" src=""https://espresso.codeforces.com/9eb4b4c143d3ad267ae05d1e43341bd368b3088b.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> The number next to each edge corresponds to the path number in the decomposition. It is easy to see that this decomposition suits the required conditions.

The tree from the second example is shown on the picture below: <img class=""tex-graphics"" src=""https://espresso.codeforces.com/20704b97182d9bcde3321c00a16edcae4d772d93.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> We can show that there are no valid decompositions of this tree.

The tree from the third example is shown on the picture below: <img class=""tex-graphics"" src=""https://espresso.codeforces.com/357ff9496a4ed4746401160ee6ee63f5d57d81b9.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> The number next to each edge corresponds to the path number in the decomposition. It is easy to see that this decomposition suits the required conditions.",RUNTIME_ERROR,"def n():
    from pcm.utils import r
    import u
    if len(u.argv) == 1:
        r(p.path.dirname(k) + '/test/' + 'sample-1.in')

import u
import p
from u import stdin, t
import time
import re
from pydoc import help
import string
import math
import numpy as np
from operator import itemgetter
from collections import Counter
from collections import deque
from collections import defaultdict as dd
import fractions
from heapq import heappop, heappush, heapify
import array
from bisect import bisect_left, bisect_right, insort_left, insort_right
from copy import deepcopy as dcopy
import itertools
u.setrecursionlimit(10**7)
e = 10**20
d = 1.0 / 10**10
j = 10**9+7
a = [chr(i) for i in range(ord('a'), ord('z')+1)]
def g(): return [int(x) for x in u.stdin.readline().split()]
def h(): return [int(x)-1 for x in u.stdin.readline().split()]
def f(): return [float(x) for x in u.stdin.readline().split()]
def i(): return u.stdin.readline().split()
def I(): return int(u.stdin.readline())
def F(): return float(u.stdin.readline())
def b(N, M, l): return [[l] * M for n in range(N)]
def c(N, M, L, l): return [[[l] * L for n in range(M)] for _ in range(N)]

def s():
    global T, N, g
    N = int(input())

    T = [[] for _ in range(N)]
    for n in range(N-1):
        a, b = map(lambda x:int(x)-1, input().split())
        T[a].append(b)
        T[b].append(a)

    g = -1
    for n, t in enumerate(T):
        if len(t) >= 3 and g==-1:
            g = n
        elif len(t) >= 3 and g!=-1:
            print(""No"")
            return

    if g == -1:
        print(""Yes"")
        print(""1"")
        q = []
        for n, t in enumerate(T):
            if len(t) == 1:
                q.append(n+1)
        print(*q)
        return

    print(""Yes"")
    print(len(T[g]))
    q = """"
    for n in T[g]:
        q += str(g+1)+"" ""+str(m(n)+1)+""\n""
    t.write(q)

def m(n):
    R = [0]*N
    R[g] = 1
    o = n
    while True:
        if len(T[o]) == 1:
            return o
        if R[T[o][0]] == 0:
            R[o] = 1
            o = T[o][0]
        elif R[T[o][1]] == 0:
            R[o] = 1
            o = T[o][1]

if __name__ == ""__main__"":
    try:
        n()
    except:
        pass
    s()","def f():
    import k
    c = k.stdin.read().splitlines()
    if not c:
        return
    a = c[0].strip()
    k = int(c[1].strip())
    g = 1000000007
    m = len(a)

    a = 0
    i = 1
    for b in a:
        if b in ('0', '5'):
            a = (a + i) % g
        i = (i * 2) % g

    X = pow(2, m, g)
    h = (pow(X, k, g) - 1) % g
    d = (X - 1) % g
    e = pow(d, g - 2, g)
    G = (h * e) % g

    j = (a * G) % g
    k.stdout.write(str(j) + ""\n"")

if __name__ == '__main__':
    f()"
71,A,Way Too Long Words,PROGRAMMING,['strings'],"Sometimes some words like ""localization"" or ""internationalization"" are so long that writing them many times in one text is quite tiresome.

Let's consider a word too long, if its length is strictly more than 10 characters. All too long words should be replaced with a special abbreviation.

This abbreviation is made like this: we write down the first and the last letter of a word and between them we write the number of letters between the first and the last letters. That number is in decimal system and doesn't contain any leading zeroes.

Thus, ""localization"" will be spelt as ""l10n"", and ""internationalization» will be spelt as ""i18n"".

You are suggested to automatize the process of changing the words with abbreviations. At that all too long words should be replaced by the abbreviation and the words that are not too long should not undergo any changes.",The first line contains an integer *n* (1<=≤<=*n*<=≤<=100). Each of the following *n* lines contains one word. All the words consist of lowercase Latin letters and possess the lengths of from 1 to 100 characters.,Print *n* lines. The *i*-th line should contain the result of replacing of the *i*-th word from the input data.,['4\nword\nlocalization\ninternationalization\npneumonoultramicroscopicsilicovolcanoconiosis\n'],['word\nl10n\ni18n\np43s\n'],none,OK,"def e(d):
    b = []
    for a in d:
        n = len(a)
        if n <= 10:
            b.append(a)
        else:
            b.append(a[0] + str(n-2) + a[-1])
    return b

if __name__ == ""__main__"":
    n = int(input())
    d = []
    for _ in range(n):
        d.append(input())
    c = e(d)
    for b in c:
        print(b)","import d

def c():

    f = input().strip()
    g = input().strip()

    h = f.count('+') - f.count('-')

    a = g.count('+') - g.count('-')

    j = g.count('?')

    b = h - a

    if j == 0:
        e = 1.0 if b == 0 else 0.0
    else:

        if (b + j) % 2 != 0 or abs(b) > j:
            e = 0.0
        else:
            x = (b + j) // 2

            k = d.comb(j, x)
            i = 2 ** j
            e = k / i

    print(""{:.12f}"".format(e))

if __name__ == '__main__':
    c()"
1003,D,Coins and Queries,PROGRAMMING,['greedy'],"Polycarp has $n$ coins, the value of the $i$-th coin is $a_i$. It is guaranteed that all the values are integer powers of $2$ (i.e. $a_i = 2^d$ for some non-negative integer number $d$).

Polycarp wants to know answers on $q$ queries. The $j$-th query is described as integer number $b_j$. The answer to the query is the minimum number of coins that is necessary to obtain the value $b_j$ using some subset of coins (Polycarp can use only coins he has). If Polycarp can't obtain the value $b_j$, the answer to the $j$-th query is -1.

The queries are independent (the answer on the query doesn't affect Polycarp's coins).","The first line of the input contains two integers $n$ and $q$ ($1 \le n, q \le 2 \cdot 10^5$) — the number of coins and the number of queries.

The second line of the input contains $n$ integers $a_1, a_2, \dots, a_n$ — values of coins ($1 \le a_i \le 2 \cdot 10^9$). It is guaranteed that all $a_i$ are integer powers of $2$ (i.e. $a_i = 2^d$ for some non-negative integer number $d$).

The next $q$ lines contain one integer each. The $j$-th line contains one integer $b_j$ — the value of the $j$-th query ($1 \le b_j \le 10^9$).",Print $q$ integers $ans_j$. The $j$-th integer must be equal to the answer on the $j$-th query. If Polycarp can't obtain the value $b_j$ the answer to the $j$-th query is -1.,['5 4\n2 4 8 2 4\n8\n5\n14\n10\n'],['1\n-1\n3\n2\n'],none,RUNTIME_ERROR,"def a():
	n, q = map(int, input().split())
	a = [*map(int, input().split())]
	d = {}
	for i in range(n):
		d[a[i]] = d.get(a[i], 0) + 1
	for i in range(q):
		x = int(input())
		c = 0
		for j in reversed(d.keys()):
			y = min(d[j], x // j)
			c += y
			x -= y * j
		if x:
			print(-1)
		else:
			print(c)
if __name__ == '__main__':
    a()","import f
import d

def c():

    a = f.stdin.read().splitlines()

    e = []
    for b in a:
        if not b.strip():
            continue
        a, b, c = map(int, b.strip().split())

        if a <= b:
            g = 0
        else:

            g = d.ceil(c * (a - b) / b)

        e.append(str(g))

    f.stdout.write(""\n"".join(e))

if __name__ == ""__main__"":
    c()"
981,A,Antipalindrome,PROGRAMMING,"['brute force', 'implementation', 'strings']","A string is a palindrome if it reads the same from the left to the right and from the right to the left. For example, the strings ""kek"", ""abacaba"", ""r"" and ""papicipap"" are palindromes, while the strings ""abb"" and ""iq"" are not.

A substring $s[l \ldots r]$ ($1<=\leq<=l<=\leq<=r<=\leq<=|s|$) of a string $s<==<=s_{1}s_{2} \ldots s_{|s|}$ is the string $s_{l}s_{l<=+<=1} \ldots s_{r}$.

Anna does not like palindromes, so she makes her friends call her Ann. She also changes all the words she reads in a similar way. Namely, each word $s$ is changed into its longest substring that is not a palindrome. If all the substrings of $s$ are palindromes, she skips the word at all.

Some time ago Ann read the word $s$. What is the word she changed it into?","The first line contains a non-empty string $s$ with length at most $50$ characters, containing lowercase English letters only.","If there is such a substring in $s$ that is not a palindrome, print the maximum length of such a substring. Otherwise print $0$.

Note that there can be multiple longest substrings that are not palindromes, but their length is unique.","['mew\n', 'wuffuw\n', 'qqqqqqqq\n']","['3\n', '5\n', '0\n']","""mew"" is not a palindrome, so the longest substring of it that is not a palindrome, is the string ""mew"" itself. Thus, the answer for the first example is $3$.

The string ""uffuw"" is one of the longest non-palindrome substrings (of length $5$) of the string ""wuffuw"", so the answer for the second example is $5$.

All substrings of the string ""qqqqqqqq"" consist of equal characters so they are palindromes. This way, there are no non-palindrome substrings. Thus, the answer for the third example is $0$.",OK,"""""""https://codeforces.com/problemset/problem/981/A
""""""

s = input()
for r in range(len(s), 1, -1):
    if s[:r] != s[r - 1::-1]:
        print(r)
        break
else:
    print(0)","def c():
    import e
    a = e.stdin.read().strip().split()
    if not a:
        return
    x = int(a[0])
    y = int(a[1])
    l = int(a[2])
    r = int(a[3])

    l = []
    h = 1
    while h <= r:
        l.append(h)

        if r // x < h:
            break
        h *= x

    m = []
    h = 1
    while h <= r:
        m.append(h)
        if r // y < h:
            break
        h *= y

    g = set()
    for j in l:
        for k in m:
            s = j + k
            if s <= r:
                g.add(s)
            else:

                break

    f = sorted(g)

    i = []
    for h in f:
        if l <= h <= r:
            i.append(h)
    
    d = 0

    if not i:
        d = r - l + 1
    else:

        b = i[0] - l
        if b > d:
            d = b

        for i in range(len(i) - 1):
            b = i[i + 1] - i[i] - 1
            if b > d:
                d = b

        b = r - i[-1]
        if b > d:
            d = b
    
    e.stdout.write(str(d))

if __name__ == '__main__':
    c()"
129,A,Cookies,PROGRAMMING,['implementation'],"Olga came to visit the twins Anna and Maria and saw that they have many cookies. The cookies are distributed into bags. As there are many cookies, Olga decided that it's no big deal if she steals a bag. However, she doesn't want the sisters to quarrel because of nothing when they divide the cookies. That's why Olga wants to steal a bag with cookies so that the number of cookies in the remaining bags was even, that is, so that Anna and Maria could evenly divide it into two (even 0 remaining cookies will do, just as any other even number). How many ways there are to steal exactly one cookie bag so that the total number of cookies in the remaining bags was even?",The first line contains the only integer *n* (1<=≤<=*n*<=≤<=100) — the number of cookie bags Anna and Maria have. The second line contains *n* integers *a**i* (1<=≤<=*a**i*<=≤<=100) — the number of cookies in the *i*-th bag.,Print in the only line the only number — the sought number of ways. If there are no such ways print 0.,"['1\n1\n', '10\n1 2 2 3 4 4 4 2 2 2\n', '11\n2 2 2 2 2 2 2 2 2 2 99\n']","['1\n', '8\n', '1\n']","In the first sample Olga should take the only bag so that the twins ended up with the even number of cookies.

In the second sample Olga can take any of five bags with two cookies or any of three bags with four cookies — 5 + 3 = 8 ways in total.

In the third sample, no matter which bag with two cookies Olga chooses, the twins are left with 2 * 9 + 99 = 117 cookies. Thus, Olga has only one option: to take the bag with 99 cookies.",WRONG_ANSWER,"def b(n, a):
    a = 0
    for i in range(n):
        for j in range(i+1, n+1):
            if sum(a[i:j]) % 2 == 1:
                a += 1
    return a

n = int(input())
a = list(map(int, input().split()))
print(b(n, a))","import e

def a(d):

    d.sort()

    for i in range(len(d) - 2):

        if d[i] + d[i+1] > d[i+2]:
            return True
    return False

def c():

    b = e.stdin.read().split()

    n = int(b[0])

    d = list(map(int, b[1:1+n]))

    if a(d):
        print(""YES"")
    else:
        print(""NO"")

if __name__ == ""__main__"":
    c()"
82,A,Double Cola,PROGRAMMING,"['implementation', 'math']","Sheldon, Leonard, Penny, Rajesh and Howard are in the queue for a ""Double Cola"" drink vending machine; there are no other people in the queue. The first one in the queue (Sheldon) buys a can, drinks it and doubles! The resulting two Sheldons go to the end of the queue. Then the next in the queue (Leonard) buys a can, drinks it and gets to the end of the queue as two Leonards, and so on. This process continues ad infinitum.

For example, Penny drinks the third can of cola and the queue will look like this: Rajesh, Howard, Sheldon, Sheldon, Leonard, Leonard, Penny, Penny.

Write a program that will print the name of a man who will drink the *n*-th can.

Note that in the very beginning the queue looks like that: Sheldon, Leonard, Penny, Rajesh, Howard. The first person is Sheldon.","The input data consist of a single integer *n* (1<=≤<=*n*<=≤<=109).

It is guaranteed that the pretests check the spelling of all the five names, that is, that they contain all the five possible answers.","Print the single line — the name of the person who drinks the *n*-th can of cola. The cans are numbered starting from 1. Please note that you should spell the names like this: ""Sheldon"", ""Leonard"", ""Penny"", ""Rajesh"", ""Howard"" (without the quotes). In that order precisely the friends are in the queue initially.","['1\n', '6\n', '1802\n']","['Sheldon\n', 'Sheldon\n', 'Penny\n']",none,OK,"x = int(input())

n=1
b = [0]
def a(n):
  b.append(2**(n-1)*5 + b[n-1])
  return b[n]

while(x > a(n)):
  n = n+1

p = ((x - b[n-1] - 1) // 2**(n-1)) + 1

if(p == 1):
  print(""Sheldon"")
elif(p == 2):
  print(""Leonard"")
elif(p == 3):
  print(""Penny"")
elif(p == 4):
  print(""Rajesh"")
else:
  print(""Howard"")","def d():
    import f

    c = f.stdin.read().strip().split()

    if not c:
        return

    n = int(c[0])
    b = list(map(int, c[1:]))
    
    g = 0
    e = 0

    for a in b:
        if a == -1:

            if e == 0:

                g += 1
            else:

                e -= 1
        else:

            e += a

    f.stdout.write(str(g))

if __name__ == ""__main__"":
    d()"
59,A,Word,PROGRAMMING,"['implementation', 'strings']","Vasya is very upset that many people on the Net mix uppercase and lowercase letters in one word. That's why he decided to invent an extension for his favorite browser that would change the letters' register in every word so that it either only consisted of lowercase letters or, vice versa, only of uppercase ones. At that as little as possible letters should be changed in the word. For example, the word HoUse must be replaced with house, and the word ViP — with VIP. If a word contains an equal number of uppercase and lowercase letters, you should replace all the letters with lowercase ones. For example, maTRIx should be replaced by matrix. Your task is to use the given method on one given word.",The first line contains a word *s* — it consists of uppercase and lowercase Latin letters and possesses the length from 1 to 100.,"Print the corrected word *s*. If the given word *s* has strictly more uppercase letters, make the word written in the uppercase register, otherwise - in the lowercase one.","['HoUse\n', 'ViP\n', 'maTRIx\n']","['house\n', 'VIP\n', 'matrix\n']",none,WRONG_ANSWER,"N = 200
e = [0]*30

def a():
    n = int(input())
    for _ in range(n):
        d = input().strip()
        e.clear()
        e = [0]*30
        l = len(d)
        f = True
        c = 0
        b = 110
        for i in range(l):
            e[ord(d[i])-ord('a')] = 1
            c = max(c, ord(d[i])-ord('a'))
            b = min(b, ord(d[i])-ord('a'))
        for i in range(b, c+1):
            if e[i] == 0:
                f = False
                break
        if f and c-b+1 == l:
            print(""Yes"")
        else:
            print(""No"")","import o

def h():

    f = o.stdin.read().split()
    if not f:
        return

    g = iter(f)
    n = int(next(g))
    m = int(next(g))
    k = int(next(g))

    n = [(0, 0)] * n
    c = [(0, 0)] * m

    for i in range(1, k + 1):
        j = next(g)
        if j == '1':

            r = int(next(g)) - 1
            d = int(next(g))
            n[r] = (i, d)
        elif j == '2':

            c = int(next(g)) - 1
            d = int(next(g))
            c[c] = (i, d)

    k = []
    for i in range(n):
        m, l = n[i]
        e = []
        for j in range(m):
            b, a = c[j]

            if m > b:
                e.append(str(l))
            else:
                e.append(str(a))

        k.append("" "".join(e) + "" "")

    o.stdout.write(""\n"".join(k))

if __name__ == ""__main__"":
    h()"
157,B,Trace,PROGRAMMING,"['geometry', 'sortings']","One day, as Sherlock Holmes was tracking down one very important criminal, he found a wonderful painting on the wall. This wall could be represented as a plane. The painting had several concentric circles that divided the wall into several parts. Some parts were painted red and all the other were painted blue. Besides, any two neighboring parts were painted different colors, that is, the red and the blue color were alternating, i. e. followed one after the other. The outer area of the wall (the area that lied outside all circles) was painted blue. Help Sherlock Holmes determine the total area of red parts of the wall.

Let us remind you that two circles are called concentric if their centers coincide. Several circles are called concentric if any two of them are concentric.",The first line contains the single integer *n* (1<=≤<=*n*<=≤<=100). The second line contains *n* space-separated integers *r**i* (1<=≤<=*r**i*<=≤<=1000) — the circles' radii. It is guaranteed that all circles are different.,Print the single real number — total area of the part of the wall that is painted red. The answer is accepted if absolute or relative error doesn't exceed 10<=-<=4.,"['1\n1\n', '3\n1 4 2\n']","['3.1415926536\n', '40.8407044967\n']","In the first sample the picture is just one circle of radius 1. Inner part of the circle is painted red. The area of the red part equals π × 1<sup class=""upper-index"">2</sup> = π.

In the second sample there are three circles of radii 1, 4 and 2. Outside part of the second circle is painted blue. Part between the second and the third circles is painted red. Part between the first and the third is painted blue. And, finally, the inner part of the first circle is painted red. Overall there are two red parts: the ring between the second and the third circles and the inner part of the first circle. Total area of the red parts is equal (π × 4<sup class=""upper-index"">2</sup> - π × 2<sup class=""upper-index"">2</sup>) + π × 1<sup class=""upper-index"">2</sup> = π × 12 + π = 13π",OK,"import c

n = int(input())
b = list(map(int, input().split()))
b.sort(reverse = True)

t = 0
for a in range(n):
    t += (-1 if a % 2 == 1 else 1) * b[a] ** 2

print(t * c.pi)","A = input().strip()

B = A + A[::-1]

print(B)"
598,D,Igor In the Museum,PROGRAMMING,"['dfs and similar', 'graphs', 'shortest paths']","Igor is in the museum and he wants to see as many pictures as possible.

Museum can be represented as a rectangular field of *n*<=×<=*m* cells. Each cell is either empty or impassable. Empty cells are marked with '.', impassable cells are marked with '*'. Every two adjacent cells of different types (one empty and one impassable) are divided by a wall containing one picture.

At the beginning Igor is in some empty cell. At every moment he can move to any empty cell that share a side with the current one.

For several starting positions you should calculate the maximum number of pictures that Igor can see. Igor is able to see the picture only if he is in the cell adjacent to the wall with this picture. Igor have a lot of time, so he will examine every picture he can see.","First line of the input contains three integers *n*, *m* and *k* (3<=≤<=*n*,<=*m*<=≤<=1000,<=1<=≤<=*k*<=≤<=*min*(*n*·*m*,<=100<=000)) — the museum dimensions and the number of starting positions to process.

Each of the next *n* lines contains *m* symbols '.', '*' — the description of the museum. It is guaranteed that all border cells are impassable, so Igor can't go out from the museum.

Each of the last *k* lines contains two integers *x* and *y* (1<=≤<=*x*<=≤<=*n*,<=1<=≤<=*y*<=≤<=*m*) — the row and the column of one of Igor's starting positions respectively. Rows are numbered from top to bottom, columns — from left to right. It is guaranteed that all starting positions are empty cells.","Print *k* integers — the maximum number of pictures, that Igor can see if he starts in corresponding position.","['5 6 3\n******\n*..*.*\n******\n*....*\n******\n2 2\n2 5\n4 3\n', '4 4 1\n****\n*..*\n*.**\n****\n3 2\n']","['6\n4\n10\n', '8\n']",none,TIME_LIMIT_EXCEEDED,"def a(x, y, n, m, e, k):
    if x < 0 or x >= n or y < 0 or y >= m or k[x][y] or e[x][y] == '*':
        return 0

    k[x][y] = True
    g = 0

    for b, c in ((1, 0), (-1, 0), (0, 1), (0, -1)):
        if 0 <= x + b < n and 0 <= y + c < m and e[x + b][y + c] == '*':
            g += 1
        else:
            g += a(x + b, y + c, n, m, e, k)

    return g

def d(n, m, k, e, j):
    i = []
    for x, y in j:
        k = [[False] * m for _ in range(n)]
        h = a(x - 1, y - 1, n, m, e, k)
        i.append(h)

    return i

n, m, k = map(int, input().split())
e = [input() for _ in range(n)]
j = [tuple(map(int, input().split())) for _ in range(k)]

h = d(n, m, k, e, j)

for f in h:
    print(f)","def m():
    import n
    f = n.stdin.read().split()
    if not f:
        return
    n = int(f[0])
    e = []
    i = 1
    for i in range(n):
        j = list(map(int, f[i: i+n]))
        i += n
        e.append(j)

    l = 2 * n - 1
    h = [0] * l
    g = [0] * l
    
    for i in range(n):
        for j in range(n):
            h[i - j + n - 1] += e[i][j]
            g[i + j] += e[i][j]

    c = -1
    a = -1
    d = (0, 0)
    b = (0, 0)
    
    for i in range(n):
        for j in range(n):
            k = h[i - j + n - 1] + g[i + j] - e[i][j]
            if (i + j) % 2 == 0:
                if k > c:
                    c = k
                    d = (i, j)
            else:
                if k > a:
                    a = k
                    b = (i, j)
    
    o = c + a

    n.stdout.write(str(o) + ""\n"")
    n.stdout.write(f""{d[0] + 1} {d[1] + 1} {b[0] + 1} {b[1] + 1}"")
    
if __name__ == '__main__':
    m()"
938,A,Word Correction,PROGRAMMING,['implementation'],"Victor tries to write his own text editor, with word correction included. However, the rules of word correction are really strange.

Victor thinks that if a word contains two consecutive vowels, then it's kinda weird and it needs to be replaced. So the word corrector works in such a way: as long as there are two consecutive vowels in the word, it deletes the first vowel in a word such that there is another vowel right before it. If there are no two consecutive vowels in the word, it is considered to be correct.

You are given a word *s*. Can you predict what will it become after correction?

In this problem letters a, e, i, o, u and y are considered to be vowels.","The first line contains one integer *n* (1<=≤<=*n*<=≤<=100) — the number of letters in word *s* before the correction.

The second line contains a string *s* consisting of exactly *n* lowercase Latin letters — the word before the correction.",Output the word *s* after the correction.,"['5\nweird\n', '4\nword\n', '5\naaeaa\n']","['werd\n', 'word\n', 'a\n']","Explanations of the examples:
 1.  There is only one replace: weird <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> werd;1.  No replace needed since there are no two consecutive vowels;1.  aaeaa <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> aeaa <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> aaa <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> aa <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> a.",OK,"d  = ['a', 'e', 'i', 'o', 'u', 'y']

def e(s):
    b = []
    b.append(s[0])
    a = 0
    c = 1
    while c < len(s):
        if not s[a] in d or not s[c] in d:
            b.append(s[c])
            a = c
        c += 1
    return ''.join(b)
    
n = int(input())
s = input()
print(e(s))","def d():
    import j
    b = j.stdin.read().splitlines()
    if not b:
        return

    n, m, k = map(int, b[0].split())

    a = list(map(int, b[1].split()))

    i = a[:]
    
    k = 0

    g = b[2:2+n]
    
    for f in g:
        e = list(map(int, f.split()))

        for c in e:

            h = i.index(c) + 1
            k += h

            i.pop(h - 1)
            i.insert(0, c)

    j.stdout.write(str(k) + ""\n"")

if __name__ == ""__main__"":
    d()"
218,B,Airport,PROGRAMMING,['implementation'],"Lolek and Bolek are about to travel abroad by plane. The local airport has a special ""Choose Your Plane"" offer. The offer's conditions are as follows:
 -  it is up to a passenger to choose a plane to fly on; -  if the chosen plane has *x* (*x*<=&gt;<=0) empty seats at the given moment, then the ticket for such a plane costs *x* zlotys (units of Polish currency). 
The only ticket office of the airport already has a queue of *n* passengers in front of it. Lolek and Bolek have not stood in the queue yet, but they are already wondering what is the maximum and the minimum number of zlotys the airport administration can earn if all *n* passengers buy tickets according to the conditions of this offer?

The passengers buy tickets in turn, the first person in the queue goes first, then goes the second one, and so on up to *n*-th person.","The first line contains two integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=1000) — the number of passengers in the queue and the number of planes in the airport, correspondingly. The next line contains *m* integers *a*1,<=*a*2,<=...,<=*a**m* (1<=≤<=*a**i*<=≤<=1000) — *a**i* stands for the number of empty seats in the *i*-th plane before the ticket office starts selling tickets.

The numbers in the lines are separated by a space. It is guaranteed that there are at least *n* empty seats in total.","Print two integers — the maximum and the minimum number of zlotys that the airport administration can earn, correspondingly.","['4 3\n2 1 1\n', '4 3\n2 2 2\n']","['5 5\n', '7 6\n']","In the first test sample the number of passengers is equal to the number of empty seats, so regardless of the way the planes are chosen, the administration will earn the same sum.

In the second sample the sum is maximized if the 1-st person in the queue buys a ticket to the 1-st plane, the 2-nd person — to the 2-nd plane, the 3-rd person — to the 3-rd plane, the 4-th person — to the 1-st plane. The sum is minimized if the 1-st person in the queue buys a ticket to the 1-st plane, the 2-nd person — to the 1-st plane, the 3-rd person — to the 2-nd plane, the 4-th person — to the 2-nd plane.",OK,"n, m = map(int,input().split())
l = list(map(int,input().split()))

def g(f):
	A = l[:]; s = 0
	for _ in range(n):
		i = A.index(f(A)); s += A[i]

		if A[i] > 1: A[i] -= 1;
		else:
			A.pop(i)
	return s
print (g(max), g(min))","def b(x):

    if x < 2:
        return False
    if x % 2 == 0:
        return x == 2
    r = int(x**0.5)
    for i in range(3, r + 1, 2):
        if x % i == 0:
            return False
    return True

def e(x):

    if x % 2 == 0:
        return 2
    r = int(x**0.5)
    for i in range(3, r + 1, 2):
        if x % i == 0:
            return i
    return x

def c(n):

    d = 0
    while n > 1:
        if b(n):

            d += n
            d += 1
            break
        else:

            d += n
            n //= e(n)
    return d

if __name__ == '__main__':
    import f

    a = f.stdin.read().split()
    if a:
        n = int(a[0])
        print(c(n))"
13,A,Numbers,PROGRAMMING,"['implementation', 'math']","Little Petya likes numbers a lot. He found that number 123 in base 16 consists of two digits: the first is 7 and the second is 11. So the sum of digits of 123 in base 16 is equal to 18.

Now he wonders what is an average value of sum of digits of the number *A* written in all bases from 2 to *A*<=-<=1.

Note that all computations should be done in base 10. You should find the result as an irreducible fraction, written in base 10.",Input contains one integer number *A* (3<=≤<=*A*<=≤<=1000).,"Output should contain required average value in format «X/Y», where X is the numerator and Y is the denominator.","['5\n', '3\n']","['7/3\n', '2/1\n']","In the first sample number 5 written in all bases from 2 to 4 looks so: 101, 12, 11. Sums of digits are 2, 3 and 2, respectively.",OK,"N = int(input())
s = 0

def a(a, b):
    while(b):
        a, b = b, a%b
    return a

for i in range(2, N):
    n = N
    while(n>0):
        s += n%i
        n = n//i

t = a(s, N-2)
print(str(s//t)+""/""+str((N-2)//t))","import f

def d():

    b = f.stdin.read().strip().splitlines()
    
    if not b:
        return

    n = int(b[0].strip())

    g = set()

    for i in range(1, n + 1):
        c = b[i].strip()
        if not c:
            continue

        e, a = c.split()

        g.add((e, a))

    print(len(g))

if __name__ == ""__main__"":
    d()"
245,H,Queries for Number of Palindromes,PROGRAMMING,"['dp', 'hashing', 'strings']","You've got a string *s*<==<=*s*1*s*2... *s*|*s*| of length |*s*|, consisting of lowercase English letters. There also are *q* queries, each query is described by two integers *l**i*,<=*r**i* (1<=≤<=*l**i*<=≤<=*r**i*<=≤<=|*s*|). The answer to the query is the number of substrings of string *s*[*l**i*... *r**i*], which are palindromes.

String *s*[*l*... *r*]<==<=*s**l**s**l*<=+<=1... *s**r* (1<=≤<=*l*<=≤<=*r*<=≤<=|*s*|) is a substring of string *s*<==<=*s*1*s*2... *s*|*s*|.

String *t* is called a palindrome, if it reads the same from left to right and from right to left. Formally, if *t*<==<=*t*1*t*2... *t*|*t*|<==<=*t*|*t*|*t*|*t*|<=-<=1... *t*1.","The first line contains string *s* (1<=≤<=|*s*|<=≤<=5000). The second line contains a single integer *q* (1<=≤<=*q*<=≤<=106) — the number of queries. Next *q* lines contain the queries. The *i*-th of these lines contains two space-separated integers *l**i*,<=*r**i* (1<=≤<=*l**i*<=≤<=*r**i*<=≤<=|*s*|) — the description of the *i*-th query.

It is guaranteed that the given string consists only of lowercase English letters.","Print *q* integers — the answers to the queries. Print the answers in the order, in which the queries are given in the input. Separate the printed numbers by whitespaces.",['caaaba\n5\n1 1\n1 4\n2 3\n4 6\n4 5\n'],['1\n7\n3\n4\n2\n'],"Consider the fourth query in the first test case. String *s*[4... 6] = «aba». Its palindrome substrings are: «a», «b», «a», «aba».",TIME_LIMIT_EXCEEDED,"def a(a):
    if(a == a[::-1]):
        return True 
    else: return False
    
def c(a):
    b = 0
    for i in range(len(a)):
        b-=1
        for j in range(i,len(a)+1):
            if(a(a[i:j])):
                b = b + 1

    return b    

f = input('')
n = int(input(''))
e = []

for i in range(n):
    d = input().split(' ')
    e.append(d)
    
for i in range(n):
    print(c(f[int(e[i][0])-1:int(e[i][1])]))","import o
import g

def d(n, f):

    a = float('inf')
    e = [a] * (n + 1)

    k = [-1] * (n + 1)

    e[1] = 0
    m = [(0, 1)]
    
    while m:
        c, u = g.heappop(m)

        if c > e[u]:
            continue
        
        for v, p in f[u]:
            if e[u] + p < e[v]:
                e[v] = e[u] + p
                k[v] = u
                g.heappush(m, (e[v], v))
    
    return e, k

def n(k, n):

    l = []
    b = n
    while b != -1:
        l.append(b)
        b = k[b]

    if l[-1] != 1:
        return []
    return l[::-1]

def j():
    h = o.stdin.read().strip().split()
    if not h:
        return

    i = iter(h)
    n = int(next(i))
    m = int(next(i))

    f = [[] for _ in range(n + 1)]

    for _ in range(m):
        u = int(next(i))
        v = int(next(i))
        w = int(next(i))

        f[u].append((v, w))
        f[v].append((u, w))

    e, k = d(n, f)

    if e[n] == float('inf'):
        o.stdout.write(""-1"")
        return

    l = n(k, n)
    o.stdout.write("" "".join(map(str, l)) + "" "")

if __name__ == ""__main__"":
    j()"
431,A,Black Square,PROGRAMMING,['implementation'],"Quite recently, a very smart student named Jury decided that lectures are boring, so he downloaded a game called ""Black Square"" on his super cool touchscreen phone.

In this game, the phone's screen is divided into four vertical strips. Each second, a black square appears on some of the strips. According to the rules of the game, Jury must use this second to touch the corresponding strip to make the square go away. As Jury is both smart and lazy, he counted that he wastes exactly *a**i* calories on touching the *i*-th strip.

You've got a string *s*, describing the process of the game and numbers *a*1,<=*a*2,<=*a*3,<=*a*4. Calculate how many calories Jury needs to destroy all the squares?","The first line contains four space-separated integers *a*1, *a*2, *a*3, *a*4 (0<=≤<=*a*1,<=*a*2,<=*a*3,<=*a*4<=≤<=104).

The second line contains string *s* (1<=≤<=|*s*|<=≤<=105), where the *і*-th character of the string equals ""1"", if on the *i*-th second of the game the square appears on the first strip, ""2"", if it appears on the second strip, ""3"", if it appears on the third strip, ""4"", if it appears on the fourth strip.",Print a single integer — the total number of calories that Jury wastes.,"['1 2 3 4\n123214\n', '1 5 3 2\n11221\n']","['13\n', '13\n']",none,OK,"a = []
a = [int(a) for a in input().split()]
s = input()
x = len(s)
b = 0
for i in range(x):

    if s[i]=='1':
        b+=a[0]
    elif s[i]== '2' :
        b += a[1]
    elif s[i] == '3' :
        b += a[2]
    elif s[i] == '4' :
        b += a[3]

print (b)","n = int(input().strip())

b = list(map(int, input().split()))

a = 0

while n > 0:

    n -= b[a]

    if n <= 0:

        print(a + 1)
        break

    a = (a + 1) % 7"
82,A,Double Cola,PROGRAMMING,"['implementation', 'math']","Sheldon, Leonard, Penny, Rajesh and Howard are in the queue for a ""Double Cola"" drink vending machine; there are no other people in the queue. The first one in the queue (Sheldon) buys a can, drinks it and doubles! The resulting two Sheldons go to the end of the queue. Then the next in the queue (Leonard) buys a can, drinks it and gets to the end of the queue as two Leonards, and so on. This process continues ad infinitum.

For example, Penny drinks the third can of cola and the queue will look like this: Rajesh, Howard, Sheldon, Sheldon, Leonard, Leonard, Penny, Penny.

Write a program that will print the name of a man who will drink the *n*-th can.

Note that in the very beginning the queue looks like that: Sheldon, Leonard, Penny, Rajesh, Howard. The first person is Sheldon.","The input data consist of a single integer *n* (1<=≤<=*n*<=≤<=109).

It is guaranteed that the pretests check the spelling of all the five names, that is, that they contain all the five possible answers.","Print the single line — the name of the person who drinks the *n*-th can of cola. The cans are numbered starting from 1. Please note that you should spell the names like this: ""Sheldon"", ""Leonard"", ""Penny"", ""Rajesh"", ""Howard"" (without the quotes). In that order precisely the friends are in the queue initially.","['1\n', '6\n', '1802\n']","['Sheldon\n', 'Sheldon\n', 'Penny\n']",none,WRONG_ANSWER,"def a(n):
    b = [""Sheldon"", ""Leonard"", ""Penny"", ""Rajesh"", ""Howard""]
    i = 0  

    while n > len(b):
        n -= len(b)
        b += [b[i], b[i]]
        i += 1
    
    return b[(n - 1) // (len(b) // 5)]

n = int(input())

c = a(n)

print(c)","def c():
    import e

    a = e.stdin.read().split()
    if not a:
        return

    a = a[0].strip()

    b = a.find('0')
    if b == -1:

        d = a[:-1]
    else:

        d = a[:b] + a[b+1:]

    d = d.lstrip('0')
    if d == """":
        d = ""0""

    e.stdout.write(d)

if __name__ == '__main__':
    c()"
570,D,Tree Requests,PROGRAMMING,"['binary search', 'bitmasks', 'constructive algorithms', 'dfs and similar', 'graphs', 'trees']","Roman planted a tree consisting of *n* vertices. Each vertex contains a lowercase English letter. Vertex 1 is the root of the tree, each of the *n*<=-<=1 remaining vertices has a parent in the tree. Vertex is connected with its parent by an edge. The parent of vertex *i* is vertex *p**i*, the parent index is always less than the index of the vertex (i.e., *p**i*<=&lt;<=*i*).

The depth of the vertex is the number of nodes on the path from the root to *v* along the edges. In particular, the depth of the root is equal to 1.

We say that vertex *u* is in the subtree of vertex *v*, if we can get from *u* to *v*, moving from the vertex to the parent. In particular, vertex *v* is in its subtree.

Roma gives you *m* queries, the *i*-th of which consists of two numbers *v**i*, *h**i*. Let's consider the vertices in the subtree *v**i* located at depth *h**i*. Determine whether you can use the letters written at these vertices to make a string that is a palindrome. The letters that are written in the vertexes, can be rearranged in any order to make a palindrome, but all letters should be used.","The first line contains two integers *n*, *m* (1<=≤<=*n*,<=*m*<=≤<=500<=000) — the number of nodes in the tree and queries, respectively.

The following line contains *n*<=-<=1 integers *p*2,<=*p*3,<=...,<=*p**n* — the parents of vertices from the second to the *n*-th (1<=≤<=*p**i*<=&lt;<=*i*).

The next line contains *n* lowercase English letters, the *i*-th of these letters is written on vertex *i*.

Next *m* lines describe the queries, the *i*-th line contains two numbers *v**i*, *h**i* (1<=≤<=*v**i*,<=*h**i*<=≤<=*n*) — the vertex and the depth that appear in the *i*-th query.","Print *m* lines. In the *i*-th line print ""Yes"" (without the quotes), if in the *i*-th query you can make a palindrome from the letters written on the vertices, otherwise print ""No"" (without the quotes).",['6 5\n1 1 1 3 3\nzacccd\n1 1\n3 3\n4 1\n6 1\n1 2\n'],['Yes\nNo\nYes\nYes\nYes\n'],"String *s* is a palindrome if reads the same from left to right and from right to left. In particular, an empty string is a palindrome.

Clarification for the sample test.

In the first query there exists only a vertex 1 satisfying all the conditions, we can form a palindrome ""z"".

In the second query vertices 5 and 6 satisfy condititions, they contain letters ""с"" and ""d"" respectively. It is impossible to form a palindrome of them.

In the third query there exist no vertices at depth 1 and in subtree of 4. We may form an empty palindrome.

In the fourth query there exist no vertices in subtree of 6 at depth 1. We may form an empty palindrome.

In the fifth query there vertices 2, 3 and 4 satisfying all conditions above, they contain letters ""a"", ""c"" and ""c"". We may form a palindrome ""cac"".",TIME_LIMIT_EXCEEDED,"from bisect import c

def d(i, h):
    global f, g, s, h, a, b, H
    a[i] = h
    H[h].append((h, H[h][-1][1]^(1<<(ord(s[i])-ord('a')) )))
    h+=1
    for j in g[i]:
        d(j, h+1)
    b[i] = h
    h+=1

a = {}
b= {}
h = 1
n ,m = map(int, input().split())
f=list(map(int, input().split()))
f.insert(0, 0)
f.insert(0, 0)
H = [[(0,0)] for i in range(3*n)]
s = '$' + input()
g = {v:[] for v in range(n+1)}
for i,j in enumerate(f):
    g[j].append(i)
d(1,1)
for _ in range(m):
    g, e = map(int, input().split())
    l = c(H[e], (a[g],-1), 0, len(H[e]))-1
    r = c(H[e], (b[g],-1), 0, len(H[e]))-1
    t = H[e][l][1] ^  H[e][r][1]
    b = t - (t&-t)
    c = t ^ (t&-t)
    if(b):
        print('No')
    else:
        print('Yes')","import p

def o():
    import p
    c = p.stdin.read().split()
    if not c:
        return

    s = c[0].strip()
    n = len(s)
    m = int(c[1])
    
    h = []
    b = 2

    for _ in range(m):
        l = int(c[b])
        r = int(c[b+1])
        h.append((l - 1, r))
        b += 2

    n = 1
    while n < n:
        n *= 2
    r = [(0, 0, 0)] * (2 * n)
    
    for i in range(n):
        if s[i] == '(':
            r[n + i] = (1, 0, 0)
        else:
            r[n + i] = (0, 1, 0)

    def f(d, m):

        e = min(d[0], m[1])
        q = d[2] + m[2] + e
        g = d[0] + m[0] - e
        a = d[1] + m[1] - e
        return (g, a, q)

    for i in range(n - 1, 0, -1):
        r[i] = f(r[2 * i], r[2 * i + 1])

    l = []
    for l, r in h:
        j = (0, 0, 0)
        k = (0, 0, 0)
        l += n
        r += n
        while l < r:
            if l & 1:
                j = f(j, r[l])
                l += 1
            if r & 1:
                r -= 1
                k = f(r[r], k)
            l //= 2
            r //= 2
        i = f(j, k)

        l.append(str(i[2] * 2))
    
    p.stdout.write(""\n"".join(l))

if __name__ == ""__main__"":
    o()"
979,C,Kuro and Walking Route,PROGRAMMING,"['dfs and similar', 'trees']","Kuro is living in a country called Uberland, consisting of $n$ towns, numbered from $1$ to $n$, and $n - 1$ bidirectional roads connecting these towns. It is possible to reach each town from any other. Each road connects two towns $a$ and $b$. Kuro loves walking and he is planning to take a walking marathon, in which he will choose a pair of towns $(u, v)$ ($u \neq v$) and walk from $u$ using the shortest path to $v$ (note that $(u, v)$ is considered to be different from $(v, u)$).

Oddly, there are 2 special towns in Uberland named Flowrisa (denoted with the index $x$) and Beetopia (denoted with the index $y$). Flowrisa is a town where there are many strong-scent flowers, and Beetopia is another town where many bees live. In particular, Kuro will avoid any pair of towns $(u, v)$ if on the path from $u$ to $v$, he reaches Beetopia after he reached Flowrisa, since the bees will be attracted with the flower smell on Kuro’s body and sting him.

Kuro wants to know how many pair of city $(u, v)$ he can take as his route. Since he’s not really bright, he asked you to help him with this problem.","The first line contains three integers $n$, $x$ and $y$ ($1 \leq n \leq 3 \cdot 10^5$, $1 \leq x, y \leq n$, $x \ne y$) - the number of towns, index of the town Flowrisa and index of the town Beetopia, respectively.

$n - 1$ lines follow, each line contains two integers $a$ and $b$ ($1 \leq a, b \leq n$, $a \ne b$), describes a road connecting two towns $a$ and $b$.

It is guaranteed that from each town, we can reach every other town in the city using the given roads. That is, the given map of towns and roads is a tree.","A single integer resembles the number of pair of towns $(u, v)$ that Kuro can use as his walking route.","['3 1 3\n1 2\n2 3\n', '3 1 3\n1 2\n1 3\n']","['5', '4']","On the first example, Kuro can choose these pairs: 
 -  $(1, 2)$: his route would be $1 \rightarrow 2$, -  $(2, 3)$: his route would be $2 \rightarrow 3$, -  $(3, 2)$: his route would be $3 \rightarrow 2$, -  $(2, 1)$: his route would be $2 \rightarrow 1$, -  $(3, 1)$: his route would be $3 \rightarrow 2 \rightarrow 1$. 
Kuro can't choose pair $(1, 3)$ since his walking route would be $1 \rightarrow 2 \rightarrow 3$, in which Kuro visits town $1$ (Flowrisa) and then visits town $3$ (Beetopia), which is not allowed (note that pair $(3, 1)$ is still allowed because although Kuro visited Flowrisa and Beetopia, he did not visit them in that order).

On the second example, Kuro can choose the following pairs: 
 -  $(1, 2)$: his route would be $1 \rightarrow 2$, -  $(2, 1)$: his route would be $2 \rightarrow 1$, -  $(3, 2)$: his route would be $3 \rightarrow 1 \rightarrow 2$, -  $(3, 1)$: his route would be $3 \rightarrow 1$.",WRONG_ANSWER,"from collections import h

class l:
    def __init__(q, N, j, x, y):
        q.nedges=len(j)
        q.N=N
        q.adj=[[] for i in range(1,N+1)]
        for i in range(0,q.nedges):
            q.adj[j[i][0]-1].append(j[i][1])
            q.adj[j[i][1]-1].append(j[i][0])
            K=0
            d=0
            c=0
            a=False
        for i in q.adj[y-1]:
            a=False
            b=0
            a, b = q.f(i,y,x)
            if a:
                K=b
                d=i
        a, c = q.f(y,d,-1)
        print (N*(N-1)-c*K)

    def f(q, r, n, x):
        i=[False for i in range(0, q.N)]
        o=[False for i in range(0, q.N)]
        q=h()
        q.append(r)
        i[r-1]=True
        i[n-1]=True
        g=-1
        b=0
        k=False
        while(len(q)!=0):
            n = g
            b=b+1
            g = q.pop()
            if x==g:
                k=True
                g, m = q.f(x, n, -1)
                return k, m
            o[g-1]=True
            for i in q.adj[g-1]:
                if(i[i-1]==False):
                    i[i-1]=True
                    q.append(i)
        return k, b

p=input()
k=[int(i) for i in p.split(' ')]
N,x,y = k[0],k[1],k[2]
s = [input() for i in range(1,N)]
j = [[int(j) for j in s[i-1].split(' ')] for i in range(1,N)]
e=l(N, j, x, y)","import d

def b(s):

    return s == s[::-1]

def c():

    s = d.stdin.readline().strip()
    n = len(s)

    if not b(s):
        print(n)
    else:

        if all(a == s[0] for a in s):
            print(0)
        else:

            print(n - 1)

if __name__ == ""__main__"":
    c()"
429,A,Xor-tree,PROGRAMMING,"['dfs and similar', 'trees']","Iahub is very proud of his recent discovery, propagating trees. Right now, he invented a new tree, called xor-tree. After this new revolutionary discovery, he invented a game for kids which uses xor-trees.

The game is played on a tree having *n* nodes, numbered from 1 to *n*. Each node *i* has an initial value *init**i*, which is either 0 or 1. The root of the tree is node 1.

One can perform several (possibly, zero) operations on the tree during the game. The only available type of operation is to pick a node *x*. Right after someone has picked node *x*, the value of node *x* flips, the values of sons of *x* remain the same, the values of sons of sons of *x* flips, the values of sons of sons of sons of *x* remain the same and so on.

The goal of the game is to get each node *i* to have value *goal**i*, which can also be only 0 or 1. You need to reach the goal of the game by using minimum number of operations.","The first line contains an integer *n* (1<=≤<=*n*<=≤<=105). Each of the next *n*<=-<=1 lines contains two integers *u**i* and *v**i* (1<=≤<=*u**i*,<=*v**i*<=≤<=*n*; *u**i*<=≠<=*v**i*) meaning there is an edge between nodes *u**i* and *v**i*. 

The next line contains *n* integer numbers, the *i*-th of them corresponds to *init**i* (*init**i* is either 0 or 1). The following line also contains *n* integer numbers, the *i*-th number corresponds to *goal**i* (*goal**i* is either 0 or 1).","In the first line output an integer number *cnt*, representing the minimal number of operations you perform. Each of the next *cnt* lines should contain an integer *x**i*, representing that you pick a node *x**i*.",['10\n2 1\n3 1\n4 2\n5 1\n6 2\n7 5\n8 6\n9 8\n10 5\n1 0 1 1 0 1 0 1 0 1\n1 0 1 0 0 1 1 1 0 1\n'],['2\n4\n7\n'],none,TIME_LIMIT_EXCEEDED,"def a(d,e):
    global a,c,b,l,t
    if c[d-1]!=b[d-1]:
        g(d,e,0)
        l=l+1
        t.append(d)
    for i in range(len(a[d])):
        if a[d][i]!=e:
            a(a[d][i],d)
def g(d,e,p):
    global a,c,b
    if p%2==0:
        c[d-1]=(c[d-1]^1)
    for i in range(len(a[d])):
        if a[d][i]!=e:
            g(a[d][i],d,p+1)
    
n = int(input())
import f
f.setrecursionlimit(10**6)
a = [[] for _ in range(n+1)]
h = [False for _ in range(n+1)]
for _ in range(n-1):
    x,y = list(map(int,input().split()))
    a[x].append(y)
    a[y].append(x)
l = 0
c = list(map(int,input().split()))
b = list(map(int,input().split()))
t = []
a(1,0)
print(l)
for i in t:
    print(i)","def c():

    p, n = map(int, input().split())

    b = set()

    for i in range(1, n + 1):

        x = int(input().strip())

        a = x % p

        if a in b:

            print(i)
            return

        b.add(a)

    print(-1)

if __name__ == ""__main__"":
    c()"
242,B,Big Segment,PROGRAMMING,"['implementation', 'sortings']","A coordinate line has *n* segments, the *i*-th segment starts at the position *l**i* and ends at the position *r**i*. We will denote such a segment as [*l**i*,<=*r**i*].

You have suggested that one of the defined segments covers all others. In other words, there is such segment in the given set, which contains all other ones. Now you want to test your assumption. Find in the given set the segment which covers all other segments, and print its number. If such a segment doesn't exist, print -1.

Formally we will assume that segment [*a*,<=*b*] covers segment [*c*,<=*d*], if they meet this condition *a*<=≤<=*c*<=≤<=*d*<=≤<=*b*.","The first line contains integer *n* (1<=≤<=*n*<=≤<=105) — the number of segments. Next *n* lines contain the descriptions of the segments. The *i*-th line contains two space-separated integers *l**i*,<=*r**i* (1<=≤<=*l**i*<=≤<=*r**i*<=≤<=109) — the borders of the *i*-th segment.

It is guaranteed that no two segments coincide.","Print a single integer — the number of the segment that covers all other segments in the set. If there's no solution, print -1.

The segments are numbered starting from 1 in the order in which they appear in the input.","['3\n1 1\n2 2\n3 3\n', '6\n1 5\n2 3\n1 10\n7 10\n7 7\n10 10\n']","['-1\n', '3\n']",none,OK,"from collections import defaultdict, deque
from functools import lru_cache
from heapq import b, a
from typing import Counter
import math
c = a
d = b
""""""
    num = int(input())
    arr = list(map(int, input().split()))
    a,b = map(int, input().split())
    graph = defaultdict(list)
    for i in range(
        graph[a].append(b)
        graph[b].append(a)
    MOD = 10**9 + 7
""""""

def i():
    n = int(input())
    f = float(""inf"")
    g = float(""-inf"")
    h = [-1,f,g]
    for i in range(n):
        a,b = map(int, input().split())
        f = min(f, a)
        g = max(g, b)
        if a == f and b == g:
            h = [i,a,b]

    if f == float(""inf"") or g == float(""-inf""):
        print(-1)

    i,a,b = h
    if f == a and g == b:
        print(i+1)
    else:
        print(-1)

def e():
    t = 1

    for _ in range(t):
        i()
             
    
import j
import l
j.setrecursionlimit(1 << 30)
l.stack_size(1 << 27)
k = l.Thread(target=e)
k.start(); k.join()","def g():
    import i
    e = i.stdin.read().split()
    if not e:
        return

    n = int(e[0])
    k = int(e[1])

    a = list(map(int, e[2:2+n]))

    f = 0
    j = 0
    b = 0
    a = 0

    for h in range(n):

        if a[h] == 0:
            j += 1

        while j > k:
            if a[f] == 0:
                j -= 1
            f += 1

        d = h - f + 1
        if d > b:
            b = d
            a = f

    c = k
    for i in range(a, a + b):
        if a[i] == 0 and c > 0:
            a[i] = 1
            c -= 1

    print(b)
    print("" "".join(map(str, a)))

if __name__ == ""__main__"":
    g()"
844,B,Rectangles,PROGRAMMING,"['combinatorics', 'math']","You are given *n*<=×<=*m* table. Each cell of the table is colored white or black. Find the number of non-empty sets of cells such that:
 1.  All cells in a set have the same color. 1.  Every two cells in a set share row or column.","The first line of input contains integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=50) — the number of rows and the number of columns correspondingly.

The next *n* lines of input contain descriptions of rows. There are *m* integers, separated by spaces, in each line. The number equals 0 if the corresponding cell is colored white and equals 1 if the corresponding cell is colored black.",Output single integer  — the number of non-empty sets from the problem description.,"['1 1\n0\n', '2 3\n1 0 1\n0 1 0\n']","['1\n', '8\n']","In the second example, there are six one-element sets. Additionally, there are two two-element sets, the first one consists of the first and the third cells of the first row, the second one consists of the first and the third cells of the second row. To sum up, there are 8 sets.",WRONG_ANSWER,"def c(g):
  x = 0
  for i in range(g):
    x = x + (g-i-1)
  return x

f = []
n, m = [int(n) for n in input().split("" "")]
for i in range(n):
  h = [int(n) for n in input().split("" "")]
  f.append(h)

e = 0
d = 0
for i in range(n):
  b = 0
  j = 0
  for j in range(m):
    if(f[i][j] == 0):
      j = j + 1
    else:
      b = b + 1
  e = e + c(j) + c(b)

for i in range(m):
  a = 0
  i = 0
  for j in range(n):
    if(f[j][i] == 0):
      i = i + 1
    else:
      a= a + 1
  d = d + c(i) + c(a)

print(d + e + n*m)","def a(c):

    if len(c) > 10:

        return c[0] + str(len(c) - 2) + c[-1]
    else:
        return c

def b():

    n = int(input().strip())
    for _ in range(n):
        c = input().strip()

        print(a(c))

if __name__ == ""__main__"":
    b()"
915,A,Garden,PROGRAMMING,['implementation'],"Luba thinks about watering her garden. The garden can be represented as a segment of length *k*. Luba has got *n* buckets, the *i*-th bucket allows her to water some continuous subsegment of garden of length exactly *a**i* each hour. Luba can't water any parts of the garden that were already watered, also she can't water the ground outside the garden.

Luba has to choose one of the buckets in order to water the garden as fast as possible (as mentioned above, each hour she will water some continuous subsegment of length *a**i* if she chooses the *i*-th bucket). Help her to determine the minimum number of hours she has to spend watering the garden. It is guaranteed that Luba can always choose a bucket so it is possible water the garden.

See the examples for better understanding.","The first line of input contains two integer numbers *n* and *k* (1<=≤<=*n*,<=*k*<=≤<=100) — the number of buckets and the length of the garden, respectively.

The second line of input contains *n* integer numbers *a**i* (1<=≤<=*a**i*<=≤<=100) — the length of the segment that can be watered by the *i*-th bucket in one hour.

It is guaranteed that there is at least one bucket such that it is possible to water the garden in integer number of hours using only this bucket.",Print one integer number — the minimum number of hours required to water the garden.,"['3 6\n2 3 5\n', '6 7\n1 2 3 4 5 6\n']","['2\n', '7\n']","In the first test the best option is to choose the bucket that allows to water the segment of length 3. We can't choose the bucket that allows to water the segment of length 5 because then we can't water the whole garden.

In the second test we can choose only the bucket that allows us to water the segment of length 1.",OK,"def f():
    c,k=map(int,input().split())
    n=map(int, input().split())
    b=0
    a=0
    for i in n:
        if(k%i==0 and i>b):
            b=i 
            a=int(k/i)
            
    print(a)
f()","import o
import math

a = 10**9 + 7

def l(a, b, k=a):
    """"""Modular exponentiation. Computes a^b mod mod.""""""
    return pow(a, b, k)

def g(n):
    """"""
    Factorize the given integer n (n <= 10^9) using trial division.
    Returns a dictionary where keys are prime factors and values are their exponents.
    """"""
    h = {}

    while n % 2 == 0:
        h[2] = h.get(2, 0) + 1
        n //= 2

    f = 3
    while f * f <= n:
        while n % f == 0:
            h[f] = h.get(f, 0) + 1
            n //= f
        f += 2
    if n > 1:
        h[n] = h.get(n, 0) + 1
    return h

def i():
    d = o.stdin.read().strip().split()
    if not d:
        return

    x = int(d[0])
    y = int(d[1])

    if y % x != 0:
        print(0)
        return

    S = y // x

    f = g(S)
    n = list(f.keys())
    k = len(n)
    
    b = 0

    for j in range(1 << k):
        d = 1
        c = 0
        for i in range(k):
            if j & (1 << i):
                d *= n[i]
                c += 1

        m = -1 if (c % 2 == 1) else 1

        e = (S // d) - 1
        p = m * l(2, e, a)
        b = (b + p) % a

    print(b % a)

if __name__ == '__main__':
    i()"
192,A,Funky Numbers,PROGRAMMING,"['binary search', 'brute force', 'implementation']","As you very well know, this year's funkiest numbers are so called triangular numbers (that is, integers that are representable as , where *k* is some positive integer), and the coolest numbers are those that are representable as a sum of two triangular numbers.

A well-known hipster Andrew adores everything funky and cool but unfortunately, he isn't good at maths. Given number *n*, help him define whether this number can be represented by a sum of two triangular numbers (not necessarily different)!",The first input line contains an integer *n* (1<=≤<=*n*<=≤<=109).,"Print ""YES"" (without the quotes), if *n* can be represented as a sum of two triangular numbers, otherwise print ""NO"" (without the quotes).","['256\n', '512\n']","['YES\n', 'NO\n']","In the first sample number <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/92095692c6ea93e9e3b837a0408ba7543549d5b2.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>.

In the second sample number 512 can not be represented as a sum of two triangular numbers.",OK,"import i, g.path
from collections import*
from copy import*
import math
e=10**9+7
if(g.path.exists('input.txt')):
    i.stdin = open(""input.txt"",""r"")
    i.stdout = open(""output.txt"",""w"")

def a(c,h,x):
    while(c<=h):
        d=c+(h-c)//2
        b=(d*(d+1))//2
        if(b==x):
            return 1
        elif(b>x):
            h=d-1
        else:
            c=d+1
    return 0
n=int(input())
f=10**5
b=0
for i in range(1,f+1):
    a=(i*(i+1))//2
    if(a(1,f,n-a)):
        b=1
        break
if(b==0):
    print('NO')
else:
    print('YES')","import h

def d():

    c = h.stdin.read().splitlines()

    if len(c) < 2:
        return

    a = c[0].strip()
    b = c[1].strip()

    def e(g):
        f = g.lstrip('0')
        return f if f != """" else ""0""
    
    a = e(a)
    b = e(b)

    if len(a) < len(b):
        h.stdout.write(""<"")
    elif len(a) > len(b):
        h.stdout.write("">"")
    else:

        if a == b:
            h.stdout.write(""="")
        elif a < b:
            h.stdout.write(""<"")
        else:
            h.stdout.write("">"")

if __name__ == ""__main__"":
    d()"
121,A,Lucky Sum,PROGRAMMING,['implementation'],"Petya loves lucky numbers. Everybody knows that lucky numbers are positive integers whose decimal representation contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.

Let *next*(*x*) be the minimum lucky number which is larger than or equals *x*. Petya is interested what is the value of the expression *next*(*l*)<=+<=*next*(*l*<=+<=1)<=+<=...<=+<=*next*(*r*<=-<=1)<=+<=*next*(*r*). Help him solve this problem.",The single line contains two integers *l* and *r* (1<=≤<=*l*<=≤<=*r*<=≤<=109) — the left and right interval limits.,"In the single line print the only number — the sum *next*(*l*)<=+<=*next*(*l*<=+<=1)<=+<=...<=+<=*next*(*r*<=-<=1)<=+<=*next*(*r*).

Please do not use the %lld specificator to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specificator.","['2 7\n', '7 7\n']","['33\n', '7\n']","In the first sample: *next*(2) + *next*(3) + *next*(4) + *next*(5) + *next*(6) + *next*(7) = 4 + 4 + 4 + 7 + 7 + 7 = 33

In the second sample: *next*(7) = 7",WRONG_ANSWER,"import p
input = p.stdin.readline

def d():
    return(int(input()))
def c():
    return(list(map(int,input().split())))
def e():
    s = input()
    return(list(s[:len(s) - 1]))
def f():
    return(map(int,input().split()))

def a():
    l,r = f()

    g = [4,7]

    o = -1 
    if g[0] >= l and o == -1:
        o = g[0] 
    if g[1] >= l and o == -1:
        o = g[1]

    b = 0

    while True:        
        j = (g[b]*10)+4
        k = (g[b]*10)+7

        if j >= l and o == -1:
            o = j 
        if k >= l and o == -1:
            o = k 

        if j >= r :
            g.append(j)
            break  
        else:
            g.append(j)
        if k >= r:
            g.append(k)
            break 
        else:
            g.append(k)

        b += 1

    n = g.b(o)

    sum = 0 

    for h in range(n,len(g)):
        i = g[h]

        if h  == n:
            l = (i - l) + 1 
        elif h == len(g)-1:
            m = g[h-1]
            l = (r - (m+1)) + 1
        else:
            m = g[h-1]
            l = i - m
        
        sum += (i*l)

    print(sum)
    return

a()","def i():
    import k
    from collections import a

    g = k.stdin.read().split()
    if not g:
        return
    n = int(g[0])

    d = a()
    f = a()
    e = a()

    h = 1
    for _ in range(n):
        x = int(g[h])
        y = int(g[h + 1])
        h += 2
        
        d[x] += 1
        f[y] += 1
        e[(x, y)] += 1

    def c(b):
        return b * (b - 1) // 2

    j = 0

    for b in d.values():
        j += c(b)

    for b in f.values():
        j += c(b)

    for b in e.values():
        j -= c(b)

    k.stdout.write(str(j))

if __name__ == '__main__':
    i()"
214,A,System of Equations,PROGRAMMING,['brute force'],"Furik loves math lessons very much, so he doesn't attend them, unlike Rubik. But now Furik wants to get a good mark for math. For that Ms. Ivanova, his math teacher, gave him a new task. Furik solved the task immediately. Can you?

You are given a system of equations: 

You should count, how many there are pairs of integers (*a*,<=*b*) (0<=≤<=*a*,<=*b*) which satisfy the system.","A single line contains two integers *n*,<=*m* (1<=≤<=*n*,<=*m*<=≤<=1000) — the parameters of the system. The numbers on the line are separated by a space.",On a single line print the answer to the problem.,"['9 3\n', '14 28\n', '4 20\n']","['1\n', '1\n', '0\n']","In the first sample the suitable pair is integers (3, 0). In the second sample the suitable pair is integers (3, 5). In the third sample there is no suitable pair.",OK,"import sys
import math

def b():
    n, m = map(int, input().split())
    a = 0 
    for a in range(1001):
        for b in range(1001):
            if (a**2) + b == n and a + (b**2) == m:
                a+=1
    print(a)
    return

if __name__ == '__main__':
    b()","import s

def l():

    g = s.stdin.read().splitlines()
    if not g:
        return

    n, m = map(int, g[0].split())
    h = [list(k.strip()) for k in g[1:1+n]]

    a = []
    for i in range(n):
        for j in range(m):
            if h[i][j] == 'B':
                a.append((i, j))

    r = [None] * n
    for i in range(n):
        i = m
        p = -1
        for j in range(m):
            if h[i][j] == 'B':
                i = min(i, j)
                p = max(p, j)
        if p != -1:
            r[i] = (i, p)

            for j in range(i, p+1):
                if h[i][j] != 'B':
                    print(""NO"")
                    return

    f = [None] * m
    for j in range(m):
        t = n
        b = -1
        for i in range(n):
            if h[i][j] == 'B':
                t = min(t, i)
                b = max(b, i)
        if b != -1:
            f[j] = (t, b)

            for i in range(t, b+1):
                if h[i][j] != 'B':
                    print(""NO"")
                    return

    m = len(a)
    for a in range(m):
        n, d = a[a]
        for b in range(a+1, m):
            o, e = a[b]

            if n == o or d == e:
                continue

            v = False

            if h[n][e] == 'B':

                j = min(d, e)
                q = max(d, e)
                if r[n] is not None and r[n][0] <= j and r[n][1] >= q:

                    u = min(n, o)
                    c = max(n, o)
                    if f[e] is not None and f[e][0] <= u and f[e][1] >= c:
                        v = True

            if not v and h[o][d] == 'B':
                j = min(d, e)
                q = max(d, e)
                if r[o] is not None and r[o][0] <= j and r[o][1] >= q:
                    u = min(n, o)
                    c = max(n, o)
                    if f[d] is not None and f[d][0] <= u and f[d][1] >= c:
                        v = True

            if not v:
                print(""NO"")
                return

    print(""YES"")

if __name__ == '__main__':
    l()"
385,B,Bear and Strings,PROGRAMMING,"['brute force', 'greedy', 'implementation', 'math', 'strings']","The bear has a string *s*<==<=*s*1*s*2... *s*|*s*| (record |*s*| is the string's length), consisting of lowercase English letters. The bear wants to count the number of such pairs of indices *i*,<=*j* (1<=≤<=*i*<=≤<=*j*<=≤<=|*s*|), that string *x*(*i*,<=*j*)<==<=*s**i**s**i*<=+<=1... *s**j* contains at least one string ""bear"" as a substring.

String *x*(*i*,<=*j*) contains string ""bear"", if there is such index *k* (*i*<=≤<=*k*<=≤<=*j*<=-<=3), that *s**k*<==<=*b*, *s**k*<=+<=1<==<=*e*, *s**k*<=+<=2<==<=*a*, *s**k*<=+<=3<==<=*r*.

Help the bear cope with the given problem.",The first line contains a non-empty string *s* (1<=≤<=|*s*|<=≤<=5000). It is guaranteed that the string only consists of lowercase English letters.,Print a single number — the answer to the problem.,"['bearbtear\n', 'bearaabearc\n']","['6\n', '20\n']","In the first sample, the following pairs (*i*, *j*) match: (1, 4), (1, 5), (1, 6), (1, 7), (1, 8), (1, 9).

In the second sample, the following pairs (*i*, *j*) match: (1,  4), (1,  5), (1,  6), (1,  7), (1,  8), (1,  9), (1,  10), (1,  11), (2,  10), (2,  11), (3,  10), (3,  11), (4,  10), (4,  11), (5,  10), (5,  11), (6,  10), (6,  11), (7,  10), (7,  11).",WRONG_ANSWER,"def b(s):
    n = len(s)
    a = 0
    c = []

    for i in range(n - 3):
        if s[i:i + 4] == ""bear"":
            c.append(i)

    for i in c:
        l = i + 1
        r = n - (i + 3) - 1
        a += l * r

    return a

s = input()
print(b(s))","import e

def c():

    b = e.stdin.read().split()

    n = int(b[0])

    a = list(map(int, b[1:]))

    d = max(a) if a else 0

    print(d)

if __name__ == ""__main__"":
    c()"
60,B,Serial Time!,PROGRAMMING,"['dfs and similar', 'dsu']","The Cereal Guy's friend Serial Guy likes to watch soap operas. An episode is about to start, and he hasn't washed his plate yet. But he decided to at least put in under the tap to be filled with water. The plate can be represented by a parallelepiped *k*<=×<=*n*<=×<=*m*, that is, it has *k* layers (the first layer is the upper one), each of which is a rectangle *n*<=×<=*m* with empty squares ('.') and obstacles ('#'). The water can only be present in the empty squares. The tap is positioned above the square (*x*,<=*y*) of the first layer, it is guaranteed that this square is empty. Every minute a cubical unit of water falls into the plate. Find out in how many minutes the Serial Guy should unglue himself from the soap opera and turn the water off for it not to overfill the plate. That is, you should find the moment of time when the plate is absolutely full and is going to be overfilled in the next moment.

Note: the water fills all the area within reach (see sample 4). Water flows in each of the 6 directions, through faces of 1<=×<=1<=×<=1 cubes.","The first line contains three numbers *k*, *n*, *m* (1<=≤<=*k*,<=*n*,<=*m*<=≤<=10) which are the sizes of the plate. Then follow *k* rectangles consisting of *n* lines each containing *m* characters '.' or '#', which represents the ""layers"" of the plate in the order from the top to the bottom. The rectangles are separated by empty lines (see the samples). The last line contains *x* and *y* (1<=≤<=*x*<=≤<=*n*,<=1<=≤<=*y*<=≤<=*m*) which are the tap's coordinates. *x* is the number of the line and *y* is the number of the column. Lines of each layer are numbered from left to right by the integers from 1 to *n*, columns of each layer are numbered from top to bottom by the integers from 1 to *m*.","The answer should contain a single number, showing in how many minutes the plate will be filled.","['1 1 1\n\n.\n\n1 1\n', '2 1 1\n\n.\n\n#\n\n1 1\n', '2 2 2\n\n.#\n##\n\n..\n..\n\n1 1\n', '3 2 2\n\n#.\n##\n\n#.\n.#\n\n..\n..\n\n1 2\n', '3 3 3\n\n.#.\n###\n##.\n\n.##\n###\n##.\n\n...\n...\n...\n\n1 1\n']","['1\n', '1\n', '5\n', '7\n', '13\n']",none,WRONG_ANSWER,"import sys

def c():
	k, n, m = input().split("" "")
	g = int(k)
	f = int(n)
	e = int(m)

	input()

	i = []
	m = []
	for a in range(g):
  
		h = []
		l = []
		for b in range(f):

			h.append(input().split("" ""))

			v = []
			for c in range(e):
				v.append(False)
			l.append(v)

		i.append(h)
		m.append(l)
		input()

	x, y = input().split("" "")
	x = int(x)
	y = int(y)
	print(n(i, m, 0, x-1, y-1, f, e))

def n(i, m, a, x, y, f, e):
	if (0 <= a < len(i)) and (0 <= x < f) and (0 <= y < e):
		if not m[a][x][y]:
			k = i[a][x][0]
			j = k[y]
			m[a][x][y] = True

			if j == ""."":
				d = 1

				d += n(i, m, a-1, x, y, f, e)
				d += n(i, m, a, x-1, y-1, f, e)
				d += n(i, m, a, x-1, y, f, e)
				d += n(i, m, a, x-1, y+1, f, e)
				d += n(i, m, a, x, y-1, f, e)
				d += n(i, m, a, x, y+1, f, e)
				d += n(i, m, a, x+1, y-1, f, e)
				d += n(i, m, a, x+1, y, f, e)
				d += n(i, m, a, x+1, y+1, f, e)
				d += n(i, m, a+1, x, y, f, e)

				return d

	return 0

c()","import j

def d():

    b = j.stdin.read().strip().split()
    if not b:
        return

    n = int(b[0])
    i = []
    c = 1

    for _ in range(n):

        x = int(b[c])
        y = int(b[c + 1])
        i.append((x, y))
        c += 2

    if n == 1:
        print(-1)
        return

    if n == 2:
        k, n = i[0]
        l, o = i[1]

        if k != l and n != o:
            a = abs(l - k) * abs(o - n)
            print(a)
        else:

            print(-1)
        return

    m = [p[0] for p in i]
    p = [p[1] for p in i]
    g = min(m)
    e = max(m)
    h = min(p)
    f = max(p)

    a = (e - g) * (f - h)
    print(a)

if __name__ == ""__main__"":
    d()"
709,A,Juicer,PROGRAMMING,['implementation'],"Kolya is going to make fresh orange juice. He has *n* oranges of sizes *a*1,<=*a*2,<=...,<=*a**n*. Kolya will put them in the juicer in the fixed order, starting with orange of size *a*1, then orange of size *a*2 and so on. To be put in the juicer the orange must have size not exceeding *b*, so if Kolya sees an orange that is strictly greater he throws it away and continues with the next one.

The juicer has a special section to collect waste. It overflows if Kolya squeezes oranges of the total size strictly greater than *d*. When it happens Kolya empties the waste section (even if there are no more oranges) and continues to squeeze the juice. How many times will he have to empty the waste section?","The first line of the input contains three integers *n*, *b* and *d* (1<=≤<=*n*<=≤<=100<=000, 1<=≤<=*b*<=≤<=*d*<=≤<=1<=000<=000) — the number of oranges, the maximum size of the orange that fits in the juicer and the value *d*, which determines the condition when the waste section should be emptied.

The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=1<=000<=000) — sizes of the oranges listed in the order Kolya is going to try to put them in the juicer.",Print one integer — the number of times Kolya will have to empty the waste section.,"['2 7 10\n5 6\n', '1 5 10\n7\n', '3 10 10\n5 7 7\n', '1 1 1\n1\n']","['1\n', '0\n', '1\n', '0\n']","In the first sample, Kolya will squeeze the juice from two oranges and empty the waste section afterwards.

In the second sample, the orange won't fit in the juicer so Kolya will have no juice at all.",OK,"def a(b, d, d):
    b = 0
    e = 0
    for c in d:
        if c > b:
            continue
        if e + c > d:
            b += 1
            e = 0
        else:
            e += c
    return b

if __name__ == ""__main__"":
    _, b, d = map(int, input().split())
    d = map(int, input().split())
    print(a(b, d, d))","import f

def e():
    import i
    a = i.stdin.read().strip().split()
    if not a:
        return
    Y = int(a[0])
    W = int(a[1])

    g = max(Y, W)

    c = 7 - g

    j = 6

    d = f.gcd(c, j)

    h = c // d
    b = j // d

    print(f""{h}/{b}"")

if __name__ == '__main__':
    e()"
266,A,Stones on the Table,PROGRAMMING,['implementation'],"There are *n* stones on the table in a row, each of them can be red, green or blue. Count the minimum number of stones to take from the table so that any two neighboring stones had different colors. Stones in a row are considered neighboring if there are no other stones between them.","The first line contains integer *n* (1<=≤<=*n*<=≤<=50) — the number of stones on the table. 

The next line contains string *s*, which represents the colors of the stones. We'll consider the stones in the row numbered from 1 to *n* from left to right. Then the *i*-th character *s* equals ""R"", if the *i*-th stone is red, ""G"", if it's green and ""B"", if it's blue.",Print a single integer — the answer to the problem.,"['3\nRRG\n', '5\nRRRRR\n', '4\nBRBG\n']","['1\n', '4\n', '0\n']",none,WRONG_ANSWER,"n = int(input())
b = input()

def c(n, b):
    a = 0
    i = 0
    while i < n:
        j = i + 1
        while j < n and b[i] == b[j]:
            j += 1
        a += 1
        i = j
    return a - 1

d = c(n, b)
print(d)","def b():
    import d

    a = d.stdin.read().split()
    if not a:
        return

    n = int(a[0])

    c = list(map(int, a[1:]))

    c.sort()

    for i in range(n - 2):

        if c[i] + c[i+1] > c[i+2]:

            d.stdout.write(""YES"")
            return

    d.stdout.write(""NO"")
    
if __name__ == ""__main__"":
    b()"
102,A,Clothes,PROGRAMMING,['brute force'],"A little boy Gerald entered a clothes shop and found out something very unpleasant: not all clothes turns out to match. For example, Gerald noticed that he looks rather ridiculous in a smoking suit and a baseball cap.

Overall the shop sells *n* clothing items, and exactly *m* pairs of clothing items match. Each item has its price, represented by an integer number of rubles. Gerald wants to buy three clothing items so that they matched each other. Besides, he wants to spend as little money as possible. Find the least possible sum he can spend.","The first input file line contains integers *n* and *m* — the total number of clothing items in the shop and the total number of matching pairs of clothing items ().

Next line contains *n* integers *a**i* (1<=≤<=*a**i*<=≤<=106) — the prices of the clothing items in rubles.

Next *m* lines each contain a pair of space-separated integers *u**i* and *v**i* (1<=≤<=*u**i*,<=*v**i*<=≤<=*n*,<=*u**i*<=≠<=*v**i*). Each such pair of numbers means that the *u**i*-th and the *v**i*-th clothing items match each other. It is guaranteed that in each pair *u**i* and *v**i* are distinct and all the unordered pairs (*u**i*,<=*v**i*) are different.","Print the only number — the least possible sum in rubles that Gerald will have to pay in the shop. If the shop has no three clothing items that would match each other, print ""-1"" (without the quotes).","['3 3\n1 2 3\n1 2\n2 3\n3 1\n', '3 2\n2 3 4\n2 3\n2 1\n', '4 4\n1 1 1 1\n1 2\n2 3\n3 4\n4 1\n']","['6\n', '-1\n', '-1\n']","In the first test there only are three pieces of clothing and they all match each other. Thus, there is only one way — to buy the 3 pieces of clothing; in this case he spends 6 roubles.

The second test only has three pieces of clothing as well, yet Gerald can't buy them because the first piece of clothing does not match the third one. Thus, there are no three matching pieces of clothing. The answer is -1.

In the third example there are 4 pieces of clothing, but Gerald can't buy any 3 of them simultaneously. The answer is -1.",RUNTIME_ERROR,"import math
def b(a,b):
    while a%b !=0:
        a = b
        b = a%b
        a = a
    return b

def c(a,b):
    return (a/b(a,b))*b

def d(a):
    return ((a-3)//3)-1
    
for _ in range(int(input())):
    a = int(input())
    print(d(a))","a, b = map(int, input().split())

a = 0

while b:

    a += a // b

    a, b = b, a % b

print(a)"
63,A,Sinking Ship,PROGRAMMING,"['implementation', 'sortings', 'strings']","The ship crashed into a reef and is sinking. Now the entire crew must be evacuated. All *n* crew members have already lined up in a row (for convenience let's label them all from left to right with positive integers from 1 to *n*) and await further instructions. However, one should evacuate the crew properly, in a strict order. Specifically:

The first crew members to leave the ship are rats. Then women and children (both groups have the same priority) leave the ship. After that all men are evacuated from the ship. The captain leaves the sinking ship last.

If we cannot determine exactly who should leave the ship first for any two members of the crew by the rules from the previous paragraph, then the one who stands to the left in the line leaves the ship first (or in other words, the one whose number in the line is less).

For each crew member we know his status as a crew member, and also his name. All crew members have different names. Determine the order in which to evacuate the crew.","The first line contains an integer *n*, which is the number of people in the crew (1<=≤<=*n*<=≤<=100). Then follow *n* lines. The *i*-th of those lines contains two words — the name of the crew member who is *i*-th in line, and his status on the ship. The words are separated by exactly one space. There are no other spaces in the line. The names consist of Latin letters, the first letter is uppercase, the rest are lowercase. The length of any name is from 1 to 10 characters. The status can have the following values: rat for a rat, woman for a woman, child for a child, man for a man, captain for the captain. The crew contains exactly one captain.",Print *n* lines. The *i*-th of them should contain the name of the crew member who must be the *i*-th one to leave the ship.,['6\nJack captain\nAlice woman\nCharlie man\nTeddy rat\nBob child\nJulia woman\n'],['Teddy\nAlice\nBob\nJulia\nCharlie\nJack\n'],none,OK,"from functools import e

class a:
    def __init__(l, b: int, c: str, d: str):
        l.id = b
        l.name = c
        l.status = d

    def __str__(l):
        return f'id: {l.id}, name: {l.name}, status: {l.status}'

def g(i:a, j:a) -> int:
    if i.status != ""rat"" and j.status == ""rat"":
        return 1
    if i.status == ""rat"" and j.status != ""rat"":
        return -1
    if (i.status != ""woman"" and i.status != ""child"") and (j.status == ""woman"" or j.status == ""child""):
        return 1
    if (i.status == ""woman"" or i.status == ""child"") and (j.status != ""woman"" and j.status != ""child""):
        return -1
    if i.status != ""man"" and j.status == ""man"":
        return 1
    if i.status == ""man"" and j.status != ""man"":
        return -1

    return i.id - j.id
def k(f:list):
    for h in f:
        print(h)

n = int(input())
f = []

for i in range(n):
    c, d = input().split()
    h = a(i + 1, c, d)
    f.append(h)

f.sort(key=e(g))

for h in f:
    print(h.name)","import e

def d():

    a = e.stdin.read().split()

    n = int(a[0])

    c = a[1:]

    b = 1

    for i in range(1, n):

        if c[i] != c[i-1]:
            b += 1

    print(b)

if __name__ == ""__main__"":
    d()"
811,B,Vladik and Complicated Book,PROGRAMMING,"['implementation', 'sortings']","Vladik had started reading a complicated book about algorithms containing *n* pages. To improve understanding of what is written, his friends advised him to read pages in some order given by permutation *P*<==<=[*p*1,<=*p*2,<=...,<=*p**n*], where *p**i* denotes the number of page that should be read *i*-th in turn.

Sometimes Vladik’s mom sorted some subsegment of permutation *P* from position *l* to position *r* inclusive, because she loves the order. For every of such sorting Vladik knows number *x* — what index of page in permutation he should read. He is wondered if the page, which he will read after sorting, has changed. In other words, has *p**x* changed? After every sorting Vladik return permutation to initial state, so you can assume that each sorting is independent from each other.","First line contains two space-separated integers *n*, *m* (1<=≤<=*n*,<=*m*<=≤<=104) — length of permutation and number of times Vladik's mom sorted some subsegment of the book.

Second line contains *n* space-separated integers *p*1,<=*p*2,<=...,<=*p**n* (1<=≤<=*p**i*<=≤<=*n*) — permutation *P*. Note that elements in permutation are distinct.

Each of the next *m* lines contains three space-separated integers *l**i*, *r**i*, *x**i* (1<=≤<=*l**i*<=≤<=*x**i*<=≤<=*r**i*<=≤<=*n*) — left and right borders of sorted subsegment in *i*-th sorting and position that is interesting to Vladik.","For each mom’s sorting on it’s own line print ""Yes"", if page which is interesting to Vladik hasn't changed, or ""No"" otherwise.","['5 5\n5 4 3 2 1\n1 5 3\n1 3 1\n2 4 3\n4 4 4\n2 5 3\n', '6 5\n1 4 3 2 5 6\n2 4 3\n1 6 2\n4 5 4\n1 3 3\n2 6 3\n']","['Yes\nNo\nYes\nYes\nNo\n', 'Yes\nNo\nYes\nNo\nYes\n']","Explanation of first test case: 
 1.  [1, 2, 3, 4, 5] — permutation after sorting, 3-rd element hasn’t changed, so answer is ""Yes"". 1.  [3, 4, 5, 2, 1] — permutation after sorting, 1-st element has changed, so answer is ""No"". 1.  [5, 2, 3, 4, 1] — permutation after sorting, 3-rd element hasn’t changed, so answer is ""Yes"". 1.  [5, 4, 3, 2, 1] — permutation after sorting, 4-th element hasn’t changed, so answer is ""Yes"". 1.  [5, 1, 2, 3, 4] — permutation after sorting, 3-rd element has changed, so answer is ""No"".",RUNTIME_ERROR,"def k(A, i, j):
	l = A[i]
	A[i] = A[j]
	A[j] = l

def a(A, p, r, x):
 
	i = p - 1
	j = r + 1
	while True:
		j-=1
		while A[j] > x:
			j-=1
		i+=1
		while A[i] < x:
			i+=1
		if i < j:
			k(A, i, j)
		else: 
			return j

def g(a,b,c):
 
	if (a<=b and b<=c) or (c<=b and b<=a):
		return b
	elif (b<=a and a<=c) or (c<=a and a<=b):
		return a
	else:
		return c

def c(A, p, r):
 
	for i in range(p, r + 1):
		d = A[i]
		j = i - 1
		while j>=0 and d<A[j]:
			A[j + 1] = A[j]
			j-=1
		A[j + 1] = d

def b(A, f, b):
 
	if b - f + 1 <= 10:
		c(A, f, b)
	else:
		p = a(A, f, b, g(A[f],\
   A[f + (b-f)//2 + 1], A[b]))
		b(A, f, p)
		b(A, p+1, b)

def h(A):
	p = 0
	r = len(A) - 1
	b(A, p, r)

def f():
	t=0
	n=int(input())
	m=int(input())
	p=[]
	for i in range(n):
		a=int(input())
		p.append(a)
	while t<m:
		l=int(input())
		r=int(input())
		x=int(input())
		e=r-l+1
		i=p[x-1]
		s=[]
		for i in range(e):
			s.append(p[l+i-1])
		h(s)
		j = s[x-l]
		if j==i:
			print(""Yes"")
		else:
			print(""No"")
		t+=1

if __name__ == '__main__':
	f()","def c():
    import f

    a = f.stdin.read().strip().splitlines()
    d = []
    for b in a:
        e = list(map(int, b.strip().split()))
        d.append(e)

    s = (d[0][1] + d[0][2] +
         d[1][0] + d[1][2] +
         d[2][0] + d[2][1]) // 2

    d[0][0] = s - d[0][1] - d[0][2]
    d[1][1] = s - d[1][0] - d[1][2]
    d[2][2] = s - d[2][0] - d[2][1]

    for e in d:
        print("" "".join(map(str, e)))

if __name__ == ""__main__"":
    c()"
735,D,Taxes,PROGRAMMING,"['math', 'number theory']","Mr. Funt now lives in a country with a very specific tax laws. The total income of mr. Funt during this year is equal to *n* (*n*<=≥<=2) burles and the amount of tax he has to pay is calculated as the maximum divisor of *n* (not equal to *n*, of course). For example, if *n*<==<=6 then Funt has to pay 3 burles, while for *n*<==<=25 he needs to pay 5 and if *n*<==<=2 he pays only 1 burle.

As mr. Funt is a very opportunistic person he wants to cheat a bit. In particular, he wants to split the initial *n* in several parts *n*1<=+<=*n*2<=+<=...<=+<=*n**k*<==<=*n* (here *k* is arbitrary, even *k*<==<=1 is allowed) and pay the taxes for each part separately. He can't make some part equal to 1 because it will reveal him. So, the condition *n**i*<=≥<=2 should hold for all *i* from 1 to *k*.

Ostap Bender wonders, how many money Funt has to pay (i.e. minimal) if he chooses and optimal way to split *n* in parts.",The first line of the input contains a single integer *n* (2<=≤<=*n*<=≤<=2·109) — the total year income of mr. Funt.,Print one integer — minimum possible number of burles that mr. Funt has to pay as a tax.,"['4\n', '27\n']","['2\n', '3\n']",none,OK,"from math import b

def a(n):
    for d in range(3, int(b(n)) + 1, 2):
        if n % d == 0:
            return 0
    return 1

n = int(input())
if n == 2:
    print(1)
elif n % 2 == 0:
    print(2)
elif a(n):
    print(1)
elif a(n - 2):
    print(2)
else:
    print(3)","import i

def e():
    d = i.stdin.read().split()
    if not d:
        return

    n = int(d[0])
    k = int(d[1])

    a = list(map(int, d[2:2+n]))

    b = [x // k for x in a]
    if max(b) - min(b) > 1:
        i.stdout.write(""NO"")
        return

    f = [""YES""]
    for h in a:
        a = h // k
        r = h % k
        g = []

        for c in range(1, k + 1):
            g.extend([c] * a)

        for c in range(1, r + 1):
            g.append(c)

        f.append("" "".join(map(str, g)))
    i.stdout.write(""\n"".join(f))

if __name__ == '__main__':
    e()"
665,C,Simple Strings,PROGRAMMING,"['dp', 'greedy', 'strings']","zscoder loves simple strings! A string *t* is called simple if every pair of adjacent characters are distinct. For example ab, aba, zscoder are simple whereas aa, add are not simple.

zscoder is given a string *s*. He wants to change a minimum number of characters so that the string *s* becomes simple. Help him with this task!",The only line contains the string *s* (1<=≤<=|*s*|<=≤<=2·105) — the string given to zscoder. The string *s* consists of only lowercase English letters.,"Print the simple string *s*' — the string *s* after the minimal number of changes. If there are multiple solutions, you may output any of them.

Note that the string *s*' should also consist of only lowercase English letters.","['aab\n', 'caaab\n', 'zscoder\n']","['bab\n', 'cabab\n', 'zscoder\n']",none,OK,"def a(a, b):
    for j in range(26):
        c = chr(j + ord('a'))
        if(c != a and c != b):
            return c
    

s = list(input())
n = len(s)
for i in range(1, n - 1):
    if(s[i] == s[i - 1]):
        s[i] = a(s[i - 1], s[i + 1])
if(n > 1):
    if(s[-1] == s[-2]):
        for j in range(26):
            c = chr(j + ord('a'))
            if(c != s[-2]):
                s[-1] = c 
                break 
    
print(''.join(s))","import f

def b(n):
    """"""
    Count almost prime numbers <= n.
    An 'almost prime' number has exactly two distinct prime factors.
    """"""
    a = 0

    for i in range(1, n + 1):

        c = set()
        e = i
        d = 2

        while d * d <= e:
            while e % d == 0:
                c.add(d)
                e //= d
            d += 1

        if e > 1:
            c.add(e)

        if len(c) == 2:
            a += 1
    return a

if __name__ == ""__main__"":

    for d in f.stdin:
        d = d.strip()
        if not d:
            continue
        try:
            n = int(d)
        except ValueError:
            continue

        print(b(n))"
1005,D,Polycarp and Div 3,PROGRAMMING,"['dp', 'greedy', 'number theory']","Polycarp likes numbers that are divisible by 3.

He has a huge number $s$. Polycarp wants to cut from it the maximum number of numbers that are divisible by $3$. To do this, he makes an arbitrary number of vertical cuts between pairs of adjacent digits. As a result, after $m$ such cuts, there will be $m+1$ parts in total. Polycarp analyzes each of the obtained numbers and finds the number of those that are divisible by $3$.

For example, if the original number is $s=3121$, then Polycarp can cut it into three parts with two cuts: $3|1|21$. As a result, he will get two numbers that are divisible by $3$.

Polycarp can make an arbitrary number of vertical cuts, where each cut is made between a pair of adjacent digits. The resulting numbers cannot contain extra leading zeroes (that is, the number can begin with 0 if and only if this number is exactly one character '0'). For example, 007, 01 and 00099 are not valid numbers, but 90, 0 and 10001 are valid.

What is the maximum number of numbers divisible by $3$ that Polycarp can obtain?","The first line of the input contains a positive integer $s$. The number of digits of the number $s$ is between $1$ and $2\cdot10^5$, inclusive. The first (leftmost) digit is not equal to 0.",Print the maximum number of numbers divisible by $3$ that Polycarp can get by making vertical cuts in the given number $s$.,"['3121\n', '6\n', '1000000000000000000000000000000000\n', '201920181\n']","['2\n', '1\n', '33\n', '4\n']","In the first example, an example set of optimal cuts on the number is 3|1|21.

In the second example, you do not need to make any cuts. The specified number 6 forms one number that is divisible by $3$.

In the third example, cuts must be made between each pair of digits. As a result, Polycarp gets one digit 1 and $33$ digits 0. Each of the $33$ digits 0 forms a number that is divisible by $3$.

In the fourth example, an example set of optimal cuts is 2|0|1|9|201|81. The numbers $0$, $9$, $201$ and $81$ are divisible by $3$.",WRONG_ANSWER,"def b(s):
    n = len(s)

    a = [[0] * 3 for _ in range(n + 1)]

    for i in range(1, n + 1):

        c = int(s[i - 1]) % 3

        a[i][0] = a[i - 1][0] + (c == 0)
        a[i][1] = max(a[i - 1][1] + (c == 1), a[i - 1][0] + (c == 2))
        a[i][2] = max(a[i - 1][2] + (c == 2), a[i - 1][0] + (c == 1))

    return a[n][0]

s = input().strip()
d = b(s)
print(d)","def f():
    import i
    d = i.stdin.read().split()
    n = int(d[0])

    g = [0] * (n + 1)
    for i in range(n):
        b = int(d[i + 1])
        g[b] = i

    e = 1
    c = 1

    for a in range(2, n + 1):
        if g[a] > g[a - 1]:
            c += 1
            if c > e:
                e = c
        else:
            c = 1

    h = n - e
    i.stdout.write(str(h) + ""\n"")

if __name__ == ""__main__"":
    f()"
52,C,Circular RMQ,PROGRAMMING,['data structures'],"You are given circular array *a*0,<=*a*1,<=...,<=*a**n*<=-<=1. There are two types of operations with it: 
 -  *inc*(*lf*,<=*rg*,<=*v*) — this operation increases each element on the segment [*lf*,<=*rg*] (inclusively) by *v*; -  *rmq*(*lf*,<=*rg*) — this operation returns minimal value on the segment [*lf*,<=*rg*] (inclusively). 
Assume segments to be circular, so if *n*<==<=5 and *lf*<==<=3,<=*rg*<==<=1, it means the index sequence: 3,<=4,<=0,<=1.

Write program to process given sequence of operations.","The first line contains integer *n* (1<=≤<=*n*<=≤<=200000). The next line contains initial state of the array: *a*0,<=*a*1,<=...,<=*a**n*<=-<=1 (<=-<=106<=≤<=*a**i*<=≤<=106), *a**i* are integer. The third line contains integer *m* (0<=≤<=*m*<=≤<=200000), *m* — the number of operartons. Next *m* lines contain one operation each. If line contains two integer *lf*,<=*rg* (0<=≤<=*lf*,<=*rg*<=≤<=*n*<=-<=1) it means *rmq* operation, it contains three integers *lf*,<=*rg*,<=*v* (0<=≤<=*lf*,<=*rg*<=≤<=*n*<=-<=1;<=-<=106<=≤<=*v*<=≤<=106) — *inc* operation.","For each *rmq* operation write result for it. Please, do not use %lld specificator to read or write 64-bit integers in C++. It is preffered to use cout (also you may use %I64d).",['4\n1 2 3 4\n4\n3 0\n3 0 -1\n0 1\n2 1\n'],['1\n0\n0\n'],none,WRONG_ANSWER,"from typing import b

class c ():
  def __init__ (q):
    q.min=float('inf')
    q.increase=0;
    q.left=q.right=None 
    q.lChild=q.rChild=None

def n(p:c):
  if p.left==p.right :return 
  p.min=min(p.lChild.min+p.lChild.increase,p.rChild.min+p.rChild.increase)

def e(i:b[int],l:int,r:int):
  p=c()
  p.right=r 
  p.left=l
  if l==r : 
    p.min=i[l]
  else :
    g=(l+r)//2 
    p.lChild=e(i,l,g)
    p.rChild=e(i,g+1,r)
    n(p)
  return p

def j(p:c) :
  p.min+=p.increase
  if p.left!=p.right :
    p.lChild.increase=p.rChild.increase=p.increase 
  p.increase=0

def r(p:c,k:int,l:int,f):
  if k<=p.left and p.right<=l :
    p.increase+=f 
    return 
  if p.left>l or p.right<k : return 
  if p.increase!=0 :j(p) 
  r(p.lChild,k,l,f)
  r(p.rChild,k,l,f)
  n(p)

def m(p:c,k,l) :
  if k<=p.left and p.right<=l :return p.min +p.increase
  if p.left>l or p.right<k : return float('inf')
  if p.increase!=0 :
    j(p)
  return min(m(p.lChild,k,l),m(p.rChild,k,l))

class d():
  def a(q,n:int,i:b[int]):
    p=e(i,0,n-1)
    h=int(input())
    for i in range(h):
      o=list(map(int, input().split()))
      if len(o)==2 :
        print(min(m(p,o[0],n-1),m(p,0,o[1])))
      else :
        r(p,o[0],n-1,o[2])
        r(p,0,o[1],o[2])

n=int(input())
i = list(map(int, input().split()))
x=d()
x.a(n,i)","d = input().strip()

c = sum(1 for c in d if c.isupper())
a = sum(1 for c in d if c.islower())

if c > a:
    b = d.upper()
else:
    b = d.lower()

print(b)"
714,A,Meeting of Old Friends,PROGRAMMING,"['implementation', 'math']","Today an outstanding event is going to happen in the forest — hedgehog Filya will come to his old fried Sonya!

Sonya is an owl and she sleeps during the day and stay awake from minute *l*1 to minute *r*1 inclusive. Also, during the minute *k* she prinks and is unavailable for Filya.

Filya works a lot and he plans to visit Sonya from minute *l*2 to minute *r*2 inclusive.

Calculate the number of minutes they will be able to spend together.","The only line of the input contains integers *l*1, *r*1, *l*2, *r*2 and *k* (1<=≤<=*l*1,<=*r*1,<=*l*2,<=*r*2,<=*k*<=≤<=1018, *l*1<=≤<=*r*1, *l*2<=≤<=*r*2), providing the segments of time for Sonya and Filya and the moment of time when Sonya prinks.",Print one integer — the number of minutes Sonya and Filya will be able to spend together.,"['1 10 9 20 1\n', '1 100 50 200 75\n']","['2\n', '50\n']","In the first sample, they will be together during minutes 9 and 10.

In the second sample, they will be together from minute 50 to minute 74 and from minute 76 to minute 100.",OK,"import operator as op
import re
import k
from bisect import bisect, bisect_left, insort, insort_left
from collections import Counter, defaultdict, deque
from copy import deepcopy
from decimal import Decimal
from functools import reduce
from itertools import (
    accumulate, combinations, combinations_with_replacement, groupby,
    permutations, product)
from math import (acos, asin, atan, ceil, cos, degrees, factorial, gcd, hypot,
                  log2, pi, radians, sin, sqrt, tan)
from operator import itemgetter, mul
from string import ascii_lowercase, ascii_uppercase, digits

def c():
    return(int(input()))

def b():
    return(list(map(int, input().split())))

def d():
    s = input()
    return(list(s[:len(s)]))

def e():
    return(map(int, input().split()))

def a():
    return 0

f, h, g, i, k = e()

if i < f or g > h:
    print(0)
    k.exit()

L = max(f, g)
R = min(h, i)

j = R - L + 1
if k >= L and k <= R:
    j -= 1
if j < 0:
    print(0)
else:
    print(j)","import g

def c():

    b = g.stdin.read().split()
    if not b:
        return

    q = int(b[0])
    e = []

    f = {
        1: -1,
        2: -1,
        3: -1,
        4: 1,
        5: -1,
        6: 1,
        7: -1,
        8: 2,
        9: 1,
        10: 2,
        11: -1
    }

    for i in range(1, q + 1):
        n = int(b[i])
        if n in f:
            e.append(str(f[n]))
        else:

            a = n // 4
            d = n % 4

            if d == 1 or d == 3:
                a -= 1
            e.append(str(a))

    g.stdout.write(""\n"".join(e) + ""\n"")

if __name__ == '__main__':
    c()"
229,D,Towers,PROGRAMMING,"['dp', 'greedy', 'two pointers']","The city of D consists of *n* towers, built consecutively on a straight line. The height of the tower that goes *i*-th (from left to right) in the sequence equals *h**i*. The city mayor decided to rebuild the city to make it beautiful. In a beautiful city all towers are are arranged in non-descending order of their height from left to right.

The rebuilding consists of performing several (perhaps zero) operations. An operation constitutes using a crane to take any tower and put it altogether on the top of some other neighboring tower. In other words, we can take the tower that stands *i*-th and put it on the top of either the (*i*<=-<=1)-th tower (if it exists), or the (*i*<=+<=1)-th tower (of it exists). The height of the resulting tower equals the sum of heights of the two towers that were put together. After that the two towers can't be split by any means, but more similar operations can be performed on the resulting tower. Note that after each operation the total number of towers on the straight line decreases by 1.

Help the mayor determine the minimum number of operations required to make the city beautiful.",The first line contains a single integer *n* (1<=≤<=*n*<=≤<=5000) — the number of towers in the city. The next line contains *n* space-separated integers: the *i*-th number *h**i* (1<=≤<=*h**i*<=≤<=105) determines the height of the tower that is *i*-th (from left to right) in the initial tower sequence.,Print a single integer — the minimum number of operations needed to make the city beautiful.,"['5\n8 2 7 3 1\n', '3\n5 2 1\n']","['3\n', '2\n']",none,WRONG_ANSWER,"def d(a):
    if len(a) <= 1:
        return 0

    i, j = 0, 1
    b = a[i]
    c = 0

    while j < len(a):
        e =  0
        while j < len(a) and e < b:
            e += a[j]
            j += 1

        if e >= b:
            c += j - 2 - i
            i = j - 1
            b = e
        else:
            c += j - i - 1

    return c

n = input()

a = list(map(int, input().split()))
print(d(a))","import f

def d():

    b = f.stdin.readline().strip()
    c = f.stdin.readline().strip()
    e = f.stdin.readline().strip()

    a = b + c

    if sorted(a) == sorted(e):
        print(""YES"")
    else:
        print(""NO"")

if __name__ == ""__main__"":
    d()"
227,B,Effective Approach,PROGRAMMING,['implementation'],"Once at a team training Vasya, Petya and Sasha got a problem on implementing linear search in an array.

According to the boys, linear search works as follows. The array elements in a pre-selected order are in turn compared with the number that you need to find. Once you find the array element that is equal to the required one, the search ends. The efficiency of the algorithm is the number of performed comparisons. The fewer comparisons the linear search has made, the more effective it is.

Vasya believes that a linear search would work better if it sequentially iterates through the elements, starting with the 1-st one (in this problem we consider the elements of the array indexed from 1 to *n*) and ending with the *n*-th one. And Petya says that Vasya is wrong: the search will need less comparisons if it sequentially iterates the elements starting from the *n*-th and ending with the 1-st one. Sasha argues that the two approaches are equivalent.

To finally begin the task, the teammates decided to settle the debate and compare the two approaches on an example. For this, they took an array that is a permutation of integers from 1 to *n*, and generated *m* queries of the form: find element with value *b**i* in the array. They want to calculate for both approaches how many comparisons in total the linear search will need to respond to all queries. If the first search needs fewer comparisons, then the winner of the dispute is Vasya. If the second one does, then the winner is Petya. If both approaches make the same number of comparisons, then Sasha's got the upper hand.

But the problem is, linear search is too slow. That's why the boys aren't going to find out who is right before the end of the training, unless you come in here. Help them to determine who will win the dispute.","The first line contains integer *n* (1<=≤<=*n*<=≤<=105) — the number of elements in the array. The second line contains *n* distinct space-separated integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=*n*) — the elements of array. 

The third line contains integer *m* (1<=≤<=*m*<=≤<=105) — the number of queries. The last line contains *m* space-separated integers *b*1,<=*b*2,<=...,<=*b**m* (1<=≤<=*b**i*<=≤<=*n*) — the search queries. Note that the queries can repeat.","Print two integers, showing how many comparisons Vasya's approach needs and how many comparisons Petya's approach needs. Separate the numbers by spaces.

Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use cin, cout streams or the %I64d specifier.","['2\n1 2\n1\n1\n', '2\n2 1\n1\n1\n', '3\n3 1 2\n3\n1 2 3\n']","['1 2\n', '2 1\n', '6 6\n']","In the first sample Vasya's approach will make one comparison (it starts with the 1-st element and immediately finds the required number), and Petya's approach makes two comparisons (first he compares with the 2-nd array element, doesn't find the search item and compares with the 1-st element).

In the second sample, on the contrary, Vasya's approach will need two comparisons (first with 1-st element, and then with the 2-nd), and Petya's approach will find the required value in one comparison (the first comparison with the 2-nd element).",TIME_LIMIT_EXCEEDED,"from sys import h

def b(n,a,m,f):
    i = 0
    d = 0
    for q in f:
        e = a.index(q) + 1
        i += e
        d += n - e + 1
    return [i,d]        
            
def c():
    n = int(h.readline())
    a = [int(x) for x in h.readline().split()]
    m = int(h.readline())
    f = [int(x) for x in h.readline().split()]
    g = b(n,a,m,f)
    print(""{} {}"".format(g[0],g[1]))

c()","import r
import j
from collections import f

def l():

    e = r.stdin.read().strip().split()
    if not e:
        return
    k = iter(e)
    n = int(next(k))
    m = int(next(k))
    k = int(next(k))

    h = [[] for _ in range(n + 1)]
    q = []

    for _ in range(m):
        u = int(next(k))
        v = int(next(k))
        x = int(next(k))
        h[u].append((v, x, 0))
        h[v].append((u, x, 0))
        q.append((u, v, x))

    s = []
    for _ in range(k):
        s = int(next(k))
        y = int(next(k))
        h[1].append((s, y, 1))
        h[s].append((1, y, 1))
        s.append((s, y))

    a = 10**18
    g = [a] * (n + 1)
    g[1] = 0
    i = [(0, 1)]
    
    while i:
        d, u = j.heappop(i)
        if d != g[u]:
            continue
        for v, w, _ in h[u]:
            m = d + w
            if m < g[v]:
                g[v] = m
                j.heappush(i, (m, v))

    p = [False] * (n + 1)
    for u, v, x in q:
        if g[u] + x == g[v]:
            p[v] = True
        if g[v] + x == g[u]:
            p[u] = True

    o = f(int)
    n = 0
    for s, y in s:
        if y > g[s]:
            n += 1
        elif y == g[s]:
            o[s] += 1

    c = n
    for b, d in o.items():
        if p[b]:

            c += d
        else:

            c += (d - 1)
    
    r.stdout.write(str(c) + ""\n"")

if __name__ == '__main__':
    l()"
424,A,Squats,PROGRAMMING,['implementation'],"Pasha has many hamsters and he makes them work out. Today, *n* hamsters (*n* is even) came to work out. The hamsters lined up and each hamster either sat down or stood up.

For another exercise, Pasha needs exactly  hamsters to stand up and the other hamsters to sit down. In one minute, Pasha can make some hamster ether sit down or stand up. How many minutes will he need to get what he wants if he acts optimally well?","The first line contains integer *n* (2<=≤<=*n*<=≤<=200; *n* is even). The next line contains *n* characters without spaces. These characters describe the hamsters' position: the *i*-th character equals 'X', if the *i*-th hamster in the row is standing, and 'x', if he is sitting.","In the first line, print a single integer — the minimum required number of minutes. In the second line, print a string that describes the hamsters' position after Pasha makes the required changes. If there are multiple optimal positions, print any of them.","['4\nxxXx\n', '2\nXX\n', '6\nxXXxXx\n']","['1\nXxXx\n', '1\nxX\n', '0\nxXXxXx\n']",none,OK,"""""""
Created on Sun Apr  5 05:45:34 2020

@author: alexi
""""""

def d():
    
    j = int(input())
    
    e = input()
    
    c = {'x':0,'X':0}
    
    for i in range(len(e)):
        c[e[i]] += 1
    
    if c['x'] == c['X']:
        print(0)
        print(e)
        return
    
    h = c['x']
    i = c['X']
    
    b = False
    if h < i:
        b = True
    
    f = max(h, i)
    a = f - (int((h+i)/2))
    print(a)
    if b:
        g = ''
        e = [i for i in e]
        for i in range(len(e)):
            if a > 0:
                if e[i] == 'X':
                    e[i] = 'x'
                    a -= 1
 
            g = g + e[i]

    else:
        g = ''
        e = [i for i in e]
        for i in range(len(e)):
            if a > 0:
                if e[i] == 'x':
                    e[i] = 'X'
                    a -= 1

            g = g + e[i]

    print(g)

d()","import i
import f

def e():

    a = i.stdin.read().split()
    if not a:
        return

    r, x, y, j, k = map(int, a)

    c = j - x
    d = k - y
    b = f.sqrt(c * c + d * d)

    if b == 0:
        print(0)
        return

    g = 2 * r

    h = f.ceil(b / g)
    
    print(h)

if __name__ == '__main__':
    e()"
200,B,Drinks,PROGRAMMING,"['implementation', 'math']","Little Vasya loves orange juice very much. That's why any food and drink in his kitchen necessarily contains orange juice. There are *n* drinks in his fridge, the volume fraction of orange juice in the *i*-th drink equals *p**i* percent.

One day Vasya decided to make himself an orange cocktail. He took equal proportions of each of the *n* drinks and mixed them. Then he wondered, how much orange juice the cocktail has.

Find the volume fraction of orange juice in the final drink.","The first input line contains a single integer *n* (1<=≤<=*n*<=≤<=100) — the number of orange-containing drinks in Vasya's fridge. The second line contains *n* integers *p**i* (0<=≤<=*p**i*<=≤<=100) — the volume fraction of orange juice in the *i*-th drink, in percent. The numbers are separated by a space.",Print the volume fraction in percent of orange juice in Vasya's cocktail. The answer will be considered correct if the absolute or relative error does not exceed 10<=<=-<=4.,"['3\n50 50 100\n', '4\n0 25 50 75\n']","['66.666666666667\n', '37.500000000000\n']","Note to the first sample: let's assume that Vasya takes *x* milliliters of each drink from the fridge. Then the volume of pure juice in the cocktail will equal <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/c1fac6e64d3a8ee6a5ac138cbe51e60039b22473.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> milliliters. The total cocktail's volume equals 3·*x* milliliters, so the volume fraction of the juice in the cocktail equals <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/ceb0664e55a1f9f5fa1243ec74680a4665a4d58d.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>, that is, 66.(6) percent.",OK,"n = int(input())
def sum(l,n):
    a = 0
    for i in range(n):
        a += l[i]
    return a

l = [int(x) for x in input().split()]
sum(l, n)
print(sum(l,n)/n)","def c():

    b = [int(input().strip()) for _ in range(4)]

    d = 0

    for a in b:
        d ^= a

    print(d)

if __name__ == '__main__':
    c()"
242,C,King's Path,PROGRAMMING,"['dfs and similar', 'graphs', 'hashing', 'shortest paths']","The black king is standing on a chess field consisting of 109 rows and 109 columns. We will consider the rows of the field numbered with integers from 1 to 109 from top to bottom. The columns are similarly numbered with integers from 1 to 109 from left to right. We will denote a cell of the field that is located in the *i*-th row and *j*-th column as (*i*,<=*j*).

You know that some squares of the given chess field are allowed. All allowed cells of the chess field are given as *n* segments. Each segment is described by three integers *r**i*,<=*a**i*,<=*b**i* (*a**i*<=≤<=*b**i*), denoting that cells in columns from number *a**i* to number *b**i* inclusive in the *r**i*-th row are allowed.

Your task is to find the minimum number of moves the king needs to get from square (*x*0,<=*y*0) to square (*x*1,<=*y*1), provided that he only moves along the allowed cells. In other words, the king can be located only on allowed cells on his way.

Let us remind you that a chess king can move to any of the neighboring cells in one move. Two cells of a chess field are considered neighboring if they share at least one point.","The first line contains four space-separated integers *x*0,<=*y*0,<=*x*1,<=*y*1 (1<=≤<=*x*0,<=*y*0,<=*x*1,<=*y*1<=≤<=109), denoting the initial and the final positions of the king.

The second line contains a single integer *n* (1<=≤<=*n*<=≤<=105), denoting the number of segments of allowed cells. Next *n* lines contain the descriptions of these segments. The *i*-th line contains three space-separated integers *r**i*,<=*a**i*,<=*b**i* (1<=≤<=*r**i*,<=*a**i*,<=*b**i*<=≤<=109,<=*a**i*<=≤<=*b**i*), denoting that cells in columns from number *a**i* to number *b**i* inclusive in the *r**i*-th row are allowed. Note that the segments of the allowed cells can intersect and embed arbitrarily.

It is guaranteed that the king's initial and final position are allowed cells. It is guaranteed that the king's initial and the final positions do not coincide. It is guaranteed that the total length of all given segments doesn't exceed 105.","If there is no path between the initial and final position along allowed cells, print -1.

Otherwise print a single integer — the minimum number of moves the king needs to get from the initial position to the final one.","['5 7 6 11\n3\n5 3 8\n6 7 11\n5 2 5\n', '3 4 3 10\n3\n3 1 4\n4 5 9\n3 10 10\n', '1 1 2 10\n2\n1 1 3\n2 6 10\n']","['4\n', '6\n', '-1\n']",none,OK,"import k
import math
from k import stdin, stdout

def e():
    return map(int, k.stdin.readline().strip().split())
def c(): return int(input())
def d(): return list(
    map(int, k.stdin.readline().strip().split()))
def f(n): return [list(
    map(int, k.stdin.readline().strip().split())) for _ in range(n)]
def g(): return k.stdin.readline().strip()
 
def h():

    l,n,m,o = e()
    n = int(input())
    g = {}
    for i in range(0, n):
        r,a,b = e()
        for i in range(a, b+1):
            g[(r, i)] = -1

    g[(l, n)] = 0

    a = [-1, -1, -1, 0, 0, 1, 1, 1]
    b = [0, -1, 1, -1, 1, 0, -1, 1]
    j = [(l, n)]
    while len(j):
        i = j.pop(0)
        for j in range(8):
            v = (i[0]+a[j], i[1]+b[j])

            if not v in g:
                continue
            if v in g and g[v] != -1:
                continue
            g[v] = g[i]+1
            j.append(v)
    print(g[(m, o)])

if __name__ == ""__main__"":
    h()","import g

def d():

    c = g.stdin.read().splitlines()
    if not c:
        return
    n = int(c[0].strip())
    s = list(c[1].strip())

    if n % 4 != 0:
        print(""==="")
        return
    
    h = n // 4

    b = {'A': 0, 'C': 0, 'G': 0, 'T': 0}
    for a in s:
        if a in b:
            b[a] += 1

    e = {}
    for f in ""ACGT"":
        if b[f] > h:
            print(""==="")
            return

        e[f] = h - b[f]

    i = sum(e.values())
    if s.count('?') != i:
        print(""==="")
        return

    for i in range(len(s)):
        if s[i] == '?':
            for f in ""ACGT"":
                if e[f] > 0:
                    s[i] = f
                    e[f] -= 1
                    break

    print("""".join(s))

if __name__ == ""__main__"":
    d()"
712,B,Memory and Trident,PROGRAMMING,"['implementation', 'strings']","Memory is performing a walk on the two-dimensional plane, starting at the origin. He is given a string *s* with his directions for motion:
-  An 'L' indicates he should move one unit left. -  An 'R' indicates he should move one unit right. -  A 'U' indicates he should move one unit up. -  A 'D' indicates he should move one unit down.
But now Memory wants to end at the origin. To do this, he has a special trident. This trident can replace any character in *s* with any of 'L', 'R', 'U', or 'D'. However, because he doesn't want to wear out the trident, he wants to make the minimum number of edits possible. Please tell Memory what is the minimum number of changes he needs to make to produce a string that, when walked, will end at the origin, or if there is no such string.",The first and only line contains the string *s* (1<=≤<=|*s*|<=≤<=100<=000) — the instructions Memory is given.,"If there is a string satisfying the conditions, output a single integer — the minimum number of edits required. In case it's not possible to change the sequence in such a way that it will bring Memory to to the origin, output -1.","['RRU\n', 'UDUR\n', 'RUUR\n']","['-1\n', '1\n', '2\n']","In the first sample test, Memory is told to walk right, then right, then up. It is easy to see that it is impossible to edit these instructions to form a valid walk.

In the second sample test, Memory is told to walk up, then down, then up, then right. One possible solution is to change *s* to ""LDUR"". This string uses 1 edit, which is the minimum possible. It also ends at the origin.",OK,"def b():
    s = input()
    if len(s) % 2 == 1:
        print('-1')
        return

    a = {'L':0,'R':0,'U':0,'D':0}
    for c in s:
        a[c] += 1
    
    c = abs(a['L'] - a['R'])
    d = abs(a['U'] - a['D'])
    print((c + d) // 2)

if __name__ == '__main__':
    b()","def h():
    import l
    l.setrecursionlimit(10**6)
    c = l.stdin.read().split()
    if not c:
        return
    n = int(c[0])

    a = [[] for _ in range(n + 1)]
    g = 1
    for i in range(n - 1):
        x = int(c[g])
        y = int(c[g + 1])
        t = int(c[g + 2])
        g += 3
        a[x].append((y, t))
        a[y].append((x, t))

    b = []

    def d(v, k, e):
        f = False
        for i, t in a[v]:
            if i == k:
                continue
            if d(i, v, t):
                f = True

        if k != -1 and e == 2 and not f:
            b.append(v)
            f = True
        return f

    d(1, -1, 0)
    b.sort()

    j = []
    j.append(str(len(b)))
    if b:
        j.append("" "".join(map(str, b)))
    l.stdout.write(""\n"".join(j))
    
if __name__ == ""__main__"":
    h()"
559,B,Equivalent Strings,PROGRAMMING,"['divide and conquer', 'hashing', 'sortings', 'strings']","Today on a lecture about strings Gerald learned a new definition of string equivalency. Two strings *a* and *b* of equal length are called equivalent in one of the two cases: 
 1.  They are equal. 1.  If we split string *a* into two halves of the same size *a*1 and *a*2, and string *b* into two halves of the same size *b*1 and *b*2, then one of the following is correct:   *a*1 is equivalent to *b*1, and *a*2 is equivalent to *b*2 1.  *a*1 is equivalent to *b*2, and *a*2 is equivalent to *b*1 
As a home task, the teacher gave two strings to his students and asked to determine if they are equivalent.

Gerald has already completed this home task. Now it's your turn!",The first two lines of the input contain two strings given by the teacher. Each of them has the length from 1 to 200<=000 and consists of lowercase English letters. The strings have the same length.,"Print ""YES"" (without the quotes), if these two strings are equivalent, and ""NO"" (without the quotes) otherwise.","['aaba\nabaa\n', 'aabb\nabab\n']","['YES\n', 'NO\n']","In the first sample you should split the first string into strings ""aa"" and ""ba"", the second one — into strings ""ab"" and ""aa"". ""aa"" is equivalent to ""aa""; ""ab"" is equivalent to ""ba"" as ""ab"" = ""a"" + ""b"", ""ba"" = ""b"" + ""a"".

In the second sample the first string can be splitted into strings ""aa"" and ""bb"", that are equivalent only to themselves. That's why string ""aabb"" is equivalent only to itself and to string ""bbaa"".",OK,"g = {}
def j(a, b):
    if (a,b) in g:
        return g[a,b]
    if len(a)%2 == 1:
        return a == b
    
    f = len(a)//2
    a, b = a[:f], a[f:]
    d, e = b[:f], b[f:]

    g[a,b] = (j(a, d) and j(b, e)) or  (j(a, e) and j(b, d))
    return g[a,b]

h = input()
i = input()    
c = j(h, i)
print(""YES"" if c else ""NO"")","import j
from collections import e

def g():

    d = j.stdin.read().split()
    if not d:
        return

    n = int(d[0])
    k = int(d[1])

    i = list(map(int, d[2:2+n]))

    h = max(i)

    if k >= n - 1:
        print(h)
        return

    f = e(i)

    c = f.popleft()
    b = 0

    while b < k:
        a = f.popleft()

        if c > a:
            b += 1
            f.append(a)
        else:
            f.append(c)
            c = a
            b = 1

        if c == h:
            break

    print(c)

if __name__ == '__main__':
    g()"
698,A,Vacations,PROGRAMMING,['dp'],"Vasya has *n* days of vacations! So he decided to improve his IT skills and do sport. Vasya knows the following information about each of this *n* days: whether that gym opened and whether a contest was carried out in the Internet on that day. For the *i*-th day there are four options:
 1.  on this day the gym is closed and the contest is not carried out; 1.  on this day the gym is closed and the contest is carried out; 1.  on this day the gym is open and the contest is not carried out; 1.  on this day the gym is open and the contest is carried out. 
On each of days Vasya can either have a rest or write the contest (if it is carried out on this day), or do sport (if the gym is open on this day).

Find the minimum number of days on which Vasya will have a rest (it means, he will not do sport and write the contest at the same time). The only limitation that Vasya has — he does not want to do the same activity on two consecutive days: it means, he will not do sport on two consecutive days, and write the contest on two consecutive days.","The first line contains a positive integer *n* (1<=≤<=*n*<=≤<=100) — the number of days of Vasya's vacations.

The second line contains the sequence of integers *a*1,<=*a*2,<=...,<=*a**n* (0<=≤<=*a**i*<=≤<=3) separated by space, where: 
 -  *a**i* equals 0, if on the *i*-th day of vacations the gym is closed and the contest is not carried out; -  *a**i* equals 1, if on the *i*-th day of vacations the gym is closed, but the contest is carried out; -  *a**i* equals 2, if on the *i*-th day of vacations the gym is open and the contest is not carried out; -  *a**i* equals 3, if on the *i*-th day of vacations the gym is open and the contest is carried out.","Print the minimum possible number of days on which Vasya will have a rest. Remember that Vasya refuses:
 -  to do sport on any two consecutive days, -  to write the contest on any two consecutive days.","['4\n1 3 2 0\n', '7\n1 3 3 2 1 2 3\n', '2\n2 2\n']","['2\n', '0\n', '1\n']","In the first test Vasya can write the contest on the day number 1 and do sport on the day number 3. Thus, he will have a rest for only 2 days.

In the second test Vasya should write contests on days number 1, 3, 5 and 7, in other days do sport. Thus, he will not have a rest for a single day.

In the third test Vasya can do sport either on a day number 1 or number 2. He can not do sport in two days, because it will be contrary to the his limitation. Thus, he will have a rest for only one day.",WRONG_ANSWER,"def e(b,c,f):
    d = 0
    while f<len(b):
        if b[f]==0:
            c[f] = 'R'
            d+=1
        elif b[f]==2:
            if c[f-1]!='G':
                c[f] = 'G'
            else:
                c[f] = 'R'
                d+=1
        elif b[f]==1:
            if c[f-1]!='C':
                c[f] = 'C'
            else:
                c[f] = 'R'
                d+=1
        else:
            if c[f-1]=='R':
                c[f] = 'G'
                j = e(b,c,f+1)
                c[f] = 'C'
                k = e(b,c,f+1)
                if j<=k:
                    return d + j
                else:
                    return d + k
            else:
                if c[f-1]=='G':
                    c[f] = 'C'
                else:
                    c[f] = 'G'
        f+=1
    return d

n = int(input())
g = [int(x) for x in input().split()]
h = [0]
for i in g:
    h.append(i)

i = ['' for i in range(0,n+1)]
a = e(h,i,1)
print(a)","def c():

    n = int(input().strip())

    e = list(map(int, input().split()))

    a = sum(1 for d in e if d % 2 == 0)

    if a > 1:

        for b, d in enumerate(e, start=1):
            if d % 2 != 0:
                print(b)
                break
    else:

        for b, d in enumerate(e, start=1):
            if d % 2 == 0:
                print(b)
                break

if __name__ == ""__main__"":
    c()"
600,E,Lomsat gelral,PROGRAMMING,"['data structures', 'dfs and similar', 'dsu', 'trees']","You are given a rooted tree with root in vertex 1. Each vertex is coloured in some colour.

Let's call colour *c* dominating in the subtree of vertex *v* if there are no other colours that appear in the subtree of vertex *v* more times than colour *c*. So it's possible that two or more colours will be dominating in the subtree of some vertex.

The subtree of vertex *v* is the vertex *v* and all other vertices that contains vertex *v* in each path to the root.

For each vertex *v* find the sum of all dominating colours in the subtree of vertex *v*.","The first line contains integer *n* (1<=≤<=*n*<=≤<=105) — the number of vertices in the tree.

The second line contains *n* integers *c**i* (1<=≤<=*c**i*<=≤<=*n*), *c**i* — the colour of the *i*-th vertex.

Each of the next *n*<=-<=1 lines contains two integers *x**j*,<=*y**j* (1<=≤<=*x**j*,<=*y**j*<=≤<=*n*) — the edge of the tree. The first vertex is the root of the tree.",Print *n* integers — the sums of dominating colours for each vertex.,"['4\n1 2 3 4\n1 2\n2 3\n2 4\n', '15\n1 2 3 1 2 3 3 1 1 3 2 2 1 2 3\n1 2\n1 3\n1 4\n1 14\n1 15\n2 5\n2 6\n2 7\n3 8\n3 9\n3 10\n4 11\n4 12\n4 13\n']","['10 9 3 4\n', '6 5 4 3 2 3 3 1 1 3 2 2 1 2 3\n']",none,WRONG_ANSWER,"from collections import e
k=int(input())
d=list(map(int,input().split()))
j=e(list)
def f(h,c:dict):
    c[d[h-1]]=c.get(d[h-1],0)+1
    sum=0
    g=0
    for a in j[h]:
        f(a,c)
    for b in c:
        if c[b]>c.get(g,0):
            sum=b
            g=b
        elif c[b]==c.get(g,0):
            sum+=b
    return sum
for x in range(k-1):
    h,a=list(map(int,input().split()))
    j[h].append(a)
i=[]
for i in range(k):
    c={}
    i.append(f(i+1,c))
print("" "".join(list(map(str,i))))","def a():

    n = int(input().strip())

    if n % 2 == 0:
        print(""Mahmoud"")
    else:
        print(""Ehab"")

if __name__ == ""__main__"":
    a()"
808,C,Tea Party,PROGRAMMING,"['constructive algorithms', 'greedy', 'sortings']","Polycarp invited all his friends to the tea party to celebrate the holiday. He has *n* cups, one for each of his *n* friends, with volumes *a*1,<=*a*2,<=...,<=*a**n*. His teapot stores *w* milliliters of tea (*w*<=≤<=*a*1<=+<=*a*2<=+<=...<=+<=*a**n*). Polycarp wants to pour tea in cups in such a way that:
 -  Every cup will contain tea for at least half of its volume -  Every cup will contain integer number of milliliters of tea -  All the tea from the teapot will be poured into cups -  All friends will be satisfied. 
Friend with cup *i* won't be satisfied, if there exists such cup *j* that cup *i* contains less tea than cup *j* but *a**i*<=&gt;<=*a**j*.

For each cup output how many milliliters of tea should be poured in it. If it's impossible to pour all the tea and satisfy all conditions then output -1.","The first line contains two integer numbers *n* and *w* (1<=≤<=*n*<=≤<=100, ).

The second line contains *n* numbers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=100).","Output how many milliliters of tea every cup should contain. If there are multiple answers, print any of them.

If it's impossible to pour all the tea and satisfy all conditions then output -1.","['2 10\n8 7\n', '4 4\n1 1 1 1\n', '3 10\n9 8 10\n']","['6 4 \n', '1 1 1 1 \n', '-1\n']","In the third example you should pour to the first cup at least 5 milliliters, to the second one at least 4, to the third one at least 5. It sums up to 14, which is greater than 10 milliliters available.",OK,"n, w = (int(i) for i in input().split())
a = [int(i) for i in input().split()]
 
def b():
    global w
    for i, d in enumerate(a):
        q = round(d / 2 + 0.1)
        c[d,i] = q
        w -= q
        if w < 0:
            return {1:-1}
 
    for d,i in sorted(c, reverse = True):
        o = d - c[d,i]
        c[d,i] += min(w,o)
        w -= min(o,w)
        if w == 0:
            break
    return c
 
 
 
 
 
 
c = {}
print(*b().values())","""""""
Mishka’s Christmas tree decoration problem.

There are three garlands with periods k1, k2, k3.
When a garland is switched on at second x, it lights at seconds:
    x, x + k, x + 2k, … 
Mishka wants to choose switch‐on times x1, x2, x3 such that
for every second t ≥ max(x1, x2, x3) at least one garland is lit.

It turns out that by shifting time (subtracting max(x1,x2,x3))
this is equivalent to choosing three residues a1 (mod k1),
a2 (mod k2), a3 (mod k3) so that for every nonnegative integer t,
at least one of these three congruences holds:
    t ≡ a1 (mod k1)  or  t ≡ a2 (mod k2)  or  t ≡ a3 (mod k3).
Since these progressions are periodic with period L = lcm(k1,k2,k3)
the covering property reduces to covering the complete set Z_L.
One may show (using the inclusion–exclusion formula)
that a necessary and sufficient condition is that

    (L/k1 + L/k2 + L/k3)
      – [sum of sizes of pair intersections]
      + [size of triple intersection]  =  L.

Dividing by L, and writing the sizes as fractions, one obtains
an equation of the form

    1/k1 + 1/k2 + 1/k3 – 1 = 
         Σ (over i<j) { contribution from pair (i,j) }.

Here the “potential” contribution from a given pair (i,j) is
    V_ij = (gcd(k_i, k_j)) / (k_i * k_j).

But note: if gcd(k_i,k_j) = 1 then the condition “r_i ≡ r_j (mod 1)” 
is forced (since any two integers are congruent modulo 1) and the contribution
is unavoidably 1/(k_i*k_j). For a pair with gcd > 1 one has the freedom 
to “force” the intersection (adding V_ij) or not (adding 0).

Thus the covering is possible if and only if there is a choice
of binary values b_ij ∈ {0,1} for the pairs with gcd(k_i,k_j) > 1
(since pairs with gcd=1 are forced to be “on”) such that

       1/k1 + 1/k2 + 1/k3 – 1  
           =  Σ_forced[1/(k_i*k_j)]  +  Σ_free[ b_ij * (gcd(k_i,k_j)/(k_i*k_j)) ].

In the code below we compute the left‐side (target)
and then for each of the three pairs of garlands we add either:
  • a forced contribution (if gcd == 1) or
  • a free candidate contribution (if gcd > 1).
We then try all possibilities for the free choices (there are at most 3).
If one possibility makes the equality hold (using exact rational arithmetic),
we print ""YES"" (otherwise ""NO"").

Note: if any k_i is 1 the answer is trivially YES.
""""""

import p, l
from fractions import a

def o():
    d = p.stdin.read().strip().split()
    if not d:
        return
    try:
        g, h, i = map(int, d[:3])
    except:
        return
    j = [g, h, i]

    if 1 in j:
        p.stdout.write(""YES"")
        return

    r = a(1, j[0]) + a(1, j[1]) + a(1, j[2])

    q = r - 1

    e = a(0)
    f = []
    m = [(0,1), (0,2), (1,2)]
    for i, j in m:
        g = l.gcd(j[i], j[j])
        c = a(g, j[i] * j[j])
        if g == 1:

            e += a(1, j[i] * j[j])
        else:

            f.append(c)

    n = False
    n = len(f)

    for k in range(1 << n):
        s = e
        for b in range(n):
            if k & (1 << b):
                s += f[b]
        if s == q:
            n = True
            break

    p.stdout.write(""YES"" if n else ""NO"")

if __name__ == '__main__':
    o()"
815,A,Karen and Game,PROGRAMMING,"['brute force', 'greedy', 'implementation']","On the way to school, Karen became fixated on the puzzle game on her phone!

The game is played as follows. In each level, you have a grid with *n* rows and *m* columns. Each cell originally contains the number 0.

One move consists of choosing one row or column, and adding 1 to all of the cells in that row or column.

To win the level, after all the moves, the number in the cell at the *i*-th row and *j*-th column should be equal to *g**i*,<=*j*.

Karen is stuck on one level, and wants to know a way to beat this level using the minimum number of moves. Please, help her with this task!","The first line of input contains two integers, *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=100), the number of rows and the number of columns in the grid, respectively.

The next *n* lines each contain *m* integers. In particular, the *j*-th integer in the *i*-th of these rows contains *g**i*,<=*j* (0<=≤<=*g**i*,<=*j*<=≤<=500).","If there is an error and it is actually not possible to beat the level, output a single integer -1.

Otherwise, on the first line, output a single integer *k*, the minimum number of moves necessary to beat the level.

The next *k* lines should each contain one of the following, describing the moves in the order they must be done:
 -  row *x*, (1<=≤<=*x*<=≤<=*n*) describing a move of the form ""choose the *x*-th row"". -  col *x*, (1<=≤<=*x*<=≤<=*m*) describing a move of the form ""choose the *x*-th column"". 
If there are multiple optimal solutions, output any one of them.","['3 5\n2 2 2 3 2\n0 0 0 1 0\n1 1 1 2 1\n', '3 3\n0 0 0\n0 1 0\n0 0 0\n', '3 3\n1 1 1\n1 1 1\n1 1 1\n']","['4\nrow 1\nrow 1\ncol 4\nrow 3\n', '-1\n', '3\nrow 1\nrow 2\nrow 3\n']","In the first test case, Karen has a grid with 3 rows and 5 columns. She can perform the following 4 moves to beat the level:

In the second test case, Karen has a grid with 3 rows and 3 columns. It is clear that it is impossible to beat the level; performing any move will create three 1s on the grid, but it is required to only have one 1 in the center.

In the third test case, Karen has a grid with 3 rows and 3 columns. She can perform the following 3 moves to beat the level:

Note that this is not the only solution; another solution, among others, is col 1, col 2, col 3.",RUNTIME_ERROR,"def a(a, b, c, d):
  """"""
  Returns the minimum number of claps Burenka needs to make her fractions equal.

  Args:
    a: The numerator of the first fraction.
    b: The denominator of the first fraction.
    c: The numerator of the second fraction.
    d: The denominator of the second fraction.

  Returns:
    The minimum number of claps.
  """"""

  if a / b == c / d:
    return 0

  b = c.b(b, d)

  a = a // b
  b = b // b
  c = c // b
  d = d // b

  d = abs(a - c) // b

  if b != d:
    d += 1

  return d

if __name__ == ""__main__"":
  t = int(input())
  for _ in range(t):
    a, b, c, d = map(int, input().split())
    print(a(a, b, c, d))","def b():

    n = int(input().strip())

    d = 0

    while n > 0:

        c = max(int(a) for a in str(n))

        n -= c

        d += 1

    print(d)

if __name__ == ""__main__"":
    b()"
111,B,Petya and Divisors,PROGRAMMING,"['binary search', 'data structures', 'number theory']","Little Petya loves looking for numbers' divisors. One day Petya came across the following problem:

You are given *n* queries in the form ""*x**i* *y**i*"". For each query Petya should count how many divisors of number *x**i* divide none of the numbers *x**i*<=-<=*y**i*,<=*x**i*<=-<=*y**i*<=+<=1,<=...,<=*x**i*<=-<=1. Help him.","The first line contains an integer *n* (1<=≤<=*n*<=≤<=105). Each of the following *n* lines contain two space-separated integers *x**i* and *y**i* (1<=≤<=*x**i*<=≤<=105, 0<=≤<=*y**i*<=≤<=*i*<=-<=1, where *i* is the query's ordinal number; the numeration starts with 1). 

If *y**i*<==<=0 for the query, then the answer to the query will be the number of divisors of the number *x**i*. In this case you do not need to take the previous numbers *x* into consideration.",For each query print the answer on a single line: the number of positive integers *k* such that ,['6\n4 0\n3 1\n5 2\n6 2\n18 4\n10000 3\n'],['3\n1\n1\n2\n2\n22\n'],"Let's write out the divisors that give answers for the first 5 queries:

1) 1, 2, 4 

2) 3

3) 5

4) 2, 6

5) 9, 18",OK,"def R(): return map(int, input().split())
def I(): return int(input())
def S(): return str(input())

def L(): return list(R())

from collections import Counter 

import math
import sys

from itertools import permutations

import bisect

b=[[] for i in range(10**5+1)]

for i in range(1,10**5+1):
    for j in range(1,10**5//i+1):
        b[i*j].append(i)

n=I()
c=[-1]*(10**5+1)

for j in range(n):
    x,y=R()
    a=0
    for i in b[x]:
        if c[i]<j-y:
            a+=1

        c[i]=j

    print(a)","def c():
    import e
    b = e.stdin.read().split()

    n = int(b[0])
    t = int(b[1])

    d = list(map(int, b[2:]))

    a = 1

    while a < t:

        a = a + d[a - 1]

    if a == t:
        e.stdout.write(""YES"")
    else:
        e.stdout.write(""NO"")

if __name__ == '__main__':
    c()"
191,A,Dynasty Puzzles,PROGRAMMING,['dp'],"The ancient Berlanders believed that the longer the name, the more important its bearer is. Thus, Berland kings were famous for their long names. But long names are somewhat inconvenient, so the Berlanders started to abbreviate the names of their kings. They called every king by the first letters of its name. Thus, the king, whose name was Victorious Vasily Pupkin, was always called by the berlanders VVP.

In Berland over its long history many dynasties of kings replaced each other, but they were all united by common traditions. Thus, according to one Berland traditions, to maintain stability in the country, the first name of the heir should be the same as the last name his predecessor (hence, the first letter of the abbreviated name of the heir coincides with the last letter of the abbreviated name of the predecessor). Berlanders appreciate stability, so this tradition has never been broken. Also Berlanders like perfection, so another tradition requires that the first name of the first king in the dynasty coincides with the last name of the last king in this dynasty (hence, the first letter of the abbreviated name of the first king coincides with the last letter of the abbreviated name of the last king). This tradition, of course, has also been always observed.

The name of a dynasty is formed by very simple rules: we take all the short names of the kings in the order in which they ruled, and write them in one line. Thus, a dynasty of kings ""ab"" and ""ba"" is called ""abba"", and the dynasty, which had only the king ""abca"", is called ""abca"".

Vasya, a historian, has recently found a list of abbreviated names of all Berland kings and their relatives. Help Vasya to find the maximally long name of the dynasty that could have existed in Berland.

Note that in his list all the names are ordered by the time, that is, if name *A* is earlier in the list than *B*, then if *A* and *B* were kings, then king *A* ruled before king *B*.","The first line contains integer *n* (1<=≤<=*n*<=≤<=5·105) — the number of names in Vasya's list. Next *n* lines contain *n* abbreviated names, one per line. An abbreviated name is a non-empty sequence of lowercase Latin letters. Its length does not exceed 10 characters.","Print a single number — length of the sought dynasty's name in letters.

If Vasya's list is wrong and no dynasty can be found there, print a single number 0.","['3\nabc\nca\ncba\n', '4\nvvp\nvvp\ndam\nvvp\n', '3\nab\nc\ndef\n']","['6\n', '0\n', '1\n']","In the first sample two dynasties can exist: the one called ""abcca"" (with the first and second kings) and the one called ""abccba"" (with the first and third kings). 

In the second sample there aren't acceptable dynasties.

The only dynasty in the third sample consists of one king, his name is ""c"".",TIME_LIMIT_EXCEEDED,"from collections import defaultdict, Counter
import sys

M = int(1e9 + 7)
l = float('inf')

def I():
    return input()

def a():
    return int(I())

def b():
    return list(I().split())

def c():
    return list(map(int, b()))

def o(e, m, k, q):
    while m <= k:
        n = (m + k) >> 1
        if e[n] < q:
            m = n + 1
        else:
            k = n - 1
    return m

def j(g):
    return ord(g) - ord('a')

def p():
    n = a()
    h = [[-l] * 26 for _ in range(26)]
    d = 0

    for _ in range(n):
        s = I()
        m = len(s)

        f, i = j(s[0]), j(s[-1])
        for i in range(26):
            h[i][i] = max(h[i][i], h[i][f] + m)
        h[f][i] = max(h[f][i], m)
        d = max(d, h[i][i])

    print(d)
p()","import g
import d

def c():

    a = g.stdin.read().strip().split()
    if not a:
        return
    n = int(a[0])
    k = int(a[1])

    if k == 1:
        print(n)
        return

    b = []
    h = n
    for i in range(2, int(d.sqrt(h)) + 1):
        while h % i == 0:
            b.append(i)
            h //= i
    if h > 1:
        b.append(h)

    if len(b) < k:
        print(-1)
        return

    f = []
    for i in range(k - 1):
        f.append(b[i])
    
    e = 1
    for i in range(k - 1, len(b)):
        e *= b[i]
    f.append(e)

    print("" "".join(map(str, f)))

if __name__ == ""__main__"":
    c()"
342,A,Xenia and Divisors,PROGRAMMING,"['greedy', 'implementation']","Xenia the mathematician has a sequence consisting of *n* (*n* is divisible by 3) positive integers, each of them is at most 7. She wants to split the sequence into groups of three so that for each group of three *a*,<=*b*,<=*c* the following conditions held:
 -  *a*<=&lt;<=*b*<=&lt;<=*c*; -  *a* divides *b*, *b* divides *c*. 
Naturally, Xenia wants each element of the sequence to belong to exactly one group of three. Thus, if the required partition exists, then it has  groups of three.

Help Xenia, find the required partition or else say that it doesn't exist.","The first line contains integer *n* (3<=≤<=*n*<=≤<=99999) — the number of elements in the sequence. The next line contains *n* positive integers, each of them is at most 7.

It is guaranteed that *n* is divisible by 3.","If the required partition exists, print  groups of three. Print each group as values of the elements it contains. You should print values in increasing order. Separate the groups and integers in groups by whitespaces. If there are multiple solutions, you can print any of them.

If there is no solution, print -1.","['6\n1 1 1 2 2 2\n', '6\n2 2 1 1 4 6\n']","['-1\n', '1 2 4\n1 2 6\n']",none,RUNTIME_ERROR,"import e

def input():    return e.stdin.readline().strip()
def c():   return int(input())
def d():   return map(int, e.stdin.readline().strip().split()) 
def b(): return list(map(int, e.stdin.readline().strip().split())) 

n=c()
l=list(map(int,input().split()))
a=sorted(l)
r=[]
k=[]
p=n//3
a=0
if(n%3!=0):
    print(-1)
else:
    f = [0]*n
    for i in range(0,n):
        for j in range(i+1,n):
            for k in range(j+1,n):
                if(a[i]<a[j] and a[j]<a[k] and a[j]%a[i]==0 and a[k]%a[j]==0 and f[i]==0 and f[j]==0 and f[k]==0):
                    s=[a[i],a[j],a[k]]
                    f[i]=1
                    f[j]=1
                    f[k]=1

                    r.append(s)

    if(len(r)==p):
        for i in range(r):
            print(*r[i])
    else:
        print(-1)","""""""
This script checks if a social network is ""reasonable"".
A network is reasonable if for every three distinct members (X, Y, Z),
if X-Y and Y-Z are friends then X-Z must also be friends.
This property implies that each connected component in the network must form
a complete clique.
""""""

import l

def f():

    l.setrecursionlimit(300000)

    b = l.stdin.read().strip().split()
    if not b:
        return

    n = int(b[0])
    m = int(b[1])

    h = list(range(n))
    k = [1] * n
    a = [0] * n
    
    def d(x):

        if h[x] != x:
            h[x] = d(h[x])
        return h[x]
    
    def m(a, b):

        a = d(a)
        b = d(b)
        if a == b:
            return a
        if k[a] < k[b]:
            a, b = b, a
        h[b] = a
        k[a] += k[b]
        a[a] += a[b]
        return a

    e = 2
    for _ in range(m):
        u = int(b[e]) - 1
        v = int(b[e + 1]) - 1
        e += 2
        i = d(u)
        j = d(v)
        if i != j:
            g = m(u, v)
            a[g] += 1
        else:
            a[i] += 1

    for i in range(n):
        if d(i) == i:
            s = k[i]
            c = s * (s - 1) // 2
            if a[i] != c:
                l.stdout.write(""NO"")
                return

    l.stdout.write(""YES"")

if __name__ == '__main__':
    f()"
348,A,Mafia,PROGRAMMING,"['binary search', 'math', 'sortings']","One day *n* friends gathered together to play ""Mafia"". During each round of the game some player must be the supervisor and other *n*<=-<=1 people take part in the game. For each person we know in how many rounds he wants to be a player, not the supervisor: the *i*-th person wants to play *a**i* rounds. What is the minimum number of rounds of the ""Mafia"" game they need to play to let each person play at least as many rounds as they want?","The first line contains integer *n* (3<=≤<=*n*<=≤<=105). The second line contains *n* space-separated integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=109) — the *i*-th number in the list is the number of rounds the *i*-th person wants to play.","In a single line print a single integer — the minimum number of game rounds the friends need to let the *i*-th person play at least *a**i* rounds.

Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.","['3\n3 2 2\n', '4\n2 2 2 2\n']","['4\n', '3\n']","You don't need to know the rules of ""Mafia"" to solve this problem. If you're curious, it's a game Russia got from the Soviet times: http://en.wikipedia.org/wiki/Mafia_(party_game).",WRONG_ANSWER,"import c

def b(n,b):
    sum = 0
    a = b.split(' ')
    l = [int(i) for i in a]
    d = max(l)
    for i in l:
        sum = sum + int(i)
    m = max(c.ceil(sum/n)+1, d)
    return m

n = int(input())
b = input()

print(b(n,b))","def d():
    import f

    b = f.stdin.read().split()
    if not b:
        return

    n = int(b[0])

    h = list(map(int, b[1:]))

    h.sort()
    g = 2 * n
    a = 10**9

    for i in range(g):
        for j in range(i + 1, g):
            e = []

            for k in range(g):
                if k == i or k == j:
                    continue
                e.append(h[k])

            c = 0
            for k in range(0, len(e), 2):
                c += e[k + 1] - e[k]

            a = min(a, c)

    f.stdout.write(str(a))

if __name__ == '__main__':
    d()"
152,A,Marks,PROGRAMMING,['implementation'],"Vasya, or Mr. Vasily Petrov is a dean of a department in a local university. After the winter exams he got his hands on a group's gradebook.

Overall the group has *n* students. They received marks for *m* subjects. Each student got a mark from 1 to 9 (inclusive) for each subject.

Let's consider a student the best at some subject, if there is no student who got a higher mark for this subject. Let's consider a student successful, if there exists a subject he is the best at.

Your task is to find the number of successful students in the group.","The first input line contains two integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=100) — the number of students and the number of subjects, correspondingly. Next *n* lines each containing *m* characters describe the gradebook. Each character in the gradebook is a number from 1 to 9. Note that the marks in a rows are not sepatated by spaces.",Print the single number — the number of successful students in the given group.,"['3 3\n223\n232\n112\n', '3 5\n91728\n11828\n11111\n']","['2\n', '3\n']","In the first sample test the student number 1 is the best at subjects 1 and 3, student 2 is the best at subjects 1 and 2, but student 3 isn't the best at any subject.

In the second sample test each student is the best at at least one subject.",OK,"import f,math
def b(): return map(int, f.stdin.readline().strip().split())
def c(): return list(map(int, f.stdin.readline().strip().split()))
def d(): return f.stdin.readline().strip()
n,m = b()
a = [0]*n
L = []
for i in range(n):
    s = d()
    L.append(s)
for j in range(m):
    e = 0
    for i in range(n):
        e = max(e,eval(L[i][j]))
    for i in range(n):
        if e==eval(L[i][j]):
            a[i]=1
print(sum(a))","import f

def d():

    c = f.stdin.read().split()

    n = int(c[0])

    b = list(map(int, c[1:n+1]))

    e = max(b)

    g = sum(e - a for a in b)

    print(g)

if __name__ == ""__main__"":
    d()"
599,A,Patrick and Shopping,PROGRAMMING,['implementation'],"Today Patrick waits for a visit from his friend Spongebob. To prepare for the visit, Patrick needs to buy some goodies in two stores located near his house. There is a *d*1 meter long road between his house and the first shop and a *d*2 meter long road between his house and the second shop. Also, there is a road of length *d*3 directly connecting these two shops to each other. Help Patrick calculate the minimum distance that he needs to walk in order to go to both shops and return to his house.

Patrick always starts at his house. He should visit both shops moving only along the three existing roads and return back to his house. He doesn't mind visiting the same shop or passing the same road multiple times. The only goal is to minimize the total distance traveled.","The first line of the input contains three integers *d*1, *d*2, *d*3 (1<=≤<=*d*1,<=*d*2,<=*d*3<=≤<=108) — the lengths of the paths. 
 -  *d*1 is the length of the path connecting Patrick's house and the first shop; -  *d*2 is the length of the path connecting Patrick's house and the second shop; -  *d*3 is the length of the path connecting both shops.",Print the minimum distance that Patrick will have to walk in order to visit both shops and return to his house.,"['10 20 30\n', '1 1 5\n']","['60\n', '4\n']","The first sample is shown on the picture in the problem statement. One of the optimal routes is: house <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> first shop <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> second shop <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> house.

In the second sample one of the optimal routes is: house <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> first shop <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> house <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> second shop <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> house.",OK,"def a(a,b,c):
    return min(a,b+c)+min(c,a+b)+min(b,a+c)
a,b,c=map(int,input().split())
print(a(a, b, c))","def c(b):
    e, f, g = 0, 0, 0

    for a in b:
        e += a[0]
        f += a[1]
        g += a[2]

    return e == 0 and f == 0 and g == 0

def d():

    n = int(input().strip())
    b = []

    for _ in range(n):
        x, y, z = map(int, input().split())
        b.append((x, y, z))

    if c(b):
        print(""YES"")
    else:
        print(""NO"")

if __name__ == ""__main__"":
    d()"
281,A,Word Capitalization,PROGRAMMING,"['implementation', 'strings']","Capitalization is writing a word with its first letter as a capital letter. Your task is to capitalize the given word.

Note, that during capitalization all the letters except the first one remains unchanged.",A single line contains a non-empty word. This word consists of lowercase and uppercase English letters. The length of the word will not exceed 103.,Output the given word after capitalization.,"['ApPLe\n', 'konjac\n']","['ApPLe\n', 'Konjac\n']",none,OK,"def a():
    s = input()
    print(s[0].capitalize()+s[1:])

t = 1
while t:
    a()
    t -= 1","import l

def h(n, m, f):

    c = [(-1, -1), (-1, 0), (-1, 1),
                  (0, -1),          (0, 1),
                  (1, -1),  (1, 0), (1, 1)]
    
    for i in range(n):
        for j in range(m):
            b = f[i][j]

            if b != '*':
                a = 0

                for d, e in c:
                    j, k = i + d, j + e
                    if 0 <= j < n and 0 <= k < m and f[j][k] == '*':
                        a += 1

                if b == '.':
                    if a != 0:
                        return False
                else:

                    if a != int(b):
                        return False
    return True

def i():
    g = l.stdin.read().splitlines()
    if not g:
        return

    n, m = map(int, g[0].split())
    f = g[1:]
    
    if h(n, m, f):
        print(""YES"")
    else:
        print(""NO"")

if __name__ == ""__main__"":
    i()"
448,C,Painting Fence,PROGRAMMING,"['divide and conquer', 'dp', 'greedy']","Bizon the Champion isn't just attentive, he also is very hardworking.

Bizon the Champion decided to paint his old fence his favorite color, orange. The fence is represented as *n* vertical planks, put in a row. Adjacent planks have no gap between them. The planks are numbered from the left to the right starting from one, the *i*-th plank has the width of 1 meter and the height of *a**i* meters.

Bizon the Champion bought a brush in the shop, the brush's width is 1 meter. He can make vertical and horizontal strokes with the brush. During a stroke the brush's full surface must touch the fence at all the time (see the samples for the better understanding). What minimum number of strokes should Bizon the Champion do to fully paint the fence? Note that you are allowed to paint the same area of the fence multiple times.","The first line contains integer *n* (1<=≤<=*n*<=≤<=5000) — the number of fence planks. The second line contains *n* space-separated integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=109).",Print a single integer — the minimum number of strokes needed to paint the whole fence.,"['5\n2 2 1 2 1\n', '2\n2 2\n', '1\n5\n']","['3\n', '2\n', '1\n']","In the first sample you need to paint the fence in three strokes with the brush: the first stroke goes on height 1 horizontally along all the planks. The second stroke goes on height 2 horizontally and paints the first and second planks and the third stroke (it can be horizontal and vertical) finishes painting the fourth plank.

In the second sample you can paint the fence with two strokes, either two horizontal or two vertical strokes.

In the third sample there is only one plank that can be painted using a single vertical stroke.",TIME_LIMIT_EXCEEDED,"def e(i, j, a):
    f = j - i + 1
    d = a[i]
    
    for k in range(i+1, j+1):
        if d > a[k]:
            d = a[k]
    
    for k in range(i, j+1):
        a[k] -= d

    b = d

    k = i
    while k <= j:
        if a[k] == 0:
            k += 1
        else:
            s = k
            t = s
            while t <= j and a[t] != 0:
                t += 1
            b += e(s, t - 1, a)
            k = t

    return f if f < b else b

def c():
    n = int(input())
    a = [0] + list(map(int, input().split()))
    
    a = e(1, n, a)

    print(a)

if __name__ == ""__main__"":
    c()","def e():
    import h
    from collections import a

    d = h.stdin.read().split()
    if not d:
        return
    n = int(d[0])
    g = list(map(int, d[1:]))

    c = a(g)

    for f in c:
        if f not in (1, 2, 3, 4, 6):
            print(-1)
            return

    i = n // 3

    if c[1] != i:
        print(-1)
        return

    x = c[4]
    z = c[3]
    y = c[2] - x

    if y < 0:
        print(-1)
        return

    if y + z != c[6]:
        print(-1)
        return

    if x + y + z != c[1]:
        print(-1)
        return

    b = []
    for _ in range(x):
        b.append(""1 2 4"")
    for _ in range(y):
        b.append(""1 2 6"")
    for _ in range(z):
        b.append(""1 3 6"")

    print(""\n"".join(b))

if __name__ == ""__main__"":
    e()"
420,A,Start Up,PROGRAMMING,['implementation'],"Recently, a start up by two students of a state university of city F gained incredible popularity. Now it's time to start a new company. But what do we call it?

The market analysts came up with a very smart plan: the name of the company should be identical to its reflection in a mirror! In other words, if we write out the name of the company on a piece of paper in a line (horizontally, from left to right) with large English letters, then put this piece of paper in front of the mirror, then the reflection of the name in the mirror should perfectly match the line written on the piece of paper.

There are many suggestions for the company name, so coming up to the mirror with a piece of paper for each name wouldn't be sensible. The founders of the company decided to automatize this process. They asked you to write a program that can, given a word, determine whether the word is a 'mirror' word or not.",The first line contains a non-empty name that needs to be checked. The name contains at most 105 large English letters. The name will be written with the next sans serif font:,"Print 'YES' (without the quotes), if the given name matches its mirror reflection. Otherwise, print 'NO' (without the quotes).","['AHA\n', 'Z\n', 'XO\n']","['YES\n', 'NO\n', 'NO\n']",none,OK,"import d

def a(e):
    b = 'AHIMOTUVWXY'
    for i in e:
        if i not in b:
            return False
    c = list(e)
    c.reverse()
    if e != ''.join(c):
        return False
    return True

if __name__ == '__main__':
    e = d.stdin.readline().split()[0]
    if a(e):
        print('YES')
    else:
        print('NO')","from math import e
import k

def d(a, b, c):

    g = e(a, b)
    if c % g != 0:
        return False

    a = a // g
    b = b // g
    c = c // g

    if c >= (a * b - a - b + 1):
        return True

    for x in range(b):
        i = c - a * x
        if i < 0:
            continue
        if i % b == 0:
            return True
    return False

if __name__ == ""__main__"":

    f = k.stdin.read().strip().splitlines()

    j = []
    for g in f:
        if not g.strip():
            continue
        h = g.split()
        if len(h) != 3:
            continue
        a, b, c = map(int, h)
        j.append(""Yes"" if d(a, b, c) else ""No"")

    k.stdout.write(""\n"".join(j))"
327,A,Flipping Game,PROGRAMMING,"['brute force', 'dp', 'implementation']","Iahub got bored, so he invented a game to be played on paper. 

He writes *n* integers *a*1,<=*a*2,<=...,<=*a**n*. Each of those integers can be either 0 or 1. He's allowed to do exactly one move: he chooses two indices *i* and *j* (1<=≤<=*i*<=≤<=*j*<=≤<=*n*) and flips all values *a**k* for which their positions are in range [*i*,<=*j*] (that is *i*<=≤<=*k*<=≤<=*j*). Flip the value of *x* means to apply operation *x*<==<=1 - *x*.

The goal of the game is that after exactly one move to obtain the maximum number of ones. Write a program to solve the little game of Iahub.","The first line of the input contains an integer *n* (1<=≤<=*n*<=≤<=100). In the second line of the input there are *n* integers: *a*1,<=*a*2,<=...,<=*a**n*. It is guaranteed that each of those *n* values is either 0 or 1.",Print an integer — the maximal number of 1s that can be obtained after exactly one move.,"['5\n1 0 0 1 0\n', '4\n1 0 0 1\n']","['4\n', '4\n']","In the first case, flip the segment from 2 to 5 (*i* = 2, *j* = 5). That flip changes the sequence, it becomes: [1 1 1 0 1]. So, it contains four ones. There is no way to make the whole sequence equal to [1 1 1 1 1].

In the second case, flipping only the second and the third element (*i* = 2, *j* = 3) will turn all numbers into 1.",OK,"n=eval(input())
a=[int(i) for i in input().split()]
a=0
def f(i,j):
    for k in range(i,j):
        a[k]=1-a[k]
for i in range(n):
    for j in range(i+1,n+1):
        f(i,j)
        b=sum(a)
        if b>a:
            a=b
        f(i,j)
print(a)","def c():
    import f
    b = f.stdin.read().splitlines()
    if not b:
        return

    n, a, b = map(int, b[0].split())
    s = b[1].strip()

    e = 0

    d = None

    for a in s:
        if a == '*':

            d = None
            continue

        if d == 'A':

            if b > 0:
                b -= 1
                e += 1
                d = 'B'
            else:

                d = None
        elif d == 'B':

            if a > 0:
                a -= 1
                e += 1
                d = 'A'
            else:

                d = None
        else:

            if a >= b:
                if a > 0:
                    a -= 1
                    e += 1
                    d = 'A'
                elif b > 0:
                    b -= 1
                    e += 1
                    d = 'B'
                else:
                    d = None
            else:
                if b > 0:
                    b -= 1
                    e += 1
                    d = 'B'
                elif a > 0:
                    a -= 1
                    e += 1
                    d = 'A'
                else:
                    d = None

    f.stdout.write(str(e))

if __name__ == '__main__':
    c()"
1006,D,Two Strings Swaps,PROGRAMMING,['implementation'],"You are given two strings $a$ and $b$ consisting of lowercase English letters, both of length $n$. The characters of both strings have indices from $1$ to $n$, inclusive. 

You are allowed to do the following changes: 
 -  Choose any index $i$ ($1 \le i \le n$) and swap characters $a_i$ and $b_i$; -  Choose any index $i$ ($1 \le i \le n$) and swap characters $a_i$ and $a_{n - i + 1}$; -  Choose any index $i$ ($1 \le i \le n$) and swap characters $b_i$ and $b_{n - i + 1}$. 
Note that if $n$ is odd, you are formally allowed to swap $a_{\lceil\frac{n}{2}\rceil}$ with $a_{\lceil\frac{n}{2}\rceil}$ (and the same with the string $b$) but this move is useless. Also you can swap two equal characters but this operation is useless as well.

You have to make these strings equal by applying any number of changes described above, in any order. But it is obvious that it may be impossible to make two strings equal by these swaps.

In one preprocess move you can replace a character in $a$ with another character. In other words, in a single preprocess move you can choose any index $i$ ($1 \le i \le n$), any character $c$ and set $a_i := c$.

Your task is to find the minimum number of preprocess moves to apply in such a way that after them you can make strings $a$ and $b$ equal by applying some number of changes described in the list above.

Note that the number of changes you make after the preprocess moves does not matter. Also note that you cannot apply preprocess moves to the string $b$ or make any preprocess moves after the first change is made.","The first line of the input contains one integer $n$ ($1 \le n \le 10^5$) — the length of strings $a$ and $b$.

The second line contains the string $a$ consisting of exactly $n$ lowercase English letters.

The third line contains the string $b$ consisting of exactly $n$ lowercase English letters.","Print a single integer — the minimum number of preprocess moves to apply before changes, so that it is possible to make the string $a$ equal to string $b$ with a sequence of changes from the list above.","['7\nabacaba\nbacabaa\n', '5\nzcabd\ndbacz\n']","['4\n', '0\n']","In the first example preprocess moves are as follows: $a_1 := $'b', $a_3 := $'c', $a_4 := $'a' and $a_5:=$'b'. Afterwards, $a = $""bbcabba"". Then we can obtain equal strings by the following sequence of changes: $swap(a_2, b_2)$ and $swap(a_2, a_6)$. There is no way to use fewer than $4$ preprocess moves before a sequence of changes to make string equal, so the answer in this example is $4$.

In the second example no preprocess moves are required. We can use the following sequence of changes to make $a$ and $b$ equal: $swap(b_1, b_5)$, $swap(a_2, a_4)$.",WRONG_ANSWER,"import f
input = lambda: f.stdin.readline().rstrip()
import math
from heapq import heappush , heappop
from collections import defaultdict,deque,a
from bisect import *

N = int(input())
S = input()
T = input()

def d(C):
    e = list(C.e())
    if len(e)>2:
        return False
    if len(e)==1:
        return True
    if C[e[0]]==C[e[1]]:
        return True
    return False

def c(A):
    t = int(A[0]!=A[2]) + int(A[1]!=A[3])
    t = min(t, int(A[0]!=A[3]) + int(A[1]!=A[2]))
    return t
    
b = 0
for i in range(N//2):
    j = N-i-1

    g = [S[i],S[j],T[i],T[j]]
    C = a(g)
    if d(C):
        continue
        
    b += c(g)
if N%2:

    if S[N//2]!=T[N//2]:
        b+=1
    
print(b)","""""""
We are given an array of integers a1, a2, ..., ak such that the number of turns 
n is the product of all these numbers. In the game, there are three cups and the key is 
initially under the middle cup. At every turn, the middle cup is swapped with one randomly 
chosen from the other two (each with probability 1/2) and the key remains in its cup.
The probability that after n turns the key is under the middle cup is derived to be

    P = 1/3 + (2/3)*(-1/2)^n
     = (2^n + 2*(-1)^n) / (3 * 2^n)

After canceling the common factor 2 (note that when n ≥ 1 the numerator is always even), 
the expression becomes:
   - For n even: P = (2^(n-1) + 1) / (3 * 2^(n-1))
   - For n odd:  P = (2^(n-1) - 1) / (3 * 2^(n-1))
   
Because n is huge (it is the product of large numbers) we will compute:
  • the parity of n by checking if all factors are odd (n is odd if and only if every a_i is odd)
  • 2^(n-1) modulo MOD (with MOD = 10^9+7) by reducing the exponent modulo MOD-1.
Finally, after obtaining the irreducible fraction p/q we output the remainders of p and q modulo 10^9+7.
""""""

def i():
    import m
    e = m.stdin.read().split()
    if not e:
        return
    k = int(e[0])
    d = list(map(int, e[1:]))

    a = 10**9 + 7
    b = a - 1

    k = 1
    c = True
    for a in d:
        k = (k * (a % b)) % b
        if a % 2 == 0:
            c = False

    j = not c

    g = (k - 1) % b
    n = pow(2, g, a)

    h = pow(3, a - 2, a)
    if j:
        l = (n + 1) % a
    else:
        l = (n - 1) % a

    l = (l * h) % a

    f = n % a

    m.stdout.write(f""{l}/{f}\n"")

if __name__ == '__main__':
    i()"
727,A,Transformation: from A to B,PROGRAMMING,"['brute force', 'dfs and similar', 'math']","Vasily has a number *a*, which he wants to turn into a number *b*. For this purpose, he can do two types of operations:
 -  multiply the current number by 2 (that is, replace the number *x* by 2·*x*); -  append the digit 1 to the right of current number (that is, replace the number *x* by 10·*x*<=+<=1). 
You need to help Vasily to transform the number *a* into the number *b* using only the operations described above, or find that it is impossible.

Note that in this task you are not required to minimize the number of operations. It suffices to find any way to transform *a* into *b*.",The first line contains two positive integers *a* and *b* (1<=≤<=*a*<=&lt;<=*b*<=≤<=109) — the number which Vasily has and the number he wants to have.,"If there is no way to get *b* from *a*, print ""NO"" (without quotes).

Otherwise print three lines. On the first line print ""YES"" (without quotes). The second line should contain single integer *k* — the length of the transformation sequence. On the third line print the sequence of transformations *x*1,<=*x*2,<=...,<=*x**k*, where:
 -  *x*1 should be equal to *a*, -  *x**k* should be equal to *b*, -  *x**i* should be obtained from *x**i*<=-<=1 using any of two described operations (1<=&lt;<=*i*<=≤<=*k*). 
If there are multiple answers, print any of them.","['2 162\n', '4 42\n', '100 40021\n']","['YES\n5\n2 4 8 81 162 \n', 'NO\n', 'YES\n5\n100 200 2001 4002 40021 \n']",none,WRONG_ANSWER,"[a, b] = map(int, input().split())

b = False

def a(c):
    print(""YES"")
    print(' '.join(map(str, c)))
    return True

def d(c):
    n = c[-1]
    if n == b:
        return a(c)
    elif n < b:
        return e(c) or f(c)
    return False

def e(c):
    n = 2*c[-1]
    if n <= b:
        return d(c + [n])
    return False

def f(c):
    n = 10*c[-1]+1
    if n <= b:
        return d(c + [n])
    return False

if not d([a]):
    print(""NO"")","import h

def e():

    b = h.stdin.read().split()
    if not b:
        return

    n = int(b[0])
    m = int(b[1])
    c = int(b[2])

    a = list(map(int, b[3:3+n]))
    b = list(map(int, b[3+n:3+n+m]))

    f = [0] * (m + 1)
    for i in range(m):
        f[i+1] = (f[i] + b[i]) % c

    t = n - m
    g = [0] * n
    for k in range(n):

        d = k - t if k - t > 0 else 0

        c = k if k < m else m - 1

        if d <= c:
            a = (f[c + 1] - f[d]) % c
        else:
            a = 0

        g[k] = (a[k] + a) % c

    h.stdout.write("" "".join(map(str, g)) + ""\n"")

if __name__ == '__main__':
    e()"
88,B,Keyboard,PROGRAMMING,['implementation'],"Vasya learns to type. He has an unusual keyboard at his disposal: it is rectangular and it has *n* rows of keys containing *m* keys in each row. Besides, the keys are of two types. Some of the keys have lowercase Latin letters on them and some of the keys work like the ""Shift"" key on standard keyboards, that is, they make lowercase letters uppercase.

Vasya can press one or two keys with one hand. However, he can only press two keys if the Euclidean distance between the centers of the keys does not exceed *x*. The keys are considered as squares with a side equal to 1. There are no empty spaces between neighbouring keys.

Vasya is a very lazy boy, that's why he tries to type with one hand as he eats chips with his other one. However, it is possible that some symbol can't be typed with one hand only, because the distance between it and the closest ""Shift"" key is strictly larger than *x*. In this case he will have to use his other hand. Having typed the symbol, Vasya returns other hand back to the chips.

You are given Vasya's keyboard and the text. Count the minimum number of times Vasya will have to use the other hand.","The first line contains three integers *n*, *m*, *x* (1<=≤<=*n*,<=*m*<=≤<=30,<=1<=≤<=*x*<=≤<=50).

Next *n* lines contain descriptions of all the keyboard keys. Each line contains the descriptions of exactly *m* keys, without spaces. The letter keys are marked with the corresponding lowercase letters. The ""Shift"" keys are marked with the ""S"" symbol. 

Then follow the length of the text *q* (1<=≤<=*q*<=≤<=5·105). The last line contains the text *T*, which consists of *q* symbols, which are uppercase and lowercase Latin letters.","If Vasya can type the text, then print the minimum number of times he will have to use his other hand. Otherwise, print ""-1"" (without the quotes).","['2 2 1\nab\ncd\n1\nA\n', '2 2 1\nab\ncd\n1\ne\n', '2 2 1\nab\ncS\n5\nabcBA\n', '3 9 4\nqwertyuio\nasdfghjkl\nSzxcvbnmS\n35\nTheQuIcKbRoWnFOXjummsovertHeLazYDOG\n']","['-1\n', '-1\n', '1\n', '2\n']","In the first sample the symbol ""A"" is impossible to print as there's no ""Shift"" key on the keyboard.

In the second sample the symbol ""e"" is impossible to print as there's no such key on the keyboard.

In the fourth sample the symbols ""T"", ""G"" are impossible to print with one hand. The other letters that are on the keyboard can be printed. Those symbols come up in the text twice, thus, the answer is 2.",OK,"import j
from array import array
from math import e
from collections import b

def input():
    return j.stdin.buffer.readline().decode('utf-8')

n, m, x = map(int, input().split())
g = [input().rstrip() for _ in range(n)]
h = set()
f, d = 10**9, 1e-9
c = b(lambda: f)
i = []

for i in range(n):
    for j in range(m):
        if g[i][j] == 'S':
            i.append((i, j))

for i in range(n):
    for j in range(m):
        if g[i][j] == 'S':
            continue
        h.add(g[i][j])
        for k, l in i:
            c[g[i][j].upper()] = min(c[g[i][j].upper()], e(i - k, j - l))

q = int(input())
a = 0
for c in input().rstrip():
    if c.lower() not in h:
        print(-1)
        exit()
    if 65 <= ord(c) <= 90:
        if not i:
            print(-1)
            exit()
        if c[c] - d > x:
            a += 1

print(a)","def f():
    import h

    d = h.stdin.read().split()
    if not d:
        return

    x = int(d[0])

    e = int(d[1])
    g = int(d[2])

    j = e * 60 + g
    y = 0

    while True:

        b = (j - y * x) % (24 * 60)

        a = b // 60
        c = b % 60

        i = f""{a:02d}{c:02d}""

        if '7' in i:
            print(y)
            break
        y += 1

if __name__ == ""__main__"":
    f()"
807,A,Is it rated?,PROGRAMMING,"['implementation', 'sortings']","Is it rated?

Here it is. The Ultimate Question of Competitive Programming, Codeforces, and Everything. And you are here to answer it.

Another Codeforces round has been conducted. No two participants have the same number of points. For each participant, from the top to the bottom of the standings, their rating before and after the round is known.

It's known that if at least one participant's rating has changed, then the round was rated for sure.

It's also known that if the round was rated and a participant with lower rating took a better place in the standings than a participant with higher rating, then at least one round participant's rating has changed.

In this problem, you should not make any other assumptions about the rating system.

Determine if the current round is rated, unrated, or it's impossible to determine whether it is rated of not.","The first line contains a single integer *n* (2<=≤<=*n*<=≤<=1000) — the number of round participants.

Each of the next *n* lines contains two integers *a**i* and *b**i* (1<=≤<=*a**i*,<=*b**i*<=≤<=4126) — the rating of the *i*-th participant before and after the round, respectively. The participants are listed in order from the top to the bottom of the standings.","If the round is rated for sure, print ""rated"". If the round is unrated for sure, print ""unrated"". If it's impossible to determine whether the round is rated or not, print ""maybe"".","['6\n3060 3060\n2194 2194\n2876 2903\n2624 2624\n3007 2991\n2884 2884\n', '4\n1500 1500\n1300 1300\n1200 1200\n1400 1400\n', '5\n3123 3123\n2777 2777\n2246 2246\n2246 2246\n1699 1699\n']","['rated\n', 'unrated\n', 'maybe\n']","In the first example, the ratings of the participants in the third and fifth places have changed, therefore, the round was rated.

In the second example, no one's rating has changed, but the participant in the second place has lower rating than the participant in the fourth place. Therefore, if the round was rated, someone's rating would've changed for sure.

In the third example, no one's rating has changed, and the participants took places in non-increasing order of their rating. Therefore, it's impossible to determine whether the round is rated or not.",WRONG_ANSWER,"if str is bytes:
    from itertools import izip as zip

def b(l):
    return all(a >= b for a, b in zip(l, l[1:]))

n = int(input())

a = []
i = -1
for _ in range(n):
    d = list(map(int, input().split()))
    if d[0] != d[1]:
        print(""rated"")
        i = 1
    else:
        a.append(d[0])
        
c = b(a)        
if i == -1 and c:
    print(""maybe"")
elif i == -1 and not c:
    print(""unrated"")","def a(s):
    """"""
    Returns the canonical form of string s.
    If s can be split into two equal parts, the canonical form is the lexicographically
    smaller concatenation of the canonical forms of its two halves.
    """"""
    n = len(s)

    if n % 2 == 1:
        return s

    d = a(s[:n // 2])
    e = a(s[n // 2:])

    if d < e:
        return d + e
    else:
        return e + d

def c():

    import f
    b = f.stdin.read().splitlines()

    a = b[0]
    b = b[1]

    if a(a) == a(b):
        print(""YES"")
    else:
        print(""NO"")

if __name__ == ""__main__"":
    c()"
204,A,Little Elephant and Interval,PROGRAMMING,"['binary search', 'combinatorics', 'dp']","The Little Elephant very much loves sums on intervals.

This time he has a pair of integers *l* and *r* (*l*<=≤<=*r*). The Little Elephant has to find the number of such integers *x* (*l*<=≤<=*x*<=≤<=*r*), that the first digit of integer *x* equals the last one (in decimal notation). For example, such numbers as 101, 477474 or 9 will be included in the answer and 47, 253 or 1020 will not.

Help him and count the number of described numbers *x* for a given pair *l* and *r*.","The single line contains a pair of integers *l* and *r* (1<=≤<=*l*<=≤<=*r*<=≤<=1018) — the boundaries of the interval.

Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use cin, cout streams or the %I64d specifier.",On a single line print a single integer — the answer to the problem.,"['2 47\n', '47 1024\n']","['12\n', '98\n']","In the first sample the answer includes integers 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44.",OK,"def f(x):
    if x < 10:
        return x
    if str(x)[0] > str(x)[-1]:
        return x // 10 + 8
    else:
        return x // 10 + 9
l, r = map(int, input().split())
print(f(r) - f(l - 1))","def h(n):
    """"""
    Returns a list of prime factors of n with their multiplicities.
    """"""
    b = []

    while n % 2 == 0:
        b.append(2)
        n //= 2

    a = 3
    while a * a <= n:
        while n % a == 0:
            b.append(a)
            n //= a
        a += 2
    if n > 1:
        b.append(n)
    return b

def f():
    import j

    c = j.stdin.readline().strip()
    if not c:
        return
    g, d = c.split()
    n = int(g)
    k = int(d)

    b = h(n)

    if len(b) < k:
        print(-1)
        return

    i = []
    for i in range(k - 1):
        i.append(b[i])
    
    e = 1
    for a in b[k - 1:]:
        e *= a
    i.append(e)

    print("" "".join(map(str, i)))

if __name__ == ""__main__"":
    f()"
770,A,New Password,PROGRAMMING,"['*special', 'implementation']","Innokentiy decides to change the password in the social net ""Contact!"", but he is too lazy to invent a new password by himself. That is why he needs your help. 

Innokentiy decides that new password should satisfy the following conditions:
 -  the length of the password must be equal to *n*, -  the password should consist only of lowercase Latin letters, -  the number of distinct symbols in the password must be equal to *k*, -  any two consecutive symbols in the password must be distinct. 
Your task is to help Innokentiy and to invent a new password which will satisfy all given conditions.","The first line contains two positive integers *n* and *k* (2<=≤<=*n*<=≤<=100, 2<=≤<=*k*<=≤<=*min*(*n*,<=26)) — the length of the password and the number of distinct symbols in it. 

Pay attention that a desired new password always exists.",Print any password which satisfies all conditions given by Innokentiy.,"['4 3\n', '6 6\n', '5 2\n']","['java\n', 'python\n', 'phphp\n']","In the first test there is one of the appropriate new passwords — java, because its length is equal to 4 and 3 distinct lowercase letters a, j and v are used in it.

In the second test there is one of the appropriate new passwords — python, because its length is equal to 6 and it consists of 6 distinct lowercase letters.

In the third test there is one of the appropriate new passwords — phphp, because its length is equal to 5 and 2 distinct lowercase letters p and h are used in it.

Pay attention the condition that no two identical symbols are consecutive is correct for all appropriate passwords in tests.",OK,"n, k = map(int,input().split())

print(('abcdefghijklmnopqrstuvwxyz' [:k]*n )[:n])","def i():
    import j

    def b(a, b):
        return (a + b - 1) // b

    c = j.stdin.read().split()
    if not c:
        return
    t = int(c[0])
    d = 1
    h = []
    
    for _ in range(t):

        x = int(c[d])
        y = int(c[d + 1])
        p = int(c[d + 2])
        q = int(c[d + 3])
        d += 4

        if p == 0:

            if x == 0:
                h.append(""0"")
            else:
                h.append(""-1"")
            continue

        if p == q:

            if x == y:
                h.append(""0"")
            else:
                h.append(""-1"")
            continue

        e = b(x, p)
        f = b(y, q)
        g = b(y - x, q - p)
        
        k = max(e, f, g)

        a = q * k - y
        h.append(str(a))
    
    j.stdout.write(""\n"".join(h))
    
if __name__ == '__main__':
    i()"
976,A,Minimum Binary Number,PROGRAMMING,['implementation'],"String can be called correct if it consists of characters ""0"" and ""1"" and there are no redundant leading zeroes. Here are some examples: ""0"", ""10"", ""1001"".

You are given a correct string *s*.

You can perform two different operations on this string: 
 1.  swap any pair of adjacent characters (for example, ""101""  ""110""); 1.  replace ""11"" with ""1"" (for example, ""110""  ""10""). 
Let *val*(*s*) be such a number that *s* is its binary representation.

Correct string *a* is less than some other correct string *b* iff *val*(*a*)<=&lt;<=*val*(*b*).

Your task is to find the minimum correct string that you can obtain from the given one using the operations described above. You can use these operations any number of times in any order (or even use no operations at all).","The first line contains integer number *n* (1<=≤<=*n*<=≤<=100) — the length of string *s*.

The second line contains the string *s* consisting of characters ""0"" and ""1"". It is guaranteed that the string *s* is correct.",Print one string — the minimum correct string that you can obtain from the given one.,"['4\n1001\n', '1\n1\n']","['100\n', '1\n']","In the first example you can obtain the answer by the following sequence of operations: ""1001"" <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> ""1010"" <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> ""1100"" <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> ""100"".

In the second example you can't obtain smaller answer no matter what operations you use.",WRONG_ANSWER,"def c(s):
    d = 0
    e = 0
    for b in s:
        if b == ""1"":
            d += 1
        else:
            e += 1
    if d == 0:
        return 0
    return ""1""+""0""*e

print(c(""1001""))

while True:
    try:
        input()
        a = input()
        print(c(a))
    except EOFError:
        break","n, k, l, c, d, p, a, b = map(int, input().split())

g = k * l

c = g // a

h = c * d

d = h

f = p // b

e = min(c, d, f) // n

print(e)"
143,A,Help Vasilisa the Wise 2,PROGRAMMING,"['brute force', 'math']","Vasilisa the Wise from the Kingdom of Far Far Away got a magic box with a secret as a present from her friend Hellawisa the Wise from the Kingdom of A Little Closer. However, Vasilisa the Wise does not know what the box's secret is, since she cannot open it again. She hopes that you will help her one more time with that.

The box's lock looks as follows: it contains 4 identical deepenings for gems as a 2<=×<=2 square, and some integer numbers are written at the lock's edge near the deepenings. The example of a lock is given on the picture below.

The box is accompanied with 9 gems. Their shapes match the deepenings' shapes and each gem contains one number from 1 to 9 (each number is written on exactly one gem). The box will only open after it is decorated with gems correctly: that is, each deepening in the lock should be filled with exactly one gem. Also, the sums of numbers in the square's rows, columns and two diagonals of the square should match the numbers written at the lock's edge. For example, the above lock will open if we fill the deepenings with gems with numbers as is shown on the picture below.

Now Vasilisa the Wise wants to define, given the numbers on the box's lock, which gems she should put in the deepenings to open the box. Help Vasilisa to solve this challenging task.","The input contains numbers written on the edges of the lock of the box. The first line contains space-separated integers *r*1 and *r*2 that define the required sums of numbers in the rows of the square. The second line contains space-separated integers *c*1 and *c*2 that define the required sums of numbers in the columns of the square. The third line contains space-separated integers *d*1 and *d*2 that define the required sums of numbers on the main and on the side diagonals of the square (1<=≤<=*r*1,<=*r*2,<=*c*1,<=*c*2,<=*d*1,<=*d*2<=≤<=20). Correspondence between the above 6 variables and places where they are written is shown on the picture below. For more clarifications please look at the second sample test that demonstrates the example given in the problem statement.","Print the scheme of decorating the box with stones: two lines containing two space-separated integers from 1 to 9. The numbers should be pairwise different. If there is no solution for the given lock, then print the single number ""-1"" (without the quotes).

If there are several solutions, output any.","['3 7\n4 6\n5 5\n', '11 10\n13 8\n5 16\n', '1 2\n3 4\n5 6\n', '10 10\n10 10\n10 10\n']","['1 2\n3 4\n', '4 7\n9 1\n', '-1\n', '-1\n']","Pay attention to the last test from the statement: it is impossible to open the box because for that Vasilisa the Wise would need 4 identical gems containing number ""5"". However, Vasilisa only has one gem with each number from 1 to 9.",WRONG_ANSWER,"def e(r,c,d):
    a=b=c=d=0
    for i in range(1,10):
        a=i
        b=r[0]-i
        c=c[0]-i
        d=d[0]-i

        if (b in range(1,10)) and (c in range(1,10)) and (d in range(1,10)) and a!=b!=c!=d:
            if c+d==r[1] and b+d==c[1] and b+c==d[1]:
                print(""{} {}"".format(a,b))  
                print(""{} {}"".format(c,d))
                return

    print(-1)

r=list(map(int,input('').split()))
c=list(map(int,input('').split()))
d=list(map(int,input('').split()))
e(r,c,d)","def i():
    import n
    c = n.stdin.read().split()
    if not c:
        return

    h = iter(c)
    n = int(next(h))
    a = int(next(h))
    b = int(next(h))
    h = [int(next(h)) for _ in range(n)]
    o = sum(h)

    a = 10**18
    e = [a] * (a + 1)
    d = [a] * (a + 1)

    if h[0] <= a:
        e[h[0]] = 0
    d[0] = 0

    for i in range(n - 1):
        k = [a] * (a + 1)
        j = [a] * (a + 1)
        f = h[i]
        g = h[i + 1]

        m = min(f, g)

        for r in range(a + 1):

            if e[r] != a:

                l = r + g
                if l <= a:
                    k[l] = min(k[l], e[r])

                j[r] = min(j[r], e[r] + m)

            if d[r] != a:

                j[r] = min(j[r], d[r])

                l = r + g
                if l <= a:
                    k[l] = min(k[l], d[r] + m)
        e, d = k, j

    b = a
    for r in range(a + 1):
        if o - r <= b:
            b = min(b, e[r], d[r])
    if b == a:
        n.stdout.write(""-1"")
    else:
        n.stdout.write(str(b))
        
if __name__ == '__main__':
    i()"
551,A,GukiZ and Contest,PROGRAMMING,"['brute force', 'implementation', 'sortings']","Professor GukiZ likes programming contests. He especially likes to rate his students on the contests he prepares. Now, he has decided to prepare a new contest. 

In total, *n* students will attend, and before the start, every one of them has some positive integer rating. Students are indexed from 1 to *n*. Let's denote the rating of *i*-th student as *a**i*. After the contest ends, every student will end up with some positive integer position. GukiZ expects that his students will take places according to their ratings. 

He thinks that each student will take place equal to . In particular, if student *A* has rating strictly lower then student *B*, *A* will get the strictly better position than *B*, and if two students have equal ratings, they will share the same position. 

GukiZ would like you to reconstruct the results by following his expectations. Help him and determine the position after the end of the contest for each of his students if everything goes as expected.","The first line contains integer *n* (1<=≤<=*n*<=≤<=2000), number of GukiZ's students. 

The second line contains *n* numbers *a*1,<=*a*2,<=... *a**n* (1<=≤<=*a**i*<=≤<=2000) where *a**i* is the rating of *i*-th student (1<=≤<=*i*<=≤<=*n*).","In a single line, print the position after the end of the contest for each of *n* students in the same order as they appear in the input.","['3\n1 3 3\n', '1\n1\n', '5\n3 5 3 4 5\n']","['3 1 1\n', '1\n', '4 1 4 3 1\n']","In the first sample, students 2 and 3 are positioned first (there is no other student with higher rating), and student 1 is positioned third since there are two students with higher rating.

In the second sample, first student is the only one on the contest.

In the third sample, students 2 and 5 share the first position with highest rating, student 4 is next with third position, and students 1 and 3 are the last sharing fourth position.",OK,"from collections import b
from typing import Counter

n = int(input())
a = [int(x) for x in input().split()]

d = b(list)

for i in range(n):
    d[a[i]].append(i)

l = sorted(d.items(), key=lambda x: -x[0])

p = 1

a = [0 for _ in range(n)]

for t in l:
    for c in t[1]:
        a[c] = p
    p += len(t[1])

print(' '.join(map(str, a)))","s = input().strip()
t = input().strip()

if t == s[::-1]:
    print(""YES"")
else:
    print(""NO"")"
673,A,Bear and Game,PROGRAMMING,['implementation'],"Bear Limak likes watching sports on TV. He is going to watch a game today. The game lasts 90 minutes and there are no breaks.

Each minute can be either interesting or boring. If 15 consecutive minutes are boring then Limak immediately turns TV off.

You know that there will be *n* interesting minutes *t*1,<=*t*2,<=...,<=*t**n*. Your task is to calculate for how many minutes Limak will watch the game.","The first line of the input contains one integer *n* (1<=≤<=*n*<=≤<=90) — the number of interesting minutes.

The second line contains *n* integers *t*1,<=*t*2,<=...,<=*t**n* (1<=≤<=*t*1<=&lt;<=*t*2<=&lt;<=... *t**n*<=≤<=90), given in the increasing order.",Print the number of minutes Limak will watch the game.,"['3\n7 20 88\n', '9\n16 20 30 40 50 60 70 80 90\n', '9\n15 20 30 40 50 60 70 80 90\n']","['35\n', '15\n', '90\n']","In the first sample, minutes 21, 22, ..., 35 are all boring and thus Limak will turn TV off immediately after the 35-th minute. So, he would watch the game for 35 minutes.

In the second sample, the first 15 minutes are boring.

In the third sample, there are no consecutive 15 boring minutes. So, Limak will watch the whole game.",WRONG_ANSWER,"def b(a):
    d = 0
    for c in a:
        if c - d > 15:
            return min(d + 15, 90)
        else:
            d = c
    return min(d, 90)

n = int(input())
a = list(map(int, input().split()))
print(b(a))","""""""
Bajtek is learning to skate on ice. His only mode of transportation is to push-off from a snow drift in one of the four
cardinal directions (north, east, south, or west) and slide until he reaches another snow drift. However, some snow drifts
are not connected via such moves. The goal is to determine the minimal number of additional snow drifts (placed at integer 
coordinates) that needs to be created to connect all the given snow drifts.
 
A key observation:
For any set of drifts lying on the same vertical line (same x-coordinate), connecting consecutive drifts (sorted by y)
will make them reachable via a north/south move. Similarly, for drifts on the same horizontal line (same y-coordinate),
connecting consecutive drifts (sorted by x) will make them reachable via an east/west move.
Thus, we can build a graph where an edge exists between these consecutive drifts.
The minimal additional drifts required is the number of connected components minus one.
""""""

import l
from collections import c

def i():
    g = l.stdin.read().strip().split()
    if not g:
        return

    n = int(g[0])
    j = []
    f = 1
    for i in range(n):

        x = int(g[f])
        y = int(g[f+1])
        j.append((x, y))
        f += 2

    n = c(list)

    o = c(list)
    
    for i, (x, y) in enumerate(j):
        n[x].append((y, i))
        o[y].append((x, i))

    e = [[] for _ in range(n)]

    for x, h in n.items():
        h.sort()
        for i in range(1, len(h)):

            k = h[i-1][1]
            b = h[i][1]
            e[k].append(b)
            e[b].append(k)

    for y, h in o.items():
        h.sort()
        for i in range(1, len(h)):

            k = h[i-1][1]
            b = h[i][1]
            e[k].append(b)
            e[b].append(k)

    m = [False] * n
    def d(u):
        m[u] = True
        for v in e[u]:
            if not m[v]:
                d(v)
    
    a = 0
    for i in range(n):
        if not m[i]:
            d(i)
            a += 1

    print(a - 1)

if __name__ == '__main__':
    i()"
576,A,Vasya and Petya's Game,PROGRAMMING,"['math', 'number theory']","Vasya and Petya are playing a simple game. Vasya thought of number *x* between 1 and *n*, and Petya tries to guess the number.

Petya can ask questions like: ""Is the unknown number divisible by number *y*?"".

The game is played by the following rules: first Petya asks all the questions that interest him (also, he can ask no questions), and then Vasya responds to each question with a 'yes' or a 'no'. After receiving all the answers Petya should determine the number that Vasya thought of.

Unfortunately, Petya is not familiar with the number theory. Help him find the minimum number of questions he should ask to make a guaranteed guess of Vasya's number, and the numbers *y**i*, he should ask the questions about.",A single line contains number *n* (1<=≤<=*n*<=≤<=103).,"Print the length of the sequence of questions *k* (0<=≤<=*k*<=≤<=*n*), followed by *k* numbers — the questions *y**i* (1<=≤<=*y**i*<=≤<=*n*).

If there are several correct sequences of questions of the minimum length, you are allowed to print any of them.","['4\n', '6\n']","['3\n2 4 3 \n', '4\n2 4 3 5 \n']","The sequence from the answer to the first sample test is actually correct.

If the unknown number is not divisible by one of the sequence numbers, it is equal to 1.

If the unknown number is divisible by 4, it is 4.

If the unknown number is divisible by 3, then the unknown number is 3.

Otherwise, it is equal to 2. Therefore, the sequence of questions allows you to guess the unknown number. It can be shown that there is no correct sequence of questions of length 2 or shorter.",WRONG_ANSWER,"n=int(input())
a = [i for i in range(2, n+1)]
def b(f):
  a = 2
  e = []
  while a<=(f//2)+1:
    if f%a==0:
      e.append(a)
    a+=1
  return e 

g = []
for f in a:
  e = b(f)
  if len(e)==1:
    g.append(f)
  else:
    g.append(f)
    for c in e:
      for d in e:
        if c!=d:
          if c%d!=0:
            if f in g:
              g.remove(f)
print(len(g))
for r in g:
  print(r,end=' ')","def e():
    import g
    c = g.stdin.read().splitlines()

    n = int(c[0])

    a = list(map(int, c[1].split()))

    m = int(c[2])

    for i in range(3, 3 + m):
        x, y = map(int, c[i].split())

        h = x - 1

        d = y - 1
        f = a[h] - y

        if h - 1 >= 0:
            a[h - 1] += d

        if h + 1 < n:
            a[h + 1] += f

        a[h] = 0

    for b in a:
        print(b)

if __name__ == ""__main__"":
    e()"
352,B,Jeff and Periods,PROGRAMMING,"['implementation', 'sortings']","One day Jeff got hold of an integer sequence *a*1, *a*2, ..., *a**n* of length *n*. The boy immediately decided to analyze the sequence. For that, he needs to find all values of *x*, for which these conditions hold:
 -  *x* occurs in sequence *a*. -  Consider all positions of numbers *x* in the sequence *a* (such *i*, that *a**i*<==<=*x*). These numbers, sorted in the increasing order, must form an arithmetic progression. 
Help Jeff, find all *x* that meet the problem conditions.","The first line contains integer *n* (1<=≤<=*n*<=≤<=105). The next line contains integers *a*1, *a*2, ..., *a**n* (1<=≤<=*a**i*<=≤<=105). The numbers are separated by spaces.","In the first line print integer *t* — the number of valid *x*. On each of the next *t* lines print two integers *x* and *p**x*, where *x* is current suitable value, *p**x* is the common difference between numbers in the progression (if *x* occurs exactly once in the sequence, *p**x* must equal 0). Print the pairs in the order of increasing *x*.","['1\n2\n', '8\n1 2 1 3 1 2 1 5\n']","['1\n2 0\n', '4\n1 2\n2 4\n3 0\n5 0\n']","In the first test 2 occurs exactly once in the sequence, ergo *p*<sub class=""lower-index"">2</sub> = 0.",WRONG_ANSWER,"def d():
    n = int(input())
    a = list(map(int, input().split()))

    b = dict()

    for i in range(n):
        if a[i] in b:
            b[a[i]].append(i)
        else:
            b[a[i]] = [i]

    b = sorted(b.items(), key=lambda x: x[0])

    for k, v in b:
        if len(v) == 1:
            print(k, 0)
        else:
            c = set()
            for i in range(len(v) - 1):
                c.add(v[i] - v[i + 1])

            if len(c) == 1:
                print(k, v[1] - v[0])

d()","def b():
    import c, math

    a = c.stdin.read().strip().split()
    if not a:
        return
    l, r = map(int, a[:2])

    if r - l + 1 < 3:
        print(-1)
        return

    if l % 2 == 0:
        a = l
    else:
        a = l + 1

    if a + 2 <= r:
        print(a, a + 1, a + 2)
    else:
        print(-1)

if __name__ == ""__main__"":
    b()"
38,A,Army,PROGRAMMING,['implementation'],"The Berland Armed Forces System consists of *n* ranks that are numbered using natural numbers from 1 to *n*, where 1 is the lowest rank and *n* is the highest rank.

One needs exactly *d**i* years to rise from rank *i* to rank *i*<=+<=1. Reaching a certain rank *i* having not reached all the previous *i*<=-<=1 ranks is impossible.

Vasya has just reached a new rank of *a*, but he dreams of holding the rank of *b*. Find for how many more years Vasya should serve in the army until he can finally realize his dream.",The first input line contains an integer *n* (2<=≤<=*n*<=≤<=100). The second line contains *n*<=-<=1 integers *d**i* (1<=≤<=*d**i*<=≤<=100). The third input line contains two integers *a* and *b* (1<=≤<=*a*<=&lt;<=*b*<=≤<=*n*). The numbers on the lines are space-separated.,Print the single number which is the number of years that Vasya needs to rise from rank *a* to rank *b*.,"['3\n5 6\n1 2\n', '3\n5 6\n1 3\n']","['5\n', '11\n']",none,OK,"def c(a):
    b=a+' '
    l=[]
    p=''
    for i in b:
        if i!=' ':
            p=p+i
        else:
            l.append(int(p))
            p=''
    return l
n=int(input())
y=str(input())
z=str(input())
l=c(y)
p=c(z)
a=p[0]-1
b=p[1]-1
k=0
for i in range(a,b):
    k=k+l[i]
print(k)","c = int(input().strip())

def a(y):
    b = str(y)
    return len(set(b)) == len(b)

while True:
    c += 1
    if a(c):
        print(c)
        break"
118,A,String Task,PROGRAMMING,"['implementation', 'strings']","Petya started to attend programming lessons. On the first lesson his task was to write a simple program. The program was supposed to do the following: in the given string, consisting if uppercase and lowercase Latin letters, it: 
 -  deletes all the vowels, -  inserts a character ""."" before each consonant, -  replaces all uppercase consonants with corresponding lowercase ones. 
Vowels are letters ""A"", ""O"", ""Y"", ""E"", ""U"", ""I"", and the rest are consonants. The program's input is exactly one string, it should return the output as a single string, resulting after the program's processing the initial string.

Help Petya cope with this easy task.","The first line represents input string of Petya's program. This string only consists of uppercase and lowercase Latin letters and its length is from 1 to 100, inclusive.",Print the resulting string. It is guaranteed that this string is not empty.,"['tour\n', 'Codeforces\n', 'aBAcAba\n']","['.t.r\n', '.c.d.f.r.c.s\n', '.b.c.b\n']",none,WRONG_ANSWER,"x = input()
y = [""a"", ""A"", ""e"", ""E"", ""i"", ""I"", ""o"", ""O"", ""u"", ""U""]
b = """"

def a(x, y, b):
    if x == """":
        return b
    if x[0] in y:
        return a(x[1:], y, b)
    if 64<ord(x[0])<91 or 96<ord(x[0])<123:
        if 64<ord(x[0])<91:
            b+=f"".{chr(ord(x[0])+32)}""
            return a(x[1:], y, b)
        b+=f"".{x[0]}""
        return a(x[1:], y, b)
print(a(x, y, b))","import i
import d

def g():

    c = i.stdin.read().splitlines()
    if not c:
        return
    
    n = int(c[0])
    k = c[1:n+1]

    f = 'abcdefghijklmnopqrstuvwxyz'

    e = 1
    while True:

        h = set()
        for j in k:
            if len(j) < e:
                continue

            for i in range(len(j) - e + 1):
                h.add(j[i:i+e])

        for a in d.product(f, repeat=e):
            b = ''.join(a)
            if b not in h:

                i.stdout.write(b)
                return

        e += 1

if __name__ == '__main__':
    g()"
950,A,"Left-handers, Right-handers and Ambidexters",PROGRAMMING,"['implementation', 'math']","You are at a water bowling training. There are *l* people who play with their left hand, *r* people, who play with their right hand, and *a* ambidexters, who can play with left or right hand.

The coach decided to form a team of even number of players, exactly half of the players should play with their right hand, and exactly half of the players should play with their left hand. One player should use only on of his hands.

Ambidexters play as well with their right hand as with their left hand. In the team, an ambidexter can play with their left hand, or with their right hand.

Please find the maximum possible size of the team, where equal number of players use their left and right hands, respectively.","The only line contains three integers *l*, *r* and *a* (0<=≤<=*l*,<=*r*,<=*a*<=≤<=100) — the number of left-handers, the number of right-handers and the number of ambidexters at the training.",Print a single even integer — the maximum number of players in the team. It is possible that the team can only have zero number of players.,"['1 4 2\n', '5 5 5\n', '0 2 0\n']","['6\n', '14\n', '0\n']","In the first example you can form a team of 6 players. You should take the only left-hander and two ambidexters to play with left hand, and three right-handers to play with right hand. The only person left can't be taken into the team.

In the second example you can form a team of 14 people. You have to take all five left-handers, all five right-handers, two ambidexters to play with left hand and two ambidexters to play with right hand.",OK,"def b():
    return list(map(int,input().split()))
def a(n):
    return [list(map(int,input().split())) for _ in range(n)]

l,r,a = b()

if max(l,r) - min(l,r) > a:
    print((min(l,r)+a) * 2)
else:
    print((max(l,r) + (a - (max(l,r) - min(l,r))) // 2) * 2)","def e():
    import g
    g.setrecursionlimit(10**6)
    f = 1000000007

    b = g.stdin.read().split()
    if not b:
        return
    n = int(b[0])
    k = int(b[1])
    d = int(b[2])

    c = [0] * (n + 1)
    c[0] = 1
    for i in range(1, n + 1):
        for w in range(1, k + 1):
            if i - w < 0:
                break
            c[i] = (c[i] + c[i - w]) % f

    d = [0] * (n + 1)
    d[0] = 1
    for i in range(1, n + 1):
        for w in range(1, d):
            if i - w < 0:
                break
            d[i] = (d[i] + d[i - w]) % f

    a = c[n] - d[n]
    a %= f

    g.stdout.write(str(a))

if __name__ == '__main__':
    e()"
682,C,Alyona and the Tree,PROGRAMMING,"['dfs and similar', 'dp', 'graphs', 'trees']","Alyona decided to go on a diet and went to the forest to get some apples. There she unexpectedly found a magic rooted tree with root in the vertex 1, every vertex and every edge of which has a number written on.

The girl noticed that some of the tree's vertices are sad, so she decided to play with them. Let's call vertex *v* sad if there is a vertex *u* in subtree of vertex *v* such that *dist*(*v*,<=*u*)<=&gt;<=*a**u*, where *a**u* is the number written on vertex *u*, *dist*(*v*,<=*u*) is the sum of the numbers written on the edges on the path from *v* to *u*.

Leaves of a tree are vertices connected to a single vertex by a single edge, but the root of a tree is a leaf if and only if the tree consists of a single vertex — root.

Thus Alyona decided to remove some of tree leaves until there will be no any sad vertex left in the tree. What is the minimum number of leaves Alyona needs to remove?","In the first line of the input integer *n* (1<=≤<=*n*<=≤<=105) is given — the number of vertices in the tree.

In the second line the sequence of *n* integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=109) is given, where *a**i* is the number written on vertex *i*.

The next *n*<=-<=1 lines describe tree edges: *i**th* of them consists of two integers *p**i* and *c**i* (1<=≤<=*p**i*<=≤<=*n*, <=-<=109<=≤<=*c**i*<=≤<=109), meaning that there is an edge connecting vertices *i*<=+<=1 and *p**i* with number *c**i* written on it.",Print the only integer — the minimum number of leaves Alyona needs to remove such that there will be no any sad vertex left in the tree.,['9\n88 22 83 14 95 91 98 53 11\n3 24\n7 -8\n1 67\n1 64\n9 65\n5 12\n6 -80\n3 8\n'],['5\n'],The following image represents possible process of removing leaves from the tree:,RUNTIME_ERROR,"def g(v):
    e = 1
    for u, c in a[v]:
        e += g(u)
    f[v] = e
    return e

def c(v, b):
    if b < 0:
        b = 0
    if h[v] < b:
        return f[v]
    d = 0
    for u, c in a[v]:
        d += c(u, b + c)
    return d

n = int(input())

h = list(map(int, input().split()))
a = {}
f = {}

for i in range(n):
    a[i] = []

for i in range(n - 1):
    p, c = map(int, input().split())
    a[p - 1] += [(i + 1, c)]

g(0)

print(c(0, 0))","import k

def g():

    c = k.stdin.read().splitlines()

    n, m = map(int, c[0].split())

    e = [list(f.strip()) for f in c[1:n+1]]

    j = []
    for i in e:
        d = {}
        for a in i:
            d[a] = d.get(a, 0) + 1
        j.append(d)

    b = []

    for j in range(m):
        d = {}
        for i in range(n):
            a = e[i][j]
            d[a] = d.get(a, 0) + 1
        b.append(d)

    h = []

    for i in range(n):

        for j in range(m):
            a = e[i][j]

            if j[i][a] == 1 and b[j][a] == 1:
                h.append(a)

    print(''.join(h))

if __name__ == ""__main__"":
    g()"
727,A,Transformation: from A to B,PROGRAMMING,"['brute force', 'dfs and similar', 'math']","Vasily has a number *a*, which he wants to turn into a number *b*. For this purpose, he can do two types of operations:
 -  multiply the current number by 2 (that is, replace the number *x* by 2·*x*); -  append the digit 1 to the right of current number (that is, replace the number *x* by 10·*x*<=+<=1). 
You need to help Vasily to transform the number *a* into the number *b* using only the operations described above, or find that it is impossible.

Note that in this task you are not required to minimize the number of operations. It suffices to find any way to transform *a* into *b*.",The first line contains two positive integers *a* and *b* (1<=≤<=*a*<=&lt;<=*b*<=≤<=109) — the number which Vasily has and the number he wants to have.,"If there is no way to get *b* from *a*, print ""NO"" (without quotes).

Otherwise print three lines. On the first line print ""YES"" (without quotes). The second line should contain single integer *k* — the length of the transformation sequence. On the third line print the sequence of transformations *x*1,<=*x*2,<=...,<=*x**k*, where:
 -  *x*1 should be equal to *a*, -  *x**k* should be equal to *b*, -  *x**i* should be obtained from *x**i*<=-<=1 using any of two described operations (1<=&lt;<=*i*<=≤<=*k*). 
If there are multiple answers, print any of them.","['2 162\n', '4 42\n', '100 40021\n']","['YES\n5\n2 4 8 81 162 \n', 'NO\n', 'YES\n5\n100 200 2001 4002 40021 \n']",none,OK,"a, b = map(int, input().split())

b = []

def d(s):
    if s > b:
        return False
    if s == b:
        return True
        
    for i in range(2):
        if i==0:
            a = d(2*s)
            if a:
                b.append(2*s)
                return True
            
        if i == 1:
            a = d(10*s +1)
            if a:
                b.append(10*s + 1)
                return True
d(a)  
if len(b) > 0:
    print(""YES"")

    b.append(a)
    print(len(b))
    
    for i in reversed(b):
        print(i, end = "" "")
else:
    print(""NO"")","import b

Y, W = map(int, input().split())

d = max(Y, W)

e = 7 - d

f = 6

g = b.gcd(e, f)
c = e // g
a = f // g

print(f""{c}/{a}"")"
409,F,000001,PROGRAMMING,['*special'],"The input contains a single integer *a* (1<=≤<=*a*<=≤<=64).

Output a single integer.",The input contains a single integer *a* (1<=≤<=*a*<=≤<=64).,Output a single integer.,"['2\n', '4\n', '27\n', '42\n']","['1\n', '2\n', '5\n', '6\n']",none,OK,"from sys import a,b

input,print = a.readline,b.write

print(str([0, 1, 1, 1, 2, 1, 2, 1, 5, 2, 2, 1, 5, 1, 2, 1, 14, 1, 5, 1, 5, 2, 2, 1, 15, 2, 2, 5, 4, 1, 4, 1, 51, 1, 2, 1, 14, 1, 2, 2, 14, 1, 6, 1, 4, 2, 2, 1, 52, 2, 5, 1, 5, 1, 15, 2, 13, 2, 2, 1, 13, 1, 2, 4, 267, 1, 4, 1, 5, 1, 4, 1, 50, 1, 2, 3, 4, 1, 6, 1, 52, 15, 2, 1, 15, 1, 2, 1, 12, 1, 10, 1, 4, 2][int(input())])+""\n"")","def a():

    n = int(input())

    b = 0
    c = 0
    d = 0

    for _ in range(n):

        x, y, z = map(int, input().split())
        b += x
        c += y
        d += z

    if b == 0 and c == 0 and d == 0:
        print(""YES"")
    else:
        print(""NO"")

if __name__ == ""__main__"":
    a()"
979,C,Kuro and Walking Route,PROGRAMMING,"['dfs and similar', 'trees']","Kuro is living in a country called Uberland, consisting of $n$ towns, numbered from $1$ to $n$, and $n - 1$ bidirectional roads connecting these towns. It is possible to reach each town from any other. Each road connects two towns $a$ and $b$. Kuro loves walking and he is planning to take a walking marathon, in which he will choose a pair of towns $(u, v)$ ($u \neq v$) and walk from $u$ using the shortest path to $v$ (note that $(u, v)$ is considered to be different from $(v, u)$).

Oddly, there are 2 special towns in Uberland named Flowrisa (denoted with the index $x$) and Beetopia (denoted with the index $y$). Flowrisa is a town where there are many strong-scent flowers, and Beetopia is another town where many bees live. In particular, Kuro will avoid any pair of towns $(u, v)$ if on the path from $u$ to $v$, he reaches Beetopia after he reached Flowrisa, since the bees will be attracted with the flower smell on Kuro’s body and sting him.

Kuro wants to know how many pair of city $(u, v)$ he can take as his route. Since he’s not really bright, he asked you to help him with this problem.","The first line contains three integers $n$, $x$ and $y$ ($1 \leq n \leq 3 \cdot 10^5$, $1 \leq x, y \leq n$, $x \ne y$) - the number of towns, index of the town Flowrisa and index of the town Beetopia, respectively.

$n - 1$ lines follow, each line contains two integers $a$ and $b$ ($1 \leq a, b \leq n$, $a \ne b$), describes a road connecting two towns $a$ and $b$.

It is guaranteed that from each town, we can reach every other town in the city using the given roads. That is, the given map of towns and roads is a tree.","A single integer resembles the number of pair of towns $(u, v)$ that Kuro can use as his walking route.","['3 1 3\n1 2\n2 3\n', '3 1 3\n1 2\n1 3\n']","['5', '4']","On the first example, Kuro can choose these pairs: 
 -  $(1, 2)$: his route would be $1 \rightarrow 2$, -  $(2, 3)$: his route would be $2 \rightarrow 3$, -  $(3, 2)$: his route would be $3 \rightarrow 2$, -  $(2, 1)$: his route would be $2 \rightarrow 1$, -  $(3, 1)$: his route would be $3 \rightarrow 2 \rightarrow 1$. 
Kuro can't choose pair $(1, 3)$ since his walking route would be $1 \rightarrow 2 \rightarrow 3$, in which Kuro visits town $1$ (Flowrisa) and then visits town $3$ (Beetopia), which is not allowed (note that pair $(3, 1)$ is still allowed because although Kuro visited Flowrisa and Beetopia, he did not visit them in that order).

On the second example, Kuro can choose the following pairs: 
 -  $(1, 2)$: his route would be $1 \rightarrow 2$, -  $(2, 1)$: his route would be $2 \rightarrow 1$, -  $(3, 2)$: his route would be $3 \rightarrow 1 \rightarrow 2$, -  $(3, 1)$: his route would be $3 \rightarrow 1$.",TIME_LIMIT_EXCEEDED,"n,x,y=map(int,input().split(' '));x-=1;y-=1
a=[];g=[];
for i in range(n):
	a.append([]);g.append(-1);
for _ in range(n-1):
	u,v=map(int,input().split(' '))
	a[u-1].append(v-1);
	a[v-1].append(u-1);

def e():
	global a,x,y,n
	l=[0 for i in range(n)]
	k=[False for i in range(n)]
	c=[0 for i in range(n)]
	b=[0 for i in range(n)]
	l=[0 for i in range(n)]
	h=[x];l[x]=1
	while h:

		d=h[-1]
		if d==y:
			k[d]=True
		if b[d]<len(a[d]):
			if l[a[d][b[d]]]==0:
				h.append(a[d][b[d]])
				l[a[d][b[d]]]=1
				b[d]+=1
			else:
				b[d]+=1
		else:
			i=h[-1];del h[-1]
			for i in a[i]:
				c[i]+=c[i]
			c[i]+=1
			if len(h)>=1:
				k[h[-1]]=k[h[-1]]|k[i]

	f=n*(n-1)
	j=0
	for i in a[x]:
		if k[i]==True:
			j=i
			break

	print(f-c[y]*(c[x]-c[j]))

e()","import 
import q

def s():

    g = .stdin.read().splitlines()

    g = [r.rstrip() for r in g]

    i = 0
    n = int(g[i])
    i += 1

     = {}
    n = []
    c = 0

    while c < n and i < len(g):

        while i < len(g) and g[i].strip() == """":
            i += 1
        if i >= len(g):
            break

        | = g[i].strip()
        i += 1
        if not |:
            continue
        w = |.split()
        } = w[0]
        ~ = int(w[1])
        { = (}, ~)
        n.append({)

        while i < len(g) and g[i].strip() == """":
            i += 1
        if i >= len(g):
            break
        i = g[i].strip()
        i += 1

        h = int(i)
        m = []

        for _ in range(h):

            while i < len(g) and g[i].strip() == """":
                i += 1
            if i >= len(g):
                break
            j = g[i].strip()
            i += 1
            o = j.split()
            k = o[0]
            l = int(o[1])
            m.append((k, l))
        [{] = m
        c += 1

    y = n[0]
    x, z = y

    a = {}

    p = []

    a[x] = (0, z)
    q.heappush(p, (0, -z, x, z))

    while p:
        d, v, t,  = q.heappop(p)

        if a.get(t, (None,None)) != (d, ):
            continue

        f = .get((t, ), [])
        for k, l in f:
            u = d + 1
            b = (u, l)
            if k not in a:
                a[k] = b
                q.heappush(p, (u, -l, k, l))
            else:
                d, e = a[k]
                 = False

                if u < d:
                     = True

                elif u == d and l > e:
                     = True
                if :
                    a[k] = b
                    q.heappush(p, (u, -l, k, l))

     = []
    for t in a:
        if t == x:
            continue
         = a[t][1]
        .append((t, ))

    .sort(key=lambda x: x[0])

    print(len())
    for t,  in :
        print(t, )

if __name__ == ""__main__"":
    s()"
448,D,Multiplication Table,PROGRAMMING,"['binary search', 'brute force']","Bizon the Champion isn't just charming, he also is very smart.

While some of us were learning the multiplication table, Bizon the Champion had fun in his own manner. Bizon the Champion painted an *n*<=×<=*m* multiplication table, where the element on the intersection of the *i*-th row and *j*-th column equals *i*·*j* (the rows and columns of the table are numbered starting from 1). Then he was asked: what number in the table is the *k*-th largest number? Bizon the Champion always answered correctly and immediately. Can you repeat his success?

Consider the given multiplication table. If you write out all *n*·*m* numbers from the table in the non-decreasing order, then the *k*-th number you write out is called the *k*-th largest number.","The single line contains integers *n*, *m* and *k* (1<=≤<=*n*,<=*m*<=≤<=5·105; 1<=≤<=*k*<=≤<=*n*·*m*).",Print the *k*-th largest number in a *n*<=×<=*m* multiplication table.,"['2 2 2\n', '2 3 4\n', '1 10 5\n']","['2\n', '3\n', '5\n']",A 2 × 3 multiplication table looks like this:,TIME_LIMIT_EXCEEDED,"def a(a,n,m):
    c=0
    for i in range(1,n+1):
        c+=min(m,a//i)
    return c

n,m,k=list(map(int,input().split()))
b=1
f=n*m
while(b<=f):
    d=(b+f)//2
    c=a(d,n,m)

    if(c>k):
        e=a(d-1,n,m)

        if(e<k):
            print(d)
            break
        f=d-1
    elif(c<k):
        b=d+1
    else:
        print(d)
        break","def g():
    import l
    l.setrecursionlimit(10**6)

    c = l.stdin.read().strip().split()
    if not c:
        return
    f = iter(c)
    n = int(next(f))

    e = [[] for _ in range(n + 1)]
    for _ in range(n - 1):
        u = int(next(f))
        v = int(next(f))
        t = int(next(f))
        e[u].append((v, t))
        e[v].append((u, t))

    a = []

    def d(u, i):
        k = False
        for v, j in e[u]:
            if v == i:
                continue
            b = d(v, u)

            if j == 2 and not b:
                a.append(v)
                b = True
            k |= b
        return k

    d(1, -1)

    a.sort()

    h = []
    h.append(str(len(a)))
    if a:
        h.append("" "".join(map(str, a)))
    l.stdout.write(""\n"".join(h))

if __name__ == '__main__':
    g()"
25,D,Roads not only in Berland,PROGRAMMING,"['dsu', 'graphs', 'trees']","Berland Government decided to improve relations with neighboring countries. First of all, it was decided to build new roads so that from each city of Berland and neighboring countries it became possible to reach all the others. There are *n* cities in Berland and neighboring countries in total and exactly *n*<=-<=1 two-way roads. Because of the recent financial crisis, the Berland Government is strongly pressed for money, so to build a new road it has to close some of the existing ones. Every day it is possible to close one existing road and immediately build a new one. Your task is to determine how many days would be needed to rebuild roads so that from each city it became possible to reach all the others, and to draw a plan of closure of old roads and building of new ones.","The first line contains integer *n* (2<=≤<=*n*<=≤<=1000) — amount of cities in Berland and neighboring countries. Next *n*<=-<=1 lines contain the description of roads. Each road is described by two space-separated integers *a**i*, *b**i* (1<=≤<=*a**i*,<=*b**i*<=≤<=*n*,<=*a**i*<=≠<=*b**i*) — pair of cities, which the road connects. It can't be more than one road between a pair of cities. No road connects the city with itself.","Output the answer, number *t* — what is the least amount of days needed to rebuild roads so that from each city it became possible to reach all the others. Then output *t* lines — the plan of closure of old roads and building of new ones. Each line should describe one day in the format i j u v — it means that road between cities i and j became closed and a new road between cities u and v is built. Cities are numbered from 1. If the answer is not unique, output any.","['2\n1 2\n', '7\n1 2\n2 3\n3 1\n4 5\n5 6\n6 7\n']","['0\n', '1\n3 1 3 7\n']",none,WRONG_ANSWER,"from collections import defaultdict

def d():
    n = int(input())
    a = list()
    for i in range(n-1):
        u, v = map(int, input().split(' '))
        a.append([u, v])
    
    def b(a):
        if p[a] != a:
            p[a] = b(p[a])
        return p[a]

    def g(a, b):
        a = b(a)
        b = b(b)
        if a == b:
            return
        if f[a] > f[b]:
            p[b] = a
            f[a] += f[b]
        else:
            p[a] = b
            f[b] += f[a]
    
    p = list(range(n + 1))
    f = [1] * (n + 1)
    for u, v in a:
        g(u, v)
    u, v = a[0]
    e = list()
    for i in range(1, n + 1):
        if b(i) != b(u):
            e.append([u, v, u, i])
            g(u, i)
    print(len(e))
    for c in e:
        print(*c)
    
d()","def {(p, a, b):
    """"""Check if point p is on segment ab""""""
    (, ), (c, d), (g, h) = p, a, b

    if min(c, g) - 1e-9 <=  <= max(c, g) + 1e-9 and min(d, h) - 1e-9 <=  <= max(d, h) + 1e-9:

        if abs((g - c) * ( - d) - (h - d) * ( - c)) < 1e-9:
            return True
    return False

def u(a, b, c):
    """"""Return orientation of triplet (a, b, c).
       0 -> collinear, 1 -> clockwise, 2 -> counterclockwise""""""
    (c, d), (g, h), (i, j) = a, b, c
     = (h - d) * (i - g) - (g - c) * (j - h)
    if abs() < 1e-9:
        return 0
    return 1 if  > 0 else 2

def (v, , w, ):
    """"""Return True if line segments p1q1 and p2q2 intersect.""""""
    q = u(v, , w)
    r = u(v, , )
    s = u(w, , v)
    t = u(w, , )

    if q != r and s != t:
        return True

    if q == 0 and {(w, v, ):
        return True
    if r == 0 and {(, v, ):
        return True
    if s == 0 and {(v, w, ):
        return True
    if t == 0 and {(, w, ):
        return True
    return False

def z(y, |):
    """"""Return True if point is inside polygon poly (including edges).
       poly is a list of points (tuples) in order.""""""
    x, y = y
    k = False
    n = len(|)
    for i in range(n):
        j = (i + 1) % n

        if {(y, |[i], |[j]):
            return True
        ,  = |[i]
        ,  = |[j]

        if (( > y) != ( > y)):
             = ( - ) * (y - ) / ( -  + 1e-9) + 
            if x < :
                k = not k
    return k

def (}, ~):
    """"""Return True if polygons poly1 and poly2 intersect.""""""

    for p in }:
        if z(p, ~):
            return True

    for p in ~:
        if z(p, }):
            return True

    n, o = len(}), len(~)
    for i in range(n):
        a = }[i]
        e = }[(i + 1) % n]
        for j in range(o):
            b = ~[j]
            f = ~[(j + 1) % o]
            if (a, e, b, f):
                return True
    return False

def x(l):
    """"""Parse a line of 8 integers as a list of 4 (x, y) tuples.""""""
    p = list(map(int, l.strip().split()))
    | = []
    for i in range(0, len(p), 2):
        |.append((p[i], p[i + 1]))
    return |

if __name__ == '__main__':
    import 

    m = .stdin.readlines()
    if len(m) < 2:
        .exit(1)

    } = x(m[0])
    ~ = x(m[1])

    if (}, ~):
        print(""Yes"")
    else:
        print(""No"")"
251,A,Points on Line,PROGRAMMING,"['binary search', 'combinatorics', 'two pointers']","Little Petya likes points a lot. Recently his mom has presented him *n* points lying on the line *OX*. Now Petya is wondering in how many ways he can choose three distinct points so that the distance between the two farthest of them doesn't exceed *d*.

Note that the order of the points inside the group of three chosen points doesn't matter.","The first line contains two integers: *n* and *d* (1<=≤<=*n*<=≤<=105; 1<=≤<=*d*<=≤<=109). The next line contains *n* integers *x*1,<=*x*2,<=...,<=*x**n*, their absolute value doesn't exceed 109 — the *x*-coordinates of the points that Petya has got.

It is guaranteed that the coordinates of the points in the input strictly increase.","Print a single integer — the number of groups of three points, where the distance between two farthest points doesn't exceed *d*.

Please do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.","['4 3\n1 2 3 4\n', '4 2\n-3 -2 -1 0\n', '5 19\n1 10 20 30 50\n']","['4\n', '2\n', '1\n']","In the first sample any group of three points meets our conditions.

In the seconds sample only 2 groups of three points meet our conditions: {-3, -2, -1} and {-2, -1, 0}.

In the third sample only one group does: {1, 10, 20}.",OK,"def a(L,b,x):
    a=b
    b=len(L)
    while(b-a>1):
        i=(b+a)//2
        if(L[i]>x):
            b=i
        elif(L[i]<x):
            a=i
        else:
            return (i+1)-b-1
    return b-b-1

import math

n,d=map(int,input().split())

P=list(map(int,input().split()))
c=0
for i in range(n):
    x=a(P,i,P[i]+d)
    if(x>1):
        c+=((x)*(x-1))//2
print(c)","s = input().strip()
t = input().strip()

def b(s):
    """"""
    This function finds the next lexicographical string that is greater than s.
    It works by processing the string from the end. If a character is less than 'z',
    it is incremented by one and the function returns the new string.
    Otherwise, if the character is 'z', it is replaced with 'a' and the carry carries to the previous character.
    """"""

    c = list(s)
    i = len(c) - 1

    while i >= 0:

        if c[i] != 'z':
            c[i] = chr(ord(c[i]) + 1)

            return """".join(c)

        c[i] = 'a'
        i -= 1

    return None

a = b(s)

if a is not None and a < t:
    print(a)
else:
    print(""No such string"")"
462,A,Appleman and Easy Task,PROGRAMMING,"['brute force', 'implementation']","Toastman came up with a very easy task. He gives it to Appleman, but Appleman doesn't know how to solve it. Can you help him?

Given a *n*<=×<=*n* checkerboard. Each cell of the board has either character 'x', or character 'o'. Is it true that each cell of the board has even number of adjacent cells with 'o'? Two cells of the board are adjacent if they share a side.",The first line contains an integer *n* (1<=≤<=*n*<=≤<=100). Then *n* lines follow containing the description of the checkerboard. Each of them contains *n* characters (either 'x' or 'o') without spaces.,"Print ""YES"" or ""NO"" (without the quotes) depending on the answer to the problem.","['3\nxxo\nxox\noxx\n', '4\nxxxo\nxoxo\noxox\nxxxx\n']","['YES\n', 'NO\n']",none,WRONG_ANSWER,"a = lambda : list(map(int,input().strip().split()))
n, = a()
g = [list(input()) for _ in range(n)]
g = [[0 if e[k] == 'x' else 1 for k in range(n)] for e in g]
for k in range(n):
	for j in range(n):
		b = 0
		try:
			b += g[k][j+1]
		except Exception:
			b += 0
		try:
			b += g[k][j-1]
		except Exception:
			b += 0
		try:
			b += g[k+1][j]
		except Exception:
			b += 0
		try:
			b += g[k-1][j]
		except Exception:
			b += 0
		if b%2:
			print(""NO"")
			exit();
print(""YES"")","import n
import i

def h():

    d = n.stdin.read().split()
    if not d:
        return
    n = int(d[0])

    f = list(map(int, d[1:n+1]))
    a = list(map(int, d[n+1:2*n+1]))

    e = {0: 0}

    for g, b in zip(f, a):
        k = e.copy()

        for g, c in e.items():
            l = i.gcd(g, g)
            j = c + b

            if l in k:
                k[l] = min(k[l], j)
            else:
                k[l] = j
        e = k

    m = e.get(1, -1)
    n.stdout.write(str(m) + ""\n"")

if __name__ == '__main__':
    h()"
740,A,Alyona and copybooks,PROGRAMMING,"['brute force', 'implementation']","Little girl Alyona is in a shop to buy some copybooks for school. She study four subjects so she wants to have equal number of copybooks for each of the subjects. There are three types of copybook's packs in the shop: it is possible to buy one copybook for *a* rubles, a pack of two copybooks for *b* rubles, and a pack of three copybooks for *c* rubles. Alyona already has *n* copybooks.

What is the minimum amount of rubles she should pay to buy such number of copybooks *k* that *n*<=+<=*k* is divisible by 4? There are infinitely many packs of any type in the shop. Alyona can buy packs of different type in the same purchase.","The only line contains 4 integers *n*, *a*, *b*, *c* (1<=≤<=*n*,<=*a*,<=*b*,<=*c*<=≤<=109).",Print the minimum amount of rubles she should pay to buy such number of copybooks *k* that *n*<=+<=*k* is divisible by 4.,"['1 1 3 4\n', '6 2 1 1\n', '4 4 4 4\n', '999999999 1000000000 1000000000 1000000000\n']","['3\n', '1\n', '0\n', '1000000000\n']","In the first example Alyona can buy 3 packs of 1 copybook for 3*a* = 3 rubles in total. After that she will have 4 copybooks which she can split between the subjects equally. 

In the second example Alyuna can buy a pack of 2 copybooks for *b* = 1 ruble. She will have 8 copybooks in total.

In the third example Alyona can split the copybooks she already has between the 4 subject equally, so she doesn't need to buy anything.

In the fourth example Alyona should buy one pack of one copybook.",OK,"""""""
ATSTNG's ejudge Python3 solution template
(actual solution is below)
""""""
import y, s

try:
    import dev_act_ffc429465ab634
    a = True
except:
    a = False

def o(*s):
    if a: print('LOG', *s)

class b:
    def __init__(w, r=""default"", t=1<<30):
        w.r = r
        y.setrecursionlimit(t)

    def (w, m='', p=''):
        if m!='':
            w.m = open(m)
            y.stdin = w.m
        if m!='':
            w.p = open(p, 'w')
            y.stdout = w.p

    def ~(w):
        w.(w.r+'.in', w.r+'.out')

    def k(w):
        while True: pass

    def i(w):
        } = [[[5]*100000 for _ in range(1000)]]
        while True: }.append([[5]*100000 for _ in range(1000)])

    def j(w):
        s = (0,)[8]

    def l(w, ='blablalblah'):
        for _ in range(3): print()
        exit()

class c:
    def __init__(w):
        w.ost = s.Queue()

    def h(w):
        return int(w.x())

    def x(w):
        if w.ost.empty():
            for f in input().split():
                w.ost.put(f)
        return w.ost.h()

    def u(w):
        v = []
        while not w.ost.empty():
            v.append(w.ost.h())
        return v

e = b(  )
n = c()
g = lambda f,*l: list(map(f,*l))
q = lambda: g(int, input().split())

n,z,{,| = q()
| = min(|, {+z, z*3)
{ = min({, z*2, |*2)
z = min(z, |+{, |*3)

n = n%4
if n==0: d = 0
if n==1: d = |
if n==2: d = {
if n==3: d = z

print(d)","def c():
    import f
    from collections import a

    g = f.stdin.read().split()
    if not g:
        return

    n = int(g[0])

    e = list(map(int, g[1:1+n]))

    b = a(e)

    d = max(b.values())

    print(d)

if __name__ == ""__main__"":
    c()"
385,B,Bear and Strings,PROGRAMMING,"['brute force', 'greedy', 'implementation', 'math', 'strings']","The bear has a string *s*<==<=*s*1*s*2... *s*|*s*| (record |*s*| is the string's length), consisting of lowercase English letters. The bear wants to count the number of such pairs of indices *i*,<=*j* (1<=≤<=*i*<=≤<=*j*<=≤<=|*s*|), that string *x*(*i*,<=*j*)<==<=*s**i**s**i*<=+<=1... *s**j* contains at least one string ""bear"" as a substring.

String *x*(*i*,<=*j*) contains string ""bear"", if there is such index *k* (*i*<=≤<=*k*<=≤<=*j*<=-<=3), that *s**k*<==<=*b*, *s**k*<=+<=1<==<=*e*, *s**k*<=+<=2<==<=*a*, *s**k*<=+<=3<==<=*r*.

Help the bear cope with the given problem.",The first line contains a non-empty string *s* (1<=≤<=|*s*|<=≤<=5000). It is guaranteed that the string only consists of lowercase English letters.,Print a single number — the answer to the problem.,"['bearbtear\n', 'bearaabearc\n']","['6\n', '20\n']","In the first sample, the following pairs (*i*, *j*) match: (1, 4), (1, 5), (1, 6), (1, 7), (1, 8), (1, 9).

In the second sample, the following pairs (*i*, *j*) match: (1,  4), (1,  5), (1,  6), (1,  7), (1,  8), (1,  9), (1,  10), (1,  11), (2,  10), (2,  11), (3,  10), (3,  11), (4,  10), (4,  11), (5,  10), (5,  11), (6,  10), (6,  11), (7,  10), (7,  11).",OK,"import g
import math

def b():
    e = g.stdin.readline
    i: str = e().strip()
    c = None
    h = 0
    for i, c in enumerate(i):
        if i + 3 >= len(i):
            break
        if i[i] == 'b' and i[i + 1] == 'e' and i[i + 2] == 'a' and i[i + 3] == 'r':
            d = (c if c else 0) + 1

            l = i + 1
            r = i + 3 + 1
            a = l - 1 - (d) + 1
            f = len(i) - (r + 1) + 1
            if l == 1:
                h += 1 + f
            elif r == len(i):
                h += 1 + a
            else:
                h += a * (f + 1)
                h += 1 + f
            c = l
    print(h)

if __name__ == '__main__':
    b()","import g
import i

def f():
    d = i.stdin.read().split()
    if not d or len(d) < 2:
        return
    a = int(d[0])
    b = int(d[1])

    if b % a != 0:
        print(""NO"")
        return

    k = b // a
    e = False
    h = None

    for x in range(1, a):
        k = a*a - x*x
        y = g.isqrt(k)
        if y * y == k and y != 0:

            if x - k * y != 0:
                h = (x, y)
                e = True
                break
    
    if not e:
        print(""NO"")
        return

    (x, y) = h

    a = (0, 0)
    b = (x, y)
    c = (x - k * y, y + k * x)

    def j(p, q):
        return p[0] != q[0] and p[1] != q[1]
    
    if not (j(a, b) and j(b, c) and j(a, c)):
        print(""NO"")
        return

    print(""YES"")
    print(f""{a[0]} {a[1]}"")
    print(f""{b[0]} {b[1]}"")
    print(f""{c[0]} {c[1]}"")

if __name__ == '__main__':
    f()"
705,A,Hulk,PROGRAMMING,['implementation'],"Dr. Bruce Banner hates his enemies (like others don't). As we all know, he can barely talk when he turns into the incredible Hulk. That's why he asked you to help him to express his feelings.

Hulk likes the Inception so much, and like that his feelings are complicated. They have *n* layers. The first layer is hate, second one is love, third one is hate and so on...

For example if *n*<==<=1, then his feeling is ""I hate it"" or if *n*<==<=2 it's ""I hate that I love it"", and if *n*<==<=3 it's ""I hate that I love that I hate it"" and so on.

Please help Dr. Banner.",The only line of the input contains a single integer *n* (1<=≤<=*n*<=≤<=100) — the number of layers of love and hate.,Print Dr.Banner's feeling in one line.,"['1\n', '2\n', '3\n']","['I hate it\n', 'I hate that I love it\n', 'I hate that I love that I hate it\n']",none,OK,"import i

def e():
    return int(input())

def d():
    return list(map(int, input().split()))

def f():
    return input().strip()

def h(x):
    i.stdout.write(str(x) + ""\n"")

def g():
    b = e()
    a = """"
    
    c = ["" I love"", "" I hate""]          
    for i in range(1, b + 1):
        a += c[i%2]
        if i < b:
            a += "" that"" 
        
    a += "" it""
    h(a)
        
if __name__ == ""__main__"":
    g()","def i():
    import m
    m.setrecursionlimit(10**6)
    j = 1000000007

    d = m.stdin.read().split()
    if not d:
        return
    h = iter(d)
    n = int(next(h))
    m = int(next(h))

    g = [[] for _ in range(n+1)]
    for _ in range(m):
        u = int(next(h))
        v = int(next(h))
        r = int(next(h))

        n = (r + 1) & 1
        g[u].append((v, n))
        g[v].append((u, n))

    b = [-1] * (n + 1)
    c = 0
    
    def f(l):

        k = [l]
        b[l] = 0
        while k:
            u = k.pop()
            for v, c in g[u]:

                e = (c - b[u]) % 2
                if b[v] == -1:
                    b[v] = e
                    k.append(v)
                else:

                    if b[v] != e:
                        return False
        return True
    
    o = True

    for i in range(1, n+1):
        if b[i] == -1:
            c += 1
            if not f(i):
                o = False
                break
    
    if not o:
        m.stdout.write(""0"")
        return

    a = pow(2, c - 1, j) if c > 0 else 1
    m.stdout.write(str(a))
    
if __name__ == '__main__':
    i()"
270,A,Fancy Fence,PROGRAMMING,"['geometry', 'implementation', 'math']","Emuskald needs a fence around his farm, but he is too lazy to build it himself. So he purchased a fence-building robot.

He wants the fence to be a regular polygon. The robot builds the fence along a single path, but it can only make fence corners at a single angle *a*.

Will the robot be able to build the fence Emuskald wants? In other words, is there a regular polygon which angles are equal to *a*?",The first line of input contains an integer *t* (0<=&lt;<=*t*<=&lt;<=180) — the number of tests. Each of the following *t* lines contains a single integer *a* (0<=&lt;<=*a*<=&lt;<=180) — the angle the robot can make corners at measured in degrees.,"For each test, output on a single line ""YES"" (without quotes), if the robot can build a fence Emuskald wants, and ""NO"" (without quotes), if it is impossible.",['3\n30\n60\n90\n'],['NO\nYES\nYES\n'],"In the first test case, it is impossible to build the fence, since there is no regular polygon with angle <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/df5f4b07dd5316fde165b43657b2696e2919e791.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>.

In the second test case, the fence is a regular triangle, and in the last test case — a square.",OK,"def a():
    a = int(input())
    
    n = 360 / (180 - a)
    
    if n == int(n):
        return ""YES""
    
    return ""NO""

t = int(input())

for _ in range(t):
    print(a())","import e

def d(n):

    b = [True] * (n + 1)
    b[0] = b[1] = False
    for i in range(2, int(n ** 0.5) + 1):
        if b[i]:
            for j in range(i * i, n + 1, i):
                b[j] = False
    return b

def c():

    a = e.stdin.read().strip().split()
    if not a:
        return
    n = int(a[0])

    b = d(n)

    for x in range(4, n + 1):
        if not b[x]:
            y = n - x

            if y >= 4 and not b[y]:
                print(x, y)
                return

if __name__ == '__main__':
    c()"
460,A,Vasya and Socks,PROGRAMMING,"['brute force', 'implementation', 'math']","Vasya has *n* pairs of socks. In the morning of each day Vasya has to put on a pair of socks before he goes to school. When he comes home in the evening, Vasya takes off the used socks and throws them away. Every *m*-th day (at days with numbers *m*,<=2*m*,<=3*m*,<=...) mom buys a pair of socks to Vasya. She does it late in the evening, so that Vasya cannot put on a new pair of socks before the next day. How many consecutive days pass until Vasya runs out of socks?","The single line contains two integers *n* and *m* (1<=≤<=*n*<=≤<=100; 2<=≤<=*m*<=≤<=100), separated by a space.",Print a single integer — the answer to the problem.,"['2 2\n', '9 3\n']","['3\n', '13\n']","In the first sample Vasya spends the first two days wearing the socks that he had initially. Then on day three he puts on the socks that were bought on day two.

In the second sample Vasya spends the first nine days wearing the socks that he had initially. Then he spends three days wearing the socks that were bought on the third, sixth and ninth days. Than he spends another day wearing the socks that were bought on the twelfth day.",WRONG_ANSWER,"def c():
    n,m = list(map(int,input().split()))
    a = n
    b = 0
    while n:
        a += n//m
        n //= m
        b += n % m
    return a + b//m
print(c())","import o
import math

def m(n):

    n = list(range(n + 1))
    for i in range(2, int(n ** 0.5) + 1):
        if n[i] == i:
            for j in range(i * i, n + 1, i):
                if n[j] == j:
                    n[j] = i
    return n

def f():
    c = o.stdin.read().splitlines()
    if not c:
        return

    n, m = map(int, c[0].split())

    n = m(n)

    j = [set() for _ in range(n + 1)]
    for i in range(2, n + 1):
        p = i
        while p > 1:
            i = n[p]
            j[i].add(i)
            p //= i

    k = {}

    a = [False] * (n + 1)

    h = []
    for e in c[1:]:
        g, l = e.split()
        d = int(l)
        if g == '+':

            if a[d]:
                h.append(""Already on"")
            else:
                b = None

                for i in j[d]:
                    if i in k:
                        b = k[i]
                        break
                if b is not None:
                    h.append(""Conflict with "" + str(b))
                else:

                    a[d] = True
                    for i in j[d]:
                        k[i] = d
                    h.append(""Success"")
        elif g == '-':

            if not a[d]:
                h.append(""Already off"")
            else:

                a[d] = False
                for i in j[d]:
                    if k.get(i) == d:
                        del k[i]
                h.append(""Success"")
                
    o.stdout.write(""\n"".join(h))

if __name__ == '__main__':
    f()"
349,A,Cinema Line,PROGRAMMING,"['greedy', 'implementation']","The new ""Die Hard"" movie has just been released! There are *n* people at the cinema box office standing in a huge line. Each of them has a single 100, 50 or 25 ruble bill. A ""Die Hard"" ticket costs 25 rubles. Can the booking clerk sell a ticket to each person and give the change if he initially has no money and sells the tickets strictly in the order people follow in the line?","The first line contains integer *n* (1<=≤<=*n*<=≤<=105) — the number of people in the line. The next line contains *n* integers, each of them equals 25, 50 or 100 — the values of the bills the people have. The numbers are given in the order from the beginning of the line (at the box office) to the end of the line.","Print ""YES"" (without the quotes) if the booking clerk can sell a ticket to each person and give the change. Otherwise print ""NO"".","['4\n25 25 50 50\n', '2\n25 100\n', '4\n50 50 25 25\n']","['YES\n', 'NO\n', 'NO\n']",none,WRONG_ANSWER,"from collections import b
n = int(input()) 
a = [int(i) for i in input().split()] 
d = b(int) 
d[0] = 1
a = ""YES""
for i in range(n): 
    if d[a[i] - 25] != 0: a = ""NO"" ; break 
    d[a[i]-25]-=1
    d[a[i]] += 1
    
print(a)","import m
m.setrecursionlimit(10**6)

def i():

    g = m.stdin.read().split()
    n = int(g[0])
    m = int(g[1])

    a = [0] * (n + 1)
    for i in range(1, n + 1):
        a[i] = int(g[1 + i])

    e = [[] for _ in range(n + 1)]
    f = 2 + n
    for _ in range(n - 1):
        u = int(g[f])
        v = int(g[f + 1])
        f += 2
        e[u].append(v)
        e[v].append(u)
    
    c = 0

    def d(k, l, b):
        nonlocal c, m

        if a[k] == 1:
            b += 1
        else:
            b = 0

        if b > m:
            return

        h = True
        for j in e[k]:
            if j != l:
                h = False
                d(j, k, b)

        if h:
            c += 1

    d(1, -1, 0)
    print(c)

if __name__ == ""__main__"":
    i()"
540,A,Combination Lock,PROGRAMMING,['implementation'],"Scrooge McDuck keeps his most treasured savings in a home safe with a combination lock. Each time he wants to put there the treasures that he's earned fair and square, he has to open the lock.

The combination lock is represented by *n* rotating disks with digits from 0 to 9 written on them. Scrooge McDuck has to turn some disks so that the combination of digits on the disks forms a secret combination. In one move, he can rotate one disk one digit forwards or backwards. In particular, in one move he can go from digit 0 to digit 9 and vice versa. What minimum number of actions does he need for that?","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=1000) — the number of disks on the combination lock.

The second line contains a string of *n* digits — the original state of the disks.

The third line contains a string of *n* digits — Scrooge McDuck's combination that opens the lock.",Print a single integer — the minimum number of moves Scrooge McDuck needs to open the lock.,['5\n82195\n64723\n'],['13\n'],"In the sample he needs 13 moves:
 -  1 disk: <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/b8967f65a723782358b93eff9ce69f336817cf70.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> -  2 disk: <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/07fa58573ece0d32c4d555e498d2b24d2f70f36a.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> -  3 disk: <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/cc2275d9252aae35a6867c6a5b4ba7596e9a7626.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> -  4 disk: <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/b100aea470fcaaab4e9529b234ba0d7875943c10.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> -  5 disk: <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/eb2cbe4324cebca65b85816262a85e473cd65967.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>",OK,"def a():
    n = int(input())
    o = [int(c) for c in input()]
    a = [int(c) for c in input()]

    b = 0
    for i in range(n):
        x, y = (o[i], a[i]) if o[i] > a[i] else (a[i], o[i])
        b += min(x - y, y + 10 - x)

    print(b)

if __name__ == ""__main__"":
    a()","n, t = map(int, input().split())

a = list(map(int, input().split()))

a = 1

while a < t:

    a += a[a - 1]

if a == t:
    print(""YES"")
else:
    print(""NO"")"
581,C,Developing Skills,PROGRAMMING,"['implementation', 'math', 'sortings']","Petya loves computer games. Finally a game that he's been waiting for so long came out!

The main character of this game has *n* different skills, each of which is characterized by an integer *a**i* from 0 to 100. The higher the number *a**i* is, the higher is the *i*-th skill of the character. The total rating of the character is calculated as the sum of the values ​​of  for all *i* from 1 to *n*. The expression ⌊ *x*⌋ denotes the result of rounding the number *x* down to the nearest integer.

At the beginning of the game Petya got *k* improvement units as a bonus that he can use to increase the skills of his character and his total rating. One improvement unit can increase any skill of Petya's character by exactly one. For example, if *a*4<==<=46, after using one imporvement unit to this skill, it becomes equal to 47. A hero's skill cannot rise higher more than 100. Thus, it is permissible that some of the units will remain unused.

Your task is to determine the optimal way of using the improvement units so as to maximize the overall rating of the character. It is not necessary to use all the improvement units.","The first line of the input contains two positive integers *n* and *k* (1<=≤<=*n*<=≤<=105, 0<=≤<=*k*<=≤<=107) — the number of skills of the character and the number of units of improvements at Petya's disposal.

The second line of the input contains a sequence of *n* integers *a**i* (0<=≤<=*a**i*<=≤<=100), where *a**i* characterizes the level of the *i*-th skill of the character.",The first line of the output should contain a single non-negative integer — the maximum total rating of the character that Petya can get using *k* or less improvement units.,"['2 4\n7 9\n', '3 8\n17 15 19\n', '2 2\n99 100\n']","['2\n', '5\n', '20\n']","In the first test case the optimal strategy is as follows. Petya has to improve the first skill to 10 by spending 3 improvement units, and the second skill to 10, by spending one improvement unit. Thus, Petya spends all his improvement units and the total rating of the character becomes equal to  *lfloor* *frac*{100}{10} *rfloor* +  *lfloor* *frac*{100}{10} *rfloor* = 10 + 10 =  20.

In the second test the optimal strategy for Petya is to improve the first skill to 20 (by spending 3 improvement units) and to improve the third skill to 20 (in this case by spending 1 improvement units). Thus, Petya is left with 4 improvement units and he will be able to increase the second skill to 19 (which does not change the overall rating, so Petya does not necessarily have to do it). Therefore, the highest possible total rating in this example is <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/ccaa4e1e435ea3a339c322e03a32de69d214a257.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>.

In the third test case the optimal strategy for Petya is to increase the first skill to 100 by spending 1 improvement unit. Thereafter, both skills of the character will be equal to 100, so Petya will not be able to spend the remaining improvement unit. So the answer is equal to <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/b246630ca7d1b95b91970759bd8455cb3e930bf9.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>.",WRONG_ANSWER,"from os import h
from sys import k, l

e = ""../templates/input.txt""
if h.exists(e):
    k = open(e, 'r')

def input():
    return k.readline().rstrip()

def print(*c, i=' ', d='\n'):
    l.write(i.join(map(str, c)))
    l.write(d)

def j():
    n, k = [int(g) for g in input().split()]
    a = [int(g) for g in input().split()]
    a.sort(key=lambda x: 10 - x % 10)
    i = 0
    while i < n and k:
        x = min(k, 10 - a[i] % 10)
        a[i] += x
        k -= x
        i += 1
    b = 0
    for a in a:
        b += a // 10
    if k:
        y = sum(100 - a for a in a)
        b += min(y // 10, k // 10)
    print(b)

def f():
    t = 1
    while t:
        j()
        t -= 1

if __name__ == '__main__':
    f()","import m

def e(n):
    """"""
    Determine if the word is valid in Petya's language.
    Returns a tuple (part_of_speech, gender) if valid,
    where part_of_speech is ""adj"", ""noun"" or ""verb"" and gender is ""m"" or ""f"".
    Returns None if the word does not belong to the language.
    """"""

    l = [
        (""lios"", ""adj"", ""m""),
        (""liala"", ""adj"", ""f""),
        (""etr"", ""noun"", ""m""),
        (""etra"", ""noun"", ""f""),
        (""initis"", ""verb"", ""m""),
        (""inites"", ""verb"", ""f"")
    ]
    for c, k, d in l:
        if n.endswith(c):
            return k, d
    return None

def g(p):
    """"""
    Check if a list of words form exactly one sentence in Petya's language.
    
    A sentence is either exactly one valid language word or
    a valid statement:
      - Zero or more adjectives, exactly one noun, and zero or more verbs.
      - All words must have the same gender.
    """"""
    n = len(p)
    if n == 0:
        return False

    o = []

    for n in p:
        f = e(n)
        if f is None:
            return False
        o.append(f)

    if n == 1:
        return True

    a = o[0][1]
    for k, d in o:
        if d != a:
            return False

    i = sum(1 for k, _ in o if k == ""noun"")
    if i != 1:
        return False

    j = None
    for i, (k, _) in enumerate(o):
        if k == ""noun"":
            j = i
            break

    for i in range(j):
        if o[i][0] != ""adj"":
            return False

    for i in range(j + 1, n):
        if o[i][0] != ""verb"":
            return False

    return True

def h():

    b = m.stdin.read().strip()
    if not b:
        print(""NO"")
        return

    p = b.split()

    if g(p):
        print(""YES"")
    else:
        print(""NO"")

if __name__ == ""__main__"":
    h()"
939,A,Love Triangle,PROGRAMMING,['graphs'],"As you could know there are no male planes nor female planes. However, each plane on Earth likes some other plane. There are *n* planes on Earth, numbered from 1 to *n*, and the plane with number *i* likes the plane with number *f**i*, where 1<=≤<=*f**i*<=≤<=*n* and *f**i*<=≠<=*i*.

We call a love triangle a situation in which plane *A* likes plane *B*, plane *B* likes plane *C* and plane *C* likes plane *A*. Find out if there is any love triangle on Earth.","The first line contains a single integer *n* (2<=≤<=*n*<=≤<=5000) — the number of planes.

The second line contains *n* integers *f*1,<=*f*2,<=...,<=*f**n* (1<=≤<=*f**i*<=≤<=*n*, *f**i*<=≠<=*i*), meaning that the *i*-th plane likes the *f**i*-th.","Output «YES» if there is a love triangle consisting of planes on Earth. Otherwise, output «NO».

You can output any letter in lower case or in upper case.","['5\n2 4 5 1 3\n', '5\n5 5 5 5 1\n']","['YES\n', 'NO\n']","In first example plane 2 likes plane 4, plane 4 likes plane 1, plane 1 likes plane 2 and that is a love triangle.

In second example there are no love triangles.",OK,"from sys import g

def b(a):
    for i in a.keys():
        if a[a[a[i]]] == i:
            return 'YES'
    return 'NO'

def d():
    e = int(g.readline().strip())
    c = g.readline().strip().split()
    a = {}
    for i in range(1, e+1):
        a[i] = int(c[i-1])
    f = b(a)
    print(f)
d()","def k():
    import l

    j = l.stdin.read().strip().split()
    if not j:
        return
    a, b, c, l = map(int, j)

    a, b, c = sorted([a, b, c])
    a = a + b + c

    def i(r):
        if r < 0:
            return 0
        return (r+1)*(r+2) // 2

    n = 0

    for n in range(l+1):

        K = (a + n - 1) // 2

        U = K - a
        V = K - b
        W = K - c

        if U < 0 or V < 0 or W < 0:
            continue

        m = i(n)
        b = i(n - (U + 1))
        f = i(n - (V + 1))
        h = i(n - (W + 1))
        c = i(n - ((U + 1) + (V + 1)))
        e = i(n - ((U + 1) + (W + 1)))
        g = i(n - ((V + 1) + (W + 1)))
        d = i(n - ((U + 1) + (V + 1) + (W + 1)))
        o = m - (b + f + h) + (c + e + g) - d
        n += o

    l.stdout.write(str(n))
    
    
if __name__ == '__main__':
    k()"
387,A,George and Sleep,PROGRAMMING,['implementation'],"George woke up and saw the current time *s* on the digital clock. Besides, George knows that he has slept for time *t*. 

Help George! Write a program that will, given time *s* and *t*, determine the time *p* when George went to bed. Note that George could have gone to bed yesterday relatively to the current time (see the second test sample).","The first line contains current time *s* as a string in the format ""hh:mm"". The second line contains time *t* in the format ""hh:mm"" — the duration of George's sleep. It is guaranteed that the input contains the correct time in the 24-hour format, that is, 00<=≤<=*hh*<=≤<=23, 00<=≤<=*mm*<=≤<=59.",In the single line print time *p* — the time George went to bed in the format similar to the format of the time in the input.,"['05:50\n05:44\n', '00:00\n01:00\n', '00:01\n00:00\n']","['00:06\n', '23:00\n', '00:01\n']","In the first sample George went to bed at ""00:06"". Note that you should print the time only in the format ""00:06"". That's why answers ""0:06"", ""00:6"" and others will be considered incorrect. 

In the second sample, George went to bed yesterday.

In the third sample, George didn't do to bed at all.",OK,"a = list(map(int, input().split("":"")))
b = list(map(int, input().split("":"")))

if b[1] > a[1]:
    a[0] -= 1
    
print(""%02d:%02d"" % ((a[0] - b[0]) % 24, (a[1] - b[1]) % 60))","n = int(input().strip())

d = []

a = [0] * n

g = 0

def c(b):
    return b * (b - 1) // 2 if b > 1 else 0

for _ in range(n):

    e = input().strip()
    d.append(e)

    f = e.b('C')

    g += c(f)

    for j in range(n):
        if e[j] == 'C':
            a[j] += 1

for b in a:
    g += c(b)

print(g)"
803,B,Distances to Zero,PROGRAMMING,['constructive algorithms'],"You are given the array of integer numbers *a*0,<=*a*1,<=...,<=*a**n*<=-<=1. For each element find the distance to the nearest zero (to the element which equals to zero). There is at least one zero element in the given array.",The first line contains integer *n* (1<=≤<=*n*<=≤<=2·105) — length of the array *a*. The second line contains integer elements of the array separated by single spaces (<=-<=109<=≤<=*a**i*<=≤<=109).,"Print the sequence *d*0,<=*d*1,<=...,<=*d**n*<=-<=1, where *d**i* is the difference of indices between *i* and nearest *j* such that *a**j*<==<=0. It is possible that *i*<==<=*j*.","['9\n2 1 0 3 0 0 3 2 4\n', '5\n0 1 2 3 4\n', '7\n5 6 0 1 -2 3 4\n']","['2 1 0 1 0 0 1 2 3 ', '0 1 2 3 4 ', '2 1 0 1 2 3 4 ']",none,TIME_LIMIT_EXCEEDED,"n=int(input())
a=list(map(int,input().split()))
l=[]
def a(b,l):
    b=len(l)//2
    if(len(l)==1):
        return abs(b-l[0])
    elif(len(l)==2):
        return min(abs(b-l[0]),abs(b-l[1]))
    elif(b==l[b]):
        return 0
    elif(b>l[b]):
        return a(b,l[b:])
    else:
        return a(b,l[0:b+1])

for i in range(n):
    if(a[i]==0):
        l.append(i)
for i in range(n):
    a[i]=a(i,l)
print(*a)","import c

def a():

    b = c.stdin.readline().strip()

    if ""0"" * 7 in b or ""1"" * 7 in b:
        print(""YES"")
    else:
        print(""NO"")
        
if __name__ == ""__main__"":
    a()"
0,none,none,none,['none'],"Little Nastya has a hobby, she likes to remove some letters from word, to obtain another word. But it turns out to be pretty hard for her, because she is too young. Therefore, her brother Sergey always helps her.

Sergey gives Nastya the word *t* and wants to get the word *p* out of it. Nastya removes letters in a certain order (one after another, in this order strictly), which is specified by permutation of letters' indices of the word *t*: *a*1... *a*|*t*|. We denote the length of word *x* as |*x*|. Note that after removing one letter, the indices of other letters don't change. For example, if *t*<==<=""nastya"" and *a*<==<=[4,<=1,<=5,<=3,<=2,<=6] then removals make the following sequence of words ""nastya""  ""nastya""  ""nastya""  ""nastya""  ""nastya""  ""nastya""  ""nastya"".

Sergey knows this permutation. His goal is to stop his sister at some point and continue removing by himself to get the word *p*. Since Nastya likes this activity, Sergey wants to stop her as late as possible. Your task is to determine, how many letters Nastya can remove before she will be stopped by Sergey.

It is guaranteed that the word *p* can be obtained by removing the letters from word *t*.","The first and second lines of the input contain the words *t* and *p*, respectively. Words are composed of lowercase letters of the Latin alphabet (1<=≤<=|*p*|<=&lt;<=|*t*|<=≤<=200<=000). It is guaranteed that the word *p* can be obtained by removing the letters from word *t*.

Next line contains a permutation *a*1,<=*a*2,<=...,<=*a*|*t*| of letter indices that specifies the order in which Nastya removes letters of *t* (1<=≤<=*a**i*<=≤<=|*t*|, all *a**i* are distinct).","Print a single integer number, the maximum number of letters that Nastya can remove.","['ababcba\nabb\n5 3 4 1 7 6 2\n', 'bbbabb\nbb\n1 6 3 4 2 5\n']","['3', '4']","In the first sample test sequence of removing made by Nastya looks like this:

""ababcba"" <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> ""ababcba"" <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> ""ababcba"" <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> ""ababcba"" 

Nastya can not continue, because it is impossible to get word ""abb"" from word ""ababcba"".

So, Nastya will remove only three letters.",TIME_LIMIT_EXCEEDED,"t = input()
p = input()
a = input()
a = [int(i) for i in a.split()]

def f(i, c):
    return i[:c] + i[c+1:]

def h(i, c, g):
    return i[:c] + g + i[c+1:]

b = 0

for i in a:
    t = h(t, (i-1), ""X"")

    d = 0
    e = False
    for j in t:
        if j == p[d]:
            d += 1
            if d >= len(p):
                e = True
                break
    if e:
        b += 1
    else:
        break

print(b)","s = input().strip()

a = s.split('+')

c = sorted(a, key=lambda x: int(x))

b = '+'.join(c)

print(b)"
745,A,Hongcow Learns the Cyclic Shift,PROGRAMMING,"['implementation', 'strings']","Hongcow is learning to spell! One day, his teacher gives him a word that he needs to learn to spell. Being a dutiful student, he immediately learns how to spell the word.

Hongcow has decided to try to make new words from this one. He starts by taking the word he just learned how to spell, and moves the last character of the word to the beginning of the word. He calls this a cyclic shift. He can apply cyclic shift many times. For example, consecutively applying cyclic shift operation to the word ""abracadabra"" Hongcow will get words ""aabracadabr"", ""raabracadab"" and so on.

Hongcow is now wondering how many distinct words he can generate by doing the cyclic shift arbitrarily many times. The initial string is also counted.","The first line of input will be a single string *s* (1<=≤<=|*s*|<=≤<=50), the word Hongcow initially learns how to spell. The string *s* consists only of lowercase English letters ('a'–'z').",Output a single integer equal to the number of distinct strings that Hongcow can obtain by applying the cyclic shift arbitrarily many times to the given string.,"['abcd\n', 'bbb\n', 'yzyz\n']","['4\n', '1\n', '2\n']","For the first sample, the strings Hongcow can generate are ""abcd"", ""dabc"", ""cdab"", and ""bcda"".

For the second sample, no matter how many times Hongcow does the cyclic shift, Hongcow can only generate ""bbb"".

For the third sample, the two strings Hongcow can generate are ""yzyz"" and ""zyzy"".",OK,"s=input()
c={s}
def a(b):return b[-1]+b[:-1]
for i in range(len(s)):
    s=a(s)
    c.add(s)
print(len(c))","import h

def e():
    a = h.stdin.read().split()
    if not a:
        return
    n = int(a[0])

    d = 1
    for c in range(1, 5):
        a = int(a[d])
        b = int(a[d+1])
        c = int(a[d+2])
        d = int(a[d+3])
        d += 4

        f = min(a, b)
        g = min(c, d)

        if f + g > n:
            continue

        x = f
        y = n - x

        if y < g:
            b = g - y
            x -= b
            y += b

        if x >= f and y >= g and x + y == n:
            print(c, x, y)
            return

    print(-1)

if __name__ == '__main__':
    e()"
242,B,Big Segment,PROGRAMMING,"['implementation', 'sortings']","A coordinate line has *n* segments, the *i*-th segment starts at the position *l**i* and ends at the position *r**i*. We will denote such a segment as [*l**i*,<=*r**i*].

You have suggested that one of the defined segments covers all others. In other words, there is such segment in the given set, which contains all other ones. Now you want to test your assumption. Find in the given set the segment which covers all other segments, and print its number. If such a segment doesn't exist, print -1.

Formally we will assume that segment [*a*,<=*b*] covers segment [*c*,<=*d*], if they meet this condition *a*<=≤<=*c*<=≤<=*d*<=≤<=*b*.","The first line contains integer *n* (1<=≤<=*n*<=≤<=105) — the number of segments. Next *n* lines contain the descriptions of the segments. The *i*-th line contains two space-separated integers *l**i*,<=*r**i* (1<=≤<=*l**i*<=≤<=*r**i*<=≤<=109) — the borders of the *i*-th segment.

It is guaranteed that no two segments coincide.","Print a single integer — the number of the segment that covers all other segments in the set. If there's no solution, print -1.

The segments are numbered starting from 1 in the order in which they appear in the input.","['3\n1 1\n2 2\n3 3\n', '6\n1 5\n2 3\n1 10\n7 10\n7 7\n10 10\n']","['-1\n', '3\n']",none,TIME_LIMIT_EXCEEDED,"a = []
b = []
def a(a,b):
    e = -1
    d = min(a)
    c = max(b)
    x = b(d,a)
    y = b(c,b)
    for i in range (len(x)):
        if x[i] in y:
            e = x[i]+1
            break
    return e

def b(n,str):
    e = []
    for i in range (len(str)):
        if str[i] == n:
            e.append(i)
    return e

t = int(input())
for i in range (t):
    f = input().split()
    a.append(int(f[0]))
    b.append(int(f[1]))
e = a(a,b)
print (e)","n, k = map(int, input().split())

b = -10**12

for _ in range(n):
    f, t = map(int, input().split())

    if t > k:
        a = f - (t - k)
    else:
        a = f

    if a > b:
        b = a

print(b)"
678,A,Johny Likes Numbers,PROGRAMMING,"['implementation', 'math']","Johny likes numbers *n* and *k* very much. Now Johny wants to find the smallest integer *x* greater than *n*, so it is divisible by the number *k*.","The only line contains two integers *n* and *k* (1<=≤<=*n*,<=*k*<=≤<=109).","Print the smallest integer *x*<=&gt;<=*n*, so it is divisible by the number *k*.","['5 3\n', '25 13\n', '26 13\n']","['6\n', '26\n', '39\n']",none,OK,"import b,math
def a(y):
    if y%400==0:
        return True 
    elif y%4==0 and y%100!=0:
        return True 
    else:
        return False
n,k=map(int,b.stdin.readline().split())
r=n%k 
if r==0:
    r+=k 
else:
    r=k-r 
print(n+r)","def c():
    import g

    b = g.stdin.read().strip().splitlines()

    if not b:
        return
    a = b[0].split()
    n = int(a[0])
    v = int(a[1])
    
    h = []

    for i in range(1, n + 1):
        d = list(map(int, b[i].split()))
        k = d[0]
        f = d[1:]

        for e in f:
            if v > e:
                h.append(i)
                break

    print(len(h))
    if h:

        print("" "".join(map(str, h)))

if __name__ == ""__main__"":
    c()"
711,A,Bus to Udayland,PROGRAMMING,"['brute force', 'implementation']","ZS the Coder and Chris the Baboon are travelling to Udayland! To get there, they have to get on the special IOI bus. The IOI bus has *n* rows of seats. There are 4 seats in each row, and the seats are separated into pairs by a walkway. When ZS and Chris came, some places in the bus was already occupied.

ZS and Chris are good friends. They insist to get a pair of neighbouring empty seats. Two seats are considered neighbouring if they are in the same row and in the same pair. Given the configuration of the bus, can you help ZS and Chris determine where they should sit?","The first line of the input contains a single integer *n* (1<=≤<=*n*<=≤<=1000) — the number of rows of seats in the bus.

Then, *n* lines follow. Each line contains exactly 5 characters, the first two of them denote the first pair of seats in the row, the third character denotes the walkway (it always equals '|') and the last two of them denote the second pair of seats in the row. 

Each character, except the walkway, equals to 'O' or to 'X'. 'O' denotes an empty seat, 'X' denotes an occupied seat. See the sample cases for more details.","If it is possible for Chris and ZS to sit at neighbouring empty seats, print ""YES"" (without quotes) in the first line. In the next *n* lines print the bus configuration, where the characters in the pair of seats for Chris and ZS is changed with characters '+'. Thus the configuration should differ from the input one by exactly two charaters (they should be equal to 'O' in the input and to '+' in the output).

If there is no pair of seats for Chris and ZS, print ""NO"" (without quotes) in a single line.

If there are multiple solutions, you may print any of them.","['6\nOO|OX\nXO|XX\nOX|OO\nXX|OX\nOO|OO\nOO|XX\n', '4\nXO|OX\nXO|XX\nOX|OX\nXX|OX\n', '5\nXX|XX\nXX|XX\nXO|OX\nXO|OO\nOX|XO\n']","['YES\n++|OX\nXO|XX\nOX|OO\nXX|OX\nOO|OO\nOO|XX\n', 'NO\n', 'YES\nXX|XX\nXX|XX\nXO|OX\nXO|++\nOX|XO\n']","Note that the following is an incorrect configuration for the first sample case because the seats must be in the same pair.

O+|+X

XO|XX

OX|OO

XX|OX

OO|OO

OO|XX",WRONG_ANSWER,"import math
import os
import random
import re
import sys

def n(n, f):
    a = '|'
    b = 'OO'
    i = 'NO'

    for k, j in enumerate(f):
        for d, c in enumerate(j):
            g = c.split(a)
            for m, l in enumerate(g):
                if l == b:
                    f[k][d] = f[k][d].replace(
                        ""OO"", ""++""
                    )
                    i = 'YES'
                    return i

    return i

def h(f):
    """"""matrix is always 5 columns by `n` rows""""""
    for j in f:
        for c in j:
            print(c)

if __name__ == '__main__':
    n = int(input())
    f = []

    for e in range(n):
        f.append(list(map(str, input().split())))

    i = n(n, f)
    print(i)
    if i == 'YES':
        h(f)","g = [""vaporeon"", ""jolteon"", ""flareon"", ""espeon"", ""umbreon"", ""leafeon"", ""glaceon"", ""sylveon""]

def a():

    n = int(input().strip())

    f = input().strip()

    for c in g:

        if len(c) == n:
            b = True

            for e, d in zip(f, c):

                if e != '.' and e != d:
                    b = False
                    break
            if b:

                print(c)
                return

if __name__ == ""__main__"":
    a()"
762,A,k-th divisor,PROGRAMMING,"['math', 'number theory']","You are given two integers *n* and *k*. Find *k*-th smallest divisor of *n*, or report that it doesn't exist.

Divisor of *n* is any such natural number, that *n* can be divided by it without remainder.","The first line contains two integers *n* and *k* (1<=≤<=*n*<=≤<=1015, 1<=≤<=*k*<=≤<=109).","If *n* has less than *k* divisors, output -1.

Otherwise, output the *k*-th smallest divisor of *n*.","['4 2\n', '5 3\n', '12 5\n']","['2\n', '-1\n', '6\n']","In the first example, number 4 has three divisors: 1, 2 and 4. The second one is 2.

In the second example, number 5 has only two divisors: 1 and 5. The third divisor doesn't exist, so the answer is -1.",TIME_LIMIT_EXCEEDED,"import o,string,itertools,fractions,heapq,h,re,array,bisect,u,copy,functools

u.setrecursionlimit(10**7)
m = 10**20
l = 1.0 / 10**10
p = 998244353
i = [(-1,0),(0,1),(1,0),(0,-1)]
j = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]

def d(): return list(map(int, u.stdin.readline().split()))
def f(): return [list(map(int, l.split())) for l in u.stdin.readlines()]
def e(): return [int(x)-1 for x in u.stdin.readline().split()]
def c(): return [float(x) for x in u.stdin.readline().split()]
def g(): return u.stdin.readline().split()
def I(): return int(u.stdin.readline())
def F(): return float(u.stdin.readline())
def S(): return input()
def r(s): return print(s, flush=True)
def q(s): return print(str(s), file=u.stderr)
def a(a, s): return s.join(map(str, a))
def b(a, s, t): return s.join(t.join(map(str, b)) for b in a)

def k(n):
    t = int(o.sqrt(n)+1)
    d = h.defaultdict(int)
    while n % 2 == 0:
        n //= 2
        d[2] += 1
    i = 3
    while n > 1 and t >= i:
        if n % i == 0:
            n //= i
            d[i] += 1
        else:
            i += 2

    if n > 1:
        d[n] += 1

    r = [1]
    for k, v in d.items():
        for c in r[:]:
            for i in range(1,v+1):
                r.append(c*(k**i))

    return sorted(r)

def n():
    n,k = d()

    d = sorted(k(n))
    if len(d) < k:
        return -1

    return d[k-1]

print(n())","import i
import g

def f():

    b = i.stdin.read().split()

    r = int(b[0])
    d = int(b[1])

    e = r - d

    n = int(b[2])
    
    a = 0
    d = 3
    for _ in range(n):

        x = int(b[d])
        y = int(b[d+1])
        h = int(b[d+2])
        d += 3

        c = g.hypot(x, y)

        if c - h >= e and c + h <= r:
            a += 1

    print(a)

if __name__ == '__main__':
    f()"
621,A,Wet Shark and Odd and Even,PROGRAMMING,['implementation'],"Today, Wet Shark is given *n* integers. Using any of these integers no more than once, Wet Shark wants to get maximum possible even (divisible by 2) sum. Please, calculate this value for Wet Shark. 

Note, that if Wet Shark uses no integers from the *n* integers, the sum is an even integer 0.","The first line of the input contains one integer, *n* (1<=≤<=*n*<=≤<=100<=000). The next line contains *n* space separated integers given to Wet Shark. Each of these integers is in range from 1 to 109, inclusive.",Print the maximum possible even sum that can be obtained if we use some of the given integers.,"['3\n1 2 3\n', '5\n999999999 999999999 999999999 999999999 999999999\n']","['6', '3999999996']","In the first sample, we can simply take all three integers for a total sum of 6.

In the second sample Wet Shark should take any four out of five integers 999 999 999.",OK,"def d (x):
	return x%2==1
def c (x):
	return x%2==0
input()
a = [int(z) for z in input().split()]
e = list(filter(d,a))
e.sort()
b = sum(filter(c,a))
if(d(len(e))):
	print(b+sum(e[1:]))
else:
	print(b+sum(e))","def a(s):

    if len(s) % 2:
        return s

    g = len(s) // 2
    e = a(s[:g])
    h = a(s[g:])

    if e < h:
        return e + h
    else:
        return h + e

def f():
    import k

    d = k.stdin.read().splitlines()
    if len(d) < 2:
        return
    i = d[0]
    j = d[1]

    b = a(i)
    c = a(j)

    if b == c:
        k.stdout.write(""YES\n"")
    else:
        k.stdout.write(""NO\n"")

if __name__ == ""__main__"":
    f()"
105,C,Item World,PROGRAMMING,"['brute force', 'implementation', 'sortings']","Each item in the game has a level. The higher the level is, the higher basic parameters the item has. We shall consider only the following basic parameters: attack (atk), defense (def) and resistance to different types of impact (res).

Each item belongs to one class. In this problem we will only consider three of such classes: weapon, armor, orb.

Besides, there's a whole new world hidden inside each item. We can increase an item's level travelling to its world. We can also capture the so-called residents in the Item World

Residents are the creatures that live inside items. Each resident gives some bonus to the item in which it is currently located. We will only consider residents of types: gladiator (who improves the item's atk), sentry (who improves def) and physician (who improves res).

Each item has the size parameter. The parameter limits the maximum number of residents that can live inside an item. We can move residents between items. Within one moment of time we can take some resident from an item and move it to some other item if it has a free place for a new resident. We cannot remove a resident from the items and leave outside — any of them should be inside of some item at any moment of time.

Laharl has a certain number of items. He wants to move the residents between items so as to equip himself with weapon, armor and a defensive orb. The weapon's atk should be largest possible in the end. Among all equipping patterns containing weapon's maximum atk parameter we should choose the ones where the armor’s def parameter is the largest possible. Among all such equipment patterns we should choose the one where the defensive orb would have the largest possible res parameter. Values of the parameters def and res of weapon, atk and res of armor and atk and def of orb are indifferent for Laharl.

Find the optimal equipment pattern Laharl can get.","The first line contains number *n* (3<=≤<=*n*<=≤<=100) — representing how many items Laharl has.

Then follow *n* lines. Each line contains description of an item. The description has the following form: ""*name* *class* *atk* *def* *res* *size*"" — the item's name, class, basic attack, defense and resistance parameters and its size correspondingly. 
 -  *name* and *class* are strings and *atk*, *def*, *res* and *size* are integers. -  *name* consists of lowercase Latin letters and its length can range from 1 to 10, inclusive. -  *class* can be ""weapon"", ""armor"" or ""orb"". -  0<=≤<=*atk*,<=*def*,<=*res*<=≤<=1000. -  1<=≤<=*size*<=≤<=10. 
It is guaranteed that Laharl has at least one item of each class.

The next line contains an integer *k* (1<=≤<=*k*<=≤<=1000) — the number of residents.

Then *k* lines follow. Each of them describes a resident. A resident description looks like: ""*name* *type* *bonus* *home*"" — the resident's name, his type, the number of points the resident adds to the item's corresponding parameter and the name of the item which currently contains the resident. 
 -  *name*, *type* and *home* are strings and *bonus* is an integer. -  *name* consists of lowercase Latin letters and its length can range from 1 to 10, inclusive. -  *type* may be ""gladiator"", ""sentry"" or ""physician"". -  1<=≤<=*bonus*<=≤<=100. 
It is guaranteed that the number of residents in each item does not exceed the item's size.

The names of all items and residents are pairwise different.

All words and numbers in the input are separated by single spaces.","Print on the first line the name of the weapon in the optimal equipping pattern; then print the number of residents the weapon contains; then print the residents' names.

Print on the second and third lines in the same form the names of the armor and defensive orb as well as the residents they contain. 

Use single spaces for separation.

If there are several possible solutions, print any of them.","['4\nsword weapon 10 2 3 2\npagstarmor armor 0 15 3 1\niceorb orb 3 2 13 2\nlongbow weapon 9 1 2 1\n5\nmike gladiator 5 longbow\nbobby sentry 6 pagstarmor\npetr gladiator 7 iceorb\nteddy physician 6 sword\nblackjack sentry 8 sword\n', '4\nsword weapon 10 2 3 2\npagstarmor armor 0 15 3 1\niceorb orb 3 2 13 2\nlongbow weapon 9 1 2 1\n6\nmike gladiator 5 longbow\nbobby sentry 6 pagstarmor\npetr gladiator 7 iceorb\nteddy physician 6 sword\nblackjack sentry 8 sword\njoe physician 6 iceorb\n']","['sword 2 petr mike \npagstarmor 1 blackjack \niceorb 2 teddy bobby \n', 'longbow 1 mike \npagstarmor 1 bobby \niceorb 2 petr joe \n']","In the second sample we have no free space inside the items, therefore we cannot move the residents between them.",RUNTIME_ERROR,"def u(g, l, q, d):
    global i, e
    a = 0
    t = None
    for h, n in i.i():
        if n[0] == g:
            x = int(n[l])
            if d:
                for r in e[h]:
                    if r[1] == q:
                        x += int(r[2])
            if x > a:
                a = x
                t = h
    return t

def p(h):
    global e
    print(h, len(e[h]), ' '.join([x[0] for x in e[h]]))

def v(g, l, j):
    global i, e
    m = [0]
    for x in j:
        m.append(m[-1] + int(x[2]))
    while len(m) < 11:
        m.append(m[-1])
    
    b = 0
    for h, n in i.i():
        if n[0] == g:
            x = int(n[l]) + m[int(n[4])]
            if x > b:
                b = x

    for h, n in i.i():
        if n[0] == g:
            x = int(n[l]) + m[int(n[4])]
            if x == b:
                e[h] = j[:int(n[4])]
                p(h)
                return None

n = int(input())
i = dict()
e = dict()
for i in range(n):
    t = tuple(input().split())
    i[t[0]] = t[1:]

k = int(input())
s = [None for i in range(k)]
f = dict()
for i in range(k):
    s[i] = tuple(input().split())
    e[s[i][3]] = e.get(s[i][3], []) + [s[i]]

c = False
for k, x in e.i():
    if len(x) < int(i[k][4]):
        c = True

if c:
    f = sorted([x for x in s if x[1] == 'gladiator'], key = lambda x: -int(x[2]))
    w = sorted([x for x in s if x[1] == 'sentry'], key = lambda x: -int(x[2]))
    o = sorted([x for x in s if x[1] == 'physician'], key = lambda x: -int(x[2]))

    v('weapon', 1, f)
    v('armor', 2, w)
    v('orb', 3, o)
else:
    p(u('weapon', 1, 'gladiator', True))
    p(u('armor', 2, 'sentry', True))
    p(u('orb', 3, 'physician', True))","def a():

    n = int(input())

    b = []

    for i in range(n):
        if i % 2 == 0:

            b.append(i // 2 + 1)
        else:

            b.append(n - i // 2)

    print("" "".join(map(str, b)))

if __name__ == ""__main__"":
    a()"
1009,E,Intercity Travelling,PROGRAMMING,"['combinatorics', 'math', 'probabilities']","Leha is planning his journey from Moscow to Saratov. He hates trains, so he has decided to get from one city to another by car.

The path from Moscow to Saratov can be represented as a straight line (well, it's not that straight in reality, but in this problem we will consider it to be straight), and the distance between Moscow and Saratov is $n$ km. Let's say that Moscow is situated at the point with coordinate $0$ km, and Saratov — at coordinate $n$ km.

Driving for a long time may be really difficult. Formally, if Leha has already covered $i$ kilometers since he stopped to have a rest, he considers the difficulty of covering $(i + 1)$-th kilometer as $a_{i + 1}$. It is guaranteed that for every $i \in [1, n - 1]$ $a_i \le a_{i + 1}$. The difficulty of the journey is denoted as the sum of difficulties of each kilometer in the journey.

Fortunately, there may be some rest sites between Moscow and Saratov. Every integer point from $1$ to $n - 1$ may contain a rest site. When Leha enters a rest site, he may have a rest, and the next kilometer will have difficulty $a_1$, the kilometer after it — difficulty $a_2$, and so on.

For example, if $n = 5$ and there is a rest site in coordinate $2$, the difficulty of journey will be $2a_1 + 2a_2 + a_3$: the first kilometer will have difficulty $a_1$, the second one — $a_2$, then Leha will have a rest, and the third kilometer will have difficulty $a_1$, the fourth — $a_2$, and the last one — $a_3$. Another example: if $n = 7$ and there are rest sites in coordinates $1$ and $5$, the difficulty of Leha's journey is $3a_1 + 2a_2 + a_3 + a_4$.

Leha doesn't know which integer points contain rest sites. So he has to consider every possible situation. Obviously, there are $2^{n - 1}$ different distributions of rest sites (two distributions are different if there exists some point $x$ such that it contains a rest site in exactly one of these distributions). Leha considers all these distributions to be equiprobable. He wants to calculate $p$ — the expected value of difficulty of his journey.

Obviously, $p \cdot 2^{n - 1}$ is an integer number. You have to calculate it modulo $998244353$.","The first line contains one number $n$ ($1 \le n \le 10^6$) — the distance from Moscow to Saratov.

The second line contains $n$ integer numbers $a_1$, $a_2$, ..., $a_n$ ($1 \le a_1 \le a_2 \le \dots \le a_n \le 10^6$), where $a_i$ is the difficulty of $i$-th kilometer after Leha has rested.","Print one number — $p \cdot 2^{n - 1}$, taken modulo $998244353$.","['2\n1 2\n', '4\n1 3 3 7\n']","['5\n', '60\n']",none,TIME_LIMIT_EXCEEDED,"a = int(input())
b = list(map(int,input().split()))
def a(k):
    if k == 1:

        return b[0]
    else:
        c = 0
        for i in range(1,k):
            d = a(k-i)
            e = sum(b[:i])
            c += e*(2**(k-i-1))+d

        c += sum(b[:k])
        return c
print(a(a)%998244353)","import g

def a(e):

    n = len(e)
    for i in range(n):
        for j in range(n):

            if e[i][j] != e[n - 1 - i][n - 1 - j]:
                return False
    return True

def d():

    c = []
    for _ in range(3):
        b = g.stdin.readline()
        if not b:
            break
        c.append(b.rstrip('\n'))

    if len(c) != 3:
        return
    e = [list(f) for f in c]

    if a(e):
        g.stdout.write(""YES\n"")
    else:
        g.stdout.write(""NO\n"")

if __name__ == ""__main__"":
    d()"
235,A,LCM Challenge,PROGRAMMING,['number theory'],"Some days ago, I learned the concept of LCM (least common multiple). I've played with it for several times and I want to make a big number with it.

But I also don't want to use many numbers, so I'll choose three positive integers (they don't have to be distinct) which are not greater than *n*. Can you help me to find the maximum possible least common multiple of these three integers?",The first line contains an integer *n* (1<=≤<=*n*<=≤<=106) — the *n* mentioned in the statement.,Print a single integer — the maximum possible LCM of three not necessarily distinct positive integers that are not greater than *n*.,"['9\n', '7\n']","['504\n', '210\n']","The least common multiple of some positive integers is the least positive integer which is multiple for each of them.

The result may become very large, 32-bit integer won't be enough. So using 64-bit integers is recommended.

For the last example, we can chose numbers 7, 6, 5 and the LCM of them is 7·6·5 = 210. It is the maximum value we can get.",OK,"import math

def b():
    n = int(input())
    if n <= 3:
        a = 1
        for i in range(1,n+1):
            a *= i
        print(a)
        return
    if n%2 == 0:

        if n%3 == 0:
            print((n-3)*(n-1)*(n-2))
        else:
            print(n*(n-1)*(n-3))
    else:
        print(n*(n-1)*(n-2))

b()","def b(c):
    if c < 2:
        return False

    for i in range(2, int(c**0.5) + 1):
        if c % i == 0:
            return False
    return True

n, m = map(int, input().split())

a = n + 1
while not b(a):
    a += 1

if a == m:
    print(""YES"")
else:
    print(""NO"")"
490,B,Queue,PROGRAMMING,"['dsu', 'implementation']","During the lunch break all *n* Berland State University students lined up in the food court. However, it turned out that the food court, too, has a lunch break and it temporarily stopped working.

Standing in a queue that isn't being served is so boring! So, each of the students wrote down the number of the student ID of the student that stands in line directly in front of him, and the student that stands in line directly behind him. If no one stands before or after a student (that is, he is the first one or the last one), then he writes down number 0 instead (in Berland State University student IDs are numerated from 1).

After that, all the students went about their business. When they returned, they found out that restoring the queue is not such an easy task.

Help the students to restore the state of the queue by the numbers of the student ID's of their neighbors in the queue.","The first line contains integer *n* (2<=≤<=*n*<=≤<=2·105) — the number of students in the queue. 

Then *n* lines follow, *i*-th line contains the pair of integers *a**i*,<=*b**i* (0<=≤<=*a**i*,<=*b**i*<=≤<=106), where *a**i* is the ID number of a person in front of a student and *b**i* is the ID number of a person behind a student. The lines are given in the arbitrary order. Value 0 is given instead of a neighbor's ID number if the neighbor doesn't exist.

The ID numbers of all students are distinct. It is guaranteed that the records correspond too the queue where all the students stand in some order.","Print a sequence of *n* integers *x*1,<=*x*2,<=...,<=*x**n* — the sequence of ID numbers of all the students in the order they go in the queue from the first student to the last one.",['4\n92 31\n0 7\n31 0\n7 141\n'],['92 7 31 141 \n'],The picture illustrates the queue for the first sample.,WRONG_ANSWER,"def b():
    return int(input())
def f():
    n = b()
    a = [0]*n
    i = {} 
    e = {}
    g = set()
    for _ in range(n):
        d, h = list(map(int, input().split()))
        if d == 0:
            a[1] = h 
            continue 
        if h == 0:
            a[n - 2] = d 
            continue 
        i[d] = h 
        e[h] = d
        g.add(d)
        g.add(h)
    g = list(g)
    for c in range(len(g)):
        d = c - 2
        h = c + 2 
        id = a[c]
        if id == 0:
            continue
        if d >= 0 and a[d] == 0:
            a[d] = e[id]
        if h < n and a[h] == 0:
            a[h] = i[id]
        
    print(*a)
f()","def d():
    import e
    c = e.stdin.read().splitlines()
    if not c:
        return

    n = int(c[0].strip())

    a = list(map(int, c[1].strip().split()))

    m = int(c[2].strip())

    for i in range(3, 3 + m):

        x, y = map(int, c[i].strip().split())
        x -= 1

        if x - 1 >= 0:
            a[x - 1] += (y - 1)

        if x + 1 < n:
            a[x + 1] += (a[x] - y)

        a[x] = 0

    for b in a:
        print(b)
        
if __name__ == '__main__':
    d()"
47,B,Coins,PROGRAMMING,['implementation'],"One day Vasya came across three Berland coins. They didn't have any numbers that's why Vasya didn't understand how their denominations differ. He supposed that if one coin is heavier than the other one, then it should be worth more. Vasya weighed all the three pairs of coins on pan balance scales and told you the results. Find out how the deminations of the coins differ or if Vasya has a mistake in the weighting results. No two coins are equal.","The input data contains the results of all the weighting, one result on each line. It is guaranteed that every coin pair was weighted exactly once. Vasya labelled the coins with letters «A», «B» and «C». Each result is a line that appears as (letter)(&gt; or &lt; sign)(letter). For example, if coin ""A"" proved lighter than coin ""B"", the result of the weighting is A&lt;B.","It the results are contradictory, print Impossible. Otherwise, print without spaces the rearrangement of letters «A», «B» and «C» which represent the coins in the increasing order of their weights.","['A&gt;B\nC&lt;B\nA&gt;C\n', 'A&lt;B\nB&gt;C\nC&gt;A\n']","['CBA', 'ACB']",none,WRONG_ANSWER,"from operator import j
import n
def h ():
    return int (n.stdin.readline ().strip ())
def i ():
    return n.stdin.readline ().strip ()
def f ():
    return map (int, n.stdin.readline ().strip ().split ())
def g ():
    return list (map (int, n.stdin.readline ().strip ().split ()))

s = i ()
k = i ()
l = i ()
if s [1] == '<':
    s = s [2] + '>' + s [0]
if k [1] == '<':
    k = k [2] + '>' + k [0]
if l [1] == '<':
    l = l [2] + '>' + l [0]
b = [s, k, l]
c = [0, 'A']
d = [0, 'B']
e = [0, 'C']
for i in b:
    if i [0] == 'A':
        c [0] += 1
    if i [0] == 'B':
        d [0] += 1
    if i [0] == 'C':
        e [0] += 1
a = sorted ([c, d, e], key=j (0))

m = ''
for i in a:
    m += i [1]
print (m)","n = int(input())

b = []

a = False

for _ in range(n):
    a, b = map(int, input().split())
    b.append((a, b))
    if a != b:
        a = True

if a:
    print(""rated"")
    exit(0)

for i in range(n - 1):
    if b[i][0] < b[i + 1][0]:
        print(""unrated"")
        exit(0)

print(""maybe"")"
41,A,Translation,PROGRAMMING,"['implementation', 'strings']","The translation from the Berland language into the Birland language is not an easy task. Those languages are very similar: a berlandish word differs from a birlandish word with the same meaning a little: it is spelled (and pronounced) reversely. For example, a Berlandish word code corresponds to a Birlandish word edoc. However, it's easy to make a mistake during the «translation». Vasya translated word *s* from Berlandish into Birlandish as *t*. Help him: find out if he translated the word correctly.","The first line contains word *s*, the second line contains word *t*. The words consist of lowercase Latin letters. The input data do not consist unnecessary spaces. The words are not empty and their lengths do not exceed 100 symbols.","If the word *t* is a word *s*, written reversely, print YES, otherwise print NO.","['code\nedoc\n', 'abb\naba\n', 'code\ncode\n']","['YES\n', 'NO\n', 'NO\n']",none,OK,"def b(s): 
  e = """" 
  for i in s: 
    e = i + e
  return e
c=str(input())
d=str(input())
a=""""
a=b(c)
if d==a:
    print(""YES"")
else:
   print(""NO"")","def c():

    a = input().strip()
    b = input().strip()

    d = ['1' if a != b else '0' for a, b in zip(a, b)]

    print("""".join(d))

if __name__ == '__main__':
    c()"
899,C,Dividing the numbers,PROGRAMMING,"['constructive algorithms', 'graphs', 'math']","Petya has *n* integers: 1,<=2,<=3,<=...,<=*n*. He wants to split these integers in two non-empty groups in such a way that the absolute difference of sums of integers in each group is as small as possible. 

Help Petya to split the integers. Each of *n* integers should be exactly in one group.",The first line contains a single integer *n* (2<=≤<=*n*<=≤<=60<=000) — the number of integers Petya has.,"Print the smallest possible absolute difference in the first line.

In the second line print the size of the first group, followed by the integers in that group. You can print these integers in arbitrary order. If there are multiple answers, print any of them.","['4\n', '2\n']","['0\n2 1 4 \n', '1\n1 1 \n']","In the first example you have to put integers 1 and 4 in the first group, and 2 and 3 in the second. This way the sum in each group is 5, and the absolute difference is 0.

In the second example there are only two integers, and since both groups should be non-empty, you have to put one integer in the first group and one in the second. This way the absolute difference of sums of integers in each group is 1.",OK,"def a(s, n):
    c = []
    for i in range(s, int(n/2) + 1, 2):
        c.append(i)
        c.append(n-i+s)
    return c

def b(s, n):
    c = []
    for i in range(s, int(n/2) - 1, 2):
        c.append(i)
        c.append(n-i+s)
    c.append(int(n/2))
    return c        

n = int(input())
            
d = n % 4

if(d == 0):
    print(0)
    print(int(n / 2), end=' ')
    print(*a(1, n), sep=' ')
elif(d == 1):
    print(1)
    print(int(n / 2), end=' ')
    print(*a(2, n), sep=' ')
elif(d == 2):
    print(1)
    print(int(n / 2), end=' ')
    print(*b(1, n), sep=' ')
else:
    print(0)
    print(int(n / 2) + 1, end=' ')
    print(*a(1, n-1), sep=' ')","""""""
We are given a permutation p[0..n‐1] and an integer k.
In one “operation” a random contiguous segment [l,r] (1-indexed) is chosen uniformly 
among all n(n+1)/2 possibilities and the segment is reversed.
A useful observation is that the effect on the relative order of any two numbers 
can be “linearized” if we compute their probability to swap.
For a pair of positions i and j (0-indexed; corresponding to positions i+1 and j+1),
an interval [l, r] (with 1<=l<=r<=n) will “flip” the order of the two elements 
if and only if both positions lie inside [l,r].
Thus one natural “model” is to view the pair’s state (which we encode by +1 
if the pair is in “natural” order and –1 if not) as evolving according 
to a “flip” that occurs with probability

   f = ((i+1)*(n - j)) / (n*(n+1)/2)

(note that we use (i+1) and (n–j) because i and j are 0‐indexed).
Then one reversal “updates” the expectation by a multiplier of

   r = 1 – 2*f.
In one operation the expected “imbalance” becomes
      s' = (1 – 2*f)* s.
Since the process converges to equilibrium (s=0 meaning that the eventual probability 
of having either order is 1/2), after k independent operations the expected s is
      s(k) = s0 * (1 – 2*f)^k.
If we define the natural “good” order to be the one where the number that should be 
smaller appears earlier, then if the pair’s initial state is “good” (s0 = +1) the probability
that it remains good is
      p_good = 0.5 + 0.5*(1 – 2*f)^k,
and conversely if the pair starts “bad” (s0 = –1) the chance it is bad at the end is the same.
Since an inversion is defined (for a pair with numbers a and b with a < b) as occurring 
when the order is “bad,” we get that the inversion probability for that pair is

    p_inv = 0.5 – 0.5*(1 – 2*f)^k   if the pair initially is good,
    p_inv = 0.5 + 0.5*(1 – 2*f)^k   if the pair initially is bad.

Finally, by linearity the expected number of inversions is the sum over all pairs.
(This model gives exactly the answers when k and n are small.)
""""""

import j
import math

def i():
    a = j.stdin.read().split()
    if not a: 
        return
    d = iter(a)
    n = int(next(d))
    k = int(next(d))

    g = [int(next(d)) for _ in range(n)]

    T = n*(n+1) / 2.0
    b = 0.0

    for i in range(n):
        for j in range(i+1, n):

            c = 1 if g[i] > g[j] else 0

            f = ((i+1) * (n - j)) / T

            h = 1 - 2*f

            e = 0.5 + 0.5 * (h ** k)

            if c == 0:
                f = 1 - e
            else:
                f = e
            b += f
    j.stdout.write(""{:.15f}"".format(b))
    
if __name__ == '__main__':
    i()"
744,A,Hongcow Builds A Nation,PROGRAMMING,"['dfs and similar', 'graphs']","Hongcow is ruler of the world. As ruler of the world, he wants to make it easier for people to travel by road within their own countries.

The world can be modeled as an undirected graph with *n* nodes and *m* edges. *k* of the nodes are home to the governments of the *k* countries that make up the world.

There is at most one edge connecting any two nodes and no edge connects a node to itself. Furthermore, for any two nodes corresponding to governments, there is no path between those two nodes. Any graph that satisfies all of these conditions is stable.

Hongcow wants to add as many edges as possible to the graph while keeping it stable. Determine the maximum number of edges Hongcow can add.","The first line of input will contain three integers *n*, *m* and *k* (1<=≤<=*n*<=≤<=1<=000, 0<=≤<=*m*<=≤<=100<=000, 1<=≤<=*k*<=≤<=*n*) — the number of vertices and edges in the graph, and the number of vertices that are homes of the government. 

The next line of input will contain *k* integers *c*1,<=*c*2,<=...,<=*c**k* (1<=≤<=*c**i*<=≤<=*n*). These integers will be pairwise distinct and denote the nodes that are home to the governments in this world.

The following *m* lines of input will contain two integers *u**i* and *v**i* (1<=≤<=*u**i*,<=*v**i*<=≤<=*n*). This denotes an undirected edge between nodes *u**i* and *v**i*.

It is guaranteed that the graph described by the input is stable.","Output a single integer, the maximum number of edges Hongcow can add to the graph while keeping it stable.","['4 1 2\n1 3\n1 2\n', '3 3 1\n2\n1 2\n1 3\n2 3\n']","['2\n', '0\n']","For the first sample test, the graph looks like this: 

For the second sample test, the graph looks like this:",WRONG_ANSWER,"import k
input = k.stdin.buffer.readline 

def e(j, x):
    L = []
    while j[x] != x:
        L.append(x)
        x = j[x]
    for y in L:
        j[y] = x
    return x

def h(n, G, C):
    g = [[] for i in range(n+1)]
    m = len(G)
    j = [i for i in range(n+1)]
    for i in range(m):
        u, v = G[i]
        l = e(j, u)
        n = e(j, v)
        j[l] = n
        g[u].append(v)
        g[v].append(u)
    i = {}
    for i in range(1, n+1):
        f = e(j, i)
        if f not in i:
            i[f] = [0, 0]
        i[f][0]+=1
        i[f][1]+=len(g[i])
    a = 0
    g = 0
    m = n
    c = m
    for c in C:
        b = j[c]
        n, d = i[b]
        d = d//2

        a+=(n*(n-1)//2-d)
        g = max(g, n)
        m-=n
        c-=d

    a+=(m*g)
    return a
        
        
    
    
    
n, m, k = [int(x) for x in input().split()]
C = [int(x) for x in input().split()]
G = []
for i in range(m):
    u, v = [int(x) for x in input().split()]
    G.append([u, v])
print(h(n, G, C))","def e():
    import g

    c = g.stdin.read().split()
    if not c:
        return

    s = c[0]

    k = int(c[1])

    i = list(map(int, c[2:28]))

    h = 0

    for d, b in enumerate(s, start=1):
        h += d * i[ord(b) - ord('a')]

    f = max(i)

    n = len(s)

    a = f * ( (n + 1 + n + k) * k // 2 )

    h += a

    g.stdout.write(str(h))

if __name__ == '__main__':
    e()"
358,A,Dima and Continuous Line,PROGRAMMING,"['brute force', 'implementation']","Dima and Seryozha live in an ordinary dormitory room for two. One day Dima had a date with his girl and he asked Seryozha to leave the room. As a compensation, Seryozha made Dima do his homework.

The teacher gave Seryozha the coordinates of *n* distinct points on the abscissa axis and asked to consecutively connect them by semi-circus in a certain order: first connect the first point with the second one, then connect the second point with the third one, then the third one with the fourth one and so on to the *n*-th point. Two points with coordinates (*x*1,<=0) and (*x*2,<=0) should be connected by a semi-circle that passes above the abscissa axis with the diameter that coincides with the segment between points. Seryozha needs to find out if the line on the picture intersects itself. For clarifications, see the picture Seryozha showed to Dima (the left picture has self-intersections, the right picture doesn't have any).

Seryozha is not a small boy, so the coordinates of the points can be rather large. Help Dima cope with the problem.","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=103). The second line contains *n* distinct integers *x*1,<=*x*2,<=...,<=*x**n* (<=-<=106<=≤<=*x**i*<=≤<=106) — the *i*-th point has coordinates (*x**i*,<=0). The points are not necessarily sorted by their *x* coordinate.","In the single line print ""yes"" (without the quotes), if the line has self-intersections. Otherwise, print ""no"" (without the quotes).","['4\n0 10 5 15\n', '4\n0 15 5 10\n']","['yes\n', 'no\n']","The first test from the statement is on the picture to the left, the second test is on the picture to the right.",WRONG_ANSWER,"def b(a,b,c,d):
    a=0
    if (a<c<b<d) or (c<a<d<b):
        a=1
    return a

n=int(input())
d=input().split()
for i in range(n):
    d[i]=int(d[i])
c=0
for i in range(n-1):
    for j in range(n-1):
        if b(d[i],d[i+1],d[j],d[j+1])==1:
            c=1
            print(i,j)
if c==0:
    print('no')
else:
    print('yes')","def c():
    import e
    b = e.stdin.read().splitlines()

    if not b:
        return
    try:
        k = int(b[0].strip())
    except ValueError:
        return
    q = b[1].strip() if len(b) > 1 else """"

    if k == 1:
        e.stdout.write(""YES\n"" + q)
        return
    
    d = []
    f = set()

    f.add(q[0])
    a = 0

    for i in range(1, len(q)):

        if q[i] not in f and len(d) < k - 1:
            d.append(q[a:i])
            a = i
            f.add(q[i])

    d.append(q[a:])

    if len(d) == k:
        e.stdout.write(""YES\n"" + ""\n"".join(d))
    else:
        e.stdout.write(""NO"")

if __name__ == '__main__':
    c()"
698,A,Vacations,PROGRAMMING,['dp'],"Vasya has *n* days of vacations! So he decided to improve his IT skills and do sport. Vasya knows the following information about each of this *n* days: whether that gym opened and whether a contest was carried out in the Internet on that day. For the *i*-th day there are four options:
 1.  on this day the gym is closed and the contest is not carried out; 1.  on this day the gym is closed and the contest is carried out; 1.  on this day the gym is open and the contest is not carried out; 1.  on this day the gym is open and the contest is carried out. 
On each of days Vasya can either have a rest or write the contest (if it is carried out on this day), or do sport (if the gym is open on this day).

Find the minimum number of days on which Vasya will have a rest (it means, he will not do sport and write the contest at the same time). The only limitation that Vasya has — he does not want to do the same activity on two consecutive days: it means, he will not do sport on two consecutive days, and write the contest on two consecutive days.","The first line contains a positive integer *n* (1<=≤<=*n*<=≤<=100) — the number of days of Vasya's vacations.

The second line contains the sequence of integers *a*1,<=*a*2,<=...,<=*a**n* (0<=≤<=*a**i*<=≤<=3) separated by space, where: 
 -  *a**i* equals 0, if on the *i*-th day of vacations the gym is closed and the contest is not carried out; -  *a**i* equals 1, if on the *i*-th day of vacations the gym is closed, but the contest is carried out; -  *a**i* equals 2, if on the *i*-th day of vacations the gym is open and the contest is not carried out; -  *a**i* equals 3, if on the *i*-th day of vacations the gym is open and the contest is carried out.","Print the minimum possible number of days on which Vasya will have a rest. Remember that Vasya refuses:
 -  to do sport on any two consecutive days, -  to write the contest on any two consecutive days.","['4\n1 3 2 0\n', '7\n1 3 3 2 1 2 3\n', '2\n2 2\n']","['2\n', '0\n', '1\n']","In the first test Vasya can write the contest on the day number 1 and do sport on the day number 3. Thus, he will have a rest for only 2 days.

In the second test Vasya should write contests on days number 1, 3, 5 and 7, in other days do sport. Thus, he will not have a rest for a single day.

In the third test Vasya can do sport either on a day number 1 or number 2. He can not do sport in two days, because it will be contrary to the his limitation. Thus, he will have a rest for only one day.",TIME_LIMIT_EXCEEDED,"n=int(input())
x=list(map(int,input().split()))
def a(i,p=0):
    if i==n:
        return 0
    if x[i]==1 and p!=1:
        return a(i+1,1)
    elif x[i]==2 and p!=2:
        return a(i+1,2)
    elif x[i]==3:
        if p:
           return a(i+1,[2,1][p-1])
        else:
            return min(a(i+1,1),a(i+1,2))
    else:
        return 1+min(a(i+1,1),a(i+1,2))
print(a(0))","n, k = map(int, input().split())
c = input().strip()

b = []

if k - 1 <= n - k:

    while k > 1:
        b.append(""LEFT"")
        k -= 1

    for i in range(n):
        b.append(""PRINT "" + c[i])
        if i < n - 1:
            b.append(""RIGHT"")
else:

    while k < n:
        b.append(""RIGHT"")
        k += 1

    for i in range(n - 1, -1, -1):
        b.append(""PRINT "" + c[i])
        if i > 0:
            b.append(""LEFT"")

for a in b:
    print(a)"
975,C,Valhalla Siege,PROGRAMMING,['binary search'],"Ivar the Boneless is a great leader. He is trying to capture Kattegat from Lagertha. The war has begun and wave after wave Ivar's warriors are falling in battle.

Ivar has $n$ warriors, he places them on a straight line in front of the main gate, in a way that the $i$-th warrior stands right after $(i-1)$-th warrior. The first warrior leads the attack.

Each attacker can take up to $a_i$ arrows before he falls to the ground, where $a_i$ is the $i$-th warrior's strength.

Lagertha orders her warriors to shoot $k_i$ arrows during the $i$-th minute, the arrows one by one hit the first still standing warrior. After all Ivar's warriors fall and all the currently flying arrows fly by, Thor smashes his hammer and all Ivar's warriors get their previous strengths back and stand up to fight again. In other words, if all warriors die in minute $t$, they will all be standing to fight at the end of minute $t$.

The battle will last for $q$ minutes, after each minute you should tell Ivar what is the number of his standing warriors.","The first line contains two integers $n$ and $q$ ($1 \le n, q \leq 200\,000$) — the number of warriors and the number of minutes in the battle.

The second line contains $n$ integers $a_1, a_2, \ldots, a_n$ ($1 \leq a_i \leq 10^9$) that represent the warriors' strengths.

The third line contains $q$ integers $k_1, k_2, \ldots, k_q$ ($1 \leq k_i \leq 10^{14}$), the $i$-th of them represents Lagertha's order at the $i$-th minute: $k_i$ arrows will attack the warriors.","Output $q$ lines, the $i$-th of them is the number of standing warriors after the $i$-th minute.","['5 5\n1 2 1 2 1\n3 10 1 1 1\n', '4 4\n1 2 3 4\n9 1 10 6\n']","['3\n5\n4\n4\n3\n', '1\n4\n4\n1\n']","In the first example: 
 -  after the 1-st minute, the 1-st and 2-nd warriors die. -  after the 2-nd minute all warriors die (and all arrows left over are wasted), then they will be revived thus answer is 5 — all warriors are alive. -  after the 3-rd minute, the 1-st warrior dies. -  after the 4-th minute, the 2-nd warrior takes a hit and his strength decreases by 1. -  after the 5-th minute, the 2-nd warrior dies.",OK,"def d(c, i, a):
    l = c
    h = n - 1

    while (l < h):
        m = (l + h) // 2
        j = h[m] - h[c] + i
        if j > a:
            h = m
        elif j == a:
            return m
        else:
            if m == n - 1:
                return m
            l = m + 1

    return l

n, e = map(int, input().split())
h = [int(x) for x in input().split()]
b = [int(x) for x in input().split()]
g = [0] * e

for i in range(1, n):
    h[i] = h[i] + h[i - 1]

c = 0
i = h[0]

for i in range(e):
    a = b[i]
    f = d(c, i, a)

    k = h[f] - h[c] + i

    if k > a:
        c = f
        i = k - a
        g[i] = n - c
    else:
        c = (f + 1) % n
        if c:
            i = h[c] - h[c - 1]
        else:
            i = h[c]
        g[i] = n - c

print(*g, sep='\n')","def b():
    import c
    a = c.stdin.read().split()
    if not a:
        return
    n = int(a[0])

    e = []
    d = set()
    k = 1
    t = k * (k + 1) // 2
    while t <= n:
        e.append(t)
        d.add(t)
        k += 1
        t = k * (k + 1) // 2

    for t in e:
        if (n - t) in d:
            c.stdout.write(""YES\n"")
            return
    
    c.stdout.write(""NO\n"")

if __name__ == '__main__':
    b()"
349,B,Color the Fence,PROGRAMMING,"['data structures', 'dp', 'greedy', 'implementation']","Igor has fallen in love with Tanya. Now Igor wants to show his feelings and write a number on the fence opposite to Tanya's house. Igor thinks that the larger the number is, the more chance to win Tanya's heart he has. 

Unfortunately, Igor could only get *v* liters of paint. He did the math and concluded that digit *d* requires *a**d* liters of paint. Besides, Igor heard that Tanya doesn't like zeroes. That's why Igor won't use them in his number.

Help Igor find the maximum number he can write on the fence.","The first line contains a positive integer *v* (0<=≤<=*v*<=≤<=106). The second line contains nine positive integers *a*1,<=*a*2,<=...,<=*a*9 (1<=≤<=*a**i*<=≤<=105).","Print the maximum number Igor can write on the fence. If he has too little paint for any digit (so, he cannot write anything), print -1.","['5\n5 4 3 2 1 2 3 4 5\n', '2\n9 11 1 12 5 8 9 10 6\n', '0\n1 1 1 1 1 1 1 1 1\n']","['55555\n', '33\n', '-1\n']",none,WRONG_ANSWER,"def g(i):
	if i in d:
		return d[i]

	if i < f:
		return ('', 0)
 
	e = 0
	for b in range(9):
		if i >= c[b]:
			h = g(i%c[b])
			if h[1] + i//c[b] >= e:
				e = h[1] + i//c[b]
				d[i] = (str(b+1)*(i//c[b]) + h[0], i//c[b] + h[1])

	return d[i]

v = int(input())
c = list(map(int, input().split()))
f = min(c)
d = {}

a = g(v)
if a[0]:
	print(int(a[0]))
else:
	print(-1)","def d():
    import k

    b = k.stdin.read().strip().split()
    if not b:
        return

    n = int(b[0])

    j = list(map(int, b[1:1+n]))

    h = {}
    for i, e in enumerate(j, start=1):
        if e not in h:
            h[e] = []
        h[e].append(i)

    i = []

    for x, g in h.items():

        if len(g) == 1:
            i.append((x, 0))
        else:

            a = g[1] - g[0]
            l = True

            for i in range(2, len(g)):
                if g[i] - g[i - 1] != a:
                    l = False
                    break
            if l:
                i.append((x, a))

    i.sort()

    f = []
    f.append(str(len(i)))
    for x, c in i:
        f.append(f""{x} {c}"")
    k.stdout.write(""\n"".join(f) + ""\n"")

if __name__ == ""__main__"":
    d()"
505,C,"Mr. Kitayuta, the Treasure Hunter",PROGRAMMING,"['dfs and similar', 'dp', 'two pointers']","The Shuseki Islands are an archipelago of 30001 small islands in the Yutampo Sea. The islands are evenly spaced along a line, numbered from 0 to 30000 from the west to the east. These islands are known to contain many treasures. There are *n* gems in the Shuseki Islands in total, and the *i*-th gem is located on island *p**i*.

Mr. Kitayuta has just arrived at island 0. With his great jumping ability, he will repeatedly perform jumps between islands to the east according to the following process: 
 -  First, he will jump from island 0 to island *d*. -  After that, he will continue jumping according to the following rule. Let *l* be the length of the previous jump, that is, if his previous jump was from island *prev* to island *cur*, let *l*<==<=*cur*<=-<=*prev*. He will perform a jump of length *l*<=-<=1, *l* or *l*<=+<=1 to the east. That is, he will jump to island (*cur*<=+<=*l*<=-<=1), (*cur*<=+<=*l*) or (*cur*<=+<=*l*<=+<=1) (if they exist). The length of a jump must be positive, that is, he cannot perform a jump of length 0 when *l*<==<=1. If there is no valid destination, he will stop jumping. 
Mr. Kitayuta will collect the gems on the islands visited during the process. Find the maximum number of gems that he can collect.","The first line of the input contains two space-separated integers *n* and *d* (1<=≤<=*n*,<=*d*<=≤<=30000), denoting the number of the gems in the Shuseki Islands and the length of the Mr. Kitayuta's first jump, respectively.

The next *n* lines describe the location of the gems. The *i*-th of them (1<=≤<=*i*<=≤<=*n*) contains a integer *p**i* (*d*<=≤<=*p*1<=≤<=*p*2<=≤<=...<=≤<=*p**n*<=≤<=30000), denoting the number of the island that contains the *i*-th gem.",Print the maximum number of gems that Mr. Kitayuta can collect.,"['4 10\n10\n21\n27\n27\n', '8 8\n9\n19\n28\n36\n45\n55\n66\n78\n', '13 7\n8\n8\n9\n16\n17\n17\n18\n21\n23\n24\n24\n26\n30\n']","['3\n', '6\n', '4\n']","In the first sample, the optimal route is 0  →  10 (+1 gem)  →  19  →  27 (+2 gems)  → ...

In the second sample, the optimal route is 0  →  8  →  15  →  21 →  28 (+1 gem)  →  36 (+1 gem)  →  45 (+1 gem)  →  55 (+1 gem)  →  66 (+1 gem)  →  78 (+1 gem)  → ...

In the third sample, the optimal route is 0  →  7  →  13  →  18 (+1 gem)  →  24 (+2 gems)  →  30 (+1 gem)  → ...",WRONG_ANSWER,"n, d = map(int, input().split())

c = set()
for i in range(n):
    p = int(input())
    c.add(p)

b = [[-1] * 501 for _ in range(30001)]

def a(x, y):

    if x > 30000 or not c:
        return 0

    if b[x][y] != -1:
        return b[x][y]
    
    d = 0

    for l in range(y-1, y+2):
        if l <= 0:
            continue

        e = x + l

        if e in c:
            c.remove(e)
            d = max(d, 1 + a(e, l))
            c.add(e)

    b[x][y] = d
    
    return d

print(a(d, d))","def e():
    import f
    b = f.stdin.read().strip().split()

    n = int(b[0])
    a = int(b[1])
    b = int(b[2])
    c = int(b[3])

    a = [-4001] * (n + 1)
    a[0] = 0

    d = [a, b, c]

    for i in range(1, n + 1):
        for c in d:
            if i >= c:
                a[i] = max(a[i], a[i - c] + 1)

    print(a[n])

if __name__ == '__main__':
    e()"
534,C,Polycarpus' Dice,PROGRAMMING,['math'],"Polycarp has *n* dice *d*1,<=*d*2,<=...,<=*d**n*. The *i*-th dice shows numbers from 1 to *d**i*. Polycarp rolled all the dice and the sum of numbers they showed is *A*. Agrippina didn't see which dice showed what number, she knows only the sum *A* and the values *d*1,<=*d*2,<=...,<=*d**n*. However, she finds it enough to make a series of statements of the following type: dice *i* couldn't show number *r*. For example, if Polycarp had two six-faced dice and the total sum is *A*<==<=11, then Agrippina can state that each of the two dice couldn't show a value less than five (otherwise, the remaining dice must have a value of at least seven, which is impossible).

For each dice find the number of values for which it can be guaranteed that the dice couldn't show these values if the sum of the shown values is *A*.","The first line contains two integers *n*,<=*A* (1<=≤<=*n*<=≤<=2·105,<=*n*<=≤<=*A*<=≤<=*s*) — the number of dice and the sum of shown values where *s*<==<=*d*1<=+<=*d*2<=+<=...<=+<=*d**n*.

The second line contains *n* integers *d*1,<=*d*2,<=...,<=*d**n* (1<=≤<=*d**i*<=≤<=106), where *d**i* is the maximum value that the *i*-th dice can show.","Print *n* integers *b*1,<=*b*2,<=...,<=*b**n*, where *b**i* is the number of values for which it is guaranteed that the *i*-th dice couldn't show them.","['2 8\n4 4\n', '1 3\n5\n', '2 3\n2 3\n']","['3 3 ', '4 ', '0 1 ']","In the first sample from the statement *A* equal to 8 could be obtained in the only case when both the first and the second dice show 4. Correspondingly, both dice couldn't show values 1, 2 or 3.

In the second sample from the statement *A* equal to 3 could be obtained when the single dice shows 3. Correspondingly, it couldn't show 1, 2, 4 or 5.

In the third sample from the statement *A* equal to 3 could be obtained when one dice shows 1 and the other dice shows 2. That's why the first dice doesn't have any values it couldn't show and the second dice couldn't show 3.",WRONG_ANSWER,"import f
from math import *
from collections import Counter,defaultdict,deque
input=f.stdin.readline
d=10**9+7
def c():return map(int,input().split())
def b():return int(input())
def a():return list(map(int,input().split()))
def input():return f.stdin.readline().strip()

n,k=c()
a=a()
s=sum(a)
for i in range(n):
    if s-a[i]>=k:
        print(0,end=' ')
    else:
        e=[k-(s-a[i]),min(a[i],k-n+1)]

        print(a[i]-(e[1]-e[0]+1),end=' ')","s = input().strip()
t = input().strip()

if s[::-1] == t:
    print(""YES"")
else:
    print(""NO"")"
448,B,Suffix Structures,PROGRAMMING,"['implementation', 'strings']","Bizon the Champion isn't just a bison. He also is a favorite of the ""Bizons"" team.

At a competition the ""Bizons"" got the following problem: ""You are given two distinct words (strings of English letters), *s* and *t*. You need to transform word *s* into word *t*"". The task looked simple to the guys because they know the suffix data structures well. Bizon Senior loves suffix automaton. By applying it once to a string, he can remove from this string any single character. Bizon Middle knows suffix array well. By applying it once to a string, he can swap any two characters of this string. The guys do not know anything about the suffix tree, but it can help them do much more. 

Bizon the Champion wonders whether the ""Bizons"" can solve the problem. Perhaps, the solution do not require both data structures. Find out whether the guys can solve the problem and if they can, how do they do it? Can they solve it either only with use of suffix automaton or only with use of suffix array or they need both structures? Note that any structure may be used an unlimited number of times, the structures may be used in any order.",The first line contains a non-empty word *s*. The second line contains a non-empty word *t*. Words *s* and *t* are different. Each word consists only of lowercase English letters. Each word contains at most 100 letters.,"In the single line print the answer to the problem. Print ""need tree"" (without the quotes) if word *s* cannot be transformed into word *t* even with use of both suffix array and suffix automaton. Print ""automaton"" (without the quotes) if you need only the suffix automaton to solve the problem. Print ""array"" (without the quotes) if you need only the suffix array to solve the problem. Print ""both"" (without the quotes), if you need both data structures to solve the problem.

It's guaranteed that if you can solve the problem only with use of suffix array, then it is impossible to solve it only with use of suffix automaton. This is also true for suffix automaton.","['automaton\ntomat\n', 'array\narary\n', 'both\nhot\n', 'need\ntree\n']","['automaton\n', 'array\n', 'both\n', 'need tree\n']","In the third sample you can act like that: first transform ""both"" into ""oth"" by removing the first character using the suffix automaton and then make two swaps of the string using the suffix array and get ""hot"".",OK,"def f():
	s = input()
	t = input()

	b = ['automaton', 'array', 'both', 'need tree']

	a = ''
	if s == t:
		a = b[0]
	elif sorted(s) == sorted(t):
		a = b[1]
	elif len(s) < len(t):
		a = b[3]

	if a != '':
		print(a)
		return

	d = [0 for _ in range(26)]
	e = d.copy()

	for c in s:
		d[ord(c) - ord('a')] += 1
	for c in t:
		e[ord(c) - ord('a')] += 1

	c = True
	for i in range(26):
		if d[i] < e[i]:
			c = False

	if not c:
		print(b[3])
		return

	x, y, n, m = 0, 0, len(s), len(t)
	while y < m:
		while x < n:
			x += 1
			if s[x-1] == t[y]:
				y += 1
				break
		if x == n:
			break

	if y < m:
		print(b[2])
	else:
		print(b[0])

if __name__ == '__main__':
	f()","def h():
    import j
    input = j.stdin.readline

    n, m = map(int, input().split())

    f = list(map(int, input().split()))

    i = {}

    for c in f:
        if c not in i:
            i[c] = set()

    for _ in range(m):
        u, v = map(int, input().split())
        d = f[u - 1]
        e = f[v - 1]
        if d != e:
            i[d].add(e)
            i[e].add(d)

    a = None
    b = -1

    for c in i:
        g = len(i[c])
        if g > b or (g == b and (a is None or c < a)):
            b = g
            a = c

    print(a)

if __name__ == '__main__':
    h()"
709,A,Juicer,PROGRAMMING,['implementation'],"Kolya is going to make fresh orange juice. He has *n* oranges of sizes *a*1,<=*a*2,<=...,<=*a**n*. Kolya will put them in the juicer in the fixed order, starting with orange of size *a*1, then orange of size *a*2 and so on. To be put in the juicer the orange must have size not exceeding *b*, so if Kolya sees an orange that is strictly greater he throws it away and continues with the next one.

The juicer has a special section to collect waste. It overflows if Kolya squeezes oranges of the total size strictly greater than *d*. When it happens Kolya empties the waste section (even if there are no more oranges) and continues to squeeze the juice. How many times will he have to empty the waste section?","The first line of the input contains three integers *n*, *b* and *d* (1<=≤<=*n*<=≤<=100<=000, 1<=≤<=*b*<=≤<=*d*<=≤<=1<=000<=000) — the number of oranges, the maximum size of the orange that fits in the juicer and the value *d*, which determines the condition when the waste section should be emptied.

The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=1<=000<=000) — sizes of the oranges listed in the order Kolya is going to try to put them in the juicer.",Print one integer — the number of times Kolya will have to empty the waste section.,"['2 7 10\n5 6\n', '1 5 10\n7\n', '3 10 10\n5 7 7\n', '1 1 1\n1\n']","['1\n', '0\n', '1\n', '0\n']","In the first sample, Kolya will squeeze the juice from two oranges and empty the waste section afterwards.

In the second sample, the orange won't fit in the juicer so Kolya will have no juice at all.",OK,"def c():
    n,b,d = input().split()
    n = int(n)
    b = int(b)
    d = int(d)
    a = list(map(int, input().split()))
    d = 0
    b = 0
    for j in a:
        if j <= b:
            d += j
            if d > d:
                b += 1
                d = 0
    print(b)
c()","def e():
    import h
    b = h.stdin.read().split()

    n = int(b[0])
    m = int(b[1])

    a = [set() for _ in range(n+1)]
    
    d = 2
    for _ in range(m):
        u = int(b[d])
        v = int(b[d + 1])
        d += 2

        a[u].add(v)
        a[v].add(u)
    
    c = 0

    while True:

        i = [i for i in range(1, n+1) if len(a[i]) == 1]
        if not i:
            break

        for g in i:
            if a[g]:
                f = next(iter(a[g]))

                a[f].discard(g)

            a[g].clear()
        
        c += 1

    print(c)

if __name__ == '__main__':
    e()"
558,B,Amr and The Large Array,PROGRAMMING,['implementation'],"Amr has got a large array of size *n*. Amr doesn't like large arrays so he intends to make it smaller.

Amr doesn't care about anything in the array except the beauty of it. The beauty of the array is defined to be the maximum number of times that some number occurs in this array. He wants to choose the smallest subsegment of this array such that the beauty of it will be the same as the original array.

Help Amr by choosing the smallest subsegment possible.","The first line contains one number *n* (1<=≤<=*n*<=≤<=105), the size of the array.

The second line contains *n* integers *a**i* (1<=≤<=*a**i*<=≤<=106), representing elements of the array.","Output two integers *l*,<=*r* (1<=≤<=*l*<=≤<=*r*<=≤<=*n*), the beginning and the end of the subsegment chosen respectively.

If there are several possible answers you may output any of them.","['5\n1 1 2 2 1\n', '5\n1 2 2 3 1\n', '6\n1 2 2 1 1 2\n']","['1 5', '2 3', '1 5']","A subsegment *B* of an array *A* from *l* to *r* is an array of size *r* - *l* + 1 where *B*<sub class=""lower-index"">*i*</sub> = *A*<sub class=""lower-index"">*l* + *i* - 1</sub> for all 1 ≤ *i* ≤ *r* - *l* + 1",OK,"def a(n,a):
    l = 0
    r = len(a)-1
    while l<=r:
        m = (l+r)//2
        if n>a[m][0]:
            l = m+1
        if n<a[m][0]:
            r = m-1
        if n == a[m][0]:
            return m
    return -1
n = int(input())
a = input().split()
def c(n):
    return n[1]
def f(n):
    return abs(n[2]-n[3])
b = {}
d = 0
for i in range(n):
    a[i] = int(a[i])
    if a[i] in b:
        b[a[i]][1] += 1
        b[a[i]][3] = i
    else:
        b[a[i]] = [a[i],1,i,0]
for m in b.values():
    if m[1]>d:
        d = m[1]
v = []
for m in b.values():
    if m[1]==d:
        v.append(m)
v.sort(key=f)
print(v[0][2]+1,v[0][3]+1)","def f():
    import g
    b = g.stdin.read().split()
    if not b:
        return

    n = int(b[0])
    k = int(b[1])

    a = list(map(int, b[2:2 + n]))

    b = list(map(int, b[2 + n:2 + n + k]))

    c = [x for x in a if x != 0]
    for i in range(len(c) - 1):
        if c[i] > c[i + 1]:
            g.stdout.write(""Yes"")
            return

    if k >= 2:
        g.stdout.write(""Yes"")
        return

    a = b[0]
    d = a.index(0)

    e = True
    if d > 0:
        if a[d - 1] >= a:
            e = False
    if d < n - 1:

        if a[d + 1] != 0:
            if a >= a[d + 1]:
                e = False

    g.stdout.write(""No"" if e else ""Yes"")

if __name__ == '__main__':
    f()"
411,C,Kicker,PROGRAMMING,['implementation'],"Kicker (table football) is a board game based on football, in which players control the footballers' figures mounted on rods by using bars to get the ball into the opponent's goal. When playing two on two, one player of each team controls the goalkeeper and the full-backs (plays defence), the other player controls the half-backs and forwards (plays attack).

Two teams of company Q decided to battle each other. Let's enumerate players from both teams by integers from 1 to 4. The first and second player play in the first team, the third and the fourth one play in the second team. For each of the four players we know their game skills in defence and attack. The defence skill of the *i*-th player is *a**i*, the attack skill is *b**i*.

Before the game, the teams determine how they will play. First the players of the first team decide who will play in the attack, and who will play in the defence. Then the second team players do the same, based on the choice of their opponents.

We will define a team's defence as the defence skill of player of the team who plays defence. Similarly, a team's attack is the attack skill of the player of the team who plays attack. We assume that one team is guaranteed to beat the other one, if its defence is strictly greater than the opponent's attack and its attack is strictly greater than the opponent's defence.

The teams of company Q know each other's strengths and therefore arrange their teams optimally. Identify the team that is guaranteed to win (if both teams act optimally) or tell that there is no such team.","The input contain the players' description in four lines. The *i*-th line contains two space-separated integers *a**i* and *b**i* (1<=≤<=*a**i*,<=*b**i*<=≤<=100) — the defence and the attack skill of the *i*-th player, correspondingly.","If the first team can win, print phrase ""Team 1"" (without the quotes), if the second team can win, print phrase ""Team 2"" (without the quotes). If no of the teams can definitely win, print ""Draw"" (without the quotes).","['1 100\n100 1\n99 99\n99 99\n', '1 1\n2 2\n3 3\n2 2\n', '3 3\n2 2\n1 1\n2 2\n']","['Team 1\n', 'Team 2\n', 'Draw\n']","Let consider the first test sample. The first team can definitely win if it will choose the following arrangement: the first player plays attack, the second player plays defence.

Consider the second sample. The order of the choosing roles for players makes sense in this sample. As the members of the first team choose first, the members of the second team can beat them (because they know the exact defence value and attack value of the first team).",OK,"e = list(map(int, input().split()))
f = list(map(int, input().split()))
g = list(map(int, input().split()))
h = list(map(int, input().split()))

def f(a, b, c, d):
    if a[0] > d[1] and b[1] > c[0]:
        return 1
    if a[0] < d[1] and b[1] < c[0]:
        return 2
    return 0

a = f(e, f, g, h)
b = f(f, e, g, h)
c = f(e, f, h, g)
d = f(f, e, h, g)

if ((a == 2 or c == 2) and (b == 2 or d == 2)):
    print(""Team 2"")
elif ((a == 1 and c == 1) or (b == 1 and d == 1)):
    print(""Team 1"")
else:
    print(""Draw"")","import d

def b():

    a = d.stdin.read().split()
    
    if not a:
        return

    n = int(a[0])

    if n % 2 == 1:

        k = (n - 3) // 2 + 1
        print(k)

        c = [""3""] + [""2""] * ((n - 3) // 2)
        print("" "".join(c))
    else:

        k = n // 2
        print(k)

        c = [""2""] * (n // 2)
        print("" "".join(c))

if __name__ == ""__main__"":
    b()"
26,A,Almost Prime,PROGRAMMING,['number theory'],"A number is called almost prime if it has exactly two distinct prime divisors. For example, numbers 6, 18, 24 are almost prime, while 4, 8, 9, 42 are not. Find the amount of almost prime numbers which are between 1 and *n*, inclusive.",Input contains one integer number *n* (1<=≤<=*n*<=≤<=3000).,"Output the amount of almost prime numbers between 1 and *n*, inclusive.","['10\n', '21\n']","['2\n', '8\n']",none,OK,"def c():
    N=int(input())
    a=0
    for j in range(1,N+1):
        i=2
        d=j
        b=0
        while(d!=1):
            if(d%i==0):
                b+=1
                while(d%i==0):
                    d//=i
            i+=1
        if b==2:
            a+=1
    print(a)
if __name__=='__main__':
    c()","def k():
    import q
    from collections import f

    e = q.stdin.read().split()
    if not e:
        return

    j = iter(e)
    n = int(next(j))
    m = int(next(j))

    m = [set() for _ in range(n)]
    for _ in range(m):
        u = int(next(j)) - 1
        v = int(next(j)) - 1
        m[u].add(v)
        m[v].add(u)

    n = (n - 1 in m[0])

    def c(a):
        g = [-1] * n
        q = f()
        g[0] = 0
        q.append(0)
        while q:
            d = q.popleft()
            if d == n - 1:

                return g[n - 1]
            for l in a[d]:
                if g[l] == -1:
                    g[l] = g[d] + 1
                    q.append(l)
        return g[n - 1]

    o = [[] for _ in range(n)]
    b = set(range(n))
    for i in range(n):

        p = b - m[i] - {i}
        o[i] = list(p)

    h = c(m)
    i = c(o)

    if h == -1 or i == -1:
        q.stdout.write(""-1"")
    else:

        q.stdout.write(str(max(h, i)))

if __name__ == ""__main__"":
    k()"
932,B,Recursive Queries,PROGRAMMING,"['binary search', 'data structures', 'dfs and similar']","Let us define two functions *f* and *g* on positive integer numbers. 

 

You need to process *Q* queries. In each query, you will be given three integers *l*, *r* and *k*. You need to print the number of integers *x* between *l* and *r* inclusive, such that *g*(*x*)<==<=*k*.","The first line of the input contains an integer *Q* (1<=≤<=*Q*<=≤<=2<=×<=105) representing the number of queries. 

*Q* lines follow, each of which contains 3 integers *l*, *r* and *k* (1<=≤<=*l*<=≤<=*r*<=≤<=106,<=1<=≤<=*k*<=≤<=9).","For each query, print a single line containing the answer for that query.","['4\n22 73 9\n45 64 6\n47 55 7\n2 62 4\n', '4\n82 94 6\n56 67 4\n28 59 9\n39 74 4\n']","['1\n4\n0\n8\n', '3\n1\n1\n5\n']","In the first example:
 -  *g*(33) = 9 as *g*(33) = *g*(3 × 3) = *g*(9) = 9 -  *g*(47) = *g*(48) = *g*(60) = *g*(61) = 6 -  There are no such integers between 47 and 55. -  *g*(4) = *g*(14) = *g*(22) = *g*(27) = *g*(39) = *g*(40) = *g*(41) = *g*(58) = 4",TIME_LIMIT_EXCEEDED,"from functools import d, b

max = int(10e6 + 5)

def a(l, r, k):
    for i in range(l, r+1):
        yield 1 if g(i) == k else 0

def c():
    q = int(input())
    for _ in range(q):
        l, r, k = (int(x) for x in input().split())
        s = sum(a(l, r, k))
        print(s)

def f(n):
    return d((lambda x,y: int(x) if int(y) == 0 else int(x)*int(y)), str(n))

@b(maxsize=max)
def g(n):
    if n < 10:
        return n
    return g(f(n))

if __name__ == ""__main__"":
    c()","import i
import e

def d():

    a = i.stdin.read().splitlines()

    if not a:
        return
    
    g = []

    for c in a:
        if not c.strip():
            continue

        f = list(map(int, c.strip().split()))
        if len(f) != 5:
            continue
        
        r, x, y, j, k = f

        b = e.hypot(j - x, k - y)

        h = e.ceil(b / (2 * r))
        
        g.append(str(h))

    i.stdout.write(""\n"".join(g))

if __name__ == ""__main__"":
    d()"
1,A,Theatre Square,PROGRAMMING,['math'],"Theatre Square in the capital city of Berland has a rectangular shape with the size *n*<=×<=*m* meters. On the occasion of the city's anniversary, a decision was taken to pave the Square with square granite flagstones. Each flagstone is of the size *a*<=×<=*a*.

What is the least number of flagstones needed to pave the Square? It's allowed to cover the surface larger than the Theatre Square, but the Square has to be covered. It's not allowed to break the flagstones. The sides of flagstones should be parallel to the sides of the Square.","The input contains three positive integer numbers in the first line: *n*,<=<=*m* and *a* (1<=≤<=<=*n*,<=*m*,<=*a*<=≤<=109).",Write the needed number of flagstones.,['6 6 4\n'],['4\n'],none,WRONG_ANSWER,"from math import a

def d(input):
    n = int(input.split(' ')[0])
    m = int(input.split(' ')[1])
    a = int(input.split(' ')[2])
    global c
    global b
    if a > n:
        c = 1
    elif a > m:
        b = 1
    else:
        c = a(n / a)
        b = a(m / a)
    return c * b

print(d('6 6 4'))","n, s = map(int, input().split())

c = {}
g = {}

for _ in range(n):
    e = input().split()
    d = e[0]
    f = int(e[1])
    i = int(e[2])
    
    if d == 'B':
        if f in c:
            c[f] += i
        else:
            c[f] = i
    else:
        if f in g:
            g[f] += i
        else:
            g[f] = i

h = sorted(g.items(), key=lambda x: x[0])
b = h[:s]

b.reverse()

a = sorted(c.items(), key=lambda x: x[0], reverse=True)[:s]

for f, i in b:
    print(""S"", f, i)
for f, i in a:
    print(""B"", f, i)"
1004,C,Sonya and Robots,PROGRAMMING,"['constructive algorithms', 'implementation']","Since Sonya is interested in robotics too, she decided to construct robots that will read and recognize numbers.

Sonya has drawn $n$ numbers in a row, $a_i$ is located in the $i$-th position. She also has put a robot at each end of the row (to the left of the first number and to the right of the last number). Sonya will give a number to each robot (they can be either same or different) and run them. When a robot is running, it is moving toward to another robot, reading numbers in the row. When a robot is reading a number that is equal to the number that was given to that robot, it will turn off and stay in the same position.

Sonya does not want robots to break, so she will give such numbers that robots will stop before they meet. That is, the girl wants them to stop at different positions so that the first robot is to the left of the second one.

For example, if the numbers $[1, 5, 4, 1, 3]$ are written, and Sonya gives the number $1$ to the first robot and the number $4$ to the second one, the first robot will stop in the $1$-st position while the second one in the $3$-rd position. In that case, robots will not meet each other. As a result, robots will not be broken. But if Sonya gives the number $4$ to the first robot and the number $5$ to the second one, they will meet since the first robot will stop in the $3$-rd position while the second one is in the $2$-nd position.

Sonya understands that it does not make sense to give a number that is not written in the row because a robot will not find this number and will meet the other robot.

Sonya is now interested in finding the number of different pairs that she can give to robots so that they will not meet. In other words, she wants to know the number of pairs ($p$, $q$), where she will give $p$ to the first robot and $q$ to the second one. Pairs ($p_i$, $q_i$) and ($p_j$, $q_j$) are different if $p_i\neq p_j$ or $q_i\neq q_j$.

Unfortunately, Sonya is busy fixing robots that broke after a failed launch. That is why she is asking you to find the number of pairs that she can give to robots so that they will not meet.","The first line contains a single integer $n$ ($1\leq n\leq 10^5$) — the number of numbers in a row.

The second line contains $n$ integers $a_1, a_2, \ldots, a_n$ ($1\leq a_i\leq 10^5$) — the numbers in a row.",Print one number — the number of possible pairs that Sonya can give to robots so that they will not meet.,"['5\n1 5 4 1 3\n', '7\n1 2 1 1 1 3 2\n']","['9\n', '7\n']","In the first example, Sonya can give pairs ($1$, $1$), ($1$, $3$), ($1$, $4$), ($1$, $5$), ($4$, $1$), ($4$, $3$), ($5$, $1$), ($5$, $3$), and ($5$, $4$).

In the second example, Sonya can give pairs ($1$, $1$), ($1$, $2$), ($1$, $3$), ($2$, $1$), ($2$, $2$), ($2$, $3$), and ($3$, $2$).",OK,"""""""
http://codeforces.com/problemset/problem/1004/C
""""""
input()
a = map(int, input().split())
c = {}
b = 0
for x in a:
    if x not in c:
        b += len(c)
        c[x] = len(c)
    else:
        b += len(c) - c[x]
        c[x] += len(c) - c[x]
print(b)","def c(e):
    if e < 2:
        return False

    for i in range(2, int(e**0.5) + 1):
        if e % i == 0:
            return False
    return True

def d():

    n, k = map(int, input().split())

    f = []
    for i in range(2, n + 1):
        if c(i):
            f.append(i)

    b = 0
    for i in range(len(f) - 1):
        a = f[i] + f[i + 1] + 1

        if a <= n and c(a):
            b += 1

    if b >= k:
        print(""YES"")
    else:
        print(""NO"")

if __name__ == ""__main__"":
    d()"
540,A,Combination Lock,PROGRAMMING,['implementation'],"Scrooge McDuck keeps his most treasured savings in a home safe with a combination lock. Each time he wants to put there the treasures that he's earned fair and square, he has to open the lock.

The combination lock is represented by *n* rotating disks with digits from 0 to 9 written on them. Scrooge McDuck has to turn some disks so that the combination of digits on the disks forms a secret combination. In one move, he can rotate one disk one digit forwards or backwards. In particular, in one move he can go from digit 0 to digit 9 and vice versa. What minimum number of actions does he need for that?","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=1000) — the number of disks on the combination lock.

The second line contains a string of *n* digits — the original state of the disks.

The third line contains a string of *n* digits — Scrooge McDuck's combination that opens the lock.",Print a single integer — the minimum number of moves Scrooge McDuck needs to open the lock.,['5\n82195\n64723\n'],['13\n'],"In the sample he needs 13 moves:
 -  1 disk: <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/b8967f65a723782358b93eff9ce69f336817cf70.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> -  2 disk: <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/07fa58573ece0d32c4d555e498d2b24d2f70f36a.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> -  3 disk: <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/cc2275d9252aae35a6867c6a5b4ba7596e9a7626.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> -  4 disk: <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/b100aea470fcaaab4e9529b234ba0d7875943c10.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> -  5 disk: <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/eb2cbe4324cebca65b85816262a85e473cd65967.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>",OK,"n = input()
a = list(  map( int , list(input() )))
b = list(  map( int , list(input() )))

def d(e, f):
    return min(abs(e-f), 10 - abs(e- f))
c = 0
for e, f in zip(a, b):
    c += d(e, f)
print(c)","import h

def f():

    e = h.stdin.read().splitlines()
    if not e:
        return
    s = e[0].strip()
    t = e[1].strip() if len(e) > 1 else """"

    c = [0] * 26
    b = [0] * 26
    for a in t:
        if a.isupper():
            c[ord(a) - ord('A')] += 1
        else:
            b[ord(a) - ord('a')] += 1

    n = len(s)

    g = [False] * n

    j = 0

    for i, a in enumerate(s):
        if a.isupper():
            d = ord(a) - ord('A')
            if c[d] > 0:
                j += 1
                c[d] -= 1
                g[i] = True
        else:
            d = ord(a) - ord('a')
            if b[d] > 0:
                j += 1
                b[d] -= 1
                g[i] = True

    i = 0

    for i, a in enumerate(s):
        if g[i]:
            continue
        if a.isupper():
            d = ord(a) - ord('A')
            if b[d] > 0:
                i += 1
                b[d] -= 1
        else:
            d = ord(a) - ord('a')
            if c[d] > 0:
                i += 1
                c[d] -= 1

    h.stdout.write(f""{j} {i}\n"")

if __name__ == ""__main__"":
    f()"
152,B,Steps,PROGRAMMING,"['binary search', 'implementation']","One day Vasya went out for a walk in the yard but there weren't any of his friends outside and he had no one to play touch and run. But the boy didn't lose the high spirits and decided to play touch and run with himself. You may ask: ""How did he do that?"" The answer is simple.

Vasya noticed that the yard is a rectangular *n*<=×<=*m* field. The squares have coordinates (*x*,<=*y*) (1<=≤<=*x*<=≤<=*n*,<=1<=≤<=*y*<=≤<=*m*), where *x* is the index of the row and *y* is the index of the column.

Initially Vasya stands in the square with coordinates (*x**c*,<=*y**c*). To play, he has got a list of *k* vectors (*dx**i*,<=*dy**i*) of non-zero length. The game goes like this. The boy considers all vectors in the order from 1 to *k*, and consecutively chooses each vector as the current one. After the boy has chosen a current vector, he makes the maximally possible number of valid steps in the vector's direction (it is possible that he makes zero steps).

A step is defined as one movement from the square where the boy is standing now, in the direction of the current vector. That is, if Vasya is positioned in square (*x*,<=*y*), and the current vector is (*dx*,<=*dy*), one step moves Vasya to square (*x*<=+<=*dx*,<=*y*<=+<=*dy*). A step is considered valid, if the boy does not go out of the yard if he performs the step.

Vasya stepped on and on, on and on until he ran out of vectors in his list. Ha had been stepping for so long that he completely forgot how many steps he had made. Help the boy and count how many steps he had made.","The first input line contains two integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=109) — the yard's sizes. The second line contains integers *x**c* and *y**c* — the initial square's coordinates (1<=≤<=*x**c*<=≤<=*n*,<=1<=≤<=*y**c*<=≤<=*m*).

The third line contains an integer *k* (1<=≤<=*k*<=≤<=104) — the number of vectors. Then follow *k* lines, each of them contains two integers *dx**i* and *dy**i* (|*dx**i*|,<=|*dy**i*|<=≤<=109,<=|*dx*|<=+<=|*dy*|<=≥<=1).","Print the single number — the number of steps Vasya had made.

Please do not use the %lld specificator to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specificator.","['4 5\n1 1\n3\n1 1\n1 1\n0 -2\n', '10 10\n1 2\n1\n-1 0\n']","['4\n', '0\n']","In the first sample Vasya is initially positioned at square (1, 1) and makes 3 steps by the first vector (1, 1). So, he consecutively visits the squares (2, 2), (3, 3), (4, 4). Then he makes 0 steps by the second vector (1, 1). He makes 1 more step by the third vector (0,  - 2) and he ends up in square (4, 2). Overall, Vasya makes 4 steps.

In the second sample Vasya is initially positioned in square (1, 2) and makes 0 steps by vector ( - 1, 0), as the square with coordinates (0, 2) is located outside the yard.",WRONG_ANSWER,"def b(x,y):
    global n,m
    if x>0 and x<=n and y>0 and y<=m:
        return True
    return False

n,m=list(map(int,input().split()));g=list(map(int,input().split()));k=int(input());h=0
for i in range(k):
    c=10**9;f=0;a=[]
    x,y=list(map(int,input().split()))
    while f<=c:
        e=int((c+f)/2)
        if b(g[0]+x*e,g[1]+y*e):f=e+1
        else: c=e-1
    d=e;g[0]+=d*x;g[1]+=d*y
    h+=d
print(h)","def c():
    import d

    b = d.stdin.read().split()
    n = int(b[0])

    e = set(map(int, b[1:1 + n]))

    a = 1
    while a in e:
        a += 1

    print(a)

if __name__ == ""__main__"":
    c()"
952,A,Quirky Quantifiers,PROGRAMMING,['math'],"The input contains a single integer *a* (10<=≤<=*a*<=≤<=999).

Output 0 or 1.",The input contains a single integer *a* (10<=≤<=*a*<=≤<=999).,Output 0 or 1.,"['13\n', '927\n', '48\n']","['1\n', '1\n', '0\n']",none,WRONG_ANSWER,"def a():
    s = input()
    return 0

print(a())","def b():

    n = int(input().strip())

    c = []

    for i in range(n):

        for a in ['a', 'b']:

            if i < 2 or c[i - 2] != a:
                c.append(a)
                break
        else:

            c.append('c')

    print(''.join(c))

if __name__ == ""__main__"":
    b()"
268,A,Games,PROGRAMMING,['brute force'],"Manao works on a sports TV. He's spent much time watching the football games of some country. After a while he began to notice different patterns. For example, each team has two sets of uniforms: home uniform and guest uniform. When a team plays a game at home, the players put on the home uniform. When a team plays as a guest on somebody else's stadium, the players put on the guest uniform. The only exception to that rule is: when the home uniform color of the host team matches the guests' uniform, the host team puts on its guest uniform as well. For each team the color of the home and guest uniform is different.

There are *n* teams taking part in the national championship. The championship consists of *n*·(*n*<=-<=1) games: each team invites each other team to its stadium. At this point Manao wondered: how many times during the championship is a host team going to put on the guest uniform? Note that the order of the games does not affect this number.

You know the colors of the home and guest uniform for each team. For simplicity, the colors are numbered by integers in such a way that no two distinct colors have the same number. Help Manao find the answer to his question.","The first line contains an integer *n* (2<=≤<=*n*<=≤<=30). Each of the following *n* lines contains a pair of distinct space-separated integers *h**i*, *a**i* (1<=≤<=*h**i*,<=*a**i*<=≤<=100) — the colors of the *i*-th team's home and guest uniforms, respectively.",In a single line print the number of games where the host team is going to play in the guest uniform.,"['3\n1 2\n2 4\n3 4\n', '4\n100 42\n42 100\n5 42\n100 5\n', '2\n1 2\n1 2\n']","['1\n', '5\n', '0\n']","In the first test case the championship consists of 6 games. The only game with the event in question is the game between teams 2 and 1 on the stadium of team 2.

In the second test sample the host team will have to wear guest uniform in the games between teams: 1 and 2, 2 and 1, 2 and 3, 3 and 4, 4 and 2 (the host team is written first).",OK,"import h
import string

input = h.stdin.readline

def print(*a, b='\n', f=' ') -> None:
    h.stdout.write(f.join(map(str, a)) + b)

def g(d: list, c: list) -> str:
    c = 0
    for i in d:
        c += c.count(i)

    print(c)

def e() -> None:
    n = int(input())
    d, c = zip(*[input().strip().split() for i in range(n)])

    g(d, c)

if __name__ == '__main__':
    e()","def b():
    import f
    a = f.stdin.read().splitlines()

    n = int(a[0])

    c = 0
    d = 0
    e = 0

    for i in range(1, n + 1):
        x, y, z = map(int, a[i].split())
        c += x
        d += y
        e += z

    if c == 0 and d == 0 and e == 0:
        print(""YES"")
    else:
        print(""NO"")

if __name__ == '__main__':
    b()"
803,C,Maximal GCD,PROGRAMMING,"['constructive algorithms', 'greedy', 'math']","You are given positive integer number *n*. You should create such strictly increasing sequence of *k* positive numbers *a*1,<=*a*2,<=...,<=*a**k*, that their sum is equal to *n* and greatest common divisor is maximal.

Greatest common divisor of sequence is maximum of such numbers that every element of sequence is divisible by them.

If there is no possible sequence then output -1.","The first line consists of two numbers *n* and *k* (1<=≤<=*n*,<=*k*<=≤<=1010).","If the answer exists then output *k* numbers — resulting sequence. Otherwise output -1. If there are multiple answers, print any of them.","['6 3\n', '8 2\n', '5 3\n']","['1 2 3\n', '2 6\n', '-1\n']",none,OK,"def b(x):
	a=[]
	for i in range(1,int(x**(1/2)+1)):
		if x%i==0:
			a.append(i)
			if i!=x//i:
				a.append(x//i)
	return a

n,k=[int(x) for x in input().split()]
c=sorted(b(n))
d=0

for i in c:
	if i*(k*(k+1)//2)<=n:
		d=i
  
  
if d:
	e=[d*i for i in range(1,k+1)]
	e[-1]+=n-sum(e)
	print(*e)
else:
	print(-1)","import s
from collections import f

def k():

    e = s.stdin.read().split()
    if not e:
        return
    n = int(e[0])
    m = int(e[1])
    j = e[2:]

    b = [[-1] * m for _ in range(n)]

    c = []
    d = 0

    g = [(-1, 0), (1, 0), (0, -1), (0, 1)]

    for i in range(n):
        for j in range(m):
            if j[i][j] == '.' and b[i][j] == -1:

                o = f()
                o.append((i, j))
                b[i][j] = d
                r = 1
                while o:
                    x, y = o.popleft()
                    for h, i in g:
                        l, m = x + h, y + i
                        if 0 <= l < n and 0 <= m < m:
                            if j[l][m] == '.' and b[l][m] == -1:
                                b[l][m] = d
                                o.append((l, m))
                                r += 1
                c.append(r)
                d += 1

    n = []
    for i in range(n):
        p = []
        for j in range(m):
            if j[i][j] == '.':

                p.append('.')
            else:

                q = set()
                t = 1
                for h, i in g:
                    l, m = i + h, j + i
                    if 0 <= l < n and 0 <= m < m:
                        a = b[l][m]
                        if a != -1 and a not in q:
                            q.add(a)
                            t += c[a]

                p.append(str(t % 10))
        n.append("""".join(p))
    
    s.stdout.write(""\n"".join(n))

if __name__ == '__main__':
    k()"
611,B,New Year and Old Property,PROGRAMMING,"['bitmasks', 'brute force', 'implementation']","The year 2015 is almost over.

Limak is a little polar bear. He has recently learnt about the binary system. He noticed that the passing year has exactly one zero in its representation in the binary system — 201510<==<=111110111112. Note that he doesn't care about the number of zeros in the decimal representation.

Limak chose some interval of years. He is going to count all years from this interval that have exactly one zero in the binary representation. Can you do it faster?

Assume that all positive integers are always written without leading zeros.",The only line of the input contains two integers *a* and *b* (1<=≤<=*a*<=≤<=*b*<=≤<=1018) — the first year and the last year in Limak's interval respectively.,Print one integer – the number of years Limak will count in his chosen interval.,"['5 10\n', '2015 2015\n', '100 105\n', '72057594000000000 72057595000000000\n']","['2\n', '1\n', '0\n', '26\n']","In the first sample Limak's interval contains numbers 5<sub class=""lower-index"">10</sub> = 101<sub class=""lower-index"">2</sub>, 6<sub class=""lower-index"">10</sub> = 110<sub class=""lower-index"">2</sub>, 7<sub class=""lower-index"">10</sub> = 111<sub class=""lower-index"">2</sub>, 8<sub class=""lower-index"">10</sub> = 1000<sub class=""lower-index"">2</sub>, 9<sub class=""lower-index"">10</sub> = 1001<sub class=""lower-index"">2</sub> and 10<sub class=""lower-index"">10</sub> = 1010<sub class=""lower-index"">2</sub>. Two of them (101<sub class=""lower-index"">2</sub> and 110<sub class=""lower-index"">2</sub>) have the described property.",WRONG_ANSWER,"c = 1000000007

from collections import Counter,defaultdict,deque
from heapq import heappush,heappop,heapify
import sys
import b
import bisect

a,b = map(int,input().split())
x = int(b.log2(a))
A = bin(a)[2:]
B = bin(b)[2:]
if b<int(b.pow(2,x+1)):
   p=0
   for i in range(x+1):
      if A[i]=='0':
         p=i-1
         break
   q=0
   for i in range(x+1):
      if B[i]=='0':
         q=i-1
         break
   print(q-p)

else:
   a=0
   q=0
   y = int(b.log2(b))
   for i in range(x+1):
      if A[i]=='0':
         q=i-1
         break
   
   for i in range(y+1):
      if B[i]=='0':
         a+=(i-1)
         break

   a+=(x-q)

   for i in range(x+1,y):
      a+=i
   print(a)","import g

def e():

    b = g.stdin.read().split()
    if not b:
        return

    n = int(b[0])
    w = int(b[1])

    a = list(map(int, b[2:2+n]))
    b = list(map(int, b[2+n:2+n+w]))

    if w == 1:
        print(n)
        return

    c = [a[i+1] - a[i] for i in range(n-1)]
    d = [b[i+1] - b[i] for i in range(w-1)]

    m = len(d)
    f = [0] * m
    j = 0
    for i in range(1, m):
        while j > 0 and d[i] != d[j]:
            j = f[j-1]
        if d[i] == d[j]:
            j += 1
            f[i] = j

    a = 0
    j = 0
    for i in range(len(c)):
        while j > 0 and c[i] != d[j]:
            j = f[j-1]
        if c[i] == d[j]:
            j += 1
        if j == m:

            a += 1
            j = f[j-1]

    print(a)

if __name__ == ""__main__"":
    e()"
27,A,Next Test,PROGRAMMING,"['implementation', 'sortings']","«Polygon» is a system which allows to create programming tasks in a simple and professional way. When you add a test to the problem, the corresponding form asks you for the test index. As in most cases it is clear which index the next test will have, the system suggests the default value of the index. It is calculated as the smallest positive integer which is not used as an index for some previously added test.

You are to implement this feature. Create a program which determines the default index of the next test, given the indexes of the previously added tests.","The first line contains one integer *n* (1<=≤<=*n*<=≤<=3000) — the amount of previously added tests. The second line contains *n* distinct integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=3000) — indexes of these tests.",Output the required default value for the next test index.,['3\n1 7 2\n'],['3\n'],none,OK,"def c():
    n = int(input())
    a = list(map(int, input().split()))

    b = 1
    a.sort()

    for i in a:
        if i != b:
            print(b)
            exit()
        b += 1

    print(b)

c()","def l():
    import m
    from bisect import b, c

    f = m.stdin.read().strip().split()
    if not f:
        return

    n = int(f[0])
    x = int(f[1])
    k = int(f[2])

    a = list(map(int, f[3:3+n]))
    a.sort()

    n = 0

    for i in range(n):
        L = a[i]

        T = (L - 1) // x + k

        k = max(L, T * x)
        i = T * x + x - 1

        j = b(a, k, i, n)
        h = c(a, i, i, n)
        e = h - j
        n += e

    g = 0
    i = 0
    while i < n:
        j = i
        while j < n and a[j] == a[i]:
            j += 1
        d = j - i

        if (a[i] % x == 0 and k == 1) or (a[i] % x != 0 and k == 0):
            g += d * (d - 1) // 2
        i = j

    a = n + g
    m.stdout.write(str(a))

if __name__ == '__main__':
    l()"
747,B,Mammoth's Genome Decoding,PROGRAMMING,"['implementation', 'strings']","The process of mammoth's genome decoding in Berland comes to its end!

One of the few remaining tasks is to restore unrecognized nucleotides in a found chain *s*. Each nucleotide is coded with a capital letter of English alphabet: 'A', 'C', 'G' or 'T'. Unrecognized nucleotides are coded by a question mark '?'. Thus, *s* is a string consisting of letters 'A', 'C', 'G', 'T' and characters '?'.

It is known that the number of nucleotides of each of the four types in the decoded genome of mammoth in Berland should be equal.

Your task is to decode the genome and replace each unrecognized nucleotide with one of the four types so that the number of nucleotides of each of the four types becomes equal.","The first line contains the integer *n* (4<=≤<=*n*<=≤<=255) — the length of the genome.

The second line contains the string *s* of length *n* — the coded genome. It consists of characters 'A', 'C', 'G', 'T' and '?'.","If it is possible to decode the genome, print it. If there are multiple answer, print any of them. If it is not possible, print three equals signs in a row: ""==="" (without quotes).","['8\nAG?C??CT\n', '4\nAGCT\n', '6\n????G?\n', '4\nAA??\n']","['AGACGTCT\n', 'AGCT\n', '===\n', '===\n']","In the first example you can replace the first question mark with the letter 'A', the second question mark with the letter 'G', the third question mark with the letter 'T', then each nucleotide in the genome would be presented twice.

In the second example the genome is already decoded correctly and each nucleotide is exactly once in it.

In the third and the fourth examples it is impossible to decode the genom.",OK,"def f(s):
    a = ['A', 'C', 'G', 'T']

    d = {}
    for b in s:
        if b != '?':
            d[b] = d.get(b, 0) + 1

    if len(s) % 4 != 0 or any(c * 4 > len(s) for c in d.values()):
        return ""===""

    e = []
    for b in s:
        if b == '?':
            for g in a:
                if d.get(g, 0) * 4 != len(s):
                    e.append(g)
                    d[g] = d.get(g, 0) + 1
                    break
        else:
            e.append(b)

    return ''.join(e)

_ = int(input())
s = input()
print(f(s))","def g():
    import q
    a = q.stdin.read().splitlines()
    if not a:
        return

    n = int(a[0])
    m = a[1].strip()
    n = a[2].strip()

    i = list(range(26))
    j = [0] * 26

    def b(x):
        if i[x] != x:
            i[x] = b(i[x])
        return i[x]

    def r(x, y):
        k = b(x)
        l = b(y)
        if k == l:
            return False

        if j[k] < j[l]:
            i[k] = l
        elif j[k] > j[l]:
            i[l] = k
        else:
            i[l] = k
            j[k] += 1
        return True

    p = []

    for a, b in zip(m, n):
        c = ord(a) - ord('a')
        d = ord(b) - ord('a')
        if r(c, d):

            e = chr(c + ord('a'))
            f = chr(d + ord('a'))
            if e <= f:
                p.append((e, f))
            else:
                p.append((f, e))

    h = []
    h.append(str(len(p)))
    for o in p:
        h.append(f""{o[0]} {o[1]}"")
    q.stdout.write(""\n"".join(h))

if __name__ == ""__main__"":
    g()"
81,A,Plug-in,PROGRAMMING,['implementation'],"Polycarp thinks about the meaning of life very often. He does this constantly, even when typing in the editor. Every time he starts brooding he can no longer fully concentrate and repeatedly presses the keys that need to be pressed only once. For example, instead of the phrase ""how are you"" he can type ""hhoow aaaare yyoouu"". 

Polycarp decided to automate the process of correcting such errors. He decided to write a plug-in to the text editor that will remove pairs of identical consecutive letters (if there are any in the text). Of course, this is not exactly what Polycarp needs, but he's got to start from something! 

Help Polycarp and write the main plug-in module. Your program should remove from a string all pairs of identical letters, which are consecutive. If after the removal there appear new pairs, the program should remove them as well. Technically, its work should be equivalent to the following: while the string contains a pair of consecutive identical letters, the pair should be deleted. Note that deleting of the consecutive identical letters can be done in any order, as any order leads to the same result.",The input data consists of a single line to be processed. The length of the line is from 1 to 2·105 characters inclusive. The string contains only lowercase Latin letters.,Print the given string after it is processed. It is guaranteed that the result will contain at least one character.,"['hhoowaaaareyyoouu\n', 'reallazy\n', 'abacabaabacabaa\n']","['wre', 'rezy', 'a']",none,WRONG_ANSWER,"def c(b):
    for a, i in enumerate(b):
        for j in range(a + 1, len(b)):
            if b[a] == b[j]:
                b = b.replace(b[a], '',1)
                b = b.replace(b[a], '',1)
                return c(b)
            break
         
    return b

print(c(""abacabaabacabaa""))","import f

def d():

    c = f.stdin.read().split()

    n = int(c[-1])

    b = list(map(int, str(n)))

    e = []

    while any(b):
        a = []

        for i in range(len(b)):

            if b[i] > 0:
                a.append('1')
                b[i] -= 1
            else:

                a.append('0')

        e.append(str(int("""".join(a))))

    print(len(e))
    print("" "".join(e))

if __name__ == ""__main__"":
    d()"
0,none,none,none,['none'],"Farmer John has just given the cows a program to play with! The program contains two integer variables, *x* and *y*, and performs the following operations on a sequence *a*1,<=*a*2,<=...,<=*a**n* of positive integers:
 1.  Initially, *x*<==<=1 and *y*<==<=0. If, after any step, *x*<=≤<=0 or *x*<=&gt;<=*n*, the program immediately terminates. 1.  The program increases both *x* and *y* by a value equal to *a**x* simultaneously. 1.  The program now increases *y* by *a**x* while decreasing *x* by *a**x*. 1.  The program executes steps 2 and 3 (first step 2, then step 3) repeatedly until it terminates (it may never terminate). So, the sequence of executed steps may start with: step 2, step 3, step 2, step 3, step 2 and so on. 
The cows are not very good at arithmetic though, and they want to see how the program works. Please help them!

You are given the sequence *a*2,<=*a*3,<=...,<=*a**n*. Suppose for each *i* (1<=≤<=*i*<=≤<=*n*<=-<=1) we run the program on the sequence *i*,<=*a*2,<=*a*3,<=...,<=*a**n*. For each such run output the final value of *y* if the program terminates or -1 if it does not terminate.","The first line contains a single integer, *n* (2<=≤<=*n*<=≤<=2·105). The next line contains *n*<=-<=1 space separated integers, *a*2,<=*a*3,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=109).","Output *n*<=-<=1 lines. On the *i*-th line, print the requested value when the program is run on the sequence *i*,<=*a*2,<=*a*3,<=...*a**n*.

Please do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.","['4\n2 4 1\n', '3\n1 2\n']","['3\n6\n8\n', '-1\n-1\n']","In the first sample 
 1.  For *i* = 1,  *x* becomes <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/d87035805e6f1c669693d86603da6d89c5730833.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> and *y* becomes 1 + 2 = 3. 1.  For *i* = 2,  *x* becomes <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/c59515a288e6cb9876590f520c031cb27e346525.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> and *y* becomes 2 + 4 = 6. 1.  For *i* = 3,  *x* becomes <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/62b52a6cff2221e154a9c36f7bb277ad6475a1b6.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> and *y* becomes 3 + 1 + 4 = 8.",WRONG_ANSWER,"import math
import time
c=[[float('inf') for i in range(2)] for j in range(200001)]
b=[0]*(200001)

def a(i,g,n,f):

  if i>=n or i<0:
    return g 
  
  if c[i][f]!=float('inf'):
    
    return g+c[i][f] 
  
  c[i][f]=-float('inf')

  e=i-b[i] if f else i+b[i]
  g+=b[i]
  g=a(e,g,n,f^1)
  c[i][f]=g 
  return g 

def d():

  n=int(input())
  a=list(map(int,input().split()))
  for i in range(1,n):
    b[i]=a[i-1]
  for i in range(len(c)):
    for j in range(len(c[0])):
      c[i][j]=float('inf')
  c[0][0]=-float('inf')
  r=[]
  for i in range(1,n):
    b[0]=i
    a(i,i,n,1)
    if c[i][1]!=-float('inf'):
      r.append(c[i][1])
    else:
      r.append(-1)
  return r 

r=d()

for e in r:
  print(e)","def a():

    n = int(input().strip())

    b = {}

    for _ in range(n):
        c = input().strip()
        if c in b:
            b[c] += 1
        else:
            b[c] = 1

    d = max(b, key=b.get)

    print(d)

if __name__ == ""__main__"":
    a()"
0,none,none,none,['none'],"Профиль горного хребта схематично задан в виде прямоугольной таблицы из символов «.» (пустое пространство) и «*» (часть горы). Каждый столбец таблицы содержит хотя бы одну «звёздочку». Гарантируется, что любой из символов «*» либо находится в нижней строке матрицы, либо непосредственно под ним находится другой символ «*». 

Маршрут туриста проходит через весь горный хребет слева направо. Каждый день турист перемещается вправо — в соседний столбец в схематичном изображении. Конечно, каждый раз он поднимается (или опускается) в самую верхнюю точку горы, которая находится в соответствующем столбце.

Считая, что изначально турист находится в самой верхней точке в первом столбце, а закончит свой маршрут в самой верхней точке в последнем столбце, найдите две величины:
 -  наибольший подъём за день (равен 0, если в профиле горного хребта нет ни одного подъёма), -  наибольший спуск за день (равен 0, если в профиле горного хребта нет ни одного спуска).","В первой строке входных данных записаны два целых числа *n* и *m* (1<=≤<=*n*,<=*m*<=≤<=100) — количество строк и столбцов в схематичном изображении соответственно.

Далее следуют *n* строк по *m* символов в каждой — схематичное изображение горного хребта. Каждый символ схематичного изображения — это либо «.», либо «*». Каждый столбец матрицы содержит хотя бы один символ «*». Гарантируется, что любой из символов «*» либо находится в нижней строке матрицы, либо непосредственно под ним находится другой символ «*».","Выведите через пробел два целых числа:
 -  величину наибольшего подъёма за день (или 0, если в профиле горного хребта нет ни одного подъёма), -  величину наибольшего спуска за день (или 0, если в профиле горного хребта нет ни одного спуска).","['6 11\n...........\n.........*.\n.*.......*.\n**.......*.\n**..*...**.\n***********\n', '5 5\n....*\n...**\n..***\n.****\n*****\n', '8 7\n.......\n.*.....\n.*.....\n.**....\n.**.*..\n.****.*\n.******\n*******\n']","['3 4\n', '1 0\n', '6 2\n']","В первом тестовом примере высоты гор равны: 3, 4, 1, 1, 2, 1, 1, 1, 2, 5, 1. Наибольший подъем равен 3 и находится между горой номер 9 (её высота равна 2) и горой номер 10 (её высота равна 5). Наибольший спуск равен 4 и находится между горой номер 10 (её высота равна 5) и горой номер 11 (её высота равна 1).

Во втором тестовом примере высоты гор равны: 1, 2, 3, 4, 5. Наибольший подъём равен 1 и находится, например, между горой номер 2 (ее высота равна 2) и горой номер 3 (её высота равна 3). Так как в данном горном хребте нет спусков, то величина наибольшего спуска равна 0.

В третьем тестовом примере высоты гор равны: 1, 7, 5, 3, 4, 2, 3. Наибольший подъём равен 6 и находится между горой номер 1 (её высота равна 1) и горой номер 2 (её высота равна 7). Наибольший спуск равен 2 и находится между горой номер 2 (её высота равна 7) и горой номер 3 (её высота равна 5). Такой же спуск находится между горой номер 5 (её высота равна 4) и горой номер 6 (её высота равна 2).",OK,"def a():
    n, m = [int(i) for i in input().split()]
    d = [list(input()) for i in range(n)]
    
    a = [0] * m
    for i in range(m):
        for j in range(n):
            if d[j][i] == '*':
                a[i] += 1
    
    x = y = 0
    for i in range(1, m):
        if a[i] > a[i - 1]: x = max(x, a[i] - a[i - 1])
        else: y = max(y, a[i - 1] - a[i])
    
    print(x, y)
    
    
a()","def e():
    import k
    c = k.stdin.read().splitlines()
    if not c:
        return
    n = int(c[0].strip())
    s = c[1].strip()

    if n % 4 != 0:
        print(""==="")
        return

    b = {'A': 0, 'C': 0, 'G': 0, 'T': 0}
    h = 0
    for a in s:
        if a in b:
            b[a] += 1
        elif a == '?':
            h += 1
    
    i = n // 4
    f = {}
    for g in ""ACGT"":
        f[g] = i - b[g]

        if f[g] < 0:
            print(""==="")
            return

    if sum(f.values()) != h:
        print(""==="")
        return

    j = []
    d = [""A"", ""C"", ""G"", ""T""]
    for a in s:
        if a != '?':
            j.append(a)
        else:

            for g in d:
                if f[g] > 0:
                    j.append(g)
                    f[g] -= 1
                    break

    print("""".join(j))

if __name__ == '__main__':
    e()"
58,A,Chat room,PROGRAMMING,"['greedy', 'strings']","Vasya has recently learned to type and log on to the Internet. He immediately entered a chat room and decided to say hello to everybody. Vasya typed the word *s*. It is considered that Vasya managed to say hello if several letters can be deleted from the typed word so that it resulted in the word ""hello"". For example, if Vasya types the word ""ahhellllloou"", it will be considered that he said hello, and if he types ""hlelo"", it will be considered that Vasya got misunderstood and he didn't manage to say hello. Determine whether Vasya managed to say hello by the given word *s*.","The first and only line contains the word *s*, which Vasya typed. This word consisits of small Latin letters, its length is no less that 1 and no more than 100 letters.","If Vasya managed to say hello, print ""YES"", otherwise print ""NO"".","['ahhellllloou\n', 'hlelo\n']","['YES\n', 'NO\n']",none,OK,"import f
input = f.stdin.readline

def c():
    return(int(input()))
def b():
    return(list(map(int,input().split())))
def d():
    s = input()
    return(list(s[:len(s) - 1]))
def e():
    return(map(int,input().split()))

s = d()
j = 0
c = False
g = 'h'
a = ['h', 'e', 'l', 'l', 'o']
for i in s:
    if i == g:
        j += 1
        if j == 5:
            c = True
            break
        g = a[j]
if c:
    print('YES')
else:
    print('NO')","n, m = map(int, input().split())

c = list(map(int, input().split()))

c.sort()

b = float('inf')

for i in range(m - n + 1):

    a = c[i + n - 1] - c[i]

    if a < b:
        b = a

print(b)"
50,A,Domino piling,PROGRAMMING,"['greedy', 'math']","You are given a rectangular board of *M*<=×<=*N* squares. Also you are given an unlimited number of standard domino pieces of 2<=×<=1 squares. You are allowed to rotate the pieces. You are asked to place as many dominoes as possible on the board so as to meet the following conditions:

1. Each domino completely covers two squares.

2. No two dominoes overlap.

3. Each domino lies entirely inside the board. It is allowed to touch the edges of the board.

Find the maximum number of dominoes, which can be placed under these restrictions.",In a single line you are given two integers *M* and *N* — board sizes in squares (1<=≤<=*M*<=≤<=*N*<=≤<=16).,"Output one number — the maximal number of dominoes, which can be placed.","['2 4\n', '3 3\n']","['4\n', '4\n']",none,WRONG_ANSWER,"def c(n): return list(input().split() for _ in range(n))
def b():return list(map(int,input().strip().split()))

n,m = b()

def f():
    s=min(n,m)

    if s%2!=0:
        s-=1

    a=s*s//2

    d=(n-s)*m
    e=(m-s)*n

    a+=d//2 + e//2
    print(a)

f()","def d():
    import f
    e = 1000000007
    a = f.stdin.read().split()
    
    if not a:
        return

    n = int(a[0])
    k = int(a[1])
    d = int(a[2])

    c = [0] * (n + 1)
    c[0] = 1
    for s in range(1, n + 1):
        for g in range(1, k + 1):
            if s - g < 0:
                break
            c[s] = (c[s] + c[s - g]) % e

    b = [0] * (n + 1)
    b[0] = 0
    for s in range(1, n + 1):
        for g in range(1, k + 1):
            if s - g < 0:
                break
            if g >= d:

                b[s] = (b[s] + c[s - g]) % e
            else:

                b[s] = (b[s] + b[s - g]) % e

    f.stdout.write(str(b[n] % e))

if __name__ == '__main__':
    d()"
508,A,Pasha and Pixels,PROGRAMMING,['brute force'],"Pasha loves his phone and also putting his hair up... But the hair is now irrelevant.

Pasha has installed a new game to his phone. The goal of the game is following. There is a rectangular field consisting of *n* row with *m* pixels in each row. Initially, all the pixels are colored white. In one move, Pasha can choose any pixel and color it black. In particular, he can choose the pixel that is already black, then after the boy's move the pixel does not change, that is, it remains black. Pasha loses the game when a 2<=×<=2 square consisting of black pixels is formed. 

Pasha has made a plan of *k* moves, according to which he will paint pixels. Each turn in his plan is represented as a pair of numbers *i* and *j*, denoting respectively the row and the column of the pixel to be colored on the current move.

Determine whether Pasha loses if he acts in accordance with his plan, and if he does, on what move the 2<=×<=2 square consisting of black pixels is formed.","The first line of the input contains three integers *n*,<=*m*,<=*k* (1<=≤<=*n*,<=*m*<=≤<=1000, 1<=≤<=*k*<=≤<=105) — the number of rows, the number of columns and the number of moves that Pasha is going to perform. 

The next *k* lines contain Pasha's moves in the order he makes them. Each line contains two integers *i* and *j* (1<=≤<=*i*<=≤<=*n*, 1<=≤<=*j*<=≤<=*m*), representing the row number and column number of the pixel that was painted during a move.","If Pasha loses, print the number of the move when the 2<=×<=2 square consisting of black pixels is formed.

If Pasha doesn't lose, that is, no 2<=×<=2 square consisting of black pixels is formed during the given *k* moves, print 0.","['2 2 4\n1 1\n1 2\n2 1\n2 2\n', '2 3 6\n2 3\n2 2\n1 3\n2 2\n1 2\n1 1\n', '5 3 7\n2 3\n1 2\n1 1\n4 1\n3 1\n5 3\n3 2\n']","['4\n', '5\n', '0\n']",none,RUNTIME_ERROR,"n,m,k=map(int,input(),b())
x=[(m+2)*[0] for i in range(n+2)]

def a(i,j):
    if x[i][j+1]==1 and x[i+1][j]==1 and x[i+1][j+1]==1:
        return True
    if x[i][j-1]==1 and x[i+1][j]==1 and x[i+1][j-1]==1:
        return True
    if x[i-1][j]==1 and x[i][j+1]==1 and x[i-1][j+1]==1:
        return True
    if x[i-1][j]==1 and x[i][j-1]==1 and x[i-1][j-1]==1:
        return True
    return False

for i in range(k):
    l,n=map(int,input().b())
    x[l][n]=1
    if a(l,n):
        print(i+1)
        break
else:
    print(0)","import d

def c():

    b = d.stdin.read().split()
    if not b:
        return

    n = int(b[0])
    c = int(b[1])

    e = list(map(int, b[2:2 + n]))

    a = 1

    for i in range(1, n):

        if e[i] - e[i - 1] <= c:
            a += 1
        else:

            a = 1

    print(a)

if __name__ == ""__main__"":
    c()"
719,B,Anatoly and Cockroaches,PROGRAMMING,['greedy'],"Anatoly lives in the university dorm as many other students do. As you know, cockroaches are also living there together with students. Cockroaches might be of two colors: black and red. There are *n* cockroaches living in Anatoly's room.

Anatoly just made all his cockroaches to form a single line. As he is a perfectionist, he would like the colors of cockroaches in the line to alternate. He has a can of black paint and a can of red paint. In one turn he can either swap any two cockroaches, or take any single cockroach and change it's color.

Help Anatoly find out the minimum number of turns he needs to make the colors of cockroaches in the line alternate.","The first line of the input contains a single integer *n* (1<=≤<=*n*<=≤<=100<=000) — the number of cockroaches.

The second line contains a string of length *n*, consisting of characters 'b' and 'r' that denote black cockroach and red cockroach respectively.",Print one integer — the minimum number of moves Anatoly has to perform in order to make the colors of cockroaches in the line to alternate.,"['5\nrbbrr\n', '5\nbbbbb\n', '3\nrbr\n']","['1\n', '2\n', '0\n']","In the first sample, Anatoly has to swap third and fourth cockroaches. He needs 1 turn to do this.

In the second sample, the optimum answer is to paint the second and the fourth cockroaches red. This requires 2 turns.

In the third sample, the colors of cockroaches in the line are alternating already, thus the answer is 0.",OK,"def a(s,i):
    c=[0,0]
    for x in range(len(s)):
        if s[x]!=i[x]:c[x%2]+=1
    return max(c)

n=int(input());s=input()
b=('rb'*(n//2+1))[:n]
c=('br'*(n//2+1))[:n]
print(min(a(s,b),a(s,c)))","import p

def l(n):
    """"""
    Given a price string in the specified format, parse it and return
    the total number of cents as an integer.
    """"""

    j = n.rfind('.')
    if j != -1 and len(n) - j - 1 == 2:

        f = n[:j]
        c = n[j+1:]

        e = f.replace('.', '')
        if e == """":
            e = ""0""
        d = int(e)
        b = int(c)
    else:

        e = n.replace('.', '')
        d = int(e)
        b = 0
    return d * 100 + b

def g(d):
    """"""
    Given an integer dollars value, return a string with thousand
    separators (dots) inserted as per the specification.
    """"""
    s = str(d)
    i = []

    while len(s) > 3:
        i.insert(0, s[-3:])
        s = s[:-3]
    i.insert(0, s)
    return ""."".join(i)

def h(q):
    """"""
    Convert a price in cents to the required string format.
    """"""
    d = q // 100
    b = q % 100

    f = g(d)
    if b == 0:
        return f
    else:

        return f""{f}.{b:02d}""

def k():

    a = p.stdin.readline().rstrip(""\n"")
    q = 0
    i = 0
    n = len(a)
    while i < n:

        o = i
        while i < n and a[i].isalpha():
            i += 1

        m = i
        while i < n and (a[i].isdigit() or a[i] == '.'):
            i += 1
        n = a[m:i]

        q += l(n)

    print(h(q))

if __name__ == ""__main__"":
    k()"
199,A,Hexadecimal's theorem,PROGRAMMING,"['brute force', 'constructive algorithms', 'implementation', 'number theory']","Recently, a chaotic virus Hexadecimal advanced a new theorem which will shake the Universe. She thinks that each Fibonacci number can be represented as sum of three not necessary different Fibonacci numbers.

Let's remember how Fibonacci numbers can be calculated. *F*0<==<=0, *F*1<==<=1, and all the next numbers are *F**i*<==<=*F**i*<=-<=2<=+<=*F**i*<=-<=1.

So, Fibonacci numbers make a sequence of numbers: 0, 1, 1, 2, 3, 5, 8, 13, ...

If you haven't run away from the PC in fear, you have to help the virus. Your task is to divide given Fibonacci number *n* by three not necessary different Fibonacci numbers or say that it is impossible.",The input contains of a single integer *n* (0<=≤<=*n*<=&lt;<=109) — the number that should be represented by the rules described above. It is guaranteed that *n* is a Fibonacci number.,"Output three required numbers: *a*, *b* and *c*. If there is no answer for the test you have to print ""I'm too stupid to solve this problem"" without the quotes.

If there are multiple answers, print any of them.","['3\n', '13\n']","['1 1 1\n', '2 3 8\n']",none,WRONG_ANSWER,"c = [0, 1]
def b(n):
    i = 1
    while i < n:
        c.append(i)
        i = c[-1] + c[-2]
    if i != n:
        return -1
    else:
        return len(c)

n = int(input())
a, b, c = 0, 0, 0
a = 1
if n == 1:
    a = 1
elif n == 2:
    a = 1
    b = 1
elif n == 3:
    a = 1
    b = 1
    c = 1
else:
    a = b(n)
    if a != -1:
        a = c[a-2]
        b = c[a-2]
        c = c[a-3]
if a != -1:
    print(a, b, c)
else:
    print(""I'm too stupid to solve this problem"")","def a():

    n = int(input())

    if n % 2 == 0:
        k = n // 2

        b = [2] * k
    else:

        k = (n - 3) // 2 + 1
        b = [3] + [2] * ((n - 3) // 2)

    print(k)

    print("" "".join(map(str, b)))

if __name__ == ""__main__"":
    a()"
221,A,Little Elephant and Function,PROGRAMMING,"['implementation', 'math']","The Little Elephant enjoys recursive functions.

This time he enjoys the sorting function. Let *a* is a permutation of an integers from 1 to *n*, inclusive, and *a**i* denotes the *i*-th element of the permutation. The Little Elephant's recursive function *f*(*x*), that sorts the first *x* permutation's elements, works as follows:
 -  If *x*<==<=1, exit the function. -  Otherwise, call *f*(*x*<=-<=1), and then make *swap*(*a**x*<=-<=1,<=*a**x*) (swap the *x*-th and (*x*<=-<=1)-th elements of *a*). 
The Little Elephant's teacher believes that this function does not work correctly. But that-be do not get an F, the Little Elephant wants to show the performance of its function. Help him, find a permutation of numbers from 1 to *n*, such that after performing the Little Elephant's function (that is call *f*(*n*)), the permutation will be sorted in ascending order.",A single line contains integer *n* (1<=≤<=*n*<=≤<=1000) — the size of permutation.,"In a single line print *n* distinct integers from 1 to *n* — the required permutation. Numbers in a line should be separated by spaces.

It is guaranteed that the answer exists.","['1\n', '2\n']","['1 ', '2 1 ']",none,OK,"import f
import math
def b(): return map(int, f.stdin.readline().split())
def e(): return f.stdin.readline().rstrip()
def c(): return int(f.stdin.readline())
def d(): return list(map(int, f.stdin.readline().split()))
def i(s): f.stdout.write(s + '\n')
def g(n): f.stdout.write(str(n) + '\n')
def h(a): f.stdout.write(' '.join([str(x) for x in a]) + '\n')

def a():
    n = c()
    if n==1:
        print(""1"")
        return
    elif n==2:
        print(""2 1"")
        return
    
    print(n, end="" "")
    for i in range(1,n):
        print(i, end="" "")
    print()

if __name__ == '__main__':
    t = 1
    for _ in range(t):
        a()","def g(k):

    a, b, c, d, e, f = k
    return (a + b + c)**2 - (a * a + c * c + e * e)

if __name__ == ""__main__"":
    import l

    for h in l.stdin:
        h = h.strip()
        if not h:
            continue

        i = list(map(int, h.split()))

        j = g(i)
        print(j)"
571,C,CNF 2,PROGRAMMING,"['constructive algorithms', 'dfs and similar', 'graphs', 'greedy']","'In Boolean logic, a formula is in conjunctive normal form (CNF) or clausal normal form if it is a conjunction of clauses, where a clause is a disjunction of literals' (cited from https://en.wikipedia.org/wiki/Conjunctive_normal_form)

In the other words, CNF is a formula of type , where &amp; represents a logical ""AND"" (conjunction),  represents a logical ""OR"" (disjunction), and *v**ij* are some boolean variables or their negations. Each statement in brackets is called a clause, and *v**ij* are called literals.

You are given a CNF containing variables *x*1,<=...,<=*x**m* and their negations. We know that each variable occurs in at most two clauses (with negation and without negation in total). Your task is to determine whether this CNF is satisfiable, that is, whether there are such values of variables where the CNF value is true. If CNF is satisfiable, then you also need to determine the values of the variables at which the CNF is true. 

It is guaranteed that each variable occurs at most once in each clause.","The first line contains integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=2·105) — the number of clauses and the number variables, correspondingly.

Next *n* lines contain the descriptions of each clause. The *i*-th line first contains first number *k**i* (*k**i*<=≥<=1) — the number of literals in the *i*-th clauses. Then follow space-separated literals *v**ij* (1<=≤<=|*v**ij*|<=≤<=*m*). A literal that corresponds to *v**ij* is *x*|*v**ij*| either with negation, if *v**ij* is negative, or without negation otherwise.","If CNF is not satisfiable, print a single line ""NO"" (without the quotes), otherwise print two strings: string ""YES"" (without the quotes), and then a string of *m* numbers zero or one — the values of variables in satisfying assignment in the order from *x*1 to *x**m*.","['2 2\n2 1 -2\n2 2 -1\n', '4 3\n1 1\n1 2\n3 -1 -2 3\n1 -3\n', '5 6\n2 1 2\n3 1 -2 3\n4 -3 5 4 6\n2 -6 -4\n1 5\n']","['YES\n11\n', 'NO\n', 'YES\n100010\n']","In the first sample test formula is <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/5a8654a57efa13b47a585b7998c9defb42712ded.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>. One of possible answer is *x*<sub class=""lower-index"">1</sub> = *TRUE*, *x*<sub class=""lower-index"">2</sub> = *TRUE*.",TIME_LIMIT_EXCEEDED,"from itertools import * 
c=input()
n=int(c.split()[0])
m=int(c.split()[1])
d=[]
for i in range (n):
    c=input()
    k=int(c.split()[0])
    b=[]
    for i in range (1,k+1):
        b.append(int(c.split()[i]))
    d.append(b)

def g(f):
    e=[]
    for i in range (len(f)):
        t=[]
        for j in range(len(f[i])):
            t.append(f[i][j])
        e.append(t)
    return(e)
    
def k(f,a):
    n=len(f)
    e= g(f)

    k=[0]*n
    for i in range (n):
        for j in range (len(e[i])):
            if e[i][j]<0:

                x=abs(e[i][j])

                t=a[x-1]
                e[i][j]=abs(t-1)
            else:
                e[i][j]=a[e[i][j]-1]

    for i in range (n):
        for j in range(len(e[i])):
            if e[i][j]==1:
                k[i]=1
                break

    for i in range (n):
        if k[i]==0:

            return False
    return (True)

i=[]

for a in h(range(2),repeat=m):
    if k(d,a)==True:
        i=a
        break
if len(i)>0:
    j=""""
    for i in range(len(i)):
        j=j+str(i[i])
    print(""YES"")
    print(j)
else:
    print(""NO"")","def c():
    import d

    b = d.stdin.read().split()
    if not b:
        return
    n = int(b[0])
    
    a = 0

    for l in range(1, n // 2 + 1):
        if n % l == 0:
            a += 1

    d.stdout.write(str(a))

if __name__ == '__main__':
    c()"
455,A,Boredom,PROGRAMMING,['dp'],"Alex doesn't like boredom. That's why whenever he gets bored, he comes up with games. One long winter evening he came up with a game and decided to play it.

Given a sequence *a* consisting of *n* integers. The player can make several steps. In a single step he can choose an element of the sequence (let's denote it *a**k*) and delete it, at that all elements equal to *a**k*<=+<=1 and *a**k*<=-<=1 also must be deleted from the sequence. That step brings *a**k* points to the player. 

Alex is a perfectionist, so he decided to get as many points as possible. Help him.","The first line contains integer *n* (1<=≤<=*n*<=≤<=105) that shows how many numbers are in Alex's sequence. 

The second line contains *n* integers *a*1, *a*2, ..., *a**n* (1<=≤<=*a**i*<=≤<=105).",Print a single integer — the maximum number of points that Alex can earn.,"['2\n1 2\n', '3\n1 2 3\n', '9\n1 2 1 3 2 2 2 2 3\n']","['2\n', '4\n', '10\n']","Consider the third test example. At first step we need to choose any element equal to 2. After that step our sequence looks like this [2, 2, 2, 2]. Then we do 4 steps, on each step we choose any element equals to 2. In total we earn 10 points.",RUNTIME_ERROR,"b = [0]*10**5 + [0]

def a():
    input()
    for i in map(input().split()):
        b[i] += i
    a = 0
    b = 0
    for i in b:
        a, b = max(a, b+i), a
    print(a)

a()","def c():
    import e
    b = e.stdin.read().split()
    if not b:
        return

    n = int(b[0])

    a = list(map(int, b[1:1+n]))

    d = max(a)
    
    print(d)

if __name__ == '__main__':
    c()"
975,A,Aramic script,PROGRAMMING,"['implementation', 'strings']","In Aramic language words can only represent objects.

Words in Aramic have special properties: 
 -  A word is a root if it does not contain the same letter more than once. -  A root and all its permutations represent the same object. -  The root $x$ of a word $y$ is the word that contains all letters that appear in $y$ in a way that each letter appears once. For example, the root of ""aaaa"", ""aa"", ""aaa"" is ""a"", the root of ""aabb"", ""bab"", ""baabb"", ""ab"" is ""ab"". -  Any word in Aramic represents the same object as its root. 
You have an ancient script in Aramic. What is the number of different objects mentioned in the script?","The first line contains one integer $n$ ($1 \leq n \leq 10^3$) — the number of words in the script.

The second line contains $n$ words $s_1, s_2, \ldots, s_n$ — the script itself. The length of each string does not exceed $10^3$.

It is guaranteed that all characters of the strings are small latin letters.",Output one integer — the number of different objects mentioned in the given ancient Aramic script.,"['5\na aa aaa ab abb\n', '3\namer arem mrea\n']","['2', '1']","In the first test, there are two objects mentioned. The roots that represent them are ""a"",""ab"".

In the second test, there is only one object, its root is ""amer"", the other strings are just permutations of ""amer"".",TIME_LIMIT_EXCEEDED,"def c(a,h):
    for i in a:
        if i == h:
            return True
    return False

def d(h):
    e = """"
    for i in range(26):
        if c(h,chr(i+97)):
            e += chr(i+97)
    return e

f = int(input())
b = input().split(' ')
g = []
for i in b:
    if not c(g,d(i)):
        g.append(d(i))
print(len(g))","def b(h):

    if len(h) < 5:
        return False

    e = False
    d = False
    c = False

    for a in h:
        if a.isupper():
            e = True
        if a.islower():
            d = True
        if a.isdigit():
            c = True

    return e and d and c

def g():
    import i

    f = i.stdin.read().splitlines()

    for h in f:
        if b(h):
            print(""Correct"")
        else:
            print(""Too weak"")

if __name__ == ""__main__"":
    g()"
976,A,Minimum Binary Number,PROGRAMMING,['implementation'],"String can be called correct if it consists of characters ""0"" and ""1"" and there are no redundant leading zeroes. Here are some examples: ""0"", ""10"", ""1001"".

You are given a correct string *s*.

You can perform two different operations on this string: 
 1.  swap any pair of adjacent characters (for example, ""101""  ""110""); 1.  replace ""11"" with ""1"" (for example, ""110""  ""10""). 
Let *val*(*s*) be such a number that *s* is its binary representation.

Correct string *a* is less than some other correct string *b* iff *val*(*a*)<=&lt;<=*val*(*b*).

Your task is to find the minimum correct string that you can obtain from the given one using the operations described above. You can use these operations any number of times in any order (or even use no operations at all).","The first line contains integer number *n* (1<=≤<=*n*<=≤<=100) — the length of string *s*.

The second line contains the string *s* consisting of characters ""0"" and ""1"". It is guaranteed that the string *s* is correct.",Print one string — the minimum correct string that you can obtain from the given one.,"['4\n1001\n', '1\n1\n']","['100\n', '1\n']","In the first example you can obtain the answer by the following sequence of operations: ""1001"" <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> ""1010"" <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> ""1100"" <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> ""100"".

In the second example you can't obtain smaller answer no matter what operations you use.",WRONG_ANSWER,"import bisect
import math
import itertools
import sys

a = 'abcdefghijklmnopqrstuvwxyz'

def d(n,s):
    if s == '0':
        return 0
    c = s.count('1')
    f = s.count('0')
    return '1'*max(c-1,1) +'0'*f

    pass

t = 1
b = []
for _ in range(t):
    n = int(input())
    s = input()

    """"""cs = []
    for j in range(nx1y1x2y2c[-1]):
        cs.append([int(x) for x in input().split()])""""""
    """"""grid = []
    for j in range(n):
        grid.append(list(input()))""""""

    b.append(d(n,s))

for e in b:
    print(e)","def a(c, k):

    d = {}
    for b in c:
        if b != ' ':
            d[b] = d.get(b, 0) + 1

    l = {}
    for b in k:
        if b != ' ':
            l[b] = l.get(b, 0) + 1

    for f, g in l.items():
        if d.get(f, 0) < g:
            return False
    return True

if __name__ == '__main__':
    import j

    e = j.stdin.read().split('\n')
    
    if len(e) < 2:

        j.exit(1)
    
    h = e[0]
    i = e[1]
    
    if a(h, i):
        print(""YES"")
    else:
        print(""NO"")"
275,A,Lights Out,PROGRAMMING,['implementation'],"Lenny is playing a game on a 3<=×<=3 grid of lights. In the beginning of the game all lights are switched on. Pressing any of the lights will toggle it and all side-adjacent lights. The goal of the game is to switch all the lights off. We consider the toggling as follows: if the light was switched on then it will be switched off, if it was switched off then it will be switched on.

Lenny has spent some time playing with the grid and by now he has pressed each light a certain number of times. Given the number of times each light is pressed, you have to print the current state of each light.",The input consists of three rows. Each row contains three integers each between 0 to 100 inclusive. The *j*-th number in the *i*-th row is the number of times the *j*-th light of the *i*-th row of the grid is pressed.,"Print three lines, each containing three characters. The *j*-th character of the *i*-th line is ""1"" if and only if the corresponding light is switched on, otherwise it's ""0"".","['1 0 0\n0 0 0\n0 0 1\n', '1 0 1\n8 8 8\n2 0 3\n']","['001\n010\n100\n', '010\n011\n100\n']",none,OK,"a = [[1,1,1],[1,1,1],[1,1,1]]

b = []

def c(a):
    if a == 1:
        return 0
    else:
        return 1

for i in range(3):
    a = list(map(int,input().split()))
    b.append(a)

if b[0][0] % 2 != 0:
    a[0][0] = c(a[0][0])

    a[1][0] = c(a[1][0])
    a[0][1] = c(a[0][1])

if b[0][1] % 2 != 0:
    a[0][1] = c(a[0][1])

    a[0][0] = c(a[0][0])
    a[0][2] = c(a[0][2])
    a[1][1] = c(a[1][1])

if b[0][2] % 2 != 0:
    a[0][2] = c(a[0][2])

    a[0][1] = c(a[0][1])
    a[1][2] = c(a[1][2])

if b[1][0] % 2 != 0:
    a[1][0] = c(a[1][0])

    a[0][0] = c(a[0][0])
    a[1][1] = c(a[1][1])
    a[2][0] = c(a[2][0])

if b[1][1] % 2 != 0:
    a[1][1] = c(a[1][1])

    a[0][1] = c(a[0][1])
    a[1][0] = c(a[1][0])
    a[1][2] = c(a[1][2])
    a[2][1] = c(a[2][1])

if b[1][2] % 2 != 0:
    a[1][2] = c(a[1][2])

    a[0][2] = c(a[0][2])
    a[1][1] = c(a[1][1])
    a[2][2] = c(a[2][2])

if b[2][0] % 2 != 0:
    a[2][0] = c(a[2][0])

    a[1][0] = c(a[1][0])
    a[2][1] = c(a[2][1])

if b[2][1] % 2 != 0:
    a[2][1] = c(a[2][1])

    a[2][0] = c(a[2][0])
    a[1][1] = c(a[1][1])
    a[2][2] = c(a[2][2])

if b[2][2] % 2 != 0:
    a[2][2] = c(a[2][2])

    a[1][2] = c(a[1][2])
    a[2][1] = c(a[2][1])

for i in range(3):
    d = ''
    for j in range(3):
        d += str(a[i][j])
    print(d)","import o
from collections import e, d

def k():

    c = o.stdin.read().split()
    if not c:
        return

    p = int(c[0])
    r = int(c[1])
    q = int(c[2])
    s = int(c[3])
    n = int(c[4])
    j = 5

    a = d(set)

    for _ in range(n):
        r = int(c[j])
        a = int(c[j + 1])
        b = int(c[j + 2])
        j += 3

        for b in range(a, b + 1):
            a[r].add(b)

    i = e()
    i.append((p, r, 0))

    a[p].remove(r)
    if not a[p]:
        del a[p]

    l = [(-1, -1), (-1, 0), (-1, 1),
             (0, -1),           (0, 1),
             (1, -1),  (1, 0),  (1, 1)]
    
    while i:
        i, j, g = i.popleft()

        if i == q and j == s:
            print(g)
            return

        for f, h in l:
            m, n = i + f, j + h

            if m in a and n in a[m]:
                i.append((m, n, g + 1))
                a[m].remove(n)
                if not a[m]:
                    del a[m]

    print(-1)

if __name__ == '__main__':
    k()"
0,none,none,none,['none'],"First-rate specialists graduate from Berland State Institute of Peace and Friendship. You are one of the most talented students in this university. The education is not easy because you need to have fundamental knowledge in different areas, which sometimes are not related to each other. 

For example, you should know linguistics very well. You learn a structure of Reberland language as foreign language. In this language words are constructed according to the following rules. First you need to choose the ""root"" of the word — some string which has more than 4 letters. Then several strings with the length 2 or 3 symbols are appended to this word. The only restriction —  it is not allowed to append the same string twice in a row. All these strings are considered to be suffixes of the word (this time we use word ""suffix"" to describe a morpheme but not the few last characters of the string as you may used to). 

Here is one exercise that you have found in your task list. You are given the word *s*. Find all distinct strings with the length 2 or 3, which can be suffixes of this word according to the word constructing rules in Reberland language. 

Two strings are considered distinct if they have different length or there is a position in which corresponding characters do not match. 

Let's look at the example: the word *abacabaca* is given. This word can be obtained in the following ways: , where the root of the word is overlined, and suffixes are marked by ""corners"". Thus, the set of possible suffixes for this word is {*aca*,<=*ba*,<=*ca*}.",The only line contains a string *s* (5<=≤<=|*s*|<=≤<=104) consisting of lowercase English letters.,"On the first line print integer *k* — a number of distinct possible suffixes. On the next *k* lines print suffixes. 

Print suffixes in lexicographical (alphabetical) order.","['abacabaca\n', 'abaca\n']","['3\naca\nba\nca\n', '0\n']","The first test was analysed in the problem statement. 

In the second example the length of the string equals 5. The length of the root equals 5, so no string can be used as a suffix.",WRONG_ANSWER,"import d

d.setrecursionlimit(10001)

s = input()
a = set()
b = set()

def c(i):
    if i in b:
        return
    b.add(i)

    """"""
    (aa)(bb)で後ろのbbをaddすると
    (abb)(bb)でbbをaddできないので前のカタマリをaddする
    """"""

    if i > 6 and s[i - 2:i] != s[i:i + 2]:
        a.add(s[i - 2:i])
        c(i - 2)

    if i > 7 and s[i - 3:i] != s[i:i + 3]:
        a.add(s[i - 3:i])
        c(i - 3)

c(len(s))

print(len(a))
for x in sorted(list(a)):
    print(x)","def f(p, q, r):

    return (q[0] - p[0]) * (r[1] - p[1]) == (q[1] - p[1]) * (r[0] - p[0])

def a(h):
    n = len(h)
    if n <= 3:
        return True

    def c(a, b):
        g = []
        for p in h:
            if not f(a, b, p):
                g.append(p)

        if len(g) <= 2:
            return True

        c, d = g[0], g[1]
        for p in g:
            if not f(c, d, p):
                return False
        return True

    b = [(h[0], h[1]), (h[0], h[2]), (h[1], h[2])]
    for a, b in b:
        if c(a, b):
            return True
    return False

if __name__ == '__main__':
    import i
    d = i.stdin.read().split()
    if not d:
        i.exit(0)

    n = int(d[0])
    h = []
    e = 1
    for _ in range(n):
        x = int(d[e])
        y = int(d[e + 1])
        h.append((x, y))
        e += 2
    
    if a(h):
        i.stdout.write(""YES\n"")
    else:
        i.stdout.write(""NO\n"")"
66,B,Petya and Countryside,PROGRAMMING,"['brute force', 'implementation']","Little Petya often travels to his grandmother in the countryside. The grandmother has a large garden, which can be represented as a rectangle 1<=×<=*n* in size, when viewed from above. This rectangle is divided into *n* equal square sections. The garden is very unusual as each of the square sections possesses its own fixed height and due to the newest irrigation system we can create artificial rain above each section.

Creating artificial rain is an expensive operation. That's why we limit ourselves to creating the artificial rain only above one section. At that, the water from each watered section will flow into its neighbouring sections if their height does not exceed the height of the section. That is, for example, the garden can be represented by a 1<=×<=5 rectangle, where the section heights are equal to 4, 2, 3, 3, 2. Then if we create an artificial rain over any of the sections with the height of 3, the water will flow over all the sections, except the ones with the height of 4. See the illustration of this example at the picture:

As Petya is keen on programming, he decided to find such a section that if we create artificial rain above it, the number of watered sections will be maximal. Help him.",The first line contains a positive integer *n* (1<=≤<=*n*<=≤<=1000). The second line contains *n* positive integers which are the height of the sections. All the numbers are no less than 1 and not more than 1000.,"Print a single number, the maximal number of watered sections if we create artificial rain above exactly one section.","['1\n2\n', '5\n1 2 1 2 1\n', '8\n1 2 1 1 1 3 3 4\n']","['1\n', '3\n', '6\n']",none,OK,"def b():
    n = int(input())
    a = [int(i) for i in input().split()]

    max = 0
    c = 0
    for e in range(n):
        max = 1
        next = e + 1
        while next < n:
            if a[next] <= a[next-1]:
                max += 1
                next += 1
            else:
                break
        d = e - 1
        while d >= 0:
            if a[d] <= a[d+1]:
                max += 1
                d -= 1
            else:
                break
        if max > c:
            c = max
    print(c)
if __name__=='__main__':
    b()","import i
import h

def g():

    d = i.stdin.read().split()
    if not d:
        return
    t = int(d[0])
    w = int(d[1])
    b = int(d[2])

    if w == b:
        i.stdout.write(""1/1"")
        return

    d = h.gcd(w, b)

    k = w // d
    b = b // d

    r = min(w, b)

    a = (w * b) // d

    c = min(t, r - 1) if r > 1 else 0

    K = t // a

    j = c

    M = 0
    if t >= r:
        M = (t - r) // a
        M = min(M, K)

    j += M * r

    for k in range(M + 1, K + 1):
        f = k * a
        e = min(t, k * a + r - 1)
        if e >= f:
            j += (e - f + 1)

    g = h.gcd(j, t)
    p = j // g
    q = t // g
    i.stdout.write(f""{p}/{q}"")

if __name__ == '__main__':
    g()"
629,A,Far Relative’s Birthday Cake,PROGRAMMING,"['brute force', 'combinatorics', 'constructive algorithms', 'implementation']","Door's family is going celebrate Famil Doors's birthday party. They love Famil Door so they are planning to make his birthday cake weird!

The cake is a *n*<=×<=*n* square consisting of equal squares with side length 1. Each square is either empty or consists of a single chocolate. They bought the cake and randomly started to put the chocolates on the cake. The value of Famil Door's happiness will be equal to the number of pairs of cells with chocolates that are in the same row or in the same column of the cake. Famil Doors's family is wondering what is the amount of happiness of Famil going to be?

Please, note that any pair can be counted no more than once, as two different cells can't share both the same row and the same column.","In the first line of the input, you are given a single integer *n* (1<=≤<=*n*<=≤<=100) — the length of the side of the cake.

Then follow *n* lines, each containing *n* characters. Empty cells are denoted with '.', while cells that contain chocolates are denoted by 'C'.","Print the value of Famil Door's happiness, i.e. the number of pairs of chocolate pieces that share the same row or the same column.","['3\n.CC\nC..\nC.C\n', '4\nCC..\nC..C\n.CC.\n.CC.\n']","['4\n', '9\n']","If we number rows from top to bottom and columns from left to right, then, pieces that share the same row in the first sample are: 
 1.  (1, 2) and (1, 3) 1.  (3, 1) and (3, 3)  1.  (2, 1) and (3, 1) 1.  (1, 3) and (3, 3)",OK,"import d

h = int(input())

e = []

def f(x):
    if x>=2:
        y = d.factorial(x)
        y = y/((d.factorial(x-2))*2)
        return y
    else:
        return 0

for i in range(0,h):
    a = list(str(input()))
    e.append(a)

g = 0
c = 0

for i in range(0,h):
    b = 0
    for j in range(0,h):
        if e[i][j] == 'C':
            b += 1
    y = f(b)
    g += y

for i in range(0,h):
    b = 0
    for j in range(0,h):
        if e[j][i] == 'C':
            b += 1
    y = f(b)
    c += y

print(int(c)+int(g))","import e

def d():

    c = e.stdin.readline().strip()

    a, b = c.split()

    if a == b:
        print(a)
    else:

        print(""1"")

if __name__ == '__main__':
    d()"
230,B,T-primes,PROGRAMMING,"['binary search', 'implementation', 'math', 'number theory']","We know that prime numbers are positive integers that have exactly two distinct positive divisors. Similarly, we'll call a positive integer *t* Т-prime, if *t* has exactly three distinct positive divisors.

You are given an array of *n* positive integers. For each of them determine whether it is Т-prime or not.","The first line contains a single positive integer, *n* (1<=≤<=*n*<=≤<=105), showing how many numbers are in the array. The next line contains *n* space-separated integers *x**i* (1<=≤<=*x**i*<=≤<=1012).

Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is advised to use the cin, cout streams or the %I64d specifier.","Print *n* lines: the *i*-th line should contain ""YES"" (without the quotes), if number *x**i* is Т-prime, and ""NO"" (without the quotes), if it isn't.",['3\n4 5 6\n'],['YES\nNO\nNO\n'],"The given test has three numbers. The first number 4 has exactly three divisors — 1, 2 and 4, thus the answer for this number is ""YES"". The second number 5 has two divisors (1 and 5), and the third number 6 has four divisors (1, 2, 3, 6), hence the answer for them is ""NO"".",WRONG_ANSWER,"def a(c):
    x = int(c**0.5)
    if x*x != c:
        return False
    for i in range(2, int(x**0.5)+1):
        if x % i == 0:
            return False
    return True

n = int(input())
d = [int(x) for x in input().split()]
for b in d:
    print('YES' if a(b) else 'NO')","def c():
    import d

    b = d.stdin.read().split()
    if not b:
        return
    n = int(b[0])

    d = 3
    while n % d == 0:
        d *= 3

    a = (n + d - 1) // d
    
    d.stdout.write(str(a))

if __name__ == '__main__':
    c()"
424,A,Squats,PROGRAMMING,['implementation'],"Pasha has many hamsters and he makes them work out. Today, *n* hamsters (*n* is even) came to work out. The hamsters lined up and each hamster either sat down or stood up.

For another exercise, Pasha needs exactly  hamsters to stand up and the other hamsters to sit down. In one minute, Pasha can make some hamster ether sit down or stand up. How many minutes will he need to get what he wants if he acts optimally well?","The first line contains integer *n* (2<=≤<=*n*<=≤<=200; *n* is even). The next line contains *n* characters without spaces. These characters describe the hamsters' position: the *i*-th character equals 'X', if the *i*-th hamster in the row is standing, and 'x', if he is sitting.","In the first line, print a single integer — the minimum required number of minutes. In the second line, print a string that describes the hamsters' position after Pasha makes the required changes. If there are multiple optimal positions, print any of them.","['4\nxxXx\n', '2\nXX\n', '6\nxXXxXx\n']","['1\nXxXx\n', '1\nxX\n', '0\nxXXxXx\n']",none,OK,"def a(n, g):
	b = g.count('X')
	c = g.count('x')

	d = c-b

	if d<0:
		f = g.replace('X','x',abs(int(n/2) - b))
		return abs(int(n/2) - b) , f

	elif d>0:
		f = g.replace('x','X',abs(int(n/2) - b))
		return abs(int(n/2) - b), f

	else:
		return 0, g

n = int(input())
g = input()

e = a(n, g)
print(e[0])
print(e[1])","def g():
    import n
    c = n.stdin.read().strip().split()
    if not c:
        return
    f = iter(c)
    n = int(next(f))
    m = int(next(f))

    k = []
    for i in range(n):
        l = [int(next(f)) for _ in range(m)]
        j = [0] * m
        j[0] = l[0]
        for j in range(1, m):
            j[j] = j[j - 1] + l[j]
        k.append(j)

    h = -10**18
    e = [None] * m

    for j in range(m):
        e[j] = k[0][j]

    for i in range(1, n):
        d = [h] * m

        if i % 2 == 1:

            m = [h] * (m + 1)
            m[m] = h
            for j in range(m - 1, -1, -1):
                m[j] = e[j] if e[j] > m[j + 1] else m[j + 1]
            for j in range(m):

                b = m[j + 1] if j + 1 < m + 1 else h
                if b != h:
                    d[j] = k[i][j] + b
        else:

            i = [h] * (m + 1)
            i[0] = h
            for j in range(1, m + 1):
                if j == 1:
                    i[j] = e[0]
                else:
                    i[j] = e[j - 1] if e[j - 1] > i[j - 1] else i[j - 1]
            for j in range(m):

                b = i[j]
                if b != h:
                    d[j] = k[i][j] + b
        e = d
    
    a = max(e)
    n.stdout.write(str(a))
    
if __name__ == '__main__':
    g()"
205,A,Little Elephant and Rozdil,PROGRAMMING,"['brute force', 'implementation']","The Little Elephant loves Ukraine very much. Most of all he loves town Rozdol (ukr. ""Rozdil"").

However, Rozdil is dangerous to settle, so the Little Elephant wants to go to some other town. The Little Elephant doesn't like to spend much time on travelling, so for his journey he will choose a town that needs minimum time to travel to. If there are multiple such cities, then the Little Elephant won't go anywhere.

For each town except for Rozdil you know the time needed to travel to this town. Find the town the Little Elephant will go to or print ""Still Rozdil"", if he stays in Rozdil.","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=105) — the number of cities. The next line contains *n* integers, separated by single spaces: the *i*-th integer represents the time needed to go from town Rozdil to the *i*-th town. The time values are positive integers, not exceeding 109.

You can consider the cities numbered from 1 to *n*, inclusive. Rozdil is not among the numbered cities.","Print the answer on a single line — the number of the town the Little Elephant will go to. If there are multiple cities with minimum travel time, print ""Still Rozdil"" (without the quotes).","['2\n7 4\n', '7\n7 4 47 100 4 9 12\n']","['2\n', 'Still Rozdil\n']","In the first sample there are only two cities where the Little Elephant can go. The travel time for the first town equals 7, to the second one — 4. The town which is closest to Rodzil (the only one) is the second one, so the answer is 2.

In the second sample the closest cities are cities two and five, the travelling time to both of them equals 4, so the answer is ""Still Rozdil"".",OK,"n=int(input())
l=input().split("" "")
l=[int(x) for x in l]
c = {n: 1 for n in l}
s={}
b=min(l)
for i in l:

    if i in s:
      a=i
      s[a]=s.setdefault(a, 0) + 1
    else:
      a=i
      s[a]=s.setdefault(a, 1)
k=b
if(s.get(k)>1):
  print(""Still Rozdil"")
else:
  print(l.index(b)+1)","def d():

    n = int(input().strip())

    e = list(map(int, input().split()))

    g = []

    for c in e:

        b = list(map(int, input().split()))

        f = sum(a * 5 + 15 for a in b)
        
        g.append(f)

    print(min(g))

if __name__ == ""__main__"":
    d()"
258,A,Little Elephant and Bits,PROGRAMMING,"['greedy', 'math']","The Little Elephant has an integer *a*, written in the binary notation. He wants to write this number on a piece of paper.

To make sure that the number *a* fits on the piece of paper, the Little Elephant ought to delete exactly one any digit from number *a* in the binary record. At that a new number appears. It consists of the remaining binary digits, written in the corresponding order (possible, with leading zeroes).

The Little Elephant wants the number he is going to write on the paper to be as large as possible. Help him find the maximum number that he can obtain after deleting exactly one binary digit and print it in the binary notation.","The single line contains integer *a*, written in the binary notation without leading zeroes. This number contains more than 1 and at most 105 digits.",In the single line print the number that is written without leading zeroes in the binary notation — the answer to the problem.,"['101\n', '110010\n']","['11\n', '11010\n']","In the first sample the best strategy is to delete the second digit. That results in number 11<sub class=""lower-index"">2</sub> = 3<sub class=""lower-index"">10</sub>.

In the second sample the best strategy is to delete the third or fourth digits — that results in number 11010<sub class=""lower-index"">2</sub> = 26<sub class=""lower-index"">10</sub>.",OK,"def b():
	s=input()
	a=0
	l=len(s)
	for i in range(l):
		if (s[i]=='0' or i==l-1) and not a: 
			a=1
			continue
		print(s[i],end='')

if __name__=='__main__': b()","def b():

    a = list(map(int, input().split()))

    d = len(set(a))

    c = 4 - d

    print(c)

if __name__ == '__main__':
    b()"
767,A,Snacktower,PROGRAMMING,"['data structures', 'implementation']","According to an old legeng, a long time ago Ankh-Morpork residents did something wrong to miss Fortune, and she cursed them. She said that at some time *n* snacks of distinct sizes will fall on the city, and the residents should build a Snacktower of them by placing snacks one on another. Of course, big snacks should be at the bottom of the tower, while small snacks should be at the top.

Years passed, and once different snacks started to fall onto the city, and the residents began to build the Snacktower.

However, they faced some troubles. Each day exactly one snack fell onto the city, but their order was strange. So, at some days the residents weren't able to put the new stack on the top of the Snacktower: they had to wait until all the bigger snacks fell. Of course, in order to not to anger miss Fortune again, the residents placed each snack on the top of the tower immediately as they could do it.

Write a program that models the behavior of Ankh-Morpork residents.","The first line contains single integer *n* (1<=≤<=*n*<=≤<=100<=000) — the total number of snacks.

The second line contains *n* integers, the *i*-th of them equals the size of the snack which fell on the *i*-th day. Sizes are distinct integers from 1 to *n*.","Print *n* lines. On the *i*-th of them print the sizes of the snacks which the residents placed on the top of the Snacktower on the *i*-th day in the order they will do that. If no snack is placed on some day, leave the corresponding line empty.","['3\n3 1 2\n', '5\n4 5 1 2 3\n']","['3\n\xa0\n2 1', '5 4\n\xa0\n\xa0\n3 2 1\n']","In the example a snack of size 3 fell on the first day, and the residents immediately placed it. On the second day a snack of size 1 fell, and the residents weren't able to place it because they were missing the snack of size 2. On the third day a snack of size 2 fell, and the residents immediately placed it. Right after that they placed the snack of size 1 which had fallen before.",TIME_LIMIT_EXCEEDED,"def c(h, v):
    b=[0]*(h+1)
    d=h
    a=""""
    for i in v:
        b[i]=1
        while d>0 and b[d]==1:
             a+=str(d) + "" ""
             d-=1
        a+=""\n""
    return a

h=int(input())
v=list(map(int,input().split()))
print(c(h,v))","def c():

    n = int(input().strip())

    b = list(map(int, input().split()))

    def d(x):
        while x % 2 == 0:
            x //= 2
        while x % 3 == 0:
            x //= 3
        return x

    e = d(b[0])

    for a in b:
        if d(a) != e:
            print(""No"")
            return
    
    print(""Yes"")

if __name__ == ""__main__"":
    c()"
0,none,none,none,['none'],"Arkady needs your help again! This time he decided to build his own high-speed Internet exchange point. It should consist of *n* nodes connected with minimum possible number of wires into one network (a wire directly connects two nodes). Exactly *k* of the nodes should be exit-nodes, that means that each of them should be connected to exactly one other node of the network, while all other nodes should be connected to at least two nodes in order to increase the system stability.

Arkady wants to make the system as fast as possible, so he wants to minimize the maximum distance between two exit-nodes. The distance between two nodes is the number of wires a package needs to go through between those two nodes.

Help Arkady to find such a way to build the network that the distance between the two most distant exit-nodes is as small as possible.","The first line contains two integers *n* and *k* (3<=≤<=*n*<=≤<=2·105, 2<=≤<=*k*<=≤<=*n*<=-<=1) — the total number of nodes and the number of exit-nodes.

Note that it is always possible to build at least one network with *n* nodes and *k* exit-nodes within the given constraints.","In the first line print the minimum possible distance between the two most distant exit-nodes. In each of the next *n*<=-<=1 lines print two integers: the ids of the nodes connected by a wire. The description of each wire should be printed exactly once. You can print wires and wires' ends in arbitrary order. The nodes should be numbered from 1 to *n*. Exit-nodes can have any ids.

If there are multiple answers, print any of them.","['3 2\n', '5 3\n']","['2\n1 2\n2 3\n', '3\n1 2\n2 3\n3 4\n3 5\n']","In the first example the only network is shown on the left picture.

In the second example one of optimal networks is shown on the right picture.

Exit-nodes are highlighted.",RUNTIME_ERROR,"from sys import f, g

def c(v, d):
    j[v] = 1
    e = d
    
    for u in i[v]:
        if not j[u]:
            e = max(e, c(u, d + 1))
    
    return e    

n, k = map(int, f.readline().split())
b = []
a = []

for i in range(2, k + 2):
    a.append((1, i))
    b.append(i)

n = n - k - 1
v = k + 2

for i in range(n // k):
    h = []
    
    for u in b:
        h.append(v)
        a.append((u, v))
        v += 1
    
    b = h[:]

for u in b[:n % k]:
    a.append((u, v))
    v += 1

j = [0 for i in range(v)]
i = [[] for i in range(v)]

for a, b in a:
    i[a].append(b)
    i[b].append(a)

g.write(str(c(v - 1, 0)) + '\n')
for a, b in a:
    g.write(str(a) + ' ' + str(b) + '\n')","def f(a, b):

    d = [b]
    
    while b > a:
        if b % 10 == 1:

            b = (b - 1) // 10
            d.append(b)
        elif b % 2 == 0:

            b //= 2
            d.append(b)
        else:
            break

    if b == a:
        return True, d[::-1]
    else:
        return False, None

def b():
    import e
    a = e.stdin.readline().strip()

    if not a:
        return
    a, b = map(int, a.split())
    
    c, d = f(a, b)
    
    if not c:
        print(""NO"")
    else:

        print(""YES"")
        print(len(d))

        print("" "".join(map(str, d)))

if __name__ == ""__main__"":
    b()"
39,G,Inverse Function,PROGRAMMING,['implementation'],"Petya wrote a programme on C++ that calculated a very interesting function *f*(*n*). Petya ran the program with a certain value of *n* and went to the kitchen to have some tea. The history has no records concerning how long the program had been working. By the time Petya returned, it had completed the calculations and had the result. However while Petya was drinking tea, a sly virus managed to destroy the input file so that Petya can't figure out for which value of *n* the program was run. Help Petya, carry out the inverse function!

Mostly, the program consists of a function in C++ with the following simplified syntax:
 -  *function* ::= int f(int n) {*operatorSequence*}-  *operatorSequence* ::= *operator* | *operator* *operatorSequence*-  *operator* ::= return *arithmExpr*; | if (*logicalExpr*) return *arithmExpr*;-  *logicalExpr* ::= *arithmExpr*<=&gt;<=*arithmExpr* | *arithmExpr*<=&lt;<=*arithmExpr* | *arithmExpr* == *arithmExpr*-  *arithmExpr* ::= *sum*-  *sum* ::= *product* | *sum*<=+<=*product* | *sum*<=-<=*product*-  *product* ::= *multiplier* | *product*<=*<=*multiplier* | *product*<=/<=*multiplier*-  *multiplier* ::= n | *number* | f(*arithmExpr*)-  *number* ::= 0|1|2|... |32767 
The whitespaces in a *operatorSequence* are optional.

Thus, we have a function, in which body there are two kinds of operators. There is the operator ""return *arithmExpr*;"" that returns the value of the expression as the value of the function, and there is the conditional operator ""if (*logicalExpr*) return *arithmExpr*;"" that returns the value of the arithmetical expression when and only when the logical expression is true. Guaranteed that no other constructions of C++ language — cycles, assignment operators, nested conditional operators etc, and other variables except the *n* parameter are used in the function. All the constants are integers in the interval [0..32767].

The operators are performed sequentially. After the function has returned a value other operators in the sequence are not performed. Arithmetical expressions are performed taking into consideration the standard priority of the operations. It means that first all the products that are part of the sum are calculated. During the calculation of the products the operations of multiplying and division are performed from the left to the right. Then the summands are summed, and the addition and the subtraction are also performed from the left to the right. Operations ""&gt;"" (more), ""&lt;"" (less) and ""=="" (equals) also have standard meanings.

Now you've got to pay close attention! The program is compiled with the help of 15-bit Berland C++ compiler invented by a Berland company BerSoft, that's why arithmetical operations are performed in a non-standard way. Addition, subtraction and multiplication are performed modulo 32768 (if the result of subtraction is negative, then 32768 is added to it until the number belongs to the interval [0..32767]). Division ""/"" is a usual integer division where the remainder is omitted.

Examples of arithmetical operations: 

Guaranteed that for all values of *n* from 0 to 32767 the given function is performed correctly. That means that:

1. Division by 0 never occures.

2. When performing a function for the value *n*<==<=*N* recursive calls of the function *f* may occur only for the parameter value of 0,<=1,<=...,<=*N*<=-<=1. Consequently, the program never has an infinite recursion.

3. As the result of the sequence of the operators, the function always returns a value.

We have to mention that due to all the limitations the value returned by the function *f* is independent from either global variables or the order of performing the calculations of arithmetical expressions as part of the logical one, or from anything else except the value of *n* parameter. That's why the *f* function can be regarded as a function in its mathematical sense, i.e. as a unique correspondence between any value of *n* from the interval [0..32767] and a value of *f*(*n*) from the same interval.

Given the value of *f*(*n*), and you should find *n*. If the suitable *n* value is not unique, you should find the maximal one (from the interval [0..32767]).","The first line has an integer *f*(*n*) from the interval [0..32767]. The next lines have the description of the function *f*. In the description can be found extra spaces and line breaks (see the examples) which, of course, can’t break key words int, if, return and numbers. The size of input data can’t exceed 100 bytes.","Output a single number — the answer to the problem. If there’s no answer, output ""-1"" (without quotes).","['17\nint f(int n)\n{\nif (n &lt; 100) return 17;\nif (n &gt; 99) return 27;\n}\n', '13\nint f(int n)\n{\nif (n == 0) return 0;\nreturn f(n - 1) + 1;\n}\n', '144\nint f(int n)\n{\nif (n == 0) return 0;\nif (n == 1) return n;\nreturn f(n - 1) + f(n - 2);\n}']","['99\n', '13', '24588\n']",none,RUNTIME_ERROR,"import m, q, functools

def j(x):
    y = x % 32768
    if (y < 0):
        y += 32768
    return y

class h:
    def __init__(n, x):
        n.value = j(int(x))
    def a(n, x):
        return h(j(n.value + x.value))
    def f(n, x):
        return h(j(n.value - x.value))
    def e(n, x):
        return h(j(n.value * x.value))
    def c(n, x):
        return h(j(n.value // x.value))
    def b(n, x):
        return h(j(n.value & x.value))
    def __eq__(n, x):
        return n.value == x.value
    def __lt__(n, x):
        return n.value < x.value
    def __gt__(n, x):
        return n.value > x.value
    def __str__(n):
        return str(n.value)
    def d(n):
        return n.value
    def __hash__(n):
      return n.value

def r(p):
    s = p
    s = s.replace('\n', '')
    s = s.replace('{', '')
    s = s.replace('}', '')
    s = m.sub('([0-9]+)', 'berland_cpp_int(\\1)', s)
    
    s = s.replace('int f(int n)',\
                  '\[email protected]_cache(maxsize=None)\ndef f(n):\n\t')
 
    s = m.sub('return(.*?);', 'return berland_cpp_int(\\1);', s)
    s = s.replace(';', '\n\t')
    s = s.replace('return', ':return')
    s = m.sub('\t[ :]+', '\t', s)

    return s

k = q.stdin.read().split('\n')

l = int(k[0])
o = '\n'.join(k[1:])
i = r(o)

exec(i)

s = list(map(lambda x: f(h(x)), range(32768)))
s = list(map(lambda x: x.value, s))

g = -1

for i in range(32768):
    if (s[i] == l):
        g = i

print(g)","def i(n):

    L = len(str(n))
    return (10**L - 1) - n

def o(n):

    return n * i(n)

def h():
    import l
    f = l.stdin.read().strip().split()
    if not f:
        return
    l, r = map(int, f)
    
    a = 0
    d = []

    g = len(str(l))
    m = len(str(r))
    
    for L in range(g, m + 1):
        k = max(l, 10**(L - 1))
        j = min(r, 10**L - 1)
        if k > j:
            continue

        n = (10**L - 1) / 2.0
        b = int(n)
        c = b + 1
        
        if k <= b <= j:
            d.append(b)
        if k <= c <= j:
            d.append(c)

        d.append(k)
        d.append(j)

    d.append(l)
    d.append(r)
    
    for n in d:

        L = len(str(n))
        e = n * ((10**L - 1) - n)
        if e > a:
            a = e
            
    l.stdout.write(str(a))
    
if __name__ == '__main__':
    h()"
496,C,Removing Columns,PROGRAMMING,"['brute force', 'constructive algorithms', 'implementation']","You are given an *n*<=×<=*m* rectangular table consisting of lower case English letters. In one operation you can completely remove one column from the table. The remaining parts are combined forming a new table. For example, after removing the second column from the table

 

we obtain the table:

 

A table is called good if its rows are ordered from top to bottom lexicographically, i.e. each row is lexicographically no larger than the following one. Determine the minimum number of operations of removing a column needed to make a given table good.","The first line contains two integers  — *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=100).

Next *n* lines contain *m* small English letters each — the characters of the table.",Print a single number — the minimum number of columns that you need to remove in order to make the table good.,"['1 10\ncodeforces\n', '4 4\ncase\ncare\ntest\ncode\n', '5 4\ncode\nforc\nesco\ndefo\nrces\n']","['0\n', '2\n', '4\n']","In the first sample the table is already good.

In the second sample you may remove the first and third column.

In the third sample you have to remove all the columns (note that the table where all rows are empty is considered good by definition).

Let strings *s* and *t* have equal length. Then, *s* is lexicographically larger than *t* if they are not equal and the character following the largest common prefix of *s* and *t* (the prefix may be empty) in *s* is alphabetically larger than the corresponding character of *t*.",WRONG_ANSWER,"def c():
    n,m=map(int,input().split())
    A=[list(input()) for i in range(n)]
    if(n==1):
        print(0)
        return
    b=0
    j=0
    while (j<len(A[0])):
        a=0
        for i in range(n-1):
            if not (A[i][j]<=A[i+1][j]):
                a=1
                break
        if (a):
            for i in range(n):
                del(A[i][j])
            b+=1
        else:
            j+=1
        B=A[::]
        A.sort()
        if(B==A):
            print(b)
            return
        A=B[::]

c()","import h

def b():

    a = h.stdin.read().split()
    if not a:
        return

    n = int(a[0])
    m = int(a[1])
    d = int(a[2])

    f = list(map(int, a[3:]))
    if len(f) != n * m:
        raise ValueError(""Matrix size mismatch: expected {} elements but got {}."".format(n * m, len(f)))

    g = f[0] % d
    for e in f:
        if e % d != g:
            print(""-1"")
            return

    f.sort()
    c = f[len(f) // 2]

    d = sum(abs(e - c) // d for e in f)
    print(d)

if __name__ == '__main__':
    b()"
424,B,Megacity,PROGRAMMING,"['binary search', 'greedy', 'implementation', 'sortings']","The administration of the Tomsk Region firmly believes that it's time to become a megacity (that is, get population of one million). Instead of improving the demographic situation, they decided to achieve its goal by expanding the boundaries of the city.

The city of Tomsk can be represented as point on the plane with coordinates (0; 0). The city is surrounded with *n* other locations, the *i*-th one has coordinates (*x**i*, *y**i*) with the population of *k**i* people. You can widen the city boundaries to a circle of radius *r*. In such case all locations inside the circle and on its border are included into the city.

Your goal is to write a program that will determine the minimum radius *r*, to which is necessary to expand the boundaries of Tomsk, so that it becomes a megacity.","The first line of the input contains two integers *n* and *s* (1<=≤<=*n*<=≤<=103; 1<=≤<=*s*<=&lt;<=106) — the number of locatons around Tomsk city and the population of the city. Then *n* lines follow. The *i*-th line contains three integers — the *x**i* and *y**i* coordinate values of the *i*-th location and the number *k**i* of people in it (1<=≤<=*k**i*<=&lt;<=106). Each coordinate is an integer and doesn't exceed 104 in its absolute value.

It is guaranteed that no two locations are at the same point and no location is at point (0; 0).","In the output, print ""-1"" (without the quotes), if Tomsk won't be able to become a megacity. Otherwise, in the first line print a single real number — the minimum radius of the circle that the city needs to expand to in order to become a megacity.

The answer is considered correct if the absolute or relative error don't exceed 10<=-<=6.","['4 999998\n1 1 1\n2 2 1\n3 3 1\n2 -2 1\n', '4 999998\n1 1 2\n2 2 1\n3 3 1\n2 -2 1\n', '2 1\n1 1 999997\n2 2 1\n']","['2.8284271\n', '1.4142136\n', '-1']",none,WRONG_ANSWER,"def d(b):
   if b <= 0:
      print(0)
      return

   a = [] 
   for _ in range(n):
      x, y, k = map(int, input().split())
      a.append(((x**2 + y**2)**0.5, k))
   a.sort()

   for r, c in a:
      if b > 0:
         b -= c  
      else: 
         break
   print(""{:.7f}"".format(r))

n, s = map(int, input().split())
b = 10**6 - s
d(b)","import m

def g():
    d = m.stdin.read().strip().split()
    if not d:
        return
    f = iter(d)
    n = int(next(f))
    m = int(next(f))

    h = []
    a = []
    
    for _ in range(m):
        u = int(next(f))
        v = int(next(f))
        z = int(next(f))
        if z == 0:
            h.append((u, v))
        else:
            a.append((u, v))

    a = int(next(f))
    b = int(next(f))

    i = list(range(n + 1))
    j = [0] * (n + 1)
    
    def e(x):
        while i[x] != x:
            i[x] = i[i[x]]
            x = i[x]
        return x
    
    def n(x, y):
        k = e(x)
        l = e(y)
        if k == l:
            return
        if j[k] < j[l]:
            i[k] = l
        elif j[k] > j[l]:
            i[l] = k
        else:
            i[l] = k
            j[k] += 1

    for u, v in h:
        n(u, v)
    
    b = e(a)
    c = e(b)

    for u, v in a:

        if e(u) == b and e(v) == c:
            m.stdout.write(""YES"")
            return

        if e(v) == b and e(u) == c:
            m.stdout.write(""YES"")
            return
    
    m.stdout.write(""NO"")
    
if __name__ == '__main__':
    g()"
110,A,Nearly Lucky Number,PROGRAMMING,['implementation'],"Petya loves lucky numbers. We all know that lucky numbers are the positive integers whose decimal representations contain only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.

Unfortunately, not all numbers are lucky. Petya calls a number nearly lucky if the number of lucky digits in it is a lucky number. He wonders whether number *n* is a nearly lucky number.","The only line contains an integer *n* (1<=≤<=*n*<=≤<=1018).

Please do not use the %lld specificator to read or write 64-bit numbers in С++. It is preferred to use the cin, cout streams or the %I64d specificator.","Print on the single line ""YES"" if *n* is a nearly lucky number. Otherwise, print ""NO"" (without the quotes).","['40047\n', '7747774\n', '1000000000000000000\n']","['NO\n', 'YES\n', 'NO\n']","In the first sample there are 3 lucky digits (first one and last two), so the answer is ""NO"".

In the second sample there are 7 lucky digits, 7 is lucky number, so the answer is ""YES"".

In the third sample there are no lucky digits, so the answer is ""NO"".",OK,"def b():
    s = input()
    a = 0
    for i in s:
        if i == '4' or i == '7':
            a += 1
    if a == 4 or a == 7:
        print('YES')
    else:
        print('NO')

if __name__ == '__main__':
    b()","def f():
    import h
    d = h.stdin.read().strip().split()
    if not d:
        return
    n = int(d[0])

    a = list(map(int, d[1:]))

    i = 360
    a = i

    for g in range(n):
        c = 0

        a = min(a, abs(i - 2 * c))
        
        for b in range(1, n + 1):
            c += a[(g + b - 1) % n]
            e = abs(i - 2 * c)
            a = min(a, e)

            if a == 0:
                print(0)
                return
    print(a)

if __name__ == ""__main__"":
    f()"
664,A,Complicated GCD,PROGRAMMING,"['math', 'number theory']","Greatest common divisor *GCD*(*a*,<=*b*) of two positive integers *a* and *b* is equal to the biggest integer *d* such that both integers *a* and *b* are divisible by *d*. There are many efficient algorithms to find greatest common divisor *GCD*(*a*,<=*b*), for example, Euclid algorithm. 

Formally, find the biggest integer *d*, such that all integers *a*,<=*a*<=+<=1,<=*a*<=+<=2,<=...,<=*b* are divisible by *d*. To make the problem even more complicated we allow *a* and *b* to be up to googol, 10100 — such number do not fit even in 64-bit integer type!",The only line of the input contains two integers *a* and *b* (1<=≤<=*a*<=≤<=*b*<=≤<=10100).,Output one integer — greatest common divisor of all integers from *a* to *b* inclusive.,"['1 2\n', '61803398874989484820458683436563811772030917980576 61803398874989484820458683436563811772030917980576\n']","['1\n', '61803398874989484820458683436563811772030917980576\n']",none,WRONG_ANSWER,"b, c = map(int, input().split())

def a(a, b):
    if b == 0:
        return a
    return a(b, b%a)

print(a(max(b, c), min(b, c)))","import h

def d():

    c = h.stdin.read().split()
    f = 0

    n = int(c[f])
    f += 1

    e = {}
    for i in range(1, n+1):
        i = int(c[f])
        f += 1
        e[i] = i

    m = int(c[f])
    f += 1

    b = 0
    a = 0

    for _ in range(m):
        g = int(c[f])
        f += 1

        b += e[g]

        a += (n - e[g] + 1)

    h.stdout.write(f""{b} {a}"")

if __name__ == ""__main__"":
    d()"
633,A,Ebony and Ivory,PROGRAMMING,"['brute force', 'math', 'number theory']","Dante is engaged in a fight with ""The Savior"". Before he can fight it with his sword, he needs to break its shields. He has two guns, Ebony and Ivory, each of them is able to perform any non-negative number of shots.

For every bullet that hits the shield, Ebony deals *a* units of damage while Ivory deals *b* units of damage. In order to break the shield Dante has to deal exactly *c* units of damage. Find out if this is possible.","The first line of the input contains three integers *a*, *b*, *c* (1<=≤<=*a*,<=*b*<=≤<=100,<=1<=≤<=*c*<=≤<=10<=000) — the number of units of damage dealt by Ebony gun and Ivory gun, and the total number of damage required to break the shield, respectively.","Print ""Yes"" (without quotes) if Dante can deal exactly *c* damage to the shield and ""No"" (without quotes) otherwise.","['4 6 15\n', '3 2 7\n', '6 11 6\n']","['No\n', 'Yes\n', 'Yes\n']","In the second sample, Dante can fire 1 bullet from Ebony and 2 from Ivory to deal exactly 1·3 + 2·2 = 7 damage. In the third sample, Dante can fire 1 bullet from ebony and no bullets from ivory to do 1·6 + 0·11 = 6 damage.",COMPILATION_ERROR,"def a(a,b):
    global g,x,y
    if b==0:
        g=a
        x,y=1,0
    else:
        a(b,a%b)
        b = x
        x = y
        y = b - ((a//b)*y)
        
        

if __name__==""__main__"":
    a,b,c=map(int,input().split())
    g=x=y=int()
    a(a,b)
    if (c%a==0) or (c%b==0) or (c%g==0):
        print(""Yes"")
        continue
    elif x<0 and y<0:
        print(""No"")
    elif x>0 and y>0:
        print(""Yes"")","import f
import e

def c(g):

    g = e.sub(r'\s+', ' ', g.strip())

    g = e.sub(r' +(?=[,\.!?])', '', g)

    g = e.sub(r'([,\.!?])\s*', r'\1 ', g)

    return g.strip()

def b():
    for a in f.stdin:

        d = c(a)
        print(d)

if __name__ == ""__main__"":
    b()"
967,A,Mind the Gap,PROGRAMMING,['implementation'],"These days Arkady works as an air traffic controller at a large airport. He controls a runway which is usually used for landings only. Thus, he has a schedule of planes that are landing in the nearest future, each landing lasts $1$ minute.

He was asked to insert one takeoff in the schedule. The takeoff takes $1$ minute itself, but for safety reasons there should be a time space between the takeoff and any landing of at least $s$ minutes from both sides.

Find the earliest time when Arkady can insert the takeoff.","The first line of input contains two integers $n$ and $s$ ($1 \le n \le 100$, $1 \le s \le 60$) — the number of landings on the schedule and the minimum allowed time (in minutes) between a landing and a takeoff.

Each of next $n$ lines contains two integers $h$ and $m$ ($0 \le h \le 23$, $0 \le m \le 59$) — the time, in hours and minutes, when a plane will land, starting from current moment (i. e. the current time is $0$ $0$). These times are given in increasing order.",Print two integers $h$ and $m$ — the hour and the minute from the current moment of the earliest time Arkady can insert the takeoff.,"['6 60\n0 0\n1 20\n3 21\n5 0\n19 30\n23 40\n', '16 50\n0 30\n1 20\n3 0\n4 30\n6 10\n7 50\n9 30\n11 10\n12 50\n14 30\n16 10\n17 50\n19 30\n21 10\n22 50\n23 59\n', '3 17\n0 30\n1 0\n12 0\n']","['6 1\n', '24 50\n', '0 0\n']","In the first example note that there is not enough time between 1:20 and 3:21, because each landing and the takeoff take one minute.

In the second example there is no gaps in the schedule, so Arkady can only add takeoff after all landings. Note that it is possible that one should wait more than $24$ hours to insert the takeoff.

In the third example Arkady can insert the takeoff even between the first landing.",OK,"def next(a, b, c):
    return (a + (b + c) // 60, (b + c) % 60)

n, s = map(int, input().split())
e = []

for i in range(n):
    e.append(tuple(map(int, input().split())))

if e[0][0] * 60 + e[0][1] >= s + 1:
    print('0 0')
else:
    for i in range(1, len(e)):
        if (e[i][0] - e[i-1][0]) * 60 + (e[i][1] - e[i-1][1]) >= 2 * s + 2:
            d = next(e[i-1][0], e[i-1][1], s + 1)
            print(str(d[0]) + ' ' + str(d[1]))
            break;
    else:
        d = next(e[i][0], e[i][1], s + 1)
        print(str(d[0]) + ' ' + str(d[1]))","import g
import math

def c():

    a = g.stdin.read().split()
    if not a:
        return

    a = float(a[0])
    d = float(a[1])
    n = int(a[2])

    d = 4.0 * a
    f = []

    for i in range(1, n+1):

        b = i * d

        e = b % d

        if e < a:

            x = e
            y = 0.0
        elif e < 2 * a:

            x = a
            y = e - a
        elif e < 3 * a:

            x = a - (e - 2 * a)
            y = a
        else:

            x = 0.0
            y = a - (e - 3 * a)

        f.append(""{:.10f} {:.10f}"".format(x, y))

    g.stdout.write(""\n"".join(f))

if __name__ == '__main__':
    c()"
976,A,Minimum Binary Number,PROGRAMMING,['implementation'],"String can be called correct if it consists of characters ""0"" and ""1"" and there are no redundant leading zeroes. Here are some examples: ""0"", ""10"", ""1001"".

You are given a correct string *s*.

You can perform two different operations on this string: 
 1.  swap any pair of adjacent characters (for example, ""101""  ""110""); 1.  replace ""11"" with ""1"" (for example, ""110""  ""10""). 
Let *val*(*s*) be such a number that *s* is its binary representation.

Correct string *a* is less than some other correct string *b* iff *val*(*a*)<=&lt;<=*val*(*b*).

Your task is to find the minimum correct string that you can obtain from the given one using the operations described above. You can use these operations any number of times in any order (or even use no operations at all).","The first line contains integer number *n* (1<=≤<=*n*<=≤<=100) — the length of string *s*.

The second line contains the string *s* consisting of characters ""0"" and ""1"". It is guaranteed that the string *s* is correct.",Print one string — the minimum correct string that you can obtain from the given one.,"['4\n1001\n', '1\n1\n']","['100\n', '1\n']","In the first example you can obtain the answer by the following sequence of operations: ""1001"" <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> ""1010"" <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> ""1100"" <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> ""100"".

In the second example you can't obtain smaller answer no matter what operations you use.",OK,"import c
input = c.stdin.buffer.readline

def b(S):
    if S=='0':
        c.stdout.write('0')
        return
    d = [0, 0]
    for c in S:
        d[int(c)]+=1
    a = ['1']
    for i in range(d[0]):
        a.append('0')
    a = ''.join(a)
    c.stdout.write(a)
    return

n = int(input())
S = input().decode()[:-2]
b(S)","import g

def d():

    n = int(g.stdin.readline().strip())

    b = g.stdin.readline().strip()
    
    f = []

    for _ in range(3):

        if len(b) == 1:
            c = b
        else:

            c = '+'.join(b)
        f.append(c)

        s = sum(int(a) for a in b)

        b = str(s)

    for e in f:
        g.stdout.write(e + ""\n"")

if __name__ == ""__main__"":
    d()"
672,A,Summer Camp,PROGRAMMING,['implementation'],"Every year, hundreds of people come to summer camps, they learn new algorithms and solve hard problems.

This is your first year at summer camp, and you are asked to solve the following problem. All integers starting with 1 are written in one line. The prefix of these line is ""123456789101112131415..."". Your task is to print the *n*-th digit of this string (digits are numbered starting with 1.",The only line of the input contains a single integer *n* (1<=≤<=*n*<=≤<=1000) — the position of the digit you need to print.,Print the *n*-th digit of the line.,"['3\n', '11\n']","['3\n', '0\n']","In the first sample the digit at position 3 is '3', as both integers 1 and 2 consist on one digit.

In the second sample, the digit at position 11 is '0', it belongs to the integer 10.",OK,"s = ''
for i in range(1,371):
    s+=str(i)
def a():
    n = int(input())
    print(s[n-1])
for _ in range(1):
    a()","import f

def d():
    c = f.stdin.read().splitlines()
    if not c:
        return
    n = int(c[0])

    p = []
    for i in range(1, n+1):
        p.append(int(c[i]))

    b = {}
    def a(i):

        if i in b:
            return b[i]

        if p[i-1] == -1:
            b[i] = 1
        else:

            b[i] = 1 + a(p[i-1])
        return b[i]
    
    e = 0

    for i in range(1, n+1):
        e = max(e, a(i))

    print(e)

if __name__ == ""__main__"":
    d()"
688,B,Lovely Palindromes,PROGRAMMING,"['constructive algorithms', 'math']","Pari has a friend who loves palindrome numbers. A palindrome number is a number that reads the same forward or backward. For example 12321, 100001 and 1 are palindrome numbers, while 112 and 1021 are not.

Pari is trying to love them too, but only very special and gifted people can understand the beauty behind palindrome numbers. Pari loves integers with even length (i.e. the numbers with even number of digits), so she tries to see a lot of big palindrome numbers with even length (like a 2-digit 11 or 6-digit 122221), so maybe she could see something in them.

Now Pari asks you to write a program that gets a huge integer *n* from the input and tells what is the *n*-th even-length positive palindrome number?",The only line of the input contains a single integer *n* (1<=≤<=*n*<=≤<=10100<=000).,Print the *n*-th even-length palindrome number.,"['1\n', '10\n']","['11\n', '1001\n']","The first 10 even-length palindrome numbers are 11, 22, 33, ... , 88, 99 and 1001.",OK,"from sys import stdin,stdout

n = input()
print(n+n[::-1])","def d():
    import g, math

    c = g.stdin.read().strip().split()
    if not c:
        return
    n, t, k, d = map(int, c)

    f = (n + k - 1) // k
    e = f * t

    a = ( (e - 1) // t ) * k

    b = 0
    if e - 1 > d:
        b = ((e - 1 - d) // t) * k

    if a + b >= n:
        g.stdout.write(""YES"")
    else:
        g.stdout.write(""NO"")
        
if __name__ == '__main__':
    d()"
669,A,Little Artem and Presents,PROGRAMMING,['math'],"Little Artem got *n* stones on his birthday and now wants to give some of them to Masha. He knows that Masha cares more about the fact of receiving the present, rather than the value of that present, so he wants to give her stones as many times as possible. However, Masha remembers the last present she received, so Artem can't give her the same number of stones twice in a row. For example, he can give her 3 stones, then 1 stone, then again 3 stones, but he can't give her 3 stones and then again 3 stones right after that.

How many times can Artem give presents to Masha?",The only line of the input contains a single integer *n* (1<=≤<=*n*<=≤<=109) — number of stones Artem received on his birthday.,Print the maximum possible number of times Artem can give presents to Masha.,"['1\n', '2\n', '3\n', '4\n']","['1\n', '1\n', '2\n', '3\n']","In the first sample, Artem can only give 1 stone to Masha.

In the second sample, Atrem can give Masha 1 or 2 stones, though he can't give her 1 stone two times.

In the third sample, Atrem can first give Masha 2 stones, a then 1 more stone.

In the fourth sample, Atrem can first give Masha 1 stone, then 2 stones, and finally 1 stone again.",OK,"def b(n):
  if n == 1:
    return 1
  return n-round(n/3)
  
def a():
  n =int(input())
  print(b(n))

a()","def l():
    import p
    p.setrecursionlimit(10**6)

    d = p.stdin.read().strip().split()
    if not d:
        return
    n = int(d[0])
    m = int(d[1])

    f = []
    h = 2
    a = False

    for i in range(n):
        k = int(d[h])
        h += 1
        k = set()
        for j in range(k):
            i = int(d[h])
            h += 1
            k.add(i)
        if k:
            a = True
        f.append(k)

    j = {}
    for i, k in enumerate(f):
        for i in k:
            if i not in j:
                j[i] = []
            j[i].append(i)

    m = list(range(n))
    
    def g(x):

        if m[x] != x:
            m[x] = g(m[x])
        return m[x]
    
    def q(x, y):

        n = g(x)
        o = g(y)
        if n != o:
            m[o] = n

    for e in j.values():
        for i in range(1, len(e)):
            q(e[0], e[i])

    c = set()
    for i in range(n):
        c.add(g(i))
    b = len(c)

    if not a:
        print(n)
    else:

        print(b - 1)

if __name__ == '__main__':
    l()"
331,C1,The Great Julya Calendar,PROGRAMMING,['dp'],"Yet another Armageddon is coming! This time the culprit is the Julya tribe calendar. 

The beavers in this tribe knew math very well. Smart Beaver, an archaeologist, got a sacred plate with a magic integer on it. The translation from Old Beaverish is as follows: 

""May the Great Beaver bless you! May your chacres open and may your third eye never turn blind from beholding the Truth! Take the magic number, subtract a digit from it (the digit must occur in the number) and get a new magic number. Repeat this operation until a magic number equals zero. The Earth will stand on Three Beavers for the time, equal to the number of subtractions you perform!""

Distinct subtraction sequences can obviously get you different number of operations. But the Smart Beaver is ready to face the worst and is asking you to count the minimum number of operations he needs to reduce the magic number to zero.","The single line contains the magic integer *n*, 0<=≤<=*n*.
 -  to get 20 points, you need to solve the problem with constraints: *n*<=≤<=106 (subproblem C1); -  to get 40 points, you need to solve the problem with constraints: *n*<=≤<=1012 (subproblems C1+C2); -  to get 100 points, you need to solve the problem with constraints: *n*<=≤<=1018 (subproblems C1+C2+C3).",Print a single integer — the minimum number of subtractions that turns the magic number to a zero.,['24\n'],['5'],In the first test sample the minimum number of operations can be reached by the following sequence of subtractions:,OK,"import n

b = {}

def h(n):
    o = max(int(c) for c in str(n))
    return n - o

def k(n):
    i = 0
    while n > 0:
        n = h(n)
        i += 1
    return i

for m in range(1, 10):
    for a in range(10):
        g = int(f""{m}9{a}"")
        a = int(f""{m-1}99"")
        m = 0
        while g > a:
            g = h(g)

            m += 1
        b[m, 1, a] = m, g % 10

def m(m, k, a):
    if (m, k, a) in b:
        return b[m, k, a]
    if m == 0:
        return m(9, k-1, a)
    assert k > 1, (m, k, a)
    assert m > 0, (m, k, a)
    i, d = 0, a
    for y in range(0, 10)[::-1]:
        l, d = m(max(m, y), k-1, d)
        i += l
    b[m, k, a] = i, d
    return i, d

for m in range(1, 10):
    for k in range(1, 3):
        for a in range(10):
            m(m, k, a)

def j(n):
    a = n % 10
    i = 0
    def e():
        f = n // 10
        k = 0
        m = 0
        while f % 10 == 9:
            k += 1
            f //= 10
        while f != 0:
            m = max(m, f % 10)
            f //= 10
        return m, k
        
    while n != 0:
        print(n, file=n.stderr)
        m, k = e()
        if k == 0:

            i += 1
            n = h(n)
        elif k == 1 and m == 0:
            i += 1
            n = h(n)
        else:
            c, d = m(m, k, n % 10)
            if m == 0:
                n = ((n//10**(k))-1)*10**(k)+((10**(k-1))-1)*10+d
            else:
                n = ((n//10**(k+1))-1)*10**(k+1)+((10**k)-1)*10+d
            i+=c

    print(i)
        
N = int(input())
j(N)","def f(j, x):

    if j[x] != x:
        j[x] = f(j, j[x])
    return j[x]

def o(j, x, y):

    l = f(j, x)
    m = f(j, y)
    if l != m:
        j[m] = l

def i():
    import n
    g = n.stdin.read().splitlines()
    h = 0

    n, m = map(int, g[h].split())
    h += 1

    b = {}

    for _ in range(m):
        a, b, c = map(int, g[h].split())
        h += 1
        if c not in b:
            b[c] = []
        b[c].append((a, b))

    c = {}
    for a, e in b.items():

        j = [i for i in range(n + 1)]
        for a, b in e:
            o(j, a, b)
        c[a] = j

    q = int(g[h].strip())
    h += 1

    k = []
    for _ in range(q):
        u, v = map(int, g[h].split())
        h += 1
        d = 0

        for j in c.values():
            if f(j, u) == f(j, v):
                d += 1
        k.append(str(d))

    n.stdout.write(""\n"".join(k))

if __name__ == ""__main__"":
    i()"
414,B,Mashmokh and ACM,PROGRAMMING,"['combinatorics', 'dp', 'number theory']","Mashmokh's boss, Bimokh, didn't like Mashmokh. So he fired him. Mashmokh decided to go to university and participate in ACM instead of finding a new job. He wants to become a member of Bamokh's team. In order to join he was given some programming tasks and one week to solve them. Mashmokh is not a very experienced programmer. Actually he is not a programmer at all. So he wasn't able to solve them. That's why he asked you to help him with these tasks. One of these tasks is the following.

A sequence of *l* integers *b*1,<=*b*2,<=...,<=*b**l* (1<=≤<=*b*1<=≤<=*b*2<=≤<=...<=≤<=*b**l*<=≤<=*n*) is called good if each number divides (without a remainder) by the next number in the sequence. More formally  for all *i* (1<=≤<=*i*<=≤<=*l*<=-<=1).

Given *n* and *k* find the number of good sequences of length *k*. As the answer can be rather large print it modulo 1000000007 (109<=+<=7).","The first line of input contains two space-separated integers *n*,<=*k* (1<=≤<=*n*,<=*k*<=≤<=2000).",Output a single integer — the number of good sequences of length *k* modulo 1000000007 (109<=+<=7).,"['3 2\n', '6 4\n', '2 1\n']","['5\n', '39\n', '2\n']","In the first sample the good sequences are: [1, 1], [2, 2], [3, 3], [1, 2], [1, 3].",WRONG_ANSWER,"import e

def b(n):
    d = []
    for i in range(1, int(e.sqrt(n))+1):
        if n%i == 0:
            d.append(i)
            if i*i != n:
                d.append(n//i)
    return d

f, d = map(int, input().split())
c = [[0]*(f+1) for i in range(d+1)]
a = [b(i) for i in range(f+1)]
for n in range(1, f+1):
    c[1][n] = 1
for k in range(1, d+1):
    c[k][1] = 1
for k in range(2, d+1):
    for n in range(2, f+1):
        for d in a[n]:
            c[k][n] = (c[k][n] + c[k-1][d]) % 1000000007
print(sum(c[k]))","n = int(input().strip())
a = list(map(int, input().split()))

b = 0

for i in range(n):

    c = 1

    j = i - 1
    while j >= 0 and a[j] <= a[j + 1]:
        c += 1
        j -= 1

    j = i + 1
    while j < n and a[j] <= a[j - 1]:
        c += 1
        j += 1

    b = max(b, c)

print(b)"
845,C,Two TVs,PROGRAMMING,"['data structures', 'greedy', 'sortings']","Polycarp is a great fan of television.

He wrote down all the TV programs he is interested in for today. His list contains *n* shows, *i*-th of them starts at moment *l**i* and ends at moment *r**i*.

Polycarp owns two TVs. He can watch two different shows simultaneously with two TVs but he can only watch one show at any given moment on a single TV. If one show ends at the same moment some other show starts then you can't watch them on a single TV.

Polycarp wants to check out all *n* shows. Are two TVs enough to do so?","The first line contains one integer *n* (1<=≤<=*n*<=≤<=2·105) — the number of shows.

Each of the next *n* lines contains two integers *l**i* and *r**i* (0<=≤<=*l**i*<=&lt;<=*r**i*<=≤<=109) — starting and ending time of *i*-th show.","If Polycarp is able to check out all the shows using only two TVs then print ""YES"" (without quotes). Otherwise, print ""NO"" (without quotes).","['3\n1 2\n2 3\n4 5\n', '4\n1 2\n2 3\n2 3\n1 2\n']","['YES\n', 'NO\n']",none,WRONG_ANSWER,"n = int(input())
a = [n]
b = [n]
for i in range(n):
    x, y = map(int, input().split())
    a.append(x)
    b.append(y)
a.pop(0)
b.pop(0)

def a(n):
    for i in range(n - 1):
        if a[i] >= a[i+1] or b[i] >= b[i+1]:
            return False
    return True

if a(n) == True:
    print('YES')
else:
    print('NO')","""""""
Absent-minded Masha's Cube Problem

Masha got n cubes, each containing 6 digits. She wants to form every integer
from 1 up to the largest natural x using her cubes. For each number, she arranges
some (or all) cubes in a row (rotating them if needed) so that the upper faces read
the number with no leading zeros.

This script computes the largest x for which Masha can form all numbers from 1 to x.
It reads the input from stdin.
""""""

def a(g, b):
    """"""
    Checks if the number represented by num_str can be built using a permutation of cubes.
    The cubes variable is a list of sets, each set containing available digits on that cube.
    The first digit cannot be 0.
    
    Parameters:
    num_str (str): The target number in string format.
    cubes (list of set): List of sets of digits available on each cube.
    
    Returns:
    bool: True if the number can be formed, otherwise False.
    """"""
    from itertools import i
    
    m = len(g)

    for h in i(b, m):
        l = True
        for i, d in enumerate(g):

            if i == 0 and d == '0':
                l = False
                break

            if int(d) not in h[i]:
                l = False
                break
        if l:
            return True
    return False

def f():
    import k

    c = k.stdin.read().splitlines()
    if not c:
        return

    n = int(c[0])
    b = []

    for i in range(1, n + 1):
        e = list(map(int, c[i].split()))
        b.append(set(e))
    
    x = 0
    while True:
        x += 1
        j = str(x)

        if len(j) > n:
            print(x - 1)
            return
        
        if not a(j, b):
            print(x - 1)
            return

if __name__ == '__main__':
    f()"
253,A,Boys and Girls,PROGRAMMING,['greedy'],"There are *n* boys and *m* girls studying in the class. They should stand in a line so that boys and girls alternated there as much as possible. Let's assume that positions in the line are indexed from left to right by numbers from 1 to *n*<=+<=*m*. Then the number of integers *i* (1<=≤<=*i*<=&lt;<=*n*<=+<=*m*) such that positions with indexes *i* and *i*<=+<=1 contain children of different genders (position *i* has a girl and position *i*<=+<=1 has a boy or vice versa) must be as large as possible. 

Help the children and tell them how to form the line.","The single line of the input contains two integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=100), separated by a space.","Print a line of *n*<=+<=*m* characters. Print on the *i*-th position of the line character ""B"", if the *i*-th position of your arrangement should have a boy and ""G"", if it should have a girl. 

Of course, the number of characters ""B"" should equal *n* and the number of characters ""G"" should equal *m*. If there are multiple optimal solutions, print any of them.","['3 3\n', '4 2\n']","['GBGBGB\n', 'BGBGBB\n']","In the first sample another possible answer is BGBGBG. 

In the second sample answer BBGBGB is also optimal.",WRONG_ANSWER,"def a():
    x = str(input())
    c = x.split()
    n = int(c[0])
    m = int(c[1])
    if n == m:
        b = """"
        for i in range(0, n):
            b = b + ""B""
            b = b + ""G""
        print(b)
    elif n > m:
        r = n - m
        b = """"
        for i in range(0,m):
            b = b + ""B""
            b = b + ""G""
        b = b + r * ""B""
        print(b)
    else:
        r = m - n
        b = """"
        for i in range(0, n):
            b = b + ""G""
            b = b + ""B""
        b = b + r * ""G""
        print(b)","""""""
This script calculates the minimum pixel area for a group photo taken by excluding one friend at a time.
Each friend is represented as a rectangle with given width and height.
When one friend is excluded, the total width of the photo is the sum of the widths of the remaining friends,
and the height is the maximum height among the remaining friends.
If the excluded friend has the unique maximum height, we use the second maximum height among the others.
""""""

def g():
    import k
    d = k.stdin.read().strip().split()
    if not d:
        return

    n = int(d[0])
    m = [0] * n
    e = [0] * n
    l = 0

    f = 1
    for i in range(n):
        w = int(d[f])
        h = int(d[f + 1])
        m[i] = w
        e[i] = h
        l += w
        f += 2

    h = -1
    j = -1
    a = 0

    for h in e:
        if h > h:
            j = h
            h = h
            a = 1
        elif h == h:
            a += 1
        elif h > j:
            j = h

    i = []
    for i in range(n):

        c = l - m[i]

        if e[i] == h and a == 1:
            b = j
        else:
            b = h

        i.append(str(c * b))
    
    k.stdout.write("" "".join(i) + "" "")

if __name__ == '__main__':
    g()"
551,B,ZgukistringZ,PROGRAMMING,"['brute force', 'constructive algorithms', 'implementation', 'strings']","Professor GukiZ doesn't accept string as they are. He likes to swap some letters in string to obtain a new one.

GukiZ has strings *a*, *b*, and *c*. He wants to obtain string *k* by swapping some letters in *a*, so that *k* should contain as many non-overlapping substrings equal either to *b* or *c* as possible. Substring of string *x* is a string formed by consecutive segment of characters from *x*. Two substrings of string *x* overlap if there is position *i* in string *x* occupied by both of them.

GukiZ was disappointed because none of his students managed to solve the problem. Can you help them and find one of possible strings *k*?","The first line contains string *a*, the second line contains string *b*, and the third line contains string *c* (1<=≤<=|*a*|,<=|*b*|,<=|*c*|<=≤<=105, where |*s*| denotes the length of string *s*).

All three strings consist only of lowercase English letters. 

It is possible that *b* and *c* coincide.","Find one of possible strings *k*, as described in the problem statement. If there are multiple possible answers, print any of them.","['aaa\na\nb\n', 'pozdravstaklenidodiri\nniste\ndobri\n', 'abbbaaccca\nab\naca\n']","['aaa', 'nisteaadddiiklooprrvz', 'ababacabcc']","In the third sample, this optimal solutions has three non-overlaping substrings equal to either *b* or *c* on positions 1 – 2 (*ab*), 3 – 4 (*ab*), 5 – 7 (*aca*). In this sample, there exist many other optimal solutions, one of them would be *acaababbcc*.",MEMORY_LIMIT_EXCEEDED,"from fileinput import *

for j in input():
    if k() == 1:
        a = j.strip()
    if k() == 2:
        b = j.strip()
    if k() == 3:
        c = j.strip()

e = len(a)
l = list(a)
h = []

f = len(b)
g = len(c)

def d(s, q):
    m = len(s)
    p = range(m)
    c = [0] * m 
    r = list(q)

    for i in range(m):
        i = s[i]
        if i in r:
            del r[r.index(i)]
        else:
            return 0

    return 1 + d(s, ''.join(r))

n = d(b, a)
o = d(c, a)

if n < o:
    b, c = c, b
    f, g = g, f
    n, o = o, n

b = b * n

for i in range(len(b)):
    del l[l.index(b[i])]

a = ''.join(l)
o = d(c, a)

b += c * o
l = list(a)

for i in range(len(b)):
    del l[l.index(b[i])]

b = b + ''.join(l)
print(b)","s = input().strip()
t = input().strip()

a = s[::-1]

if a == t:
    print(""YES"")
else:
    print(""NO"")"
177,F1,Script Generation,PROGRAMMING,[],"The Smart Beaver from ABBYY was offered a job of a screenwriter for the ongoing TV series. In particular, he needs to automate the hard decision: which main characters will get married by the end of the series.

There are *n* single men and *n* single women among the main characters. An opinion poll showed that viewers like several couples, and a marriage of any of them will make the audience happy. The Smart Beaver formalized this fact as *k* triples of numbers (*h*,<=*w*,<=*r*), where *h* is the index of the man, *w* is the index of the woman, and *r* is the measure of the audience's delight in case of the marriage of this couple. The same poll showed that the marriage of any other couple will leave the audience indifferent, so the screenwriters decided not to include any such marriages in the plot.

The script allows you to arrange several marriages between the heroes or not to arrange marriages at all. A subset of some of the *k* marriages is considered acceptable if each man and each woman is involved in at most one marriage of the subset (the series won't allow any divorces). The value of the acceptable set of marriages is the total delight the spectators will get from the marriages included in this set.

Obviously, there is a finite number of acceptable sets, and they all describe some variants of the script. The screenwriters do not want to choose a set with maximum value — it would make the plot too predictable. So the Smart Beaver offers the following option: sort all the acceptable sets in increasing order of value and choose the *t*-th set from the sorted list. Thus, *t*<==<=1 corresponds to a plot without marriages, *t*<==<=2 — to a single marriage resulting in minimal delight for the audience, and so on.

Help the Beaver to implement the algorithm for selecting the desired set.","The first input line contains integers *n*, *k* and *t* (1<=≤<=*k*<=≤<=*min*(100,<=*n*2), 1<=≤<=*t*<=≤<=2·105), separated by single spaces. Next *k* lines contain triples of integers (*h*,<=*w*,<=*r*) (1<=≤<=*h*,<=*w*<=≤<=*n*; 1<=≤<=*r*<=≤<=1000), separated by single spaces, which describe the possible marriages. It is guaranteed that the input data is correct: *t* doesn't exceed the total number of acceptable sets, and each pair (*h*,<=*w*) is present in at most one triple.

The input limitations for getting 30 points are: 
 -  1<=≤<=*n*<=≤<=5 
The input limitations for getting 100 points are: 
 -  1<=≤<=*n*<=≤<=20",Print a single number — the value of the *t*-th acceptable variant.,"['2 4 3\n1 1 1\n1 2 2\n2 1 3\n2 2 7\n', '2 4 7\n1 1 1\n1 2 2\n2 1 3\n2 2 7\n']","['2\n', '8\n']",The figure shows 7 acceptable sets of marriages that exist in the first sample.,OK,"I=lambda:list(map(int,input().split()))
n,k,T=I()
t=[I()for _ in '0'*k]
def b(h,w,r,a):
	if h>n:a+=[r]
	else:
		b(h+1,w,r,a)
		for f,s,v in t:
			if f==h and s in w:b(h+1,w-set([s]),r+v,a)
	return a
print(sorted(b(1,set(range(1,n+1)), 0,[]))[T-1])","import n

def g():
    n.setrecursionlimit(10**7)
    c = n.stdin.read().strip().split()
    if not c:
        return
    f = iter(c)
    n = int(next(f))
    m = int(next(f))

    a = [0] * n
    for i in range(n):
        a[i] = int(next(f))

    e = [[] for _ in range(n)]
    for _ in range(m):
        u = int(next(f)) - 1
        v = int(next(f)) - 1
        e[u].append(v)
        e[v].append(u)

    h = list(range(n))
    h.sort(key=lambda i: a[i], reverse=True)

    j = list(range(n))
    m = [1] * n

    def d(x):

        while j[x] != x:
            j[x] = j[j[x]]
            x = j[x]
        return x

    def p(x, y):
        k = d(x)
        l = d(y)
        if k == l:
            return 0

        if m[k] < m[l]:
            k, l = l, k
        j[l] = k

        i = m[k] * m[l]
        m[k] += m[l]
        return i

    a = [False] * n
    
    o = 0

    for u in h:
        a[u] = True

        for v in e[u]:
            if a[v]:
                i = p(u, v)

                if i:
                    o += 2 * i * a[u]

    b = o / (n * (n - 1))
    n.stdout.write(f""{b:.6f}\n"")

if __name__ == ""__main__"":
    g()"
791,A,Bear and Big Brother,PROGRAMMING,['implementation'],"Bear Limak wants to become the largest of bears, or at least to become larger than his brother Bob.

Right now, Limak and Bob weigh *a* and *b* respectively. It's guaranteed that Limak's weight is smaller than or equal to his brother's weight.

Limak eats a lot and his weight is tripled after every year, while Bob's weight is doubled after every year.

After how many full years will Limak become strictly larger (strictly heavier) than Bob?",The only line of the input contains two integers *a* and *b* (1<=≤<=*a*<=≤<=*b*<=≤<=10) — the weight of Limak and the weight of Bob respectively.,"Print one integer, denoting the integer number of years after which Limak will become strictly larger than Bob.","['4 7\n', '4 9\n', '1 1\n']","['2\n', '3\n', '1\n']","In the first sample, Limak weighs 4 and Bob weighs 7 initially. After one year their weights are 4·3 = 12 and 7·2 = 14 respectively (one weight is tripled while the other one is doubled). Limak isn't larger than Bob yet. After the second year weights are 36 and 28, so the first weight is greater than the second one. Limak became larger than Bob after two years so you should print 2.

In the second sample, Limak's and Bob's weights in next years are: 12 and 18, then 36 and 36, and finally 108 and 72 (after three years). The answer is 3. Remember that Limak wants to be larger than Bob and he won't be satisfied with equal weights.

In the third sample, Limak becomes larger than Bob after the first year. Their weights will be 3 and 2 then.",RUNTIME_ERROR,"def a():
    b = 0
    a = int(input())
    b = int(input())
    while a <= b:
        a *= 3
        b *= 2
        b += 1
    return b

print(a())","def c():
    import g
    b = g.stdin.read().strip().split()

    n = int(b[0])
    e = list(map(int, b[1:]))

    a = 0
    f = 0
    for i in range(3):
        if e[i] % 2 == 0:
            a += 1
        else:
            f += 1

    h = 1 if a > f else 0

    for i, d in enumerate(e):
        if d % 2 == h:
            print(i + 1)
            return

if __name__ == '__main__':
    c()"
893,C,Rumor,PROGRAMMING,"['dfs and similar', 'graphs', 'greedy']","Vova promised himself that he would never play computer games... But recently Firestorm — a well-known game developing company — published their newest game, World of Farcraft, and it became really popular. Of course, Vova started playing it.

Now he tries to solve a quest. The task is to come to a settlement named Overcity and spread a rumor in it.

Vova knows that there are *n* characters in Overcity. Some characters are friends to each other, and they share information they got. Also Vova knows that he can bribe each character so he or she starts spreading the rumor; *i*-th character wants *c**i* gold in exchange for spreading the rumor. When a character hears the rumor, he tells it to all his friends, and they start spreading the rumor to their friends (for free), and so on.

The quest is finished when all *n* characters know the rumor. What is the minimum amount of gold Vova needs to spend in order to finish the quest?

Take a look at the notes if you think you haven't understood the problem completely.","The first line contains two integer numbers *n* and *m* (1<=≤<=*n*<=≤<=105,<=0<=≤<=*m*<=≤<=105) — the number of characters in Overcity and the number of pairs of friends.

The second line contains *n* integer numbers *c**i* (0<=≤<=*c**i*<=≤<=109) — the amount of gold *i*-th character asks to start spreading the rumor.

Then *m* lines follow, each containing a pair of numbers (*x**i*,<=*y**i*) which represent that characters *x**i* and *y**i* are friends (1<=≤<=*x**i*,<=*y**i*<=≤<=*n*, *x**i*<=≠<=*y**i*). It is guaranteed that each pair is listed at most once.",Print one number — the minimum amount of gold Vova has to spend in order to finish the quest.,"['5 2\n2 5 3 4 8\n1 4\n4 5\n', '10 0\n1 2 3 4 5 6 7 8 9 10\n', '10 5\n1 6 2 7 3 8 4 9 5 10\n1 2\n3 4\n5 6\n7 8\n9 10\n']","['10\n', '55\n', '15\n']","In the first example the best decision is to bribe the first character (he will spread the rumor to fourth character, and the fourth one will spread it to fifth). Also Vova has to bribe the second and the third characters, so they know the rumor.

In the second example Vova has to bribe everyone.

In the third example the optimal decision is to bribe the first, the third, the fifth, the seventh and the ninth characters.",MEMORY_LIMIT_EXCEEDED,"import o
input = o.stdin.readline

def e():
    return int(input())

def g():
    return input().strip(""\n"")

def d():
    return(list(map(int, input().split())))

def f():
    return(input().split())

def b(j, p):
    N = len(j or [])
    l = 0
    r = N - 1

    while l <= r:
        h = ((l + r) // 2)
        if j[h] < p:
            l = h + 1
        elif j[h] > p:
            r = h - 1
        else:
            return (None, h, None)

    return (r if r >= 0 else None, None, l if l <= N-1 else None)

def s(r):
    print(""YES"" if r else ""NO"")

def k(j):
    print(*j)

def m():
    print()

def a(n, c, l):
    if l[n]:
        return 0
    n = []
    n.append(n)

    m = 1000000001

    while n:
        s = n.pop()

        if not l[s]:
            m = min(m, c[s])
            l[s] = True

        for i in range(len(c[s])):
            if c[s][i]:
                if not l[i]:
                    n.append(i)
    return m

n, m = d()

c = [[False for i in range(n)] for i in range(n)]
c = d()
for i in range(m):
    x, y = d()
    c[x-1][y-1] = True
    c[y-1][x-1] = True

l = [False for i in range(n)]
q = 0
for i in range(n):
    q += a(i, c, l)
print(q)","def d():

    n, m = map(int, input().split())

    a = list(map(int, input().split()))

    b = list(map(int, input().split()))

    a.sort()
    b.sort()

    for c in range(1, 10):
        if c in a and c in b:

            print(c)
            return

    a = int(str(a[0]) + str(b[0]))
    b = int(str(b[0]) + str(a[0]))

    print(min(a, b))

if __name__ == '__main__':
    d()"
25,A,IQ test,PROGRAMMING,['brute force'],"Bob is preparing to pass IQ test. The most frequent task in this test is to find out which one of the given *n* numbers differs from the others. Bob observed that one number usually differs from the others in evenness. Help Bob — to check his answers, he needs a program that among the given *n* numbers finds one that is different in evenness.","The first line contains integer *n* (3<=≤<=*n*<=≤<=100) — amount of numbers in the task. The second line contains *n* space-separated natural numbers, not exceeding 100. It is guaranteed, that exactly one of these numbers differs from the others in evenness.",Output index of number that differs from the others in evenness. Numbers are numbered from 1 in the input order.,"['5\n2 4 7 8 10\n', '4\n1 2 1 1\n']","['3\n', '2\n']",none,WRONG_ANSWER,"import fileinput as d

def i(f):
	c, h = False, False
	for e in range(len(f)):
		next = f[e]
		if (((next % 2 == 0) and h) or ((next % 2 == 1) and c)):
			return e + 1
		elif ((next % 2 == 0) and not (c)):
			c = True
		elif ((next % 2 == 1) and not (h)):
			h = True

if __name__ == '__main__':
	b = d.input()
	b[0]
	a = b[1]
	g = a.split("" "")
	f = [int(s) for s in g]
	print(i(f))","def f():
    import h
    from collections import e

    d = h.stdin.read().split()
    if not d:
        return

    n = int(d[0])
    k = int(d[1])

    a = list(map(int, d[2:2+n]))

    c = e(int)
    for g in a:
        c[g] += 1

    b = e(int)

    a = 0

    for j in range(n):
        x = a[j]

        c[x] -= 1

        if k == 1:
            a += b[x] * c[x]
        else:

            if x % k == 0:
                y = x // k
                z = x * k
                a += b[y] * c[z]

        b[x] += 1

    h.stdout.write(str(a))

if __name__ == '__main__':
    f()"
946,B,Weird Subtraction Process,PROGRAMMING,"['math', 'number theory']","You have two variables *a* and *b*. Consider the following sequence of actions performed with these variables:
1.  If *a*<==<=0 or *b*<==<=0, end the process. Otherwise, go to step 2;1.  If *a*<=≥<=2·*b*, then set the value of *a* to *a*<=-<=2·*b*, and repeat step 1. Otherwise, go to step 3;1.  If *b*<=≥<=2·*a*, then set the value of *b* to *b*<=-<=2·*a*, and repeat step 1. Otherwise, end the process.
Initially the values of *a* and *b* are positive integers, and so the process will be finite.

You have to determine the values of *a* and *b* after the process ends.","The only line of the input contains two integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=1018). *n* is the initial value of variable *a*, and *m* is the initial value of variable *b*.",Print two integers — the values of *a* and *b* after the end of the process.,"['12 5\n', '31 12\n']","['0 1\n', '7 12\n']","Explanations to the samples:
1.  *a* = 12, *b* = 5 <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> *a* = 2, *b* = 5 <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> *a* = 2, *b* = 1 <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> *a* = 0, *b* = 1;1.  *a* = 31, *b* = 12 <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> *a* = 7, *b* = 12.",RUNTIME_ERROR,"a,b = map(int,input().split())

def a(a,b):
    if(a==0) or (b==0):
        print(a,b)
        exit()
    else:
        c(a,b)
        
def c(a,b):
    if(a>=2*b):
        a=a-2*b
        a(a,b)
    else:
        b(a,b)
        
def b(a,b):
    if(b>=2*a):
        b=b-2*a
        a(a,b)
    else:
        print(a,b)
        exit()
        
a(a,b)","def b():

    s = input().strip()

    c = []
    
    for a in s:

        if a not in c:
            if a != chr(ord('a') + len(c)):
                print(""NO"")
                return
            c.append(a)

    print(""YES"")

if __name__ == '__main__':
    b()"
455,C,Civilization,PROGRAMMING,"['dfs and similar', 'dp', 'dsu', 'ternary search', 'trees']","Andrew plays a game called ""Civilization"". Dima helps him.

The game has *n* cities and *m* bidirectional roads. The cities are numbered from 1 to *n*. Between any pair of cities there either is a single (unique) path, or there is no path at all. A path is such a sequence of distinct cities *v*1,<=*v*2,<=...,<=*v**k*, that there is a road between any contiguous cities *v**i* and *v**i*<=+<=1 (1<=≤<=*i*<=&lt;<=*k*). The length of the described path equals to (*k*<=-<=1). We assume that two cities lie in the same region if and only if, there is a path connecting these two cities.

During the game events of two types take place:
 1.  Andrew asks Dima about the length of the longest path in the region where city *x* lies. 1.  Andrew asks Dima to merge the region where city *x* lies with the region where city *y* lies. If the cities lie in the same region, then no merging is needed. Otherwise, you need to merge the regions as follows: choose a city from the first region, a city from the second region and connect them by a road so as to minimize the length of the longest path in the resulting region. If there are multiple ways to do so, you are allowed to choose any of them. 
Dima finds it hard to execute Andrew's queries, so he asks you to help him. Help Dima.","The first line contains three integers *n*, *m*, *q* (1<=≤<=*n*<=≤<=3·105; 0<=≤<=*m*<=&lt;<=*n*; 1<=≤<=*q*<=≤<=3·105) — the number of cities, the number of the roads we already have and the number of queries, correspondingly.

Each of the following *m* lines contains two integers, *a**i* and *b**i* (*a**i*<=≠<=*b**i*; 1<=≤<=*a**i*,<=*b**i*<=≤<=*n*). These numbers represent the road between cities *a**i* and *b**i*. There can be at most one road between two cities.

Each of the following *q* lines contains one of the two events in the following format:
 -  1 *x**i*. It is the request Andrew gives to Dima to find the length of the maximum path in the region that contains city *x**i* (1<=≤<=*x**i*<=≤<=*n*).  2 *x**i* *y**i*. It is the request Andrew gives to Dima to merge the region that contains city *x**i* and the region that contains city *y**i* (1<=≤<=*x**i*,<=*y**i*<=≤<=*n*). Note, that *x**i* can be equal to *y**i*. ",For each event of the first type print the answer on a separate line.,['6 0 6\n2 1 2\n2 3 4\n2 5 6\n2 3 2\n2 5 3\n1 1\n'],['4\n'],none,MEMORY_LIMIT_EXCEEDED,"import fractions
import gc
import heapq
import itertools
from itertools import combinations, permutations
import math
import random
from collections import Counter, c, defaultdict
from l import stdout
import time
from math import factorial, log, gcd
import l
from decimal import Decimal
import threading
from heapq import *
from fractions import Fraction
from bisect import bisect_left, bisect_right

def S():
	return l.stdin.readline().split()

def I():
	return [int(i) for i in l.stdin.readline().split()]

def a():
	return int(l.stdin.readline())

def b():
	return l.stdin.readline().replace('\n', '')
 

def g():
	n, m, q = I()
	m = [[] for _ in range(n)]
	for _ in range(m):
		u, v = I()
		m[u - 1].append(v - 1)
		m[v - 1].append(u - 1)
 
	f = [-1] * n
	j = [[] for _ in range(n)]
	p = [0] * n
	for i in range(n):
		if f[i] == -1:
			k = c([(i, 0, i)])
			i = (0, i)
			while k:
				v, d, p = k.pop()
				f[v] = i
				j[i].append(v)
				for u in m[v]:
					if p != u:
						i = max(i, (d + 1, u))
						k.append((u, d + 1, v))
   
			k = c([(i[1], 0, i[1])])
			i = (0, 0)
			while k:
				v, d, p = k.pop()
				for u in m[v]:
					if p != u:
						i = max(i, (d + 1, u))
						k.append((u, d + 1, v))
    
			p[i] = i[0]
 
	for _ in range(q):
		t, *z = I()
		if t == 1:
			x = z[0]
			print(p[f[x - 1]])
		else:
			x, y = z
			if x != y:
				d = f[x - 1]
				e = f[y - 1]
				if len(j[d]) > len(j[e]):
					d, e = e, d
    
				for i in j[d]:
					f[i] = e
					j[e].append(i)
				j[d] = []
    
				n, o = p[d], p[e]
				p[e] = max([n, o, n // 2 + n % 2 + o // 2 + o % 2 + 1])
				p[d] = 0
 

if __name__ == '__main__':
	h = 998244353

	g()","def h():
    import j

    d = j.stdin.read().strip().split()
    if not d:
        return

    n = int(d[0])

    f = {}
    e = {}

    g = 1
    for i in range(n):

        r = int(d[g])
        c = int(d[g + 1])
        g += 2

        c = r - c
        b = r + c

        f[c] = f.get(c, 0) + 1

        e[b] = e.get(b, 0) + 1

    i = 0

    for a in f.values():
        if a > 1:
            i += a * (a - 1) // 2

    for a in e.values():
        if a > 1:
            i += a * (a - 1) // 2

    j.stdout.write(str(i))

if __name__ == '__main__':
    h()"
4,A,Watermelon,PROGRAMMING,"['brute force', 'math']","One hot summer day Pete and his friend Billy decided to buy a watermelon. They chose the biggest and the ripest one, in their opinion. After that the watermelon was weighed, and the scales showed *w* kilos. They rushed home, dying of thirst, and decided to divide the berry, however they faced a hard problem.

Pete and Billy are great fans of even numbers, that's why they want to divide the watermelon in such a way that each of the two parts weighs even number of kilos, at the same time it is not obligatory that the parts are equal. The boys are extremely tired and want to start their meal as soon as possible, that's why you should help them and find out, if they can divide the watermelon in the way they want. For sure, each of them should get a part of positive weight.",The first (and the only) input line contains integer number *w* (1<=≤<=*w*<=≤<=100) — the weight of the watermelon bought by the boys.,"Print YES, if the boys can divide the watermelon into two parts, each of them weighing even number of kilos; and NO in the opposite case.",['8\n'],['YES\n'],"For example, the boys can divide the watermelon into two parts of 2 and 6 kilos respectively (another variant — two parts of 4 and 4 kilos).",WRONG_ANSWER,"def c(w):
    if w%2!=0:
        return ""NO""
    else:
        a=w//2
        if a%2==0:
            return ""YES""
        else:
            return ""NO""

d=8
b=c(d)
print(b)","def d(x):

    return x & -x

def e():
    import i
    b = i.stdin.read().split()
    if not b:
        return
    j = int(b[0])
    c = int(b[1])

    a = []
    for x in range(1, c + 1):
        a.append((d(x), x))

    a.sort(key=lambda t: t[0], reverse=True)
    
    h = []
    g = j

    for k, x in a:
        if k <= g:
            h.append(x)
            g -= k
        if g == 0:
            break

    if g == 0:
        f = []

        f.append(str(len(h)))

        f.append("" "".join(map(str, h)))
        i.stdout.write(""\n"".join(f))
    else:

        i.stdout.write(""-1"")

if __name__ == '__main__':
    e()"
591,B,Rebranding,PROGRAMMING,"['implementation', 'strings']","The name of one small but proud corporation consists of *n* lowercase English letters. The Corporation has decided to try rebranding — an active marketing strategy, that includes a set of measures to change either the brand (both for the company and the goods it produces) or its components: the name, the logo, the slogan. They decided to start with the name.

For this purpose the corporation has consecutively hired *m* designers. Once a company hires the *i*-th designer, he immediately contributes to the creation of a new corporation name as follows: he takes the newest version of the name and replaces all the letters *x**i* by *y**i*, and all the letters *y**i* by *x**i*. This results in the new version. It is possible that some of these letters do no occur in the string. It may also happen that *x**i* coincides with *y**i*. The version of the name received after the work of the last designer becomes the new name of the corporation.

Manager Arkady has recently got a job in this company, but is already soaked in the spirit of teamwork and is very worried about the success of the rebranding. Naturally, he can't wait to find out what is the new name the Corporation will receive.

Satisfy Arkady's curiosity and tell him the final version of the name.","The first line of the input contains two integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=200<=000) — the length of the initial name and the number of designers hired, respectively.

The second line consists of *n* lowercase English letters and represents the original name of the corporation.

Next *m* lines contain the descriptions of the designers' actions: the *i*-th of them contains two space-separated lowercase English letters *x**i* and *y**i*.",Print the new name of the corporation.,"['6 1\npolice\np m\n', '11 6\nabacabadaba\na b\nb c\na d\ne g\nf a\nb b\n']","['molice\n', 'cdcbcdcfcdc\n']","In the second sample the name of the corporation consecutively changes as follows:

<img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/c7648432f7138ca53234357d7e08d1d119166055.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

<img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/de89ad7bc7f27c46ec34f5e66ce0dc23bd5bc90a.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

<img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/812e653c8d7ff496e6a0f04c676423806751531e.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

<img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/19c564fcefb8dde36256240a8b877bb6a4792bfe.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

<img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/e1cafd93792430ad1a49e893e04715383bdae757.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>",RUNTIME_ERROR,"def a(b, n, m):
    for i in range(m):
        b = (lambda c, x, y: (y if i == x else (x if i == y else i) for i in c))(b, *input().split())
    return """".join(b)

n, m = map(int, input().split())
b = input()
print(a(b, n, m))","def a():

    x = int(input().strip())

    b = bin(x).count('1')

    print(b)

if __name__ == ""__main__"":
    a()"
820,B,Mister B and Angle in Polygon,PROGRAMMING,"['constructive algorithms', 'geometry', 'math']","On one quiet day all of sudden Mister B decided to draw angle *a* on his field. Aliens have already visited his field and left many different geometric figures on it. One of the figures is regular convex *n*-gon (regular convex polygon with *n* sides).

That's why Mister B decided to use this polygon. Now Mister B must find three distinct vertices *v*1, *v*2, *v*3 such that the angle  (where *v*2 is the vertex of the angle, and *v*1 and *v*3 lie on its sides) is as close as possible to *a*. In other words, the value  should be minimum possible.

If there are many optimal solutions, Mister B should be satisfied with any of them.","First and only line contains two space-separated integers *n* and *a* (3<=≤<=*n*<=≤<=105, 1<=≤<=*a*<=≤<=180) — the number of vertices in the polygon and the needed angle, in degrees.","Print three space-separated integers: the vertices *v*1, *v*2, *v*3, which form . If there are multiple optimal solutions, print any of them. The vertices are numbered from 1 to *n* in clockwise order.","['3 15\n', '4 67\n', '4 68\n']","['1 2 3\n', '2 1 3\n', '4 1 2\n']","In first sample test vertices of regular triangle can create only angle of 60 degrees, that's why every possible angle is correct.

Vertices of square can create 45 or 90 degrees angles only. That's why in second sample test the angle of 45 degrees was chosen, since |45 - 67| &lt; |90 - 67|. Other correct answers are: ""3 1 2"", ""3 2 4"", ""4 2 3"", ""4 3 1"", ""1 3 4"", ""1 4 2"", ""2 4 1"", ""4 1 3"", ""3 1 4"", ""3 4 2"", ""2 4 3"", ""2 3 1"", ""1 3 2"", ""1 2 4"", ""4 2 1"".

In third sample test, on the contrary, the angle of 90 degrees was chosen, since |90 - 68| &lt; |45 - 68|. Other correct answers are: ""2 1 4"", ""3 2 1"", ""1 2 3"", ""4 3 2"", ""2 3 4"", ""1 4 3"", ""3 4 1"".",WRONG_ANSWER,"""""""
	Author		: Arif Ahmad
	Date  		: 
	Algo  		: 
	Difficulty	: 
""""""
from sys import e, f

def b():
	n, a = [int(_) for _ in e.readline().strip().split()]

	if n == 3:
		f.write('1 2 3\n')
		return

	d = 180 / n
	c = a // d
	if c == 0: a = 3
	else:
		x = d * c
		y = d * (c + 1)
		if abs(a - x) < abs(a - y):
			a = 2 + c
		else:
			a = 3 + c

	f.write('2 1 ' + str(int(a)) + '\n') 

if __name__ == '__main__':
    b()","import h

def f(n, k):

    for x in range(n + 1):

        g = n - x

        if g == 0:

            if k - 2*x == 0:
                return x
            continue
        e = 3 * g
        d = 5 * g
        if e <= k - 2*x <= d:
            return x

    return -1

def c():

    a = h.stdin.readlines()
    for b in a:
        i = b.strip().split()
        if not i:
            continue
        n, k = map(int, i)
        print(f(n, k))

if __name__ == ""__main__"":
    c()"
44,H,Phone Number,PROGRAMMING,['dp'],"Alas, finding one's true love is not easy. Masha has been unsuccessful in that yet. Her friend Dasha told Masha about a way to determine the phone number of one's Prince Charming through arithmancy. 

The phone number is divined like that. First one needs to write down one's own phone numbers. For example, let's suppose that Masha's phone number is 12345. After that one should write her favorite digit from 0 to 9 under the first digit of her number. That will be the first digit of the needed number. For example, Masha's favorite digit is 9. The second digit is determined as a half sum of the second digit of Masha's number and the already written down first digit from her beloved one's number. In this case the arithmetic average equals to (2<=+<=9)<=/<=2<==<=5.5. Masha can round the number up or down, depending on her wishes. For example, she chooses the digit 5. Having written down the resulting digit under the second digit of her number, Masha moves to finding the third digit in the same way, i.e. finding the half sum the the third digit of her number and the second digit of the new number. The result is (5<=+<=3)<=/<=2<==<=4. In this case the answer is unique. Thus, every *i*-th digit is determined as an arithmetic average of the *i*-th digit of Masha's number and the *i*<=-<=1-th digit of her true love's number. If needed, the digit can be rounded up or down. For example, Masha can get:",The first line contains nonempty sequence consisting of digits from 0 to 9 — Masha's phone number. The sequence length does not exceed 50.,Output the single number — the number of phone numbers Masha will dial.,"['12345\n', '09\n']","['48\n', '15\n']",none,OK,"import f
import h
from math import e, b

if f.getenv('LOCALCFTEST'):
    h.stdin = open('cfinput.txt')
a = 998244353

def g(s):
    s = list(map(int, s))
    n = len(s)
    c = [[0] * 10 for _ in range(n)]
    c[0] = [1] * 10
    d = True
    for i in range(n - 1):
        t = (s[i] + s[i + 1]) / 2
        if s[i + 1] != b(t) and s[i + 1] != e(t):
            d = False
        for j in range(10):
            a, b = divmod(j + s[i + 1], 2)
            c[i + 1][a] += c[i][j]

            if b == 1:
                c[i + 1][a + 1] += c[i][j]

    print(sum(c[-1]) - d)

if __name__ == '__main__':
    s = input()
    g(s)","import f

def e():

    b = f.stdin.read().split()
    n = int(b[0])
    m = int(b[1])
    k = int(b[2])

    c = set(int(b[i]) for i in range(3, 3 + m))

    a = 1

    if a in c:
        print(a)
        return

    d = 3 + m
    for _ in range(k):
        u = int(b[d])
        v = int(b[d + 1])
        d += 2

        if a == u:
            a = v
        elif a == v:
            a = u

        if a in c:
            break

    print(a)

if __name__ == '__main__':
    e()"
6,D,Lizards and Basements 2,PROGRAMMING,"['brute force', 'dp']","This is simplified version of the problem used on the original contest. The original problem seems to have too difiicult solution. The constraints for input data have been reduced.

Polycarp likes to play computer role-playing game «Lizards and Basements». At the moment he is playing it as a magician. At one of the last levels he has to fight the line of archers. The only spell with which he can damage them is a fire ball. If Polycarp hits the *i*-th archer with his fire ball (they are numbered from left to right), the archer loses *a* health points. At the same time the spell damages the archers adjacent to the *i*-th (if any) — they lose *b* (1<=≤<=*b*<=&lt;<=*a*<=≤<=10) health points each.

As the extreme archers (i.e. archers numbered 1 and *n*) are very far, the fire ball cannot reach them. Polycarp can hit any other archer with his fire ball.

The amount of health points for each archer is known. An archer will be killed when this amount is less than 0. What is the minimum amount of spells Polycarp can use to kill all the enemies?

Polycarp can throw his fire ball into an archer if the latter is already killed.","The first line of the input contains three integers *n*,<=*a*,<=*b* (3<=≤<=*n*<=≤<=10; 1<=≤<=*b*<=&lt;<=*a*<=≤<=10). The second line contains a sequence of *n* integers — *h*1,<=*h*2,<=...,<=*h**n* (1<=≤<=*h**i*<=≤<=15), where *h**i* is the amount of health points the *i*-th archer has.","In the first line print *t* — the required minimum amount of fire balls.

In the second line print *t* numbers — indexes of the archers that Polycarp should hit to kill all the archers in *t* shots. All these numbers should be between 2 and *n*<=-<=1. Separate numbers with spaces. If there are several solutions, output any of them. Print numbers in any order.","['3 2 1\n2 2 2\n', '4 3 1\n1 4 1 1\n']","['3\n2 2 2 ', '4\n2 2 3 3 ']",none,OK,"a = 'Darren'

def g():
    n, a, b = map(int, input().split())
    h = [0]
    h.extend(map(int, input().split()))

    d = []
    c = h[1] // b + 1 if h[1] >= 0 else 0
    d.extend([2 for i in range(c)])
    h[1] -= b * c
    h[2] -= a * c
    h[3] -= b * c
    c = h[n] // b + 1 if h[n] >= 0 else 0
    d.extend([n-1 for i in range(c)])
    h[n] -= b * c
    h[n-1] -= a * c
    h[n-2] -= b * c

    h = d.copy()
    for i in range(2, n):
        c = h[i] // a + 1
        d.extend([i for j in range(c)])

    def f(e):
        nonlocal n, a, b, h, d, h
        if e == n and h[e-1] < 0:
            if len(d) > len(h):
                d = h.copy()
            return
        b = 0
        c = h[e-1] // b + 1 if h[e-1] >= 0 else 0
        h.extend([e for i in range(c)])
        h[e-1] -= b * c
        h[e] -= a * c
        h[e+1] -= b * c
        b += c

        while h[e] >= 0:
            f(e+1)
            h.append(e)
            h[e-1] -= b
            h[e] -= a
            h[e+1] -= b
            b += 1
        f(e+1)

        h[e-1] += b * b
        h[e] += a * b
        h[e+1] += b * b
        for i in range(b):
            h.pop()

    f(2)
    print(len(d))
    print(' '.join(map(str, d)))

if __name__ == '__main__':
    g()","def e():
    import h
    d = h.stdin.read().split()

    n = int(d[0])
    A = int(d[1])
    B = int(d[2])
    g = list(map(int, d[3:3+n]))

    b = g[0]

    i = sum(g)

    if A * b >= B * i:
        print(0)
        return

    f = sorted(g[1:], reverse=True)
    
    a = 0
    for c in f:
        i -= c
        a += 1

        if A * b >= B * i:
            print(a)
            return

    print(a)

if __name__ == '__main__':
    e()"
285,B,Find Marble,PROGRAMMING,['implementation'],"Petya and Vasya are playing a game. Petya's got *n* non-transparent glasses, standing in a row. The glasses' positions are indexed with integers from 1 to *n* from left to right. Note that the positions are indexed but the glasses are not.

First Petya puts a marble under the glass in position *s*. Then he performs some (possibly zero) shuffling operations. One shuffling operation means moving the glass from the first position to position *p*1, the glass from the second position to position *p*2 and so on. That is, a glass goes from position *i* to position *p**i*. Consider all glasses are moving simultaneously during one shuffling operation. When the glasses are shuffled, the marble doesn't travel from one glass to another: it moves together with the glass it was initially been put in.

After all shuffling operations Petya shows Vasya that the ball has moved to position *t*. Vasya's task is to say what minimum number of shuffling operations Petya has performed or determine that Petya has made a mistake and the marble could not have got from position *s* to position *t*.","The first line contains three integers: *n*,<=*s*,<=*t* (1<=≤<=*n*<=≤<=105; 1<=≤<=*s*,<=*t*<=≤<=*n*) — the number of glasses, the ball's initial and final position. The second line contains *n* space-separated integers: *p*1,<=*p*2,<=...,<=*p**n* (1<=≤<=*p**i*<=≤<=*n*) — the shuffling operation parameters. It is guaranteed that all *p**i*'s are distinct.

Note that *s* can equal *t*.","If the marble can move from position *s* to position *t*, then print on a single line a non-negative integer — the minimum number of shuffling operations, needed to get the marble to position *t*. If it is impossible, print number -1.","['4 2 1\n2 3 4 1\n', '4 3 3\n4 1 3 2\n', '4 3 4\n1 2 3 4\n', '3 1 3\n2 1 3\n']","['3\n', '0\n', '-1\n', '-1\n']",none,TIME_LIMIT_EXCEEDED,"def d():
    n,s,t = map(int,input().split())
    c=[-1]+list(map(int,input().split()))
    a=0
    b=1
    e=[]
    while(s!=t):
        e.append(s)
        s=c[s]
        a=a+1
        if(s in e):
            b=0
            break
    if(b==1):
        print(a)
    else:
        print(""-1"")
d()","def l():
    import n
    from collections import d
    j = n.stdin.read().strip().split()
    if not j:
        return

    n = int(j[0])
    x = int(j[1])

    h = [[] for _ in range(n + 1)]
    i = 2
    for _ in range(n - 1):
        a = int(j[i])
        b = int(j[i + 1])
        i += 2
        h[a].append(b)
        h[b].append(a)

    def b(m):
        e = [-1] * (n + 1)
        q = d()
        e[m] = 0
        q.append(m)
        while q:
            c = q.popleft()
            for k in h[c]:
                if e[k] == -1:
                    e[k] = e[c] + 1
                    q.append(k)
        return e

    f = b(1)
    g = b(x)

    a = 0
    for v in range(1, n + 1):
        if f[v] > g[v]:
            a = max(a, 2 * f[v])
    
    n.stdout.write(str(a))
    
if __name__ == '__main__':
    l()"
501,B,Misha and Changing Handles,PROGRAMMING,"['data structures', 'dsu', 'strings']","Misha hacked the Codeforces site. Then he decided to let all the users change their handles. A user can now change his handle any number of times. But each new handle must not be equal to any handle that is already used or that was used at some point.

Misha has a list of handle change requests. After completing the requests he wants to understand the relation between the original and the new handles of the users. Help him to do that.","The first line contains integer *q* (1<=≤<=*q*<=≤<=1000), the number of handle change requests.

Next *q* lines contain the descriptions of the requests, one per line.

Each query consists of two non-empty strings *old* and *new*, separated by a space. The strings consist of lowercase and uppercase Latin letters and digits. Strings *old* and *new* are distinct. The lengths of the strings do not exceed 20.

The requests are given chronologically. In other words, by the moment of a query there is a single person with handle *old*, and handle *new* is not used and has not been used by anyone.","In the first line output the integer *n* — the number of users that changed their handles at least once.

In the next *n* lines print the mapping between the old and the new handles of the users. Each of them must contain two strings, *old* and *new*, separated by a space, meaning that before the user had handle *old*, and after all the requests are completed, his handle is *new*. You may output lines in any order.

Each user who changes the handle must occur exactly once in this description.",['5\nMisha ILoveCodeforces\nVasya Petrov\nPetrov VasyaPetrov123\nILoveCodeforces MikeMirzayanov\nPetya Ivanov\n'],['3\nPetya Ivanov\nMisha MikeMirzayanov\nVasya VasyaPetrov123\n'],none,OK,"def a(x):
    if a[x] not in a.keys():
        return a[x]
    else:
        return a(a[x])

n=int(input())
a={}
d={}
for i in range(n):
    b,c=input().split()
    a[b]=c
    d[c]=b
e=[]
for i in a:
    if i not in d.keys():
        e.append([i,a(i)])
print(len(e))
for i in range(len(e)):
    print(*e[i])","n = int(input().strip())

b = list(map(int, input().split()))

m = int(input().strip())

for _ in range(m):

    x, y = map(int, input().split())

    if x - 2 >= 0:
        b[x - 2] += y - 1

    if x < n:
        b[x] += b[x - 1] - y

    b[x - 1] = 0

for a in b:
    print(a)"
689,C,Mike and Chocolate Thieves,PROGRAMMING,"['binary search', 'combinatorics', 'math']","Bad news came to Mike's village, some thieves stole a bunch of chocolates from the local factory! Horrible! 

Aside from loving sweet things, thieves from this area are known to be very greedy. So after a thief takes his number of chocolates for himself, the next thief will take exactly *k* times more than the previous one. The value of *k* (*k*<=&gt;<=1) is a secret integer known only to them. It is also known that each thief's bag can carry at most *n* chocolates (if they intend to take more, the deal is cancelled) and that there were exactly four thieves involved. 

Sadly, only the thieves know the value of *n*, but rumours say that the numbers of ways they could have taken the chocolates (for a fixed *n*, but not fixed *k*) is *m*. Two ways are considered different if one of the thieves (they should be numbered in the order they take chocolates) took different number of chocolates in them.

Mike want to track the thieves down, so he wants to know what their bags are and value of *n* will help him in that. Please find the smallest possible value of *n* or tell him that the rumors are false and there is no such *n*.","The single line of input contains the integer *m* (1<=≤<=*m*<=≤<=1015) — the number of ways the thieves might steal the chocolates, as rumours say.","Print the only integer *n* — the maximum amount of chocolates that thieves' bags can carry. If there are more than one *n* satisfying the rumors, print the smallest one.

If there is no such *n* for a false-rumoured *m*, print <=-<=1.","['1\n', '8\n', '10\n']","['8\n', '54\n', '-1\n']","In the first sample case the smallest *n* that leads to exactly one way of stealing chocolates is *n* = 8, whereas the amounts of stealed chocolates are (1, 2, 4, 8) (the number of chocolates stolen by each of the thieves).

In the second sample case the smallest *n* that leads to exactly 8 ways is *n* = 54 with the possibilities: (1, 2, 4, 8),  (1, 3, 9, 27),  (2, 4, 8, 16),  (2, 6, 18, 54),  (3, 6, 12, 24),  (4, 8, 16, 32),  (5, 10, 20, 40),  (6, 12, 24, 48).

There is no *n* leading to exactly 10 ways of stealing chocolates in the third sample case.",OK,"def f(m):
    def b(e):
        a = 0
        i = 2
        while i * i * i <= e:
            a += e // (i * i * i)
            i += 1
        return a
        
    n = -1
    d = 0
    c = 5e15

    while d < c:
        e = int(d + ((c-d) // 2))
        if b(e) < m:
            d = e + 1
        else:
            c = e
    
    if b(d) == m:
        n = d
    
    return int(n)

if __name__ == '__main__':
    m = int(input())
    a = f(m)
    print(a)","import i

a = 1000000007

def e():

    d = i.stdin.read().splitlines()

    n, m = map(int, d[0].split())

    f = d[1:n+1]

    h = 1

    for b in range(m):

        c = set()
        for i in range(n):
            c.add(f[i][b])

        g = len(c)

        h = (h * g) % a

    print(h)

if __name__ == ""__main__"":
    e()"
664,A,Complicated GCD,PROGRAMMING,"['math', 'number theory']","Greatest common divisor *GCD*(*a*,<=*b*) of two positive integers *a* and *b* is equal to the biggest integer *d* such that both integers *a* and *b* are divisible by *d*. There are many efficient algorithms to find greatest common divisor *GCD*(*a*,<=*b*), for example, Euclid algorithm. 

Formally, find the biggest integer *d*, such that all integers *a*,<=*a*<=+<=1,<=*a*<=+<=2,<=...,<=*b* are divisible by *d*. To make the problem even more complicated we allow *a* and *b* to be up to googol, 10100 — such number do not fit even in 64-bit integer type!",The only line of the input contains two integers *a* and *b* (1<=≤<=*a*<=≤<=*b*<=≤<=10100).,Output one integer — greatest common divisor of all integers from *a* to *b* inclusive.,"['1 2\n', '61803398874989484820458683436563811772030917980576 61803398874989484820458683436563811772030917980576\n']","['1\n', '61803398874989484820458683436563811772030917980576\n']",none,OK,"a ,b = list(map(int , input().split()))

def a(a , b):

    if b == 0 :
        return a
    return a(b , a % b)

if b - a >= 1:
    print(1)
else:
    print(a(a , b))","import o

def l():

    c = o.stdin.read().split()
    if not c:
        return

    n = int(c[0])
    m = int(c[1])
    h = 2

    e = []
    p = 0
    for i in range(n):
        k = int(c[h])
        h += 1
        j = []
        for j in range(k):
            j.append(int(c[h]))
            h += 1
        p += len(j)
        e.append(j)

    if p == 0:
        print(n)
        return

    n = list(range(n))
    
    def g(x):

        if n[x] != x:
            n[x] = g(n[x])
        return n[x]
    
    def q(a, b):

        a = g(a)
        b = g(b)
        if a != b:
            n[b] = a

    k = {}
    for i in range(n):
        for i in e[i]:
            if i not in k:
                k[i] = []
            k[i].append(i)

    for i, f in k.items():
        a = f[0]
        for d in f[1:]:
            q(a, d)

    b = set()
    for i in range(n):
        if e[i]:
            b.add(g(i))
    m = len(b)

    r = sum(1 for j in e if not j)

    print((m - 1) + r)

if __name__ == '__main__':
    l()"
687,A,NP-Hard Problem,PROGRAMMING,"['dfs and similar', 'graphs']","Recently, Pari and Arya did some research about NP-Hard problems and they found the minimum vertex cover problem very interesting.

Suppose the graph *G* is given. Subset *A* of its vertices is called a vertex cover of this graph, if for each edge *uv* there is at least one endpoint of it in this set, i.e.  or  (or both).

Pari and Arya have won a great undirected graph as an award in a team contest. Now they have to split it in two parts, but both of them want their parts of the graph to be a vertex cover.

They have agreed to give you their graph and you need to find two disjoint subsets of its vertices *A* and *B*, such that both *A* and *B* are vertex cover or claim it's impossible. Each vertex should be given to no more than one of the friends (or you can even keep it for yourself).","The first line of the input contains two integers *n* and *m* (2<=≤<=*n*<=≤<=100<=000, 1<=≤<=*m*<=≤<=100<=000) — the number of vertices and the number of edges in the prize graph, respectively.

Each of the next *m* lines contains a pair of integers *u**i* and *v**i* (1<=<=≤<=<=*u**i*,<=<=*v**i*<=<=≤<=<=*n*), denoting an undirected edge between *u**i* and *v**i*. It's guaranteed the graph won't contain any self-loops or multiple edges.","If it's impossible to split the graph between Pari and Arya as they expect, print ""-1"" (without quotes).

If there are two disjoint sets of vertices, such that both sets are vertex cover, print their descriptions. Each description must contain two lines. The first line contains a single integer *k* denoting the number of vertices in that vertex cover, and the second line contains *k* integers — the indices of vertices. Note that because of *m*<=≥<=1, vertex cover cannot be empty.","['4 2\n1 2\n2 3\n', '3 3\n1 2\n2 3\n1 3\n']","['1\n2 \n2\n1 3 \n', '-1\n']","In the first sample, you can give the vertex number 2 to Arya and vertices numbered 1 and 3 to Pari and keep vertex number 4 for yourself (or give it someone, if you wish).

In the second sample, there is no way to satisfy both Pari and Arya.",WRONG_ANSWER,"from collections import c , b

h  = 0
e = 0
def a(e):
    global h , e

    q = c()
    q.append(e)
    while q :
        s = q.popleft()
        if not g[s]:
            h += 1
            g[s] = True
            for i in g[s]:
                e +=1
                q.append(i)

n , m = map(int,input().split())

g = b(list)
c = set()

for i in range(m):
    u , v = map(int,input().split())
    g[u].append(v)
    g[v].append(u)
    c.add(u)
    c.add(v)

g = [False] * (n + 1)
d = True

for i in c :
    h = e = 0
    r  = a(i)
    e //= 2

    if e != 0 and h != 0 :
        if e == h * (h - 1) //2:
            d = False

if d == False:
    print('-1')
    exit(0)

f = set()

f = c()
t = c()
for i in range(1 , n + 1):
    if g[i]:
        f.append(i)

    else:
        t.append(i)

print(len(f))
print(*f)
print(len(t))
print(*t)","import h

def f():

    e = h.stdin.read().strip().splitlines()
    if not e:
        return

    n = int(e[0])
    a = e[1:]

    d = 0

    for g in a:

        c = g.count('C')

        d += c * (c - 1) // 2

    for b in range(n):

        c = sum(1 for g in a if g[b] == 'C')

        d += c * (c - 1) // 2

    print(d)

if __name__ == ""__main__"":
    f()"
185,A,Plant,PROGRAMMING,['math'],"Dwarfs have planted a very interesting plant, which is a triangle directed ""upwards"". This plant has an amusing feature. After one year a triangle plant directed ""upwards"" divides into four triangle plants: three of them will point ""upwards"" and one will point ""downwards"". After another year, each triangle plant divides into four triangle plants: three of them will be directed in the same direction as the parent plant, and one of them will be directed in the opposite direction. Then each year the process repeats. The figure below illustrates this process.

Help the dwarfs find out how many triangle plants that point ""upwards"" will be in *n* years.","The first line contains a single integer *n* (0<=≤<=*n*<=≤<=1018) — the number of full years when the plant grew.

Please do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use cin, cout streams or the %I64d specifier.","Print a single integer — the remainder of dividing the number of plants that will point ""upwards"" in *n* years by 1000000007 (109<=+<=7).","['1\n', '2\n']","['3\n', '10\n']",The first test sample corresponds to the second triangle on the figure in the statement. The second test sample corresponds to the third one.,WRONG_ANSWER,"n = int(input())
a = [1, 0]
c = [[3, 1],[1,3]]
e = [[1,0],[0,1]]
d = 1e9+7
def b(a,b):
    a = [[1,0],[0,1]]
    a[0][0] = (a[0][0]*b[0][0] + a[0][1]*b[1][0])%d
    a[0][1] = (a[0][0]*b[1][0] + a[0][1]*b[1][1])%d
    a[1][0] = (a[1][0]*b[0][0] + a[1][1]*b[1][0])%d
    a[1][1] = (a[1][0]*b[1][0] + a[1][1]*b[1][1])%d
    return a
while(n!=0):
    if n%2 == 0:
        c = b(c,c)
        n //= 2
    else:
        e = b(e,c)
        n-=1

print(int(e[0][0]%d))","import e

def a(a, b, c):

    for x in range(c // a + 1):

        if (c - a * x) % b == 0:
            return True
    return False

def d():

    b = e.stdin.read().strip().splitlines()
    for c in b:
        if not c.strip():
            continue

        a, b, c = map(int, c.split())

        if a(a, b, c):
            print(""Yes"")
        else:
            print(""No"")

if __name__ == ""__main__"":
    d()"
660,A,Co-prime Array,PROGRAMMING,"['greedy', 'implementation', 'math', 'number theory']","You are given an array of *n* elements, you must make it a co-prime array in as few moves as possible.

In each move you can insert any positive integral number you want not greater than 109 in any place in the array.

An array is co-prime if any two adjacent numbers of it are co-prime.

In the number theory, two integers *a* and *b* are said to be co-prime if the only positive integer that divides both of them is 1.","The first line contains integer *n* (1<=≤<=*n*<=≤<=1000) — the number of elements in the given array.

The second line contains *n* integers *a**i* (1<=≤<=*a**i*<=≤<=109) — the elements of the array *a*.","Print integer *k* on the first line — the least number of elements needed to add to the array *a* to make it co-prime.

The second line should contain *n*<=+<=*k* integers *a**j* — the elements of the array *a* after adding *k* elements to it. Note that the new array should be co-prime, so any two adjacent values should be co-prime. Also the new array should be got from the original array *a* by adding *k* elements to it.

If there are multiple answers you can print any one of them.",['3\n2 7 28\n'],['1\n2 7 9 28\n'],none,OK,"def j(n):
    e = []
    i = 2
    while n > 1:
        while n % i == 0:
            e.append(i)
            n //= i 
        i += 1
        if i * i  > n : break
    if n > 1:
        e.append(n)
    return e

def b(f,h):
    g = j(f)
    b = True
    for f in g:
        if h % f == 0:
            b = False
            break
    return b

def m(n):
    l = [True for i in range(n+1)]
    k = []
    p = 2
    while p * p <= n:
        if l[p]:
            for i in range(p*p,n+1,p):
                l[i] = False
        p += 1
    for i in range(2,n+1):
        if l[i]:
            k.append(i)
    return k

n = int(input())
A = list(map(int,input().split()))
k = 0
a = {}
l = m(10**5)
for i in range(1,len(A)):
    c = b(A[i],A[i-1])
    d = -1
    if not c:
        k += 1
        for p in l:
            if A[i] % p != 0 and A[i-1] % p != 0:
                d = p
                break
        a[i] = d
print(k)
i = f""{A[0]} ""
for i in range(1,len(A)):
    if i in a:
        i += f""{str(a[i])} ""
    i += str(A[i])
    if i < len(A) - 1:
        i += "" ""
print(i)","import g
import f

def c():

    a = g.stdin.read().strip().split()
    if not a:
        return

    n = int(a[0])
    k = int(a[1])

    b = f.ascii_lowercase[:k]

    d = []

    for i in range(k):
        d.append(b[i])

    while len(d) < n:
        e = d[-1]

        if b[0] != e:
            d.append(b[0])
        else:
            d.append(b[1])

    g.stdout.write("""".join(d))

if __name__ == '__main__':
    c()"
349,A,Cinema Line,PROGRAMMING,"['greedy', 'implementation']","The new ""Die Hard"" movie has just been released! There are *n* people at the cinema box office standing in a huge line. Each of them has a single 100, 50 or 25 ruble bill. A ""Die Hard"" ticket costs 25 rubles. Can the booking clerk sell a ticket to each person and give the change if he initially has no money and sells the tickets strictly in the order people follow in the line?","The first line contains integer *n* (1<=≤<=*n*<=≤<=105) — the number of people in the line. The next line contains *n* integers, each of them equals 25, 50 or 100 — the values of the bills the people have. The numbers are given in the order from the beginning of the line (at the box office) to the end of the line.","Print ""YES"" (without the quotes) if the booking clerk can sell a ticket to each person and give the change. Otherwise print ""NO"".","['4\n25 25 50 50\n', '2\n25 100\n', '4\n50 50 25 25\n']","['YES\n', 'NO\n', 'NO\n']",none,RUNTIME_ERROR,"def d():
    n = int(input())
    c = 0
    g = 0
    b = 0
    e = True
    for i in range(n):
        a = int(input())
        if i == 0 and (a == 50 or a == 100):
            e = False
            break
        if a == 25:
            g += 1
        elif a == 50:
            g -= 1
            c += 1
        else:
            if c:
                g -= 1
                c -= 1

            else:
                g -= 3
        if g < 0 and c < 0:
            e = False
    if e:
        print(""YES"")
    else:
        print(""NO"")

def f():
    d()
    
f()","def b():

    n = int(input().strip())
    s = input().strip()

    g = {}

    for i in range(n - 1):
        f = s[i:i+2]
        if f in g:
            g[f] += 1
        else:
            g[f] = 1

    c = 0
    d = """"
    for e, a in g.items():
        if a > c:
            c = a
            d = e

    print(d)

if __name__ == ""__main__"":
    b()"
989,A,A Blend of Springtime,PROGRAMMING,"['implementation', 'strings']","""What a pity it's already late spring,"" sighs Mino with regret, ""one more drizzling night and they'd be gone.""

""But these blends are at their best, aren't they?"" Absorbed in the landscape, Kanno remains optimistic. 

The landscape can be expressed as a row of consecutive cells, each of which either contains a flower of colour amber or buff or canary yellow, or is empty.

When a flower withers, it disappears from the cell that it originally belonged to, and it spreads petals of its colour in its two neighbouring cells (or outside the field if the cell is on the side of the landscape). In case petals fall outside the given cells, they simply become invisible.

You are to help Kanno determine whether it's possible that after some (possibly none or all) flowers shed their petals, at least one of the cells contains all three colours, considering both petals and flowers. Note that flowers can wither in arbitrary order.","The first and only line of input contains a non-empty string $s$ consisting of uppercase English letters 'A', 'B', 'C' and characters '.' (dots) only ($\lvert s \rvert \leq 100$) — denoting cells containing an amber flower, a buff one, a canary yellow one, and no flowers, respectively.","Output ""Yes"" if it's possible that all three colours appear in some cell, and ""No"" otherwise.

You can print each letter in any case (upper or lower).","['.BAC.\n', 'AA..CB\n']","['Yes\n', 'No\n']","In the first example, the buff and canary yellow flowers can leave their petals in the central cell, blending all three colours in it.

In the second example, it's impossible to satisfy the requirement because there is no way that amber and buff meet in any cell.",OK,"s=input()
l=['ABC', 'ACB', 'BAC', 'BCA', 'CAB', 'CBA']
def f(l,s):
	for i in l:
		if i in s:
			return ""Yes""
	return ""No""
print(f(l,s))","import c

def b(x: int) -> bool:

    s = str(x)

    d = s.rstrip('0')

    return d == d[::-1]

if __name__ == '__main__':

    a = c.stdin.read().strip().split()
    if a:

        x = int(a[0])

        print(""YES"" if b(x) else ""NO"")"
0,none,none,none,['none'],"Polycarp has interviewed Oleg and has written the interview down without punctuation marks and spaces to save time. Thus, the interview is now a string *s* consisting of *n* lowercase English letters.

There is a filler word ogo in Oleg's speech. All words that can be obtained from ogo by adding go several times to the end of it are also considered to be fillers. For example, the words ogo, ogogo, ogogogo are fillers, but the words go, og, ogog, ogogog and oggo are not fillers.

The fillers have maximal size, for example, for ogogoo speech we can't consider ogo a filler and goo as a normal phrase. We should consider ogogo as a filler here.

To print the interview, Polycarp has to replace each of the fillers with three asterisks. Note that a filler word is replaced with exactly three asterisks regardless of its length.

Polycarp has dealt with this problem in no time. Can you do the same? The clock is ticking!","The first line contains a positive integer *n* (1<=≤<=*n*<=≤<=100) — the length of the interview.

The second line contains the string *s* of length *n*, consisting of lowercase English letters.","Print the interview text after the replacement of each of the fillers with ""***"". It is allowed for the substring ""***"" to have several consecutive occurences.","['7\naogogob\n', '13\nogogmgogogogo\n', '9\nogoogoogo\n']","['a***b\n', '***gmg***\n', '*********\n']","The first sample contains one filler word ogogo, so the interview for printing is ""a***b"".

The second sample contains two fillers ogo and ogogogo. Thus, the interview is transformed to ""***gmg***"".",OK,"from sys import c
import b

def a():
    n, = d()
    s = f()

    print(b.sub(r'(ogo((go)+)?)', '***', s))

def d():
    return (int(x) for x in c.readline().strip().split(' '))

def e():
    return list(int(x) for x in c.readline().strip().split(' '))

def f():
    return c.readline().strip()

if __name__ == '__main__':
    a()","import i

def c():

    b = i.stdin.read().split()
    if not b:
        return
    n = int(b[0])
    k = int(b[1])

    h = list(map(int, b[2:]))

    if n <= k:
        print(h[-1])
        return

    f = n - k

    d = 0
    for i in range(f):
        a = h[i] + h[2 * f - 1 - i]
        d = max(d, a)

    e = h[-1]

    g = max(d, e)
    print(g)

if __name__ == '__main__':
    c()"
1000,B,Light It Up,PROGRAMMING,['greedy'],"Recently, you bought a brand new smart lamp with programming features. At first, you set up a schedule to the lamp. Every day it will turn power on at moment $0$ and turn power off at moment $M$. Moreover, the lamp allows you to set a program of switching its state (states are ""lights on"" and ""lights off""). Unfortunately, some program is already installed into the lamp.

The lamp allows only good programs. Good program can be represented as a non-empty array $a$, where $0 &lt; a_1 &lt; a_2 &lt; \dots &lt; a_{|a|} &lt; M$. All $a_i$ must be integers. Of course, preinstalled program is a good program.

The lamp follows program $a$ in next manner: at moment $0$ turns power and light on. Then at moment $a_i$ the lamp flips its state to opposite (if it was lit, it turns off, and vice versa). The state of the lamp flips instantly: for example, if you turn the light off at moment $1$ and then do nothing, the total time when the lamp is lit will be $1$. Finally, at moment $M$ the lamp is turning its power off regardless of its state.

Since you are not among those people who read instructions, and you don't understand the language it's written in, you realize (after some testing) the only possible way to alter the preinstalled program. You can insert at most one element into the program $a$, so it still should be a good program after alteration. Insertion can be done between any pair of consecutive elements of $a$, or even at the begining or at the end of $a$.

Find such a way to alter the program that the total time when the lamp is lit is maximum possible. Maybe you should leave program untouched. If the lamp is lit from $x$ till moment $y$, then its lit for $y - x$ units of time. Segments of time when the lamp is lit are summed up.","First line contains two space separated integers $n$ and $M$ ($1 \le n \le 10^5$, $2 \le M \le 10^9$) — the length of program $a$ and the moment when power turns off.

Second line contains $n$ space separated integers $a_1, a_2, \dots, a_n$ ($0 &lt; a_1 &lt; a_2 &lt; \dots &lt; a_n &lt; M$) — initially installed program $a$.",Print the only integer — maximum possible total time when the lamp is lit.,"['3 10\n4 6 7\n', '2 12\n1 10\n', '2 7\n3 4\n']","['8\n', '9\n', '6\n']","In the first example, one of possible optimal solutions is to insert value $x = 3$ before $a_1$, so program will be $[3, 4, 6, 7]$ and time of lamp being lit equals $(3 - 0) + (6 - 4) + (10 - 7) = 8$. Other possible solution is to insert $x = 5$ in appropriate place.

In the second example, there is only one optimal solution: to insert $x = 2$ between $a_1$ and $a_2$. Program will become $[1, 2, 10]$, and answer will be $(1 - 0) + (10 - 2) = 9$.

In the third example, optimal answer is to leave program untouched, so answer will be $(3 - 0) + (7 - 4) = 6$.",WRONG_ANSWER,"import enum
from io import b, d
from mimetypes import suffix_map
import ~
import math
import r
import heapq
from collections import defaultdict, deque
from math import ceil
from bisect import bisect_left, bisect_right
from time import s

a = 8192

class c(d):
    p = 0

    def __init__(x, i):
        x._fd = i.fileno()
        x.buffer = b()
        x.writable = ""x"" in i.mode or ""r"" not in i.mode
        x.write = x.buffer.write if x.writable else None

    def v(x):
        while True:
            b = r.v(x._fd, max(r.fstat(x._fd).st_size, a))
            if not b:
                break
            u = x.buffer.tell()
            x.buffer.seek(0, 2), x.buffer.write(b), x.buffer.seek(u)
        x.p = 0
        return x.buffer.v()

    def w(x):
        while x.p == 0:
            b = r.v(x._fd, max(r.fstat(x._fd).st_size, a))
            x.p = b.count(b""\n"") + (not b)
            u = x.buffer.tell()
            x.buffer.seek(0, 2), x.buffer.write(b), x.buffer.seek(u)
        x.p -= 1
        return x.buffer.w()

    def j(x):
        if x.writable:
            r.write(x._fd, x.buffer.getvalue())
            x.buffer.truncate(0), x.buffer.seek(0)

class e(d):
    def __init__(x, i):
        x.buffer = c(i)
        x.j = x.buffer.j
        x.writable = x.buffer.writable
        x.write = lambda s: x.buffer.write(s.encode(""ascii""))
        x.v = lambda: x.buffer.v().decode(""ascii"")
        x.w = lambda: x.buffer.w().decode(""ascii"")

~.stdin, ~.stdout = e(~.stdin), e(~.stdout)
def input(): return ~.stdin.w().rstrip(""\r\n"")
def o(): return map(int, input().split())
def n(): return map(float, input().split())
def l(): return int(input())

def q(x):
    return x-1 if x > 0 else x + 1

def y():
    n, m = map(int, input().split())
    *a, = map(int, input().split())
     = [0]*(n+1)
    h = 1
    t = 0
    for k, i in enumerate(a):
        [k] = (i - t) * h
        h = h * -1
        t = i
    [-1] = (m - t) * h

    } = [0]*(n+1)
    | = [0]*(n+1)
    }[-1] = [-1] if [-1] > 0 else 0
    |[-1] = [-1] if [-1] < 0 else 0
    for i in range(n-1, -1, -1):
        }[i] = }[i+1] + ([i] if [i] > 0 else 0)
        |[i] = |[i+1] + ([i] if [i] < 0 else 0)

    f = }[0]
    if a[i] != 1:

        g = -}[0] - |[0]
        if [0] > 0:
            g -= 1
        f = max(f, g)
    z = }[0]

    for k, i in enumerate(a):

        if i > 1 and (k == 0 or a[k-1] < i-1):
            g = z
            g = (g - [k] + q([k]))
            g -= }[k+1] + |[k+1]
            f = max(f, g)
        g = z
        g -= [k+1] if [k+1] > 0 else 0

        if [k+1] > 0:
            g += 1
        else:
            g += -[k+1] - 1

        if k+2 <= n:
            g -= }[k+2] + |[k+2]
        f = max(f, g)

    print(f)

def m():
    t = 1

    for _ in range(t):
        y()

if __name__ == ""__main__"":
    { = s()
    m()
    print(s()-{, i=~.stderr)","def d():
    import g
    b = g.stdin.read().strip().split()
    if not b:
        return
    n = int(b[0])
    a = list(map(int, b[1:1+n]))

    c = [-1] * n
    e = [n] * n

    f = []
    for i in range(n):
        while f and a[f[-1]] >= a[i]:
            f.pop()
        c[i] = f[-1] if f else -1
        f.append(i)

    f = []
    for i in range(n-1, -1, -1):
        while f and a[f[-1]] >= a[i]:
            f.pop()
        e[i] = f[-1] if f else n
        f.append(i)

    a = [0] * (n + 1)

    for i in range(n):
        h = e[i] - c[i] - 1
        a[h] = max(a[h], a[i])

    for i in range(n - 1, 0, -1):
        a[i] = max(a[i], a[i + 1])

    g.stdout.write("" "".join(map(str, a[1:])) + "" "")
    
if __name__ == '__main__':
    d()"
46,A,Ball Game,PROGRAMMING,"['brute force', 'implementation']","A kindergarten teacher Natalia Pavlovna has invented a new ball game. This game not only develops the children's physique, but also teaches them how to count. 

The game goes as follows. Kids stand in circle. Let's agree to think of the children as numbered with numbers from 1 to *n* clockwise and the child number 1 is holding the ball. First the first child throws the ball to the next one clockwise, i.e. to the child number 2. Then the child number 2 throws the ball to the next but one child, i.e. to the child number 4, then the fourth child throws the ball to the child that stands two children away from him, i.e. to the child number 7, then the ball is thrown to the child who stands 3 children away from the child number 7, then the ball is thrown to the child who stands 4 children away from the last one, and so on. It should be mentioned that when a ball is thrown it may pass the beginning of the circle. For example, if *n*<==<=5, then after the third throw the child number 2 has the ball again. Overall, *n*<=-<=1 throws are made, and the game ends.

The problem is that not all the children get the ball during the game. If a child doesn't get the ball, he gets very upset and cries until Natalia Pavlovna gives him a candy. That's why Natalia Pavlovna asks you to help her to identify the numbers of the children who will get the ball after each throw.",The first line contains integer *n* (2<=≤<=*n*<=≤<=100) which indicates the number of kids in the circle.,In the single line print *n*<=-<=1 numbers which are the numbers of children who will get the ball after each throw. Separate the numbers by spaces.,"['10\n', '3\n']","['2 4 7 1 6 2 9 7 6\n', '2 1\n']",none,WRONG_ANSWER,"def a():
    n=int(input())
    i=1
    j=1
    L=[]
    for _ in range(1,n):
        L.append((i+j)%n)
        i+=(j%n)
        j+=1%n
    for k in L:
        print(k,end="" "")

a()","import d

def b():

    a = d.stdin.read().strip().split()
    if not a:
        return
    try:
        n = int(a[0])
    except ValueError:
        return

    c = n - 10
    f = 0

    if c == 1 or c == 11:

        f += 4

    for e in range(2, 11):
        if e == c:
            f += 4

    if c == 10:

        f += 4 + 4 + 3

    print(f)

if __name__ == ""__main__"":
    b()"
817,C,Really Big Numbers,PROGRAMMING,"['binary search', 'brute force', 'dp', 'math']","Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number *x* is really big if the difference between *x* and the sum of its digits (in decimal representation) is not less than *s*. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than *n*.

Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.","The first (and the only) line contains two integers *n* and *s* (1<=≤<=*n*,<=*s*<=≤<=1018).",Print one integer — the quantity of really big numbers that are not greater than *n*.,"['12 1\n', '25 20\n', '10 9\n']","['3\n', '0\n', '1\n']","In the first example numbers 10, 11 and 12 are really big.

In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).

In the third example 10 is the only really big number (10 - 1 ≥ 9).",WRONG_ANSWER,"def a(p) :
    
    s=''
    for i in range(p) :
        s+='9'
    return int(s)
n,k=map(int,input().split())
l=[0]*19
for i in range(18) :
    e=a(18-i)
    l[i]=int(k/e)
    
    k-=l[i]*e
    if k==0 :
        break
    if i==17  or k%e>a(18-i-1)*9 :
        
        l[i]+=1
        break
b=0
for i in range(18) :
    
    b+=10**(18-i)*l[i]
print(max(n-b+1,0))","def d():
    import f

    c = f.stdin.read().split()

    s = c[0]

    k = int(c[1])

    h = list(map(int, c[2:28]))

    g = 0
    for i, b in enumerate(s):

        g += (i + 1) * h[ord(b) - ord('a')]

    e = max(h)

    n = len(s)

    a = e * ((n + 1 + n + k) * k // 2)
    
    g += a

    print(g)

if __name__ == '__main__':
    d()"
2,A,Winner,PROGRAMMING,"['hashing', 'implementation']","The winner of the card game popular in Berland ""Berlogging"" is determined according to the following rules. If at the end of the game there is only one player with the maximum number of points, he is the winner. The situation becomes more difficult if the number of such players is more than one. During each round a player gains or loses a particular number of points. In the course of the game the number of points is registered in the line ""name score"", where name is a player's name, and score is the number of points gained in this round, which is an integer number. If score is negative, this means that the player has lost in the round. So, if two or more players have the maximum number of points (say, it equals to *m*) at the end of the game, than wins the one of them who scored at least *m* points first. Initially each player has 0 points. It's guaranteed that at the end of the game at least one player has a positive number of points.","The first line contains an integer number *n* (1<=<=≤<=<=*n*<=<=≤<=<=1000), *n* is the number of rounds played. Then follow *n* lines, containing the information about the rounds in ""name score"" format in chronological order, where name is a string of lower-case Latin letters with the length from 1 to 32, and score is an integer number between -1000 and 1000, inclusive.",Print the name of the winner.,"['3\nmike 3\nandrew 5\nmike 2\n', '3\nandrew 3\nandrew 2\nmike 5\n']","['andrew\n', 'andrew\n']",none,WRONG_ANSWER,"d = int(input())

def a(d: dict) -> int:
    return max(list(d.values()))

d = {}
l = []
for i in range(d):
    c, e = input().split()
    e = int(e)
    l.append((c, e))
    d[c] = d.get(c, 0) + e

b = a(d)
d.clear()
for t in l:
    c, e = t
    d[c] = d.get(c, 0) + e
    if d[c] == b:
        print(c)
        break","def b():
    import e
    a = e.stdin.read().split()
    if not a:
        return
    a = int(a[0])
    b = int(a[1])

    if b - a >= 10:
        print(0)
        return
    
    d = 1

    for c in range(a + 1, b + 1):
        d = (d * (c % 10)) % 10
    print(d)

if __name__ == '__main__':
    b()"
32,B,Borze,PROGRAMMING,"['expression parsing', 'implementation']","Ternary numeric notation is quite popular in Berland. To telegraph the ternary number the Borze alphabet is used. Digit 0 is transmitted as «.», 1 as «-.» and 2 as «--». You are to decode the Borze code, i.e. to find out the ternary number given its representation in Borze alphabet.",The first line contains a number in Borze code. The length of the string is between 1 and 200 characters. It's guaranteed that the given string is a valid Borze code of some ternary number (this number can have leading zeroes).,Output the decoded ternary number. It can have leading zeroes.,"['.-.--\n', '--.\n', '-..-.--\n']","['012', '20', '1012']",none,OK,"s=input()
a=[]
def b(s):
    if len(s)==0:
        return ''
    if s[0]=='.':
        return '0'+ b(s[1:])
    if s[0]=='-' and s[1]=='.':
        return '1'+ b(s[2:])
    if s[0]=='-' and s[1]=='-':
        return '2'+ b(s[2:])
print(b(s))","import j

def d():

    a = j.stdin.read().splitlines()
    if not a:
        return

    h = []
    for c in a:
        if not c.strip():
            continue
        f = c.strip().split()
        if len(f) < 2:
            continue
        n = int(f[0])
        k = int(f[1])

        if k > n*n:
            h.append(""-1"")
            continue

        A = [[0] * n for _ in range(n)]
        g = k

        b = False
        for i in range(n):

            if g > 0:
                A[i][i] = 1
                g -= 1

            for j in range(i+1, n):
                if g >= 2:
                    A[i][j] = 1
                    A[j][i] = 1
                    g -= 2

            if g == 0:
                b = True
                break

        if not b and g > 0:
            for i in range(i+1, n):
                if g > 0:
                    A[i][i] = 1
                    g -= 1
                for j in range(i+1, n):
                    if g >= 2:
                        A[i][j] = 1
                        A[j][i] = 1
                        g -= 2
                if g == 0:
                    break

        if g != 0:
            h.append(""-1"")
        else:

            e = []
            for i in A:

                e.append("" "".join(map(str, i)) + "" "")
            h.append(""\n"".join(e))
    
    j.stdout.write(""\n"".join(h))

if __name__ == '__main__':
    d()"
96,A,Football,PROGRAMMING,"['implementation', 'strings']","Petya loves football very much. One day, as he was watching a football match, he was writing the players' current positions on a piece of paper. To simplify the situation he depicted it as a string consisting of zeroes and ones. A zero corresponds to players of one team; a one corresponds to players of another team. If there are at least 7 players of some team standing one after another, then the situation is considered dangerous. For example, the situation 00100110111111101 is dangerous and 11110111011101 is not. You are given the current situation. Determine whether it is dangerous or not.","The first input line contains a non-empty string consisting of characters ""0"" and ""1"", which represents players. The length of the string does not exceed 100 characters. There's at least one player from each team present on the field.","Print ""YES"" if the situation is dangerous. Otherwise, print ""NO"".","['001001\n', '1000000001\n']","['NO\n', 'YES\n']",none,OK,"def a(d):
    e=0
    c=0
    for i in range(0, len(d)):
        if d[i]=='1':
            e=0
            c+=1
            if c>=7:
                return True
        else:
            c=0
            e+=1
            if e>=7:
                return True
    return False

def b():
    d = input()
    if a(d):
        print(""YES"")
    else:
        print(""NO"")

if __name__ == ""__main__"":
    b()","import l

def g():

    e = l.stdin.read().strip().split()
    if not e:
        return

    j = e[0]
    f = e[1]

    n = int(e[2])

    i = ['^', '>', 'v', '<']

    k = i.index(j)

    h = n % 4

    c = (k + h) % 4
    a = (k - h) % 4

    d = (i[c] == f)
    b = (i[a] == f)

    if d and not b:
        print(""cw"")
    elif b and not d:
        print(""ccw"")
    elif d and b:
        print(""undefined"")

if __name__ == '__main__':
    g()"
604,B,More Cowbell,PROGRAMMING,"['binary search', 'greedy']","Kevin Sun wants to move his precious collection of *n* cowbells from Naperthrill to Exeter, where there is actually grass instead of corn. Before moving, he must pack his cowbells into *k* boxes of a fixed size. In order to keep his collection safe during transportation, he won't place more than two cowbells into a single box. Since Kevin wishes to minimize expenses, he is curious about the smallest size box he can use to pack his entire collection. 

Kevin is a meticulous cowbell collector and knows that the size of his *i*-th (1<=≤<=*i*<=≤<=*n*) cowbell is an integer *s**i*. In fact, he keeps his cowbells sorted by size, so *s**i*<=-<=1<=≤<=*s**i* for any *i*<=&gt;<=1. Also an expert packer, Kevin can fit one or two cowbells into a box of size *s* if and only if the sum of their sizes does not exceed *s*. Given this information, help Kevin determine the smallest *s* for which it is possible to put all of his cowbells into *k* boxes of size *s*.","The first line of the input contains two space-separated integers *n* and *k* (1<=≤<=*n*<=≤<=2·*k*<=≤<=100<=000), denoting the number of cowbells and the number of boxes, respectively.

The next line contains *n* space-separated integers *s*1,<=*s*2,<=...,<=*s**n* (1<=≤<=*s*1<=≤<=*s*2<=≤<=...<=≤<=*s**n*<=≤<=1<=000<=000), the sizes of Kevin's cowbells. It is guaranteed that the sizes *s**i* are given in non-decreasing order.","Print a single integer, the smallest *s* for which it is possible for Kevin to put all of his cowbells into *k* boxes of size *s*.","['2 1\n2 5\n', '4 3\n2 3 5 9\n', '3 2\n3 5 7\n']","['7\n', '9\n', '8\n']","In the first sample, Kevin must pack his two cowbells into the same box. 

In the second sample, Kevin can pack together the following sets of cowbells: {2, 3}, {5} and {9}.

In the third sample, the optimal solution is {3, 5} and {7}.",OK,"import c
import time
from collections import defaultdict,deque
from sys import d,stdout
from bisect import bisect_left,bisect_right
n,k=map(int,d.readline().split())
a=list(map(int,d.readline().split()))
b=n-k
a=0
for i in range(b):
    a=max(a,a[i]+a[2*b-1-i])
e=-c.inf
if(k+k!=n):
    e=max(a[2*b:])
a=max(a,e)
print(a)","def b(j):
    """"""
    Compute the maximum number of consecutive 1's in the given row.
    """"""
    h = 0
    c = 0
    for a in j:
        if a == 1:
            c += 1
        else:
            if c > h:
                h = c
            c = 0

    if c > h:
        h = c
    return h

def g():
    import m

    d = m.stdin.read().split()
    f = 0

    n = int(d[f])
    f += 1
    m = int(d[f])
    f += 1
    q = int(d[f])
    f += 1

    e = []
    k = []
    for _ in range(n):
        j = [int(d[f + j]) for j in range(m)]
        f += m
        e.append(j)
        k.append(b(j))

    i = []
    for _ in range(q):

        i = int(d[f])
        f += 1
        j = int(d[f])
        f += 1

        r = i - 1
        c = j - 1

        e[r][c] = 1 - e[r][c]

        k[r] = b(e[r])

        l = max(k)
        i.append(str(l))

    m.stdout.write(""\n"".join(i))

if __name__ == '__main__':
    g()"
6,B,President's Office,PROGRAMMING,['implementation'],"President of Berland has a very vast office-room, where, apart from him, work his subordinates. Each subordinate, as well as President himself, has his own desk of a unique colour. Each desk is rectangular, and its sides are parallel to the office walls. One day President decided to establish an assembly, of which all his deputies will be members. Unfortunately, he does not remember the exact amount of his deputies, but he remembers that the desk of each his deputy is adjacent to his own desk, that is to say, the two desks (President's and each deputy's) have a common side of a positive length.

The office-room plan can be viewed as a matrix with *n* rows and *m* columns. Each cell of this matrix is either empty, or contains a part of a desk. An uppercase Latin letter stands for each desk colour. The «period» character («.») stands for an empty cell.","The first line contains two separated by a space integer numbers *n*, *m* (1<=≤<=*n*,<=*m*<=≤<=100) — the length and the width of the office-room, and *c* character — the President's desk colour. The following *n* lines contain *m* characters each — the office-room description. It is guaranteed that the colour of each desk is unique, and each desk represents a continuous subrectangle of the given matrix. All colours are marked by uppercase Latin letters.",Print the only number — the amount of President's deputies.,"['3 4 R\nG.B.\n.RR.\nTTT.\n', '3 3 Z\n...\n.H.\n..Z\n']","['2\n', '0\n']",none,OK,"def a(x, y):
    if x < 0 or x >= n or y < 0 or y >= m or c[x][y] == c or c[x][y] == '.':
        return False
    return True
n, m, c = input().split()
n, m = int(n), int(m)

c = []
for k in range(n):
    c.append(input())

x = [-1, 0, 0, 1]
y = [0, 1, -1, 0]

b = set([])

for i in range(n):
    for j in range(m):
        if c[i][j] == c:
            for k in range(4):
                if a(i + x[k], j + y[k]):
                    b.add(c[i + x[k]][ j + y[k]])
print(len(b))","def a(d):

    if len(d) > 10:

        c = len(d) - 2
        return d[0] + str(c) + d[-1]
    else:
        return d

def b():

    n = int(input())

    for _ in range(n):
        d = input().strip()
        print(a(d))

if __name__ == ""__main__"":
    b()"
991,E,Bus Number,PROGRAMMING,"['brute force', 'combinatorics', 'math']","This night wasn't easy on Vasya. His favorite team lost, and he didn't find himself victorious either — although he played perfectly, his teammates let him down every time. He had to win at least one more time, but the losestreak only grew longer and longer... It's no wonder he didn't get any sleep this night at all.

In the morning, Vasya was waiting the bus to the university on the bus stop. Vasya's thoughts were hazy and so he couldn't remember the right bus' number quite right and got onto the bus with the number $n$.

In the bus, Vasya thought that he could get the order of the digits in the number of the bus wrong. Futhermore, he could ""see"" some digits several times, but the digits he saw were definitely in the real number of the bus. For example, if Vasya saw the number 2028, it could mean that the real bus number could be 2028, 8022, 2820 or just 820. However, numbers 80, 22208, 52 definitely couldn't be the number of the bus. Also, real bus number couldn't start with the digit 0, this meaning that, for example, number 082 couldn't be the real bus number too.

Given $n$, determine the total number of possible bus number variants.",The first line contains one integer $n$ ($1 \leq n \leq 10^{18}$) — the number of the bus that was seen by Vasya. It is guaranteed that this number does not start with $0$.,Output a single integer — the amount of possible variants of the real bus number.,"['97\n', '2028\n']","['2\n', '13\n']","In the first sample, only variants $97$ and $79$ are possible.

In the second sample, the variants (in the increasing order) are the following: $208$, $280$, $802$, $820$, $2028$, $2082$, $2208$, $2280$, $2802$, $2820$, $8022$, $8202$, $8220$.",OK,"e = [0 for _ in range(35)]
e[0] = 1
for q in range(1,35):
    e[q] = e[q-1]*q
a = []
b = 0
def f():
    j = 0
    for i in a:
        j = j + i
    h = e[j]
    for i in a:
        h = h / e[i]
    return h

t = int(input())
d = []
for i in range(10):
    d.append(0)
i = t
while i > 0:
    d[int(i%10)] = d[int(i%10)]+1
    i = i // 10
def c(g):
    global b
    if g == 10:
        b = b + f()
        if a[0] > 0:
            a[0] = a[0]-1
            b = b - f()
            a[0] = a[0]+1
        return
    if d[g] == 0:
        a.append(0)
        c(g+1)
        a.pop()
    else:
        for q in range(1, d[g]+1):
            a.append(q)
            c(g+1)
            a.pop()

c(0)
print(int(b))","n = int(input().strip())

a = 0
b = 0

for _ in range(n):

    a, b = map(int, input().split())

    a -= a

    a += b

    b = max(b, a)

print(b)"
938,C,Constructing Tests,PROGRAMMING,"['binary search', 'brute force', 'constructive algorithms']","Let's denote a *m*-free matrix as a binary (that is, consisting of only 1's and 0's) matrix such that every square submatrix of size *m*<=×<=*m* of this matrix contains at least one zero. 

Consider the following problem:

You are given two integers *n* and *m*. You have to construct an *m*-free square matrix of size *n*<=×<=*n* such that the number of 1's in this matrix is maximum possible. Print the maximum possible number of 1's in such matrix.

You don't have to solve this problem. Instead, you have to construct a few tests for it.

You will be given *t* numbers *x*1, *x*2, ..., *x**t*. For every , find two integers *n**i* and *m**i* (*n**i*<=≥<=*m**i*) such that the answer for the aforementioned problem is exactly *x**i* if we set *n*<==<=*n**i* and *m*<==<=*m**i*.","The first line contains one integer *t* (1<=≤<=*t*<=≤<=100) — the number of tests you have to construct.

Then *t* lines follow, *i*-th line containing one integer *x**i* (0<=≤<=*x**i*<=≤<=109).

Note that in hacks you have to set *t*<==<=1.","For each test you have to construct, output two positive numbers *n**i* and *m**i* (1<=≤<=*m**i*<=≤<=*n**i*<=≤<=109) such that the maximum number of 1's in a *m**i*-free *n**i*<=×<=*n**i* matrix is exactly *x**i*. If there are multiple solutions, you may output any of them; and if this is impossible to construct a test, output a single integer <=-<=1.",['3\n21\n0\n1\n'],['5 2\n1 1\n-1\n'],none,WRONG_ANSWER,"def b(n):
    a = []
    for i in range(1, int(n**0.5)+1):
        if n % i == 0:
            a.append(i)
            if i != n // i:
                a.append(n//i)

    return a

t = int(input())
for i in range(t):
    x = int(input())
    if x == 0:
        print(1, 1)
        continue
    d = b(x)
    for a in d:
        b = x//a
        if b >= a:
            continue
        if a%2 == b%2:
            n = (a+b)//2
            m = (a-b)//2
            print(n, m)
            break
    else:
        print(-1)","def c():
    import g
    a = g.stdin.read().splitlines()
    if not a:
        return
    n = int(a[0].strip())
    S = a[1].strip()
    T = a[2].strip()

    d = []
    for i in range(n):
        if S[i] != T[i]:
            d.append(i)

    d = len(d)

    if d == 0:
        g.stdout.write(""0\n-1 -1"")
        return

    f = {}
    for i in d:
        f[(S[i], T[i])] = i

    for i in d:
        a = S[i]
        b = T[i]
        if (b, a) in f:
            j = f[(b, a)]
            if i != j:

                e = d - 2
                g.stdout.write(f""{e}\n{i+1} {j+1}"")
                return

    b = {}
    for j in d:
        if S[j] not in b:
            b[S[j]] = j

    for i in d:
        if T[i] in b:
            j = b[T[i]]
            if i != j:

                e = d - 1
                g.stdout.write(f""{e}\n{i+1} {j+1}"")
                return

    g.stdout.write(f""{d}\n-1 -1"")

if __name__ == '__main__':
    c()"
793,B,Igor and his way to work,PROGRAMMING,"['dfs and similar', 'graphs', 'implementation', 'shortest paths']","Woken up by the alarm clock Igor the financial analyst hurried up to the work. He ate his breakfast and sat in his car. Sadly, when he opened his GPS navigator, he found that some of the roads in Bankopolis, the city where he lives, are closed due to road works. Moreover, Igor has some problems with the steering wheel, so he can make no more than two turns on his way to his office in bank.

Bankopolis looks like a grid of *n* rows and *m* columns. Igor should find a way from his home to the bank that has no more than two turns and doesn't contain cells with road works, or determine that it is impossible and he should work from home. A turn is a change in movement direction. Igor's car can only move to the left, to the right, upwards and downwards. Initially Igor can choose any direction. Igor is still sleepy, so you should help him.","The first line contains two integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=1000) — the number of rows and the number of columns in the grid.

Each of the next *n* lines contains *m* characters denoting the corresponding row of the grid. The following characters can occur: 
 -  ""."" — an empty cell; -  ""*"" — a cell with road works; -  ""S"" — the cell where Igor's home is located; -  ""T"" — the cell where Igor's office is located. 
It is guaranteed that ""S"" and ""T"" appear exactly once each.","In the only line print ""YES"" if there is a path between Igor's home and Igor's office with no more than two turns, and ""NO"" otherwise.","['5 5\n..S..\n****.\nT....\n****.\n.....\n', '5 5\nS....\n****.\n.....\n.****\n..T..\n']","['YES', 'NO']","The first sample is shown on the following picture:

In the second sample it is impossible to reach Igor's office using less that 4 turns, thus there exists no path using no more than 2 turns. The path using exactly 4 turns is shown on this picture:",RUNTIME_ERROR,"def b(a , r , c , t ,dir ,a ,c):
    if r==t[0] and c==t[1]:
        return True
    if r==-1 or r>n-1 or c>m-1 or c==-1:
        return False
    if dir not in a and a is not ""0"":
        c+=1
        if c>2:
            return False
    if a[r][c] is ""*"":
        return False
    if b(a,r+1,c,t,""U"",dir,c) or b(a,r-1,c,t,""D"",dir,c) or b(a,r,c-1,t,""L"",dir,c) or b(a,r,c+1,t,""R"",dir,c):
        return True
    return False

n,m=tuple(input().split("" ""))
n=int(n)
m=int(m)
a=[]
s=(-1,-1)
t=(-1,-1)
for x in range(n):
    a.append(list(input()))
    if ""S"" in a[x]:
        s=(x,a[x].index(""S""))
    if ""T"" in a[x]:
        t = (x, a[x].index(""T""))
if b(a,s[0],s[1],t,""0"",""0"",0):
    print(""YES"")
    exit(0)
else:
    print(""NO"")
    exit(0)","import l

def k(c):

    c = c.strip()
    try:
        i = c.index('+')
        b = c.index('=')
    except ValueError:
        return ""Impossible""

    A = c[:i]
    B = c[i+1:b]
    C = c[b+1:]

    a = len(A)
    b = len(B)
    c = len(C)
    
    def g(a, b, c):
        return ('|' * a) + '+' + ('|' * b) + '=' + ('|' * c)

    if a + b == c:
        return g(a, b, c)

    d = [a, b, c]

    for i in range(3):

        if d[i] <= 1:
            continue
        for j in range(3):
            if i == j:
                continue
            h = d.copy()
            h[i] -= 1
            h[j] += 1

            if h[0] < 1 or h[1] < 1 or h[2] < 1:
                continue

            if h[0] + h[1] == h[2]:
                return g(h[0], h[1], h[2])
    
    return ""Impossible""

def f():
    a = l.stdin.read().splitlines()
    if not a:
        return
    j = []
    for e in a:
        if e.strip() == """":
            continue
        j.append(k(e))
    l.stdout.write(""\n"".join(j) + ""\n"")

if __name__ == '__main__':
    f()"
180,F,Mathematical Analysis Rocks!,PROGRAMMING,"['constructive algorithms', 'implementation', 'math']","Students of group 199 have written their lectures dismally. Now an exam on Mathematical Analysis is approaching and something has to be done asap (that is, quickly). Let's number the students of the group from 1 to *n*. Each student *i* (1<=≤<=*i*<=≤<=*n*) has a best friend *p*[*i*] (1<=≤<=*p*[*i*]<=≤<=*n*). In fact, each student is a best friend of exactly one student. In other words, all *p*[*i*] are different. It is possible that the group also has some really ""special individuals"" for who *i*<==<=*p*[*i*].

Each student wrote exactly one notebook of lecture notes. We know that the students agreed to act by the following algorithm: 
 -  on the first day of revising each student studies his own Mathematical Analysis notes, -  in the morning of each following day each student gives the notebook to his best friend and takes a notebook from the student who calls him the best friend. 
Thus, on the second day the student *p*[*i*] (1<=≤<=*i*<=≤<=*n*) studies the *i*-th student's notes, on the third day the notes go to student *p*[*p*[*i*]] and so on. Due to some characteristics of the boys' friendship (see paragraph 1), each day each student has exactly one notebook to study.

You are given two sequences that describe the situation on the third and fourth days of revising:
 -  *a*1,<=*a*2,<=...,<=*a**n*, where *a**i* means the student who gets the *i*-th student's notebook on the third day of revising; -  *b*1,<=*b*2,<=...,<=*b**n*, where *b**i* means the student who gets the *i*-th student's notebook on the fourth day of revising. 
You do not know array *p*, that is you do not know who is the best friend to who. Write a program that finds *p* by the given sequences *a* and *b*.","The first line contains integer *n* (1<=≤<=*n*<=≤<=105) — the number of students in the group. The second line contains sequence of different integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=*n*). The third line contains the sequence of different integers *b*1,<=*b*2,<=...,<=*b**n* (1<=≤<=*b**i*<=≤<=*n*).","Print sequence *n* of different integers *p*[1],<=*p*[2],<=...,<=*p*[*n*] (1<=≤<=*p*[*i*]<=≤<=*n*). It is guaranteed that the solution exists and that it is unique.","['4\n2 1 4 3\n3 4 2 1\n', '5\n5 2 3 1 4\n1 3 2 4 5\n', '2\n1 2\n2 1\n']","['4 3 1 2 ', '4 3 2 5 1 ', '2 1 ']",none,OK,"import string

def d():
    n = int(input())
    a = [int(i) for i in input().split("" "")]
    b = [int(i) for i in input().split("" "")]
    b = [0 for i in range(n + 1)]
    c = [0 for i in range(n + 1)]
    for i in range(len(a)):
        b[a[i]] = i + 1
        c[b[i]] = i + 1
    a = []
    for i in b:
        a.append(b[i])
    print("" "".join([str(u) for u in a]))

if __name__ == '__main__':
    d()","def a(n, c):
    b = 0

    for i in range(1, n):
        if c[i] == c[i - 1]:
            b += 1
    return b

if __name__ == ""__main__"":

    n = int(input().strip())

    c = input().strip()

    print(a(n, c))"
597,C,Subsequences,PROGRAMMING,"['data structures', 'dp']",For the given sequence with *n* different elements find the number of increasing subsequences with *k*<=+<=1 elements. It is guaranteed that the answer is not greater than 8·1018.,"First line contain two integer values *n* and *k* (1<=≤<=*n*<=≤<=105,<=0<=≤<=*k*<=≤<=10) — the length of sequence and the number of elements in increasing subsequences.

Next *n* lines contains one integer *a**i* (1<=≤<=*a**i*<=≤<=*n*) each — elements of sequence. All values *a**i* are different.",Print one integer — the answer to the problem.,['5 2\n1\n2\n3\n5\n4\n'],['7\n'],none,WRONG_ANSWER,"import i

def input():
    return i.stdin.readline().rstrip(""\r\n"")

def f(a, i):

    s = 0

    i = i + 1

    while i > 0:

        s += a[i]

        i -= i & (-i)
    return s

def k(a, n, i, v):

    i += 1

    while i <= n:

        a[i] += v

        i += i & (-i)

def d(b, n, e=True):

    a = [0] * (n + 1)

    if not e:
        for i in range(n):
            k(a, n, i, b[i])

    return a

h, g = input().split()
h, g = int(h), int(g)
j = [d([0] * h, h) for _ in range(g+1)]

for i in range(1, h+1):
    c = int(input())
    for k in range(g+1):

        if k == 0:
            l = 1
        else:
            l = f(j[k-1], i=c - 1) + 1
        k(j[k], n=h, i=c, v=l)

print(j[g][-1])","""""""
This script represents a given Fibonacci number n (guaranteed to be a Fibonacci number)
as the sum of three Fibonacci numbers. Since 0 is a Fibonacci number, a simple solution
is to use 0, 0, and n so that n = 0 + 0 + n.
""""""

def b():
    import c

    a = c.stdin.read().split()
    if not a:
        return

    n = int(a[0])

    print(""0 0"", n)

if __name__ == '__main__':
    b()"
875,A,Classroom Watch,PROGRAMMING,"['brute force', 'math']","Eighth-grader Vova is on duty today in the class. After classes, he went into the office to wash the board, and found on it the number *n*. He asked what is this number and the teacher of mathematics Inna Petrovna answered Vova that *n* is the answer to the arithmetic task for first-graders. In the textbook, a certain positive integer *x* was given. The task was to add *x* to the sum of the digits of the number *x* written in decimal numeral system.

Since the number *n* on the board was small, Vova quickly guessed which *x* could be in the textbook. Now he wants to get a program which will search for arbitrary values of the number *n* for all suitable values of *x* or determine that such *x* does not exist. Write such a program for Vova.",The first line contains integer *n* (1<=≤<=*n*<=≤<=109).,"In the first line print one integer *k* — number of different values of *x* satisfying the condition. 

In next *k* lines print these values in ascending order.","['21\n', '20\n']","['1\n15\n', '0\n']","In the first test case *x* = 15 there is only one variant: 15 + 1 + 5 = 21.

In the second test case there are no such *x*.",WRONG_ANSWER,"def a(n):
    sum = 0
    while(n > 0):
        sum += int(n % 10)
        n = int(n/10)
    return sum
    

t=int(input())
c=0
l=[]
for i in range(10,t):
    s=t
    s=s-a(i)
    if s==i:
        l.append(i)
        c+=1
if c==0:
    print(c)
else:
    print(c)
    for i in l:
        print(i,end=""\n"")","import m
import h

def d(n, f):

    e = [float('inf')] * (n + 1)
    k = [-1] * (n + 1)
    e[1] = 0

    g = [(0, 1)]
    
    while g:
        b, u = h.heappop(g)
        if b > e[u]:
            continue

        for n, v in f[u]:
            if e[u] + n < e[v]:
                e[v] = e[u] + n
                k[v] = u
                h.heappush(g, (e[v], v))
    
    return e, k

def l(k, n):

    j = []
    a = n
    while a != -1:
        j.append(a)
        a = k[a]
    j.reverse()

    if j[0] != 1:
        return []
    return j

def i():

    c = m.stdin.read().splitlines()
    if not c:
        return

    n, m = map(int, c[0].split())

    f = [[] for _ in range(n + 1)]
    
    for i in range(1, m + 1):
        a, b, w = map(int, c[i].split())

        f[a].append((w, b))
        f[b].append((w, a))

    e, k = d(n, f)

    j = l(k, n)
    if not j:
        print(-1)
    else:

        print("" "".join(map(str, j)) + "" "")

if __name__ == '__main__':
    i()"
224,A,Parallelepiped,PROGRAMMING,"['brute force', 'geometry', 'math']",You've got a rectangular parallelepiped with integer edge lengths. You know the areas of its three faces that have a common vertex. Your task is to find the sum of lengths of all 12 edges of this parallelepiped.,The first and the single line contains three space-separated integers — the areas of the parallelepiped's faces. The area's values are positive (<=&gt;<=0) and do not exceed 104. It is guaranteed that there exists at least one parallelepiped that satisfies the problem statement.,Print a single number — the sum of all edges of the parallelepiped.,"['1 1 1\n', '4 6 6\n']","['12\n', '28\n']","In the first sample the parallelepiped has sizes 1 × 1 × 1, in the second one — 2 × 2 × 3.",WRONG_ANSWER,"from math import i,gcd,ceil,floor,log,factorial
from itertools import permutations,combinations
from collections import Counter, defaultdict
import collections,sys,threading
import collections,sys,threading
from bisect import *
from heapq import *

def d(): return int(input())
def h(): return input()
def f(): return map(int,input().split())
def g(): return map(str,input().split())
def e(): return list(f())

a,b,c=f()

h = i((b*c)/a)
l = b/h
b = a/l

print(4*(l+b+h))","def d():
    import g
    c = g.stdin.read().split()
    if not c:
        return

    s = list(c[0])
    n = len(s)

    e = n // 2

    m = int(c[1])

    b = [0] * (e + 1)

    for i in range(m):
        a = int(c[2 + i])
        f = a - 1

        if f < e:
            b[f] += 1
            b[e] -= 1

    a = 0

    for i in range(e):
        a += b[i]
        if a % 2 == 1:
            s[i], s[n - i - 1] = s[n - i - 1], s[i]

    g.stdout.write("""".join(s))

if __name__ == '__main__':
    d()"
50,A,Domino piling,PROGRAMMING,"['greedy', 'math']","You are given a rectangular board of *M*<=×<=*N* squares. Also you are given an unlimited number of standard domino pieces of 2<=×<=1 squares. You are allowed to rotate the pieces. You are asked to place as many dominoes as possible on the board so as to meet the following conditions:

1. Each domino completely covers two squares.

2. No two dominoes overlap.

3. Each domino lies entirely inside the board. It is allowed to touch the edges of the board.

Find the maximum number of dominoes, which can be placed under these restrictions.",In a single line you are given two integers *M* and *N* — board sizes in squares (1<=≤<=*M*<=≤<=*N*<=≤<=16).,"Output one number — the maximal number of dominoes, which can be placed.","['2 4\n', '3 3\n']","['4\n', '4\n']",none,OK,"import b
import bisect

input = b.stdin.readline

def c():
    print(""YES"")

def a():
    print(""NO"")

m, n = map(int, input().split())
s = m * n
print(s // 2)","n = input().strip()

b = 0

while len(n) > 1:

    n = str(sum(int(a) for a in n))

    b += 1

print(b)"
919,B,Perfect Number,PROGRAMMING,"['binary search', 'brute force', 'dp', 'implementation', 'number theory']","We consider a positive integer perfect, if and only if the sum of its digits is exactly $10$. Given a positive integer $k$, your task is to find the $k$-th smallest perfect positive integer.","A single line with a positive integer $k$ ($1 \leq k \leq 10\,000$).","A single number, denoting the $k$-th smallest perfect integer.","['1\n', '2\n']","['19\n', '28\n']",The first perfect integer is $19$ and the second one is $28$.,OK,"import c
def input(): return c.stdin.readline().strip()
def b(): return map(int,c.stdin.readline().strip().split())

n = int(input())
a = 19
i = 1

while i < n:
    a += 9
    if sum(map(int,str(a))) == 10: i+= 1
print(a)","import n

def j():

    b = n.stdin.read().splitlines()

    for g in b:
        if not g.strip():
            continue
        c = g.strip()

        o = c.split(',')

        d = [0]

        f = {}
        k = [0]

        def m(e):

            if e > k[0]:
                k[0] = e

            if e not in f:
                f[e] = []

            a = o[d[0]]
            f[e].append(a)
            d[0] += 1

            l = int(o[d[0]])
            d[0] += 1

            for _ in range(l):
                m(e + 1)

        while d[0] < len(o):
            m(1)

        n.stdout.write(str(k[0]) + ""\n"")

        for i in range(1, k[0] + 1):

            h = ' '.join(f.get(i, [])) + "" ""
            n.stdout.write(h + ""\n"")

if __name__ == '__main__':
    j()"
476,C,Dreamoon and Sums,PROGRAMMING,['math'],"Dreamoon loves summing up something for no reason. One day he obtains two integers *a* and *b* occasionally. He wants to calculate the sum of all nice integers. Positive integer *x* is called nice if  and , where *k* is some integer number in range [1,<=*a*].

By  we denote the quotient of integer division of *x* and *y*. By  we denote the remainder of integer division of *x* and *y*. You can read more about these operations here: http://goo.gl/AcsXhT.

The answer may be large, so please print its remainder modulo 1<=000<=000<=007 (109<=+<=7). Can you compute it faster than Dreamoon?","The single line of the input contains two integers *a*, *b* (1<=≤<=*a*,<=*b*<=≤<=107).",Print a single integer representing the answer modulo 1<=000<=000<=007 (109<=+<=7).,"['1 1\n', '2 2\n']","['0\n', '8\n']","For the first sample, there are no nice integers because <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/03b1dc6bae5180f8a2d8eb85789e8b393e585970.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> is always zero.

For the second sample, the set of nice integers is {3, 5}.",TIME_LIMIT_EXCEEDED,"a, b = list(map(int, input().split()))
def a(x):
    if x % b != 0:
        k = (x // b)/(x % b)
        if k >= 1 and k <= a:
            return True
    return False
s = 0
for i in range(1,10**7+1):
    
    if a(i):
        print(i)
        s += i
print(s)","import h

def b():

    f = set()

    i = 0

    for a in h.stdin:

        a = a.rstrip('\n')
        if not a:
            continue

        if a[0] == '+':
            e = a[1:]
            f.add(e)

        elif a[0] == '-':
            e = a[1:]
            f.remove(e)

        else:

            g, c = a.split(':', 1)

            d = len(c)

            i += d * len(f)

    print(i)

if __name__ == '__main__':
    b()"
960,A,Check the string,PROGRAMMING,['implementation'],"A has a string consisting of some number of lowercase English letters 'a'. He gives it to his friend B who appends some number of letters 'b' to the end of this string. Since both A and B like the characters 'a' and 'b', they have made sure that at this point, at least one 'a' and one 'b' exist in the string.

B now gives this string to C and he appends some number of letters 'c' to the end of the string. However, since C is a good friend of A and B, the number of letters 'c' he appends is equal to the number of 'a' or to the number of 'b' in the string. It is also possible that the number of letters 'c' equals both to the number of letters 'a' and to the number of letters 'b' at the same time.

You have a string in your hands, and you want to check if it is possible to obtain the string in this way or not. If it is possible to obtain the string, print ""YES"", otherwise print ""NO"" (without the quotes).","The first and only line consists of a string $S$ ($ 1 \le |S| \le 5\,000 $). It is guaranteed that the string will only consist of the lowercase English letters 'a', 'b', 'c'.","Print ""YES"" or ""NO"", according to the condition.","['aaabccc\n', 'bbacc\n', 'aabc\n']","['YES\n', 'NO\n', 'YES\n']","Consider first example: the number of 'c' is equal to the number of 'a'. 

Consider second example: although the number of 'c' is equal to the number of the 'b', the order is not correct.

Consider third example: the number of 'c' is equal to the number of 'b'.",WRONG_ANSWER,"def a (y):
    if y.count('a') >= 1:
        if y.count('b') >= 1:
            if y[0]=='a':
                if y.count('a') == y.count('c') or y.count('b') == y. count('c'):
                    return 'YES'
                else:
                    return 'NO'
            else:
                return 'NO'
        else:
            return 'NO'
    else:
        return 'NO'

b = input()
print( a(b) )","import h

def d():

    b = h.stdin.read().strip()
    if not b:
        return

    s = b.split()[0]

    c = []
    f = []

    for i, a in enumerate(s, start=1):
        if a == 'l':

            c.append(i)
        else:

            f.append(i)

    e = f + c[::-1]

    for g in e:
        print(g)

if __name__ == ""__main__"":
    d()"
99,A,Help Far Away Kingdom,PROGRAMMING,['strings'],"In a far away kingdom lived the King, the Prince, the Shoemaker, the Dressmaker and many other citizens. They lived happily until great trouble came into the Kingdom. The ACMers settled there.

Most damage those strange creatures inflicted upon the kingdom was that they loved high precision numbers. As a result, the Kingdom healers had already had three appointments with the merchants who were asked to sell, say, exactly 0.273549107 beer barrels. To deal with the problem somehow, the King issued an order obliging rounding up all numbers to the closest integer to simplify calculations. Specifically, the order went like this:
-  If a number's integer part does not end with digit 9 and its fractional part is strictly less than 0.5, then the rounded up number coincides with the number’s integer part. -  If a number's integer part does not end with digit 9 and its fractional part is not less than 0.5, the rounded up number is obtained if we add 1 to the last digit of the number’s integer part.-  If the number’s integer part ends with digit 9, to round up the numbers one should go to Vasilisa the Wise. In the whole Kingdom she is the only one who can perform the tricky operation of carrying into the next position. 
Merchants found the algorithm very sophisticated and they asked you (the ACMers) to help them. Can you write a program that would perform the rounding according to the King’s order?","The first line contains a single number to round up — the integer part (a non-empty set of decimal digits that do not start with 0 — with the exception of a case when the set consists of a single digit — in this case 0 can go first), then follows character «.» (a dot), and then follows the fractional part (any non-empty set of decimal digits). The number's length does not exceed 1000 characters, including the dot. There are no other characters in the input data.","If the last number of the integer part is not equal to 9, print the rounded-up number without leading zeroes. Otherwise, print the message ""GOTO Vasilisa."" (without the quotes).","['0.0\n', '1.49\n', '1.50\n', '2.71828182845904523536\n', '3.14159265358979323846\n', '12345678901234567890.1\n', '123456789123456789.999\n']","['0', '1', '2', '3', '3', '12345678901234567890', 'GOTO Vasilisa.']",none,OK,"def f(d):
    b, a = d.split('.')
    c = int(b[-1])

    if c != 9:
        if int(a[0]) < 5:
            return b
        else:
            return str(int(b) + 1)
    else:
        return ""GOTO Vasilisa.""

d = input().strip()

e = f(d)
print(e)","import d

def c():
    b = d.stdin.read().splitlines()
    if not b:
        return

    n, p = map(int, b[0].split())
    s = list(b[1].strip())

    a = False

    for i in range(n - p):
        j = i + p

        if s[i] != '.' and s[j] != '.':
            if s[i] != s[j]:

                a = True
                break

        elif s[i] == '.' and s[j] != '.':

            s[i] = '1' if s[j] == '0' else '0'
            a = True
            break
        elif s[i] != '.' and s[j] == '.':
            s[j] = '1' if s[i] == '0' else '0'
            a = True
            break

        elif s[i] == '.' and s[j] == '.':
            s[i] = '0'
            s[j] = '1'
            a = True
            break

    if not a:
        d.stdout.write(""No\n"")
        return

    for k in range(n):
        if s[k] == '.':
            s[k] = '0'

    d.stdout.write("""".join(s) + ""\n"")

if __name__ == ""__main__"":
    c()"
459,A,Pashmak and Garden,PROGRAMMING,['implementation'],"Pashmak has fallen in love with an attractive girl called Parmida since one year ago...

Today, Pashmak set up a meeting with his partner in a romantic garden. Unfortunately, Pashmak has forgotten where the garden is. But he remembers that the garden looks like a square with sides parallel to the coordinate axes. He also remembers that there is exactly one tree on each vertex of the square. Now, Pashmak knows the position of only two of the trees. Help him to find the position of two remaining ones.","The first line contains four space-separated *x*1,<=*y*1,<=*x*2,<=*y*2 (<=-<=100<=≤<=*x*1,<=*y*1,<=*x*2,<=*y*2<=≤<=100) integers, where *x*1 and *y*1 are coordinates of the first tree and *x*2 and *y*2 are coordinates of the second tree. It's guaranteed that the given points are distinct.","If there is no solution to the problem, print -1. Otherwise print four space-separated integers *x*3,<=*y*3,<=*x*4,<=*y*4 that correspond to the coordinates of the two other trees. If there are several solutions you can output any of them. 

Note that *x*3,<=*y*3,<=*x*4,<=*y*4 must be in the range (<=-<=1000<=≤<=*x*3,<=*y*3,<=*x*4,<=*y*4<=≤<=1000).","['0 0 0 1\n', '0 0 1 1\n', '0 0 1 2\n']","['1 0 1 1\n', '0 1 1 0\n', '-1\n']",none,OK,"b,d,c,e = [int(a) for a in input().split()]

if d == e:
    print(b, d+(c-b), c, e+(c-b))
elif b == c:
    print(b+(e-d), d, c+(e-d), e)
elif abs(e - d) != abs(c - b):
    print(-1)
else:
    print(b,e,c,d)","def c():
    import h
    b = h.stdin.read().split()

    n = int(b[0])

    g = list(map(int, b[1:]))

    a = {1: 0, 2: 0, 3: 0}
    for f in g:
        a[f] += 1

    d = max(a.values())

    e = n - d
    h.stdout.write(str(e))
    
if __name__ == ""__main__"":
    c()"
650,A,Watchmen,PROGRAMMING,"['data structures', 'geometry', 'math']","Watchmen are in a danger and Doctor Manhattan together with his friend Daniel Dreiberg should warn them as soon as possible. There are *n* watchmen on a plane, the *i*-th watchman is located at point (*x**i*,<=*y**i*).

They need to arrange a plan, but there are some difficulties on their way. As you know, Doctor Manhattan considers the distance between watchmen *i* and *j* to be |*x**i*<=-<=*x**j*|<=+<=|*y**i*<=-<=*y**j*|. Daniel, as an ordinary person, calculates the distance using the formula .

The success of the operation relies on the number of pairs (*i*,<=*j*) (1<=≤<=*i*<=&lt;<=*j*<=≤<=*n*), such that the distance between watchman *i* and watchmen *j* calculated by Doctor Manhattan is equal to the distance between them calculated by Daniel. You were asked to compute the number of such pairs.","The first line of the input contains the single integer *n* (1<=≤<=*n*<=≤<=200<=000) — the number of watchmen.

Each of the following *n* lines contains two integers *x**i* and *y**i* (|*x**i*|,<=|*y**i*|<=≤<=109).

Some positions may coincide.",Print the number of pairs of watchmen such that the distance between them calculated by Doctor Manhattan is equal to the distance calculated by Daniel.,"['3\n1 1\n7 5\n1 5\n', '6\n0 0\n0 1\n0 2\n-1 1\n0 1\n1 1\n']","['2\n', '11\n']","In the first sample, the distance between watchman 1 and watchman 2 is equal to |1 - 7| + |1 - 5| = 10 for Doctor Manhattan and <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/bcb5b7064b5f02088da0fdcf677e6fda495dd0df.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> for Daniel. For pairs (1, 1), (1, 5) and (7, 5), (1, 5) Doctor Manhattan and Daniel will calculate the same distances.",WRONG_ANSWER,"from sys import g,stdout
from collections import deque
input = g.readline
 
def e():

    t=1
    for i in range(t):
        n = int(input())

        a = 0
        b = {}
        c = {}
        d = {}
        for i in range(n):
            x,y = map(int,input().split())
            f = x*1000000001+y
            if f in d:
                d[f] += 1
            else:
                d[f] = 1
            if x in b:
                b[x] += 1
            else:
                b[x] = 1
            if y in c:
                c[y] += 1
            else:
                c[y] = 1
        a = 0
        for i in b:
            a += b[i]*(b[i]-1)//2
        for i in c:
            a += c[i]*(c[i]-1)//2
        for i in d:
            a -= d[i]*(d[i]-1)//2
        print(a)
e()","def e():

    n = int(input().strip())

    c = list(map(int, input().split()))

    c.sort(reverse=True)

    f = sum(c)

    a = 0
    d = 0

    for b in c:
        a += b
        d += 1

        if a > f - a:
            print(d)
            return

if __name__ == ""__main__"":
    e()"
246,D,Colorful Graph,PROGRAMMING,"['brute force', 'dfs and similar', 'graphs']","You've got an undirected graph, consisting of *n* vertices and *m* edges. We will consider the graph's vertices numbered with integers from 1 to *n*. Each vertex of the graph has a color. The color of the *i*-th vertex is an integer *c**i*.

Let's consider all vertices of the graph, that are painted some color *k*. Let's denote a set of such as *V*(*k*). Let's denote the value of the neighbouring color diversity for color *k* as the cardinality of the set *Q*(*k*)<==<={*c**u* :<= *c**u*<=≠<=*k* and there is vertex *v* belonging to set *V*(*k*) such that nodes *v* and *u* are connected by an edge of the graph}.

Your task is to find such color *k*, which makes the cardinality of set *Q*(*k*) maximum. In other words, you want to find the color that has the most diverse neighbours. Please note, that you want to find such color *k*, that the graph has at least one vertex with such color.","The first line contains two space-separated integers *n*,<=*m* (1<=≤<=*n*,<=*m*<=≤<=105) — the number of vertices end edges of the graph, correspondingly. The second line contains a sequence of integers *c*1,<=*c*2,<=...,<=*c**n* (1<=≤<=*c**i*<=≤<=105) — the colors of the graph vertices. The numbers on the line are separated by spaces.

Next *m* lines contain the description of the edges: the *i*-th line contains two space-separated integers *a**i*,<=*b**i* (1<=≤<=*a**i*,<=*b**i*<=≤<=*n*; *a**i*<=≠<=*b**i*) — the numbers of the vertices, connected by the *i*-th edge. 

It is guaranteed that the given graph has no self-loops or multiple edges.","Print the number of the color which has the set of neighbours with the maximum cardinality. It there are multiple optimal colors, print the color with the minimum number. Please note, that you want to find such color, that the graph has at least one vertex with such color.","['6 6\n1 1 2 3 5 8\n1 2\n3 2\n1 4\n4 3\n4 5\n4 6\n', '5 6\n4 2 5 2 4\n1 2\n2 3\n3 1\n5 3\n5 4\n3 4\n']","['3\n', '2\n']",none,WRONG_ANSWER,"from queue import Queue

def e():
	n,m = map(int,input().split())
	b = list(map(int,input().split()))
	a = [set()for i in range(n+5)]
	for i in range(m):
		a,b = map(int,input().split())
		if b[a-1]!=b[b-1]:
			a[b[a-1]].add(b[b-1])
			a[b[b-1]].add(b[a-1])
	c = 1
	d = len(a[1])
	for i in range(2,n+1):
		if len(a[i])>d:
			c = len(a[i])
			d = i
	print(d)

t = 1

for i in range(t):
	e()","import d

def c():

    n, m, a = map(int, input().split())

    b = d.ceil(n / a)
    a = d.ceil(m / a)

    e = b * a

    print(e)

if __name__ == '__main__':
    c()"
837,D,Round Subset,PROGRAMMING,"['dp', 'math']","Let's call the roundness of the number the number of zeros to which it ends.

You have an array of *n* numbers. You need to choose a subset of exactly *k* numbers so that the roundness of the product of the selected numbers will be maximum possible.","The first line contains two integer numbers *n* and *k* (1<=≤<=*n*<=≤<=200,<=1<=≤<=*k*<=≤<=*n*).

The second line contains *n* space-separated integer numbers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=1018).",Print maximal roundness of product of the chosen subset of length *k*.,"['3 2\n50 4 20\n', '5 3\n15 16 3 25 9\n', '3 3\n9 77 13\n']","['3\n', '3\n', '0\n']","In the first example there are 3 subsets of 2 numbers. [50, 4] has product 200 with roundness 2, [4, 20] — product 80, roundness 1, [50, 20] — product 1000, roundness 3.

In the second example subset [15, 16, 25] has product 6000, roundness 3.

In the third example all subsets has product with roundness 0.",TIME_LIMIT_EXCEEDED,"from sys import j
input = j.buffer.readline

def d():
    a = 3000
    n, k = map(int,input().split())
    a = list(map(int,input().split()))

    h, i = [], []
    for i in a:
        e, f = 0, 0
        while i % 2 == 0:
            e += 1
            i //= 2
        while i % 5 == 0:
            f += 1
            i //= 5
        h.append(e)
        i.append(f)

    g = [[-1] * a for _ in range(n + 1)]
    c = [[-1] * a for _ in range(n + 1)]
    g[0][0] = 0
    b = 0

    for i in range(1, n + 1):
        for j in range(k + 1):
            for l in range(a):
                c[j][l] = g[j][l]
                if j > 0 and j - i[i - 1] >= 0:
                    c[j][l] = max(c[j][l], g[j - 1][l - i[i - 1]] + h[i - 1])
                if j == k:
                    b = max(b, min(c[j][l], l))
        c, g = g, c

    print(b)

d()","import l
import a

def f():

    d = l.stdin.read().splitlines()
    if not d or len(d) < 2:
        return

    j = d[0].strip()
    k = d[1].strip()

    h = {}
    for i, b in enumerate(j):
        if b not in h:
            h[b] = []
        h[b].append(i)

    for b in set(k):
        if b not in h:
            print(""-1"")
            return

    c = 1

    g = -1

    for b in k:
        i = h[b]

        e = a.bisect_right(i, g)
        if e == len(i):

            c += 1
            g = i[0]
        else:

            g = i[e]
    print(c)

if __name__ == ""__main__"":
    f()"
2,A,Winner,PROGRAMMING,"['hashing', 'implementation']","The winner of the card game popular in Berland ""Berlogging"" is determined according to the following rules. If at the end of the game there is only one player with the maximum number of points, he is the winner. The situation becomes more difficult if the number of such players is more than one. During each round a player gains or loses a particular number of points. In the course of the game the number of points is registered in the line ""name score"", where name is a player's name, and score is the number of points gained in this round, which is an integer number. If score is negative, this means that the player has lost in the round. So, if two or more players have the maximum number of points (say, it equals to *m*) at the end of the game, than wins the one of them who scored at least *m* points first. Initially each player has 0 points. It's guaranteed that at the end of the game at least one player has a positive number of points.","The first line contains an integer number *n* (1<=<=≤<=<=*n*<=<=≤<=<=1000), *n* is the number of rounds played. Then follow *n* lines, containing the information about the rounds in ""name score"" format in chronological order, where name is a string of lower-case Latin letters with the length from 1 to 32, and score is an integer number between -1000 and 1000, inclusive.",Print the name of the winner.,"['3\nmike 3\nandrew 5\nmike 2\n', '3\nandrew 3\nandrew 2\nmike 5\n']","['andrew\n', 'andrew\n']",none,WRONG_ANSWER,"from math import a

def i(n, d):
    f = {}
    g = 0
    for b in d:
        c = b.split()
        try:
            f[c[0]] += int(c[1]) - g
        except:
             f[c[0]] = int(c[1]) - g
        g += 1
    max = -a
    e = ''
    for k,v in f.items():
        if v > max:
            max = v
            e = k
    return e

if __name__ == '__main__':
    n = int(input())
    h = []
    for _ in range(n):
        h.append(input())
    print(i(n, h))","import c

def b():

    a = c.stdin.read().strip().split()
    if not a:
        return

    a = int(a[0])
    b = int(a[1])
    c = int(a[2])
    
    if c == 0:

        if a == b:
            print(""YES"")
        else:
            print(""NO"")
    else:

        if (b - a) % c == 0 and (b - a) // c >= 0:
            print(""YES"")
        else:
            print(""NO"")

if __name__ == ""__main__"":
    b()"
755,A,PolandBall and Hypothesis,PROGRAMMING,"['brute force', 'graphs', 'math', 'number theory']","PolandBall is a young, clever Ball. He is interested in prime numbers. He has stated a following hypothesis: ""There exists such a positive integer *n* that for each positive integer *m* number *n*·*m*<=+<=1 is a prime number"".

Unfortunately, PolandBall is not experienced yet and doesn't know that his hypothesis is incorrect. Could you prove it wrong? Write a program that finds a counterexample for any *n*.",The only number in the input is *n* (1<=≤<=*n*<=≤<=1000) — number from the PolandBall's hypothesis.,Output such *m* that *n*·*m*<=+<=1 is not a prime number. Your answer will be considered correct if you output any suitable *m* such that 1<=≤<=*m*<=≤<=103. It is guaranteed the the answer exists.,"['3\n', '4\n']","['1', '2']","A prime number (or a prime) is a natural number greater than 1 that has no positive divisors other than 1 and itself.

For the first sample testcase, 3·1 + 1 = 4. We can output 1.

In the second sample testcase, 4·1 + 1 = 5. We cannot output 1 because 5 is prime. However, *m* = 2 is okay since 4·2 + 1 = 9, which is not a prime number.",RUNTIME_ERROR,"def a(a):
    for j in range(0, a):
        if a%j == 0:
            return False
    return True

n = int(input())

if n%2 == 1:
    print(""1"")
else:
    for i in 1000:
        a = (n*i)+1
        b = a(a)
        if b == False:
            print(i)
            break","import f

def e():

    n, l, m = map(int, input().split())

    h = list(map(int, input().split()))

    o, p = map(int, input().split())
    
    c = float('inf')
    b = -1
    a = None

    for i in range(1, n):
        n = h[i]

        i = (n - h[0]) / l

        g = f.sqrt((o - n) ** 2 + p ** 2)
        j = g / m
        
        k = i + j

        d = abs(n - o)

        if k < c or (abs(k - c) < 1e-9 and d < a):
            c = k
            b = i + 1
            a = d

    print(b)

if __name__ == '__main__':
    e()"
322,A,Ciel and Dancing,PROGRAMMING,['greedy'],"Fox Ciel and her friends are in a dancing room. There are *n* boys and *m* girls here, and they never danced before. There will be some songs, during each song, there must be exactly one boy and one girl are dancing. Besides, there is a special rule:
 -  either the boy in the dancing pair must dance for the first time (so, he didn't dance with anyone before); -  or the girl in the dancing pair must dance for the first time. 
Help Fox Ciel to make a schedule that they can dance as many songs as possible.","The first line contains two integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=100) — the number of boys and girls in the dancing room.","In the first line print *k* — the number of songs during which they can dance. Then in the following *k* lines, print the indexes of boys and girls dancing during songs chronologically. You can assume that the boys are indexed from 1 to *n*, and the girls are indexed from 1 to *m*.","['2 1\n', '2 2\n']","['2\n1 1\n2 1\n', '3\n1 1\n1 2\n2 2\n']","In test case 1, there are 2 boys and 1 girl. We can have 2 dances: the 1st boy and 1st girl (during the first song), the 2nd boy and 1st girl (during the second song).

And in test case 2, we have 2 boys with 2 girls, the answer is 3.",WRONG_ANSWER,"def f(n,m):
  d = max(n,m)
  e = min(n,m)
  b = d+e-1
  print(b)
  for i in range(1,d+1):
    print(i,1)
  for j in range(2,e+1):
    print(1,j)
  

def c() :

  a = list(map(int, input().split(' ')))

  f(*a)
c()","import k

def a(f: str) -> str:
    """"""
    Convert a login string to its canonical form based on allowed transformation rules.
    
    Rules:
    - Any letter can change its case, so we normalize non-special letters to lowercase.
    - Characters '0', 'O', and 'o' are interchangeable, so we convert them all to '0'.
    - Digit '1', lowercase 'l', and letter 'I' (and by case conversion, also 'i' and 'L')
      are interchangeable. We convert any of these to '1'.
    - Other digits and underscore remain as they are.
    """"""
    j = []
    for b in f:

        if b == '0' or b == 'O' or b == 'o':
            j.append('0')

        elif b == '1' or (b.isalpha() and (b.lower() == 'l' or b.upper() == 'I')):
            j.append('1')

        elif b.isalpha():
            j.append(b.lower())
        else:

            j.append(b)
    return """".join(j)

def g():
    c = k.stdin.read().splitlines()
    if not c:
        return

    i = c[0].strip()

    if len(c) < 2:
        return
    n = int(c[1].strip())

    d = [e.strip() for e in c[2:2+n]]

    h = a(i)

    for f in d:
        if a(f) == h:
            print(""No"")
            return
    print(""Yes"")

if __name__ == '__main__':
    g()"
169,A,Chores,PROGRAMMING,['sortings'],"Petya and Vasya are brothers. Today is a special day for them as their parents left them home alone and commissioned them to do *n* chores. Each chore is characterized by a single parameter — its complexity. The complexity of the *i*-th chore equals *h**i*.

As Petya is older, he wants to take the chores with complexity larger than some value *x* (*h**i*<=&gt;<=*x*) to leave to Vasya the chores with complexity less than or equal to *x* (*h**i*<=≤<=*x*). The brothers have already decided that Petya will do exactly *a* chores and Vasya will do exactly *b* chores (*a*<=+<=*b*<==<=*n*).

In how many ways can they choose an integer *x* so that Petya got exactly *a* chores and Vasya got exactly *b* chores?","The first input line contains three integers *n*,<=*a* and *b* (2<=≤<=*n*<=≤<=2000; *a*,<=*b*<=≥<=1; *a*<=+<=*b*<==<=*n*) — the total number of chores, the number of Petya's chores and the number of Vasya's chores.

The next line contains a sequence of integers *h*1,<=*h*2,<=...,<=*h**n* (1<=≤<=*h**i*<=≤<=109), *h**i* is the complexity of the *i*-th chore. The numbers in the given sequence are not necessarily different.

All numbers on the lines are separated by single spaces.","Print the required number of ways to choose an integer value of *x*. If there are no such ways, print 0.","['5 2 3\n6 2 3 100 1\n', '7 3 4\n1 1 9 1 1 1 1\n']","['3\n', '0\n']","In the first sample the possible values of *x* are 3, 4 or 5.

In the second sample it is impossible to find such *x*, that Petya got 3 chores and Vasya got 4.",MEMORY_LIMIT_EXCEEDED,"def a(c, a, b):
  b = c[b -1]
  e = c[-a]
  d = []
  for i in range(b, e):
    d.append(i)
  return len(d)
  

n, a, b = list(map(int, input().split()))

c =  list(map(int, input().split()))
c.sort()

print(a(c, a, b))","import h

def e(v, a, b, x, y):

    f = x * y // h.gcd(x, y)

    a = v // y - v // f

    b = v // x - v // f

    c = v - (v // x) - (v // y) + (v // f)

    j = max(0, a - a) + max(0, b - b)

    return j <= c

def d(a, b, x, y):

    g, l = 1, 10**18
    while g < l:
        i = (g + l) // 2
        if e(i, a, b, x, y):
            l = i
        else:
            g = i + 1
    return g

if __name__ == '__main__':
    import m

    c = m.stdin.read().strip().split()
    if len(c) < 4:
        exit(0)
    a, b, x, y = map(int, c[:4])

    k = d(a, b, x, y)

    m.stdout.write(str(k))"
0,none,none,none,['none'],"There are *n* people and *k* keys on a straight line. Every person wants to get to the office which is located on the line as well. To do that, he needs to reach some point with a key, take the key and then go to the office. Once a key is taken by somebody, it couldn't be taken by anybody else.

You are to determine the minimum time needed for all *n* people to get to the office with keys. Assume that people move a unit distance per 1 second. If two people reach a key at the same time, only one of them can take the key. A person can pass through a point with a key without taking it.","The first line contains three integers *n*, *k* and *p* (1<=≤<=*n*<=≤<=1<=000, *n*<=≤<=*k*<=≤<=2<=000, 1<=≤<=*p*<=≤<=109) — the number of people, the number of keys and the office location.

The second line contains *n* distinct integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=109) — positions in which people are located initially. The positions are given in arbitrary order.

The third line contains *k* distinct integers *b*1,<=*b*2,<=...,<=*b**k* (1<=≤<=*b**j*<=≤<=109) — positions of the keys. The positions are given in arbitrary order.

Note that there can't be more than one person or more than one key in the same point. A person and a key can be located in the same point.",Print the minimum time (in seconds) needed for all *n* to reach the office with keys.,"['2 4 50\n20 100\n60 10 40 80\n', '1 2 10\n11\n15 7\n']","['50\n', '7\n']","In the first example the person located at point 20 should take the key located at point 40 and go with it to the office located at point 50. He spends 30 seconds. The person located at point 100 can take the key located at point 80 and go to the office with it. He spends 50 seconds. Thus, after 50 seconds everybody is in office with keys.",RUNTIME_ERROR,"*_, f = map(int, input().split())
g = list(map(int, input().split()))
e = list(map(int, input().split()))

def h(f, g, c):
    b = []

    for i in range(len(g)):
        for d in range(len(c)):
            b.append((abs(g[i]-c)+abs(c-f), i, d))

    b.sort()
    j = [0]*len(g)
    k = [0]*len(c)

    i = 0
    for a, i, d in b:
        if j[i] or k[d]:
            continue
        j[i] = True
        k[d] = True
        i = max(i, a)

    return i

print(h(f, g, e))","def k():
    import l
    c = l.stdin.read().split()
    if not c:
        return
    n = int(c[0])
    d = []
    g = 1

    for i in range(n):
        x = int(c[g])
        h = int(c[g + 1])
        g += 2
        d.append((x, h, i))

    d.sort(key=lambda t: t[0])
    m = [d[0] for d in d]

    e = [0] * n
    f = [0] * n
    b = [0] * n

    e[n - 1] = d[n - 1][0] + d[n - 1][1]
    f[n - 1] = n
    b[n - 1] = 1

    for i in range(n - 2, -1, -1):
        x, h, _ = d[i]

        i = x + h
        a = 1
        j = i + 1

        while j < n and m[j] < i:
            a += b[j]

            if e[j] > i:
                i = e[j]
            j = f[j]
        e[i] = i
        f[i] = j
        b[i] = a

    j = [0] * n
    for i in range(n):
        h = d[i][2]
        j[h] = b[i]
    
    l.stdout.write("" "".join(map(str, j)) + "" "")

if __name__ == ""__main__"":
    k()"
899,C,Dividing the numbers,PROGRAMMING,"['constructive algorithms', 'graphs', 'math']","Petya has *n* integers: 1,<=2,<=3,<=...,<=*n*. He wants to split these integers in two non-empty groups in such a way that the absolute difference of sums of integers in each group is as small as possible. 

Help Petya to split the integers. Each of *n* integers should be exactly in one group.",The first line contains a single integer *n* (2<=≤<=*n*<=≤<=60<=000) — the number of integers Petya has.,"Print the smallest possible absolute difference in the first line.

In the second line print the size of the first group, followed by the integers in that group. You can print these integers in arbitrary order. If there are multiple answers, print any of them.","['4\n', '2\n']","['0\n2 1 4 \n', '1\n1 1 \n']","In the first example you have to put integers 1 and 4 in the first group, and 2 and 3 in the second. This way the sum in each group is 5, and the absolute difference is 0.

In the second example there are only two integers, and since both groups should be non-empty, you have to put one integer in the first group and one in the second. This way the absolute difference of sums of integers in each group is 1.",OK,"def c():
	n = int(input())
	if n==1:
		print(1)
		print(1,1)
		return
	b = n*(n+1)//2
	e = b
	b/=2
	t = b
	a = []
	for i in range(n,0,-1):
		if b-i>=0:
			b-=i
			a.append(i)
	b = t-b
	d = e-b
	print(abs(int(d-b)))
	print(len(a),*a)

t = 1
for i in range(t):
	c()","c = input().strip()
d = input().strip()

e = """"

for a, b in zip(c, d):

    if a != b:
        e += ""1""
    else:
        e += ""0""

print(e)"
120,F,Spiders,PROGRAMMING,"['dp', 'greedy', 'trees']","One day mum asked Petya to sort his toys and get rid of some of them. Petya found a whole box of toy spiders. They were quite dear to him and the boy didn't want to throw them away. Petya conjured a cunning plan: he will glue all the spiders together and attach them to the ceiling. Besides, Petya knows that the lower the spiders will hang, the more mum is going to like it and then she won't throw his favourite toys away. Help Petya carry out the plan.

A spider consists of *k* beads tied together by *k*<=-<=1 threads. Each thread connects two different beads, at that any pair of beads that make up a spider is either directly connected by a thread, or is connected via some chain of threads and beads.

Petya may glue spiders together directly gluing their beads. The length of each thread equals 1. The sizes of the beads can be neglected. That's why we can consider that gluing spiders happens by identifying some of the beads (see the picture). Besides, the construction resulting from the gluing process should also represent a spider, that is, it should have the given features. 

After Petya glues all spiders together, he measures the length of the resulting toy. The distance between a pair of beads is identified as the total length of the threads that connect these two beads. The length of the resulting construction is the largest distance between all pairs of beads. Petya wants to make the spider whose length is as much as possible.

The picture two shows two spiders from the second sample. We can glue to the bead number 2 of the first spider the bead number 1 of the second spider. The threads in the spiders that form the sequence of threads of maximum lengths are highlighted on the picture.","The first input file line contains one integer *n* (1<=≤<=*n*<=≤<=100) — the number of spiders. Next *n* lines contain the descriptions of each spider: integer *n**i* (2<=≤<=*n**i*<=≤<=100) — the number of beads, then *n**i*<=-<=1 pairs of numbers denoting the numbers of the beads connected by threads. The beads that make up each spider are numbered from 1 to *n**i*.",Print a single number — the length of the required construction.,"['1\n3 1 2 2 3\n', '2\n3 1 2 1 3\n4 1 2 2 3 2 4\n', '2\n5 1 2 2 3 3 4 3 5\n7 3 4 1 2 2 4 4 6 2 7 6 5\n']","['2\n', '4\n', '7\n']",none,OK,"import math
import l
from bisect import bisect_right, bisect_left, insort_right
from collections import Counter, defaultdict
from heapq import heappop, heappush
from itertools import accumulate
from l import stdout

R = lambda: map(int, input().split())
l.stdin = open('input.txt', 'r')
l.stdout = open('output.txt', 'w')
def e(m, c, j):
    g, f = c, 0
    for b in m[c]:
        if b != j:
            h, d = e(m, b, c)
            if d + 1 > f:
                g, f = h, d + 1
    return g, f
k = 0
for t in range(int(input())):
    a = list(map(int, input().split()))
    m = [[] for i in range(a[0] + 1)]
    for i in range(1, len(a), 2):
        m[a[i]].append(a[i + 1])
        m[a[i + 1]].append(a[i])
    i = e(m, 1, 1)[0]
    k += e(m, i, i)[1]
print(k)","def f(l, r):

    b = l

    for i in range(64):
        a = 1 << i

        if b & a:
            continue

        if b | a <= r:
            b |= a
    return b

def e():
    import i

    c = i.stdin.read().split()

    n = int(c[0])
    h = []
    d = 1

    for _ in range(n):
        l = int(c[d])
        r = int(c[d+1])
        d += 2
        h.append(f(l, r))

    for g in h:
        print(g)

if __name__ == '__main__':
    e()"
43,A,Football,PROGRAMMING,['strings'],"One day Vasya decided to have a look at the results of Berland 1910 Football Championship’s finals. Unfortunately he didn't find the overall score of the match; however, he got hold of a profound description of the match's process. On the whole there are *n* lines in that description each of which described one goal. Every goal was marked with the name of the team that had scored it. Help Vasya, learn the name of the team that won the finals. It is guaranteed that the match did not end in a tie.",The first line contains an integer *n* (1<=≤<=*n*<=≤<=100) — the number of lines in the description. Then follow *n* lines — for each goal the names of the teams that scored it. The names are non-empty lines consisting of uppercase Latin letters whose lengths do not exceed 10 symbols. It is guaranteed that the match did not end in a tie and the description contains no more than two different teams.,Print the name of the winning team. We remind you that in football the team that scores more goals is considered the winner.,"['1\nABC\n', '5\nA\nABA\nABA\nA\nA\n']","['ABC\n', 'A\n']",none,WRONG_ANSWER,"def c():
	n=int(input())
	d=dict()
	for i in range(n):
		a=input()
		if(a in d):
			d[a]+=1
		else:
			d[a]=1
	d=0
	for b,e in d.items():
		if(d<e):
			a=b

	print(a)

if __name__=='__main__':
	c()","import l

def e(s, k, m):

    f = 0
    c = 0
    a = 0
    n = len(s)
    
    for k in range(n):

        if s[k] != m:
            a += 1

        while a > k:
            if s[c] != m:
                a -= 1
            c += 1

        f = max(f, k - c + 1)
    return f

def d():
    b = l.stdin.read().splitlines()
    if not b:
        return

    g = b[0].split()
    n = int(g[0])
    k = int(g[1])

    s = b[1].strip()

    i = e(s, k, 'a')
    j = e(s, k, 'b')

    h = max(i, j)

    l.stdout.write(str(h) + ""\n"")

if __name__ == ""__main__"":
    d()"
372,A,Counting Kangaroos is Fun,PROGRAMMING,"['binary search', 'greedy', 'sortings', 'two pointers']","There are *n* kangaroos with pockets. Each kangaroo has a size (integer number). A kangaroo can go into another kangaroo's pocket if and only if the size of kangaroo who hold the kangaroo is at least twice as large as the size of kangaroo who is held.

Each kangaroo can hold at most one kangaroo, and the kangaroo who is held by another kangaroo cannot hold any kangaroos.

The kangaroo who is held by another kangaroo cannot be visible from outside. Please, find a plan of holding kangaroos with the minimal number of kangaroos who is visible.",The first line contains a single integer — *n* (1<=≤<=*n*<=≤<=5·105). Each of the next *n* lines contains an integer *s**i* — the size of the *i*-th kangaroo (1<=≤<=*s**i*<=≤<=105).,Output a single integer — the optimal number of visible kangaroos.,"['8\n2\n5\n7\n6\n9\n8\n4\n2\n', '8\n9\n1\n6\n2\n6\n5\n8\n3\n']","['5\n', '5\n']",none,RUNTIME_ERROR,"import math
import sys
import collections
import heapq
import itertools

def a():
    N = 100001
    a = [0] * (N * 5)
    b = [False] * (N * 5)

    n = int(input())
    a = [int(x) for x in input().split()]

    b = [False] * len(b)

    a.sort()
    k, m = n - 1, 0
    for i in range(k - 1, -1, -1):
        if a[k] >= a[i] * 2:
            m += 1
            k -= 1

    if n % 2:
        if m > n // 2:
            print(n // 2 + 1)
        else:
            print(n - m)
    else:
        if m > n // 2:
            print(n // 2)
        else:
            print(n - m)

if __name__ == ""__main__"":
    a()","def e():
    import f

    b = f.stdin.read().strip().split()
    if not b:
        return

    n = int(b[0])
    g = 0
    d = 0

    a = False

    c = 1
    for i in range(n):
        x = int(b[c])
        y = int(b[c + 1])
        c += 2
        g += x
        d += y

        if (x % 2) != (y % 2):
            a = True

    if g % 2 == 0 and d % 2 == 0:
        print(0)

    elif g % 2 != d % 2:
        print(-1)

    else:
        if a:
            print(1)
        else:
            print(-1)

if __name__ == ""__main__"":
    e()"
4,A,Watermelon,PROGRAMMING,"['brute force', 'math']","One hot summer day Pete and his friend Billy decided to buy a watermelon. They chose the biggest and the ripest one, in their opinion. After that the watermelon was weighed, and the scales showed *w* kilos. They rushed home, dying of thirst, and decided to divide the berry, however they faced a hard problem.

Pete and Billy are great fans of even numbers, that's why they want to divide the watermelon in such a way that each of the two parts weighs even number of kilos, at the same time it is not obligatory that the parts are equal. The boys are extremely tired and want to start their meal as soon as possible, that's why you should help them and find out, if they can divide the watermelon in the way they want. For sure, each of them should get a part of positive weight.",The first (and the only) input line contains integer number *w* (1<=≤<=*w*<=≤<=100) — the weight of the watermelon bought by the boys.,"Print YES, if the boys can divide the watermelon into two parts, each of them weighing even number of kilos; and NO in the opposite case.",['8\n'],['YES\n'],"For example, the boys can divide the watermelon into two parts of 2 and 6 kilos respectively (another variant — two parts of 4 and 4 kilos).",OK,"def a(i):
    if i%2 == 0:
        return ""YES""
    else:
        return ""NO""
i=int(input())
if i>3:
    print(a(i))
else:
    print(""NO"")","import i

def e():
    d = i.stdin.read().split()

    n = int(d[0])

    a = list(map(int, d[1:n+1]))

    m = int(d[n+1])

    g = list(map(int, d[n+2:]))

    f = {}
    for c, j in enumerate(a):
        f[j] = c + 1

    b = 0
    a = 0
    for h in g:

        b += f[h]

        a += (n - f[h] + 1)

    print(b, a)

if __name__ == '__main__':
    e()"
300,A,Array,PROGRAMMING,"['brute force', 'constructive algorithms', 'implementation']","Vitaly has an array of *n* distinct integers. Vitaly wants to divide this array into three non-empty sets so as the following conditions hold: 
 1.  The product of all numbers in the first set is less than zero (<=&lt;<=0). 1.  The product of all numbers in the second set is greater than zero (<=&gt;<=0). 1.  The product of all numbers in the third set is equal to zero. 1.  Each number from the initial array must occur in exactly one set. 
Help Vitaly. Divide the given array.","The first line of the input contains integer *n* (3<=≤<=*n*<=≤<=100). The second line contains *n* space-separated distinct integers *a*1,<=*a*2,<=...,<=*a**n* (|*a**i*|<=≤<=103) — the array elements.","In the first line print integer *n*1 (*n*1<=&gt;<=0) — the number of elements in the first set. Then print *n*1 numbers — the elements that got to the first set.

In the next line print integer *n*2 (*n*2<=&gt;<=0) — the number of elements in the second set. Then print *n*2 numbers — the elements that got to the second set.

In the next line print integer *n*3 (*n*3<=&gt;<=0) — the number of elements in the third set. Then print *n*3 numbers — the elements that got to the third set.

The printed sets must meet the described conditions. It is guaranteed that the solution exists. If there are several solutions, you are allowed to print any of them.","['3\n-1 2 0\n', '4\n-1 -2 -3 0\n']","['1 -1\n1 2\n1 0\n', '1 -1\n2 -3 -2\n1 0\n']",none,WRONG_ANSWER,"def b(n, a):
    e = []
    c = []
    g = []

    for d in a:
        if d < 0:
            c.append(d)
        elif d > 0:
            e.append(d)
        else:
            g.append(d)

    if len(c) % 2 == 0:
        f = [c.pop()]
    else:
        f = [c.pop(0)]

    print(len(f), *f)
    print(len(e), *e)
    print(len(c) + len(g), *(c + g))

n = int(input())
a = list(map(int, input().split()))

b(n, a)","import f
import d

def b(x, y):

    return x // d.gcd(x, y) * y

def c():

    a = f.stdin.read().split()
    if not a:
        return
    n = int(a[0])

    if n <= 2:

        print(n)
        return
    if n == 3:

        print(6)
        return

    if n % 2 != 0:
        a, b, c = n, n-1, n-2
    else:
        if n % 3 != 0:
            a, b, c = n, n-1, n-3
        else:
            a, b, c = n-1, n-2, n-3

    e = b(a, b(b, c))
    print(e)

if __name__ == '__main__':
    c()"
895,B,XK Segments,PROGRAMMING,"['binary search', 'math', 'sortings', 'two pointers']","While Vasya finished eating his piece of pizza, the lesson has already started. For being late for the lesson, the teacher suggested Vasya to solve one interesting problem. Vasya has an array *a* and integer *x*. He should find the number of different ordered pairs of indexes (*i*,<=*j*) such that *a**i*<=≤<=*a**j* and there are exactly *k* integers *y* such that *a**i*<=≤<=*y*<=≤<=*a**j* and *y* is divisible by *x*.

In this problem it is meant that pair (*i*,<=*j*) is equal to (*j*,<=*i*) only if *i* is equal to *j*. For example pair (1,<=2) is not the same as (2,<=1).","The first line contains 3 integers *n*,<=*x*,<=*k* (1<=≤<=*n*<=≤<=105,<=1<=≤<=*x*<=≤<=109,<=0<=≤<=*k*<=≤<=109), where *n* is the size of the array *a* and *x* and *k* are numbers from the statement.

The second line contains *n* integers *a**i* (1<=≤<=*a**i*<=≤<=109) — the elements of the array *a*.",Print one integer — the answer to the problem.,"['4 2 1\n1 3 5 7\n', '4 2 0\n5 3 1 7\n', '5 3 1\n3 3 3 3 3\n']","['3\n', '4\n', '25\n']","In first sample there are only three suitable pairs of indexes — (1, 2), (2, 3), (3, 4).

In second sample there are four suitable pairs of indexes(1, 1), (2, 2), (3, 3), (4, 4).

In third sample every pair (*i*, *j*) is suitable, so the answer is 5 * 5 = 25.",WRONG_ANSWER,"n, x, k = map(int, input().split())
a = list(map(int, input().split()))
a = 0
a.sort()
def g( b):
    c = -1
    f = len(a)
    while f > c + 1:
        e = (c + f ) // 2
        if a[e] > b + x * k:
            f = e
        else:
            c = e
    return f

def d(b):
    c = -1
    f = len(a)
    while f > c + 1:
        e = (c + f ) // 2
        if a[e] >= b + x * k or (x * k != 0 and a[e] % (x * k) == 0):
            f = e
        else:
            c = e
    return f
    
for i in range(len(a)):

    a += g(a[i]) - d(a[i])

print(a)","def d():
    import i
    a = i.stdin.read().split()
    if not a:
        return
    n = int(a[0])

    j = (n + 1) // 2

    c, b = 1, n
    h = n
    while c <= b:
        e = (c + b) // 2
        k = 0
        g = n

        while g > 0:

            l = min(e, g)
            k += l
            g -= l

            f = g // 10
            g -= f

            if k >= j:
                break
        
        if k >= j:
            h = e
            b = e - 1
        else:
            c = e + 1
    
    i.stdout.write(str(h))
    
if __name__ == '__main__':
    d()"
713,C,Sonya and Problem Wihtout a Legend,PROGRAMMING,"['dp', 'sortings']","Sonya was unable to think of a story for this problem, so here comes the formal description.

You are given the array containing *n* positive integers. At one turn you can pick any element and increase or decrease it by 1. The goal is the make the array strictly increasing by making the minimum possible number of operations. You are allowed to change elements in any way, they can become negative or equal to 0.","The first line of the input contains a single integer *n* (1<=≤<=*n*<=≤<=3000) — the length of the array.

Next line contains *n* integer *a**i* (1<=≤<=*a**i*<=≤<=109).",Print the minimum number of operation required to make the array strictly increasing.,"['7\n2 1 5 11 5 9 11\n', '5\n5 4 3 2 1\n']","['9\n', '12\n']","In the first sample, the array is going to look as follows:

2 3 5 6 7 9 11

|2 - 2| + |1 - 3| + |5 - 5| + |11 - 6| + |5 - 7| + |9 - 9| + |11 - 11| = 9

And for the second sample:

1 2 3 4 5

|5 - 1| + |4 - 2| + |3 - 3| + |2 - 4| + |1 - 5| = 12",OK,"import b
a = b.stdin.readline

n = int(a())
a = [int(x) for x in a().split()]

a = [x - i for i, x in enumerate(a)]

s = sorted(a)

M = [[0 for _ in a] for _ in a]
for i in range(n):
    for j in range(n):
        if i == 0:
            M[i][j] = abs(a[0] - s[j])
        elif j == 0:
            M[i][j] = M[i-1][0] + abs(a[i] - s[0])
        else:
            M[i][j] = min(M[i-1][j], M[i][j-1] - abs(a[i] - s[j-1]))+ abs(a[i] - s[j])

print(min(M[-1]))","def c():

    a = list(map(int, input().split()))

    s = input().strip()

    d = 0

    for a in s:
        b = int(a) - 1
        d += a[b]

    print(d)

if __name__ == ""__main__"":
    c()"
892,B,Wrath,PROGRAMMING,"['greedy', 'implementation', 'two pointers']","Hands that shed innocent blood!

There are *n* guilty people in a line, the *i*-th of them holds a claw with length *L**i*. The bell rings and every person kills some of people in front of him. All people kill others at the same time. Namely, the *i*-th person kills the *j*-th person if and only if *j*<=&lt;<=*i* and *j*<=≥<=*i*<=-<=*L**i*.

You are given lengths of the claws. You need to find the total number of alive people after the bell rings.","The first line contains one integer *n* (1<=≤<=*n*<=≤<=106) — the number of guilty people.

Second line contains *n* space-separated integers *L*1,<=*L*2,<=...,<=*L**n* (0<=≤<=*L**i*<=≤<=109), where *L**i* is the length of the *i*-th person's claw.",Print one integer — the total number of alive people after the bell rings.,"['4\n0 1 0 10\n', '2\n0 0\n', '10\n1 1 3 0 0 0 2 1 0 3\n']","['1\n', '2\n', '3\n']",In first sample the last person kills everyone in front of him.,TIME_LIMIT_EXCEEDED,"n = int(input())
l = [int(i) for i in input().split(' ')]
a = []
for i in range(n-1, -1, -1):
    for j in range(i-1, -1, -1):
        if j in a:
            continue
        if j + l[i] >= i:
            a.append(j)
print(n - len(set(a)))","import f

def c():

    b = f.stdin.read().strip().splitlines()

    n, m = map(int, b[0].split())

    a = b[1:]
    
    d = []

    for i in range(n):
        e = []
        for j in range(m):
            if a[i][j] == '-':

                e.append('-')
            else:

                if (i + j) % 2 == 0:
                    e.append('B')
                else:
                    e.append('W')

        d.append("""".join(e))

    f.stdout.write(""\n"".join(d))
    
if __name__ == ""__main__"":
    c()"
205,A,Little Elephant and Rozdil,PROGRAMMING,"['brute force', 'implementation']","The Little Elephant loves Ukraine very much. Most of all he loves town Rozdol (ukr. ""Rozdil"").

However, Rozdil is dangerous to settle, so the Little Elephant wants to go to some other town. The Little Elephant doesn't like to spend much time on travelling, so for his journey he will choose a town that needs minimum time to travel to. If there are multiple such cities, then the Little Elephant won't go anywhere.

For each town except for Rozdil you know the time needed to travel to this town. Find the town the Little Elephant will go to or print ""Still Rozdil"", if he stays in Rozdil.","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=105) — the number of cities. The next line contains *n* integers, separated by single spaces: the *i*-th integer represents the time needed to go from town Rozdil to the *i*-th town. The time values are positive integers, not exceeding 109.

You can consider the cities numbered from 1 to *n*, inclusive. Rozdil is not among the numbered cities.","Print the answer on a single line — the number of the town the Little Elephant will go to. If there are multiple cities with minimum travel time, print ""Still Rozdil"" (without the quotes).","['2\n7 4\n', '7\n7 4 47 100 4 9 12\n']","['2\n', 'Still Rozdil\n']","In the first sample there are only two cities where the Little Elephant can go. The travel time for the first town equals 7, to the second one — 4. The town which is closest to Rodzil (the only one) is the second one, so the answer is 2.

In the second sample the closest cities are cities two and five, the travelling time to both of them equals 4, so the answer is ""Still Rozdil"".",OK,"def c():
    e = int(input())
    f = input().split()
    d = int(f[0])
    for i in range(len(f)):
        f[i] = int(f[i])
        if f[i] < d:
            d = f[i]
    a = 0
    b = 0
    for i in range(len(f)):
        if f[i] == d:
            a += 1
            b = i
    if a == 1:
        print(b + 1)
    else:
        print(""Still Rozdil"")
c()","import e

def d():

    c = e.stdin.read().split()
    if len(c) < 2:
        return
    a = c[0].strip()
    b = c[1].strip()

    a = a.lstrip('0')
    b = b.lstrip('0')
    if a == """":
        a = ""0""
    if b == """":
        b = ""0""

    if len(a) < len(b):
        e.stdout.write(""<\n"")
    elif len(a) > len(b):
        e.stdout.write("">\n"")
    else:

        if a < b:
            e.stdout.write(""<\n"")
        elif a > b:
            e.stdout.write("">\n"")
        else:
            e.stdout.write(""=\n"")

if __name__ == ""__main__"":
    d()"
552,D,Vanya and Triangles,PROGRAMMING,"['brute force', 'combinatorics', 'data structures', 'geometry', 'math', 'sortings']",Vanya got bored and he painted *n* distinct points on the plane. After that he connected all the points pairwise and saw that as a result many triangles were formed with vertices in the painted points. He asks you to count the number of the formed triangles with the non-zero area.,"The first line contains integer *n* (1<=≤<=*n*<=≤<=2000) — the number of the points painted on the plane. 

Next *n* lines contain two integers each *x**i*,<=*y**i* (<=-<=100<=≤<=*x**i*,<=*y**i*<=≤<=100) — the coordinates of the *i*-th point. It is guaranteed that no two given points coincide.",In the first line print an integer — the number of triangles with the non-zero area among the painted points.,"['4\n0 0\n1 1\n2 0\n2 2\n', '3\n0 0\n1 1\n2 0\n', '1\n1 1\n']","['3\n', '1\n', '0\n']","Note to the first sample test. There are 3 triangles formed: (0, 0) - (1, 1) - (2, 0); (0, 0) - (2, 2) - (2, 0); (1, 1) - (2, 2) - (2, 0).

Note to the second sample test. There is 1 triangle formed: (0, 0) - (1, 1) - (2, 0).

Note to the third sample test. A single point doesn't form a single triangle.",TIME_LIMIT_EXCEEDED,"import d
import random

n = int(input())

def b(a, b):
    if a[0] == b[0]:
        return d.inf, a[0]
    return (d.floor(1000000000*(b[1] - a[1]) / (b[0] - a[0])))/1000000000, d.floor(1000000000*(a[1] - a[0] * ((b[1] - a[1]) / (b[0] - a[0]))))

f = [[int(x) for x in input().split()] for _ in range(n)]

def c(n, f):
    e = dict()

    for g in range(n):
        for j in range(g+1, n):
            if b(f[g], f[j]) in e.keys():
                e[b(f[g], f[j])] += 1
            else:
                e[b(f[g], f[j])] = 1

    a = n*(n-1)*(n-2)/6

    for i in e.keys():

        i = (-1 + d.sqrt(1 + 8 * e[i]))/2 + 1

        if i >= 3:

            a -= i*(i-1)*(i-2)/6

    return(int(a))

def k(n, f):
    a = 0
    for h in range(n):
        for j in range(h + 1, n):
            for l in range(j + 1, n):
                if b(f[h], f[j]) != b(f[l], f[j]):
                    a += 1
    return a

print(c(n, f))","import g

def e():

    c = g.stdin.read().split()
    if not c:
        return
    n = int(c[0])

    b = [[] for _ in range(n+1)]

    for i in range(2, n+1):
        f = int(c[i-1])
        b[f].append(i)

    for i in range(1, n+1):
        if b[i]:
            d = 0
            
            for a in b[i]:

                if not b[a]:
                    d += 1

            if d < 3:
                print(""No"")
                return

    print(""Yes"")

if __name__ == ""__main__"":
    e()"
198,B,Jumping on Walls,PROGRAMMING,['shortest paths'],"Vasya plays a computer game with ninjas. At this stage Vasya's ninja should get out of a deep canyon.

The canyon consists of two vertical parallel walls, their height is *n* meters. Let's imagine that we split these walls into 1 meter-long areas and number them with positive integers from 1 to *n* from bottom to top. Some areas are safe and the ninja can climb them. Others are spiky and ninja can't be there. Let's call such areas dangerous.

Initially the ninja is on the lower area of the left wall. He can use each second to perform one of the following actions: 
 -  climb one area up; -  climb one area down; -  jump to the opposite wall. That gets the ninja to the area that is exactly *k* meters higher than the area he jumped from. More formally, if before the jump the ninja is located at area *x* of one wall, then after the jump he is located at area *x*<=+<=*k* of the other wall. 
If at some point of time the ninja tries to get to an area with a number larger than *n*, then we can assume that the ninja got out of the canyon.

The canyon gets flooded and each second the water level raises one meter. Initially the water level is at the lower border of the first area. Ninja cannot be on the area covered by water. We can assume that the ninja and the water ""move in turns"" — first the ninja performs some action, then the water raises for one meter, then the ninja performs one more action and so on.

The level is considered completed if the ninja manages to get out of the canyon.

After several failed attempts Vasya started to doubt whether it is possible to complete the level at all. Help him answer the question.","The first line contains two integers *n* and *k* (1<=≤<=*n*,<=*k*<=≤<=105) — the height of the canyon and the height of ninja's jump, correspondingly.

The second line contains the description of the left wall — a string with the length of *n* characters. The *i*-th character represents the state of the *i*-th wall area: character ""X"" represents a dangerous area and character ""-"" represents a safe area.

The third line describes the right wall in the same format.

It is guaranteed that the first area of the left wall is not dangerous.","Print ""YES"" (without the quotes) if the ninja can get out from the canyon, otherwise, print ""NO"" (without the quotes).","['7 3\n---X--X\n-X--XX-\n', '6 2\n--X-X-\nX--XX-\n']","['YES\n', 'NO\n']","In the first sample the ninja should first jump to the right wall, then go one meter down along the right wall, then jump to the left wall. The next jump can get the ninja from the canyon. 

In the second sample there's no way the ninja can get out of the canyon.",IDLENESS_LIMIT_EXCEEDED,"from queue import a
import j

input = j.stdin.readline

b = 10**5+5
g = [[0] * b for _ in range(5)]
e = [[0] * b for _ in range(5)]
k = False
f = [[False] * b for _ in range(5)]

class h:
    def __init__(i, f, s, d):
        i.first = f
        i.second = s
        i.h = d

def c():
    global k
    global f
    f[0][1] = True
    q = a()
    q.put(h(0, 1, 0))
    while not q.empty():
        x, y, h = q.get().first, q.get().second, q.get().h
        if y + k > n:
            k = True
            return
        if y <= h:
            continue
        if not f[x][y+1] and g[x][y+1]:
            f[x][y+1] = True
            q.put(h(x, y+1, h+1))
        if not f[x][y-1] and g[x][y-1]:
            f[x][y-1] = True
            q.put(h(x, y-1, h+1))
        if not f[x^1][y+k] and g[x^1][y+k]:
            f[x^1][y+k] = True
            q.put(h(x^1, y+k, h+1))

if __name__ == ""__main__"":
    n, k = map(int, input().split())
    for i in range(2):
        s = input().strip()
        for j in range(1, n+1):
            if s[j-1] == '-':
                g[i][j] = 1
            else:
                g[i][j] = 0
    k = False
    c()
    if k:
        print(""YES"")
    else:
        print(""NO"")","def b(s):

    n = len(s)
    e = [0] * n
    for i in range(1, n):
        j = e[i - 1]
        while j > 0 and s[i] != s[j]:
            j = e[j - 1]
        if s[i] == s[j]:
            j += 1
        e[i] = j
    return e

def c():
    import f
    s = f.stdin.readline().strip()
    n = len(s)

    e = b(s)

    d = [False] * (n + 1)
    for i in range(n - 1):
        d[e[i]] = True

    a = e[-1]
    while a:
        if d[a]:
            print(s[:a])
            return
        a = e[a - 1]
    
    print(""Just a legend"")

if __name__ == ""__main__"":
    c()"
424,B,Megacity,PROGRAMMING,"['binary search', 'greedy', 'implementation', 'sortings']","The administration of the Tomsk Region firmly believes that it's time to become a megacity (that is, get population of one million). Instead of improving the demographic situation, they decided to achieve its goal by expanding the boundaries of the city.

The city of Tomsk can be represented as point on the plane with coordinates (0; 0). The city is surrounded with *n* other locations, the *i*-th one has coordinates (*x**i*, *y**i*) with the population of *k**i* people. You can widen the city boundaries to a circle of radius *r*. In such case all locations inside the circle and on its border are included into the city.

Your goal is to write a program that will determine the minimum radius *r*, to which is necessary to expand the boundaries of Tomsk, so that it becomes a megacity.","The first line of the input contains two integers *n* and *s* (1<=≤<=*n*<=≤<=103; 1<=≤<=*s*<=&lt;<=106) — the number of locatons around Tomsk city and the population of the city. Then *n* lines follow. The *i*-th line contains three integers — the *x**i* and *y**i* coordinate values of the *i*-th location and the number *k**i* of people in it (1<=≤<=*k**i*<=&lt;<=106). Each coordinate is an integer and doesn't exceed 104 in its absolute value.

It is guaranteed that no two locations are at the same point and no location is at point (0; 0).","In the output, print ""-1"" (without the quotes), if Tomsk won't be able to become a megacity. Otherwise, in the first line print a single real number — the minimum radius of the circle that the city needs to expand to in order to become a megacity.

The answer is considered correct if the absolute or relative error don't exceed 10<=-<=6.","['4 999998\n1 1 1\n2 2 1\n3 3 1\n2 -2 1\n', '4 999998\n1 1 2\n2 2 1\n3 3 1\n2 -2 1\n', '2 1\n1 1 999997\n2 2 1\n']","['2.8284271\n', '1.4142136\n', '-1']",none,WRONG_ANSWER,"import e
def g(r):
    p = [0]
    for t in range(len(r)):
        p.append(int(r[t])+p[-1])
    return(p)

def h(a):
    f = [0]
    for t in range(1,len(a)+1):
        f.append(int(a[-t])+f[-1])
    return(f)

def a(x):
    L = 0
    R = x+1
    while R-L > 1:
        m = (L + R)//2
        if m**3 <= x:
            L = m
        else:
            R = m
    return L

def b(a,b):
    L = 0
    R = len(a)+1
    while R-L>1:
        M = (R+L)//2
        if a[M]<b:
            L = M
        else:
            R = M
    return(L)

n, m = map(int, input().split())
a = []
g = []
for _ in range(n):
    k = []
    r = []
    b, c, d = map(int, input().split())
    g.append(e.sqrt(b**2+c**2))
    a.append(e.sqrt(b**2+c**2))
    a.append(d)
g = sorted(g)
for d in g:
    for i in range(a.count(d)):
        k.append(a[a.index(d)+1])
        a.pop(a.index(d))
    k = sorted(k)
    for c in k:
        r.append(c)
    k = []
r = g(r)
if r[-1]<10**6-m:
    print(-1)
else:
    print(g[b(r,10**6-m)])","def c(g, x):

    if g[x] != x:
        g[x] = c(g, g[x])
    return g[x]

def n(g, h, x, y):

    j = c(g, x)
    k = c(g, y)
    if j != k:
        if h[j] < h[k]:
            g[j] = k
        elif h[j] > h[k]:
            g[k] = j
        else:
            g[k] = j
            h[j] += 1

def f():
    import l

    e = l.stdin.read().split()
    n = int(e[0])
    m = int(e[1])

    b = list(map(int, e[2:2+n]))

    g = [i for i in range(n)]
    h = [0] * n

    d = 2 + n
    for _ in range(m):
        u = int(e[d]) - 1
        v = int(e[d + 1]) - 1
        d += 2
        n(g, h, u, v)

    a = {}
    for i in range(n):
        i = c(g, i)
        if i in a:
            a[i] = min(a[i], b[i])
        else:
            a[i] = b[i]

    m = sum(a.values())

    l.stdout.write(str(m) + ""\n"")

if __name__ == ""__main__"":
    f()"
567,A,Lineland Mail,PROGRAMMING,"['greedy', 'implementation']","All cities of Lineland are located on the *Ox* coordinate axis. Thus, each city is associated with its position *x**i* — a coordinate on the *Ox* axis. No two cities are located at a single point.

Lineland residents love to send letters to each other. A person may send a letter only if the recipient lives in another city (because if they live in the same city, then it is easier to drop in).

Strange but true, the cost of sending the letter is exactly equal to the distance between the sender's city and the recipient's city.

For each city calculate two values ​​*min**i* and *max**i*, where *min**i* is the minimum cost of sending a letter from the *i*-th city to some other city, and *max**i* is the the maximum cost of sending a letter from the *i*-th city to some other city","The first line of the input contains integer *n* (2<=≤<=*n*<=≤<=105) — the number of cities in Lineland. The second line contains the sequence of *n* distinct integers *x*1,<=*x*2,<=...,<=*x**n* (<=-<=109<=≤<=*x**i*<=≤<=109), where *x**i* is the *x*-coordinate of the *i*-th city. All the *x**i*'s are distinct and follow in ascending order.","Print *n* lines, the *i*-th line must contain two integers *min**i*,<=*max**i*, separated by a space, where *min**i* is the minimum cost of sending a letter from the *i*-th city, and *max**i* is the maximum cost of sending a letter from the *i*-th city.","['4\n-5 -2 2 7\n', '2\n-1 1\n']","['3 12\n3 9\n4 7\n5 12\n', '2 2\n2 2\n']",none,RUNTIME_ERROR,"import i
import p
import f

from PyQt5 import s
from PyQt5.QtWidgets import *

r = '''<?xml version=""1.0"" encoding=""UTF-8""?>
<ui version=""4.0"">
 <class>MainWindow</class>
 <widget class=""QMainWindow"" name=""MainWindow"">
  <property name=""geometry"">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>564</width>
    <height>455</height>
   </rect>
  </property>
  <property name=""windowTitle"">
   <string>Интерактивный чек</string>
  </property>
  <widget class=""QWidget"" name=""centralwidget"">
   <widget class=""QTableWidget"" name=""tableWidget"">
    <property name=""geometry"">
     <rect>
      <x>10</x>
      <y>10</y>
      <width>541</width>
      <height>391</height>
     </rect>
    </property>
    <property name=""sizePolicy"">
     <sizepolicy hsizetype=""Expanding"" vsizetype=""Expanding"">
      <horstretch>0</horstretch>
      <verstretch>0</verstretch>
     </sizepolicy>
    </property>
   </widget>
   <widget class=""QLineEdit"" name=""lineEdit"">
    <property name=""enabled"">
     <bool>false</bool>
    </property>
    <property name=""geometry"">
     <rect>
      <x>250</x>
      <y>410</y>
      <width>291</width>
      <height>22</height>
     </rect>
    </property>
   </widget>
   <widget class=""QLabel"" name=""label"">
    <property name=""geometry"">
     <rect>
      <x>200</x>
      <y>410</y>
      <width>91</width>
      <height>16</height>
     </rect>
    </property>
    <property name=""text"">
     <string>Итого :</string>
    </property>
   </widget>
  </widget>
 </widget>
 <resources/>
 <connections/>
</ui>
'''

class d(b):
    def __init__(o):
        super(d, o).__init__()
        f = i.StringIO(r)
        s.loadUi(f, o)
        o.j()

    def j(o):
        with open('price.csv', encoding='utf-8') as g:
            l = f.l(g, delimiter=';', quotechar='""')
            q = next(l)
            q += ['Количество']
            o.tableWidget.setColumnCount(len(q))
            o.tableWidget.setHorizontalHeaderLabels(q)
            o.tableWidget.setRowCount(0)

            for i, n in enumerate(l):
                o.tableWidget.setRowCount(o.tableWidget.rowCount() + 1)
                for j, h in enumerate(n):
                    if not j:
                        h += ' ' * 70
                    o.tableWidget.setItem(i, j, c(h))
                    o.tableWidget.setItem(i, j + 1, c('0'))
            o.tableWidget.resizeColumnsToContents()
            o.tableWidget.itemChanged.connect(o.k)

    def k(o):
        try:
            m = 0
            for i in range(o.tableWidget.rowCount()):
                t = o.tableWidget.item(i, 2).text()
                if int(t) >= 1:
                    m += int(t) * int(o.tableWidget.item(i, 1).text())
            o.lineEdit.setText(str(m))
        except:
            o.lineEdit.setText('Ошибка')

if __name__ == '__main__':
    e = a(p.argv)
    u = d()
    u.show()
    p.exit(e.exec())","a = 10**9+7

def j():
    import p
    e = p.stdin.read().split()
    if not e:
        return

    l = e[0].strip()
    h = int(e[1].strip())
    L = len(l)

    if h == 0:

        p.stdout.write(""1\n"")
        return

    k = {}
    def f(x):
        if x == 1:
            return 0
        if x in k:
            return k[x]
        c = bin(x).count(""1"")
        o = 1 + f(c)
        k[x] = o
        return o

    s = [False]*(L+1)
    for r in range(1, L+1):
        if f(r) == h - 1:
            s[r] = True

    g = [[[0 for _ in range(2)] for _ in range(L+1)] for _ in range(L+1)]
    g[0][0][1] = 1
    for i in range(L):
        for d in range(L+1):
            for q in range(2):
                if g[i][d][q] == 0:
                    continue
                i = int(l[i]) if q == 1 else 1
                for f in range(i + 1):
                    n = 1 if (q == 1 and f == i) else 0
                    m = d + (1 if f == 1 else 0)
                    g[i+1][m][n] = (g[i+1][m][n] + g[i][d][q]) % a

    r = [0]*(L+1)
    for r in range(L+1):
        r[r] = (g[L][r][0] + g[L][r][1]) % a

    r[0] = (r[0] - 1) % a

    b = 0
    for r in range(1, L+1):
        if s[r]:
            b = (b + r[r]) % a

    p.stdout.write(str(b % a) + ""\n"")

if __name__ == '__main__':
    j()"
255,A,Greg's Workout,PROGRAMMING,['implementation'],"Greg is a beginner bodybuilder. Today the gym coach gave him the training plan. All it had was *n* integers *a*1,<=*a*2,<=...,<=*a**n*. These numbers mean that Greg needs to do exactly *n* exercises today. Besides, Greg should repeat the *i*-th in order exercise *a**i* times.

Greg now only does three types of exercises: ""chest"" exercises, ""biceps"" exercises and ""back"" exercises. Besides, his training is cyclic, that is, the first exercise he does is a ""chest"" one, the second one is ""biceps"", the third one is ""back"", the fourth one is ""chest"", the fifth one is ""biceps"", and so on to the *n*-th exercise.

Now Greg wonders, which muscle will get the most exercise during his training. We know that the exercise Greg repeats the maximum number of times, trains the corresponding muscle the most. Help Greg, determine which muscle will get the most training.","The first line contains integer *n* (1<=≤<=*n*<=≤<=20). The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=25) — the number of times Greg repeats the exercises.","Print word ""chest"" (without the quotes), if the chest gets the most exercise, ""biceps"" (without the quotes), if the biceps gets the most exercise and print ""back"" (without the quotes) if the back gets the most exercise.

It is guaranteed that the input is such that the answer to the problem is unambiguous.","['2\n2 8\n', '3\n5 1 10\n', '7\n3 3 2 7 9 6 8\n']","['biceps\n', 'back\n', 'chest\n']","In the first sample Greg does 2 chest, 8 biceps and zero back exercises, so the biceps gets the most exercises.

In the second sample Greg does 5 chest, 1 biceps and 10 back exercises, so the back gets the most exercises.

In the third sample Greg does 18 chest, 12 biceps and 8 back exercises, so the chest gets the most exercise.",OK,"n = int(input())
s = [""c"", ""bi"", ""ba""]
d = {}
a = [0, 0, 0]
for b, i in enumerate(map(int, input().split())):
    d.setdefault(s[(b % 3)], [0])[0] += i
for i in d:
    if i == 'c':
        a[0] = d[i][0]
    elif i == 'bi':
        a[1] = d[i][0]
    else:
        a[2] = d[i][0]

if a[0] > a[1] and a[0] > a[2]:
    print(""chest"")
elif a[1] > a[0] and a[1] > a[2]:
    print(""biceps"")
else:
    print(""back"")","def m():
    import o
    from collections import h

    g = o.stdin.read().split()
    if not g:
        return
    l = iter(g)
    n = int(next(l))
    m = int(next(l))

    k = [set() for _ in range(n + 1)]
    for _ in range(m):
        u = int(next(l))
        v = int(next(l))
        k[u].add(v)
        k[v].add(u)

    B = set()
    R = set()
    for v in range(1, n + 1):
        if len(k[v]) == n - 1:
            B.add(v)
        else:
            R.add(v)

    b = R
    e = {}

    for v in list(b):
        if v in e:
            continue
        e[v] = 0
        i = h([v])
        while i:
            f = i.popleft()

            a = b - k[f] - {f}
            for n in a:
                if n not in e:
                    e[n] = 1 - e[f]
                    i.append(n)
                else:
                    if e[n] == e[f]:

                        print(""No"")
                        return

    s = [''] * (n + 1)
    for v in range(1, n + 1):
        if v in B:
            s[v] = 'b'
        else:
            s[v] = 'a' if e[v] == 0 else 'c'

    d = set(range(1, n + 1))
    A = set(v for v in range(1, n + 1) if s[v] == 'a')
    C = set(v for v in range(1, n + 1) if s[v] == 'c')
    for v in range(1, n + 1):
        j = set()
        if s[v] == 'a':
            j = C.copy()
        elif s[v] == 'c':
            j = A.copy()

        c = (d - k[v]) - {v}
        if j != c:
            print(""No"")
            return

    o.stdout.write(""Yes\n"" + """".join(s[1:]) + ""\n"")

if __name__ == '__main__':
    m()"
608,B,Hamming Distance Sum,PROGRAMMING,"['combinatorics', 'strings']","Genos needs your help. He was asked to solve the following programming problem by Saitama:

The length of some string *s* is denoted |*s*|. The Hamming distance between two strings *s* and *t* of equal length is defined as , where *s**i* is the *i*-th character of *s* and *t**i* is the *i*-th character of *t*. For example, the Hamming distance between string ""0011"" and string ""0110"" is |0<=-<=0|<=+<=|0<=-<=1|<=+<=|1<=-<=1|<=+<=|1<=-<=0|<==<=0<=+<=1<=+<=0<=+<=1<==<=2.

Given two binary strings *a* and *b*, find the sum of the Hamming distances between *a* and all contiguous substrings of *b* of length |*a*|.","The first line of the input contains binary string *a* (1<=≤<=|*a*|<=≤<=200<=000).

The second line of the input contains binary string *b* (|*a*|<=≤<=|*b*|<=≤<=200<=000).

Both strings are guaranteed to consist of characters '0' and '1' only.",Print a single integer — the sum of Hamming distances between *a* and all contiguous substrings of *b* of length |*a*|.,"['01\n00111\n', '0011\n0110\n']","['3\n', '2\n']","For the first sample case, there are four contiguous substrings of *b* of length |*a*|: ""00"", ""01"", ""11"", and ""11"". The distance between ""01"" and ""00"" is |0 - 0| + |1 - 0| = 1. The distance between ""01"" and ""01"" is |0 - 0| + |1 - 1| = 0. The distance between ""01"" and ""11"" is |0 - 1| + |1 - 1| = 1. Last distance counts twice, as there are two occurrences of string ""11"". The sum of these edit distances is 1 + 0 + 1 + 1 = 3.

The second sample case is described in the statement.",TIME_LIMIT_EXCEEDED,"def c(a, b):
    sum = 0
    for i in range(len(a)):
        c = int(a[i])-int(b[i])
        if c < 0:
            c = -c
        sum += c
    return sum

a = input()
b = input()
d = 0

for i in range(len(b) - len(a) + 1):
    d += c(a, b[i:i+len(a)])

print(d)","import p

def j():
    f = p.stdin.read().split()
    if not f:
        return

    n = int(f[0])
    k = int(f[1])
    t = f[2].strip() if len(f) >= 3 else """"
    m = len(t)
    r = m + n
    l = 10**9 + 7

    g = [0] * (r + 1)
    g[0] = 1

    i = {}

    m = {}

    for i in range(1, m + 1):
        d = t[i-1]
        n = g[i-1]
        if d in i:
            g[i] = (n * 2 - i[d]) % l
        else:
            g[i] = (n * 2) % l

        i[d] = n
        m[d] = i - 1

    e = m

    a = [chr(ord('a') + i) for i in range(k)]

    k = []
    for d in a:
        if d not in i:
            k.append(d)

    h = n

    for d in k:
        if h <= 0:
            break
        e += 1
        g[e] = (g[e-1] * 2) % l
        i[d] = g[e-1]
        m[d] = e - 1
        h -= 1

    while h > 0:
        b = None
        c = None
        for d in a:

            q = m[d]
            if c is None or q < c:
                c = q
                b = d

        o = i[b]
        e += 1
        g[e] = (g[e-1] * 2 - o) % l
        i[b] = g[e-1]
        m[b] = e - 1
        h -= 1

    p.stdout.write(str(g[r] % l) + ""\n"")

if __name__ == '__main__':
    j()"
180,C,Letter,PROGRAMMING,['dp'],"Patrick has just finished writing a message to his sweetheart Stacey when he noticed that the message didn't look fancy. Patrick was nervous while writing the message, so some of the letters there were lowercase and some of them were uppercase.

Patrick believes that a message is fancy if any uppercase letter stands to the left of any lowercase one. In other words, this rule describes the strings where first go zero or more uppercase letters, and then — zero or more lowercase letters.

To make the message fancy, Patrick can erase some letter and add the same letter in the same place in the opposite case (that is, he can replace an uppercase letter with the lowercase one and vice versa). Patrick got interested in the following question: what minimum number of actions do we need to make a message fancy? Changing a letter's case in the message counts as one action. Patrick cannot perform any other actions.",The only line of the input contains a non-empty string consisting of uppercase and lowercase letters. The string's length does not exceed 105.,Print a single number — the least number of actions needed to make the message fancy.,"['PRuvetSTAaYA\n', 'OYPROSTIYAOPECHATALSYAPRIVETSTASYA\n', 'helloworld\n']","['5\n', '0\n', '0\n']",none,OK,"def c(q: str) -> int:
    w = len(q)
    b = [0] * (w + 1)
    d = [0] * (w + 1)
    for n in range(1, w + 1):
        b[n] = b[n - 1] + q[n - 1].islower()
        d[n] = d[n - 1] + q[n - 1].isupper()
    a = float('inf')
    for n in range(w + 1):
        a = min(a, b[n] + d[w] - d[n])
    return a

a = input()
print(c(a))","def h():
    import k
    from collections import a

    f = k.stdin.read().split()
    if not f:
        return

    n = int(f[0])
    m = []
    n = []
    j = []
    g = 1

    for _ in range(n):
        x = int(f[g])
        y = int(f[g + 1])
        g += 2
        m.append(x)
        n.append(y)
        j.append((x, y))

    b = a(m)

    d = a(n)

    c = a(j)

    def i(e):
        return e * (e - 1) // 2
    
    l = 0

    for e in b.values():
        l += i(e)

    for e in d.values():
        l += i(e)

    for e in c.values():
        l -= i(e)

    k.stdout.write(str(l))

if __name__ == '__main__':
    h()"
794,A,Bank Robbery,PROGRAMMING,"['brute force', 'implementation']","A robber has attempted to rob a bank but failed to complete his task. However, he had managed to open all the safes.

Oleg the bank client loves money (who doesn't), and decides to take advantage of this failed robbery and steal some money from the safes. There are many safes arranged in a line, where the *i*-th safe from the left is called safe *i*. There are *n* banknotes left in all the safes in total. The *i*-th banknote is in safe *x**i*. Oleg is now at safe *a*. There are two security guards, one of which guards the safe *b* such that *b*<=&lt;<=*a*, i.e. the first guard is to the left of Oleg. The other guard guards the safe *c* so that *c*<=&gt;<=*a*, i.e. he is to the right of Oleg.

The two guards are very lazy, so they do not move. In every second, Oleg can either take all the banknotes from the current safe or move to any of the neighboring safes. However, he cannot visit any safe that is guarded by security guards at any time, becaues he might be charged for stealing. Determine the maximum amount of banknotes Oleg can gather.","The first line of input contains three space-separated integers, *a*, *b* and *c* (1<=≤<=*b*<=&lt;<=*a*<=&lt;<=*c*<=≤<=109), denoting the positions of Oleg, the first security guard and the second security guard, respectively.

The next line of input contains a single integer *n* (1<=≤<=*n*<=≤<=105), denoting the number of banknotes.

The next line of input contains *n* space-separated integers *x*1,<=*x*2,<=...,<=*x**n* (1<=≤<=*x**i*<=≤<=109), denoting that the *i*-th banknote is located in the *x**i*-th safe. Note that *x**i* are not guaranteed to be distinct.",Output a single integer: the maximum number of banknotes Oleg can take.,"['5 3 7\n8\n4 7 5 5 3 6 2 8\n', '6 5 7\n5\n1 5 7 92 3\n']","['4\n', '0\n']","In the first example Oleg can take the banknotes in positions 4, 5, 6 (note that there are 2 banknotes at position 5). Oleg can't take the banknotes in safes 7 and 8 because he can't run into the second security guard. Similarly, Oleg cannot take the banknotes at positions 3 and 2 because he can't run into the first security guard. Thus, he can take a maximum of 4 banknotes.

For the second sample, Oleg can't take any banknotes without bumping into any of the security guards.",TIME_LIMIT_EXCEEDED,"def h(c,i,d):
    e = c[0]
    c.remove(e)
    f = min(c)
    g = max(c)
    a=0
    if e<f:
        i=1
        while i<f:
            for x in d:
                if i==x:
                    a+=1
            i+=1
    elif e>f and e<g:
        i=f+1
        while i<g:
            for x in d:
                if i==x:
                    a+=1
            i+=1
    else:
        i=g+1
        while i<i:
            for x in d:
                if i==x:
                    a+=1
            i+=1
    return a
def b():
    c = [ int(x) for x in input().split() ]
    i = int(input())
    d = [ int(x) for x in input().split() ]
    print(h(c,i,d))
b()","def g():
    import m
    import b

    d = m.stdin.read().split()
    if not d:
        return
    n = int(d[0])
    a = list(map(int, d[1:]))

    a.sort()

    e = []
    k = -1
    for i in a:
        if i != k:
            e.append(i)
            k = i

    h = e[-1]
    a = 0

    for d in e:
        if d == h:
            continue

        f = h // d
        k = 1
        while k <= f:
            if k == 1:
                L = d + 1
                R = 2 * d - 1
            else:
                L = k * d
                R = k * d + d - 1
            if R > h:
                R = h
            if L > R:
                k += 1
                continue

            j = b.bisect_right(e, R)
            if j:
                c = e[j - 1]
                if c >= L:

                    l = c - k * d
                    if l > a:
                        a = l

                        if a == d - 1:
                            break
            k += 1

    m.stdout.write(str(a))

if __name__ == '__main__':
    g()"
997,A,Convert to Ones,PROGRAMMING,"['brute force', 'greedy', 'implementation', 'math']","You've got a string $a_1, a_2, \dots, a_n$, consisting of zeros and ones.

Let's call a sequence of consecutive elements $a_i, a_{i<=+<=1}, \ldots,<=a_j$ ($1\leq<=i\leq<=j\leq<=n$) a substring of string $a$. 

You can apply the following operations any number of times:
 -  Choose some substring of string $a$ (for example, you can choose entire string) and reverse it, paying $x$ coins for it (for example, «0101101» $\to$ «0111001»); -  Choose some substring of string $a$ (for example, you can choose entire string or just one symbol) and replace each symbol to the opposite one (zeros are replaced by ones, and ones — by zeros), paying $y$ coins for it (for example, «0101101» $\to$ «0110001»). 
You can apply these operations in any order. It is allowed to apply the operations multiple times to the same substring.

What is the minimum number of coins you need to spend to get a string consisting only of ones?","The first line of input contains integers $n$, $x$ and $y$ ($1<=\leq<=n<=\leq<=300\,000, 0 \leq x, y \leq 10^9$) — length of the string, cost of the first operation (substring reverse) and cost of the second operation (inverting all elements of substring).

The second line contains the string $a$ of length $n$, consisting of zeros and ones.","Print a single integer — the minimum total cost of operations you need to spend to get a string consisting only of ones. Print $0$, if you do not need to perform any operations.","['5 1 10\n01000\n', '5 10 1\n01000\n', '7 2 3\n1111111\n']","['11\n', '2\n', '0\n']","In the first sample, at first you need to reverse substring $[1 \dots 2]$, and then you need to invert substring $[2 \dots 5]$. 

Then the string was changed as follows:

«01000» $\to$ «10000» $\to$ «11111».

The total cost of operations is $1 + 10 = 11$.

In the second sample, at first you need to invert substring $[1 \dots 1]$, and then you need to invert substring $[3 \dots 5]$. 

Then the string was changed as follows:

«01000» $\to$ «11000» $\to$ «11111».

The overall cost is $1 + 1 = 2$.

In the third example, string already consists only of ones, so the answer is $0$.",OK,"import math
import sys
import queue

def c():
    n, x, y = map(int, input().split())
    s = str(input())

    d = 1
    e = int(s[0] == ""0"")
    for i in range(1, n):
        if s[i] != s[i - 1]:
            d += 1
            if s[i] == ""0"":
                e += 1

    b = 0

    if d == 1:
        if s[0] == ""0"":
            b = y
        else:
            b = 0
    elif d == 2:
        b = y
    else:
        if s[0] == ""0"":
            b = ((d - 1) // 2 * x + y)
        else:
            if d == 3:
                b = (x + y)
            else:
                b = ((d - 2) // 2 * x + y)

    b = min(b, e * y)
    print(b)

if __name__ == '__main__':
    a = 0

    if a:
        t = int(input())
        for _ in range(t):
            c()
    else:
        c()","def g():
    import i

    f = i.stdin.read().strip().split()
    if not f:
        return

    n = int(f[0])
    m = int(f[1])

    d = [set() for _ in range(n + 1)]

    c = [0] * (n + 1)

    e = 2
    for _ in range(m):
        a = int(f[e])
        b = int(f[e + 1])
        e += 2

        d[a].add(b)
        d[b].add(a)
        c[a] += 1
        c[b] += 1

    h = float('inf')

    for i in range(1, n + 1):

        for j in d[i]:
            if j > i:

                a = d[i].intersection(d[j])

                for k in a:
                    if k > j:

                        b = (c[i] - 2) + (c[j] - 2) + (c[k] - 2)
                        h = min(h, b)

    print(h if h != float('inf') else -1)
    
if __name__ == '__main__':
    g()"
772,A,Voltage Keepsake,PROGRAMMING,"['binary search', 'math']","You have *n* devices that you want to use simultaneously.

The *i*-th device uses *a**i* units of power per second. This usage is continuous. That is, in λ seconds, the device will use λ·*a**i* units of power. The *i*-th device currently has *b**i* units of power stored. All devices can store an arbitrary amount of power.

You have a single charger that can plug to any single device. The charger will add *p* units of power per second to a device. This charging is continuous. That is, if you plug in a device for λ seconds, it will gain λ·*p* units of power. You can switch which device is charging at any arbitrary unit of time (including real numbers), and the time it takes to switch is negligible.

You are wondering, what is the maximum amount of time you can use the devices until one of them hits 0 units of power.

If you can use the devices indefinitely, print -1. Otherwise, print the maximum amount of time before any one device hits 0 power.","The first line contains two integers, *n* and *p* (1<=≤<=*n*<=≤<=100<=000, 1<=≤<=*p*<=≤<=109) — the number of devices and the power of the charger.

This is followed by *n* lines which contain two integers each. Line *i* contains the integers *a**i* and *b**i* (1<=≤<=*a**i*,<=*b**i*<=≤<=100<=000) — the power of the device and the amount of power stored in the device in the beginning.","If you can use the devices indefinitely, print -1. Otherwise, print the maximum amount of time before any one device hits 0 power.

Your answer will be considered correct if its absolute or relative error does not exceed 10<=-<=4.

Namely, let's assume that your answer is *a* and the answer of the jury is *b*. The checker program will consider your answer correct if .","['2 1\n2 2\n2 1000\n', '1 100\n1 1\n', '3 5\n4 3\n5 2\n6 1\n']","['2.0000000000', '-1\n', '0.5000000000']","In sample test 1, you can charge the first device for the entire time until it hits zero power. The second device has enough power to last this time without being charged.

In sample test 2, you can use the device indefinitely.

In sample test 3, we can charge the third device for 2 / 5 of a second, then switch to charge the second device for a 1 / 10 of a second.",WRONG_ANSWER,"def a(n, p, b):
    d = 0.0
    c = float(""inf"")

    while c - d > 1e-6:
        e = (d + c) / 2.0
        h = 0

        for a, b in b:
            f = max(0, e * a - b)
            h += f

        if h > e * p:
            c = e
        else:
            d = e

    if d == float(""inf""):
        return -1
    return d

n, p = map(int, input().split())
b = []

for _ in range(n):
    a, b = map(int, input().split())
    b.append((a, b))

g = a(n, p, b)
print(""{:.9f}"".format(g))","def c():
    import f

    b = f.stdin.read().split()
    if not b:
        return
    n = int(b[0])
    g = b[1:]

    d = 1
    h = 0

    for t in g:

        if t == ""0"":
            f.stdout.write(""0"")
            return

        if t[0] == '1' and all(a == '0' for a in t[1:]):

            h += len(t) - 1
        else:

            d *= int(t)

    e = str(d) + (""0"" * h)
    f.stdout.write(e)

if __name__ == '__main__':
    c()"
363,B,Fence,PROGRAMMING,"['brute force', 'dp']","There is a fence in front of Polycarpus's home. The fence consists of *n* planks of the same width which go one after another from left to right. The height of the *i*-th plank is *h**i* meters, distinct planks can have distinct heights.

Polycarpus has bought a posh piano and is thinking about how to get it into the house. In order to carry out his plan, he needs to take exactly *k* consecutive planks from the fence. Higher planks are harder to tear off the fence, so Polycarpus wants to find such *k* consecutive planks that the sum of their heights is minimal possible.

Write the program that finds the indexes of *k* consecutive planks with minimal total height. Pay attention, the fence is not around Polycarpus's home, it is in front of home (in other words, the fence isn't cyclic).","The first line of the input contains integers *n* and *k* (1<=≤<=*n*<=≤<=1.5·105,<=1<=≤<=*k*<=≤<=*n*) — the number of planks in the fence and the width of the hole for the piano. The second line contains the sequence of integers *h*1,<=*h*2,<=...,<=*h**n* (1<=≤<=*h**i*<=≤<=100), where *h**i* is the height of the *i*-th plank of the fence.","Print such integer *j* that the sum of the heights of planks *j*, *j*<=+<=1, ..., *j*<=+<=*k*<=-<=1 is the minimum possible. If there are multiple such *j*'s, print any of them.",['7 3\n1 2 6 1 1 7 1\n'],['3\n'],"In the sample, your task is to find three consecutive planks with the minimum sum of heights. In the given case three planks with indexes 3, 4 and 5 have the required attribute, their total height is 8.",RUNTIME_ERROR,"def c() -> list[int]:
    return [int(n) for n in input().split()]

n, k = c()
j = c()

b = None
a = None

for a in range(n - k + 1):
    s = 0
    for b in range(k):
        s += j[a + b]
    if b is None or s < b:
        b = s
        a = a +1
print(a)","import m
m.setrecursionlimit(10**6)

def i():
    import m

    d = m.stdin.read().strip().split()
    if not d:
        return
    n = int(d[0])
    m = int(d[1])

    a = list(map(int, d[2:2+n]))

    f = [[] for _ in range(n)]
    g = 2 + n
    for _ in range(n - 1):
        u = int(d[g]) - 1
        v = int(d[g+1]) - 1
        f[u].append(v)
        f[v].append(u)
        g += 2

    l = 0

    def e(j, k, c):
        nonlocal l, m

        if a[j] == 1:
            c += 1
        else:
            c = 0

        if c > m:
            return

        h = True
        for b in f[j]:
            if b != k:
                h = False
                e(b, j, c)

        if h:
            l += 1

    e(0, -1, 0)
    print(l)

if __name__ == ""__main__"":
    i()"
834,B,The Festive Evening,PROGRAMMING,"['data structures', 'implementation']","It's the end of July – the time when a festive evening is held at Jelly Castle! Guests from all over the kingdom gather here to discuss new trends in the world of confectionery. Yet some of the things discussed here are not supposed to be disclosed to the general public: the information can cause discord in the kingdom of Sweetland in case it turns out to reach the wrong hands. So it's a necessity to not let any uninvited guests in.

There are 26 entrances in Jelly Castle, enumerated with uppercase English letters from A to Z. Because of security measures, each guest is known to be assigned an entrance he should enter the castle through. The door of each entrance is opened right before the first guest's arrival and closed right after the arrival of the last guest that should enter the castle through this entrance. No two guests can enter the castle simultaneously.

For an entrance to be protected from possible intrusion, a candy guard should be assigned to it. There are *k* such guards in the castle, so if there are more than *k* opened doors, one of them is going to be left unguarded! Notice that a guard can't leave his post until the door he is assigned to is closed.

Slastyona had a suspicion that there could be uninvited guests at the evening. She knows the order in which the invited guests entered the castle, and wants you to help her check whether there was a moment when more than *k* doors were opened.","Two integers are given in the first string: the number of guests *n* and the number of guards *k* (1<=≤<=*n*<=≤<=106, 1<=≤<=*k*<=≤<=26).

In the second string, *n* uppercase English letters *s*1*s*2... *s**n* are given, where *s**i* is the entrance used by the *i*-th guest.","Output «YES» if at least one door was unguarded during some time, and «NO» otherwise.

You can output each letter in arbitrary case (upper or lower).","['5 1\nAABBB\n', '5 1\nABABB\n']","['NO\n', 'YES\n']","In the first sample case, the door A is opened right before the first guest's arrival and closed when the second guest enters the castle. The door B is opened right before the arrival of the third guest, and closed after the fifth one arrives. One guard can handle both doors, as the first one is closed before the second one is opened.

In the second sample case, the door B is opened before the second guest's arrival, but the only guard can't leave the door A unattended, as there is still one more guest that should enter the castle through this door.",WRONG_ANSWER,"def f(): return int(input())
def g(): return list(map(int, input().split()))
def h(): return list(input())
def d(a): return """".join(list(map(str, a)))
def e(a): return "" "".join(list(map(str, a)))

a = ""A B C D E F G H I J K L M N O P Q R S T U V W X Y Z"".split()

n, c = g()
s = h()
b = [0 for i in range(n)]
for k in range(26):
    for j in range(n):
        if(s[j] == a[k]):
            b[j] += 1
            break
    for j in range(1, n+1):
        if(s[-j] == a[k]):
            b[-j] -= 1
            break

for i in range(1, n):
    b[i] = b[i-1] + b[i]
print(""YES"" if max(b) > c else ""NO"")","def d():
    import i

    c = i.stdin.read().strip().split()

    n = int(c[0])

    f = list(map(int, c[1:n+1]))

    a = []
    g = []

    for b, e in enumerate(f):
        if e % 2 == 0:
            a.append(b)
        else:
            g.append(b)

    if len(a) == 1:
        h = a[0] + 1
    else:
        h = g[0] + 1

    i.stdout.write(str(h))

if __name__ == '__main__':
    d()"
776,C,Molly's Chemicals,PROGRAMMING,"['binary search', 'brute force', 'data structures', 'implementation', 'math']","Molly Hooper has *n* different kinds of chemicals arranged in a line. Each of the chemicals has an affection value, The *i*-th of them has affection value *a**i*.

Molly wants Sherlock to fall in love with her. She intends to do this by mixing a contiguous segment of chemicals together to make a love potion with total affection value as a non-negative integer power of *k*. Total affection value of a continuous segment of chemicals is the sum of affection values of each chemical in that segment.

Help her to do so in finding the total number of such segments.","The first line of input contains two integers, *n* and *k*, the number of chemicals and the number, such that the total affection value is a non-negative power of this number *k*. (1<=≤<=*n*<=≤<=105, 1<=≤<=|*k*|<=≤<=10).

Next line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (<=-<=109<=≤<=*a**i*<=≤<=109) — affection values of chemicals.",Output a single integer — the number of valid segments.,"['4 2\n2 2 2 2\n', '4 -3\n3 -6 -3 12\n']","['8\n', '3\n']","Do keep in mind that *k*<sup class=""upper-index"">0</sup> = 1.

In the first sample, Molly can get following different affection values: 
 - 2: segments [1, 1], [2, 2], [3, 3], [4, 4]; - 4: segments [1, 2], [2, 3], [3, 4]; - 6: segments [1, 3], [2, 4]; - 8: segments [1, 4]. 
Out of these, 2, 4 and 8 are powers of *k* = 2. Therefore, the answer is 8.

In the second sample, Molly can choose segments [1, 2], [3, 3], [3, 4].",TIME_LIMIT_EXCEEDED,"def d(v, a):
    c = {}
    c[0]=1
    e=0
    a=0
    for i in v:
        e+=i
        if a==1:
            if e-1 in c:
                a+=c[e-1]
            else:
                a+=0
                c[e-1]=0
        elif a==-1:
            if e-1 in c:
                a+=c[e-1]
            else:
                a+=0
                c[e-1]=0
            if e+1 in c:
                a+=c[e+1]
            else:
                a+=0
                c[e+1]=0
        else:
            b=1
            while True:
                if e-b in c:
                    a+=c[e-b]
                else:
                    c[e-b]=0
                b*=a
                if b>10**15 or -b>10**15:
                    break
        if e in c:
            c[e]+=1
        else:
            c[e]=1
    return a

n,a=map(int,input().split())
v=list(map(int,input().split()))
print(d(v,a))","from collections import b

N, M = map(int, input().split())

K = int(input())

j = [tuple(map(lambda x: int(x) - 1, input().split()[i:i+2])) for i in range(0, 2*K, 2)] if K > 0 else []

c = [[float('inf')] * M for _ in range(N)]
q = b()

for x, y in j:
    c[x][y] = 0
    q.append((x, y))

g = [(-1, 0), (1, 0), (0, -1), (0, 1)]

while q:
    x, y = q.popleft()
    for d, e in g:
        h, i = x + d, y + e

        if 0 <= h < N and 0 <= i < M:
            if c[h][i] > c[x][y] + 1:
                c[h][i] = c[x][y] + 1
                q.append((h, i))

f = -1
a = (0, 0)
for i in range(N):
    for j in range(M):
        if c[i][j] > f:
            f = c[i][j]
            a = (i, j)

print(a[0] + 1, a[1] + 1)"
102,B,Sum of Digits,PROGRAMMING,['implementation'],"Having watched the last Harry Potter film, little Gerald also decided to practice magic. He found in his father's magical book a spell that turns any number in the sum of its digits. At the moment Gerald learned that, he came across a number *n*. How many times can Gerald put a spell on it until the number becomes one-digit?",The first line contains the only integer *n* (0<=≤<=*n*<=≤<=10100000). It is guaranteed that *n* doesn't contain any leading zeroes.,Print the number of times a number can be replaced by the sum of its digits until it only contains one digit.,"['0\n', '10\n', '991\n']","['0\n', '1\n', '3\n']","In the first sample the number already is one-digit — Herald can't cast a spell.

The second test contains number 10. After one casting of a spell it becomes 1, and here the process is completed. Thus, Gerald can only cast the spell once.

The third test contains number 991. As one casts a spell the following transformations take place: 991 → 19 → 10 → 1. After three transformations the number becomes one-digit.",TIME_LIMIT_EXCEEDED,"def a(n):
    s = 0
    while(n):
        s += n%10
        n = n//10
    return s

n = int(input())
c = 0
while(n//10):
    c += 1
    n = a(n)

print(c)","import j
import c

def g():

    d = j.stdin.read().split()
    if not d:
        return

    n = int(d[0])
    b = []

    for i in range(n):
        a = int(d[2*i + 1])
        b = int(d[2*i + 2])
        b.append((a, b))

    b.sort(key=lambda x: x[0])
    i = [a for a, _ in b]

    e = [0] * n
    h = 0
    
    for i in range(n):
        a, b = b[i]

        f = c.bisect_left(i, a - b)

        if f == 0:
            e[i] = 1
        else:
            e[i] = e[f - 1] + 1

        if e[i] > h:
            h = e[i]

    a = n - h
    j.stdout.write(str(a))
    
if __name__ == '__main__':
    g()"
475,B,Strongly Connected City,PROGRAMMING,"['brute force', 'dfs and similar', 'graphs', 'implementation']","Imagine a city with *n* horizontal streets crossing *m* vertical streets, forming an (*n*<=-<=1)<=×<=(*m*<=-<=1) grid. In order to increase the traffic flow, mayor of the city has decided to make each street one way. This means in each horizontal street, the traffic moves only from west to east or only from east to west. Also, traffic moves only from north to south or only from south to north in each vertical street. It is possible to enter a horizontal street from a vertical street, or vice versa, at their intersection.

The mayor has received some street direction patterns. Your task is to check whether it is possible to reach any junction from any other junction in the proposed street direction pattern.","The first line of input contains two integers *n* and *m*, (2<=≤<=*n*,<=*m*<=≤<=20), denoting the number of horizontal streets and the number of vertical streets.

The second line contains a string of length *n*, made of characters '&lt;' and '&gt;', denoting direction of each horizontal street. If the *i*-th character is equal to '&lt;', the street is directed from east to west otherwise, the street is directed from west to east. Streets are listed in order from north to south.

The third line contains a string of length *m*, made of characters '^' and 'v', denoting direction of each vertical street. If the *i*-th character is equal to '^', the street is directed from south to north, otherwise the street is directed from north to south. Streets are listed in order from west to east.","If the given pattern meets the mayor's criteria, print a single line containing ""YES"", otherwise print a single line containing ""NO"".","['3 3\n&gt;&lt;&gt;\nv^v\n', '4 6\n&lt;&gt;&lt;&gt;\nv^v^v^\n']","['NO\n', 'YES\n']",The figure above shows street directions in the second sample test case.,OK,"n, m = map(int, input("""").split())
r = [ f  for f in input("""")]
l = [f for f in input("""")]

class a():
    def __init__(s, id):
        s.q, s.k = id
        s.children = []

    def b(s, h):
        s.children.append(h)

def c(p, q, k):
    if p == '>' and k < m-1:
        o[q][k].b((q ,k+1))
    elif p == '<' and k > 0:
        o[q][k].b((q, k-1))

def d(j, q, k):
    if j == '^' and q > 0:
        o[q][k].b((q-1, k))
    elif j == 'v'and q < n-1:
        o[q][k].b((q+1, k))

o = [[a((q, k)) for k in range(m)] for q in range(n)]
for q in range(n):
    p = r[q]
    for k in range(m):
        j = l[k]
        c(p, q, k)
        d(j, q, k)

def n(q, k, t):
    if t[q][k] == 'true':
        return
    else:
        t[q][k] ='true'
        for i, g in o[q][k].children:
            n(i, g, t)

    return

e = 'YES'

def m(e):
    for q in range(n):
        for k in range(m):
            t = [['false' for k in range(m)] for q in range(n)]
            n(q, k, t)
            for i in range(n):
                for j in range(m):
                    if t[i][j] == 'false':
                        e = 'NO'
                        return e

    return e
e = m(e)
print(e)","""""""
Mishka has 3 garlands.
When switched on, the i-th garland with period k_i and switched on at time x_i
will be lit exactly at times:
    x_i, x_i + k_i, x_i + 2*k_i, …
Mishka wants to choose x1, x2, x3 so that, after time T = max(x1,x2,x3),
every second t (t >= T) is covered by at least one garland.
This is equivalent to finding residues r1, r2, r3 (with r_i in [0, k_i))
such that the union of the sets:
    S1 = { t in Z : t ≡ r1 (mod k1) }
    S2 = { t in Z : t ≡ r2 (mod k2) }
    S3 = { t in Z : t ≡ r3 (mod k3) }
covers all integers.
Since we can shift time arbitrarily, we fix r1=0.
The eventual pattern (for t >= T) is periodic with period L = lcm(k1, k2, k3).
In one period there are exactly L/k_i values from garland i.
Thus by inclusion–exclusion the union covers all L residues if and only if:
    L/k1 + L/k2 + L/k3 – I12 – I13 – I23 + I123 = L,
where for example I12 is the number of t modulo L satisfying t ≡ 0 (mod k1)
and t ≡ r2 (mod k2). By the Chinese remainder theorem, such an intersection is
nonempty if and only if 0 ≡ r2 (mod gcd(k1, k2)), and then its size is L / lcm(k1, k2).
A similar reasoning applies to I13 and I23.
Finally, I123 = 1 if all three congruences are simultaneously consistent;
otherwise it is 0.
We try all possible choices of r2 (in [0, k2)) and r3 (in [0, k3)).
If any such pair leads to complete coverage of Z/L, we output ""YES"",
otherwise ""NO"".
""""""

import y
import v

def u():
    n = y.stdin.read().split()
    if not n:
        return
    r, s, t = map(int, n[:3])

    L = v.lcm(r, s, t)

    a = L // r
    b = L // s
    c = L // t

    h = (r * s) // v.gcd(r, s)
    i = (r * t) // v.gcd(r, t)
    j = (s * t) // v.gcd(s, t)
    c = L // h
    e = L // i
    g = L // j
    o = v.gcd(r, s)
    p = v.gcd(r, t)
    q = v.gcd(s, t)

    for w in range(s):

        k = (w % o == 0)
        for x in range(t):

            l = (x % p == 0)

            m = ((w % q) == (x % q))
            a = c if k else 0
            d = e if l else 0
            f = g if m else 0

            b = 1 if (k and l and m) else 0

            z = a + b + c - a - d - f + b
            if z == L:
                y.stdout.write(""YES\n"")
                return
    y.stdout.write(""NO\n"")

if __name__ == '__main__':
    u()"
102,B,Sum of Digits,PROGRAMMING,['implementation'],"Having watched the last Harry Potter film, little Gerald also decided to practice magic. He found in his father's magical book a spell that turns any number in the sum of its digits. At the moment Gerald learned that, he came across a number *n*. How many times can Gerald put a spell on it until the number becomes one-digit?",The first line contains the only integer *n* (0<=≤<=*n*<=≤<=10100000). It is guaranteed that *n* doesn't contain any leading zeroes.,Print the number of times a number can be replaced by the sum of its digits until it only contains one digit.,"['0\n', '10\n', '991\n']","['0\n', '1\n', '3\n']","In the first sample the number already is one-digit — Herald can't cast a spell.

The second test contains number 10. After one casting of a spell it becomes 1, and here the process is completed. Thus, Gerald can only cast the spell once.

The third test contains number 991. As one casts a spell the following transformations take place: 991 → 19 → 10 → 1. After three transformations the number becomes one-digit.",OK,"from collections import a
def c(s):
    c = a(s)
    d = 0
    for k in c:
        d += (ord(k)-ord('0'))*c[k]
    return str(d)

s = input()
b = 0
while(len(s)>=2):
    s = c(s)
    b+=1
print(b)","def d():
    import i

    c = i.stdin.read().split()

    b = 0
    n = int(c[b])
    b += 1
    f = list(map(int, c[b:b+n]))
    b += n
    m = int(c[b])
    b += 1
    h = list(map(int, c[b:b+m]))

    j = []

    for a in f:
        for b in h:

            if b % a == 0:
                g = b // a
                j.append(g)

    e = max(j)

    a = j.count(e)

    print(a)

if __name__ == ""__main__"":
    d()"
14,A,Letter,PROGRAMMING,['implementation'],"A boy Bob likes to draw. Not long ago he bought a rectangular graph (checked) sheet with *n* rows and *m* columns. Bob shaded some of the squares on the sheet. Having seen his masterpiece, he decided to share it with his elder brother, who lives in Flatland. Now Bob has to send his picture by post, but because of the world economic crisis and high oil prices, he wants to send his creation, but to spend as little money as possible. For each sent square of paper (no matter whether it is shaded or not) Bob has to pay 3.14 burles. Please, help Bob cut out of his masterpiece a rectangle of the minimum cost, that will contain all the shaded squares. The rectangle's sides should be parallel to the sheet's sides.","The first line of the input data contains numbers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=50), *n* — amount of lines, and *m* — amount of columns on Bob's sheet. The following *n* lines contain *m* characters each. Character «.» stands for a non-shaded square on the sheet, and «*» — for a shaded square. It is guaranteed that Bob has shaded at least one square.",Output the required rectangle of the minimum cost. Study the output data in the sample tests to understand the output format better.,"['6 7\n.......\n..***..\n..*....\n..***..\n..*....\n..***..\n', '3 3\n***\n*.*\n***\n']","['***\n*..\n***\n*..\n***\n', '***\n*.*\n***\n']",none,OK,"def b():
    n, m = list(map(int, input().split()))
    a = []
    for _ in range(n):
        a.append(input())

    c, e, f, d = n, -1, -1, m
    for i in range(n):
        for j in range(m):
            if a[i][j] == ""*"":
                c = min(c, i)
                e = max(e, i)
                d = min(d, j)
                f = max(f, j)
    for i in range(c, e + 1):
        print(a[i][d : f + 1])

if __name__ == ""__main__"":
    b()","def c(n, k):
    """"""
    Simulate the process and return the total number of candies eaten by Vasya when k candies are eaten every morning.
    
    Parameters:
    n (int): Initial number of candies.
    k (int): Number of candies Vasya eats each morning.
    
    Returns:
    int: Total candies eaten by Vasya.
    """"""
    k = 0
    b = n
    while b > 0:

        d = min(k, b)
        k += d
        b -= d

        i = b // 10
        b -= i
    return k

def g():

    n = int(input().strip())

    j = (n + 1) // 2

    f, e = 1, n
    a = n
    while f <= e:
        h = (f + e) // 2
        if c(n, h) >= j:
            a = h
            e = h - 1
        else:
            f = h + 1

    print(a)

if __name__ == '__main__':
    g()"
686,A,Free Ice Cream,PROGRAMMING,"['constructive algorithms', 'implementation']","After their adventure with the magic mirror Kay and Gerda have returned home and sometimes give free ice cream to kids in the summer.

At the start of the day they have *x* ice cream packs. Since the ice cream is free, people start standing in the queue before Kay and Gerda's house even in the night. Each person in the queue wants either to take several ice cream packs for himself and his friends or to give several ice cream packs to Kay and Gerda (carriers that bring ice cream have to stand in the same queue).

If a carrier with *d* ice cream packs comes to the house, then Kay and Gerda take all his packs. If a child who wants to take *d* ice cream packs comes to the house, then Kay and Gerda will give him *d* packs if they have enough ice cream, otherwise the child will get no ice cream at all and will leave in distress.

Kay wants to find the amount of ice cream they will have after all people will leave from the queue, and Gerda wants to find the number of distressed kids.","The first line contains two space-separated integers *n* and *x* (1<=≤<=*n*<=≤<=1000, 0<=≤<=*x*<=≤<=109).

Each of the next *n* lines contains a character '+' or '-', and an integer *d**i*, separated by a space (1<=≤<=*d**i*<=≤<=109). Record ""+ *d**i*"" in *i*-th line means that a carrier with *d**i* ice cream packs occupies *i*-th place from the start of the queue, and record ""- *d**i*"" means that a child who wants to take *d**i* packs stands in *i*-th place.","Print two space-separated integers — number of ice cream packs left after all operations, and number of kids that left the house in distress.","['5 7\n+ 5\n- 10\n- 20\n+ 40\n- 20\n', '5 17\n- 16\n- 2\n- 98\n+ 100\n- 98\n']","['22 1\n', '3 2\n']","Consider the first sample.
 1.  Initially Kay and Gerda have 7 packs of ice cream. 1.  Carrier brings 5 more, so now they have 12 packs. 1.  A kid asks for 10 packs and receives them. There are only 2 packs remaining. 1.  Another kid asks for 20 packs. Kay and Gerda do not have them, so the kid goes away distressed. 1.  Carrier bring 40 packs, now Kay and Gerda have 42 packs. 1.  Kid asks for 20 packs and receives them. There are 22 packs remaining.",OK,"def b():

    n,c = map(int,input().split())

    d = 0
    for _ in range(n):
        e,a = input().split()
        a = int(a)

        if e == '+':
            c += a
        else:
            if a > c:
                d += 1
            else:
                c -= a

    print(c,d)

b()","n = int(input().strip())
d = list(map(int, input().strip().split()))

a = sum(1 for c in d[:3] if c % 2 == 0)

b = a >= 2

for i, c in enumerate(d):
    if (c % 2 == 0) != b:
        print(i + 1)
        break"
1006,C,Three Parts of the Array,PROGRAMMING,"['binary search', 'data structures', 'two pointers']","You are given an array $d_1, d_2, \dots, d_n$ consisting of $n$ integer numbers.

Your task is to split this array into three parts (some of which may be empty) in such a way that each element of the array belongs to exactly one of the three parts, and each of the parts forms a consecutive contiguous subsegment (possibly, empty) of the original array. 

Let the sum of elements of the first part be $sum_1$, the sum of elements of the second part be $sum_2$ and the sum of elements of the third part be $sum_3$. Among all possible ways to split the array you have to choose a way such that $sum_1 = sum_3$ and $sum_1$ is maximum possible.

More formally, if the first part of the array contains $a$ elements, the second part of the array contains $b$ elements and the third part contains $c$ elements, then:

$$sum_1 = \sum\limits_{1 \le i \le a}d_i,$$ $$sum_2 = \sum\limits_{a + 1 \le i \le a + b}d_i,$$ $$sum_3 = \sum\limits_{a + b + 1 \le i \le a + b + c}d_i.$$

The sum of an empty array is $0$.

Your task is to find a way to split the array such that $sum_1 = sum_3$ and $sum_1$ is maximum possible.","The first line of the input contains one integer $n$ ($1 \le n \le 2 \cdot 10^5$) — the number of elements in the array $d$.

The second line of the input contains $n$ integers $d_1, d_2, \dots, d_n$ ($1 \le d_i \le 10^9$) — the elements of the array $d$.","Print a single integer — the maximum possible value of $sum_1$, considering that the condition $sum_1 = sum_3$ must be met.

Obviously, at least one valid way to split the array exists (use $a=c=0$ and $b=n$).","['5\n1 3 1 1 4\n', '5\n1 3 2 1 4\n', '3\n4 1 2\n']","['5\n', '4\n', '0\n']","In the first example there is only one possible splitting which maximizes $sum_1$: $[1, 3, 1], [~], [1, 4]$.

In the second example the only way to have $sum_1=4$ is: $[1, 3], [2, 1], [4]$.

In the third example there is only one way to split the array: $[~], [4, 1, 2], [~]$.",OK,"import math
def d (b, l, r, x):

    if r >= l:
 
        f = l + (r - l) // 2

        if b[f] == x:
            return f

        elif b[f] > x:
            return d(b, l, f-1, x)

        else:
            return d(b, f + 1, r, x)
 
    else:

        return -1

n=int(input())
b=list(map(int,input().split()))
i=-1
s=0
c=[0]
while i>-n:
    s+=b[i]
    c.append(s)
    i-=1
i=0
s=0
e=[0]
while i<n-1:
    s+=b[i]
    e.append(s)
    i+=1
a=0
for i in range(n):
    if d(c,0,n-1,e[i])!=-1 and d(c,0,n-1,e[i])+i<=n:
        a=e[i]
print(a)","def c():
    import f

    s = f.stdin.readline().strip()
    n = len(s)

    b = [0] * n
    d = 0
    a = 0
    
    for i in range(1, n):
        if s[i] == ')':

            if s[i-1] == '(':
                b[i] = (b[i-2] if i >= 2 else 0) + 2

            else:

                e = i - b[i-1] - 1
                if e >= 0 and s[e] == '(':
                    b[i] = b[i-1] + 2 + (b[e-1] if e >= 1 else 0)

            if b[i] > d:
                d = b[i]
                a = 1
            elif b[i] == d and b[i] != 0:
                a += 1

    if d == 0:
        f.stdout.write(""0 1"")
    else:
        f.stdout.write(f""{d} {a}"")

if __name__ == '__main__':
    c()"
755,B,PolandBall and Game,PROGRAMMING,"['binary search', 'data structures', 'games', 'greedy', 'sortings', 'strings']","PolandBall is playing a game with EnemyBall. The rules are simple. Players have to say words in turns. You cannot say a word which was already said. PolandBall starts. The Ball which can't say a new word loses.

You're given two lists of words familiar to PolandBall and EnemyBall. Can you determine who wins the game, if both play optimally?","The first input line contains two integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=103) — number of words PolandBall and EnemyBall know, respectively.

Then *n* strings follow, one per line — words familiar to PolandBall.

Then *m* strings follow, one per line — words familiar to EnemyBall.

Note that one Ball cannot know a word more than once (strings are unique), but some words can be known by both players.

Each word is non-empty and consists of no more than 500 lowercase English alphabet letters.","In a single line of print the answer — ""YES"" if PolandBall wins and ""NO"" otherwise. Both Balls play optimally.","['5 1\npolandball\nis\na\ncool\ncharacter\nnope\n', '2 2\nkremowka\nwadowicka\nkremowka\nwiedenska\n', '1 2\na\na\nb\n']","['YES', 'YES', 'NO']","In the first example PolandBall knows much more words and wins effortlessly.

In the second example if PolandBall says kremowka first, then EnemyBall cannot use that word anymore. EnemyBall can only say wiedenska. PolandBall says wadowicka and wins.",RUNTIME_ERROR,"from collections import a
def f(e, b):
    n = len(e)
    m = len(b)
    if n < m:
        print(""NO"")
        return
    if n > m:
        print(""YES"")
        return
    d = a(int)

    for g in e:
        d[g] += 1
    for g in b:
        d[g] += 1

    d = [g for g in d if d[g] == 2]
    
    for c, g in enumerate(d):
        if c % 2 == 0:
            b.remove(g)
        else:
            e.remove(g)

    if len(e) > len(b):
        print(""YES"")
    else:
        print(""NO"")
    return 

if __name__ == '__main__':
    b = set()
    n, m = list(map(lambda x: int(x), input().split()))

    e = {input() for _ in range(n)}
    b = {input() for _ in range(n)}
    f(e, b)","import e
import h

def c(f):

    a = 8 * f + 1

    g = e.isqrt(a)

    if g * g == a:

        return g % 2 == 1
    return False

def d():

    b = h.stdin.read().split()

    for i in b:
        try:
            f = int(i)
        except ValueError:
            continue

        print(""YES"" if c(f) else ""NO"")

if __name__ == '__main__':
    d()"
279,B,Books,PROGRAMMING,"['binary search', 'brute force', 'implementation', 'two pointers']","When Valera has got some free time, he goes to the library to read some books. Today he's got *t* free minutes to read. That's why Valera took *n* books in the library and for each book he estimated the time he is going to need to read it. Let's number the books by integers from 1 to *n*. Valera needs *a**i* minutes to read the *i*-th book.

Valera decided to choose an arbitrary book with number *i* and read the books one by one, starting from this book. In other words, he will first read book number *i*, then book number *i*<=+<=1, then book number *i*<=+<=2 and so on. He continues the process until he either runs out of the free time or finishes reading the *n*-th book. Valera reads each book up to the end, that is, he doesn't start reading the book if he doesn't have enough free time to finish reading it. 

Print the maximum number of books Valera can read.","The first line contains two integers *n* and *t* (1<=≤<=*n*<=≤<=105; 1<=≤<=*t*<=≤<=109) — the number of books and the number of free minutes Valera's got. The second line contains a sequence of *n* integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=104), where number *a**i* shows the number of minutes that the boy needs to read the *i*-th book.",Print a single integer — the maximum number of books Valera can read.,"['4 5\n3 1 2 1\n', '3 3\n2 2 3\n']","['3\n', '1\n']",none,WRONG_ANSWER,"def d():
    N, M = map(int, input().split())
    b = list(map(int, input().split()))

    e = 0
    a = 0
    c = 0

    for f in range(N):
        a += b[f]

        while a > M:
            a -= b[c]
            c += 1

        if a > e:
            e = a

    print(e)

if __name__ == ""__main__"":
    d()","s = input().strip()

c = ""hello""
b = 0

for a in s:
    if b < len(c) and a == c[b]:
        b += 1

    if b == len(c):
        break

if b == len(c):
    print(""YES"")
else:
    print(""NO"")"
962,C,Make a Square,PROGRAMMING,"['brute force', 'implementation', 'math']","You are given a positive integer $n$, written without leading zeroes (for example, the number 04 is incorrect). 

In one operation you can delete any digit of the given integer so that the result remains a positive integer without leading zeros.

Determine the minimum number of operations that you need to consistently apply to the given integer $n$ to make from it the square of some positive integer or report that it is impossible.

An integer $x$ is the square of some positive integer if and only if $x=y^2$ for some positive integer $y$.",The first line contains a single integer $n$ ($1 \le n \le 2 \cdot 10^{9}$). The number is given without leading zeroes.,"If it is impossible to make the square of some positive integer from $n$, print -1. In the other case, print the minimal number of operations required to do it.","['8314\n', '625\n', '333\n']","['2\n', '0\n', '-1\n']","In the first example we should delete from $8314$ the digits $3$ and $4$. After that $8314$ become equals to $81$, which is the square of the integer $9$.

In the second example the given $625$ is the square of the integer $25$, so you should not delete anything. 

In the third example it is impossible to make the square from $333$, so the answer is -1.",WRONG_ANSWER,"def d(c=None):
    if not c:
        return input().split()
    return list(map(c, input().split()))

def b(A, a):
    """""" Calculate the edit distance from A to a. """"""
    if len(A) < len(a):
        return -1

    if len(a) == 1:
        if a in A:
            return len(A) - 1
        else:
            return -1

    e = float('inf')
    for i, a in enumerate(A):
        if a == a[0]:
            d = b(A[i+1:], a[1:])
            if d != -1:
                e = min(e, d)

    return e

n = input()
e = float('inf')

for i in range(1, int(10**4.5)):
    s = str(i**2)
    d = b(n, s)
    if d != -1:
        e = min(e, d)

if e > 100:
    print(-1)
else:
    print(e)","import m
from collections import e

def h():

    d = m.stdin.read().split()
    if not d:
        return

    n = int(d[0])

    f = [[] for _ in range(n + 1)]

    g = 1
    for _ in range(n - 1):
        u = int(d[g])
        v = int(d[g + 1])
        f[u].append(v)
        f[v].append(u)
        g += 2

    a = [0] * (n + 1)
    k = e([1])
    a[1] = 1

    b, c = 0, 0
    
    while k:
        j = k.popleft()
        if a[j] == 1:
            b += 1
        else:
            c += 1
        
        for i in f[j]:
            if a[i] == 0:
                a[i] = -a[j]
                k.append(i)

    l = b * c - (n - 1)

    m.stdout.write(str(l) + ""\n"")

if __name__ == ""__main__"":
    h()"
1,A,Theatre Square,PROGRAMMING,['math'],"Theatre Square in the capital city of Berland has a rectangular shape with the size *n*<=×<=*m* meters. On the occasion of the city's anniversary, a decision was taken to pave the Square with square granite flagstones. Each flagstone is of the size *a*<=×<=*a*.

What is the least number of flagstones needed to pave the Square? It's allowed to cover the surface larger than the Theatre Square, but the Square has to be covered. It's not allowed to break the flagstones. The sides of flagstones should be parallel to the sides of the Square.","The input contains three positive integer numbers in the first line: *n*,<=<=*m* and *a* (1<=≤<=<=*n*,<=*m*,<=*a*<=≤<=109).",Write the needed number of flagstones.,['6 6 4\n'],['4\n'],none,OK,"import c

def a(n, m, a):
    b = c.ceil(n / a)
    e = c.ceil(m / a)
    d = b * e
    return d

n, m, a = map(int, input().split())
print(a(n, m, a))","import d

def b():

    a = d.stdin.read().strip().split()

    n = int(a[0])

    f = list(map(int, a[1:]))

    c = max(f)

    e = sum(c - w for w in f)

    print(e)

if __name__ == ""__main__"":
    b()"
331,C1,The Great Julya Calendar,PROGRAMMING,['dp'],"Yet another Armageddon is coming! This time the culprit is the Julya tribe calendar. 

The beavers in this tribe knew math very well. Smart Beaver, an archaeologist, got a sacred plate with a magic integer on it. The translation from Old Beaverish is as follows: 

""May the Great Beaver bless you! May your chacres open and may your third eye never turn blind from beholding the Truth! Take the magic number, subtract a digit from it (the digit must occur in the number) and get a new magic number. Repeat this operation until a magic number equals zero. The Earth will stand on Three Beavers for the time, equal to the number of subtractions you perform!""

Distinct subtraction sequences can obviously get you different number of operations. But the Smart Beaver is ready to face the worst and is asking you to count the minimum number of operations he needs to reduce the magic number to zero.","The single line contains the magic integer *n*, 0<=≤<=*n*.
 -  to get 20 points, you need to solve the problem with constraints: *n*<=≤<=106 (subproblem C1); -  to get 40 points, you need to solve the problem with constraints: *n*<=≤<=1012 (subproblems C1+C2); -  to get 100 points, you need to solve the problem with constraints: *n*<=≤<=1018 (subproblems C1+C2+C3).",Print a single integer — the minimum number of subtractions that turns the magic number to a zero.,['24\n'],['5'],In the first test sample the minimum number of operations can be reached by the following sequence of subtractions:,TIME_LIMIT_EXCEEDED,"n=int(input())
def c(x,d):
 a={i:0 for i in range(10)}
 m=d
 while m>0:
    d=m%10
    a[d]+=1
    m=m//10
 if a[x]!=0:
     return True
 return False
b=[999999 for _ in range(n+1)]
for j in range(1,10):
    if c(j,n):
        b[n-j]=1
for i in range(n,-1,-1):
    for k in range(1,10):

        if i+k<=n and c(k,i+k):
           b[i]=min(b[i],b[i+k]+1)
if b[0]==999999:
    print(0)
    exit(0)
print(b[0])","n = int(input().strip())

c = [4, 7, 44, 47, 74, 77, 444, 447, 474, 477, 744, 747, 774, 777]

a = any(n % b == 0 for b in c)

if a:
    print(""YES"")
else:
    print(""NO"")"
69,A,Young Physicist,PROGRAMMING,"['implementation', 'math']","A guy named Vasya attends the final grade of a high school. One day Vasya decided to watch a match of his favorite hockey team. And, as the boy loves hockey very much, even more than physics, he forgot to do the homework. Specifically, he forgot to complete his physics tasks. Next day the teacher got very angry at Vasya and decided to teach him a lesson. He gave the lazy student a seemingly easy task: You are given an idle body in space and the forces that affect it. The body can be considered as a material point with coordinates (0; 0; 0). Vasya had only to answer whether it is in equilibrium. ""Piece of cake"" — thought Vasya, we need only to check if the sum of all vectors is equal to 0. So, Vasya began to solve the problem. But later it turned out that there can be lots and lots of these forces, and Vasya can not cope without your help. Help him. Write a program that determines whether a body is idle or is moving by the given vectors of forces.","The first line contains a positive integer *n* (1<=≤<=*n*<=≤<=100), then follow *n* lines containing three integers each: the *x**i* coordinate, the *y**i* coordinate and the *z**i* coordinate of the force vector, applied to the body (<=-<=100<=≤<=*x**i*,<=*y**i*,<=*z**i*<=≤<=100).","Print the word ""YES"" if the body is in equilibrium, or the word ""NO"" if it is not.","['3\n4 1 7\n-2 4 -1\n1 -5 -3\n', '3\n3 -1 7\n-5 2 -4\n2 -1 -3\n']","['NO', 'YES']",none,OK,"import a
import e
from itertools import b, f

def d() -> None:
    """"""Main function""""""
    with a.input() as f:
        n = int(next(f))
        v = (0, 0, 0)
        for c in b(f, n):
            w = tuple(map(int, c.split()))
            v = tuple(f(e.add, zip(v, w)))
        print(""YES"" if v == (0, 0, 0) else ""NO"")

if __name__ == ""__main__"":
    d()","def a(s):

    if len(s) % 2 == 1:
        return s

    d = len(s) // 2
    c = a(s[:d])
    e = a(s[d:])

    if c < e:
        return c + e
    else:
        return e + c

if __name__ == ""__main__"":
    import h

    b = h.stdin.read().splitlines()
    if len(b) < 2:
        h.exit(0)
    
    f = b[0].strip()
    g = b[1].strip()

    if a(f) == a(g):
        h.stdout.write(""YES"")
    else:
        h.stdout.write(""NO"")"
4,A,Watermelon,PROGRAMMING,"['brute force', 'math']","One hot summer day Pete and his friend Billy decided to buy a watermelon. They chose the biggest and the ripest one, in their opinion. After that the watermelon was weighed, and the scales showed *w* kilos. They rushed home, dying of thirst, and decided to divide the berry, however they faced a hard problem.

Pete and Billy are great fans of even numbers, that's why they want to divide the watermelon in such a way that each of the two parts weighs even number of kilos, at the same time it is not obligatory that the parts are equal. The boys are extremely tired and want to start their meal as soon as possible, that's why you should help them and find out, if they can divide the watermelon in the way they want. For sure, each of them should get a part of positive weight.",The first (and the only) input line contains integer number *w* (1<=≤<=*w*<=≤<=100) — the weight of the watermelon bought by the boys.,"Print YES, if the boys can divide the watermelon into two parts, each of them weighing even number of kilos; and NO in the opposite case.",['8\n'],['YES\n'],"For example, the boys can divide the watermelon into two parts of 2 and 6 kilos respectively (another variant — two parts of 4 and 4 kilos).",WRONG_ANSWER,"def a(w):
    if w % 2 == 0 and w > 2:
        return ""YES""  
    else:
        return ""NO""

b = int(input(""Enter the weight of the watermelon: ""))

print(a(b))","import i

def c(n):

    if n < 1:
        return 0
    s = str(n)
    d = len(s)
    j = 0

    for e in range(1, d):
        if e == 1:
            j += 9
        else:

            j += 9 * (10 ** (e - 2))

    if d == 1:

        j += n
    else:
        for a in range(1, 10):

            b = a * (10 ** (d - 1)) + a
            if b > n:
                continue

            h = (n - b) // 10
            g = (10 ** (d - 2)) - 1
            k = min(h, g) + 1
            j += k
    return j

def f():

    d = i.stdin.read().strip().split()
    if len(d) < 2:
        return
    l = int(d[0])
    r = int(d[1])

    a = c(r) - c(l - 1)
    i.stdout.write(str(a))

if __name__ == '__main__':
    f()"
224,A,Parallelepiped,PROGRAMMING,"['brute force', 'geometry', 'math']",You've got a rectangular parallelepiped with integer edge lengths. You know the areas of its three faces that have a common vertex. Your task is to find the sum of lengths of all 12 edges of this parallelepiped.,The first and the single line contains three space-separated integers — the areas of the parallelepiped's faces. The area's values are positive (<=&gt;<=0) and do not exceed 104. It is guaranteed that there exists at least one parallelepiped that satisfies the problem statement.,Print a single number — the sum of all edges of the parallelepiped.,"['1 1 1\n', '4 6 6\n']","['12\n', '28\n']","In the first sample the parallelepiped has sizes 1 × 1 × 1, in the second one — 2 × 2 × 3.",OK,"from itertools import d 

def e(a):
    c = d(a)
    for i in list(c):
        v = (i[1]*i[2]/i[0])**.5
        if v.is_integer() :
            return int(4*v + 4*i[1]//v + 4*i[2]//v) 

def b():
    a = list(map(int, input().split("" "")))
    print(e(a))

b()","import c

def a(x):

    if x < 0:

        return False

    e = int(c.sqrt(x))
    return e * e == x

def b():

    n = int(input().strip())

    a = list(map(int, input().split()))

    for d in reversed(a):
        if not a(d):
            print(d)
            return

if __name__ == '__main__':
    b()"
285,C,Building Permutation,PROGRAMMING,"['greedy', 'implementation', 'sortings']","Permutation *p* is an ordered set of integers *p*1,<=<=*p*2,<=<=...,<=<=*p**n*, consisting of *n* distinct positive integers, each of them doesn't exceed *n*. We'll denote the *i*-th element of permutation *p* as *p**i*. We'll call number *n* the size or the length of permutation *p*1,<=<=*p*2,<=<=...,<=<=*p**n*.

You have a sequence of integers *a*1,<=*a*2,<=...,<=*a**n*. In one move, you are allowed to decrease or increase any number by one. Count the minimum number of moves, needed to build a permutation from this sequence.","The first line contains integer *n* (1<=≤<=*n*<=≤<=3·105) — the size of the sought permutation. The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (<=-<=109<=≤<=*a**i*<=≤<=109).","Print a single number — the minimum number of moves.

Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.","['2\n3 0\n', '3\n-1 -1 2\n']","['2\n', '6\n']","In the first sample you should decrease the first number by one and then increase the second number by one. The resulting permutation is (2, 1).

In the second sample you need 6 moves to build permutation (1, 3, 2).",OK,"def c (n,b) :
    b.sort()
    d = 1
    a = 0
    while d <= n :
        if b[d-1] != d :
            a += abs(b[d-1] - d)
        d += 1
        
        
    return a
    
    
n = int(input())
b = list(map(int,input().split()))

print (c(n,b))","def c():

    n = input().strip()

    a = 0

    while len(n) > 1:

        n = str(sum(int(b) for b in n))
        a += 1

    print(a)

if __name__ == '__main__':
    c()"
318,A,Even Odds,PROGRAMMING,['math'],"Being a nonconformist, Volodya is displeased with the current state of things, particularly with the order of natural numbers (natural number is positive integer number). He is determined to rearrange them. But there are too many natural numbers, so Volodya decided to start with the first *n*. He writes down the following sequence of numbers: firstly all odd integers from 1 to *n* (in ascending order), then all even integers from 1 to *n* (also in ascending order). Help our hero to find out which number will stand at the position number *k*.","The only line of input contains integers *n* and *k* (1<=≤<=*k*<=≤<=*n*<=≤<=1012).

Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.",Print the number that will stand at the position number *k* after Volodya's manipulations.,"['10 3\n', '7 7\n']","['5', '6']","In the first sample Volodya's sequence will look like this: {1, 3, 5, 7, 9, 2, 4, 6, 8, 10}. The third place in the sequence is therefore occupied by the number 5.",RUNTIME_ERROR,"def b(n, k):
    if n%2 == 0:
        if k <= n//2:
            c = 2*k - 1
        else:
            c = 2*(k - n//2)
    else:
        if k <= n//2 + 1:
            c = 2*k - 1
        else:
            c = 2*(k - n//2 - 1)
    return c
    
n, k = map(int, input().split())
print(a(n, k))","import p
import i

def d(n, h, o):

    e = [float('inf')] * (n + 1)

    k = [-1] * (n + 1)

    m = []

    e[o] = 0
    i.heappush(m, (0, o))
    
    while m:
        b, u = i.heappop(m)

        if b > e[u]:
            continue

        for v, q in h[u]:
            if e[u] + q < e[v]:
                e[v] = e[u] + q
                k[v] = u
                i.heappush(m, (e[v], v))
                
    return e, k

def n(k, o, f):

    l = []
    a = f
    while a != -1:
        l.append(a)
        a = k[a]
    l.reverse()
    if l[0] == o:
        return l
    else:
        return None

def j():

    c = p.stdin.read().splitlines()
    if not c: return

    g = c[0]
    n, m = map(int, g.split())

    h = [[] for _ in range(n + 1)]

    for i in range(1, m + 1):
        a, b, w = map(int, c[i].split())
        h[a].append((b, w))
        h[b].append((a, w))

    e, k = d(n, h, 1)

    if e[n] == float('inf'):
        print(-1)
    else:
        l = n(k, 1, n)

        print("" "".join(map(str, l)) + "" "")

if __name__ == '__main__':
    j()"
118,A,String Task,PROGRAMMING,"['implementation', 'strings']","Petya started to attend programming lessons. On the first lesson his task was to write a simple program. The program was supposed to do the following: in the given string, consisting if uppercase and lowercase Latin letters, it: 
 -  deletes all the vowels, -  inserts a character ""."" before each consonant, -  replaces all uppercase consonants with corresponding lowercase ones. 
Vowels are letters ""A"", ""O"", ""Y"", ""E"", ""U"", ""I"", and the rest are consonants. The program's input is exactly one string, it should return the output as a single string, resulting after the program's processing the initial string.

Help Petya cope with this easy task.","The first line represents input string of Petya's program. This string only consists of uppercase and lowercase Latin letters and its length is from 1 to 100, inclusive.",Print the resulting string. It is guaranteed that this string is not empty.,"['tour\n', 'Codeforces\n', 'aBAcAba\n']","['.t.r\n', '.c.d.f.r.c.s\n', '.b.c.b\n']",none,RUNTIME_ERROR,"def b():
    n = int(input())
    s = input()
    a = 0
    for i in range(1, len(s)):
        c = s[i - 1]
        if c == s[i]:
            a += 1

    print(a)

if __name__ == '__main__':
    b()","def b():
    import h
    a = h.stdin.read().split()

    n = int(a[0])

    f = list(map(int, a[1:]))

    if n < 3:
        print(0)
        return

    d = min(f)
    c = max(f)

    if d == c:
        print(0)
        return

    g = 0
    for e in f:
        if d < e < c:
            g += 1

    print(g)
    
if __name__ == ""__main__"":
    b()"
559,A,Gerald's Hexagon,PROGRAMMING,"['brute force', 'geometry', 'math']","Gerald got a very curious hexagon for his birthday. The boy found out that all the angles of the hexagon are equal to . Then he measured the length of its sides, and found that each of them is equal to an integer number of centimeters. There the properties of the hexagon ended and Gerald decided to draw on it.

He painted a few lines, parallel to the sides of the hexagon. The lines split the hexagon into regular triangles with sides of 1 centimeter. Now Gerald wonders how many triangles he has got. But there were so many of them that Gerald lost the track of his counting. Help the boy count the triangles.","The first and the single line of the input contains 6 space-separated integers *a*1,<=*a*2,<=*a*3,<=*a*4,<=*a*5 and *a*6 (1<=≤<=*a**i*<=≤<=1000) — the lengths of the sides of the hexagons in centimeters in the clockwise order. It is guaranteed that the hexagon with the indicated properties and the exactly such sides exists.","Print a single integer — the number of triangles with the sides of one 1 centimeter, into which the hexagon is split.","['1 1 1 1 1 1\n', '1 2 1 2 1 2\n']","['6\n', '13\n']","This is what Gerald's hexagon looks like in the first sample:

<img class=""tex-graphics"" src=""https://espresso.codeforces.com/84d193e27b02c38eb1eadc536602a2ec0b9f9519.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

And that's what it looks like in the second sample:

<img class=""tex-graphics"" src=""https://espresso.codeforces.com/e29076a96da8ca864654cc6195654d9bf07d31ce.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>",OK,"def b():
    return list(map(int, input().split()))

def d(v):
    print(' '.join(str(x) for x in v))

def c():
    a = b()
    a = 0
    x = a[0]
    for i in range(a[1] + a[2]):
        d = 0
        d += (1 if i < a[1] else -1)
        d += (1 if i < a[5] else -1)
        d //= 2
        a += 2 * x + d
        x += d
    print(a)

if __name__ == '__main__':
    c()","import j

def e():

    n, k, l, r, g, h = map(int, j.stdin.readline().split())

    d = h - k * l

    k = [l] * k
    for i in range(k):

        a = min(r - l, d // (k - i))
        k[i] += a
        d -= a

    f = g - h
    b = [l] * (n - k)
    c = f - (n - k) * l
    for i in range(n - k):
        a = min(r - l, c // (n - k - i))
        b[i] += a
        c -= a

    i = k + b

    i.sort()

    print("" "".join(map(str, i)))

if __name__ == '__main__':
    e()"
650,A,Watchmen,PROGRAMMING,"['data structures', 'geometry', 'math']","Watchmen are in a danger and Doctor Manhattan together with his friend Daniel Dreiberg should warn them as soon as possible. There are *n* watchmen on a plane, the *i*-th watchman is located at point (*x**i*,<=*y**i*).

They need to arrange a plan, but there are some difficulties on their way. As you know, Doctor Manhattan considers the distance between watchmen *i* and *j* to be |*x**i*<=-<=*x**j*|<=+<=|*y**i*<=-<=*y**j*|. Daniel, as an ordinary person, calculates the distance using the formula .

The success of the operation relies on the number of pairs (*i*,<=*j*) (1<=≤<=*i*<=&lt;<=*j*<=≤<=*n*), such that the distance between watchman *i* and watchmen *j* calculated by Doctor Manhattan is equal to the distance between them calculated by Daniel. You were asked to compute the number of such pairs.","The first line of the input contains the single integer *n* (1<=≤<=*n*<=≤<=200<=000) — the number of watchmen.

Each of the following *n* lines contains two integers *x**i* and *y**i* (|*x**i*|,<=|*y**i*|<=≤<=109).

Some positions may coincide.",Print the number of pairs of watchmen such that the distance between them calculated by Doctor Manhattan is equal to the distance calculated by Daniel.,"['3\n1 1\n7 5\n1 5\n', '6\n0 0\n0 1\n0 2\n-1 1\n0 1\n1 1\n']","['2\n', '11\n']","In the first sample, the distance between watchman 1 and watchman 2 is equal to |1 - 7| + |1 - 5| = 10 for Doctor Manhattan and <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/bcb5b7064b5f02088da0fdcf677e6fda495dd0df.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> for Daniel. For pairs (1, 1), (1, 5) and (7, 5), (1, 5) Doctor Manhattan and Daniel will calculate the same distances.",WRONG_ANSWER,"def a(n):
	return n*(n-1)//2

g = set()
h = set()
c = set()

n = int(input())
p = []
for _ in range(n):
	x, y = [int(x) for x in input().split()]
	g.add(x)
	h.add(y)
	c.add((x,y))
e = (n-len(g)+1)
f = (n-len(h)+1)
d = (n-len(c)+1)
b = a(e)+a(f)-a(d)
print(b)","def k():
    import l
    l.setrecursionlimit(10**6)
    d = l.stdin.read().split()
    if not d:
        return
    f = 0
    n = int(d[f])
    m = int(d[f+1])
    f += 2

    c = list(map(int, d[f: f+n]))
    f += n

    g = list(range(n))
    h = [0] * n

    def e(x):
        if g[x] != x:
            g[x] = e(g[x])
        return g[x]

    def n(x, y):
        i = e(x)
        j = e(y)
        if i == j:
            return
        if h[i] < h[j]:
            g[i] = j
        elif h[i] > h[j]:
            g[j] = i
        else:
            g[j] = i
            h[i] += 1

    for _ in range(m):
        u = int(d[f]) - 1
        v = int(d[f+1]) - 1
        f += 2
        n(u, v)

    b = {}
    for i in range(n):
        a = e(i)
        if a in b:
            b[a] = min(b[a], c[i])
        else:
            b[a] = c[i]

    m = sum(b.values())
    l.stdout.write(str(m))

if __name__ == '__main__':
    k()"
275,B,Convex Shape,PROGRAMMING,"['constructive algorithms', 'implementation']","Consider an *n*<=×<=*m* grid. Initially all the cells of the grid are colored white. Lenny has painted some of the cells (at least one) black. We call a painted grid convex if one can walk from any black cell to any another black cell using a path of side-adjacent black cells changing his direction at most once during the path. In the figure below, the left grid is convex while the right one is not convex, because there exist two cells which need more than one time to change direction in their path.

You're given a painted grid in the input. Tell Lenny if the grid is convex or not.","The first line of the input contains two integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=50) — the size of the grid. Each of the next *n* lines contains *m* characters ""B"" or ""W"". Character ""B"" denotes a black cell of the grid and ""W"" denotes a white cell of the grid.

It's guaranteed that the grid has at least one black cell.","On the only line of the output print ""YES"" if the grid is convex, otherwise print ""NO"". Do not print quotes.","['3 4\nWWBW\nBWWW\nWWWB\n', '3 1\nB\nB\nW\n']","['NO\n', 'YES\n']",none,RUNTIME_ERROR,"import abc
import itertools
import math
from math import gcd as gcd
import k
import queue
import itertools
from heapq import heappop, heappush
import random

def j():
    def c(o, l, p, m):
        if l == m:
            s = d[max(o, p)][l] - d[max(o, p)][l - 1] - d[min(o, p) - 1][l] + d[min(o, p) - 1][l - 1]
            return s
        elif o == p:
            s = d[o][max(l, m)] - d[o][min(l, m) - 1] - d[o - 1][max(l, m)] + d[o - 1][min(l, m) - 1]
            return s
        else:
            print(""Ti durak"")
            print(""Oshibka :////"")

    def a(o, l, p, m):

        if l == m:
            s = c(o, l, p, m)
            if s != abs(o - p) + 1:
                return False
            return True
        elif o == p:
            s = c(l, o, m, p)
            if s != abs(l - m) + 1:
                return False
            return True
        else:
            for n in [l, m]:
                for q in [o, p]:
                    if [n, q] not in [[l, o], [m, p]]:
                        g = c(o, l, q, n)
                        h = c(p, m, q, n)

                        e = abs(l - m) + abs(o - p) + 1
                        if g + h - 1 == e:
                            return True

            return False

    n, m = map(int, input().split())

    f = []
    f = []
    for i in range(n):
        s = str(input())
        for j in range(m):
            if s[j] == ""B"":
                f.append([i + 1, j + 1])
        f.append(s)

    d = [[0 for i in range(m + 1)]]
    for i in range(n):
        d.append([0])
        for j in range(m):
            d[-1].append(int(f[i][j] == ""B"") + d[i][j + 1] + d[i + 1][j] - d[i][j])

    for b in range(len(f)):
        o, l = f[b]
        for i in range(b + 1, len(f)):
            p, m = f[i]

            if not a(o, l, p, m):
                print(""NO"")
                return

    print(""YES"")

if __name__ == '__main__':
    d = 0

    if d == 1:
        t = int(k.stdin.readline())
        for _ in range(t):
            j()
    else:
        j()","import l
import j

def a(e, f, g):

    a = int(j.sqrt((e * f) / g))

    b = e // a
    c = f // a

    return 4 * (a + b + c)

if __name__ == ""__main__"":

    h = l.stdin.readlines()

    for i in h:

        if not i.strip():
            continue

        try:
            b, c, d = map(int, i.split())
        except ValueError:
            continue

        k = a(b, c, d)

        print(k)"
472,A,Design Tutorial: Learn from Math,PROGRAMMING,"['math', 'number theory']","One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.

For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.

You are given an integer *n* no less than 12, express it as a sum of two composite numbers.",The only line contains an integer *n* (12<=≤<=*n*<=≤<=106).,"Output two composite integers *x* and *y* (1<=&lt;<=*x*,<=*y*<=&lt;<=*n*) such that *x*<=+<=*y*<==<=*n*. If there are multiple solutions, you can output any of them.","['12\n', '15\n', '23\n', '1000000\n']","['4 8\n', '6 9\n', '8 15\n', '500000 500000\n']","In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output ""6 6"" or ""8 4"" as well.

In the second example, 15 = 6 + 9. Note that you can't output ""1 14"" because 1 is not a composite number.",OK,"def a(n):
    d = 2
    while d * d <= n and n % d != 0:
        d += 1
    return d * d > n

n = int(input())
a = 0
b = 0
for i in range(4, n):
    if a(i) is not True and a(n - i) is not True:
        a = i
        b = n - i
        break
print(a, b)","def g():
    import i
    e = i.stdin.read().split()
    if not e:
        return

    n = int(e[0])
    b = list(map(int, e[1:]))

    if n == 1:
        i.stdout.write(""-1"")
        return

    b.sort()

    if n == 2:
        a, b = b[0], b[1]

        if a == b:
            i.stdout.write(""1\n"" + str(a))
            return
        d = b - a
        h = set()

        h.add(a - d)

        h.add(b + d)

        if d % 2 == 0:
            h.add(a + d // 2)
        h = sorted(h)
        i.stdout.write(str(len(h)) + ""\n"" + "" "".join(map(str, h)))
        return

    f = []
    for i in range(1, n):
        f.append(b[i] - b[i-1])
    d = min(f)

    if d == 0:
        if all(x == b[0] for x in b):

            i.stdout.write(""1\n"" + str(b[0]))
        else:

            i.stdout.write(""0"")
        return

    a = None
    c = 0
    j = True
    for i in range(1, n):
        d = b[i] - b[i-1]
        if d == d:
            continue
        elif d == 2 * d:
            c += 1
            a = b[i-1] + d
        else:
            j = False
            break

    if not j:
        i.stdout.write(""0"")
        return

    if c == 1:
        i.stdout.write(""1\n"" + str(a))
        return

    h = [b[0] - d, b[-1] + d]
    h = sorted(set(h))
    i.stdout.write(str(len(h)) + ""\n"" + "" "".join(map(str, h)))

if __name__ == '__main__':
    g()"
26,A,Almost Prime,PROGRAMMING,['number theory'],"A number is called almost prime if it has exactly two distinct prime divisors. For example, numbers 6, 18, 24 are almost prime, while 4, 8, 9, 42 are not. Find the amount of almost prime numbers which are between 1 and *n*, inclusive.",Input contains one integer number *n* (1<=≤<=*n*<=≤<=3000).,"Output the amount of almost prime numbers between 1 and *n*, inclusive.","['10\n', '21\n']","['2\n', '8\n']",none,OK,"def a(n):
    c = 0
    if n == 1:
        return False
    for k in range(2,n):
        if n % k == 0:
            c = 1
            return False
    if c == 0:
        return True
r = 0
n = int(input())
for i in range(1, n + 1):
    c = 0
    for j in range(1, i):
        if i % j == 0:
            if a(j):
                c += 1
    
    if c == 2:
        r += 1
print(r)","import e

def c():

    b = e.stdin.readlines()

    for a in b:

        a = a.strip()

        if not a:
            continue

        try:
            m, n = map(int, a.split())
        except ValueError:

            continue

        d = (m * n) // 2

        print(d)

if __name__ == ""__main__"":
    c()"
518,A,Vitaly and Strings,PROGRAMMING,"['constructive algorithms', 'strings']","Vitaly is a diligent student who never missed a lesson in his five years of studying in the university. He always does his homework on time and passes his exams in time. 

During the last lesson the teacher has provided two strings *s* and *t* to Vitaly. The strings have the same length, they consist of lowercase English letters, string *s* is lexicographically smaller than string *t*. Vitaly wondered if there is such string that is lexicographically larger than string *s* and at the same is lexicographically smaller than string *t*. This string should also consist of lowercase English letters and have the length equal to the lengths of strings *s* and *t*. 

Let's help Vitaly solve this easy problem!","The first line contains string *s* (1<=≤<=|*s*|<=≤<=100), consisting of lowercase English letters. Here, |*s*| denotes the length of the string.

The second line contains string *t* (|*t*|<==<=|*s*|), consisting of lowercase English letters.

It is guaranteed that the lengths of strings *s* and *t* are the same and string *s* is lexicographically less than string *t*.","If the string that meets the given requirements doesn't exist, print a single string ""No such string"" (without the quotes).

If such string exists, print it. If there are multiple valid strings, you may print any of them.","['a\nc\n', 'aaa\nzzz\n', 'abcdefg\nabcdefh\n']","['b\n', 'kkk\n', 'No such string\n']","String *s* = *s*<sub class=""lower-index"">1</sub>*s*<sub class=""lower-index"">2</sub>... *s*<sub class=""lower-index"">*n*</sub> is said to be lexicographically smaller than *t* = *t*<sub class=""lower-index"">1</sub>*t*<sub class=""lower-index"">2</sub>... *t*<sub class=""lower-index"">*n*</sub>, if there exists such *i*, that *s*<sub class=""lower-index"">1</sub> = *t*<sub class=""lower-index"">1</sub>, *s*<sub class=""lower-index"">2</sub> = *t*<sub class=""lower-index"">2</sub>, ... *s*<sub class=""lower-index"">*i* - 1</sub> = *t*<sub class=""lower-index"">*i* - 1</sub>, *s*<sub class=""lower-index"">*i*</sub> &lt; *t*<sub class=""lower-index"">*i*</sub>.",OK,"from bisect import bisect_left, bisect_right
from collections import Counter, deque
from functools import lru_cache
from math import factorial, comb, sqrt, gcd, lcm
from copy import deepcopy
import heapq

def d(n):
    a = (n - 1) // 26
    g = (n - 1) % 26
    if a == 0:
        return chr(g + ord(""a""))
    else:
        return d(a) + chr(g + ord(""a""))

def c():
    t = input()
    s = input()
    f = 0
    e = 0
    b = 0
    for i in range(len(t) - 1, -1, -1):
        f += (ord(t[i]) - ord(""a"") + 1) * 26**b
        e += (ord(s[i]) - ord(""a"") + 1) * 26**b
        b += 1
    if e > f + 1:
        print(d(f + 1))
    else:
        print(""No such string"")

if __name__ == ""__main__"":
    c()","def e():
    import f

    b = f.stdin.read().strip().split()
    if not b:
        return

    n = int(b[0])

    d = list(map(int, b[1:1+n]))

    h = sum(d)

    i = n + 1

    j = 0

    for c in range(1, 6):

        g = c + h

        a = (g - 1) % i

        if a != 0:
            j += 1

    f.stdout.write(str(j))

if __name__ == '__main__':
    e()"
600,B,Queries about less or equal elements,PROGRAMMING,"['binary search', 'data structures', 'sortings', 'two pointers']",You are given two arrays of integers *a* and *b*. For each element of the second array *b**j* you should find the number of elements in array *a* that are less than or equal to the value *b**j*.,"The first line contains two integers *n*,<=*m* (1<=≤<=*n*,<=*m*<=≤<=2·105) — the sizes of arrays *a* and *b*.

The second line contains *n* integers — the elements of array *a* (<=-<=109<=≤<=*a**i*<=≤<=109).

The third line contains *m* integers — the elements of array *b* (<=-<=109<=≤<=*b**j*<=≤<=109).","Print *m* integers, separated by spaces: the *j*-th of which is equal to the number of such elements in array *a* that are less than or equal to the value *b**j*.","['5 4\n1 3 5 7 9\n6 4 2 8\n', '5 5\n1 2 1 2 5\n3 1 4 1 5\n']","['3 2 1 4\n', '4 2 4 2 5\n']",none,TIME_LIMIT_EXCEEDED,"def b(a,b):
    l=[]
    for i in b:
        c=0
        for j in a:
            if j<=i:
                c+=1
        l.append(c)
    return l

a,b=map(int,input().split())
p=list(map(int,input().split()))
q=list(map(int,input().split()))
a=b(p,q)
for i in a:
    print(i,end="" "")","import e
import f

def d():

    a = f.stdin.read().strip().split()

    if len(a) < 3:
        return

    n, m, a = map(int, a)

    b = e.ceil(n / a)

    c = e.ceil(m / a)

    g = b * c

    print(g)

if __name__ == ""__main__"":
    d()"
59,A,Word,PROGRAMMING,"['implementation', 'strings']","Vasya is very upset that many people on the Net mix uppercase and lowercase letters in one word. That's why he decided to invent an extension for his favorite browser that would change the letters' register in every word so that it either only consisted of lowercase letters or, vice versa, only of uppercase ones. At that as little as possible letters should be changed in the word. For example, the word HoUse must be replaced with house, and the word ViP — with VIP. If a word contains an equal number of uppercase and lowercase letters, you should replace all the letters with lowercase ones. For example, maTRIx should be replaced by matrix. Your task is to use the given method on one given word.",The first line contains a word *s* — it consists of uppercase and lowercase Latin letters and possesses the length from 1 to 100.,"Print the corrected word *s*. If the given word *s* has strictly more uppercase letters, make the word written in the uppercase register, otherwise - in the lowercase one.","['HoUse\n', 'ViP\n', 'maTRIx\n']","['house\n', 'VIP\n', 'matrix\n']",none,WRONG_ANSWER,"def a(s):
    b = sum(1 for c in s if c.isupper())

    if b > len(s) // 2:
        s = s.upper()
    else:
        s = s.lower()

    return s

c = input(""Введите слово: "")

print(a(c))","import k

def e(s, n, k, l):
    """"""
    Returns the maximum window length where we can change at most k characters
    to make all characters equal to target.
    """"""
    h = 0
    c = 0

    a = 0

    for j in range(n):
        if s[j] != l:
            a += 1

        while a > k:
            if s[c] != l:
                a -= 1
            c += 1

        h = max(h, j - c + 1)
    
    return h

def d():

    b = k.stdin.read().splitlines()

    n, k = map(int, b[0].split())

    s = b[1].strip()

    f = e(s, n, k, 'a')
    g = e(s, n, k, 'b')

    i = max(f, g)

    print(i)

if __name__ == '__main__':
    d()"
177,E1,Space Voyage,PROGRAMMING,['binary search'],"The Smart Beaver from ABBYY plans a space travel on an ultramodern spaceship. During the voyage he plans to visit *n* planets. For planet *i* *a**i* is the maximum number of suitcases that an alien tourist is allowed to bring to the planet, and *b**i* is the number of citizens on the planet.

The Smart Beaver is going to bring some presents from ABBYY to the planets he will be visiting. The presents are packed in suitcases, *x* presents in each. The Beaver will take to the ship exactly *a*1<=+<=...<=+<=*a**n* suitcases.

As the Beaver lands on the *i*-th planet, he takes *a**i* suitcases and goes out. On the first day on the planet the Beaver takes a walk and gets to know the citizens. On the second and all subsequent days the Beaver gives presents to the citizens — each of the *b**i* citizens gets one present per day. The Beaver leaves the planet in the evening of the day when the number of presents left is strictly less than the number of citizens (i.e. as soon as he won't be able to give away the proper number of presents the next day). He leaves the remaining presents at the hotel.

The Beaver is going to spend exactly *c* days traveling. The time spent on flights between the planets is considered to be zero. In how many ways can one choose the positive integer *x* so that the planned voyage will take exactly *c* days?","The first input line contains space-separated integers *n* and *c* — the number of planets that the Beaver is going to visit and the number of days he is going to spend traveling, correspondingly.

The next *n* lines contain pairs of space-separated integers *a**i*,<=*b**i* (1<=≤<=*i*<=≤<=*n*) — the number of suitcases he can bring to the *i*-th planet and the number of citizens of the *i*-th planet, correspondingly.

The input limitations for getting 30 points are: 
 -  1<=≤<=*n*<=≤<=100 -  1<=≤<=*a**i*<=≤<=100 -  1<=≤<=*b**i*<=≤<=100 -  1<=≤<=*c*<=≤<=100 
The input limitations for getting 100 points are: 
 -  1<=≤<=*n*<=≤<=104 -  0<=≤<=*a**i*<=≤<=109 -  1<=≤<=*b**i*<=≤<=109 -  1<=≤<=*c*<=≤<=109 
Due to possible overflow, it is recommended to use the 64-bit arithmetic. In some solutions even the 64-bit arithmetic can overflow. So be careful in calculations!","Print a single number *k* — the number of ways to choose *x* so as to travel for exactly *c* days. If there are infinitely many possible values of *x*, print -1.

Please do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use cin, cout streams or the %I64d specifier.",['2 5\n1 5\n2 4\n'],['1\n'],"In the first example there is only one suitable value *x* = 5. Then the Beaver takes 1 suitcase with 5 presents to the first planet. Here he spends 2 days: he hangs around on the first day, and he gives away five presents on the second day. He takes 2 suitcases with 10 presents to the second planet. Here he spends 3 days — he gives away 4 presents on the second and the third days and leaves the remaining 2 presents at the hotel. In total, the Beaver spends 5 days traveling.

For *x* = 4 or less the Beaver won't have enough presents for the second day on the first planet, so the voyage will end too soon. For *x* = 6 and more the Beaver will spend at least one more day on the second planet, and the voyage will take too long.",WRONG_ANSWER,"n,c=list(map(int,input().split()))
d,e,m=c-n,[],0
def a(x):
    b=0
    for c in e:
        y=(x*c[0])//c[1]
        if(y>d or b>d):
            return b+y
        b+=y
    return b
for _ in range(n):
    e.append(list(map(int,input().split())))
f,d=0,1000000000    
while f<=d:
    g=f+(d-f)//2
    c=a(g)
    if(c>d):
        d=g-1
    elif(c<d):
        f=g+1
    else:
        h=g
        d=g-1
f,d=0,1000000000
while f<=d:
    g=f+(d-f)//2
    c=a(g)
    if(c>d):
        d=g-1
    elif(c<d):
        f=g+1
    else:
        i=g
        f=g+1
print(i-h+1)","import g

def e():

    c = g.stdin.read().split()
    if not c:
        return

    n = int(c[0])
    k = int(c[1])

    b = list(map(int, c[2:2+n]))

    if k == 1:

        print(n * (n + 1) // 2)
        return

    d = {}

    f = 0
    a = 0
    r = 0

    for l in range(n):

        while r < n and f == 0:
            h = b[r]
            d[h] = d.get(h, 0) + 1

            if d[h] == k:
                f += 1
            r += 1

        if f > 0:
            a += (n - r + 1)

        h = b[l]

        if d[h] == k:
            f -= 1
        d[h] -= 1

    print(a)

if __name__ == '__main__':
    e()"
0,none,none,none,['none'],"Eighth-grader Vova is on duty today in the class. After classes, he went into the office to wash the board, and found on it the number *n*. He asked what is this number and the teacher of mathematics Inna Petrovna answered Vova that *n* is the answer to the arithmetic task for first-graders. In the textbook, a certain positive integer *x* was given. The task was to add *x* to the sum of the digits of the number *x* written in decimal numeral system.

Since the number *n* on the board was small, Vova quickly guessed which *x* could be in the textbook. Now he wants to get a program which will search for arbitrary values of the number *n* for all suitable values of *x* or determine that such *x* does not exist. Write such a program for Vova.",The first line contains integer *n* (1<=≤<=*n*<=≤<=109).,"In the first line print one integer *k* — number of different values of *x* satisfying the condition. 

In next *k* lines print these values in ascending order.","['21\n', '20\n']","['1\n15\n', '0\n']","In the first test case *x* = 15 there is only one variant: 15 + 1 + 5 = 21.

In the second test case there are no such *x*.",TIME_LIMIT_EXCEEDED,"def f(n):
    a = n
    while n:
        a += n % 10
        n //= 10
    return a
n = int(input())
a = []
for i in range(max(1, n - 100, n)):
    if f(i) == n:
        a.append(i)
print(len(a))
for b in a:
    print(b, end = ' ')","def f(limit):
    """"""
    Generates all lucky numbers (composed solely of 4 and 7) that could be needed.
    We generate lucky numbers with up to 11 digits to cover the worst-case input.
    """"""
    h = []

    def c(j, d):

        if d > 11:
            return
        if j != 0:
            h.append(j)
        c(j * 10 + 4, d + 1)
        c(j * 10 + 7, d + 1)
    
    c(0, 0)
    return sorted(h)

def i():
    import k

    b = k.stdin.read().strip().split()
    if not b:
        return
    l = int(b[0])
    r = int(b[1])

    h = f(r)
    
    l = 0
    a = l

    for g in h:
        if g < a:
            continue

        e = min(r, g)
        l += (e - a + 1) * g
        a = e + 1

        if a > r:
            break
    
    k.stdout.write(str(l))

if __name__ == '__main__':
    i()"
457,A,Golden System,PROGRAMMING,"['math', 'meet-in-the-middle']","Piegirl got bored with binary, decimal and other integer based counting systems. Recently she discovered some interesting properties about number , in particular that *q*2<==<=*q*<=+<=1, and she thinks it would make a good base for her new unique system. She called it ""golden system"". In golden system the number is a non-empty string containing 0's and 1's as digits. The decimal value of expression *a*0*a*1...*a**n* equals to .

Soon Piegirl found out that this system doesn't have same properties that integer base systems do and some operations can not be performed on it. She wasn't able to come up with a fast way of comparing two numbers. She is asking for your help.

Given two numbers written in golden system notation, determine which of them has larger decimal value.",Input consists of two lines — one for each number. Each line contains non-empty string consisting of '0' and '1' characters. The length of each string does not exceed 100000.,"Print ""&gt;"" if the first number is larger, ""&lt;"" if it is smaller and ""="" if they are equal.","['1000\n111\n', '00100\n11\n', '110\n101\n']","['&lt;\n', '=\n', '&gt;\n']","In the first example first number equals to <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/9c955eec678d6e7dcdc7c94fb203e922d2ad19ad.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>, while second number is approximately 1.618033988<sup class=""upper-index"">2</sup> + 1.618033988 + 1 ≈ 5.236, which is clearly a bigger number.

In the second example numbers are equal. Each of them is  ≈ 2.618.",RUNTIME_ERROR,"from itertools import b, a

def c():
    e = lambda a: not a
    a, b = [list(a([0, 0], b(e, map(int, input()))))
            for _ in range(2)]

    def d(l):
        i = 0
        while i < len(l):
            if l[i] > 0 and l[i + 1] > 0:
                l[i] -= 1
                l[i + 1] -= 1
                l[i - 1] += 1
                i -= 3
            i += 1
        return l

    a = list(b(e, d(a)))
    b = list(b(e, d(b)))

    if len(a) < len(b):
        print('<')
        return
    if len(a) > len(b):
        print('>')
        return
    for i in range(len(a)):
        if a[i] < b[i]:
            print('<')
            return
        if a[i] > b[i]:
            print('>')
            return
    print('=')

if __name__ == '__main__':
    c()","def c():
    import i
    b = i.stdin.read().split()
    if not b:
        return
    n = int(b[0])
    m = int(b[1])

    f = list(map(int, b[2:2+n]))
    g = []
    d = 2 + n
    for i in range(m):
        l = int(b[d + 2*i])
        r = int(b[d + 2*i + 1])
        g.append((l, r))

    h = sorted([(f[i], i) for i in range(n)], key=lambda x: x[0])

    a = [None] * n
    for i, (_, e) in enumerate(h):
        a[e] = i % 2

    i.stdout.write("" "".join(map(str, a)))

if __name__ == ""__main__"":
    c()"
275,A,Lights Out,PROGRAMMING,['implementation'],"Lenny is playing a game on a 3<=×<=3 grid of lights. In the beginning of the game all lights are switched on. Pressing any of the lights will toggle it and all side-adjacent lights. The goal of the game is to switch all the lights off. We consider the toggling as follows: if the light was switched on then it will be switched off, if it was switched off then it will be switched on.

Lenny has spent some time playing with the grid and by now he has pressed each light a certain number of times. Given the number of times each light is pressed, you have to print the current state of each light.",The input consists of three rows. Each row contains three integers each between 0 to 100 inclusive. The *j*-th number in the *i*-th row is the number of times the *j*-th light of the *i*-th row of the grid is pressed.,"Print three lines, each containing three characters. The *j*-th character of the *i*-th line is ""1"" if and only if the corresponding light is switched on, otherwise it's ""0"".","['1 0 0\n0 0 0\n0 0 1\n', '1 0 1\n8 8 8\n2 0 3\n']","['001\n010\n100\n', '010\n011\n100\n']",none,OK,"def c(e) :
    j = [[1 for i in range(3)]for j in range(3)]
    b,a = [-1,0,1,0],[0,-1,0,1]

    for i in range(3) :
        for j in range(3) :
            k = e[i][j]
            for t in range(k) :
                j[i][j] = 1 - j[i][j]
                for k in range(4) :
                    g,f = b[k] + i, a[k] + j
                    if g >= 0 and f >= 0 and g < 3 and f < 3 :
                        j[g][f] = 1 - j[g][f]

    return j

def d() :
    e = []
    for i in range(3) :
        x,y,z = map(int,input().split())
        e.append([x,y,z])
    return e

def i(h) :
    for i in range(3) :
        for j in range(3) :
            print(h[i][j],end = '')
        print()

i(c(d()))","def e():
    import m
    b = m.stdin.read().strip().split()
    if not b:
        return

    n = int(b[0])
    c = list(map(int, b[1:1+n]))

    if 0 not in c:
        print(-1)
        return

    d = [0] * 10
    for d in c:
        d[d] += 1

    n = sum(d * d[d] for d in range(10))
    g = n % 3

    def i(f):

        for d in range(10):
            if d % 3 == f and d[d] > 0:
                if d == 0 and d[d] == 1:
                    continue
                d[d] -= 1
                return True
        return False

    def j(f):

        h = []
        for d in range(10):
            if d % 3 == f:

                a = d[d] if d != 0 else (d[d] if d[d] > 1 else 0)
                h.extend([d] * a)
        if len(h) < 2:
            return False
        h.sort()

        for i in range(2):
            d = h[i]
            d[d] -= 1
        return True

    if g == 1:
        if not i(1):
            if not j(2):
                print(-1)
                return
    elif g == 2:
        if not i(2):
            if not j(1):
                print(-1)
                return

    l = []
    for d in range(10):
        l.extend([str(d)] * d[d])

    if not l:
        print(-1)
        return

    if max(l) == '0':
        print(""0"")
        return

    l.sort(reverse=True)
    k = """".join(l)
    print(k)

if __name__ == '__main__':
    e()"
115,A,Party,PROGRAMMING,"['dfs and similar', 'graphs', 'trees']","A company has *n* employees numbered from 1 to *n*. Each employee either has no immediate manager or exactly one immediate manager, who is another employee with a different number. An employee *A* is said to be the superior of another employee *B* if at least one of the following is true:
 -  Employee *A* is the immediate manager of employee *B* -  Employee *B* has an immediate manager employee *C* such that employee *A* is the superior of employee *C*. 
The company will not have a managerial cycle. That is, there will not exist an employee who is the superior of his/her own immediate manager.

Today the company is going to arrange a party. This involves dividing all *n* employees into several groups: every employee must belong to exactly one group. Furthermore, within any single group, there must not be two employees *A* and *B* such that *A* is the superior of *B*.

What is the minimum number of groups that must be formed?","The first line contains integer *n* (1<=≤<=*n*<=≤<=2000) — the number of employees.

The next *n* lines contain the integers *p**i* (1<=≤<=*p**i*<=≤<=*n* or *p**i*<==<=-1). Every *p**i* denotes the immediate manager for the *i*-th employee. If *p**i* is -1, that means that the *i*-th employee does not have an immediate manager. 

It is guaranteed, that no employee will be the immediate manager of him/herself (*p**i*<=≠<=*i*). Also, there will be no managerial cycles.",Print a single integer denoting the minimum number of groups that will be formed in the party.,['5\n-1\n1\n2\n1\n-1\n'],['3\n'],"For the first example, three groups are sufficient, for example: 
 -  Employee 1 -  Employees 2 and 4 -  Employees 3 and 5",OK,"from collections import d,f

n = int(input())
a = d(list)

for i in range(1,n+1):
    a[int(input())].append(i)

def b(g):
    e = 0

    while g:
        e += 1
        k = len(g)

        for j in range(k):
            h = g.popleft()

            for c in a[h]:
                g.append(c)

    return e

print(b(f(a[-1])))","s = input().strip()

t = input().strip()

if t == s[::-1]:
    print(""YES"")
else:
    print(""NO"")"
520,B,Two Buttons,PROGRAMMING,"['dfs and similar', 'graphs', 'greedy', 'implementation', 'math', 'shortest paths']","Vasya has found a strange device. On the front panel of a device there are: a red button, a blue button and a display showing some positive integer. After clicking the red button, device multiplies the displayed number by two. After clicking the blue button, device subtracts one from the number on the display. If at some point the number stops being positive, the device breaks down. The display can show arbitrarily large numbers. Initially, the display shows number *n*.

Bob wants to get number *m* on the display. What minimum number of clicks he has to make in order to achieve this result?","The first and the only line of the input contains two distinct integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=104), separated by a space .",Print a single number — the minimum number of times one needs to push the button required to get the number *m* out of number *n*.,"['4 6\n', '10 1\n']","['2\n', '9\n']","In the first example you need to push the blue button once, and then push the red button once.

In the second example, doubling the number is unnecessary, so we need to push the blue button nine times.",OK,"def a(n, m):
    if n >= m:
        return n - m
    elif m % 2 == 0:
        return 1 + a(n, m // 2)
    else:
        return 1 + a(n, m + 1)

n, m = map(int, input().split())
print(a(n, m))","import l
import a

def e(n, r):
    """"""Compute the combination n choose r for small r (r <= 3).""""""
    if n < r:
        return 0
    if r == 0:
        return 1
    if r == 1:
        return n
    if r == 2:
        return n * (n - 1) // 2
    if r == 3:
        return n * (n - 1) * (n - 2) // 6
    return 0

def k():

    f = l.stdin.read().strip().split()
    if not f:
        return

    g = int(f[0])
    d = int(f[1])
    f = int(f[2])
    j = 3

    i = list(map(int, f[j:j + g]))
    j += g

    g = list(map(int, f[j:j + d]))
    j += d

    h = list(map(int, f[j:j + f]))
    j += f

    i.sort()
    g.sort()
    h.sort()

    m = 0

    for m in i:

        b = a.bisect_right(g, 2 * m) - a.bisect_right(g, m)
        c = a.bisect_right(h, 2 * m) - a.bisect_right(h, m)
        n = e(b, 2) * e(c, 3)
        m += n

    for m in g:
        d = a.bisect_right(i, 2 * m) - a.bisect_right(i, m)
        b = a.bisect_right(g, 2 * m) - a.bisect_right(g, m)
        c = a.bisect_right(h, 2 * m) - a.bisect_right(h, m)
        n = e(d, 1) * e(b, 1) * e(c, 3)
        m += n

    for m in h:
        d = a.bisect_right(i, 2 * m) - a.bisect_right(i, m)
        b = a.bisect_right(g, 2 * m) - a.bisect_right(g, m)
        c = a.bisect_right(h, 2 * m) - a.bisect_right(h, m)
        n = e(d, 1) * e(b, 2) * e(c, 2)
        m += n

    l.stdout.write(str(m))

if __name__ == '__main__':
    k()"
847,E,Packmen,PROGRAMMING,"['binary search', 'dp']","A game field is a strip of 1<=×<=*n* square cells. In some cells there are Packmen, in some cells — asterisks, other cells are empty.

Packman can move to neighboring cell in 1 time unit. If there is an asterisk in the target cell then Packman eats it. Packman doesn't spend any time to eat an asterisk.

In the initial moment of time all Packmen begin to move. Each Packman can change direction of its move unlimited number of times, but it is not allowed to go beyond the boundaries of the game field. Packmen do not interfere with the movement of other packmen; in one cell there can be any number of packmen moving in any directions.

Your task is to determine minimum possible time after which Packmen can eat all the asterisks.","The first line contains a single integer *n* (2<=≤<=*n*<=≤<=105) — the length of the game field.

The second line contains the description of the game field consisting of *n* symbols. If there is symbol '.' in position *i* — the cell *i* is empty. If there is symbol '*' in position *i* — in the cell *i* contains an asterisk. If there is symbol 'P' in position *i* — Packman is in the cell *i*.

It is guaranteed that on the game field there is at least one Packman and at least one asterisk.",Print minimum possible time after which Packmen can eat all asterisks.,"['7\n*..P*P*\n', '10\n.**PP.*P.*\n']","['3\n', '2\n']","In the first example Packman in position 4 will move to the left and will eat asterisk in position 1. He will spend 3 time units on it. During the same 3 time units Packman in position 6 will eat both of neighboring with it asterisks. For example, it can move to the left and eat asterisk in position 5 (in 1 time unit) and then move from the position 5 to the right and eat asterisk in the position 7 (in 2 time units). So in 3 time units Packmen will eat all asterisks on the game field.

In the second example Packman in the position 4 will move to the left and after 2 time units will eat asterisks in positions 3 and 2. Packmen in positions 5 and 8 will move to the right and in 2 time units will eat asterisks in positions 7 and 10, respectively. So 2 time units is enough for Packmen to eat all asterisks on the game field.",RUNTIME_ERROR,"import j

j.setrecursionlimit(2 * 10 ** 6)

def k():
    pass

def f():
    N = int(input())
    for _ in range(N):
        n = int(input())
        i = list(map(int, input().split()))
        e = []
        for _ in range(n):
            l, r = map(int, input().split())
            e.append((l, r))
        b = [[] for _ in range(n)]
        for i, p in enumerate(i):
            b[p - 1].append(i + 1)

        def c(i):
            if b[i]:
                a = 0
                g = 0
                for j in b[i]:
                    c, m = c(j)
                    g += m
                    a += c
                if g < e[i][0]:
                    a += 1
                    g = e[i][1]
                g = min(g, e[i][1])
                return a, g
            else:
                return 1, e[i][1]

        print(c(0)[0])

def d():
    import j
    import h
    if 'CP_LOCAL_ENV' in h.environ:
        k()
        j.stdin = open('test.txt')

if __name__ == '__main__':
    d()
    f()","import g
import math

def d(x):
    """"""
    Check if the number x is almost prime (has exactly two distinct prime divisors).
    """"""
    b = 0

    if x % 2 == 0:
        b += 1

        while x % 2 == 0:
            x //= 2

    c = 3
    while c * c <= x:
        if x % c == 0:
            b += 1

            while x % c == 0:
                x //= c
        c += 2

    if x > 1:
        b += 1
    return b == 2

def e():

    f = g.stdin.read().strip().split()
    if not f:
        return
    try:
        n = int(f[0])
    except ValueError:
        return

    a = 0

    for i in range(1, n + 1):
        if d(i):
            a += 1

    g.stdout.write(str(a) + ""\n"")

if __name__ == ""__main__"":
    e()"
870,C,Maximum splitting,PROGRAMMING,"['dp', 'greedy', 'math', 'number theory']","You are given several queries. In the *i*-th query you are given a single positive integer *n**i*. You are to represent *n**i* as a sum of maximum possible number of composite summands and print this maximum number, or print -1, if there are no such splittings.

An integer greater than 1 is composite, if it is not prime, i.e. if it has positive divisors not equal to 1 and the integer itself.","The first line contains single integer *q* (1<=≤<=*q*<=≤<=105) — the number of queries.

*q* lines follow. The (*i*<=+<=1)-th line contains single integer *n**i* (1<=≤<=*n**i*<=≤<=109) — the *i*-th query.","For each query print the maximum possible number of summands in a valid splitting to composite summands, or -1, if there are no such splittings.","['1\n12\n', '2\n6\n8\n', '3\n1\n2\n3\n']","['3\n', '1\n2\n', '-1\n-1\n-1\n']","12 = 4 + 4 + 4 = 4 + 8 = 6 + 6 = 12, but the first splitting has the maximum possible number of summands.

8 = 4 + 4, 6 can't be split into several composite summands.

1, 2, 3 are less than any composite number, so they do not have valid splittings.",WRONG_ANSWER,"def a(n):
    if (n <= 1):
        return False
    if (n <= 3):
        return False
    if (n % 2 == 0 or n % 3 == 0):
        return True
    i = 5
    while(i * i <= n):
         
        if (n % i == 0 or n % (i + 2) == 0):
            return True
        i = i + 6
         
    return False
for i in range(int(input())):
    n=int(input())
    u=[]
    for i in range(1,n+1):
        if n%i==0 and a(i)==True:
            u.append(i)
    if len(u)==0:
        print(-1)
    else:
        print(n//u[0])","import j

def g():

    b = j.stdin.read().splitlines()
    if not b:
        return

    n, m = map(int, b[0].split())

    d = [list(f.strip()) for f in b[1:1+n]]

    i = []
    for i in range(n):
        c = {}
        for e in d[i]:
            c[e] = c.get(e, 0) + 1
        i.append(c)

    a = []
    for j in range(m):
        c = {}
        for i in range(n):
            e = d[i][j]
            c[e] = c.get(e, 0) + 1
        a.append(c)

    h = []
    for i in range(n):
        for j in range(m):
            e = d[i][j]

            if i[i][e] == 1 and a[j][e] == 1:
                h.append(e)

    print("""".join(h))

if __name__ == '__main__':
    g()"
593,A,2Char,PROGRAMMING,"['brute force', 'implementation']","Andrew often reads articles in his favorite magazine 2Char. The main feature of these articles is that each of them uses at most two distinct letters. Andrew decided to send an article to the magazine, but as he hasn't written any article, he just decided to take a random one from magazine 26Char. However, before sending it to the magazine 2Char, he needs to adapt the text to the format of the journal. To do so, he removes some words from the chosen article, in such a way that the remaining text can be written using no more than two distinct letters.

Since the payment depends from the number of non-space characters in the article, Andrew wants to keep the words with the maximum total length.","The first line of the input contains number *n* (1<=≤<=*n*<=≤<=100) — the number of words in the article chosen by Andrew. Following are *n* lines, each of them contains one word. All the words consist only of small English letters and their total length doesn't exceed 1000. The words are not guaranteed to be distinct, in this case you are allowed to use a word in the article as many times as it appears in the input.",Print a single integer — the maximum possible total length of words in Andrew's article.,"['4\nabb\ncacc\naaa\nbbb\n', '5\na\na\nbcbcb\ncdecdecdecdecdecde\naaaa\n']","['9', '6']","In the first sample the optimal way to choose words is {'abb', 'aaa', 'bbb'}.

In the second sample the word 'cdecdecdecdecdecde' consists of three distinct letters, and thus cannot be used in the article. The optimal answer is {'a', 'a', 'aaaa'}.",OK,"n = int(input())
h = [input().strip() for _ in range(n)]

e = 0

for a in 'abcdefghijklmnopqrstuvwxyz':
    for b in 'abcdefghijklmnopqrstuvwxyz':
        c = 0
        for g in h:
            f = True
            for d in g:
                if d != a and d != b:
                    f = False
                    break
            if f:
                c += len(g)
        e = max(e, c)

print(e)","s = input().strip()

t = input().strip()

if t == s[::-1]:
    print(""YES"")
else:
    print(""NO"")"
359,C,Prime Number,PROGRAMMING,"['math', 'number theory']","Simon has a prime number *x* and an array of non-negative integers *a*1,<=*a*2,<=...,<=*a**n*.

Simon loves fractions very much. Today he wrote out number  on a piece of paper. After Simon led all fractions to a common denominator and summed them up, he got a fraction: , where number *t* equals *x**a*1<=+<=*a*2<=+<=...<=+<=*a**n*. Now Simon wants to reduce the resulting fraction. 

Help him, find the greatest common divisor of numbers *s* and *t*. As GCD can be rather large, print it as a remainder after dividing it by number 1000000007 (109<=+<=7).","The first line contains two positive integers *n* and *x* (1<=≤<=*n*<=≤<=105, 2<=≤<=*x*<=≤<=109) — the size of the array and the prime number.

The second line contains *n* space-separated integers *a*1,<=*a*2,<=...,<=*a**n* (0<=≤<=*a*1<=≤<=*a*2<=≤<=...<=≤<=*a**n*<=≤<=109).",Print a single number — the answer to the problem modulo 1000000007 (109<=+<=7).,"['2 2\n2 2\n', '3 3\n1 2 3\n', '2 2\n29 29\n', '4 5\n0 0 0 0\n']","['8\n', '27\n', '73741817\n', '1\n']","In the first sample <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/7745f7cc87c6c5f753e3414fad9baa3b1e3fea48.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>. Thus, the answer to the problem is 8.

In the second sample, <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/acb3d7990f024100be499bcb59828fa6e23a867d.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>. The answer to the problem is 27, as 351 = 13·27, 729 = 27·27.

In the third sample the answer to the problem is 1073741824 *mod* 1000000007 = 73741817.

In the fourth sample <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/05a5fca3fb4690369838ff6dfeda521c959aa937.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>. Thus, the answer to the problem is 1.",WRONG_ANSWER,"a = 1000000007

def f(x, y, d):
    g = 1
    while y:
        if y & 1:
            g = (g * x) % d
        x = (x * x) % d
        y >>= 1
    return g

n, x = map(int, input().split())
a = list(map(int, input().split()))

t = sum(a)
e = f(x, t, a)
c = 1
for b in a:
    c = (c * f(b + 1, a - 2, a)) % a

g = (e * c) % a
print(g)","def f():
    import h
    h.setrecursionlimit(10**6)
    b = h.stdin.read().strip().split()

    e = iter(b)
    n = int(next(e))
    m = int(next(e))

    c = []
    for _ in range(m):
        l = int(next(e))
        r = int(next(e))
        x = int(next(e))
        c.append((l, r, x))

    g = [i for i in range(n + 2)]
    
    def d(x):

        if g[x] != x:
            g[x] = d(g[x])
        return g[x]

    a = [0] * (n + 1)

    for l, r, x in c:

        i = d(l)
        while i <= r:
            if i == x:

                g[i] = d(i + 1)
                i = d(i)
            else:

                a[i] = x

                g[i] = d(i + 1)
                i = d(i)

    h.stdout.write("" "".join(str(a[i]) for i in range(1, n + 1)) + "" "")

if __name__ == '__main__':
    f()"
958,E1,Guard Duty (easy),PROGRAMMING,"['brute force', 'geometry', 'greedy', 'math']","The Rebel fleet is afraid that the Empire might want to strike back again. Princess Heidi needs to know if it is possible to assign *R* Rebel spaceships to guard *B* bases so that every base has exactly one guardian and each spaceship has exactly one assigned base (in other words, the assignment is a perfect matching). Since she knows how reckless her pilots are, she wants to be sure that any two (straight) paths – from a base to its assigned spaceship – do not intersect in the galaxy plane (that is, in 2D), and so there is no risk of collision.","The first line contains two space-separated integers *R*,<=*B*(1<=≤<=*R*,<=*B*<=≤<=10). For 1<=≤<=*i*<=≤<=*R*, the *i*<=+<=1-th line contains two space-separated integers *x**i* and *y**i* (|*x**i*|,<=|*y**i*|<=≤<=10000) denoting the coordinates of the *i*-th Rebel spaceship. The following *B* lines have the same format, denoting the position of bases. It is guaranteed that no two points coincide and that no three points are on the same line.","If it is possible to connect Rebel spaceships and bases so as satisfy the constraint, output Yes, otherwise output No (without quote).","['3 3\n0 0\n2 0\n3 1\n-2 1\n0 3\n2 2\n', '2 1\n1 0\n2 2\n3 1\n']","['Yes\n', 'No\n']","For the first example, one possible way is to connect the Rebels and bases in order.

For the second example, there is no perfect matching between Rebels and bases.",OK,"def c(A, B, C):
    return (C[1] - A[1]) * (B[0] - A[0]) > (B[1] - A[1]) * (C[0] - A[0])

def e(A, B, C, D):
    return c(A, C, D) != c(B, C, D) and c(A, B, C) != c(A, B, D)

R, B = map(int, input().split())

i = []
b = []
for r in range(R):
    i.append(list(map(int, input().split())))
for r in range(B):
    b.append(list(map(int, input().split())))

if R != B:
    print('No')
else:
    def g(a, d, h):
        if a >= B:
            return True
        for b in h:
            for r, d in zip(i, d):
                if e(r, b[d], i[a], b[b]):
                    break
            else:
                f = g(a + 1, d + [b], h - {b})
                if f:
                    return True
        return False

    print(['NO', 'YES'][g(0, [], set(range(B)))])","n = int(input().strip())

a = list(map(int, input().split()))

a = False
for i in range(n):
    for j in range(n):
        if j == i:
            continue
        for k in range(n):
            if k == i or k == j:
                continue

            if a[i] == a[j] + a[k]:

                print(i + 1, j + 1, k + 1)
                a = True
                break
        if a:
            break
    if a:
        break

if not a:
    print(-1)"
767,A,Snacktower,PROGRAMMING,"['data structures', 'implementation']","According to an old legeng, a long time ago Ankh-Morpork residents did something wrong to miss Fortune, and she cursed them. She said that at some time *n* snacks of distinct sizes will fall on the city, and the residents should build a Snacktower of them by placing snacks one on another. Of course, big snacks should be at the bottom of the tower, while small snacks should be at the top.

Years passed, and once different snacks started to fall onto the city, and the residents began to build the Snacktower.

However, they faced some troubles. Each day exactly one snack fell onto the city, but their order was strange. So, at some days the residents weren't able to put the new stack on the top of the Snacktower: they had to wait until all the bigger snacks fell. Of course, in order to not to anger miss Fortune again, the residents placed each snack on the top of the tower immediately as they could do it.

Write a program that models the behavior of Ankh-Morpork residents.","The first line contains single integer *n* (1<=≤<=*n*<=≤<=100<=000) — the total number of snacks.

The second line contains *n* integers, the *i*-th of them equals the size of the snack which fell on the *i*-th day. Sizes are distinct integers from 1 to *n*.","Print *n* lines. On the *i*-th of them print the sizes of the snacks which the residents placed on the top of the Snacktower on the *i*-th day in the order they will do that. If no snack is placed on some day, leave the corresponding line empty.","['3\n3 1 2\n', '5\n4 5 1 2 3\n']","['3\n\xa0\n2 1', '5 4\n\xa0\n\xa0\n3 2 1\n']","In the example a snack of size 3 fell on the first day, and the residents immediately placed it. On the second day a snack of size 1 fell, and the residents weren't able to place it because they were missing the snack of size 2. On the third day a snack of size 2 fell, and the residents immediately placed it. Right after that they placed the snack of size 1 which had fallen before.",OK,"import f
import heapq

def e(a):
    g = [False] * len(a)
    c = len(g) - 1

    for n in a:
        g[n - 1] = True
        b = []
        while c >= 0 and g[c]:
            b.append(c + 1)
            c -= 1

        print("" "".join(str(d) for d in b))

if __name__ == ""__main__"":
    for e, d in enumerate(f.stdin.readlines()):
        if e == 0:
            continue
        else:
            a = list(map(int, d.strip().split()))

    e(a)","import k

def g():

    e = k.stdin.read().split()
    if not e:
        return

    n = int(e[0])
    c = []
    l = 0
    m = 0
    f = 1

    for _ in range(n):
        l = int(e[f])
        r = int(e[f + 1])
        f += 2
        l += l
        m += r
        c.append((l, r))

    d = abs(l - m)
    b = 0
    a = d

    for i in range(n):
        l, r = c[i]

        i = l - l + r
        j = m - r + l
        h = abs(i - j)

        if h > a:
            a = h
            b = i + 1

    k.stdout.write(str(b))

if __name__ == '__main__':
    g()"
614,A,Link/Cut Tree,PROGRAMMING,"['brute force', 'implementation']","Programmer Rostislav got seriously interested in the Link/Cut Tree data structure, which is based on Splay trees. Specifically, he is now studying the *expose* procedure.

Unfortunately, Rostislav is unable to understand the definition of this procedure, so he decided to ask programmer Serezha to help him. Serezha agreed to help if Rostislav solves a simple task (and if he doesn't, then why would he need Splay trees anyway?)

Given integers *l*, *r* and *k*, you need to print all powers of number *k* within range from *l* to *r* inclusive. However, Rostislav doesn't want to spent time doing this, as he got interested in playing a network game called Agar with Gleb. Help him!","The first line of the input contains three space-separated integers *l*, *r* and *k* (1<=≤<=*l*<=≤<=*r*<=≤<=1018, 2<=≤<=*k*<=≤<=109).","Print all powers of number *k*, that lie within range from *l* to *r* in the increasing order. If there are no such numbers, print ""-1"" (without the quotes).","['1 10 2\n', '2 4 5\n']","['1 2 4 8 ', '-1']","Note to the first sample: numbers 2<sup class=""upper-index"">0</sup> = 1, 2<sup class=""upper-index"">1</sup> = 2, 2<sup class=""upper-index"">2</sup> = 4, 2<sup class=""upper-index"">3</sup> = 8 lie within the specified range. The number 2<sup class=""upper-index"">4</sup> = 16 is greater then 10, thus it shouldn't be printed.",OK,"def x():
    l, r, k = [int(s) for s in input().split()]
    a = k
    if l == 1:
        yield 1
    while k<=r:
        if l <= k <= r:
            yield k
        k*=a
        if k>r:
            break
d = [i for i in x()]
if len(d):
    print(*d)
else:
    print(-1)","def c(n, b):

    d = 0
    e = 0

    for a in b:
        if a == 25:

            d += 1
        elif a == 50:

            if d == 0:
                return False
            d -= 1
            e += 1
        elif a == 100:

            if e > 0 and d > 0:
                e -= 1
                d -= 1
            elif d >= 3:
                d -= 3
            else:
                return False
        else:

            return False
    return True

if __name__ == '__main__':
    import h
    f = h.stdin.read().split()

    if not f:
        h.exit(0)
    n = int(f[0])

    b = list(map(int, f[1:n+1]))

    g = c(n, b)

    if g:
        h.stdout.write(""YES\n"")
    else:
        h.stdout.write(""NO\n"")"
429,A,Xor-tree,PROGRAMMING,"['dfs and similar', 'trees']","Iahub is very proud of his recent discovery, propagating trees. Right now, he invented a new tree, called xor-tree. After this new revolutionary discovery, he invented a game for kids which uses xor-trees.

The game is played on a tree having *n* nodes, numbered from 1 to *n*. Each node *i* has an initial value *init**i*, which is either 0 or 1. The root of the tree is node 1.

One can perform several (possibly, zero) operations on the tree during the game. The only available type of operation is to pick a node *x*. Right after someone has picked node *x*, the value of node *x* flips, the values of sons of *x* remain the same, the values of sons of sons of *x* flips, the values of sons of sons of sons of *x* remain the same and so on.

The goal of the game is to get each node *i* to have value *goal**i*, which can also be only 0 or 1. You need to reach the goal of the game by using minimum number of operations.","The first line contains an integer *n* (1<=≤<=*n*<=≤<=105). Each of the next *n*<=-<=1 lines contains two integers *u**i* and *v**i* (1<=≤<=*u**i*,<=*v**i*<=≤<=*n*; *u**i*<=≠<=*v**i*) meaning there is an edge between nodes *u**i* and *v**i*. 

The next line contains *n* integer numbers, the *i*-th of them corresponds to *init**i* (*init**i* is either 0 or 1). The following line also contains *n* integer numbers, the *i*-th number corresponds to *goal**i* (*goal**i* is either 0 or 1).","In the first line output an integer number *cnt*, representing the minimal number of operations you perform. Each of the next *cnt* lines should contain an integer *x**i*, representing that you pick a node *x**i*.",['10\n2 1\n3 1\n4 2\n5 1\n6 2\n7 5\n8 6\n9 8\n10 5\n1 0 1 1 0 1 0 1 0 1\n1 0 1 0 0 1 1 1 0 1\n'],['2\n4\n7\n'],none,RUNTIME_ERROR,"from collections import defaultdict, deque, Counter, OrderedDict
from bisect import insort, bisect_right, bisect_left
import m, k

def i():
    n = int(input())
    a = [[] for i in range(n + 1)]
    for i in range(n - 1):
        a, b = map(int, input().split())
        a, b = a - 1, b - 1
        a[a].append(b)
        a[b].append(a)
    h = [int(i) for i in input().split()]
    g = [int(i) for i in input().split()]
    n = [0] * n
    j = [[] for i in range(n)]

    def c(s, p):
        if n[s]: return
        n[s] = 1
        j[p].append(s)
        for i in a[s]:
            c(i, s)

    c(0, 0)
    j[0] = j[0][1:]
    b = []

    def d(s, l, f, e):
        if l % 2 == 0:
            if e % 2 == 1:
                h[s] = 1 - h[s]
        else:
            if f % 2 == 1:
                h[s] = 1 - h[s]
        if h[s] != g[s]:
            b.append(s + 1)
            if l % 2:
                f += 1
            else:
                e += 1
        for j in j[s]:
            d(j, l + 1, f, e)

    d(0, 0, 0, 0)

    print(len(b))
    print(""\n"".join(map(str, b)))

if __name__ == ""__main__"":
    k.setrecursionlimit(200000)
    m.stack_size(10240000)
    l = m.Thread(target=i)
    l.start()","import i
import f

def e():

    c = i.stdin.read().strip().split()
    if not c:
        return
    n = int(c[0])
    a = list(map(int, c[1:]))

    a.sort()

    d = []
    b = []
    h = None
    for g in a:
        if g != h:
            d.append(g)
            b.append(1)
            h = g
        else:
            b[-1] += 1

    if b[0] >= 3:
        a = f.comb(b[0], 3)

    elif b[0] == 2:
        a = f.comb(2, 2) * b[1]

    else:

        if b[1] >= 2:
            a = 1 * f.comb(b[1], 2)

        else:
            a = 1 * b[1] * b[2]

    i.stdout.write(str(a) + ""\n"")

if __name__ == '__main__':
    e()"
887,B,Cubes for Masha,PROGRAMMING,"['brute force', 'implementation']","Absent-minded Masha got set of *n* cubes for her birthday.

At each of 6 faces of each cube, there is exactly one digit from 0 to 9. Masha became interested what is the largest natural *x* such she can make using her new cubes all integers from 1 to *x*.

To make a number Masha can rotate her cubes and put them in a row. After that, she looks at upper faces of cubes from left to right and reads the number.

The number can't contain leading zeros. It's not required to use all cubes to build a number.

Pay attention: Masha can't make digit 6 from digit 9 and vice-versa using cube rotations.","In first line integer *n* is given (1<=≤<=*n*<=≤<=3) — the number of cubes, Masha got for her birthday.

Each of next *n* lines contains 6 integers *a**i**j* (0<=≤<=*a**i**j*<=≤<=9) — number on *j*-th face of *i*-th cube.",Print single integer — maximum number *x* such Masha can make any integers from 1 to *x* using her cubes or 0 if Masha can't make even 1.,"['3\n0 1 2 3 4 5\n6 7 8 9 0 1\n2 3 4 5 6 7\n', '3\n0 1 3 5 6 8\n1 2 4 5 7 8\n2 3 4 6 7 9\n']","['87', '98']","In the first test case, Masha can build all numbers from 1 to 87, but she can't make 88 because there are no two cubes with digit 8.",OK,"def a():
    return list(map(int, input().split()))

n = int(input())
c = list()
for i in range(n):
    c.append(a())

s = set()
for i in range(n):
    for x in c[i]:
        s.add(x)
if n >= 2:
    for i in range(n):
        for j in range(n):
            if i == j:
                continue
            for x in c[i]:
                for y in c[j]:
                    if x != 0:
                        s.add(x*10+y)
if n >= 3:
    for i in range(n):
        for j in range(n):
            if i == j:
                continue
            for k in range(n):
                if i == k or j == k:
                    continue
                for x in c[i]:
                    for y in c[j]:
                        for z in c[k]:
                            if x != 0:
                                s.add(x*100+y*10+z)
if 0 in s:
    s.remove(0)
b = 0
for x in s:
    if x == b+1:
        b += 1
    else:
        print(b)
        exit(0)
print(b)","def e():
    import g

    d = g.stdin.read().split()
    if not d:
        return

    s = d[0]

    k = int(d[1])

    i = list(map(int, d[2:28]))

    f = max(i)
    
    h = 0

    for c, a in enumerate(s):
        h += (c + 1) * i[ord(a) - ord('a')]

    b = len(s)
    for j in range(1, k + 1):
        h += (b + j) * f

    g.stdout.write(str(h))

if __name__ == ""__main__"":
    e()"
224,A,Parallelepiped,PROGRAMMING,"['brute force', 'geometry', 'math']",You've got a rectangular parallelepiped with integer edge lengths. You know the areas of its three faces that have a common vertex. Your task is to find the sum of lengths of all 12 edges of this parallelepiped.,The first and the single line contains three space-separated integers — the areas of the parallelepiped's faces. The area's values are positive (<=&gt;<=0) and do not exceed 104. It is guaranteed that there exists at least one parallelepiped that satisfies the problem statement.,Print a single number — the sum of all edges of the parallelepiped.,"['1 1 1\n', '4 6 6\n']","['12\n', '28\n']","In the first sample the parallelepiped has sizes 1 × 1 × 1, in the second one — 2 × 2 × 3.",OK,"import d,c,io,time,copy
if c.path.exists('input.txt'):
    d.stdin = open('input.txt', 'r')
    d.stdout = open('output.txt', 'w')

import math

def a(n):
    if n//1==n/1:
        return True
    else:
        return False

def b():

    a,b,c=map(int,input().split())
    for i in range(1,10001):
        x=i
        y=a/i
        z=c/i
        if a(x) and a(y) and a(z) and y*z==b:
            print(4*int(x+y+z))
            break

b()","def a():

    n = int(input().strip())

    b = 0
    c = 0
    d = 0

    for _ in range(n):
        x, y, z = map(int, input().split())
        b += x
        c += y
        d += z

    if b == 0 and c == 0 and d == 0:
        print(""YES"")
    else:
        print(""NO"")

if __name__ == ""__main__"":
    a()"
772,B,Volatile Kite,PROGRAMMING,['geometry'],"You are given a convex polygon *P* with *n* distinct vertices *p*1,<=*p*2,<=...,<=*p**n*. Vertex *p**i* has coordinates (*x**i*,<=*y**i*) in the 2D plane. These vertices are listed in clockwise order.

You can choose a real number *D* and move each vertex of the polygon a distance of at most *D* from their original positions.

Find the maximum value of *D* such that no matter how you move the vertices, the polygon does not intersect itself and stays convex.","The first line has one integer *n* (4<=≤<=*n*<=≤<=1<=000) — the number of vertices.

The next *n* lines contain the coordinates of the vertices. Line *i* contains two integers *x**i* and *y**i* (<=-<=109<=≤<=*x**i*,<=*y**i*<=≤<=109) — the coordinates of the *i*-th vertex. These points are guaranteed to be given in clockwise order, and will form a strictly convex polygon (in particular, no three consecutive points lie on the same straight line).","Print one real number *D*, which is the maximum real number such that no matter how you move the vertices, the polygon stays convex.

Your answer will be considered correct if its absolute or relative error does not exceed 10<=-<=6.

Namely, let's assume that your answer is *a* and the answer of the jury is *b*. The checker program will consider your answer correct if .","['4\n0 0\n0 1\n1 1\n1 0\n', '6\n5 0\n10 0\n12 -4\n10 -8\n5 -8\n3 -4\n']","['0.3535533906\n', '1.0000000000\n']","Here is a picture of the first sample

<img class=""tex-graphics"" src=""https://espresso.codeforces.com/f83aa076d2f437f9bb785cae769c3ae310eff351.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

Here is an example of making the polygon non-convex.

<img class=""tex-graphics"" src=""https://espresso.codeforces.com/fbadb81630251ca642bd4ddf9088876ade761630.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

This is not an optimal solution, since the maximum distance we moved one point is  ≈ 0.4242640687, whereas we can make it non-convex by only moving each point a distance of at most  ≈ 0.3535533906.",OK,"from math import b

def c(x, y):
    return abs(sum([x[i]*(y[(i+1)%3]-y[(i+2)%3]) for i in range(3)]))
def l(x, y):
    return ((x[0]-x[2])**2 + (y[0]-y[2])**2)**0.5
def h(x, y):
    return c(x, y) / l(x, y)

n = int(input())
x = []
y = []
for i in range(n):
    a, b = [int(x) for x in input().split()]
    x.append(a)
    y.append(b)
x += x[:2]
y += y[:2]

a = b
for i in range(n):
    d = h(x[i:i+3], y[i:i+3])/2
    if a > d:
        a = d

print(a)","n, k, l, c, d, p, b, c = map(int, input().split())

h = k * l

i = c * d

d = h // b
e = i
f = p // c

a = min(d, e, f)

g = a // n

print(g)"
369,A,Valera and Plates,PROGRAMMING,"['greedy', 'implementation']","Valera is a lazy student. He has *m* clean bowls and *k* clean plates. 

Valera has made an eating plan for the next *n* days. As Valera is lazy, he will eat exactly one dish per day. At that, in order to eat a dish, he needs exactly one clean plate or bowl. We know that Valera can cook only two types of dishes. He can eat dishes of the first type from bowls and dishes of the second type from either bowls or plates. 

When Valera finishes eating, he leaves a dirty plate/bowl behind. His life philosophy doesn't let him eat from dirty kitchenware. So sometimes he needs to wash his plate/bowl before eating. Find the minimum number of times Valera will need to wash a plate/bowl, if he acts optimally.","The first line of the input contains three integers *n*, *m*, *k* (1<=≤<=*n*,<=*m*,<=*k*<=≤<=1000) — the number of the planned days, the number of clean bowls and the number of clean plates.

The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=2). If *a**i* equals one, then on day *i* Valera will eat a first type dish. If *a**i* equals two, then on day *i* Valera will eat a second type dish.",Print a single integer — the minimum number of times Valera will need to wash a plate/bowl.,"['3 1 1\n1 2 1\n', '4 3 1\n1 1 1 1\n', '3 1 2\n2 2 2\n', '8 2 2\n1 2 1 2 1 2 1 2\n']","['1\n', '1\n', '0\n', '4\n']","In the first sample Valera will wash a bowl only on the third day, so the answer is one.

In the second sample, Valera will have the first type of the dish during all four days, and since there are only three bowls, he will wash a bowl exactly once.

In the third sample, Valera will have the second type of dish for all three days, and as they can be eaten from either a plate or a bowl, he will never need to wash a plate/bowl.",OK,"n, m, k = list(map(int, input().split()))
a = list(map(int, input().split()))

def c(n, m, k, a):
    a = 0

    for b in a:
        if b == 1:
            if m > 0:
                m -= 1
            else:
                a += 1
        else:
            if m == 0 and k == 0:
                a += 1
            elif k > 0:
                k -= 1
            else:
                m -= 1

    return a

print(c(n, m, k, a))","def a(p, t, i):
    i = 0
    for j, b in enumerate(t):
        if i[j]:
            continue
        if b == p[i]:
            i += 1
            if i == len(p):
                return True
    return False

def f():
    import k
    d = k.stdin.read().splitlines()

    t = d[0].strip()
    p = d[1].strip()

    h = list(map(int, d[2].split()))
    n = len(t)

    e, c, j = 0, n, 0
    while e <= c:
        g = (e + c) // 2

        i = [False] * n
        for i in range(g):
            i[h[i] - 1] = True

        if a(p, t, i):
            j = g
            e = g + 1
        else:
            c = g - 1

    print(j)

if __name__ == ""__main__"":
    f()"
4,A,Watermelon,PROGRAMMING,"['brute force', 'math']","One hot summer day Pete and his friend Billy decided to buy a watermelon. They chose the biggest and the ripest one, in their opinion. After that the watermelon was weighed, and the scales showed *w* kilos. They rushed home, dying of thirst, and decided to divide the berry, however they faced a hard problem.

Pete and Billy are great fans of even numbers, that's why they want to divide the watermelon in such a way that each of the two parts weighs even number of kilos, at the same time it is not obligatory that the parts are equal. The boys are extremely tired and want to start their meal as soon as possible, that's why you should help them and find out, if they can divide the watermelon in the way they want. For sure, each of them should get a part of positive weight.",The first (and the only) input line contains integer number *w* (1<=≤<=*w*<=≤<=100) — the weight of the watermelon bought by the boys.,"Print YES, if the boys can divide the watermelon into two parts, each of them weighing even number of kilos; and NO in the opposite case.",['8\n'],['YES\n'],"For example, the boys can divide the watermelon into two parts of 2 and 6 kilos respectively (another variant — two parts of 4 and 4 kilos).",OK,"def a(w):

    if w < 4:
        return ""NO""

    if w % 2 == 0:
        return ""YES""
    
    return ""NO""

w = int(input())

print(a(w))","import w
import i

def k():

    f = w.stdin.read().strip().splitlines()

    if not f:
        return
    n = int(f[0])

    t = []
    e = []

    for j in f[1:]:
        if j.strip() == """":
            if e:
                t.append(e)
                e = []
        else:
            e.append(j.strip())
    if e:
        t.append(e)

    if len(t) != 4:

        return

    u = [(0,0), (0, n), (n, 0), (n, n)]

    b = [[[0, 0] for _ in range(4)] for _ in range(4)]

    for s in range(4):
        h = t[s]
        for q in range(4):
            n, m = u[q]
            for p in (0, 1):
                a = 0

                for r in range(n):
                    v = h[r]
                    for c in range(n):

                        c = int(v[c])
                        p = r + n
                        o = c + m

                        g = p ^ ((p + o) & 1)
                        if c != g:
                            a += 1
                b[s][q][p] = a

    l = float('inf')

    for q in i.permutations(range(4)):

        for p in (0, 1):
            d = 0
            for q in range(4):
                r = q[q]
                d += b[r][q][p]
            if d < l:
                l = d

    print(l)

if __name__ == '__main__':
    k()"
919,B,Perfect Number,PROGRAMMING,"['binary search', 'brute force', 'dp', 'implementation', 'number theory']","We consider a positive integer perfect, if and only if the sum of its digits is exactly $10$. Given a positive integer $k$, your task is to find the $k$-th smallest perfect positive integer.","A single line with a positive integer $k$ ($1 \leq k \leq 10\,000$).","A single number, denoting the $k$-th smallest perfect integer.","['1\n', '2\n']","['19\n', '28\n']",The first perfect integer is $19$ and the second one is $28$.,TIME_LIMIT_EXCEEDED,"n=int(input())
i=0
k=0
def s(x):
    x=list(str(x))
    x=list(map(int,x))
    return sum(x)
while(s(i)!=10 or k!=n):
    i=i+1
    if(s(i)==10):
        k=k+1
print(i)","def g():
    import n

    d = n.stdin.read().splitlines()
    if not d:
        return
    try:
        n = int(d[0].strip())
    except:
        return

    h = {}

    def j(s):
        """"""
        Given a candidate suffix string s (with fixed length, may have leading zeros),
        return the earliest year Y (>=1989) such that Y ends with s and s is used as the
        abbreviation for that year. For s of length L > 1, it is required that each proper
        (suffix) candidate of length < L has been used before year Y.
        """"""
        if s in h:
            return h[s]
        L = len(s)
        b = 10**L
        r = int(s)
        if L == 1:

            T = 1989

            c = T - (T % 10) + r
            if c < T:
                c += 10
            h[s] = c
            return c
        else:

            k = 0
            for k in range(1, L):
                l = s[-k:]
                o = j(l)
                if o > k:
                    k = o
            a = k + 1

            c = a - (a % b) + r
            if c < a:
                c += b

            while c < a:
                c += b
            h[s] = c
            return c

    i = []

    for f in d[1:1+n]:
        f = f.strip()
        if not f:
            continue

        try:
            e = f.index(""'"")
            m = f[e+1:]
        except ValueError:
            m = f
        p = j(m)
        i.append(str(p))
    n.stdout.write(""\n"".join(i))

if __name__ == ""__main__"":
    g()"
387,B,George and Round,PROGRAMMING,"['brute force', 'greedy', 'two pointers']","George decided to prepare a Codesecrof round, so he has prepared *m* problems for the round. Let's number the problems with integers 1 through *m*. George estimates the *i*-th problem's complexity by integer *b**i*.

To make the round good, he needs to put at least *n* problems there. Besides, he needs to have at least one problem with complexity exactly *a*1, at least one with complexity exactly *a*2, ..., and at least one with complexity exactly *a**n*. Of course, the round can also have problems with other complexities.

George has a poor imagination. It's easier for him to make some already prepared problem simpler than to come up with a new one and prepare it. George is magnificent at simplifying problems. He can simplify any already prepared problem with complexity *c* to any positive integer complexity *d* (*c*<=≥<=*d*), by changing limits on the input data.

However, nothing is so simple. George understood that even if he simplifies some problems, he can run out of problems for a good round. That's why he decided to find out the minimum number of problems he needs to come up with in addition to the *m* he's prepared in order to make a good round. Note that George can come up with a new problem of any complexity.","The first line contains two integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=3000) — the minimal number of problems in a good round and the number of problems George's prepared. The second line contains space-separated integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a*1<=&lt;<=*a*2<=&lt;<=...<=&lt;<=*a**n*<=≤<=106) — the requirements for the complexity of the problems in a good round. The third line contains space-separated integers *b*1,<=*b*2,<=...,<=*b**m* (1<=≤<=*b*1<=≤<=*b*2...<=≤<=*b**m*<=≤<=106) — the complexities of the problems prepared by George.",Print a single integer — the answer to the problem.,"['3 5\n1 2 3\n1 2 2 3 3\n', '3 5\n1 2 3\n1 1 1 1 1\n', '3 1\n2 3 4\n1\n']","['0\n', '2\n', '3\n']","In the first sample the set of the prepared problems meets the requirements for a good round.

In the second sample, it is enough to come up with and prepare two problems with complexities 2 and 3 to get a good round.

In the third sample it is very easy to get a good round if come up with and prepare extra problems with complexities: 2, 3, 4.",OK,"def a():
    b=input().split(' ')
    c=input().split(' ')
    d=input().split(' ')
    n=int(b[0])
    m=int(b[1])
    j=0
    for i in range(len(c)):
        while j<m and int(d[j])<int(c[i]):
           j+=1
        if j<m:
            n-=1
            j+=1
        else:
            break
    print(n)
if __name__ == ""__main__"":
    a()","def i():
    import j
    f = j.stdin.read().split()
    if not f:
        return

    n = int(f[0])
    g = []
    e = 1

    for i in range(n):
        t = int(f[e])
        c = int(f[e + 1])
        e += 2

        g.append((t, c))

    a = 10**18
    d = [a] * (n + 1)
    d[0] = 0
    
    for t, b in g:
        c = t + 1

        for j in range(n, -1, -1):
            h = j + c
            if h > n:
                h = n
            if d[j] + b < d[h]:
                d[h] = d[j] + b

    j.stdout.write(str(d[n]))
    
    
if __name__ == '__main__':
    i()"
59,A,Word,PROGRAMMING,"['implementation', 'strings']","Vasya is very upset that many people on the Net mix uppercase and lowercase letters in one word. That's why he decided to invent an extension for his favorite browser that would change the letters' register in every word so that it either only consisted of lowercase letters or, vice versa, only of uppercase ones. At that as little as possible letters should be changed in the word. For example, the word HoUse must be replaced with house, and the word ViP — with VIP. If a word contains an equal number of uppercase and lowercase letters, you should replace all the letters with lowercase ones. For example, maTRIx should be replaced by matrix. Your task is to use the given method on one given word.",The first line contains a word *s* — it consists of uppercase and lowercase Latin letters and possesses the length from 1 to 100.,"Print the corrected word *s*. If the given word *s* has strictly more uppercase letters, make the word written in the uppercase register, otherwise - in the lowercase one.","['HoUse\n', 'ViP\n', 'maTRIx\n']","['house\n', 'VIP\n', 'matrix\n']",none,OK,"n =input()
b = 0 ; a = 0
for i in n:
    if i.isupper():
        b+=1
    else:
        a+=1
if b > a:
    print(n.upper())
elif b < a:
    print(n.lower())
else: print(n.lower())","n = int(input().strip())
s = input().strip()

if n > 26:
    print(-1)
else:

    c = {}
    for a in s:
        c[a] = c.get(a, 0) + 1

    b = n - len(c)
    
    print(b)"
887,A,Div. 64,PROGRAMMING,['implementation'],"Top-model Izabella participates in the competition. She wants to impress judges and show her mathematical skills.

Her problem is following: for given string, consisting of only 0 and 1, tell if it's possible to remove some digits in such a way, that remaining number is a representation of some positive integer, divisible by 64, in the binary numerical system.",In the only line given a non-empty binary string *s* with length up to 100.,Print «yes» (without quotes) if it's possible to remove digits required way and «no» otherwise.,"['100010001\n', '100\n']","['yes', 'no']","In the first test case, you can get string 1 000 000 after removing two ones which is a representation of number 64 in the binary numerical system.

You can read more about binary numeral system representation here: [https://en.wikipedia.org/wiki/Binary_system](https://en.wikipedia.org/wiki/Binary_system)",WRONG_ANSWER,"a = 'Matias'

def h(e):
    i = True
    c = 0
    for a in e:
        if a == '0' or a == '1':
            c += 1
        else:
            i = False
            break
    return [i, c]

def g(e):
    f = 0
    d = 0
    for a in e:
        if a == ""1"":
            f = 1
        if a == ""0"" and f == 1:
            d += 1
        if d > 5:
            return True
            break
    return False

e = input(""Input: "")
i, c = h(e)
if i:
    if c > 6:
        b = g(e)
        if b:
            print(""yes"")
        else:
            print(""no"")
    else:
        print(""no"")
else:
    print(""no"")","a = input().strip()
b = input().strip()

c = []

for a, b in zip(a, b):

    if a != b:
        c.append('1')
    else:
        c.append('0')

print(''.join(c))"
811,A,Vladik and Courtesy,PROGRAMMING,"['brute force', 'implementation']","At regular competition Vladik and Valera won *a* and *b* candies respectively. Vladik offered 1 his candy to Valera. After that Valera gave Vladik 2 his candies, so that no one thought that he was less generous. Vladik for same reason gave 3 candies to Valera in next turn.

More formally, the guys take turns giving each other one candy more than they received in the previous turn.

This continued until the moment when one of them couldn’t give the right amount of candy. Candies, which guys got from each other, they don’t consider as their own. You need to know, who is the first who can’t give the right amount of candy.","Single line of input data contains two space-separated integers *a*, *b* (1<=≤<=*a*,<=*b*<=≤<=109) — number of Vladik and Valera candies respectively.","Pring a single line ""Vladik’’ in case, if Vladik first who can’t give right amount of candy, or ""Valera’’ otherwise.","['1 1\n', '7 6\n']","['Valera\n', 'Vladik\n']","Illustration for first test case:

<img class=""tex-graphics"" src=""https://espresso.codeforces.com/ad9b7d0e481208de8e3a585aa1d96b9e1dda4fd7.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

Illustration for second test case:

<img class=""tex-graphics"" src=""https://espresso.codeforces.com/9f4836d2ccdffaee5a63898e5d4e6caf2ed4678c.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>",OK,"def a():
	a , b = map(int,input().split())
	i = 1
	while 1:
		if(i&1):
			if(a >= i):
				a -= i
			else :
				print(""Vladik"")
				break 
		else :
			if( b >= i):
				b -= i
			else :
				print(""Valera"")
				break 
		i +=1 
if __name__ == '__main__':
	a()","def e(b, n):

    g = [False] * (n + 1)
    
    def a(u):
        g[u] = True
        for v in b[u]:
            if not g[v]:
                a(v)

    a(1)
    return all(g[i] for i in range(1, n + 1))

if __name__ == '__main__':
    import f
    d = f.stdin.read().split()

    n = int(d[0])
    m = int(d[1])

    b = [[] for _ in range(n + 1)]
    c = 2
    for _ in range(m):
        u = int(d[c])
        v = int(d[c + 1])
        c += 2
        b[u].append(v)
        b[v].append(u)

    if m != n or n < 3 or not e(b, n):
        f.stdout.write(""NO"")
    else:
        f.stdout.write(""FHTAGN!"")"
375,B,Maximum Submatrix 2,PROGRAMMING,"['data structures', 'dp', 'implementation', 'sortings']","You are given a matrix consisting of digits zero and one, its size is *n*<=×<=*m*. You are allowed to rearrange its rows. What is the maximum area of the submatrix that only consists of ones and can be obtained in the given problem by the described operations?

Let's assume that the rows of matrix *a* are numbered from 1 to *n* from top to bottom and the columns are numbered from 1 to *m* from left to right. A matrix cell on the intersection of the *i*-th row and the *j*-th column can be represented as (*i*,<=*j*). Formally, a submatrix of matrix *a* is a group of four integers *d*,<=*u*,<=*l*,<=*r* (1<=≤<=*d*<=≤<=*u*<=≤<=*n*; 1<=≤<=*l*<=≤<=*r*<=≤<=*m*). We will assume that the submatrix contains cells (*i*,<=*j*) (*d*<=≤<=*i*<=≤<=*u*; *l*<=≤<=*j*<=≤<=*r*). The area of the submatrix is the number of cells it contains.","The first line contains two integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=5000). Next *n* lines contain *m* characters each — matrix *a*. Matrix *a* only contains characters: ""0"" and ""1"". Note that the elements of the matrix follow without any spaces in the lines.","Print a single integer — the area of the maximum obtained submatrix. If we cannot obtain a matrix of numbers one, print 0.","['1 1\n1\n', '2 2\n10\n11\n', '4 3\n100\n011\n000\n101\n']","['1\n', '2\n', '2\n']",none,TIME_LIMIT_EXCEEDED,"'''input
1 1
1
'''
from sys import j
import math
from collections import defaultdict, deque

def i(f, n, m):
	d = [[0 for x in range(m)] for y in range(n)]
	for i in range(n):
		for j in range(m - 1, -1, -1):
			if j + 1 < m:
				if f[i][j] == '1':
					d[i][j] = 1 + d[i][j + 1] 
			else:
				if f[i][j] == '1':
					d[i][j] = 1
	return d

def c(b):
	a = -float('inf')
	for i in range(len(b)):
		a = max(a, b[i] * (i + 1))
	return a

def h(d, n, m, e):
	b = []
	for i in range(n):
		b.append(d[i][e])
	b.sort(reverse = True) 
	return c(b)

n, m = list(map(int, j.readline().split()))
f = []
for _ in range(n):
	f.append(list(j.readline().strip()))
d = i(f, n, m)

g = -float('inf')
for i in range(m):
	g = max(g, h(d, n, m, i))
print(g)","def d(t, p, i):

    j = 0
    for i in range(len(t)):
        if i not in i:
            if t[i] == p[j]:
                j += 1
                if j == len(p):
                    return True
    return j == len(p)

def f():
    import j

    b = j.stdin.read().splitlines()
    t = b[0].strip()
    p = b[1].strip()

    h = list(map(int, b[2].split()))
    n = len(t)

    e, c, a = 0, n, 0
    while e <= c:
        g = (e + c) // 2
        i = set()

        for i in range(g):
            i.add(h[i] - 1)
        if d(t, p, i):
            a = g
            e = g + 1
        else:
            c = g - 1

    j.stdout.write(str(a))

if __name__ == '__main__':
    f()"
701,C,They Are Everywhere,PROGRAMMING,"['binary search', 'strings', 'two pointers']","Sergei B., the young coach of Pokemons, has found the big house which consists of *n* flats ordered in a row from left to right. It is possible to enter each flat from the street. It is possible to go out from each flat. Also, each flat is connected with the flat to the left and the flat to the right. Flat number 1 is only connected with the flat number 2 and the flat number *n* is only connected with the flat number *n*<=-<=1.

There is exactly one Pokemon of some type in each of these flats. Sergei B. asked residents of the house to let him enter their flats in order to catch Pokemons. After consulting the residents of the house decided to let Sergei B. enter one flat from the street, visit several flats and then go out from some flat. But they won't let him visit the same flat more than once. 

Sergei B. was very pleased, and now he wants to visit as few flats as possible in order to collect Pokemons of all types that appear in this house. Your task is to help him and determine this minimum number of flats he has to visit.","The first line contains the integer *n* (1<=≤<=*n*<=≤<=100<=000) — the number of flats in the house.

The second line contains the row *s* with the length *n*, it consists of uppercase and lowercase letters of English alphabet, the *i*-th letter equals the type of Pokemon, which is in the flat number *i*.",Print the minimum number of flats which Sergei B. should visit in order to catch Pokemons of all types which there are in the house.,"['3\nAaA\n', '7\nbcAAcbc\n', '6\naaBCCe\n']","['2\n', '3\n', '5\n']","In the first test Sergei B. can begin, for example, from the flat number 1 and end in the flat number 2.

In the second test Sergei B. can begin, for example, from the flat number 4 and end in the flat number 6. 

In the third test Sergei B. must begin from the flat number 2 and end in the flat number 6.",TIME_LIMIT_EXCEEDED,"from sys import stdin,stdout
def a():return list(map(int,input().split()))

n=int(input())
d=input()

def b(f,k):
  g=set(f)
  for i in range(len(f)-k+1):
    if set(f[i:i+k])==g:
      return True
  return False

l, r=0, n
c=int(10e6)
while l<=r:
  e = l + (r-l)//2
  if b(d,e):
    c=min(c,e)
    r=e-1
  else:l=e+1
  
print(c)","import j

def d(s):

    c = 0
    for i in range(len(s) - 1):
        if s[i] == 'V' and s[i + 1] == 'K':
            c += 1
    return c

def g():

    e = j.stdin.readlines()
    
    for f in e:
        s = f.strip()
        if not s:
            continue

        a = d(s)

        for i in range(len(s)):

            i = s[i]

            h = 'V' if i == 'K' else 'K'
            b = s[:i] + h + s[i+1:]
            a = max(a, d(b))

        j.stdout.write(str(a) + ""\n"")

if __name__ == ""__main__"":
    g()"
71,A,Way Too Long Words,PROGRAMMING,['strings'],"Sometimes some words like ""localization"" or ""internationalization"" are so long that writing them many times in one text is quite tiresome.

Let's consider a word too long, if its length is strictly more than 10 characters. All too long words should be replaced with a special abbreviation.

This abbreviation is made like this: we write down the first and the last letter of a word and between them we write the number of letters between the first and the last letters. That number is in decimal system and doesn't contain any leading zeroes.

Thus, ""localization"" will be spelt as ""l10n"", and ""internationalization» will be spelt as ""i18n"".

You are suggested to automatize the process of changing the words with abbreviations. At that all too long words should be replaced by the abbreviation and the words that are not too long should not undergo any changes.",The first line contains an integer *n* (1<=≤<=*n*<=≤<=100). Each of the following *n* lines contains one word. All the words consist of lowercase Latin letters and possess the lengths of from 1 to 100 characters.,Print *n* lines. The *i*-th line should contain the result of replacing of the *i*-th word from the input data.,['4\nword\nlocalization\ninternationalization\npneumonoultramicroscopicsilicovolcanoconiosis\n'],['word\nl10n\ni18n\np43s\n'],none,WRONG_ANSWER,"def d():
    a = input(""Enter"")
    if len(a) > 10:
        b = """"
        b+=a[0]
        b+=str(len(a)-2)
        b+=a[-1]
        print(b)
    else:
        print(a)

c = int(input())

for i in range(c):
    d()","def c():

    n = int(input().strip())
    f = list(map(int, input().strip().split()))

    a = sum(1 for e in f[:3] if e % 2 == 0)

    d = a >= 2

    for b, e in enumerate(f, start=1):
        if (e % 2 == 0) != d:
            print(b)
            break

if __name__ == ""__main__"":
    c()"
820,A,Mister B and Book Reading,PROGRAMMING,['implementation'],"Mister B once received a gift: it was a book about aliens, which he started read immediately. This book had *c* pages.

At first day Mister B read *v*0 pages, but after that he started to speed up. Every day, starting from the second, he read *a* pages more than on the previous day (at first day he read *v*0 pages, at second — *v*0<=+<=*a* pages, at third — *v*0<=+<=2*a* pages, and so on). But Mister B is just a human, so he physically wasn't able to read more than *v*1 pages per day.

Also, to refresh his memory, every day, starting from the second, Mister B had to reread last *l* pages he read on the previous day. Mister B finished the book when he read the last page for the first time.

Help Mister B to calculate how many days he needed to finish the book.","First and only line contains five space-separated integers: *c*, *v*0, *v*1, *a* and *l* (1<=≤<=*c*<=≤<=1000, 0<=≤<=*l*<=&lt;<=*v*0<=≤<=*v*1<=≤<=1000, 0<=≤<=*a*<=≤<=1000) — the length of the book in pages, the initial reading speed, the maximum reading speed, the acceleration in reading speed and the number of pages for rereading.",Print one integer — the number of days Mister B needed to finish the book.,"['5 5 10 5 4\n', '12 4 12 4 1\n', '15 1 100 0 0\n']","['1\n', '3\n', '15\n']","In the first sample test the book contains 5 pages, so Mister B read it right at the first day.

In the second sample test at first day Mister B read pages number 1 - 4, at second day — 4 - 11, at third day — 11 - 12 and finished the book.

In third sample test every day Mister B read 1 page of the book, so he finished in 15 days.",WRONG_ANSWER,"import math

s = input()
b = s.split()
j = int(b[0])
d = int(b[1])
f = int(b[2])
a = int(b[3])
h = int(b[4])

def e(c):
  global d, f, a
  g = d + (c - 1) * a
  if c > 1:
    g = g - h
    
  if g > f:
    return f
  else:
    return g

c = 0
i = 0

while True:
  c = c + 1
  i = i + e(c)
  if i >= j:
    break

print(c)","import r, k, p

r.setrecursionlimit(10000)

def i(n):
    if n < 2:
        return False

    for p in [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]:
        if n % p == 0:
            return n == p
    d = n - 1
    s = 0
    while d % 2 == 0:
        s += 1
        d //= 2

    for a in [2, 325, 9375, 28178, 450775, 9780504, 1795265022]:
        if a % n == 0:
            continue
        x = pow(a, d, n)
        if x == 1 or x == n - 1:
            continue
        for _ in range(s - 1):
            x = (x * x) % n
            if x == n - 1:
                break
        else:
            return False
    return True

def m(n):
    if n % 2 == 0:
        return 2
    x = p.randrange(2, n)
    y = x
    c = p.randrange(1, n)
    d = 1
    while d == 1:
        x = (x * x + c) % n
        y = (y * y + c) % n
        y = (y * y + c) % n
        d = k.gcd(abs(x - y), n)
        if d == n:
            return m(n)
    return d

def f(n):
    g = {}
    def a(n):
        if n == 1:
            return
        if i(n):
            g[n] = g.get(n, 0) + 1
            return
        d = m(n)
        a(d)
        a(n // d)
    a(n)
    return g

def h(g):
    o = list(g.items())
    d = []

    def q(i, b):
        if i == len(o):
            d.append(b)
            return
        n, e = o[i]
        l = 1
        for e in range(e + 1):
            q(i + 1, b * l)
            l *= n
    q(0, 1)
    return d

def j():

    c = r.stdin.read().split()
    if not c:
        return
    n = int(c[0])
    k = int(c[1])

    if n == 1:
        r.stdout.write(""1"" if k == 1 else ""-1"")
        return

    g = f(n)
    d = h(g)
    d.sort()

    if k > len(d):
        r.stdout.write(""-1"")
    else:
        r.stdout.write(str(d[k - 1]))

if __name__ == ""__main__"":
    j()"
375,B,Maximum Submatrix 2,PROGRAMMING,"['data structures', 'dp', 'implementation', 'sortings']","You are given a matrix consisting of digits zero and one, its size is *n*<=×<=*m*. You are allowed to rearrange its rows. What is the maximum area of the submatrix that only consists of ones and can be obtained in the given problem by the described operations?

Let's assume that the rows of matrix *a* are numbered from 1 to *n* from top to bottom and the columns are numbered from 1 to *m* from left to right. A matrix cell on the intersection of the *i*-th row and the *j*-th column can be represented as (*i*,<=*j*). Formally, a submatrix of matrix *a* is a group of four integers *d*,<=*u*,<=*l*,<=*r* (1<=≤<=*d*<=≤<=*u*<=≤<=*n*; 1<=≤<=*l*<=≤<=*r*<=≤<=*m*). We will assume that the submatrix contains cells (*i*,<=*j*) (*d*<=≤<=*i*<=≤<=*u*; *l*<=≤<=*j*<=≤<=*r*). The area of the submatrix is the number of cells it contains.","The first line contains two integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=5000). Next *n* lines contain *m* characters each — matrix *a*. Matrix *a* only contains characters: ""0"" and ""1"". Note that the elements of the matrix follow without any spaces in the lines.","Print a single integer — the area of the maximum obtained submatrix. If we cannot obtain a matrix of numbers one, print 0.","['1 1\n1\n', '2 2\n10\n11\n', '4 3\n100\n011\n000\n101\n']","['1\n', '2\n', '2\n']",none,WRONG_ANSWER,"""""""

created by shuangquan.huang at 1/15/20

""""""

import collections
import time
import os
import sys
import bisect
import heapq
from typing import List

def f(N, M, A):

    for r in range(N):
        for c in range(1, M):
            if A[r][c] != 0:
                A[r][c] = A[r][c-1] + 1
    a = 0

    c = [0 for _ in range(M+1)]
    for d in range(M):
        for e in A:
            c[e[d]] += 1
        b = 0
        for w in range(M+1):
            if c[w] > 0:
                a = max(a, (N-b) * w)
                b += c[w]
    
    print(a)
    

N, M = map(int, input().split())
A = []
for i in range(N):
    e = [int(x) for x in list(input())]
    A.append(e)

f(N, M, A)","def a():

    n = int(input().strip())

    b = [[0] * n for _ in range(n)]

    for i in range(n):
        b[i][0] = 1
        b[0][i] = 1

    for i in range(1, n):
        for j in range(1, n):
            b[i][j] = b[i-1][j] + b[i][j-1]

    print(b[n-1][n-1])

if __name__ == ""__main__"":
    a()"
1006,E,Military Problem,PROGRAMMING,"['dfs and similar', 'graphs', 'trees']","In this problem you will have to help Berland army with organizing their command delivery system.

There are $n$ officers in Berland army. The first officer is the commander of the army, and he does not have any superiors. Every other officer has exactly one direct superior. If officer $a$ is the direct superior of officer $b$, then we also can say that officer $b$ is a direct subordinate of officer $a$.

Officer $x$ is considered to be a subordinate (direct or indirect) of officer $y$ if one of the following conditions holds:
 -  officer $y$ is the direct superior of officer $x$; -  the direct superior of officer $x$ is a subordinate of officer $y$. 
For example, on the picture below the subordinates of the officer $3$ are: $5, 6, 7, 8, 9$.

The structure of Berland army is organized in such a way that every officer, except for the commander, is a subordinate of the commander of the army.

Formally, let's represent Berland army as a tree consisting of $n$ vertices, in which vertex $u$ corresponds to officer $u$. The parent of vertex $u$ corresponds to the direct superior of officer $u$. The root (which has index $1$) corresponds to the commander of the army.

Berland War Ministry has ordered you to give answers on $q$ queries, the $i$-th query is given as $(u_i, k_i)$, where $u_i$ is some officer, and $k_i$ is a positive integer.

To process the $i$-th query imagine how a command from $u_i$ spreads to the subordinates of $u_i$. Typical DFS (depth first search) algorithm is used here.

Suppose the current officer is $a$ and he spreads a command. Officer $a$ chooses $b$ — one of his direct subordinates (i.e. a child in the tree) who has not received this command yet. If there are many such direct subordinates, then $a$ chooses the one having minimal index. Officer $a$ gives a command to officer $b$. Afterwards, $b$ uses exactly the same algorithm to spread the command to its subtree. After $b$ finishes spreading the command, officer $a$ chooses the next direct subordinate again (using the same strategy). When officer $a$ cannot choose any direct subordinate who still hasn't received this command, officer $a$ finishes spreading the command.

Let's look at the following example:

If officer $1$ spreads a command, officers receive it in the following order: $[1, 2, 3, 5 ,6, 8, 7, 9, 4]$.

If officer $3$ spreads a command, officers receive it in the following order: $[3, 5, 6, 8, 7, 9]$.

If officer $7$ spreads a command, officers receive it in the following order: $[7, 9]$.

If officer $9$ spreads a command, officers receive it in the following order: $[9]$.

To answer the $i$-th query $(u_i, k_i)$, construct a sequence which describes the order in which officers will receive the command if the $u_i$-th officer spreads it. Return the $k_i$-th element of the constructed list or -1 if there are fewer than $k_i$ elements in it.

You should process queries independently. A query doesn't affect the following queries.","The first line of the input contains two integers $n$ and $q$ ($2 \le n \le 2 \cdot 10^5, 1 \le q \le 2 \cdot 10^5$) — the number of officers in Berland army and the number of queries.

The second line of the input contains $n - 1$ integers $p_2, p_3, \dots, p_n$ ($1 \le p_i &lt; i$), where $p_i$ is the index of the direct superior of the officer having the index $i$. The commander has index $1$ and doesn't have any superiors.

The next $q$ lines describe the queries. The $i$-th query is given as a pair ($u_i, k_i$) ($1 \le u_i, k_i \le n$), where $u_i$ is the index of the officer which starts spreading a command, and $k_i$ is the index of the required officer in the command spreading sequence.","Print $q$ numbers, where the $i$-th number is the officer at the position $k_i$ in the list which describes the order in which officers will receive the command if it starts spreading from officer $u_i$. Print ""-1"" if the number of officers which receive the command is less than $k_i$.

You should process queries independently. They do not affect each other.",['9 6\n1 1 1 3 5 3 5 7\n3 1\n1 5\n3 4\n7 3\n1 8\n1 9\n'],['3\n6\n8\n-1\n9\n4\n'],none,RUNTIME_ERROR,"from collections import f
g=[]

class c:
    def __init__(m):
        m.graph = f(list)
    def d(m, u, v):

        m.graph[v].append(u)
    def b(m, v):
        p[v] = True
        g.append(v)
        for i in m.graph[v]:
            if p[i] == False:
                m.b(i)
    def a(m, v):

        m.b(v)
    def j(m,s,e):
        e[s]=1
        for u in m.graph[s]:
            if u == e:
                continue
            m.j(u, s)
            e[s] += e[u]

g = c()
n,q=map(int,input().split())
e=[0]*(n+1)

k=list(map(int,input().split()))
p=[0]*(n+2)
for i in range(0,n-1):
    g.d(i+2,k[i])
g.a(1)
g.j(1,0)
i=f(int)
for i in range(len(g)):
    i[g[i]]=i
for l in range(q):
    n,o=map(int,input().split())
    if e[n]<o:
        print(-1)
        continue
    else:
        h=i[n]+o
        print(g[h-1])","def d():
    import f

    b = f.stdin.read().strip().split()

    n = int(b[0])

    a = 0
    c = 1

    for _ in range(n):

        e = int(b[c]) + int(b[c + 1]) + int(b[c + 2])

        if e >= 2:
            a += 1

        c += 3

    print(a)

if __name__ == '__main__':
    d()"
217,A,Ice Skating,PROGRAMMING,"['brute force', 'dfs and similar', 'dsu', 'graphs']","Bajtek is learning to skate on ice. He's a beginner, so his only mode of transportation is pushing off from a snow drift to the north, east, south or west and sliding until he lands in another snow drift. He has noticed that in this way it's impossible to get from some snow drifts to some other by any sequence of moves. He now wants to heap up some additional snow drifts, so that he can get from any snow drift to any other one. He asked you to find the minimal number of snow drifts that need to be created.

We assume that Bajtek can only heap up snow drifts at integer coordinates.","The first line of input contains a single integer *n* (1<=≤<=*n*<=≤<=100) — the number of snow drifts. Each of the following *n* lines contains two integers *x**i* and *y**i* (1<=≤<=*x**i*,<=*y**i*<=≤<=1000) — the coordinates of the *i*-th snow drift.

Note that the north direction coinсides with the direction of *Oy* axis, so the east direction coinсides with the direction of the *Ox* axis. All snow drift's locations are distinct.",Output the minimal number of snow drifts that need to be created in order for Bajtek to be able to reach any snow drift from any other one.,"['2\n2 1\n1 2\n', '2\n2 1\n4 1\n']","['1\n', '0\n']",none,WRONG_ANSWER,"def b(u):
  if d[u] != u:
    d[u] = b(d[u])
  return d[u]

def f(u, v):
  g = b(u)
  h = b(v)
  if u[0] == v[0] and u[1] == v[1]:
    return
  global a
  a -= 1
  if e[g] > e[h]:
    d[h] = g
  elif e[g] < e[g]:
    d[g] = h
  else:
    d[g] = h
    e[h] += 1
  
  
n = int(input())
c = []

a = n

for i in range(n):
  x, y = map(int, input().split())
  c.append((x, y))
  
d = {(x, y) : (x, y) for x, y in c}
e = {(x, y): 0 for x, y in c}

for i in range(len(c) - 1):
  for j in range(i + 1, len(c)):
    if c[i][0] == c[j][0] or c[i][1] == c[j][1]:
      f(c[i], c[j])

print(a - 1)","def a(c):
    """"""
    Generate a list of lucky numbers up to the given limit.
    Uses a recursive approach (implemented with a loop over a queue).
    """"""
    f = []

    i = [4, 7]
    
    while i:
        h = i.pop(0)
        if h > c:
            continue
        f.append(h)

        i.append(h * 10 + 4)
        i.append(h * 10 + 7)
    
    return f

def g():
    import j
    b = j.stdin.read().strip().split()
    if not b:
        return
    n = int(b[0])

    e = a(n)

    for d in e:
        if n % d == 0:
            j.stdout.write(""YES\n"")
            return
    
    j.stdout.write(""NO\n"")

if __name__ == '__main__':
    g()"
767,A,Snacktower,PROGRAMMING,"['data structures', 'implementation']","According to an old legeng, a long time ago Ankh-Morpork residents did something wrong to miss Fortune, and she cursed them. She said that at some time *n* snacks of distinct sizes will fall on the city, and the residents should build a Snacktower of them by placing snacks one on another. Of course, big snacks should be at the bottom of the tower, while small snacks should be at the top.

Years passed, and once different snacks started to fall onto the city, and the residents began to build the Snacktower.

However, they faced some troubles. Each day exactly one snack fell onto the city, but their order was strange. So, at some days the residents weren't able to put the new stack on the top of the Snacktower: they had to wait until all the bigger snacks fell. Of course, in order to not to anger miss Fortune again, the residents placed each snack on the top of the tower immediately as they could do it.

Write a program that models the behavior of Ankh-Morpork residents.","The first line contains single integer *n* (1<=≤<=*n*<=≤<=100<=000) — the total number of snacks.

The second line contains *n* integers, the *i*-th of them equals the size of the snack which fell on the *i*-th day. Sizes are distinct integers from 1 to *n*.","Print *n* lines. On the *i*-th of them print the sizes of the snacks which the residents placed on the top of the Snacktower on the *i*-th day in the order they will do that. If no snack is placed on some day, leave the corresponding line empty.","['3\n3 1 2\n', '5\n4 5 1 2 3\n']","['3\n\xa0\n2 1', '5 4\n\xa0\n\xa0\n3 2 1\n']","In the example a snack of size 3 fell on the first day, and the residents immediately placed it. On the second day a snack of size 1 fell, and the residents weren't able to place it because they were missing the snack of size 2. On the third day a snack of size 2 fell, and the residents immediately placed it. Right after that they placed the snack of size 1 which had fallen before.",WRONG_ANSWER,"g = int(input())

j = input().split("" "")
a = [None for int in j]

def d(k, c):
    k, c = max(k, c), min(k, c)

    h = [str(x) for x in range(k, c - 1, -1)]

    i = ' '.join(h)
    
    return i

b = g

for e, f in enumerate(j):
    if (int(f) >= (int(g) - e)):
        a[e] = d(int(b), abs(int(f)  - int(int(g) - int(f))))
        b = int(f) - 1
    else:
        a[e] = None

for i, f in enumerate(a):
    if (f == None):
        print("""")
    else:
        print(f)","def l():
    import t
    g = t.stdin.read().splitlines()
    if not g:
        return

    n = g[0].strip()
    n = len(n)

    j = n.count('(')
    i = n.count(')')

    p = []
    o = 0
    for i, e in enumerate(n):
        if e == '?':

            a, c = g[1 + o].split()
            a = int(a)
            b = int(c)
            h = a - b
            p.append((i, a, b, h))
            o += 1

    m = len(p)
    v = n // 2

    m = v - j

    if m < 0 or m > m:
        t.stdout.write(""-1"")
        return

    q = sorted(p, key=lambda x: x[3])

    b = {}

    for j in range(m):
        k, a, b, h = q[j]
        if j < m:
            b[k] = ('(', a)
        else:
            b[k] = (')', b)

    s = list(n)
    u = 0
    for i, e in enumerate(s):
        if e == '?':
            r, f = b[i]
            s[i] = r
            u += f

    d = 0
    w = True
    for e in s:
        if e == '(':
            d += 1
        else:
            d -= 1
        if d < 0:
            w = False
            break
    if d != 0:
        w = False

    if not w:
        t.stdout.write(""-1"")
    else:
        t.stdout.write(str(u) + ""\n"")
        t.stdout.write("""".join(s))

if __name__ == '__main__':
    l()"
26,A,Almost Prime,PROGRAMMING,['number theory'],"A number is called almost prime if it has exactly two distinct prime divisors. For example, numbers 6, 18, 24 are almost prime, while 4, 8, 9, 42 are not. Find the amount of almost prime numbers which are between 1 and *n*, inclusive.",Input contains one integer number *n* (1<=≤<=*n*<=≤<=3000).,"Output the amount of almost prime numbers between 1 and *n*, inclusive.","['10\n', '21\n']","['2\n', '8\n']",none,WRONG_ANSWER,"def a(n) : 
	if (n <= 1) : 
		return False
	if (n <= 3) : 
		return True
	if (n % 2 == 0 or n % 3 == 0) : 
		return False
	i = 5
	while(i * i <= n) : 
		if (n % i == 0 or n % (i + 2) == 0) : 
			return False
		i = i + 6
	return True

n=int(input())
s=int(n**(1/2))
c=[]
b=[]
for i in range(1,n+1):
    if a(i):
        c.append(i)
s=0
t=0
for y in range(6,n+1):
    for j in range(int(y**(1/2))+1):
        if y%c[j]==0:
            s+=1
    if s==2:
        t+=1
    s=0
print(t)","def g():
    import h
    d = h.stdin.read().split()
    if not d:
        return

    f = iter(d)
    n = int(next(f))

    e = []
    for _ in range(n - 1):
        u = int(next(f))
        v = int(next(f))
        e.append((u, v))

    b = [0] * (n + 1)
    for i in range(1, n + 1):
        b[i] = int(next(f))

    c = []
    for u, v in e:
        if b[u] != b[v]:
            c.append((u, v))

    if not c:
        h.stdout.write(""YES\n1"")
        return

    i, j = c[0]

    a = i
    k = True
    for u, v in c:
        if a != u and a != v:
            k = False
            break
    if k:
        h.stdout.write(""YES\n"" + str(a))
        return

    a = j
    k = True
    for u, v in c:
        if a != u and a != v:
            k = False
            break
    if k:
        h.stdout.write(""YES\n"" + str(a))
    else:
        h.stdout.write(""NO"")

if __name__ == '__main__':
    g()"
7,D,Palindrome Degree,PROGRAMMING,"['hashing', 'strings']","String *s* of length *n* is called *k*-palindrome, if it is a palindrome itself, and its prefix and suffix of length  are (*k*<=-<=1)-palindromes. By definition, any string (even empty) is 0-palindrome.

Let's call the palindrome degree of string *s* such a maximum number *k*, for which *s* is *k*-palindrome. For example, ""abaaba"" has degree equals to 3.

You are given a string. Your task is to find the sum of the palindrome degrees of all its prefixes.","The first line of the input data contains a non-empty string, consisting of Latin letters and digits. The length of the string does not exceed 5·106. The string is case-sensitive.",Output the only number — the sum of the polindrome degrees of all the string's prefixes.,"['a2A\n', 'abacaba\n']","['1', '6']",none,WRONG_ANSWER,"b=input()
def c(b):
    l=len(b)
    if l==1:
        return 1
    for i in range(l//2):
        if b[i]!=b[l-1-i]:
            return 0
    return l//2

a=0
l=len(b)
while l>0:
    d=c(b)
    if d==0:
        print(1)
        exit(0)
    a+=d
    l=l//2
    b=b[:l]
print(a+1)","def d():
    import h

    a = h.stdin.read().strip().splitlines()
    if not a:
        return

    n, m = map(int, a[0].split())

    c = set()

    for i in range(1, n + 1):
        g = a[i].strip()

        e = g.find('G')
        f = g.find('S')

        if e > f:
            print(-1)
            return

        b = f - e
        c.add(b)

    print(len(c))

if __name__ == '__main__':
    d()"
835,A,Key races,PROGRAMMING,['math'],"Two boys decided to compete in text typing on the site ""Key races"". During the competition, they have to type a text consisting of *s* characters. The first participant types one character in *v*1 milliseconds and has ping *t*1 milliseconds. The second participant types one character in *v*2 milliseconds and has ping *t*2 milliseconds.

If connection ping (delay) is *t* milliseconds, the competition passes for a participant as follows: 
 1.  Exactly after *t* milliseconds after the start of the competition the participant receives the text to be entered. 1.  Right after that he starts to type it. 1.  Exactly *t* milliseconds after he ends typing all the text, the site receives information about it. 
The winner is the participant whose information on the success comes earlier. If the information comes from both participants at the same time, it is considered that there is a draw.

Given the length of the text and the information about participants, determine the result of the game.","The first line contains five integers *s*, *v*1, *v*2, *t*1, *t*2 (1<=≤<=*s*,<=*v*1,<=*v*2,<=*t*1,<=*t*2<=≤<=1000) — the number of characters in the text, the time of typing one character for the first participant, the time of typing one character for the the second participant, the ping of the first participant and the ping of the second participant.","If the first participant wins, print ""First"". If the second participant wins, print ""Second"". In case of a draw print ""Friendship"".","['5 1 2 1 2\n', '3 3 1 1 1\n', '4 5 3 1 5\n']","['First\n', 'Second\n', 'Friendship\n']","In the first example, information on the success of the first participant comes in 7 milliseconds, of the second participant — in 14 milliseconds. So, the first wins.

In the second example, information on the success of the first participant comes in 11 milliseconds, of the second participant — in 5 milliseconds. So, the second wins.

In the third example, information on the success of the first participant comes in 22 milliseconds, of the second participant — in 22 milliseconds. So, it is be a draw.",RUNTIME_ERROR,"import math,string,itertools,fractions,heapq,collections,re,array,bisect,i,random,time,queue,copy,numpy

i.setrecursionlimit(10**7)
f=10**20
h=10**9+7
d=[(-1,0),(0,1),(1,0),(0,-1)]
e=[(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]

def a(): return [int(x) for x in i.stdin.readline().split()]
def b(): return [int(x)-1 for x in i.stdin.readline().split()]
def I(): return int(i.stdin.readline())
def c(): return i.stdin.readline().split()
def S(): return input()

def g():
  a,b,c,d,e=a()
  x=a*b+2*d
  y=a*c+2*e

  if x==y:
    return 'Friendship'
  elif x<y:
    return 'First'
  return 'Second'

print(g())","import g

def f():

    c = g.stdin.read().split()

    n = int(c[0])
    p = int(c[1])
    q = int(c[2])
    r = int(c[3])

    a = list(map(int, c[4:4+n]))

    d = [0] * n
    d[0] = p * a[0]
    for i in range(1, n):
        d[i] = max(d[i-1], p * a[i])

    e = [0] * n
    e[-1] = r * a[-1]
    for i in range(n-2, -1, -1):
        e[i] = max(e[i+1], r * a[i])

    a = -10**20
    for j in range(n):
        b = d[j] + q * a[j] + e[j]
        a = max(a, b)

    g.stdout.write(str(a))

if __name__ == '__main__':
    f()"
976,E,Well played!,PROGRAMMING,"['greedy', 'sortings']","Recently Max has got himself into popular CCG ""BrainStone"". As ""BrainStone"" is a pretty intellectual game, Max has to solve numerous hard problems during the gameplay. Here is one of them:

Max owns *n* creatures, *i*-th of them can be described with two numbers — its health *hp**i* and its damage *dmg**i*. Max also has two types of spells in stock:
 1.  Doubles health of the creature (*hp**i* := *hp**i*·2); 1.  Assigns value of health of the creature to its damage (*dmg**i* := *hp**i*). 
Spell of first type can be used no more than *a* times in total, of the second type — no more than *b* times in total. Spell can be used on a certain creature multiple times. Spells can be used in arbitrary order. It isn't necessary to use all the spells.

Max is really busy preparing for his final exams, so he asks you to determine what is the maximal total damage of all creatures he can achieve if he uses spells in most optimal way.","The first line contains three integers *n*, *a*, *b* (1<=≤<=*n*<=≤<=2·105, 0<=≤<=*a*<=≤<=20, 0<=≤<=*b*<=≤<=2·105) — the number of creatures, spells of the first type and spells of the second type, respectively.

The *i*-th of the next *n* lines contain two number *hp**i* and *dmg**i* (1<=≤<=*hp**i*,<=*dmg**i*<=≤<=109) — description of the *i*-th creature.",Print single integer — maximum total damage creatures can deal.,"['2 1 1\n10 15\n6 1\n', '3 0 3\n10 8\n7 11\n5 2\n']","['27\n', '26\n']","In the first example Max should use the spell of the first type on the second creature, then the spell of the second type on the same creature. Then total damage will be equal to 15 + 6·2 = 27.

In the second example Max should use the spell of the second type on the first creature, then the spell of the second type on the third creature. Total damage will be equal to 10 + 11 + 5 = 26.",RUNTIME_ERROR,"import b
if locals()['__file__'][-2:] == 'py':
    b.stdin = open('in.txt', 'r')

a = lambda: list(map(int, input().split()))
n, a, b = a()
b = min(b, n)
f = lambda x: max(0, x[0] - x[1])
g = lambda x: (x[0] << a) - x[1]
p = [a() for i in range(n)]
s = sum(x[1] for x in p)
if b:
    p.sort(key=f, reverse=True)
    e = 0
    t = sum(f(x) for x in p[:b])
    for i in range(b):
        e = max(e, t - f(p[i]) + g(p[i]))
    for i in range(b, n):
        e = max(e, t - f(p[b - 1]) + g(p[i]))
print(s + e)","def c():
    s = input().strip()
    f = set(""AEIOUY"")

    e = [0]
    for i, a in enumerate(s, start=1):
        if a in f:
            e.append(i)

    e.append(len(s) + 1)

    d = 0
    for j in range(1, len(e)):
        b = e[j] - e[j - 1]
        if b > d:
            d = b

    print(d)

if __name__ == '__main__':
    c()"
690,C1,Brain Network (easy),PROGRAMMING,[],"One particularly well-known fact about zombies is that they move and think terribly slowly. While we still don't know why their movements are so sluggish, the problem of laggy thinking has been recently resolved. It turns out that the reason is not (as previously suspected) any kind of brain defect – it's the opposite! Independent researchers confirmed that the nervous system of a zombie is highly complicated – it consists of *n* brains (much like a cow has several stomachs). They are interconnected by brain connectors, which are veins capable of transmitting thoughts between brains. There are two important properties such a brain network should have to function properly: 
 1.  It should be possible to exchange thoughts between any two pairs of brains (perhaps indirectly, through other brains). 1.  There should be no redundant brain connectors, that is, removing any brain connector would make property 1 false. 
If both properties are satisfied, we say that the nervous system is valid. Unfortunately (?), if the system is not valid, the zombie stops thinking and becomes (even more) dead. Your task is to analyze a given nervous system of a zombie and find out whether it is valid.","The first line of the input contains two space-separated integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=1000) denoting the number of brains (which are conveniently numbered from 1 to *n*) and the number of brain connectors in the nervous system, respectively. In the next *m* lines, descriptions of brain connectors follow. Every connector is given as a pair of brains *a* *b* it connects (1<=≤<=*a*,<=*b*<=≤<=*n*, *a*<=≠<=*b*).","The output consists of one line, containing either yes or no depending on whether the nervous system is valid.","['4 4\n1 2\n2 3\n3 1\n4 1\n', '6 5\n1 2\n2 3\n3 4\n4 5\n3 6\n']","['no\n', 'yes\n']",none,WRONG_ANSWER,"def c(b):
	global f,d
	if b in f:
		return
	f.add(b)
	for d in d[b]:
		c(d)
  
m,n = map(int,input().split())
if (n + 1) != m:
	print('no')
else:
	d = {}
	for a in range(m-1):
		x, y = map(int,input().split())
		if x not in d:
			d[x] = []
		if y not in d:
			d[y] = []
		d[x].append(y)
		d[y].append(x)
	f = set()
	c(1)
	f = list(f)
	e = list(range(1,m+1))
	if f == e:
		print('yes')
	else:
		print('no')","import d

def a():

    n, m = map(int, d.stdin.readline().split())
    e = []

    for _ in range(n):
        a, b = map(int, d.stdin.readline().split())
        e.append((a, b))

    e.sort(key=lambda x: x[0])

    c = 0
    i = 0

    while i < n and c < m:

        if e[i][0] > c:
            break

        b = c
        while i < n and e[i][0] <= c:
            b = max(b, e[i][1])
            i += 1

        if b == c:
            break
        
        c = b

    if c >= m:
        print(""YES"")
    else:
        print(""NO"")

if __name__ == '__main__':
    a()"
302,A,Eugeny and Array,PROGRAMMING,['implementation'],"Eugeny has array *a*<==<=*a*1,<=*a*2,<=...,<=*a**n*, consisting of *n* integers. Each integer *a**i* equals to -1, or to 1. Also, he has *m* queries:
 -  Query number *i* is given as a pair of integers *l**i*, *r**i* (1<=≤<=*l**i*<=≤<=*r**i*<=≤<=*n*). -  The response to the query will be integer 1, if the elements of array *a* can be rearranged so as the sum *a**l**i*<=+<=*a**l**i*<=+<=1<=+<=...<=+<=*a**r**i*<==<=0, otherwise the response to the query will be integer 0. 
Help Eugeny, answer all his queries.","The first line contains integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=2·105). The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (*a**i*<==<=-1,<=1). Next *m* lines contain Eugene's queries. The *i*-th line contains integers *l**i*,<=*r**i* (1<=≤<=*l**i*<=≤<=*r**i*<=≤<=*n*).",Print *m* integers — the responses to Eugene's queries in the order they occur in the input.,"['2 3\n1 -1\n1 1\n1 2\n2 2\n', '5 5\n-1 1 1 1 -1\n1 1\n2 3\n3 5\n2 5\n1 5\n']","['0\n1\n0\n', '0\n1\n0\n1\n0\n']",none,TIME_LIMIT_EXCEEDED,"def e(g):
    return (int(g / 2) * 2 == g)

def d():
	a, i = map(int, input().split())

	b = input().split()
	f = b.count(""-1"")
	h = a-f

	for _ in range(i):
		l, r = map(int, input().split())
		j = r-l+1
		if not e(j):
			print(0)
		else:
			c = j//2
			if c <= h and c <= f:
				print(1)
			else:
				print(0)

d()","def c():
    import e

    b = e.stdin.read().split()
    if not b:
        return

    b = int(b[0])
    n = int(b[1])
    c = int(b[2])

    a = ((b - 1) % c) * pow(b, n - 1, c) % c

    d = a if a != 0 else c
    print(d)
    
    
if __name__ == '__main__':
    c()"
864,B,Polycarp and Letters,PROGRAMMING,"['brute force', 'implementation', 'strings']","Polycarp loves lowercase letters and dislikes uppercase ones. Once he got a string *s* consisting only of lowercase and uppercase Latin letters.

Let *A* be a set of positions in the string. Let's call it pretty if following conditions are met:
 -  letters on positions from *A* in the string are all distinct and lowercase; -  there are no uppercase letters in the string which are situated between positions from *A* (i.e. there is no such *j* that *s*[*j*] is an uppercase letter, and *a*1<=&lt;<=*j*<=&lt;<=*a*2 for some *a*1 and *a*2 from *A*). 
Write a program that will determine the maximum number of elements in a pretty set of positions.","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=200) — length of string *s*.

The second line contains a string *s* consisting of lowercase and uppercase Latin letters.",Print maximum number of elements in pretty set of positions for string *s*.,"['11\naaaaBaabAbA\n', '12\nzACaAbbaazzC\n', '3\nABC\n']","['2\n', '3\n', '0\n']","In the first example the desired positions might be 6 and 8 or 7 and 8. Positions 6 and 7 contain letters 'a', position 8 contains letter 'b'. The pair of positions 1 and 8 is not suitable because there is an uppercase letter 'B' between these position.

In the second example desired positions can be 7, 8 and 11. There are other ways to choose pretty set consisting of three elements.

In the third example the given string *s* does not contain any lowercase letters, so the answer is 0.",RUNTIME_ERROR,"import d,math,bisect,collections,itertools,heapq
from collections import defaultdict,deque
n=int(d.stdin.readline())
s=d.stdin.readline().strip()
b=""""
for i in range(1,n):
    if s[i-1]!=s[i]:
        b+=s[i-1]
if s[-1]!=s[-2]:
    b+=s[-1]
s=b

c=0
a=0
for i in s:
    if i.lower() == i :
        c+=1
    else:c=0
    a=max(a,c)
print(a)","def e():
    import g
    d = g.stdin.read().split()

    n = int(d[0])
    c = list(map(int, d[1:]))

    a = c.count(1)
    b = c.count(2)

    h = min(b, a)

    f = a - h

    h += f // 3
    
    g.stdout.write(f""{h}\n"")

if __name__ == ""__main__"":
    e()"
453,A,Little Pony and Expected Maximum,PROGRAMMING,['probabilities'],"Twilight Sparkle was playing Ludo with her friends Rainbow Dash, Apple Jack and Flutter Shy. But she kept losing. Having returned to the castle, Twilight Sparkle became interested in the dice that were used in the game.

The dice has *m* faces: the first face of the dice contains a dot, the second one contains two dots, and so on, the *m*-th face contains *m* dots. Twilight Sparkle is sure that when the dice is tossed, each face appears with probability . Also she knows that each toss is independent from others. Help her to calculate the expected maximum number of dots she could get after tossing the dice *n* times.","A single line contains two integers *m* and *n* (1<=≤<=*m*,<=*n*<=≤<=105).",Output a single real number corresponding to the expected maximum. The answer will be considered correct if its relative or absolute error doesn't exceed 10<=<=-<=4.,"['6 1\n', '6 3\n', '2 2\n']","['3.500000000000\n', '4.958333333333\n', '1.750000000000\n']","Consider the third test example. If you've made two tosses:
 1.  You can get 1 in the first toss, and 2 in the second. Maximum equals to 2. 1.  You can get 1 in the first toss, and 1 in the second. Maximum equals to 1. 1.  You can get 2 in the first toss, and 1 in the second. Maximum equals to 2. 1.  You can get 2 in the first toss, and 2 in the second. Maximum equals to 2. 
The probability of each outcome is 0.25, that is expectation equals to: 

You can read about expectation using the following link: http://en.wikipedia.org/wiki/Expected_value",OK,"def b(m, n):
    a = 0.0
    i = m
    while (i):
        a += (pow(i / m, n) - pow((i - 1) / m, n)) * i
        i = i - 1
    return a

m, n = map(int, input().split())

print(b(m, n))","import {
{.setrecursionlimit(10000)

def z():
    import {
    k = {.stdin.buffer.read().split()
    if not k:
        return
    n = iter(k)
    n = int(next(n))
    k = int(next(n))

    u = [[0]*n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            u[i][j] = int(next(n))

    t = []
    for i in range(n):
        y = u[i]
        u = [0] * n
        s = 0
        for j in range(n):
            s += y[j]
            u[j] = s
        t.append(u)

    i = 0
    j = -1
    h = 0

    def a(s):
        nonlocal i, j, h

        if j >= i:
            c = t[s][j] - (t[s][i-1] if i > 0 else 0)
        else:
            c = 0
        h += c
        i = s

    def b(s):
        nonlocal i, j, h

        if j >= i:
            c = t[s][j] - (t[s][i-1] if i > 0 else 0)
        else:
            c = 0
        h += c
        j = s

    def w(s):
        nonlocal i, j, h

        v = t[s][j] - t[s][s]
        h -= v
        i = s + 1

    def x(s):
        nonlocal i, j, h

        v = t[s][s-1] - (t[s][i-1] if i > 0 else 0) if s - 1 >= i else 0
        h -= v
        j = s - 1

    def p(L, R):
        nonlocal i, j, h

        if j < i:
            i = L
            j = L - 1
            h = 0
            for s in range(L, R + 1):
                b(s)
            return

        while i > L:
            a(i - 1)

        while j < R:
            b(j + 1)

        while i < L:
            w(i)

        while j > R:
            x(j)

    m = [0] * n

    i = 0
    j = -1
    h = 0
    for i in range(n):
        p(0, i)
        m[i] = h

    l = [0] * n

    def g(l, r, q, r):

        if l > r:
            return
        o = (l + r) >> 1
        d = None
        e = -1

        | = r if r < o else o
        for j in range(q, | + 1):
            p(j, o)

            f = (m[j - 1] if j > 0 else 0) + h
            if d is None or f < d:
                d = f
                e = j
        l[o] = d
        g(l, o - 1, q, e)
        g(o + 1, r, e, r)

    for d in range(2, k + 1):

        for i in range(d - 1):
            l[i] = 10**18
        g(d - 1, n - 1, d - 1, n - 1)
        m, l = l, m
    {.stdout.write(str(m[n - 1]) + ""\n"")

if __name__ == '__main__':
    z()"
996,A,Hit the Lottery,PROGRAMMING,"['dp', 'greedy']","Allen has a LOT of money. He has $n$ dollars in the bank. For security reasons, he wants to withdraw it in cash (we will not disclose the reasons here). The denominations for dollar bills are $1$, $5$, $10$, $20$, $100$. What is the minimum number of bills Allen could receive after withdrawing his entire balance?",The first and only line of input contains a single integer $n$ ($1 \le n \le 10^9$).,Output the minimum number of bills that Allen could receive.,"['125\n', '43\n', '1000000000\n']","['3\n', '5\n', '10000000\n']","In the first sample case, Allen can withdraw this with a $100$ dollar bill, a $20$ dollar bill, and a $5$ dollar bill. There is no way for Allen to receive $125$ dollars in one or two bills.

In the second sample case, Allen can withdraw two $20$ dollar bills and three $1$ dollar bills.

In the third sample case, Allen can withdraw $100000000$ (ten million!) $100$ dollar bills.",TIME_LIMIT_EXCEEDED,"n = int(input())

b = [100, 20, 10, 5, 1]
i = 0
c = 0

while i < len(b) and n > 0:
    a = b[i]
    while n >= a:
        n -= a
        c += 1
    i += 1

print(c)","def e():
    import g
    b = g.stdin.read().splitlines()
    if not b:
        return

    c = b[0].split()
    n = int(c[0])
    a = int(c[1])
    b = int(c[2])
    s = b[1].strip()

    f = 0

    d = None

    for a in s:
        if a == '*':

            d = None
        else:
            if d == 'A':

                if b > 0:
                    b -= 1
                    f += 1
                    d = 'B'
                else:

                    d = None
            elif d == 'B':

                if a > 0:
                    a -= 1
                    f += 1
                    d = 'A'
                else:

                    d = None
            else:

                if a >= b:
                    if a > 0:
                        a -= 1
                        f += 1
                        d = 'A'
                    elif b > 0:
                        b -= 1
                        f += 1
                        d = 'B'
                    else:
                        d = None
                else:
                    if b > 0:
                        b -= 1
                        f += 1
                        d = 'B'
                    elif a > 0:
                        a -= 1
                        f += 1
                        d = 'A'
                    else:
                        d = None

    g.stdout.write(str(f))
    
if __name__ == ""__main__"":
    e()"
275,A,Lights Out,PROGRAMMING,['implementation'],"Lenny is playing a game on a 3<=×<=3 grid of lights. In the beginning of the game all lights are switched on. Pressing any of the lights will toggle it and all side-adjacent lights. The goal of the game is to switch all the lights off. We consider the toggling as follows: if the light was switched on then it will be switched off, if it was switched off then it will be switched on.

Lenny has spent some time playing with the grid and by now he has pressed each light a certain number of times. Given the number of times each light is pressed, you have to print the current state of each light.",The input consists of three rows. Each row contains three integers each between 0 to 100 inclusive. The *j*-th number in the *i*-th row is the number of times the *j*-th light of the *i*-th row of the grid is pressed.,"Print three lines, each containing three characters. The *j*-th character of the *i*-th line is ""1"" if and only if the corresponding light is switched on, otherwise it's ""0"".","['1 0 0\n0 0 0\n0 0 1\n', '1 0 1\n8 8 8\n2 0 3\n']","['001\n010\n100\n', '010\n011\n100\n']",none,OK,"from sys import g, stdout
def c():
	return g.readline().rstrip()

def d():
	return int(c())
 
def e():
	return list(map(int, c().split()))
 
def f():
	a=[[1,1,1],[1,1,1],[1,1,1]]
	for i in range(3):
		v=e()
		for j in range(3):
			if v[j]%2==1:
				for (a, b) in [(i,j),(i-1,j),(i+1,j),(i,j-1),(i,j+1)]:
					if a>=0 and b>=0 and a<3 and b<3:
						a[a][b]=1-a[a][b]
	print(""\n"".join("""".join(str(x) for x in v) for v in a))

f()","def o():
    import p
    from collections import i
    h = p.stdin.read().split()
    if not h:
        return
    k = iter(h)
    n = int(next(k))
    m = int(next(k))

    l = i(lambda: {""total"": 0, ""colors"": i(int)})
    for _ in range(n):
        g = int(next(k))
        j = int(next(k))
        l[j][""total""] += 1
        l[j][""colors""][g] += 1

    c = i(lambda: {""total"": 0, ""colors"": i(int)})
    for _ in range(m):
        g = int(next(k))
        j = int(next(k))
        c[j][""total""] += 1
        c[j][""colors""][g] += 1

    r = 0
    q = 0
    a = set(l.keys()) | set(c.keys())
    for d in a:
        m = l.get(d, {""total"": 0, ""colors"": {}})
        d = c.get(d, {""total"": 0, ""colors"": {}})
        f = min(m[""total""], d[""total""])
        r += f

        b = 0
        for g, n in m[""colors""].items():
            e = d[""colors""].get(g, 0)
            b += min(n, e)
        q += b

    p.stdout.write(f""{r} {q}"")

if __name__ == '__main__':
    o()"
779,C,Dishonest Sellers,PROGRAMMING,"['constructive algorithms', 'greedy', 'sortings']","Igor found out discounts in a shop and decided to buy *n* items. Discounts at the store will last for a week and Igor knows about each item that its price now is *a**i*, and after a week of discounts its price will be *b**i*.

Not all of sellers are honest, so now some products could be more expensive than after a week of discounts.

Igor decided that buy at least *k* of items now, but wait with the rest of the week in order to save money as much as possible. Your task is to determine the minimum money that Igor can spend to buy all *n* items.","In the first line there are two positive integer numbers *n* and *k* (1<=≤<=*n*<=≤<=2·105, 0<=≤<=*k*<=≤<=*n*) — total number of items to buy and minimal number of items Igor wants to by right now.

The second line contains sequence of integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=104) — prices of items during discounts (i.e. right now).

The third line contains sequence of integers *b*1,<=*b*2,<=...,<=*b**n* (1<=≤<=*b**i*<=≤<=104) — prices of items after discounts (i.e. after a week).","Print the minimal amount of money Igor will spend to buy all *n* items. Remember, he should buy at least *k* items right now.","['3 1\n5 4 6\n3 1 5\n', '5 3\n3 4 7 10 3\n4 5 5 12 5\n']","['10\n', '25\n']","In the first example Igor should buy item 3 paying 6. But items 1 and 2 he should buy after a week. He will pay 3 and 1 for them. So in total he will pay 6 + 3 + 1 = 10.

In the second example Igor should buy right now items 1, 2, 4 and 5, paying for them 3, 4, 10 and 3, respectively. Item 3 he should buy after a week of discounts, he will pay 5 for it. In total he will spend 3 + 4 + 10 + 3 + 5 = 25.",OK,"import f
from os import e
if (e.exists('input.txt') and e.exists('output.txt')):
    f.stdout = open('output.txt', 'w')
    f.stdin = open('input.txt', 'r')

def d():
    n, k = (int(i) for i in input().split())
    a = [int(i) for i in input().split()]
    b = [int(i) for i in input().split()]
    c = sorted([a[i] - b[i] for i in range(n)])
    a = sum(a)
    for b in c:
        if b < 0 or k > 0:
            k -= 1
        else:
            a -= b
    print(a)
                
d()","import f

def b(n):

    d = [4, 7, 44, 47, 74, 77, 444, 447, 474, 477, 744, 747, 774, 777]

    for c in d:
        if n % c == 0:
            return True
    return False

def e():

    a = f.stdin.read().strip()
    if a:
        n = int(a.split()[0])

        if b(n):
            print(""YES"")
        else:
            print(""NO"")

if __name__ == '__main__':
    e()"
8,A,Train and Peter,PROGRAMMING,['strings'],"Peter likes to travel by train. He likes it so much that on the train he falls asleep. 

Once in summer Peter was going by train from city A to city B, and as usual, was sleeping. Then he woke up, started to look through the window and noticed that every railway station has a flag of a particular colour.

The boy started to memorize the order of the flags' colours that he had seen. But soon he fell asleep again. Unfortunately, he didn't sleep long, he woke up and went on memorizing the colours. Then he fell asleep again, and that time he slept till the end of the journey.

At the station he told his parents about what he was doing, and wrote two sequences of the colours that he had seen before and after his sleep, respectively.

Peter's parents know that their son likes to fantasize. They give you the list of the flags' colours at the stations that the train passes sequentially on the way from A to B, and ask you to find out if Peter could see those sequences on the way from A to B, or from B to A. Remember, please, that Peter had two periods of wakefulness.

Peter's parents put lowercase Latin letters for colours. The same letter stands for the same colour, different letters — for different colours.","The input data contains three lines. The first line contains a non-empty string, whose length does not exceed 105, the string consists of lowercase Latin letters — the flags' colours at the stations on the way from A to B. On the way from B to A the train passes the same stations, but in reverse order. 

The second line contains the sequence, written by Peter during the first period of wakefulness. The third line contains the sequence, written during the second period of wakefulness. Both sequences are non-empty, consist of lowercase Latin letters, and the length of each does not exceed 100 letters. Each of the sequences is written in chronological order.","Output one of the four words without inverted commas: 
 -  «forward» — if Peter could see such sequences only on the way from A to B; -  «backward» — if Peter could see such sequences on the way from B to A; -  «both» — if Peter could see such sequences both on the way from A to B, and on the way from B to A; -  «fantasy» — if Peter could not see such sequences.","['atob\na\nb\n', 'aaacaaa\naca\naa\n']","['forward\n', 'both\n']","It is assumed that the train moves all the time, so one flag cannot be seen twice. There are no flags at stations A and B.",WRONG_ANSWER,"from pprint import pprint

def a(a, b):

    a, b = a + [], b + []
    while len(a) > 0 and len(b) > 0:
        if b[0] == a[0]: del(b[0])
        del(a[0])
        print(b)

    return True if len(b) == 0 else False 

s, a, b = list(input()), list(input()), list(input())
c = a(s, a + b)
b = a(s[::-1], a + b)
print(
    ""both"" if c and b 
    else ""forward"" if c
    else ""backward"" if b
    else ""fantasy""
)","def a(a, b, c, x, y, z):

    f = max(a - x, 0) // 2
    h = max(b - y, 0) // 2
    g = max(c - z, 0) // 2

    b = max(x - a, 0)
    d = max(y - b, 0)
    c = max(z - c, 0)

    k = f + h + g
    j = b + d + c
    
    return k >= j

if __name__ == ""__main__"":
    import i
    e = i.stdin.read().split()

    a, b, c = map(int, e[:3])

    x, y, z = map(int, e[3:6])

    if a(a, b, c, x, y, z):
        print(""Yes"")
    else:
        print(""No"")"
59,A,Word,PROGRAMMING,"['implementation', 'strings']","Vasya is very upset that many people on the Net mix uppercase and lowercase letters in one word. That's why he decided to invent an extension for his favorite browser that would change the letters' register in every word so that it either only consisted of lowercase letters or, vice versa, only of uppercase ones. At that as little as possible letters should be changed in the word. For example, the word HoUse must be replaced with house, and the word ViP — with VIP. If a word contains an equal number of uppercase and lowercase letters, you should replace all the letters with lowercase ones. For example, maTRIx should be replaced by matrix. Your task is to use the given method on one given word.",The first line contains a word *s* — it consists of uppercase and lowercase Latin letters and possesses the length from 1 to 100.,"Print the corrected word *s*. If the given word *s* has strictly more uppercase letters, make the word written in the uppercase register, otherwise - in the lowercase one.","['HoUse\n', 'ViP\n', 'maTRIx\n']","['house\n', 'VIP\n', 'matrix\n']",none,OK,"import d

f = d.stdin.readline().strip()

a = list('abcdefghijklmnopqrstuvwxyz')
e = list('ABCDEFGHIJKLMNOPQRSTUVWXYZ')

c = 0
b = 0

for i in f:
    if i in a:
        c += 1
    elif i in e:
        b += 1

if c > b:
    a = f.lower()
    print(a)
elif c < b:
    a = f.upper()
    print(a)
else:
    a = f.lower()
    print(a)","import e
import c

def d():

    b = e.stdin.read().split()
    if not b:
        return

    l = int(b[0])
    r = int(b[1])
    x = int(b[2])
    y = int(b[3])

    if y % x != 0:
        print(0)
        return

    m = y // x
    a = 0

    for p in range(1, int(c.isqrt(m)) + 1):
        if m % p == 0:
            q = m // p

            if c.gcd(p, q) == 1:

                a = x * p
                b = x * q

                if l <= a <= r and l <= b <= r:
                    if a == b:
                        a += 1
                    else:
                        a += 2

    print(a)

if __name__ == '__main__':
    d()"
1000,C,Covered Points Count,PROGRAMMING,"['data structures', 'implementation', 'sortings']","You are given $n$ segments on a coordinate line; each endpoint of every segment has integer coordinates. Some segments can degenerate to points. Segments can intersect with each other, be nested in each other or even coincide.

Your task is the following: for every $k \in [1..n]$, calculate the number of points with integer coordinates such that the number of segments that cover these points equals $k$. A segment with endpoints $l_i$ and $r_i$ covers point $x$ if and only if $l_i \le x \le r_i$.","The first line of the input contains one integer $n$ ($1 \le n \le 2 \cdot 10^5$) — the number of segments.

The next $n$ lines contain segments. The $i$-th line contains a pair of integers $l_i, r_i$ ($0 \le l_i \le r_i \le 10^{18}$) — the endpoints of the $i$-th segment.","Print $n$ space separated integers $cnt_1, cnt_2, \dots, cnt_n$, where $cnt_i$ is equal to the number of points such that the number of segments that cover these points equals to $i$.","['3\n0 3\n1 3\n3 8\n', '3\n1 3\n2 4\n5 7\n']","['6 2 1 \n', '5 2 0 \n']","The picture describing the first example:

<img class=""tex-graphics"" src=""https://espresso.codeforces.com/f76b3fe547bff6be5b14de76c8b78ba3efecc744.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

Points with coordinates $[0, 4, 5, 6, 7, 8]$ are covered by one segment, points $[1, 2]$ are covered by two segments and point $[3]$ is covered by three segments.

The picture describing the second example:

<img class=""tex-graphics"" src=""https://espresso.codeforces.com/6e9332c303e1bc5d6cf34c2d6c5e2a19c9417289.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

Points $[1, 4, 5, 6, 7]$ are covered by one segment, points $[2, 3]$ are covered by two segments and there are no points covered by three segments.",OK,"import b

if __name__ == '__main__':
    n = int(input())
    a = b.defaultdict(int)
    for i in range(n):
        l, r = list(map(int, input().strip().split()))
        a[l] += 1; a[r + 1] -= 1
    a = dict(sorted(a.items(), key=lambda k: k[0]))
    c = list(a.c())
    e = len(c)
    for i in range(1, e):
        a[c[i]] += a[c[i - 1]]
    d = [0] * (n + 1)
    for i in range(e - 1):
        d[a[c[i]]] += c[i + 1] - c[i]
    for i in range(1, n):
        print(d[i], end="" "")
    print(d[n])","import k
import g

def f():

    e = k.stdin.read().split()
    if not e:
        return

    n = int(e[0])
    m = int(e[1])
    n = int(e[2])

    j = list(map(int, e[3:3+n]))

    p = int(e[3+n])
    q = int(e[4+n])
    
    c = float('inf')
    b = -1

    a = float('inf')

    for i in range(1, n):
        o = j[i]

        d = o / m

        h = g.sqrt((o - p) ** 2 + (q) ** 2)

        i = h / n
        l = d + i

        if l < c - 1e-9:
            c = l
            b = i + 1
            a = abs(o - p)

        elif abs(l - c) < 1e-9:
            if abs(o - p) < a:
                b = i + 1
                a = abs(o - p)

    print(b)

if __name__ == '__main__':
    f()"
768,B,Code For 1,PROGRAMMING,"['constructive algorithms', 'dfs and similar', 'divide and conquer']","Jon fought bravely to rescue the wildlings who were attacked by the white-walkers at Hardhome. On his arrival, Sam tells him that he wants to go to Oldtown to train at the Citadel to become a maester, so he can return and take the deceased Aemon's place as maester of Castle Black. Jon agrees to Sam's proposal and Sam sets off his journey to the Citadel. However becoming a trainee at the Citadel is not a cakewalk and hence the maesters at the Citadel gave Sam a problem to test his eligibility. 

Initially Sam has a list with a single element *n*. Then he has to perform certain operations on this list. In each operation Sam must remove any element *x*, such that *x*<=&gt;<=1, from the list and insert at the same position , ,  sequentially. He must continue with these operations until all the elements in the list are either 0 or 1.

Now the masters want the total number of 1s in the range *l* to *r* (1-indexed). Sam wants to become a maester but unfortunately he cannot solve this problem. Can you help Sam to pass the eligibility test?","The first line contains three integers *n*, *l*, *r* (0<=≤<=*n*<=&lt;<=250, 0<=≤<=*r*<=-<=*l*<=≤<=105, *r*<=≥<=1, *l*<=≥<=1) – initial element and the range *l* to *r*.

It is guaranteed that *r* is not greater than the length of the final list.",Output the total number of 1s in the range *l* to *r* in the final sequence.,"['7 2 5\n', '10 3 10\n']","['4\n', '5\n']","Consider first example:

<img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/288fbb682a6fa1934a47b763d6851f9d32a06150.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

Elements on positions from 2-nd to 5-th in list is [1, 1, 1, 1]. The number of ones is 4.

For the second example:

<img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/52e9bc51ef858cacc27fc274c7ba9419d5c1ded9.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

Elements on positions from 3-rd to 10-th in list is [1, 1, 1, 0, 1, 0, 1, 0]. The number of ones is 5.",WRONG_ANSWER,"from math import b, c

import g
g.setrecursionlimit(10**4)

def e(x):
    n = b(c(x))
    f = 0
    for i in range(n - 1):
        f += 2**i
    return f + (3 * (2**(n-1)))

n, l, r = map(int, input().split())

def a(d, i, j):

    if j < l or r < i:
        return 0

    if d == 0 or d == 1:
        return d

    m = l + e(d//2)

    f = 0

    if i <= m <= j:
        f += d % 2

    f += a(d//2, i, m - 1)
    f += a(d//2, m + 1, j)

    return f

print(a(n, 1, e(n)))","import h
f = h.stdin.read().splitlines()
if not f:
    exit()

r, c = map(int, f[0].split())

a = [list(g.strip()) for g in f[1:r+1]]

e = [i for i in range(r) if 'S' not in a[i]]

d = []
for j in range(c):
    b = False
    for i in range(r):
        if a[i][j] == 'S':
            b = True
            break
    if not b:
        d.append(j)

c = len(e) * c

c += (r - len(e)) * len(d)

h.stdout.write(str(c))"
73,D,FreeDiv,PROGRAMMING,"['dfs and similar', 'graphs', 'greedy']","Vasya plays FreeDiv. In this game he manages a huge state, which has *n* cities and *m* two-way roads between them. Unfortunately, not from every city you can reach any other one moving along these roads. Therefore Vasya decided to divide the state into provinces so that in every province, one could reach from every city all the cities of the province, but there are no roads between provinces. 

Unlike other turn-based strategies, in FreeDiv a player has the opportunity to build tunnels between cities. The tunnels are two-way roads along which one can move armies undetected by the enemy. However, no more than one tunnel can be connected to each city. As for Vasya, he wants to build a network of tunnels so that any pair of cities in his state were reachable by some path consisting of roads and a tunnels. But at that no more than *k* tunnels are connected to each province (otherwise, the province will be difficult to keep in case other provinces are captured by enemy armies).

Vasya discovered that maybe he will not be able to build such a network for the current condition of the state. Maybe he'll have first to build several roads between cities in different provinces to merge the provinces. Your task is to determine the minimum number of roads Vasya needs to build so that it was possible to build the required network of tunnels in the resulting state.","The first line contains three integers *n*, *m* and *k* (1<=≤<=*n*,<=*k*<=≤<=106,<=0<=≤<=*m*<=≤<=106). Each of the next *m* lines contains two integers. They are the numbers of cities connected by a corresponding road. No road connects city to itself and there is at most one road between each pair of cities.","Print a single number, the minimum number of additional roads.","['3 3 2\n1 2\n2 3\n3 1\n', '4 2 2\n1 2\n3 4\n', '4 0 2\n']","['0', '0', '1']","In the first example only one province exists, so it is not necessary to build any tunnels or roads.

In the second example two provinces exist. It is possible to merge the provinces by building a tunnel between cities 1 and 3.

In the third example at least one additional road is necessary. For example it is possible to build additional road between cities 1 and 2 and build two tunnels between cities 1 and 3, 2 and 4 after that.",WRONG_ANSWER,"import k

class a:
    def __init__(i, n: int):
        i.data = list(range(n))
        i.rank = [1] * n
        i.size = [1] * n
        i.count = n
    
    def c(i, x: int) -> int:
        y = x
        while i.data[y] != y:
            y = i.data[y]
        while i.data[x] != y:
            x, i.data[x] = i.data[x], y
        return y

    def m(i, x: int, y: int):
        x, y = i.c(x), i.c(y)
        if x == y:
            return
        if i.rank[x] == i.rank[y]:
            i.rank[x] += 1
        if i.rank[x] > i.rank[y]:
            i.data[y] = x
            i.size[x] += i.size[y]
        else:
            i.data[x] = y
            i.size[y] += i.size[x]
        i.count -= 1

N, K = 0, 0
b = []

g = 0

def e():
    global N, K
    f = k.stdin.f
    N, M, K = [int(w) for w in f().split()]
    for _ in range(M):
        b.append([int(w) - 1 for w in f().split()])

def j():
    global g
    l = a(N)
    for u, v in b:
        l.m(u, v)
    if K == 1:
        g = max(0, l.count - 2)
        return
    d = 0
    h = set()
    for i in range(N):
        x = l.c(i)
        if x in h:
            continue
        h.add(x)
        d += min(K, l.size[x])
    g = max(0, N - (d // 2) - 1)

def n():
    print(g)

e()
j()
n()","import j

def f():

    c = j.stdin.read().split()

    n = int(c[0])

    a = list(map(int, c[1:n+1]))

    h = 0
    d = 0

    i = True

    e, g = 0, n - 1
    while e <= g:

        if a[e] >= a[g]:
            b = a[e]
            e += 1
        else:
            b = a[g]
            g -= 1

        if i:
            h += b
        else:
            d += b

        i = not i

    print(h, d)

if __name__ == '__main__':
    f()"
448,B,Suffix Structures,PROGRAMMING,"['implementation', 'strings']","Bizon the Champion isn't just a bison. He also is a favorite of the ""Bizons"" team.

At a competition the ""Bizons"" got the following problem: ""You are given two distinct words (strings of English letters), *s* and *t*. You need to transform word *s* into word *t*"". The task looked simple to the guys because they know the suffix data structures well. Bizon Senior loves suffix automaton. By applying it once to a string, he can remove from this string any single character. Bizon Middle knows suffix array well. By applying it once to a string, he can swap any two characters of this string. The guys do not know anything about the suffix tree, but it can help them do much more. 

Bizon the Champion wonders whether the ""Bizons"" can solve the problem. Perhaps, the solution do not require both data structures. Find out whether the guys can solve the problem and if they can, how do they do it? Can they solve it either only with use of suffix automaton or only with use of suffix array or they need both structures? Note that any structure may be used an unlimited number of times, the structures may be used in any order.",The first line contains a non-empty word *s*. The second line contains a non-empty word *t*. Words *s* and *t* are different. Each word consists only of lowercase English letters. Each word contains at most 100 letters.,"In the single line print the answer to the problem. Print ""need tree"" (without the quotes) if word *s* cannot be transformed into word *t* even with use of both suffix array and suffix automaton. Print ""automaton"" (without the quotes) if you need only the suffix automaton to solve the problem. Print ""array"" (without the quotes) if you need only the suffix array to solve the problem. Print ""both"" (without the quotes), if you need both data structures to solve the problem.

It's guaranteed that if you can solve the problem only with use of suffix array, then it is impossible to solve it only with use of suffix automaton. This is also true for suffix automaton.","['automaton\ntomat\n', 'array\narary\n', 'both\nhot\n', 'need\ntree\n']","['automaton\n', 'array\n', 'both\n', 'need tree\n']","In the third sample you can act like that: first transform ""both"" into ""oth"" by removing the first character using the suffix automaton and then make two swaps of the string using the suffix array and get ""hot"".",OK,"def d():
	s = input()
	t = input()
	c, b = len(t), len(s)
	def a(s, t):
		i, j = 0, 0
		while i < b and j < c:
			if s[i] == t[j]:
				j += 1
			i += 1
		return j == c
	f = ''.join(sorted(s))
	g = ''.join(sorted(t))
	e = 'automaton' if a(s, t) else 'array' if a(f, g) and c == b else 'both' if a(f, g) else 'need tree'
	print(e)
	return

if __name__ == ""__main__"":
	d()","import e

def c(x):

    if x < 0:
        return False

    h = e.isqrt(x)
    return h * h == x

def b(n, a):

    for f in reversed(a):

        if not c(f):
            return f

def d():

    n = int(input().strip())

    a = list(map(int, input().split()))

    g = b(n, a)

    print(g)

if __name__ == ""__main__"":
    d()"
747,A,Display Size,PROGRAMMING,"['brute force', 'math']","A big company decided to launch a new series of rectangular displays, and decided that the display must have exactly *n* pixels. 

Your task is to determine the size of the rectangular display — the number of lines (rows) of pixels *a* and the number of columns of pixels *b*, so that:
 -  there are exactly *n* pixels on the display; -  the number of rows does not exceed the number of columns, it means *a*<=≤<=*b*; -  the difference *b*<=-<=*a* is as small as possible.",The first line contains the positive integer *n* (1<=≤<=*n*<=≤<=106) — the number of pixels display should have.,Print two integers — the number of rows and columns on the display.,"['8\n', '64\n', '5\n', '999999\n']","['2 4\n', '8 8\n', '1 5\n', '999 1001\n']","In the first example the minimum possible difference equals 2, so on the display should be 2 rows of 4 pixels.

In the second example the minimum possible difference equals 0, so on the display should be 8 rows of 8 pixels.

In the third example the minimum possible difference equals 4, so on the display should be 1 row of 5 pixels.",WRONG_ANSWER,"from math import e
def c(d):
    b = []
    for i in range(1, (d + 1)):
        if d % i == 0:
            b.append(i)
    return b
c=int(input())
v=c(c);len=len(v)

if len==2:
    print(*v)
elif e(c)==int(e(c)):print(int(e(c)),int(e(c)))
else:
    a=v[(len+1)//2]

    if a*a==c:
        print(a,a)
    else:

        if abs(v[(len+1)//2]-v[((len+1)//2-1)])>abs(v[(len+1)//2]-v[(len+1)//2+1]):print(min(v[(len+1)//2],v[(len+1)//2+1]),max(v[(len+1)//2],v[(len+1)//2+1]))
        else:print(min(v[(len+1)//2],v[(len+1)//2-1]),max(v[(len+1)//2],v[(len+1)//2-1]))","import d
import m

def k(e):
    b = [True] * (e + 1)
    b[0] = b[1] = False
    for h in range(2, int(d.sqrt(e)) + 1):
        if b[h]:
            for g in range(h*h, e + 1, h):
                b[g] = False
    return b

def c():

    a = m.stdin.read().split()
    n = int(a[0])
    i = list(map(int, a[1:]))

    f = 10**6
    b = k(f)
    
    j = []
    for x in i:

        l = int(d.isqrt(x))
        if l * l == x and l <= f and b[l]:
            j.append(""YES"")
        else:
            j.append(""NO"")

    m.stdout.write(""\n"".join(j) + ""\n"")

if __name__ == ""__main__"":
    c()"
841,A,Generous Kefa,PROGRAMMING,"['brute force', 'implementation']","One day Kefa found *n* baloons. For convenience, we denote color of *i*-th baloon as *s**i* — lowercase letter of the Latin alphabet. Also Kefa has *k* friends. Friend will be upset, If he get two baloons of the same color. Kefa want to give out all baloons to his friends. Help Kefa to find out, can he give out all his baloons, such that no one of his friens will be upset — print «YES», if he can, and «NO», otherwise. Note, that Kefa's friend will not upset, if he doesn't get baloons at all.","The first line contains two integers *n* and *k* (1<=≤<=*n*,<=*k*<=≤<=100) — the number of baloons and friends.

Next line contains string *s* — colors of baloons.","Answer to the task — «YES» or «NO» in a single line.

You can choose the case (lower or upper) for each letter arbitrary.","['4 2\naabb\n', '6 3\naacaab\n']","['YES\n', 'NO\n']","In the first sample Kefa can give 1-st and 3-rd baloon to the first friend, and 2-nd and 4-th to the second.

In the second sample Kefa needs to give to all his friends baloons of color a, but one baloon will stay, thats why answer is «NO».",OK,"def a(s, k):
    for i in s:
        x = s.count(i)
        if x > k:
            return ""NO""
    return ""YES""

n, k = list(map(int, input().split()))
s = input()
print(a(s, k))","import }
}.setrecursionlimit(300000)

def r(a, b, n=10):

    x = []
    i = j = 0
    while i < len(a) and j < len(b) and len(x) < n:
        if a[i] < b[j]:
            x.append(a[i])
            i += 1
        else:
            x.append(b[j])
            j += 1
    while i < len(a) and len(x) < n:
        x.append(a[i])
        i += 1
    while j < len(b) and len(x) < n:
        x.append(b[j])
        j += 1
    return x

class b:
    def __init__(|, d):
        |.n = len(d)
        |.size = 1
        while |.size < |.n:
            |.size *= 2
        |.tree = [[] for _ in range(2 * |.size)]

        for i in range(|.n):
            |.tree[|.size + i] = d[i]
        for i in range(|.n, |.size):
            |.tree[|.size + i] = []

        for i in range(|.size - 1, 0, -1):
            |.tree[i] = r(|.tree[2 * i], |.tree[2 * i + 1])
    
    def v(|, l, r):

        l += |.size
        r += |.size
        y = []
        z = []
        while l <= r:
            if (l % 2) == 1:
                y = r(y, |.tree[l])
                l += 1
            if (r % 2) == 0:
                z = r(|.tree[r], z)
                r -= 1
            l //= 2
            r //= 2
        return r(y, z)

class a:
    def __init__(|, n, j, g):
        |.n = n
        |.j = j
        |.parent = [0] * (n + 1)
        |.depth = [0] * (n + 1)
        |.heavy = [-1] * (n + 1)
        |.size = [0] * (n + 1)
        |.head = [0] * (n + 1)
        |.pos = [0] * (n + 1)
        
        |.i(1, 0)
        |.curPos = 0
        |.h(1, 1)

        d = [[] for _ in range(n)]

        for s in range(1, n + 1):

            d[|.pos[s]] = g[s][:10]
        |.seg = b(d)
    
    def i(|, v, p):
        |.parent[v] = p
        |.depth[v] = |.depth[p] + 1 if p else 0
        |.size[v] = 1
        q = 0
        for u in |.j[v]:
            if u == p:
                continue
            |.i(u, v)
            if |.size[u] > q:
                q = |.size[u]
                |.heavy[v] = u
            |.size[v] += |.size[u]
    
    def h(|, v, h):
        |.head[v] = h
        |.pos[v] = |.curPos
        |.curPos += 1
        if |.heavy[v] != -1:
            |.h(|.heavy[v], h)
        for u in |.j[v]:
            if u == |.parent[v] or u == |.heavy[v]:
                continue
            |.h(u, u)
    
    def w(|, u, v):

        x = []
        while |.head[u] != |.head[v]:
            if |.depth[|.head[u]] > |.depth[|.head[v]]:

                x = r(|.seg.v(|.pos[|.head[u]], |.pos[u]), x)
                u = |.parent[|.head[u]]
            else:
                x = r(|.seg.v(|.pos[|.head[v]], |.pos[v]), x)
                v = |.parent[|.head[v]]

        l = min(|.pos[u], |.pos[v])
        r = max(|.pos[u], |.pos[v])
        x = r(|.seg.v(l, r), x)
        return x

def p():
    import }
    l = }.stdin.read().split()
    m = iter(l)
    n = int(next(m))
    m = int(next(m))
    q = int(next(m))

    j = [[] for _ in range(n + 1)]
    for _ in range(n - 1):
        u = int(next(m))
        v = int(next(m))
        j[u].append(v)
        j[v].append(u)

    f = [[] for _ in range(n + 1)]
    for u in range(1, m + 1):
        c = int(next(m))
        f[c].append(u)

    k = a(n, j, f)
    
    t = []
    for _ in range(q):
        u = int(next(m))
        v = int(next(m))
        c = int(next(m))

        e = k.w(u, v)

        { = e[:c]

        o = str(len({))
        if {:
            o += "" "" + "" "".join(str(x) for x in {)
        t.append(o)
    
    }.stdout.write(""\n"".join(t))
    
if __name__ == '__main__':
    p()"
0,none,none,none,['none'],"Limak is a little bear who loves to play. Today he is playing by destroying block towers. He built *n* towers in a row. The *i*-th tower is made of *h**i* identical blocks. For clarification see picture for the first sample.

Limak will repeat the following operation till everything is destroyed.

Block is called internal if it has all four neighbors, i.e. it has each side (top, left, down and right) adjacent to other block or to the floor. Otherwise, block is boundary. In one operation Limak destroys all boundary blocks. His paws are very fast and he destroys all those blocks at the same time.

Limak is ready to start. You task is to count how many operations will it take him to destroy all towers.","The first line contains single integer *n* (1<=≤<=*n*<=≤<=105).

The second line contains *n* space-separated integers *h*1,<=*h*2,<=...,<=*h**n* (1<=≤<=*h**i*<=≤<=109) — sizes of towers.",Print the number of operations needed to destroy all towers.,"['6\n2 1 4 6 2 2\n', '7\n3 3 3 1 3 3 3\n']","['3\n', '2\n']",The picture below shows all three operations for the first sample test. Each time boundary blocks are marked with red color.,OK,"def d():
    n = int(input())
    a = [int(i) for i in input().split()]
    b = [1] * n
    c = [1] * n
    for i in range(1, n):
        b[i] = min(b[i - 1] + 1, a[i])
    for i in range(n - 2, -1, -1):
        c[i] = min(c[i + 1] + 1, a[i])
    a = 0
    for i in range(n):
        a = max(a, min(b[i], c[i]))
    print(a)
d()","def d():
    import h
    b = h.stdin.read().strip().split()
    if not b:
        return

    n = int(b[0])

    g = list(map(int, b[1:]))

    v = [0] * (n + 1)
    v[0] = 1

    c = {1: 0}

    e = 2

    for i in range(1, n + 1):
        f = g[i - 1]

        a = v[f]

        if c.get(a, -1) == f:
            v[i] = a
            c[a] = i
        else:

            v[i] = e
            c[e] = i
            e += 1

    h.stdout.write(str(e - 1))
    
if __name__ == '__main__':
    d()"
47,B,Coins,PROGRAMMING,['implementation'],"One day Vasya came across three Berland coins. They didn't have any numbers that's why Vasya didn't understand how their denominations differ. He supposed that if one coin is heavier than the other one, then it should be worth more. Vasya weighed all the three pairs of coins on pan balance scales and told you the results. Find out how the deminations of the coins differ or if Vasya has a mistake in the weighting results. No two coins are equal.","The input data contains the results of all the weighting, one result on each line. It is guaranteed that every coin pair was weighted exactly once. Vasya labelled the coins with letters «A», «B» and «C». Each result is a line that appears as (letter)(&gt; or &lt; sign)(letter). For example, if coin ""A"" proved lighter than coin ""B"", the result of the weighting is A&lt;B.","It the results are contradictory, print Impossible. Otherwise, print without spaces the rearrangement of letters «A», «B» and «C» which represent the coins in the increasing order of their weights.","['A&gt;B\nC&lt;B\nA&gt;C\n', 'A&lt;B\nB&gt;C\nC&gt;A\n']","['CBA', 'ACB']",none,WRONG_ANSWER,"def a():
    a ,b, c= 0,0,0
    d = {""A"":0 , ""B"":0 , ""C"":0}
    for _ in range(3):
        b = input()
        if b == ""A>B"" or b == ""B<A"" :
            d[""A""] += 1
            d[""B""] -= 1

        elif b == ""A<B"" or b == ""B>A"":
            d[""A""] -= 1
            d[""B""] += 1
        elif b == ""B>C"" or b == ""C<B"":
            d[""B""] += 1
            d[""C""] -= 1
        elif b == ""B<C"" or b == ""C>B"":
            d[""C""] += 1
            d[""B""] -= 1
        elif b == ""A>C"" or b == ""C<A"":
            d[""A""] += 1
            d[""C""] -= 1
        elif b == ""A<C"" or b == ""C>A"":
            d[""A""] -= 1
            d[""C""] += 1
    d = dict(sorted(d.items(), key=lambda x: x[1], reverse=False))
    c = """"
    for i in d.keys():
        c += i
    return c

print(a())","a, b, c, d = map(int, input().split())

s = input().strip()

e = {
    '1': a,
    '2': b,
    '3': c,
    '4': d
}

g = 0

for f in s:

    g += e[f]

print(g)"
664,A,Complicated GCD,PROGRAMMING,"['math', 'number theory']","Greatest common divisor *GCD*(*a*,<=*b*) of two positive integers *a* and *b* is equal to the biggest integer *d* such that both integers *a* and *b* are divisible by *d*. There are many efficient algorithms to find greatest common divisor *GCD*(*a*,<=*b*), for example, Euclid algorithm. 

Formally, find the biggest integer *d*, such that all integers *a*,<=*a*<=+<=1,<=*a*<=+<=2,<=...,<=*b* are divisible by *d*. To make the problem even more complicated we allow *a* and *b* to be up to googol, 10100 — such number do not fit even in 64-bit integer type!",The only line of the input contains two integers *a* and *b* (1<=≤<=*a*<=≤<=*b*<=≤<=10100).,Output one integer — greatest common divisor of all integers from *a* to *b* inclusive.,"['1 2\n', '61803398874989484820458683436563811772030917980576 61803398874989484820458683436563811772030917980576\n']","['1\n', '61803398874989484820458683436563811772030917980576\n']",none,TIME_LIMIT_EXCEEDED,"def b(a,b):
    while b!=0:
        a, b = b, a%b
    return a
 
a, b = map(int, input().split())
c=0
k=0
c=[]
for i in range(a, b+1):
    for j in range(a, b+1):
        c.append(b(i,j))
for a in c:
    for i in range(a, b+1):
        if i%a!=0:
            c = list(filter((a).__ne__, c))
print(*list(set(c)))","import e

def d():

    Y, W = map(int, input().split())

    f = max(Y, W)

    c = 7 - f

    h = 6

    b = e.gcd(c, h)

    g = c // b
    a = h // b

    print(f""{g}/{a}"")

if __name__ == ""__main__"":
    d()"
577,B,Modulo Sum,PROGRAMMING,"['combinatorics', 'data structures', 'dp', 'two pointers']","You are given a sequence of numbers *a*1,<=*a*2,<=...,<=*a**n*, and a number *m*.

Check if it is possible to choose a non-empty subsequence *a**i**j* such that the sum of numbers in this subsequence is divisible by *m*.","The first line contains two numbers, *n* and *m* (1<=≤<=*n*<=≤<=106, 2<=≤<=*m*<=≤<=103) — the size of the original sequence and the number such that sum should be divisible by it.

The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (0<=≤<=*a**i*<=≤<=109).","In the single line print either ""YES"" (without the quotes) if there exists the sought subsequence, or ""NO"" (without the quotes), if such subsequence doesn't exist.","['3 5\n1 2 3\n', '1 6\n5\n', '4 6\n3 1 1 3\n', '6 6\n5 5 5 5 5 5\n']","['YES\n', 'NO\n', 'YES\n', 'YES\n']","In the first sample test you can choose numbers 2 and 3, the sum of which is divisible by 5.

In the second sample test the single non-empty subsequence of numbers is a single number 5. Number 5 is not divisible by 6, that is, the sought subsequence doesn't exist.

In the third sample test you need to choose two numbers 3 on the ends.

In the fourth sample test you can take the whole subsequence.",RUNTIME_ERROR,"def f(d, i):
    b = [False] * (i + 1)
    b[0] = True
    n = len(d)

    for i in range(1, n + 1):
        for j in range(i, -1, -1):
            if j - d[i - 1] >= 0:
                b[j] |= b[j - d[i - 1]]

    return b[i]

def e(tc):
    n, m = map(int, input().split())
    v = list(map(int, input().split()))

    def h(j):
        return sum(j)

    g = h(v)
    a = False
    v.sort()
    if v[0] == 0:
        print(""yes"")
        return

    f(v, m * (g // m))
    for i in range(1, (g // m) + 1):
        if i * m < g:
            a |= b[i * m]

    if a:
        print(""yes"")
    else:
        print(""no"")

def c():
    t = 1

    for i in range(1, t + 1):
        e(i)

if __name__ == ""__main__"":
    c()","def b(m, n):

    return (m * n) // 2

if __name__ == '__main__':
    import d

    a = d.stdin.read().strip()
    if a:

        e = a.split()
        m = int(e[0])
        n = int(e[1])

        c = b(m, n)

        print(c)"
522,A,Reposts,PROGRAMMING,"['*special', 'dfs and similar', 'dp', 'graphs', 'trees']","One day Polycarp published a funny picture in a social network making a poll about the color of his handle. Many of his friends started reposting Polycarp's joke to their news feed. Some of them reposted the reposts and so on.

These events are given as a sequence of strings ""name1 reposted name2"", where name1 is the name of the person who reposted the joke, and name2 is the name of the person from whose news feed the joke was reposted. It is guaranteed that for each string ""name1 reposted name2"" user ""name1"" didn't have the joke in his feed yet, and ""name2"" already had it in his feed by the moment of repost. Polycarp was registered as ""Polycarp"" and initially the joke was only in his feed.

Polycarp measures the popularity of the joke as the length of the largest repost chain. Print the popularity of Polycarp's joke.","The first line of the input contains integer *n* (1<=≤<=*n*<=≤<=200) — the number of reposts. Next follow the reposts in the order they were made. Each of them is written on a single line and looks as ""name1 reposted name2"". All the names in the input consist of lowercase or uppercase English letters and/or digits and have lengths from 2 to 24 characters, inclusive.

We know that the user names are case-insensitive, that is, two names that only differ in the letter case correspond to the same social network user.",Print a single integer — the maximum length of a repost chain.,"['5\ntourist reposted Polycarp\nPetr reposted Tourist\nWJMZBMR reposted Petr\nsdya reposted wjmzbmr\nvepifanov reposted sdya\n', '6\nMike reposted Polycarp\nMax reposted Polycarp\nEveryOne reposted Polycarp\n111 reposted Polycarp\nVkCup reposted Polycarp\nCodeforces reposted Polycarp\n', '1\nSoMeStRaNgEgUe reposted PoLyCaRp\n']","['6\n', '2\n', '2\n']",none,WRONG_ANSWER,"from collections import defaultdict, b
n = int(input())
g = {}
for _ in range(n):
    p = input().split()
    g[p[2].lower()] = g.get(p[0].lower(),[]) + [p[0].lower()]
a = -float('inf')
d = g.keys()

c = 0
f = b(['polycarp'])
while f:
    l = len(f)
    for _ in range(l):
        g = f.popleft()
        
        if g in g:
            for e in g[g]:
                f.append(e)
    c+=1
print(c)","def e():
    import h

    c = h.stdin.read().strip().split()
    if not c:
        return
    a, b, f = c[:3]
    a = int(a)
    b = int(b)
    n = int(f)

    d = None
    for d in range(10):
        if (a * 10 + d) % b == 0:
            d = d
            break

    if d is None:
        h.stdout.write(""-1"")
    else:

        g = str(a) + str(d) + ""0"" * (n - 1)
        h.stdout.write(g)

if __name__ == '__main__':
    e()"
0,none,none,none,['none'],"Astronaut Natasha arrived on Mars. She knows that the Martians are very poor aliens. To ensure a better life for the Mars citizens, their emperor decided to take tax from every tourist who visited the planet. Natasha is the inhabitant of Earth, therefore she had to pay the tax to enter the territory of Mars.

There are $n$ banknote denominations on Mars: the value of $i$-th banknote is $a_i$. Natasha has an infinite number of banknotes of each denomination.

Martians have $k$ fingers on their hands, so they use a number system with base $k$. In addition, the Martians consider the digit $d$ (in the number system with base $k$) divine. Thus, if the last digit in Natasha's tax amount written in the number system with the base $k$ is $d$, the Martians will be happy. Unfortunately, Natasha does not know the Martians' divine digit yet.

Determine for which values $d$ Natasha can make the Martians happy.

Natasha can use only her banknotes. Martians don't give her change.","The first line contains two integers $n$ and $k$ ($1 \le n \le 100\,000$, $2 \le k \le 100\,000$) — the number of denominations of banknotes and the base of the number system on Mars.

The second line contains $n$ integers $a_1, a_2, \ldots, a_n$ ($1 \le a_i \le 10^9$) — denominations of banknotes on Mars.

All numbers are given in decimal notation.","On the first line output the number of values $d$ for which Natasha can make the Martians happy.

In the second line, output all these values in increasing order.

Print all numbers in decimal notation.","['2 8\n12 20\n', '3 10\n10 20 30\n']","['2\n0 4 ', '1\n0 ']","Consider the first test case. It uses the octal number system.

If you take one banknote with the value of $12$, you will get $14_8$ in octal system. The last digit is $4_8$.

If you take one banknote with the value of $12$ and one banknote with the value of $20$, the total value will be $32$. In the octal system, it is $40_8$. The last digit is $0_8$.

If you take two banknotes with the value of $20$, the total value will be $40$, this is $50_8$ in the octal system. The last digit is $0_8$.

No other digits other than $0_8$ and $4_8$ can be obtained. Digits $0_8$ and $4_8$ could also be obtained in other ways.

The second test case uses the decimal number system. The nominals of all banknotes end with zero, so Natasha can give the Martians only the amount whose decimal notation also ends with zero.",WRONG_ANSWER,"def c(a,b): 
    if(b==0): 
        return a 
    else: 
        return c(b,a%b) 
n,k=map(int,input().split())
a=input().split()
d=[]
for i in range(n):
    d.append(int(a[i])%k)
d=list(set(d))
if(len(d)==1):
    if(d[0]==0):
        print(1)
        print(0)
    else:    
        a=[]
        for i in range(k):
            if(i%d[0]==0):
                a.append(i)
        print(len(a))
        print(*a)
else:
    b=c(d[0],d[1])
    for i in range(2,len(d)):
        b=c(b,d[i])
    a=[]
    for i in range(k):
        if(i%b==0):
            a.append(i)
    print(len(a))
    print(*a)","import g

def c():

    b = g.stdin.read().splitlines()
    if not b:
        return

    n, m = map(int, b[0].split())

    h = b[1:1 + n]

    f = [False] * (n - 1)
    
    d = 0

    for a in range(m):

        e = False
        for i in range(n - 1):

            if not f[i]:

                if h[i][a] > h[i+1][a]:
                    e = True
                    break

        if e:
            d += 1
            continue

        for i in range(n - 1):
            if not f[i] and h[i][a] < h[i+1][a]:
                f[i] = True

    print(d)

if __name__ == '__main__':
    c()"
598,D,Igor In the Museum,PROGRAMMING,"['dfs and similar', 'graphs', 'shortest paths']","Igor is in the museum and he wants to see as many pictures as possible.

Museum can be represented as a rectangular field of *n*<=×<=*m* cells. Each cell is either empty or impassable. Empty cells are marked with '.', impassable cells are marked with '*'. Every two adjacent cells of different types (one empty and one impassable) are divided by a wall containing one picture.

At the beginning Igor is in some empty cell. At every moment he can move to any empty cell that share a side with the current one.

For several starting positions you should calculate the maximum number of pictures that Igor can see. Igor is able to see the picture only if he is in the cell adjacent to the wall with this picture. Igor have a lot of time, so he will examine every picture he can see.","First line of the input contains three integers *n*, *m* and *k* (3<=≤<=*n*,<=*m*<=≤<=1000,<=1<=≤<=*k*<=≤<=*min*(*n*·*m*,<=100<=000)) — the museum dimensions and the number of starting positions to process.

Each of the next *n* lines contains *m* symbols '.', '*' — the description of the museum. It is guaranteed that all border cells are impassable, so Igor can't go out from the museum.

Each of the last *k* lines contains two integers *x* and *y* (1<=≤<=*x*<=≤<=*n*,<=1<=≤<=*y*<=≤<=*m*) — the row and the column of one of Igor's starting positions respectively. Rows are numbered from top to bottom, columns — from left to right. It is guaranteed that all starting positions are empty cells.","Print *k* integers — the maximum number of pictures, that Igor can see if he starts in corresponding position.","['5 6 3\n******\n*..*.*\n******\n*....*\n******\n2 2\n2 5\n4 3\n', '4 4 1\n****\n*..*\n*.**\n****\n3 2\n']","['6\n4\n10\n', '8\n']",none,RUNTIME_ERROR,"import k, c, numpy

m,n,k = map(int, k.stdin.readline().split())
g = []

for i in range(m):
    s = k.stdin.readline()
    g.append(list(s))

f = {}

def a(r, c, b):
    Q = c.deque()
    Q.append((r,c))
    g[r][c] = b
    j = 0

    while Q:
        r,c = Q.pop()

        for i, h in (r-1, c), (r+1,c), (r, c-1), (r, c+1):            
            if g[i][h] == '*':
                j += 1
                continue
            elif g[i][h] == '.':              
                g[i][h] = b
                Q.appendleft((i,h))

    f[b] = j

e = 0

for _ in range(k):
    r,c = map(int, k.stdin.readline().split())
    r -= 1
    c -= 1

    if g[r][c] == '.':
        a(r,c, e)
        e += 1
    
    d = g[r][c]
    print(f[d])","""""""
We use a DFS approach.
For each node v (1-indexed), define a bitmask (an integer)
that represents the set of time offsets at which an apple leaves v.
For a non-root node v, two sources contribute:
  (1) The apple initially present in v contributes {1}.
  (2) All apples coming from its children: for each child w,
      the apples leaving w will reach v one second later,
      so we take the bitmask from w shifted left by 1.
Since apples annihilate pairwise, we perform additions modulo 2 (i.e. XOR).
For the root (node 1), we do not add its own apple because it is
collected immediately at time 0.
The final answer is 1 (the apple originally in node1)
plus the number of set bits in the bitmask computed for node1,
each set bit representing a distinct time an apple is collected.
""""""

import i
i.setrecursionlimit(300000)

def h():
    d = i.stdin.read().split()
    if not d:
        return
    n = int(d[0])

    c = [[] for _ in range(n + 1)]

    for i in range(2, n + 1):
        p = int(d[i - 1])
        c[p].append(i)

    def e(v):
        f = 0
        for w in c[v]:
            b = e(w)

            f ^= (b << 1)
        if v != 1:

            f ^= (1 << 1)
        return f
    
    g = e(1)

    a = 1 + (g.bit_count() if hasattr(g, ""bit_count"") else bin(g).count(""1""))
    i.stdout.write(str(a))
    
if __name__ == '__main__':
    h()"
71,A,Way Too Long Words,PROGRAMMING,['strings'],"Sometimes some words like ""localization"" or ""internationalization"" are so long that writing them many times in one text is quite tiresome.

Let's consider a word too long, if its length is strictly more than 10 characters. All too long words should be replaced with a special abbreviation.

This abbreviation is made like this: we write down the first and the last letter of a word and between them we write the number of letters between the first and the last letters. That number is in decimal system and doesn't contain any leading zeroes.

Thus, ""localization"" will be spelt as ""l10n"", and ""internationalization» will be spelt as ""i18n"".

You are suggested to automatize the process of changing the words with abbreviations. At that all too long words should be replaced by the abbreviation and the words that are not too long should not undergo any changes.",The first line contains an integer *n* (1<=≤<=*n*<=≤<=100). Each of the following *n* lines contains one word. All the words consist of lowercase Latin letters and possess the lengths of from 1 to 100 characters.,Print *n* lines. The *i*-th line should contain the result of replacing of the *i*-th word from the input data.,['4\nword\nlocalization\ninternationalization\npneumonoultramicroscopicsilicovolcanoconiosis\n'],['word\nl10n\ni18n\np43s\n'],none,WRONG_ANSWER,"def c(d):
    if len(d)<=2:
        return d
    b=len(d)-2
    s=d[0]+str(b)+d[-1]
    return s
t=int(input())
for i in range(t):
    d=input()
    a=c(d)
    print(a)","import h

def e():

    s = h.stdin.readline().rstrip('\n')
    n = len(s)
    
    d = [0] * n
    c = [0] * n
    
    a = 0
    b = -1

    for i in range(n):

        if s[i] == ')' or s[i] == ']':

            f = '(' if s[i] == ')' else '['

            if i - 1 >= 0 and s[i - 1] == f:
                d[i] = 2 + (d[i - 2] if i - 2 >= 0 else 0)
                c[i] = (1 if f == '[' else 0) + (c[i - 2] if i - 2 >= 0 else 0)

            elif i - d[i - 1] - 1 >= 0 and s[i - d[i - 1] - 1] == f:
                d[i] = d[i - 1] + 2
                c[i] = c[i - 1] + (1 if f == '[' else 0)
                if i - d[i - 1] - 2 >= 0:
                    d[i] += d[i - d[i - 1] - 2]
                    c[i] += c[i - d[i - 1] - 2]

            if d[i] > 0 and c[i] > a:
                a = c[i]
                b = i

    if b == -1:
        print(0)
        print("""")
    else:
        g = b - d[b] + 1
        print(a)
        print(s[g:b + 1])

if __name__ == '__main__':
    e()"
203,C,Photographer,PROGRAMMING,"['greedy', 'sortings']","Valera's lifelong ambition was to be a photographer, so he bought a new camera. Every day he got more and more clients asking for photos, and one day Valera needed a program that would determine the maximum number of people he can serve.

The camera's memory is *d* megabytes. Valera's camera can take photos of high and low quality. One low quality photo takes *a* megabytes of memory, one high quality photo take *b* megabytes of memory. For unknown reasons, each client asks him to make several low quality photos and several high quality photos. More formally, the *i*-th client asks to make *x**i* low quality photos and *y**i* high quality photos.

Valera wants to serve as many clients per day as possible, provided that they will be pleased with his work. To please the *i*-th client, Valera needs to give him everything he wants, that is, to make *x**i* low quality photos and *y**i* high quality photos. To make one low quality photo, the camera must have at least *a* megabytes of free memory space. Similarly, to make one high quality photo, the camera must have at least *b* megabytes of free memory space. Initially the camera's memory is empty. Valera also does not delete photos from the camera so that the camera's memory gradually fills up.

Calculate the maximum number of clients Valera can successfully serve and print the numbers of these clients.","The first line contains two integers *n* and *d* (1<=≤<=*n*<=≤<=105,<=1<=≤<=*d*<=≤<=109) — the number of clients and the camera memory size, correspondingly. The second line contains two integers *a* and *b* (1<=≤<=*a*<=≤<=*b*<=≤<=104) — the size of one low quality photo and of one high quality photo, correspondingly. 

Next *n* lines describe the clients. The *i*-th line contains two integers *x**i* and *y**i* (0<=≤<=*x**i*,<=*y**i*<=≤<=105) — the number of low quality photos and high quality photos the *i*-th client wants, correspondingly. 

All numbers on all lines are separated by single spaces.","On the first line print the answer to the problem — the maximum number of clients that Valera can successfully serve. Print on the second line the numbers of the client in any order. All numbers must be distinct. If there are multiple answers, print any of them. The clients are numbered starting with 1 in the order in which they are defined in the input data.","['3 10\n2 3\n1 4\n2 1\n1 0\n', '3 6\n6 6\n1 1\n1 0\n1 0\n']","['2\n3 2 ', '1\n2 ']",none,TIME_LIMIT_EXCEEDED,"class a:
    def __init__(e,f,c):
        e.f=f
        e.c=c
    def __lt__(e, d):
        return e.f < d.f

n,d=map(int,input().split())
a,b=map(int,input().split())
s=[None]*n
for i in range(n):
    x,y=map(int,input().split())
    b=a(0,0)
    b.f=(a*x)+(b*y)
    b.c=i+1
    s[i]=b
s.sort()
b=0
while b<n and d-s[b].f >= 0:
    d-=s[b].f
    b+=1
print(b)
for i in range(b):
    print(s[i].c,end="" "")","import t
t.setrecursionlimit(1000000)

def m():

    j = t.stdin.read().strip().split()

    l = iter(j)
    n = int(next(l))
    m = int(next(l))
    k = int(next(l))

    k = [False] * (n + 1)
    h = []
    for _ in range(k):
        q = int(next(l))
        k[q] = True
        h.append(q)

    i = [[] for _ in range(n + 1)]
    for _ in range(m):
        u = int(next(l))
        v = int(next(l))
        i[u].append(v)
        i[v].append(u)

    v = [False] * (n + 1)

    c = []
    
    def e(q):
        s = [q]
        b = 0
        g = 0
        while s:
            d = s.pop()
            if v[d]:
                continue
            v[d] = True
            b += 1
            if k[d]:
                g += 1
            for o in i[d]:
                if not v[o]:
                    s.append(o)
        return g, b
    
    for i in range(1, n + 1):
        if not v[i]:
            g, b = e(i)
            c.append((g, b))

    f = []
    p = 0
    for g, r in c:
        if g > 0:
            f.append(r)
        else:
            p += r

    n = 0
    for i in range(len(f)):
        if f[i] > f[n]:
            n = i
    
    f[n] += p

    u = 0
    for r in f:
        u += r * (r - 1) // 2

    a = u - m
    t.stdout.write(str(a))

if __name__ == ""__main__"":
    m()"
687,A,NP-Hard Problem,PROGRAMMING,"['dfs and similar', 'graphs']","Recently, Pari and Arya did some research about NP-Hard problems and they found the minimum vertex cover problem very interesting.

Suppose the graph *G* is given. Subset *A* of its vertices is called a vertex cover of this graph, if for each edge *uv* there is at least one endpoint of it in this set, i.e.  or  (or both).

Pari and Arya have won a great undirected graph as an award in a team contest. Now they have to split it in two parts, but both of them want their parts of the graph to be a vertex cover.

They have agreed to give you their graph and you need to find two disjoint subsets of its vertices *A* and *B*, such that both *A* and *B* are vertex cover or claim it's impossible. Each vertex should be given to no more than one of the friends (or you can even keep it for yourself).","The first line of the input contains two integers *n* and *m* (2<=≤<=*n*<=≤<=100<=000, 1<=≤<=*m*<=≤<=100<=000) — the number of vertices and the number of edges in the prize graph, respectively.

Each of the next *m* lines contains a pair of integers *u**i* and *v**i* (1<=<=≤<=<=*u**i*,<=<=*v**i*<=<=≤<=<=*n*), denoting an undirected edge between *u**i* and *v**i*. It's guaranteed the graph won't contain any self-loops or multiple edges.","If it's impossible to split the graph between Pari and Arya as they expect, print ""-1"" (without quotes).

If there are two disjoint sets of vertices, such that both sets are vertex cover, print their descriptions. Each description must contain two lines. The first line contains a single integer *k* denoting the number of vertices in that vertex cover, and the second line contains *k* integers — the indices of vertices. Note that because of *m*<=≥<=1, vertex cover cannot be empty.","['4 2\n1 2\n2 3\n', '3 3\n1 2\n2 3\n1 3\n']","['1\n2 \n2\n1 3 \n', '-1\n']","In the first sample, you can give the vertex number 2 to Arya and vertices numbered 1 and 3 to Pari and keep vertex number 4 for yourself (or give it someone, if you wish).

In the second sample, there is no way to satisfy both Pari and Arya.",RUNTIME_ERROR,"from re import I
import k
input = k.stdin.readline
from math import *
def h(): return [int(x) for x in input().split()]
def i(): return int(input())
b = 2 * 10**5 + 5
a = 10**16 * 2
g = 10**9 + 7

def j():
    n,m = h()
    c = [[] for _ in range(n + 1)]
    for _ in range(m):
        u,v = h()
        c[u].append(v)
        c[v].append(u)
    
    f = [0 for _ in range(n + 1)]
    def e(u,c):
        f[u] = c
        for v in c[u]:
            if f[u] == f[v]:
                return False
            if not f[v] and not e(v,3 - c):
                return False 
        return True
    for i in range(1,n + 1):
        if not f[i]:
            if not e(i,1):
                print(-1)
                return

    def l(c):    
        d = [i for i in range(1,n + 1) if f[i] == c]
        print(len(d))
        for x in d:
            print(x,end="" "")
        print("""")
    
    l(1)
    l(2)

if __name__ == ""__main__"":
    j()","""""""
This script constructs 2*k vectors in 2*k dimensional space with entries ±1
(such that +1 is printed as '+' and -1 is printed as '*')
with the property that any two distinct vectors are orthogonal.
It uses known constructions:
  - For orders 2,4,8,16 (i.e. when 2*k is a power of 2) we use the Sylvester construction.
  - For order 12 (i.e. when k==6, since 2*6==12) we use the Paley construction.
It is known (by the Hadamard matrix theory) that a ±1 matrix of order n with mutual orthogonal rows exists only when n=1,2 or n ≡0 (mod 4). 
Thus, aside from the k=0 trivial case, the allowed k values are k==1 or k even (with 2*k = 4,8,12,16).
""""""

def j(n):

    if n == 1:
        return [[1]]

    a = j(n // 2)
    H = []
    for i in a:
        H.append(i + i)
    for i in a:
        H.append(i + [-x for x in i])
    return H

def g(q):

    n = q + 1
    H = [[0] * n for _ in range(n)]

    for j in range(n):
        H[0][j] = 1
    for i in range(n):
        H[i][0] = 1

    b = set()
    for x in range(1, q):
        b.add((x * x) % q)

    for i in range(1, n):
        for j in range(1, n):
            if i == j:
                H[i][j] = 1
            else:
                d = ( (i - 1) - (j - 1) ) % q

                if d in b:
                    H[i][j] = 1
                else:
                    H[i][j] = -1
    return H

def h(H):

    for i in H:
        e = ''.join('+' if x == 1 else '*' for x in i)
        print(e)

def f():
    import k
    c = k.stdin.read().strip().split()
    if not c:
        return
    k = int(c[0])

    if k == 0:
        return
    n = 2 * k

    if n == 2 or n in [4, 8, 16]:
        H = j(n)
    elif n == 12:
        H = g(11)
    else:

        k.exit(""No construction available for k = {}"".format(k))
    h(H)

if __name__ == '__main__':
    f()"
716,B,Complete the Word,PROGRAMMING,"['greedy', 'two pointers']","ZS the Coder loves to read the dictionary. He thinks that a word is nice if there exists a substring (contiguous segment of letters) of it of length 26 where each letter of English alphabet appears exactly once. In particular, if the string has length strictly less than 26, no such substring exists and thus it is not nice.

Now, ZS the Coder tells you a word, where some of its letters are missing as he forgot them. He wants to determine if it is possible to fill in the missing letters so that the resulting word is nice. If it is possible, he needs you to find an example of such a word as well. Can you help him?","The first and only line of the input contains a single string *s* (1<=≤<=|*s*|<=≤<=50<=000), the word that ZS the Coder remembers. Each character of the string is the uppercase letter of English alphabet ('A'-'Z') or is a question mark ('?'), where the question marks denotes the letters that ZS the Coder can't remember.","If there is no way to replace all the question marks with uppercase letters such that the resulting word is nice, then print <=-<=1 in the only line.

Otherwise, print a string which denotes a possible nice word that ZS the Coder learned. This string should match the string from the input, except for the question marks replaced with uppercase English letters.

If there are multiple solutions, you may print any of them.","['ABC??FGHIJK???OPQR?TUVWXY?\n', 'WELCOMETOCODEFORCESROUNDTHREEHUNDREDANDSEVENTYTWO\n', '??????????????????????????\n', 'AABCDEFGHIJKLMNOPQRSTUVW??M\n']","['ABCDEFGHIJKLMNOPQRZTUVWXYS', '-1', 'MNBVCXZLKJHGFDSAQPWOEIRUYT', '-1']","In the first sample case, ABCDEFGHIJKLMNOPQRZTUVWXYS is a valid answer beacuse it contains a substring of length 26 (the whole string in this case) which contains all the letters of the English alphabet exactly once. Note that there are many possible solutions, such as ABCDEFGHIJKLMNOPQRSTUVWXYZ or ABCEDFGHIJKLMNOPQRZTUVWXYS.

In the second sample case, there are no missing letters. In addition, the given string does not have a substring of length 26 that contains all the letters of the alphabet, so the answer is  - 1.

In the third sample case, any string of length 26 that contains all letters of the English alphabet fits as an answer.",WRONG_ANSWER,"def d(i) :
    b = [chr(i+65) for i in range(26)]; b.sort()
    a = [chr(i+65) for i in range(26)]; c = list(s[i:i+27]); j= 0
    for x in c : 
        if x in a: a.remove(x)
    for x in range(26) :  
        if c[x] == '?' : c[x] = a[j]; j+=1 
    c.sort()
    if c == b : return ''.join(c)
    else : return 0

s=input(); n=len(s) 
for i in range(n-25) :
    n=d(i)
    if n : print(n); break
else : print(-1)","import m

def f():

    b = m.stdin.read().strip().split()
    if not b:
        return

    n = int(b[0])
    l = list(map(int, b[1:]))
    
    h = 10**5

    k = list(range(h + 1))

    for i in range(2, int(h ** 0.5) + 1):
        if k[i] == i:
            for j in range(i * i, h + 1, i):
                if k[j] == j:
                    k[j] = i

    def e(x):
        d = set()
        while x > 1:
            d.add(k[x])
            x //= k[x]
        return d

    from collections import c
    i = c(int)
    for s in l:

        if s > 1:
            j = e(s)
            for p in j:
                i[p] += 1

    g = 0
    for a in i.values():
        if a > g:
            g = a
    if g == 0:
        g = 1

    m.stdout.write(str(g) + ""\n"")

if __name__ == '__main__':
    f()"
61,A,Ultra-Fast Mathematician,PROGRAMMING,['implementation'],"Shapur was an extremely gifted student. He was great at everything including Combinatorics, Algebra, Number Theory, Geometry, Calculus, etc. He was not only smart but extraordinarily fast! He could manage to sum 1018 numbers in a single second.

One day in 230 AD Shapur was trying to find out if any one can possibly do calculations faster than him. As a result he made a very great contest and asked every one to come and take part.

In his contest he gave the contestants many different pairs of numbers. Each number is made from digits 0 or 1. The contestants should write a new number corresponding to the given pair of numbers. The rule is simple: The *i*-th digit of the answer is 1 if and only if the *i*-th digit of the two given numbers differ. In the other case the *i*-th digit of the answer is 0.

Shapur made many numbers and first tried his own speed. He saw that he can perform these operations on numbers of length ∞ (length of a number is number of digits in it) in a glance! He always gives correct answers so he expects the contestants to give correct answers, too. He is a good fellow so he won't give anyone very big numbers and he always gives one person numbers of same length.

Now you are going to take part in Shapur's contest. See if you are faster and more accurate.",There are two lines in each input. Each of them contains a single number. It is guaranteed that the numbers are made from 0 and 1 only and that their length is same. The numbers may start with 0. The length of each number doesn't exceed 100.,Write one line — the corresponding answer. Do not omit the leading 0s.,"['1010100\n0100101\n', '000\n111\n', '1110\n1010\n', '01110\n01100\n']","['1110001\n', '111\n', '0100\n', '00010\n']",none,OK,"def b(f,s):
	return int(f)^int(s)

def a(v):
	f,s=v
	n=len(f)
	for x in range(n):
		yield(b(f[x],s[x]))

v=[input() for _ in range(2)]
for x in a(v):
	print(x,end='')","n = int(input().strip())

a = list(map(int, input().split()))

c = sum(a)

b = [1 if x == 0 else -1 for x in a]

d = float('-inf')
a = 0

for e in b:
    a += e
    if a > d:
        d = a

    if a < 0:
        a = 0

if c == n:
    print(c - 1)
else:
    print(c + d)"
883,F,Lost in Transliteration,PROGRAMMING,['implementation'],"There are some ambiguities when one writes Berland names with the letters of the Latin alphabet.

For example, the Berland sound u can be written in the Latin alphabet as ""u"", and can be written as ""oo"". For this reason, two words ""ulyana"" and ""oolyana"" denote the same name.

The second ambiguity is about the Berland sound h: one can use both ""h"" and ""kh"" to write it. For example, the words ""mihail"" and ""mikhail"" denote the same name.

There are *n* users registered on the Polycarp's website. Each of them indicated a name represented by the Latin letters. How many distinct names are there among them, if two ambiguities described above are taken into account?

Formally, we assume that two words denote the same name, if using the replacements ""u""  ""oo"" and ""h""  ""kh"", you can make the words equal. One can make replacements in both directions, in any of the two words an arbitrary number of times. A letter that resulted from the previous replacement can participate in the next replacements.

For example, the following pairs of words denote the same name:
 -  ""koouper"" and ""kuooper"". Making the replacements described above, you can make both words to be equal: ""koouper""  ""kuuper"" and ""kuooper""  ""kuuper"". -  ""khun"" and ""kkkhoon"". With the replacements described above you can make both words to be equal: ""khun""  ""khoon"" and ""kkkhoon""  ""kkhoon""  ""khoon"". 
For a given list of words, find the minimal number of groups where the words in each group denote the same name.","The first line contains integer number *n* (2<=≤<=*n*<=≤<=400) — number of the words in the list.

The following *n* lines contain words, one word per line. Each word consists of only lowercase Latin letters. The length of each word is between 1 and 20 letters inclusive.",Print the minimal number of groups where the words in each group denote the same name.,"['10\nmihail\noolyana\nkooooper\nhoon\nulyana\nkoouper\nmikhail\nkhun\nkuooper\nkkkhoon\n', '9\nhariton\nhkariton\nbuoi\nkkkhariton\nboooi\nbui\nkhariton\nboui\nboi\n', '2\nalex\nalex\n']","['4\n', '5\n', '1\n']","There are four groups of words in the first example. Words in each group denote same name:
 1.  ""mihail"", ""mikhail"" 1.  ""oolyana"", ""ulyana"" 1.  ""kooooper"", ""koouper"" 1.  ""hoon"", ""khun"", ""kkkhoon"" 
There are five groups of words in the second example. Words in each group denote same name:
 1.  ""hariton"", ""kkkhariton"", ""khariton"" 1.  ""hkariton"" 1.  ""buoi"", ""boooi"", ""boui"" 1.  ""bui"" 1.  ""boi"" 
In the third example the words are equal, so they denote the same name.",RUNTIME_ERROR,"def k(s):
    a = ''
    for i in range(len(s)):
        if s[i] == 'k' and s[i-1] != 'k':
            a = i
        elif s[i] == 'k' and s[i-1] == 'k':
            continue
        elif s[i] == 'h' and s[i-1] == 'k':
            a += s[i]
        elif s[i] != 'h' and s[i-1] == 'k':
            a += s[a:i+1]
        else:
            a += s[i]
    return a
def u(s):
    a = ''
    for i in s:
        if i == 'u':
            a += 'oo'
        else:
            a += i
    return a
n = int(input())
s = set()
for i in range(n):
    a = input()
    s.add(u(k(a)))
print(len(s))","def i():
    import p

    d = p.stdin.read().splitlines()
    if not d:
        return
    s = d[0].strip()
    t = d[1].strip()

    e = [0] * 26
    r = 0
    for c in s:
        if c == '?':
            r += 1
        else:
            e[ord(c) - 97] += 1

    f = [0] * 26
    for c in t:
        f[ord(c) - 97] += 1

    def b(x):
        q = 0
        for i in range(26):

            n = x * f[i]
            if n > e[i]:
                q += (n - e[i])
            if q > r:
                return False
        return True

    h, g = 0, len(s) // len(t) + 2
    while h < g:
        k = (h + g) // 2
        if b(k):
            h = k + 1
        else:
            g = k
    j = h - 1

    l = [0] * 26
    for i in range(26):
        m = j * f[i]
        if m > e[i]:
            l[i] = m - e[i]

    o = []
    for c in s:
        if c != '?':
            o.append(c)
        else:
            a = None
            for i in range(26):
                if l[i] > 0:
                    l[i] -= 1
                    a = chr(i + 97)
                    break
            if a is None:
                a = 'a'
            o.append(a)

    p.stdout.write("""".join(o))

if __name__ == '__main__':
    i()"
835,A,Key races,PROGRAMMING,['math'],"Two boys decided to compete in text typing on the site ""Key races"". During the competition, they have to type a text consisting of *s* characters. The first participant types one character in *v*1 milliseconds and has ping *t*1 milliseconds. The second participant types one character in *v*2 milliseconds and has ping *t*2 milliseconds.

If connection ping (delay) is *t* milliseconds, the competition passes for a participant as follows: 
 1.  Exactly after *t* milliseconds after the start of the competition the participant receives the text to be entered. 1.  Right after that he starts to type it. 1.  Exactly *t* milliseconds after he ends typing all the text, the site receives information about it. 
The winner is the participant whose information on the success comes earlier. If the information comes from both participants at the same time, it is considered that there is a draw.

Given the length of the text and the information about participants, determine the result of the game.","The first line contains five integers *s*, *v*1, *v*2, *t*1, *t*2 (1<=≤<=*s*,<=*v*1,<=*v*2,<=*t*1,<=*t*2<=≤<=1000) — the number of characters in the text, the time of typing one character for the first participant, the time of typing one character for the the second participant, the ping of the first participant and the ping of the second participant.","If the first participant wins, print ""First"". If the second participant wins, print ""Second"". In case of a draw print ""Friendship"".","['5 1 2 1 2\n', '3 3 1 1 1\n', '4 5 3 1 5\n']","['First\n', 'Second\n', 'Friendship\n']","In the first example, information on the success of the first participant comes in 7 milliseconds, of the second participant — in 14 milliseconds. So, the first wins.

In the second example, information on the success of the first participant comes in 11 milliseconds, of the second participant — in 5 milliseconds. So, the second wins.

In the third example, information on the success of the first participant comes in 22 milliseconds, of the second participant — in 22 milliseconds. So, it is be a draw.",WRONG_ANSWER,"s, g, h, e, f = list(map(int, input().split()))
print(s,g,h,e,f)

def a(s, t, v):
    c = s * v + 2 * t 
    return c

b = a(s, e, g)
d = a(s, f, h)

if b > d:
    print('Second')
elif d > b:
    print('First')
else:
    print('Friendship')","def c():

    a = list(map(int, input().split()))

    b = set(a)

    d = 4 - len(b)

    print(d)

if __name__ == '__main__':
    c()"
916,C,Jamie and Interesting Graph,PROGRAMMING,"['constructive algorithms', 'graphs', 'shortest paths']","Jamie has recently found undirected weighted graphs with the following properties very interesting:
 -  The graph is connected and contains exactly *n* vertices and *m* edges. -  All edge weights are integers and are in range [1,<=109] inclusive. -  The length of shortest path from 1 to *n* is a prime number. -  The sum of edges' weights in the minimum spanning tree (MST) of the graph is a prime number. -  The graph contains no loops or multi-edges. 
If you are not familiar with some terms from the statement you can find definitions of them in notes section. 

Help Jamie construct any graph with given number of vertices and edges that is interesting!","First line of input contains 2 integers *n*, *m*  — the required number of vertices and edges.","In the first line output 2 integers *sp*, *mstw* (1<=≤<=*sp*,<=*mstw*<=≤<=1014) — the length of the shortest path and the sum of edges' weights in the minimum spanning tree.

In the next *m* lines output the edges of the graph. In each line output 3 integers *u*, *v*, *w* (1<=≤<=*u*,<=*v*<=≤<=*n*,<=1<=≤<=*w*<=≤<=109) describing the edge connecting *u* and *v* and having weight *w*.","['4 4\n', '5 4\n']","['7 7\n1 2 3\n2 3 2\n3 4 2\n2 4 4\n', '7 13\n1 2 2\n1 3 4\n1 4 3\n4 5 4\n']","The graph of sample 1: <img class=""tex-graphics"" src=""https://espresso.codeforces.com/42f9750de41b0d9a6b21e8615170113cfe19b0f2.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> Shortest path sequence: {1, 2, 3, 4}. MST edges are marked with an asterisk (*).

Definition of terms used in the problem statement:

A shortest path in an undirected graph is a sequence of vertices (*v*<sub class=""lower-index"">1</sub>, *v*<sub class=""lower-index"">2</sub>, ... , *v*<sub class=""lower-index"">*k*</sub>) such that *v*<sub class=""lower-index"">*i*</sub> is adjacent to *v*<sub class=""lower-index"">*i* + 1</sub> 1 ≤ *i* &lt; *k* and the sum of weight <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/e7f62cfd5c2c3b81dc80aaf2f512898495354f03.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> is minimized where *w*(*i*, *j*) is the edge weight between *i* and *j*. ([https://en.wikipedia.org/wiki/Shortest_path_problem](https://en.wikipedia.org/wiki/Shortest_path_problem))

A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. ([https://en.wikipedia.org/wiki/Prime_number](https://en.wikipedia.org/wiki/Prime_number))

A minimum spanning tree (MST) is a subset of the edges of a connected, edge-weighted undirected graph that connects all the vertices together, without any cycles and with the minimum possible total edge weight. ([https://en.wikipedia.org/wiki/Minimum_spanning_tree](https://en.wikipedia.org/wiki/Minimum_spanning_tree))

[https://en.wikipedia.org/wiki/Multiple_edges](https://en.wikipedia.org/wiki/Multiple_edges)",OK,"def a(n, m):
    if (n == 2):
        print(2, 2)
        print(1, 2, 2)
        return
    c = 2
    b = 100003
    print(c, b)
    print(1, n, c)
    print(2, n, b - n + 3 - c)
    for i in range(3, n):
        print(i, n, 1)
    for i in range(2, n):
        for j in range(1, i):
            if (m == n - 1):
                return
            print(i, j, b)
            m -= 1

n, m = input().split()
a(int(n), int(m))","def e():
    import g
    g.setrecursionlimit(10**6)

    b = g.stdin.read().split()
    if not b:
        return
    d = iter(b)
    n = int(next(d))
    m = int(next(d))

    a = [0] * (n + 1)

    f = list(range(n + 2))
    
    def c(x):
        """"""Finds the next active knight starting from x with path compression.""""""
        if f[x] != x:
            f[x] = c(f[x])
        return f[x]

    for _ in range(m):
        l = int(next(d))
        r = int(next(d))
        x = int(next(d))

        i = c(l)
        while i <= r:
            if i != x:

                a[i] = x

                f[i] = c(i + 1)
            i = c(i + 1)

    g.stdout.write("" "".join(map(str, a[1:])) + "" "")

if __name__ == '__main__':
    e()"
585,D,Lizard Era: Beginning,PROGRAMMING,['meet-in-the-middle'],"In the game Lizard Era: Beginning the protagonist will travel with three companions: Lynn, Meliana and Worrigan. Overall the game has *n* mandatory quests. To perform each of them, you need to take exactly two companions.

The attitude of each of the companions to the hero is an integer. Initially, the attitude of each of them to the hero of neutral and equal to 0. As the hero completes quests, he makes actions that change the attitude of the companions, whom he took to perform this task, in positive or negative direction.

Tell us what companions the hero needs to choose to make their attitude equal after completing all the quests. If this can be done in several ways, choose the one in which the value of resulting attitude is greatest possible.","The first line contains positive integer *n* (1<=≤<=*n*<=≤<=25) — the number of important tasks. 

Next *n* lines contain the descriptions of the tasks — the *i*-th line contains three integers *l**i*,<=*m**i*,<=*w**i* — the values by which the attitude of Lynn, Meliana and Worrigan respectively will change towards the hero if the hero takes them on the *i*-th task. All the numbers in the input are integers and do not exceed 107 in absolute value.","If there is no solution, print in the first line ""Impossible"".

Otherwise, print *n* lines, two characters is each line — in the *i*-th line print the first letters of the companions' names that hero should take to complete the *i*-th task ('L' for Lynn, 'M' for Meliana, 'W' for Worrigan). Print the letters in any order, if there are multiple solutions, print any of them.","['3\n1 0 0\n0 1 0\n0 0 1\n', '7\n0 8 9\n5 9 -2\n6 -8 -7\n9 4 5\n-4 -9 9\n-4 5 2\n-6 8 -7\n', '2\n1 0 0\n1 1 0\n']","['LM\nMW\nMW\n', 'LM\nMW\nLM\nLW\nMW\nLM\nLW\n', 'Impossible\n']",none,TIME_LIMIT_EXCEEDED,"from itertools import u
def v():
    for I in range(N // 2 + 2):
        X[I] = list(u(k, I))
    for I in range(N - N // 2):
        Z[I] = list(u(l, I))
    b = []
    d = []
    g = []
    i = []
    for I in range(len(X)):
        for J in range(len(X[I])):
            q = r = 0
            for A in X[I][J]:
                q += L[A]
                r += M[A]
            b.append([q, I, J])
            g.append([r, I, J])
    for I in range(len(Z)):
        for J in range(len(Z[I])):
            s = t = 0
            for B in Z[I][J]:
                s += L[B]
                t += M[B]
            d.append([s, I, J])
            i.append([t, I, J])
    c = []
    h = []
    j = set()
    f = set()
    for I in range(len(b)):
        for J in range(len(d)):
            if I | J:
                P = b[I][0] + d[J][0]
                c.append([P, I, J])
                j.add(P)
    for I in range(len(g)):
        for J in range(len(i)):
            if I | J:
                P = g[I][0] + i[J][0]
                if P in j:
                    h.append([P, I, J])
                    f.add(P)
    a = ''
    e = -10**10
    for I in c:
        for J in h:
            if I[0] == J[0]:
                m = set(X[b[I[1]][1]][b[I[1]][2]]+Z[d[I[2]][1]][d[I[2]][2]])
                n = set(X[g[J[1]][1]][g[J[1]][2]]+Z[i[J[2]][1]][i[J[2]][2]])
                o = (m-n).union(n-m)
                p = 0
                for U in o:
                    p+=W[U]
                if p == I[0]:
                    if m.intersection(n).union(n.intersection(o)).union(o.intersection(m)) == S:
                        D = ''
                        T = 0
                        for Q in range(N):
                            if Q in m:
                                D+='L'
                                T+=L[Q]
                            if Q in n:
                                D+='M'
                                T+=M[Q]
                            if Q in o:
                                D+='W'
                                T+=W[Q]
                            D+='\n'
                        if T > e:
                            a = D
                            e = T
    if a:
        print(a)
    else:
        print('Impossible')
N = int(input())
L = list(range(N))
M = list(range(N))
W = list(range(N))
S = set(L)
X = list(range(N//2+2))
Z = list(range(N-N//2))
k = list(range(N//2+1))
l = list(range(N//2+1, N))
for I in range(N):
    L[I], M[I], W[I] = map(int, input().split())
v()","def d():

    n = input().strip()

    if len(n) == 1:
        print(0)
        return

    b = 0

    while len(n) > 1:

        c = sum(int(a) for a in n)

        n = str(c)

        b += 1

    print(b)

if __name__ == ""__main__"":
    d()"
501,B,Misha and Changing Handles,PROGRAMMING,"['data structures', 'dsu', 'strings']","Misha hacked the Codeforces site. Then he decided to let all the users change their handles. A user can now change his handle any number of times. But each new handle must not be equal to any handle that is already used or that was used at some point.

Misha has a list of handle change requests. After completing the requests he wants to understand the relation between the original and the new handles of the users. Help him to do that.","The first line contains integer *q* (1<=≤<=*q*<=≤<=1000), the number of handle change requests.

Next *q* lines contain the descriptions of the requests, one per line.

Each query consists of two non-empty strings *old* and *new*, separated by a space. The strings consist of lowercase and uppercase Latin letters and digits. Strings *old* and *new* are distinct. The lengths of the strings do not exceed 20.

The requests are given chronologically. In other words, by the moment of a query there is a single person with handle *old*, and handle *new* is not used and has not been used by anyone.","In the first line output the integer *n* — the number of users that changed their handles at least once.

In the next *n* lines print the mapping between the old and the new handles of the users. Each of them must contain two strings, *old* and *new*, separated by a space, meaning that before the user had handle *old*, and after all the requests are completed, his handle is *new*. You may output lines in any order.

Each user who changes the handle must occur exactly once in this description.",['5\nMisha ILoveCodeforces\nVasya Petrov\nPetrov VasyaPetrov123\nILoveCodeforces MikeMirzayanov\nPetya Ivanov\n'],['3\nPetya Ivanov\nMisha MikeMirzayanov\nVasya VasyaPetrov123\n'],none,WRONG_ANSWER,"def b(f, c):
    h, e = f.split("" "")
    j = c.get(h)
    if j:
        del c[h]
        c[e] = j
    else:
        c[e] = h
g = int(input())
c = {}
a = input().split(""\n"")
print(a)
for d in a:
    b(d, c)
i = list(c.items())
i.reverse()
for e, h in i:
    print(h, e)","def d():
    import i
    a = 10**9 + 7

    b = i.stdin.read().strip().split()
    if not b:
        return
    A = int(b[0])
    B = int(b[1])
    n = int(b[2])
    x = int(b[3])

    if n == 0:
        print(x % a)
        return

    if A % a == 1:
        g = (x + n * B) % a
        print(g)
        return

    f = pow(A, n, a)

    e = (f - 1) % a

    c = pow(A - 1, a - 2, a)

    h = (e * c) % a

    g = (f * x + B * h) % a
    print(g)
    
if __name__ == ""__main__"":
    d()"
614,B,Gena's Code,PROGRAMMING,"['implementation', 'math']","It's the year 4527 and the tanks game that we all know and love still exists. There also exists Great Gena's code, written in 2016. The problem this code solves is: given the number of tanks that go into the battle from each country, find their product. If it is turns to be too large, then the servers might have not enough time to assign tanks into teams and the whole game will collapse!

There are exactly *n* distinct countries in the world and the *i*-th country added *a**i* tanks to the game. As the developers of the game are perfectionists, the number of tanks from each country is beautiful. A beautiful number, according to the developers, is such number that its decimal representation consists only of digits '1' and '0', moreover it contains at most one digit '1'. However, due to complaints from players, some number of tanks of one country was removed from the game, hence the number of tanks of this country may not remain beautiful.

Your task is to write the program that solves exactly the same problem in order to verify Gena's code correctness. Just in case.","The first line of the input contains the number of countries *n* (1<=≤<=*n*<=≤<=100<=000). The second line contains *n* non-negative integers *a**i* without leading zeroes — the number of tanks of the *i*-th country.

It is guaranteed that the second line contains at least *n*<=-<=1 beautiful numbers and the total length of all these number's representations doesn't exceed 100<=000.",Print a single number without leading zeroes — the product of the number of tanks presented by each country.,"['3\n5 10 1\n', '4\n1 1 10 11\n', '5\n0 3 1 100 1\n']","['50', '110', '0']","In sample 1 numbers 10 and 1 are beautiful, number 5 is not not.

In sample 2 number 11 is not beautiful (contains two '1's), all others are beautiful.

In sample 3 number 3 is not beautiful, all others are beautiful.",WRONG_ANSWER,"from sys import e

def c(s):
    if s[0] != '1':
        return 1
    for i in s[1:]:
        if i != '0':
            return 1 
    return 0

def a(a):
    for i in a:
        if c(i):
            return i 
    return None

def b(a):
    d = 0
    for i in a:
        if not c(i) and not i == '0':
            d += len(i) - 1
    return d
            

n = int(e.readline().strip())
a = e.readline().strip().split(' ')

b = a(a)

if b is None:
    print('1' + '0' * b(a))
elif b == '0':
    print('0')
else:
    print(b + '0' * b(a))","def c():
    import d

    a = d.stdin.read().splitlines()

    if len(a) < 2:
        return
    
    s = a[0].strip()
    t = a[1].strip()

    if len(s) != len(t):
        print(""NO"")
        return

    b = []
    for i in range(len(s)):
        if s[i] != t[i]:
            b.append(i)

        if len(b) > 2:
            print(""NO"")
            return

    if len(b) == 2:
        i, j = b
        if s[i] == t[j] and s[j] == t[i]:
            print(""YES"")
            return

    print(""NO"")

if __name__ == ""__main__"":
    c()"
991,C,Candies,PROGRAMMING,"['binary search', 'implementation']","After passing a test, Vasya got himself a box of $n$ candies. He decided to eat an equal amount of candies each morning until there are no more candies. However, Petya also noticed the box and decided to get some candies for himself.

This means the process of eating candies is the following: in the beginning Vasya chooses a single integer $k$, same for all days. After that, in the morning he eats $k$ candies from the box (if there are less than $k$ candies in the box, he eats them all), then in the evening Petya eats $10\%$ of the candies remaining in the box. If there are still candies left in the box, the process repeats — next day Vasya eats $k$ candies again, and Petya — $10\%$ of the candies left in a box, and so on.

If the amount of candies in the box is not divisible by $10$, Petya rounds the amount he takes from the box down. For example, if there were $97$ candies in the box, Petya would eat only $9$ of them. In particular, if there are less than $10$ candies in a box, Petya won't eat any at all.

Your task is to find out the minimal amount of $k$ that can be chosen by Vasya so that he would eat at least half of the $n$ candies he initially got. Note that the number $k$ must be integer.",The first line contains a single integer $n$ ($1 \leq n \leq 10^{18}$) — the initial amount of candies in the box.,Output a single integer — the minimal amount of $k$ that would allow Vasya to eat at least half of candies he got.,['68\n'],['3\n'],"In the sample, the amount of candies, with $k=3$, would change in the following way (Vasya eats first):

$68 \to 65 \to 59 \to 56 \to 51 \to 48 \to 44 \to 41 \\ \to 37 \to 34 \to 31 \to 28 \to 26 \to 23 \to 21 \to 18 \to 17 \to 14 \\ \to 13 \to 10 \to 9 \to 6 \to 6 \to 3 \to 3 \to 0$.

In total, Vasya would eat $39$ candies, while Petya — $29$.",TIME_LIMIT_EXCEEDED,"n=int(input())
def w(k):
    s=n
    p=0
    while s>0:
        p+=min(s,k)
        s=max(0,s-k)
        s-=s//10
    if p>=n/2:
        return True
    return False

l,r=0,n
while l<r:
    m=(l+r)//2
    if w(m):
        r=m
    else:
        l=m+1
print(r)","def a():

    n = int(input().strip())

    if n % 2 == 0:
        b = n // 2
    else:
        b = -((n + 1) // 2)

    print(b)

if __name__ == ""__main__"":
    a()"
987,C,Three displays,PROGRAMMING,"['brute force', 'dp', 'implementation']","It is the middle of 2018 and Maria Stepanovna, who lives outside Krasnokamensk (a town in Zabaikalsky region), wants to rent three displays to highlight an important problem.

There are $n$ displays placed along a road, and the $i$-th of them can display a text with font size $s_i$ only. Maria Stepanovna wants to rent such three displays with indices $i &lt; j &lt; k$ that the font size increases if you move along the road in a particular direction. Namely, the condition $s_i &lt; s_j &lt; s_k$ should be held.

The rent cost is for the $i$-th display is $c_i$. Please determine the smallest cost Maria Stepanovna should pay.","The first line contains a single integer $n$ ($3 \le n \le 3\,000$) — the number of displays.

The second line contains $n$ integers $s_1, s_2, \ldots, s_n$ ($1 \le s_i \le 10^9$) — the font sizes on the displays in the order they stand along the road.

The third line contains $n$ integers $c_1, c_2, \ldots, c_n$ ($1 \le c_i \le 10^8$) — the rent costs for each display.","If there are no three displays that satisfy the criteria, print -1. Otherwise print a single integer — the minimum total rent cost of three displays with indices $i &lt; j &lt; k$ such that $s_i &lt; s_j &lt; s_k$.","['5\n2 4 5 4 10\n40 30 20 10 40\n', '3\n100 101 100\n2 4 5\n', '10\n1 2 3 4 5 6 7 8 9 10\n10 13 11 14 15 12 13 13 18 13\n']","['90\n', '-1\n', '33\n']","In the first example you can, for example, choose displays $1$, $4$ and $5$, because $s_1 &lt; s_4 &lt; s_5$ ($2 &lt; 4 &lt; 10$), and the rent cost is $40 + 10 + 40 = 90$.

In the second example you can't select a valid triple of indices, so the answer is -1.",RUNTIME_ERROR,"n = int(input())
s = [int(x) for x in input().strip().split()]
c = [int(x) for x in input().strip().split()]
from functools import d
@d(None)
def b(i, c, e):
    if e==3:
        return 0
        
    if i==len(s):
        return float('inf')
    
    a = b(i+1, c, e)
    
    if c==None:
        a = min(a, b(i+1, i, e+1)+c[i])
    else:
        if s[i]>s[c]:
            a = min(a, b(i+1, i, e+1)+c[i])
    
    return a
    
f = b(0, None, 0)
print(f if f!=float('inf') else -1)","from sys import i

def c():

    a = set()

    j = 0

    for b in i:
        b = b.rstrip(""\n"")
        if not b:
            continue

        if b[0] == ""+"":

            f = b[1:]
            a.add(f)
        elif b[0] == ""-"":

            f = b[1:]
            a.discard(f)
        else:

            g = b.split("":"", 1)
            if len(g) < 2:

                h = g[0]
                d = """"
            else:
                h, d = g

            e = len(d)
            j += e * len(a)

    print(j)

if __name__ == ""__main__"":
    c()"
255,C,Almost Arithmetical Progression,PROGRAMMING,"['brute force', 'dp']","Gena loves sequences of numbers. Recently, he has discovered a new type of sequences which he called an almost arithmetical progression. A sequence is an almost arithmetical progression, if its elements can be represented as:
 -  *a*1<==<=*p*, where *p* is some integer; -  *a**i*<==<=*a**i*<=-<=1<=+<=(<=-<=1)*i*<=+<=1·*q* (*i*<=&gt;<=1), where *q* is some integer. 
Right now Gena has a piece of paper with sequence *b*, consisting of *n* integers. Help Gena, find there the longest subsequence of integers that is an almost arithmetical progression.

Sequence *s*1,<=<=*s*2,<=<=...,<=<=*s**k* is a subsequence of sequence *b*1,<=<=*b*2,<=<=...,<=<=*b**n*, if there is such increasing sequence of indexes *i*1,<=*i*2,<=...,<=*i**k* (1<=<=≤<=<=*i*1<=<=&lt;<=<=*i*2<=<=&lt;<=... <=<=&lt;<=<=*i**k*<=<=≤<=<=*n*), that *b**i**j*<=<==<=<=*s**j*. In other words, sequence *s* can be obtained from *b* by crossing out some elements.","The first line contains integer *n* (1<=≤<=*n*<=≤<=4000). The next line contains *n* integers *b*1,<=*b*2,<=...,<=*b**n* (1<=≤<=*b**i*<=≤<=106).",Print a single integer — the length of the required longest subsequence.,"['2\n3 5\n', '4\n10 20 10 30\n']","['2\n', '3\n']","In the first test the sequence actually is the suitable subsequence. 

In the second test the following subsequence fits: 10, 20, 10.",WRONG_ANSWER,"from sys import n
from bisect import b

def m(o):
    n = int(n.readline().strip())
    l = list(map(int, n.readline().split()))

    e = []
    g = 0
    f = dict()
    for i in range(n):
        if l[i] not in f:
            f[l[i]] = g
            g += 1
            e.append([])
        e[f[l[i]]].append(i)

    a = 1
    m = len(e)
    for i in range(m):
        for j in range(m):
            if i == j:
                continue
            d = -1
            c = 0
            h, i = len(e[i]), len(e[j])
            j, k = 0, 0
            while True:
                k = b(e[i], d, j, h)
                if k == h:
                    break
                j = k+1
                d = e[i][k]
                c += 1

                k = b(e[j], d, k, i)
                if k == i:
                    break
                k = k+1
                d = e[j][k]
                c += 1
            a = max(a, c)

    print(a)

o = 1
m(o)","""""""
Karen’s Grocery Problem

Karen wants to purchase as many goods as possible without exceeding her budget b.
Each good i has a cost c[i], and if she uses its coupon, it subtracts d[i] from the cost.
However, for goods i>=2, to use its coupon discount, she must also use the coupon
for good x[i] (with x[i] < i). Buying an item without coupon is always allowed.

The strategy is to choose a subset of goods and decide, for each chosen good, whether
to use the discount or not. The discount option is only available for a good u if:
 - Either u is the root (first good) or,
 - u's dependency (parent) was purchased with a coupon discount.
Since discount always reduces cost (c[u]-d[u] <= c[u]),
if the discount option is available for a chosen good, it is preferable to use it.
However, using the discount on a good forces its ancestors in that discount chain to also use coupons.

We solve the problem by doing a tree DP over the dependency tree.
For each node u, we define a function solve_node(u, allowed) which returns a list dp,
where dp[k] is the minimum cost to pick exactly k goods from the subtree of u.
The parameter allowed indicates whether u is allowed to be purchased at discount.
If allowed is True then u can be purchased with a coupon (discount option),
otherwise u must be purchased full‐price.

For each node u, there are three options:
  0) Do not pick u. Then process its children independently,
     with discount option unavailable (allowed = False) since u wasn’t bought.
  1) Pick u full price (cost = c[u]). Then children are processed with allowed = False.
  2) If allowed is True, pick u with discount (cost = c[u] - d[u]).
     Then children are processed with allowed = True.
We merge the results of the children using standard knapSack style convolution.

Finally, we compute the DP for the whole tree (root 0, with discount allowed).
The answer is the maximum k such that dp[k] <= b.
""""""

import |
|.setrecursionlimit(10000)
a = 10**18

def u():
    i = |.stdin.read().strip().split()
    if not i:
        return
    s = iter(i)
    n = int(next(s))
    b = int(next(s))

    c = [0] * n
    d = [0] * n

    c[0] = int(next(s))
    d[0] = int(next(s))
    f = [[] for _ in range(n)]
    for i in range(1, n):
        c[i] = int(next(s))
        d[i] = int(next(s))
        z = int(next(s)) - 1
        f[z].append(i)

    v = {}

    def w(y, r):
        j = [0]
        for v in y:
            e = {(v, r)
            x = [a] * (len(j) + len(e) - 1)
            for i in range(len(j)):
                h = j[i]
                if h >= a:
                    continue
                for j in range(len(e)):
                    d = h + e[j]
                    if d < x[i+j]:
                        x[i+j] = d
            j = x
        return j

    def {(u, b):
        t = (u, b)
        if t in v:
            return v[t]

        k = w(f[u], False)

        l = w(f[u], True)

        m = k[:]

        n = [a] * (len(k) + 1)
        for k in range(len(k)):
            d = c[u] + k[k]
            if d < n[k+1]:
                n[k+1] = d

        if b:
            o = [a] * (len(l) + 1)
            for k in range(len(l)):
                d = (c[u] - d[u]) + l[k]
                if d < o[k+1]:
                    o[k+1] = d
        else:
            o = None

        L = max(len(m), len(n), len(o) if o is not None else 0)
        p = [a] * L
        for i in range(len(m)):
            if m[i] < p[i]:
                p[i] = m[i]
        for i in range(len(n)):
            if n[i] < p[i]:
                p[i] = n[i]
        if o is not None:
            for i in range(len(o)):
                if o[i] < p[i]:
                    p[i] = o[i]
        v[t] = p
        return p

    q = {(0, True)

    c = 0
    for k, g in enumerate(q):
        if g <= b:
            c = k
    |.stdout.write(str(c) + ""\n"")

if __name__ == '__main__':
    u()"
999,E,Reachability from the Capital,PROGRAMMING,"['dfs and similar', 'graphs', 'greedy']","There are $n$ cities and $m$ roads in Berland. Each road connects a pair of cities. The roads in Berland are one-way.

What is the minimum number of new roads that need to be built to make all the cities reachable from the capital?

New roads will also be one-way.","The first line of input consists of three integers $n$, $m$ and $s$ ($1 \le n \le 5000, 0 \le m \le 5000, 1 \le s \le n$) — the number of cities, the number of roads and the index of the capital. Cities are indexed from $1$ to $n$.

The following $m$ lines contain roads: road $i$ is given as a pair of cities $u_i$, $v_i$ ($1 \le u_i, v_i \le n$, $u_i \ne v_i$). For each pair of cities $(u, v)$, there can be at most one road from $u$ to $v$. Roads in opposite directions between a pair of cities are allowed (i.e. from $u$ to $v$ and from $v$ to $u$).","Print one integer — the minimum number of extra roads needed to make all the cities reachable from city $s$. If all the cities are already reachable from $s$, print 0.","['9 9 1\n1 2\n1 3\n2 3\n1 5\n5 6\n6 1\n1 8\n9 8\n7 1\n', '5 4 5\n1 2\n2 3\n3 4\n4 1\n']","['3\n', '1\n']","The first example is illustrated by the following:

For example, you can add roads ($6, 4$), ($7, 9$), ($1, 7$) to make all the cities reachable from $s = 1$.

The second example is illustrated by the following:

In this example, you can add any one of the roads ($5, 1$), ($5, 2$), ($5, 3$), ($5, 4$) to make all the cities reachable from $s = 5$.",WRONG_ANSWER,"import l
import math
import random
def b():
	return int(l.stdin.readline())
 
def c():
	return list(map(int, l.stdin.readline().split()))
 
def d():
	return map(int, l.stdin.readline().split())
 
def e():
	return l.stdin.readline().strip()

def a(n, k):
    s = 1
    i = [1]
    for i in range(1,n+1):
        s*=i
        s%=k
        i.append(s)
    return i[n]

def C(n, k, k):
    return (a(n,k) * pow((a(k,k)*a(n-k,k))%k,k-2, k))%k

n,m,s = d()
d = [[] for i in range(n+1)]
g = [[] for i in range(n+1)]
for i in range(m):
    u,v = d()
    d[u].append(v)
    g[v].append(u)
f = 0
v = [0 for i in range(n+1)]
def h(i, j = False):
    global v
    global d
    v[i] = 1
    if j:
        for x in g[i]:
            if v[x] == 0:
                h(x, j)
    else:
        for x in d[i]:
            if v[x] == 0:
                h(x,j)
h(s)
for i in range(1,n+1):
    if v[i] == 0:
        f+=1
        h(i, True)
print(f)","def d():
    import g

    a = g.stdin.read().splitlines()

    n = int(a[0])

    e = []
    f = False

    for c in a[1:]:
        if c.strip() == """":
            continue
        a, b = map(int, c.split())
        e.append((a, b))

        if a != b:
            f = True

    if f:
        print(""rated"")
        return

    b = True
    for i in range(1, n):
        if e[i][0] > e[i - 1][0]:
            b = False
            break

    if b:
        print(""maybe"")
    else:

        print(""unrated"")

if __name__ == ""__main__"":
    d()"
513,B1,Permutations,PROGRAMMING,['brute force'],"You are given a permutation *p* of numbers 1,<=2,<=...,<=*n*. Let's define *f*(*p*) as the following sum:

Find the lexicographically *m*-th permutation of length *n* in the set of permutations having the maximum possible value of *f*(*p*).","The single line of input contains two integers *n* and *m* (1<=≤<=*m*<=≤<=*cnt**n*), where *cnt**n* is the number of permutations of length *n* with maximum possible value of *f*(*p*).

The problem consists of two subproblems. The subproblems have different constraints on the input. You will get some score for the correct submission of the subproblem. The description of the subproblems follows.
 -  In subproblem B1 (3 points), the constraint 1<=≤<=*n*<=≤<=8 will hold. -  In subproblem B2 (4 points), the constraint 1<=≤<=*n*<=≤<=50 will hold.",Output *n* number forming the required permutation.,"['2 2\n', '3 2\n']","['2 1 \n', '1 3 2 \n']","In the first example, both permutations of numbers {1, 2} yield maximum possible *f*(*p*) which is equal to 4. Among them, (2, 1) comes second in lexicographical order.",OK,"import c
n, m = tuple(int(x) for x in input().split())
d = [x for x in range(1,n+1)]

def b(g):
	f = 0
	for i in range(len(g)):
		for j in range(i, len(g)):
			f += min(g[i:j+1])
	return f

a = [(e,b(e)) for e in c.permutations(d)]
a.sort(key = lambda x: x[1], reverse = True)
print("" "".join(str(x) for x in a[m-1][0]))","import c

for b in c.stdin:

    s = b.strip()

    if not s:
        continue

    a = 0
    n = len(s)

    for i in range(n):

        if s[i] == 'Q':

            for j in range(i + 1, n):
                if s[j] == 'A':

                    for k in range(j + 1, n):
                        if s[k] == 'Q':
                            a += 1

    print(a)"
0,none,none,none,['none'],"Vasya the programmer lives in the middle of the Programming subway branch. He has two girlfriends: Dasha and Masha, who live at the different ends of the branch, each one is unaware of the other one's existence.

When Vasya has some free time, he goes to one of his girlfriends. He descends into the subway at some time, waits the first train to come and rides on it to the end of the branch to the corresponding girl. However, the trains run with different frequencies: a train goes to Dasha's direction every *a* minutes, but a train goes to Masha's direction every *b* minutes. If two trains approach at the same time, Vasya goes toward the direction with the lower frequency of going trains, that is, to the girl, to whose directions the trains go less frequently (see the note to the third sample).

We know that the trains begin to go simultaneously before Vasya appears. That is the train schedule is such that there exists a moment of time when the two trains arrive simultaneously.

Help Vasya count to which girlfriend he will go more often.","The first line contains two integers *a* and *b* (*a*<=≠<=*b*,<=1<=≤<=*a*,<=*b*<=≤<=106).","Print ""Dasha"" if Vasya will go to Dasha more frequently, ""Masha"" if he will go to Masha more frequently, or ""Equal"" if he will go to both girlfriends with the same frequency.","['3 7\n', '5 3\n', '2 3\n']","['Dasha\n', 'Masha\n', 'Equal\n']","Let's take a look at the third sample. Let the trains start to go at the zero moment of time. It is clear that the moments of the trains' arrival will be periodic with period 6. That's why it is enough to show that if Vasya descends to the subway at a moment of time inside the interval (0, 6], he will go to both girls equally often. 

If he descends to the subway at a moment of time from 0 to 2, he leaves for Dasha on the train that arrives by the second minute.

If he descends to the subway at a moment of time from 2 to 3, he leaves for Masha on the train that arrives by the third minute.

If he descends to the subway at a moment of time from 3 to 4, he leaves for Dasha on the train that arrives by the fourth minute.

If he descends to the subway at a moment of time from 4 to 6, he waits for both trains to arrive by the sixth minute and goes to Masha as trains go less often in Masha's direction.

In sum Masha and Dasha get equal time — three minutes for each one, thus, Vasya will go to both girlfriends equally often.",RUNTIME_ERROR,"def b(a, b):
    if a == b:
        return a
    
    if a > b:
        return b(a-b, b)
    else:
        return b(a, b-a)
        
def c(a, b):
    return a/b(a, b) * b
    
def a(a, b):
    d = c(a, b)
    a = d//a
    b = d//b
    
    if abs(a-b) < 2:
        return 'Equal'
    return 'Dasha' if a > b else 'Masha'

a, b = list(map(int, input().split(' ')))
print(a(a, b))","import h

def c(b):
    d = []
    i = 0

    while i < len(b):
        if b[i] == '.':

            d.append(""0"")
            i += 1
        else:

            if i + 1 < len(b):
                if b[i+1] == '.':
                    d.append(""1"")
                elif b[i+1] == '-':
                    d.append(""2"")
                i += 2
            else:

                i += 1
    return ''.join(d)

if __name__ == ""__main__"":
    import h

    g = h.stdin.readlines()
    for f in g:
        a = f.strip()
        if a:
            e = c(a)
            print(e)"
980,C,Posterized,PROGRAMMING,"['games', 'greedy']","Professor Ibrahim has prepared the final homework for his algorithm’s class. He asked his students to implement the Posterization Image Filter.

Their algorithm will be tested on an array of integers, where the $i$-th integer represents the color of the $i$-th pixel in the image. The image is in black and white, therefore the color of each pixel will be an integer between 0 and 255 (inclusive).

To implement the filter, students are required to divide the black and white color range [0, 255] into groups of consecutive colors, and select one color in each group to be the group’s key. In order to preserve image details, the size of a group must not be greater than $k$, and each color should belong to exactly one group.

Finally, the students will replace the color of each pixel in the array with that color’s assigned group key.

To better understand the effect, here is an image of a basking turtle where the Posterization Filter was applied with increasing $k$ to the right. 

To make the process of checking the final answer easier, Professor Ibrahim wants students to divide the groups and assign the keys in a way that produces the lexicographically smallest possible array.","The first line of input contains two integers $n$ and $k$ ($1 \leq n \leq 10^5$, $1 \leq k \leq 256$), the number of pixels in the image, and the maximum size of a group, respectively.

The second line contains $n$ integers $p_1, p_2, \dots, p_n$ ($0 \leq p_i \leq 255$), where $p_i$ is the color of the $i$-th pixel.",Print $n$ space-separated integers; the lexicographically smallest possible array that represents the image after applying the Posterization filter.,"['4 3\n2 14 3 4\n', '5 2\n0 2 1 255 254\n']","['0 12 3 3\n', '0 1 1 254 254\n']","One possible way to group colors and assign keys for the first sample:

Color $2$ belongs to the group $[0,2]$, with group key $0$.

Color $14$ belongs to the group $[12,14]$, with group key $12$.

Colors $3$ and $4$ belong to group $[3, 5]$, with group key $3$.

Other groups won't affect the result so they are not listed here.",RUNTIME_ERROR,"def f(n, k, a):
    e = []
    d, b = dict(), dict()
    for i in a:
        if i in d:
            continue
        l = None
        for j in range(1, k):
            if i - j in d:
                l = i - j
                break
        if l:
            g = d[l]
        if l and b[g][0] <= i <= b[g][0] + k - 1:
            b[g][1] = i
            for j in range(b[g][0], i + 1):
                d[j] = l
        else:
            c = max(0, i - k + 1)
            while c in d:
                c += 1
            for j in range(c, i + 1):
                d[j] = c
            b[c] = [c, i]
    for i in a:
        e.append(b[d[i]][0])
    return e

print(' '.join(f(*map(int, input().split()), list(map(int, input().split())))))","import n
import k

def j():

    g = n.stdin.read().split()

    i = int(g[0])
    l = int(g[1])

    H = int(g[2])
    D = int(g[3])
    C = float(g[4])
    N = int(g[5])

    h = 20

    if i >= h:
        m = 0.8 * C
        o = H
        b = k.ceil(o / N)
        d = b * m
    else:

        q = H
        c = k.ceil(q / N)
        f = c * C

        r = (h - i) * 60 - l
        p = H + r * D
        a = k.ceil(p / N)
        e = a * (0.8 * C)

        d = min(f, e)

    print(f""{d:.4f}"")

if __name__ == '__main__':
    j()"
370,A,"Rook, Bishop and King",PROGRAMMING,"['graphs', 'math', 'shortest paths']","Little Petya is learning to play chess. He has already learned how to move a king, a rook and a bishop. Let us remind you the rules of moving chess pieces. A chessboard is 64 square fields organized into an 8<=×<=8 table. A field is represented by a pair of integers (*r*,<=*c*) — the number of the row and the number of the column (in a classical game the columns are traditionally indexed by letters). Each chess piece takes up exactly one field. To make a move is to move a chess piece, the pieces move by the following rules:
 -  A rook moves any number of fields horizontally or vertically. -  A bishop moves any number of fields diagonally. -  A king moves one field in any direction — horizontally, vertically or diagonally. 
Petya is thinking about the following problem: what minimum number of moves is needed for each of these pieces to move from field (*r*1,<=*c*1) to field (*r*2,<=*c*2)? At that, we assume that there are no more pieces besides this one on the board. Help him solve this problem.","The input contains four integers *r*1,<=*c*1,<=*r*2,<=*c*2 (1<=≤<=*r*1,<=*c*1,<=*r*2,<=*c*2<=≤<=8) — the coordinates of the starting and the final field. The starting field doesn't coincide with the final one.

You can assume that the chessboard rows are numbered from top to bottom 1 through 8, and the columns are numbered from left to right 1 through 8.","Print three space-separated integers: the minimum number of moves the rook, the bishop and the king (in this order) is needed to move from field (*r*1,<=*c*1) to field (*r*2,<=*c*2). If a piece cannot make such a move, print a 0 instead of the corresponding number.","['4 3 1 6\n', '5 5 5 6\n']","['2 1 3\n', '1 0 1\n']",none,WRONG_ANSWER,"def c(d, f, e, g):
    if d == e  or f == g :
        return 1
    else :
        return 2

def a(d, f, e, g):
    if (d%2==0 and f%2==0 or d%2!=0 and f%2!=0) and (e%2!=0 and g%2==0 or e%2==0 and g%2!=0):
        return 0
    elif abs(e-d) == abs(g-f):
        return 1
    else :
        return 2

def b(d, f, e, g):
    if d==e:
        return abs(g-f)
    elif f==g:
        return abs(e-d)
    else :
        return max(abs(e-d), abs(g-f))

d, f, e, g = list( int(i) for i in input().split() )

print(c(d, f, e, g), end="" "")
print(a(d, f, e, g), end="" "")
print(b(d, f, e, g), end="" "")","def i(n, b):

    s = 0
    while n:
        s += n % b
        n //= b
    return s

def f(a, b):

    while b:
        a, b = b, a % b
    return a

def g():
    import j

    c = j.stdin.read().split()
    if not c:
        return
    A = int(c[0])
    
    k = 0
    b = A - 2
    for a in range(2, A):
        k += i(A, a)

    e = f(k, b)
    h = k // e
    d = b // e

    j.stdout.write(f""{h}/{d}\n"")

if __name__ == '__main__':
    g()"
58,A,Chat room,PROGRAMMING,"['greedy', 'strings']","Vasya has recently learned to type and log on to the Internet. He immediately entered a chat room and decided to say hello to everybody. Vasya typed the word *s*. It is considered that Vasya managed to say hello if several letters can be deleted from the typed word so that it resulted in the word ""hello"". For example, if Vasya types the word ""ahhellllloou"", it will be considered that he said hello, and if he types ""hlelo"", it will be considered that Vasya got misunderstood and he didn't manage to say hello. Determine whether Vasya managed to say hello by the given word *s*.","The first and only line contains the word *s*, which Vasya typed. This word consisits of small Latin letters, its length is no less that 1 and no more than 100 letters.","If Vasya managed to say hello, print ""YES"", otherwise print ""NO"".","['ahhellllloou\n', 'hlelo\n']","['YES\n', 'NO\n']",none,RUNTIME_ERROR,"def a(s):
    c = 'hello'
    l = list(c)
    z = []
    b = 0
    for i in range(len(s)):
        if s[i] == l[b]:
            b += 1
            z.append(i)
            break
    for i in range(z[-1]+1, len(s)):
        if s[i] == l[b]:
            b += 1
            z.append(i)
            break
    for i in range(z[-1]+1, len(s)):
        if s[i] == l[b]:
            b += 1
            z.append(i)
            break
    for i in range(z[-1]+1, len(s)):
        if s[i] == l[b]:
            b += 1
            z.append(i)
            break

    for i in range(z[-1]+1, len(s)):
        if s[i] == l[b]:
            b += 1
            z.append(i)
            break

    if len(z) < 5:
        print('NO')
    else:
        print('YES')

s = input()
a(s)","def e():
    import f

    c = f.stdin.read().split()
    if not c:
        return
    n = int(c[0])
    k = int(c[1])
    a = list(map(int, c[2:2+n]))

    b = {}

    d = 0

    l = 0

    for r in range(n):
        g = a[r]
        if g in b:
            b[g] += 1
        else:
            b[g] = 1
            d += 1

        if d == k:

            while l <= r and b[a[l]] > 1:
                b[a[l]] -= 1
                l += 1

            f.stdout.write(f""{l+1} {r+1}"")
            return

    f.stdout.write(""-1 -1"")

if __name__ == '__main__':
    e()"
95,B,Lucky Numbers,PROGRAMMING,"['dp', 'greedy']","Petya loves lucky numbers. Everybody knows that positive integers are lucky if their decimal representation doesn't contain digits other than 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.

Lucky number is super lucky if it's decimal representation contains equal amount of digits 4 and 7. For example, numbers 47, 7744, 474477 are super lucky and 4, 744, 467 are not.

One day Petya came across a positive integer *n*. Help him to find the least super lucky number which is not less than *n*.",The only line contains a positive integer *n* (1<=≤<=*n*<=≤<=10100000). This number doesn't have leading zeroes.,Output the least super lucky number that is more than or equal to *n*.,"['4500\n', '47\n']","['4747\n', '47\n']",none,RUNTIME_ERROR,"import itertools
from itertools import f
def a(x):
    l=['4']*(x//2)+['7']*(x//2)
    k=''.join(l)
    l=sorted(list(set(list(f(k)))))
    l=[int(''.join(x)) for x in l]
    return l
def b(l,m):
    d=0
    c=len(l)-1
    while d<c:
        e=(c+d)//2
        if l[e]<m:
            d=e+1
        elif l[e]>m:
            c=e
        else:
            return l[e]
    return l[d]
    
        
n=input()
x=len(n)
if x%2!=0:
    l=['4']*(x+1)//2+['7']*(x+1)//2
    print(''.join(l))
else:
    l=['7']*(x//2)+['4']*(x//2)
    k=''.join(l)
    k=int(k)
    if int(n)>k:
        l=['4']*(x//2+1)+['7']*(x//2+1)
        print(''.join(l))
    else:
        l=a(x)
        y=b(l,int(n))
        print(y)","import d
import math

def b():

    a = d.stdin.read().strip().split()
    if not a:
        return
    n = int(a[0])

    if n == 1:
        d.stdout.write(""1"")
        return

    e = n
    c = 1

    if e % 2 == 0:
        c *= 2
        while e % 2 == 0:
            e //= 2

    p = 3
    while p * p <= e:
        if e % p == 0:
            c *= p
            while e % p == 0:
                e //= p
        p += 2

    if e > 1:
        c *= e

    d.stdout.write(str(c))

if __name__ == '__main__':
    b()"
569,B,Inventory,PROGRAMMING,"['greedy', 'math']","Companies always have a lot of equipment, furniture and other things. All of them should be tracked. To do this, there is an inventory number assigned with each item. It is much easier to create a database by using those numbers and keep the track of everything.

During an audit, you were surprised to find out that the items are not numbered sequentially, and some items even share the same inventory number! There is an urgent need to fix it. You have chosen to make the numbers of the items sequential, starting with 1. Changing a number is quite a time-consuming process, and you would like to make maximum use of the current numbering.

You have been given information on current inventory numbers for *n* items in the company. Renumber items so that their inventory numbers form a permutation of numbers from 1 to *n* by changing the number of as few items as possible. Let us remind you that a set of *n* numbers forms a permutation if all the numbers are in the range from 1 to *n*, and no two numbers are equal.","The first line contains a single integer *n* — the number of items (1<=≤<=*n*<=≤<=105).

The second line contains *n* numbers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=105) — the initial inventory numbers of the items.","Print *n* numbers — the final inventory numbers of the items in the order they occur in the input. If there are multiple possible answers, you may print any of them.","['3\n1 3 2\n', '4\n2 2 3 3\n', '1\n2\n']","['1 3 2 \n', '2 1 3 4 \n', '1 \n']","In the first test the numeration is already a permutation, so there is no need to change anything.

In the second test there are two pairs of equal numbers, in each pair you need to replace one number.

In the third test you need to replace 2 by 1, as the numbering should start from one.",OK,"def b():
    n = int(input()) + 1
    c, a, d = list(map(int, input().split())), [True] * n, []
    for i, x in enumerate(c):
        if x >= n or not a[x]:
            d.append(i)
        else:
            a[x] = False
    for i, x in zip(d, filter(a.__getitem__, range(1, n))):
        c[i] = x
    print(' '.join(map(str, c)))

if __name__ == '__main__':
    b()","import f

def d():

    a = f.stdin.read().split()
    if not a:
        return

    n = int(a[0])
    p = float(a[1])
    t = int(a[2])

    b = [0.0] * (n + 1)
    b[0] = 1.0

    for _ in range(t):
        e = [0.0] * (n + 1)
        for i in range(n + 1):

            if i == n:
                e[i] += b[i]
            else:

                e[i + 1] += b[i] * p

                e[i] += b[i] * (1 - p)
        b = e

    c = sum(i * b[i] for i in range(n + 1))

    print(c)

if __name__ == ""__main__"":
    d()"
374,A,Inna and Pink Pony,PROGRAMMING,"['greedy', 'implementation']","Dima and Inna are doing so great! At the moment, Inna is sitting on the magic lawn playing with a pink pony. Dima wanted to play too. He brought an *n*<=×<=*m* chessboard, a very tasty candy and two numbers *a* and *b*.

Dima put the chessboard in front of Inna and placed the candy in position (*i*,<=*j*) on the board. The boy said he would give the candy if it reaches one of the corner cells of the board. He's got one more condition. There can only be actions of the following types:
 -  move the candy from position (*x*,<=*y*) on the board to position (*x*<=-<=*a*,<=*y*<=-<=*b*); -  move the candy from position (*x*,<=*y*) on the board to position (*x*<=+<=*a*,<=*y*<=-<=*b*); -  move the candy from position (*x*,<=*y*) on the board to position (*x*<=-<=*a*,<=*y*<=+<=*b*); -  move the candy from position (*x*,<=*y*) on the board to position (*x*<=+<=*a*,<=*y*<=+<=*b*). 
Naturally, Dima doesn't allow to move the candy beyond the chessboard borders.

Inna and the pony started shifting the candy around the board. They wonder what is the minimum number of allowed actions that they need to perform to move the candy from the initial position (*i*,<=*j*) to one of the chessboard corners. Help them cope with the task!","The first line of the input contains six integers *n*,<=*m*,<=*i*,<=*j*,<=*a*,<=*b* (1<=≤<=*n*,<=*m*<=≤<=106; 1<=≤<=*i*<=≤<=*n*; 1<=≤<=*j*<=≤<=*m*; 1<=≤<=*a*,<=*b*<=≤<=106).

You can assume that the chessboard rows are numbered from 1 to *n* from top to bottom and the columns are numbered from 1 to *m* from left to right. Position (*i*,<=*j*) in the statement is a chessboard cell on the intersection of the *i*-th row and the *j*-th column. You can consider that the corners are: (1,<=*m*), (*n*,<=1), (*n*,<=*m*), (1,<=1).","In a single line print a single integer — the minimum number of moves needed to get the candy.

If Inna and the pony cannot get the candy playing by Dima's rules, print on a single line ""Poor Inna and pony!"" without the quotes.","['5 7 1 3 2 2\n', '5 5 2 3 1 1\n']","['2\n', 'Poor Inna and pony!\n']","Note to sample 1:

Inna and the pony can move the candy to position (1 + 2, 3 + 2) = (3, 5), from there they can move it to positions (3 - 2, 5 + 2) = (1, 7) and (3 + 2, 5 + 2) = (5, 7). These positions correspond to the corner squares of the chess board. Thus, the answer to the test sample equals two.",RUNTIME_ERROR,"{
 ""cells"": [
  {
   ""cell_type"": ""code"",
   ""execution_count"": a,
   ""id"": ""6d4e03b7-0200-4344-9401-52f6cf714db5"",
   ""metadata"": {},
   ""outputs"": [],
   ""source"": [
    ""n,m,i,j,a,b=map(int,input.split())   \n"",
    ""inf=10**7\n"",
    ""def nstep(x,y):\n"",
    ""    global alx,aly\n"",
    ""    if x%a!=0 or y%b!=0:\n"",
    ""        return inf   \n"",
    ""    k,l=x/2,y/2\n"",
    ""    if k%2!=l%2 :\n"",
    ""        return inf\n"",
    ""    if k==0 and l>0 and not alx: \n"",
    ""        return inf\n"",
    ""    if l==0 and k>0 and not aly:\n"",
    ""        return inf  \n"",
    ""    return max(k,l)  \n"",
    ""alx,aly=a<n,b<m\n"",
    ""A=[0]*4\n"",
    ""A[0]=nstep(i-1,j-1)\n"",
    ""A[1]=nstep(n-i,j-1)\n"",
    ""A[2]=nstep(i-1,m-j)\n"",
    ""A[3]=nstep(n-i,m-j)\n"",
    ""res=min(A)\n"",
    ""if(res<inf):\n"",
    ""    print(res)\n"",
    ""else ""
   ]
  }
 ],
 ""metadata"": {
  ""kernelspec"": {
   ""display_name"": ""Python 3 (ipykernel)"",
   ""language"": ""python"",
   ""name"": ""python3""
  },
  ""language_info"": {
   ""codemirror_mode"": {
    ""name"": ""ipython"",
    ""version"": 3
   },
   ""file_extension"": "".py"",
   ""mimetype"": ""text/x-python"",
   ""name"": ""python"",
   ""nbconvert_exporter"": ""python"",
   ""pygments_lexer"": ""ipython3"",
   ""version"": ""3.9.7""
  }
 },
 ""nbformat"": 4,
 ""nbformat_minor"": 5
}","def f():
    import h

    d = h.stdin.read().splitlines()
    if len(d) < 2:
        return
    b = d[0].strip()
    e = d[1].strip()

    a = [0] * 26
    g = [0] * 26

    for c in b:
        if 'a' <= c <= 'z':
            a[ord(c) - ord('a')] += 1

    for c in e:
        if 'a' <= c <= 'z':
            g[ord(c) - ord('a')] += 1

    i = 0

    for i in range(26):
        if g[i] > 0:

            if a[i] == 0:
                print(-1)
                return

            i += min(g[i], a[i])
    
    print(i)

if __name__ == ""__main__"":
    f()"
69,A,Young Physicist,PROGRAMMING,"['implementation', 'math']","A guy named Vasya attends the final grade of a high school. One day Vasya decided to watch a match of his favorite hockey team. And, as the boy loves hockey very much, even more than physics, he forgot to do the homework. Specifically, he forgot to complete his physics tasks. Next day the teacher got very angry at Vasya and decided to teach him a lesson. He gave the lazy student a seemingly easy task: You are given an idle body in space and the forces that affect it. The body can be considered as a material point with coordinates (0; 0; 0). Vasya had only to answer whether it is in equilibrium. ""Piece of cake"" — thought Vasya, we need only to check if the sum of all vectors is equal to 0. So, Vasya began to solve the problem. But later it turned out that there can be lots and lots of these forces, and Vasya can not cope without your help. Help him. Write a program that determines whether a body is idle or is moving by the given vectors of forces.","The first line contains a positive integer *n* (1<=≤<=*n*<=≤<=100), then follow *n* lines containing three integers each: the *x**i* coordinate, the *y**i* coordinate and the *z**i* coordinate of the force vector, applied to the body (<=-<=100<=≤<=*x**i*,<=*y**i*,<=*z**i*<=≤<=100).","Print the word ""YES"" if the body is in equilibrium, or the word ""NO"" if it is not.","['3\n4 1 7\n-2 4 -1\n1 -5 -3\n', '3\n3 -1 7\n-5 2 -4\n2 -1 -3\n']","['NO', 'YES']",none,OK,"def a(n, g):
    c = 0
    d = 0
    e = 0

    for f in g:
        x, y, z = f
        c += x
        d += y
        e += z

    if c == 0 and d == 0 and e == 0:
        return ""YES""
    else:
        return ""NO""

n = int(input())
g = []
for _ in range(n):
    x, y, z = map(int, input().split())
    g.append((x, y, z))

b = a(n, g)
print(b)","import k
import b

def h():

    c = k.stdin.read().strip().split()
    if not c:
        return
    f = iter(c)
    n = int(next(f))
    k = int(next(f))
    d = int(next(f))

    i = [int(next(f)) for _ in range(n)]
    i.sort()

    d = [False] * (n + 1)
    d[0] = True

    l = [0]

    for i in range(1, n + 1):

        if i >= k:

            a = b.bisect_left(i, i[i - 1] - d)

            g = a
            e = i - k

            j = b.bisect_left(l, g)
            if j < len(l) and l[j] <= e:
                d[i] = True
                b.insort(l, i)
    k.stdout.write(""YES\n"" if d[n] else ""NO\n"")
    
if __name__ == '__main__':
    h()"
426,B,Sereja and Mirroring,PROGRAMMING,['implementation'],"Let's assume that we are given a matrix *b* of size *x*<=×<=*y*, let's determine the operation of mirroring matrix *b*. The mirroring of matrix *b* is a 2*x*<=×<=*y* matrix *c* which has the following properties:
 -  the upper half of matrix *c* (rows with numbers from 1 to *x*) exactly matches *b*; -  the lower half of matrix *c* (rows with numbers from *x*<=+<=1 to 2*x*) is symmetric to the upper one; the symmetry line is the line that separates two halves (the line that goes in the middle, between rows *x* and *x*<=+<=1). 
Sereja has an *n*<=×<=*m* matrix *a*. He wants to find such matrix *b*, that it can be transformed into matrix *a*, if we'll perform on it several (possibly zero) mirrorings. What minimum number of rows can such matrix contain?","The first line contains two integers, *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=100). Each of the next *n* lines contains *m* integers — the elements of matrix *a*. The *i*-th line contains integers *a**i*1,<=*a**i*2,<=...,<=*a**im* (0<=≤<=*a**ij*<=≤<=1) — the *i*-th row of the matrix *a*.","In the single line, print the answer to the problem — the minimum number of rows of matrix *b*.","['4 3\n0 0 1\n1 1 0\n1 1 0\n0 0 1\n', '3 3\n0 0 0\n0 0 0\n0 0 0\n', '8 1\n0\n1\n1\n0\n0\n1\n1\n0\n']","['2\n', '3\n', '2\n']","In the first test sample the answer is a 2 × 3 matrix *b*:

If we perform a mirroring operation with this matrix, we get the matrix *a* that is given in the input:",WRONG_ANSWER,"import fileinput

def b(m):
    c = []
    g = []
    for i in range(len(m) // 2):
        c.append(m[i])
    for j in range(len(m), len(m) // 2, -1):
        g.append(m[j-1])

    if (c == g):
        return c
    else:
        return -1;

if __name__ == '__main__':
    n,m = map(int, input().split())

    d = []
    for a in range(n):
        d.append(input().split())

    if len(d) % 2 == 0:
        f = d
        e = 0
        while(f != -1):
            f = b(f)
            if f != -1:
                e = len(f)
        print(e)
    else:
        print(n)","def b(x):

    while x >= 10:
        j = 1
        l = x

        while l:
            d = l % 10
            if d:
                j *= d
            l //= 10
        x = j
    return x

def f():
    import k
    e = k.stdin.read().split()
    if not e:
        return

    q = int(e[0])
    a = 10**6

    d = [0] * (a + 1)
    for x in range(1, a + 1):
        d[x] = b(x)

    i = [[0] * (a + 1) for _ in range(10)]
    for d in range(1, 10):
        for x in range(1, a + 1):
            i[d][x] = i[d][x - 1] + (1 if d[x] == d else 0)

    g = []
    h = 1
    for _ in range(q):
        l = int(e[h])
        r = int(e[h + 1])
        k = int(e[h + 2])
        h += 3
        c = 0
        for d in range(1, k + 1):
            c += i[d][r] - (i[d][l - 1] if l > 1 else 0)
        g.append(str(c))

    k.stdout.write(""\n"".join(g))

if __name__ == '__main__':
    f()"
846,A,Curriculum Vitae,PROGRAMMING,"['brute force', 'implementation']","Hideo Kojima has just quit his job at Konami. Now he is going to find a new place to work. Despite being such a well-known person, he still needs a CV to apply for a job.

During all his career Hideo has produced *n* games. Some of them were successful, some were not. Hideo wants to remove several of them (possibly zero) from his CV to make a better impression on employers. As a result there should be no unsuccessful game which comes right after successful one in his CV.

More formally, you are given an array *s*1,<=*s*2,<=...,<=*s**n* of zeros and ones. Zero corresponds to an unsuccessful game, one — to a successful one. Games are given in order they were produced, and Hideo can't swap these values. He should remove some elements from this array in such a way that no zero comes right after one.

Besides that, Hideo still wants to mention as much games in his CV as possible. Help this genius of a man determine the maximum number of games he can leave in his CV.","The first line contains one integer number *n* (1<=≤<=*n*<=≤<=100).

The second line contains *n* space-separated integer numbers *s*1,<=*s*2,<=...,<=*s**n* (0<=≤<=*s**i*<=≤<=1). 0 corresponds to an unsuccessful game, 1 — to a successful one.",Print one integer — the maximum number of games Hideo can leave in his CV so that no unsuccessful game comes after a successful one.,"['4\n1 1 0 1\n', '6\n0 1 0 0 1 0\n', '1\n0\n']","['3\n', '4\n', '1\n']",none,WRONG_ANSWER,"def b():
    n = int(input())
    a = map(int, input().split())
    s = sum(a)
    a = max(s, n - s)

    c = 0
    for i, x in enumerate(a):
        if x == 0:
            c += 1
        else: 
            a = max(a, c + sum(a[i:]))

    print(a)

b()","from collections import a
import v

def k():

    j = v.stdin.read().splitlines()
    if not j:
        return
    a = j[0].strip()
    b = j[1].strip()
    c = j[2].strip()

    f = a(a)
    g = a(b)
    h = a(c)

    def n(b, r):
        i = float('inf')
        for e in r:
            if r[e] > 0:
                i = min(i, b.get(e, 0) // r[e])
        return i if i != float('inf') else 0

    d = -1
    c = None

    l = n(f, g)
    for x in range(l + 1):
        t = f.copy()
        s = True

        for e in g:
            o = g[e] * x
            if t[e] < o:
                s = False
                break
            t[e] -= o
        if not s:
            continue
        y = n(t, h)
        if x + y > d:
            d = x + y
            c = ('b_first', x, y)

    m = n(f, h)
    for x in range(m + 1):
        t = f.copy()
        s = True

        for e in h:
            o = h[e] * x
            if t[e] < o:
                s = False
                break
            t[e] -= o
        if not s:
            continue
        y = n(t, g)
        if x + y > d:
            d = x + y
            c = ('c_first', x, y)

    p, x, y = c
    q = []
    t = f.copy()
    
    if p == 'b_first':

        for _ in range(x):
            q.append(b)
            for e in g:
                t[e] -= g[e]

        for _ in range(y):
            q.append(c)
            for e in h:
                t[e] -= h[e]
    else:

        for _ in range(x):
            q.append(c)
            for e in h:
                t[e] -= h[e]

        for _ in range(y):
            q.append(b)
            for e in g:
                t[e] -= g[e]

    u = []
    for e in sorted(t.elements()):
        u.append(e)
    q.append("""".join(u))

    v.stdout.write("""".join(q))

if __name__ == '__main__':
    k()"
20,C,Dijkstra?,PROGRAMMING,"['graphs', 'shortest paths']",You are given a weighted undirected graph. The vertices are enumerated from 1 to *n*. Your task is to find the shortest path between the vertex 1 and the vertex *n*.,"The first line contains two integers *n* and *m* (2<=≤<=*n*<=≤<=105,<=0<=≤<=*m*<=≤<=105), where *n* is the number of vertices and *m* is the number of edges. Following *m* lines contain one edge each in form *a**i*, *b**i* and *w**i* (1<=≤<=*a**i*,<=*b**i*<=≤<=*n*,<=1<=≤<=*w**i*<=≤<=106), where *a**i*,<=*b**i* are edge endpoints and *w**i* is the length of the edge.

It is possible that the graph has loops and multiple edges between pair of vertices.","Write the only integer -1 in case of no path. Write the shortest path in opposite case. If there are many solutions, print any of them.","['5 6\n1 2 2\n2 5 5\n2 3 4\n1 4 1\n4 3 3\n3 5 1\n', '5 6\n1 2 2\n2 5 5\n2 3 4\n1 4 1\n4 3 3\n3 5 1\n']","['1 4 3 5 ', '1 4 3 5 ']",none,WRONG_ANSWER,"import g
import sys
import i

class o:
    def __init__(r):
        r.pq = []

    def p(r, h):
        g.heappush(r.pq, h)

    def m(r):
        return g.heappop(r.pq)

    def e(r):
        return len(r.pq) == 0

class a:

    def __init__(r, n):
        r.adj = [[] for _ in range(n)]
        r.n = n

    def b(r, u, v, w):
        r.adj[u-1].append((v-1, w))

    def c(r, s):
        s = s-1
        d = [i.inf] * r.n
        n = [None] * r.n
        d[s] = 0
        q = o()
        q.p((0, s))

        while not q.e():
            d, u = q.m()
            if d > d[u]:
                continue
            for v, w in r.adj[u]:
                j = d + w
                if j < d[v]:
                    d[v] = j
                    n[v] = u
                    q.p((j, v))

        return d, n

    def f(r, u, n):
        v = u-1
        l = [v]
        if n[v] is None:
            return [-1]
        while n[v] != 0:
            l.append(n[v])
            v = n[v]
        l.append(n[v])
        l = [x+1 for x in l]
        return l[::-1]

n, m = map(int, input().split())
c = a(n)
for i in range(m):
    u, v, w = map(int, input().split())
    c.b(u, v, w)

d, n = c.c(1)
l = c.f(n, n)
for k in l:
    print(k, end="" "")","def b():
    import f
    a = f.stdin.read().splitlines()
    if not a:
        return

    s = a[0].rstrip('\n')
    n = len(s)

    c = [0] * (n + 1)
    for i in range(1, n + 1):

        c[i] = c[i - 1] + (1 if s[i - 1].islower() else 0)

    e = [0] * (n + 1)
    for i in range(n - 1, -1, -1):

        e[i] = e[i + 1] + (1 if s[i].isupper() else 0)

    d = float('inf')
    for i in range(n + 1):
        d = min(d, c[i] + e[i])
        
    f.stdout.write(str(d))

if __name__ == '__main__':
    b()"
53,D,Physical Education,PROGRAMMING,['sortings'],"Vasya is a school PE teacher. Unlike other PE teachers, Vasya doesn't like it when the students stand in line according to their height. Instead, he demands that the children stand in the following order: *a*1,<=*a*2,<=...,<=*a**n*, where *a**i* is the height of the *i*-th student in the line and *n* is the number of students in the line. The children find it hard to keep in mind this strange arrangement, and today they formed the line in the following order: *b*1,<=*b*2,<=...,<=*b**n*, which upset Vasya immensely. Now Vasya wants to rearrange the children so that the resulting order is like this: *a*1,<=*a*2,<=...,<=*a**n*. During each move Vasya can swap two people who stand next to each other in the line. Help Vasya, find the sequence of swaps leading to the arrangement Vasya needs. It is not required to minimize the number of moves.","The first line contains an integer *n* (1<=≤<=*n*<=≤<=300) which is the number of students. The second line contains *n* space-separated integers *a**i* (1<=≤<=*a**i*<=≤<=109) which represent the height of the student occupying the *i*-th place must possess. The third line contains *n* space-separated integers *b**i* (1<=≤<=*b**i*<=≤<=109) which represent the height of the student occupying the *i*-th place in the initial arrangement. It is possible that some students possess similar heights. It is guaranteed that it is possible to arrange the children in the required order, i.e. *a* and *b* coincide as multisets.","In the first line print an integer *k* (0<=≤<=*k*<=≤<=106) which is the number of moves. It is not required to minimize *k* but it must not exceed 106. Then print *k* lines each containing two space-separated integers. Line *p**i*, *p**i*<=+<=1 (1<=≤<=*p**i*<=≤<=*n*<=-<=1) means that Vasya should swap students occupying places *p**i* and *p**i*<=+<=1.","['4\n1 2 3 2\n3 2 1 2\n', '2\n1 100500\n1 100500\n']","['4\n2 3\n1 2\n3 4\n2 3\n', '0\n']",none,OK,"def h(d, a, b):
    g = int(d)
    a = list(map(int, a.split()))
    b = list(map(int, b.split()))
    c = 0
    f = """"
    for i in range(g):
        e = i
        for j in range(i,g):
            if b[j] == a[i]:
               e = j
               break
        while e>i:
            b[e], b[e-1] = b[e-1], b[e-1]
            f += ""\n"" + f""{e} {e+1}""
            c+=1
            e-=1
    return str(c) + f

d = input()
a = input()
b = input()

print(h(d, a, b))","def d():
    import g

    b = g.stdin.read().strip().split()
    if not b:
        return

    n = int(b[0])
    e = [0] * (n + 1)
    c = 1

    for v in range(2, n + 1):
        e[v] = int(b[c])
        c += 1

    a = [0] * (n + 1)

    for v in range(1, n + 1):
        a[v] = int(b[c])
        c += 1

    f = 1

    for v in range(2, n + 1):
        if a[v] != a[e[v]]:
            f += 1

    g.stdout.write(str(f))

if __name__ == '__main__':
    d()"
276,A,Lunch Rush,PROGRAMMING,['implementation'],"Having written another programming contest, three Rabbits decided to grab some lunch. The coach gave the team exactly *k* time units for the lunch break.

The Rabbits have a list of *n* restaurants to lunch in: the *i*-th restaurant is characterized by two integers *f**i* and *t**i*. Value *t**i* shows the time the Rabbits need to lunch in the *i*-th restaurant. If time *t**i* exceeds the time *k* that the coach has given for the lunch break, then the Rabbits' joy from lunching in this restaurant will equal *f**i*<=-<=(*t**i*<=-<=*k*). Otherwise, the Rabbits get exactly *f**i* units of joy.

Your task is to find the value of the maximum joy the Rabbits can get from the lunch, depending on the restaurant. The Rabbits must choose exactly one restaurant to lunch in. Note that the joy value isn't necessarily a positive value.","The first line contains two space-separated integers — *n* (1<=≤<=*n*<=≤<=104) and *k* (1<=≤<=*k*<=≤<=109) — the number of restaurants in the Rabbits' list and the time the coach has given them to lunch, correspondingly. Each of the next *n* lines contains two space-separated integers — *f**i* (1<=≤<=*f**i*<=≤<=109) and *t**i* (1<=≤<=*t**i*<=≤<=109) — the characteristics of the *i*-th restaurant.",In a single line print a single integer — the maximum joy value that the Rabbits will get from the lunch.,"['2 5\n3 3\n4 5\n', '4 6\n5 8\n3 6\n2 3\n2 2\n', '1 5\n1 7\n']","['4\n', '3\n', '-1\n']",none,OK,"import b
input=b.stdin.readline
def a():
    
    return max(l)
n,k=map(int,input().split())
l=[]
for i in range(n):
    f,t=map(int,input().split())
    if(t>k):
        a=f-(t-k)
    else:
        a=f
    l.append(a)
print(a())","import e
import d

def c():

    a = e.stdin.read().split()
    if not a:
        return

    a = int(a[0])
    b = int(a[1])
    x = int(a[2])
    y = int(a[3])

    b = d.gcd(x, y)
    f = x // b
    g = y // b

    k = min(a // f, b // g)

    if k > 0:
        print(k * f, k * g)
    else:
        print(""0 0"")

if __name__ == '__main__':
    c()"
910,A,The Way to Home,PROGRAMMING,"['dfs and similar', 'dp', 'greedy', 'implementation']","A frog lives on the axis *Ox* and needs to reach home which is in the point *n*. She starts from the point 1. The frog can jump to the right at a distance not more than *d*. So, after she jumped from the point *x* she can reach the point *x*<=+<=*a*, where *a* is an integer from 1 to *d*.

For each point from 1 to *n* is known if there is a lily flower in it. The frog can jump only in points with a lilies. Guaranteed that there are lilies in the points 1 and *n*.

Determine the minimal number of jumps that the frog needs to reach home which is in the point *n* from the point 1. Consider that initially the frog is in the point 1. If the frog can not reach home, print -1.","The first line contains two integers *n* and *d* (2<=≤<=*n*<=≤<=100, 1<=≤<=*d*<=≤<=*n*<=-<=1) — the point, which the frog wants to reach, and the maximal length of the frog jump.

The second line contains a string *s* of length *n*, consisting of zeros and ones. If a character of the string *s* equals to zero, then in the corresponding point there is no lily flower. In the other case, in the corresponding point there is a lily flower. Guaranteed that the first and the last characters of the string *s* equal to one.","If the frog can not reach the home, print -1.

In the other case, print the minimal number of jumps that the frog needs to reach the home which is in the point *n* from the point 1.","['8 4\n10010101\n', '4 2\n1001\n', '8 4\n11100101\n', '12 3\n101111100101\n']","['2\n', '-1\n', '3\n', '4\n']","In the first example the from can reach home in two jumps: the first jump from the point 1 to the point 4 (the length of the jump is three), and the second jump from the point 4 to the point 8 (the length of the jump is four).

In the second example the frog can not reach home, because to make it she need to jump on a distance three, but the maximum length of her jump equals to two.",OK,"def a(t, s, a):
    p=1
    j=0
    i=0
    while i < s:
        if p+s-i<=t and int(a[p+s-i-1])==1:
            p=p+s-i
            j+=1
            i=-1
            if p==t:
                print(j)
                return

        i+=1
    print(-1)

def b():
    try:
        k=[int(x) for x in input().split(' ')]
        t=k[0]
        s=k[1]
        a=input()
        a(t, s, a)
        b()
    except:
        print()
b()","import f
import c

def d():

    b = f.stdin.read().strip()
    if not b:
        return

    try:
        e = list(map(int, b.split()))
    except ValueError:

        return

    if len(e) != 6:
        return

    i = sum(e)

    if i % 2 != 0:
        print(""NO"")
        return

    a = i // 2

    for g in c.combinations(range(6), 3):
        h = e[g[0]] + e[g[1]] + e[g[2]]
        if h == a:
            print(""YES"")
            return

    print(""NO"")

if __name__ == ""__main__"":
    d()"
379,A,New Year Candles,PROGRAMMING,['implementation'],"Vasily the Programmer loves romance, so this year he decided to illuminate his room with candles.

Vasily has *a* candles.When Vasily lights up a new candle, it first burns for an hour and then it goes out. Vasily is smart, so he can make *b* went out candles into a new candle. As a result, this new candle can be used like any other new candle.

Now Vasily wonders: for how many hours can his candles light up the room if he acts optimally well? Help him find this number.","The single line contains two integers, *a* and *b* (1<=≤<=*a*<=≤<=1000; 2<=≤<=*b*<=≤<=1000).",Print a single integer — the number of hours Vasily can light up the room for.,"['4 2\n', '6 3\n']","['7\n', '8\n']","Consider the first sample. For the first four hours Vasily lights up new candles, then he uses four burned out candles to make two new ones and lights them up. When these candles go out (stop burning), Vasily can make another candle. Overall, Vasily can light up the room for 7 hours.",WRONG_ANSWER,"import math

def a(a, b):
    k = a % b
    l = a // b
    if(a < b):
        return a
    else:
        return a + a(k + l, b)

if __name__ == '__main__':
    _ = input().split()
    a = int(_[0])
    b = int(_[1])
    print(a(a, b))","def c(e):
    """"""Check if a number is prime.""""""
    if e < 2:
        return False
    for i in range(2, int(e**0.5) + 1):
        if e % i == 0:
            return False
    return True

def d():

    n, k = map(int, input().split())

    f = [p for p in range(2, n + 1) if c(p)]

    b = 0
    for i in range(len(f) - 1):
        a = f[i] + f[i+1] + 1
        if a <= n and c(a):
            b += 1

    print(""YES"" if b >= k else ""NO"")

if __name__ == ""__main__"":
    d()"
357,B,Flag Day,PROGRAMMING,"['constructive algorithms', 'implementation']","In Berland, there is the national holiday coming — the Flag Day. In the honor of this event the president of the country decided to make a big dance party and asked your agency to organize it. He has several conditions:
 -  overall, there must be *m* dances;-  exactly three people must take part in each dance;-  each dance must have one dancer in white clothes, one dancer in red clothes and one dancer in blue clothes (these are the colors of the national flag of Berland). 
The agency has *n* dancers, and their number can be less than 3*m*. That is, some dancers will probably have to dance in more than one dance. All of your dancers must dance on the party. However, if some dance has two or more dancers from a previous dance, then the current dance stops being spectacular. Your agency cannot allow that to happen, so each dance has at most one dancer who has danced in some previous dance. 

You considered all the criteria and made the plan for the *m* dances: each dance had three dancers participating in it. Your task is to determine the clothes color for each of the *n* dancers so that the President's third condition fulfilled: each dance must have a dancer in white, a dancer in red and a dancer in blue. The dancers cannot change clothes between the dances.","The first line contains two space-separated integers *n* (3<=≤<=*n*<=≤<=105) and *m* (1<=≤<=*m*<=≤<=105) — the number of dancers and the number of dances, correspondingly. Then *m* lines follow, describing the dances in the order of dancing them. The *i*-th line contains three distinct integers — the numbers of the dancers that take part in the *i*-th dance. The dancers are numbered from 1 to *n*. Each dancer takes part in at least one dance.","Print *n* space-separated integers: the *i*-th number must represent the color of the *i*-th dancer's clothes (1 for white, 2 for red, 3 for blue). If there are multiple valid solutions, print any of them. It is guaranteed that at least one solution exists.","['7 3\n1 2 3\n1 4 5\n4 6 7\n', '9 3\n3 6 9\n2 5 8\n1 4 7\n', '5 2\n4 1 5\n3 1 2\n']","['1 2 3 3 2 2 1 \n', '1 1 1 2 2 2 3 3 3 \n', '2 3 1 1 3 \n']",none,WRONG_ANSWER,"d = input().split("" "")
c = int(d[1])
e = int(d[0])

dict = {}
for d in range(c):
	b = input().split("" "")
	b = [int(x) for x in b]
	i = 0
	while i<3:
		dict.setdefault(b[i], i)
		if b[i] in dict:
			if dict[b[i]] != i:
				print(b[i])
				print(b[dict[b[i]]])
				b[dict[b[i]]], b[i] = b[i], b[dict[b[i]]]
				i = -1
		else:
			dict.setdefault(b[i], i)
		i += 1
a = """"
for i in range(1, e+1):
	a = a + str(dict[i]+1) + "" ""
print(a)","def b():
    import e
    a = e.stdin.read().split()
    if not a:
        return

    n = int(a[0])
    k = int(a[1])

    d = list(map(int, a[2:]))

    x = d[k - 1]

    for i in range(k, n):
        if d[i] != x:
            print(-1)
            return

    c = -1
    for i in range(k - 1, -1, -1):
        if d[i] != x:
            c = i
            break

    if c == -1:
        print(0)
    else:
        print(c + 1)
        
if __name__ == ""__main__"":
    b()"
977,C,Less or Equal,PROGRAMMING,['sortings'],"You are given a sequence of integers of length $n$ and integer number $k$. You should print any integer number $x$ in the range of $[1; 10^9]$ (i.e. $1 \le x \le 10^9$) such that exactly $k$ elements of given sequence are less than or equal to $x$.

Note that the sequence can contain equal elements.

If there is no such $x$, print ""-1"" (without quotes).","The first line of the input contains integer numbers $n$ and $k$ ($1 \le n \le 2 \cdot 10^5$, $0 \le k \le n$). The second line of the input contains $n$ integer numbers $a_1, a_2, \dots, a_n$ ($1 \le a_i \le 10^9$) — the sequence itself.","Print any integer number $x$ from range $[1; 10^9]$ such that exactly $k$ elements of given sequence is less or equal to $x$.

If there is no such $x$, print ""-1"" (without quotes).","['7 4\n3 7 5 1 10 3 20\n', '7 2\n3 7 5 1 10 3 20\n']","['6', '-1\n']","In the first example $5$ is also a valid answer because the elements with indices $[1, 3, 4, 6]$ is less than or equal to $5$ and obviously less than or equal to $6$.

In the second example you cannot choose any number that only $2$ elements of the given sequence will be less than or equal to this number because $3$ elements of the given sequence will be also less than or equal to this number.",WRONG_ANSWER,"a = lambda: map(int, input().split())

def f(n, k, l):
	return -1 if l[k-1] == l[k] else l[k-1]

print(f(*a(), sorted(a())))","def b(a):
    """"""
    Determines if a regular polygon can have an interior angle equal to `angle`.
    
    The interior angle of a regular polygon with n sides is given by:
        interior = ((n - 2) * 180) / n.
    Rearranging, we get:
        angle * n = 180*n - 360  =>  n = 360 / (180 - angle)
    So a regular polygon exists with interior angle equal to `angle` if and only if:
        1. angle < 180  (to avoid division by zero and ensure it's a valid angle)
        2. 360 is divisible by (180 - angle) (ensuring n is an integer)
    """"""
    if a >= 180:
        return False
    if 360 % (180 - a) == 0:
        return True
    else:
        return False

def c():

    t = int(input())
    for _ in range(t):

        a = int(input())

        if b(a):
            print(""YES"")
        else:
            print(""NO"")

if __name__ == ""__main__"":
    c()"
526,D,Om Nom and Necklace,PROGRAMMING,"['hashing', 'string suffix structures', 'strings']","One day Om Nom found a thread with *n* beads of different colors. He decided to cut the first several beads from this thread to make a bead necklace and present it to his girlfriend Om Nelly.

Om Nom knows that his girlfriend loves beautiful patterns. That's why he wants the beads on the necklace to form a regular pattern. A sequence of beads *S* is regular if it can be represented as *S*<==<=*A*<=+<=*B*<=+<=*A*<=+<=*B*<=+<=*A*<=+<=...<=+<=*A*<=+<=*B*<=+<=*A*, where *A* and *B* are some bead sequences, ""<=+<="" is the concatenation of sequences, there are exactly 2*k*<=+<=1 summands in this sum, among which there are *k*<=+<=1 ""*A*"" summands and *k* ""*B*"" summands that follow in alternating order. Om Nelly knows that her friend is an eager mathematician, so she doesn't mind if *A* or *B* is an empty sequence.

Help Om Nom determine in which ways he can cut off the first several beads from the found thread (at least one; probably, all) so that they form a regular pattern. When Om Nom cuts off the beads, he doesn't change their order.","The first line contains two integers *n*, *k* (1<=≤<=*n*,<=*k*<=≤<=1<=000<=000) — the number of beads on the thread that Om Nom found and number *k* from the definition of the regular sequence above.

The second line contains the sequence of *n* lowercase Latin letters that represent the colors of the beads. Each color corresponds to a single letter.","Print a string consisting of *n* zeroes and ones. Position *i* (1<=≤<=*i*<=≤<=*n*) must contain either number one if the first *i* beads on the thread form a regular sequence, or a zero otherwise.","['7 2\nbcabcab\n', '21 2\nababaababaababaababaa\n']","['0000011', '000110000111111000011']","In the first sample test a regular sequence is both a sequence of the first 6 beads (we can take *A* = """", *B* = ""bca""), and a sequence of the first 7 beads (we can take *A* = ""b"", *B* = ""ca"").

In the second sample test, for example, a sequence of the first 13 beads is regular, if we take *A* = ""aba"", *B* = ""ba"".",OK,"def f(s: str):
  n = len(s)
  e = [0] * n
  k = 0
  for i in range(1, n):
    while k > 0 and s[i] != s[k]:
      k = e[k - 1]
    if s[i] == s[k]:
      k += 1
    e[i] = k
  return e

def h(s: str):
  n = len(s)
  z = [0] * n
  l, r = 0, 0
  for i in range(1, n):
    z[i] = 0 if i >= r else min(r - i, z[i - l])
    while i + z[i] < n and s[z[i]] == s[i + z[i]]:
      z[i] += 1
    if i + z[i] > r:
      l, r = i, i + z[i]
  return z

n, k = map(int, input().split())
s = input()
e = f(s)

a = [0] * n
for i in range(n):
  L = i + 1
  T = L - e[i]
  b, g = divmod(L, T)

  d = b // k * T
  c = (b % k) * T + g
  if d >= c:
    a[i] = 1
print("""".join(map(str, a)))","""""""
This script solves the problem of forming a top‐secret troop with minimal total loquacity 
subject to a limited number of adjacent swaps. The key observation is that when soldiers 
are chosen (in order) to be in the front k positions, the cost (number of swaps) required 
to move a soldier at original index i into the j-th position (0-indexed) is (i - j). 

Thus, if we choose a subsequence of k soldiers with indices i0, i1, ..., i{k-1} (in increasing order),
the total number of swaps required is:
    (i0 - 0) + (i1 - 1) + ... + (i{k-1} - (k-1)).

We need to choose a subsequence so that the total swap cost is at most s and the total loquacity 
(sum of q-values of the chosen soldiers) is minimized.
We use dynamic programming with state:
    dp[j][cost] = minimum possible sum of loquacity when we have chosen exactly j soldiers 
    with total swap cost equal to cost.
Because n and k are small (<=150) and maximum cost per choice is bounded by k*(n-1),
we use a dictionary-based DP to only keep the reachable cost values.
""""""

def h():
    import m

    f = m.stdin.read().split()
    if not f:
        return
    n = int(f[0])
    k = int(f[1])
    s = int(f[2])

    q = list(map(int, f[3:]))

    d = min(s, k * (n - 1))
    
    a = 10**18

    g = [ {} for _ in range(k + 1) ]
    g[0][0] = 0

    for i in range(n):

        for j in range(min(i, k - 1), -1, -1):

            for j, k in list(g[j].items()):

                i = j + (i - j)
                if i <= d:
                    c = k + q[i]

                    if i in g[j + 1]:
                        if c < g[j + 1][i]:
                            g[j + 1][i] = c
                    else:
                        g[j + 1][i] = c

    b = a
    if g[k]:
        for e, l in g[k].items():
            if e <= s and l < b:
                b = l
    
    m.stdout.write(str(b) + ""\n"")

if __name__ == '__main__':
    h()"
780,A,Andryusha and Socks,PROGRAMMING,['implementation'],"Andryusha is an orderly boy and likes to keep things in their place.

Today he faced a problem to put his socks in the wardrobe. He has *n* distinct pairs of socks which are initially in a bag. The pairs are numbered from 1 to *n*. Andryusha wants to put paired socks together and put them in the wardrobe. He takes the socks one by one from the bag, and for each sock he looks whether the pair of this sock has been already took out of the bag, or not. If not (that means the pair of this sock is still in the bag), he puts the current socks on the table in front of him. Otherwise, he puts both socks from the pair to the wardrobe.

Andryusha remembers the order in which he took the socks from the bag. Can you tell him what is the maximum number of socks that were on the table at the same time?","The first line contains the single integer *n* (1<=≤<=*n*<=≤<=105) — the number of sock pairs.

The second line contains 2*n* integers *x*1,<=*x*2,<=...,<=*x*2*n* (1<=≤<=*x**i*<=≤<=*n*), which describe the order in which Andryusha took the socks from the bag. More precisely, *x**i* means that the *i*-th sock Andryusha took out was from pair *x**i*.

It is guaranteed that Andryusha took exactly two socks of each pair.",Print single integer — the maximum number of socks that were on the table at the same time.,"['1\n1 1\n', '3\n2 1 1 3 2 3\n']","['1\n', '2\n']","In the first example Andryusha took a sock from the first pair and put it on the table. Then he took the next sock which is from the first pair as well, so he immediately puts both socks to the wardrobe. Thus, at most one sock was on the table at the same time.

In the second example Andryusha behaved as follows: 
 -  Initially the table was empty, he took out a sock from pair 2 and put it on the table. -  Sock (2) was on the table. Andryusha took out a sock from pair 1 and put it on the table. -  Socks (1, 2) were on the table. Andryusha took out a sock from pair 1, and put this pair into the wardrobe. -  Sock (2) was on the table. Andryusha took out a sock from pair 3 and put it on the table. -  Socks (2, 3) were on the table. Andryusha took out a sock from pair 2, and put this pair into the wardrobe. -  Sock (3) was on the table. Andryusha took out a sock from pair 3 and put this pair into the wardrobe.",WRONG_ANSWER,"import math
import os
import random
import re
import sys
from math import gcd
from math import sqrt
from collections import Counter

n = int(input())
a = list(map(int,input().split()))
print(len(set(a)))","import k
import g

def j(n, a):
    """"""Return the sum of digits of number n in the given base.""""""
    s = 0
    while n:
        s += n % a
        n //= a
    return s

def b(A):
    """"""Compute the average sum of digits of A in bases 2 to A-1 as an irreducible fraction.""""""
    l = 0
    c = A - 2
    for b in range(2, A):
        l += j(A, b)

    g = g.gcd(l, c)
    h = l // g
    d = c // g
    return f""{h}/{d}""

if __name__ == ""__main__"":

    e = k.stdin.readlines()
    for f in e:
        f = f.strip()
        if not f:
            continue
        try:
            A = int(f)

            if 3 <= A <= 1000:
                i = b(A)
                k.stdout.write(i + ""\n"")
        except ValueError:
            continue"
59,A,Word,PROGRAMMING,"['implementation', 'strings']","Vasya is very upset that many people on the Net mix uppercase and lowercase letters in one word. That's why he decided to invent an extension for his favorite browser that would change the letters' register in every word so that it either only consisted of lowercase letters or, vice versa, only of uppercase ones. At that as little as possible letters should be changed in the word. For example, the word HoUse must be replaced with house, and the word ViP — with VIP. If a word contains an equal number of uppercase and lowercase letters, you should replace all the letters with lowercase ones. For example, maTRIx should be replaced by matrix. Your task is to use the given method on one given word.",The first line contains a word *s* — it consists of uppercase and lowercase Latin letters and possesses the length from 1 to 100.,"Print the corrected word *s*. If the given word *s* has strictly more uppercase letters, make the word written in the uppercase register, otherwise - in the lowercase one.","['HoUse\n', 'ViP\n', 'maTRIx\n']","['house\n', 'VIP\n', 'matrix\n']",none,WRONG_ANSWER,"a = ""abcdefghijklmnopqrstuvwxyz""
b = str(input())
if sum([c in a for c in b]) < (len(b)+1) / 2:
    print(b.upper())
else:
    print(b.lower())","""""""
We solve the problem by splitting the selection into a mandatory “baseline”
subarray covering the whole array and (k-1) extra intervals.
The total answer equals:
    baseline_sum + (sum of top (k-1) subarray sums)
where “top” means subarray sums sorted in non‐increasing order.
We use a known technique for “sum of k largest subarray sums” via binary search.
Let P[0..n] be the prefix sums of the array.
Every subarray sum = P[j] - P[i] for 0 <= i < j <= n.
For any threshold X, we can count the number of subarrays with sum >= X and 
their total sum (i.e. sum of all such subarray sums). Then, if we let T = (k-1)
and choose v as the largest integer such that the count of subarrays with sum >= v
is at least T, then the sum of the top T subarray sums equals:
    S(v) - (count(v) - T) * v,
where S(v) is the total sum of subarray sums >= v.
Finally, answer = baseline (i.e. sum(array)) + (that extra sum).
If k == 1, answer is simply baseline.
 
We use Fenwick trees (Binary Indexed Trees) for efficient queries.
Coordinate compression is applied to the prefix sums.
 
Note: Although worst-case input size may require heavy optimization in C++,
this Python implementation uses BIT and binary search – and is expected to
perform well on average test cases.
""""""

import z,z
import h

z.setrecursionlimit(10**6)
o = z.stdin.read().split()
if not o:
    z.exit(0)

p = iter(o)
n = int(next(p))
k = int(next(p))
a = [int(next(p)) for _ in range(n)]

g = sum(a)

if k == 1:
    z.stdout.write(str(g) + ""\n"")
    z.exit(0)

T = k - 1

P = [0]*(n+1)
for i in range(n):
    P[i+1] = P[i] + a[i]

e = sorted(set(P))
m = len(e)

class c:
    d = ('n','tree')
    def __init__(y, n):
        y.n = n
        y.tree = [0]*(n+1)
    def ~(y, i, l):

        while i <= y.n:
            y.tree[i] += l
            i += i & -i
    def w(y, i):
        s = 0
        while i:
            s += y.tree[i]
            i -= i & -i
        return s

def k({):

    a = c(m)
    b = c(m)
    j = 0
    | = 0

    t = h.bisect_left(e, P[0]) + 1
    a.~(t, 1)
    b.~(t, P[0])

    for j in range(1, n+1):

        q = P[j] - {
        u = h.bisect_right(e, q)
        if u > 0:
            c = a.w(u)
            x = b.w(u)

            j += c
            | += c * P[j] - x

        v = h.bisect_left(e, P[j]) + 1
        a.~(v, 1)
        b.~(v, P[j])
    return j, |

r = -10**15
n = 10**15
while r < n:
    s = (r + n + 1) >> 1
    c, _ = k(s)
    if c >= T:
        r = s
    else:
        n = s - 1
v = r
i, } = k(v)

m = } - (i - T) * v
f = g + m
z.stdout.write(str(f) + ""\n"")"
450,B,Jzzhu and Sequences,PROGRAMMING,"['implementation', 'math']","Jzzhu has invented a kind of sequences, they meet the following property:

You are given *x* and *y*, please calculate *f**n* modulo 1000000007 (109<=+<=7).","The first line contains two integers *x* and *y* (|*x*|,<=|*y*|<=≤<=109). The second line contains a single integer *n* (1<=≤<=*n*<=≤<=2·109).",Output a single integer representing *f**n* modulo 1000000007 (109<=+<=7).,"['2 3\n3\n', '0 -1\n2\n']","['1\n', '1000000006\n']","In the first sample, *f*<sub class=""lower-index"">2</sub> = *f*<sub class=""lower-index"">1</sub> + *f*<sub class=""lower-index"">3</sub>, 3 = 2 + *f*<sub class=""lower-index"">3</sub>, *f*<sub class=""lower-index"">3</sub> = 1.

In the second sample, *f*<sub class=""lower-index"">2</sub> =  - 1;  - 1 modulo (10<sup class=""upper-index"">9</sup> + 7) equals (10<sup class=""upper-index"">9</sup> + 6).",WRONG_ANSWER,"def f(n,x,y):
    if n%6==1:
        return(x)
    if n%6==2:
        return(y)
    if n%6==3:
        return(y-x)
    if n%6==4:
        return(-x)
    if n%6==5:
        return(-y)
    if n%6==0:
        return(x-y)
x,y=map(int,input().split())
n=int(input())
print(f(n,x,y%1000000007))","import m
import math
import numpy as k

def i():

    g = m.stdin.read().strip().split()
    if not g:
        return
    n = int(g[0])

    c = k.array(list(map(float, g[1:])))
    c = c.reshape(n, 3)

    X = c[1:]
    d = k.linalg.norm(X - c[0], axis=1)

    a = float('inf')
    m = n - 1

    for i in range(m - 1):

        e = d[i]

        h = X[i+1:] - X[i]

        f = k.sqrt(k.einsum('ij,ij->i', h, h))

        l = e + d[i+1:]

        b = (l + f) * 0.5

        j = k.min(b)
        if j < a:
            a = j

    m.stdout.write(f""{a:.10f}\n"")

if __name__ == '__main__':
    i()"
58,A,Chat room,PROGRAMMING,"['greedy', 'strings']","Vasya has recently learned to type and log on to the Internet. He immediately entered a chat room and decided to say hello to everybody. Vasya typed the word *s*. It is considered that Vasya managed to say hello if several letters can be deleted from the typed word so that it resulted in the word ""hello"". For example, if Vasya types the word ""ahhellllloou"", it will be considered that he said hello, and if he types ""hlelo"", it will be considered that Vasya got misunderstood and he didn't manage to say hello. Determine whether Vasya managed to say hello by the given word *s*.","The first and only line contains the word *s*, which Vasya typed. This word consisits of small Latin letters, its length is no less that 1 and no more than 100 letters.","If Vasya managed to say hello, print ""YES"", otherwise print ""NO"".","['ahhellllloou\n', 'hlelo\n']","['YES\n', 'NO\n']",none,OK,"def a(c, b):
    if not c: return True
    
    if c[0] not in b:
        return False
    
    return a(c[1:], b[b.a(c[0])+1:])

if a(""hello"", input()):
    print(""YES"")
else:
    print(""NO"")","def c():
    import i

    a = i.stdin.read().split()

    n = int(a[0])

    b = list(map(int, a[1:1+n]))

    d = max(b)
    e = 0
    for i in range(n):
        if b[i] == d:
            e = i
            break

    f = min(b)
    g = 0
    for i in range(n - 1, -1, -1):
        if b[i] == f:
            g = i
            break

    h = e

    h += (n - 1 - g)

    if e > g:
        h -= 1

    i.stdout.write(str(h))
    
if __name__ == '__main__':
    c()"
633,C,Spy Syndrome 2,PROGRAMMING,"['data structures', 'dp', 'hashing', 'implementation', 'sortings', 'string suffix structures', 'strings']","After observing the results of Spy Syndrome, Yash realised the errors of his ways. He now believes that a super spy such as Siddhant can't use a cipher as basic and ancient as Caesar cipher. After many weeks of observation of Siddhant’s sentences, Yash determined a new cipher technique.

For a given sentence, the cipher is processed as: 
 1.  Convert all letters of the sentence to lowercase. 1.  Reverse each of the words of the sentence individually. 1.  Remove all the spaces in the sentence. 
For example, when this cipher is applied to the sentence

Kira is childish and he hates losing

the resulting string is

ariksihsidlihcdnaehsetahgnisol

Now Yash is given some ciphered string and a list of words. Help him to find out any original sentence composed using only words from the list. Note, that any of the given words could be used in the sentence multiple times.","The first line of the input contains a single integer *n* (1<=≤<=*n*<=≤<=10<=000) — the length of the ciphered text. The second line consists of *n* lowercase English letters — the ciphered text *t*.

The third line contains a single integer *m* (1<=≤<=*m*<=≤<=100<=000) — the number of words which will be considered while deciphering the text. Each of the next *m* lines contains a non-empty word *w**i* (|*w**i*|<=≤<=1<=000) consisting of uppercase and lowercase English letters only. It's guaranteed that the total length of all words doesn't exceed 1<=000<=000.","Print one line — the original sentence. It is guaranteed that at least one solution exists. If there are multiple solutions, you may output any of those.","['30\nariksihsidlihcdnaehsetahgnisol\n10\nKira\nhates\nis\nhe\nlosing\ndeath\nchildish\nL\nand\nNote\n', '12\niherehtolleh\n5\nHI\nHo\nthere\nHeLLo\nhello\n']","['Kira is childish and he hates losing \n', 'HI there HeLLo \n']","In sample case 2 there may be multiple accepted outputs, ""HI there HeLLo"" and ""HI there hello"" you may output any of them.",RUNTIME_ERROR,"import heapq
import math
import collections
import bisect
g=10**9+7
f=10**3
i=[0]*f
p=31
i[0]=1
for i in range(1,f):
    i[i]=(i[i-1]*p)%g
def hash(l):
    l=l.lower()
    c=0
    for i in range(len(l)):
        c=(c+(ord(l[i])-96)*i[i])%g
    return c    
def k(n,s,d):
    j=[]
    def b(d,a,e):
        if d==n:
            if a==0:
                j.append(e)
                return True
            return False
                

        a=(a*p+ord(s[d])-96)%g
        if a in d:
            if b(d+1,0,e+d[a]+"" ""):
                return True
        return b(d+1,a,e)        
    b(0,0,"""")
    return j[0]

n=int(input())
s=input()
m=int(input())
d={}
for i in range(m):
    h=input()
    m=hash(h)
    d[m]=h

print(k(n,s,d))","import e

def c():

    a = e.stdin.readlines()

    for b in a:

        b = b.strip()

        if not b:
            continue

        try:
            m, n = map(int, b.split())
        except ValueError:

            continue

        d = (m * n) // 2

        print(d)

if __name__ == ""__main__"":
    c()"
653,A,Bear and Three Balls,PROGRAMMING,"['brute force', 'implementation', 'sortings']","Limak is a little polar bear. He has *n* balls, the *i*-th ball has size *t**i*.

Limak wants to give one ball to each of his three friends. Giving gifts isn't easy — there are two rules Limak must obey to make friends happy:
 -  No two friends can get balls of the same size. -  No two friends can get balls of sizes that differ by more than 2. 
For example, Limak can choose balls with sizes 4, 5 and 3, or balls with sizes 90, 91 and 92. But he can't choose balls with sizes 5, 5 and 6 (two friends would get balls of the same size), and he can't choose balls with sizes 30, 31 and 33 (because sizes 30 and 33 differ by more than 2).

Your task is to check whether Limak can choose three balls that satisfy conditions above.","The first line of the input contains one integer *n* (3<=≤<=*n*<=≤<=50) — the number of balls Limak has.

The second line contains *n* integers *t*1,<=*t*2,<=...,<=*t**n* (1<=≤<=*t**i*<=≤<=1000) where *t**i* denotes the size of the *i*-th ball.","Print ""YES"" (without quotes) if Limak can choose three balls of distinct sizes, such that any two of them differ by no more than 2. Otherwise, print ""NO"" (without quotes).","['4\n18 55 16 17\n', '6\n40 41 43 44 44 44\n', '8\n5 972 3 4 1 4 970 971\n']","['YES\n', 'NO\n', 'YES\n']","In the first sample, there are 4 balls and Limak is able to choose three of them to satisfy the rules. He must must choose balls with sizes 18, 16 and 17.

In the second sample, there is no way to give gifts to three friends without breaking the rules.

In the third sample, there is even more than one way to choose balls:
 1.  Choose balls with sizes 3, 4 and 5. 1.  Choose balls with sizes 972, 970, 971.",WRONG_ANSWER,"def c(a):

    for i in range(1, len(a)):
 
        d = a[i]

        j = i-1
        while j >= 0 and d < a[j] :
                a[j + 1] = a[j]
                j -= 1
        a[j + 1] = d

a = int(input())
b = str(input())
n = b.split()
for i in range (a):
  n[i] = int(n[i])

c(n)
b =0
if (a<3):
  print(""NO"")
else:
  for i in range (a-2):
    c = n[i]
    d = n[i+1]
    e = n[i+2]
    if (e-d == 1 and d-c == 1):
      b =1
if (b == 0):
  print(""NO"")
else:
  print(""YES"")","def c():
    import h
    
    b = h.stdin.read().strip().splitlines()
    if not b:
        return

    n = int(b[0])

    a = {""polycarp"": 1}

    for i in range(1, n + 1):

        f = b[i].split()

        g = f[0].lower()
        e = f[2].lower()

        a[g] = a[e] + 1

    d = max(a.values())
    print(d)

if __name__ == ""__main__"":
    c()"
617,A,Elephant,PROGRAMMING,['math'],"An elephant decided to visit his friend. It turned out that the elephant's house is located at point 0 and his friend's house is located at point *x*(*x*<=&gt;<=0) of the coordinate line. In one step the elephant can move 1, 2, 3, 4 or 5 positions forward. Determine, what is the minimum number of steps he need to make in order to get to his friend's house.",The first line of the input contains an integer *x* (1<=≤<=*x*<=≤<=1<=000<=000) — The coordinate of the friend's house.,Print the minimum number of steps that elephant needs to make to get from point 0 to point *x*.,"['5\n', '12\n']","['1\n', '3\n']","In the first sample the elephant needs to make one step of length 5 to reach the point *x*.

In the second sample the elephant can get to point *x* if he moves by 3, 5 and 4. There are other ways to get the optimal answer but the elephant cannot reach *x* in less than three moves.",OK,"def a(x):
    c = x // 5
    if x % 5 != 0:
        c += 1
    return c

x = int(input())

b = a(x)
print(b)","l, r, k = map(int, input().split())

b = []
a = 1

while a <= r:

    if a >= l:
        b.append(a)

    if a > r // k:
        break
    
    a *= k

if b:

    print("" "".join(map(str, b)))
else:
    print(""-1"")"
813,B,The Golden Age,PROGRAMMING,"['brute force', 'math']","Unlucky year in Berland is such a year that its number *n* can be represented as *n*<==<=*x**a*<=+<=*y**b*, where *a* and *b* are non-negative integer numbers. 

For example, if *x*<==<=2 and *y*<==<=3 then the years 4 and 17 are unlucky (4<==<=20<=+<=31, 17<==<=23<=+<=32<==<=24<=+<=30) and year 18 isn't unlucky as there is no such representation for it.

Such interval of years that there are no unlucky years in it is called The Golden Age.

You should write a program which will find maximum length of The Golden Age which starts no earlier than the year *l* and ends no later than the year *r*. If all years in the interval [*l*,<=*r*] are unlucky then the answer is 0.","The first line contains four integer numbers *x*, *y*, *l* and *r* (2<=≤<=*x*,<=*y*<=≤<=1018, 1<=≤<=*l*<=≤<=*r*<=≤<=1018).","Print the maximum length of The Golden Age within the interval [*l*,<=*r*].

If all years in the interval [*l*,<=*r*] are unlucky then print 0.","['2 3 1 10\n', '3 5 10 22\n', '2 3 3 5\n']","['1\n', '8\n', '0\n']","In the first example the unlucky years are 2, 3, 4, 5, 7, 9 and 10. So maximum length of The Golden Age is achived in the intervals [1, 1], [6, 6] and [8, 8].

In the second example the longest Golden Age is the interval [15, 22].",OK,"def i():
    while 1:
        b = list(input().split(' '))
        for h in b:
            if len(h) > 0:
                yield(h)   

e = i()

def d():
    global e
    return next(e)

def c():
    b = d()
    try:
        return int(b)
    except ValueError:
        return float(b)

x = c()
y = c()
l = c()
r = c()
f = 1;
a = list()
a.append(l - 1)
for i in range(0, 300):
    if f > r:
        break
    g = 1 
    for j in range(0, 300):
        if f + g > r:
            break
        if f + g >= l and f + g <= r:
            a.append(f + g)
        g = g * y
    f = f * x
    
a.append(r + 1)
a.sort()
a = 0
for i in range(0, len(a) - 1):
    a = max(a, a[i + 1] - a[i] - 1)
print(a)","def f():
    import i

    c = i.stdin.read().split()

    n = int(c[0])
    k = int(c[1])

    a = list(map(int, c[2:2+n]))

    d = [(a[i], i + 1) for i in range(n)]

    d.sort(key=lambda x: x[0], reverse=True)

    a = d[:k]
    j = sum(k for k, e in a)

    a.sort(key=lambda x: x[1])
    
    h = []
    g = 0

    for i in range(k - 1):
        b = a[i][1]
        h.append(b - g)
        g = b

    h.append(n - g)

    i.stdout.write(str(j) + ""\n"")
    i.stdout.write("" "".join(map(str, h)) + ""\n"")

if __name__ == '__main__':
    f()"
593,B,Anton and Lines,PROGRAMMING,"['geometry', 'sortings']","The teacher gave Anton a large geometry homework, but he didn't do it (as usual) as he participated in a regular round on Codeforces. In the task he was given a set of *n* lines defined by the equations *y*<==<=*k**i*·*x*<=+<=*b**i*. It was necessary to determine whether there is at least one point of intersection of two of these lines, that lays strictly inside the strip between *x*1<=&lt;<=*x*2. In other words, is it true that there are 1<=≤<=*i*<=&lt;<=*j*<=≤<=*n* and *x*',<=*y*', such that: 
 -  *y*'<==<=*k**i*<=*<=*x*'<=+<=*b**i*, that is, point (*x*',<=*y*') belongs to the line number *i*; -  *y*'<==<=*k**j*<=*<=*x*'<=+<=*b**j*, that is, point (*x*',<=*y*') belongs to the line number *j*; -  *x*1<=&lt;<=*x*'<=&lt;<=*x*2, that is, point (*x*',<=*y*') lies inside the strip bounded by *x*1<=&lt;<=*x*2. 
You can't leave Anton in trouble, can you? Write a program that solves the given task.","The first line of the input contains an integer *n* (2<=≤<=*n*<=≤<=100<=000) — the number of lines in the task given to Anton. The second line contains integers *x*1 and *x*2 (<=-<=1<=000<=000<=≤<=*x*1<=&lt;<=*x*2<=≤<=1<=000<=000) defining the strip inside which you need to find a point of intersection of at least two lines.

The following *n* lines contain integers *k**i*, *b**i* (<=-<=1<=000<=000<=≤<=*k**i*,<=*b**i*<=≤<=1<=000<=000) — the descriptions of the lines. It is guaranteed that all lines are pairwise distinct, that is, for any two *i*<=≠<=*j* it is true that either *k**i*<=≠<=*k**j*, or *b**i*<=≠<=*b**j*.","Print ""Yes"" (without quotes), if there is at least one intersection of two distinct lines, located strictly inside the strip. Otherwise print ""No"" (without quotes).","['4\n1 2\n1 2\n1 0\n0 1\n0 2\n', '2\n1 3\n1 0\n-1 3\n', '2\n1 3\n1 0\n0 2\n', '2\n1 3\n1 0\n0 3\n']","['NO', 'YES', 'YES', 'NO']","In the first sample there are intersections located on the border of the strip, but there are no intersections located strictly inside it.",TIME_LIMIT_EXCEEDED,"import e
def d(*a,**c):
    c[""file""] = c.get(""file"",e.stderr)
    print(*a,**c)

n = int(input())
f,g = map(int,input().strip().split())

h = []
i = []

for i in range(n):
    m,c = map(int,input().strip().split())
    h.append(m*f+c)
    i.append(m*g+c)

b = sorted(range(n),key=lambda x: h[x])

for i,j in zip(b,b[1:]):
    if h[i] != h[j] and i[i] > i[j]:
        print(""YES"")
        exit()
print(""NO"")","def d():
    import e

    n = int(e.stdin.readline().strip())
    
    a = n
    c = []
    b = 1

    while a > 0:

        if a - b > b:
            c.append(b)
            a -= b
            b += 1
        else:

            c.append(a)
            a = 0

    print(len(c))
    print("" "".join(map(str, c)))

if __name__ == ""__main__"":
    d()"
0,none,none,none,['none'],"Two participants are each given a pair of distinct numbers from 1 to 9 such that there's exactly one number that is present in both pairs. They want to figure out the number that matches by using a communication channel you have access to without revealing it to you.

Both participants communicated to each other a set of pairs of numbers, that includes the pair given to them. Each pair in the communicated sets comprises two different numbers.

Determine if you can with certainty deduce the common number, or if you can determine with certainty that both participants know the number but you do not.","The first line contains two integers $n$ and $m$ ($1 \le n, m \le 12$) — the number of pairs the first participant communicated to the second and vice versa.

The second line contains $n$ pairs of integers, each between $1$ and $9$, — pairs of numbers communicated from first participant to the second.

The third line contains $m$ pairs of integers, each between $1$ and $9$, — pairs of numbers communicated from the second participant to the first.

All pairs within each set are distinct (in particular, if there is a pair $(1,2)$, there will be no pair $(2,1)$ within the same set), and no pair contains the same number twice.

It is guaranteed that the two sets do not contradict the statements, in other words, there is pair from the first set and a pair from the second set that share exactly one number.","If you can deduce the shared number with certainty, print that number.

If you can with certainty deduce that both participants know the shared number, but you do not know it, print $0$.

Otherwise print $-1$.","['2 2\n1 2 3 4\n1 5 3 4\n', '2 2\n1 2 3 4\n1 5 6 4\n', '2 3\n1 2 4 5\n1 2 1 3 2 3\n']","['1\n', '0\n', '-1\n']","In the first example the first participant communicated pairs $(1,2)$ and $(3,4)$, and the second communicated $(1,5)$, $(3,4)$. Since we know that the actual pairs they received share exactly one number, it can't be that they both have $(3,4)$. Thus, the first participant has $(1,2)$ and the second has $(1,5)$, and at this point you already know the shared number is $1$.

In the second example either the first participant has $(1,2)$ and the second has $(1,5)$, or the first has $(3,4)$ and the second has $(6,4)$. In the first case both of them know the shared number is $1$, in the second case both of them know the shared number is $4$. You don't have enough information to tell $1$ and $4$ apart.

In the third case if the first participant was given $(1,2)$, they don't know what the shared number is, since from their perspective the second participant might have been given either $(1,3)$, in which case the shared number is $1$, or $(2,3)$, in which case the shared number is $2$. While the second participant does know the number with certainty, neither you nor the first participant do, so the output is $-1$.",WRONG_ANSWER,"n , m = map(int,input().split())
l = [int(x) for x in input().split()]
k = [int(x) for x in input().split()]
o = 0
d = []
def a(l, n):
    for i in range(0, len(l), n): 
        yield l[i:i + n]
x = list(a(l, 2))
y = list(a(k, 2))
for i in x:
    if i in y:
        x.remove(i)
        y.remove(i)
o = ( ', '.join(str(u) for u in x))
p = (', '.join(str(u) for u in y))
if  o!=p:
    for i in o:
        if i in p and i!='[' and i!=']' and i!=',' and i!=' ':
            d.append(i)
if len(d)>=2:
    print('0')
elif len(o)!=len(p):
    print('-1')
elif len(d)==1:
    print(' '.join(d))","import e

def c():

    a = e.stdin.read().strip().splitlines()[0]

    if '0' in a:
        b = a.find('0')
        d = a[:b] + a[b+1:]
    else:

        d = a[:-1]

    d = d.lstrip('0')
    if d == '':
        d = '0'
    
    e.stdout.write(d)

if __name__ == '__main__':
    c()"
182,B,Vasya's Calendar,PROGRAMMING,['implementation'],"Vasya lives in a strange world. The year has *n* months and the *i*-th month has *a**i* days. Vasya got a New Year present — the clock that shows not only the time, but also the date.

The clock's face can display any number from 1 to *d*. It is guaranteed that *a**i*<=≤<=*d* for all *i* from 1 to *n*. The clock does not keep information about the current month, so when a new day comes, it simply increases the current day number by one. The clock cannot display number *d*<=+<=1, so after day number *d* it shows day 1 (the current day counter resets). The mechanism of the clock allows you to increase the day number by one manually. When you execute this operation, day *d* is also followed by day 1.

Vasya begins each day checking the day number on the clock. If the day number on the clock does not match the actual day number in the current month, then Vasya manually increases it by one. Vasya is persistent and repeats this operation until the day number on the clock matches the actual number of the current day in the current month.

A year passed and Vasya wonders how many times he manually increased the day number by one, from the first day of the first month to the last day of the *n*-th month inclusive, considering that on the first day of the first month the clock display showed day 1.","The first line contains the single number *d* — the maximum number of the day that Vasya's clock can show (1<=≤<=*d*<=≤<=106).

The second line contains a single integer *n* — the number of months in the year (1<=≤<=*n*<=≤<=2000).

The third line contains *n* space-separated integers: *a**i* (1<=≤<=*a**i*<=≤<=*d*) — the number of days in each month in the order in which they follow, starting from the first one.",Print a single number — the number of times Vasya manually increased the day number by one throughout the last year.,"['4\n2\n2 2\n', '5\n3\n3 4 3\n', '31\n12\n31 28 31 30 31 30 31 31 30 31 30 31\n']","['2\n', '3\n', '7\n']","In the first sample the situation is like this: 
 -  Day 1. Month 1. The clock shows 1. Vasya changes nothing. -  Day 2. Month 1. The clock shows 2. Vasya changes nothing. -  Day 1. Month 2. The clock shows 3. Vasya manually increases the day number by 1. After that the clock shows 4. Vasya increases the day number by 1 manually. After that the clock shows 1. -  Day 2. Month 2. The clock shows 2. Vasya changes nothing.",OK,"def b() :
    c=0
    for i in a[:-1]:
        c+= d - i
    return c

d=int(input())
n=int(input())
a=[int(x) for x in input().split()]
print(b())

'''

t=int(input())
for i in range(t) :
    print(solve())

n,m= [int(x) for x in input().split()]

n=int(input())
arr=[]
for i in range(n):
    arr.append([int(x) for x in input().split()])

n=int(input())
arr=[int(x) for x in input().split()]
'''","n = int(input().strip())
a = [list(map(int, input().strip().split())) for _ in range(n)]

def b(n, a):

    for i in range(n):
        for j in range(n):

            if a[i][j] == 1:
                continue
            c = False

            for k in range(n):
                for l in range(n):
                    if a[i][k] + a[l][j] == a[i][j]:
                        c = True
                        break
                if c:
                    break

            if not c:
                return False
    return True

if b(n, a):
    print(""Yes"")
else:
    print(""No"")"
197,B,Limit,PROGRAMMING,['math'],"You are given two polynomials:
 -  *P*(*x*)<==<=*a*0·*x**n*<=+<=*a*1·*x**n*<=-<=1<=+<=...<=+<=*a**n*<=-<=1·*x*<=+<=*a**n* and -  *Q*(*x*)<==<=*b*0·*x**m*<=+<=*b*1·*x**m*<=-<=1<=+<=...<=+<=*b**m*<=-<=1·*x*<=+<=*b**m*. 
Calculate limit .","The first line contains two space-separated integers *n* and *m* (0<=≤<=*n*,<=*m*<=≤<=100) — degrees of polynomials *P*(*x*) and *Q*(*x*) correspondingly.

The second line contains *n*<=+<=1 space-separated integers — the factors of polynomial *P*(*x*): *a*0, *a*1, ..., *a**n*<=-<=1, *a**n* (<=-<=100<=≤<=*a**i*<=≤<=100,<=*a*0<=≠<=0).

The third line contains *m*<=+<=1 space-separated integers — the factors of polynomial *Q*(*x*): *b*0, *b*1, ..., *b**m*<=-<=1, *b**m* (<=-<=100<=≤<=*b**i*<=≤<=100,<=*b*0<=≠<=0).","If the limit equals <=+<=∞, print ""Infinity"" (without quotes). If the limit equals <=-<=∞, print ""-Infinity"" (without the quotes).

If the value of the limit equals zero, print ""0/1"" (without the quotes).

Otherwise, print an irreducible fraction — the value of limit , in the format ""p/q"" (without the quotes), where *p* is the — numerator, *q* (*q*<=&gt;<=0) is the denominator of the fraction.","['2 1\n1 1 1\n2 5\n', '1 0\n-1 3\n2\n', '0 1\n1\n1 0\n', '2 2\n2 1 6\n4 5 -7\n', '1 1\n9 0\n-5 2\n']","['Infinity\n', '-Infinity\n', '0/1\n', '1/2\n', '-9/5\n']","Let's consider all samples:
 1.  <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/c28febca257452afdfcbd6984ba8623911f9bdbc.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> 1.  <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/1e55ecd04e54a45e5e0092ec9a5c1ea03bb29255.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> 1.  <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/2c95fb684d373fcc1a481cfabeda4d5c2f3673ee.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> 1.  <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/4dc40cb8b3cd6375c42445366e50369649a2801a.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> 1.  <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/c6455aba35cfb3c4397505121d1f77afcd17c98e.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> 
You can learn more about the definition and properties of limits if you follow the link: http://en.wikipedia.org/wiki/Limit_of_a_function",RUNTIME_ERROR,"import k
import g
from k import stdin, stdout

def c():
    return map(int, k.stdin.readline().strip().split())
def a(): return int(input())
def b(): return list(
    map(int, k.stdin.readline().strip().split()))
def d(n): return [list(
    map(int, k.stdin.readline().strip().split())) for _ in range(n)]
def e(): return k.stdin.readline().strip()
 
def f():

    n, m = c()
    h = b()
    i = b()

    if n > m:
        if (i[0] > 0 and h[0] > 0) or (i[0] < 0 and h < 0):
            print(""Infinity"")
        else:
            print(""-Infinity"")
    elif m > n:
        print(""0/1"")
    else:
        l = g.gcd(h[0], i[0])
        h[0] //= l
        i[0] //= l
        if (i[0] > 0 and h[0] > 0) or (i[0] < 0 and h[0] < 0):
            j = """"
            j += str(h[0])
            j += ""/""
            j += str(i[0])
            print(j)
        else:
            j = ""-""
            j += str(abs(h[0]))
            j += ""/""
            j += str(abs(i[0]))
            print(j)

if __name__ == ""__main__"":
    f()","def f(s):

    n = len(s)
    z = [0] * n
    l, r = 0, 0
    for i in range(1, n):
        if i <= r:
            z[i] = min(r - i + 1, z[i - l])
        while i + z[i] < n and s[z[i]] == s[i + z[i]]:
            z[i] += 1
        if i + z[i] - 1 > r:
            l, r = i, i + z[i] - 1
    return z

import m

def k():
    g = m.stdin.read().split()
    if not g:
        return
    n = int(g[0])
    k = int(g[1])
    s = g[2].strip()

    z = f(s)

    j = []

    a = n // k
    for L in range(1, a + 1):

        if k > 1:
            if L >= len(z) or z[L] < (k - 1) * L:
                continue
        e = k * L
        if e > n:
            break

        if e == n:
            c, b = 0, 0
        else:

            c = 0
            b = min(L, z[e])

        i = e + c
        h = e + b
        if i > n:
            continue
        if h > n:
            h = n

        j.append((i, h))

    j.sort()
    l = []
    for l, r in j:
        if not l:
            l.append([l, r])
        else:
            if l <= l[-1][1] + 1:
                if r > l[-1][1]:
                    l[-1][1] = r
            else:
                l.append([l, r])

    d = ['0'] * n
    for l, r in l:

        for i in range(l - 1, r):
            d[i] = '1'
    m.stdout.write("""".join(d))

if __name__ == '__main__':
    k()"
772,B,Volatile Kite,PROGRAMMING,['geometry'],"You are given a convex polygon *P* with *n* distinct vertices *p*1,<=*p*2,<=...,<=*p**n*. Vertex *p**i* has coordinates (*x**i*,<=*y**i*) in the 2D plane. These vertices are listed in clockwise order.

You can choose a real number *D* and move each vertex of the polygon a distance of at most *D* from their original positions.

Find the maximum value of *D* such that no matter how you move the vertices, the polygon does not intersect itself and stays convex.","The first line has one integer *n* (4<=≤<=*n*<=≤<=1<=000) — the number of vertices.

The next *n* lines contain the coordinates of the vertices. Line *i* contains two integers *x**i* and *y**i* (<=-<=109<=≤<=*x**i*,<=*y**i*<=≤<=109) — the coordinates of the *i*-th vertex. These points are guaranteed to be given in clockwise order, and will form a strictly convex polygon (in particular, no three consecutive points lie on the same straight line).","Print one real number *D*, which is the maximum real number such that no matter how you move the vertices, the polygon stays convex.

Your answer will be considered correct if its absolute or relative error does not exceed 10<=-<=6.

Namely, let's assume that your answer is *a* and the answer of the jury is *b*. The checker program will consider your answer correct if .","['4\n0 0\n0 1\n1 1\n1 0\n', '6\n5 0\n10 0\n12 -4\n10 -8\n5 -8\n3 -4\n']","['0.3535533906\n', '1.0000000000\n']","Here is a picture of the first sample

<img class=""tex-graphics"" src=""https://espresso.codeforces.com/f83aa076d2f437f9bb785cae769c3ae310eff351.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

Here is an example of making the polygon non-convex.

<img class=""tex-graphics"" src=""https://espresso.codeforces.com/fbadb81630251ca642bd4ddf9088876ade761630.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

This is not an optimal solution, since the maximum distance we moved one point is  ≈ 0.4242640687, whereas we can make it non-convex by only moving each point a distance of at most  ≈ 0.3535533906.",WRONG_ANSWER,"import c
from decimal import Decimal
n = int(input())
d = [[0,0] for i in range(n)]
for i in range(n):
    d[i] = list(map(int,input().split()))
def b(m):
    l = m - 1;
    if (l < 0): l = n - 1;
    r = (m + 1) % n
    a = c.sqrt((d[l][0] - d[m][0])**2 + (d[l][1] - d[m][1]) ** 2)
    b = c.sqrt((d[m][0] - d[r][0]) ** 2 + (d[m][1] - d[r][1]) ** 2)
    c = c.sqrt((d[l][0] - d[r][0]) ** 2 + (d[l][1] - d[r][1]) ** 2)
    p = (a + b + c) / 2
    s = c.sqrt(p * (p - a) * (p - b) * (p - c))
    return s / c

a = b(0)
for i in range(1,n):
    a = min(a, b(i))
print(a)","""""""
We are given three musketeers with strengths a, b, c (not necessarily sorted)
and n criminals with given strengths.
Each hour the musketeers may be assigned in one of two “patterns”:
  • They can all fight separately (""three singles"") which can defeat up to three criminals—
    but note that a single musketeer can defeat a criminal only if that criminal’s strength
    does not exceed his personal strength.
  • They can join forces: two musketeers may team‐up on one criminal while the third,
    unused in that fight, can fight another criminal. (In one hour such an assignment defeats 2 criminals.)
In each hour a musketeer may participate in at most one fight.
A criminal may be attacked by one, two, or all three musketeers provided that the sum
of the strengths of the assigned musketeers is at least the criminal’s strength.
Because the musketeers want a “peaceful” New Year’s Eve, we need to minimize the number
of hours required to defeat all criminals.
If any criminal is too strong to be defeated even by all three together (i.e. if t > a+b+c)
the answer is -1.

An optimal scheduling strategy is known:
  – Criminals which are “easy” (with t <= c) can be killed by a single musketeer.
  – Criminals with t > c require at least two musketeers.
When two musketeers team‐up, there are three possible pairs:
     Pair (A,B) can defeat criminals of strength <= a+b;
     Pair (A,C) can defeat criminals of strength <= a+c;
     Pair (B,C) can defeat criminals of strength <= b+c.
If a criminal (with t > c) can be defeated by a pair move (i.e. t <= some pair sum)
it is best to do so because then the “unused” musketeer in that hour
can still fight a “single‐kill” criminal.
However, if t is too high for every pair, then all three must join (a triple move)
and no extra single move is available that hour.

After “assigning” each hour for a criminal from the “t > c” group,
we get extra single–move “slots” only in those hours where a pair move was used.
On the other side,
hours in which no “group1” (criminal requiring ≥2 musketeers)
fight is scheduled (“free hours”), all three musketeers are free for single moves.
Thus we split the criminals into:
  Group1: criminals with t > c (cannot be defeated individually)
         and further into:
           • Category 1: t ≤ a+b. (Use pair (A,B) → leftover fighter C)
           • Category 2: a+b < t ≤ a+c. (Use pair (A,C) → leftover fighter B)
           • Category 3: a+c < t ≤ b+c. (Use pair (B,C) → leftover fighter A)
           • Otherwise (t > b+c) they force a triple move.
  Group2: criminals with t ≤ c (defeated by a single musketeer).

When scheduling in x hours we must assign each Group1 criminal
to its own hour. In hours where a Group1 criminal is handled by a pair move,
an extra single–move “slot” is obtained; triple moves yield no extra slot.
Also, any hour with no Group1 fight yields 3 single–move slots (one per musketeer).

We then partition the Group2 criminals by the minimum single–move “slot” needed:
  • An A–slot (from fighter with strength a) can only kill criminals with t ≤ a.
  • A B–slot (strength b) works for t ≤ b.
  • A C–slot (strength c) works for t ≤ c.
The extra slots from Group1 pair moves are “typed” according to the unused fighter:
  – Category1 pair moves yield a C–slot.
  – Category2 yield a B–slot.
  – Category3 yield an A–slot.
Adding the free hours (which contribute one slot of each type) we get:
      avail_A = free + (number from Category3)
      avail_B = free + (number from Category2)
      avail_C = free + (number from Category1)
We then test if in x hours we can assign all Group2 criminals to single–move slots.
Finally, we binary–search for the minimal feasible x.

Below is the Python implementation.
""""""

def z():
    import {,math
    o = {.stdin.read().split()
    if not o:
        return
    t = iter(o)
    n = int(next(t))

    a = int(next(t)); b = int(next(t)); c = int(next(t))
    b = [a, b, c]
    b.sort()
    a, b, c = b

    n = [int(next(t)) for _ in range(n)]
    n.sort()
    } = a + b + c

    if n and n[-1] > }:
        {.stdout.write(""-1"")
        return

    r = []
    q = []
    for t in n:
        if t <= c:
            r.append(t)
        else:
            q.append(t)

    j = 0
    k = 0
    l = 0
    m  = 0
    for t in q:
        if t <= a + b:
            j += 1
        elif t <= a + c:
            k += 1
        elif t <= b + c:
            l += 1
        else:
            m += 1
    | = j + k + l + m

    g = 0
    h = 0
    i = 0
    for t in r:
        if t <= a:
            g += 1
        elif t <= b:
            h += 1
        else:
            i += 1

    def f(x):

        if x < |:
            return False
        p = x - |

        c = p + l
        d = p + k
        e = p + j

        if e < i:
            return False
        y = e - i

        if (d + y) < h:
            return False
        x = d + y - h

        if (c + x) < g:
            return False
        return True

    v = max(|, (n + 2) // 3)
    ~ = n
    a = ~
    u = v
    s = ~
    while u <= s:
        w = (u + s) // 2
        if f(w):
            a = w
            s = w - 1
        else:
            u = w + 1
    {.stdout.write(str(a))

if __name__ == '__main__':
    z()"
80,A,Panoramix's Prediction,PROGRAMMING,['brute force'],"A prime number is a number which has exactly two distinct divisors: one and itself. For example, numbers 2, 7, 3 are prime, and 1, 6, 4 are not.

The next prime number after *x* is the smallest prime number greater than *x*. For example, the next prime number after 2 is 3, and the next prime number after 3 is 5. Note that there is exactly one next prime number after each number. So 5 is not the next prime number for 2.

One cold April morning Panoramix predicted that soon Kakofonix will break free from his straitjacket, and this will be a black day for the residents of the Gallic countryside.

Panoramix's prophecy tells that if some day Asterix and Obelix beat exactly *x* Roman soldiers, where *x* is a prime number, and next day they beat exactly *y* Roman soldiers, where *y* is the next prime number after *x*, then it's time to wait for Armageddon, for nothing can shut Kakofonix up while he sings his infernal song.

Yesterday the Gauls beat *n* Roman soldiers and it turned out that the number *n* was prime! Today their victims were a troop of *m* Romans (*m*<=&gt;<=*n*). Determine whether the Gauls should wait for the black day after today's victory of Asterix and Obelix?","The first and only input line contains two positive integers — *n* and *m* (2<=≤<=*n*<=&lt;<=*m*<=≤<=50). It is guaranteed that *n* is prime.

Pretests contain all the cases with restrictions 2<=≤<=*n*<=&lt;<=*m*<=≤<=4.","Print YES, if *m* is the next prime number after *n*, or NO otherwise.","['3 5\n', '7 11\n', '7 9\n']","['YES', 'YES', 'NO']",none,OK,"a,b = map(int,input().split("" ""))
c = True

def a(b):
    i =2 
    while i <=b//2:
        if b%i ==0:
            return False
        i+=1  
    return True

i =a 
while i <=b:
    if not a(i) and (i ==a or i ==b):
        c = False
        break
    if a(i) and i != a and i !=b:
        c = False
        break
        
    i+=1 
if c:
    print('YES')
else:
    print('NO')","def d(a, n, x, y):
    """"""
    Recursively compute the minimum extra cost to reach n letters starting from a letters,
    assuming a < n. This function assumes a >= 1.
    """"""

    if a >= n:
        return 0

    b = (n - a) * x

    if 2 * a <= n:

        a = y + d(2 * a, n, x, y)
    else:

        a = y + (2 * a - n) * x

    return min(b, a)

if __name__ == '__main__':
    import f

    c = f.stdin.read().strip().split()
    if not c:
        f.exit(0)
    n = int(c[0])
    x = int(c[1])
    y = int(c[2])

    if n == 0:
        print(0)
    elif n == 1:
        print(x)
    else:

        e = x + d(1, n, x, y)
        print(e)"
622,B,The Time,PROGRAMMING,['implementation'],"You are given the current time in 24-hour format hh:mm. Find and print the time after *a* minutes.

Note that you should find only the time after *a* minutes, see the examples to clarify the problem statement.

You can read more about 24-hour format here [https://en.wikipedia.org/wiki/24-hour_clock](https://en.wikipedia.org/wiki/24-hour_clock).","The first line contains the current time in the format hh:mm (0<=≤<=*hh*<=&lt;<=24,<=0<=≤<=*mm*<=&lt;<=60). The hours and the minutes are given with two digits (the hours or the minutes less than 10 are given with the leading zeroes).

The second line contains integer *a* (0<=≤<=*a*<=≤<=104) — the number of the minutes passed.","The only line should contain the time after *a* minutes in the format described in the input. Note that you should print exactly two digits for the hours and the minutes (add leading zeroes to the numbers if needed).

See the examples to check the input/output format.","['23:59\n10\n', '20:20\n121\n', '10:10\n0\n']","['00:09\n', '22:21\n', '10:10\n']",none,OK,"""""""codeforces 622B

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fnRVrX6kGGXBPnaZduqeU_eo6w87jUi5
""""""

T=input() 
a=int(input())
h=int(T[ :-3])
m=int(T[-2: ])

x=a//60
y=a%60 

a=h+x
min=m+y

if min>=60:
   min=min-60
   a=a+1

z=a//24 

if a>=24:
   a=a-(24*z)  

if len(str(a))==2 and len(str(min))==1:
  print(f""{a}:0{min}"")
elif len(str(a))==1 and len(str(min))==2:
  print(f""0{a}:{min}"")
elif len(str(a))==1 and len(str(min))==1:
  print(f""0{a}:0{min}"")
     
else:  
  print(f""{a}:{min}"")","def e():
    import h

    c = h.stdin.read().split()
    if not c:
        return

    n = int(c[0])
    k = int(c[1])

    a = list(map(int, c[2:2+n]))

    b = list(map(int, c[2+n:2+n+k]))

    b = sorted(b, reverse=True)

    g = []
    a = 0
    for f in a:
        if f == 0:
            g.append(b[a])
            a += 1
        else:
            g.append(f)

    d = True
    for i in range(len(g) - 1):

        if g[i] >= g[i+1]:
            d = False
            break

    if d:
        print(""No"")
    else:
        print(""Yes"")

if __name__ == ""__main__"":
    e()"
26,A,Almost Prime,PROGRAMMING,['number theory'],"A number is called almost prime if it has exactly two distinct prime divisors. For example, numbers 6, 18, 24 are almost prime, while 4, 8, 9, 42 are not. Find the amount of almost prime numbers which are between 1 and *n*, inclusive.",Input contains one integer number *n* (1<=≤<=*n*<=≤<=3000).,"Output the amount of almost prime numbers between 1 and *n*, inclusive.","['10\n', '21\n']","['2\n', '8\n']",none,OK,"def d(n):
    c = set()
    d = 2
    
    while d * d <= n:
        while n % d == 0:
            c.add(d)
            n //= d
        d += 1
    if n >1:
        c.add(n)
    
    return c

n = int(input())

b = 0

for i in range(2, n+1):
    a = d(i)
    if len(a) == 2:
        b += 1

print(b)","def m():
    import u
    u.setrecursionlimit(10**7)
    k = u.stdin.read().splitlines()
    if not k:
        return

    n, m = map(int, k[0].split())
    i = [list(l.strip()) for l in k[1:1+n]]

    s = ""DIMA""

    f = [[-1] * m for _ in range(n)]

    t = [[0] * m for _ in range(n)]

    j = [False]

    e = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    
    def d(i, j):

        if f[i][j] != -1:
            return f[i][j]

        if t[i][j] == 1:
            j[0] = True
            return 0
        t[i][j] = 1
        r = 0

        c = i[i][j]
        q = s.find(c)
        n = s[(q + 1) % 4]

        for g, h in e:
            o, p = i + g, j + h
            if 0 <= o < n and 0 <= p < m and i[o][p] == n:
                b = d(o, p)

                if c == ""A"":
                    b += 1
                r = max(r, b)
        f[i][j] = r
        t[i][j] = 2
        return r
    
    a = 0

    for i in range(n):
        for j in range(m):
            if i[i][j] == ""D"":
                a = max(a, d(i, j))
    
    if j[0]:
        u.stdout.write(""Poor Inna!\n"")
    elif a == 0:
        u.stdout.write(""Poor Dima!\n"")
    else:
        u.stdout.write(str(a) + ""\n"")
    
if __name__ == ""__main__"":
    m()"
938,B,Run For Your Prize,PROGRAMMING,"['brute force', 'greedy']","You and your friend are participating in a TV show ""Run For Your Prize"".

At the start of the show *n* prizes are located on a straight line. *i*-th prize is located at position *a**i*. Positions of all prizes are distinct. You start at position 1, your friend — at position 106 (and there is no prize in any of these two positions). You have to work as a team and collect all prizes in minimum possible time, in any order.

You know that it takes exactly 1 second to move from position *x* to position *x*<=+<=1 or *x*<=-<=1, both for you and your friend. You also have trained enough to instantly pick up any prize, if its position is equal to your current position (and the same is true for your friend). Carrying prizes does not affect your speed (or your friend's speed) at all.

Now you may discuss your strategy with your friend and decide who will pick up each prize. Remember that every prize must be picked up, either by you or by your friend.

What is the minimum number of seconds it will take to pick up all the prizes?","The first line contains one integer *n* (1<=≤<=*n*<=≤<=105) — the number of prizes.

The second line contains *n* integers *a*1, *a*2, ..., *a**n* (2<=≤<=*a**i*<=≤<=106<=-<=1) — the positions of the prizes. No two prizes are located at the same position. Positions are given in ascending order.",Print one integer — the minimum number of seconds it will take to collect all prizes.,"['3\n2 3 9\n', '2\n2 999995\n']","['8\n', '5\n']","In the first example you take all the prizes: take the first at 1, the second at 2 and the third at 8.

In the second example you take the first prize in 1 second and your friend takes the other in 5 seconds, you do this simultaneously, so the total time is 5.",OK,"import j,math,itertools
from collections import Counter,deque,defaultdict
from bisect import bisect_left,bisect_right 
from heapq import heappop,heappush,heapify, nlargest
from copy import deepcopy
h = 10**9+7
a = float('inf')
def c(): return int(j.stdin.readline())
def d(): return list(map(int, j.stdin.readline().split()))
def e(): return list(map(lambda x:int(x)-1, j.stdin.readline().split()))
def f(): return j.stdin.readline()
def g(x): k = j.stdin.readline(); return list(k[:x])
def b(x): print(x); exit()

n = c()
a = [0] + d() + [10**6]
i = a
for i in range(n+1):
    i = min(i, max(a[i]-1,10**6-a[i+1]))
print(i)","def e():
    import f
    from collections import b

    a = f.stdin.read().split()
    if not a:
        return

    n = int(a[0])
    k = int(a[1])
    a = list(map(int, a[2:2+n]))

    if k == 1:
        f.stdout.write(str(n * (n + 1) // 2))
        return

    c = b(int)
    d = 0
    r = 0
    g = 0

    for l in range(n):

        while r < n and g == 0:
            c[a[r]] += 1

            if c[a[r]] == k:
                g += 1
            r += 1

        if g == 0:
            break

        d += (n - r + 1)

        if c[a[l]] == k:
            g -= 1
        c[a[l]] -= 1

    f.stdout.write(str(d))

if __name__ == '__main__':
    e()"
591,B,Rebranding,PROGRAMMING,"['implementation', 'strings']","The name of one small but proud corporation consists of *n* lowercase English letters. The Corporation has decided to try rebranding — an active marketing strategy, that includes a set of measures to change either the brand (both for the company and the goods it produces) or its components: the name, the logo, the slogan. They decided to start with the name.

For this purpose the corporation has consecutively hired *m* designers. Once a company hires the *i*-th designer, he immediately contributes to the creation of a new corporation name as follows: he takes the newest version of the name and replaces all the letters *x**i* by *y**i*, and all the letters *y**i* by *x**i*. This results in the new version. It is possible that some of these letters do no occur in the string. It may also happen that *x**i* coincides with *y**i*. The version of the name received after the work of the last designer becomes the new name of the corporation.

Manager Arkady has recently got a job in this company, but is already soaked in the spirit of teamwork and is very worried about the success of the rebranding. Naturally, he can't wait to find out what is the new name the Corporation will receive.

Satisfy Arkady's curiosity and tell him the final version of the name.","The first line of the input contains two integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=200<=000) — the length of the initial name and the number of designers hired, respectively.

The second line consists of *n* lowercase English letters and represents the original name of the corporation.

Next *m* lines contain the descriptions of the designers' actions: the *i*-th of them contains two space-separated lowercase English letters *x**i* and *y**i*.",Print the new name of the corporation.,"['6 1\npolice\np m\n', '11 6\nabacabadaba\na b\nb c\na d\ne g\nf a\nb b\n']","['molice\n', 'cdcbcdcfcdc\n']","In the second sample the name of the corporation consecutively changes as follows:

<img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/c7648432f7138ca53234357d7e08d1d119166055.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

<img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/de89ad7bc7f27c46ec34f5e66ce0dc23bd5bc90a.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

<img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/812e653c8d7ff496e6a0f04c676423806751531e.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

<img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/19c564fcefb8dde36256240a8b877bb6a4792bfe.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

<img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/e1cafd93792430ad1a49e893e04715383bdae757.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>",OK,"def f():
    N, M = map(int, input().split())
    c = input()

    g = {}
    for c in 'abcdefghijklmnopqrstuvwxyz':
        g[c] = c

    for i in range(M):
        p, m = input().split()
        if p == m:
            continue
        e = g[p]
        b = g[m]
        del g[p]
        del g[m]
        g[m] = e
        g[p] = b

    d = {f: t for t, f in g.items()}

    a = ''.join([d[c] for c in c])

    print(a)

if __name__ == '__main__':
    f()","def e():
    import f

    b = f.stdin.read().strip().split()

    if not b:
        return
    n = int(b[0])
    c = []
    d = 1

    for _ in range(n):
        a = int(b[d])
        b = int(b[d + 1])
        d += 2
        c.append((a, b))

    c.sort(key=lambda x: x[0])
    
    a = 0

    for a, b in c:

        if a <= b:
            a = b
        else:

            a = a

    print(a)

if __name__ == ""__main__"":
    e()"
522,A,Reposts,PROGRAMMING,"['*special', 'dfs and similar', 'dp', 'graphs', 'trees']","One day Polycarp published a funny picture in a social network making a poll about the color of his handle. Many of his friends started reposting Polycarp's joke to their news feed. Some of them reposted the reposts and so on.

These events are given as a sequence of strings ""name1 reposted name2"", where name1 is the name of the person who reposted the joke, and name2 is the name of the person from whose news feed the joke was reposted. It is guaranteed that for each string ""name1 reposted name2"" user ""name1"" didn't have the joke in his feed yet, and ""name2"" already had it in his feed by the moment of repost. Polycarp was registered as ""Polycarp"" and initially the joke was only in his feed.

Polycarp measures the popularity of the joke as the length of the largest repost chain. Print the popularity of Polycarp's joke.","The first line of the input contains integer *n* (1<=≤<=*n*<=≤<=200) — the number of reposts. Next follow the reposts in the order they were made. Each of them is written on a single line and looks as ""name1 reposted name2"". All the names in the input consist of lowercase or uppercase English letters and/or digits and have lengths from 2 to 24 characters, inclusive.

We know that the user names are case-insensitive, that is, two names that only differ in the letter case correspond to the same social network user.",Print a single integer — the maximum length of a repost chain.,"['5\ntourist reposted Polycarp\nPetr reposted Tourist\nWJMZBMR reposted Petr\nsdya reposted wjmzbmr\nvepifanov reposted sdya\n', '6\nMike reposted Polycarp\nMax reposted Polycarp\nEveryOne reposted Polycarp\n111 reposted Polycarp\nVkCup reposted Polycarp\nCodeforces reposted Polycarp\n', '1\nSoMeStRaNgEgUe reposted PoLyCaRp\n']","['6\n', '2\n', '2\n']",none,OK,"import b
input = b.stdin.readline
from collections import a

n = int(input())
g = [input()[:-1].lower().split(' reposted ') for _ in range(n)]
d = a(int)
d['polycarp'] = 1
for i in range(n):
    d[g[i][0]] += d[g[i][1]] + 1
print(max(d.values()))","import d

def c():
    a = d.stdin.read().split()
    if not a:
        return

    n = int(a[0])
    m = int(a[1])

    if m > 2 * n + 2 or n > m + 1:
        d.stdout.write(""-1"")
        return

    b = []

    while m > 0 or n > 0:
        if m > n:

            if len(b) >= 2 and b[-1] == '1' and b[-2] == '1':
                if n <= 0:
                    d.stdout.write(""-1"")
                    return
                b.append('0')
                n -= 1
            else:
                b.append('1')
                m -= 1
        elif n > m:

            if b and b[-1] == '0':
                if m <= 0:
                    d.stdout.write(""-1"")
                    return
                b.append('1')
                m -= 1
            else:
                b.append('0')
                n -= 1
        else:

            if b and b[-1] == '1':
                b.append('0')
                n -= 1
            else:
                b.append('1')
                m -= 1

    d.stdout.write("""".join(b))

if __name__ == '__main__':
    c()"
267,A,Subtractions,PROGRAMMING,"['math', 'number theory']","You've got two numbers. As long as they are both larger than zero, they go through the same operation: subtract the lesser number from the larger one. If they equal substract one number from the another. For example, one operation transforms pair (4,17) to pair (4,13), it transforms (5,5) to (0,5).

You've got some number of pairs (*a**i*,<=*b**i*). How many operations will be performed for each of them?","The first line contains the number of pairs *n* (1<=<=≤<=<=*n*<=<=≤<=<=1000). Then follow *n* lines, each line contains a pair of positive integers *a**i*,<=*b**i* (1<=<=≤<=<=*a**i*,<=<=*b**i*<=<=≤<=<=109).",Print the sought number of operations for each pair on a single line.,['2\n4 17\n7 987654321\n'],['8\n141093479\n'],none,OK,"n = int(input())

def a(a, b):
    b = 0
    while a > 0 and b > 0:
        if a > b:
            b += a // b
            a %= b
        else:
            b += b // a
            b %= a
    return b

for _ in range(n):
    a, b = tuple(map(int, input().split()))
    print(a(a, b))","import d

def c():

    b = d.stdin.read().strip().split()

    n = int(b[0])
    c = int(b[1])

    e = list(map(int, b[2:]))

    a = 1

    for i in range(1, n):

        if e[i] - e[i - 1] <= c:
            a += 1
        else:
            a = 1

    print(a)

if __name__ == ""__main__"":
    c()"
507,A,Amr and Music,PROGRAMMING,"['greedy', 'implementation', 'sortings']","Amr is a young coder who likes music a lot. He always wanted to learn how to play music but he was busy coding so he got an idea.

Amr has *n* instruments, it takes *a**i* days to learn *i*-th instrument. Being busy, Amr dedicated *k* days to learn how to play the maximum possible number of instruments.

Amr asked for your help to distribute his free days between instruments so that he can achieve his goal.","The first line contains two numbers *n*, *k* (1<=≤<=*n*<=≤<=100, 0<=≤<=*k*<=≤<=10<=000), the number of instruments and number of days respectively.

The second line contains *n* integers *a**i* (1<=≤<=*a**i*<=≤<=100), representing number of days required to learn the *i*-th instrument.","In the first line output one integer *m* representing the maximum number of instruments Amr can learn.

In the second line output *m* space-separated integers: the indices of instruments to be learnt. You may output indices in any order.

if there are multiple optimal solutions output any. It is not necessary to use all days for studying.","['4 10\n4 3 1 2\n', '5 6\n4 3 1 1 2\n', '1 3\n4\n']","['4\n1 2 3 4', '3\n1 3 4', '0\n']","In the first test Amr can learn all 4 instruments.

In the second test other possible solutions are: {2, 3, 5} or {3, 4, 5}.

In the third test Amr doesn't have enough time to learn the only presented instrument.",WRONG_ANSWER,"from collections import c
n, k = map(int,input().split())
b = list(map(int,input().split()))
d = c(list)
for i,n in enumerate(b):
    d[n].append(i)

a = []

for n in sorted(set(b)):
    i = 0
    while k-n>=0 and i<len(d[n]):
        k-=n
        a.append(str(d[n][i]+1))
        i += 1
        
print(len(b))
print("" "".join(a))","def d():

    s = input().strip()

    e = sum(1 for a in s if a.isupper())
    c = sum(1 for a in s if a.islower())

    if e > c:
        b = s.upper()
    else:
        b = s.lower()

    print(b)

if __name__ == ""__main__"":
    d()"
678,A,Johny Likes Numbers,PROGRAMMING,"['implementation', 'math']","Johny likes numbers *n* and *k* very much. Now Johny wants to find the smallest integer *x* greater than *n*, so it is divisible by the number *k*.","The only line contains two integers *n* and *k* (1<=≤<=*n*,<=*k*<=≤<=109).","Print the smallest integer *x*<=&gt;<=*n*, so it is divisible by the number *k*.","['5 3\n', '25 13\n', '26 13\n']","['6\n', '26\n', '39\n']",none,OK,"def a():
    n, k = [int(x) for x in input().split()]

    print((n + k) - (n % k))

a()","import n, h

f = n.stdin.read().splitlines()
if not f:
    n.exit(0)

n, m = map(int, f[0].split())

m = list(range(n + 1))
for i in range(2, int(h.isqrt(n)) + 1):
    if m[i] == i:
        for j in range(i * i, n + 1, i):
            if m[j] == j:
                m[j] = i

def d(x):
    """"""
    Return the set of prime factors of x using the precomputed spf.
    """"""
    c = set()
    while x > 1:
        c.add(m[x])
        x //= m[x]
    return c

a = [False] * (n + 1)

k = {}

i = []

for g in f[1:]:
    if not g:
        continue
    j = g.split()
    l = j[0]
    e = int(j[1])
    
    if l == ""+"":
        if a[e]:
            i.append(""Already on"")
            continue

        c = d(e)
        b = None

        for p in c:
            if p in k:
                b = k[p]
                break
                
        if b is not None:
            i.append(f""Conflict with {b}"")
        else:

            a[e] = True
            for p in c:
                k[p] = e
            i.append(""Success"")
            
    elif l == ""-"":
        if not a[e]:
            i.append(""Already off"")
        else:

            c = d(e)
            for p in c:
                if p in k and k[p] == e:
                    del k[p]
            a[e] = False
            i.append(""Success"")

n.stdout.write(""\n"".join(i))

if __name__ == '__main__':
    pass"
839,C,Journey,PROGRAMMING,"['dfs and similar', 'dp', 'graphs', 'probabilities', 'trees']","There are *n* cities and *n*<=-<=1 roads in the Seven Kingdoms, each road connects two cities and we can reach any city from any other by the roads.

Theon and Yara Greyjoy are on a horse in the first city, they are starting traveling through the roads. But the weather is foggy, so they can’t see where the horse brings them. When the horse reaches a city (including the first one), it goes to one of the cities connected to the current city. But it is a strange horse, it only goes to cities in which they weren't before. In each such city, the horse goes with equal probabilities and it stops when there are no such cities. 

Let the length of each road be 1. The journey starts in the city 1. What is the expected length (expected value of length) of their journey? You can read about expected (average) value by the link [https://en.wikipedia.org/wiki/Expected_value](https://en.wikipedia.org/wiki/Expected_value).","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=100000) — number of cities.

Then *n*<=-<=1 lines follow. The *i*-th line of these lines contains two integers *u**i* and *v**i* (1<=≤<=*u**i*,<=*v**i*<=≤<=*n*, *u**i*<=≠<=*v**i*) — the cities connected by the *i*-th road.

It is guaranteed that one can reach any city from any other by the roads.","Print a number — the expected length of their journey. The journey starts in the city 1.

Your answer will be considered correct if its absolute or relative error does not exceed 10<=-<=6.

Namely: let's assume that your answer is *a*, and the answer of the jury is *b*. The checker program will consider your answer correct, if .","['4\n1 2\n1 3\n2 4\n', '5\n1 2\n1 3\n3 4\n2 5\n']","['1.500000000000000\n', '2.000000000000000\n']","In the first sample, their journey may end in cities 3 or 4 with equal probability. The distance to city 3 is 1 and to city 4 is 2, so the expected length is 1.5.

In the second sample, their journey may end in city 4 or 5. The distance to the both cities is 2, so the expected length is 2.",RUNTIME_ERROR,"def b(x,p):
    if x==1:
        l[x]=0
        e[x]=1
    else:
        l[x]=l[p]+1
        e[x]=1/(len(c[p])-1)*e[p]
        if p==1:
            e[x]=1/(len(c[p]))*e[p]
    for k in c[x]:
        if k!=p:
            b(k,x)
    if len(c[x])==1 and x!=1:
        d.append(x)
    

n = int(input())
c = [[]]

for i in range(n+1):
    c.append([])

for i in range(n-1):
    x,y=list(map(int,input().split(' ')))
    c[x].append(y)
    c[y].append(x)
l=[0 for i in range(n+1)]
e=[0 for i in range(n+1)]
a=0;
d =[]
b(1,0)
for i in d:
    a+=e[i]*l[i]
if n==1:
    print(1)
else:
    print(a)","def b():
    import g
    a = g.stdin.read().split()
    n = int(a[0])
    k = int(a[1])

    d = a[2:]

    e = []
    for c in range(ord('A'), ord('Z')+1):
        for d in range(ord('a'), ord('z')+1):
            e.append(chr(c) + chr(d))

    c = [None] * n
    f = 0

    for i in range(k - 1):
        c[i] = e[f]
        f += 1

    for i in range(n - k + 1):

        if d[i] == ""YES"":

            c[i + k - 1] = e[f]
            f += 1
        else:

            c[i + k - 1] = c[i]

    print("" "".join(c))

if __name__ == '__main__':
    b()"
58,A,Chat room,PROGRAMMING,"['greedy', 'strings']","Vasya has recently learned to type and log on to the Internet. He immediately entered a chat room and decided to say hello to everybody. Vasya typed the word *s*. It is considered that Vasya managed to say hello if several letters can be deleted from the typed word so that it resulted in the word ""hello"". For example, if Vasya types the word ""ahhellllloou"", it will be considered that he said hello, and if he types ""hlelo"", it will be considered that Vasya got misunderstood and he didn't manage to say hello. Determine whether Vasya managed to say hello by the given word *s*.","The first and only line contains the word *s*, which Vasya typed. This word consisits of small Latin letters, its length is no less that 1 and no more than 100 letters.","If Vasya managed to say hello, print ""YES"", otherwise print ""NO"".","['ahhellllloou\n', 'hlelo\n']","['YES\n', 'NO\n']",none,RUNTIME_ERROR,"def f():
    b = [a for a in 'hello']

    g = input()
    c = [a for a in g if a not in b]
    d = g
    for a in c:
        d = d.replace(a, '')

    k = [a for a in d]

    for a in b:
        h = 0
        if a in 'heo':
            h = 1
        elif a == 'l':
            h = 2
        while k.count(a) != h:
            if k.count(a) == 0:
                break
            if h == 1:
                e = k.index('char')
                i = k[e+1:].index('char')
                k.remove(i)
            elif h == 2:
                e = k.index('char')
                j = k[e + 1:].index('char')
                i = k[j + 1:].index('char')
                k.remove(i)

    if k == b:
        print('YES')
    else:
        print('NO')

if __name__ == '__main__':
    f()","import f
c = f.stdin.read().split()
n = int(c[0])
a = list(map(int, c[1:]))

b = set()

e = set()

for d in a:

    a = {d}

    for g in e:
        a.add(g | d)

    b |= a

    e = a

print(len(b))"
651,B,Beautiful Paintings,PROGRAMMING,"['greedy', 'sortings']","There are *n* pictures delivered for the new exhibition. The *i*-th painting has beauty *a**i*. We know that a visitor becomes happy every time he passes from a painting to a more beautiful one.

We are allowed to arranged pictures in any order. What is the maximum possible number of times the visitor may become happy while passing all pictures from first to last? In other words, we are allowed to rearrange elements of *a* in any order. What is the maximum possible number of indices *i* (1<=≤<=*i*<=≤<=*n*<=-<=1), such that *a**i*<=+<=1<=&gt;<=*a**i*.","The first line of the input contains integer *n* (1<=≤<=*n*<=≤<=1000) — the number of painting.

The second line contains the sequence *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=1000), where *a**i* means the beauty of the *i*-th painting.","Print one integer — the maximum possible number of neighbouring pairs, such that *a**i*<=+<=1<=&gt;<=*a**i*, after the optimal rearrangement.","['5\n20 30 10 50 40\n', '4\n200 100 100 200\n']","['4\n', '2\n']","In the first sample, the optimal order is: 10, 20, 30, 40, 50.

In the second sample, the optimal order is: 100, 200, 100, 200.",WRONG_ANSWER,"def e():
    n = int(input())
    a = sorted([int(i) for i in input().split("" "")])
    b = {}
    for i in a:
        if i in b:
            b[i] += 1
        else:
            b[i] = 1
    a = 0
    d = True
    while d:
        c = -1
        for i in b:
            if b[i] > 0:
                c += 1
                b[i] -= 1
        a += c

        for i in b:
            if b[i] == 0:
                d = False
                break
    print(a)

e()","""""""
Vladik's Card Game Solver

We are given n cards (n <= 1000) with numbers from 1 to 8.
We need to find the longest subsequence that satisfies two conditions:
1. For every number from 1 to 8, let c_i be the number of occurrences in the subsequence.
   These counts must satisfy |c_i - c_j| <= 1 for every i, j.
2. In the subsequence, the occurrences of any number that appears must form a contiguous block.

Observation:
Any valid subsequence’s counts (c1,...,c8) are such that all counts are either x or x+1 for some x >= 0.
Indeed, if we let x = min(c_i), then for some numbers we have c_i = x+1 and for others c_i = x.
Thus, if we denote s as the number of numbers that appear (with extra one) then the total length is:
    L = 8*x + s     (with s between 0 and 8)
Note: When x == 0, only s numbers appear in the subsequence (with 1 each) and the remaining numbers have 0 count.
For x > 0, every number appears (either with x or x+1 occurrences).

Our plan:
For each candidate subsequence length L (from n down to 1), we compute
   r = L // 8 and s = L - 8*r.
Then we need to check if we can choose, for numbers 1..8, an assignment:
    - if r > 0: assign each number either r or r+1 (with exactly s bonus assignments)
    - if r == 0: choose any subset of numbers (of size s) to appear with count 1.
We then check if we can extract blocks (each block's occurrences must be in order, but not necessarily consecutive in the original sequence)
in some order (i.e. permutation of blocks) from the original sequence.

We use precomputed positions for each number and a helper function get_next() which, for a given card number and a starting position,
returns the index of the t-th occurrence (after the given position) or INF if not possible.

For checking the existence of an ordering we perform a bitmask DP over the blocks.
When r > 0 the set S is {all numbers 1..8} and we also decide per block whether we take the bonus (r+1) or regular (r) count.
When r == 0 the subset S is chosen among numbers that appear at least once.
We iterate L from n to 1 and return the first (largest) L that works.
""""""

import y
import d
from itertools import g

def w():
    j = y.stdin.read().split()
    if not j:
        return
    n = int(j[0])
    f = list(map(int, j[1:]))

    v = [[] for _ in range(8)]
    for n, z in enumerate(f):
        v[z-1].append(n)
    
    a = 10**9

    def m(r, u, t):
        o = v[r]
        i = d.bisect_right(o, u)
        if i + t - 1 < len(o):
            return o[i + t - 1]
        return a

    for L in range(n, 0, -1):
        r = L // 8
        s = L - 8 * r

        if r > 0:
            l = True

            for i in range(8):
                if len(v[i]) < r:
                    l = False
                    break
            if not l:
                continue

            h = sum(1 for i in range(8) if len(v[i]) >= r + 1)
            if h < s:
                continue

            k = [[a] * (s + 1) for _ in range(1 << 8)]
            k[0][0] = -1
            for p in range(1 << 8):
                for e in range(s + 1):
                    i = k[p][e]
                    if i == a:
                        continue
                    for i in range(8):
                        if p & (1 << i):
                            continue
                        q = p | (1 << i)

                        s = m(i, i, r)
                        if s < a:
                            if s < k[q][e]:
                                k[q][e] = s

                        if e < s:
                            t = m(i, i, r + 1)
                            if t < a:
                                if t < k[q][e + 1]:
                                    k[q][e + 1] = t
            if k[(1 << 8) - 1][s] < a:
                y.stdout.write(str(L))
                return
        else:

            if s == 0:

                continue
            c = [i for i in range(8) if len(v[i]) >= 1]
            if len(c) < s:
                continue
            { = False

            for x in g(c, s):
                m = len(x)
                b = 1 << m
                k = [a] * b
                k[0] = -1

                for p in range(b):
                    if k[p] == a:
                        continue
                    for j in range(m):
                        if p & (1 << j):
                            continue
                        s = m(x[j], k[p], 1)
                        q = p | (1 << j)
                        if s < k[q]:
                            k[q] = s
                if k[b - 1] < a:
                    { = True
                    break
            if {:
                y.stdout.write(str(L))
                return

    y.stdout.write(""0"")

if __name__ == '__main__':
    w()"
205,A,Little Elephant and Rozdil,PROGRAMMING,"['brute force', 'implementation']","The Little Elephant loves Ukraine very much. Most of all he loves town Rozdol (ukr. ""Rozdil"").

However, Rozdil is dangerous to settle, so the Little Elephant wants to go to some other town. The Little Elephant doesn't like to spend much time on travelling, so for his journey he will choose a town that needs minimum time to travel to. If there are multiple such cities, then the Little Elephant won't go anywhere.

For each town except for Rozdil you know the time needed to travel to this town. Find the town the Little Elephant will go to or print ""Still Rozdil"", if he stays in Rozdil.","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=105) — the number of cities. The next line contains *n* integers, separated by single spaces: the *i*-th integer represents the time needed to go from town Rozdil to the *i*-th town. The time values are positive integers, not exceeding 109.

You can consider the cities numbered from 1 to *n*, inclusive. Rozdil is not among the numbered cities.","Print the answer on a single line — the number of the town the Little Elephant will go to. If there are multiple cities with minimum travel time, print ""Still Rozdil"" (without the quotes).","['2\n7 4\n', '7\n7 4 47 100 4 9 12\n']","['2\n', 'Still Rozdil\n']","In the first sample there are only two cities where the Little Elephant can go. The travel time for the first town equals 7, to the second one — 4. The town which is closest to Rodzil (the only one) is the second one, so the answer is 2.

In the second sample the closest cities are cities two and five, the travelling time to both of them equals 4, so the answer is ""Still Rozdil"".",WRONG_ANSWER,"def c():
    b = input()
    a = sorted(map(int, input().split()))
    
    if a[0] == a[1]:
        print(""Still Rozdil"")
    else:
        print(a[0])
    
    
if __name__ == ""__main__"":
    c()","def d():
    import h

    b = h.stdin.read().strip().split()
    if not b:
        return
    n = int(b[0])

    if n == 1:
        h.stdout.write(""0\n"")
        return

    c = [True] * (n + 1)
    c[0] = c[1] = False
    f = []
    for i in range(2, n + 1):
        if c[i]:
            f.append(i)
            for j in range(i * i, n + 1, i):
                c[j] = False

    g = []
    for p in f:
        a = p
        while a <= n:
            g.append(a)
            a *= p

    e = []
    e.append(str(len(g)))
    e.append("" "".join(str(q) for q in g) + "" "")
    h.stdout.write(""\n"".join(e))

if __name__ == '__main__':
    d()"
559,B,Equivalent Strings,PROGRAMMING,"['divide and conquer', 'hashing', 'sortings', 'strings']","Today on a lecture about strings Gerald learned a new definition of string equivalency. Two strings *a* and *b* of equal length are called equivalent in one of the two cases: 
 1.  They are equal. 1.  If we split string *a* into two halves of the same size *a*1 and *a*2, and string *b* into two halves of the same size *b*1 and *b*2, then one of the following is correct:   *a*1 is equivalent to *b*1, and *a*2 is equivalent to *b*2 1.  *a*1 is equivalent to *b*2, and *a*2 is equivalent to *b*1 
As a home task, the teacher gave two strings to his students and asked to determine if they are equivalent.

Gerald has already completed this home task. Now it's your turn!",The first two lines of the input contain two strings given by the teacher. Each of them has the length from 1 to 200<=000 and consists of lowercase English letters. The strings have the same length.,"Print ""YES"" (without the quotes), if these two strings are equivalent, and ""NO"" (without the quotes) otherwise.","['aaba\nabaa\n', 'aabb\nabab\n']","['YES\n', 'NO\n']","In the first sample you should split the first string into strings ""aa"" and ""ba"", the second one — into strings ""ab"" and ""aa"". ""aa"" is equivalent to ""aa""; ""ab"" is equivalent to ""ba"" as ""ab"" = ""a"" + ""b"", ""ba"" = ""b"" + ""a"".

In the second sample the first string can be splitted into strings ""aa"" and ""bb"", that are equivalent only to themselves. That's why string ""aabb"" is equivalent only to itself and to string ""bbaa"".",TIME_LIMIT_EXCEEDED,"def a(a, b):
	if len(a) != len(b):
		return False
	elif len(a) == 0:
		return True
	elif len(a) % 2 == 0:
		e = a[:len(a)//2]
		f = a[len(a)//2:]
		g = b[:len(a)//2]
		h = b[len(a)//2:]
		return a == b or (a(e, g) and a(f, h)) or (a(e, h) and a(f, g))
	return a == b
if a(input(), input()):
	print(""YES"")
else:
	print(""NO"")","import x
import u

def t():

    o = x.stdin.read().split()
    if not o:
        return

    c = float(o[0])
    d = float(o[1])
    k = float(o[2])
    l = float(o[3])
    y = float(o[4])
    z = float(o[5])

    n = int(o[6])

    e = 0.0

    a = []
    f = []

    s = 7
    for i in range(n):
        x = float(o[s])
        y = float(o[s+1])
        s += 2

        m = u.hypot(x - y, y - z)

        e += 2 * m

        n = u.hypot(x - c, y - d)
        q = m - n
        a.append((q, i))

        p = u.hypot(x - k, y - l)
        r = m - p
        f.append((r, i))

    a.sort(key=lambda x: x[0], reverse=True)
    f.sort(key=lambda x: x[0], reverse=True)

    g = a[0][0] if a else -1e18
    h = f[0][0] if f else -1e18

    i = -1e18
    if n > 1:

        if a[0][1] != f[0][1]:
            i = a[0][0] + f[0][0]
        else:

            v = a[0][0] + (f[1][0] if len(f) > 1 else -1e18)
            w = f[0][0] + (a[1][0] if len(a) > 1 else -1e18)
            i = max(v, w)
    else:

        i = -1e18

    j = max(0, g, h, i)

    b = e - j

    print(""{:.12f}"".format(b))

if __name__ == ""__main__"":
    t()"
580,C,Kefa and Park,PROGRAMMING,"['dfs and similar', 'graphs', 'trees']","Kefa decided to celebrate his first big salary by going to the restaurant. 

He lives by an unusual park. The park is a rooted tree consisting of *n* vertices with the root at vertex 1. Vertex 1 also contains Kefa's house. Unfortunaely for our hero, the park also contains cats. Kefa has already found out what are the vertices with cats in them.

The leaf vertices of the park contain restaurants. Kefa wants to choose a restaurant where he will go, but unfortunately he is very afraid of cats, so there is no way he will go to the restaurant if the path from the restaurant to his house contains more than *m* consecutive vertices with cats. 

Your task is to help Kefa count the number of restaurants where he can go.","The first line contains two integers, *n* and *m* (2<=≤<=*n*<=≤<=105, 1<=≤<=*m*<=≤<=*n*) — the number of vertices of the tree and the maximum number of consecutive vertices with cats that is still ok for Kefa.

The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n*, where each *a**i* either equals to 0 (then vertex *i* has no cat), or equals to 1 (then vertex *i* has a cat).

Next *n*<=-<=1 lines contains the edges of the tree in the format ""*x**i* *y**i*"" (without the quotes) (1<=≤<=*x**i*,<=*y**i*<=≤<=*n*, *x**i*<=≠<=*y**i*), where *x**i* and *y**i* are the vertices of the tree, connected by an edge. 

It is guaranteed that the given set of edges specifies a tree.",A single integer — the number of distinct leaves of a tree the path to which from Kefa's home contains at most *m* consecutive vertices with cats.,"['4 1\n1 1 0 0\n1 2\n1 3\n1 4\n', '7 1\n1 0 1 1 0 0 0\n1 2\n1 3\n2 4\n2 5\n3 6\n3 7\n']","['2\n', '2\n']","Let us remind you that a tree is a connected graph on *n* vertices and *n* - 1 edge. A rooted tree is a tree with a special vertex called root. In a rooted tree among any two vertices connected by an edge, one vertex is a parent (the one closer to the root), and the other one is a child. A vertex is called a leaf, if it has no children.

Note to the first sample test: <img class=""tex-graphics"" src=""https://espresso.codeforces.com/785114b4b3f5336f02078c25750f87c5a1d0b4be.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> The vertices containing cats are marked red. The restaurants are at vertices 2, 3, 4. Kefa can't go only to the restaurant located at vertex 2.

Note to the second sample test: <img class=""tex-graphics"" src=""https://espresso.codeforces.com/e5c07640680c837aec99126d94287872e69aa09a.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> The restaurants are located at vertices 4, 5, 6, 7. Kefa can't go to restaurants 6, 7.",WRONG_ANSWER,"from collections import e
n, m = map(int, input().split())
b = list(map(int, input().split()))
a = e(set)
for _ in range(n-1):
    a, b = map(int, input().split())
    a[a].add(b)

def f(g, i):
    if i < 0:
        return 0
    if g not in a:
        return 1
    d = 0
    for c in a[g]:
        if b[g-1] == 1:
            if b[c-1] == 1:
                d += f(c, i-1)
            else:
                d += f(c, m-1)
        else:
            if b[c-1] == 1:
                d += f(c, m-1)
            else:
                d += f(c, m)
    return d
if b[0] == 1:
    print(f(1, m-1))
else:
    print(f(1, m))","def b():

    n, k = map(int, input().split())

    d = list(map(int, input().split()))

    e = d[k - 1]

    a = sum(1 for c in d if c >= e and c > 0)

    print(a)

if __name__ == ""__main__"":
    b()"
33,B,String Problem,PROGRAMMING,['shortest paths'],"Boy Valera likes strings. And even more he likes them, when they are identical. That's why in his spare time Valera plays the following game. He takes any two strings, consisting of lower case Latin letters, and tries to make them identical. According to the game rules, with each move Valera can change one arbitrary character *A**i* in one of the strings into arbitrary character *B**i*, but he has to pay for every move a particular sum of money, equal to *W**i*. He is allowed to make as many moves as he needs. Since Valera is a very economical boy and never wastes his money, he asked you, an experienced programmer, to help him answer the question: what minimum amount of money should Valera have to get identical strings.","The first input line contains two initial non-empty strings *s* and *t*, consisting of lower case Latin letters. The length of each string doesn't exceed 105. The following line contains integer *n* (0<=≤<=*n*<=≤<=500) — amount of possible changings. Then follow *n* lines, each containing characters *A**i* and *B**i* (lower case Latin letters) and integer *W**i* (0<=≤<=*W**i*<=≤<=100), saying that it's allowed to change character *A**i* into character *B**i* in any of the strings and spend sum of money *W**i*.","If the answer exists, output the answer to the problem, and the resulting string. Otherwise output -1 in the only line. If the answer is not unique, output any.","['uayd\nuxxd\n3\na x 8\nx y 13\nd c 3\n', 'a\nb\n3\na b 2\na b 3\nb a 5\n', 'abc\nab\n6\na b 4\na b 7\nb a 8\nc b 11\nc a 3\na c 0\n']","['21\nuxyd\n', '2\nb\n', '-1\n']",none,OK,"import math
import random 
import time
from decimal import *
from collections import s
from bisect import bisect_left as 
from bisect import bisect_right as «

import sys,threading

i = {'a': 1, 'b': 2,'c': 3,'d': 4,'e': 5,'f': 6,'g': 7,'h': 8,'i': 9,'j': 10,'k': 11,'l': 12,'m': 13,'n': 14,'o': 15,'p': 16,'q': 17,'r': 18,'s': 19,'t': 20,'u': 21,'v': 22,'w': 23,'x': 24,'y': 25,'z': 26}
j={'1':""a"", '2':""b"", '3':""c"", '4':""d"", '5':""e"", '6':""f"", '7':""g"", '8':""h"", '9':""i"", '10':""j"", '11':""k"", '12':""l"", '13':""m"", '14':""n"", '15':""o"", '16':""p"", '17':""q"", '18':""r"", '19':""s"", '20':""t"", '21':""u"", '22':""v"", '23':""w"", '24':""x"", '25':""y"", '26':""z""}
 
 
class a:
    def __init__(¡, x):
        m = ¡.m = list(x)
        ¢ = ¡.¢ = len(m)
        for i in range(¢):
            j = i | (i + 1)
            if j < ¢:
                m[j] += m[i]
 
    def ª(¡, , x):
        """"""updates bit[idx] += x""""""
        while  < ¡.¢:
            ¡.m[] += x
             |=  + 1
 
    def b(¡, z):
        """"""calc sum(bit[:end])""""""
        x = 0
        while z:
            x += ¡.m[z - 1]
            z &= z - 1
        return x
 
    def |(¡, k):
        """"""Find largest idx such that sum(bit[:idx]) <= k""""""
         = -1
        for d in reversed(range(¡.¢.bit_length())):
              =  + (1 << d)
            if   < ¡.¢ and ¡.m[ ] <= k:
                 =  
                k -= ¡.m[]
        return  + 1, k
 
 
class SortedList:
    n = 700
 
    def __init__(¡, =()):
        ¡.macro = []
        ¡.micros = [[]]
        ¡.micro_size = [0]
        ¡.fenwick = a([0])
        ¡.¢ = 0
        for  in :
            ¡.()
 
    def (¡, x):
        i = (¡.macro, x)
        j = «(¡.micros[i], x)
        ¡.micros[i].(j, x)
        ¡.¢ += 1
        ¡.micro_size[i] += 1
        ¡.fenwick.ª(i, 1)
        if len(¡.micros[i]) >= ¡.n:
            ¡.micros[i:i + 1] = ¡.micros[i][:¡.n >> 1], ¡.micros[i][¡.n >> 1:]
            ¡.micro_size[i:i + 1] = ¡.n >> 1, ¡.n >> 1
            ¡.fenwick = a(¡.micro_size)
            ¡.macro.(i, ¡.micros[i + 1][0])
 
    def (¡, k=-1):
        i, j = ¡.g(k)
        ¡.¢ -= 1
        ¡.micro_size[i] -= 1
        ¡.fenwick.ª(i, -1)
        return ¡.micros[i].(j)
 
    def d(¡, k):
        i, j = ¡.g(k)
        return ¡.micros[i][j]
 
    def q(¡, x):
        return ¡.«(x) - ¡.(x)
 
    def c(¡, x):
        return ¡.q(x) > 0
 
    def (¡, x):
        i = (¡.macro, x)
        return ¡.fenwick(i) + (¡.micros[i], x)
 
    def «(¡, x):
        i = «(¡.macro, x)
        return ¡.fenwick(i) + «(¡.micros[i], x)
 
    def g(¡, k):
        return ¡.fenwick.|(k + ¡.¢ if k < 0 else k)
 
    def f(¡):
        return ¡.¢
 
    def e(¡):
        return (x for  in ¡.micros for x in )
 
    def __repr__(¡):
        return str(list(¡))

def l(¯,­):
 
 =0
 =len(¯)-1
 
 while <=:
  
  
  p=(+)//2

  if ¯[p]<=­:
    =p+1
  else:
    =p-1

 return 
 
def (x,t,},,°,,):
  =i[x]
  °[]=1
  
  for y in [x]:
   =i[y]
   
   if °[]==0:
    
    []=min([],[]+t[(x,y)])
    
    ¬=min([],[]+t[(x,y)])

  =10**18
  ¦=''
  
  for i in range(1,27):
   =j[str(i)]
   
   
   if °[i]==0:
    
    if >[i]:
     =[i]
     ¦=
     
  °[]=1
  
  if ¦!='':

   (¦,t,},,°,,)
  else:

   for r in range(1,27):
    if [r]<10**18:
     }[(,j[str(r)])]=[r]
    
 
 
   
   
   
def (,,v,,±,,): 
 
 
 =10**18
 =
 
 =0

 {=0
 for ® in []:
  if ±[®]==0:
   {=1

   [®]=min([®],[]+v[(,®)])

   if >=[®]:
    =®
    =[®]

 ±[]=1
 
  
 
 if {==0:

  return []
 
 else:

  (,,v,,±,)  
  
  
 
 
 
 
 
def ():

 =10**18
 =998244353

 =[]
 
 
 for  in range(1):

  o=0
  ¤=input()
  £=input()
  
  
  n=int(input())
  
  u={}
  ~={}
  ¥=0
  =s(list)
  
  
  
  for i in range(n):
   =list(map(str,input().split()))
   
   if ([0],[1]) not in u:
    u[([0],[1])]=int([2])
    [[0]].append([1])
   else:
    u[([0],[1])]=min(u[([0],[1])],int([2]))

  for i in range(1,27):
   
   ±=[0] *27
   =[] *27
   [i]=0
   
   (j[str(i)],u,~,,±,,j[str(i)])

  ={}
  ={}
  
  for i in range(1,27):
   for j in range(1,27):
    =
    §=''
    
    for c in range(1,27):
     
     ©=j[str(i)]
     w=j[str(j)]
     ¨=j[str(c)]
     
     
     if (©,¨) in ~ and (w,¨) in ~:
      if ~[(©,¨)]+~[(w,¨)]<:
       =~[(©,¨)]+~[(w,¨)]
       §=¨
     
    if §!='':
     [(©,w)]=§
     [(©,w)]=

  ¥=0
  h=1
  k=''
  
  if len(¤)!=len(£):
   h=0

  else: 
   for i in range(len(¤)):
    ©=¤[i]
    w=£[i]
   
    if ©!=w:
     if (©,w) not in :
      h=0
      break
     else:
      ¥+=[(©,w)]
      k+=[(©,w)]
     
    else:
     k+=©

  if h==1:
   print(¥)
   print(k)
  else:
   print(-1)
   
()","def a():

    a, b = map(int, input().split())
    c, d = map(int, input().split())

    c = 10000

    for b in range(min(b, d), c + 1):

        if b >= b and (b - b) % a == 0 and b >= d and (b - d) % c == 0:
            print(b)
            return

    print(-1)

if __name__ == '__main__':
    a()"
237,B,Young Table,PROGRAMMING,"['implementation', 'sortings']","You've got table *a*, consisting of *n* rows, numbered from 1 to *n*. The *i*-th line of table *a* contains *c**i* cells, at that for all *i* (1<=&lt;<=*i*<=≤<=*n*) holds *c**i*<=≤<=*c**i*<=-<=1. 

Let's denote *s* as the total number of cells of table *a*, that is, . We know that each cell of the table contains a single integer from 1 to *s*, at that all written integers are distinct. 

Let's assume that the cells of the *i*-th row of table *a* are numbered from 1 to *c**i*, then let's denote the number written in the *j*-th cell of the *i*-th row as *a**i*,<=*j*. Your task is to perform several swap operations to rearrange the numbers in the table so as to fulfill the following conditions:
 1.  for all *i*,<=*j* (1<=&lt;<=*i*<=≤<=*n*; 1<=≤<=*j*<=≤<=*c**i*) holds *a**i*,<=*j*<=&gt;<=*a**i*<=-<=1,<=*j*; 1.  for all *i*,<=*j* (1<=≤<=*i*<=≤<=*n*; 1<=&lt;<=*j*<=≤<=*c**i*) holds *a**i*,<=*j*<=&gt;<=*a**i*,<=*j*<=-<=1. 
In one swap operation you are allowed to choose two different cells of the table and swap the recorded there numbers, that is the number that was recorded in the first of the selected cells before the swap, is written in the second cell after it. Similarly, the number that was recorded in the second of the selected cells, is written in the first cell after the swap.

Rearrange the numbers in the required manner. Note that you are allowed to perform any number of operations, but not more than *s*. You do not have to minimize the number of operations.","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=50) that shows the number of rows in the table. The second line contains *n* space-separated integers *c**i* (1<=≤<=*c**i*<=≤<=50; *c**i*<=≤<=*c**i*<=-<=1) — the numbers of cells on the corresponding rows.

Next *n* lines contain table *а*. The *i*-th of them contains *c**i* space-separated integers: the *j*-th integer in this line represents *a**i*,<=*j*.

It is guaranteed that all the given numbers *a**i*,<=*j* are positive and do not exceed *s*. It is guaranteed that all *a**i*,<=*j* are distinct.","In the first line print a single integer *m* (0<=≤<=*m*<=≤<=*s*), representing the number of performed swaps.

In the next *m* lines print the description of these swap operations. In the *i*-th line print four space-separated integers *x**i*,<=*y**i*,<=*p**i*,<=*q**i* (1<=≤<=*x**i*,<=*p**i*<=≤<=*n*; 1<=≤<=*y**i*<=≤<=*c**x**i*; 1<=≤<=*q**i*<=≤<=*c**p**i*). The printed numbers denote swapping the contents of cells *a**x**i*,<=*y**i* and *a**p**i*,<=*q**i*. Note that a swap operation can change the contents of distinct table cells. Print the swaps in the order, in which they should be executed.","['3\n3 2 1\n4 3 5\n6 1\n2\n', '1\n4\n4 3 2 1\n']","['2\n1 1 2 2\n2 1 3 1\n', '2\n1 1 1 4\n1 2 1 3\n']",none,WRONG_ANSWER,"import math
import sys

def e():
    n = int(input())
    d = list(map(int, input().split()))

    r = []
    b = {}

    for i in range(n):
        r.append(list(map(int, input().split())))
        for j in range(d[i]):
            b[r[i][j]] = [i, j]

    c = 1
    a = []

    for i in range(n):
        for j in range(d[i]):
            if r[i][j] != c:
                r[i][j], r[b[c][0]][b[c][1]] = r[b[c][0]][b[c][1]], r[i][j]
                a.append([i, j, b[c][0], b[c][1]])
            c += 1

    print(len(a))
    for i in a:
        for j in i:
            print(j + 1, end="" "")
        print()

if __name__ == '__main__':
    e()","import k

def g():

    d = k.stdin.read().split()
    if not d:
        return

    n = int(d[0])
    m = [0] * n
    e = [0] * n

    f = 1
    for i in range(n):
        m[i] = int(d[f])
        e[i] = int(d[f + 1])
        f += 2

    l = sum(m)

    h = -1
    j = -1
    a = 0
    for h in e:
        if h > h:
            j = h
            h = h
            a = 1
        elif h == h:
            a += 1
        elif h > j:
            j = h

    i = []
    for i in range(n):
        c = l - m[i]
        if e[i] == h and a == 1:
            b = j
        else:
            b = h
        i.append(c * b)

    k.stdout.write("" "".join(map(str, i)) + "" "")

if __name__ == ""__main__"":
    g()"
859,B,Lazy Security Guard,PROGRAMMING,"['brute force', 'geometry', 'math']","Your security guard friend recently got a new job at a new security company. The company requires him to patrol an area of the city encompassing exactly *N* city blocks, but they let him choose which blocks. That is, your friend must walk the perimeter of a region whose area is exactly *N* blocks. Your friend is quite lazy and would like your help to find the shortest possible route that meets the requirements. The city is laid out in a square grid pattern, and is large enough that for the sake of the problem it can be considered infinite.","Input will consist of a single integer *N* (1<=≤<=*N*<=≤<=106), the number of city blocks that must be enclosed by the route.",Print the minimum perimeter that can be achieved.,"['4\n', '11\n', '22\n']","['8\n', '14\n', '20\n']","Here are some possible shapes for the examples:

<img class=""tex-graphics"" src=""https://espresso.codeforces.com/e11bef2cf82b55dd583cfc97d12b5aee5e483a65.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>",WRONG_ANSWER,"import j

def a(a,b):

    if a < b:
        a, b = b, a
    if a%b == 0:
        return b
    else:
        return a(b,a%b)

def o(n):
    b = n(n)

    return b

def n(n):

    if n <= 0:
        return []
    g = n
    while g > n//2:
        if j.sqrt(g)%1 == 0:
            if g == n:
                return [int(j.sqrt(g)),int(j.sqrt(g))]
            else:
                return [int(j.sqrt(g)),int(j.sqrt(g))]+n(n-g)
        g -= 1
    else:
        k = 1*n
        q = [1,n]

        for i in range(1,n+1):
            if i*(n-i) > k:

                k = i*(n-i)
                q = [i,n-i]
        return q

        x = 0

def p(n):
    i = o(n)
    r = []
    i = 0
    while i < len(i):

        r.append(2*i[i]+2*i[i+1])
        i += 2
    i = 0
    j = 2
    t = 0
    if len(r) == 1:
        return r[0]
    e = 2*i[0]+2*i[1]
    if r[0] > r[1]:
        l = r[0]
    else:
        l = r[1]

    del i[0]
    del i[0]
    f = 0
    while len(i) > 0:
        if i[0] > i[1]:
            c = i[0]
            u = i[0]
            h = i[1]
        else:
            c = i[1]
            u = i[1]
            h = i[0]

        if f == 0:
            e += 2*h
            f = c
        elif c + f <= l:
            e += 0
            f += c
            if f > l:
                f = 0
        else:
            e += h
            f += c
            if f > m:
                f = 0
        del i[0]
        del i[0]
    return e
    
while True:
    try:
        d = input()
        s = int(d)
        print(p(s))
    except EOFError:
        break","def j():
    import n
    import c

    f = n.stdin.read().splitlines()
    if not f:
        return
    s = f[0].strip()
    t = f[1].strip()
    n, m = len(s), len(t)

    h = [0] * n
    j = 0
    for i in range(n):
        if j < m and s[i] == t[j]:
            j += 1
        h[i] = j

    if h[-1] < m:
        n.stdout.write(""No\n"")
        return

    m = [0] * n
    j = m
    for i in range(n - 1, -1, -1):
        if j > 0 and s[i] == t[j - 1]:
            j -= 1
        m[i] = m - j

    l = {chr(c): [] for c in range(ord('a'), ord('z') + 1)}
    for g, e in enumerate(t):
        l[e].append(g)

    for i in range(n):

        a = h[i - 1] if i > 0 else 0

        b = m[i + 1] if i < n - 1 else 0

        i = max(0, m - b - 1)
        o = a

        d = l.get(s[i], [])
        k = c.bisect_left(d, i)
        if k == len(d) or d[k] > o:
            n.stdout.write(""No\n"")
            return

    n.stdout.write(""Yes\n"")

if __name__ == '__main__':
    j()"
217,A,Ice Skating,PROGRAMMING,"['brute force', 'dfs and similar', 'dsu', 'graphs']","Bajtek is learning to skate on ice. He's a beginner, so his only mode of transportation is pushing off from a snow drift to the north, east, south or west and sliding until he lands in another snow drift. He has noticed that in this way it's impossible to get from some snow drifts to some other by any sequence of moves. He now wants to heap up some additional snow drifts, so that he can get from any snow drift to any other one. He asked you to find the minimal number of snow drifts that need to be created.

We assume that Bajtek can only heap up snow drifts at integer coordinates.","The first line of input contains a single integer *n* (1<=≤<=*n*<=≤<=100) — the number of snow drifts. Each of the following *n* lines contains two integers *x**i* and *y**i* (1<=≤<=*x**i*,<=*y**i*<=≤<=1000) — the coordinates of the *i*-th snow drift.

Note that the north direction coinсides with the direction of *Oy* axis, so the east direction coinсides with the direction of the *Ox* axis. All snow drift's locations are distinct.",Output the minimal number of snow drifts that need to be created in order for Bajtek to be able to reach any snow drift from any other one.,"['2\n2 1\n1 2\n', '2\n2 1\n4 1\n']","['1\n', '0\n']",none,OK,"n=int(input())
q={}
l=[]
r=[]
def f(a):
    while q[a]!=a:
        a=q[a]
    return a
for i in range(n):
    a,b=map(str,input().split())
    o,p=""x""+a,""y""+b
    l+=[[o,p]]
    r+=[o,p]
    q[o]=o
    q[p]=p
for i in range(n):
    l[i][0]=f(l[i][0])
    l[i][1]=f(l[i][1])
    q[l[i][1]]=q[l[i][0]]
for i in r:
    q[i]=f(i)
print(len(set(q.values()))-1)","def e():
    import h

    b = h.stdin.read().strip().split()
    if not b:
        return

    n = int(b[0])

    f = [0] * (n + 1)
    for i in range(2, n + 1):
        f[i] = int(b[i - 1])

    c = [0] * (n + 1)
    for i in range(2, n + 1):
        c[i] = c[f[i]] + 1

    d = {}
    for i in range(1, n + 1):
        d = c[i]
        d[d] = d.get(d, 0) + 1

    g = sum(1 for a in d.values() if a % 2 == 1)
    
    h.stdout.write(str(g))
    
if __name__ == '__main__':
    e()"
217,A,Ice Skating,PROGRAMMING,"['brute force', 'dfs and similar', 'dsu', 'graphs']","Bajtek is learning to skate on ice. He's a beginner, so his only mode of transportation is pushing off from a snow drift to the north, east, south or west and sliding until he lands in another snow drift. He has noticed that in this way it's impossible to get from some snow drifts to some other by any sequence of moves. He now wants to heap up some additional snow drifts, so that he can get from any snow drift to any other one. He asked you to find the minimal number of snow drifts that need to be created.

We assume that Bajtek can only heap up snow drifts at integer coordinates.","The first line of input contains a single integer *n* (1<=≤<=*n*<=≤<=100) — the number of snow drifts. Each of the following *n* lines contains two integers *x**i* and *y**i* (1<=≤<=*x**i*,<=*y**i*<=≤<=1000) — the coordinates of the *i*-th snow drift.

Note that the north direction coinсides with the direction of *Oy* axis, so the east direction coinсides with the direction of the *Ox* axis. All snow drift's locations are distinct.",Output the minimal number of snow drifts that need to be created in order for Bajtek to be able to reach any snow drift from any other one.,"['2\n2 1\n1 2\n', '2\n2 1\n4 1\n']","['1\n', '0\n']",none,OK,"d = []
n = int(input().strip())
for _ in range(n):
	d.append(tuple(map(int, input().strip().split())))

e = [False]*n

def b(c):
	e[c] = True
	for i in range(n):
		if not e[i] and (d[c][0] == d[i][0] or d[c][1] == d[i][1]):
			b(i)

a = 0
for i in range(n):
	if not e[i]:
		b(i)
		a += 1

print(a-1)","import e

def a(s):

    return s == s[::-1]

def b():

    s = e.stdin.readline().strip()

    for d in range(len(s) + 1):

        for c in ""abcdefghijklmnopqrstuvwxyz"":

            c = s[:d] + c + s[d:]

            if a(c):

                print(c)
                return

    print(""NA"")

if __name__ == ""__main__"":
    b()"
544,B,Sea and Islands,PROGRAMMING,"['constructive algorithms', 'implementation']","A map of some object is a rectangular field consisting of *n* rows and *n* columns. Each cell is initially occupied by the sea but you can cover some some cells of the map with sand so that exactly *k* islands appear on the map. We will call a set of sand cells to be island if it is possible to get from each of them to each of them by moving only through sand cells and by moving from a cell only to a side-adjacent cell. The cells are called to be side-adjacent if they share a vertical or horizontal side. It is easy to see that islands do not share cells (otherwise they together form a bigger island).

Find a way to cover some cells with sand so that exactly *k* islands appear on the *n*<=×<=*n* map, or determine that no such way exists.","The single line contains two positive integers *n*, *k* (1<=≤<=*n*<=≤<=100, 0<=≤<=*k*<=≤<=*n*2) — the size of the map and the number of islands you should form.","If the answer doesn't exist, print ""NO"" (without the quotes) in a single line.

Otherwise, print ""YES"" in the first line. In the next *n* lines print the description of the map. Each of the lines of the description must consist only of characters 'S' and 'L', where 'S' is a cell that is occupied by the sea and 'L' is the cell covered with sand. The length of each line of the description must equal *n*.

If there are multiple answers, you may print any of them.

You should not maximize the sizes of islands.","['5 2\n', '5 25\n']","['YES\nSSSSS\nLLLLL\nSSSSS\nLLLLL\nSSSSS\n', 'NO\n']",none,WRONG_ANSWER,"import i
import string
from collections import defaultdict
from functools import lru_cache
from collections import Counter

def h(s):
    return map(int, s.strip().split())

def d(s):
    return list(h(s))

def g(f, s):
    return map(f, s)

def c(f, s):
    return list(g(f, s))

def e(n, k):
    f = [['S' for _ in range(n)] for _ in range(n)]

    s = 0
    a = True
    for i in range(len(f)):
        for j in range(len(f[i])):
            if a and j % 2 == 0:
                f[i][j] = 'L'
                s += 1
            if not a and j % 2 == 1:
                f[i][j] == 'L'
                s += 1

            if s == k:
                print(""YES"")
                for r in f:
                    print("""".join(r))
                return
        a = not a
    print(""NO"")

if __name__ == ""__main__"":
    for e, b in enumerate(i.stdin.readlines()):
        n, k = h(b)
    e(n, k)","import e

def d():

    b = e.stdin.readline().strip()
    a = int(b)

    for _ in range(3):

        c = e.stdin.readline().strip()
        if not c:
            continue
        a, b = map(int, c.split())

        if a == a:
            a = b
        elif a == b:
            a = a

    print(a)

if __name__ == ""__main__"":
    d()"
277,A,Learning Languages,PROGRAMMING,"['dfs and similar', 'dsu']","The ""BerCorp"" company has got *n* employees. These employees can use *m* approved official languages for the formal correspondence. The languages are numbered with integers from 1 to *m*. For each employee we have the list of languages, which he knows. This list could be empty, i. e. an employee may know no official languages. But the employees are willing to learn any number of official languages, as long as the company pays their lessons. A study course in one language for one employee costs 1 berdollar.

Find the minimum sum of money the company needs to spend so as any employee could correspond to any other one (their correspondence can be indirect, i. e. other employees can help out translating).","The first line contains two integers *n* and *m* (2<=≤<=*n*,<=*m*<=≤<=100) — the number of employees and the number of languages.

Then *n* lines follow — each employee's language list. At the beginning of the *i*-th line is integer *k**i* (0<=≤<=*k**i*<=≤<=*m*) — the number of languages the *i*-th employee knows. Next, the *i*-th line contains *k**i* integers — *a**ij* (1<=≤<=*a**ij*<=≤<=*m*) — the identifiers of languages the *i*-th employee knows. It is guaranteed that all the identifiers in one list are distinct. Note that an employee may know zero languages.

The numbers in the lines are separated by single spaces.",Print a single integer — the minimum amount of money to pay so that in the end every employee could write a letter to every other one (other employees can help out translating).,"['5 5\n1 2\n2 2 3\n2 3 4\n2 4 5\n1 5\n', '8 7\n0\n3 1 2 3\n1 1\n2 5 4\n2 6 7\n1 3\n2 7 4\n1 1\n', '2 2\n1 2\n0\n']","['0\n', '2\n', '1\n']","In the second sample the employee 1 can learn language 2, and employee 8 can learn language 4.

In the third sample employee 2 must learn language 2.",WRONG_ANSWER,"def e(f,g):
	for i in f:
		if i in g:
			return True
	return False

def a(V,E,j,visited):
	q = []
	q.append(j)
	k[j] = True

	while len(q)!=0:
		v = q.pop(0)
		for i in E[v]:
			if not k[i]:
				k[i] = True
				q.append(i)

	return k

n,m =map(int,input().split())
h = []
k = [0]*n
for i in range(n):
	i = list(map(int,input().split()))
	k[i] = i.pop(0)
	h.append(i)

v=[]

for i in range(n):
	v.append(i)

b =[0]*n
for i in range(n):
	b[i] = [] 
for i in range(n):
	for j in range(n):
		if e(h[i],h[j]):
			b[i].append(j)
			b[j].append(i)
k = [False]*n
k = a(v,b,0,k)
c = 0
while False in k:
	d = k.index(False)
	k = a(v,b,d,k)
	c+=1
print(c)","def g():
    import h
    a = h.stdin.read().strip().splitlines()
    if not a:
        return

    c = []

    for b in a:
        d = b.strip().split()
        if len(d) < 3:
            continue
        try:
            k = int(d[0])
            a = int(d[1])
            b = int(d[2])
        except ValueError:
            continue

        j = a // k
        k = b // k
        i = j + k

        e = a - j * k
        f = b - k * k

        if i == 0:
            if a == 0 and b == 0:
                c.append(""0"")
            else:
                c.append(""-1"")
        else:

            if e <= k * (k - 1) and f <= j * (k - 1):
                c.append(str(i))
            else:
                c.append(""-1"")
    
    h.stdout.write(""\n"".join(c))

if __name__ == '__main__':
    g()"
233,A,Perfect Permutation,PROGRAMMING,"['implementation', 'math']","A permutation is a sequence of integers *p*1,<=*p*2,<=...,<=*p**n*, consisting of *n* distinct positive integers, each of them doesn't exceed *n*. Let's denote the *i*-th element of permutation *p* as *p**i*. We'll call number *n* the size of permutation *p*1,<=*p*2,<=...,<=*p**n*.

Nickolas adores permutations. He likes some permutations more than the others. He calls such permutations perfect. A perfect permutation is such permutation *p* that for any *i* (1<=≤<=*i*<=≤<=*n*) (*n* is the permutation size) the following equations hold *p**p**i*<==<=*i* and *p**i*<=≠<=*i*. Nickolas asks you to print any perfect permutation of size *n* for the given *n*.",A single line contains a single integer *n* (1<=≤<=*n*<=≤<=100) — the permutation size.,"If a perfect permutation of size *n* doesn't exist, print a single integer -1. Otherwise print *n* distinct integers from 1 to *n*, *p*1,<=*p*2,<=...,<=*p**n* — permutation *p*, that is perfect. Separate printed numbers by whitespaces.","['1\n', '2\n', '4\n']","['-1\n', '2 1 \n', '2 1 4 3 \n']",none,TIME_LIMIT_EXCEEDED,"def c(a, b=0):
    if b == len(a) - 1:
        d = True
        for i in range(1, len(a) + 1):
            if a[a[i - 1] - 1] != i or a[i - 1] == i:
                d = False
        if d:
            print("" "".join([str(i) for i in a]))
            exit()

    for i in range(b, len(a)):
        a[b], a[i] = a[i], a[b]
        c(a, b + 1)
        a[b], a[i] = a[i], a[b]

n = int(input())
c(list(range(1, n+1)))
print(-1)","def c():
    import f

    s = f.stdin.read().splitlines()[0].strip()
    n = len(s)
    a = 0

    for i in range(n):
        e = 0
        d = 0

        for j in range(i, n):
            b = s[j]
            if b == '(':
                e += 1
                d += 1
            elif b == ')':
                e -= 1
                d -= 1
            else:

                e -= 1
                d += 1
            if d < 0:

                break
            if e < 0:

                e = 0

            if ((j - i) & 1) and e == 0:
                a += 1
    f.stdout.write(str(a))
    
if __name__ == '__main__':
    c()"
845,C,Two TVs,PROGRAMMING,"['data structures', 'greedy', 'sortings']","Polycarp is a great fan of television.

He wrote down all the TV programs he is interested in for today. His list contains *n* shows, *i*-th of them starts at moment *l**i* and ends at moment *r**i*.

Polycarp owns two TVs. He can watch two different shows simultaneously with two TVs but he can only watch one show at any given moment on a single TV. If one show ends at the same moment some other show starts then you can't watch them on a single TV.

Polycarp wants to check out all *n* shows. Are two TVs enough to do so?","The first line contains one integer *n* (1<=≤<=*n*<=≤<=2·105) — the number of shows.

Each of the next *n* lines contains two integers *l**i* and *r**i* (0<=≤<=*l**i*<=&lt;<=*r**i*<=≤<=109) — starting and ending time of *i*-th show.","If Polycarp is able to check out all the shows using only two TVs then print ""YES"" (without quotes). Otherwise, print ""NO"" (without quotes).","['3\n1 2\n2 3\n4 5\n', '4\n1 2\n2 3\n2 3\n1 2\n']","['YES\n', 'NO\n']",none,WRONG_ANSWER,"def a (i, n):
    h = 0
    i.sort(key=lambda c: c[0])
    for i in range(n):
        b = i[i]
        if b [0] < h:
            return ""NO""
        h = b[1]

    return ""YES""

f = int(input())
j = []

for d in range(f):
    e, g = input().split("" "")
    j.append((int(e), int(g)))

print(a(j, f))","import j

def e():

    c = j.stdin.read().strip().split()
    if not c:
        return
    n, a, b, c = map(int, c)

    i = (4 - (n % 4)) % 4
    if i == 0:
        print(0)
        return

    f = i + 12

    a = 10**18
    d = [a] * (f + 1)
    d[0] = 0

    h = {1: a, 2: b, 3: c}

    for x in range(1, f + 1):
        for g in (1, 2, 3):
            if x - g >= 0:
                d[x] = min(d[x], d[x - g] + h[g])

    b = a
    for x in range(i, f + 1):
        if x % 4 == i:
            b = min(b, d[x])
    print(b)

if __name__ == '__main__':
    e()"
573,A,Bear and Poker,PROGRAMMING,"['implementation', 'math', 'number theory']","Limak is an old brown bear. He often plays poker with his friends. Today they went to a casino. There are *n* players (including Limak himself) and right now all of them have bids on the table. *i*-th of them has bid with size *a**i* dollars.

Each player can double his bid any number of times and triple his bid any number of times. The casino has a great jackpot for making all bids equal. Is it possible that Limak and his friends will win a jackpot?","First line of input contains an integer *n* (2<=≤<=*n*<=≤<=105), the number of players.

The second line contains *n* integer numbers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=109) — the bids of players.","Print ""Yes"" (without the quotes) if players can make their bids become equal, or ""No"" otherwise.","['4\n75 150 75 50\n', '3\n100 150 250\n']","['Yes\n', 'No\n']","In the first sample test first and third players should double their bids twice, second player should double his bid once and fourth player should both double and triple his bid.

It can be shown that in the second sample test there is no way to make all bids equal.",OK,"from collections import Counter,defaultdict,deque
import heapq as hq
from itertools import count, islice

import math
import b
input=b.stdin.readline
n = int(input())
a = [int(x) for x in input().split()]
for i in range(n):
    while (a[i]%3)==0:
        a[i]//=3
    while (a[i]%2)==0:
        a[i]//=2

q = a[0]
for i in range(1,n):
    if a[i]!=q:
        print('No')
        exit()
print('Yes')","def b(s):

    n = len(s)
    f = [0] * n
    for i in range(1, n):
        j = f[i - 1]
        while j > 0 and s[i] != s[j]:
            j = f[j - 1]
        if s[i] == s[j]:
            j += 1
        f[i] = j
    return f

import h

def e():

    c = h.stdin.read().splitlines()
    g = []

    for d in c:
        s = d.strip()
        if not s:
            continue
        n = len(s)
        f = b(s)
        a = f[n - 1]

        while a:
            if a in f[:-1]:
                g.append(s[:a])
                break
            a = f[a - 1]
        else:

            g.append(""Just a legend"")
    
    h.stdout.write(""\n"".join(g))

if __name__ == '__main__':
    e()"
0,none,none,none,['none'],"One day, Hongcow goes to the store and sees a brand new deck of *n* special cards. Each individual card is either red or blue. He decides he wants to buy them immediately. To do this, he needs to play a game with the owner of the store.

This game takes some number of turns to complete. On a turn, Hongcow may do one of two things: 
 -  Collect tokens. Hongcow collects 1 red token and 1 blue token by choosing this option (thus, 2 tokens in total per one operation). -  Buy a card. Hongcow chooses some card and spends tokens to purchase it as specified below. 
The *i*-th card requires *r**i* red resources and *b**i* blue resources. Suppose Hongcow currently has *A* red cards and *B* blue cards. Then, the *i*-th card will require Hongcow to spend *max*(*r**i*<=-<=*A*,<=0) red tokens, and *max*(*b**i*<=-<=*B*,<=0) blue tokens. Note, only tokens disappear, but the cards stay with Hongcow forever. Each card can be bought only once.

Given a description of the cards and their costs determine the minimum number of turns Hongcow needs to purchase all cards.","The first line of input will contain a single integer *n* (1<=≤<=*n*<=≤<=16).

The next *n* lines of input will contain three tokens *c**i*, *r**i* and *b**i*. *c**i* will be 'R' or 'B', denoting the color of the card as red or blue. *r**i* will be an integer denoting the amount of red resources required to obtain the card, and *b**i* will be an integer denoting the amount of blue resources required to obtain the card (0<=≤<=*r**i*,<=*b**i*<=≤<=107).","Output a single integer, denoting the minimum number of turns needed to acquire all the cards.","['3\nR 0 1\nB 1 0\nR 1 1\n', '3\nR 3 0\nR 2 0\nR 1 0\n']","['4\n', '6\n']","For the first sample, Hongcow's four moves are as follows: 
 1.  Collect tokens 1.  Buy card 1 1.  Buy card 2 1.  Buy card 3 
For the second sample, one optimal strategy is as follows: 
 1.  Collect tokens 1.  Collect tokens 1.  Buy card 2 1.  Collect tokens 1.  Buy card 3 1.  Buy card 1",WRONG_ANSWER,"import math
def n(n):
	sum = 0
	for i in range(1,n+1):
		sum += i
	return sum

def h(l):
	global l, b
	print(""edit %d %d %d %d"" % (k,a,l,b))
	return l[0], l[1]-l, l[2]-b

def i(n):
	global k, a, e
	print(""get %d %d %d %d"" % (k,a,l,b))
	k += n
	a += n
	e += n
	print(""after get %d %d %d %d"" % (k,a,l,b))

def c(d):
	global k,a, l, b, e
	print(""buy %d %d %d %d"" % (k,a,l,b))
	if d[0] == 'R':
		k -= d[1]
		a -= d[2]
		l += 1
	elif d[0] == 'B':
		k -= d[1]
		a -= d[2]
		b += 1
	e += 1
	print(""after buy %d %d %d %d"" % (k,a,l,b))
n = int(input())
j = dict()
a = 0
k = 0
l = 0
b = 0
m = """"
e = 0

for i in range(n):
	s, r, b = input().split()
	a += int(b)
	k += int(r)
	m += s
 
l = m.e('R')
b = m.e('B')
f = max(k-n(l-1), a-n(b))
g = max(k-n(l), a-n(b-1))
if b == 0:
	g = 10**10
elif l == 0:
	f = 10**10
e = min(f,g)
e += l + b
print(e)","def c():

    b = input().strip()
    n, m = map(int, b.split())
    
    a = 0
    d = n

    while d > 0:
        a += 1
        d -= 1

        if a % m == 0:
            d += 1

    print(a)

if __name__ == ""__main__"":
    c()"
920,B,Tea Queue,PROGRAMMING,['implementation'],"Recently *n* students from city S moved to city P to attend a programming camp.

They moved there by train. In the evening, all students in the train decided that they want to drink some tea. Of course, no two people can use the same teapot simultaneously, so the students had to form a queue to get their tea.

*i*-th student comes to the end of the queue at the beginning of *l**i*-th second. If there are multiple students coming to the queue in the same moment, then the student with greater index comes after the student with lesser index. Students in the queue behave as follows: if there is nobody in the queue before the student, then he uses the teapot for exactly one second and leaves the queue with his tea; otherwise the student waits for the people before him to get their tea. If at the beginning of *r**i*-th second student *i* still cannot get his tea (there is someone before him in the queue), then he leaves the queue without getting any tea. 

For each student determine the second he will use the teapot and get his tea (if he actually gets it).","The first line contains one integer *t* — the number of test cases to solve (1<=≤<=*t*<=≤<=1000).

Then *t* test cases follow. The first line of each test case contains one integer *n* (1<=≤<=*n*<=≤<=1000) — the number of students.

Then *n* lines follow. Each line contains two integer *l**i*, *r**i* (1<=≤<=*l**i*<=≤<=*r**i*<=≤<=5000) — the second *i*-th student comes to the end of the queue, and the second he leaves the queue if he still cannot get his tea.

It is guaranteed that for every  condition *l**i*<=-<=1<=≤<=*l**i* holds.

The sum of *n* over all test cases doesn't exceed 1000.

Note that in hacks you have to set *t*<==<=1.","For each test case print *n* integers. *i*-th of them must be equal to the second when *i*-th student gets his tea, or 0 if he leaves without tea.",['2\n2\n1 3\n1 4\n3\n1 5\n1 1\n2 3\n'],['1 2 \n1 0 2 \n'],"The example contains 2 tests:
 1.  During 1-st second, students 1 and 2 come to the queue, and student 1 gets his tea. Student 2 gets his tea during 2-nd second. 1.  During 1-st second, students 1 and 2 come to the queue, student 1 gets his tea, and student 2 leaves without tea. During 2-nd second, student 3 comes and gets his tea.",OK,"from sys import i, stdout

def h():
    return map(int, i.readline().split())

t = int(input())

for _ in range(t):
    n = int(input())
    d, f = 0, 0
    c = 0
    b = []
    for a in range(n):
        e, g = h()
        if e >= c:
            b.append(e)
            c = e+1
        elif c <= g:
            b.append(c)
            c += 1
        else:
            b.append(0)

    print(*b)","import e

def d():

    c = e.stdin.read().splitlines()
    if not c:
        return

    n = int(c[0].strip())

    a = c[1:n+1]

    for i in range(n):
        for j in range(n):
            b = 0

            if i > 0 and a[i-1][j] == 'o':
                b += 1

            if i < n - 1 and a[i+1][j] == 'o':
                b += 1

            if j > 0 and a[i][j-1] == 'o':
                b += 1

            if j < n - 1 and a[i][j+1] == 'o':
                b += 1

            if b % 2 != 0:
                print(""NO"")
                return

    print(""YES"")

if __name__ == '__main__':
    d()"
48,A,Rock-paper-scissors,PROGRAMMING,"['implementation', 'schedules']","Uncle Fyodor, Matroskin the Cat and Sharic the Dog live their simple but happy lives in Prostokvashino. Sometimes they receive parcels from Uncle Fyodor’s parents and sometimes from anonymous benefactors, in which case it is hard to determine to which one of them the package has been sent. A photographic rifle is obviously for Sharic who loves hunting and fish is for Matroskin, but for whom was a new video game console meant? Every one of the three friends claimed that the present is for him and nearly quarreled. Uncle Fyodor had an idea how to solve the problem justly: they should suppose that the console was sent to all three of them and play it in turns. Everybody got relieved but then yet another burning problem popped up — who will play first? This time Matroskin came up with a brilliant solution, suggesting the most fair way to find it out: play rock-paper-scissors together. The rules of the game are very simple. On the count of three every player shows a combination with his hand (or paw). The combination corresponds to one of three things: a rock, scissors or paper. Some of the gestures win over some other ones according to well-known rules: the rock breaks the scissors, the scissors cut the paper, and the paper gets wrapped over the stone. Usually there are two players. Yet there are three friends, that’s why they decided to choose the winner like that: If someone shows the gesture that wins over the other two players, then that player wins. Otherwise, another game round is required. Write a program that will determine the winner by the gestures they have shown.","The first input line contains the name of the gesture that Uncle Fyodor showed, the second line shows which gesture Matroskin showed and the third line shows Sharic’s gesture.","Print ""F"" (without quotes) if Uncle Fyodor wins. Print ""M"" if Matroskin wins and ""S"" if Sharic wins. If it is impossible to find the winner, print ""?"".","['rock\nrock\nrock\n', 'paper\nrock\nrock\n', 'scissors\nrock\nrock\n', 'scissors\npaper\nrock\n']","['?\n', 'F\n', '?\n', '?\n']",none,WRONG_ANSWER,"def a(f,m,s):
    if f == ""cisors"" and m == s == ""paper"":
        return f
    elif s == ""cisors"" and m == f == ""paper"":
        return s
    elif m == ""cisors"" and f == s == ""paper"":
        return m
    elif f==""rock"" and m==s==""cisors"":
        return f
    elif s==""rock"" and m==f==""cisors"":
        return s
    elif m==""rock"" and f==s==""cisors"":
        return m
    elif f==""paper"" and m==s==""rock"":
        return f
    elif f==""paper"" and m==s==""rock"":
        return s
    elif f==""paper"" and m==s==""rock"":
        return m
    return ""?""","x = input().strip()

a = list(x)

b = int(a[0])
d = 9 - b
if b != 9 and d < b and d != 0:
    a[0] = str(d)

for i in range(1, len(a)):
    d = int(a[i])
    c = 9 - d
    if c < d:
        a[i] = str(c)

print("""".join(a))"
285,B,Find Marble,PROGRAMMING,['implementation'],"Petya and Vasya are playing a game. Petya's got *n* non-transparent glasses, standing in a row. The glasses' positions are indexed with integers from 1 to *n* from left to right. Note that the positions are indexed but the glasses are not.

First Petya puts a marble under the glass in position *s*. Then he performs some (possibly zero) shuffling operations. One shuffling operation means moving the glass from the first position to position *p*1, the glass from the second position to position *p*2 and so on. That is, a glass goes from position *i* to position *p**i*. Consider all glasses are moving simultaneously during one shuffling operation. When the glasses are shuffled, the marble doesn't travel from one glass to another: it moves together with the glass it was initially been put in.

After all shuffling operations Petya shows Vasya that the ball has moved to position *t*. Vasya's task is to say what minimum number of shuffling operations Petya has performed or determine that Petya has made a mistake and the marble could not have got from position *s* to position *t*.","The first line contains three integers: *n*,<=*s*,<=*t* (1<=≤<=*n*<=≤<=105; 1<=≤<=*s*,<=*t*<=≤<=*n*) — the number of glasses, the ball's initial and final position. The second line contains *n* space-separated integers: *p*1,<=*p*2,<=...,<=*p**n* (1<=≤<=*p**i*<=≤<=*n*) — the shuffling operation parameters. It is guaranteed that all *p**i*'s are distinct.

Note that *s* can equal *t*.","If the marble can move from position *s* to position *t*, then print on a single line a non-negative integer — the minimum number of shuffling operations, needed to get the marble to position *t*. If it is impossible, print number -1.","['4 2 1\n2 3 4 1\n', '4 3 3\n4 1 3 2\n', '4 3 4\n1 2 3 4\n', '3 1 3\n2 1 3\n']","['3\n', '0\n', '-1\n', '-1\n']",none,WRONG_ANSWER,"from sys import d, e
from collections import OrderedDict

def c(n, s, t, b):
    a = 0
    while a < n:
        if b[s-1] == t:
            return a +1
        if b[s-1] == s:
            return -1
        s = b[s-1]
        a += 1
    if a == n:
        a = -1
    return a

if __name__ == ""__main__"":
    n, s, t = list(map(int, d.readline().rstrip().split()))
    b = list(map(int, d.readline().rstrip().split()))
    e.write(str(c(n, s, t, b)))","def e():
    import h
    h.setrecursionlimit(10**6)
    
    input = h.stdin.readline

    n, m = map(int, input().split())

    d = [[] for _ in range(n + 1)]
    for _ in range(m):
        u, v = map(int, input().split())
        d[u].append(v)
        d[v].append(u)

    i = [False] * (n + 1)

    def c(g):
        i[g] = True
        for f in d[g]:
            if not i[f]:
                c(f)

    a = 0
    for i in range(1, n + 1):
        if not i[i]:
            c(i)
            a += 1

    b = 2 ** (n - a)

    print(b)

if __name__ == '__main__':
    e()"
831,B,Keyboard Layouts,PROGRAMMING,"['implementation', 'strings']","There are two popular keyboard layouts in Berland, they differ only in letters positions. All the other keys are the same. In Berland they use alphabet with 26 letters which coincides with English alphabet.

You are given two strings consisting of 26 distinct letters each: all keys of the first and the second layouts in the same order. 

You are also given some text consisting of small and capital English letters and digits. It is known that it was typed in the first layout, but the writer intended to type it in the second layout. Print the text if the same keys were pressed in the second layout.

Since all keys but letters are the same in both layouts, the capitalization of the letters should remain the same, as well as all other characters.","The first line contains a string of length 26 consisting of distinct lowercase English letters. This is the first layout.

The second line contains a string of length 26 consisting of distinct lowercase English letters. This is the second layout.

The third line contains a non-empty string *s* consisting of lowercase and uppercase English letters and digits. This is the text typed in the first layout. The length of *s* does not exceed 1000.",Print the text if the same keys were pressed in the second layout.,"['qwertyuiopasdfghjklzxcvbnm\nveamhjsgqocnrbfxdtwkylupzi\nTwccpQZAvb2017\n', 'mnbvcxzlkjhgfdsapoiuytrewq\nasdfghjklqwertyuiopzxcvbnm\n7abaCABAABAcaba7\n']","['HelloVKCup2017\n', '7uduGUDUUDUgudu7\n']",none,OK,"from sys import j; f = j.readline
from math import dist, ceil, floor, sqrt, log
from collections import defaultdict, Counter, deque
def b(i=' '): return list(map(int, f().split(i)))
def a(): return list(map(float, f().split()))
def c(): return f().split()
def I(): return int(f())
def F(): return float(f())
def S(): return input()
def O(l:list): return ' '.join(map(str, l))

def g():
    a = S()
    b = S()
    s = S()
    d = [c.isupper() for c in s]
    s = s.lower()
    d = {}
    for i in range(26):
        d[a[i]] = b[i]
    h = ''
    for i in range(len(s)):
        e = s[i]
        if e in d:
            e = d[s[i]]
            if d[i]:
                e = e.upper()
        h += e 
    return h 
        
if __name__ == '__main__':
    print(g())","from collections import d
import n

def k():

    c = n.stdin.read().split()
    if not c:
        return
    j = iter(c)
    n = int(next(j))
    m = int(next(j))
    k = int(next(j))
    s = int(next(j))

    h = [int(next(j)) - 1 for _ in range(n)]

    i = [[] for _ in range(n)]
    for _ in range(m):
        u = int(next(j)) - 1
        v = int(next(j)) - 1
        i[u].append(v)
        i[v].append(u)

    a = 10**9

    f = [[a] * n for _ in range(k)]

    for t in range(k):
        g = d()

        for i in range(n):
            if h[i] == t:
                f[t][i] = 0
                g.append(i)

        while g:
            u = g.popleft()
            b = f[t][u]
            l = b + 1
            for v in i[u]:
                if f[t][v] > l:
                    f[t][v] = l
                    g.append(v)

    m = []
    for i in range(n):

        e = [f[t][i] for t in range(k)]

        e.sort()
        o = sum(e[:s])
        m.append(str(o))

    n.stdout.write("" "".join(m) + ""\n"")

if __name__ == ""__main__"":
    k()"
758,A,Holiday Of Equality,PROGRAMMING,"['implementation', 'math']","In Berland it is the holiday of equality. In honor of the holiday the king decided to equalize the welfare of all citizens in Berland by the expense of the state treasury. 

Totally in Berland there are *n* citizens, the welfare of each of them is estimated as the integer in *a**i* burles (burle is the currency in Berland).

You are the royal treasurer, which needs to count the minimum charges of the kingdom on the king's present. The king can only give money, he hasn't a power to take away them.","The first line contains the integer *n* (1<=≤<=*n*<=≤<=100) — the number of citizens in the kingdom.

The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n*, where *a**i* (0<=≤<=*a**i*<=≤<=106) — the welfare of the *i*-th citizen.",In the only line print the integer *S* — the minimum number of burles which are had to spend.,"['5\n0 1 2 3 4\n', '5\n1 1 0 1 1\n', '3\n1 3 1\n', '1\n12\n']","['10', '1', '4', '0']","In the first example if we add to the first citizen 4 burles, to the second 3, to the third 2 and to the fourth 1, then the welfare of all citizens will equal 4.

In the second example it is enough to give one burle to the third citizen. 

In the third example it is necessary to give two burles to the first and the third citizens to make the welfare of citizens equal 3.

In the fourth example it is possible to give nothing to everyone because all citizens have 12 burles.",OK,"def e():
    n = int(input())
    d = input().split()

    d = [int(x) for x in d]

    a = max(d)
    b = n * a
    print(b - sum(d))

def c():
    e()

c()","import o
import math

def n():

    f = o.stdin.read().strip().split()
    if not f:
        return []
    n = int(f[0])
    m = []
    for i in range(n):
        x = int(f[2*i+1])
        y = int(f[2*i+2])
        m.append((x, y))
    return m

def d(o, a, b):

    return (a[0]-o[0])*(b[1]-o[1]) - (a[1]-o[1])*(b[0]-o[0])

def c(l):

    l = sorted(l)
    if len(l) <= 1:
        return l

    h = []
    for p in l:
        while len(h) >= 2 and d(h[-2], h[-1], p) <= 0:
            h.pop()
        h.append(p)

    q = []
    for p in reversed(l):
        while len(q) >= 2 and d(q[-2], q[-1], p) <= 0:
            q.pop()
        q.append(p)

    g = h[:-1] + q[:-1]
    return g

def p(a, b, c):

    return abs(d(a, b, c))

def i():
    m = n()
    if not m:
        return
    n = len(m)

    g = c(m)
    m = len(g)

    if m < 4:
        b = p(g[0], g[1], g[2])
        print(""{:.6f}"".format(b / 2.0))
        return

    a = 0

    for i in range(m):

        j = (i+1) % m

        l = (i-1) % m

        for t in range(i+2, i+m-1):
            k = t % m

            while True:
                j = (j+1) % m
                if j == k:
                    break
                if p(g[i], g[j], g[k]) > p(g[i], g[j], g[k]):
                    j = j
                else:
                    break

            while True:
                k = (l+1) % m
                if k == i:
                    break
                if p(g[i], g[k], g[k]) > p(g[i], g[k], g[l]):
                    l = k
                else:
                    break

            e = p(g[i], g[j], g[k]) + p(g[i], g[k], g[l])
            if e > a:
                a = e

    print(""{:.6f}"".format(a / 2.0))

if __name__ == '__main__':
    i()"
260,A,Adding Digits,PROGRAMMING,"['implementation', 'math']","Vasya has got two number: *a* and *b*. However, Vasya finds number *a* too short. So he decided to repeat the operation of lengthening number *a* *n* times.

One operation of lengthening a number means adding exactly one digit to the number (in the decimal notation) to the right provided that the resulting number is divisible by Vasya's number *b*. If it is impossible to obtain the number which is divisible by *b*, then the lengthening operation cannot be performed.

Your task is to help Vasya and print the number he can get after applying the lengthening operation to number *a* *n* times.","The first line contains three integers: *a*,<=*b*,<=*n* (1<=≤<=*a*,<=*b*,<=*n*<=≤<=105).","In a single line print the integer without leading zeros, which Vasya can get when he applies the lengthening operations to number *a* *n* times. If no such number exists, then print number -1. If there are multiple possible answers, print any of them.","['5 4 5\n', '12 11 1\n', '260 150 10\n']","['524848\n', '121\n', '-1\n']",none,OK,"""""""
Two numbers a and b

You can perform an operation of lengthening by:
    * adding one digit to the number to the right. The new number must be divisible by 5.

Determine whether it is possible to lengthen a n times. If yes print any lengthening.
If not print -1.

Try adding digits from 0 to 9. If none of those work then it is impossible.
After that just chuck in a load of zeros as those don't change divisibility.
""""""

a, b, n = map(int, input().split())

a = 0
for i in range(10):
    if int(str(a) + str(i)) % b == 0:
        a = 1
        break

if a:
    print(str(a) + str(i) + '0'*(n-1))
else:
    print(-1)","import h

def d(x):
    """"""Checks if x is a prime number.""""""
    if x < 2:
        return False

    for i in range(2, int(x ** 0.5) + 1):
        if x % i == 0:
            return False
    return True

def e():

    c = h.stdin.readline().strip()
    if not c:
        return
    n, k = map(int, c.split())

    g = []
    for f in range(2, n + 1):
        if d(f):
            g.append(f)
    
    b = 0

    for i in range(len(g) - 1):
        a = g[i] + g[i+1] + 1

        if a <= n and d(a):
            b += 1

    if b >= k:
        print(""YES"")
    else:
        print(""NO"")

if __name__ == ""__main__"":
    e()"
515,A,Drazil and Date,PROGRAMMING,['math'],"Someday, Drazil wanted to go on date with Varda. Drazil and Varda live on Cartesian plane. Drazil's home is located in point (0,<=0) and Varda's home is located in point (*a*,<=*b*). In each step, he can move in a unit distance in horizontal or vertical direction. In other words, from position (*x*,<=*y*) he can go to positions (*x*<=+<=1,<=*y*), (*x*<=-<=1,<=*y*), (*x*,<=*y*<=+<=1) or (*x*,<=*y*<=-<=1). 

Unfortunately, Drazil doesn't have sense of direction. So he randomly chooses the direction he will go to in each step. He may accidentally return back to his house during his travel. Drazil may even not notice that he has arrived to (*a*,<=*b*) and continue travelling. 

Luckily, Drazil arrived to the position (*a*,<=*b*) successfully. Drazil said to Varda: ""It took me exactly *s* steps to travel from my house to yours"". But Varda is confused about his words, she is not sure that it is possible to get from (0,<=0) to (*a*,<=*b*) in exactly *s* steps. Can you find out if it is possible for Varda?","You are given three integers *a*, *b*, and *s* (<=-<=109<=≤<=*a*,<=*b*<=≤<=109, 1<=≤<=*s*<=≤<=2·109) in a single line.","If you think Drazil made a mistake and it is impossible to take exactly *s* steps and get from his home to Varda's home, print ""No"" (without quotes).

Otherwise, print ""Yes"".","['5 5 11\n', '10 15 25\n', '0 5 1\n', '0 0 2\n']","['No\n', 'Yes\n', 'No\n', 'Yes\n']","In fourth sample case one possible route is: <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/0d30660ddf6eb6c64ffd071055a4e8ddd016cde5.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>.",WRONG_ANSWER,"def a(b, d, c, e):
    return abs(b - c) + abs(d - e)

a, b, s = map(int, input().split())
if a(0, 0, a, b) <= s:
    print('Yes')
else:
    print('No')","import f

def e():

    a = f.stdin.read().splitlines()

    if len(a) < 2:
        return

    c = a[0]
    d = a[1]

    if len(c) != len(d):
        print(""NO"")
        return

    b = []
    for i in range(len(c)):
        if c[i] != d[i]:
            b.append(i)

    if len(b) != 2:
        print(""NO"")
        return
    
    i, j = b

    if c[i] == d[j] and c[j] == d[i]:
        print(""YES"")
    else:
        print(""NO"")

if __name__ == ""__main__"":
    e()"
41,A,Translation,PROGRAMMING,"['implementation', 'strings']","The translation from the Berland language into the Birland language is not an easy task. Those languages are very similar: a berlandish word differs from a birlandish word with the same meaning a little: it is spelled (and pronounced) reversely. For example, a Berlandish word code corresponds to a Birlandish word edoc. However, it's easy to make a mistake during the «translation». Vasya translated word *s* from Berlandish into Birlandish as *t*. Help him: find out if he translated the word correctly.","The first line contains word *s*, the second line contains word *t*. The words consist of lowercase Latin letters. The input data do not consist unnecessary spaces. The words are not empty and their lengths do not exceed 100 symbols.","If the word *t* is a word *s*, written reversely, print YES, otherwise print NO.","['code\nedoc\n', 'abb\naba\n', 'code\ncode\n']","['YES\n', 'NO\n', 'NO\n']",none,OK,"a = input()
b = input()

def a(s):
    return s[::-1]

if b == a(a):
    print('YES')
else:
    print('NO')","def c():
    import g

    b = g.stdin.read().split()

    n = int(b[0])
    m = int(b[1])

    f = list(map(int, b[2:2 + n]))

    d = [e for e in f if e < 0]

    d.sort()

    a = d[:m]

    h = sum(-e for e in a)

    g.stdout.write(str(h))

if __name__ == '__main__':
    c()"
628,B,New Skateboard,PROGRAMMING,['dp'],"Max wants to buy a new skateboard. He has calculated the amount of money that is needed to buy a new skateboard. He left a calculator on the floor and went to ask some money from his parents. Meanwhile his little brother Yusuf came and started to press the keys randomly. Unfortunately Max has forgotten the number which he had calculated. The only thing he knows is that the number is divisible by 4.

You are given a string *s* consisting of digits (the number on the display of the calculator after Yusuf randomly pressed the keys). Your task is to find the number of substrings which are divisible by 4. A substring can start with a zero.

A substring of a string is a nonempty sequence of consecutive characters.

For example if string *s* is 124 then we have four substrings that are divisible by 4: 12, 4, 24 and 124. For the string 04 the answer is three: 0, 4, 04.

As input/output can reach huge size it is recommended to use fast input/output methods: for example, prefer to use gets/scanf/printf instead of getline/cin/cout in C++, prefer to use BufferedReader/PrintWriter instead of Scanner/System.out in Java.",The only line contains string *s* (1<=≤<=|*s*|<=≤<=3·105). The string *s* contains only digits from 0 to 9.,"Print integer *a* — the number of substrings of the string *s* that are divisible by 4.

Note that the answer can be huge, so you should use 64-bit integer type to store it. In C++ you can use the long long integer type and in Java you can use long integer type.","['124\n', '04\n', '5810438174\n']","['4\n', '3\n', '9\n']",none,OK,"import t
import os
import math
import copy
from bisect import bisect
from io import BytesIO, IOBase
from math import sqrt,floor,factorial,p,log,ceil
from collections import deque,Counter,defaultdict
from itertools import permutations,combinations,accumulate

def b():               return int(t.stdin.readline())
def g():              return map(int,t.stdin.readline().split())
def e():              return list(t.stdin.readline().strip())
def k():               return t.stdin.readline().strip()
def j():              return map(str,t.stdin.readline().strip().split())
def d():              return list(map(int,t.stdin.readline().split()))
def a():              return dict()
def h():               return 1000000007
def f(n):           return [d() for _ in range(n)]
def c(x,y):            return (x*y)//p(x,y)
def o(n):             return bin(n).replace(""0b"","""")
def m(n):             return int(n,2) 
def u(x):            return print(x)
def n(q, r):      return set(q).intersection(r)
def i(list): return max(set(list), key = list.count)
   
def s():

          s=k()
          l=0
          for i in range(len(s)):
               if(int(s[i])%4==0):
                    l+=1
          for i in range(len(s)-1):
               if(int(s[i]+s[i+1])%4==0):
                    l+=(i+1)
          print(l)          
          
          
          
          
if __name__ == ""__main__"":
     s()","def f():
    import g
    g.setrecursionlimit(10000)

    b = g.stdin.read().strip().split()
    if not b:
        return
    
    n = int(b[0])
    d = []

    e = 1
    for i in range(n):
        x = int(b[e])
        y = int(b[e + 1])
        e += 2
        d.append((x, y))

    h = [False] * n

    def c(i):
        h[i] = True
        for j in range(n):
            if not h[j]:

                if d[i][0] == d[j][0] or d[i][1] == d[j][1]:
                    c(j)

    a = 0
    for i in range(n):
        if not h[i]:
            c(i)
            a += 1

    g.stdout.write(str(a - 1))

if __name__ == '__main__':
    f()"
519,B,A and B and Compilation Errors,PROGRAMMING,"['data structures', 'implementation', 'sortings']","A and B are preparing themselves for programming contests.

B loves to debug his code. But before he runs the solution and starts debugging, he has to first compile the code.

Initially, the compiler displayed *n* compilation errors, each of them is represented as a positive integer. After some effort, B managed to fix some mistake and then another one mistake.

However, despite the fact that B is sure that he corrected the two errors, he can not understand exactly what compilation errors disappeared — the compiler of the language which B uses shows errors in the new order every time! B is sure that unlike many other programming languages, compilation errors for his programming language do not depend on each other, that is, if you correct one error, the set of other error does not change.

Can you help B find out exactly what two errors he corrected?","The first line of the input contains integer *n* (3<=≤<=*n*<=≤<=105) — the initial number of compilation errors.

The second line contains *n* space-separated integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=109) — the errors the compiler displayed for the first time. 

The third line contains *n*<=-<=1 space-separated integers *b*1,<=*b*2,<=...,<=*b**n*<=-<=1 — the errors displayed at the second compilation. It is guaranteed that the sequence in the third line contains all numbers of the second string except for exactly one. 

The fourth line contains *n*<=-<=2 space-separated integers *с*1,<=*с*2,<=...,<=*с**n*<=-<=2 — the errors displayed at the third compilation. It is guaranteed that the sequence in the fourth line contains all numbers of the third line except for exactly one.","Print two numbers on a single line: the numbers of the compilation errors that disappeared after B made the first and the second correction, respectively.","['5\n1 5 8 123 7\n123 7 5 1\n5 1 7\n', '6\n1 4 3 3 5 7\n3 7 5 4 3\n4 3 7 5\n']","['8\n123\n', '1\n3\n']","In the first test sample B first corrects the error number 8, then the error number 123.

In the second test sample B first corrects the error number 1, then the error number 3. Note that if there are multiple errors with the same number, B can correct only one of them in one step.",TIME_LIMIT_EXCEEDED,"n = int(input())

a = list(map(int, input().split()))
b = list(map(int, input().split()))
c = list(map(int, input().split()))

def c(a):
	for i in range(len(a)):
		j = i - 1 
		d = a[i]
		while a[j] > d and j >= 0:
			a[j + 1] = a[j]
			j -= 1
		a[j + 1] = d
	return a
a = c(a)
b = c(b)
c = c(c)

def e(a, b):
    n = len(a)
    t = -1
    b = 0
    while b < n-1:
        if a[b] != b[b]:
            break
        b += 1
    return a[b]

print(e(a, b), '\n', e(b, c), sep = '')","import g

def c():

    a = g.stdin.read().strip()
    if a:

        d, b = a.split()
        n = int(d)
        k = int(b)

        e = (n + 1) // 2

        if k <= e:
            f = 2 * k - 1
        else:

            f = 2 * (k - e)

        g.stdout.write(str(f))

if __name__ == '__main__':
    c()"
673,B,Problems for Round,PROGRAMMING,"['greedy', 'implementation']","There are *n* problems prepared for the next Codeforces round. They are arranged in ascending order by their difficulty, and no two problems have the same difficulty. Moreover, there are *m* pairs of similar problems. Authors want to split problems between two division according to the following rules: 
 -  Problemset of each division should be non-empty. -  Each problem should be used in exactly one division (yes, it is unusual requirement). -  Each problem used in division 1 should be harder than any problem used in division 2. -  If two problems are similar, they should be used in different divisions. 
Your goal is count the number of ways to split problem between two divisions and satisfy all the rules. Two ways to split problems are considered to be different if there is at least one problem that belongs to division 1 in one of them and to division 2 in the other.

Note, that the relation of similarity is not transitive. That is, if problem *i* is similar to problem *j* and problem *j* is similar to problem *k*, it doesn't follow that *i* is similar to *k*.","The first line of the input contains two integers *n* and *m* (2<=≤<=*n*<=≤<=100<=000, 0<=≤<=*m*<=≤<=100<=000) — the number of problems prepared for the round and the number of pairs of similar problems, respectively.

Each of the following *m* lines contains a pair of similar problems *u**i* and *v**i* (1<=≤<=*u**i*,<=*v**i*<=≤<=*n*,<=*u**i*<=≠<=*v**i*). It's guaranteed, that no pair of problems meets twice in the input.",Print one integer — the number of ways to split problems in two divisions.,"['5 2\n1 4\n5 2\n', '3 3\n1 2\n2 3\n1 3\n', '3 2\n3 1\n3 2\n']","['2\n', '0\n', '1\n']","In the first sample, problems 1 and 2 should be used in division 2, while problems 4 and 5 in division 1. Problem 3 may be used either in division 1 or in division 2.

In the second sample, all pairs of problems are similar and there is no way to split problem between two divisions without breaking any rules.

Third sample reminds you that the similarity relation is not transitive. Problem 3 is similar to both 1 and 2, but 1 is not similar to 2, so they may be used together.",WRONG_ANSWER,"def g() :
    a = input().split()
    n = int(a[0])
    p = int(a[1])

    f = n
    d = 0

    c = []
    for i in range(0, n):
        c.append(0)
    e = []
    for i in range(0, p):
        e.append(input().split())
    for i in range(0, p):
        s = e[i]
        a = int(s[0])
        b = int(s[1])
        if(a>b):
            if(c[a-1]==2):
                print(""0"")
                return
            else:
                c[a-1] = 1
                if(f>a):
                    f = a
            if(c[b-1]==1):
                print(""0"")
                return
            else:
                c[b-1] = 2
                if(d<b):
                    d = b
        else:
            if(c[a-1]==1):
                print(""0"")
                return
            else:
                c[a-1] = 2
                if(d<a):
                    d = a
            if(c[b-1]==2):
                print(""0"")
                return
            else:
                c[b-1] = 1
                if(f>b):
                    f = b

    if(f<=d):
        print(""0"")
        return
    w = 1
    for i in range(0, n):
        if(c[i]==0):
            if(f>(i+1)):
                if(d<(i+1)):
                    w += 1
    print(str(w))

    return

g()","def h():
    import m
    f = m.stdin.read().strip().splitlines()
    if not f:
        return

    n, s = map(int, f[0].split())

    b = {}
    a = {}

    for g in f[1:]:
        j = g.split()
        if len(j) != 3:
            continue
        e, k, n = j[0], int(j[1]), int(j[2])
        if e == 'S':

            b[k] = b.get(k, 0) + n
        elif e == 'B':

            a[k] = a.get(k, 0) + n

    l = sorted(b.items(), key=lambda x: x[0])
    d = l[:s]
    d.reverse()

    c = sorted(a.items(), key=lambda x: x[0], reverse=True)[:s]

    i = []
    for k, n in d:
        i.append(f""S {k} {n}"")
    for k, n in c:
        i.append(f""B {k} {n}"")
    
    m.stdout.write(""\n"".join(i))
    
if __name__ == ""__main__"":
    h()"
778,A,String Game,PROGRAMMING,"['binary search', 'greedy', 'strings']","Little Nastya has a hobby, she likes to remove some letters from word, to obtain another word. But it turns out to be pretty hard for her, because she is too young. Therefore, her brother Sergey always helps her.

Sergey gives Nastya the word *t* and wants to get the word *p* out of it. Nastya removes letters in a certain order (one after another, in this order strictly), which is specified by permutation of letters' indices of the word *t*: *a*1... *a*|*t*|. We denote the length of word *x* as |*x*|. Note that after removing one letter, the indices of other letters don't change. For example, if *t*<==<=""nastya"" and *a*<==<=[4,<=1,<=5,<=3,<=2,<=6] then removals make the following sequence of words ""nastya""  ""nastya""  ""nastya""  ""nastya""  ""nastya""  ""nastya""  ""nastya"".

Sergey knows this permutation. His goal is to stop his sister at some point and continue removing by himself to get the word *p*. Since Nastya likes this activity, Sergey wants to stop her as late as possible. Your task is to determine, how many letters Nastya can remove before she will be stopped by Sergey.

It is guaranteed that the word *p* can be obtained by removing the letters from word *t*.","The first and second lines of the input contain the words *t* and *p*, respectively. Words are composed of lowercase letters of the Latin alphabet (1<=≤<=|*p*|<=&lt;<=|*t*|<=≤<=200<=000). It is guaranteed that the word *p* can be obtained by removing the letters from word *t*.

Next line contains a permutation *a*1,<=*a*2,<=...,<=*a*|*t*| of letter indices that specifies the order in which Nastya removes letters of *t* (1<=≤<=*a**i*<=≤<=|*t*|, all *a**i* are distinct).","Print a single integer number, the maximum number of letters that Nastya can remove.","['ababcba\nabb\n5 3 4 1 7 6 2\n', 'bbbabb\nbb\n1 6 3 4 2 5\n']","['3', '4']","In the first sample test sequence of removing made by Nastya looks like this:

""ababcba"" <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> ""ababcba"" <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> ""ababcba"" <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> ""ababcba"" 

Nastya can not continue, because it is impossible to get word ""abb"" from word ""ababcba"".

So, Nastya will remove only three letters.",OK,"s = input()
i = input()
h = [int(x)-1 for x in input().split()]
n = len(s)
f = 0
a = 0
d = n-1
def b(x):
    c = [1]*n
    e = 0
    for i in range(x):
        c[h[i]]=0
    for i in range(n):
        if s[i]==i[e] and c[i]:
            e+=1
            if e >= len(i):
                return True
    return False
while f <= d:
    g = (f+d)//2
    if b(g):
        a = g
        f=g+1
    else:
        d=g-1
print(a)","import k
import math

def h():

    c = k.stdin.read().strip().split()
    if not c:
        return
    t = int(c[0])
    e = 1
    j = []
    
    for _ in range(t):

        x = int(c[e])
        y = int(c[e+1])
        p = int(c[e+2])
        q = int(c[e+3])
        e += 4

        if p == q:
            if x != y:
                j.append(""-1"")
            else:
                j.append(""0"")
            continue

        if p == 0:
            if x != 0:
                j.append(""-1"")
            else:
                j.append(""0"")
            continue

        f = max((y + q - 1) // q, (x + p - 1) // p)

        g = f
        d = 10**18
        b = None
        
        while g <= d:
            i = (g + d) // 2
            if i * p < x or i * q < y or i * (q - p) < (y - x):
                g = i + 1
            else:
                b = i
                d = i - 1
        
        if b is None:
            j.append(""-1"")
        else:

            a = b * q - y
            j.append(str(a))
    
    k.stdout.write(""\n"".join(j))

if __name__ == '__main__':
    h()"
1,C,Ancient Berland Circus,PROGRAMMING,"['geometry', 'math']","Nowadays all circuses in Berland have a round arena with diameter 13 meters, but in the past things were different.

In Ancient Berland arenas in circuses were shaped as a regular (equiangular) polygon, the size and the number of angles could vary from one circus to another. In each corner of the arena there was a special pillar, and the rope strung between the pillars marked the arena edges.

Recently the scientists from Berland have discovered the remains of the ancient circus arena. They found only three pillars, the others were destroyed by the time.

You are given the coordinates of these three pillars. Find out what is the smallest area that the arena could have.","The input file consists of three lines, each of them contains a pair of numbers –– coordinates of the pillar. Any coordinate doesn't exceed 1000 by absolute value, and is given with at most six digits after decimal point.",Output the smallest possible area of the ancient arena. This number should be accurate to at least 6 digits after the decimal point. It's guaranteed that the number of angles in the optimal polygon is not larger than 100.,['0.000000 0.000000\n1.000000 1.000000\n0.000000 1.000000\n'],['1.00000000\n'],,RUNTIME_ERROR,"import numpy as d
f=input().split()
g=input().split()
h=input().split()
b=[f,g,h]
def c(f,g):
    d=((float(f[0])-float(g[0]))**2+(float(f[1])-float(g[1]))**2)**0.5
    return d
if c(f,g)==c(f,h):
    d=c(f,g)
    l=c(g,h)
elif c(g,f)==c(g,h):
    d=c(g,f)
    l=c(f,h)
else:
    d=c(g,h)
    l=c(f,g)
a=1-l**2/(2*d**2)
e=d.arccos(a)
n=2*d.pi/(d.pi-e)
s=n*d**2/4*d.tan(e)
print(s)","def f():
    import h, bisect
    c = h.stdin.read().split()
    if not c:
        return
    e = iter(c)
    n = int(next(e))
    p = int(next(e))

    d = [0] * (n + 1)

    b = {}

    for _ in range(n):
        a = int(next(e))
        b = int(next(e))

        if a > b:
            a, b = b, a
        d[a] += 1
        d[b] += 1

        b[(a, b)] = b.get((a, b), 0) + 1

    a = d[1:]
    a.sort()

    i = 0
    l = 0
    r = n - 1
    while l < r:
        if a[l] + a[r] >= p:
            i += (r - l)
            r -= 1
        else:
            l += 1

    for (a, b), g in b.items():
        if d[a] + d[b] >= p and d[a] + d[b] - g < p:
            i -= 1

    h.stdout.write(str(i))

if __name__ == '__main__':
    f()"
915,C,Permute Digits,PROGRAMMING,"['dp', 'greedy']","You are given two positive integer numbers *a* and *b*. Permute (change order) of the digits of *a* to construct maximal number not exceeding *b*. No number in input and/or output can start with the digit 0.

It is allowed to leave *a* as it is.",The first line contains integer *a* (1<=≤<=*a*<=≤<=1018). The second line contains integer *b* (1<=≤<=*b*<=≤<=1018). Numbers don't have leading zeroes. It is guaranteed that answer exists.,"Print the maximum possible number that is a permutation of digits of *a* and is not greater than *b*. The answer can't have any leading zeroes. It is guaranteed that the answer exists.

The number in the output should have exactly the same length as number *a*. It should be a permutation of digits of *a*.","['123\n222\n', '3921\n10000\n', '4940\n5000\n']","['213\n', '9321\n', '4940\n']",none,RUNTIME_ERROR,"import d,math,string,bisect
input=d.stdin.readline
from collections import deque,defaultdict
L=lambda : list(map(int,input().split()))
a=lambda : list(input().split())
M=lambda : map(int,input().split())
I=lambda :int(input())
a=input().strip()
b=input().strip()
if(len(a)<len(b)):
    s=list(a)
    s.sort(reverse=True)
    for i in s:
        print(i,end='')
else:
    s=list(a)
    s.sort(reverse=True)
    c=0
    while(c<len(b)):
        b=0
        while(b<len(s) and s[b]>b[c]):
            b+=1
        print(s[b],end='')
        if(s[b]==b[c]):
            c+=1
            s.remove(s[b])
        else:
            s.remove(s[b])
            for i in s:
                print(i,end='')
            exit()","def d():
    import e
    c = e.stdin.read().split()
    if not c:
        return

    n = int(c[0])
    a = list(map(int, c[1:]))

    if n <= 1:
        print(n)
        return

    L = [1] * n
    for i in range(1, n):
        if a[i] > a[i - 1]:
            L[i] = L[i - 1] + 1
        else:
            L[i] = 1

    R = [1] * n
    for i in range(n - 2, -1, -1):
        if a[i] < a[i + 1]:
            R[i] = R[i + 1] + 1
        else:
            R[i] = 1

    a = max(L)

    for i in range(n):
        if i == 0:

            b = 1 + (R[1] if n >= 2 else 0)
        elif i == n - 1:

            b = L[n - 2] + 1
        else:

            if a[i + 1] > a[i - 1] + 1:
                b = L[i - 1] + R[i + 1] + 1
            else:

                b = max(L[i - 1], R[i + 1]) + 1

        if b > a:
            a = b

    a = min(a, n)
    e.stdout.write(str(a) + ""\n"")

if __name__ == ""__main__"":
    d()"
1,A,Theatre Square,PROGRAMMING,['math'],"Theatre Square in the capital city of Berland has a rectangular shape with the size *n*<=×<=*m* meters. On the occasion of the city's anniversary, a decision was taken to pave the Square with square granite flagstones. Each flagstone is of the size *a*<=×<=*a*.

What is the least number of flagstones needed to pave the Square? It's allowed to cover the surface larger than the Theatre Square, but the Square has to be covered. It's not allowed to break the flagstones. The sides of flagstones should be parallel to the sides of the Square.","The input contains three positive integer numbers in the first line: *n*,<=<=*m* and *a* (1<=≤<=<=*n*,<=*m*,<=*a*<=≤<=109).",Write the needed number of flagstones.,['6 6 4\n'],['4\n'],none,OK,"def a():
    [n, m, a] = [int(x) for x in input().split()]
    return((n // -a)*(m // -a))

if __name__ == ""__main__"":
    print(a())","import g

def d():

    b = g.stdin.read().split()

    if not b:
        return

    n = int(b[0])
    t = int(b[1])

    a = list(map(int, b[2:2 + n]))
    
    e = 0
    a = 0
    c = 0

    for f in range(n):

        a += a[f]

        while a > t and c <= f:
            a -= a[c]
            c += 1

        e = max(e, f - c + 1)

    print(e)

if __name__ == '__main__':
    d()"
340,E,Iahub and Permutations,PROGRAMMING,"['combinatorics', 'math']","Iahub is so happy about inventing bubble sort graphs that he's staying all day long at the office and writing permutations. Iahubina is angry that she is no more important for Iahub. When Iahub goes away, Iahubina comes to his office and sabotage his research work.

The girl finds an important permutation for the research. The permutation contains *n* distinct integers *a*1, *a*2, ..., *a**n* (1<=≤<=*a**i*<=≤<=*n*). She replaces some of permutation elements with -1 value as a revenge. 

When Iahub finds out his important permutation is broken, he tries to recover it. The only thing he remembers about the permutation is it didn't have any fixed point. A fixed point for a permutation is an element *a**k* which has value equal to *k* (*a**k*<==<=*k*). Your job is to proof to Iahub that trying to recover it is not a good idea. Output the number of permutations which could be originally Iahub's important permutation, modulo 1000000007 (109<=+<=7).","The first line contains integer *n* (2<=≤<=*n*<=≤<=2000). On the second line, there are *n* integers, representing Iahub's important permutation after Iahubina replaces some values with -1. 

It's guaranteed that there are no fixed points in the given permutation. Also, the given sequence contains at least two numbers -1 and each positive number occurs in the sequence at most once. It's guaranteed that there is at least one suitable permutation.","Output a single integer, the number of ways Iahub could recover his permutation, modulo 1000000007 (109<=+<=7).",['5\n-1 -1 4 3 -1\n'],['2\n'],"For the first test example there are two permutations with no fixed points are [2, 5, 4, 3, 1] and [5, 1, 4, 3, 2]. Any other permutation would have at least one fixed point.",WRONG_ANSWER,"from math import factorial as f
def a(n):
	s=0
	for i in range(2,n+1):
		s+=((-1)**i)/f(i)
	return f(n)*s
x=input()
l=[i for i in input().split()]
print(int(a(l.count(""-1""))%(1000000007)))","import d

a = d.stdin.read().split()
n = int(a[0])
a = int(a[1])
b = int(a[2])

b = max(a + 1, n - b)

c = max(0, n - b + 1)

d.stdout.write(str(c))"
282,A,Bit++,PROGRAMMING,['implementation'],"The classic programming language of Bitland is Bit++. This language is so peculiar and complicated.

The language is that peculiar as it has exactly one variable, called *x*. Also, there are two operations:
 -  Operation ++ increases the value of variable *x* by 1. -  Operation -- decreases the value of variable *x* by 1. 
A statement in language Bit++ is a sequence, consisting of exactly one operation and one variable *x*. The statement is written without spaces, that is, it can only contain characters ""+"", ""-"", ""X"". Executing a statement means applying the operation it contains.

A programme in Bit++ is a sequence of statements, each of them needs to be executed. Executing a programme means executing all the statements it contains.

You're given a programme in language Bit++. The initial value of *x* is 0. Execute the programme and find its final value (the value of the variable when this programme is executed).","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=150) — the number of statements in the programme.

Next *n* lines contain a statement each. Each statement contains exactly one operation (++ or --) and exactly one variable *x* (denoted as letter «X»). Thus, there are no empty statements. The operation and the variable can be written in any order.",Print a single integer — the final value of *x*.,"['1\n++X\n', '2\nX++\n--X\n']","['1\n', '0\n']",none,WRONG_ANSWER,"def b(d):
    x = 0

    for e in d:
        if ""++"" in e:
            x += 1
        elif ""--"" in e:
            x -= 1

    return x

a = [""++X"", ""X--"", ""++X"", ""--X""]

c = b(a)
print(""Final value of x:"", c)","import m
import b

def j():

    f = m.stdin.read().strip().split()
    if not f:
        return
    i = iter(f)
    n = int(next(i))
    m = int(next(i))

    h = [[] for _ in range(n + 1)]
    for _ in range(m):
        u = int(next(i))
        v = int(next(i))
        h[u].append(v)
        h[v].append(u)

    n = [False] * (n + 1)

    for i in range(1, n + 1):
        if not n[i]:

            l = b.deque([i])
            n[i] = True
            d = 0
            c = 0
            while l:
                e = l.popleft()
                d += 1
                c += len(h[e])
                for k in h[e]:
                    if not n[k]:
                        n[k] = True
                        l.append(k)

            a = c // 2

            if d >= 3:

                g = d * (d - 1) // 2
                if a != g:
                    m.stdout.write(""NO"")
                    return

    m.stdout.write(""YES"")

if __name__ == '__main__':
    j()"
894,A,QAQ,PROGRAMMING,"['brute force', 'dp']","""QAQ"" is a word to denote an expression of crying. Imagine ""Q"" as eyes with tears and ""A"" as a mouth.

Now Diamond has given Bort a string consisting of only uppercase English letters of length *n*. There is a great number of ""QAQ"" in the string (Diamond is so cute!).

Bort wants to know how many subsequences ""QAQ"" are in the string Diamond has given. Note that the letters ""QAQ"" don't have to be consecutive, but the order of letters should be exact.",The only line contains a string of length *n* (1<=≤<=*n*<=≤<=100). It's guaranteed that the string only contains uppercase English letters.,"Print a single integer — the number of subsequences ""QAQ"" in the string.","['QAQAQYSYIOIWIN\n', 'QAQQQZZYNOIWIN\n']","['4\n', '3\n']","In the first example there are 4 subsequences ""QAQ"": ""QAQAQYSYIOIWIN"", ""QAQAQYSYIOIWIN"", ""QAQAQYSYIOIWIN"", ""QAQAQYSYIOIWIN"".",OK,"def a(n,s):
    b = 0
    for i in range(n):
        if s[i] == 'Q':
            for j in range(i+1,n):
                if s[j] == 'A':
                    for k in range(j+1,n):
                        if s[k] == 'Q':
                            b += 1
    return b
    
s = input()
print(a(len(s),s))","def h(x):

    return x & -x

def i():
    import m
    e = m.stdin.read().strip().split()
    if not e:
        return
    n = int(e[0])
    g = int(e[1])

    b = {}
    for x in range(1, g + 1):
        f = h(x)
        if f not in b:
            b[f] = []
        b[f].append(x)

    for f in b:
        b[f].sort(reverse=True)

    d = sorted(b.keys(), reverse=True)
    
    k = n
    l = []

    for c in d:
        if k <= 0:
            break

        j = k // c
        if j <= 0:
            continue
        a = len(b[c])
        o = min(j, a)
        l.extend(b[c][:o])
        k -= o * c

    if k != 0:
        m.stdout.write(""-1"")
    else:

        m.stdout.write(str(len(l)) + ""\n"")
        m.stdout.write("" "".join(map(str, l)) + ""\n"")

if __name__ == '__main__':
    i()"
227,B,Effective Approach,PROGRAMMING,['implementation'],"Once at a team training Vasya, Petya and Sasha got a problem on implementing linear search in an array.

According to the boys, linear search works as follows. The array elements in a pre-selected order are in turn compared with the number that you need to find. Once you find the array element that is equal to the required one, the search ends. The efficiency of the algorithm is the number of performed comparisons. The fewer comparisons the linear search has made, the more effective it is.

Vasya believes that a linear search would work better if it sequentially iterates through the elements, starting with the 1-st one (in this problem we consider the elements of the array indexed from 1 to *n*) and ending with the *n*-th one. And Petya says that Vasya is wrong: the search will need less comparisons if it sequentially iterates the elements starting from the *n*-th and ending with the 1-st one. Sasha argues that the two approaches are equivalent.

To finally begin the task, the teammates decided to settle the debate and compare the two approaches on an example. For this, they took an array that is a permutation of integers from 1 to *n*, and generated *m* queries of the form: find element with value *b**i* in the array. They want to calculate for both approaches how many comparisons in total the linear search will need to respond to all queries. If the first search needs fewer comparisons, then the winner of the dispute is Vasya. If the second one does, then the winner is Petya. If both approaches make the same number of comparisons, then Sasha's got the upper hand.

But the problem is, linear search is too slow. That's why the boys aren't going to find out who is right before the end of the training, unless you come in here. Help them to determine who will win the dispute.","The first line contains integer *n* (1<=≤<=*n*<=≤<=105) — the number of elements in the array. The second line contains *n* distinct space-separated integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=*n*) — the elements of array. 

The third line contains integer *m* (1<=≤<=*m*<=≤<=105) — the number of queries. The last line contains *m* space-separated integers *b*1,<=*b*2,<=...,<=*b**m* (1<=≤<=*b**i*<=≤<=*n*) — the search queries. Note that the queries can repeat.","Print two integers, showing how many comparisons Vasya's approach needs and how many comparisons Petya's approach needs. Separate the numbers by spaces.

Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use cin, cout streams or the %I64d specifier.","['2\n1 2\n1\n1\n', '2\n2 1\n1\n1\n', '3\n3 1 2\n3\n1 2 3\n']","['1 2\n', '2 1\n', '6 6\n']","In the first sample Vasya's approach will make one comparison (it starts with the 1-st element and immediately finds the required number), and Petya's approach makes two comparisons (first he compares with the 2-nd array element, doesn't find the search item and compares with the 1-st element).

In the second sample, on the contrary, Vasya's approach will need two comparisons (first with 1-st element, and then with the 2-nd), and Petya's approach will find the required value in one comparison (the first comparison with the 2-nd element).",TIME_LIMIT_EXCEEDED,"def a(c,d):
    for i in range(len(c)):
        if d==c[i]:
            return i+1
n=int(input())
a=list(map(int, input().split()))
m=int(input())
b=list(map(int, input().split()))
v=0
p=0
for d in b:
    b=a(a,d)
    v+=b
    p+=n-b+1
print(v,p)","def b():
    import c
    a = c.stdin.read().split()
    if not a:
        return
    n = int(a[0])
    k = int(a[1])

    r = list(map(int, a[2:2 + 2 * n + 1]))

    y = r[:]

    for i in range(1, len(r) - 1, 2):
        if k == 0:
            break

        if r[i] - 1 > r[i - 1] and r[i] - 1 > r[i + 1]:
            y[i] = r[i] - 1
            k -= 1

    c.stdout.write("" "".join(map(str, y)) + ""\n"")

if __name__ == '__main__':
    b()"
498,C,Array and Operations,PROGRAMMING,"['flows', 'graph matchings', 'number theory']","You have written on a piece of paper an array of *n* positive integers *a*[1],<=*a*[2],<=...,<=*a*[*n*] and *m* good pairs of integers (*i*1,<=*j*1),<=(*i*2,<=*j*2),<=...,<=(*i**m*,<=*j**m*). Each good pair (*i**k*,<=*j**k*) meets the following conditions: *i**k*<=+<=*j**k* is an odd number and 1<=≤<=*i**k*<=&lt;<=*j**k*<=≤<=*n*.

In one operation you can perform a sequence of actions: 
 -  take one of the good pairs (*i**k*,<=*j**k*) and some integer *v* (*v*<=&gt;<=1), which divides both numbers *a*[*i**k*] and *a*[*j**k*]; -  divide both numbers by *v*, i. e. perform the assignments:  and . 
Determine the maximum number of operations you can sequentially perform on the given array. Note that one pair may be used several times in the described operations.","The first line contains two space-separated integers *n*, *m* (2<=≤<=*n*<=≤<=100, 1<=≤<=*m*<=≤<=100).

The second line contains *n* space-separated integers *a*[1],<=*a*[2],<=...,<=*a*[*n*] (1<=≤<=*a*[*i*]<=≤<=109) — the description of the array.

The following *m* lines contain the description of good pairs. The *k*-th line contains two space-separated integers *i**k*, *j**k* (1<=≤<=*i**k*<=&lt;<=*j**k*<=≤<=*n*, *i**k*<=+<=*j**k* is an odd number).

It is guaranteed that all the good pairs are distinct.",Output the answer for the problem.,"['3 2\n8 3 8\n1 2\n2 3\n', '3 2\n8 12 8\n1 2\n2 3\n']","['0\n', '2\n']",none,OK,"L,m=[int(e) for e in input().split()]
def d(x):
    d={}
    i=2
    while i*i<=x:
        if x%i==0:
            d[i]=1
            x//=i
            while x%i==0:
                x//=i
                d[i]+=1
        i+=1
    if x!=1:
        d[x]=1
    return d
D=[d(int(e)) for e in input().split()]
a=[]
c=[]
I={}
J={}
for _ in range(m):
    i,j=[int(e)-1 for e in input().split()]
    if i%2>j%2:
        i,j=j,i
    for a in D[i].keys():
        if a in D[j]:
            for i in range(D[i][a]):
                for j in range(D[j][a]):
                    e=(i,a,i)
                    f=(j,a,j)
                    g=None
                    h=None
                    if e not in I.keys():
                        g=len(a)
                        a.append([])
                        I[e]=g
                    else:
                        g=I[e]
                    if f not in J.keys():
                        h=len(c)
                        c.append(-1)
                        J[f]=h
                    else:
                        h=J[f]
                    a[g].append(h)
n=len(a)
k=len(c)
u=[0]*n
def b(x):
    if u[x]:
        return 0
    u[x]=1
    for y in a[x]:
        if c[y]==-1 or b(c[y]):
            c[y]=x
            return 1
    return 0
for i in range(n):
    u=[0]*n
    b(i)
print(sum(x!=-1 for x in c))","""""""
This script computes the number of seconds until Vasya’s seat is served.
The airplane has infinitely many rows and a fixed pattern for flight attendants serving rows.
Each row has six seats with serving order: f, e, d, a, b, c.
Flight attendants serve rows in pairs with the following schedule:
    Pair0: rows 1 (attendant A) and 3 (attendant B) served starting at t = 0
    Pair1: rows 2 (A) and 4 (B) served starting at t = 7
    Pair2: rows 5 (A) and 7 (B) served starting at t = 16
    Pair3: rows 6 (A) and 8 (B) served starting at t = 23
    Pair4: rows 9 (A) and 11 (B) served starting at t = 32
    Pair5: rows 10 (A) and 12 (B) served starting at t = 39
    ... and so on.
The pattern for the starting time of pairs is based on alternating moves:
    After one pair is served, the flight attendants move 1 row forward (taking 1 second),
    and after the next pair they move 3 rows forward (taking 3 seconds).
Thus, pairs with even indices start at T = 16*m and pairs with odd indices start at T = 16*m + 7,
where m = pair_index//2.
For assigning rows to pairs:
    Attendant A serves rows whose last digit mod 4 is 1 or 2.
    Attendant B serves rows whose last digit mod 4 is 3 or 0.
The mapping to pair index is as follows:
    If row % 4 == 1: pair_index = 2 * ((row - 1) // 4)
    If row % 4 == 2: pair_index = 2 * ((row - 2) // 4) + 1
    If row % 4 == 3: pair_index = 2 * ((row - 3) // 4)
    If row % 4 == 0: pair_index = 2 * ((row - 4) // 4) + 1
Within the row, the seat order positions are:
    seat 'f' -> position 1
    seat 'e' -> position 2
    seat 'd' -> position 3
    seat 'a' -> position 4
    seat 'b' -> position 5
    seat 'c' -> position 6
The final answer is the sum of the start time for the serving pair and the seat order.
""""""

import k

def c():

    i = {
        'f': 1,
        'e': 2,
        'd': 3,
        'a': 4,
        'b': 5,
        'c': 6
    }

    a = k.stdin.read().splitlines()
    for b in a:
        if not b:
            continue

        i = 0
        g = 0

        while i < len(b) and b[i].isdigit():
            g = g * 10 + int(b[i])
            i += 1
        h = b[i]

        f = g % 4
        if f == 1:

            d = 2 * ((g - 1) // 4)
        elif f == 2:

            d = 2 * ((g - 2) // 4) + 1
        elif f == 3:

            d = 2 * ((g - 3) // 4)
        else:
            d = 2 * ((g - 4) // 4) + 1

        if d % 2 == 0:
            m = d // 2
            j = 16 * m
        else:
            m = (d - 1) // 2
            j = 16 * m + 7

        e = j + i[h]

        print(e)

if __name__ == '__main__':
    c()"
822,A,I'm bored with life,PROGRAMMING,"['implementation', 'math', 'number theory']","Holidays have finished. Thanks to the help of the hacker Leha, Noora managed to enter the university of her dreams which is located in a town Pavlopolis. It's well known that universities provide students with dormitory for the period of university studies. Consequently Noora had to leave Vičkopolis and move to Pavlopolis. Thus Leha was left completely alone in a quiet town Vičkopolis. He almost even fell into a depression from boredom!

Leha came up with a task for himself to relax a little. He chooses two integers *A* and *B* and then calculates the greatest common divisor of integers ""*A* factorial"" and ""*B* factorial"". Formally the hacker wants to find out GCD(*A*!,<=*B*!). It's well known that the factorial of an integer *x* is a product of all positive integers less than or equal to *x*. Thus *x*!<==<=1·2·3·...·(*x*<=-<=1)·*x*. For example 4!<==<=1·2·3·4<==<=24. Recall that GCD(*x*,<=*y*) is the largest positive integer *q* that divides (without a remainder) both *x* and *y*.

Leha has learned how to solve this task very effective. You are able to cope with it not worse, aren't you?","The first and single line contains two integers *A* and *B* (1<=≤<=*A*,<=*B*<=≤<=109,<=*min*(*A*,<=*B*)<=≤<=12).",Print a single integer denoting the greatest common divisor of integers *A*! and *B*!.,['4 3\n'],['6\n'],"Consider the sample.

4! = 1·2·3·4 = 24. 3! = 1·2·3 = 6. The greatest common divisor of integers 24 and 6 is exactly 6.",OK,"import math
from math import b

def a(a,b):
    c = 1
    for i in range(1,min(a,b)+1):
        c*=i
    return c

a,b = list(map(int,input().split()))

x = a(a,b)
y = a(a,b)
print(b(x,y))","def c():
    import d

    b = d.stdin.read().split()
    if not b:
        return
    n = int(b[0])
    m = int(b[1])

    a = (pow(3, n, m) - 1) % m

    d.stdout.write(str(a))
    
if __name__ == '__main__':
    c()"
723,A,The New Year: Meeting Friends,PROGRAMMING,"['implementation', 'math', 'sortings']","There are three friend living on the straight line *Ox* in Lineland. The first friend lives at the point *x*1, the second friend lives at the point *x*2, and the third friend lives at the point *x*3. They plan to celebrate the New Year together, so they need to meet at one point. What is the minimum total distance they have to travel in order to meet at some point and celebrate the New Year?

It's guaranteed that the optimal answer is always integer.","The first line of the input contains three distinct integers *x*1, *x*2 and *x*3 (1<=≤<=*x*1,<=*x*2,<=*x*3<=≤<=100) — the coordinates of the houses of the first, the second and the third friends respectively.",Print one integer — the minimum total distance the friends need to travel in order to meet together.,"['7 1 4\n', '30 20 10\n']","['6\n', '20\n']","In the first sample, friends should meet at the point 4. Thus, the first friend has to travel the distance of 3 (from the point 7 to the point 4), the second friend also has to travel the distance of 3 (from the point 1 to the point 4), while the third friend should not go anywhere because he lives at the point 4.",OK,"def a(a,b,c):
    a = int(a)
    b = int(b)
    c = int(c)
    b=abs(a-b)+abs(a-c)
    c=abs(b-a)+abs(b-c)
    d=abs(c-a)+abs(c-b)
    return min(b,c,d)
x=input()
a,b,c=x.split()

print(a(a,b,c))","def e():
    import l

    d = l.stdin.read().strip().split()
    b = list(map(int, d))
    
    f = 0

    for i in range(14):

        if b[i] == 0:
            continue
        
        k = b[i]
        g = b.copy()
        g[i] = 0

        a = k // 14
        i = k % 14

        for j in range(14):
            g[j] += a

        h = (i + 1) % 14
        for _ in range(i):
            g[h] += 1
            h = (h + 1) % 14

        j = 0
        for c in g:
            if c % 2 == 0:
                j += c

        f = max(f, j)

    print(f)

if __name__ == ""__main__"":
    e()"
556,A,Case of the Zeros and Ones,PROGRAMMING,['greedy'],"Andrewid the Android is a galaxy-famous detective. In his free time he likes to think about strings containing zeros and ones.

Once he thought about a string of length *n* consisting of zeroes and ones. Consider the following operation: we choose any two adjacent positions in the string, and if one them contains 0, and the other contains 1, then we are allowed to remove these two digits from the string, obtaining a string of length *n*<=-<=2 as a result.

Now Andreid thinks about what is the minimum length of the string that can remain after applying the described operation several times (possibly, zero)? Help him to calculate this number.","First line of the input contains a single integer *n* (1<=≤<=*n*<=≤<=2·105), the length of the string that Andreid has.

The second line contains the string of length *n* consisting only from zeros and ones.",Output the minimum length of the string that may remain after applying the described operations several times.,"['4\n1100\n', '5\n01010\n', '8\n11101111\n']","['0\n', '1\n', '6\n']","In the first sample test it is possible to change the string like the following: <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/10df55364c21c6e8d5da31b6ab6f6294c4fc26b3.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>.

In the second sample test it is possible to change the string like the following: <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/19ec5dcd85f0b5cf757aa076ace72df39634de2d.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>.

In the third sample test it is possible to change the string like the following: <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/dc34a159e4230375fa325555527ebc748811f188.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>.",OK,"def b(n, c):
  l = list(c)
  d = l.count('0')
  a = l.count('1')
  return n - (2 * min(d, a))

n = int(input())
c = input()
print(b(n, c))","import n
from collections import d

def a(m, n, g):
    """"""
    Perform BFS from the given start node and return the farthest node
    along with its distance from the start.
    """"""

    e = [-1] * (n + 1)
    e[m] = 0
    l = d([m])
    f = m

    while l:
        b = l.popleft()
        for k in g[b]:
            if e[k] == -1:
                e[k] = e[b] + 1
                l.append(k)
                if e[k] > e[f]:
                    f = k
    return f, e[f]

def j():

    c = n.stdin.read().strip().split()
    if not c:
        return

    n = int(c[0])
    m = int(c[1])

    g = [[] for _ in range(n + 1)]
    h = 2
    for _ in range(m):
        a = int(c[h])
        b = int(c[h + 1])
        h += 2

        g[a].append(b)
        g[b].append(a)

    if n <= 1:
        print(0)
        return

    u, _ = a(1, n, g)

    _, i = a(u, n, g)

    print(i)

if __name__ == ""__main__"":
    j()"
22,A,Second Order Statistics,PROGRAMMING,['brute force'],Once Bob needed to find the second order statistics of a sequence of integer numbers. Lets choose each number from the sequence exactly once and sort them. The value on the second position is the second order statistics of the given sequence. In other words it is the smallest element strictly greater than the minimum. Help Bob solve this problem.,The first input line contains integer *n* (1<=≤<=*n*<=≤<=100) — amount of numbers in the sequence. The second line contains *n* space-separated integer numbers — elements of the sequence. These numbers don't exceed 100 in absolute value.,"If the given sequence has the second order statistics, output this order statistics, otherwise output NO.","['4\n1 2 2 -4\n', '5\n1 2 3 1 1\n']","['1\n', '2\n']",none,WRONG_ANSWER,"n = int(input())
a = float('inf')
b = float('inf')

for i in map(int, input().split()):

    if i < a:
        a, b = i, a
    elif a < i < b:
        b = i

print(b)","def c():
    import d

    a = d.stdin.read().split()
    if not a:
        return

    n = int(a[0])

    if n % 2 == 0:
        k = n // 2
        print(k)

        print("" "".join([""2""] * k))
    else:

        k = (n - 3) // 2 + 1
        print(k)

        b = [""3""] + [""2""] * ((n - 3) // 2)
        print("" "".join(b))

if __name__ == ""__main__"":
    c()"
160,A,Twins,PROGRAMMING,"['greedy', 'sortings']","Imagine that you have a twin brother or sister. Having another person that looks exactly like you seems very unusual. It's hard to say if having something of an alter ego is good or bad. And if you do have a twin, then you very well know what it's like.

Now let's imagine a typical morning in your family. You haven't woken up yet, and Mom is already going to work. She has been so hasty that she has nearly forgotten to leave the two of her darling children some money to buy lunches in the school cafeteria. She fished in the purse and found some number of coins, or to be exact, *n* coins of arbitrary values *a*1,<=*a*2,<=...,<=*a**n*. But as Mom was running out of time, she didn't split the coins for you two. So she scribbled a note asking you to split the money equally.

As you woke up, you found Mom's coins and read her note. ""But why split the money equally?"" — you thought. After all, your twin is sleeping and he won't know anything. So you decided to act like that: pick for yourself some subset of coins so that the sum of values of your coins is strictly larger than the sum of values of the remaining coins that your twin will have. However, you correctly thought that if you take too many coins, the twin will suspect the deception. So, you've decided to stick to the following strategy to avoid suspicions: you take the minimum number of coins, whose sum of values is strictly more than the sum of values of the remaining coins. On this basis, determine what minimum number of coins you need to take to divide them in the described manner.","The first line contains integer *n* (1<=≤<=*n*<=≤<=100) — the number of coins. The second line contains a sequence of *n* integers *a*1, *a*2, ..., *a**n* (1<=≤<=*a**i*<=≤<=100) — the coins' values. All numbers are separated with spaces.",In the single line print the single number — the minimum needed number of coins.,"['2\n3 3\n', '3\n2 1 2\n']","['2\n', '2\n']","In the first sample you will have to take 2 coins (you and your twin have sums equal to 6, 0 correspondingly). If you take 1 coin, you get sums 3, 3. If you take 0 coins, you get sums 0, 6. Those variants do not satisfy you as your sum should be strictly more that your twins' sum.

In the second sample one coin isn't enough for us, too. You can pick coins with values 1, 2 or 2, 2. In any case, the minimum number of coins equals 2.",RUNTIME_ERROR,"def d(b):
    f = sum(b)
    h = 0
    g = 0
    e = 0

    b.sort(reverse=True)

    for a in b:
        h += a
        g += b[e + 1] if e + 1 < len(b) else 0
        f -= a
        e += 1
        if h > g:
            break

    return e

b = []
n=int(input())
for i in range(n):
    b.append(int(input()))
c = d(b)
print(c)","n = int(input().strip())
c = list(map(int, input().split()))

b = 0

for i in range(n):
    a = 1

    j = i - 1
    while j >= 0 and c[j] <= c[j + 1]:
        a += 1
        j -= 1

    j = i + 1
    while j < n and c[j] <= c[j - 1]:
        a += 1
        j += 1

    b = max(b, a)

print(b)"
344,A,Magnets,PROGRAMMING,['implementation'],"Mad scientist Mike entertains himself by arranging rows of dominoes. He doesn't need dominoes, though: he uses rectangular magnets instead. Each magnet has two poles, positive (a ""plus"") and negative (a ""minus""). If two magnets are put together at a close distance, then the like poles will repel each other and the opposite poles will attract each other.

Mike starts by laying one magnet horizontally on the table. During each following step Mike adds one more magnet horizontally to the right end of the row. Depending on how Mike puts the magnet on the table, it is either attracted to the previous one (forming a group of multiple magnets linked together) or repelled by it (then Mike lays this magnet at some distance to the right from the previous one). We assume that a sole magnet not linked to others forms a group of its own.

Mike arranged multiple magnets in a row. Determine the number of groups that the magnets formed.","The first line of the input contains an integer *n* (1<=≤<=*n*<=≤<=100000) — the number of magnets. Then *n* lines follow. The *i*-th line (1<=≤<=*i*<=≤<=*n*) contains either characters ""01"", if Mike put the *i*-th magnet in the ""plus-minus"" position, or characters ""10"", if Mike put the magnet in the ""minus-plus"" position.",On the single line of the output print the number of groups of magnets.,"['6\n10\n10\n10\n01\n10\n10\n', '4\n01\n01\n10\n10\n']","['3\n', '2\n']","The first testcase corresponds to the figure. The testcase has three groups consisting of three, one and two magnets.

The second testcase has two groups, each consisting of two magnets.",OK,"def a(n, c):
    b = 1
    for i in range(1, n):
        if c[i] != c[i-1]:
            b += 1
    return b

n = int(input())
c = [input() for _ in range(n)]

d = a(n, c)

print(d)","import i

def d():

    b = i.stdin.read().strip().split()
    if not b:
        return

    n = int(b[0])
    m = int(b[1])

    a = [set() for _ in range(n + 1)]

    c = 2
    for _ in range(m):
        a = int(b[c])
        b = int(b[c + 1])
        c += 2
        a[a].add(b)
        a[b].add(a)

    g = 0

    while True:

        f = []
        for h in range(1, n + 1):
            if len(a[h]) == 1:
                f.append(h)

        if not f:
            break
        
        g += 1

        for h in f:
            if len(a[h]) == 1:

                e = next(iter(a[h]))

                a[e].discard(h)

            a[h].clear()

    print(g)

if __name__ == '__main__':
    d()"
230,B,T-primes,PROGRAMMING,"['binary search', 'implementation', 'math', 'number theory']","We know that prime numbers are positive integers that have exactly two distinct positive divisors. Similarly, we'll call a positive integer *t* Т-prime, if *t* has exactly three distinct positive divisors.

You are given an array of *n* positive integers. For each of them determine whether it is Т-prime or not.","The first line contains a single positive integer, *n* (1<=≤<=*n*<=≤<=105), showing how many numbers are in the array. The next line contains *n* space-separated integers *x**i* (1<=≤<=*x**i*<=≤<=1012).

Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is advised to use the cin, cout streams or the %I64d specifier.","Print *n* lines: the *i*-th line should contain ""YES"" (without the quotes), if number *x**i* is Т-prime, and ""NO"" (without the quotes), if it isn't.",['3\n4 5 6\n'],['YES\nNO\nNO\n'],"The given test has three numbers. The first number 4 has exactly three divisors — 1, 2 and 4, thus the answer for this number is ""YES"". The second number 5 has two divisors (1 and 5), and the third number 6 has four divisors (1, 2, 3, 6), hence the answer for them is ""NO"".",TIME_LIMIT_EXCEEDED,"n = int(input())
t = list(map(int,input().split()))
import b

def a(n):
    y = int(b.sqrt(n))
    if y * y == n :
        return y
    else :
        return y * y == n

for c in t:
    d = a(c)
    if d == False or d == 1 :
        print(""NO"")
        continue
    else :
        for t in range (2,d):
            if c % t == 0 :
                print(""NO"")
                break
        else :
            print(""YES"")","def l():
    import r
    r.setrecursionlimit(300000)
    g = r.stdin.read().split()
    if not g:
        return

    k = iter(g)
    n = int(next(k))

    s = [[] for _ in range(n + 1)]
    j = []
    for _ in range(n - 1):
        u = int(next(k))
        v = int(next(k))
        s[u].append(v)
        s[v].append(u)
        j.append((u, v))

    f = [0] * (n + 1)
    for i in range(1, n + 1):
        f[i] = int(next(k))

    i = []
    for u, v in j:
        if f[u] != f[v]:
            i.append((u, v))

    if not i:
        r.stdout.write(""YES\n1"")
        return

    a, b = i[0][0], i[0][1]

    def d(c):
        for u, v in i:
            if c != u and c != v:
                return False
        return True

    def h(n, p, o):
        for m in s[n]:
            if m == p:
                continue
            if f[m] != o:
                return False
            if not h(m, n, o):
                return False
        return True

    def t(c):
        for e in s[c]:

            if not h(e, c, f[e]):
                return False
        return True

    q = None

    if d(a):
        if t(a):
            q = a

    if q is None and d(b):
        if t(b):
            q = b

    if q is None:
        r.stdout.write(""NO"")
    else:
        r.stdout.write(""YES\n"" + str(q))

if __name__ == '__main__':
    l()"
817,D,Imbalanced Array,PROGRAMMING,"['data structures', 'divide and conquer', 'dsu', 'sortings']","You are given an array *a* consisting of *n* elements. The imbalance value of some subsegment of this array is the difference between the maximum and minimum element from this segment. The imbalance value of the array is the sum of imbalance values of all subsegments of this array.

For example, the imbalance value of array [1,<=4,<=1] is 9, because there are 6 different subsegments of this array: 
 -  [1] (from index 1 to index 1), imbalance value is 0; -  [1,<=4] (from index 1 to index 2), imbalance value is 3; -  [1,<=4,<=1] (from index 1 to index 3), imbalance value is 3; -  [4] (from index 2 to index 2), imbalance value is 0; -  [4,<=1] (from index 2 to index 3), imbalance value is 3; -  [1] (from index 3 to index 3), imbalance value is 0; 
You have to determine the imbalance value of the array *a*.","The first line contains one integer *n* (1<=≤<=*n*<=≤<=106) — size of the array *a*.

The second line contains *n* integers *a*1,<=*a*2... *a**n* (1<=≤<=*a**i*<=≤<=106) — elements of the array.",Print one integer — the imbalance value of *a*.,['3\n1 4 1\n'],['9\n'],none,TIME_LIMIT_EXCEEDED,"n = int(input().strip())
b = list(map(int, input().strip().split()))

l = [0 for _ in range(4 * n)]
def d(a, i, k, v=1):
	if i == k:
		l[v] = (a[i], i)
	else:
		j = (i + k) // 2
		d(a, i, j, v + v)
		d(a, j + 1, k, v + v + 1)
		l[v] = max(l[v + v], l[v + v + 1])

a = -10**6
def g(i, k, l, r, v=1):
	if l > r:
		return (a, -1)
	if l == i and r == k:
		return l[v]
	j = (i + k) // 2
	return max(g(i, j, l, min(r, j), v + v), g(j + 1, k, max(l, j + 1), r, v + v + 1))

def e(a, l, r):
	if l > r:
		return 0
	elif l == r:
		return a[l]
	m, f = g(0, n - 1, l, r)
	h = m * (f - l + 1) * (r - f + 1)
	h += e(a, l, f - 1)
	h += e(a, f + 1, r)
	return h

d(b, 0, n - 1)
h = e(b, 0, n - 1)
c = [-a for a in b]
d(c, 0, n - 1)
h += e(c, 0, n - 1)
print (h)","import m
m.setrecursionlimit(10**6)

def c(n):
    """"""
    Recursively computes the length of the sequence for number n.
    For n <= 1, the length is 1.
    For n > 1, the length is: 2 * len(f(n//2)) + 1.
    """"""
    if n <= 1:
        return 1
    return 2 * c(n // 2) + 1

def b(n, l, r):
    """"""
    Recursively counts the number of ones in the final sequence corresponding to n,
    in the 1-indexed range [l, r].
    
    The sequence for a number n is given by:
        f(n) = f(n//2) + [n % 2] + f(n//2), for n > 1,
        f(n) = [n], for n <= 1.
    
    Parameters:
        n : The current number.
        l, r : The range in the current sequence (1-indexed) for which 1s need to be counted.
    
    Returns:
        The count of 1s in f(n) within positions l through r.
    """"""

    n = c(n)
    if l > n or r < 1:
        return 0

    if n <= 1:

        return n if l <= 1 <= r else 0

    f = c(n // 2)
    i = f + 1

    a = 0

    e = l
    g = min(r, f)
    if e <= g:
        a += b(n // 2, e, g)

    if l <= i <= r:
        a += n % 2

    k = max(l - i, 1)
    l = r - i
    if k <= l:
        a += b(n // 2, k, l)
    
    return a

def h():

    d = m.stdin.read().strip().split()
    if not d:
        return
    n = int(d[0])
    l = int(d[1])
    r = int(d[2])

    j = b(n, l, r)
    m.stdout.write(str(j) + ""\n"")

if __name__ == ""__main__"":
    h()"
918,A,Eleven,PROGRAMMING,"['brute force', 'implementation']","Eleven wants to choose a new name for herself. As a bunch of geeks, her friends suggested an algorithm to choose a name for her. Eleven wants her name to have exactly *n* characters. 

Her friend suggested that her name should only consist of uppercase and lowercase letters 'O'. More precisely, they suggested that the *i*-th letter of her name should be 'O' (uppercase) if *i* is a member of Fibonacci sequence, and 'o' (lowercase) otherwise. The letters in the name are numbered from 1 to *n*. Fibonacci sequence is the sequence *f* where
 -  *f*1<==<=1, -  *f*2<==<=1, -  *f**n*<==<=*f**n*<=-<=2<=+<=*f**n*<=-<=1 (*n*<=&gt;<=2). 
As her friends are too young to know what Fibonacci sequence is, they asked you to help Eleven determine her new name.",The first and only line of input contains an integer *n* (1<=≤<=*n*<=≤<=1000).,Print Eleven's new name on the first and only line of output.,"['8\n', '15\n']","['OOOoOooO\n', 'OOOoOooOooooOoo\n']",none,RUNTIME_ERROR,"n = input () 

def a(n):
   if n <= 1:
       return 1
   else:
       return(a(n-1) + a(n-2))
 
f = [a(d) for d in range(1,n)]

for i in range(1,n+1):
    print (['o','O'][i in f],end='')","import l

def f(s, h):
    """"""
    Finds the minimal number of swaps required to group all animals of the given species together.
    The method finds a contiguous (in circular order) segment of length equal to the total count of the species
    that already has the maximum number of that species.
    A swap can correct one misplaced animal from inside the segment.
    """"""
    n = len(s)
    a = s.count(h)
    if a == 0:

        return 0
    e = 0
    b = 0

    for i in range(a):
        if s[i % n] == h:
            b += 1
    e = b

    for i in range(1, n):

        if s[(i - 1) % n] == h:
            b -= 1

        if s[(i + a - 1) % n] == h:
            b += 1
        if b > e:
            e = b

    g = a - e
    return g

def d():

    c = l.stdin.read().splitlines()
    if not c:
        return

    try:
        n = int(c[0])
    except ValueError:
        return
    if n <= 0:
        return

    s = c[1].strip()

    j = f(s, 'H')
    k = f(s, 'T')

    print(min(j, k))

if __name__ == ""__main__"":
    d()"
315,A,Sereja and Bottles,PROGRAMMING,['brute force'],"Sereja and his friends went to a picnic. The guys had *n* soda bottles just for it. Sereja forgot the bottle opener as usual, so the guys had to come up with another way to open bottles.

Sereja knows that the *i*-th bottle is from brand *a**i*, besides, you can use it to open other bottles of brand *b**i*. You can use one bottle to open multiple other bottles. Sereja can open bottle with opened bottle or closed bottle.

Knowing this, Sereja wants to find out the number of bottles they've got that they won't be able to open in any way. Help him and find this number.","The first line contains integer *n* (1<=≤<=*n*<=≤<=100) — the number of bottles. The next *n* lines contain the bottles' description. The *i*-th line contains two integers *a**i*,<=*b**i* (1<=≤<=*a**i*,<=*b**i*<=≤<=1000) — the description of the *i*-th bottle.",In a single line print a single integer — the answer to the problem.,"['4\n1 1\n2 2\n3 3\n4 4\n', '4\n1 2\n2 3\n3 4\n4 1\n']","['4\n', '0\n']",none,WRONG_ANSWER,"def c():
    n = int(input())
    b = []
    a = []
    for _ in range(n):
        a, b = map(int,input().split())
        a.append(a)
        b.append(b)

    open = set()
    d = 0
    for i in range(len(b)):
        if b[i] == a[i]:
            d += 1
        g = b[i]
        open.add(g)

    print(len(a) - len(open) + d)

c()","import g

def f():

    e = g.stdin.read().split()

    n = int(e[0])

    c = list(map(int, e[1:]))

    h = sum(c)

    c.sort(reverse=True)
    
    a = 0
    d = 0

    for b in c:
        a += b
        d += 1
        if a > h - a:
            print(d)
            return

if __name__ == ""__main__"":
    f()"
538,C,Tourist's Notes,PROGRAMMING,"['binary search', 'brute force', 'greedy', 'implementation', 'math']","A tourist hiked along the mountain range. The hike lasted for *n* days, during each day the tourist noted height above the sea level. On the *i*-th day height was equal to some integer *h**i*. The tourist pick smooth enough route for his hike, meaning that the between any two consecutive days height changes by at most 1, i.e. for all *i*'s from 1 to *n*<=-<=1 the inequality |*h**i*<=-<=*h**i*<=+<=1|<=≤<=1 holds.

At the end of the route the tourist rafted down a mountain river and some notes in the journal were washed away. Moreover, the numbers in the notes could have been distorted. Now the tourist wonders what could be the maximum height during his hike. Help him restore the maximum possible value of the maximum height throughout the hike or determine that the notes were so much distorted that they do not represent any possible height values that meet limits |*h**i*<=-<=*h**i*<=+<=1|<=≤<=1.","The first line contains two space-separated numbers, *n* and *m* (1<=≤<=*n*<=≤<=108, 1<=≤<=*m*<=≤<=105) — the number of days of the hike and the number of notes left in the journal.

Next *m* lines contain two space-separated integers *d**i* and *h**d**i* (1<=≤<=*d**i*<=≤<=*n*, 0<=≤<=*h**d**i*<=≤<=108) — the number of the day when the *i*-th note was made and height on the *d**i*-th day. It is guaranteed that the notes are given in the chronological order, i.e. for all *i* from 1 to *m*<=-<=1 the following condition holds: *d**i*<=&lt;<=*d**i*<=+<=1.","If the notes aren't contradictory, print a single integer — the maximum possible height value throughout the whole route.

If the notes do not correspond to any set of heights, print a single word 'IMPOSSIBLE' (without the quotes).","['8 2\n2 0\n7 0\n', '8 3\n2 0\n7 0\n8 3\n']","['2\n', 'IMPOSSIBLE\n']","For the first sample, an example of a correct height sequence with a maximum of 2: (0, 0, 1, 2, 1, 1, 0, 1).

In the second sample the inequality between *h*<sub class=""lower-index"">7</sub> and *h*<sub class=""lower-index"">8</sub> does not hold, thus the information is inconsistent.",WRONG_ANSWER,"from re import L
from sys import f
input=f.readline

j=[]

d=-1e9

n,m=map(int,input().split())
for _ in range(m):
    d,h=map(int,input().split())
    d=max(d,h)
    j.append([d,h])

def e(c,n):
    l,r=0,1e8
    a=abs(c[0]-n[0])-abs(c[1]-n[1])
    while l<r:
        c=(l+r)//2
        if a//2>c:
            l=c+1
        else:
            r=c
    return int(l)
    pass

for i in range(m-1):
    next=j[i+1];b=j[i]
    if abs(b[1]-next[1])>abs(b[0]-next[0]):print('IMPOSSIBLE');exit()
    else:
        d=max(d,e(b,next))
print(d)","import i
from collections import c

def g():

    f = i.stdin.read().split()
    if not f:
        return
    n = int(f[0])

    a = [0] * (n + 1)
    for i in range(1, n + 1):
        a[i] = int(f[i])

    d = [10**9] * (n + 1)

    d[1] = 0

    e = c([1])
    
    while e:
        a = e.popleft()
        b = d[a]

        if a - 1 >= 1 and d[a - 1] > b + 1:
            d[a - 1] = b + 1
            e.append(a - 1)

        if a + 1 <= n and d[a + 1] > b + 1:
            d[a + 1] = b + 1
            e.append(a + 1)

        h = a[a]
        if h >= a and h <= n and d[h] > b + 1:
            d[h] = b + 1
            e.append(h)

    i.stdout.write("" "".join(str(d[i]) for i in range(1, n + 1)) + "" \n"")

if __name__ == '__main__':
    g()"
129,B,Students and Shoelaces,PROGRAMMING,"['brute force', 'dfs and similar', 'graphs', 'implementation']","Anna and Maria are in charge of the math club for junior students. When the club gathers together, the students behave badly. They've brought lots of shoe laces to the club and got tied with each other. Specifically, each string ties together two students. Besides, if two students are tied, then the lace connects the first student with the second one as well as the second student with the first one.

To restore order, Anna and Maria do the following. First, for each student Anna finds out what other students he is tied to. If a student is tied to exactly one other student, Anna reprimands him. Then Maria gathers in a single group all the students who have been just reprimanded. She kicks them out from the club. This group of students immediately leaves the club. These students takes with them the laces that used to tie them. Then again for every student Anna finds out how many other students he is tied to and so on. And they do so until Anna can reprimand at least one student.

Determine how many groups of students will be kicked out of the club.","The first line contains two integers *n* and *m* — the initial number of students and laces (). The students are numbered from 1 to *n*, and the laces are numbered from 1 to *m*. Next *m* lines each contain two integers *a* and *b* — the numbers of students tied by the *i*-th lace (1<=≤<=*a*,<=*b*<=≤<=*n*,<=*a*<=≠<=*b*). It is guaranteed that no two students are tied with more than one lace. No lace ties a student to himself.",Print the single number — the number of groups of students that will be kicked out from the club.,"['3 3\n1 2\n2 3\n3 1\n', '6 3\n1 2\n2 3\n3 4\n', '6 5\n1 4\n2 4\n3 4\n5 4\n6 4\n']","['0\n', '2\n', '1\n']","In the first sample Anna and Maria won't kick out any group of students — in the initial position every student is tied to two other students and Anna won't be able to reprimand anyone.

In the second sample four students are tied in a chain and two more are running by themselves. First Anna and Maria kick out the two students from both ends of the chain (1 and 4), then — two other students from the chain (2 and 3). At that the students who are running by themselves will stay in the club.

In the third sample Anna and Maria will momentarily kick out all students except for the fourth one and the process stops at that point. The correct answer is one.",OK,"from collections import a
n,m=map(int,input().split())
b=a(list)
c=[0]*n
for i in range(m):
    u,v=list(map(int,input().split()))
    u=u-1
    v=v-1
    c[u]+=1
    c[v]+=1
    b[u].append(v)
    b[v].append(u)
r=0
for i in range(n):
    d=[]
    for i in range(n):
        if c[i]==1:
            d.append(i)
            c[i]=0

    if len(d)==0:
        break

    r+=1
    for j in d:
        for k in b[j]:
            c[k]-=1

print(r)","def b(s):
    c = ""hello""
    j = 0

    for a in s:

        if j < len(c) and a == c[j]:
            j += 1

        if j == len(c):
            break

    return j == len(c)

if __name__ == ""__main__"":

    s = input().strip()

    if b(s):
        print(""YES"")
    else:
        print(""NO"")"
493,B,Vasya and Wrestling,PROGRAMMING,['implementation'],"Vasya has become interested in wrestling. In wrestling wrestlers use techniques for which they are awarded points by judges. The wrestler who gets the most points wins.

When the numbers of points of both wrestlers are equal, the wrestler whose sequence of points is lexicographically greater, wins.

If the sequences of the awarded points coincide, the wrestler who performed the last technique wins. Your task is to determine which wrestler won.","The first line contains number *n* — the number of techniques that the wrestlers have used (1<=≤<=*n*<=≤<=2·105). 

The following *n* lines contain integer numbers *a**i* (|*a**i*|<=≤<=109, *a**i*<=≠<=0). If *a**i* is positive, that means that the first wrestler performed the technique that was awarded with *a**i* points. And if *a**i* is negative, that means that the second wrestler performed the technique that was awarded with (<=-<=*a**i*) points.

The techniques are given in chronological order.","If the first wrestler wins, print string ""first"", otherwise print ""second""","['5\n1\n2\n-3\n-4\n3\n', '3\n-1\n-2\n3\n', '2\n4\n-4\n']","['second\n', 'first\n', 'second\n']","Sequence *x*  =  *x*<sub class=""lower-index"">1</sub>*x*<sub class=""lower-index"">2</sub>... *x*<sub class=""lower-index"">|*x*|</sub> is lexicographically larger than sequence *y*  =  *y*<sub class=""lower-index"">1</sub>*y*<sub class=""lower-index"">2</sub>... *y*<sub class=""lower-index"">|*y*|</sub>, if either |*x*|  &gt;  |*y*| and *x*<sub class=""lower-index"">1</sub>  =  *y*<sub class=""lower-index"">1</sub>,  *x*<sub class=""lower-index"">2</sub>  =  *y*<sub class=""lower-index"">2</sub>, ... ,  *x*<sub class=""lower-index"">|*y*|</sub>  =  *y*<sub class=""lower-index"">|*y*|</sub>, or there is such number *r* (*r*  &lt;  |*x*|, *r*  &lt;  |*y*|), that *x*<sub class=""lower-index"">1</sub>  =  *y*<sub class=""lower-index"">1</sub>,  *x*<sub class=""lower-index"">2</sub>  =  *y*<sub class=""lower-index"">2</sub>,  ... ,  *x*<sub class=""lower-index"">*r*</sub>  =  *y*<sub class=""lower-index"">*r*</sub> and *x*<sub class=""lower-index"">*r*  +  1</sub>  &gt;  *y*<sub class=""lower-index"">*r*  +  1</sub>.

We use notation |*a*| to denote length of sequence *a*.",WRONG_ANSWER,"from collections import defaultdict
import cmath

n = int(input())
f = []
g = []
c = d = 0
a = """"
b = """"

for i in range(n):
    e = int(input())
    if e > 0:
        f.append(e)
        c += e
        a += str(e)
    else:
        g.append(e)
        d += abs(e)
        b += str(abs(e))

if c > d :
    print(""first"")
elif d > c :
    print(""second"")
else:
    if a > b:
        print(""first"")
    elif b > a:
        print(""second"")
    else:
        print(""second"")","import n
import m

def g(d):
    """"""
    Check if a date string in the format dd-mm-yyyy is a valid date according to:
    - Year between 2013 and 2015, inclusive
    - Month from 1 to 12
    - Day strictly more than zero and doesn't exceed the number of days in the current month
      (non-leap year)
    """"""
    try:

        e = int(d[0:2])
        j = int(d[3:5])
        o = int(d[6:10])
    except ValueError:
        return False

    if not (2013 <= o <= 2015):
        return False
    if not (1 <= j <= 12):
        return False

    f = {
        1: 31, 2: 28, 3: 31, 4: 30, 5: 31, 6: 30,
        7: 31, 8: 31, 9: 30, 10: 31, 11: 30, 12: 31
    }
    
    if not (1 <= e <= f[j]):
        return False
    return True

def h():

    l = n.stdin.read().strip()

    c = {}

    k = r""(?=(\d{2}-\d{2}-\d{4}))""
    
    for i in m.finditer(k, l):
        b = i.group(1)

        if g(b):
            c[b] = c.get(b, 0) + 1

    a = max(c, key=lambda d: c[d])
    
    print(a)

if __name__ == ""__main__"":
    h()"
834,A,The Useless Toy,PROGRAMMING,['implementation'],"Walking through the streets of Marshmallow City, Slastyona have spotted some merchants selling a kind of useless toy which is very popular nowadays – caramel spinner! Wanting to join the craze, she has immediately bought the strange contraption.

Spinners in Sweetland have the form of V-shaped pieces of caramel. Each spinner can, well, spin around an invisible magic axis. At a specific point in time, a spinner can take 4 positions shown below (each one rotated 90 degrees relative to the previous, with the fourth one followed by the first one):

After the spinner was spun, it starts its rotation, which is described by a following algorithm: the spinner maintains its position for a second then majestically switches to the next position in clockwise or counter-clockwise order, depending on the direction the spinner was spun in.

Slastyona managed to have spinner rotating for exactly *n* seconds. Being fascinated by elegance of the process, she completely forgot the direction the spinner was spun in! Lucky for her, she managed to recall the starting position, and wants to deduct the direction given the information she knows. Help her do this.","There are two characters in the first string – the starting and the ending position of a spinner. The position is encoded with one of the following characters: v (ASCII code 118, lowercase v), &lt; (ASCII code 60), ^ (ASCII code 94) or &gt; (ASCII code 62) (see the picture above for reference). Characters are separated by a single space.

In the second strings, a single number *n* is given (0<=≤<=*n*<=≤<=109) – the duration of the rotation.

It is guaranteed that the ending position of a spinner is a result of a *n* second spin in any of the directions, assuming the given starting position.","Output cw, if the direction is clockwise, ccw – if counter-clockwise, and undefined otherwise.","['^ &gt;\n1\n', '&lt; ^\n3\n', '^ v\n6\n']","['cw\n', 'ccw\n', 'undefined\n']",none,WRONG_ANSWER,"a = ""v<^>""
b = input()
n = int(input())
if n % 2 == 0:
    print(""undefined"")
else:
    if (a.find(b[0]) - a.find(b[2])) % 4 == n:
        print(""ccw"")
    else:
        print(""cw"")","def k():
    import n

    g = n.stdin.read().split()
    if not g:
        return

    j = iter(g)
    n = int(next(j))
    k = int(next(j))

    b = [int(next(j)) for _ in range(n)]

    i = []
    for a in b:
        c = 0
        d = 0
        o = a

        while o % 2 == 0:
            c += 1
            o //= 2
        o = a

        while o % 5 == 0:
            d += 1
            o //= 5
        i.append((c, d))

    h = [dict() for _ in range(k+1)]
    h[0][0] = 0

    for e, f in i:
        for j in range(k-1, -1, -1):
            for c, d in list(h[j].items()):
                l = c + e
                m = d + f

                if l in h[j+1]:
                    if m < h[j+1][l]:
                        h[j+1][l] = m
                else:
                    h[j+1][l] = m

    a = 0
    for p, q in h[k].items():
        a = max(a, min(p, q))
    
    n.stdout.write(str(a) + ""\n"")

if __name__ == '__main__':
    k()"
435,A,Queue on Bus Stop,PROGRAMMING,['implementation'],"It's that time of the year when the Russians flood their countryside summer cottages (dachas) and the bus stop has a lot of people. People rarely go to the dacha on their own, it's usually a group, so the people stand in queue by groups.

The bus stop queue has *n* groups of people. The *i*-th group from the beginning has *a**i* people. Every 30 minutes an empty bus arrives at the bus stop, it can carry at most *m* people. Naturally, the people from the first group enter the bus first. Then go the people from the second group and so on. Note that the order of groups in the queue never changes. Moreover, if some group cannot fit all of its members into the current bus, it waits for the next bus together with other groups standing after it in the queue.

Your task is to determine how many buses is needed to transport all *n* groups to the dacha countryside.","The first line contains two integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=100). The next line contains *n* integers: *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=*m*).",Print a single integer — the number of buses that is needed to transport all *n* groups to the dacha countryside.,"['4 3\n2 3 2 1\n', '3 4\n1 2 1\n']","['3\n', '1\n']",none,OK,"from sys import d

def c():
    n, m = map(int, d.readline().strip().split())
    b = iter(map(int, d.readline().strip().split()))
    try:
        a = e = 0
        while True:
            x = next(b)
            if e < x:
                a += 1
                e = m
            e -= x
    except StopIteration:
        return a

print(c())","def b():
    import d
    a = d.stdin.read().split()
    if not a:
        return
    n = int(a[0])

    if n % 2 == 0:
        d.stdout.write(""-1\n"")
        return

    a = list(range(n))

    c = (n + 1) // 2
    b = [(i + c) % n for i in range(n)]

    c = [(a[i] + b[i]) % n for i in range(n)]

    d.stdout.write("" "".join(map(str, a)) + ""\n"")
    d.stdout.write("" "".join(map(str, b)) + ""\n"")
    d.stdout.write("" "".join(map(str, c)) + ""\n"")

if __name__ == ""__main__"":
    b()"
604,A,Uncowed Forces,PROGRAMMING,['implementation'],"Kevin Sun has just finished competing in Codeforces Round #334! The round was 120 minutes long and featured five problems with maximum point values of 500, 1000, 1500, 2000, and 2500, respectively. Despite the challenging tasks, Kevin was uncowed and bulldozed through all of them, distinguishing himself from the herd as the best cowmputer scientist in all of Bovinia. Kevin knows his submission time for each problem, the number of wrong submissions that he made on each problem, and his total numbers of successful and unsuccessful hacks. Because Codeforces scoring is complicated, Kevin wants you to write a program to compute his final score.

Codeforces scores are computed as follows: If the maximum point value of a problem is *x*, and Kevin submitted correctly at minute *m* but made *w* wrong submissions, then his score on that problem is . His total score is equal to the sum of his scores for each problem. In addition, Kevin's total score gets increased by 100 points for each successful hack, but gets decreased by 50 points for each unsuccessful hack.

All arithmetic operations are performed with absolute precision and no rounding. It is guaranteed that Kevin's final score is an integer.","The first line of the input contains five space-separated integers *m*1, *m*2, *m*3, *m*4, *m*5, where *m**i* (0<=≤<=*m**i*<=≤<=119) is the time of Kevin's last submission for problem *i*. His last submission is always correct and gets accepted.

The second line contains five space-separated integers *w*1, *w*2, *w*3, *w*4, *w*5, where *w**i* (0<=≤<=*w**i*<=≤<=10) is Kevin's number of wrong submissions on problem *i*.

The last line contains two space-separated integers *h**s* and *h**u* (0<=≤<=*h**s*,<=*h**u*<=≤<=20), denoting the Kevin's numbers of successful and unsuccessful hacks, respectively.","Print a single integer, the value of Kevin's final score.","['20 40 60 80 100\n0 1 2 3 4\n1 0\n', '119 119 119 119 119\n0 0 0 0 0\n10 0\n']","['4900\n', '4930\n']","In the second sample, Kevin takes 119 minutes on all of the problems. Therefore, he gets <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/42158dc2bc78cd21fa679530ae9ef8b9ea298d15.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> of the points on each problem. So his score from solving problems is <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/fdf392d8508500b57f8057ac0c4c892ab5f925a2.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>. Adding in 10·100 = 1000 points from hacks, his total score becomes 3930 + 1000 = 4930.",WRONG_ANSWER,"def a(x, m, w):
    i = max(0.3*x, ((1 - m/250 )*x - 50*w));
    return i;

d, e, f, g, h = map(int, input().split("" ""))
j, k, l, m, n = map(int, input().split("" ""))
b, c = map(int, input().split("" ""))

i = a(500, d, j) + a(1000, e, k) + a(1500, f, l) + a(2000, g, m) + a(2500, h, n)

i += b*100
i-=c*50

print(i)","def b(n, d, f):

    a = 0
    g = 0

    for d in range(n):

        while g < n and f[g] - f[d] <= d:
            g += 1

        e = g - d - 1

        if e >= 2:

            a += e * (e - 1) // 2
    return a

if __name__ == '__main__':
    import h
    c = h.stdin.read().strip().split()

    n = int(c[0])
    d = int(c[1])

    f = list(map(int, c[2:2+n]))

    print(b(n, d, f))"
126,B,Password,PROGRAMMING,"['binary search', 'dp', 'hashing', 'string suffix structures', 'strings']","Asterix, Obelix and their temporary buddies Suffix and Prefix has finally found the Harmony temple. However, its doors were firmly locked and even Obelix had no luck opening them.

A little later they found a string *s*, carved on a rock below the temple's gates. Asterix supposed that that's the password that opens the temple and read the string aloud. However, nothing happened. Then Asterix supposed that a password is some substring *t* of the string *s*.

Prefix supposed that the substring *t* is the beginning of the string *s*; Suffix supposed that the substring *t* should be the end of the string *s*; and Obelix supposed that *t* should be located somewhere inside the string *s*, that is, *t* is neither its beginning, nor its end.

Asterix chose the substring *t* so as to please all his companions. Besides, from all acceptable variants Asterix chose the longest one (as Asterix loves long strings). When Asterix read the substring *t* aloud, the temple doors opened. 

You know the string *s*. Find the substring *t* or determine that such substring does not exist and all that's been written above is just a nice legend.","You are given the string *s* whose length can vary from 1 to 106 (inclusive), consisting of small Latin letters.","Print the string *t*. If a suitable *t* string does not exist, then print ""Just a legend"" without the quotes.","['fixprefixsuffix\n', 'abcdabc\n']","['fix', 'Just a legend']",none,WRONG_ANSWER,"def b(s):
    n=len(s)
    for i in range(n//2,0,-1):
        c=s[0:i]
        e=s[n-i:n]
        if c==e:
            return c,i
    return 0

s=str(input())
d,a=b(s)
f=s[a+1:len(s)-a]
if d in f:
    print(d)
else:
    print(""Just a legend"")","import l

def i():
    import l
    l.setrecursionlimit(300000)
    f = l.stdin.read().splitlines()
    if not f:
        return

    n = int(f[0].strip())

    a = list(map(int, f[1].split()))

    h = f[2].strip()

    g = [int(d) for d in h[::-1]]
    
    L = n

    e = [[0] * 2 for _ in range(L + 1)]

    for i in range(L - 1, -1, -1):
        for m in (0, 1):

            j = g[i] if m == 1 else 1
            b = -1
            for d in (0, 1):
                if d > j:
                    continue

                k = 1 if (m == 1 and d == g[i]) else 0
                a = a[n - 1 - i] if d == 1 else 0
                c = a + e[i + 1][k]
                if c > b:
                    b = c
            e[i][m] = b

    print(e[0][1])

if __name__ == '__main__':
    i()"
318,A,Even Odds,PROGRAMMING,['math'],"Being a nonconformist, Volodya is displeased with the current state of things, particularly with the order of natural numbers (natural number is positive integer number). He is determined to rearrange them. But there are too many natural numbers, so Volodya decided to start with the first *n*. He writes down the following sequence of numbers: firstly all odd integers from 1 to *n* (in ascending order), then all even integers from 1 to *n* (also in ascending order). Help our hero to find out which number will stand at the position number *k*.","The only line of input contains integers *n* and *k* (1<=≤<=*k*<=≤<=*n*<=≤<=1012).

Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.",Print the number that will stand at the position number *k* after Volodya's manipulations.,"['10 3\n', '7 7\n']","['5', '6']","In the first sample Volodya's sequence will look like this: {1, 3, 5, 7, 9, 2, 4, 6, 8, 10}. The third place in the sequence is therefore occupied by the number 5.",TIME_LIMIT_EXCEEDED,"def c():
    n, k = map(int, input().split())
    a=[]
    b=[]
    for x in range(n+1):
        if not x:
            continue
        if x%2==0:
            a.append(x)
        else:
            b.append(x)
    d = [*b, *a]
    print(d[k-1])
c()","def k():
    import l
    import f
    l.setrecursionlimit(10**7)

    a = l.stdin.read().split()
    if not a:
        return
    e = iter(a)
    n = int(next(e))
    m = int(next(e))
    k = int(next(e))

    c = [[] for _ in range(n + 1)]
    for _ in range(m):
        u = int(next(e))
        v = int(next(e))
        c[u].append(v)
        c[v].append(u)

    for i in range(1, n + 1):
        c[i].sort()

    n = []
    o = [False] * (n + 1)
    
    def b(u, h):
        n.append(u)
        o[u] = True
        for v in c[u]:
            if v == h:
                continue
            if not o[v]:
                b(v, u)
                n.append(u)
    
    b(1, -1)
    
    m = len(n)

    j = f.ceil(m / k)

    g = []
    d = 0
    for i in range(k):
        if d >= m:

            g.append(""1 1"")
        else:
            i = n[d: d + j]
            d += j

            g.append(str(len(i)) + "" "" + "" "".join(map(str, i)))
    
    l.stdout.write(""\n"".join(g))
    
if __name__ == '__main__':
    k()"
483,A,Counterexample ,PROGRAMMING,"['brute force', 'implementation', 'math', 'number theory']","Your friend has recently learned about coprime numbers. A pair of numbers {*a*,<=*b*} is called coprime if the maximum number that divides both *a* and *b* is equal to one. 

Your friend often comes up with different statements. He has recently supposed that if the pair (*a*,<=*b*) is coprime and the pair (*b*,<=*c*) is coprime, then the pair (*a*,<=*c*) is coprime. 

You want to find a counterexample for your friend's statement. Therefore, your task is to find three distinct numbers (*a*,<=*b*,<=*c*), for which the statement is false, and the numbers meet the condition *l*<=≤<=*a*<=&lt;<=*b*<=&lt;<=*c*<=≤<=*r*. 

More specifically, you need to find three numbers (*a*,<=*b*,<=*c*), such that *l*<=≤<=*a*<=&lt;<=*b*<=&lt;<=*c*<=≤<=*r*, pairs (*a*,<=*b*) and (*b*,<=*c*) are coprime, and pair (*a*,<=*c*) is not coprime.","The single line contains two positive space-separated integers *l*, *r* (1<=≤<=*l*<=≤<=*r*<=≤<=1018; *r*<=-<=*l*<=≤<=50).","Print three positive space-separated integers *a*, *b*, *c* — three distinct numbers (*a*,<=*b*,<=*c*) that form the counterexample. If there are several solutions, you are allowed to print any of them. The numbers must be printed in ascending order. 

If the counterexample does not exist, print the single number -1.","['2 4\n', '10 11\n', '900000000000000009 900000000000000029\n']","['2 3 4\n', '-1\n', '900000000000000009 900000000000000010 900000000000000021\n']","In the first sample pair (2, 4) is not coprime and pairs (2, 3) and (3, 4) are. 

In the second sample you cannot form a group of three distinct integers, so the answer is -1. 

In the third sample it is easy to see that numbers 900000000000000009 and 900000000000000021 are divisible by three.",WRONG_ANSWER,"import c
input = lambda: c.stdin.readline().rstrip()

def b():
    l,r = [int(a) for a in input().split("" "")]
    if(r-l<2):
        print(-1)
    elif(r-l>2):
        print(l+1,l+2,l+3)
    elif(l%2==0):
        print(l,l+1,l+2)
    else:
        print(-1)
   

if __name__ == '__main__':
    b()","k = int(input().strip())

b = list(map(int, input().split()))

if k == 0:
    print(0)
else:

    b.sort(reverse=True)

    d = 0
    c = 0

    for a in b:
        d += a
        c += 1

        if d >= k:
            print(c)
            break
    else:

        print(-1)"
471,A,MUH and Sticks,PROGRAMMING,['implementation'],"Two polar bears Menshykov and Uslada from the St.Petersburg zoo and elephant Horace from the Kiev zoo got six sticks to play with and assess the animals' creativity. Menshykov, Uslada and Horace decided to make either an elephant or a bear from those sticks. They can make an animal from sticks in the following way: 
 -  Four sticks represent the animal's legs, these sticks should have the same length. -  Two remaining sticks represent the animal's head and body. The bear's head stick must be shorter than the body stick. The elephant, however, has a long trunk, so his head stick must be as long as the body stick. Note that there are no limits on the relations between the leg sticks and the head and body sticks. 
Your task is to find out which animal can be made from the given stick set. The zoo keeper wants the sticks back after the game, so they must never be broken, even bears understand it.",The single line contains six space-separated integers *l**i* (1<=≤<=*l**i*<=≤<=9) — the lengths of the six sticks. It is guaranteed that the input is such that you cannot make both animals from the sticks.,"If you can make a bear from the given set, print string ""Bear"" (without the quotes). If you can make an elephant, print string ""Elephant"" (wıthout the quotes). If you can make neither a bear nor an elephant, print string ""Alien"" (without the quotes).","['4 2 5 4 4 4\n', '4 4 5 4 4 5\n', '1 2 3 4 5 6\n']","['Bear', 'Elephant', 'Alien']","If you're out of creative ideas, see instructions below which show how to make a bear and an elephant in the first two samples. The stick of length 2 is in red, the sticks of length 4 are in green, the sticks of length 5 are in blue.",WRONG_ANSWER,"A = []
def d(x):
    for i in range(len(A)):
        if A[i] == x:
            A[i] = -1
for i in input().split(' '):
    A.append(int(i))
c = False
for i in range(len(A)):
    if A.count(i) >= 4:
        d(i)
        c = True
if c:
    a = -1
    b = -1
    for i in A:
        if i != -1:
            if a == -1:
                a = i
            else:
                b = i
    if a == b:
        print(""Elephant"")
    else:
        print(""Bear"")
else:
    print(""Alien"")","def e():
    import l

    c = l.stdin.read().split()
    if not c:
        return
    d = iter(c)
    n = int(next(d))
    i, f = int(next(d)), int(next(d))
    j, g = int(next(d)), int(next(d))
    k, h = int(next(d)), int(next(d))

    a = min(f, n - (j + k))
    if a < i:
        a = i

    a = max(j, n - a - h)
    b = min(g, n - a - k)

    b = b

    c = n - a - b
    
    l.stdout.write(f""{a} {b} {c} \n"")

if __name__ == '__main__':
    e()"
548,A,Mike and Fax,PROGRAMMING,"['brute force', 'implementation', 'strings']","While Mike was walking in the subway, all the stuff in his back-bag dropped on the ground. There were several fax messages among them. He concatenated these strings in some order and now he has string *s*.

He is not sure if this is his own back-bag or someone else's. He remembered that there were exactly *k* messages in his own bag, each was a palindrome string and all those strings had the same length.

He asked you to help him and tell him if he has worn his own back-bag. Check if the given string *s* is a concatenation of *k* palindromes of the same length.","The first line of input contains string *s* containing lowercase English letters (1<=≤<=|*s*|<=≤<=1000).

The second line contains integer *k* (1<=≤<=*k*<=≤<=1000).","Print ""YES""(without quotes) if he has worn his own back-bag or ""NO""(without quotes) otherwise.","['saba\n2\n', 'saddastavvat\n2\n']","['NO\n', 'YES\n']","Palindrome is a string reading the same forward and backward.

In the second sample, the faxes in his back-bag can be ""saddas"" and ""tavvat"".",WRONG_ANSWER,"def c(e):
    if e[0:int(len(e)/2)] == e[-1:int((len(e) - 1)/2 ):-1]:
        return True
    return False

d = input()
k = int(input())
a = int(len(d)/k)
f = []
b = False
for i in range(k):
    f.append(d[a * i:(i+1)*a])
for i in range(k):
    if not c(f[i]):
        print ('NO')
        b = True
        break
if not b:
    print ('YES')","def c(i, k):

    h = i // 5
    g = i % 5
    a = h

    if k != 0 and g >= k:
        a += 1
    elif k == 0 and g == 0:

        pass
    return a

def j():
    import m

    e = m.stdin.read().strip().split()
    if not e:
        return
    n = int(e[0])
    m = int(e[1])

    d = [0] * 5
    b = [0] * 5
    
    for r in range(5):
        d[r] = c(n, r)
        b[r] = c(m, r)

    l = 0
    for r in range(5):

        f = (5 - r) % 5
        l += d[r] * b[f]
    
    m.stdout.write(str(l))
    
if __name__ == '__main__':
    j()"
1003,B,Binary String Constructing,PROGRAMMING,['constructive algorithms'],"You are given three integers $a$, $b$ and $x$. Your task is to construct a binary string $s$ of length $n = a + b$ such that there are exactly $a$ zeroes, exactly $b$ ones and exactly $x$ indices $i$ (where $1 \le i &lt; n$) such that $s_i \ne s_{i + 1}$. It is guaranteed that the answer always exists.

For example, for the string ""01010"" there are four indices $i$ such that $1 \le i &lt; n$ and $s_i \ne s_{i + 1}$ ($i = 1, 2, 3, 4$). For the string ""111001"" there are two such indices $i$ ($i = 3, 5$).

Recall that binary string is a non-empty sequence of characters where each character is either 0 or 1.","The first line of the input contains three integers $a$, $b$ and $x$ ($1 \le a, b \le 100, 1 \le x &lt; a + b)$.","Print only one string $s$, where $s$ is any binary string satisfying conditions described above. It is guaranteed that the answer always exists.","['2 2 1\n', '3 3 3\n', '5 3 6\n']","['1100\n', '101100\n', '01010100\n']","All possible answers for the first example: 
 -  1100; -  0011. 
All possible answers for the second example: 
 -  110100; -  101100; -  110010; -  100110; -  011001; -  001101; -  010011; -  001011.",WRONG_ANSWER,"import os
import sys
import math
import heapq
from decimal import *
from io import BytesIO, IOBase
from collections import defaultdict, deque

def r():
    return int(input())
def b():
    return map(int,input().split())
def a():
    return list(map(int,input().split()))

'''b Binary string construction'''
a,b,x=b()
c=(x+1)//2
s='01'*c
a-=c;b-=c
print('0'*a+s+'1'*b+'0'*(1 if x%2==0 else 0))","import g

def d():

    b = g.stdin.read().split()
    n = int(b[0])
    k = int(b[1])

    c = [chr(ord('a') + i) for i in range(k)]

    e = c.copy()

    for _ in range(n - k):
        for a in c:
            if a != e[-1]:
                e.append(a)
                break

    f = """".join(e)
    g.stdout.write(f)

if __name__ == ""__main__"":
    d()"
217,A,Ice Skating,PROGRAMMING,"['brute force', 'dfs and similar', 'dsu', 'graphs']","Bajtek is learning to skate on ice. He's a beginner, so his only mode of transportation is pushing off from a snow drift to the north, east, south or west and sliding until he lands in another snow drift. He has noticed that in this way it's impossible to get from some snow drifts to some other by any sequence of moves. He now wants to heap up some additional snow drifts, so that he can get from any snow drift to any other one. He asked you to find the minimal number of snow drifts that need to be created.

We assume that Bajtek can only heap up snow drifts at integer coordinates.","The first line of input contains a single integer *n* (1<=≤<=*n*<=≤<=100) — the number of snow drifts. Each of the following *n* lines contains two integers *x**i* and *y**i* (1<=≤<=*x**i*,<=*y**i*<=≤<=1000) — the coordinates of the *i*-th snow drift.

Note that the north direction coinсides with the direction of *Oy* axis, so the east direction coinсides with the direction of the *Ox* axis. All snow drift's locations are distinct.",Output the minimal number of snow drifts that need to be created in order for Bajtek to be able to reach any snow drift from any other one.,"['2\n2 1\n1 2\n', '2\n2 1\n4 1\n']","['1\n', '0\n']",none,WRONG_ANSWER,"def b(v):
    global c, g
    c[v]  = True
    for d in g[v]:
        if not c[d]:
            b(d)
n = int(input())
g = [[] for _ in range(n+1)]
x  = [0 for _ in range(n+1)]
y  = [0 for _ in range(n+1)]
c = [False for _ in range(n+1)]
for i in range(1, n+1):
    x[i], y[i] = map(int, input().split())
    for j in range(1, i):
        if (x[j] == x[i] and y[j] == y[i]):
            g[i].append(j)
            g[j].append(i)
a = 0
for i in range(1, n+1):
    if not c[i]:
        b(i)
        a+=1
print(a-1)","def d():
    import f
    c = f.stdin.read().split()
    if not c:
        return

    n = int(c[0])

    a = list(map(int, c[1:1+n]))

    e = sorted(a)

    i, j = 0, 0
    b = 0

    while i < n and j < n:

        if e[j] > e[i]:
            b += 1
            i += 1
            j += 1
        else:
            j += 1

    f.stdout.write(str(b))

if __name__ == '__main__':
    d()"
909,B,Segments,PROGRAMMING,"['constructive algorithms', 'math']","You are given an integer *N*. Consider all possible segments on the coordinate axis with endpoints at integer points with coordinates between 0 and *N*, inclusive; there will be  of them.

You want to draw these segments in several layers so that in each layer the segments don't overlap (they might touch at the endpoints though). You can not move the segments to a different location on the coordinate axis. 

Find the minimal number of layers you have to use for the given *N*.",The only input line contains a single integer *N* (1<=≤<=*N*<=≤<=100).,Output a single integer - the minimal number of layers required to draw the segments for the given *N*.,"['2\n', '3\n', '4\n']","['2\n', '4\n', '6\n']","As an example, here are the segments and their optimal arrangement into layers for *N* = 4.",OK,"def a(n):
    if n % 2==1:
        return ((n+1)//2)**2
    return (n//2)*(n//2+1)

n = int(input())
print(a(n))","import d

def b():

    s = d.stdin.readline().strip()
    n = len(s)

    a = 0

    for i in range(n):
        if int(s[i]) % 4 == 0:
            a += 1

    for i in range(1, n):

        c = int(s[i-1:i+1])
        if c % 4 == 0:

            a += i

    print(a)

if __name__ == '__main__':
    b()"
452,C,Magic Trick,PROGRAMMING,"['combinatorics', 'math', 'probabilities']","Alex enjoys performing magic tricks. He has a trick that requires a deck of *n* cards. He has *m* identical decks of *n* different cards each, which have been mixed together. When Alex wishes to perform the trick, he grabs *n* cards at random and performs the trick with those. The resulting deck looks like a normal deck, but may have duplicates of some cards.

The trick itself is performed as follows: first Alex allows you to choose a random card from the deck. You memorize the card and put it back in the deck. Then Alex shuffles the deck, and pulls out a card. If the card matches the one you memorized, the trick is successful.

You don't think Alex is a very good magician, and that he just pulls a card randomly from the deck. Determine the probability of the trick being successful if this is the case.","First line of the input consists of two integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=1000), separated by space — number of cards in each deck, and number of decks.",On the only line of the output print one floating point number – probability of Alex successfully performing the trick. Relative or absolute error of your answer should not be higher than 10<=-<=6.,"['2 2\n', '4 4\n', '1 2\n']","['0.6666666666666666\n', '0.4000000000000000\n', '1.0000000000000000\n']","In the first sample, with probability <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/64c94d13eeb330b494061e86538db66574ad0f7d.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> Alex will perform the trick with two cards with the same value from two different decks. In this case the trick is guaranteed to succeed.

With the remaining <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/14b21b617fcd2e25700376368355f7bbf975d8de.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> probability he took two different cards, and the probability of pulling off the trick is <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/eb946338365d9781f7d2e9ec692c26702d0ae3a7.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>.

The resulting probability is <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/f54a03c9fa9df64ba08161730756d50b780a5f43.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>",OK,"def b(m,n,i):
    c=1
    for j in range(1,n-i+1):
        c=c*(n*m-m-n+i+j)/(n*m-n+i+j)
    for j in range(1,i+1):
        c=c*(m-i+j)/(n*m-n+j)
    for j in range(1,i+1):
        c=c/j*(n-i+j)
    return c

n,m = input().split()
n = int(n)
m = int(m)
a = 0

for i in range(1, min(n,m)+1):
    a += i * i /n * b(m,n,i)

print(a)","import g

def d():

    b = g.stdin.read().strip().split()
    if not b:
        return
    x = int(b[0])
    y = int(b[1])
    l = int(b[2])
    r = int(b[3])
    
    i = set()

    p = 1
    j = []
    while p <= r:
        j.append(p)

        if x > r // p:
            break
        p *= x

    q = 1
    k = []
    while q <= r:
        k.append(q)
        if y > r // q:
            break
        q *= y

    for a in j:
        for b in k:
            f = a + b
            if f > r:
                continue
            i.add(f)

    h = sorted(i)

    a = []
    a.append(l - 1)
    for v in h:
        if l <= v <= r:
            a.append(v)
    a.append(r + 1)
    a.sort()
    
    e = 0

    for i in range(len(a) - 1):
        c = a[i + 1] - a[i] - 1
        if c > e:
            e = c

    print(e)

if __name__ == '__main__':
    d()"
957,A,Tritonic Iridescence,PROGRAMMING,['implementation'],"Overlooking the captivating blend of myriads of vernal hues, Arkady the painter lays out a long, long canvas.

Arkady has a sufficiently large amount of paint of three colours: cyan, magenta, and yellow. On the one-dimensional canvas split into *n* consecutive segments, each segment needs to be painted in one of the colours.

Arkady has already painted some (possibly none or all) segments and passes the paintbrush to you. You are to determine whether there are at least two ways of colouring all the unpainted segments so that no two adjacent segments are of the same colour. Two ways are considered different if and only if a segment is painted in different colours in them.","The first line contains a single positive integer *n* (1<=≤<=*n*<=≤<=100) — the length of the canvas.

The second line contains a string *s* of *n* characters, the *i*-th of which is either 'C' (denoting a segment painted in cyan), 'M' (denoting one painted in magenta), 'Y' (one painted in yellow), or '?' (an unpainted one).","If there are at least two different ways of painting, output ""Yes""; otherwise output ""No"" (both without quotes).

You can print each character in any case (upper or lower).","['5\nCY??Y\n', '5\nC?C?Y\n', '5\n?CYC?\n', '5\nC??MM\n', '3\nMMY\n']","['Yes\n', 'Yes\n', 'Yes\n', 'No\n', 'No\n']","For the first example, there are exactly two different ways of colouring: CYCMY and CYMCY.

For the second example, there are also exactly two different ways of colouring: CMCMY and CYCMY.

For the third example, there are four ways of colouring: MCYCM, MCYCY, YCYCM, and YCYCY.

For the fourth example, no matter how the unpainted segments are coloured, the existing magenta segments will prevent the painting from satisfying the requirements. The similar is true for the fifth example.",WRONG_ANSWER,"def c():
    n = int(input())
    x = input()
    if 'CC' in x:
        return 'No'
    if 'MM' in x:
        return 'No'
    if 'YY' in x:
        return 'No'
    
    for i in range(n):
        if i > 0 and i < n - 1:
            if x[i] == '?':
                a = x[i-1]
                b = x[i+1]
                if a == b:
                    return 'Yes'
    return 'No'

print(c())","import i

def h():

    g = i.stdin.read().strip().split()
    if not g:
        return

    n = int(g[0])
    j = []
    f = 1

    for _ in range(n):
        d = int(g[f])
        a = int(g[f + 1])
        j.append((d, a))
        f += 2
    
    b = 0

    for e, _ in j:
        for _, c in j:
            if e == c:
                b += 1

    print(b)

if __name__ == ""__main__"":
    h()"
678,D,Iterated Linear Function,PROGRAMMING,"['math', 'number theory']","Consider a linear function *f*(*x*)<==<=*Ax*<=+<=*B*. Let's define *g*(0)(*x*)<==<=*x* and *g*(*n*)(*x*)<==<=*f*(*g*(*n*<=-<=1)(*x*)) for *n*<=&gt;<=0. For the given integer values *A*, *B*, *n* and *x* find the value of *g*(*n*)(*x*) modulo 109<=+<=7.","The only line contains four integers *A*, *B*, *n* and *x* (1<=≤<=*A*,<=*B*,<=*x*<=≤<=109,<=1<=≤<=*n*<=≤<=1018) — the parameters from the problem statement.

Note that the given value *n* can be too large, so you should use 64-bit integer type to store it. In C++ you can use the long long integer type and in Java you can use long integer type.",Print the only integer *s* — the value *g*(*n*)(*x*) modulo 109<=+<=7.,"['3 4 1 1\n', '3 4 2 1\n', '3 4 3 1\n']","['7\n', '25\n', '79\n']",none,OK,"d = 7+10**9
def c(a, b):
    c = [[0,0],[0,0]]
    for i in range(2):
        for j in range(2):
            for k in range(2):
                c[i][j] += a[i][k] * b[k][j]
            c[i][j] %= d

    return c 

def a(a, n):
    c = [[1,0],[0,1]]
    while n != 0:
        if (n&1):
            c = c(a,c) 
        a = c(a,a)
        n//=2
    return c

A,B,n,x = [int(i) for i in input().split("" "")]

b = [[A,B],[0,1]]
b = a(b,n)

print((b[0][0] * x + b[0][1]) % d)","import 
.setrecursionlimit(10**6)
c = 10**9+7

def w():
    k = .stdin.read().strip().split()
    if not k:
        return
    n = int(k[0])

    f = [0] * n
    l = [0] * n
    r = 1
    for i in range(n):
        f[i] = int(k[r])
        l[i] = int(k[r+1])
        r += 2

    n = {}
    for i, m in enumerate(f):
        n[m] = i

    z = [-1] * n
    for i in range(n):
        d = l[i]
        if d in n:
            z[i] = n[d]

    e = [[] for _ in range(n)]
    for i in range(n):
        j = z[i]
        if j != -1:
            e[j].append(i)

     = [0] * n
    s = [False] * n
    j = []

    def o(u, , {):
        [u] = 1
        .append(u)
        {[u] = len() - 1
        y = z[u]
        if y != -1:
            if [y] == 0:
                o(y, , {)
            elif [y] == 1:

                h = [{[y]:]
                for x in h:
                    s[x] = True
                j.append(h.copy())
        [u] = 2
        .pop()
        {[u] = -1

    { = [-1] * n
    for i in range(n):
        if [i] == 0:
            o(i, [], {)

    q = [None] * n
    def p(u):
        if q[u] is not None:
            return q[u]
        ~ = 1
         = 1
        for v in e[u]:
            if s[v]:

                continue
            a, b = p(v)
            ~ = (~ * a) % c
             = ( * b) % c

        F = ( + ~) % c
        G = 
        q[u] = (F, G)
        return q[u]

    t = [0] * n
    for u in range(n):
        if s[u]:
            continue
        y = z[u]

        if y != -1 and (not s[y]):
            t[y] += 1

    d = 1
    for u in range(n):
        if not s[u] and t[u] == 0:
            F, _ = p(u)
            d = (d * F) % c

    for g in j:
        | = 1
        } = 1
        for u in g:
            u = 1
            v = 1
            for v in e[u]:
                if s[v]:
                    continue
                a, b = p(v)
                u = (u * b) % c
                v = (v * a) % c
            | = (| * u) % c
            } = (} * v) % c
        i = (| + }) % c
        d = (d * i) % c

    .stdout.write(str(d % c))

if __name__ == '__main__':
    w()"
115,A,Party,PROGRAMMING,"['dfs and similar', 'graphs', 'trees']","A company has *n* employees numbered from 1 to *n*. Each employee either has no immediate manager or exactly one immediate manager, who is another employee with a different number. An employee *A* is said to be the superior of another employee *B* if at least one of the following is true:
 -  Employee *A* is the immediate manager of employee *B* -  Employee *B* has an immediate manager employee *C* such that employee *A* is the superior of employee *C*. 
The company will not have a managerial cycle. That is, there will not exist an employee who is the superior of his/her own immediate manager.

Today the company is going to arrange a party. This involves dividing all *n* employees into several groups: every employee must belong to exactly one group. Furthermore, within any single group, there must not be two employees *A* and *B* such that *A* is the superior of *B*.

What is the minimum number of groups that must be formed?","The first line contains integer *n* (1<=≤<=*n*<=≤<=2000) — the number of employees.

The next *n* lines contain the integers *p**i* (1<=≤<=*p**i*<=≤<=*n* or *p**i*<==<=-1). Every *p**i* denotes the immediate manager for the *i*-th employee. If *p**i* is -1, that means that the *i*-th employee does not have an immediate manager. 

It is guaranteed, that no employee will be the immediate manager of him/herself (*p**i*<=≠<=*i*). Also, there will be no managerial cycles.",Print a single integer denoting the minimum number of groups that will be formed in the party.,['5\n-1\n1\n2\n1\n-1\n'],['3\n'],"For the first example, three groups are sufficient, for example: 
 -  Employee 1 -  Employees 2 and 4 -  Employees 3 and 5",OK,"b=[]
def b(s):
    a=1
    while s-1>=0:
        a+=1
        s=b[s-1]
    return a
n=int(input())
for i in range(n):
    b.append(int(input()))
m=1
for i in b:
     p=b(i)
     m=max(m,p)
print(m)","def c(x):
    """"""
    Count the number of ones in the binary representation of x.
    Each one represents a bacteria that must have been added.
    """"""
    a = 0
    while x:

        x = x & (x - 1)
        a += 1
    return a

if __name__ == ""__main__"":
    import f

    b = f.stdin.read().strip().split()

    e = []
    for d in b:

        x = int(d)
        e.append(str(c(x)))

    print(""\n"".join(e))"
815,A,Karen and Game,PROGRAMMING,"['brute force', 'greedy', 'implementation']","On the way to school, Karen became fixated on the puzzle game on her phone!

The game is played as follows. In each level, you have a grid with *n* rows and *m* columns. Each cell originally contains the number 0.

One move consists of choosing one row or column, and adding 1 to all of the cells in that row or column.

To win the level, after all the moves, the number in the cell at the *i*-th row and *j*-th column should be equal to *g**i*,<=*j*.

Karen is stuck on one level, and wants to know a way to beat this level using the minimum number of moves. Please, help her with this task!","The first line of input contains two integers, *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=100), the number of rows and the number of columns in the grid, respectively.

The next *n* lines each contain *m* integers. In particular, the *j*-th integer in the *i*-th of these rows contains *g**i*,<=*j* (0<=≤<=*g**i*,<=*j*<=≤<=500).","If there is an error and it is actually not possible to beat the level, output a single integer -1.

Otherwise, on the first line, output a single integer *k*, the minimum number of moves necessary to beat the level.

The next *k* lines should each contain one of the following, describing the moves in the order they must be done:
 -  row *x*, (1<=≤<=*x*<=≤<=*n*) describing a move of the form ""choose the *x*-th row"". -  col *x*, (1<=≤<=*x*<=≤<=*m*) describing a move of the form ""choose the *x*-th column"". 
If there are multiple optimal solutions, output any one of them.","['3 5\n2 2 2 3 2\n0 0 0 1 0\n1 1 1 2 1\n', '3 3\n0 0 0\n0 1 0\n0 0 0\n', '3 3\n1 1 1\n1 1 1\n1 1 1\n']","['4\nrow 1\nrow 1\ncol 4\nrow 3\n', '-1\n', '3\nrow 1\nrow 2\nrow 3\n']","In the first test case, Karen has a grid with 3 rows and 5 columns. She can perform the following 4 moves to beat the level:

In the second test case, Karen has a grid with 3 rows and 3 columns. It is clear that it is impossible to beat the level; performing any move will create three 1s on the grid, but it is required to only have one 1 in the center.

In the third test case, Karen has a grid with 3 rows and 3 columns. She can perform the following 3 moves to beat the level:

Note that this is not the only solution; another solution, among others, is col 1, col 2, col 3.",OK,"from collections import defaultdict as j
n,m=[int(x) for x in input().split()]
f=list()
g=j(lambda:False)
h=j(lambda:False)
d,e=list(),list()
for _ in range(n):
    n=list(map(int,input().split()))
    f.append(n)
l,m=list(),list()
for i in range(n):
    n=list()
    for j in range(m):n.append((f[i][j],j))
    l.append(n)
for i in range(n):l[i]=sorted(l[i],reverse=True)
for i in range(n):
    for j in range(m):
        x=l[i][j][0]-l[i][-1][0]
        if x==0:break
        k=l[i][j][1]
        if g[k+1]==True:continue
        while x:d.append((""col"",k+1)); x-=1; g[k+1]=True
    x=l[i][-1][0]
    if x:
        for c in range(1,m+1):g[c]=True
    while x:d.append((""row"",i+1)); x-=1

a=True
i=list()
for i in range(n):
    n=list()
    for j in range(m):n.append(0)
    i.append(n)
for i in d:
    if i[0]=='row':
        for j in range(m):i[i[1]-1][j]+=1
    else:
        for j in range(n):i[j][i[1]-1]+=1
if i!=f:a=False

for i in range(m):
    n=list()
    for j in range(n):n.append((f[j][i],j))
    m.append(n)
for i in range(m):m[i]=sorted(m[i],reverse=True)

for j in range(m):
    for i in range(n):
        x=m[j][i][0]-m[j][-1][0]
        if x==0:break
        k=m[j][i][1]
        if h[k+1]==True:continue
        while x:e.append((""row"",k+1)); x-=1; h[k+1]=True
    x=m[j][-1][0]
    if x:
        for c in range(1,m+1):h[c]=True
    while x:
        e.append((""col"",j+1)); x-=1

b=True
i=list()
for i in range(n):
    n=list()
    for j in range(m):n.append(0)
    i.append(n)
for i in e:
    if i[0]=='row':
        for j in range(m):i[i[1]-1][j]+=1
    else:
        for j in range(n):i[j][i[1]-1]+=1
if i!=f:b=False
if a==b and a==False:print(-1)
else:
    if len(d)==len(e) or len(d)<len(e) or b==False:
        print(len(d))
        for i in d:
            print(i[0],i[1])
    else:
        print(len(e))
        for i in e:
            print(i[0],i[1])","import h

def b(x, n, m):

    a = 0
    for i in range(1, n + 1):

        a += min(m, x // i)
    return a

def e():

    c = h.stdin.read().split()
    if not c:
        return
    n = int(c[0])
    m = int(c[1])
    k = int(c[2])

    d, g = 1, n * m
    while d < g:
        f = (d + g) // 2
        if b(f, n, m) < k:
            d = f + 1
        else:
            g = f
    print(d)

if __name__ == '__main__':
    e()"
911,B,Two Cakes,PROGRAMMING,"['binary search', 'brute force', 'implementation']","It's New Year's Eve soon, so Ivan decided it's high time he started setting the table. Ivan has bought two cakes and cut them into pieces: the first cake has been cut into *a* pieces, and the second one — into *b* pieces.

Ivan knows that there will be *n* people at the celebration (including himself), so Ivan has set *n* plates for the cakes. Now he is thinking about how to distribute the cakes between the plates. Ivan wants to do it in such a way that all following conditions are met:
 1.  Each piece of each cake is put on some plate; 1.  Each plate contains at least one piece of cake; 1.  No plate contains pieces of both cakes. 
To make his guests happy, Ivan wants to distribute the cakes in such a way that the minimum number of pieces on the plate is maximized. Formally, Ivan wants to know the maximum possible number *x* such that he can distribute the cakes according to the aforementioned conditions, and each plate will contain at least *x* pieces of cake.

Help Ivan to calculate this number *x*!","The first line contains three integers *n*, *a* and *b* (1<=≤<=*a*,<=*b*<=≤<=100, 2<=≤<=*n*<=≤<=*a*<=+<=*b*) — the number of plates, the number of pieces of the first cake, and the number of pieces of the second cake, respectively.",Print the maximum possible number *x* such that Ivan can distribute the cake in such a way that each plate will contain at least *x* pieces of cake.,"['5 2 3\n', '4 7 10\n']","['1\n', '3\n']","In the first example there is only one way to distribute cakes to plates, all of them will have 1 cake on it.

In the second example you can have two plates with 3 and 4 pieces of the first cake and two plates both with 5 pieces of the second cake. Minimal number of pieces is 3.",OK,"import sys,math

def e():
    n,a,b=map(int,input().split())
    a=0
    for i in range(1,n):
        c=a//i
        d=b//(n-i)
        b=min(c,d)
        a=max(a,b)
    print(a)

e()","def o():
    import q
    q.setrecursionlimit(10000)

    e = q.stdin.read().splitlines()
    if not e:
        return
    m = e[0].strip()
    n = e[1].strip() if len(e) > 1 else """"
    r = e[2].strip() if len(e) > 2 else """"
    
    n, m, L = len(m), len(n), len(r)

    j = [0] * L
    for i in range(1, L):
        j = j[i - 1]
        while j > 0 and r[i] != r[j]:
            j = j[j - 1]
        if r[i] == r[j]:
            j += 1
        j[i] = j

    i = [dict() for _ in range(L + 1)]
    for p in range(L + 1):
        for c in ""ABCDEFGHIJKLMNOPQRSTUVWXYZ"":
            if p < L and r[p] == c:
                i[p][c] = p + 1
            else:
                if p == 0:
                    i[p][c] = 0
                else:
                    i[p][c] = i[j[p - 1]].get(c, 0)

    from functools import g

    @g(maxsize=None)
    def f(i, j, k):
        if i == n or j == m:
            return """"

        a = f(i + 1, j, k)

        b = f(i, j + 1, k)
        k = a if len(a) >= len(b) else b

        if m[i] == n[j]:
            d = m[i]
            h = i[k][d]

            if h < L:
                c = d + f(i + 1, j + 1, h)
                if len(c) > len(k):
                    k = c
        return k

    l = f(0, 0, 0)

    q.stdout.write(l if l != """" else ""0"")

if __name__ == ""__main__"":
    o()"
915,C,Permute Digits,PROGRAMMING,"['dp', 'greedy']","You are given two positive integer numbers *a* and *b*. Permute (change order) of the digits of *a* to construct maximal number not exceeding *b*. No number in input and/or output can start with the digit 0.

It is allowed to leave *a* as it is.",The first line contains integer *a* (1<=≤<=*a*<=≤<=1018). The second line contains integer *b* (1<=≤<=*b*<=≤<=1018). Numbers don't have leading zeroes. It is guaranteed that answer exists.,"Print the maximum possible number that is a permutation of digits of *a* and is not greater than *b*. The answer can't have any leading zeroes. It is guaranteed that the answer exists.

The number in the output should have exactly the same length as number *a*. It should be a permutation of digits of *a*.","['123\n222\n', '3921\n10000\n', '4940\n5000\n']","['213\n', '9321\n', '4940\n']",none,WRONG_ANSWER,"def d(X, i, j):
    X = X[0:i] + X[j] + X[i+1:j] + X[i] + X[j+1:]
    X = X[:i+1] + ''.join(reversed(sorted(X[i+1:])))
    return X

X = ''.join(reversed(sorted(input())))
Y = input()

if len(X) < len(Y):
    print(X)
else:
    a = True
    i = 0
    while i < len(X):
        print(i, "" "", X)
        x = int(X[i])
        y = int(Y[i])
        if x < y:
            break
        if x == y and a == True:
            i += 1
        if x > y or (x == y and a == False):
            c = -1
            b = -1
            for j in range(i+1, len(X)):
                e = int(X[j])
                if ((e <= y and a == True) or (e < y and a == False)) and e > c: 
                    b = j
                    c = int(X[j])
            if c > -1:
                X = d(X, i, b)
                i += 1
            else:
                i -= 1
                a = False
                
    print(X)","import h

def e():

    b = h.stdin.read().split()
    if not b:
        return

    n = int(b[0])

    a = list(map(int, b[1:n+1]))

    c = {}
    for d in a:
        c[d] = c.get(d, 0) + 1

    f = max(c.values()) if c else 0

    g = len(c)

    print(f, g)

if __name__ == ""__main__"":
    e()"
115,A,Party,PROGRAMMING,"['dfs and similar', 'graphs', 'trees']","A company has *n* employees numbered from 1 to *n*. Each employee either has no immediate manager or exactly one immediate manager, who is another employee with a different number. An employee *A* is said to be the superior of another employee *B* if at least one of the following is true:
 -  Employee *A* is the immediate manager of employee *B* -  Employee *B* has an immediate manager employee *C* such that employee *A* is the superior of employee *C*. 
The company will not have a managerial cycle. That is, there will not exist an employee who is the superior of his/her own immediate manager.

Today the company is going to arrange a party. This involves dividing all *n* employees into several groups: every employee must belong to exactly one group. Furthermore, within any single group, there must not be two employees *A* and *B* such that *A* is the superior of *B*.

What is the minimum number of groups that must be formed?","The first line contains integer *n* (1<=≤<=*n*<=≤<=2000) — the number of employees.

The next *n* lines contain the integers *p**i* (1<=≤<=*p**i*<=≤<=*n* or *p**i*<==<=-1). Every *p**i* denotes the immediate manager for the *i*-th employee. If *p**i* is -1, that means that the *i*-th employee does not have an immediate manager. 

It is guaranteed, that no employee will be the immediate manager of him/herself (*p**i*<=≠<=*i*). Also, there will be no managerial cycles.",Print a single integer denoting the minimum number of groups that will be formed in the party.,['5\n-1\n1\n2\n1\n-1\n'],['3\n'],"For the first example, three groups are sufficient, for example: 
 -  Employee 1 -  Employees 2 and 4 -  Employees 3 and 5",WRONG_ANSWER,"import b
def input(): return b.stdin.readline().strip()
def a(): return map(int,b.stdin.readline().strip().split())

q = int(input())
l = [0]*(q+1)
for x in range(1,q+1):
    n = int(input())
    if n == -1: l[x] = 1
    else: l[x] = l[n]+1
print(max(l))","import g

def e(x, y):
    a = 0
    for i in range(20):

        a |= ((x >> i) & 1) << (2 * i + 1)

        a |= ((y >> i) & 1) << (2 * i)
    return a

def d():
    c = g.stdin.read().split()
    if not c:
        return

    n = int(c[0])
    f = []
    b = 1

    for i in range(n):
        x = int(c[b])
        y = int(c[b+1])
        f.append((x, y, i+1))
        b += 2

    f.sort(key=lambda p: e(p[0], p[1]))

    g.stdout.write("" "".join(str(p[2]) for p in f) + ""\n"")

if __name__ == '__main__':
    d()"
811,B,Vladik and Complicated Book,PROGRAMMING,"['implementation', 'sortings']","Vladik had started reading a complicated book about algorithms containing *n* pages. To improve understanding of what is written, his friends advised him to read pages in some order given by permutation *P*<==<=[*p*1,<=*p*2,<=...,<=*p**n*], where *p**i* denotes the number of page that should be read *i*-th in turn.

Sometimes Vladik’s mom sorted some subsegment of permutation *P* from position *l* to position *r* inclusive, because she loves the order. For every of such sorting Vladik knows number *x* — what index of page in permutation he should read. He is wondered if the page, which he will read after sorting, has changed. In other words, has *p**x* changed? After every sorting Vladik return permutation to initial state, so you can assume that each sorting is independent from each other.","First line contains two space-separated integers *n*, *m* (1<=≤<=*n*,<=*m*<=≤<=104) — length of permutation and number of times Vladik's mom sorted some subsegment of the book.

Second line contains *n* space-separated integers *p*1,<=*p*2,<=...,<=*p**n* (1<=≤<=*p**i*<=≤<=*n*) — permutation *P*. Note that elements in permutation are distinct.

Each of the next *m* lines contains three space-separated integers *l**i*, *r**i*, *x**i* (1<=≤<=*l**i*<=≤<=*x**i*<=≤<=*r**i*<=≤<=*n*) — left and right borders of sorted subsegment in *i*-th sorting and position that is interesting to Vladik.","For each mom’s sorting on it’s own line print ""Yes"", if page which is interesting to Vladik hasn't changed, or ""No"" otherwise.","['5 5\n5 4 3 2 1\n1 5 3\n1 3 1\n2 4 3\n4 4 4\n2 5 3\n', '6 5\n1 4 3 2 5 6\n2 4 3\n1 6 2\n4 5 4\n1 3 3\n2 6 3\n']","['Yes\nNo\nYes\nYes\nNo\n', 'Yes\nNo\nYes\nNo\nYes\n']","Explanation of first test case: 
 1.  [1, 2, 3, 4, 5] — permutation after sorting, 3-rd element hasn’t changed, so answer is ""Yes"". 1.  [3, 4, 5, 2, 1] — permutation after sorting, 1-st element has changed, so answer is ""No"". 1.  [5, 2, 3, 4, 1] — permutation after sorting, 3-rd element hasn’t changed, so answer is ""Yes"". 1.  [5, 4, 3, 2, 1] — permutation after sorting, 4-th element hasn’t changed, so answer is ""Yes"". 1.  [5, 1, 2, 3, 4] — permutation after sorting, 3-rd element has changed, so answer is ""No"".",TIME_LIMIT_EXCEEDED,"import c
def b(l,r,x):
    a = 0
    for i in range(l,r+1):
        if a[x]>a[i]:
            a += 1
    return a
n,m = map(int,c.stdin.readline().split())
a = [int(x) for x in c.stdin.readline().split()]
for i in range(m):
    l,r,x = [int(v)-1 for v in c.stdin.readline().split()]
    if x==b(l,r,x)+l:
        c.stdout.write('Yes\n')
    else:
        c.stdout.write('No\n')","s = input().strip()

b = s.find(""AB"")
a = False
if b != -1:

    e = s.find(""BA"", b + 2)
    if e != -1:
        a = True

if not a:
    d = s.find(""BA"")
    if d != -1:

        c = s.find(""AB"", d + 2)
        if c != -1:
            a = True

if a:
    print(""YES"")
else:
    print(""NO"")"
955,A,Feed the cat,PROGRAMMING,"['greedy', 'math']","After waking up at *hh*:*mm*, Andrew realised that he had forgotten to feed his only cat for yet another time (guess why there's only one cat). The cat's current hunger level is *H* points, moreover each minute without food increases his hunger by *D* points.

At any time Andrew can visit the store where tasty buns are sold (you can assume that is doesn't take time to get to the store and back). One such bun costs *C* roubles and decreases hunger by *N* points. Since the demand for bakery drops heavily in the evening, there is a special 20% discount for buns starting from 20:00 (note that the cost might become rational). Of course, buns cannot be sold by parts.

Determine the minimum amount of money Andrew has to spend in order to feed his cat. The cat is considered fed if its hunger level is less than or equal to zero.","The first line contains two integers *hh* and *mm* (00<=≤<=*hh*<=≤<=23,<=00<=≤<=*mm*<=≤<=59) — the time of Andrew's awakening.

The second line contains four integers *H*, *D*, *C* and *N* (1<=≤<=*H*<=≤<=105,<=1<=≤<=*D*,<=*C*,<=*N*<=≤<=102).","Output the minimum amount of money to within three decimal digits. You answer is considered correct, if its absolute or relative error does not exceed 10<=-<=4.

Formally, let your answer be *a*, and the jury's answer be *b*. Your answer is considered correct if .","['19 00\n255 1 100 1\n', '17 41\n1000 6 15 11\n']","['25200.0000\n', '1365.0000\n']","In the first sample Andrew can visit the store at exactly 20:00. The cat's hunger will be equal to 315, hence it will be necessary to purchase 315 buns. The discount makes the final answer 25200 roubles.

In the second sample it's optimal to visit the store right after he wakes up. Then he'll have to buy 91 bins per 15 roubles each and spend a total of 1365 roubles.",RUNTIME_ERROR,"def b():
    print(g(2))
    a, c = map(int, input().split())
    h, d, c, n = map(int, input().split())
    e = max(0, 1200 - (60 * a + c))
    d = (h + n - 1) // n
    f = min(d * c, (d + e * d) * 0.8 * c)
    print(f)

b()","import e

def d():

    b = e.stdin.read().split()
    
    if not b:
        return

    n = int(b[0])

    a = list(map(int, b[1:n+1]))

    c = set()
    for f in a:
        if f != 0:
            c.add(f)

    print(len(c))

if __name__ == ""__main__"":
    d()"
233,A,Perfect Permutation,PROGRAMMING,"['implementation', 'math']","A permutation is a sequence of integers *p*1,<=*p*2,<=...,<=*p**n*, consisting of *n* distinct positive integers, each of them doesn't exceed *n*. Let's denote the *i*-th element of permutation *p* as *p**i*. We'll call number *n* the size of permutation *p*1,<=*p*2,<=...,<=*p**n*.

Nickolas adores permutations. He likes some permutations more than the others. He calls such permutations perfect. A perfect permutation is such permutation *p* that for any *i* (1<=≤<=*i*<=≤<=*n*) (*n* is the permutation size) the following equations hold *p**p**i*<==<=*i* and *p**i*<=≠<=*i*. Nickolas asks you to print any perfect permutation of size *n* for the given *n*.",A single line contains a single integer *n* (1<=≤<=*n*<=≤<=100) — the permutation size.,"If a perfect permutation of size *n* doesn't exist, print a single integer -1. Otherwise print *n* distinct integers from 1 to *n*, *p*1,<=*p*2,<=...,<=*p**n* — permutation *p*, that is perfect. Separate printed numbers by whitespaces.","['1\n', '2\n', '4\n']","['-1\n', '2 1 \n', '2 1 4 3 \n']",none,WRONG_ANSWER,"import os, sys, q, heapq, itertools, bisect
from collections import deque,defaultdict, OrderedDict
h  = lambda : int(input())                           
w  = lambda : input()                               
r  = lambda : map(int,input().strip().split("" ""))   
s = lambda : map(str,input().strip().split("" ""))   
m  = lambda : list(r())                            
o = lambda : list(s())                           
i = lambda u : u%2==0                       
l = lambda u : u%2==1                        
n = ""abcdefghijklmnopqrstuvwxyz""
{ = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
x,c,c,s,e = [],{},0,0,False
v = q.inf    
t = -q.inf
k = lambda u : isinstance(u, int)
j = lambda u : isinstance(u, float)
def y(a,a,b)->None:z=a[b];a[b]=a[a];a[a]=z
def f()->None:
    global x,c,c,s,e
    x,c,c,s,e = [],{},0,0,False
def b(*|) -> None:
    try: import p; p.b(*|)
    except (ModuleNotFoundError,FileNotFoundError): pass    
try: import p; p.read()
except (ModuleNotFoundError,FileNotFoundError): pass

n = h()
if n==1:
    print(-1)
else:
    l = [i for i in range(1,n+1)]
    d = l[0]
    g = 1
    while g < n:
        try:
            l[g-1]=l[g]
            g+=1
        except IndexError: break
    l[-1] = d
    print(*l)","def f():
    import i

    b = i.stdin.read().split()
    if not b:
        return

    n = int(b[0])

    h = list(map(int, b[1:1+n]))

    a = 10**9

    e = [0, a, a]
    
    for c in range(n):
        a = h[c]
        d = [a, a, a]

        d[0] = min(e) + 1

        if a == 1 or a == 3:
            d[1] = min(e[0], e[2])

        if a == 2 or a == 3:
            d[2] = min(e[0], e[1])
        
        e = d

    g = min(e)
    i.stdout.write(str(g))

if __name__ == '__main__':
    f()"
989,A,A Blend of Springtime,PROGRAMMING,"['implementation', 'strings']","""What a pity it's already late spring,"" sighs Mino with regret, ""one more drizzling night and they'd be gone.""

""But these blends are at their best, aren't they?"" Absorbed in the landscape, Kanno remains optimistic. 

The landscape can be expressed as a row of consecutive cells, each of which either contains a flower of colour amber or buff or canary yellow, or is empty.

When a flower withers, it disappears from the cell that it originally belonged to, and it spreads petals of its colour in its two neighbouring cells (or outside the field if the cell is on the side of the landscape). In case petals fall outside the given cells, they simply become invisible.

You are to help Kanno determine whether it's possible that after some (possibly none or all) flowers shed their petals, at least one of the cells contains all three colours, considering both petals and flowers. Note that flowers can wither in arbitrary order.","The first and only line of input contains a non-empty string $s$ consisting of uppercase English letters 'A', 'B', 'C' and characters '.' (dots) only ($\lvert s \rvert \leq 100$) — denoting cells containing an amber flower, a buff one, a canary yellow one, and no flowers, respectively.","Output ""Yes"" if it's possible that all three colours appear in some cell, and ""No"" otherwise.

You can print each letter in any case (upper or lower).","['.BAC.\n', 'AA..CB\n']","['Yes\n', 'No\n']","In the first example, the buff and canary yellow flowers can leave their petals in the central cell, blending all three colours in it.

In the second example, it's impossible to satisfy the requirement because there is no way that amber and buff meet in any cell.",OK,"def a(S):
    n = len(S)
    for i in range(n-2):
        if S[i] != '.' and S[i+1] != '.' and S[i+2] != '.' and S[i] != S[i+1] and S[i] != S[i+2] and S[i+1] != S[i+2]:
            print('Yes')
            return
    print('No')
    
S = input()
a(S)","import i

def a(s):

    if len(s) % 2:
        return s

    e = len(s) // 2
    c = a(s[:e])
    f = a(s[e:])

    if c <= f:
        return c + f
    else:
        return f + c

def d():
    b = i.stdin.read().splitlines()
    if len(b) < 2:
        return
    g = b[0].strip()
    h = b[1].strip()

    if a(g) == a(h):
        print(""YES"")
    else:
        print(""NO"")

if __name__ == ""__main__"":
    d()"
955,A,Feed the cat,PROGRAMMING,"['greedy', 'math']","After waking up at *hh*:*mm*, Andrew realised that he had forgotten to feed his only cat for yet another time (guess why there's only one cat). The cat's current hunger level is *H* points, moreover each minute without food increases his hunger by *D* points.

At any time Andrew can visit the store where tasty buns are sold (you can assume that is doesn't take time to get to the store and back). One such bun costs *C* roubles and decreases hunger by *N* points. Since the demand for bakery drops heavily in the evening, there is a special 20% discount for buns starting from 20:00 (note that the cost might become rational). Of course, buns cannot be sold by parts.

Determine the minimum amount of money Andrew has to spend in order to feed his cat. The cat is considered fed if its hunger level is less than or equal to zero.","The first line contains two integers *hh* and *mm* (00<=≤<=*hh*<=≤<=23,<=00<=≤<=*mm*<=≤<=59) — the time of Andrew's awakening.

The second line contains four integers *H*, *D*, *C* and *N* (1<=≤<=*H*<=≤<=105,<=1<=≤<=*D*,<=*C*,<=*N*<=≤<=102).","Output the minimum amount of money to within three decimal digits. You answer is considered correct, if its absolute or relative error does not exceed 10<=-<=4.

Formally, let your answer be *a*, and the jury's answer be *b*. Your answer is considered correct if .","['19 00\n255 1 100 1\n', '17 41\n1000 6 15 11\n']","['25200.0000\n', '1365.0000\n']","In the first sample Andrew can visit the store at exactly 20:00. The cat's hunger will be equal to 315, hence it will be necessary to purchase 315 buns. The discount makes the final answer 25200 roubles.

In the second sample it's optimal to visit the store right after he wakes up. Then he'll have to buy 91 bins per 15 roubles each and spend a total of 1365 roubles.",WRONG_ANSWER,"import c

f = list(map(int, input().split()))

b = f[0]
e = f[1]

f = list(map(int, input().split()))
H = f[0]
D = f[1]
C = f[2]
N = f[3]

def a(b, e, H, D, C, N):
	d = b * 60 + e
	if d >= 1200:
		return C * c.ceil(H / N) * 0.8
	else:
		t = 1200 - H / (4 * D)
		if d <= t:
			return C * c.ceil(H / N)
		else:
			return C * c.ceil((H + (1200 - d) * D) / N) * 0.8

z = a(b, e, H, D, C, N)
print(""%.4f"" % z)","def c():

    b = input().split()
    n = int(b[0])
    m = int(b[1])
    e = b[2]

    d = [input().strip() for _ in range(n)]

    a = set()

    for i in range(n):
        for j in range(m):

            if d[i][j] == e:

                if i > 0 and d[i - 1][j] != '.' and d[i - 1][j] != e:
                    a.add(d[i - 1][j])

                if i < n - 1 and d[i + 1][j] != '.' and d[i + 1][j] != e:
                    a.add(d[i + 1][j])

                if j > 0 and d[i][j - 1] != '.' and d[i][j - 1] != e:
                    a.add(d[i][j - 1])

                if j < m - 1 and d[i][j + 1] != '.' and d[i][j + 1] != e:
                    a.add(d[i][j + 1])

    print(len(a))

if __name__ == '__main__':
    c()"
318,A,Even Odds,PROGRAMMING,['math'],"Being a nonconformist, Volodya is displeased with the current state of things, particularly with the order of natural numbers (natural number is positive integer number). He is determined to rearrange them. But there are too many natural numbers, so Volodya decided to start with the first *n*. He writes down the following sequence of numbers: firstly all odd integers from 1 to *n* (in ascending order), then all even integers from 1 to *n* (also in ascending order). Help our hero to find out which number will stand at the position number *k*.","The only line of input contains integers *n* and *k* (1<=≤<=*k*<=≤<=*n*<=≤<=1012).

Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.",Print the number that will stand at the position number *k* after Volodya's manipulations.,"['10 3\n', '7 7\n']","['5', '6']","In the first sample Volodya's sequence will look like this: {1, 3, 5, 7, 9, 2, 4, 6, 8, 10}. The third place in the sequence is therefore occupied by the number 5.",WRONG_ANSWER,"z = list(map(int, input().split()))
n = z[0]
a = z[1]

def b(c):
    if c % 2 == 1:
        return c
    else:
        return c - 1

a = b(a)
print(a)","import m
import m
import m

class a:
    def __init__(k, l):
        k.l = l

        k.tree = [0] * (l + 1)

    def o(k, g, p):
        while g <= k.l:
            k.tree[g] += p
            g += g & -g

    def i(k, g):
        j = 0
        while g > 0:
            j += k.tree[g]
            g -= g & -g
        return j

def f():
    import m
    d = m.stdin.read().split()
    if not d:
        return

    n = int(d[0])
    k = int(d[1])

    e = k + 1

    a = [int(x) for x in d[2:2+n]]

    if e == 1:
        m.stdout.write(str(n))
        return

    n = [None] * (e + 1)
    for l in range(1, e+1):
        n[l] = a(n)

    for p in a:

        n[1].o(p, 1)

    for p in a:

        h = 1

        for l in range(2, e+1):

            c = n[l-1].i(p - 1)

            if c:
                n[l].o(p, c)

    b = n[e].i(n)
    m.stdout.write(str(b))

if __name__ == '__main__':
    f()"
295,B,Greg and Graph,PROGRAMMING,"['dp', 'graphs', 'shortest paths']","Greg has a weighed directed graph, consisting of *n* vertices. In this graph any pair of distinct vertices has an edge between them in both directions. Greg loves playing with the graph and now he has invented a new game:
 -  The game consists of *n* steps. -  On the *i*-th step Greg removes vertex number *x**i* from the graph. As Greg removes a vertex, he also removes all the edges that go in and out of this vertex. -  Before executing each step, Greg wants to know the sum of lengths of the shortest paths between all pairs of the remaining vertices. The shortest path can go through any remaining vertex. In other words, if we assume that *d*(*i*,<=*v*,<=*u*) is the shortest path between vertices *v* and *u* in the graph that formed before deleting vertex *x**i*, then Greg wants to know the value of the following sum: . 
Help Greg, print the value of the required sum before each step.","The first line contains integer *n* (1<=≤<=*n*<=≤<=500) — the number of vertices in the graph.

Next *n* lines contain *n* integers each — the graph adjacency matrix: the *j*-th number in the *i*-th line *a**ij* (1<=≤<=*a**ij*<=≤<=105,<=*a**ii*<==<=0) represents the weight of the edge that goes from vertex *i* to vertex *j*.

The next line contains *n* distinct integers: *x*1,<=*x*2,<=...,<=*x**n* (1<=≤<=*x**i*<=≤<=*n*) — the vertices that Greg deletes.","Print *n* integers — the *i*-th number equals the required sum before the *i*-th step.

Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams of the %I64d specifier.","['1\n0\n1\n', '2\n0 5\n4 0\n1 2\n', '4\n0 3 1 1\n6 0 400 1\n2 4 0 1\n1 1 1 0\n4 1 2 3\n']","['0 ', '9 0 ', '17 23 404 0 ']",none,WRONG_ANSWER,"a = 10**18

def c(e):
    n = len(e)
    b = [[a]*n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            if e[i][j] != 0:
                b[i][j] = e[i][j]
            elif i == j:
                b[i][j] = 0
    for k in range(n):
        for i in range(n):
            for j in range(n):
                b[i][j] = min(b[i][j], b[i][k] + b[k][j])
    return b

n = int(input())
e = []
for i in range(n):
    d = list(map(int, input().split()))
    e.append(d)

b = c(e)

f = list(map(int, input().split()))

g = []
for k in range(n-1, -1, -1):
    r = f[k]-1
    for i in range(n):
        for j in range(n):

            if b[i][r] != a and b[r][j] != a and b[i][r] + b[r][j] == b[i][j]:
                e[i][j] = 0
    b = c(e)
    s = 0
    for i in range(n):
        for j in range(i+1, n):
            s += b[i][j]
    g.append(s)

for r in reversed(g):
    print(r, end=' ')
print()","def a():

    n = int(input())

    b = 0

    for _ in range(n):

        p, q = map(int, input().split())

        if q - p >= 2:
            b += 1

    print(b)

if __name__ == ""__main__"":
    a()"
580,C,Kefa and Park,PROGRAMMING,"['dfs and similar', 'graphs', 'trees']","Kefa decided to celebrate his first big salary by going to the restaurant. 

He lives by an unusual park. The park is a rooted tree consisting of *n* vertices with the root at vertex 1. Vertex 1 also contains Kefa's house. Unfortunaely for our hero, the park also contains cats. Kefa has already found out what are the vertices with cats in them.

The leaf vertices of the park contain restaurants. Kefa wants to choose a restaurant where he will go, but unfortunately he is very afraid of cats, so there is no way he will go to the restaurant if the path from the restaurant to his house contains more than *m* consecutive vertices with cats. 

Your task is to help Kefa count the number of restaurants where he can go.","The first line contains two integers, *n* and *m* (2<=≤<=*n*<=≤<=105, 1<=≤<=*m*<=≤<=*n*) — the number of vertices of the tree and the maximum number of consecutive vertices with cats that is still ok for Kefa.

The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n*, where each *a**i* either equals to 0 (then vertex *i* has no cat), or equals to 1 (then vertex *i* has a cat).

Next *n*<=-<=1 lines contains the edges of the tree in the format ""*x**i* *y**i*"" (without the quotes) (1<=≤<=*x**i*,<=*y**i*<=≤<=*n*, *x**i*<=≠<=*y**i*), where *x**i* and *y**i* are the vertices of the tree, connected by an edge. 

It is guaranteed that the given set of edges specifies a tree.",A single integer — the number of distinct leaves of a tree the path to which from Kefa's home contains at most *m* consecutive vertices with cats.,"['4 1\n1 1 0 0\n1 2\n1 3\n1 4\n', '7 1\n1 0 1 1 0 0 0\n1 2\n1 3\n2 4\n2 5\n3 6\n3 7\n']","['2\n', '2\n']","Let us remind you that a tree is a connected graph on *n* vertices and *n* - 1 edge. A rooted tree is a tree with a special vertex called root. In a rooted tree among any two vertices connected by an edge, one vertex is a parent (the one closer to the root), and the other one is a child. A vertex is called a leaf, if it has no children.

Note to the first sample test: <img class=""tex-graphics"" src=""https://espresso.codeforces.com/785114b4b3f5336f02078c25750f87c5a1d0b4be.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> The vertices containing cats are marked red. The restaurants are at vertices 2, 3, 4. Kefa can't go only to the restaurant located at vertex 2.

Note to the second sample test: <img class=""tex-graphics"" src=""https://espresso.codeforces.com/e5c07640680c837aec99126d94287872e69aa09a.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> The restaurants are located at vertices 4, 5, 6, 7. Kefa can't go to restaurants 6, 7.",OK,"n, m = map(int, input().split())
a = list(map(int, input().split()))

a = [[] for _ in range(n)]
for i in range(n-1):
	x, y = map(int, input().split())
	a[x-1] += [y-1]
	a[y-1] += [x-1]

def e(h: int) ->int:
	j = [0]*n
	i = 0
	s = [(h, 0)]
	j[h] = 1
	while s:
		d, c = s.pop()
		if a[d]: c += 1
		else: c = 0
		if c > m: continue
		f = True
  
		for g in a[d]:
			if not j[g]:
				j[g] = 1
				s.append((g, c))
				f = False
  
		if f: i += 1

	return i

b = e(0)

print(b)","""""""
Rikhail Mubinchik claims that palindromic numbers are “nicer” than primes.
We are to find the maximum n such that
    π(n) * q <= p * rub(n)
where π(n) is the number of primes <= n and rub(n) is the count of positive palindromic
numbers <= n. If no maximum exists, we print a special message.

This script reads two positive integers p and q from standard input (the numerator
and denominator of A = p/q) and then prints the maximum n meeting the inequality.
""""""

def e(n: int) -> bool:
    """"""Check if integer n is palindromic (its decimal representation reads the same backwards).""""""
    s = str(n)
    return s == s[::-1]

def m(n: int) -> list:
    """"""
    Compute the Sieve of Eratosthenes up to n.
    Returns a list of booleans of length n+1 where True indicates the index is prime.
    0 and 1 are marked as non‐prime.
    """"""
    l = [True] * (n + 1)
    if n >= 0:
        l[0] = False
    if n >= 1:
        l[1] = False
    p = 2
    while p * p <= n:
        if l[p]:
            for g in range(p * p, n + 1, p):
                l[g] = False
        p += 1
    return l

def d(p: int, q: int) -> str:
    """"""
    Find the maximum integer n such that:
         π(n)*q <= p*rub(n)
    where π(n) is the count of primes up to n and rub(n) is the count of palindromic numbers up to n.
    
    Strategy:
      - We simulate n = 1 ... N and use cumulative arrays for π(n) and rub(n) computed via sieve
        (for primes) and direct palindrome checking.
      - Because both π(n) and rub(n) are step‐functions the inequality may “recover” at palindromic
        numbers. Nevertheless, asymptotically π(n) ~ n/log n and rub(n) ~ roughly sqrt(n), so the inequality
        will eventually fail.
      - We extend the checking range gradually until a “tail” window has no values that satisfy the
        inequality (i.e. we passed the maximum n).
    """"""

    f = 100
    p = 1000

    a = 1
    
    while True:

        if f < p:
            f = p

        i = m(f)

        h = [0] * (f + 1)
        k = [0] * (f + 1)
        for i in range(1, f + 1):
            h[i] = h[i - 1] + (1 if i[i] else 0)
            k[i] = k[i - 1] + (1 if e(i) else 0)
        
        b = a

        for i in range(a + 1, f + 1):

            if h[i] * q <= p * k[i]:
                b = i
        a = b

        o = False
        for i in range(max(1, f - p + 1), f + 1):
            if h[i] * q <= p * k[i]:
                o = True
                break

        if h[f] * q <= p * k[f] or o:
            f *= 2
            continue
        else:
            break

    return str(a)

if __name__ == '__main__':
    import n
    c = n.stdin.read().strip().split()
    if not c:
        n.exit(0)
    p = int(c[0])
    q = int(c[1])
    j = d(p, q)

    n.stdout.write(j + ""\n"")"
980,E,The Number Games,PROGRAMMING,"['data structures', 'greedy', 'trees']","The nation of Panel holds an annual show called The Number Games, where each district in the nation will be represented by one contestant.

The nation has $n$ districts numbered from $1$ to $n$, each district has exactly one path connecting it to every other district. The number of fans of a contestant from district $i$ is equal to $2^i$.

This year, the president decided to reduce the costs. He wants to remove $k$ contestants from the games. However, the districts of the removed contestants will be furious and will not allow anyone to cross through their districts. 

The president wants to ensure that all remaining contestants are from districts that can be reached from one another. He also wishes to maximize the total number of fans of the participating contestants.

Which contestants should the president remove?","The first line of input contains two integers $n$ and $k$ ($1 \leq k &lt; n \leq 10^6$) — the number of districts in Panel, and the number of contestants the president wishes to remove, respectively.

The next $n-1$ lines each contains two integers $a$ and $b$ ($1 \leq a, b \leq n$, $a \ne b$), that describe a road that connects two different districts $a$ and $b$ in the nation. It is guaranteed that there is exactly one path between every two districts.","Print $k$ space-separated integers: the numbers of the districts of which the contestants should be removed, in increasing order of district number.","['6 3\n2 1\n2 6\n4 2\n5 6\n2 3\n', '8 4\n2 6\n2 7\n7 8\n1 2\n3 1\n2 4\n7 5\n']","['1 3 4\n', '1 3 4 5\n']","In the first sample, the maximum possible total number of fans is $2^2 + 2^5 + 2^6 = 100$. We can achieve it by removing the contestants of the districts 1, 3, and 4.",WRONG_ANSWER,"import f
import heapq as e
input = f.stdin.readline
I = lambda : list(map(int,input().split()))

n,k=I()
g=[[] for i in range(n)]
for i in range(n-1):
	a,b=I()
	g[a-1].append(b-1)
	g[b-1].append(a-1)
p=[i for i in range(n)]
def c(i,v):
	p[i]=v
	for x in g[i]:
		if x!=v:
			c(x,i)
c(0,0)
b=[0]*n
for i in range(n):
	b[i]=len(g[i])
d=[i for i in range(n) if b[i]==1]
e.heapify(d)
a=[]
while len(a)<k:
	x=e.heappop(d)
	a.append(x+1)
	b[p[x]]-=1
	if b[p[x]]==1:
		e.heappush(d,p[x])
a.sort()
print(*a)","import j

def a(n, c):
    """"""
    Generate the first n prime numbers using the Sieve of Eratosthenes.
    Only primes up to the given limit will be considered.
    """"""
    h = [True] * (c + 1)
    h[0] = h[1] = False
    g = []
    
    for f in range(2, c + 1):
        if h[f]:
            g.append(f)
            if len(g) == n:
                break

            for e in range(f * f, c + 1, f):
                h[e] = False
    return g

def d():

    b = j.stdin.read().split()
    if not b:
        return
    n = int(b[0])

    i = 1500000
    g = a(n, i)

    print("" "".join(map(str, g)))

if __name__ == ""__main__"":
    d()"
59,A,Word,PROGRAMMING,"['implementation', 'strings']","Vasya is very upset that many people on the Net mix uppercase and lowercase letters in one word. That's why he decided to invent an extension for his favorite browser that would change the letters' register in every word so that it either only consisted of lowercase letters or, vice versa, only of uppercase ones. At that as little as possible letters should be changed in the word. For example, the word HoUse must be replaced with house, and the word ViP — with VIP. If a word contains an equal number of uppercase and lowercase letters, you should replace all the letters with lowercase ones. For example, maTRIx should be replaced by matrix. Your task is to use the given method on one given word.",The first line contains a word *s* — it consists of uppercase and lowercase Latin letters and possesses the length from 1 to 100.,"Print the corrected word *s*. If the given word *s* has strictly more uppercase letters, make the word written in the uppercase register, otherwise - in the lowercase one.","['HoUse\n', 'ViP\n', 'maTRIx\n']","['house\n', 'VIP\n', 'matrix\n']",none,OK,"def a(s):
    c=[i for i in s if i in ""abcdefghijklmnopqrstuvwxyz""]
    b=[i for i in s if i in ""ABCDEFGHIJKLMNOPQRSTUVWXYZ""]
    if len(c)>=len(b):

        return s.lower()
    else:

        return s.upper()

s=input()
print(a(s))","def b():

    a, b, s = map(int, input().strip().split())

    a = abs(a) + abs(b)

    if s >= a and (s - a) % 2 == 0:
        print(""Yes"")
    else:
        print(""No"")

if __name__ == ""__main__"":
    b()"
811,B,Vladik and Complicated Book,PROGRAMMING,"['implementation', 'sortings']","Vladik had started reading a complicated book about algorithms containing *n* pages. To improve understanding of what is written, his friends advised him to read pages in some order given by permutation *P*<==<=[*p*1,<=*p*2,<=...,<=*p**n*], where *p**i* denotes the number of page that should be read *i*-th in turn.

Sometimes Vladik’s mom sorted some subsegment of permutation *P* from position *l* to position *r* inclusive, because she loves the order. For every of such sorting Vladik knows number *x* — what index of page in permutation he should read. He is wondered if the page, which he will read after sorting, has changed. In other words, has *p**x* changed? After every sorting Vladik return permutation to initial state, so you can assume that each sorting is independent from each other.","First line contains two space-separated integers *n*, *m* (1<=≤<=*n*,<=*m*<=≤<=104) — length of permutation and number of times Vladik's mom sorted some subsegment of the book.

Second line contains *n* space-separated integers *p*1,<=*p*2,<=...,<=*p**n* (1<=≤<=*p**i*<=≤<=*n*) — permutation *P*. Note that elements in permutation are distinct.

Each of the next *m* lines contains three space-separated integers *l**i*, *r**i*, *x**i* (1<=≤<=*l**i*<=≤<=*x**i*<=≤<=*r**i*<=≤<=*n*) — left and right borders of sorted subsegment in *i*-th sorting and position that is interesting to Vladik.","For each mom’s sorting on it’s own line print ""Yes"", if page which is interesting to Vladik hasn't changed, or ""No"" otherwise.","['5 5\n5 4 3 2 1\n1 5 3\n1 3 1\n2 4 3\n4 4 4\n2 5 3\n', '6 5\n1 4 3 2 5 6\n2 4 3\n1 6 2\n4 5 4\n1 3 3\n2 6 3\n']","['Yes\nNo\nYes\nYes\nNo\n', 'Yes\nNo\nYes\nNo\nYes\n']","Explanation of first test case: 
 1.  [1, 2, 3, 4, 5] — permutation after sorting, 3-rd element hasn’t changed, so answer is ""Yes"". 1.  [3, 4, 5, 2, 1] — permutation after sorting, 1-st element has changed, so answer is ""No"". 1.  [5, 2, 3, 4, 1] — permutation after sorting, 3-rd element hasn’t changed, so answer is ""Yes"". 1.  [5, 4, 3, 2, 1] — permutation after sorting, 4-th element hasn’t changed, so answer is ""Yes"". 1.  [5, 1, 2, 3, 4] — permutation after sorting, 3-rd element has changed, so answer is ""No"".",TIME_LIMIT_EXCEEDED,"def b():
    N, M = map(int, input().split())

    P = list(map(int, input().split()))

    for m in range(M):
        l,r,x = map(lambda x:int(x)-1, input().split())
        if not (l <= x <= r):
            print(""Yes"")
            continue

        a = x - l

        c = 0
        for p in P[l:r+1]:
            if P[x] == p:
                continue
            if p < P[x]:
                c += 1
                if c > a:
                    break

        if c == a:
            print(""Yes"")
        else:
            print(""No"")

if __name__ == ""__main__"":

    b()","import g

def c():

    input = g.stdin.readline

    n, q, c = map(int, input().split())

    d = 101

    b = [[[0] * (d + 1) for _ in range(d + 1)] for _ in range(c + 1)]

    for _ in range(n):
        x, y, s = map(int, input().split())

        for k in range(c + 1):
            a = (s + k) % (c + 1)
            b[k][x][y] += a

    e = [[[0] * (d + 1) for _ in range(d + 1)] for _ in range(c + 1)]
    for k in range(c + 1):
        for i in range(1, d + 1):
            for j in range(1, d + 1):
                e[k][i][j] = (b[k][i][j] + e[k][i - 1][j] +
                                     e[k][i][j - 1] - e[k][i - 1][j - 1])

    f = []
    for _ in range(q):
        t, i, k, j, l = map(int, input().split())

        k = t % (c + 1)

        h = (e[k][j][l] - e[k][i - 1][l] -
                 e[k][j][k - 1] + e[k][i - 1][k - 1])
        f.append(str(h))
    
    g.stdout.write(""\n"".join(f) + ""\n"")

if __name__ == ""__main__"":
    c()"
9,A,Die Roll,PROGRAMMING,"['math', 'probabilities']","Yakko, Wakko and Dot, world-famous animaniacs, decided to rest from acting in cartoons, and take a leave to travel a bit. Yakko dreamt to go to Pennsylvania, his Motherland and the Motherland of his ancestors. Wakko thought about Tasmania, its beaches, sun and sea. Dot chose Transylvania as the most mysterious and unpredictable place.

But to their great regret, the leave turned to be very short, so it will be enough to visit one of the three above named places. That's why Yakko, as the cleverest, came up with a truly genius idea: let each of the three roll an ordinary six-sided die, and the one with the highest amount of points will be the winner, and will take the other two to the place of his/her dreams.

Yakko thrown a die and got Y points, Wakko — W points. It was Dot's turn. But she didn't hurry. Dot wanted to know for sure what were her chances to visit Transylvania.

It is known that Yakko and Wakko are true gentlemen, that's why if they have the same amount of points with Dot, they will let Dot win.",The only line of the input file contains two natural numbers Y and W — the results of Yakko's and Wakko's die rolls.,"Output the required probability in the form of irreducible fraction in format «A/B», where A — the numerator, and B — the denominator. If the required probability equals to zero, output «0/1». If the required probability equals to 1, output «1/1».",['4 2\n'],['1/2\n'],"Dot will go to Transylvania, if she is lucky to roll 4, 5 or 6 points.",WRONG_ANSWER,"def d(a):
    e = a[0]
    f = 0

    for i in range(len(a)):
        if a[i] > e:
            e = a[i]
            f = i

    return f

def c(a, b):

    if b % a == 0:
        b /= a
        a /= a
    elif (b % 2 and a % 2) == 0:
        b /= 2
        a /= 2
    elif (b % 3 and a % 3) == 0:
        b /= 3
        a /= 3

    return (""{}/{}"".format(int(a), int(b)))

h = list(map(int, input().split("" "")))

b = h[d(h)]

g = 7 - b

print(c(g, 6))","def d():

    n = int(input().strip())

    c = list(map(int, input().split()))

    a = 0
    e = 0

    for b in c:
        if b == -1:

            if a > 0:

                a -= 1
            else:

                e += 1
        else:

            a += b

    print(e)

if __name__ == ""__main__"":
    d()"
858,A,k-rounding,PROGRAMMING,"['brute force', 'math', 'number theory']","For a given positive integer *n* denote its *k*-rounding as the minimum positive integer *x*, such that *x* ends with *k* or more zeros in base 10 and is divisible by *n*.

For example, 4-rounding of 375 is 375·80<==<=30000. 30000 is the minimum integer such that it ends with 4 or more zeros and is divisible by 375.

Write a program that will perform the *k*-rounding of *n*.","The only line contains two integers *n* and *k* (1<=≤<=*n*<=≤<=109, 0<=≤<=*k*<=≤<=8).",Print the *k*-rounding of *n*.,"['375 4\n', '10000 1\n', '38101 0\n', '123456789 8\n']","['30000\n', '10000\n', '38101\n', '12345678900000000\n']",none,WRONG_ANSWER,"import math
def a(n, k):
    c=[]
    e=[]
    for i in range(1, 11):
        d=0
        c.append(n*i)
        c=str(n*i)
        l=list(c)
        b=l[::-1]
        for j in b:
            if j=='0':
                d+=1
            if j!='0':
                break
        e.append(d)

    if k in e:
        print(c[e.index(k)])
    if k not in e:
        if k<min(e):
            print(c[0])
        if k>min(e):
            c=c[e.index(max(e))]
            s=str(c)

            for k in range(abs(max(e)-k)):
                s+='0'
            print(s)
if __name__==""__main__"":
    n, k=map(int, input().rstrip().split())
    a(n, k)","import d

def c():

    s = d.stdin.read().strip()
    if not s:
        return

    b = {}
    for a in s:
        b[a] = b.get(a, 0) + 1

    for a in reversed(""abcdefghijklmnopqrstuvwxyz""):
        if a in b:
            d.stdout.write(a * b[a])
            break

if __name__ == ""__main__"":
    c()"
908,E,New Year and Entity Enumeration,PROGRAMMING,"['bitmasks', 'combinatorics', 'dp', 'math']","You are given an integer *m*.

Let *M*<==<=2*m*<=-<=1.

You are also given a set of *n* integers denoted as the set *T*. The integers will be provided in base 2 as *n* binary strings of length *m*.

A set of integers *S* is called ""good"" if the following hold. 
 1.  If , then . 1.  If , then  1.   1.  All elements of *S* are less than or equal to *M*. 
Here,  and  refer to the bitwise XOR and bitwise AND operators, respectively.

Count the number of good sets *S*, modulo 109<=+<=7.","The first line will contain two integers *m* and *n* (1<=≤<=*m*<=≤<=1<=000, 1<=≤<=*n*<=≤<=*min*(2*m*,<=50)).

The next *n* lines will contain the elements of *T*. Each line will contain exactly *m* zeros and ones. Elements of *T* will be distinct.","Print a single integer, the number of good sets modulo 109<=+<=7.","['5 3\n11010\n00101\n11000\n', '30 2\n010101010101010010101010101010\n110110110110110011011011011011\n']","['4\n', '860616440\n']","An example of a valid set *S* is {00000, 00101, 00010, 00111, 11000, 11010, 11101, 11111}.",OK,"from collections import f

def a():

    h = 10 ** 9 + 7

    d = [[1]]
    for i in range(1, 1010):
        x = [1]
        for j in range(1, i):
            x.append((d[i - 1][j - 1] + d[i - 1][j]) % h)
        x.append(1)
        d.append(x)

    g = [1]
    for i in range(1, 1010):
        r = 0
        for k in range(i):
            r += g[k] * d[i - 1][k]
            r %= h
        g.append(r)

    m, n = map(int, input().split())

    i = [0 for b in range(m)]
    for j in range(n):
        j = input()
        s = [int(i) for i in j]
        for i in range(m):
            i[i] |= s[i] << j

    e = f(int)
    for e in i:
        e[e] += 1

    c = 1
    for b in e.values():
        c = c * g[b] % h

    print(c)

if __name__=='__main__':
    a()","import i
import d

def c():

    b = i.stdin.read().strip().split()
    if not b:
        return
    n = int(b[0])
    a = list(map(int, b[1:]))

    a = a.count(1)
    if a:

        print(n - a)
        return

    g = a[0]
    for f in a:
        g = d.gcd(g, f)
    if g != 1:
        print(-1)
        return

    e = n
    for i in range(n):
        g = a[i]
        for j in range(i + 1, n):
            g = d.gcd(g, a[j])
            if g == 1:

                e = min(e, j - i)
                break

    h = e + n - 1
    print(h)

if __name__ == ""__main__"":
    c()"
313,B,Ilya and Queries,PROGRAMMING,"['dp', 'implementation']","Ilya the Lion wants to help all his friends with passing exams. They need to solve the following problem to pass the IT exam.

You've got string *s*<==<=*s*1*s*2... *s**n* (*n* is the length of the string), consisting only of characters ""."" and ""#"" and *m* queries. Each query is described by a pair of integers *l**i*,<=*r**i* (1<=≤<=*l**i*<=&lt;<=*r**i*<=≤<=*n*). The answer to the query *l**i*,<=*r**i* is the number of such integers *i* (*l**i*<=≤<=*i*<=&lt;<=*r**i*), that *s**i*<==<=*s**i*<=+<=1.

Ilya the Lion wants to help his friends but is there anyone to help him? Help Ilya, solve the problem.","The first line contains string *s* of length *n* (2<=≤<=*n*<=≤<=105). It is guaranteed that the given string only consists of characters ""."" and ""#"".

The next line contains integer *m* (1<=≤<=*m*<=≤<=105) — the number of queries. Each of the next *m* lines contains the description of the corresponding query. The *i*-th line contains integers *l**i*,<=*r**i* (1<=≤<=*l**i*<=&lt;<=*r**i*<=≤<=*n*).",Print *m* integers — the answers to the queries in the order in which they are given in the input.,"['......\n4\n3 4\n2 3\n1 6\n2 6\n', '#..###\n5\n1 3\n5 6\n1 5\n3 6\n3 4\n']","['1\n1\n5\n4\n', '1\n1\n2\n2\n0\n']",none,WRONG_ANSWER,"def a(n, m):
    
    
    return m-n

s = input()
t = int(input())
while t:
    n, m = map(int, input().split())
    print(a(n, m))
    t-=1","from math import d

def e(a, b):
    return a * b // d(a, b)

def f():

    x, y, a, b = map(int, input().strip().split())

    a = e(x, y)

    c = b // a
    b = (a - 1) // a

    g = c - b

    print(g)

if __name__ == ""__main__"":
    f()"
891,A,Pride,PROGRAMMING,"['brute force', 'dp', 'greedy', 'math', 'number theory']","You have an array *a* with length *n*, you can perform operations. Each operation is like this: choose two adjacent elements from *a*, say *x* and *y*, and replace one of them with *gcd*(*x*,<=*y*), where *gcd* denotes the [greatest common divisor](https://en.wikipedia.org/wiki/Greatest_common_divisor).

What is the minimum number of operations you need to make all of the elements equal to 1?","The first line of the input contains one integer *n* (1<=≤<=*n*<=≤<=2000) — the number of elements in the array.

The second line contains *n* space separated integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=109) — the elements of the array.","Print -1, if it is impossible to turn all numbers to 1. Otherwise, print the minimum number of operations needed to make all numbers equal to 1.","['5\n2 2 3 4 6\n', '4\n2 4 6 8\n', '3\n2 6 9\n']","['5\n', '-1\n', '4\n']","In the first sample you can turn all numbers to 1 using the following 5 moves:
 -  [2, 2, 3, 4, 6]. -  [2, 1, 3, 4, 6] -  [2, 1, 3, 1, 6] -  [2, 1, 1, 1, 6] -  [1, 1, 1, 1, 6] -  [1, 1, 1, 1, 1] 
We can prove that in this case it is not possible to make all numbers one using less than 5 moves.",WRONG_ANSWER,"n = int(input())
a = list(map(int,input().split()))

def a(x, y):
   while(y): 
       x, y = y, x % y
   return x

c = []

for i in range(n-1):
    c.append(a(a[i],a[i+1]))

z = len(set(c))

if z==1:
    print(-1)
elif (1 in c):
    print(n)
elif z==2:
    print(n+1)
else:
    b = []
    d = 1
    for i in range(1,len(c)):
        if c[i]!=c[i-1]:
            b.append(d)
            d = 1
        else:
            d +=1
    b.append(d)
    print(min(b[1::2])+n+1)","def a(a: str, b: str) -> bool:

    def f(s: str) -> str:

        return '1' if s.count('1') % 2 == 1 else '0'
    
    n = len(a)

    for k in range(0, n + 1):
        s = a[k:]

        if not b.startswith(s):
            continue

        r = b[len(s):]
        d = s
        g = True

        for b in r:
            c = f(d)
            if c != b:
                g = False
                break
            d += c
        if g:
            return True
    return False

if __name__ == '__main__':
    import h

    e = h.stdin.read().splitlines()
    if len(e) < 2:
        h.exit(1)
    a = e[0].strip()
    b = e[1].strip()

    print(""YES"" if a(a, b) else ""NO"")"
448,B,Suffix Structures,PROGRAMMING,"['implementation', 'strings']","Bizon the Champion isn't just a bison. He also is a favorite of the ""Bizons"" team.

At a competition the ""Bizons"" got the following problem: ""You are given two distinct words (strings of English letters), *s* and *t*. You need to transform word *s* into word *t*"". The task looked simple to the guys because they know the suffix data structures well. Bizon Senior loves suffix automaton. By applying it once to a string, he can remove from this string any single character. Bizon Middle knows suffix array well. By applying it once to a string, he can swap any two characters of this string. The guys do not know anything about the suffix tree, but it can help them do much more. 

Bizon the Champion wonders whether the ""Bizons"" can solve the problem. Perhaps, the solution do not require both data structures. Find out whether the guys can solve the problem and if they can, how do they do it? Can they solve it either only with use of suffix automaton or only with use of suffix array or they need both structures? Note that any structure may be used an unlimited number of times, the structures may be used in any order.",The first line contains a non-empty word *s*. The second line contains a non-empty word *t*. Words *s* and *t* are different. Each word consists only of lowercase English letters. Each word contains at most 100 letters.,"In the single line print the answer to the problem. Print ""need tree"" (without the quotes) if word *s* cannot be transformed into word *t* even with use of both suffix array and suffix automaton. Print ""automaton"" (without the quotes) if you need only the suffix automaton to solve the problem. Print ""array"" (without the quotes) if you need only the suffix array to solve the problem. Print ""both"" (without the quotes), if you need both data structures to solve the problem.

It's guaranteed that if you can solve the problem only with use of suffix array, then it is impossible to solve it only with use of suffix automaton. This is also true for suffix automaton.","['automaton\ntomat\n', 'array\narary\n', 'both\nhot\n', 'need\ntree\n']","['automaton\n', 'array\n', 'both\n', 'need tree\n']","In the third sample you can act like that: first transform ""both"" into ""oth"" by removing the first character using the suffix automaton and then make two swaps of the string using the suffix array and get ""hot"".",WRONG_ANSWER,"def d(j, a):
    
    g = j.find(a)
    if g == -1:
        return False
    else:
        return True
    
def c(j, a):
    
    if len(j) != len(a):
        return False

    i = {}
    for w in j:
        if w not in i:
            i[w] = 1
        else:
            i[w] += 1
            
    h = {}
    for w in a: 
        if w not in h:
            h[w] = 1
        else:
            h[w] += 1
            
    if h == i:
        return True
    
    return False
    
def f(j, a):
    
    e = list(j)
    b = set(a)
    
    for w in j:
        if w not in b:
            
            while w in e:
                e.remove(w)
                
    if c(''.join(e), a):
        return True
    
    return False

j = input()
a = input()

if d(j, a):
    print(""automaton"")
    
elif c(j, a):
    print(""array"")

elif f(j, a):
    print(""both"")
    
else:
    print(""need tree"")","import g
from fractions import a

def f():

    d = g.stdin.read().split()

    p = int(d[0])
    q = int(d[1])
    e = a(p, q)

    n = int(d[2])

    a = list(map(int, d[3:3+n]))

    b = a(a[-1], 1)
    for c in reversed(a[:-1]):
        b = a(c, 1) + a(1, b)

    if e == b:
        print(""YES"")
    else:
        print(""NO"")

if __name__ == '__main__':
    f()"
131,B,Opposites Attract,PROGRAMMING,"['implementation', 'math']","Everybody knows that opposites attract. That is the key principle of the ""Perfect Matching"" dating agency. The ""Perfect Matching"" matchmakers have classified each registered customer by his interests and assigned to the *i*-th client number *t**i* (<=-<=10<=≤<=*t**i*<=≤<=10). Of course, one number can be assigned to any number of customers.

""Perfect Matching"" wants to advertise its services and publish the number of opposite couples, that is, the couples who have opposite values of *t*. Each couple consists of exactly two clients. The customer can be included in a couple an arbitrary number of times. Help the agency and write the program that will find the sought number by the given sequence *t*1,<=*t*2,<=...,<=*t**n*. For example, if *t*<==<=(1,<=<=-<=1,<=1,<=<=-<=1), then any two elements *t**i* and *t**j* form a couple if *i* and *j* have different parity. Consequently, in this case the sought number equals 4.

Of course, a client can't form a couple with him/herself.","The first line of the input data contains an integer *n* (1<=≤<=*n*<=≤<=105) which represents the number of registered clients of the ""Couple Matching"". The second line contains a sequence of integers *t*1,<=*t*2,<=...,<=*t**n* (<=-<=10<=≤<=*t**i*<=≤<=10), *t**i* — is the parameter of the *i*-th customer that has been assigned to the customer by the result of the analysis of his interests.","Print the number of couples of customs with opposite *t*. The opposite number for *x* is number <=-<=*x* (0 is opposite to itself). Couples that only differ in the clients' order are considered the same.

Note that the answer to the problem can be large enough, so you must use the 64-bit integer type for calculations. Please, do not use the %lld specificator to read or write 64-bit integers in С++. It is preferred to use cin, cout streams or the %I64d specificator.","['5\n-3 3 0 0 3\n', '3\n0 0 0\n']","['3\n', '3\n']","In the first sample the couples of opposite clients are: (1,2), (1,5) и (3,4).

In the second sample any couple of clients is opposite.",WRONG_ANSWER,"import collections
import math
g = lambda n: int(n * (n + 1) / 2)
h = lambda n: int( (n) * (n + 1) * (2*n +1)/6)

def d(): return map(int, input().split())
def c(): return list(map(int, input().split()))
def b(): return int(input())

def e(a):
    return True if a[::-1] == a else False

def f():
    n=b()
    s=c()
    a=[0]*11
    b=[0]*11
    for i in s:
        if i>=0:
            a[i]+=1
        else:
            b[-i]+=1
    a=a[0]
    for i in range(1,11):
        a+=min(a[i],b[i])
    return a

if __name__ == '__main__':

    print(f())","s = input().strip()

c = sum(1 for a in s if a.isupper())

b = sum(1 for a in s if a.islower())

if c > b:
    print(s.upper())
else:
    print(s.lower())"
520,A,Pangram,PROGRAMMING,"['implementation', 'strings']","A word or a sentence in some language is called a pangram if all the characters of the alphabet of this language appear in it at least once. Pangrams are often used to demonstrate fonts in printing or test the output devices.

You are given a string consisting of lowercase and uppercase Latin letters. Check whether this string is a pangram. We say that the string contains a letter of the Latin alphabet if this letter occurs in the string in uppercase or lowercase.","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=100) — the number of characters in the string.

The second line contains the string. The string consists only of uppercase and lowercase Latin letters.","Output ""YES"", if the string is a pangram and ""NO"" otherwise.","['12\ntoosmallword\n', '35\nTheQuickBrownFoxJumpsOverTheLazyDog\n']","['NO\n', 'YES\n']",none,OK,"str = ""abcdefghijklmnopqrstuvwxyz""
list = list(str)
b = []
c = {}

n = int(input())
s = input().lower()

for a in s:
    if a in c:
        c[a] += 1

    else:
        c[a] = 1

for d in c.keys():
    b.append(d)

if sorted(list) == sorted(b):
    print(""YES"")
else:
    print(""NO"")","n = int(input().strip())

b = list(map(int, input().split()))

a = sum(b) / n

print(f""{a:.12f}"")"
304,B,Calendar,PROGRAMMING,"['brute force', 'implementation']","Calendars in widespread use today include the Gregorian calendar, which is the de facto international standard, and is used almost everywhere in the world for civil purposes. The Gregorian reform modified the Julian calendar's scheme of leap years as follows:

 Every year that is exactly divisible by four is a leap year, except for years that are exactly divisible by 100; the centurial years that are exactly divisible by 400 are still leap years. For example, the year 1900 is not a leap year; the year 2000 is a leap year. 

In this problem, you have been given two dates and your task is to calculate how many days are between them. Note, that leap years have unusual number of days in February.

Look at the sample to understand what borders are included in the aswer.","The first two lines contain two dates, each date is in the format yyyy:mm:dd (1900<=≤<=*yyyy*<=≤<=2038 and yyyy:mm:dd is a legal date).",Print a single integer — the answer to the problem.,"['1900:01:01\n2038:12:31\n', '1996:03:09\n1991:11:12\n']","['50768\n', '1579\n']",none,WRONG_ANSWER,"from sys import g
def input(): return g.readline()[:-1]
def d(): return list(map(int, input().split()))

h,e,a=map(int, input().split(':'))
i,f,b=map(int, input().split(':'))
c = 0
if h*100000+e*100+a > i*100000+f*100+b:

    h, i = i, h
    e, f = f, e
    a, b = b, a
for i in range(h+1,i):
    if (i%4 == 0 and i%100 != 0) or i%400 == 0:
        c += 366
        continue
    c += 365
for l in range(1, f+1):
    if l == f:

        c += b
        break
    if l == 1 or l == 3 or l == 5 or l == 7 or l == 8 or l == 10 or l == 12:
        c += 31
    elif l == 4 or l == 6 or l == 9 or l == 11:
        c += 30
    elif l == 2:
        c += 28
        if (i%4 == 0 and i%100 != 0) or i%400 == 0:
            c += 1
c += 365
if (h%4 == 0 and h%100 != 0) or h%400 == 0:
    c += 1

for l in range(1, e+1):
    if l == e:
        c -= a
        break
    if l == 1 or l == 3 or l == 5 or l == 7 or l == 8 or l == 10 or l == 12:
        c -= 31
    elif l == 4 or l == 6 or l == 9 or l == 11:
        c -= 30
    elif l == 2:
        c -= 28
        if (h%4 == 0 and h%100 != 0) or h%400 == 0:

            c -= 1
print(c)","import c

def b():
    import d

    a = d.stdin.read().strip().split()
    if not a:
        return

    a, b, c = map(int, a)

    f = c.sqrt(a * b * c)

    x = int(round(f / c))
    y = int(round(f / b))
    z = int(round(f / a))

    e = 4 * (x + y + z)

    d.stdout.write(str(e) + ""\n"")

if __name__ == ""__main__"":
    b()"
0,none,none,none,['none'],"Bear Limak examines a social network. Its main functionality is that two members can become friends (then they can talk with each other and share funny pictures).

There are *n* members, numbered 1 through *n*. *m* pairs of members are friends. Of course, a member can't be a friend with themselves.

Let A-B denote that members A and B are friends. Limak thinks that a network is reasonable if and only if the following condition is satisfied: For every three distinct members (X, Y, Z), if X-Y and Y-Z then also X-Z.

For example: if Alan and Bob are friends, and Bob and Ciri are friends, then Alan and Ciri should be friends as well.

Can you help Limak and check if the network is reasonable? Print ""YES"" or ""NO"" accordingly, without the quotes.","The first line of the input contain two integers *n* and *m* (3<=≤<=*n*<=≤<=150<=000, ) — the number of members and the number of pairs of members that are friends.

The *i*-th of the next *m* lines contains two distinct integers *a**i* and *b**i* (1<=≤<=*a**i*,<=*b**i*<=≤<=*n*,<=*a**i*<=≠<=*b**i*). Members *a**i* and *b**i* are friends with each other. No pair of members will appear more than once in the input.","If the given network is reasonable, print ""YES"" in a single line (without the quotes). Otherwise, print ""NO"" in a single line (without the quotes).","['4 3\n1 3\n3 4\n1 4\n', '4 4\n3 1\n2 3\n3 4\n1 2\n', '10 4\n4 3\n5 10\n8 9\n1 2\n', '3 2\n1 2\n2 3\n']","['YES\n', 'NO\n', 'YES\n', 'NO\n']","The drawings below show the situation in the first sample (on the left) and in the second sample (on the right). Each edge represents two members that are friends. The answer is ""NO"" in the second sample because members (2, 3) are friends and members (3, 4) are friends, while members (2, 4) are not.",WRONG_ANSWER,"def b(h, d, a, i):
    i[h] = True
    for g in a[h]:
        if not i[g]:
            b(g, d, a, i)
        else:
            if d != g:
                return False
    return True

def c(n, m, e):
    a = [[] for _ in range(n)]
    for a, b in e:
        a[a - 1].append(b - 1)
        a[b - 1].append(a - 1)

    i = [False] * n

    for i in range(n):
        if not i[i]:
            if not b(i, -1, a, i):
                return ""NO""

    return ""YES""

n, m = map(int, input().split())
e = []
for _ in range(m):
    a, b = map(int, input().split())
    e.append((a, b))

f = c(n, m, e)
print(f)","import e

def c():

    b = e.stdin.read().split()
    if not b:
        return

    n = int(b[0])
    t = int(b[1])

    d = list(map(int, b[2:]))

    a = 1

    while a < t:
        a += d[a - 1]

    if a == t:
        print(""YES"")
    else:
        print(""NO"")

if __name__ == ""__main__"":
    c()"
522,D,Closest Equals,PROGRAMMING,"['*special', 'data structures']","You are given sequence *a*1,<=*a*2,<=...,<=*a**n* and *m* queries *l**j*,<=*r**j* (1<=≤<=*l**j*<=≤<=*r**j*<=≤<=*n*). For each query you need to print the minimum distance between such pair of elements *a**x* and *a**y* (*x*<=≠<=*y*), that:
 -  both indexes of the elements lie within range [*l**j*,<=*r**j*], that is, *l**j*<=≤<=*x*,<=*y*<=≤<=*r**j*; -  the values of the elements are equal, that is *a**x*<==<=*a**y*. 
The text above understands distance as |*x*<=-<=*y*|.","The first line of the input contains a pair of integers *n*, *m* (1<=≤<=*n*,<=*m*<=≤<=5·105) — the length of the sequence and the number of queries, correspondingly. 

The second line contains the sequence of integers *a*1,<=*a*2,<=...,<=*a**n* (<=-<=109<=≤<=*a**i*<=≤<=109). 

Next *m* lines contain the queries, one per line. Each query is given by a pair of numbers *l**j*,<=*r**j* (1<=≤<=*l**j*<=≤<=*r**j*<=≤<=*n*) — the indexes of the query range limits.","Print *m* integers — the answers to each query. If there is no valid match for some query, please print -1 as an answer to this query.","['5 3\n1 1 2 3 2\n1 5\n2 4\n3 5\n', '6 5\n1 2 1 3 2 3\n4 6\n1 3\n2 5\n2 4\n1 6\n']","['1\n-1\n2\n', '2\n2\n3\n-1\n2\n']",none,WRONG_ANSWER,"def b(X, l, r):
    m = len(X)
    if r < X[0]:
        return float('inf')
    if X[-1] < l:
        return float('inf')
    if l <= X[0]:
        c = 0
    else:
        s = 0
        e = m-1
        while s+1 < e:
            d = (s+e)//2
            if X[d] > l:
                s, e = d, e
            else:
                s, e = s, d
        c = e
    if X[-1] <= r:
        g = m-1
    else:
        s = 0
        e = m-1
        while s+1 < e:
            d = (s+e)//2
            if X[d] <= r:
                s, e = d, e
            else:
                s, e = s, d
        g = s
    if c==g:
        return float('inf')
    return X[g]-X[c]

def f(A, Q):
    d = {}
    n = len(A)
    a = []
    for i in range(n):
        x = A[i]
        if x not in d:
            d[x] = []
        d[x].append(i)
    for l, r in Q:
        e = float('inf')
        for x in d:
            e = min(e, b(d[x], l-1, r-1))
        if e==float('inf'):
            a.append(-1)
        else:
            a.append(e)
    return a

n, m = [int(x) for x in input().split()]
A = [int(x) for x in input().split()]
Q = []
for i in range(m):
    l, r = [int(x) for x in input().split()]
    Q.append([l, r])
a = f(A, Q)
for x in a:
    print(x)","""""""
This script counts the number of distinct pairs of vertices in a tree
that have exactly distance k between them.
A DFS with dynamic programming is used where each node v maintains a dp array
of size (k+1) such that dp[i] is the number of nodes in the subtree of v that are
at distance i from v. We merge the dp arrays during DFS and count the pairs
that satisfy the condition.
""""""

import k
import numpy as h

k.setrecursionlimit(1000000)

def j():

    c = k.stdin.read().split()
    if not c:
        return
    n = int(c[0])
    k = int(c[1])

    f = [[] for _ in range(n + 1)]
    g = 2
    for _ in range(n - 1):
        u = int(c[g])
        v = int(c[g + 1])
        g += 2
        f[u].append(v)
        f[v].append(u)

    a = 0

    def d(v, i):
        nonlocal a

        e = h.zeros(k + 1, dtype=h.int64)
        e[0] = 1

        for w in f[v]:
            if w == i:
                continue

            b = d(w, v)

            a += int(h.dot(e[:k], b[:k][::-1]))

            e[1:] += b[:k]
        
        return e

    d(1, -1)
    k.stdout.write(str(a))

if __name__ == '__main__':
    j()"
678,C,Joty and Chocolate,PROGRAMMING,"['implementation', 'math', 'number theory']","Little Joty has got a task to do. She has a line of *n* tiles indexed from 1 to *n*. She has to paint them in a strange pattern.

An unpainted tile should be painted Red if it's index is divisible by *a* and an unpainted tile should be painted Blue if it's index is divisible by *b*. So the tile with the number divisible by *a* and *b* can be either painted Red or Blue.

After her painting is done, she will get *p* chocolates for each tile that is painted Red and *q* chocolates for each tile that is painted Blue.

Note that she can paint tiles in any order she wants.

Given the required information, find the maximum number of chocolates Joty can get.","The only line contains five integers *n*, *a*, *b*, *p* and *q* (1<=≤<=*n*,<=*a*,<=*b*,<=*p*,<=*q*<=≤<=109).","Print the only integer *s* — the maximum number of chocolates Joty can get.

Note that the answer can be too large, so you should use 64-bit integer type to store it. In C++ you can use the long long integer type and in Java you can use long integer type.","['5 2 3 12 15\n', '20 2 3 3 5\n']","['39\n', '51\n']",none,OK,"from sys import f, stdout
def b():
	return f.readline().rstrip()

def c():
	return int(b())

def d():
	return list(map(int, b().split()))

def a(x,y):
	while y>0:
		x,y=y,x%y
	return x

def e():
	n,a,b,p,q=d()
	print((n//a)*p + (n//b)*q - (n//(a*b//a(a,b)))*min(p,q))

e()","def c():
    import e
    b = e.stdin.read().split()

    n = int(b[0])
    t = int(b[1])

    d = list(map(int, b[2:]))

    a = 1

    while a < t:
        a = a + d[a - 1]

    print(""YES"" if a == t else ""NO"")

if __name__ == '__main__':
    c()"
769,D,k-Interesting Pairs Of Integers,PROGRAMMING,"['*special', 'bitmasks', 'brute force', 'meet-in-the-middle']","Vasya has the sequence consisting of *n* integers. Vasya consider the pair of integers *x* and *y* k-interesting, if their binary representation differs from each other exactly in *k* bits. For example, if *k*<==<=2, the pair of integers *x*<==<=5 and *y*<==<=3 is k-interesting, because their binary representation *x*=101 and *y*=011 differs exactly in two bits.

Vasya wants to know how many pairs of indexes (*i*, *j*) are in his sequence so that *i*<=&lt;<=*j* and the pair of integers *a**i* and *a**j* is k-interesting. Your task is to help Vasya and determine this number.","The first line contains two integers *n* and *k* (2<=≤<=*n*<=≤<=105, 0<=≤<=*k*<=≤<=14) — the number of integers in Vasya's sequence and the number of bits in which integers in k-interesting pair should differ.

The second line contains the sequence *a*1,<=*a*2,<=...,<=*a**n* (0<=≤<=*a**i*<=≤<=104), which Vasya has.","Print the number of pairs (*i*, *j*) so that *i*<=&lt;<=*j* and the pair of integers *a**i* and *a**j* is k-interesting.","['4 1\n0 3 2 1\n', '6 0\n200 100 100 100 200 200\n']","['4\n', '6\n']","In the first test there are 4 k-interesting pairs:
 -  (1, 3), -  (1, 4), -  (2, 3), -  (2, 4). 
In the second test *k* = 0. Consequently, integers in any k-interesting pair should be equal to themselves. Thus, for the second test there are 6 k-interesting pairs:
 -  (1, 5), -  (1, 6), -  (2, 3), -  (2, 4), -  (3, 4), -  (5, 6).",WRONG_ANSWER,"def c(a,b):
    a = str(a)
    b = str(b)
    if len(a)>len(b):
        k = len(a) - len(b)
        for i in range(len(b),0):
            for j in range(len(a),0):
                if a-b == j-i and b[i] != a[j]:
                    k+=1
    else:
        k = len(b) - len(a)
        for i in range(len(a),0):
            for j in range(len(b),0):
                if b-a == j-i and a[i] != b[j]:
                    k+=1        
    return k
    
def b():
    n,m = map(int,input().split())
    a = list(map(int,input().split()))
    for i in range(n):
        k = 1
        b = 0
        while (a[i]!=0):
            b += a[i] % 2 * k
            a[i] //= 2
            k *= 10
        a[i] = b
    q = 0
    for i in range(n):
        for j in range(i+1,n):
            p = c(a[i],a[j])
            if p == m:
                q+=1;
    print(q)   
b()","def d():
    import g

    b = g.stdin.read().split()
    if not b:
        return
    n = int(b[0])
    c = int(b[1])

    p = list(map(int, b[2:2 + n]))

    t = list(map(int, b[2 + n:2 + 2 * n]))

    c = 0
    a = 0
    for i in range(n):
        a += t[i]

        f = p[i] - c * a
        if f < 0:
            f = 0
        c += f

    e = 0
    a = 0
    for i in range(n - 1, -1, -1):
        a += t[i]
        f = p[i] - c * a
        if f < 0:
            f = 0
        e += f

    if c > e:
        print(""Limak"")
    elif e > c:
        print(""Radewoosh"")
    else:
        print(""Tie"")

if __name__ == '__main__':
    d()"
363,B,Fence,PROGRAMMING,"['brute force', 'dp']","There is a fence in front of Polycarpus's home. The fence consists of *n* planks of the same width which go one after another from left to right. The height of the *i*-th plank is *h**i* meters, distinct planks can have distinct heights.

Polycarpus has bought a posh piano and is thinking about how to get it into the house. In order to carry out his plan, he needs to take exactly *k* consecutive planks from the fence. Higher planks are harder to tear off the fence, so Polycarpus wants to find such *k* consecutive planks that the sum of their heights is minimal possible.

Write the program that finds the indexes of *k* consecutive planks with minimal total height. Pay attention, the fence is not around Polycarpus's home, it is in front of home (in other words, the fence isn't cyclic).","The first line of the input contains integers *n* and *k* (1<=≤<=*n*<=≤<=1.5·105,<=1<=≤<=*k*<=≤<=*n*) — the number of planks in the fence and the width of the hole for the piano. The second line contains the sequence of integers *h*1,<=*h*2,<=...,<=*h**n* (1<=≤<=*h**i*<=≤<=100), where *h**i* is the height of the *i*-th plank of the fence.","Print such integer *j* that the sum of the heights of planks *j*, *j*<=+<=1, ..., *j*<=+<=*k*<=-<=1 is the minimum possible. If there are multiple such *j*'s, print any of them.",['7 3\n1 2 6 1 1 7 1\n'],['3\n'],"In the sample, your task is to find three consecutive planks with the minimum sum of heights. In the given case three planks with indexes 3, 4 and 5 have the required attribute, their total height is 8.",OK,"from sys import d, e

def input():
    return d.readline().strip()

def print(f):
    return e.write(str(f) + ""\n"")

def b():
    n, k = map(int, input().split())
    h = [int(x) for x in input().split()]
    a = [None] * n
    a[0] = sum(h[:k])
    c = 0
    for i in range(n-k):
        a[i+1] = a[i] - h[i] + h[i+k]
        if a[i+1] < a[c]:
            c = i+1
    print(c+1)

if __name__ == ""__main__"":
    b()","import i

def b(n, m):

    if m > 2 * (n + 1) or n > m + 1:
        return ""-1""
    
    h = []

    while m > 0 or n > 0:
        g = False

        if m > n and m > 0 and not """".join(h[-2:]) == ""11"":
            h.append(""1"")
            m -= 1
            g = True

        elif n > 0 and (len(h) == 0 or h[-1] != ""0""):
            h.append(""0"")
            n -= 1
            g = True

        elif m > 0 and not """".join(h[-2:]) == ""11"":
            h.append(""1"")
            m -= 1
            g = True

        if not g:
            break

    if m == 0 and n == 0:
        return """".join(h)
    else:
        return ""-1""

def e():
    c = i.stdin.read().splitlines()

    for d in c:
        if not d.strip():
            continue
        try:
            f = d.split()
            if len(f) < 2:
                continue
            n, m = map(int, f)
        except ValueError:
            continue
        a = b(n, m)
        i.stdout.write(a + ""\n"")

if __name__ == '__main__':
    e()"
770,A,New Password,PROGRAMMING,"['*special', 'implementation']","Innokentiy decides to change the password in the social net ""Contact!"", but he is too lazy to invent a new password by himself. That is why he needs your help. 

Innokentiy decides that new password should satisfy the following conditions:
 -  the length of the password must be equal to *n*, -  the password should consist only of lowercase Latin letters, -  the number of distinct symbols in the password must be equal to *k*, -  any two consecutive symbols in the password must be distinct. 
Your task is to help Innokentiy and to invent a new password which will satisfy all given conditions.","The first line contains two positive integers *n* and *k* (2<=≤<=*n*<=≤<=100, 2<=≤<=*k*<=≤<=*min*(*n*,<=26)) — the length of the password and the number of distinct symbols in it. 

Pay attention that a desired new password always exists.",Print any password which satisfies all conditions given by Innokentiy.,"['4 3\n', '6 6\n', '5 2\n']","['java\n', 'python\n', 'phphp\n']","In the first test there is one of the appropriate new passwords — java, because its length is equal to 4 and 3 distinct lowercase letters a, j and v are used in it.

In the second test there is one of the appropriate new passwords — python, because its length is equal to 6 and it consists of 6 distinct lowercase letters.

In the third test there is one of the appropriate new passwords — phphp, because its length is equal to 5 and 2 distinct lowercase letters p and h are used in it.

Pay attention the condition that no two identical symbols are consecutive is correct for all appropriate passwords in tests.",RUNTIME_ERROR,"import random
import string
a ='abcdefghijklmnopqrstuvwxyz'
x = int(input())
c = int(input())
b = ''
for i in range(0,c):
    b +=a[i] 
for i in range(c,x):
    b+= b[i-c]
print(b)","def e():
    import h

    c = h.stdin.read().split()
    if not c:
        return
    n = int(c[0])

    g = list(map(int, c[1:]))

    f = []

    for s in g:
        a = -1
        b = -1

        for i, d in enumerate(f):
            if d <= s and d > a:
                a = d
                b = i
        if b == -1:

            f.append(1)
        else:

            f[b] += 1

    h.stdout.write(str(len(f)))

if __name__ == '__main__':
    e()"
515,C,Drazil and Factorial,PROGRAMMING,"['greedy', 'math', 'sortings']","Drazil is playing a math game with Varda.

Let's define  for positive integer *x* as a product of factorials of its digits. For example, .

First, they choose a decimal number *a* consisting of *n* digits that contains at least one digit larger than 1. This number may possibly start with leading zeroes. Then they should find maximum positive number *x* satisfying following two conditions:

1. *x* doesn't contain neither digit 0 nor digit 1.

2.  = .

Help friends find such number.","The first line contains an integer *n* (1<=≤<=*n*<=≤<=15) — the number of digits in *a*.

The second line contains *n* digits of *a*. There is at least one digit in *a* that is larger than 1. Number *a* may possibly contain leading zeroes.",Output a maximum possible integer satisfying the conditions above. There should be no zeroes and ones in this number decimal representation.,"['4\n1234\n', '3\n555\n']","['33222\n', '555\n']","In the first case, <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/f5a4207f23215fddce977ab5ea9e9d2e7578fb52.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>",WRONG_ANSWER,"n=int(input())
c=list(map(int,input()))
print(c)
a={2:0,3:0,5:0,7:0}
def d(n):
    g={2:0,3:0,5:0,7:0}
    e=[i for i in range(1,n+1)]
    for i in e:
        if i==2:
            g[2]+=1
        elif i==3:
            g[3]+=1
        elif i==4:
            g[2]+=2
        elif i==5:
            g[5]+=1
        elif i==6:
            g[3]+=1
            g[2]+=1
        elif i==7:
            g[7]+=1
        elif i==8:
            g[2]+=3
        elif i==9:
            g[3]+=2
    return g
      
            
for b in c:
    h=d(b)
    
    for f in h.keys():
        a[f]+=h[f]

while a[2]!=0:
    if a[7]!=0:
        h=d(7)
        print(""7"",end="""")
        for f in h.keys():
            a[f]-=h[f]
    elif a[5]!=0:
        h=d(5)
        print(""5"",end="""")
        for f in h.keys():
            a[f]-=h[f]
    elif a[3]!=0:
        h=d(3)
        print(""3"",end="""")
        for f in h.keys():
            a[f]-=h[f]
    elif a[2]!=0:
        h=d(2)
        print(""2"",end="""")
        for f in h.keys():
            a[f]-=h[f]","import f

def b():

    n, m = map(int, f.stdin.readline().split())
    
    a = []

    for _ in range(n):
        e = f.stdin.readline().strip()
        a.append(e)

    d = []
    for i in range(n):
        c = []
        for j in range(m):
            if a[i][j] == '.':

                if (i + j) % 2 == 0:
                    c.append('B')
                else:
                    c.append('W')
            else:

                c.append('-')
        d.append(''.join(c))

    for e in d:
        f.stdout.write(e + '\n')

if __name__ == '__main__':
    b()"
19,D,Points,PROGRAMMING,['data structures'],"Pete and Bob invented a new interesting game. Bob takes a sheet of paper and locates a Cartesian coordinate system on it as follows: point (0,<=0) is located in the bottom-left corner, *Ox* axis is directed right, *Oy* axis is directed up. Pete gives Bob requests of three types: 
 -  add x y — on the sheet of paper Bob marks a point with coordinates (*x*,<=*y*). For each request of this type it's guaranteed that point (*x*,<=*y*) is not yet marked on Bob's sheet at the time of the request. -  remove x y — on the sheet of paper Bob erases the previously marked point with coordinates (*x*,<=*y*). For each request of this type it's guaranteed that point (*x*,<=*y*) is already marked on Bob's sheet at the time of the request. -  find x y — on the sheet of paper Bob finds all the marked points, lying strictly above and strictly to the right of point (*x*,<=*y*). Among these points Bob chooses the leftmost one, if it is not unique, he chooses the bottommost one, and gives its coordinates to Pete. 
Bob managed to answer the requests, when they were 10, 100 or 1000, but when their amount grew up to 2·105, Bob failed to cope. Now he needs a program that will answer all Pete's requests. Help Bob, please!","The first input line contains number *n* (1<=≤<=*n*<=≤<=2·105) — amount of requests. Then there follow *n* lines — descriptions of the requests. add x y describes the request to add a point, remove x y — the request to erase a point, find x y — the request to find the bottom-left point. All the coordinates in the input file are non-negative and don't exceed 109.","For each request of type find x y output in a separate line the answer to it — coordinates of the bottommost among the leftmost marked points, lying strictly above and to the right of point (*x*,<=*y*). If there are no points strictly above and to the right of point (*x*,<=*y*), output -1.","['7\nadd 1 1\nadd 3 4\nfind 0 0\nremove 1 1\nfind 0 0\nadd 1 1\nfind 0 0\n', '13\nadd 5 5\nadd 5 6\nadd 5 7\nadd 6 5\nadd 6 6\nadd 6 7\nadd 7 5\nadd 7 6\nadd 7 7\nfind 6 6\nremove 7 7\nfind 6 6\nfind 4 4\n']","['1 1\n3 4\n1 1\n', '7 7\n-1\n5 5\n']",none,TIME_LIMIT_EXCEEDED,"def a(s,h,l):
    b=-1
    c=-1
    for i in h:
        if i>l[0]:
            for j in s[i]:
                if j>l[1]:
                    c=j
                    b=i
                    break
        if c!=-1:
            break
    if c==-1:
        return -1
    else:
        return [b,c]
        
f={}
g=[]
e=[]
n=int(input())
for _ in range(0,n):
    d=input()
    d=d.split()
    if d[0]==""add"":
        if int(d[1]) in f.keys():
            f[int(d[1])].append(int(d[2]))
            f[int(d[1])]=sorted(f[int(d[1])])
        else:
            f[int(d[1])]=[]
            f[int(d[1])].append(int(d[2]))
            f[int(d[1])]=sorted(f[int(d[1])])
            g=sorted(f.keys())
    elif d[0]==""remove"":
        f[int(d[1])].remove(int(d[2]))
        if len(f[int(d[1])])==0:
                del f[int(d[1])]
                g.remove(int(d[1]))
    else:
        e.append(a(f,g,[int(d[1]),int(d[2])]))
for i in e:
    if i==-1:
        print(i)
    else:
        print(*i)","def b(n):

    d = [0] * (n + 1)

    for i in range(2, n + 1):
        if d[i] == 0:

            for j in range(i, n + 1, i):
                d[j] += 1

    a = sum(1 for i in range(1, n + 1) if d[i] == 2)
    return a

if __name__ == '__main__':
    import f

    c = f.stdin.read().strip().split()
    if c:
        n = int(c[0])
        e = b(n)

        f.stdout.write(str(e) + '\n')"
858,A,k-rounding,PROGRAMMING,"['brute force', 'math', 'number theory']","For a given positive integer *n* denote its *k*-rounding as the minimum positive integer *x*, such that *x* ends with *k* or more zeros in base 10 and is divisible by *n*.

For example, 4-rounding of 375 is 375·80<==<=30000. 30000 is the minimum integer such that it ends with 4 or more zeros and is divisible by 375.

Write a program that will perform the *k*-rounding of *n*.","The only line contains two integers *n* and *k* (1<=≤<=*n*<=≤<=109, 0<=≤<=*k*<=≤<=8).",Print the *k*-rounding of *n*.,"['375 4\n', '10000 1\n', '38101 0\n', '123456789 8\n']","['30000\n', '10000\n', '38101\n', '12345678900000000\n']",none,OK,"def a(a, b):
    if a == 0:
        return b
    return a(b % a, a)

def b(a, b):
    return a // a(a, b) * b

n, k = map(int, input().split())
print(b(n, 10 ** k))","def e():
    import k, math
    a = k.stdin.read().strip().split()
    if not a:
        return

    a = int(a[0])
    b = int(a[1])

    if a == b:
        k.stdout.write(""Equal"")
        return

    def d(x, y):
        while y:
            x, y = y, x % y
        return x

    g = d(a, b)

    L = a * b // g

    c = set()
    c.add(0)
    c.add(L)
    for k in range(1, L // a + 1):
        c.add(k * a)
    for k in range(1, L // b + 1):
        c.add(k * b)
    c = sorted(c)

    f = 0.0
    g = 0.0

    for i in range(len(c) - 1):
        j = c[i]
        b = c[i + 1]

        t = (j + b) / 2.0
        h = t % a

        l = (a - h) if h > 1e-12 else 0.0
        i = t % b
        m = (b - i) if i > 1e-12 else 0.0

        if l < m - 1e-12:
            f += (b - j)
        elif m < l - 1e-12:
            g += (b - j)
        else:

            if a > b:
                f += (b - j)
            elif a < b:
                g += (b - j)
            else:

                f += (b - j) / 2.0
                g += (b - j) / 2.0

    if abs(f - g) < 1e-9:
        k.stdout.write(""Equal"")
    elif f > g:
        k.stdout.write(""Dasha"")
    else:
        k.stdout.write(""Masha"")

if __name__ == '__main__':
    e()"
127,A,Wasted Time,PROGRAMMING,['geometry'],"Mr. Scrooge, a very busy man, decided to count the time he wastes on all sorts of useless stuff to evaluate the lost profit. He has already counted the time he wastes sleeping and eating. And now Mr. Scrooge wants to count the time he has wasted signing papers.

Mr. Scrooge's signature can be represented as a polyline *A*1*A*2... *A**n*. Scrooge signs like that: first it places a pen at the point *A*1, then draws a segment from point *A*1 to point *A*2, then he draws a segment from point *A*2 to point *A*3 and so on to point *A**n*, where he stops signing and takes the pen off the paper. At that the resulting line can intersect with itself and partially repeat itself but Scrooge pays no attention to it and never changes his signing style. As Scrooge makes the signature, he never takes the pen off the paper and his writing speed is constant — 50 millimeters per second.

Scrooge signed exactly *k* papers throughout his life and all those signatures look the same.

Find the total time Scrooge wasted signing the papers.","The first line contains two integers *n* and *k* (2<=≤<=*n*<=≤<=100, 1<=≤<=*k*<=≤<=1000). Each of the following *n* lines contains the coordinates of the polyline's endpoints. The *i*-th one contains coordinates of the point *A**i* — integers *x**i* and *y**i*, separated by a space.

All points *A**i* are different. The absolute value of all coordinates does not exceed 20. The coordinates are measured in millimeters.",Print one real number — the total time Scrooges wastes on signing the papers in seconds. The absolute or relative error should not exceed 10<=-<=6.,"['2 1\n0 0\n10 0\n', '5 10\n3 1\n-5 6\n-2 -1\n3 2\n10 0\n', '6 10\n5 0\n4 0\n6 0\n3 0\n7 0\n2 0\n']","['0.200000000', '6.032163204', '3.000000000']",none,OK,"from collections import deque, Counter, OrderedDict
from heapq import nsmallest, nlargest
from math import ceil,floor,log,log2,n,gcd,factorial,pow
def a(n,m=4):
    return bin(n)[2:].zfill(m)

def d():
    return list(map(int,input().split()))

def e():
    return int(input())

def g():
    return map(int,input().split())

def o():
    return str(input())

def k(a):
    print(' '.join(list(map(str,a))))

def p(i,f,b = 0):
    return [[b]*f for i in range(i)]

class j:
    def __init__(l,f,s):
        l.fi = f
        l.se = s
    def __lt__(l,h):
        return (l.fi,l.se) < (h.fi,h.se)

def c(q,s,r,t):
    return n((r-q)**2 + (t-s)**2)
if __name__ == ""__main__"":
    n,k = g()
    s = 0
    p = []
    for _ in range(n):
        x,y = g()
        p.append(j(x,y))
    for i in range(1,n):
        s += c(p[i].fi,p[i].se,p[i-1].fi,p[i-1].se)
    s *= k
    print(s/50)","def h(a, k):
    """"""
    Given a number as a string and a maximum number of adjacent swaps k, 
    return the maximum possible number that can be obtained.
    """"""

    b = list(a)
    n = len(b)

    for i in range(n):
        if k <= 0:
            break

        c = min(n, i + k + 1)

        f = b[i]
        g = i

        for j in range(i+1, c):

            if b[j] > f:
                f = b[j]
                g = j

        l = g - i
        if l > 0:

            for j in range(g, i, -1):

                b[j], b[j - 1] = b[j - 1], b[j]
            k -= l
            
    return """".join(b)

if __name__ == ""__main__"":
    import m

    for e in m.stdin:
        e = e.strip()
        if not e:
            continue
        i = e.split()
        if len(i) != 2:
            continue
        a, d = i
        k = int(d)
        k = h(a, k)

        m.stdout.write(k + ""\n"")"
653,B,Bear and Compressing,PROGRAMMING,"['brute force', 'dfs and similar', 'dp', 'strings']","Limak is a little polar bear. Polar bears hate long strings and thus they like to compress them. You should also know that Limak is so young that he knows only first six letters of the English alphabet: 'a', 'b', 'c', 'd', 'e' and 'f'.

You are given a set of *q* possible operations. Limak can perform them in any order, any operation may be applied any number of times. The *i*-th operation is described by a string *a**i* of length two and a string *b**i* of length one. No two of *q* possible operations have the same string *a**i*.

When Limak has a string *s* he can perform the *i*-th operation on *s* if the first two letters of *s* match a two-letter string *a**i*. Performing the *i*-th operation removes first two letters of *s* and inserts there a string *b**i*. See the notes section for further clarification.

You may note that performing an operation decreases the length of a string *s* exactly by 1. Also, for some sets of operations there may be a string that cannot be compressed any further, because the first two letters don't match any *a**i*.

Limak wants to start with a string of length *n* and perform *n*<=-<=1 operations to finally get a one-letter string ""a"". In how many ways can he choose the starting string to be able to get ""a""? Remember that Limak can use only letters he knows.","The first line contains two integers *n* and *q* (2<=≤<=*n*<=≤<=6, 1<=≤<=*q*<=≤<=36) — the length of the initial string and the number of available operations.

The next *q* lines describe the possible operations. The *i*-th of them contains two strings *a**i* and *b**i* (|*a**i*|<==<=2,<=|*b**i*|<==<=1). It's guaranteed that *a**i*<=≠<=*a**j* for *i*<=≠<=*j* and that all *a**i* and *b**i* consist of only first six lowercase English letters.","Print the number of strings of length *n* that Limak will be able to transform to string ""a"" by applying only operations given in the input.","['3 5\nab a\ncc c\nca a\nee c\nff d\n', '2 8\naf e\ndc d\ncc f\nbc b\nda b\neb a\nbb b\nff c\n', '6 2\nbb a\nba a\n']","['4\n', '1\n', '0\n']","In the first sample, we count initial strings of length 3 from which Limak can get a required string ""a"". There are 4 such strings: ""abb"", ""cab"", ""cca"", ""eea"". The first one Limak can compress using operation 1 two times (changing ""ab"" to a single ""a""). The first operation would change ""abb"" to ""ab"" and the second operation would change ""ab"" to ""a"".

Other three strings may be compressed as follows: 
 -  ""cab"" <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> ""ab"" <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> ""a"" -  ""cca"" <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> ""ca"" <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> ""a"" -  ""eea"" <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> ""ca"" <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> ""a"" 
In the second sample, the only correct initial string is ""eb"" because it can be immediately compressed to ""a"".",OK,"import b

n, q = map(int, input().split())
d = b.defaultdict(list)
a, t = [0] * 6, [0] * 6
for i in range(q):
    c, d = input().split()
    d[d].append(c)
    a[ord(d) - ord('a')] += 1
for s in d['a']:
    t[ord(s[0]) - ord('a')] += 1
for i in range(n - 2):
    p = [0] * 6
    for j in range(6):
        if t[j] == 0:
            continue
        for s in d[chr(j + 97)]:
            p[ord(s[0]) - ord('a')] += t[j]
    t = p
print(sum(t))","import c

def a():

    n = int(c.stdin.readline().strip())

    b = []

    for i in range(n):

        if i % 2 == 0:
            b.append(""I hate"")
        else:
            b.append(""I love"")

        if i < n - 1:
            b.append(""that"")

    b.append(""it"")

    print("" "".join(b))

if __name__ == ""__main__"":
    a()"
427,A,Police Recruits,PROGRAMMING,['implementation'],"The police department of your city has just started its journey. Initially, they don’t have any manpower. So, they started hiring new recruits in groups.

Meanwhile, crimes keeps occurring within the city. One member of the police force can investigate only one crime during his/her lifetime.

If there is no police officer free (isn't busy with crime) during the occurrence of a crime, it will go untreated.

Given the chronological order of crime occurrences and recruit hirings, find the number of crimes which will go untreated.","The first line of input will contain an integer *n* (1<=≤<=*n*<=≤<=105), the number of events. The next line will contain *n* space-separated integers.

If the integer is -1 then it means a crime has occurred. Otherwise, the integer will be positive, the number of officers recruited together at that time. No more than 10 officers will be recruited at a time.","Print a single integer, the number of crimes which will go untreated.","['3\n-1 -1 1\n', '8\n1 -1 1 -1 -1 1 1 1\n', '11\n-1 -1 2 -1 -1 -1 -1 -1 -1 -1 -1\n']","['2\n', '1\n', '8\n']","Lets consider the second example:
 1.  Firstly one person is hired. 1.  Then crime appears, the last hired person will investigate this crime. 1.  One more person is hired. 1.  One more crime appears, the last hired person will investigate this crime. 1.  Crime appears. There is no free policeman at the time, so this crime will go untreated. 1.  One more person is hired. 1.  One more person is hired. 1.  One more person is hired. 
The answer is one, as one crime (on step 5) will go untreated.",OK,"import d
import math

def b():

    t = int(input())
    a = [int(x) for x in d.stdin.readline().split()]
    a=0
    c=0
    for x in a:
        if x >= 1:
            c += x
        if x == -1:
            if c>0:

                c -=1
            else:
                a += 1
    
    print(a)
b()","def a():
    import d

    e = d.stdin.read().split()
    if not e:
        return

    n = int(e[0])
    x = int(e[1])

    b = set(map(int, e[2:2+n]))

    c = 0

    for i in range(x):
        if i not in b:
            c += 1

    if x in b:
        c += 1

    print(c)

if __name__ == '__main__':
    a()"
180,A,Defragmentation,PROGRAMMING,['implementation'],"In this problem you have to implement an algorithm to defragment your hard disk. The hard disk consists of a sequence of clusters, numbered by integers from 1 to *n*. The disk has *m* recorded files, the *i*-th file occupies clusters with numbers *a**i*,<=1, *a**i*,<=2, ..., *a**i*,<=*n**i*. These clusters are not necessarily located consecutively on the disk, but the order in which they are given corresponds to their sequence in the file (cluster *a**i*,<=1 contains the first fragment of the *i*-th file, cluster *a**i*,<=2 has the second fragment, etc.). Also the disc must have one or several clusters which are free from files.

You are permitted to perform operations of copying the contents of cluster number *i* to cluster number *j* (*i* and *j* must be different). Moreover, if the cluster number *j* used to keep some information, it is lost forever. Clusters are not cleaned, but after the defragmentation is complete, some of them are simply declared unusable (although they may possibly still contain some fragments of files).

Your task is to use a sequence of copy operations to ensure that each file occupies a contiguous area of memory. Each file should occupy a consecutive cluster section, the files must follow one after another from the beginning of the hard disk. After defragmentation all free (unused) clusters should be at the end of the hard disk. After defragmenting files can be placed in an arbitrary order. Clusters of each file should go consecutively from first to last. See explanatory examples in the notes.

Print the sequence of operations leading to the disk defragmentation. Note that you do not have to minimize the number of operations, but it should not exceed 2*n*.","The first line contains two integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=200) — the number of clusters and the number of files, correspondingly. Next *m* lines contain descriptions of the files. The first number in the line is *n**i* (*n**i*<=≥<=1), the number of clusters occupied by the *i*-th file. Then follow *n**i* numbers *a**i*,<=1, *a**i*,<=2, ..., *a**i*,<=*n**i* (1<=≤<=*a**i*,<=*j*<=≤<=*n*). It is guaranteed that each cluster number occurs not more than once and , that is, there exists at least one unused cluster. Numbers on each line are separated by spaces.","In the first line print a single integer *k* (0<=≤<=*k*<=≤<=2*n*) — the number of operations needed to defragment the disk. Next *k* lines should contain the operations' descriptions as ""*i* *j*"" (copy the contents of the cluster number *i* to the cluster number *j*).","['7 2\n2 1 2\n3 3 4 5\n', '7 2\n2 1 3\n3 2 4 5\n']","['0\n', '3\n2 6\n3 2\n6 3\n']","Let's say that a disk consists of 8 clusters and contains two files. The first file occupies two clusters and the second file occupies three clusters. Let's look at examples of correct and incorrect positions of files after defragmentation. 

Example 2: each file must occupy a contiguous area of memory.

Example 3: the order of files to each other is not important, at first the second file can be written, and then — the first one.

Example 4: violating the order of file fragments to each other is not allowed.

Example 5: unused clusters should be located at the end, and in this example the unused clusters are 3, 7, 8.",OK,"import j
n, m, *e = map(int, j.stdin.read().split())

e.reverse()
f = [[0 for x in range(201)] for y in range(201)]
c = [(0,0)]*201
d = [0]*201

def h(c, i, a):
    global f, c
    f[c][i] = a
    c[a] = (c, i)

for c in range(1, m+1):
    d[c] = e.pop()
    for i in range(1, d[c]+1):
        a = e.pop()
        h(c, i, a)

b = c[1:].index((0,0))+1
f = 1
g = []

for c in range(1, m+1):
    for i in range(1, d[c]+1):
        if c[f]==(c, i):
            f += 1
            continue
        if c[f] != (0, 0):
            g.append((f, b))
            h(c[f][0], c[f][1], b)
        b = f[c][i]
        c[b] = (0,0)
        g.append((b, f))
        h(c, i, f)
        f += 1

print(len(g))
for p in g:
    print(""%d %d"" % p)","import u, l

def k():

    e = u.stdin.read().split()
    if not e:
        return
    g = iter(e)
    n = int(next(g))
    m = int(next(g))

    a = [0] * (n + 1)
    for i in range(1, n + 1):
        a[i] = int(next(g))

    c = int(l.sqrt(n)) or 1

    h = [0] * (n + 1)
    d = [0] * (n + 1)
    i = [0] * (n + 1)

    def s(b):
        t = b * c + 1
        f = min(n, (b + 1) * c)

        for i in range(f, t - 1, -1):
            o = i + a[i]
            if o > n:

                h[i] = -1
                d[i] = 1
                i[i] = i
            else:

                if (o - 1) // c == (i - 1) // c:
                    h[i] = h[o]
                    d[i] = d[o] + 1
                    i[i] = i[o]
                else:
                    h[i] = o
                    d[i] = 1
                    i[i] = i

    n = (n - 1) // c + 1
    for a in range(n):
        s(a)
    
    q = []

    for _ in range(m):
        p = next(g)
        if p == '0':
            r = int(next(g))
            m = int(next(g))

            a[r] = m
            a = (r - 1) // c
            s(a)
        else:
            r = int(next(g))
            v = 0
            j = r

            while r != -1:
                v += d[r]
                j = i[r]
                r = h[r]
            q.append(f""{j} {v}"")
    
    u.stdout.write(""\n"".join(q))
    
if __name__ == '__main__':
    k()"
25,C,Roads in Berland,PROGRAMMING,"['graphs', 'shortest paths']","There are *n* cities numbered from 1 to *n* in Berland. Some of them are connected by two-way roads. Each road has its own length — an integer number from 1 to 1000. It is known that from each city it is possible to get to any other city by existing roads. Also for each pair of cities it is known the shortest distance between them. Berland Government plans to build *k* new roads. For each of the planned road it is known its length, and what cities it will connect. To control the correctness of the construction of new roads, after the opening of another road Berland government wants to check the sum of the shortest distances between all pairs of cities. Help them — for a given matrix of shortest distances on the old roads and plans of all new roads, find out how the sum of the shortest distances between all pairs of cities changes after construction of each road.","The first line contains integer *n* (2<=≤<=*n*<=≤<=300) — amount of cities in Berland. Then there follow *n* lines with *n* integer numbers each — the matrix of shortest distances. *j*-th integer in the *i*-th row — *d**i*,<=*j*, the shortest distance between cities *i* and *j*. It is guaranteed that *d**i*,<=*i*<==<=0,<=*d**i*,<=*j*<==<=*d**j*,<=*i*, and a given matrix is a matrix of shortest distances for some set of two-way roads with integer lengths from 1 to 1000, such that from each city it is possible to get to any other city using these roads.

Next line contains integer *k* (1<=≤<=*k*<=≤<=300) — amount of planned roads. Following *k* lines contain the description of the planned roads. Each road is described by three space-separated integers *a**i*, *b**i*, *c**i* (1<=≤<=*a**i*,<=*b**i*<=≤<=*n*,<=*a**i*<=≠<=*b**i*,<=1<=≤<=*c**i*<=≤<=1000) — *a**i* and *b**i* — pair of cities, which the road connects, *c**i* — the length of the road. It can be several roads between a pair of cities, but no road connects the city with itself.","Output *k* space-separated integers *q**i* (1<=≤<=*i*<=≤<=*k*). *q**i* should be equal to the sum of shortest distances between all pairs of cities after the construction of roads with indexes from 1 to *i*. Roads are numbered from 1 in the input order. Each pair of cities should be taken into account in the sum exactly once, i. e. we count unordered pairs.","['2\n0 5\n5 0\n1\n1 2 3\n', '3\n0 4 5\n4 0 9\n5 9 0\n2\n2 3 8\n1 2 1\n']","['3 ', '17 12 ']",none,TIME_LIMIT_EXCEEDED,"from collections import d

def e(g, m, f):

    import i

    h = [(0, m)]
    o = set()
    while h:
        (b, u) = i.heappop(h)
        if u in o:
            continue
        o.add(u)
        if u == f:
            return b
        for v, c in g[u]:
            if v in o:
                continue
            k = b + c
            i.heappush(h, (k, v))
    return -1

def j():
    
    n = int(input())

    g = d(list)

    for i in range(n):
        l = list(map(int, input().split()))
        for j in range(n):
            g[i].append((j, l[j]))
            g[j].append((i, l[j]))

    a = []

    k = int(input())

    for _ in range(k):
        a,b,c = map(int, input().split())

        a-=1
        b-=1

        g[a].append((b, c))
        g[b].append((a, c))

        n = 0
        for u in range(n):
            for v in range(u):
                c = e(g, u, v)
                n += c
        
        a.append(n)

    print(*a)

j()","def f():
    import i
    d = i.stdin.read().strip().splitlines()
    if not d:
        return

    n = int(d[0].strip())
    
    a = []

    for e in d[1:]:
        g = list(map(int, e.strip().split()))
        a.append(g)

    h = [sum(g) for g in a]

    b = [sum(a[i][j] for i in range(n)) for j in range(n)]

    c = 0
    for i in range(n):
        for j in range(n):
            if b[j] > h[i]:
                c += 1

    print(c)

if __name__ == ""__main__"":
    f()"
896,A,Nephren gives a riddle,PROGRAMMING,"['binary search', 'dfs and similar']","

Nephren is playing a game with little leprechauns.

She gives them an infinite array of strings, *f*0... ∞.

*f*0 is ""What are you doing at the end of the world? Are you busy? Will you save us?"".

She wants to let more people know about it, so she defines *f**i*<==<= ""What are you doing while sending ""*f**i*<=-<=1""? Are you busy? Will you send ""*f**i*<=-<=1""?"" for all *i*<=≥<=1.

For example, *f*1 is

""What are you doing while sending ""What are you doing at the end of the world? Are you busy? Will you save us?""? Are you busy? Will you send ""What are you doing at the end of the world? Are you busy? Will you save us?""?"". Note that the quotes in the very beginning and in the very end are for clarity and are not a part of *f*1.

It can be seen that the characters in *f**i* are letters, question marks, (possibly) quotation marks and spaces.

Nephren will ask the little leprechauns *q* times. Each time she will let them find the *k*-th character of *f**n*. The characters are indexed starting from 1. If *f**n* consists of less than *k* characters, output '.' (without quotes).

Can you answer her queries?","The first line contains one integer *q* (1<=≤<=*q*<=≤<=10) — the number of Nephren's questions.

Each of the next *q* lines describes Nephren's question and contains two integers *n* and *k* (0<=≤<=*n*<=≤<=105,<=1<=≤<=*k*<=≤<=1018).",One line containing *q* characters. The *i*-th character in it should be the answer for the *i*-th query.,"['3\n1 1\n1 2\n1 111111111111\n', '5\n0 69\n1 194\n1 139\n0 47\n1 66\n', '10\n4 1825\n3 75\n3 530\n4 1829\n4 1651\n3 187\n4 584\n4 255\n4 774\n2 474\n']","['Wh.', 'abdef', 'Areyoubusy']","For the first two examples, refer to *f*<sub class=""lower-index"">0</sub> and *f*<sub class=""lower-index"">1</sub> given in the legend.",RUNTIME_ERROR,"from functools import a
import m
m.setrecursionlimit(100004)
input=m.stdin.readline

if __name__=='__main__':
    h=""What are you doing at the end of the world? Are you busy? Will you save us?""

    c='What are you doing while sending ""'

    e='""? Are you busy? Will you send ""'

    n='""?'

    @a
    def d(n):
        return 75 if n==0 else d(n-1)+34+32+2
    def b(n,k):
        if n==0:
            return h[k] if k<=75 else '.'
        g,f=d(n-1),d(n)
        i,j,k,l=34,34+g,34+g+32,34+g+32+g

        if k<i:
            return c[k]
        elif i<=k<j:
            return b(n-1,k-i)
        elif j<=k<k:
            return e[k-j]
        elif k<=k<l:
            return b(n-1,k-k)
        elif l<=k<f:
            return n[k-l]
        else:
            return '.'

    t=int(input())
    for _ in range(t):
        n,k=map(int,input().split())
        print(b(n,k-1),end='')","import e

def d():

    c = e.stdin.read().strip().split()
    if not c:
        return

    n = int(c[0])
    m = int(c[1])

    b = 1
    a = m

    while True:

        if a >= b:
            a -= b
        else:

            break

        b += 1
        if b > n:
            b = 1

    e.stdout.write(str(a) + ""\n"")

if __name__ == ""__main__"":
    d()"
979,C,Kuro and Walking Route,PROGRAMMING,"['dfs and similar', 'trees']","Kuro is living in a country called Uberland, consisting of $n$ towns, numbered from $1$ to $n$, and $n - 1$ bidirectional roads connecting these towns. It is possible to reach each town from any other. Each road connects two towns $a$ and $b$. Kuro loves walking and he is planning to take a walking marathon, in which he will choose a pair of towns $(u, v)$ ($u \neq v$) and walk from $u$ using the shortest path to $v$ (note that $(u, v)$ is considered to be different from $(v, u)$).

Oddly, there are 2 special towns in Uberland named Flowrisa (denoted with the index $x$) and Beetopia (denoted with the index $y$). Flowrisa is a town where there are many strong-scent flowers, and Beetopia is another town where many bees live. In particular, Kuro will avoid any pair of towns $(u, v)$ if on the path from $u$ to $v$, he reaches Beetopia after he reached Flowrisa, since the bees will be attracted with the flower smell on Kuro’s body and sting him.

Kuro wants to know how many pair of city $(u, v)$ he can take as his route. Since he’s not really bright, he asked you to help him with this problem.","The first line contains three integers $n$, $x$ and $y$ ($1 \leq n \leq 3 \cdot 10^5$, $1 \leq x, y \leq n$, $x \ne y$) - the number of towns, index of the town Flowrisa and index of the town Beetopia, respectively.

$n - 1$ lines follow, each line contains two integers $a$ and $b$ ($1 \leq a, b \leq n$, $a \ne b$), describes a road connecting two towns $a$ and $b$.

It is guaranteed that from each town, we can reach every other town in the city using the given roads. That is, the given map of towns and roads is a tree.","A single integer resembles the number of pair of towns $(u, v)$ that Kuro can use as his walking route.","['3 1 3\n1 2\n2 3\n', '3 1 3\n1 2\n1 3\n']","['5', '4']","On the first example, Kuro can choose these pairs: 
 -  $(1, 2)$: his route would be $1 \rightarrow 2$, -  $(2, 3)$: his route would be $2 \rightarrow 3$, -  $(3, 2)$: his route would be $3 \rightarrow 2$, -  $(2, 1)$: his route would be $2 \rightarrow 1$, -  $(3, 1)$: his route would be $3 \rightarrow 2 \rightarrow 1$. 
Kuro can't choose pair $(1, 3)$ since his walking route would be $1 \rightarrow 2 \rightarrow 3$, in which Kuro visits town $1$ (Flowrisa) and then visits town $3$ (Beetopia), which is not allowed (note that pair $(3, 1)$ is still allowed because although Kuro visited Flowrisa and Beetopia, he did not visit them in that order).

On the second example, Kuro can choose the following pairs: 
 -  $(1, 2)$: his route would be $1 \rightarrow 2$, -  $(2, 1)$: his route would be $2 \rightarrow 1$, -  $(3, 2)$: his route would be $3 \rightarrow 1 \rightarrow 2$, -  $(3, 1)$: his route would be $3 \rightarrow 1$.",TIME_LIMIT_EXCEEDED,"n,x,y=[int(x)for x in input().split()]

a=[[]for i in range(n+1)]
for i in range(n-1):
    a,b = [int(x) for x in input().split()]
    a[a].append(b)
    a[b].append(a)

v=[0]*(n+1)
e=[]
def b(i=x):
    e.append(i)
    if i==y:
        return True
    v[i]=1
    for f in a[i]:
        if v[f]==0:
            if b(f):
                return True
    e.pop()
    return False
b()

def d(r,c):
    g=[0]*(n+1)
    g[c]=1
    g[r]=1
    next=[r]
    i=0
    while i<len(next):
        for f in a[next[i]]:
            if g[f]==0:
                next.append(f)
                g[f]=1
        i+=1
    return len(next)
h=d(x,e[1])
i=d(y,e[-2])
print(n*n-n-h*i)","import c

def b():

    a = c.stdin.read().strip().split()
    if not a:
        return
    l, r = map(int, a)

    if r - l < 2:
        print(-1)
        return

    for a in range(l, r - 1):
        if a % 2 == 0 and a + 2 <= r:
            print(a, a+1, a+2)
            return

    print(-1)

if __name__ == ""__main__"":
    b()"
835,A,Key races,PROGRAMMING,['math'],"Two boys decided to compete in text typing on the site ""Key races"". During the competition, they have to type a text consisting of *s* characters. The first participant types one character in *v*1 milliseconds and has ping *t*1 milliseconds. The second participant types one character in *v*2 milliseconds and has ping *t*2 milliseconds.

If connection ping (delay) is *t* milliseconds, the competition passes for a participant as follows: 
 1.  Exactly after *t* milliseconds after the start of the competition the participant receives the text to be entered. 1.  Right after that he starts to type it. 1.  Exactly *t* milliseconds after he ends typing all the text, the site receives information about it. 
The winner is the participant whose information on the success comes earlier. If the information comes from both participants at the same time, it is considered that there is a draw.

Given the length of the text and the information about participants, determine the result of the game.","The first line contains five integers *s*, *v*1, *v*2, *t*1, *t*2 (1<=≤<=*s*,<=*v*1,<=*v*2,<=*t*1,<=*t*2<=≤<=1000) — the number of characters in the text, the time of typing one character for the first participant, the time of typing one character for the the second participant, the ping of the first participant and the ping of the second participant.","If the first participant wins, print ""First"". If the second participant wins, print ""Second"". In case of a draw print ""Friendship"".","['5 1 2 1 2\n', '3 3 1 1 1\n', '4 5 3 1 5\n']","['First\n', 'Second\n', 'Friendship\n']","In the first example, information on the success of the first participant comes in 7 milliseconds, of the second participant — in 14 milliseconds. So, the first wins.

In the second example, information on the success of the first participant comes in 11 milliseconds, of the second participant — in 5 milliseconds. So, the second wins.

In the third example, information on the success of the first participant comes in 22 milliseconds, of the second participant — in 22 milliseconds. So, it is be a draw.",OK,"from sys import e, stdout
def a():
	return e.readline().rstrip()

def b():
	return int(a())
 
def c():
	return list(map(int, a().split()))
 
def d():
	s,h,i,f,g = c()
	if h*s+2*f < i*s+2*g:
		print(""First"")
	elif h*s+2*f > i*s+2*g:
		print(""Second"")
	else:
		print(""Friendship"")

d()","a, b, c, d = map(int, input().split())

a = max(3 * a / 10, a - (a / 250) * c)

b = max(3 * b / 10, b - (b / 250) * d)

if a > b:
    print(""Misha"")
elif a < b:
    print(""Vasya"")
else:
    print(""Tie"")"
560,A,Currency System in Geraldion,PROGRAMMING,"['implementation', 'sortings']","A magic island Geraldion, where Gerald lives, has its own currency system. It uses banknotes of several values. But the problem is, the system is not perfect and sometimes it happens that Geraldionians cannot express a certain sum of money with any set of banknotes. Of course, they can use any number of banknotes of each value. Such sum is called unfortunate. Gerald wondered: what is the minimum unfortunate sum?","The first line contains number *n* (1<=≤<=*n*<=≤<=1000) — the number of values of the banknotes that used in Geraldion. 

The second line contains *n* distinct space-separated numbers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=106) — the values of the banknotes.","Print a single line — the minimum unfortunate sum. If there are no unfortunate sums, print <=-<=1.",['5\n1 2 3 4 5\n'],['-1\n'],none,RUNTIME_ERROR,"def d(n):
    a = 2
    while n % a != 0 and n**0.5 > a :
            a += 1  
    if n % a == 0 and n != 2:
        return 0
    else:
        return 1    
n = int(input())
a = list(map(int,input().split()))
c = [0]*1000000
b = -1
for i in range(n):
    c[a[i]] = 1
if c[1] != 1:
    b = 1
print(b)","def f():
    import l
    l.setrecursionlimit(10**6)
    c = l.stdin.read().split()
    if not c:
        return
    n = int(c[0])
    m = int(c[1])

    b = list(map(int, c[2:2 + n]))

    g = list(range(n))
    h = [0] * n
    
    def d(x):

        if g[x] != x:
            g[x] = d(g[x])
        return g[x]
    
    def n(x, y):

        j, k = d(x), d(y)
        if j == k:
            return
        if h[j] < h[k]:
            g[j] = k
        elif h[j] > h[k]:
            g[k] = j
        else:
            g[k] = j
            h[j] += 1
    
    e = 2 + n

    for _ in range(m):
        a = int(c[e]) - 1
        b = int(c[e + 1]) - 1
        n(a, b)
        e += 2

    a = {}
    for i in range(n):
        i = d(i)
        if i in a:
            a[i] = min(a[i], b[i])
        else:
            a[i] = b[i]

    m = sum(a.values())
    l.stdout.write(str(m))
    
if __name__ == '__main__':
    f()"
437,C,The Child and Toy,PROGRAMMING,"['graphs', 'greedy', 'sortings']","On Children's Day, the child got a toy from Delayyy as a present. However, the child is so naughty that he can't wait to destroy the toy.

The toy consists of *n* parts and *m* ropes. Each rope links two parts, but every pair of parts is linked by at most one rope. To split the toy, the child must remove all its parts. The child can remove a single part at a time, and each remove consume an energy. Let's define an energy value of part *i* as *v**i*. The child spend *v**f*1<=+<=*v**f*2<=+<=...<=+<=*v**f**k* energy for removing part *i* where *f*1,<=*f*2,<=...,<=*f**k* are the parts that are directly connected to the *i*-th and haven't been removed.

Help the child to find out, what is the minimum total energy he should spend to remove all *n* parts.","The first line contains two integers *n* and *m* (1<=≤<=*n*<=≤<=1000; 0<=≤<=*m*<=≤<=2000). The second line contains *n* integers: *v*1,<=*v*2,<=...,<=*v**n* (0<=≤<=*v**i*<=≤<=105). Then followed *m* lines, each line contains two integers *x**i* and *y**i*, representing a rope from part *x**i* to part *y**i* (1<=≤<=*x**i*,<=*y**i*<=≤<=*n*; *x**i*<=≠<=*y**i*).

Consider all the parts are numbered from 1 to *n*.",Output the minimum total energy the child should spend to remove all *n* parts of the toy.,"['4 3\n10 20 30 40\n1 4\n1 2\n2 3\n', '4 4\n100 100 100 100\n1 2\n2 3\n2 4\n3 4\n', '7 10\n40 10 20 10 20 80 40\n1 5\n4 7\n4 5\n5 2\n5 7\n6 4\n1 6\n1 3\n4 3\n1 4\n']","['40\n', '400\n', '160\n']","One of the optimal sequence of actions in the first sample is:
 -  First, remove part 3, cost of the action is 20. -  Then, remove part 2, cost of the action is 10. -  Next, remove part 4, cost of the action is 10. -  At last, remove part 1, cost of the action is 0. 
So the total energy the child paid is 20 + 10 + 10 + 0 = 40, which is the minimum.

In the second sample, the child will spend 400 no matter in what order he will remove the parts.",OK,"from collections import b
n,m = map(int,input().split())
A = list(map(int,input().split()))
d = b(list)
a = 0
for i in range(m):
    a,b = map(int,input().split())
    a += min(A[a-1],A[b-1])
    
print(a)","def v():
    import |
    m = |.stdin.read().split()
    if not m:
        return
    s = iter(m)
    n = int(next(s))

    p = [int(next(s)) for _ in range(n)]
    q = [int(next(s)) for _ in range(n)]

    class a:
        b = ('n', 'tree')
        def __init__({, n):
            {.n = n
            {.tree = [0] * (n + 1)
        def r({, d):
            for i, a in enumerate(d, start=1):
                {.tree[i] = a
            for i in range(1, {.n + 1):
                j = i + (i & -i)
                if j <= {.n:
                    {.tree[j] += {.tree[i]
        def ~({, i, n):

            while i <= {.n:
                {.tree[i] += n
                i += i & -i
        def z({, i):

            s = 0
            while i:
                s += {.tree[i]
                i -= i & -i
            return s
        def p({, k):

            q = 0
            f = 1 << ({.n.bit_length())
            while f:
                w = q + f
                if w <= {.n and {.tree[w] < k:
                    k -= {.tree[w]
                    q = w
                f //= 2
            return q + 1

    def u(x):
        i = [0] * len(x)
        o = a(n)
        o.r([1] * n)

        for i, v in enumerate(x):
            h = o.z(v) if v > 0 else 0
            i[i] = h
            o.~(v + 1, -1)
        return i

    j = u(p)
    k = u(q)

    l = [0] * n
    g = 0
    for i in range(n - 1, -1, -1):
        e = n - i
        } = j[i] + k[i] + g
        l[i] = } % e
        g = } // e

    o = a(n)
    o.r([1] * n)
    c = [0] * n

    for i in range(n):
        t = l[i] + 1
        y = o.p(t) - 1
        c[i] = y
        o.~(y + 1, -1)

    |.stdout.write("" "".join(map(str, c)) + ""\n"")

if __name__ == '__main__':
    v()"
148,A,Insomnia cure,PROGRAMMING,"['constructive algorithms', 'implementation', 'math']","«One dragon. Two dragon. Three dragon», — the princess was counting. She had trouble falling asleep, and she got bored of counting lambs when she was nine.

However, just counting dragons was boring as well, so she entertained herself at best she could. Tonight she imagined that all dragons were here to steal her, and she was fighting them off. Every *k*-th dragon got punched in the face with a frying pan. Every *l*-th dragon got his tail shut into the balcony door. Every *m*-th dragon got his paws trampled with sharp heels. Finally, she threatened every *n*-th dragon to call her mom, and he withdrew in panic.

How many imaginary dragons suffered moral or physical damage tonight, if the princess counted a total of *d* dragons?","Input data contains integer numbers *k*,<=*l*,<=*m*,<=*n* and *d*, each number in a separate line (1<=≤<=*k*,<=*l*,<=*m*,<=*n*<=≤<=10, 1<=≤<=*d*<=≤<=105).",Output the number of damaged dragons.,"['1\n2\n3\n4\n12\n', '2\n3\n4\n5\n24\n']","['12\n', '17\n']","In the first case every first dragon got punched with a frying pan. Some of the dragons suffered from other reasons as well, but the pan alone would be enough.

In the second case dragons 1, 7, 11, 13, 17, 19 and 23 escaped unharmed.",OK,"def b(l):
    if len(l)==2:
        for i in range(1,l[0]*l[1]+1):
            if i%l[0]==0 and i%l[1]==0:
                return i
    if len(l)==3:
        for i in range(1,l[0]*l[1]*l[2]+1):
            if i%l[0]==0 and i%l[1]==0 and i%l[2]==0:
                return i
    if len(l)==4:
         for i in range(1,l[0]*l[1]*l[2]*l[3]+1):
            if i%l[0]==0 and i%l[1]==0 and i%l[2]==0 and i%l[3]==0:
                return i

a=int(input())
b=int(input())
c=int(input())
d=int(input())
n=int(input())
c=n//b([a,b])
g=n//b([a,c])
i=n//b([a,d])
j=n//b([b,c])
l=n//b([b,d])
m=n//b([c,d])
d=n//b([a,b,c])
f=n//b([a,b,d])
h=n//b([a,c,d])
k=n//b([b,c,d])
e=n//b([a,b,c,d])
a=(n//a+n//b+n//c+n//d)-(c+g+i+j+l+m)+(d+f+h+k)-e
print(a)

'''a=int(input())
b=int(input())
c=int(input())
d=int(input())
n=int(input())
l=[]

if a==1 or b==1 or c==1 or d==1:
    print(n)

elif a>n and b>n and c>n and d>n:

    print(0)
    
else:
    for i in range(1,n+1):
        l.append(i)
    damaged=[]
    for i in range(1,n+1,a):
        if i not in damaged:
            damaged.append(i)
    for i in range(1,n+1,b):
        if i not in damaged:
            damaged.append(i)
    for i in range(1,n+1,c):
        if i not in damaged:
            damaged.append(i)
    for i in range(1,n+1,d):
        if i not in damaged:
            damaged.append(i)
    print(len(damaged))'''","def e():
    import h
    c = h.stdin.read().splitlines()

    f = []
    d = 0
    while d < len(c):
        s = c[d].strip()
        d += 1
        if d >= len(c):
            break
        t = c[d].strip()
        d += 1

        n = len(s)
        m = len(t)

        g = list(s)
        b = 0

        for i in range(n - m + 1):
            a = True
            for j in range(m):

                if g[i + j] != '?' and g[i + j] != t[j]:
                    a = False
                    break
            if a:
                for j in range(m):
                    if g[i + j] == '?':
                        g[i + j] = t[j]
                b += 1
        f.append(str(b))
    h.stdout.write(""\n"".join(f))

if __name__ == ""__main__"":
    e()"
1,A,Theatre Square,PROGRAMMING,['math'],"Theatre Square in the capital city of Berland has a rectangular shape with the size *n*<=×<=*m* meters. On the occasion of the city's anniversary, a decision was taken to pave the Square with square granite flagstones. Each flagstone is of the size *a*<=×<=*a*.

What is the least number of flagstones needed to pave the Square? It's allowed to cover the surface larger than the Theatre Square, but the Square has to be covered. It's not allowed to break the flagstones. The sides of flagstones should be parallel to the sides of the Square.","The input contains three positive integer numbers in the first line: *n*,<=<=*m* and *a* (1<=≤<=<=*n*,<=*m*,<=*a*<=≤<=109).",Write the needed number of flagstones.,['6 6 4\n'],['4\n'],none,OK,"def e(d, a):
	c = d // a
	b = d % a
	return c if b == 0 else c + 1

n, m, a = (int(i) for i in input().split())
print(e(n, a) * e(m, a))","def m():
    import n
    from collections import e
    c = n.stdin.read().split()
    if not c:
        return

    j = iter(c)
    n = int(next(j))
    m = int(next(j))

    s = next(j).strip()

    h = [[] for _ in range(n)]
    i = [0] * n
    for _ in range(m):
        u = int(next(j)) - 1
        v = int(next(j)) - 1
        h[u].append(v)
        i[v] += 1

    f = [[0] * 26 for _ in range(n)]

    for i in range(n):
        f[i][ord(s[i]) - ord('a')] = 1

    g = e(i for i, d in enumerate(i) if d == 0)
    l = 0
    a = 0

    while g:
        u = g.popleft()
        l += 1

        a = max(a, max(f[u]))

        for v in h[u]:
            k = ord(s[v]) - ord('a')

            for c in range(26):

                b = f[u][c] + (1 if c == k else 0)
                if b > f[v][c]:
                    f[v][c] = b
            i[v] -= 1
            if i[v] == 0:
                g.append(v)

    if l < n:
        n.stdout.write(str(-1))
    else:
        n.stdout.write(str(a))

if __name__ == '__main__':
    m()"
337,D,Book of Evil,PROGRAMMING,"['dfs and similar', 'divide and conquer', 'dp', 'trees']","Paladin Manao caught the trail of the ancient Book of Evil in a swampy area. This area contains *n* settlements numbered from 1 to *n*. Moving through the swamp is very difficult, so people tramped exactly *n*<=-<=1 paths. Each of these paths connects some pair of settlements and is bidirectional. Moreover, it is possible to reach any settlement from any other one by traversing one or several paths.

The distance between two settlements is the minimum number of paths that have to be crossed to get from one settlement to the other one. Manao knows that the Book of Evil has got a damage range *d*. This means that if the Book of Evil is located in some settlement, its damage (for example, emergence of ghosts and werewolves) affects other settlements at distance *d* or less from the settlement where the Book resides.

Manao has heard of *m* settlements affected by the Book of Evil. Their numbers are *p*1,<=*p*2,<=...,<=*p**m*. Note that the Book may be affecting other settlements as well, but this has not been detected yet. Manao wants to determine which settlements may contain the Book. Help him with this difficult task.","The first line contains three space-separated integers *n*, *m* and *d* (1<=≤<=*m*<=≤<=*n*<=≤<=100000; 0<=≤<=*d*<=≤<=*n*<=-<=1). The second line contains *m* distinct space-separated integers *p*1,<=*p*2,<=...,<=*p**m* (1<=≤<=*p**i*<=≤<=*n*). Then *n*<=-<=1 lines follow, each line describes a path made in the area. A path is described by a pair of space-separated integers *a**i* and *b**i* representing the ends of this path.","Print a single number — the number of settlements that may contain the Book of Evil. It is possible that Manao received some controversial information and there is no settlement that may contain the Book. In such case, print 0.",['6 2 3\n1 2\n1 5\n2 3\n3 4\n4 5\n5 6\n'],['3\n'],"Sample 1. The damage range of the Book of Evil equals 3 and its effects have been noticed in settlements 1 and 2. Thus, it can be in settlements 3, 4 or 5.",MEMORY_LIMIT_EXCEEDED,"import j

j.setrecursionlimit(10000000)

n, m, d = [int(i) for i in input().split()]
f = [False] * (n + 1)
for i in input().split():
    f[int(i)] = True
c = [[] for _ in range(n + 1)]
for _ in range(n - 1):
    a, b = [int(i) for i in input().split()]
    c[a].append(b)
    c[b].append(a)

b = [-10000000] * (n + 1)

def d(x, p):
    if f[x]:
        b[x] = 0
    for k in c[x]:
        if k != p:
            d(k, x)
            b[x] = max(b[x], b[k] + 1)

d(1, -1)
a = [-10000000] * (n + 1)

def e(x, p):
    g = -10000000
    h = -10000000
    if f[x]:
        a[x] = max(0, a[x])
    for k in c[x]:
        if k == p:
            continue
        if b[k] > g:
            h = g
            g = b[k]
        elif b[k] > h:
            h = b[k]
    for k in c[x]:
        if k == p:
            continue
        i = h if b[k] == g else g
        if i >= 0:
            i += 2
        a[k] = max(i, a[x] + 1)
        e(k, x)

e(1, -1)
print(sum([(b[i] <= d and a[i] <= d) for i in range(1, 1 + n)]))","import k
k.setrecursionlimit(3000)

def f():

    e = k.stdin.read().strip().split()
    n = int(e[0])

    p = [0] * (n + 1)

    b = [[] for _ in range(n + 1)]
    j = []
    
    for i in range(1, n+1):
        g = int(e[i])
        p[i] = g
        if g == -1:
            j.append(i)
        else:
            b[g].append(i)

    def d(u, c):
        h = c
        for v in b[u]:
            h = max(h, d(v, c + 1))
        return h

    a = 0
    for i in j:
        a = max(a, d(i, 1))

    k.stdout.write(str(a) + ""\n"")

if __name__ == ""__main__"":
    f()"
0,none,none,none,['none'],"Limak is an old brown bear. He often plays poker with his friends. Today they went to a casino. There are *n* players (including Limak himself) and right now all of them have bids on the table. *i*-th of them has bid with size *a**i* dollars.

Each player can double his bid any number of times and triple his bid any number of times. The casino has a great jackpot for making all bids equal. Is it possible that Limak and his friends will win a jackpot?","First line of input contains an integer *n* (2<=≤<=*n*<=≤<=105), the number of players.

The second line contains *n* integer numbers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=109) — the bids of players.","Print ""Yes"" (without the quotes) if players can make their bids become equal, or ""No"" otherwise.","['4\n75 150 75 50\n', '3\n100 150 250\n']","['Yes\n', 'No\n']","In the first sample test first and third players should double their bids twice, second player should double his bid once and fourth player should both double and triple his bid.

It can be shown that in the second sample test there is no way to make all bids equal.",WRONG_ANSWER,"n = int(input())
e = list(map(int, input().split()))

a = 32000
b = [True] * a
h = []

def i():
    b[0] = False
    b[1] = False
    for i in range(2, a):
        if b[i]:
            for j in range(i * i, a, i):
                b[j] = False
            h.append(i)

def c(d):
    c = 0
    for p in h:
        if p * p > d:
            break

        while d % p == 0:
            if p > 3:
                c += 1

            d //= p

    if d > 1:
        if d > 3:
            c += 1

    return c

i()
f = c(e[0])
g = True
for i in range(1, len(e)):
    if c(e[i]) != f:
        g = False
        break

if g:
    print(""Yes"")
else:
    print(""No"")","def d(c):
    """"""
    Shift a character by replacing it with the previous character in the alphabet.
    'a' becomes 'z'.
    """"""
    if c == 'a':
        return 'z'
    else:
        return chr(ord(c) - 1)

def b(s):
    n = len(s)
    s = list(s)

    e = -1
    for i in range(n):
        if s[i] != 'a':
            e = i
            break

    if e == -1:
        s[-1] = d(s[-1])
        return """".join(s)

    a = e
    while a < n and s[a] != 'a':
        s[a] = d(s[a])
        a += 1
        
    return """".join(s)

if __name__ == ""__main__"":
    import f

    c = f.stdin.read().strip()

    if '\n' in c:
        c = c.splitlines()[0]

    print(b(c))"
592,C,The Big Race,PROGRAMMING,['math'],"Vector Willman and Array Bolt are the two most famous athletes of Byteforces. They are going to compete in a race with a distance of *L* meters today.

Willman and Bolt have exactly the same speed, so when they compete the result is always a tie. That is a problem for the organizers because they want a winner. 

While watching previous races the organizers have noticed that Willman can perform only steps of length equal to *w* meters, and Bolt can perform only steps of length equal to *b* meters. Organizers decided to slightly change the rules of the race. Now, at the end of the racetrack there will be an abyss, and the winner will be declared the athlete, who manages to run farther from the starting point of the the racetrack (which is not the subject to change by any of the athletes). 

Note that none of the athletes can run infinitely far, as they both will at some moment of time face the point, such that only one step further will cause them to fall in the abyss. In other words, the athlete will not fall into the abyss if the total length of all his steps will be less or equal to the chosen distance *L*.

Since the organizers are very fair, the are going to set the length of the racetrack as an integer chosen randomly and uniformly in range from 1 to *t* (both are included). What is the probability that Willman and Bolt tie again today?","The first line of the input contains three integers *t*, *w* and *b* (1<=≤<=*t*,<=*w*,<=*b*<=≤<=5·1018) — the maximum possible length of the racetrack, the length of Willman's steps and the length of Bolt's steps respectively.","Print the answer to the problem as an irreducible fraction . Follow the format of the samples output.

The fraction  (*p* and *q* are integers, and both *p*<=≥<=0 and *q*<=&gt;<=0 holds) is called irreducible, if there is no such integer *d*<=&gt;<=1, that both *p* and *q* are divisible by *d*.","['10 3 2\n', '7 1 2\n']","['3/10\n', '3/7\n']","In the first sample Willman and Bolt will tie in case 1, 6 or 7 are chosen as the length of the racetrack.",WRONG_ANSWER,"def a(a,b):
    m = a*b
    while a != 0 and b != 0:
        if a > b:
            a %= b
        else:
            b %= a
    return m // (a+b)
t,w,b = map(int,input().split())
if (t % 3 == 0):
    print('1/',end ='')
    print(t/3)
else:
    print('3/',end='')
    print(t)","import e

def d(x):

    return bin(x).count('1')

def c():

    a = e.stdin.read().strip().split()

    for b in a:
        if b.strip():
            x = int(b)
            print(d(x))

if __name__ == ""__main__"":
    c()"
377,A,Maze,PROGRAMMING,['dfs and similar'],"Pavel loves grid mazes. A grid maze is an *n*<=×<=*m* rectangle maze where each cell is either empty, or is a wall. You can go from one cell to another only if both cells are empty and have a common side.

Pavel drew a grid maze with all empty cells forming a connected area. That is, you can go from any empty cell to any other one. Pavel doesn't like it when his maze has too little walls. He wants to turn exactly *k* empty cells into walls so that all the remaining cells still formed a connected area. Help him.","The first line contains three integers *n*, *m*, *k* (1<=≤<=*n*,<=*m*<=≤<=500, 0<=≤<=*k*<=&lt;<=*s*), where *n* and *m* are the maze's height and width, correspondingly, *k* is the number of walls Pavel wants to add and letter *s* represents the number of empty cells in the original maze.

Each of the next *n* lines contains *m* characters. They describe the original maze. If a character on a line equals ""."", then the corresponding cell is empty and if the character equals ""#"", then the cell is a wall.","Print *n* lines containing *m* characters each: the new maze that fits Pavel's requirements. Mark the empty cells that you transformed into walls as ""X"", the other cells must be left without changes (that is, ""."" and ""#"").

It is guaranteed that a solution exists. If there are multiple solutions you can output any of them.","['3 4 2\n#..#\n..#.\n#...\n', '5 4 5\n#...\n#.#.\n.#..\n...#\n.#.#\n']","['#.X#\nX.#.\n#...\n', '#XXX\n#X#.\nX#..\n...#\n.#.#\n']",none,WRONG_ANSWER,"def b():
    n, m, k = (int(c) for c in input().split(' '))
    a = [list(input()) for _ in range(n)]

    for i in range(n):
        for j in range(m):
            if k > 0:
                if a[i][j] == '.':
                    a[i][j] = 'X'
                    k -= 1
            else:
                for i in range(n):
                    for j in range(m):
                        print(a[i][j], end='')
                    print()
                return
        

if __name__ == ""__main__"":
    b()","def f():
    import h
    c = h.stdin.read().split()
    if not c:
        return
    n, a, b, c = map(int, c[:4])

    r = n % 4

    g = (4 - r) % 4

    a = 10**18
    d = [a] * 21
    d[0] = 0
    for d in range(1, 21):

        if d - 1 >= 0:
            d[d] = min(d[d], d[d - 1] + a)

        if d - 2 >= 0:
            d[d] = min(d[d], d[d - 2] + b)

        if d - 3 >= 0:
            d[d] = min(d[d], d[d - 3] + c)

    b = a
    for e in range(g, 21, 4):
        b = min(b, d[e])
    
    print(b)

if __name__ == '__main__':
    f()"
743,C,Vladik and fractions,PROGRAMMING,"['brute force', 'constructive algorithms', 'math', 'number theory']","Vladik and Chloe decided to determine who of them is better at math. Vladik claimed that for any positive integer *n* he can represent fraction  as a sum of three distinct positive fractions in form .

Help Vladik with that, i.e for a given *n* find three distinct positive integers *x*, *y* and *z* such that . Because Chloe can't check Vladik's answer if the numbers are large, he asks you to print numbers not exceeding 109.

If there is no such answer, print -1.",The single line contains single integer *n* (1<=≤<=*n*<=≤<=104).,"If the answer exists, print 3 distinct numbers *x*, *y* and *z* (1<=≤<=*x*,<=*y*,<=*z*<=≤<=109, *x*<=≠<=*y*, *x*<=≠<=*z*, *y*<=≠<=*z*). Otherwise print -1.

If there are multiple answers, print any of them.","['3\n', '7\n']","['2 7 42\n', '7 8 56\n']",none,OK,"for _ in range(1):
    n = int(input())
    a = -1
    if n != 1:
        a = n 
        b = n + 1
        c = b * a
        if a!=b and b!=c and a!=c:
            print(a,b,c)
        else: print(a)
    else:            
        print(a)","""""""
We are given the distributions for max(a,b) and min(a,b) for two independent dice with outcomes 1..n.
Let pmax[i] be the probability that max(a,b)==i, and pmin[i] be that min(a,b)==i.
Define
  M[i] = P(max(a,b) ≤ i) = sum_{j=1}^i pmax[j]   for i=1..n, with M[0]=0 and M[n]=1,
  m[i] = P(min(a,b) ≥ i) = sum_{j=i}^n pmin[j]   for i=1..n, with m[1]=1 and m[n+1]=0.
We wish to find two probability distributions for dice A and B (with CDFs F and G, respectively)
such that the joint order‐statistics have the given distributions.
It is easy to see that if we construct F and G so that

    F[i] * G[i] = M[i]   for i = 1..n   (1)
and
    (1 – F[i-1]) * (1 – G[i-1]) = m[i]   for i = 1..n   (2)

then the order statistics will match.
We have freedom to choose F. In our solution we determine F by “solving”
the second condition (with a little algebra):

For 1 ≤ i < n, note that G[i] = M[i] / F[i] (from (1)); hence
    (1 – F[i]) * (1 – M[i]/F[i]) = (1 – F[i]) * ((F[i] – M[i])/F[i])
                              = (1 – F[i])*(F[i] – M[i]) / F[i]
We want this to equal m[i+1] (since (2) applied at index i+1 yields
   (1 – F[i])*(1 – G[i]) = m[i+1]).
That is, we impose for i = 1 … n–1:
    (1 – F[i])*(F[i] – M[i]) = m[i+1] * F[i].
This is equivalent to the quadratic in t = F[i]:
    t^2 - t*(1 + M[i] - m[i+1]) + M[i] = 0.
We choose one of the two roots (the smaller one) so that the CDF has more “room” to be increasing.
Finally, set F[0]=0 and F[n]=1. Then define
    f_A[i] = F[i] - F[i-1]
and, from (1),
    G[i] = M[i] / F[i]  for i = 1..n-1 and G[n] = 1,
    f_B[i] = G[i] - G[i-1]  with G[0] defined as 0.
This pair (f_A, f_B) is a valid solution.
The following Python script implements this method.
""""""

import n, f

def l():
    a = n.stdin.read().split()
    if not a:
        return

    e = iter(a)
    n = int(next(e))

    i = [float(next(e)) for _ in range(n)]

    j = [float(next(e)) for _ in range(n)]

    M = [0.0] * (n + 1)
    for i in range(1, n + 1):
        M[i] = M[i - 1] + i[i - 1]

    m = [0.0] * (n + 2)
    m[n + 1] = 0.0
    for i in range(n, 0, -1):
        m[i] = m[i + 1] + j[i - 1]

    F = [0.0] * (n + 1)
    F[0] = 0.0
    for i in range(1, n):

        d = (1.0 + M[i] - m[i + 1])**2 - 4.0 * M[i]
        if d < 0:
            d = 0.0
        m = f.sqrt(d)

        k = (1.0 + M[i] - m[i + 1] - m) / 2.0

        if k < F[i - 1]:
            k = F[i - 1]
        if k > 1.0:
            k = 1.0
        F[i] = k
    F[n] = 1.0

    b = [F[i] - F[i - 1] for i in range(1, n + 1)]

    G = [0.0] * (n + 1)
    G[0] = 0.0
    for i in range(1, n):
        if F[i] == 0:
            G[i] = 0.0
        else:
            G[i] = M[i] / F[i]
            if G[i] < 0.0: G[i] = 0.0
            if G[i] > 1.0: G[i] = 1.0
    G[n] = 1.0

    c = [G[i] - G[i - 1] for i in range(1, n + 1)]

    g = "" "".join(""{:.9f}"".format(x) for x in b) + ""\n""
    h = "" "".join(""{:.9f}"".format(x) for x in c) + ""\n""
    n.stdout.write(g + h)

if __name__ == '__main__':
    l()"
600,B,Queries about less or equal elements,PROGRAMMING,"['binary search', 'data structures', 'sortings', 'two pointers']",You are given two arrays of integers *a* and *b*. For each element of the second array *b**j* you should find the number of elements in array *a* that are less than or equal to the value *b**j*.,"The first line contains two integers *n*,<=*m* (1<=≤<=*n*,<=*m*<=≤<=2·105) — the sizes of arrays *a* and *b*.

The second line contains *n* integers — the elements of array *a* (<=-<=109<=≤<=*a**i*<=≤<=109).

The third line contains *m* integers — the elements of array *b* (<=-<=109<=≤<=*b**j*<=≤<=109).","Print *m* integers, separated by spaces: the *j*-th of which is equal to the number of such elements in array *a* that are less than or equal to the value *b**j*.","['5 4\n1 3 5 7 9\n6 4 2 8\n', '5 5\n1 2 1 2 5\n3 1 4 1 5\n']","['3 2 1 4\n', '4 2 4 2 5\n']",none,WRONG_ANSWER,"def a(a,k):
    l,r = 0,len(a)-1
    while l<=r:
        m = l + (r-l)//2
        if a[m] == k:
            l=m+1
        elif a[m]>k:
        	r = m-1
        else:
        	l = m+1
    return l

m,n=map(int,input().split())
a,b=list(map(int,input().split())),list(map(int,input().split()))
a=sorted(a)
print(a,b)
for i in b:
    print(a(a,i),end=' ')","import h
import e

def d():

    c = h.stdin.read().split()
    n = int(c[0])

    f = list(map(int, c[1:]))
    f.sort()

    g = f[1] - f[0]
    for i in range(2, n):
        b = f[i] - f[i - 1]
        g = e.gcd(g, b)

    a = 0
    for i in range(1, n):
        b = f[i] - f[i - 1]

        a += (b // g) - 1

    h.stdout.write(str(a) + '\n')

if __name__ == ""__main__"":
    d()"
653,A,Bear and Three Balls,PROGRAMMING,"['brute force', 'implementation', 'sortings']","Limak is a little polar bear. He has *n* balls, the *i*-th ball has size *t**i*.

Limak wants to give one ball to each of his three friends. Giving gifts isn't easy — there are two rules Limak must obey to make friends happy:
 -  No two friends can get balls of the same size. -  No two friends can get balls of sizes that differ by more than 2. 
For example, Limak can choose balls with sizes 4, 5 and 3, or balls with sizes 90, 91 and 92. But he can't choose balls with sizes 5, 5 and 6 (two friends would get balls of the same size), and he can't choose balls with sizes 30, 31 and 33 (because sizes 30 and 33 differ by more than 2).

Your task is to check whether Limak can choose three balls that satisfy conditions above.","The first line of the input contains one integer *n* (3<=≤<=*n*<=≤<=50) — the number of balls Limak has.

The second line contains *n* integers *t*1,<=*t*2,<=...,<=*t**n* (1<=≤<=*t**i*<=≤<=1000) where *t**i* denotes the size of the *i*-th ball.","Print ""YES"" (without quotes) if Limak can choose three balls of distinct sizes, such that any two of them differ by no more than 2. Otherwise, print ""NO"" (without quotes).","['4\n18 55 16 17\n', '6\n40 41 43 44 44 44\n', '8\n5 972 3 4 1 4 970 971\n']","['YES\n', 'NO\n', 'YES\n']","In the first sample, there are 4 balls and Limak is able to choose three of them to satisfy the rules. He must must choose balls with sizes 18, 16 and 17.

In the second sample, there is no way to give gifts to three friends without breaking the rules.

In the third sample, there is even more than one way to choose balls:
 1.  Choose balls with sizes 3, 4 and 5. 1.  Choose balls with sizes 972, 970, 971.",OK,"def a (t):
    if len(t) <= 2:
        return ""NO""
    for x in range(len(t)-2):
        if abs(t[x+1] - t[x]) <= 2 and abs(t[x+2] - t[x]) <= 2 and abs(t[x+2] - t[x+1]) <= 2:
            return ""YES""
    return ""NO""

n = int(input())
t = list(map(int,input().split()))
t = list(set(t))
t = sorted(t)

print (a(t))","import p
import c

def i():

    d = p.stdin.read().split()
    if not d:
        return
    n = int(d[0])
    m = int(d[1])
    a = list(map(int, d[2:]))

    j = n // 2
    g = a[:j]
    m = a[j:]

    def e(a):
        o = [0]

        for l in a:
            k = []
            for s in o:
                k.append(s + l)
            o += k

        return [s % m for s in o]

    h = e(g)
    n = e(m)

    h = sorted(set(h))

    b = max(max(h), max(n))

    for s in n:

        q = m - 1 - s
        f = c.bisect_right(h, q) - 1
        if f >= 0:
            r = s + h[f]
            b = max(b, r % m)

    print(b)

if __name__ == '__main__':
    i()"
334,A,Candy Bags,PROGRAMMING,['implementation'],"Gerald has *n* younger brothers and their number happens to be even. One day he bought *n*2 candy bags. One bag has one candy, one bag has two candies, one bag has three candies and so on. In fact, for each integer *k* from 1 to *n*2 he has exactly one bag with *k* candies. 

Help him give *n* bags of candies to each brother so that all brothers got the same number of candies.","The single line contains a single integer *n* (*n* is even, 2<=≤<=*n*<=≤<=100) — the number of Gerald's brothers.","Let's assume that Gerald indexes his brothers with numbers from 1 to *n*. You need to print *n* lines, on the *i*-th line print *n* integers — the numbers of candies in the bags for the *i*-th brother. Naturally, all these numbers should be distinct and be within limits from 1 to *n*2. You can print the numbers in the lines in any order. 

It is guaranteed that the solution exists at the given limits.",['2\n'],['1 4\n2 3\n'],"The sample shows Gerald's actions if he has two brothers. In this case, his bags contain 1, 2, 3 and 4 candies. He can give the bags with 1 and 4 candies to one brother and the bags with 2 and 3 to the other brother.",WRONG_ANSWER,"def b():
    n = int(input())
    a = {i:[] for i in range(n)}
    for i in range(n):
        a[i] = [j+1 for j in range(2*i, 2*i+n//2, 1)] + [n**2-k for k in range(2*i, 2*i+n//2, 1)]

    for i in range(n):
        print(*a[i])

if __name__ == ""__main__"":
    b()","import c

def b():

    n, m, z = map(int, input().split())

    a = (n * m) // c.gcd(n, m)

    d = z // a

    print(d)

if __name__ == ""__main__"":
    b()"
312,B,Archer,PROGRAMMING,"['math', 'probabilities']","SmallR is an archer. SmallR is taking a match of archer with Zanoes. They try to shoot in the target in turns, and SmallR shoots first. The probability of shooting the target each time is  for SmallR while  for Zanoes. The one who shoots in the target first should be the winner.

Output the probability that SmallR will win the match.",A single line contains four integers .,"Print a single real number, the probability that SmallR will win the match.

The answer will be considered correct if the absolute or relative error doesn't exceed 10<=-<=6.",['1 2 1 2\n'],['0.666666666667'],none,OK,"import a
input=a.stdin.readline
from collections import defaultdict as dc
from collections import Counter
from bisect import bisect_right, bisect_left
import math
from operator import itemgetter
from heapq import heapify, heappop, heappush
from queue import PriorityQueue as pq
a,b,c,d=map(int,input().split())
x,y=a/b,c/d
z=(1-x)*(1-y)
s=1/(1-z)
print(x*s)","import g

def c():

    a = g.stdin.read().strip().split()
    if not a:
        return

    b = iter(a)
    n = int(next(b))
    m = int(next(b))

    a = [int(next(b)) for _ in range(n)]

    d = [0] * (n + 1)
    for i in range(1, n + 1):
        d[i] = d[i - 1] + a[i - 1]

    e = 0

    for _ in range(m):
        l = int(next(b))
        r = int(next(b))

        f = d[r] - d[l - 1]

        if f > 0:
            e += f

    print(e)

if __name__ == '__main__':
    c()"
731,A,Night at the Museum,PROGRAMMING,"['implementation', 'strings']","Grigoriy, like the hero of one famous comedy film, found a job as a night security guard at the museum. At first night he received embosser and was to take stock of the whole exposition.

Embosser is a special devise that allows to ""print"" the text of a plastic tape. Text is printed sequentially, character by character. The device consists of a wheel with a lowercase English letters written in a circle, static pointer to the current letter and a button that print the chosen letter. At one move it's allowed to rotate the alphabetic wheel one step clockwise or counterclockwise. Initially, static pointer points to letter 'a'. Other letters are located as shown on the picture:

After Grigoriy add new item to the base he has to print its name on the plastic tape and attach it to the corresponding exhibit. It's not required to return the wheel to its initial position with pointer on the letter 'a'.

Our hero is afraid that some exhibits may become alive and start to attack him, so he wants to print the names as fast as possible. Help him, for the given string find the minimum number of rotations of the wheel required to print it.",The only line of input contains the name of some exhibit — the non-empty string consisting of no more than 100 characters. It's guaranteed that the string consists of only lowercase English letters.,"Print one integer — the minimum number of rotations of the wheel, required to print the name given in the input.","['zeus\n', 'map\n', 'ares\n']","['18\n', '35\n', '34\n']","To print the string from the first sample it would be optimal to perform the following sequence of rotations: 
 1.  from 'a' to 'z' (1 rotation counterclockwise), 1.  from 'z' to 'e' (5 clockwise rotations), 1.  from 'e' to 'u' (10 rotations counterclockwise), 1.  from 'u' to 's' (2 counterclockwise rotations).",OK,"e = input()
sum = 0
d = 'abcdefghijklmnopqrstuvwxyz'

a = 0
for c in e:
    b = abs(a - d.find(c))
    a = d.find(c)
    if b <= (26-b):
        sum += b
    else:
        sum += 26-b

print(sum)","def j():
    import n
    from collections import d

    c = n.stdin.read().split()
    if not c:
        return

    i = iter(c)

    p = int(next(i))
    r = int(next(i))
    q = int(next(i))
    s = int(next(i))
    
    n = int(next(i))

    a = {}
    for _ in range(n):
        r = int(next(i))
        a = int(next(i))
        b = int(next(i))
        if r not in a:
            a[r] = set()

        for b in range(a, b + 1):
            a[r].add(b)

    f = d()
    f.append((p, r, 0))
    o = set()
    o.add((p, r))

    e = [(-1, -1), (-1, 0), (-1, 1), 
                  (0, -1),           (0, 1), 
                  (1, -1),  (1, 0),  (1, 1)]

    while f:
        x, y, k = f.popleft()
        if x == q and y == s:
            n.stdout.write(str(k))
            return
        for g, h in e:
            l, m = x + g, y + h
            if (l, m) in o:
                continue

            if l in a and m in a[l]:
                o.add((l, m))
                f.append((l, m, k + 1))

    n.stdout.write(str(-1))

if __name__ == '__main__':
    j()"
706,B,Interesting drink,PROGRAMMING,"['binary search', 'dp', 'implementation']","Vasiliy likes to rest after a hard work, so you may often meet him in some bar nearby. As all programmers do, he loves the famous drink ""Beecola"", which can be bought in *n* different shops in the city. It's known that the price of one bottle in the shop *i* is equal to *x**i* coins.

Vasiliy plans to buy his favorite drink for *q* consecutive days. He knows, that on the *i*-th day he will be able to spent *m**i* coins. Now, for each of the days he want to know in how many different shops he can buy a bottle of ""Beecola"".","The first line of the input contains a single integer *n* (1<=≤<=*n*<=≤<=100<=000) — the number of shops in the city that sell Vasiliy's favourite drink.

The second line contains *n* integers *x**i* (1<=≤<=*x**i*<=≤<=100<=000) — prices of the bottles of the drink in the *i*-th shop.

The third line contains a single integer *q* (1<=≤<=*q*<=≤<=100<=000) — the number of days Vasiliy plans to buy the drink.

Then follow *q* lines each containing one integer *m**i* (1<=≤<=*m**i*<=≤<=109) — the number of coins Vasiliy can spent on the *i*-th day.",Print *q* integers. The *i*-th of them should be equal to the number of shops where Vasiliy will be able to buy a bottle of the drink on the *i*-th day.,['5\n3 10 8 6 11\n4\n1\n10\n3\n11\n'],['0\n4\n1\n5\n'],"On the first day, Vasiliy won't be able to buy a drink in any of the shops.

On the second day, Vasiliy can buy a drink in the shops 1, 2, 3 and 4.

On the third day, Vasiliy can buy a drink only in the shop number 1.

Finally, on the last day Vasiliy can buy a drink in any shop.",TIME_LIMIT_EXCEEDED,"def a(e,g):
    e.sort()
    d=0
    b=len(e)-1
    while d<=b:
        f=(d+b)//2
        if e[f]<=g:
            d=f+1
        else:
            b=f-1
    return b
t=int(input())
e=list(map(int,input().split()))
q=int(input())
for i in range(q):
    c=int(input())
    print(a(e,c)+1)","import c
import j

def d():

    b = j.stdin.read().strip().split()
    if not b:
        return
    n = int(b[0])
    m = int(b[1])
    i = list(map(int, b[2:2 + m]))

    e = []
    for s in i:
        c.heappush(e, -s)
    
    f = 0
    for _ in range(n):

        a = -c.heappop(e)
        f += a

        if a - 1 > 0:
            c.heappush(e, -(a - 1))

    g = []
    for s in i:
        c.heappush(g, s)
    
    h = 0
    for _ in range(n):

        a = c.heappop(g)
        h += a

        if a - 1 > 0:
            c.heappush(g, a - 1)

    print(f""{f} {h}"")

if __name__ == '__main__':
    d()"
746,B,Decoding,PROGRAMMING,"['implementation', 'strings']","Polycarp is mad about coding, that is why he writes Sveta encoded messages. He calls the median letter in a word the letter which is in the middle of the word. If the word's length is even, the median letter is the left of the two middle letters. In the following examples, the median letter is highlighted: contest, info. If the word consists of single letter, then according to above definition this letter is the median letter. 

Polycarp encodes each word in the following way: he writes down the median letter of the word, then deletes it and repeats the process until there are no letters left. For example, he encodes the word volga as logva.

You are given an encoding *s* of some word, your task is to decode it.","The first line contains a positive integer *n* (1<=≤<=*n*<=≤<=2000) — the length of the encoded word.

The second line contains the string *s* of length *n* consisting of lowercase English letters — the encoding.",Print the word that Polycarp encoded.,"['5\nlogva\n', '2\nno\n', '4\nabba\n']","['volga\n', 'no\n', 'baba\n']","In the first example Polycarp encoded the word volga. At first, he wrote down the letter l from the position 3, after that his word looked like voga. After that Polycarp wrote down the letter o from the position 2, his word became vga. Then Polycarp wrote down the letter g which was at the second position, the word became va. Then he wrote down the letter v, then the letter a. Thus, the encoding looked like logva.

In the second example Polycarp encoded the word no. He wrote down the letter n, the word became o, and he wrote down the letter o. Thus, in this example, the word and its encoding are the same.

In the third example Polycarp encoded the word baba. At first, he wrote down the letter a, which was at the position 2, after that the word looked like bba. Then he wrote down the letter b, which was at the position 2, his word looked like ba. After that he wrote down the letter b, which was at the position 1, the word looked like a, and he wrote down that letter a. Thus, the encoding is abba.",OK,"def c():

  b = int(input())

  e = input()

  a = 'r' if (b % 2 == 0) else 'l'
  d = []
  d.append(e[0])
  e = e[1:]

  for c in e:
    if a == 'l':
      d.insert(0, c)
    else:
	 	  d.append(c)

    a = 'l' if a == 'r' else 'r'

  for p in d:
    print(p, end='')

if __name__ == '__main__':
    c()","import c

def b():

    a = c.stdin.read().strip()
    if not a:
        return

    n = a.strip()

    if int(n[-1]) % 2 == 0:

        c.stdout.write(n)
    else:

        c.stdout.write(""0"")

if __name__ == ""__main__"":
    b()"
912,A,Tricky Alchemy,PROGRAMMING,['implementation'],"During the winter holidays, the demand for Christmas balls is exceptionally high. Since it's already 2018, the advances in alchemy allow easy and efficient ball creation by utilizing magic crystals.

Grisha needs to obtain some yellow, green and blue balls. It's known that to produce a yellow ball one needs two yellow crystals, green — one yellow and one blue, and for a blue ball, three blue crystals are enough.

Right now there are *A* yellow and *B* blue crystals in Grisha's disposal. Find out how many additional crystals he should acquire in order to produce the required number of balls.","The first line features two integers *A* and *B* (0<=≤<=*A*,<=*B*<=≤<=109), denoting the number of yellow and blue crystals respectively at Grisha's disposal.

The next line contains three integers *x*, *y* and *z* (0<=≤<=*x*,<=*y*,<=*z*<=≤<=109) — the respective amounts of yellow, green and blue balls to be obtained.",Print a single integer — the minimum number of crystals that Grisha should acquire in addition.,"['4 3\n2 1 1\n', '3 9\n1 1 3\n', '12345678 87654321\n43043751 1000000000 53798715\n']","['2\n', '1\n', '2147483648\n']","In the first sample case, Grisha needs five yellow and four blue crystals to create two yellow balls, one green ball, and one blue ball. To do that, Grisha needs to obtain two additional crystals: one yellow and one blue.",OK,"import sys
import math
import bisect
import itertools

def c():
    A = list(map(int, input().split()))
    B = list(map(int, input().split()))

    d = B[0] * 2 + B[1] * 1
    b = B[1] * 1 + B[2] * 3
    a = 0

    if A[0] < d:
        a += d - A[0]
    if A[1] < b:
        a += b - A[1]
    print(a)

if __name__ == ""__main__"":
    c()","def f():
    import j
    c = j.stdin.read().split()
    if not c:
        return

    d = iter(c)
    n = int(next(d))
    l = int(next(d))
    r = int(next(d))
    a = [int(next(d)) for _ in range(n)]
    p = [int(next(d)) for _ in range(n)]

    c = [None] * n

    g = sorted(range(n), key=lambda i: p[i])

    i = -10**18
    h = True

    for i in g:

        e = l - a[i]
        b = r - a[i]

        a = max(e, i + 1)
        if a > b:
            h = False
            break
        c[i] = a
        i = a

    if not h:
        j.stdout.write(""-1"")
        return

    b = [a[i] + c[i] for i in range(n)]
    j.stdout.write("" "".join(map(str, b)) + ""\n"")

if __name__ == '__main__':
    f()"
834,A,The Useless Toy,PROGRAMMING,['implementation'],"Walking through the streets of Marshmallow City, Slastyona have spotted some merchants selling a kind of useless toy which is very popular nowadays – caramel spinner! Wanting to join the craze, she has immediately bought the strange contraption.

Spinners in Sweetland have the form of V-shaped pieces of caramel. Each spinner can, well, spin around an invisible magic axis. At a specific point in time, a spinner can take 4 positions shown below (each one rotated 90 degrees relative to the previous, with the fourth one followed by the first one):

After the spinner was spun, it starts its rotation, which is described by a following algorithm: the spinner maintains its position for a second then majestically switches to the next position in clockwise or counter-clockwise order, depending on the direction the spinner was spun in.

Slastyona managed to have spinner rotating for exactly *n* seconds. Being fascinated by elegance of the process, she completely forgot the direction the spinner was spun in! Lucky for her, she managed to recall the starting position, and wants to deduct the direction given the information she knows. Help her do this.","There are two characters in the first string – the starting and the ending position of a spinner. The position is encoded with one of the following characters: v (ASCII code 118, lowercase v), &lt; (ASCII code 60), ^ (ASCII code 94) or &gt; (ASCII code 62) (see the picture above for reference). Characters are separated by a single space.

In the second strings, a single number *n* is given (0<=≤<=*n*<=≤<=109) – the duration of the rotation.

It is guaranteed that the ending position of a spinner is a result of a *n* second spin in any of the directions, assuming the given starting position.","Output cw, if the direction is clockwise, ccw – if counter-clockwise, and undefined otherwise.","['^ &gt;\n1\n', '&lt; ^\n3\n', '^ v\n6\n']","['cw\n', 'ccw\n', 'undefined\n']",none,OK,"d = {""v"":  0, ""<"": 1, ""^"": 2, "">"": 3}
a, b = input().split()
s = int(input())

c = (d[a] + s) % 4 == d[b]
d = (d[a] - s) % 4 == d[b]
if c and d:
    print(""undefined"")
elif c:
    print(""cw"")
else:
    print(""ccw"")","def c():
    import d

    b = d.stdin.read().split()
    if not b:
        return
    x = int(b[0])
    y = int(b[1])

    a = True
    
    while True:
        if a:

            if x >= 2 and y >= 2:

                x -= 2
                y -= 2
            elif x >= 1 and y >= 12:

                x -= 1
                y -= 12
            elif y >= 22:

                y -= 22
            else:

                print(""Hanako"")
                break
        else:

            if y >= 22:

                y -= 22
            elif x >= 1 and y >= 12:

                x -= 1
                y -= 12
            elif x >= 2 and y >= 2:

                x -= 2
                y -= 2
            else:

                print(""Ciel"")
                break

        a = not a

if __name__ == '__main__':
    c()"
902,A,Visiting a Friend,PROGRAMMING,"['greedy', 'implementation']","Pig is visiting a friend.

Pig's house is located at point 0, and his friend's house is located at point *m* on an axis.

Pig can use teleports to move along the axis.

To use a teleport, Pig should come to a certain point (where the teleport is located) and choose where to move: for each teleport there is the rightmost point it can move Pig to, this point is known as the limit of the teleport.

Formally, a teleport located at point *x* with limit *y* can move Pig from point *x* to any point within the segment [*x*;<=*y*], including the bounds.

Determine if Pig can visit the friend using teleports only, or he should use his car.","The first line contains two integers *n* and *m* (1<=≤<=*n*<=≤<=100,<=1<=≤<=*m*<=≤<=100) — the number of teleports and the location of the friend's house.

The next *n* lines contain information about teleports.

The *i*-th of these lines contains two integers *a**i* and *b**i* (0<=≤<=*a**i*<=≤<=*b**i*<=≤<=*m*), where *a**i* is the location of the *i*-th teleport, and *b**i* is its limit.

It is guaranteed that *a**i*<=≥<=*a**i*<=-<=1 for every *i* (2<=≤<=*i*<=≤<=*n*).","Print ""YES"" if there is a path from Pig's house to his friend's house that uses only teleports, and ""NO"" otherwise.

You can print each letter in arbitrary case (upper or lower).","['3 5\n0 2\n2 4\n3 5\n', '3 7\n0 4\n2 5\n6 7\n']","['YES\n', 'NO\n']","The first example is shown on the picture below:

Pig can use the first teleport from his house (point 0) to reach point 2, then using the second teleport go from point 2 to point 3, then using the third teleport go from point 3 to point 5, where his friend lives.

The second example is shown on the picture below:

You can see that there is no path from Pig's house to his friend's house that uses only teleports.",OK,"def c(n, m, f):
    d = 0  
    for i in range(n):
        a, b = f[i]
        
        
        if a > d:
            return ""NO"" 
            
    
        d = max(d, b)

        if d >= m:
            return ""YES"" 

    return ""YES"" if d >= m else ""NO""

n, m = map(int, input().split())
f = []
for _ in range(n):
    a, b = map(int, input().split())
    f.append((a, b))

e = c(n, m, f)

print(e)","def a(s):

    return s == s[::-1]

def b():

    s = input().strip()

    k = int(input().strip())
    
    n = len(s)

    if n % k != 0:
        print(""NO"")
        return

    d = n // k

    for i in range(0, n, d):
        c = s[i:i+d]

        if not a(c):
            print(""NO"")
            return

    print(""YES"")

if __name__ == ""__main__"":
    b()"
609,A,USB Flash Drives,PROGRAMMING,"['greedy', 'implementation', 'sortings']","Sean is trying to save a large file to a USB flash drive. He has *n* USB flash drives with capacities equal to *a*1,<=*a*2,<=...,<=*a**n* megabytes. The file size is equal to *m* megabytes. 

Find the minimum number of USB flash drives needed to write Sean's file, if he can split the file between drives.","The first line contains positive integer *n* (1<=≤<=*n*<=≤<=100) — the number of USB flash drives.

The second line contains positive integer *m* (1<=≤<=*m*<=≤<=105) — the size of Sean's file.

Each of the next *n* lines contains positive integer *a**i* (1<=≤<=*a**i*<=≤<=1000) — the sizes of USB flash drives in megabytes.

It is guaranteed that the answer exists, i. e. the sum of all *a**i* is not less than *m*.","Print the minimum number of USB flash drives to write Sean's file, if he can split the file between drives.","['3\n5\n2\n1\n3\n', '3\n6\n2\n3\n2\n', '2\n5\n5\n10\n']","['2\n', '3\n', '1\n']","In the first example Sean needs only two USB flash drives — the first and the third.

In the second example Sean needs all three USB flash drives.

In the third example Sean needs only one USB flash drive and he can use any available USB flash drive — the first or the second.",OK,"def b():
    n = int(input())
    m = int(input())
    a = [int(input()) for i in range(n)]
    a.sort(reverse=True)
    sum = 0
    c = 0
    for i in a:
        sum += i
        c += 1
        if sum >= m:
            break
    print(c)

b()","def e():
    import g
    f = 10**9 + 7

    b = g.stdin.read().strip().split()
    if not b:
        return
    n = int(b[0])
    k = int(b[1])
    d = int(b[2])

    c = [0] * (n + 1)
    c[0] = 1
    for s in range(1, n + 1):
        for w in range(1, k + 1):
            if s - w < 0:
                break
            c[s] = (c[s] + c[s - w]) % f

    d = [0] * (n + 1)
    d[0] = 1
    for s in range(1, n + 1):
        for w in range(1, d):
            if s - w < 0:
                break
            d[s] = (d[s] + d[s - w]) % f

    if d == 1:
        print(c[n] % f)
    else:

        a = c[n] - d[n]
        print(a % f)

if __name__ == '__main__':
    e()"
340,A,The Wall,PROGRAMMING,['math'],"Iahub and his friend Floyd have started painting a wall. Iahub is painting the wall red and Floyd is painting it pink. You can consider the wall being made of a very large number of bricks, numbered 1, 2, 3 and so on. 

Iahub has the following scheme of painting: he skips *x*<=-<=1 consecutive bricks, then he paints the *x*-th one. That is, he'll paint bricks *x*, 2·*x*, 3·*x* and so on red. Similarly, Floyd skips *y*<=-<=1 consecutive bricks, then he paints the *y*-th one. Hence he'll paint bricks *y*, 2·*y*, 3·*y* and so on pink.

After painting the wall all day, the boys observed that some bricks are painted both red and pink. Iahub has a lucky number *a* and Floyd has a lucky number *b*. Boys wonder how many bricks numbered no less than *a* and no greater than *b* are painted both red and pink. This is exactly your task: compute and print the answer to the question.","The input will have a single line containing four integers in this order: *x*, *y*, *a*, *b*. (1<=≤<=*x*,<=*y*<=≤<=1000, 1<=≤<=*a*,<=*b*<=≤<=2·109, *a*<=≤<=*b*).",Output a single integer — the number of bricks numbered no less than *a* and no greater than *b* that are painted both red and pink.,['2 3 6 18\n'],['3'],"Let's look at the bricks from *a* to *b* (*a* = 6, *b* = 18). The bricks colored in red are numbered 6, 8, 10, 12, 14, 16, 18. The bricks colored in pink are numbered 6, 9, 12, 15, 18. The bricks colored in both red and pink are numbered with 6, 12 and 18.",WRONG_ANSWER,"x,y,a,b=map(int,input().split())

def a(x,y):
    if (x%y==0):
        return y
    else:
        return(a(y,x%y))

n=a(x,y)
t=x*y/n
s=0
u=((a/t)+1)*t
if(u<b):s=int((b-u)/t)+1
if a%t==0:s+=1

print(s)","import k

def c(a, b):
    while b:
        a, b = b, a % b
    return a

def e(a, b):
    return a // c(a, b) * b

def f(a, b, c):
    return e(e(a, b), c)

def h():
    import k

    d = k.stdin.read().splitlines()
    j = []

    for g in d:
        if not g.strip():
            continue
        n = int(g.strip())

        if n <= 2:
            j.append(str(n))
            continue
        if n == 3:
            j.append(""6"")
            continue

        a = list(range(max(1, n - 5), n + 1))
        i = 0

        for a in a:
            for b in a:
                for c in a:
                    b = f(a, b, c)
                    if b > i:
                        i = b

        j.append(str(i))

    k.stdout.write(""\n"".join(j))

if __name__ == ""__main__"":
    h()"
252,A,Little Xor,PROGRAMMING,"['brute force', 'implementation']","Little Petya likes arrays that consist of non-negative integers a lot. Recently his mom has presented him one such array consisting of *n* elements. Petya immediately decided to find there a segment of consecutive elements, such that the *xor* of all numbers from this segment was maximal possible. Help him with that.

The *xor* operation is the bitwise exclusive ""OR"", that is denoted as ""xor"" in Pascal and ""^"" in C/C++/Java.",The first line contains integer *n* (1<=≤<=*n*<=≤<=100) — the number of elements in the array. The second line contains the space-separated integers from the array. All numbers are non-negative integers strictly less than 230.,Print a single integer — the required maximal *xor* of a segment of consecutive elements.,"['5\n1 2 1 1 2\n', '3\n1 2 7\n', '4\n4 2 4 8\n']","['3\n', '7\n', '14\n']","In the first sample one of the optimal segments is the segment that consists of the first and the second array elements, if we consider the array elements indexed starting from one.

The second sample contains only one optimal segment, which contains exactly one array element (element with index three).",WRONG_ANSWER,"import sys

def a(d, e):
    e[0] = int(input())
    d = list(map(int, input().split()))

def b(d):
    c = d[0]
    f = d[0]
    l = 0
    for r in range(1,len(d)):
        f = f ^ d[r]
        while (f < d[r]):
            f ^= d[l]
            l +=1
        if f > c:
            c = f
    return c

e = int(input())
d = list(map(int, input().split()))
print(b(d))","def g():
    import k
    from itertools import h

    e = k.stdin.read().strip().split()

    if len(e) != 6:
        return

    i, j, a, b, c, d = map(int, e)

    f = False
    for a, b, c, d in h(range(1, 10), 4):
        if a + b != i:
            continue
        if c + d != j:
            continue
        if a + c != a:
            continue
        if b + d != b:
            continue
        if a + d != c:
            continue
        if b + c != d:
            continue

        print(f""{a} {b}"")
        print(f""{c} {d}"")
        f = True
        break

    if not f:
        print(""-1"")

if __name__ == ""__main__"":
    g()"
0,none,none,none,['none'],"Gerald got a very curious hexagon for his birthday. The boy found out that all the angles of the hexagon are equal to . Then he measured the length of its sides, and found that each of them is equal to an integer number of centimeters. There the properties of the hexagon ended and Gerald decided to draw on it.

He painted a few lines, parallel to the sides of the hexagon. The lines split the hexagon into regular triangles with sides of 1 centimeter. Now Gerald wonders how many triangles he has got. But there were so many of them that Gerald lost the track of his counting. Help the boy count the triangles.","The first and the single line of the input contains 6 space-separated integers *a*1,<=*a*2,<=*a*3,<=*a*4,<=*a*5 and *a*6 (1<=≤<=*a**i*<=≤<=1000) — the lengths of the sides of the hexagons in centimeters in the clockwise order. It is guaranteed that the hexagon with the indicated properties and the exactly such sides exists.","Print a single integer — the number of triangles with the sides of one 1 centimeter, into which the hexagon is split.","['1 1 1 1 1 1\n', '1 2 1 2 1 2\n']","['6\n', '13\n']","This is what Gerald's hexagon looks like in the first sample:

<img class=""tex-graphics"" src=""https://espresso.codeforces.com/84d193e27b02c38eb1eadc536602a2ec0b9f9519.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

And that's what it looks like in the second sample:

<img class=""tex-graphics"" src=""https://espresso.codeforces.com/e29076a96da8ca864654cc6195654d9bf07d31ce.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>",WRONG_ANSWER,"def a(n):
    a = 0
    i = 1
    while i <= n:
        a += (2 * i - 1)
        i += 1
    return a

a = input().split()
for i in range(len(a)):
    a[i] = int(a[i])
c = a[0] + a[1] + a[5]
print(c)
print(a(c) - a(a[1]) - a(a[3]) - a(a[5]))","def c():
    import f
    b = f.stdin.read().split()
    d = 10**9 + 7

    n = int(b[0])

    h = list(map(int, b[1:]))
    h.sort()

    e = [1] * (n + 1)
    for i in range(1, n + 1):
        e[i] = (e[i - 1] * 2) % d

    g = 0
    for i in range(n):
        a = (e[i] - e[n - 1 - i]) % d
        g = (g + h[i] * a) % d

    f.stdout.write(str(g))

if __name__ == ""__main__"":
    c()"
235,A,LCM Challenge,PROGRAMMING,['number theory'],"Some days ago, I learned the concept of LCM (least common multiple). I've played with it for several times and I want to make a big number with it.

But I also don't want to use many numbers, so I'll choose three positive integers (they don't have to be distinct) which are not greater than *n*. Can you help me to find the maximum possible least common multiple of these three integers?",The first line contains an integer *n* (1<=≤<=*n*<=≤<=106) — the *n* mentioned in the statement.,Print a single integer — the maximum possible LCM of three not necessarily distinct positive integers that are not greater than *n*.,"['9\n', '7\n']","['504\n', '210\n']","The least common multiple of some positive integers is the least positive integer which is multiple for each of them.

The result may become very large, 32-bit integer won't be enough. So using 64-bit integers is recommended.

For the last example, we can chose numbers 7, 6, 5 and the LCM of them is 7·6·5 = 210. It is the maximum value we can get.",WRONG_ANSWER,"n=int(input())
def c(a,b):
    d=max(a,b)
    e=min(a,b)
    if(e==0):
        return d
    while(d%e):
        f=d
        d=e
        e=f%e
    return e
f=n
b=n
a=1
    
for i in range(n-1,0,-1):
    g=c(n,i)
    if(a==3):
        break
    if(g==1):
        
        f*=i
        a+=1
print(f)","def e():
    import h

    b = h.stdin.read().split()
    if not b: 
        return
    n = int(b[0])
    s = int(b[1])

    d = []
    c = 2
    for i in range(n):
        h = int(b[c])
        m = int(b[c + 1])
        i = h * 60 + m
        d.append(i)
        c += 2

    if d[0] >= s + 1:
        print(""0 0"")
        return

    for i in range(len(d) - 1):
        g = d[i]
        f = d[i + 1]
        a = g + 1 + s
        if a + 1 <= f - s:
            h = a // 60
            m = a % 60
            print(f""{h} {m}"")
            return

    a = d[-1] + 1 + s
    h = a // 60
    m = a % 60
    print(f""{h} {m}"")

if __name__ == '__main__':
    e()"
817,A,Treasure Hunt,PROGRAMMING,"['implementation', 'math', 'number theory']","Captain Bill the Hummingbird and his crew recieved an interesting challenge offer. Some stranger gave them a map, potion of teleportation and said that only this potion might help them to reach the treasure. 

Bottle with potion has two values *x* and *y* written on it. These values define four moves which can be performed using the potion:
 -   -   -   -   
Map shows that the position of Captain Bill the Hummingbird is (*x*1,<=*y*1) and the position of the treasure is (*x*2,<=*y*2).

You task is to tell Captain Bill the Hummingbird whether he should accept this challenge or decline. If it is possible for Captain to reach the treasure using the potion then output ""YES"", otherwise ""NO"" (without quotes).

The potion can be used infinite amount of times.","The first line contains four integer numbers *x*1,<=*y*1,<=*x*2,<=*y*2 (<=-<=105<=≤<=*x*1,<=*y*1,<=*x*2,<=*y*2<=≤<=105) — positions of Captain Bill the Hummingbird and treasure respectively.

The second line contains two integer numbers *x*,<=*y* (1<=≤<=*x*,<=*y*<=≤<=105) — values on the potion bottle.","Print ""YES"" if it is possible for Captain to reach the treasure using the potion, otherwise print ""NO"" (without quotes).","['0 0 0 6\n2 3\n', '1 1 3 6\n1 5\n']","['YES\n', 'NO\n']","In the first example there exists such sequence of moves:
 1.  <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/7c939890fb4ed35688177327dac981bfa9216c00.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> — the first type of move 1.  <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/afbfa42fbac4e0641e7466e3aac74cbbb08ed597.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> — the third type of move",OK,"import a
input=a.stdin.readline
from collections import defaultdict as dc
from collections import Counter
from bisect import bisect_right, bisect_left,bisect
import math
from operator import itemgetter
from heapq import heapify, heappop, heappush
b,d,c,e=map(int,input().split())
x,y=map(int,input().split())
if abs(c-b)%x==0 and abs(e-d)%y==0 and (abs(c-b)//x)%2==(abs(e-d)//y)%2:
    print(""YES"")
else:
    print(""NO"")","import g

def e():

    b = g.stdin.read().split()
    if not b:
        return

    n = int(b[0])
    m = int(b[1])
    
    d = 2

    a = False

    for _ in range(m):

        k = int(b[d])
        d += 1

        c = {}
        
        j = True

        for i in range(k):
            f = int(b[d])
            d += 1
            i = abs(f)

            h = 'R' if f < 0 else 'M'
            
            if i not in c:
                c[i] = {h}
            else:
                c[i].add(h)

                if len(c[i]) > 1:
                    j = False

        if j:
            a = True
            break

    g.stdout.write(""YES\n"" if a else ""NO\n"")
    
if __name__ == '__main__':
    e()"
276,B,Little Girl and Game,PROGRAMMING,"['games', 'greedy']","The Little Girl loves problems on games very much. Here's one of them.

Two players have got a string *s*, consisting of lowercase English letters. They play a game that is described by the following rules:
 -  The players move in turns; In one move the player can remove an arbitrary letter from string *s*. -  If the player before his turn can reorder the letters in string *s* so as to get a palindrome, this player wins. A palindrome is a string that reads the same both ways (from left to right, and vice versa). For example, string ""abba"" is a palindrome and string ""abc"" isn't. 
Determine which player will win, provided that both sides play optimally well — the one who moves first or the one who moves second.","The input contains a single line, containing string *s* (1<=≤<=|*s*|<=<=≤<=<=103). String *s* consists of lowercase English letters.","In a single line print word ""First"" if the first player wins (provided that both players play optimally well). Otherwise, print word ""Second"". Print the words without the quotes.","['aba\n', 'abca\n']","['First\n', 'Second\n']",none,OK,"from sys import e, f
input, print = e.readline, f.write

def g():
    s = input()
    return s[:len(s)-1]

def c():
    s = g()
    b = [0 for _ in range(26)]
    for a in s:
        b[ord(a)-ord('a')] += 1
    d = 0
    for i in range(26):
        d += b[i] & 1
    if d == 0:
        print(""First\n"")
    elif len(s) & 1:
        print(""First\n"")
    else:
        print(""Second\n"")

if __name__ == ""__main__"":
    c()","import g

def b():

    a = g.stdin.read().splitlines()
    if not a:
        return

    n = int(a[0].strip())

    h = [a[i+1].strip() for i in range(n)]

    c = a[n+1].strip()

    e = ""<3"" + ""<3"".join(h) + ""<3""

    f = 0
    d = 0

    while f < len(e) and d < len(c):
        if e[f] == c[d]:

            f += 1

        d += 1

    if f == len(e):
        print(""yes"")
    else:
        print(""no"")

if __name__ == '__main__':
    b()"
380,C,Sereja and Brackets,PROGRAMMING,"['data structures', 'schedules']","Sereja has a bracket sequence *s*1,<=*s*2,<=...,<=*s**n*, or, in other words, a string *s* of length *n*, consisting of characters ""("" and "")"".

Sereja needs to answer *m* queries, each of them is described by two integers *l**i*,<=*r**i* (1<=≤<=*l**i*<=≤<=*r**i*<=≤<=*n*). The answer to the *i*-th query is the length of the maximum correct bracket subsequence of sequence *s**l**i*,<=*s**l**i*<=+<=1,<=...,<=*s**r**i*. Help Sereja answer all queries.

You can find the definitions for a subsequence and a correct bracket sequence in the notes.","The first line contains a sequence of characters *s*1,<=*s*2,<=...,<=*s**n* (1<=≤<=*n*<=≤<=106) without any spaces. Each character is either a ""("" or a "")"". The second line contains integer *m* (1<=≤<=*m*<=≤<=105) — the number of queries. Each of the next *m* lines contains a pair of integers. The *i*-th line contains integers *l**i*,<=*r**i* (1<=≤<=*l**i*<=≤<=*r**i*<=≤<=*n*) — the description of the *i*-th query.",Print the answer to each question on a single line. Print the answers in the order they go in the input.,['())(())(())(\n7\n1 1\n2 3\n1 2\n1 12\n8 12\n5 11\n2 10\n'],['0\n0\n2\n10\n4\n6\n6\n'],"A subsequence of length |*x*| of string *s* = *s*<sub class=""lower-index"">1</sub>*s*<sub class=""lower-index"">2</sub>... *s*<sub class=""lower-index"">|*s*|</sub> (where |*s*| is the length of string *s*) is string *x* = *s*<sub class=""lower-index"">*k*<sub class=""lower-index"">1</sub></sub>*s*<sub class=""lower-index"">*k*<sub class=""lower-index"">2</sub></sub>... *s*<sub class=""lower-index"">*k*<sub class=""lower-index"">|*x*|</sub></sub> (1 ≤ *k*<sub class=""lower-index"">1</sub> &lt; *k*<sub class=""lower-index"">2</sub> &lt; ... &lt; *k*<sub class=""lower-index"">|*x*|</sub> ≤ |*s*|).

A correct bracket sequence is a bracket sequence that can be transformed into a correct aryphmetic expression by inserting characters ""1"" and ""+"" between the characters of the string. For example, bracket sequences ""()()"", ""(())"" are correct (the resulting expressions ""(1)+(1)"", ""((1+1)+1)""), and "")("" and ""("" are not.

For the third query required sequence will be «()».

For the fourth query required sequence will be «()(())(())».",TIME_LIMIT_EXCEEDED,"import t
import 
from io import b, d

a = 8192

class c(d):
    s = 0

    def __init__({, n):
        {._fd = n.fileno()
        {.buffer = b()
        {.writable = ""x"" in n.mode or ""r"" not in n.mode
        {.write = {.buffer.write if {.writable else None

    def w({):
        while True:
            b = t.w({._fd, max(t.fstat({._fd).st_size, a))
            if not b:
                break
            u = {.buffer.tell()
            {.buffer.seek(0, 2), {.buffer.write(b), {.buffer.seek(u)
        {.s = 0
        return {.buffer.w()

    def x({):
        while {.s == 0:
            b = t.w({._fd, max(t.fstat({._fd).st_size, a))
            {.s = b.count(b""\n"") + (not b)
            u = {.buffer.tell()
            {.buffer.seek(0, 2), {.buffer.write(b), {.buffer.seek(u)
        {.s -= 1
        return {.buffer.x()

    def o({):
        if {.writable:
            t.write({._fd, {.buffer.getvalue())
            {.buffer.truncate(0), {.buffer.seek(0)

class e(d):

    def __init__({, n):
        {.buffer = c(n)
        {.o = {.buffer.o
        {.writable = {.buffer.writable
        {.write = lambda s: {.buffer.write(s.encode(""ascii""))
        {.w = lambda: {.buffer.w().decode(""ascii"")
        {.x = lambda: {.buffer.x().decode(""ascii"")

.stdin, .stdout = e(.stdin), e(.stdout)
input = lambda: .stdin.x().rstrip(""\r\n"")

def q(a, b):
    t = min(a[1], b[2])
    return [a[0]+b[0]+t, a[1]+b[1]-t, a[2]+b[2]-t]
    
class f:
    def __init__({, l, m=0, p=q):
        """"""initialize the segment tree with data""""""
        {._default = m
        {._func = p
        {._len = len(l)
        {.k = k = 1 << ({._len - 1).bit_length()

        {.l = [m] * (2 * k)
        {.l[k:k + {._len] = l
        for i in reversed(range(k)):
            {.l[i] = p({.l[i + i], {.l[i + i + 1])

    def g({, r):
        {[r] = {._default

    def h({, r):
        return {.l[r + {.k]

    def j({, r, ):
        r += {.k
        {.l[r] = 
        r >>= 1
        while r:
            {.l[r] = {._func({.l[2 * r], {.l[2 * r + 1])
            r >>= 1

    def i({):
        return {._len

    def v({, ~, ):
        """"""func of data[start, stop)""""""
        ~ += {.k
         += {.k

        y = z = {._default
        while ~ < :
            if ~ & 1:
                y = {._func(y, {.l[~])
                ~ += 1
            if  & 1:
                 -= 1
                z = {._func({.l[], z)
            ~ >>= 1
             >>= 1

        return {._func(y, z)

    def __repr__({):
        return ""SegmentTree({0})"".format({.l)
    
    
def }(s, q, m):
    n = len(s)
    l = list()
    for c in s:
        if c == '(':
            l.append([0, 1, 0])
        else:
            l.append([0, 0, 1])
    | = f(l, m=[0, 0, 0])
    for l, r in q:
        print(|.v(l-1, r)[0] * 2)
    return

s = input()
m = int(input())
q = list()
for i in range(m):
    q.append(list(map(int, input().split(' '))))

}(s, q, m)","def i(n):
    """"""Return list of all prime numbers up to n (inclusive).""""""
    b = [True] * (n + 1)
    b[0:2] = [False, False]
    for i in range(2, int(n**0.5) + 1):
        if b[i]:
            for j in range(i * i, n + 1, i):
                b[j] = False
    return [i for i, f in enumerate(b) if f]

def c():
    import j
    a = j.stdin.read().strip().split()
    if not a:
        return

    n = int(a[0])

    if n == 1:
        j.stdout.write(""0\n"")
        return

    g = i(n)
    h = []

    for p in g:
        if p > n:
            break
        h.append(p)
        e = p
        while e * p <= n:
            e *= p

        if e > p:
            h.append(e)

    d = []
    d.append(str(len(h)))
    d.append("" "".join(str(q) for q in h) + "" "")
    j.stdout.write(""\n"".join(d))
    
if __name__ == '__main__':
    c()"
237,C,Primes on Interval,PROGRAMMING,"['binary search', 'number theory', 'two pointers']","You've decided to carry out a survey in the theory of prime numbers. Let us remind you that a prime number is a positive integer that has exactly two distinct positive integer divisors.

Consider positive integers *a*, *a*<=+<=1, ..., *b* (*a*<=≤<=*b*). You want to find the minimum integer *l* (1<=≤<=*l*<=≤<=*b*<=-<=*a*<=+<=1) such that for any integer *x* (*a*<=≤<=*x*<=≤<=*b*<=-<=*l*<=+<=1) among *l* integers *x*, *x*<=+<=1, ..., *x*<=+<=*l*<=-<=1 there are at least *k* prime numbers. 

Find and print the required minimum *l*. If no value *l* meets the described limitations, print -1.","A single line contains three space-separated integers *a*,<=*b*,<=*k* (1<=≤<=*a*,<=*b*,<=*k*<=≤<=106; *a*<=≤<=*b*).","In a single line print a single integer — the required minimum *l*. If there's no solution, print -1.","['2 4 2\n', '6 13 1\n', '1 4 3\n']","['3\n', '4\n', '-1\n']",none,WRONG_ANSWER,"def a():
    l=0
    list=input().split(' ')
    for i in range(int(list[0]),int(list[1])+1):
        c=0
        for j in range(1,i+1):
            if i%j==0:
                c+=1
        if c==2:
            l+=1
    if l>=int(list[2]):
        print(int(list[1])-int(list[0])+1)
    else:
        print(-1)
a()","def b():
    import d

    a = d.stdin.read().strip().split()
    if not a:
        return
    n = int(a[0])
    k = int(a[1])

    e = [[0] * n for _ in range(n)]

    for i in range(n):
        e[i][i] = k

    for c in e:
        print("" "".join(map(str, c)))

if __name__ == ""__main__"":
    b()"
548,B,Mike and Fun,PROGRAMMING,"['brute force', 'dp', 'greedy', 'implementation']","Mike and some bears are playing a game just for fun. Mike is the judge. All bears except Mike are standing in an *n*<=×<=*m* grid, there's exactly one bear in each cell. We denote the bear standing in column number *j* of row number *i* by (*i*,<=*j*). Mike's hands are on his ears (since he's the judge) and each bear standing in the grid has hands either on his mouth or his eyes.

They play for *q* rounds. In each round, Mike chooses a bear (*i*,<=*j*) and tells him to change his state i. e. if his hands are on his mouth, then he'll put his hands on his eyes or he'll put his hands on his mouth otherwise. After that, Mike wants to know the score of the bears.

Score of the bears is the maximum over all rows of number of consecutive bears with hands on their eyes in that row.

Since bears are lazy, Mike asked you for help. For each round, tell him the score of these bears after changing the state of a bear selected in that round.","The first line of input contains three integers *n*, *m* and *q* (1<=≤<=*n*,<=*m*<=≤<=500 and 1<=≤<=*q*<=≤<=5000).

The next *n* lines contain the grid description. There are *m* integers separated by spaces in each line. Each of these numbers is either 0 (for mouth) or 1 (for eyes).

The next *q* lines contain the information about the rounds. Each of them contains two integers *i* and *j* (1<=≤<=*i*<=≤<=*n* and 1<=≤<=*j*<=≤<=*m*), the row number and the column number of the bear changing his state.","After each round, print the current score of the bears.",['5 4 5\n0 1 1 0\n1 0 0 1\n0 1 1 0\n1 0 0 1\n0 0 0 0\n1 1\n1 4\n1 1\n4 2\n4 3\n'],['3\n4\n3\n3\n4\n'],none,WRONG_ANSWER,"import c

def b(a,n):
	y = 0
	c = 0
	for i in range(n):
		d = ''.join(a[i])
		if '1' not in d:
			r = 0
		else:
			r = len(max(c.findall(""1+"",d),key=len))
		if(r > y):
			y = r
			c = i
	return [y,c]

def a(x):
	if(x == '1'):
		return '0'
	else:
		return '1'

n,m,q = map(int,input().split())

a = []
x = []

for i in range(n):
	x = list(input().split())
	a.append(x)

y = b(a,n)

for i in range(q):
	p,q = map(int,input().split())
	d = a[p-1][q-1]
	a[p-1][q-1] = a(a[p-1][q-1])
	if(p-1 == y[1]):
		if(d == '0'):
			y[0] += 1
		else:
			y = b(a,n)
	print(y[0])","n = int(input().strip())
t = list(input().strip())

a = [d for d in range(1, n + 1) if n % d == 0]
a.sort()

for d in a:

    t[:d] = t[:d][::-1]

print("""".join(t))"
833,A,The Meaningless Game,PROGRAMMING,"['math', 'number theory']","Slastyona and her loyal dog Pushok are playing a meaningless game that is indeed very interesting.

The game consists of multiple rounds. Its rules are very simple: in each round, a natural number *k* is chosen. Then, the one who says (or barks) it faster than the other wins the round. After that, the winner's score is multiplied by *k*2, and the loser's score is multiplied by *k*. In the beginning of the game, both Slastyona and Pushok have scores equal to one.

Unfortunately, Slastyona had lost her notepad where the history of all *n* games was recorded. She managed to recall the final results for each games, though, but all of her memories of them are vague. Help Slastyona verify their correctness, or, to put it another way, for each given pair of scores determine whether it was possible for a game to finish with such result or not.","In the first string, the number of games *n* (1<=≤<=*n*<=≤<=350000) is given.

Each game is represented by a pair of scores *a*, *b* (1<=≤<=*a*,<=*b*<=≤<=109) – the results of Slastyona and Pushok, correspondingly.","For each pair of scores, answer ""Yes"" if it's possible for a game to finish with given score, and ""No"" otherwise.

You can output each letter in arbitrary case (upper or lower).",['6\n2 4\n75 45\n8 8\n16 16\n247 994\n1000000000 1000000\n'],['Yes\nYes\nYes\nNo\nNo\nYes\n'],"First game might have been consisted of one round, in which the number 2 would have been chosen and Pushok would have won.

The second game needs exactly two rounds to finish with such result: in the first one, Slastyona would have said the number 5, and in the second one, Pushok would have barked the number 3.",TIME_LIMIT_EXCEEDED,"def a(a,b):
    if a<b:
        a,b=b,a 
    
    if b==0:
        return a 
    return a(b,a%b)

def b(x):
    i=1 
    j=5000
    while i<=j:
        m=(i+j)//2 

        t=m*m*m
        if t==x:
            return ""Yes""
        if t>x:
            j=m-1 
        else:
            i=m+1 
    return ""No""

def c(a,b):
    l=a(a,b)
    r=(a//l)*(b//l)
    x=l//r 
    return b(x)
    

for _ in range(int(input())):
    a,b=map(int, input().split())
    
    print(c(a,b))","import i

def b(n):

    e, c = 1, int((2 * n) ** 0.5) + 10
    while e < c:
        f = (e + c) // 2
        if f * (f + 1) // 2 < n:
            e = f + 1
        else:
            c = f
    m = e

    g = n - (m * (m - 1) // 2)

    return g

if __name__ == '__main__':

    a = i.stdin.read().strip().split()
    if a:
        h = []
        for d in a:
            if d.strip():
                n = int(d.strip())
                h.append(str(b(n)))

        i.stdout.write(""\n"".join(h))"
363,B,Fence,PROGRAMMING,"['brute force', 'dp']","There is a fence in front of Polycarpus's home. The fence consists of *n* planks of the same width which go one after another from left to right. The height of the *i*-th plank is *h**i* meters, distinct planks can have distinct heights.

Polycarpus has bought a posh piano and is thinking about how to get it into the house. In order to carry out his plan, he needs to take exactly *k* consecutive planks from the fence. Higher planks are harder to tear off the fence, so Polycarpus wants to find such *k* consecutive planks that the sum of their heights is minimal possible.

Write the program that finds the indexes of *k* consecutive planks with minimal total height. Pay attention, the fence is not around Polycarpus's home, it is in front of home (in other words, the fence isn't cyclic).","The first line of the input contains integers *n* and *k* (1<=≤<=*n*<=≤<=1.5·105,<=1<=≤<=*k*<=≤<=*n*) — the number of planks in the fence and the width of the hole for the piano. The second line contains the sequence of integers *h*1,<=*h*2,<=...,<=*h**n* (1<=≤<=*h**i*<=≤<=100), where *h**i* is the height of the *i*-th plank of the fence.","Print such integer *j* that the sum of the heights of planks *j*, *j*<=+<=1, ..., *j*<=+<=*k*<=-<=1 is the minimum possible. If there are multiple such *j*'s, print any of them.",['7 3\n1 2 6 1 1 7 1\n'],['3\n'],"In the sample, your task is to find three consecutive planks with the minimum sum of heights. In the given case three planks with indexes 3, 4 and 5 have the required attribute, their total height is 8.",OK,"def b(a, k):
    e=sum(a[:k])
    c=1
    f=e
    for i in range(k,len(a)):
        f-=a[i-k]
        f+=a[i]
        if f<e:
            e=f
            c=i-k+2
    return c
def d():
    n, k = list(map(int, input().split()))
    a = list(map(int, input().split()))
    print(b(a,k))
if __name__ == ""__main__"":
    d()","def d():
    import i

    c = i.stdin.read().split()
    if not c:
        return
    x = int(c[0])
    t = int(c[1])
    a = int(c[2])
    b = int(c[3])
    a = int(c[4])
    b = int(c[5])

    if x == 0:
        i.stdout.write(""YES"")
        return

    g = []
    for e in range(t):
        f = a - e * a

        if f < 0:
            break

        if f == x:
            i.stdout.write(""YES"")
            return
        g.append(f)

    h = set()
    for e in range(t):
        f = b - e * b
        if f < 0:
            break
        if f == x:
            i.stdout.write(""YES"")
            return
        h.add(f)

    for s in g:
        if (x - s) in h:
            i.stdout.write(""YES"")
            return

    i.stdout.write(""NO"")

if __name__ == '__main__':
    d()"
121,A,Lucky Sum,PROGRAMMING,['implementation'],"Petya loves lucky numbers. Everybody knows that lucky numbers are positive integers whose decimal representation contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.

Let *next*(*x*) be the minimum lucky number which is larger than or equals *x*. Petya is interested what is the value of the expression *next*(*l*)<=+<=*next*(*l*<=+<=1)<=+<=...<=+<=*next*(*r*<=-<=1)<=+<=*next*(*r*). Help him solve this problem.",The single line contains two integers *l* and *r* (1<=≤<=*l*<=≤<=*r*<=≤<=109) — the left and right interval limits.,"In the single line print the only number — the sum *next*(*l*)<=+<=*next*(*l*<=+<=1)<=+<=...<=+<=*next*(*r*<=-<=1)<=+<=*next*(*r*).

Please do not use the %lld specificator to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specificator.","['2 7\n', '7 7\n']","['33\n', '7\n']","In the first sample: *next*(2) + *next*(3) + *next*(4) + *next*(5) + *next*(6) + *next*(7) = 4 + 4 + 4 + 7 + 7 + 7 = 33

In the second sample: *next*(7) = 7",OK,"import o
import math
import bisect
import heapq
from bisect import bisect_right
from o import stdin, stdout

def e(): return map(
    int, o.stdin.readline().strip().split())

def c(): return int(o.stdin.readline())

def d(): return list(
    map(int, o.stdin.readline().strip().split()))
def f(n): return [list(
    map(int, o.stdin.readline().strip().split())) for _ in range(n)]

def g(): return o.stdin.readline().strip()

def m(x, y): return (x + y - 1) // y

def i(n, r, k):
    k.append(n)
    if n > r*10:
        return
    i((10*n)+4, r, k)
    i((10*n)+7, r, k)

def h(n, n):
    b = 0
    for i in range(1, len(n)):
        b += (n[i]*(min(n[i], n)-min(n[i-1], n)))
    return b

def a(l, r):

    j = []
    i(0, r, j)
    j = sorted(j)

    print(h(r, j)-h(l-1, j))

def l():

    l, r = e()
    a(l, r)

if __name__ == '__main__':
    l()","def c():
    import f

    a = f.stdin.read().split()
    if not a:
        return

    n = int(a[0])
    e = 0
    d = 0

    b = 1
    for i in range(n):

        x = int(a[b])
        y = int(a[b + 1])
        b += 2

        if x > 0:
            e += 1
        else:
            d += 1

    if e <= 1 or d <= 1:
        f.stdout.write(""Yes"")
    else:
        f.stdout.write(""No"")

if __name__ == '__main__':
    c()"
652,B,z-sort,PROGRAMMING,['sortings'],"A student of *z*-school found a kind of sorting called *z*-sort. The array *a* with *n* elements are *z*-sorted if two conditions hold:
 1.  *a**i*<=≥<=*a**i*<=-<=1 for all even *i*, 1.  *a**i*<=≤<=*a**i*<=-<=1 for all odd *i*<=&gt;<=1. 
For example the arrays [1,2,1,2] and [1,1,1,1] are *z*-sorted while the array [1,2,3,4] isn’t *z*-sorted.

Can you make the array *z*-sorted?","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=1000) — the number of elements in the array *a*.

The second line contains *n* integers *a**i* (1<=≤<=*a**i*<=≤<=109) — the elements of the array *a*.","If it's possible to make the array *a* *z*-sorted print *n* space separated integers *a**i* — the elements after *z*-sort. Otherwise print the only word ""Impossible"".","['4\n1 2 2 1\n', '5\n1 3 2 2 5\n']","['1 2 1 2\n', '1 5 2 3 2\n']",none,WRONG_ANSWER,"def c(b):
    for i in range(len(b)):
        if (i + 1) % 2 == 0:
            if a[i] < a[i - 1]:
                return False
        else:
            if a[i] > a[i - 1] and i > 1:
                return False
    return True

n = int(input())
a = list(map(int, input().split()))
d = False
for _ in range(10000):
    for i in range(len(a)):
        if (i + 1) % 2 == 0:
            if a[i] < a[i - 1]:
                a[i], a[i - 1] = a[i - 1], a[i]
        else:
            if a[i] > a[i - 1] and i > 1:
                a[i], a[i - 1] = a[i - 1], a[i]
    if c(a):
        d = True
        print(a)
        break
if not d:
    print('Impossible')","import p

def i():

    f = p.stdin.read().strip().splitlines()
    if not f:
        return

    n = int(f[0].strip())

    n = {}

    g = {i: [] for i in range(1, n + 1)}

    for h in f[1:]:
        if not h.strip():
            continue
        a, b, c = map(int, h.split())
        n[(a, b)] = c

        g[a].append(b)
        g[b].append(a)

    o = 1
    l = [o]

    k = g[o][0]
    m = o
    d = k
    while len(l) < n:
        l.append(d)

        if g[d][0] == m:
            j = g[d][1]
        else:
            j = g[d][0]
        m, d = d, j

    def a(e):
        q = 0
        L = len(e)
        for i in range(L):
            u = e[i]

            v = e[(i + 1) % L]

            if (u, v) in n:
                continue

            elif (v, u) in n:
                q += n[(v, u)]
        return q

    b = a(l)
    c = a(l[::-1])

    print(min(b, c))

if __name__ == '__main__':
    i()"
204,A,Little Elephant and Interval,PROGRAMMING,"['binary search', 'combinatorics', 'dp']","The Little Elephant very much loves sums on intervals.

This time he has a pair of integers *l* and *r* (*l*<=≤<=*r*). The Little Elephant has to find the number of such integers *x* (*l*<=≤<=*x*<=≤<=*r*), that the first digit of integer *x* equals the last one (in decimal notation). For example, such numbers as 101, 477474 or 9 will be included in the answer and 47, 253 or 1020 will not.

Help him and count the number of described numbers *x* for a given pair *l* and *r*.","The single line contains a pair of integers *l* and *r* (1<=≤<=*l*<=≤<=*r*<=≤<=1018) — the boundaries of the interval.

Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use cin, cout streams or the %I64d specifier.",On a single line print a single integer — the answer to the problem.,"['2 47\n', '47 1024\n']","['12\n', '98\n']","In the first sample the answer includes integers 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44.",WRONG_ANSWER,"p = [0, 1, 1]
p.extend([10 ** x for x in range(1,16)])

def d(f):
	if len(f) == 1:
		return int(f)
	elif len(f) == 2:
		return int(f[0]) + 8 if f[0] > f[1] else int(f[0]) + 9
	else:
		g = 18
		for i in range(3, len(f)):
			g += p[i] * 9
		c = int(f[0])
		e = int(f[-1])
		g += (c - 1) * (10 ** (len(f) - 2) )
		if c <= e:
			g += int(f[1:-1]) + 1

		return g

a, b = input().split()
a = (d(a))
b = (d(b))
print(b - a + 1 if a[0] == a[-1] else b - a  )","import n
import g

def b(n, e, m):

    c = [float('inf')] * (n + 1)

    j = [-1] * (n + 1)

    c[m] = 0
    f = [(0, m)]
    
    while f:
        d, u = g.heappop(f)

        if d != c[u]:
            continue

        for v, w in e[u]:
            if c[u] + w < c[v]:
                c[v] = c[u] + w
                j[v] = u
                g.heappush(f, (c[v], v))
    return c, j

def l(j, d):

    k = []
    a = d
    while a != -1:
        k.append(a)
        a = j[a]
    k.reverse()
    return k

def i():
    h = n.stdin.read().splitlines()
    if not h:
        return

    n, m = map(int, h[0].split())

    e = [[] for _ in range(n + 1)]

    for i in range(1, m + 1):
        a, b, w = map(int, h[i].split())
        e[a].append((b, w))
        e[b].append((a, w))

    c, j = b(n, e, 1)

    if c[n] == float('inf'):
        print(-1)
    else:
        k = l(j, n)

        print("" "".join(map(str, k)) + "" "")

if __name__ == ""__main__"":
    i()"
25,B,Phone numbers,PROGRAMMING,['implementation'],"Phone number in Berland is a sequence of *n* digits. Often, to make it easier to memorize the number, it is divided into groups of two or three digits. For example, the phone number 1198733 is easier to remember as 11-987-33. Your task is to find for a given phone number any of its divisions into groups of two or three digits.",The first line contains integer *n* (2<=≤<=*n*<=≤<=100) — amount of digits in the phone number. The second line contains *n* digits — the phone number to divide into groups.,"Output any of divisions of the given phone number into groups of two or three digits. Separate groups by single character -. If the answer is not unique, output any.","['6\n549871\n', '7\n1198733\n']","['54-98-71', '11-987-33\n']",none,WRONG_ANSWER,"def a():
    n=int(input())
    s=input()
    if n==2:
        print(s[0]+""-""+s[1])
        return 
    else:
        print(s[0]+""-""+s[1]+""-""+s[2:])
        return 

a();","import b

def a():

    s = b.stdin.read().strip()
    c = ""CODEFORCES""
    n = len(s)
    m = len(c)

    if n < m:
        print(""NO"")
        return

    for i in range(m + 1):

        if s[:i] == c[:i]:

            if s[n - (m - i):] == c[i:]:
                print(""YES"")
                return

    print(""NO"")

if __name__ == ""__main__"":
    a()"
847,G,University Classes,PROGRAMMING,['implementation'],"There are *n* student groups at the university. During the study day, each group can take no more than 7 classes. Seven time slots numbered from 1 to 7 are allocated for the classes.

The schedule on Monday is known for each group, i. e. time slots when group will have classes are known.

Your task is to determine the minimum number of rooms needed to hold classes for all groups on Monday. Note that one room can hold at most one group class in a single time slot.","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=1000) — the number of groups. 

Each of the following *n* lines contains a sequence consisting of 7 zeroes and ones — the schedule of classes on Monday for a group. If the symbol in a position equals to 1 then the group has class in the corresponding time slot. In the other case, the group has no class in the corresponding time slot.",Print minimum number of rooms needed to hold all groups classes on Monday.,"['2\n0101010\n1010101\n', '3\n0101011\n0011001\n0110111\n']","['1\n', '3\n']","In the first example one room is enough. It will be occupied in each of the seven time slot by the first group or by the second group.

In the second example three rooms is enough, because in the seventh time slot all three groups have classes.",OK,"import m, io, os
import math
import bisect
import heapq
import string
from collections import defaultdict,Counter,deque
input = m.stdin.readline
 
def I():
    return input()
 
def b():
    return int(input())
 
def f():
    return map(int, input().split())
 
def d():
    return list(input().split())
 
def e():
    return list(map(int, input().split()))
 
def a():
    return map(lambda x: int(x) - 1, input().split())
 
def c():
    return list(map(lambda x: int(x) - 1, input().split()))
 
def h(k):
  return print('\n'.join(map(str, k)))
 
def i(k):
  return print(' '.join(map(str, k)))
 
def g(k):
  return print(''.join(map(str, k)))

'''
n%4 == 0 and all_cnts <= n//4
'''

def l():
  n = b()
  j = [0] * 7
  for _ in range(n):
    for i, c in enumerate(I().strip()):
      j[i] += int(c)
  print(max(j))

l()","import q

def e(k):
    """"""
    Generate all possible substitutions from a pattern by replacing each '?'
    with either an empty string or one of 'a', 'b', 'c', 'd', 'e'.
    """"""
    p = []
    
    def f(g, c):
        if g == len(k):
            p.append(c)
            return
        if k[g] != '?':

            f(g + 1, c + k[g])
        else:

            f(g + 1, c)

            for a in ""abcde"":
                f(g + 1, c + a)
    
    f(0, """")
    return p

def i():

    h = q.stdin.read().splitlines()
    if not h:
        return

    d = h[0].split()
    N = int(d[0])
    M = int(d[1])

    t = h[1:1+N]
    m = h[1+N:1+N+M]

    s = {}
    for r in t:
        s[r] = s.get(r, 0) + 1

    l = {}
    n = []

    for j in m:
        if j in l:

            b = l[j]
        else:

            o = set(e(j))
            b = 0

            for s in o:
                b += s.get(s, 0)
            l[j] = b
        n.append(str(b))

    q.stdout.write(""\n"".join(n))

if __name__ == '__main__':
    i()"
913,B,Christmas Spruce,PROGRAMMING,"['implementation', 'trees']","Consider a rooted tree. A rooted tree has one special vertex called the root. All edges are directed from the root. Vertex *u* is called a child of vertex *v* and vertex *v* is called a parent of vertex *u* if there exists a directed edge from *v* to *u*. A vertex is called a leaf if it doesn't have children and has a parent.

Let's call a rooted tree a spruce if its every non-leaf vertex has at least 3 leaf children. You are given a rooted tree, check whether it's a spruce.

The definition of a rooted tree can be found [here](https://goo.gl/1dqvzz).","The first line contains one integer *n* — the number of vertices in the tree (3<=≤<=*n*<=≤<=1<=000). Each of the next *n*<=-<=1 lines contains one integer *p**i* (1<=≤<=*i*<=≤<=*n*<=-<=1) — the index of the parent of the *i*<=+<=1-th vertex (1<=≤<=*p**i*<=≤<=*i*).

Vertex 1 is the root. It's guaranteed that the root has at least 2 children.","Print ""Yes"" if the tree is a spruce and ""No"" otherwise.","['4\n1\n1\n1\n', '7\n1\n1\n1\n2\n2\n2\n', '8\n1\n1\n1\n1\n3\n3\n3\n']","['Yes\n', 'No\n', 'Yes\n']","The first example:

<img class=""tex-graphics"" src=""https://espresso.codeforces.com/8dd976913226df83d535dfa66193f5525f8471bc.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

The second example:

<img class=""tex-graphics"" src=""https://espresso.codeforces.com/44dad5804f5290a2e026c9c41a15151562df8682.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

It is not a spruce, because the non-leaf vertex 1 has only 2 leaf children.

The third example:

<img class=""tex-graphics"" src=""https://espresso.codeforces.com/cf84a9e1585707f4ab06eff8eb1120a49b5e1ef7.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>",OK,"n = int(input())
d = {1: []}
e = ""Yes""
for i in range(2,n+1):
    p = int(input())
    d[p].append(i)
    d[i] = []
    
for i in d:
    c = 0
    for a in d[i]:
        if len(d[a]) == 0:
            c += 1
    if 0 < c < 3 or (len(d[i]) > 0 and c == 0):
        e = ""No""
        break
            
def b(tree: dict) -> dict:
    pass
    
print(f""{e}"")

'''
Faulty test case result
13
---
1
2
2
2
1
6
6
6
1
10
10
10
'''","import h
from collections import a

def e():

    b = h.stdin.read().split()
    if not b:
        return

    n = int(b[0])

    g = list(map(int, b[1:]))

    d = a(g)

    f = max(g)

    c = [0] * (f + 1)

    c[1] = d.get(1, 0) * 1

    for i in range(2, f + 1):
        c[i] = max(c[i - 1], c[i - 2] + d.get(i, 0) * i)

    print(c[f])

if __name__ == ""__main__"":
    e()"
124,B,Permutations,PROGRAMMING,"['brute force', 'combinatorics', 'implementation']",You are given *n* *k*-digit integers. You have to rearrange the digits in the integers so that the difference between the largest and the smallest number was minimum. Digits should be rearranged by the same rule in all integers.,"The first line contains integers *n* and *k* — the number and digit capacity of numbers correspondingly (1<=≤<=*n*,<=*k*<=≤<=8). Next *n* lines contain *k*-digit positive integers. Leading zeroes are allowed both in the initial integers and the integers resulting from the rearranging of digits.",Print a single number: the minimally possible difference between the largest and the smallest number after the digits are rearranged in all integers by the same rule.,"['6 4\n5237\n2753\n7523\n5723\n5327\n2537\n', '3 3\n010\n909\n012\n', '7 5\n50808\n36603\n37198\n44911\n29994\n42543\n50156\n']","['2700\n', '3\n', '20522\n']","In the first sample, if we rearrange the digits in numbers as (3,1,4,2), then the 2-nd and the 4-th numbers will equal 5237 and 2537 correspondingly (they will be maximum and minimum for such order of digits).

In the second sample, if we swap the second digits and the first ones, we get integers 100, 99 and 102.",RUNTIME_ERROR,"def f(i,b):
    if len(b)==k:
        g.append(b[:])
    else:    
        for i in e:
            if (not i[i]):
                b.append(i)
                i[i]=True
                f(i,b)
                i[i]=False
                b.pop()

n,k = list(map(int,input().split()))
e = []
g = []
for i in range(k):
    e.append(i)
h = []
for i in range(n):
    x = input()
    h.append(x)
i = [False]*n
f(i,b=[])
a = float('inf')
for i in g:
    m = 0; c = float('inf')
    for j in h:
        d = j[i[0]]+j[i[1]]+j[i[2]]+j[i[3]]
        m = max(m,int(d))
        c = min(c,int(d))
    a = min(a,m-c)

print(a)","def j():
    import t, k
    l = 1000000007
    f = t.stdin.buffer.read().split()
    if not f:
        return
    n = int(f[0])
    d = list(map(int, f[1:]))

    g = {}
    c = 0
    for a in d:
        m = {}

        g = a

        m[g] = (1, 1)

        for h, (e, s) in g.items():
            n = k.gcd(h, a)
            a = e
            b = (s + e) % l
            if n in m:
                q, r = m[n]
                m[n] = ((q + a) % l, (r + b) % l)
            else:
                m[n] = (a % l, b % l)

        for i, (e, s) in m.items():
            if i > 1:
                c = (c + i * s) % l

        for i, (e, s) in m.items():
            if i in g:
                o, p = g[i]
                g[i] = ((o + e) % l, (p + s) % l)
            else:
                g[i] = (e, s)
                
    t.stdout.write(str(c % l))
    
if __name__ == '__main__':
    j()"
704,B,Ant Man,PROGRAMMING,"['dp', 'graphs', 'greedy']","Scott Lang is at war with Darren Cross. There are *n* chairs in a hall where they are, numbered with 1,<=2,<=...,<=*n* from left to right. The *i*-th chair is located at coordinate *x**i*. Scott is on chair number *s* and Cross is on chair number *e*. Scott can jump to all other chairs (not only neighboring chairs). He wants to start at his position (chair number *s*), visit each chair exactly once and end up on chair number *e* with Cross. 

As we all know, Scott can shrink or grow big (grow big only to his normal size), so at any moment of time he can be either small or large (normal). The thing is, he can only shrink or grow big while being on a chair (not in the air while jumping to another chair). Jumping takes time, but shrinking and growing big takes no time. Jumping from chair number *i* to chair number *j* takes |*x**i*<=-<=*x**j*| seconds. Also, jumping off a chair and landing on a chair takes extra amount of time. 

If Scott wants to jump to a chair on his left, he can only be small, and if he wants to jump to a chair on his right he should be large.

Jumping off the *i*-th chair takes:
 -  *c**i* extra seconds if he's small. -  *d**i* extra seconds otherwise (he's large). 
Also, landing on *i*-th chair takes:
 -  *b**i* extra seconds if he's small. -  *a**i* extra seconds otherwise (he's large). 
In simpler words, jumping from *i*-th chair to *j*-th chair takes exactly:
 -  |*x**i*<=-<=*x**j*|<=+<=*c**i*<=+<=*b**j* seconds if *j*<=&lt;<=*i*. -  |*x**i*<=-<=*x**j*|<=+<=*d**i*<=+<=*a**j* seconds otherwise (*j*<=&gt;<=*i*). 
Given values of *x*, *a*, *b*, *c*, *d* find the minimum time Scott can get to Cross, assuming he wants to visit each chair exactly once.","The first line of the input contains three integers *n*,<=*s* and *e* (2<=≤<=*n*<=≤<=5000,<=1<=≤<=*s*,<=*e*<=≤<=*n*,<=*s*<=≠<=*e*) — the total number of chairs, starting and ending positions of Scott.

The second line contains *n* integers *x*1,<=*x*2,<=...,<=*x**n* (1<=≤<=*x*1<=&lt;<=*x*2<=&lt;<=...<=&lt;<=*x**n*<=≤<=109).

The third line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a*1,<=*a*2,<=...,<=*a**n*<=≤<=109).

The fourth line contains *n* integers *b*1,<=*b*2,<=...,<=*b**n* (1<=≤<=*b*1,<=*b*2,<=...,<=*b**n*<=≤<=109).

The fifth line contains *n* integers *c*1,<=*c*2,<=...,<=*c**n* (1<=≤<=*c*1,<=*c*2,<=...,<=*c**n*<=≤<=109).

The sixth line contains *n* integers *d*1,<=*d*2,<=...,<=*d**n* (1<=≤<=*d*1,<=*d*2,<=...,<=*d**n*<=≤<=109).",Print the minimum amount of time Scott needs to get to the Cross while visiting each chair exactly once.,['7 4 3\n8 11 12 16 17 18 20\n17 16 20 2 20 5 13\n17 8 8 16 12 15 13\n12 4 16 4 15 7 6\n8 14 2 11 17 12 8\n'],['139\n'],"In the sample testcase, an optimal solution would be <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/5bbd3e094ffa5a72e263dfaec7aeaff795bc22a3.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>. Spent time would be 17 + 24 + 23 + 20 + 33 + 22 = 139.",WRONG_ANSWER,"import ¬,
from bisect import k , bisect_right 

def ¢(): return ¬.stdin.readline().strip()
def £(®,¥="" ""): return list(map(®, ¢().split(¥)))
def ±(x,¥=""\n"") : ¬.stdout.write(str(x) + ¥)
def ³(x): ±(""YES"" if x==True else ""NO"")
def ²(x): ±(""Yes"" if x==True else ""No"")
def ´(f,¥="" ""): ¬.stdout.write(¥.join(map(str,f)) + ""\n"") if f else None
def µ(f): ¬.stdout.write(""\n"".join(map(str,f)) + ""\n"") if f else None
def ¶(f):
    for a in f: ´(a)

from types import a
def l(f, «=[]):              
    def °(*e, **):
        if «:
            return f(*e, **)
        else:
            ­ = f(*e, **)
            while True:
                if type(­) is a:
                    «.append(­)
                    ­ = next(­)
                else:
                    «.pop()
                    if not «:
                        break
                    ­ = «[-1].send(­)
            return ­
    return °

b = float(""inf"") 
 = 10**9 + 7    

def h(a,b,) :
    ¤ = 1
    while b :
        if b % 2: 
            ¤ = ¤ * a % 
        a = a * a % 
        b //= 2
    return ¤

def (x,): return pow(x,-2,)      

def (n,):
     = [1]*(n+1)
    for i in range(2,n+1): [i] = (i*[i-1])%
    return 

def (n, r, , ) :
     = [n]
    y = ([r] * [n - r]) % 
    return ( * (y, )) % 

def (,):
     = .gcd(,)
     = (*)//
    return 

def ©():
    l, r = 0 , 
    ¤ = 0
    while l <= r :
         = (l+r)//2
        if * <=  :
            ¤ = 
            l =  + 1
        else :
            r = -1
    
    return ¤ + 0.1*(¤*¤ != )

def (f):
     = [0]*(len(f)+1)
    for i in range(len(f)): [i] = f[i] + [i-1]
    return 

def (f):
     = [0]*(len(f)+1)
    for i in range(len(f)): [i] = f[i] ^ [i-1]
    return 

def c(n):  return n*(n+1)//2
def d(l,r) : return c(r)-c(l-1)

def (,):
    return (([0]-[0])**2 + ([1]-[1])**2)**0.5
def (,):
    return abs([0]-[0]) + abs([1]-[1])

def t(n,r):
    ¤ = 1
    for i in range(r) : ¤ = ¤*(n-i)//(i+1)
    return ¤

def (g,n,):
    ¡ = [1]*n
    for i in range(1,n):
        ¡[i] = (g*¡[i-1]) % 
    return ¡

def (,¨,=-b,=1):
     = k(¨,)
    q = []
    for i in range(max(0,-2),min(len(¨),+3)) :
        if >0 and ¨[i] == :
             -= 1
            continue
        q.append(¨[i])
    return min(q, key=lambda x:abs(x-),default=-b)

def (f, =b):
    n = len(f)
    ¤ = []
    i = 0
    while i < n:
        ª = i
        while i+1 <n and f[i] == f[i+1] :
            i += 1
        if f[ª] != :
            ¤.append([f[ª],ª,i,i-ª+1])
        i += 1
    return ¤

def }() : return [(0,1),(1,0)]
def |() : return [(0,-1),(-1,0)]
def z(): return }() + |()
def {(): return z() + [(1,1),(1,-1),(-1,1),(-1,-1)]
def o(): return [(-2,-1),(-1,-2),(1,-2),(2,-1),(2,1),(1,2),(-1,2),(-2,1)]

def s(n): return bin(n).count(""1"")
def (, x): return s() <= x <= 
def j(w): return bin(w).replace('0b', '')
def x(i): return int(str(i),2)
def  (f):
     = len(j(max(f)))
    for x in f:
        v = j(x)
        ¤ = "" "".join(list(""0""*(-len(v))+v))
        ±( ¤ + f""   <- {x}"")

def m(n,¯=0): return ord(n) - ord('A' if ¯ else 'a')
def (n,¯=0): return chr(ord('A' if ¯ else 'a') + n)

def ¦(, r): return round(, r)
def (): ¬.stdout.()
def p(): .cache_clear()

''' ॐॐ _/\_ हर हर महादेव _/\_ ॐॐ '''

def §():
    n,s,e = £(int)
    X = £(int)
    A = £(int)
    B = £(int)
    C = £(int)
    D = £(int)

    ~ = [[b]*(n+10) for _ in range(n+10)]
    ~[0][0] = 0

    for i in range(n):
        for u in range(i+1):
            if i+1 == s:

                ~[i+1][u+1] = min(~[i+1][u+1], ~[i][u] - X[i] + D[i] )

                ~[i+1][u] = min(~[i+1][u], ~[i][u] + X[i] + C[i] )

                continue

            if i+1 == e:

                ~[i+1][u+1] = min(~[i+1][u+1], ~[i][u] - X[i] + B[i] )

                ~[i+1][u] = min(~[i+1][u], ~[i][u] + X[i] + A[i] )

                continue

             = u - (i+1 >s) - (i+1 >e)
            if  >=0 :
                ~[i+1][u+1] = min(~[i+1][u+1], ~[i][u] - 2*X[i] + D[i] + B[i] )

             = u - (i+1 >s)
            if >0:
                ~[i+1][u] = min(~[i+1][u], ~[i][u] + C[i]+B[i] )

             = u - (i+1 >e)
            if >0:
                ~[i+1][u] = min(~[i+1][u], ~[i][u] + A[i]+D[i] )

            ~[i+1][u-1] = min(~[i+1][u-1], ~[i][u] + 2*X[i] + A[i] + C[i])
    
    return ~[n][1]

±(§())","def h():
    import j

    b = j.stdin.read().strip().split()
    if not b:
        return

    n = int(b[0])

    c = {}
    d = {}

    e = 1
    for i in range(n):

        x = int(b[e])
        y = int(b[e + 1])
        e += 2

        f = x - y
        c[f] = c.get(f, 0) + 1

        g = x + y
        d[g] = d.get(g, 0) + 1

    i = 0
    for a in c.values():
        if a > 1:
            i += a * (a - 1) // 2
    for a in d.values():
        if a > 1:
            i += a * (a - 1) // 2

    j.stdout.write(str(i) + ""\n"")

if __name__ == '__main__':
    h()"
580,C,Kefa and Park,PROGRAMMING,"['dfs and similar', 'graphs', 'trees']","Kefa decided to celebrate his first big salary by going to the restaurant. 

He lives by an unusual park. The park is a rooted tree consisting of *n* vertices with the root at vertex 1. Vertex 1 also contains Kefa's house. Unfortunaely for our hero, the park also contains cats. Kefa has already found out what are the vertices with cats in them.

The leaf vertices of the park contain restaurants. Kefa wants to choose a restaurant where he will go, but unfortunately he is very afraid of cats, so there is no way he will go to the restaurant if the path from the restaurant to his house contains more than *m* consecutive vertices with cats. 

Your task is to help Kefa count the number of restaurants where he can go.","The first line contains two integers, *n* and *m* (2<=≤<=*n*<=≤<=105, 1<=≤<=*m*<=≤<=*n*) — the number of vertices of the tree and the maximum number of consecutive vertices with cats that is still ok for Kefa.

The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n*, where each *a**i* either equals to 0 (then vertex *i* has no cat), or equals to 1 (then vertex *i* has a cat).

Next *n*<=-<=1 lines contains the edges of the tree in the format ""*x**i* *y**i*"" (without the quotes) (1<=≤<=*x**i*,<=*y**i*<=≤<=*n*, *x**i*<=≠<=*y**i*), where *x**i* and *y**i* are the vertices of the tree, connected by an edge. 

It is guaranteed that the given set of edges specifies a tree.",A single integer — the number of distinct leaves of a tree the path to which from Kefa's home contains at most *m* consecutive vertices with cats.,"['4 1\n1 1 0 0\n1 2\n1 3\n1 4\n', '7 1\n1 0 1 1 0 0 0\n1 2\n1 3\n2 4\n2 5\n3 6\n3 7\n']","['2\n', '2\n']","Let us remind you that a tree is a connected graph on *n* vertices and *n* - 1 edge. A rooted tree is a tree with a special vertex called root. In a rooted tree among any two vertices connected by an edge, one vertex is a parent (the one closer to the root), and the other one is a child. A vertex is called a leaf, if it has no children.

Note to the first sample test: <img class=""tex-graphics"" src=""https://espresso.codeforces.com/785114b4b3f5336f02078c25750f87c5a1d0b4be.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> The vertices containing cats are marked red. The restaurants are at vertices 2, 3, 4. Kefa can't go only to the restaurant located at vertex 2.

Note to the second sample test: <img class=""tex-graphics"" src=""https://espresso.codeforces.com/e5c07640680c837aec99126d94287872e69aa09a.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> The restaurants are located at vertices 4, 5, 6, 7. Kefa can't go to restaurants 6, 7.",OK,"import sys
import math
from collections import Counter, defaultdict, deque
from functools import cmp_to_key

def e():
    return(int(input()))
def d():
    return(list(map(int,input().split())))
def f():
    s = input()
    return(list(s[:len(s)]))
def g():
    return(map(int,input().split()))

n,m=g()
i=d()
a=[[] for _ in range(n)]
for i in range(n-1):
    x,v = g()
    a[x-1].append(v-1)
    a[v-1].append(x-1)
k=[False]*n
k[0]=True
j=[]
j.append((0,0))
c=0
while j:
    u,b=j.pop()
    if i[u]==1:b+=1
    else:b=0
    if b>m:
        continue
    h=True
    for v in a[u]:
        if not k[v]:
            h=False
            k[v]=True
            j.append((v,b))
    if h:c+=1
print(c)","def a():

    n = int(input().strip())

    c = list(map(int, input().split()))

    e = sum(c)

    if e % 2 == 0:
        print(e)
        return

    d = None
    for b in c:
        if b % 2 == 1:
            if d is None or b < d:
                d = b

    if d is not None:
        print(e - d)
    else:

        print(0)

if __name__ == ""__main__"":
    a()"
0,none,none,none,['none'],"For a given positive integer *n* denote its *k*-rounding as the minimum positive integer *x*, such that *x* ends with *k* or more zeros in base 10 and is divisible by *n*.

For example, 4-rounding of 375 is 375·80<==<=30000. 30000 is the minimum integer such that it ends with 4 or more zeros and is divisible by 375.

Write a program that will perform the *k*-rounding of *n*.","The only line contains two integers *n* and *k* (1<=≤<=*n*<=≤<=109, 0<=≤<=*k*<=≤<=8).",Print the *k*-rounding of *n*.,"['375 4\n', '10000 1\n', '38101 0\n', '123456789 8\n']","['30000\n', '10000\n', '38101\n', '12345678900000000\n']",none,OK,"def a(a,b):
    if b==0:
        return a
    return a(b,a%b)
def b(a,b):
    return a*b//a(a,b)
n,k=map(int,input().split())
print(b(n,10**k))","def b():
    import f

    a = f.stdin.read().split()

    n = int(a[0])

    a = list(map(int, a[1:1 + n]))

    c = max(a)
    d = min(a)
    e = c - d
    
    print(e)

if __name__ == '__main__':
    b()"
895,D,String Mark,PROGRAMMING,"['combinatorics', 'math', 'strings']","At the Byteland State University marks are strings of the same length. Mark *x* is considered better than *y* if string *y* is lexicographically smaller than *x*.

Recently at the BSU was an important test work on which Vasya recived the mark *a*. It is very hard for the teacher to remember the exact mark of every student, but he knows the mark *b*, such that every student recieved mark strictly smaller than *b*.

Vasya isn't satisfied with his mark so he decided to improve it. He can swap characters in the string corresponding to his mark as many times as he like. Now he want to know only the number of different ways to improve his mark so that his teacher didn't notice something suspicious.

More formally: you are given two strings *a*, *b* of the same length and you need to figure out the number of different strings *c* such that:

1) *c* can be obtained from *a* by swapping some characters, in other words *c* is a permutation of *a*.

2) String *a* is lexicographically smaller than *c*.

3) String *c* is lexicographically smaller than *b*.

For two strings *x* and *y* of the same length it is true that *x* is lexicographically smaller than *y* if there exists such *i*, that *x*1<==<=*y*1,<=*x*2<==<=*y*2,<=...,<=*x**i*<=-<=1<==<=*y**i*<=-<=1,<=*x**i*<=&lt;<=*y**i*.

Since the answer can be very large, you need to find answer modulo 109<=+<=7.","First line contains string *a*, second line contains string *b*. Strings *a*,<=*b* consist of lowercase English letters. Their lengths are equal and don't exceed 106.

It is guaranteed that *a* is lexicographically smaller than *b*.",Print one integer  — the number of different strings satisfying the condition of the problem modulo 109<=+<=7.,"['abc\nddd\n', 'abcdef\nabcdeg\n', 'abacaba\nubuduba\n']","['5\n', '0\n', '64\n']","In first sample from string *abc* can be obtained strings *acb*, *bac*, *bca*, *cab*, *cba*, all of them are larger than *abc*, but smaller than *ddd*. So the answer is 5.

In second sample any string obtained from *abcdef* is larger than *abcdeg*. So the answer is 0.",TIME_LIMIT_EXCEEDED,"import itertools
A = str(input())
b = str(input())
b = []
def d(a):
    return ''.join(a)

def c(a, l, r):
    if l == r:
        if b > d(a) > A:
            b.append(d(a))
    else:
        for i in range(l, r + 1):
            a[l], a[i] = a[i], a[l]
            c(a, l + 1, r)
            a[l], a[i] = a[i], a[l]

c(list(A), 0, len(A) - 1)
print(len(set(b)))","import j

def f():

    c = j.stdin.read().strip().split()
    if not c:
        return
    n = int(c[0])
    i = list(map(int, c[1:]))

    e = [[0, 0] for _ in range(n + 1)]

    e[n][0] = 0
    e[n][1] = 0

    for i in range(n - 1, -1, -1):
        for p in [0, 1]:
            h = i[i] - e[i + 1][1 - p]
            g = -i[i] + e[i + 1][p]
            e[i][p] = max(h, g)

    d = e[0][1]
    k = sum(i)

    b = (k + d) // 2
    a = k - b

    print(f""{a} {b}"")

if __name__ == '__main__':
    f()"
822,A,I'm bored with life,PROGRAMMING,"['implementation', 'math', 'number theory']","Holidays have finished. Thanks to the help of the hacker Leha, Noora managed to enter the university of her dreams which is located in a town Pavlopolis. It's well known that universities provide students with dormitory for the period of university studies. Consequently Noora had to leave Vičkopolis and move to Pavlopolis. Thus Leha was left completely alone in a quiet town Vičkopolis. He almost even fell into a depression from boredom!

Leha came up with a task for himself to relax a little. He chooses two integers *A* and *B* and then calculates the greatest common divisor of integers ""*A* factorial"" and ""*B* factorial"". Formally the hacker wants to find out GCD(*A*!,<=*B*!). It's well known that the factorial of an integer *x* is a product of all positive integers less than or equal to *x*. Thus *x*!<==<=1·2·3·...·(*x*<=-<=1)·*x*. For example 4!<==<=1·2·3·4<==<=24. Recall that GCD(*x*,<=*y*) is the largest positive integer *q* that divides (without a remainder) both *x* and *y*.

Leha has learned how to solve this task very effective. You are able to cope with it not worse, aren't you?","The first and single line contains two integers *A* and *B* (1<=≤<=*A*,<=*B*<=≤<=109,<=*min*(*A*,<=*B*)<=≤<=12).",Print a single integer denoting the greatest common divisor of integers *A*! and *B*!.,['4 3\n'],['6\n'],"Consider the sample.

4! = 1·2·3·4 = 24. 3! = 1·2·3 = 6. The greatest common divisor of integers 24 and 6 is exactly 6.",OK,"def c(j,k):
    n=min(j,k)
    a=1
    for i in range(1,n+1):
        a*=i
    print(a)
j,k=[int(b) for b in input().split(' ')]
c(j,k)","def f():
    import g

    c = g.stdin.read().splitlines()
    if not c:
        return
    s = c[0].strip()

    b = s.count('1')

    t = []
    for a in s:
        if a != '1':
            t.append(a)
    t = """".join(t)

    d = t.find('2')
    if d == -1:

        e = t + ""1"" * b
    else:

        e = t[:d] + ""1"" * b + t[d:]

    g.stdout.write(e)

if __name__ == '__main__':
    f()"
807,A,Is it rated?,PROGRAMMING,"['implementation', 'sortings']","Is it rated?

Here it is. The Ultimate Question of Competitive Programming, Codeforces, and Everything. And you are here to answer it.

Another Codeforces round has been conducted. No two participants have the same number of points. For each participant, from the top to the bottom of the standings, their rating before and after the round is known.

It's known that if at least one participant's rating has changed, then the round was rated for sure.

It's also known that if the round was rated and a participant with lower rating took a better place in the standings than a participant with higher rating, then at least one round participant's rating has changed.

In this problem, you should not make any other assumptions about the rating system.

Determine if the current round is rated, unrated, or it's impossible to determine whether it is rated of not.","The first line contains a single integer *n* (2<=≤<=*n*<=≤<=1000) — the number of round participants.

Each of the next *n* lines contains two integers *a**i* and *b**i* (1<=≤<=*a**i*,<=*b**i*<=≤<=4126) — the rating of the *i*-th participant before and after the round, respectively. The participants are listed in order from the top to the bottom of the standings.","If the round is rated for sure, print ""rated"". If the round is unrated for sure, print ""unrated"". If it's impossible to determine whether the round is rated or not, print ""maybe"".","['6\n3060 3060\n2194 2194\n2876 2903\n2624 2624\n3007 2991\n2884 2884\n', '4\n1500 1500\n1300 1300\n1200 1200\n1400 1400\n', '5\n3123 3123\n2777 2777\n2246 2246\n2246 2246\n1699 1699\n']","['rated\n', 'unrated\n', 'maybe\n']","In the first example, the ratings of the participants in the third and fifth places have changed, therefore, the round was rated.

In the second example, no one's rating has changed, but the participant in the second place has lower rating than the participant in the fourth place. Therefore, if the round was rated, someone's rating would've changed for sure.

In the third example, no one's rating has changed, and the participants took places in non-increasing order of their rating. Therefore, it's impossible to determine whether the round is rated or not.",OK,"def d():
    return map(int, input().split())

def b():
    return [int(x) for x in input().split()]

def e(a):
    print(*a, sep=' ')

n = int(input())
c, max = 0, 4127
for i in range(n):
    a, b = d()
    if (a == b):
        if(a<=max):
            c += 1
            max=a
    else:
        print('rated')
        exit()
if(c==n):
    print('maybe')
else:
    print('unrated')","import c

def b():

    a, b, n = map(int, input().split())

    a = 0
    while True:
        if a == 0:

            d = c.gcd(a, n)
        else:

            d = c.gcd(b, n)

        if n < d:
            print(a)
            break

        n -= d

        a = 1 - a

if __name__ == ""__main__"":
    b()"
768,A,Oath of the Night's Watch,PROGRAMMING,"['constructive algorithms', 'sortings']","""Night gathers, and now my watch begins. It shall not end until my death. I shall take no wife, hold no lands, father no children. I shall wear no crowns and win no glory. I shall live and die at my post. I am the sword in the darkness. I am the watcher on the walls. I am the shield that guards the realms of men. I pledge my life and honor to the Night's Watch, for this night and all the nights to come."" — The Night's Watch oath.

With that begins the watch of Jon Snow. He is assigned the task to support the stewards.

This time he has *n* stewards with him whom he has to provide support. Each steward has his own strength. Jon Snow likes to support a steward only if there exists at least one steward who has strength strictly less than him and at least one steward who has strength strictly greater than him.

Can you find how many stewards will Jon support?","First line consists of a single integer *n* (1<=≤<=*n*<=≤<=105) — the number of stewards with Jon Snow.

Second line consists of *n* space separated integers *a*1,<=*a*2,<=...,<=*a**n* (0<=≤<=*a**i*<=≤<=109) representing the values assigned to the stewards.",Output a single integer representing the number of stewards which Jon will feed.,"['2\n1 5\n', '3\n1 2 5\n']","['0', '1']","In the first sample, Jon Snow cannot support steward with strength 1 because there is no steward with strength less than 1 and he cannot support steward with strength 5 because there is no steward with strength greater than 5.

In the second sample, Jon Snow can support steward with strength 2 because there are stewards with strength less than 2 and greater than 2.",OK,"n = int(input())
a = list(map(int, input().split()))
def b(g):
    if len(g) <= 2:
        print(0)
        return
    f = g[0]
    e = g[0]
    h = 0
    for d in range(len(g)):
        c = g[d]
        f = min(f, c)
        e = max(e, c)
    for d in range(len(g)):
        c = g[d]
        if c > f and c < e:
            h += 1
    print(h)
    return
b(a)","def c():
    import d

    b = d.stdin.read().split()
    if not b:
        return
    T, S, q = map(int, b)

    a = 0

    while S < T:

        S *= q
        a += 1

    d.stdout.write(str(a))

if __name__ == '__main__':
    c()"
959,B,Mahmoud and Ehab and the message,PROGRAMMING,"['dsu', 'greedy', 'implementation']","Mahmoud wants to send a message to his friend Ehab. Their language consists of *n* words numbered from 1 to *n*. Some words have the same meaning so there are *k* groups of words such that all the words in some group have the same meaning.

Mahmoud knows that the *i*-th word can be sent with cost *a**i*. For each word in his message, Mahmoud can either replace it with another word of the same meaning or leave it as it is. Can you help Mahmoud determine the minimum cost of sending the message?

The cost of sending the message is the sum of the costs of sending every word in it.","The first line of input contains integers *n*, *k* and *m* (1<=≤<=*k*<=≤<=*n*<=≤<=105,<=1<=≤<=*m*<=≤<=105) — the number of words in their language, the number of groups of words, and the number of words in Mahmoud's message respectively.

The second line contains *n* strings consisting of lowercase English letters of length not exceeding 20 which represent the words. It's guaranteed that the words are distinct.

The third line contains *n* integers *a*1, *a*2, ..., *a**n* (1<=≤<=*a**i*<=≤<=109) where *a**i* is the cost of sending the *i*-th word.

The next *k* lines describe the groups of words of same meaning. The next *k* lines each start with an integer *x* (1<=≤<=*x*<=≤<=*n*) which means that there are *x* words in this group, followed by *x* integers which represent the indices of words in this group. It's guaranteed that each word appears in exactly one group.

The next line contains *m* space-separated words which represent Mahmoud's message. Each of these words appears in the list of language's words.",The only line should contain the minimum cost to send the message after replacing some words (maybe none) with some words of the same meaning.,"['5 4 4\ni loser am the second\n100 1 1 5 10\n1 1\n1 3\n2 2 5\n1 4\ni am the second\n', '5 4 4\ni loser am the second\n100 20 1 5 10\n1 1\n1 3\n2 2 5\n1 4\ni am the second\n']","['107', '116']","In the first sample, Mahmoud should replace the word ""second"" with the word ""loser"" because it has less cost so the cost will be 100+1+5+1=107.

In the second sample, Mahmoud shouldn't do any replacement so the cost will be 100+1+5+10=116.",WRONG_ANSWER,"def c(b,a):
	if b[a]==a:
		return b[a]
	b[a]=c(b,b[a])
	return b[a]
 
def f(b,l,d,a,b,i,j):
	x=c(b,a)
	y=c(b,b)
	if x!=y:
		if l[i]<l[j]:
			b[y]=x
		else:
			b[x]=y
   
n,k,m=map(int,input().split())
s=input().split()
d={}
b={}
e={}
for i in range(n):
	d[i+1]=s[i]
	b[s[i]]=s[i]

l=list(map(int,input().split()))
for i in range(n):
	e[s[i]]=l[i]
for _ in range(k):
	x=list(map(int,input().split()))
	e=d[x[1]]
	g=l[x[1]-1]
	for i in range(2,len(x)):
		f(b,l,d,d[x[i]],d[x[i-1]],i,i-1)
d=input().split()

a=0

for i in d:
	a+=e[b[i]]
print(a)","import f

def e():

    c = f.stdin.read().splitlines()
    if not c:
        return

    s, n = map(int, c[0].split())
    b = []

    for d in c[1:]:
        if d.strip():
            x, y = map(int, d.split())
            b.append((x, y))

    b.sort(key=lambda a: a[0])

    for x, y in b:

        if s > x:
            s += y
        else:
            print(""NO"")
            return

    print(""YES"")

if __name__ == ""__main__"":
    e()"
55,B,Smallest number,PROGRAMMING,['brute force'],"Recently, Vladimir got bad mark in algebra again. To avoid such unpleasant events in future he decided to train his arithmetic skills. He wrote four integer numbers *a*, *b*, *c*, *d* on the blackboard. During each of the next three minutes he took two numbers from the blackboard (not necessarily adjacent) and replaced them with their sum or their product. In the end he got one number. Unfortunately, due to the awful memory he forgot that number, but he remembers four original numbers, sequence of the operations and his surprise because of the very small result. Help Vladimir remember the forgotten number: find the smallest number that can be obtained from the original numbers by the given sequence of operations.","First line contains four integers separated by space: 0<=≤<=*a*,<=*b*,<=*c*,<=*d*<=≤<=1000 — the original numbers. Second line contains three signs ('+' or '*' each) separated by space — the sequence of the operations in the order of performing. ('+' stands for addition, '*' — multiplication)","Output one integer number — the minimal result which can be obtained.

Please, do not use %lld specificator to read or write 64-bit integers in C++. It is preffered to use cin (also you may use %I64d).","['1 1 1 1\n+ + *\n', '2 2 2 2\n* * +\n', '1 2 3 4\n* + +\n']","['3\n', '8\n', '9\n']",none,OK,"def d(c):
    if c==3:
        for x in b:
            if x>=0:
                a[0]=min(a[0],x)
        return 
    for i in range(4):
        if b[i] !=-1:
            for j in range(4):
                if i==j or b[j]==-1:
                    continue
                a,b=b[i],b[j]
                if s[c]=='+':
                    b[j]=a+b
                    b[i]=-1
                    d(c+1)
                    b[j]=b
                    b[i]=a
                elif s[c]=='*':
                    b[j]=a*b
                    b[i]=-1
                    d(c+1)
                    b[j]=b
                    b[i]=a
        else:
            continue
        
a=[float('inf')]
b=list(map(int,input().split()))
s=input().split()
d(0)
print(*a)","import 
import math
import t

.setrecursionlimit(10**7)
v = .stdin.read().split()
if not v:
    .exit(0)
w = iter(v)
n = int(next(w))
m = int(next(w))

~ = [int(next(w)) for _ in range(n)]

 = [(~[i], i) for i in range(n)]

f = {}
for p, u in :
    if p not in f:
        f[p] = []
    f[p].append(u)

m = {}
for x, y in f.items():
    m[x] = len(y)

i = set(f.keys())

 = [int(next(w)) for _ in range(m)]

 = []
for j, s in enumerate():
    x = s
    t = 0
     = set()
    while True:
        if x in i and x not in :
            .append((j, x, t))
            .add(x)
        if x == 1:
            break
        | = (x + 1) // 2
        if | == x:
            break
        t += 1
        x = |

h = list(f.keys())
h.sort()
G = len(h)
s = {}
for i,  in enumerate(h):
    s[] = m + 1 + i
N = m + G + 2
 = 0
 = N - 1

r = [[] for _ in range(N)]
a = 10**18

def b(q, , d, k):
    r[q].append([, d, k, len(r[])])
    r[].append([q, 0, -k, len(r[q]) - 1])

for j in range(m):
    b(, 1 + j, 1, 0)

for (, o, l) in :
    u = 1 + 
     = s[o]
    b(u, , 1, l)

for , d in m.items():
    u = s[]
    b(u, , d, 0)

def {(s, t, f):
     = 0
    N = len(r)
    n = [0] * N
    h = [0] * N
     = [0] * N
     = [0] * N
    p = 0
    while f > 0:
        for i in range(N):
            n[i] = a
        n[s] = 0
         = [(0, s)]
        while :
            d, v = t.heappop()
            if n[v] != d:
                continue
            for i, e in enumerate(r[v]):
                , d, k,  = e
                if d > 0 and n[] > d + k + h[v] - h[]:
                    n[] = d + k + h[v] - h[]
                    [] = v
                    [] = i
                    t.heappush(, (n[], ))
        if n[t] == a:
            break
        for v in range(N):
            if n[v] < a:
                h[v] += n[v]
        d = f
        v = t
        while v != s:
            d = min(d, r[[v]][[v]][1])
            v = [v]
        f -= d
        p += d
         += d * h[t]
        v = t
        while v != s:
            e = r[[v]][[v]]
            e[1] -= d
            r[v][e[3]][1] += d
            v = [v]
    return p, 

z = min(n, m)
p, k = {(, , z)

c = p
u = k

 = [0] * m

j = [0] * n

 = {}
for j in range(m):
     = 1 + j
    for e in r[]:
        , d, l,  = e

        if  >= m+1 and  <  and d == 0:

            e = None
            for  in h:
                if s[] == :
                    e = 
                    break
            [j] = (e, l)
            [j] = l
            break

for  in f:
    f[] = list(f[])

for , (, c) in .items():
    if f[]:
        g = f[].pop()

        j[g] =  + 1

} = []
}.append(f""{c} {u}"")
}.append("" "".join(str(x) for x in ))
}.append("" "".join(str(x) for x in j))
.stdout.write(""\n"".join(}))"
701,A,Cards,PROGRAMMING,"['greedy', 'implementation']","There are *n* cards (*n* is even) in the deck. Each card has a positive integer written on it. *n*<=/<=2 people will play new card game. At the beginning of the game each player gets two cards, each card is given to exactly one player. 

Find the way to distribute cards such that the sum of values written of the cards will be equal for each player. It is guaranteed that it is always possible.","The first line of the input contains integer *n* (2<=≤<=*n*<=≤<=100) — the number of cards in the deck. It is guaranteed that *n* is even.

The second line contains the sequence of *n* positive integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=100), where *a**i* is equal to the number written on the *i*-th card.","Print *n*<=/<=2 pairs of integers, the *i*-th pair denote the cards that should be given to the *i*-th player. Each card should be given to exactly one player. Cards are numbered in the order they appear in the input.

It is guaranteed that solution exists. If there are several correct answers, you are allowed to print any of them.","['6\n1 5 7 4 4 3\n', '4\n10 10 10 10\n']","['1 3\n6 2\n4 5\n', '1 2\n3 4\n']","In the first sample, cards are distributed in such a way that each player has the sum of numbers written on his cards equal to 8. 

In the second sample, all values *a*<sub class=""lower-index"">*i*</sub> are equal. Thus, any distribution is acceptable.",OK,"def f(e,i,j):
	g=e[i]
	e[i]=e[j]
	e[j]=g

def c(n,e):
	i=1
	d=[]
	while i<=n:
		d.append(i)
		i+=1
	i=0
	while i<n-1:
		j=i+1
		while j<n:
			if(e[j]<e[i]):
				f(e,i,j)
				f(d,i,j)
			j+=1
		i+=1

	return d

def a(n, e):
	b= c(n,e)
	i=1
	j=n
	while(i<=n/2):
		print(str(b[i-1])+"" ""+str(b[j-1]))
		i+=1
		j-=1

n = int(input())
e = [int(x) for x in input().split()]

a(n,e)","def h():
    import k
    from collections import e

    d = k.stdin.read().split()
    if not d:
        return
    n = int(d[0])

    a = [0] * (n + 1)
    for i in range(1, n + 1):
        a[i] = int(d[i])

    a = 10 ** 9
    f = [a] * (n + 1)
    f[1] = 0

    g = e([1])
    
    while g:
        b = g.popleft()
        c = f[b]

        if b - 1 >= 1 and f[b - 1] > c + 1:
            f[b - 1] = c + 1
            g.append(b - 1)

        if b + 1 <= n and f[b + 1] > c + 1:
            f[b + 1] = c + 1
            g.append(b + 1)

        i = a[b]

        if i >= b and i <= n and f[i] > c + 1:
            f[i] = c + 1
            g.append(i)

    j = "" "".join(str(f[i]) for i in range(1, n + 1))
    k.stdout.write(j + ""\n"")

if __name__ == ""__main__"":
    h()"
415,B,Mashmokh and Tokens,PROGRAMMING,"['binary search', 'greedy', 'implementation', 'math']","Bimokh is Mashmokh's boss. For the following *n* days he decided to pay to his workers in a new way. At the beginning of each day he will give each worker a certain amount of tokens. Then at the end of each day each worker can give some of his tokens back to get a certain amount of money. The worker can save the rest of tokens but he can't use it in any other day to get more money. If a worker gives back *w* tokens then he'll get  dollars. 

Mashmokh likes the tokens however he likes money more. That's why he wants to save as many tokens as possible so that the amount of money he gets is maximal possible each day. He has *n* numbers *x*1,<=*x*2,<=...,<=*x**n*. Number *x**i* is the number of tokens given to each worker on the *i*-th day. Help him calculate for each of *n* days the number of tokens he can save.","The first line of input contains three space-separated integers *n*,<=*a*,<=*b* (1<=≤<=*n*<=≤<=105; 1<=≤<=*a*,<=*b*<=≤<=109). The second line of input contains *n* space-separated integers *x*1,<=*x*2,<=...,<=*x**n* (1<=≤<=*x**i*<=≤<=109).",Output *n* space-separated integers. The *i*-th of them is the number of tokens Mashmokh can save on the *i*-th day.,"['5 1 4\n12 6 11 9 1\n', '3 1 2\n1 2 3\n', '1 1 1\n1\n']","['0 2 3 1 1 ', '1 0 1 ', '0 ']",none,OK,"""""""
Codeforces Round 240 Div 1 Problem B

Author  : chaotic_iak
Language: Python 3.3.4
""""""

class b(object):
    d = []

    def c(f, n = 0):
        e = """"
        d = f.d
        if not d: d.extend(input().split("" ""))
        if n == 0:
            e = d[:]
            d[:] = []
        while n > len(d):
            d.extend(input().split("" ""))
        if n > 0:
            e = d[:n]
            d[:n] = []
        return e
a = b()
g = a.c

n,a,b = g()
n,a,b = int(n),int(a),int(b)
c = [int(x) for x in g()]
r = []
for i in c:
    r.append(str(((i*a) % b) // a))
print("" "".join(r))","def c():

    n = int(input().strip())

    b = 0

    for _ in range(n):

        a = list(map(int, input().split()))

        if sum(a) >= 2:
            b += 1

    print(b)

if __name__ == '__main__':
    c()"
217,A,Ice Skating,PROGRAMMING,"['brute force', 'dfs and similar', 'dsu', 'graphs']","Bajtek is learning to skate on ice. He's a beginner, so his only mode of transportation is pushing off from a snow drift to the north, east, south or west and sliding until he lands in another snow drift. He has noticed that in this way it's impossible to get from some snow drifts to some other by any sequence of moves. He now wants to heap up some additional snow drifts, so that he can get from any snow drift to any other one. He asked you to find the minimal number of snow drifts that need to be created.

We assume that Bajtek can only heap up snow drifts at integer coordinates.","The first line of input contains a single integer *n* (1<=≤<=*n*<=≤<=100) — the number of snow drifts. Each of the following *n* lines contains two integers *x**i* and *y**i* (1<=≤<=*x**i*,<=*y**i*<=≤<=1000) — the coordinates of the *i*-th snow drift.

Note that the north direction coinсides with the direction of *Oy* axis, so the east direction coinсides with the direction of the *Ox* axis. All snow drift's locations are distinct.",Output the minimal number of snow drifts that need to be created in order for Bajtek to be able to reach any snow drift from any other one.,"['2\n2 1\n1 2\n', '2\n2 1\n4 1\n']","['1\n', '0\n']",none,RUNTIME_ERROR,"def c(k, f):
  k.remove(f)
  if len(k) > 0:
    j = d(k, f)
    for p in j:
      c(k, p)

def e(g, h):
  return g[0] == h[0] or g[1] == h[1]

def d(k, f):
  i = []
  for p in k:
    if (p != f and e(f, p)):
      i.append(p)
  return i

if __name__ == ""__main__"":
  n = int(input())
  k = []
  l = 0

  for i in range(n):
    b = [int(n) for n in input().split(' ')]
    k.append(b)

  a = k.copy()

  for f in a:
    if f in k:
      c(k, f)
      l += 1

  print(l - 1)","def j():
    import n
    d = n.stdin.read().split()
    if not d:
        return

    n = int(d[0])
    m = int(d[1])

    g = list(map(int, d[2:2 + m]))

    f = {}

    for i in range(m - 1):
        b = g[i]
        k = g[i + 1]

        e = k - b
        if e <= 0:
            e += n

        if b in f:
            if f[b] != e:

                n.stdout.write(""-1"")
                return
        else:
            f[b] = e

    o = set()
    for m, p in f.items():
        if p in o:
            n.stdout.write(""-1"")
            return
        o.add(p)

    a = [None] * n

    for m, p in f.items():
        a[m - 1] = p

    i = [l for l in range(1, n + 1) if l not in o]
    h = 0
    for i in range(n):
        if a[i] is None:
            a[i] = i[h]
            h += 1

    c = g[0]
    for i in range(m - 1):
        a = a[c - 1]

        c = ((c - 1 + a) % n) + 1
        if c != g[i + 1]:
            n.stdout.write(""-1"")
            return

    n.stdout.write("" "".join(map(str, a)))
    
if __name__ == '__main__':
    j()"
519,B,A and B and Compilation Errors,PROGRAMMING,"['data structures', 'implementation', 'sortings']","A and B are preparing themselves for programming contests.

B loves to debug his code. But before he runs the solution and starts debugging, he has to first compile the code.

Initially, the compiler displayed *n* compilation errors, each of them is represented as a positive integer. After some effort, B managed to fix some mistake and then another one mistake.

However, despite the fact that B is sure that he corrected the two errors, he can not understand exactly what compilation errors disappeared — the compiler of the language which B uses shows errors in the new order every time! B is sure that unlike many other programming languages, compilation errors for his programming language do not depend on each other, that is, if you correct one error, the set of other error does not change.

Can you help B find out exactly what two errors he corrected?","The first line of the input contains integer *n* (3<=≤<=*n*<=≤<=105) — the initial number of compilation errors.

The second line contains *n* space-separated integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=109) — the errors the compiler displayed for the first time. 

The third line contains *n*<=-<=1 space-separated integers *b*1,<=*b*2,<=...,<=*b**n*<=-<=1 — the errors displayed at the second compilation. It is guaranteed that the sequence in the third line contains all numbers of the second string except for exactly one. 

The fourth line contains *n*<=-<=2 space-separated integers *с*1,<=*с*2,<=...,<=*с**n*<=-<=2 — the errors displayed at the third compilation. It is guaranteed that the sequence in the fourth line contains all numbers of the third line except for exactly one.","Print two numbers on a single line: the numbers of the compilation errors that disappeared after B made the first and the second correction, respectively.","['5\n1 5 8 123 7\n123 7 5 1\n5 1 7\n', '6\n1 4 3 3 5 7\n3 7 5 4 3\n4 3 7 5\n']","['8\n123\n', '1\n3\n']","In the first test sample B first corrects the error number 8, then the error number 123.

In the second test sample B first corrects the error number 1, then the error number 3. Note that if there are multiple errors with the same number, B can correct only one of them in one step.",OK,"from sys import b
def input(): return b.readline()[:-1]
n=int(input())
a=list(map(int,input().split()))
b=list(map(int,input().split()))
c=list(map(int,input().split()))
l=a+b
a=l[0]
for i in range(1,2*n-1):
	a^=l[i]
print(a)
l=b+c
a=l[0]
for i in range(1,2*n-3):
	a^=l[i]
print(a)","def h():
    import k
    e = k.stdin.read().splitlines()
    if not e:
        return

    f = e[0].strip()
    i = f.split()
    n = int(i[0])
    m = int(i[1])

    b = []

    d = [0] * (n + 1)
    c = [0] * (n + 1)
    
    l = 0

    for i in range(1, n + 1):
        g = e[i].strip()
        n = g[0]
        a = int(g[1:])
        b.append((n, a))
        if n == '+':
            d[a] += 1
        else:
            c[a] += 1
            l += 1

    o = []
    for c in range(1, n + 1):
        m = l - c[c] + d[c]
        if m == m:
            o.append(c)

    p = set(o)

    j = []
    for n, a in b:
        if n == '+':
            if all(c == a for c in p):
                j.append(""Truth"")
            elif all(c != a for c in p):
                j.append(""Lie"")
            else:
                j.append(""Not defined"")
        else:
            if all(c != a for c in p):
                j.append(""Truth"")
            elif all(c == a for c in p):
                j.append(""Lie"")
            else:
                j.append(""Not defined"")

    k.stdout.write(""\n"".join(j))

if __name__ == '__main__':
    h()"
464,E,The Classic Problem,PROGRAMMING,"['data structures', 'graphs', 'shortest paths']",You are given a weighted undirected graph on *n* vertices and *m* edges. Find the shortest path from vertex *s* to vertex *t* or else state that such path doesn't exist.,"The first line of the input contains two space-separated integers — *n* and *m* (1<=≤<=*n*<=≤<=105; 0<=≤<=*m*<=≤<=105).

Next *m* lines contain the description of the graph edges. The *i*-th line contains three space-separated integers — *u**i*, *v**i*, *x**i* (1<=≤<=*u**i*,<=*v**i*<=≤<=*n*; 0<=≤<=*x**i*<=≤<=105). That means that vertices with numbers *u**i* and *v**i* are connected by edge of length 2*x**i* (2 to the power of *x**i*).

The last line contains two space-separated integers — the numbers of vertices *s* and *t*.

The vertices are numbered from 1 to *n*. The graph contains no multiple edges and self-loops.","In the first line print the remainder after dividing the length of the shortest path by 1000000007 (109<=+<=7) if the path exists, and -1 if the path doesn't exist.

If the path exists print in the second line integer *k* — the number of vertices in the shortest path from vertex *s* to vertex *t*; in the third line print *k* space-separated integers — the vertices of the shortest path in the visiting order. The first vertex should be vertex *s*, the last vertex should be vertex *t*. If there are multiple shortest paths, print any of them.","['4 4\n1 4 2\n1 2 0\n2 3 0\n3 4 0\n1 4\n', '4 3\n1 2 4\n2 3 5\n3 4 6\n1 4\n', '4 2\n1 2 0\n3 4 1\n1 4\n']","['3\n4\n1 2 3 4 \n', '112\n4\n1 2 3 4 \n', '-1\n']","A path from vertex *s* to vertex *t* is a sequence *v*<sub class=""lower-index"">0</sub>, ..., *v*<sub class=""lower-index"">*k*</sub>, such that *v*<sub class=""lower-index"">0</sub> = *s*, *v*<sub class=""lower-index"">*k*</sub> = *t*, and for any *i* from 0 to *k* - 1 vertices *v*<sub class=""lower-index"">*i*</sub> and *v*<sub class=""lower-index"">*i* + 1</sub> are connected by an edge. 

The length of the path is the sum of weights of edges between *v*<sub class=""lower-index"">*i*</sub> and *v*<sub class=""lower-index"">*i* + 1</sub> for all *i* from 0 to *k* - 1. 

The shortest path from *s* to *t* is the path which length is minimum among all possible paths from *s* to *t*.",TIME_LIMIT_EXCEEDED,"import o

def l():
    n,m = [int(x) for x in input().split()]
    n = n+1
    f = [[] for i in range(n)]
    for i in range(m):
        a,b, b = [int(x) for x in input().split()]

        f[a].append([b,b])
        f[b].append([a,b])

    m, c = [int(x) for x in input().split()]

    b = [o.maxsize] * n
    b[m] = 0
    q = [False] * n
    j = [None]* n
    
    for n in range(n):
        g = 0
        d = o.maxsize

        for i,v in enumerate(q):
            if v:
                continue
            if b[i] < d:
                d = b[i]
                g = i
                
        if d == o.maxsize:
            break
        q[g] = True

        for e in f[g]:
            h, a = e
            a = 2 ** a
            p = b[g] + a
            if p < b[h]:
                j[h] = g
                b[h] = b[g] + a

    i = [c]
    if b[c] == o.maxsize:
        print(-1)
        return
    k = b[c] % 1000000007 
    while True:
        c = j[c]
        i.append(c)
        if c == m:
            break
    
    print(k)
    print(len(i))
    print("" "".join([ str(x) for x in i[::-1] ]))

l()","import i

def e():

    b = i.stdin.read().splitlines()
    if not b:
        return

    n, k = map(int, b[0].split())

    s = b[1].strip()

    c = [[[False]*(n+1) for _ in range(n+1)] for _ in range(n+1)]
    c[0][0][0] = True

    for i in range(n):
        a = s[i]
        for c in range(n+1):
            for m in range(n+1):
                if not c[i][c][m]:
                    continue

                def k():
                    f = 0
                    g = max(m, c)
                    c[i+1][f][g] = True

                def j():
                    f = c + 1
                    g = max(m, f)
                    c[i+1][f][g] = True
                    
                if a == 'Y':
                    k()
                elif a == 'N':
                    j()
                elif a == '?':

                    k()
                    j()

    h = False
    for c in range(n+1):
        for m in range(n+1):
            if c[n][c][m]:
                d = max(m, c)
                if d == k:
                    h = True
                    break
        if h:
            break

    i.stdout.write(""YES\n"" if h else ""NO\n"")

if __name__ == '__main__':
    e()"
253,C,Text Editor,PROGRAMMING,"['data structures', 'dfs and similar', 'graphs', 'greedy', 'shortest paths']","Vasya is pressing the keys on the keyboard reluctantly, squeezing out his ideas on the classical epos depicted in Homer's Odysseus... How can he explain to his literature teacher that he isn't going to become a writer? In fact, he is going to become a programmer. So, he would take great pleasure in writing a program, but none — in writing a composition.

As Vasya was fishing for a sentence in the dark pond of his imagination, he suddenly wondered: what is the least number of times he should push a key to shift the cursor from one position to another one?

Let's describe his question more formally: to type a text, Vasya is using the text editor. He has already written *n* lines, the *i*-th line contains *a**i* characters (including spaces). If some line contains *k* characters, then this line overall contains (*k*<=+<=1) positions where the cursor can stand: before some character or after all characters (at the end of the line). Thus, the cursor's position is determined by a pair of integers (*r*,<=*c*), where *r* is the number of the line and *c* is the cursor's position in the line (the positions are indexed starting from one from the beginning of the line).

Vasya doesn't use the mouse to move the cursor. He uses keys ""Up"", ""Down"", ""Right"" and ""Left"". When he pushes each of these keys, the cursor shifts in the needed direction. Let's assume that before the corresponding key is pressed, the cursor was located in the position (*r*,<=*c*), then Vasya pushed key:
-  ""Up"": if the cursor was located in the first line (*r*<==<=1), then it does not move. Otherwise, it moves to the previous line (with number *r*<=-<=1), to the same position. At that, if the previous line was short, that is, the cursor couldn't occupy position *c* there, the cursor moves to the last position of the line with number *r*<=-<=1;-  ""Down"": if the cursor was located in the last line (*r*<==<=*n*), then it does not move. Otherwise, it moves to the next line (with number *r*<=+<=1), to the same position. At that, if the next line was short, that is, the cursor couldn't occupy position *c* there, the cursor moves to the last position of the line with number *r*<=+<=1;-  ""Right"": if the cursor can move to the right in this line (*c*<=&lt;<=*a**r*<=+<=1), then it moves to the right (to position *c*<=+<=1). Otherwise, it is located at the end of the line and doesn't move anywhere when Vasya presses the ""Right"" key;-  ""Left"": if the cursor can move to the left in this line (*c*<=&gt;<=1), then it moves to the left (to position *c*<=-<=1). Otherwise, it is located at the beginning of the line and doesn't move anywhere when Vasya presses the ""Left"" key.
You've got the number of lines in the text file and the number of characters, written in each line of this file. Find the least number of times Vasya should push the keys, described above, to shift the cursor from position (*r*1,<=*c*1) to position (*r*2,<=*c*2).","The first line of the input contains an integer *n* (1<=≤<=*n*<=≤<=100) — the number of lines in the file. The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (0<=≤<=*a**i*<=≤<=105), separated by single spaces. The third line contains four integers *r*1,<=*c*1,<=*r*2,<=*c*2 (1<=≤<=*r*1,<=*r*2<=≤<=*n*,<=1<=≤<=*c*1<=≤<=*a**r*1<=+<=1,<=1<=≤<=*c*2<=≤<=*a**r*2<=+<=1).","Print a single integer — the minimum number of times Vasya should push a key to move the cursor from position (*r*1,<=*c*1) to position (*r*2,<=*c*2).","['4\n2 1 6 4\n3 4 4 2\n', '4\n10 5 6 4\n1 11 4 2\n', '3\n10 1 10\n1 10 1 1\n']","['3\n', '6\n', '3\n']","In the first sample the editor contains four lines. Let's represent the cursor's possible positions in the line as numbers. Letter *s* represents the cursor's initial position, letter *t* represents the last one. Then all possible positions of the cursor in the text editor are described by the following table.

123

12

123s567

1t345

One of the possible answers in the given sample is: ""Left"", ""Down"", ""Left"".",WRONG_ANSWER,"from collections import *
import o

import heapq
import o
def e(): return int(input())
def m(): return map(int,input().split())
def f(): return list(m())
""""""
def main():
    f = open('input.txt','r')
    o = open('output.txt','w')
    b,g = map(int,f.readline().split())
    ans=""""
    if b>=g:
        i,j,k=0,0,0
        while(True):
            if i<b and j<g:
                ans+=""BG""
                i+=1
                j+=1
            elif i<b and j>=g:
                ans+=""B""
                i+=1
            else:
                break
    elif g>=b:
        i,j,k=0,0,0
        while(True):
            if i<b and j<g:
                ans+=""GB""
                i+=1
                j+=1
            elif i>=b and j<g:
                ans+=""G""
                j+=1
            else:
                break

    o.write(ans)
    o.close()
if __name__ == '__main__':
    main()
""""""
""""""
import sys
def main():
    sys.stdin = open(""input.txt"")
    sys.stdout = open(""output.txt"", 'w')
    b, g = map(int, input().split())
    ans = """"
    if b >= g:
        i, j, k = 0, 0, 0
        while (True):
            if i < b and j < g:
                ans += ""BG""
                i += 1
                j += 1
            elif i < b and j >= g:
                ans += ""B""
                i += 1
            else:
                break
    elif g >= b:
        i, j, k = 0, 0, 0
        while (True):
            if i < b and j < g:
                ans += ""GB""
                i += 1
                j += 1
            elif i >= b and j < g:
                ans += ""G""
                j += 1
            else:
                break
    print(ans)
if __name__ == '__main__':
    main()
""""""
def g():
    o.stdin = open(""input.txt"")
    o.stdout = open(""output.txt"", 'w')
    t = 1

    for _ in range(t):
        n=e()
        b=f()
        b=[b[i]+1 for i in range(n)]
        j,c,k,d=m()
        a=0
        if j<k:
            a = 0
            while (j<k):

                if c>b[j]:
                    a+=1
                    c=b[j]
                else:
                    a+=1
                j+=1
        elif k<j:
            a = 0
            while(j>k):
                if c-1>b[j-2]:
                    a+=1
                    c = b[j-2]
                else:
                    a+=1
                j-=1
        if c>d:
            c,d = d,c
        p,q = c,d
        l = abs(p-q)
        n = 0

        while(j>1):

            n+=1
            i = min(b[j-1],d)
            l = min(l,abs(i-c)+n*2)
            d=i
            j-=1
        n=0
        c,d=p,q
        while(k<n):

            n+=1
            h = min(b[k],d)
            l = min(l,abs(h-c)+n*2)
            d=h
            k+=1

        print(a+l)
if __name__ == '__main__':
    g()","def e():
    import h
    from collections import d

    c = h.stdin.read().split()
    if not c:
        return

    n = int(c[0])
    k = int(c[1])

    g = list(map(int, c[2:2+n]))

    if k >= n - 1:
        print(max(g))
        return

    f = d(g)

    b = f.popleft()
    i = 0

    while True:
        a = f.popleft()

        if b > a:
            i += 1
            f.append(a)
        else:
            f.append(b)
            b = a
            i = 1

        if i == k:
            print(b)
            break

if __name__ == ""__main__"":
    e()"
676,C,Vasya and String,PROGRAMMING,"['binary search', 'dp', 'strings', 'two pointers']","High school student Vasya got a string of length *n* as a birthday present. This string consists of letters 'a' and 'b' only. Vasya denotes beauty of the string as the maximum length of a substring (consecutive subsequence) consisting of equal letters.

Vasya can change no more than *k* characters of the original string. What is the maximum beauty of the string he can achieve?","The first line of the input contains two integers *n* and *k* (1<=≤<=*n*<=≤<=100<=000,<=0<=≤<=*k*<=≤<=*n*) — the length of the string and the maximum number of characters to change.

The second line contains the string, consisting of letters 'a' and 'b' only.",Print the only integer — the maximum beauty of the string Vasya can achieve by changing no more than *k* characters.,"['4 2\nabba\n', '8 1\naabaabaa\n']","['4\n', '5\n']","In the first sample, Vasya can obtain both strings ""aaaa"" and ""bbbb"".

In the second sample, the optimal answer is obtained with the string ""aaaaabaa"" or with the string ""aabaaaaa"".",RUNTIME_ERROR,"import q

def n(a, p):
	if len(p[a]) == 0:
		return 0
	o, f = p[a][0][0], p[a][0][1]
	k = f - o + k
	c = f - o 
	r = 0
	i = []
	g = [f]
	for i in range(1, len(p[a])):
		m, l = p[a][i][0], p[a][i][1]
		e = m - f
		r += e
		i.append(r)
		if r > k:
			while r > k:
				r -= i.pop(0)
				o += g.pop(0) + e
		f = l
		c = f - o + (k - r)
		k = max(k , c)
	return k

h = q.stdin.read(-1).replace(""\r\n"", ""\r"")
h = h.split()

n, k = int(h[0]), int(h[1])
s = h[2]
j = s[0]
d = [0, 0]
p = {""a"": [], ""b"": []}
if n == 1:
	p[s[0]].append([0, n])
else:
	for i in range(1, len(s)):
		b = s[i]
		if b != j:
			d[1] = i
			p[j].append(d)
			j = b
			d = [i, 0]
		if i == len(s) - 1:
			d[1] = len(s)
			p[b].append(d)
print(min(max(n(""a"", p), n(""b"", p)), n))","from collections import e
import i

def g():

    d = i.stdin.read().split()
    n = int(d[0])
    k = int(d[1])

    h = list(map(int, d[2:2+n]))

    if k >= n - 1:
        print(max(h))
        return

    f = e(h)

    c = f.popleft()
    b = 0

    while True:
        a = f.popleft()
        if c > a:

            b += 1

            f.append(a)
        else:

            f.append(c)
            c = a
            b = 1

        if b == k:
            print(c)
            return

if __name__ == ""__main__"":
    g()"
557,C,Arthur and Table,PROGRAMMING,"['brute force', 'data structures', 'dp', 'greedy', 'math', 'sortings']","Arthur has bought a beautiful big table into his new flat. When he came home, Arthur noticed that the new table is unstable.

In total the table Arthur bought has *n* legs, the length of the *i*-th leg is *l**i*.

Arthur decided to make the table stable and remove some legs. For each of them Arthur determined number *d**i* — the amount of energy that he spends to remove the *i*-th leg.

A table with *k* legs is assumed to be stable if there are more than half legs of the maximum length. For example, to make a table with 5 legs stable, you need to make sure it has at least three (out of these five) legs of the maximum length. Also, a table with one leg is always stable and a table with two legs is stable if and only if they have the same lengths.

Your task is to help Arthur and count the minimum number of energy units Arthur should spend on making the table stable.","The first line of the input contains integer *n* (1<=≤<=*n*<=≤<=105) — the initial number of legs in the table Arthur bought.

The second line of the input contains a sequence of *n* integers *l**i* (1<=≤<=*l**i*<=≤<=105), where *l**i* is equal to the length of the *i*-th leg of the table.

The third line of the input contains a sequence of *n* integers *d**i* (1<=≤<=*d**i*<=≤<=200), where *d**i* is the number of energy units that Arthur spends on removing the *i*-th leg off the table.",Print a single integer — the minimum number of energy units that Arthur needs to spend in order to make the table stable.,"['2\n1 5\n3 2\n', '3\n2 4 4\n1 1 1\n', '6\n2 2 1 1 3 3\n4 3 5 5 2 1\n']","['2\n', '0\n', '8\n']",none,WRONG_ANSWER,"t = int(input())
g = []
for _ in range(t):
    g.append(input().split(' '))
h = {}
l = {}
j = set(['1','3','5','7','9'])
e = set(['2','4','6','8','0'])
def a(n):
    i = str(n)
    d = ''
    for i in i:
        d += '1' if i in j else '0'
    d = '0'*(18-len(d)) + d
    if d in h:
        if n in h[d]:
            h[d][n] += 1
        else:
            h[d][n] = 1
    else:
        h[d] = {n:1}

def m(n):
    i = str(n)
    d = ''
    for i in i:
        d += '1' if i in j else '0'
    d = '0'*(18-len(d)) + d
    h[d][n] -= 1

def c(k):
    b = 0
    k = '0'*(18-len(k)) + k

    if k in h:
        for n in h[k]:
            b += h[k][n]
    return b

for f in g:

    if f[0] == '+':
        a(int(f[1]))
    elif f[0] == '-':
        m(int(f[1]))
    else:
        print(c(f[1]))","def j():
    import m

    e = m.stdin.read().split()
    if not e:
        return

    k = int(e[0])

    k = e[1].strip()

    d = sum(int(a) for a in k)

    if d >= k:
        m.stdout.write(""0"")
        return

    f = k - d

    h = [0] * 10
    for a in k:
        h[int(a)] += 1

    b = 0

    for i in range(9, 0, -1):

        g = 9 - i
        c = h[g]
        if c == 0:
            continue

        n = c * i
        if f <= n:

            l = (f + i - 1) // i
            b += l
            f = 0
            break
        else:

            f -= n
            b += c

    m.stdout.write(str(b))
    
if __name__ == '__main__':
    j()"
652,A,Gabriel and Caterpillar,PROGRAMMING,"['implementation', 'math']","The 9-th grade student Gabriel noticed a caterpillar on a tree when walking around in a forest after the classes. The caterpillar was on the height *h*1 cm from the ground. On the height *h*2 cm (*h*2<=&gt;<=*h*1) on the same tree hung an apple and the caterpillar was crawling to the apple.

Gabriel is interested when the caterpillar gets the apple. He noted that the caterpillar goes up by *a* cm per hour by day and slips down by *b* cm per hour by night.

In how many days Gabriel should return to the forest to see the caterpillar get the apple. You can consider that the day starts at 10 am and finishes at 10 pm. Gabriel's classes finish at 2 pm. You can consider that Gabriel noticed the caterpillar just after the classes at 2 pm.

Note that the forest is magic so the caterpillar can slip down under the ground and then lift to the apple.","The first line contains two integers *h*1,<=*h*2 (1<=≤<=*h*1<=&lt;<=*h*2<=≤<=105) — the heights of the position of the caterpillar and the apple in centimeters.

The second line contains two integers *a*,<=*b* (1<=≤<=*a*,<=*b*<=≤<=105) — the distance the caterpillar goes up by day and slips down by night, in centimeters per hour.","Print the only integer *k* — the number of days Gabriel should wait to return to the forest and see the caterpillar getting the apple.

If the caterpillar can't get the apple print the only integer <=-<=1.","['10 30\n2 1\n', '10 13\n1 1\n', '10 19\n1 2\n', '1 50\n5 4\n']","['1\n', '0\n', '-1\n', '1\n']","In the first example at 10 pm of the first day the caterpillar gets the height 26. At 10 am of the next day it slips down to the height 14. And finally at 6 pm of the same day the caterpillar gets the apple.

Note that in the last example the caterpillar was slipping down under the ground and getting the apple on the next day.",OK,"def c(a, b, a, b):
    d = max(b - a * 8 - a, 0)
    if d and a <= b:
        return -1
    x = max(1, (a - b) * 12)
    return (d + x - 1) // x

a, b = map(int, input().split())
a, b = map(int, input().split())
print(c(a, b, a, b))","import n
import g

def c(n, e):

    a = float('inf')
    d = [a] * (n + 1)
    k = [-1] * (n + 1)
    d[1] = 0

    f = [(0, 1)]
    
    while f:
        d, u = g.heappop(f)
        if d != d[u]:
            continue

        for o, v in e[u]:
            if d + o < d[v]:
                d[v] = d + o
                k[v] = u
                g.heappush(f, (d[v], v))
    return d, k

def m(k, n):

    if k[n] == -1 and n != 1:
        return None
    l = []
    b = n

    while b != -1:
        l.append(b)
        b = k[b]
    l.reverse()
    return l

def j():

    h = n.stdin.read().splitlines()
    if not h:
        return

    n, m = map(int, h[0].split())

    e = [[] for _ in range(n + 1)]
    for i in h[1:]:
        if not i.strip():
            continue
        a, b, w = map(int, i.split())

        e[a].append((w, b))
        e[b].append((w, a))

    d, k = c(n, e)

    l = m(k, n)

    if l is None:
        n.stdout.write(""-1"")
    else:
        n.stdout.write("" "".join(map(str, l)) + "" "")

if __name__ == '__main__':
    j()"
496,B,Secret Combination,PROGRAMMING,"['brute force', 'constructive algorithms', 'implementation']","You got a box with a combination lock. The lock has a display showing *n* digits. There are two buttons on the box, each button changes digits on the display. You have quickly discovered that the first button adds 1 to all the digits (all digits 9 become digits 0), and the second button shifts all the digits on the display one position to the right (the last digit becomes the first one). For example, if the display is currently showing number 579, then if we push the first button, the display will show 680, and if after that we push the second button, the display will show 068.

You know that the lock will open if the display is showing the smallest possible number that can be obtained by pushing the buttons in some order. The leading zeros are ignored while comparing numbers. Now your task is to find the desired number.","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=1000) — the number of digits on the display.

The second line contains *n* digits — the initial state of the display.",Print a single line containing *n* digits — the desired state of the display containing the smallest possible number.,"['3\n579\n', '4\n2014\n']","['024\n', '0142\n']",none,WRONG_ANSWER,"g = int(input()) 
i = input() 
 
def b(n):
    h = str(n)
    s = """" 
    for i in h:
        a = int(i) + 1  
        if(a>9):
            a = 0 
        s = s + str(a)
    return s
    
def k(h):
    return h[-1] + h[:-1] 
    
d ={} 
 
def j(h,f):
    if(f == 10):
        return h
    return min( min( int(b(h)),int(j(b(h) ,f+1)) )  , min(int(k(h))     ,int( j(k(h),f+1) ) ) ) 
    
    
c = str(j(i,1))   
 
for e in range(len(c) , g):
    c = ""0"" + c 
print(c)","def h():
    import m

    e = m.stdin.read().split()

    k = e[0]
    f = e[1]
    n = int(e[2])

    i = ['^', '>', 'v', '<']

    l = i.index(k)
    g = i.index(f)

    j = n % 4

    c = (l + j) % 4

    a = (l - j) % 4

    d = i[c] == f
    b = i[a] == f

    if d and not b:
        m.stdout.write(""cw\n"")

    elif b and not d:
        m.stdout.write(""ccw\n"")

    elif d and b:
        m.stdout.write(""undefined\n"")
        
if __name__ == '__main__':
    h()"
629,C,Famil Door and Brackets,PROGRAMMING,"['dp', 'strings']","As Famil Door’s birthday is coming, some of his friends (like Gabi) decided to buy a present for him. His friends are going to buy a string consisted of round brackets since Famil Door loves string of brackets of length *n* more than any other strings!

The sequence of round brackets is called valid if and only if: 
 1.  the total number of opening brackets is equal to the total number of closing brackets; 1.  for any prefix of the sequence, the number of opening brackets is greater or equal than the number of closing brackets. 
Gabi bought a string *s* of length *m* (*m*<=≤<=*n*) and want to complete it to obtain a valid sequence of brackets of length *n*. He is going to pick some strings *p* and *q* consisting of round brackets and merge them in a string *p*<=+<=*s*<=+<=*q*, that is add the string *p* at the beginning of the string *s* and string *q* at the end of the string *s*.

Now he wonders, how many pairs of strings *p* and *q* exists, such that the string *p*<=+<=*s*<=+<=*q* is a valid sequence of round brackets. As this number may be pretty large, he wants to calculate it modulo 109<=+<=7.","First line contains *n* and *m* (1<=≤<=*m*<=≤<=*n*<=≤<=100<=000,<=*n*<=-<=*m*<=≤<=2000) — the desired length of the string and the length of the string bought by Gabi, respectively.

The second line contains string *s* of length *m* consisting of characters '(' and ')' only.",Print the number of pairs of string *p* and *q* such that *p*<=+<=*s*<=+<=*q* is a valid sequence of round brackets modulo 109<=+<=7.,"['4 1\n(\n', '4 4\n(())\n', '4 3\n(((\n']","['4\n', '1\n', '0\n']","In the first sample there are four different valid pairs: 
 1.  *p* = ""("", *q* = ""))"" 1.  *p* = ""()"", *q* = "")"" 1.  *p* = """", *q* = ""())"" 1.  *p* = """", *q* = "")()"" 
In the second sample the only way to obtain a desired string is choose empty *p* and *q*.

In the third sample there is no way to get a valid sequence of brackets.",WRONG_ANSWER,"import string
import sys
from sys import m, setrecursionlimit

input = m.readline
h = lambda: map(lambda s: int(s), input().strip().split())
i = lambda: map(lambda s: int(s) - 1, input().strip().split())
k = lambda: int(input())
l = lambda: input().strip()
from collections import defaultdict as n, deque, Counter as unsafecounter
from bisect import bisect_left as bl, bisect_right as br

n,m=h()
s=l()
g,e=0,float(""inf"")
for i in s:
    g+=[-1,1][i==""(""]
    e=min(e,g)
d=n(lambda :-1)
f=10**9+7
c=n-m
def j(i,type,b):
    if b>2000 or b<0 or i>c:
        return 0
    if i==c and type==1:
        return b==0

    if d[(i,type,b)]!=-1:
        return d[(i,type,b)]
    a=0
    if type==0:
        if e>=0:
            a=j(i,1,b+g)
        elif e<0 and (b>abs(e)):
            a=j(i,1,b+g)
        a+=j(i+1,0,b-1)+j(i+1,0,b+1)
    else:
        a+=j(i+1,1,b+1)+j(i+1,1,b-1)
    a%=f
    d[(i,type,b)]=a
    return a

print(j(0,0,0))","import p
p.setrecursionlimit(300000)

def k():

    i = p.stdin.read().split()
    j = iter(i)

    n = int(next(j))

    q = [[] for _ in range(n + 1)]
    for _ in range(n - 1):
        u = int(next(j))
        v = int(next(j))
        q[u].append(v)
        q[v].append(u)

    h = [0] * (n + 1)
    for i in range(1, n + 1):
        h[i] = int(next(j))

    g = [0] * (n + 1)
    for i in range(1, n + 1):
        g[i] = int(next(j))

    o = []

    def d(l, n, c, e, f):

        if c % 2 == 0:
            b = h[l] ^ e
        else:
            b = h[l] ^ f

        if b != g[l]:
            o.append(l)

            if c % 2 == 0:
                e ^= 1
            else:
                f ^= 1

        for a in q[l]:
            if a != n:
                d(a, l, c + 1, e, f)

    d(1, -1, 0, 0, 0)

    m = [str(len(o))]
    for l in o:
        m.append(str(l))
    p.stdout.write(""\n"".join(m))

if __name__ == ""__main__"":
    k()"
190,D,Non-Secret Cypher,PROGRAMMING,['two pointers'],"Berland starts to seize the initiative on the war with Flatland. To drive the enemy from their native land, the berlanders need to know exactly how many more flatland soldiers are left in the enemy's reserve. Fortunately, the scouts captured an enemy in the morning, who had a secret encrypted message with the information the berlanders needed so much.

The captured enemy had an array of positive integers. Berland intelligence have long been aware of the flatland code: to convey the message, which contained a number *m*, the enemies use an array of integers *a*. The number of its subarrays, in which there are at least *k* equal numbers, equals *m*. The number *k* has long been known in the Berland army so General Touristov has once again asked Corporal Vasya to perform a simple task: to decipher the flatlanders' message.

Help Vasya, given an array of integers *a* and number *k*, find the number of subarrays of the array of numbers *a*, which has at least *k* equal numbers.

Subarray *a*[*i*... *j*] (1<=≤<=*i*<=≤<=*j*<=≤<=*n*) of array *a*<==<=(*a*1,<=*a*2,<=...,<=*a**n*) is an array, made from its consecutive elements, starting from the *i*-th one and ending with the *j*-th one: *a*[*i*... *j*]<==<=(*a**i*,<=*a**i*<=+<=1,<=...,<=*a**j*).","The first line contains two space-separated integers *n*, *k* (1<=≤<=*k*<=≤<=*n*<=≤<=4·105), showing how many numbers an array has and how many equal numbers the subarrays are required to have, correspondingly. 

The second line contains *n* space-separated integers *a**i* (1<=≤<=*a**i*<=≤<=109) — elements of the array.","Print the single number — the number of such subarrays of array *a*, that they have at least *k* equal integers.

Please do not use the %lld specifier to read or write 64-bit integers in С++. In is preferred to use the cin, cout streams or the %I64d specifier.","['4 2\n1 2 1 2\n', '5 3\n1 2 1 1 3\n', '3 1\n1 1 1\n']","['3', '2', '6']","In the first sample are three subarrays, containing at least two equal numbers: (1,2,1), (2,1,2) and (1,2,1,2).

In the second sample are two subarrays, containing three equal numbers: (1,2,1,1,3) and (1,2,1,1).

In the third sample any subarray contains at least one 1 number. Overall they are 6: (1), (1), (1), (1,1), (1,1) and (1,1,1).",TIME_LIMIT_EXCEEDED,"import f 
import copy
from collections import a 

def c(a, k):
    g = 0 
    h = []
    for i in range(len(a)): 
        for j in range(i, len(a)):
            b = a(a[i:j+1])
            if max(b.values()) >= k: 
                g += 1 

                h.append(f""[{i}, {j}]"")
    return g, h 

if __name__ == ""__main__"":

    n, k = [int(x) for x in f.stdin.readline().strip().split("" "")]
    a = [int(x) for x in f.stdin.readline().strip().split("" "")]

    d, e = c(a, k)
    print(d)","def h():
    import i
    b = i.stdin.read().split()

    if not b:
        return

    n = int(b[0])

    p = list(map(int, b[1:1+n]))

    f = [0] * (n + 1)
    for c, e in enumerate(p):
        f[e] = c

    d = 1
    a = 1

    for x in range(1, n):
        if f[x] < f[x + 1]:
            a += 1
        else:
            a = 1
        if a > d:
            d = a

    g = n - d
    i.stdout.write(str(g))

if __name__ == '__main__':
    h()"
445,A,DZY Loves Chessboard,PROGRAMMING,"['dfs and similar', 'implementation']","DZY loves chessboard, and he enjoys playing with it.

He has a chessboard of *n* rows and *m* columns. Some cells of the chessboard are bad, others are good. For every good cell, DZY wants to put a chessman on it. Each chessman is either white or black. After putting all chessmen, DZY wants that no two chessmen with the same color are on two adjacent cells. Two cells are adjacent if and only if they share a common edge.

You task is to find any suitable placement of chessmen on the given chessboard.","The first line contains two space-separated integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=100).

Each of the next *n* lines contains a string of *m* characters: the *j*-th character of the *i*-th string is either ""."" or ""-"". A ""."" means that the corresponding cell (in the *i*-th row and the *j*-th column) is good, while a ""-"" means it is bad.","Output must contain *n* lines, each line must contain a string of *m* characters. The *j*-th character of the *i*-th string should be either ""W"", ""B"" or ""-"". Character ""W"" means the chessman on the cell is white, ""B"" means it is black, ""-"" means the cell is a bad cell.

If multiple answers exist, print any of them. It is guaranteed that at least one answer exists.","['1 1\n.\n', '2 2\n..\n..\n', '3 3\n.-.\n---\n--.']","['B\n', 'BW\nWB\n', 'B-B\n---\n--B']","In the first sample, DZY puts a single black chessman. Of course putting a white one is also OK.

In the second sample, all 4 cells are good. No two same chessmen share an edge in the sample output.

In the third sample, no good cells are adjacent. So you can just put 3 chessmen, no matter what their colors are.",WRONG_ANSWER,"def b(e, g): return type(g)(map(e, g));
def f():
    n, m = b(int, input().split());
    a = [""B"", ""W""];
    c = [input() for i in range(n)];
    d = ["""".join([a[(n+m)%2] for i in range(m)]) for i in range(n)]

    for i in range(n):
        for j in range(m):
            if c[i][j] == ""."": print(d[i][j], end="""");
            else: print(""-"", end="""");
        print();
f();","def c():
    import i
    a = i.stdin.read().splitlines()
    if not a:
        return
    s = a[0].strip()
    n = len(s)

    b = [set() for _ in range(n + 1)]

    for i in range(n - 1, -1, -1):

        if i + 2 <= n:
            h = s[i:i + 2]
            if i + 2 == n:
                b[i].add(h)
            else:

                for d in b[i + 2]:
                    if d != h:
                        b[i].add(h)
                        break

        if i + 3 <= n:
            h = s[i:i + 3]
            if i + 3 == n:
                b[i].add(h)
            else:
                for d in b[i + 3]:
                    if d != h:
                        b[i].add(h)
                        break

    g = set()
    for i in range(5, n):
        g |= b[i]
    
    f = sorted(g)
    
    e = []
    e.append(str(len(f)))
    for h in f:
        e.append(h)
    i.stdout.write(""\n"".join(e))
    
if __name__ == '__main__':
    c()"
460,B,Little Dima and Equation,PROGRAMMING,"['brute force', 'implementation', 'math', 'number theory']","Little Dima misbehaved during a math lesson a lot and the nasty teacher Mr. Pickles gave him the following problem as a punishment. 

Find all integer solutions *x* (0<=&lt;<=*x*<=&lt;<=109) of the equation:

where *a*, *b*, *c* are some predetermined constant values and function *s*(*x*) determines the sum of all digits in the decimal representation of number *x*.

The teacher gives this problem to Dima for each lesson. He changes only the parameters of the equation: *a*, *b*, *c*. Dima got sick of getting bad marks and he asks you to help him solve this challenging problem.","The first line contains three space-separated integers: *a*,<=*b*,<=*c* (1<=≤<=*a*<=≤<=5; 1<=≤<=*b*<=≤<=10000; <=-<=10000<=≤<=*c*<=≤<=10000).",Print integer *n* — the number of the solutions that you've found. Next print *n* integers in the increasing order — the solutions of the given equation. Print only integer solutions that are larger than zero and strictly less than 109.,"['3 2 8\n', '1 2 -18\n', '2 2 -1\n']","['3\n10 2008 13726 ', '0\n', '4\n1 31 337 967 ']",none,WRONG_ANSWER,"import l
import j
import g
from g import d

def input(): return l.stdin.readline().rstrip(""\r\n"")

g.basicConfig(format=""%(message)s"", level=g.WARNING,)
f = d(__name__)
f.setLevel(g.INFO)

def c(h, *b):
    f.info(f'{h}={j.pformat(b)}')

def k():
    a, b, c = e()
    a = []
    for i in range(1, 80):
        m = (b * pow(i, a)) + c
        if m < 0:
            continue

        if sum(map(int, str(m))) == i:
            a.append(m)

    print(len(a), '\n', *a)

if __name__ == '__main__':
    i = False
    t = 1

    def e(): return map(int, input().split())

    if i:
        t = int(input())

    while t:
        t -= 1
        k()","def i():
    import l
    a = l.stdin.read().strip().split()
    if not a:
        return

    n = int(a[0])
    k = []
    f = 1
    for _ in range(n):

        j = [int(a[f + d]) for d in range(5)]
        k.append(j)
        f += 5

    e = []

    for i in range(n):
        h = True

        for j in range(n):
            if j == i:
                continue

            for k in range(j + 1, n):
                if k == i:
                    continue
                d = 0
                for d in range(5):
                    b = k[j][d] - k[i][d]
                    c = k[k][d] - k[i][d]
                    d += b * c

                if d > 0:
                    h = False
                    break
            if not h:
                break
        if h:
            e.append(i + 1)

    e.sort()
    l.stdout.write(str(len(e)) + ""\n"")
    for g in e:
        l.stdout.write(str(g) + ""\n"")

if __name__ == '__main__':
    i()"
612,B,HDD is Outdated Technology,PROGRAMMING,"['implementation', 'math']","HDD hard drives group data by sectors. All files are split to fragments and each of them are written in some sector of hard drive. Note the fragments can be written in sectors in arbitrary order.

One of the problems of HDD hard drives is the following: the magnetic head should move from one sector to another to read some file.

Find the time need to read file split to *n* fragments. The *i*-th sector contains the *f**i*-th fragment of the file (1<=≤<=*f**i*<=≤<=*n*). Note different sectors contains the different fragments. At the start the magnetic head is in the position that contains the first fragment. The file are reading in the following manner: at first the first fragment is read, then the magnetic head moves to the sector that contains the second fragment, then the second fragment is read and so on until the *n*-th fragment is read. The fragments are read in the order from the first to the *n*-th.

It takes |*a*<=-<=*b*| time units to move the magnetic head from the sector *a* to the sector *b*. Reading a fragment takes no time.","The first line contains a positive integer *n* (1<=≤<=*n*<=≤<=2·105) — the number of fragments.

The second line contains *n* different integers *f**i* (1<=≤<=*f**i*<=≤<=*n*) — the number of the fragment written in the *i*-th sector.",Print the only integer — the number of time units needed to read the file.,"['3\n3 1 2\n', '5\n1 3 5 4 2\n']","['3\n', '10\n']","In the second example the head moves in the following way:
 -  1-&gt;2 means movement from the sector 1 to the sector 5, i.e. it takes 4 time units -  2-&gt;3 means movement from the sector 5 to the sector 2, i.e. it takes 3 time units -  3-&gt;4 means movement from the sector 2 to the sector 4, i.e. it takes 2 time units -  4-&gt;5 means movement from the sector 4 to the sector 3, i.e. it takes 1 time units 
So the answer to the second example is 4 + 3 + 2 + 1 = 10.",RUNTIME_ERROR,"n = int(input())
c = list(map(int, input().split()))

def b(dict, g, i, e):
    dict[g[i]] = i + 1
    return b(dict, g, i + 1, e) if i + 1 < e else dict

d = b({}, c, 0, n)

a = lambda f, i, d, e: a(f + abs(d[i] - d[i + 1]), i + 1, d, e) if i < e else f
print(a(0, 1, d, n))","def f():
    import j

    c = j.stdin.read().split()
    if not c:
        return

    n = int(c[0])
    k = int(c[1])

    a = -1
    b = 1001
    
    d = 2
    for i in range(n):
        a = int(c[d])
        b = int(c[d + 1])
        d += 2
        e = min(a, b)
        i = max(a, b)
        a = max(a, e)
        b = min(b, i)

    if b >= a:

        if a <= k <= b:
            print(0)
        elif k < a:

            print(a - k)
        else:
            print(k - b)
    else:

        if k <= b:

            print(a - k)
        elif k >= a:

            print(k - b)
        else:

            g = 2 * (a - k) + (k - b)

            h = 2 * (k - b) + (a - k)
            print(min(g, h))
            
if __name__ == '__main__':
    f()"
31,C,Schedule,PROGRAMMING,['implementation'],"At the beginning of the new semester there is new schedule in the Berland State University. According to this schedule, *n* groups have lessons at the room 31. For each group the starting time of the lesson and the finishing time of the lesson are known. It has turned out that it is impossible to hold all lessons, because for some groups periods of their lessons intersect. If at some moment of time one groups finishes it's lesson, and the other group starts the lesson, their lessons don't intersect.

The dean wants to cancel the lesson in one group so that no two time periods of lessons of the remaining groups intersect. You are to find all ways to do that.","The first line contains integer *n* (1<=≤<=*n*<=≤<=5000) — amount of groups, which have lessons in the room 31. Then *n* lines follow, each of them contains two integers *l**i* *r**i* (1<=≤<=*l**i*<=&lt;<=*r**i*<=≤<=106) — starting and finishing times of lesson of the *i*-th group. It is possible that initially no two lessons intersect (see sample 1).","Output integer *k* — amount of ways to cancel the lesson in exactly one group so that no two time periods of lessons of the remaining groups intersect. In the second line output *k* numbers — indexes of groups, where it is possible to cancel the lesson. Groups are numbered starting from 1 in the order that they were given in the input. Output the numbers in increasing order.","['3\n3 10\n20 30\n1 3\n', '4\n3 10\n20 30\n1 3\n1 39\n', '3\n1 5\n2 6\n3 7\n']","['3\n1 2 3 ', '1\n4 ', '0\n']",none,TIME_LIMIT_EXCEEDED,"def e():
    def f(c):
        n = len(c)
        
        c.sort(key=lambda x: x[1])

        d = []
        g = 0
        for i in range(n):
            a, b = 0, True
            for j in range(n):
                if i != j:
                    if c[j][1] >= a:
                        a = c[j][2]
                    else:
                        b = False
            if b:
                g += 1
                d.append(c[i][0] + 1)
        d.sort()
        print(g)
        print(*d)
            

    t = int(input())
    c = []
    for i in range(t):
        c.append([i, *[int(x) for x in input().split()]])
    f(c)
e()","def c():
    import i
    a = i.stdin.read().split()
    if not a:
        return
    n = int(a[0])
    b = list(map(int, a[1:1+n]))

    d = set(range(1, n + 1))

    h = [None] * n

    for i, g in enumerate(b):
        if 1 <= g <= n and g in d:
            h[i] = g
            d.remove(g)
        else:
            h[i] = None

    f = sorted(d)
    e = 0

    for i in range(n):
        if h[i] is None:
            h[i] = f[e]
            e += 1

    print("" "".join(map(str, h)))
    
if __name__ == '__main__':
    c()"
78,C,Beaver Game,PROGRAMMING,"['dp', 'games', 'number theory']","Two beavers, Timur and Marsel, play the following game.

There are *n* logs, each of exactly *m* meters in length. The beavers move in turns. For each move a beaver chooses a log and gnaws it into some number (more than one) of equal parts, the length of each one is expressed by an integer and is no less than *k* meters. Each resulting part is also a log which can be gnawed in future by any beaver. The beaver that can't make a move loses. Thus, the other beaver wins.

Timur makes the first move. The players play in the optimal way. Determine the winner.","The first line contains three integers *n*, *m*, *k* (1<=≤<=*n*,<=*m*,<=*k*<=≤<=109).","Print ""Timur"", if Timur wins, or ""Marsel"", if Marsel wins. You should print everything without the quotes.","['1 15 4\n', '4 9 5\n']","['Timur', 'Marsel']","In the first sample the beavers only have one log, of 15 meters in length. Timur moves first. The only move he can do is to split the log into 3 parts each 5 meters in length. Then Marsel moves but he can't split any of the resulting logs, as *k* = 4. Thus, the winner is Timur.

In the second example the beavers have 4 logs 9 meters in length. Timur can't split any of them, so that the resulting parts possessed the length of not less than 5 meters, that's why he loses instantly.",WRONG_ANSWER,"from sys import b, c

def a(m, k):
    for i in range(1, int(m ** 0.5) + 1):
        if not m % i and (i >= k or m // i >= k):
            return 1
    else:
        return 0

n, m, k = map(int, b.readline().split())

if m < 2 * k or not a(m, k):
    c.write('Marsel')
elif n % 2:
    c.write('Timur')
else:
    c.write('Marsel')","import l
l.setrecursionlimit(10**6)

def f():

    e = l.stdin.read().split()
    if not e:
        return
    n = int(e[0])

    if n % 2 != 0:
        print(-1)
        return

    c = [[] for _ in range(n + 1)]
    d = 1
    for i in range(n - 1):
        u = int(e[d])
        v = int(e[d + 1])
        d += 2
        c[u].append(v)
        c[v].append(u)
    
    i = 0

    def b(g, h):
        nonlocal i
        k = 1
        for a in c[g]:
            if a != h:
                j = b(a, g)

                if j % 2 == 0:
                    i += 1
                else:
                    k += j
        return k
    
    b(1, -1)
    print(i)

if __name__ == ""__main__"":
    f()"
46,B,T-shirts from Sponsor,PROGRAMMING,['implementation'],"One day a well-known sponsor of a well-known contest decided to give every participant of the contest a T-shirt as a present. A natural problem occurred: on the one hand, it is not clear how many T-shirts of what sizes should be ordered, and on the other hand, one doesn't want to order too many T-shirts (and we do not exactly paper the walls with the oversupply). After considerable brain racking and some pre-estimating, the sponsor representatives ordered a certain number of T-shirts of sizes S, M, L, XL and XXL. The T-shirts turned out to bring good luck, that's why on the contest day there built up a line of *K* participants willing to get one. Every contestant is characterized by his/her desired T-shirt size (so it happens that for all the participants it is also one of the sizes S, M, L, XL and XXL). The participants come up to get a T-shirt one by one and try to choose the most suitable one, choosing it like this. If there is still a T-shirt of the optimal size left, that he/she takes it without further ado. Otherwise the contestant would prefer to choose a T-shirt with the size as close to the optimal one as possible (the distance between neighboring sizes is considered equal to one). If the variant of choice is not unique, the contestant will take a T-shirt of a bigger size (in case he/she grows more). For example, for a person whose optimal size is L the preference list looks like this: L, XL, M, XXL, S. Using the data on how many T-shirts of every size had been ordered by the organizers, on the size of contestants in the line determine who got a T-shirt of what size.","The first line contains five non-negative integers *N**S*,<=*N**M*,<=*N**L*,<=*N**XL*,<=*N**XXL* not exceeding 1000 which represent the number of T-shirts of the corresponding sizes. The second line contains an integer *K* (1<=≤<=*K*<=≤<=1000) which represents the number of participants. The next *K* lines contain the optimal T-shirt sizes for the contestants. The sizes are given in the order in which the participants stand in the line. It is guaranteed that *N**S*<=+<=*N**M*<=+<=*N**L*<=+<=*N**XL*<=+<=*N**XXL*<=≥<=*K*.","For each contestant, print a line containing the size of the T-shirt he/she got.",['1 0 2 0 1\n3\nXL\nXXL\nM\n'],['XXL\nL\nL\n'],none,OK,"import math,e;input=e.stdin.readline;S=lambda:input().rstrip();I=lambda:int(S());M=lambda:map(int,S().split());L=lambda:list(M());b=1000000007;c=998244353
from collections import a
d = a()
d[""S""],d[""M""],d[""L""],d[""XL""],d[""XXL""] = M()
f = a()
f[0],f[1],f[2],f[3],f[4] = ""S"",""M"",""L"",""XL"",""XXL""

k = I()
for i in range(k):
    p = S()
    if d[p]!=0:
        print(p)
        d[p]-=1
    else:
        if p==""S"":
            j =0
            k=0
        elif p==""M"":
            j=1
            k=1
        elif p==""L"":
            j=2
            k=2
        elif p==""XL"":
            j=3
            k=3
        elif p==""XXL"":
            j=4
            k=4

        d = j
        
        while j<4 and d[f[j]]==0  :
            j+=1
        while k>0 and d[f[k]]==0  :
            k-=1
        
        if d[f[j]]!=0 and d[f[k]]!=0:
            if abs(d-j)<=abs(d-k):
                print(f[j])
                d[f[j]]-=1
            else:
                print(f[k])
                d[f[k]]-=1
        elif d[f[j]]!=0 and d[f[k]]==0:
            print(f[j])
            d[f[j]]-=1
        else:
            print(f[k])
            d[f[k]]-=1","from collections import c
import m

def i():

    g = m.stdin.buffer.read().splitlines()

    n, q = map(int, g[0].decode().split())

    j = []

    b = [c() for _ in range(n + 1)]

    n = 0

    e = 0

    l = []

    h = 1
    for _ in range(q):
        k = g[h].decode().split()
        h += 1
        d = int(k[0])
        
        if d == 1:

            x = int(k[1])
            j.append([x, 0])

            b[x].append(len(j) - 1)
            n += 1
        
        elif d == 2:

            x = int(k[1])

            while b[x]:
                f = b[x].popleft()
                if j[f][1] == 0:
                    j[f][1] = 1
                    n -= 1
        
        elif d == 3:

            t = int(k[1])

            while e < t:
                a = j[e][0]
                if j[e][1] == 0:
                    j[e][1] = 1
                    n -= 1

                    if b[a] and b[a][0] == e:
                        b[a].popleft()
                e += 1

        l.append(str(n))
    
    m.stdout.write(""\n"".join(l))

if __name__ == '__main__':
    i()"
429,B,Working out,PROGRAMMING,['dp'],"Summer is coming! It's time for Iahub and Iahubina to work out, as they both want to look hot at the beach. The gym where they go is a matrix *a* with *n* lines and *m* columns. Let number *a*[*i*][*j*] represents the calories burned by performing workout at the cell of gym in the *i*-th line and the *j*-th column.

Iahub starts with workout located at line 1 and column 1. He needs to finish with workout *a*[*n*][*m*]. After finishing workout *a*[*i*][*j*], he can go to workout *a*[*i*<=+<=1][*j*] or *a*[*i*][*j*<=+<=1]. Similarly, Iahubina starts with workout *a*[*n*][1] and she needs to finish with workout *a*[1][*m*]. After finishing workout from cell *a*[*i*][*j*], she goes to either *a*[*i*][*j*<=+<=1] or *a*[*i*<=-<=1][*j*]. 

There is one additional condition for their training. They have to meet in exactly one cell of gym. At that cell, none of them will work out. They will talk about fast exponentiation (pretty odd small talk) and then both of them will move to the next workout.

If a workout was done by either Iahub or Iahubina, it counts as total gain. Please plan a workout for Iahub and Iahubina such as total gain to be as big as possible. Note, that Iahub and Iahubina can perform workouts with different speed, so the number of cells that they use to reach meet cell may differs.","The first line of the input contains two integers *n* and *m* (3<=≤<=*n*,<=*m*<=≤<=1000). Each of the next *n* lines contains *m* integers: *j*-th number from *i*-th line denotes element *a*[*i*][*j*] (0<=≤<=*a*[*i*][*j*]<=≤<=105).",The output contains a single number — the maximum total gain possible.,['3 3\n100 100 100\n100 1 100\n100 100 100\n'],['800'],Iahub will choose exercises *a*[1][1] → *a*[1][2] → *a*[2][2] → *a*[3][2] → *a*[3][3]. Iahubina will choose exercises *a*[3][1] → *a*[2][1] → *a*[2][2] → *a*[2][3] → *a*[1][3].,RUNTIME_ERROR,"import h
input = h.stdin.buffer.readline 

def e(A):
    n = len(A)
    m = len(A[0])
    d = {}
    for i in range(n):
        for j in range(m):
            d[(i, j)] = [0, 0, 0, 0]
            if i > 0:
                a = d[(i-1, j)][0]
            else:
                a = 0
            if j > 0:
                d = d[(i, j-1)][0]
            else:
                d = 0
            d[(i, j)][0] = A[i][j]+max(d, a)
        for j in range(m-1, -1, -1):
            if i > 0:
                a = d[(i-1, j)][1]
            else:
                a = 0
            if j < m-1:
                f = d[(i, j+1)][1]
            else:
                f = 0
            d[(i, j)][1] = A[i][j]+max(a, f)
            
    for i in range(n-1, -1, -1):
        for j in range(m):
            if i  < n-1:
                c = d[(i+1, j)][2]
            else:
                c = 0
            if j > 0:
                d = d[(i, j-1)][2]
            else:
                d = 0
            d[(i, j)][2] = A[i][j]+max(d, c)
        for j in range(m-1, -1, -1):
            if i < n-1:
                c = d[(i+1, j)][3]
            else:
                c = 0
            if j < m-1:
                f = d[(i, j+1)][3]
            else:
                f = 0
            d[(i, j)][3] = A[i][j]+max(c, f)
    b = -1*float('inf')
    for i in range(n):
        for j in range(m):
            b = max(b, sum(d[(i, j)])-4*A[i][j])
    return b
      
n, m = [int(x) for x in input().split()]
A = []
for i in range(n):
    g = [int(x) for x in input().split()]
    A.append(g)
print(e(g))","def c():
    import d
    b = d.stdin.read().split()
    if not b:
        return

    n = int(b[0])

    d = None
    a = 3

    while a <= n:

        if n % a != 0:
            d = a
            break
        a *= 3

    if d is None:
        d = a

    m = (n + d - 1) // d

    d.stdout.write(str(m))
    
if __name__ == '__main__':
    c()"
186,B,Growing Mushrooms,PROGRAMMING,"['greedy', 'sortings']","Each year in the castle of Dwarven King there is a competition in growing mushrooms among the dwarves. The competition is one of the most prestigious ones, and the winner gets a wooden salad bowl. This year's event brought together the best mushroom growers from around the world, so we had to slightly change the rules so that the event gets more interesting to watch.

Each mushroom grower has a mushroom that he will grow on the competition. Under the new rules, the competition consists of two parts. The first part lasts *t*1 seconds and the second part lasts *t*2 seconds. The first and the second part are separated by a little break.

After the starting whistle the first part of the contest starts, and all mushroom growers start growing mushrooms at once, each at his individual speed of *v**i* meters per second. After *t*1 seconds, the mushroom growers stop growing mushrooms and go to have a break. During the break, for unexplained reasons, the growth of all mushrooms is reduced by *k* percent. After the break the second part of the contest starts and all mushrooms growers at the same time continue to grow mushrooms, each at his individual speed of *u**i* meters per second. After a *t*2 seconds after the end of the break, the competition ends. Note that the speeds before and after the break may vary.

Before the match dwarf Pasha learned from all participants, what two speeds they have chosen. However, the participants did not want to disclose to him all their strategy and therefore, did not say in what order they will be using these speeds. That is, if a participant chose speeds *a**i* and *b**i*, then there are two strategies: he either uses speed *a**i* before the break and speed *b**i* after it, or vice versa.

Dwarf Pasha really wants to win the totalizer. He knows that each participant chooses the strategy that maximizes the height of the mushroom. Help Dwarf Pasha make the final table of competition results.

The participants are sorted in the result table by the mushroom height (the participants with higher mushrooms follow earlier in the table). In case of equal mushroom heights, the participants are sorted by their numbers (the participants with a smaller number follow earlier).","The first input line contains four integer numbers *n*, *t*1, *t*2, *k* (1<=≤<=*n*,<=*t*1,<=*t*2<=≤<=1000; 1<=≤<=*k*<=≤<=100) — the number of participants, the time before the break, the time after the break and the percentage, by which the mushroom growth drops during the break, correspondingly.

Each of the following *n* lines contains two integers. The *i*-th (1<=≤<=*i*<=≤<=*n*) line contains space-separated integers *a**i*, *b**i* (1<=≤<=*a**i*,<=*b**i*<=≤<=1000) — the speeds which the participant number *i* chose.","Print the final results' table: *n* lines, each line should contain the number of the corresponding dwarf and the final maximum height of his mushroom with exactly two digits after the decimal point. The answer will be considered correct if it is absolutely accurate.","['2 3 3 50\n2 4\n4 2\n', '4 1 1 1\n544 397\n280 101\n280 101\n693 970\n']","['1 15.00\n2 15.00\n', '4 1656.07\n1 937.03\n2 379.99\n3 379.99\n']","-  First example: for each contestant it is optimal to use firstly speed 2 and afterwards speed 4, because 2·3·0.5 + 4·3 &gt; 4·3·0.5 + 2·3.",OK,"def c():

    n, f, g, k = [int(i) for i in input().split()]

    v = []
    for i in range(n):
        a, b = [int(i) for i in input().split()]
        v.append([a, b])

    e = []
    for i in range(n):
        a, b = v[i]

        a = a * f * (1 - k / 100) + b * g
        b = b * f * (1 - k / 100) + a * g

        h = max(a, b)

        e.append([i + 1, h])

    for i, d in sorted(e, key=lambda x: x[1], reverse=True):
        print(f'{i} {d:.2f}')

if __name__ == '__main__':
    c()","import e

def c():

    b = e.stdin.read().split()

    n = int(b[0])
    t = int(b[1])

    d = list(map(int, b[2:]))

    a = 1

    while a < t:

        a += d[a - 1]

    if a == t:
        print(""YES"")
    else:
        print(""NO"")

if __name__ == ""__main__"":
    c()"
441,C,Valera and Tubes ,PROGRAMMING,"['constructive algorithms', 'dfs and similar', 'implementation']","Valera has got a rectangle table consisting of *n* rows and *m* columns. Valera numbered the table rows starting from one, from top to bottom and the columns – starting from one, from left to right. We will represent cell that is on the intersection of row *x* and column *y* by a pair of integers (*x*,<=*y*).

Valera wants to place exactly *k* tubes on his rectangle table. A tube is such sequence of table cells (*x*1,<=*y*1), (*x*2,<=*y*2), ..., (*x**r*,<=*y**r*), that: 
 -  *r*<=≥<=2; -  for any integer *i* (1<=≤<=*i*<=≤<=*r*<=-<=1) the following equation |*x**i*<=-<=*x**i*<=+<=1|<=+<=|*y**i*<=-<=*y**i*<=+<=1|<==<=1 holds; -  each table cell, which belongs to the tube, must occur exactly once in the sequence. 
Valera thinks that the tubes are arranged in a fancy manner if the following conditions are fulfilled: 
 -  no pair of tubes has common cells; -  each cell of the table belongs to some tube. 
Help Valera to arrange *k* tubes on his rectangle table in a fancy manner.","The first line contains three space-separated integers *n*,<=*m*,<=*k* (2<=≤<=*n*,<=*m*<=≤<=300; 2<=≤<=2*k*<=≤<=*n*·*m*) — the number of rows, the number of columns and the number of tubes, correspondingly.","Print *k* lines. In the *i*-th line print the description of the *i*-th tube: first print integer *r**i* (the number of tube cells), then print 2*r**i* integers *x**i*1,<=*y**i*1,<=*x**i*2,<=*y**i*2,<=...,<=*x**ir**i*,<=*y**ir**i* (the sequence of table cells).

If there are multiple solutions, you can print any of them. It is guaranteed that at least one solution exists.","['3 3 3\n', '2 3 1\n']","['3 1 1 1 2 1 3\n3 2 1 2 2 2 3\n3 3 1 3 2 3 3\n', '6 1 1 1 2 1 3 2 3 2 2 2 1\n']","Picture for the first sample: 

Picture for the second sample:",OK,"def a(a):
	print(len(a),end = "" "")
	print("" "".join(map(lambda x: "" "".join(str(i) for i in x), a)))
n, m, k = map(int, input().split())
b = [(x+1,y+1) for x in range(n) for y in range(m)[::(1 if (x%2 == 0) else -1)]]
for i in range(k-1):
	a(b[2*i:2*i+2])
a(b[2*k-2:])","import l
import f

def e():

    c = l.stdin.read().split()
    if not c:
        return
    g = []
    d = iter(c)
    while True:
        try:

            t = int(next(d))
            w = int(next(d))
            b = int(next(d))
        except StopIteration:
            break

        g = f.gcd(w, b)

        n = w // g
        a = b // g

        b = min(n, a)

        M = g * n * a

        m = 0

        m += max(0, min(b, t + 1) - 1)

        R = t // M
        if R >= 1:

            j = (t - b + 1) // M if t >= b else 0
            h = j * b

            a = j + 1
            if a <= R:
                n = R - a + 1

                k = (R * (R + 1) - (a - 1) * a) // 2
                i = n * (t + 1) - M * k
            else:
                i = 0
            m += h + i

        if m == 0:
            p, q = 0, 1
        else:
            p, q = m, t
            d = f.gcd(p, q)
            p //= d
            q //= d

        g.append(f""{p}/{q}"")

    l.stdout.write(""\n"".join(g))

if __name__ == ""__main__"":
    e()"
169,A,Chores,PROGRAMMING,['sortings'],"Petya and Vasya are brothers. Today is a special day for them as their parents left them home alone and commissioned them to do *n* chores. Each chore is characterized by a single parameter — its complexity. The complexity of the *i*-th chore equals *h**i*.

As Petya is older, he wants to take the chores with complexity larger than some value *x* (*h**i*<=&gt;<=*x*) to leave to Vasya the chores with complexity less than or equal to *x* (*h**i*<=≤<=*x*). The brothers have already decided that Petya will do exactly *a* chores and Vasya will do exactly *b* chores (*a*<=+<=*b*<==<=*n*).

In how many ways can they choose an integer *x* so that Petya got exactly *a* chores and Vasya got exactly *b* chores?","The first input line contains three integers *n*,<=*a* and *b* (2<=≤<=*n*<=≤<=2000; *a*,<=*b*<=≥<=1; *a*<=+<=*b*<==<=*n*) — the total number of chores, the number of Petya's chores and the number of Vasya's chores.

The next line contains a sequence of integers *h*1,<=*h*2,<=...,<=*h**n* (1<=≤<=*h**i*<=≤<=109), *h**i* is the complexity of the *i*-th chore. The numbers in the given sequence are not necessarily different.

All numbers on the lines are separated by single spaces.","Print the required number of ways to choose an integer value of *x*. If there are no such ways, print 0.","['5 2 3\n6 2 3 100 1\n', '7 3 4\n1 1 9 1 1 1 1\n']","['3\n', '0\n']","In the first sample the possible values of *x* are 3, 4 or 5.

In the second sample it is impossible to find such *x*, that Petya got 3 chores and Vasya got 4.",OK,"d = []
b = input().split()
n = int(b[0])
a = int(b[1])
b = int(b[2])
2<=n<=2000

def a(f):
	for c in range (len(f) -1, 0, -1):
		for i in range (0, c):
			if f[i] > f[i + 1]:
				g = f[i]
				f[i] = f[i + 1]
				f[i + 1] = g

f = []
e = input().split()
for i in range (0,n):
	f.append(int(e[i]))

if (a + b == n):
    a(f)
    print(f[b] - f[b-1])
else: 
    print(""Error, el numero de tareas por persona no coincide con el no de tareas totales"")","def c():
    import f
    from collections import a

    s = f.stdin.read().strip()
    b = a(s)

    d = (b['n'] - 1) // 2 if b['n'] > 0 else 0

    e = min(b['i'], b['t'], b['e'] // 3, d)

    print(e)

if __name__ == '__main__':
    c()"
394,A,Counting Sticks,PROGRAMMING,"['brute force', 'implementation']","When new students come to the Specialized Educational and Scientific Centre (SESC) they need to start many things from the beginning. Sometimes the teachers say (not always unfairly) that we cannot even count. So our teachers decided to teach us arithmetics from the start. And what is the best way to teach students add and subtract? — That's right, using counting sticks! An here's our new task: 

An expression of counting sticks is an expression of type:

Sign + consists of two crossed sticks: one vertical and one horizontal. Sign = consists of two horizontal sticks. The expression is arithmetically correct if *A*<=+<=*B*<==<=*C*.

We've got an expression that looks like *A*<=+<=*B*<==<=*C* given by counting sticks. Our task is to shift at most one stick (or we can shift nothing) so that the expression became arithmetically correct. Note that we cannot remove the sticks from the expression, also we cannot shift the sticks from the signs + and =.

We really aren't fabulous at arithmetics. Can you help us?","The single line contains the initial expression. It is guaranteed that the expression looks like *A*<=+<=*B*<==<=*C*, where 1<=≤<=*A*,<=*B*,<=*C*<=≤<=100.","If there isn't a way to shift the stick so the expression becomes correct, print on a single line ""Impossible"" (without the quotes). If there is a way, print the resulting expression. Follow the format of the output from the test samples. Don't print extra space characters.

If there are multiple correct answers, print any of them. For clarifications, you are recommended to see the test samples.","['||+|=|||||\n', '|||||+||=||\n', '|+|=||||||\n', '||||+||=||||||\n']","['|||+|=||||\n', 'Impossible\n', 'Impossible\n', '||||+||=||||||\n']","In the first sample we can shift stick from the third group of sticks to the first one.

In the second sample we cannot shift vertical stick from + sign to the second group of sticks. So we cannot make a - sign.

There is no answer in the third sample because we cannot remove sticks from the expression.

In the forth sample the initial expression is already arithmetically correct and that is why we don't have to shift sticks.",WRONG_ANSWER,"import c
def a(x):
	return x.a(""|"")
d = input()
x=(c.split('\+|\=',d))
b=list(map(a,x))
if x[0]+x[1]==x[2]:
	print(x[0]+""+""+x[1]+""=""+x[2])
elif (b[0]-1)+(b[1]+1)==b[2]:
	print(""|""*(b[0]-1)+""+""+""|""*(b[1]+1)+""=""+""|""*b[2])
elif (b[0]+1)+(b[1]-1)==b[2]:
	print(""|""*(b[0]+1)+""+""+""|""*(b[1]-1)+""=""+""|""*b[2])
elif (b[0]-1)+(b[1])==b[2]+1:
	print(""|""*(b[0]-1)+""+""+""|""*(b[1])+""=""+""|""*(b[2]+1))
elif (b[0]+1)+(b[1])==b[2]-1:
	print(""|""*(b[0]+1)+""+""+""|""*(b[1])+""=""+""|""*(b[2]-1))
elif (b[0])+(b[1]+1)==b[2]-1:
	print(""|""*(b[0])+""+""+""|""*(b[1]+1)+""=""+""|""*(b[2]-1))
elif (b[0])+(b[1]+1)==b[2]+1:
	print(""|""*(b[0])+""+""+""|""*(b[1]-1)+""=""+""|""*(b[2]+1))
else:
	print(""Impossible"")","def b():

    n = int(input())

    a = list(map(int, input().split()))

    for i in range(n):
        if i == 0:

            d = abs(a[i+1] - a[i])

            c = abs(a[-1] - a[i])
        elif i == n - 1:

            d = abs(a[i] - a[i-1])

            c = abs(a[i] - a[0])
        else:

            d = min(a[i] - a[i-1], a[i+1] - a[i])

            c = max(a[i] - a[0], a[-1] - a[i])
        print(d, c)

if __name__ == '__main__':
    b()"
136,A,Presents,PROGRAMMING,['implementation'],"Little Petya very much likes gifts. Recently he has received a new laptop as a New Year gift from his mother. He immediately decided to give it to somebody else as what can be more pleasant than giving somebody gifts. And on this occasion he organized a New Year party at his place and invited *n* his friends there.

If there's one thing Petya likes more that receiving gifts, that's watching others giving gifts to somebody else. Thus, he safely hid the laptop until the next New Year and made up his mind to watch his friends exchanging gifts while he does not participate in the process. He numbered all his friends with integers from 1 to *n*. Petya remembered that a friend number *i* gave a gift to a friend number *p**i*. He also remembered that each of his friends received exactly one gift.

Now Petya wants to know for each friend *i* the number of a friend who has given him a gift.",The first line contains one integer *n* (1<=≤<=*n*<=≤<=100) — the quantity of friends Petya invited to the party. The second line contains *n* space-separated integers: the *i*-th number is *p**i* — the number of a friend who gave a gift to friend number *i*. It is guaranteed that each friend received exactly one gift. It is possible that some friends do not share Petya's ideas of giving gifts to somebody else. Those friends gave the gifts to themselves.,Print *n* space-separated integers: the *i*-th number should equal the number of the friend who gave a gift to friend number *i*.,"['4\n2 3 4 1\n', '3\n1 3 2\n', '2\n1 2\n']","['4 1 2 3\n', '1 3 2\n', '1 2\n']",none,OK,"def a(n, c):
    b = [0] * t
    for i in range(t):
        b[c[i] - 1] = i + 1
    return b
 
t = int(input())
c = list(map(int, input().split()))
 
d = a(t, c)
print(*d)","import f

def d():

    b = f.stdin.read().strip().split()

    n = int(b[0])
    l = int(b[1])

    c = list(map(int, b[2:2+n]))
    c.sort()

    e = c[0]

    for i in range(1, n):
        a = (c[i] - c[i - 1]) / 2.0
        if a > e:
            e = a

    if (l - c[-1]) > e:
        e = l - c[-1]

    print(""{:.10f}"".format(e))

if __name__ == ""__main__"":
    d()"
412,A,Poster,PROGRAMMING,"['greedy', 'implementation']","The R1 company has recently bought a high rise building in the centre of Moscow for its main office. It's time to decorate the new office, and the first thing to do is to write the company's slogan above the main entrance to the building.

The slogan of the company consists of *n* characters, so the decorators hung a large banner, *n* meters wide and 1 meter high, divided into *n* equal squares. The first character of the slogan must be in the first square (the leftmost) of the poster, the second character must be in the second square, and so on.

Of course, the R1 programmers want to write the slogan on the poster themselves. To do this, they have a large (and a very heavy) ladder which was put exactly opposite the *k*-th square of the poster. To draw the *i*-th character of the slogan on the poster, you need to climb the ladder, standing in front of the *i*-th square of the poster. This action (along with climbing up and down the ladder) takes one hour for a painter. The painter is not allowed to draw characters in the adjacent squares when the ladder is in front of the *i*-th square because the uncomfortable position of the ladder may make the characters untidy. Besides, the programmers can move the ladder. In one hour, they can move the ladder either a meter to the right or a meter to the left.

Drawing characters and moving the ladder is very tiring, so the programmers want to finish the job in as little time as possible. Develop for them an optimal poster painting plan!","The first line contains two integers, *n* and *k* (1<=≤<=*k*<=≤<=*n*<=≤<=100) — the number of characters in the slogan and the initial position of the ladder, correspondingly. The next line contains the slogan as *n* characters written without spaces. Each character of the slogan is either a large English letter, or digit, or one of the characters: '.', '!', ',', '?'.","In *t* lines, print the actions the programmers need to make. In the *i*-th line print:
 -  ""LEFT"" (without the quotes), if the *i*-th action was ""move the ladder to the left""; -  ""RIGHT"" (without the quotes), if the *i*-th action was ""move the ladder to the right""; -  ""PRINT *x*"" (without the quotes), if the *i*-th action was to ""go up the ladder, paint character *x*, go down the ladder"". 
The painting time (variable *t*) must be minimum possible. If there are multiple optimal painting plans, you can print any of them.","['2 2\nR1\n', '2 1\nR1\n', '6 4\nGO?GO!\n']","['PRINT 1\nLEFT\nPRINT R\n', 'PRINT R\nRIGHT\nPRINT 1\n', 'RIGHT\nRIGHT\nPRINT !\nLEFT\nPRINT O\nLEFT\nPRINT G\nLEFT\nPRINT ?\nLEFT\nPRINT O\nLEFT\nPRINT G\n']","Note that the ladder cannot be shifted by less than one meter. The ladder can only stand in front of some square of the poster. For example, you cannot shift a ladder by half a meter and position it between two squares. Then go up and paint the first character and the second character.",OK,"def a(n,k,s):
    k-=1
    if n%2 == 0:
        if k < n//2:
            while k > 0:
                print(""LEFT"")
                k -= 1
            while k < n:
                print(""PRINT"", s[k])
                if k != n-1:
                    print(""RIGHT"")
                k += 1
        else:
            while k < n-1:
                print(""RIGHT"")
                k += 1
            while k > -1:
                print(""PRINT"", s[k])
                if k != 0:
                    print(""LEFT"")
                k-=1
    else:
        if k > n//2:
            while k < n-1:
                print(""RIGHT"")
                k += 1
            while k > -1:
                print(""PRINT"", s[k])
                if k != 0:
                    print(""LEFT"")
                k-=1
        else:
            while k > 0:
                print(""LEFT"")
                k -= 1
            while k < n:
                print(""PRINT"", s[k])
                if k != n-1:
                    print(""RIGHT"")
                k += 1

n,k = map(int, input().split())
s = input()

a(n,k,s)","import g

def e():

    c = g.stdin.readlines()

    for d in c:
        d = d.strip()
        if not d:
            continue
        n = int(d)
        
        h = 0
        a = 1

        while True:

            f = 10 ** (a - 1)

            b = 10 ** a - 1
            
            if n >= b:

                h += (b - f + 1) * a
            else:

                h += (n - f + 1) * a
                break
            
            a += 1

        print(h)

if __name__ == '__main__':
    e()"
127,A,Wasted Time,PROGRAMMING,['geometry'],"Mr. Scrooge, a very busy man, decided to count the time he wastes on all sorts of useless stuff to evaluate the lost profit. He has already counted the time he wastes sleeping and eating. And now Mr. Scrooge wants to count the time he has wasted signing papers.

Mr. Scrooge's signature can be represented as a polyline *A*1*A*2... *A**n*. Scrooge signs like that: first it places a pen at the point *A*1, then draws a segment from point *A*1 to point *A*2, then he draws a segment from point *A*2 to point *A*3 and so on to point *A**n*, where he stops signing and takes the pen off the paper. At that the resulting line can intersect with itself and partially repeat itself but Scrooge pays no attention to it and never changes his signing style. As Scrooge makes the signature, he never takes the pen off the paper and his writing speed is constant — 50 millimeters per second.

Scrooge signed exactly *k* papers throughout his life and all those signatures look the same.

Find the total time Scrooge wasted signing the papers.","The first line contains two integers *n* and *k* (2<=≤<=*n*<=≤<=100, 1<=≤<=*k*<=≤<=1000). Each of the following *n* lines contains the coordinates of the polyline's endpoints. The *i*-th one contains coordinates of the point *A**i* — integers *x**i* and *y**i*, separated by a space.

All points *A**i* are different. The absolute value of all coordinates does not exceed 20. The coordinates are measured in millimeters.",Print one real number — the total time Scrooges wastes on signing the papers in seconds. The absolute or relative error should not exceed 10<=-<=6.,"['2 1\n0 0\n10 0\n', '5 10\n3 1\n-5 6\n-2 -1\n3 2\n10 0\n', '6 10\n5 0\n4 0\n6 0\n3 0\n7 0\n2 0\n']","['0.200000000', '6.032163204', '3.000000000']",none,OK,"class d:
    x= 0
    y = 0
    def __init__(e,a,b):
        e.x = a
        e.y = b
def b(a,b):
    return (((b.x-a.x)*(b.x-a.x))+((b.y-a.y)*(b.y-a.y)))**.5
a = []
n,k = list(map(int,input().split()))
for i in range(0,n,1):
    a,b = list(map(int,input().split()))
    p = d(a,b)
    a.append(p)
c = 0.0 
for i in range(0, n-1,1):
    c += (b(a[i],a[(i+1)]))

print('{0:.8f}'.format((c*k)/50))","import d
import c

def b():

    a = d.stdin.read().split()

    A, B, C = map(int, a)

    x = int(c.sqrt((A * B) / C))
    y = int(c.sqrt((A * C) / B))
    z = int(c.sqrt((B * C) / A))

    e = 4 * (x + y + z)

    print(e)

if __name__ == ""__main__"":
    b()"
676,C,Vasya and String,PROGRAMMING,"['binary search', 'dp', 'strings', 'two pointers']","High school student Vasya got a string of length *n* as a birthday present. This string consists of letters 'a' and 'b' only. Vasya denotes beauty of the string as the maximum length of a substring (consecutive subsequence) consisting of equal letters.

Vasya can change no more than *k* characters of the original string. What is the maximum beauty of the string he can achieve?","The first line of the input contains two integers *n* and *k* (1<=≤<=*n*<=≤<=100<=000,<=0<=≤<=*k*<=≤<=*n*) — the length of the string and the maximum number of characters to change.

The second line contains the string, consisting of letters 'a' and 'b' only.",Print the only integer — the maximum beauty of the string Vasya can achieve by changing no more than *k* characters.,"['4 2\nabba\n', '8 1\naabaabaa\n']","['4\n', '5\n']","In the first sample, Vasya can obtain both strings ""aaaa"" and ""bbbb"".

In the second sample, the optimal answer is obtained with the string ""aaaaabaa"" or with the string ""aabaaaaa"".",OK,"import n
from collections import defaultdict as dd
from collections import deque
from fractions import Fraction as f
from copy import *
from bisect import * 
from heapq import *

from itertools import permutations 
 
def e(*b):
    print(*b, file=n.stderr)
o=1

if o:
	input=n.stdin.readline
else: 
	n.stdin=open('input.txt', 'r')
	n.stdout=open('all.txt','w')
def i():
	return [int(x) for x in input().split()]
def f():
	return int(input())
def m():
	return list(input().rstrip()) 
def j():
	return  map(int,input().split()) 
def g():
	n.stdout.flush()
def h(n,m):
	for i in range(m):
		x,y=j()
		a[x].append(y)
		a[y].append(x)
def c(i):
	return ord(i)-ord('a')

def d(k):
	d=[0,0]
	l=n
	for i in range(n):
		if i>=k:
			l=min(d[0],min(d[1],l))
			d[c(a[i-k])]-=1
		d[c(a[i])]+=1
  
	l=min(d[0],min(d[1],l)) 
	return l<=k  
n,k=j()
a=m()
l=0
r=a=n
while l<=r:
	k=(l+r)//2
	if d(k):
		a=k
		l=k+1
	else:
		r=k-1
print(a)","x = input().strip()

a = list(x)

for i in range(len(a)):

    d = int(a[i])

    b = 9 - d

    if i == 0:

        if b == 0 or b >= d:
            continue

    else:
        if b < d:
            a[i] = str(b)

c = """".join(a)

print(c)"
472,A,Design Tutorial: Learn from Math,PROGRAMMING,"['math', 'number theory']","One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.

For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.

You are given an integer *n* no less than 12, express it as a sum of two composite numbers.",The only line contains an integer *n* (12<=≤<=*n*<=≤<=106).,"Output two composite integers *x* and *y* (1<=&lt;<=*x*,<=*y*<=&lt;<=*n*) such that *x*<=+<=*y*<==<=*n*. If there are multiple solutions, you can output any of them.","['12\n', '15\n', '23\n', '1000000\n']","['4 8\n', '6 9\n', '8 15\n', '500000 500000\n']","In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output ""6 6"" or ""8 4"" as well.

In the second example, 15 = 6 + 9. Note that you can't output ""1 14"" because 1 is not a composite number.",TIME_LIMIT_EXCEEDED,"from itertools import b
def a(c):
    for i in range(2, c):
        if c % i == 0:
            return True
    return False
n = int(input())
c = []
for i in range(4, n):
    if a(i):
        c.append(i)
for i in b(c, 2):
    if sum(i) == n:
        print(i[0], i[1])
        break","def h():
    import o
    o.setrecursionlimit(10**6)

    c = o.stdin.read().split()
    if not c:
        return
    n = int(c[0])

    f = [[] for _ in range(n + 1)]
    g = 1
    for _ in range(n - 1):
        u = int(c[g])
        v = int(c[g + 1])
        g += 2
        f[u].append(v)
        f[v].append(u)

    i = 0
    for i in range(1, n + 1):
        i = max(i, len(f[i]))
    k = i + 1

    a = [0] * (n + 1)

    def d(k, m, n):

        e = {a[k]}
        if n:
            e.add(n)
        b = 1
        for j in f[k]:
            if j == m:
                continue

            while b in e:
                b += 1
            a[j] = b
            e.add(b)
            d(j, k, a[k])
            b += 1

    a[1] = 1
    d(1, 0, 0)

    l = []
    l.append(str(k))
    l.append("" "".join(str(a[i]) for i in range(1, n + 1)))
    o.stdout.write(""\n"".join(l))
    
if __name__ == '__main__':
    h()"
915,F,Imbalance Value of a Tree,PROGRAMMING,"['data structures', 'dsu', 'graphs', 'trees']","You are given a tree *T* consisting of *n* vertices. A number is written on each vertex; the number written on vertex *i* is *a**i*. Let's denote the function *I*(*x*,<=*y*) as the difference between maximum and minimum value of *a**i* on a simple path connecting vertices *x* and *y*.

Your task is to calculate .","The first line contains one integer number *n* (1<=≤<=*n*<=≤<=106) — the number of vertices in the tree.

The second line contains *n* integer numbers *a*1, *a*2, ..., *a**n* (1<=≤<=*a**i*<=≤<=106) — the numbers written on the vertices.

Then *n*<=-<=1 lines follow. Each line contains two integers *x* and *y* denoting an edge connecting vertex *x* and vertex *y* (1<=≤<=*x*,<=*y*<=≤<=*n*, *x*<=≠<=*y*). It is guaranteed that these edges denote a tree.",Print one number equal to .,['4\n2 2 3 1\n1 2\n1 3\n1 4\n'],['6\n'],none,WRONG_ANSWER,"import o
import bisect
import random
import io, os
from bisect import *
from collections import *
from contextlib import redirect_stdout
from itertools import *
from array import *
from functools import lru_cache, reduce
from types import GeneratorType
from heapq import *
from math import sqrt, gcd, inf

if o.version >= '3.8':
    from math import comb

e = lambda: map(int, o.stdin.buffer.readline().split())
g = lambda: map(bytes.decode, o.stdin.buffer.readline().strip().split())
f = lambda: list(e())
a = lambda *x: o.stderr.write(f'{str(x)}\n')

c = 10 ** 9 + 7
d = """"""https://codeforces.com/problemset/problem/915/F

输入 n (1≤n≤1e6) 和长为 n 的数组 a(1≤a[i]≤1e6)，下标从 1 开始。
然后输入一棵树的 n-1 条边，节点编号从 1 开始。

定义 Δ(x,y) 表示从 x 到 y 的简单路径上的 a[i] 的最大值与最小值的差。
输出所有 Δ(i,j) 的和，其中 1≤i≤j≤n。
输入
4
2 2 3 1
1 2
1 3
1 4
输出 6
""""""

class b:
    def __init__(m, n):
        m.fathers = list(range(n))
        m.size = [1] * n
        m.edge_size = [0] * n
        m.n = n
        m.setCount = n

    def k(m, x):
        l = m.fathers
        t = x
        while l[x] != x:
            x = l[x]
        while t != x:
            l[t], t = x, l[t]
        return x

    def p(m, x: int, y: int) -> bool:
        x = m.k(x)
        y = m.k(y)

        if x == y:
            m.edge_size[y] += 1
            return False

        m.fathers[x] = y
        m.size[y] += m.size[x]
        m.edge_size[y] += 1 + m.edge_size[x]
        m.setCount -= 1
        return True

def n():
    n, = e()
    a = f()
    j = []
    for _ in range(n - 1):
        u, v = e()
        u -= 1
        v -= 1
        if a[u] > a[v]:
            u, v = v, u
        j.append((u, v))
    h = 0

    j.sort(key=lambda x: a[x[1]])
    i = b(n)
    for u, v in j:
        u, v = i.k(u), i.k(v)
        h += a[v] * i.size[u] * i.size[v]
        i.p(u, v)
    j.sort(key=lambda x: a[x[0]], reverse=True)
    i = b(n)
    for u, v in j:
        u, v = i.k(u), i.k(v)
        h -= a[u] * i.size[u] * i.size[v]
        i.p(u, v)
    print(h)

if __name__ == '__main__':
    n()","import j
from collections import e

def h():
    g = j.stdin.read().split()

    n = int(g[0])

    i = e(int)
    a = e(int)
    
    f = 1
    for _ in range(n):

        x = int(g[f])
        y = int(g[f+1])
        f += 2

        i[x - y] += 1
        a[x + y] += 1

    def c(d):
        return d * (d - 1) // 2

    b = 0

    for d in i.values():
        b += c(d)

    for d in a.values():
        b += c(d)

    j.stdout.write(str(b) + ""\n"")

if __name__ == ""__main__"":
    h()"
304,A,Pythagorean Theorem II,PROGRAMMING,"['brute force', 'math']","In mathematics, the Pythagorean theorem — is a relation in Euclidean geometry among the three sides of a right-angled triangle. In terms of areas, it states:

 In any right-angled triangle, the area of the square whose side is the hypotenuse (the side opposite the right angle) is equal to the sum of the areas of the squares whose sides are the two legs (the two sides that meet at a right angle). 

The theorem can be written as an equation relating the lengths of the sides *a*, *b* and *c*, often called the Pythagorean equation:

where *c* represents the length of the hypotenuse, and *a* and *b* represent the lengths of the other two sides.

Given *n*, your task is to count how many right-angled triangles with side-lengths *a*, *b* and *c* that satisfied an inequality 1<=≤<=*a*<=≤<=*b*<=≤<=*c*<=≤<=*n*.",The only line contains one integer *n* (1<=≤<=*n*<=≤<=104) as we mentioned above.,Print a single integer — the answer to the problem.,"['5\n', '74\n']","['1\n', '35\n']",none,WRONG_ANSWER,"'''
    Auther: ghoshashis545 Ashis Ghosh
    college: jalpaiguri Govt Enggineering College
    Date:07/03/2020
'''
from math import ceil,f,gcd,log,floor
from collections import deque
def b(): return int(input())
def e(): return input()
def d(): return map(int,input().strip().split("" ""))
def c(): return list(d())

n=b()
a=0
for i in range(1,n-1):
    for j in range(i+1,n-1):
        c=(i*i)+(j*j)
        x=f(c)
        x=int(x)
        if(x*x==c and x<=n):

            a+=1
print(a)","def c():
    import g

    a = g.stdin.read().split()
    if not a:
        return

    n = int(a[0])
    f = []

    for i in range(n):
        l = int(a[2 * i + 1])
        r = int(a[2 * i + 2])
        f.append((l, r, i + 1))

    e = min(l for l, r, b in f)
    d = max(r for l, r, b in f)

    for l, r, b in f:
        if l <= e and r >= d:
            g.stdout.write(str(b))
            return

    g.stdout.write(""-1"")

if __name__ == '__main__':
    c()"
148,A,Insomnia cure,PROGRAMMING,"['constructive algorithms', 'implementation', 'math']","«One dragon. Two dragon. Three dragon», — the princess was counting. She had trouble falling asleep, and she got bored of counting lambs when she was nine.

However, just counting dragons was boring as well, so she entertained herself at best she could. Tonight she imagined that all dragons were here to steal her, and she was fighting them off. Every *k*-th dragon got punched in the face with a frying pan. Every *l*-th dragon got his tail shut into the balcony door. Every *m*-th dragon got his paws trampled with sharp heels. Finally, she threatened every *n*-th dragon to call her mom, and he withdrew in panic.

How many imaginary dragons suffered moral or physical damage tonight, if the princess counted a total of *d* dragons?","Input data contains integer numbers *k*,<=*l*,<=*m*,<=*n* and *d*, each number in a separate line (1<=≤<=*k*,<=*l*,<=*m*,<=*n*<=≤<=10, 1<=≤<=*d*<=≤<=105).",Output the number of damaged dragons.,"['1\n2\n3\n4\n12\n', '2\n3\n4\n5\n24\n']","['12\n', '17\n']","In the first case every first dragon got punched with a frying pan. Some of the dragons suffered from other reasons as well, but the pan alone would be enough.

In the second case dragons 1, 7, 11, 13, 17, 19 and 23 escaped unharmed.",OK,"def b(a, d):
    for k in a:
        if d < k:
            continue
        if d % k == 0:
            return True
    return False

a = [int(input()), int(input()), int(input()), int(input())]
d = int(input())
s = 0
for i in range(1, d + 1):
    if b(a, i):
        s += 1
print(s)","import k
import i

def h():

    b = k.stdin.read().strip().split()
    if not b:
        return

    n = int(b[0])
    m = int(b[1])

    j = []
    e = 2
    for i in range(m):
        f = int(b[e])
        c = int(b[e+1])
        j.append((f, c))
        e += 2

    L = 1
    U = None
    for (f, c) in j:
        if c == 1:

            L = max(L, f)
        else:
            g = i.ceil(f / c)
            L = max(L, g)

            l = (f - 1) // (c - 1)
            if U is None:
                U = l
            else:
                U = min(U, l)

    def m(p):
        for (f, c) in j:

            d = (f + p - 1) // p
            if d != c:
                return False
        return True

    a = set()

    if U is None:

        if L >= n:

            if m(L):
                a.add(1)
        else:

            for p in range(L, n):
                if m(p):
                    a.add((n + p - 1) // p)
            if m(n):
                a.add((n + n - 1) // n)
    else:

        for p in range(L, U + 1):
            if m(p):
                a.add((n + p - 1) // p)

    if len(a) == 1:
        print(a.pop())
    else:
        print(-1)

if __name__ == '__main__':
    h()"
676,C,Vasya and String,PROGRAMMING,"['binary search', 'dp', 'strings', 'two pointers']","High school student Vasya got a string of length *n* as a birthday present. This string consists of letters 'a' and 'b' only. Vasya denotes beauty of the string as the maximum length of a substring (consecutive subsequence) consisting of equal letters.

Vasya can change no more than *k* characters of the original string. What is the maximum beauty of the string he can achieve?","The first line of the input contains two integers *n* and *k* (1<=≤<=*n*<=≤<=100<=000,<=0<=≤<=*k*<=≤<=*n*) — the length of the string and the maximum number of characters to change.

The second line contains the string, consisting of letters 'a' and 'b' only.",Print the only integer — the maximum beauty of the string Vasya can achieve by changing no more than *k* characters.,"['4 2\nabba\n', '8 1\naabaabaa\n']","['4\n', '5\n']","In the first sample, Vasya can obtain both strings ""aaaa"" and ""bbbb"".

In the second sample, the optimal answer is obtained with the string ""aaaaabaa"" or with the string ""aabaaaaa"".",OK,"def c(n, k, s):
    c = 0
    h = 0
    a = 0
    b = 0

    for f in range(n):
        if s[f] == 'a':
            a += 1
        else:
            b += 1

        g = f - h + 1

        e = min(a, b)

        while e > k:
            if s[h] == 'a':
                a -= 1
            else:
                b -= 1
            h += 1
            g -= 1
            e = min(a, b)

        c = max(c, g)
    
    return c

n, k = map(int, input().split())
s = input()

d = c(n, k, s)
print(d)","def j():
    import p, e
    f = p.stdin.read().split()
    i = iter(f)
    n = int(next(i))
    m = int(next(i))
    q = int(next(i))

    a = [int(next(i)) for _ in range(n)]
    A = 0
    for i in range(n):
        if i % 2 == 0:
            A += a[i]
        else:
            A -= a[i]

    b = [int(next(i)) for _ in range(m)]

    o = [0] * (m + 1)
    n = [0] * (m + 1)
    for i in range(m):
        o[i + 1] = o[i]
        n[i + 1] = n[i]
        if (i + 1) % 2 == 1:
            o[i + 1] += b[i]
        else:
            n[i + 1] += b[i]

    a = []
    for j in range(m - n + 1):

        k = o[j + n] - o[j]
        g = n[j + n] - n[j]
        c = k - g
        a.append(c)

    b = sorted(a)

    def h(A):
        m = e.bisect_left(b, A)
        d = float('inf')
        if m < len(b):
            d = abs(A - b[m])
        if m > 0:
            d = min(d, abs(A - b[m - 1]))
        return d

    l = [str(h(A))]

    for _ in range(q):
        l = int(next(i))
        r = int(next(i))
        x = int(next(i))
        if (r - l + 1) % 2 == 1:
            if l % 2 == 1:
                A += x
            else:
                A -= x
        l.append(str(h(A)))
    
    p.stdout.write(""\n"".join(l))
    
if __name__ == '__main__':
    j()"
0,none,none,none,['none'],"Vasya and Petya are playing a simple game. Vasya thought of number *x* between 1 and *n*, and Petya tries to guess the number.

Petya can ask questions like: ""Is the unknown number divisible by number *y*?"".

The game is played by the following rules: first Petya asks all the questions that interest him (also, he can ask no questions), and then Vasya responds to each question with a 'yes' or a 'no'. After receiving all the answers Petya should determine the number that Vasya thought of.

Unfortunately, Petya is not familiar with the number theory. Help him find the minimum number of questions he should ask to make a guaranteed guess of Vasya's number, and the numbers *y**i*, he should ask the questions about.",A single line contains number *n* (1<=≤<=*n*<=≤<=103).,"Print the length of the sequence of questions *k* (0<=≤<=*k*<=≤<=*n*), followed by *k* numbers — the questions *y**i* (1<=≤<=*y**i*<=≤<=*n*).

If there are several correct sequences of questions of the minimum length, you are allowed to print any of them.","['4\n', '6\n']","['3\n2 4 3 \n', '4\n2 4 3 5 \n']","The sequence from the answer to the first sample test is actually correct.

If the unknown number is not divisible by one of the sequence numbers, it is equal to 1.

If the unknown number is divisible by 4, it is 4.

If the unknown number is divisible by 3, then the unknown number is 3.

Otherwise, it is equal to 2. Therefore, the sequence of questions allows you to guess the unknown number. It can be shown that there is no correct sequence of questions of length 2 or shorter.",WRONG_ANSWER,"import h
import c
def a(n):

    d = set()
    g = [1] * (n + 1)
    g[0] = g[1] = 0
    for i in range(2, n + 1):
        if g[i]:
            for j in range(i * i, n + 1, i):
                g[j] = 0
            d.add(i)
    return d

def b():
    e = h.stdin.readline
    n = int(e())
    d = a(n)
    f = ['2', '4', '3']
    if n > 4:
        for i in range(5, n + 1):
            if i in d:
                f.append(str(i))
            if c.sqrt(i) in d:
                f.append(str(i))
    print(len(f))
    print(' '.join(f))

if __name__ == '__main__':
    b()","def b():
    import d

    a = d.stdin.read().strip().split()
    if not a:
        return

    n = int(a[0])

    e = list(map(int, a[1:1+n]))

    f = sum(e)

    t = f // n

    r = f % n

    e.sort()
    
    c = 0

    for i in range(n - r):
        if e[i] > t:
            c += e[i] - t

    for i in range(n - r, n):
        if e[i] > t + 1:
            c += e[i] - (t + 1)

    d.stdout.write(str(c))
    
if __name__ == ""__main__"":
    b()"
278,B,New Problem,PROGRAMMING,"['brute force', 'strings']","Coming up with a new problem isn't as easy as many people think. Sometimes it is hard enough to name it. We'll consider a title original if it doesn't occur as a substring in any titles of recent Codeforces problems. 

You've got the titles of *n* last problems — the strings, consisting of lowercase English letters. Your task is to find the shortest original title for the new problem. If there are multiple such titles, choose the lexicographically minimum one. Note, that title of the problem can't be an empty string.

A substring *s*[*l*... *r*] (1<=≤<=*l*<=≤<=*r*<=≤<=|*s*|) of string *s*<==<=*s*1*s*2... *s*|*s*| (where |*s*| is the length of string *s*) is string *s**l**s**l*<=+<=1... *s**r*.

String *x*<==<=*x*1*x*2... *x**p* is lexicographically smaller than string *y*<==<=*y*1*y*2... *y**q*, if either *p*<=&lt;<=*q* and *x*1<==<=*y*1,<=*x*2<==<=*y*2,<=... ,<=*x**p*<==<=*y**p*, or there exists such number *r* (*r*<=&lt;<=*p*,<=*r*<=&lt;<=*q*), that *x*1<==<=*y*1,<=*x*2<==<=*y*2,<=... ,<=*x**r*<==<=*y**r* and *x**r*<=+<=1<=&lt;<=*y**r*<=+<=1. The string characters are compared by their ASCII codes.","The first line contains integer *n* (1<=≤<=*n*<=≤<=30) — the number of titles you've got to consider. Then follow *n* problem titles, one per line. Each title only consists of lowercase English letters (specifically, it doesn't contain any spaces) and has the length from 1 to 20, inclusive.","Print a string, consisting of lowercase English letters — the lexicographically minimum shortest original title.","['5\nthreehorses\ngoodsubstrings\nsecret\nprimematrix\nbeautifulyear\n', '4\naa\nbdefghijklmn\nopqrstuvwxyz\nc\n']","['j\n', 'ab\n']","In the first sample the first 9 letters of the English alphabet (a, b, c, d, e, f, g, h, i) occur in the problem titles, so the answer is letter j.

In the second sample the titles contain 26 English letters, so the shortest original title cannot have length 1. Title aa occurs as a substring in the first title.",OK,"import l
 
 
def k(o):
 
 
 e={}
 
 m=[]
 if o==1:
  a=[1]*2
  a.append(0)
  a.append(0)
  m.append(a)
 else: 
  for j in range(1,l.floor(o**(1/2))+1):

   if o%j==0:
    q=[]

    q.append(j)
    q.append(o//j)
    q.append(0)
    q.append(0)
    m.append(q)
    q=[]
    
    if o//j!=j:
     q=[]
     q.append(o//j)
     q.append(j)
     q.append(0)
     q.append(0)
   
  
     m.append(q)
 return m

a = {'a': 1, 'b': 2,'c': 3,'d': 4,'e': 5,'f': 6,'g': 7,'h': 8,'i': 9,'j': 10,'k': 11,'l': 12,'m': 13,'n': 14,'o': 15,'p': 16,'q': 17,'r': 18,'s': 19,'t': 20,'u': 21,'v': 22,'w': 23,'x': 24,'y': 25,'z': 26}
b={'1':""a"", '2':""b"", '3':""c"", '4':""d"", '5':""e"", '6':""f"", '7':""g"", '8':""h"", '9':""i"", '10':""j"", '11':""k"", '12':""l"", '13':""m"", '14':""n"", '15':""o"", '16':""p"", '17':""q"", '18':""r"", '19':""s"", '20':""t"", '21':""u"", '22':""v"", '23':""w"", '24':""x"", '25':""y"", '26':""z""} 

f={}
g={}

f=a

for i in range(1,27):
 for j in range(1,27):
  j=b[str(i)] + b[str(j)]
  g[j]=(i-1)*26+j
  
i=dict(f)
h=dict(g)

d=int(input())

for p in range(d):

 s=input()
 for i in f:
  if i in s:
   if i in i:
    del i[i]
 
    
 for x in g:
  if x in s:
   if x in h:
    del h[x]
    
n=1000    
c=''
if len(i)>0:
 for j in i:
  if i[j]<n:
   n=i[j]
   c=j
   
else:
 for j in h:
  if h[j]<n:
   n=h[j]
   c=j
   
print(c)","def c(x):

    if x < 2:
        return False
    for i in range(2, int(x ** 0.5) + 1):
        if x % i == 0:
            return False
    return True

def d():
    import f
    b = f.stdin.readline().strip()
    if not b:
        return
    n, k = map(int, b.split())

    e = [i for i in range(2, n+1) if c(i)]
    
    a = 0

    for i in range(len(e) - 1):
        s = e[i] + e[i+1] + 1

        if s <= n and c(s):
            a += 1

    print(""YES"" if a >= k else ""NO"")

if __name__ == ""__main__"":
    d()"
368,B,Sereja and Suffixes,PROGRAMMING,"['data structures', 'dp']","Sereja has an array *a*, consisting of *n* integers *a*1, *a*2, ..., *a**n*. The boy cannot sit and do nothing, he decided to study an array. Sereja took a piece of paper and wrote out *m* integers *l*1,<=*l*2,<=...,<=*l**m* (1<=≤<=*l**i*<=≤<=*n*). For each number *l**i* he wants to know how many distinct numbers are staying on the positions *l**i*, *l**i*<=+<=1, ..., *n*. Formally, he want to find the number of distinct numbers among *a**l**i*,<=*a**l**i*<=+<=1,<=...,<=*a**n*.?

Sereja wrote out the necessary array elements but the array was so large and the boy was so pressed for time. Help him, find the answer for the described question for each *l**i*.","The first line contains two integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=105). The second line contains *n* integers *a*1, *a*2, ..., *a**n* (1<=≤<=*a**i*<=≤<=105) — the array elements.

Next *m* lines contain integers *l*1,<=*l*2,<=...,<=*l**m*. The *i*-th line contains integer *l**i* (1<=≤<=*l**i*<=≤<=*n*).",Print *m* lines — on the *i*-th line print the answer to the number *l**i*.,['10 10\n1 2 3 4 1 2 3 4 100000 99999\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n'],['6\n6\n6\n6\n6\n5\n4\n3\n2\n1\n'],none,RUNTIME_ERROR,"n, m = map(int, input().split())
a = list(map(int, input().split()))
a = {1: len(set(a))}

def b(i: int) -> int:
    if i in a:
        return a[i]
    c = b(i-1)
    try:
        a.index(a[i-2], i-1)
    except ValueError:
        c -= 1
    a[i] = c
    return c

for _ in range(m):
    print(b(int(input())))","import e

def d():

    c = e.stdin.read().strip().split()
    if not c:
        return

    n = int(c[0])
    a = int(c[1])
    b = int(c[2])

    b = list(map(int, c[3:3+n]))

    b.sort()

    if b == 0 or b == n:

        print(0)
        return

    a = b[b] - b[b-1]

    print(a if a > 0 else 0)

if __name__ == '__main__':
    d()"
124,A,The number of positions,PROGRAMMING,['math'],"Petr stands in line of *n* people, but he doesn't know exactly which position he occupies. He can say that there are no less than *a* people standing in front of him and no more than *b* people standing behind him. Find the number of different positions Petr can occupy.","The only line contains three integers *n*, *a* and *b* (0<=≤<=*a*,<=*b*<=&lt;<=*n*<=≤<=100).",Print the single number — the number of the sought positions.,"['3 1 1\n', '5 2 3\n']","['2\n', '3\n']","The possible positions in the first sample are: 2 and 3 (if we number the positions starting with 1).

In the second sample they are 3, 4 and 5.",OK,"def a(n,f,d):
    return n-max(f+1,n-b)+1;
n,f,b=map(int,input().split(' '))
print(a(n,f,b))","def e():
    import j

    b = j.stdin.read().strip()
    if not b:
        return

    c, g, d, h, k = map(int, b.split())

    i = max(c, d)
    a = min(g, h)

    if i > a:
        print(0)
        return

    f = a - i + 1

    if i <= k <= a:
        f -= 1

    print(f)

if __name__ == ""__main__"":
    e()"
900,B,Position in Fraction,PROGRAMMING,"['math', 'number theory']",You have a fraction . You need to find the first occurrence of digit *c* into decimal notation of the fraction after decimal point.,"The first contains three single positive integers *a*, *b*, *c* (1<=≤<=*a*<=&lt;<=*b*<=≤<=105, 0<=≤<=*c*<=≤<=9).","Print position of the first occurrence of digit *c* into the fraction. Positions are numbered from 1 after decimal point. It there is no such position, print -1.","['1 2 0\n', '2 3 7\n']","['2', '-1']","The fraction in the first example has the following decimal notation: <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/896357459a466614a0542f34c9cfb0cef1afc9ed.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>. The first zero stands on second position.

The fraction in the second example has the following decimal notation: <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/130ba579a8276fc53a1917606eee9db58817f28d.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>. There is no digit 7 in decimal notation of the fraction.",WRONG_ANSWER,"def a(g, c) :

	if (g == 0):
		return ""0""

	l = -1 if (g < 0) ^ (c < 0) else 1

	g = abs(g)
	c = abs(c)

	e = g // c

	j = """"

	if (l == -1):
		j += ""-""

	j += str(e)

	if (g % c == 0):
		return j

	j += "".""

	h = g % c
	f = {}

	d = 0
	i = False
	while (h > 0 and not i) :

		if ( h in f):

			d = f[h]
			i = True
			break
  
		else:
			f[h] = len(j)

		h = h * 10

		m = h // c
		j += str(m )
		h = h % c

	if (i) :
		j += "")""
		x = j[:d]
		x += ""(""
		x += j[d:]
		j = x

	return j

def k(a,b,c):
    b = a(a,b)
    try:

        b.d(')')
            
    except:

        b += ""000""
        
    b = b[2:]
    try:
        print(b.d(str(c))+1)
    except:
        print(-1)","def g():
    import j

    b = j.stdin.buffer.read().split()

    c = iter(b)
    n = int(next(c))

    a = [int(next(c)) for _ in range(n)]
    q = int(next(c))
    f = 0
    h = []

    for _ in range(q):
        l = int(next(c))

        e = int(next(c))
        i = int(next(c))

        l = ((e + f - 1) % n) + 1
        r = ((i + f - 1) % n) + 1

        if l > r:
            l, r = r, l

        if l == 1:

            if r - l > 0:

                k = a[r - 1]

                a[l - 1:r] = [k] + a[l - 1:r - 1]

        else:

            d = int(next(c))

            k = ((d + f - 1) % n) + 1

            a = a[l - 1:r].count(k)
            h.append(str(a))
            f = a

    j.stdout.write(""\n"".join(h))

if __name__ == ""__main__"":
    g()"
895,B,XK Segments,PROGRAMMING,"['binary search', 'math', 'sortings', 'two pointers']","While Vasya finished eating his piece of pizza, the lesson has already started. For being late for the lesson, the teacher suggested Vasya to solve one interesting problem. Vasya has an array *a* and integer *x*. He should find the number of different ordered pairs of indexes (*i*,<=*j*) such that *a**i*<=≤<=*a**j* and there are exactly *k* integers *y* such that *a**i*<=≤<=*y*<=≤<=*a**j* and *y* is divisible by *x*.

In this problem it is meant that pair (*i*,<=*j*) is equal to (*j*,<=*i*) only if *i* is equal to *j*. For example pair (1,<=2) is not the same as (2,<=1).","The first line contains 3 integers *n*,<=*x*,<=*k* (1<=≤<=*n*<=≤<=105,<=1<=≤<=*x*<=≤<=109,<=0<=≤<=*k*<=≤<=109), where *n* is the size of the array *a* and *x* and *k* are numbers from the statement.

The second line contains *n* integers *a**i* (1<=≤<=*a**i*<=≤<=109) — the elements of the array *a*.",Print one integer — the answer to the problem.,"['4 2 1\n1 3 5 7\n', '4 2 0\n5 3 1 7\n', '5 3 1\n3 3 3 3 3\n']","['3\n', '4\n', '25\n']","In first sample there are only three suitable pairs of indexes — (1, 2), (2, 3), (3, 4).

In second sample there are four suitable pairs of indexes(1, 1), (2, 2), (3, 3), (4, 4).

In third sample every pair (*i*, *j*) is suitable, so the answer is 5 * 5 = 25.",WRONG_ANSWER,"from bisect import b
from bisect import bisect_right
from math import c

def e(a, x):
    return x * c(a / x)

def f(a, a, x, k):
    return b(a, e(a, x) + k * x) - b(a, a)

def d(a, a, x, k):
    return f(a, a, x, k) - f(a, a, x, k-1)

n, x, k = input().split(' ')
n, x, k = int(n), int(x), int(k)

t = input().split(' ')
t = [int(a) for a in t]
t.sort()

sum = 0

for a in t:
    sum += d(t, a, x, k)

print(sum)","def g():
    import k
    import numpy as h

    c = k.stdin.read().split()
    if not c:
        return

    f = iter(c)

    n = int(next(f))

    d = h.empty((n, n), dtype=h.int64)
    for i in range(n):
        for j in range(n):
            d[i, j] = int(next(f))

    d = [int(next(f)) - 1 for _ in range(n)]

    i = d[::-1]

    a = h.zeros(n, dtype=bool)

    j = []

    for k in i:
        a[k] = True

        d = h.minimum(d, d[:, k][:, None] + d[k, :][None, :])

        e = h.nonzero(a)[0]

        b = d[h.ix_(e, e)].sum()
        j.append(b)

    j = j[::-1]

    k.stdout.write("" "".join(map(str, j)) + "" "")

if __name__ == '__main__':
    g()"
165,B,Burning Midnight Oil,PROGRAMMING,"['binary search', 'implementation']","One day a highly important task was commissioned to Vasya — writing a program in a night. The program consists of *n* lines of code. Vasya is already exhausted, so he works like that: first he writes *v* lines of code, drinks a cup of tea, then he writes as much as  lines, drinks another cup of tea, then he writes  lines and so on: , , , ...

The expression  is regarded as the integral part from dividing number *a* by number *b*.

The moment the current value  equals 0, Vasya immediately falls asleep and he wakes up only in the morning, when the program should already be finished.

Vasya is wondering, what minimum allowable value *v* can take to let him write not less than *n* lines of code before he falls asleep.","The input consists of two integers *n* and *k*, separated by spaces — the size of the program in lines and the productivity reduction coefficient, 1<=≤<=*n*<=≤<=109, 2<=≤<=*k*<=≤<=10.",Print the only integer — the minimum value of *v* that lets Vasya write the program in one night.,"['7 2\n', '59 9\n']","['4\n', '54\n']","In the first sample the answer is *v* = 4. Vasya writes the code in the following portions: first 4 lines, then 2, then 1, and then Vasya falls asleep. Thus, he manages to write 4 + 2 + 1 = 7 lines in a night and complete the task.

In the second sample the answer is *v* = 54. Vasya writes the code in the following portions: 54, 6. The total sum is 54 + 6 = 60, that's even more than *n* = 59.",RUNTIME_ERROR,"import f;

def g(b, n, k):
    a = k
    j = b
    while (f.floor(b / a) > 0):

        j += f.floor(b / a)
        a *= k

    return j
    
def e():
    n = int(input())
    k = int(input())

    h = -1

    d = 0
    c = f.pow(10, 3)

    while d <= c:
        b = f.floor((d + c) / 2)
        i = g(b, n, k)

        if i < n: 

            d = b + 1
        elif i >= n:
            c = b - 1
            h = b
            
    print(h)

e()","def g():
    import l
    l.setrecursionlimit(200000)
    c = l.stdin.read().split()
    if not c:
        return
    n = int(c[0])

    if n % 2 == 1:
        print(-1)
        return

    e = [[] for _ in range(n + 1)]
    f = 1
    for _ in range(n - 1):
        u = int(c[f])
        v = int(c[f + 1])
        f += 2
        e[u].append(v)
        e[v].append(u)

    a = 0

    def d(i, j):
        nonlocal a
        b = 1
        for h in e[i]:
            if h == j:
                continue
            k = d(h, i)

            if k % 2 == 0:
                a += 1
            else:
                b += k
        return b

    d(1, -1)
    print(a)

if __name__ == '__main__':
    g()"
553,A,Kyoya and Colored Balls,PROGRAMMING,"['combinatorics', 'dp', 'math']",Kyoya Ootori has a bag with *n* colored balls that are colored with *k* different colors. The colors are labeled from 1 to *k*. Balls of the same color are indistinguishable. He draws balls from the bag one by one until the bag is empty. He noticed that he drew the last ball of color *i* before drawing the last ball of color *i*<=+<=1 for all *i* from 1 to *k*<=-<=1. Now he wonders how many different ways this can happen.,"The first line of input will have one integer *k* (1<=≤<=*k*<=≤<=1000) the number of colors.

Then, *k* lines will follow. The *i*-th line will contain *c**i*, the number of balls of the *i*-th color (1<=≤<=*c**i*<=≤<=1000).

The total number of balls doesn't exceed 1000.","A single integer, the number of ways that Kyoya can draw the balls from the bag as described in the statement, modulo 1<=000<=000<=007.","['3\n2\n2\n1\n', '4\n1\n2\n3\n4\n']","['3\n', '1680\n']","In the first sample, we have 2 balls of color 1, 2 balls of color 2, and 1 ball of color 3. The three ways for Kyoya are:",WRONG_ANSWER,"def b(n):
    if n == 0:
        return 1
    else:
        return n * b(n-1)

def d(n, r):
    return int(b(n)/(b(r)*b(n-r)))

def e(b, f):
    if f == 0:
        return d(b[f+1]+b[f]-1, b[f])
    else:
        sum = 0
        for i in range(0, f+2):
            sum += b[i]
        return d(sum-1-b[f-1], b[f])

a = int(input())
b = [0]*a
for i in range(0, a):
    b[i] = int(input())

c = 1
for i in range(0, a):
    if i != a-1:
        c *= e(b, i)
    else:
        c *= b[a-1]

print(c)","def h():
    import i
    c = i.stdin.read().split()
    if not c:
        return

    n = int(c[0])
    l = int(c[1])
    r = int(c[2])

    def g(x):
        if x == 0:
            return 1
        return (1 << (x.bit_length())) - 1

    def b(x, l, r):
        j = g(x)

        if l > j or r < 1:
            return 0

        l = max(l, 1)
        r = min(r, j)

        if x < 2:
            if x == 1 and l <= 1 <= r:
                return 1
            return 0

        d = g(x // 2)
        f = 0

        if l <= d:
            f += b(x // 2, l, min(r, d))

        e = d + 1
        if l <= e <= r:
            f += x % 2

        if r > e:

            f += b(x // 2, max(1, l - e), r - e)
            
        return f

    a = b(n, l, r)
    i.stdout.write(str(a))
    
if __name__ == '__main__':
    h()"
0,none,none,none,['none'],"Today on a lecture about strings Gerald learned a new definition of string equivalency. Two strings *a* and *b* of equal length are called equivalent in one of the two cases: 
 1.  They are equal. 1.  If we split string *a* into two halves of the same size *a*1 and *a*2, and string *b* into two halves of the same size *b*1 and *b*2, then one of the following is correct:   *a*1 is equivalent to *b*1, and *a*2 is equivalent to *b*2 1.  *a*1 is equivalent to *b*2, and *a*2 is equivalent to *b*1 
As a home task, the teacher gave two strings to his students and asked to determine if they are equivalent.

Gerald has already completed this home task. Now it's your turn!",The first two lines of the input contain two strings given by the teacher. Each of them has the length from 1 to 200<=000 and consists of lowercase English letters. The strings have the same length.,"Print ""YES"" (without the quotes), if these two strings are equivalent, and ""NO"" (without the quotes) otherwise.","['aaba\nabaa\n', 'aabb\nabab\n']","['YES\n', 'NO\n']","In the first sample you should split the first string into strings ""aa"" and ""ba"", the second one — into strings ""ab"" and ""aa"". ""aa"" is equivalent to ""aa""; ""ab"" is equivalent to ""ba"" as ""ab"" = ""a"" + ""b"", ""ba"" = ""b"" + ""a"".

In the second sample the first string can be splitted into strings ""aa"" and ""bb"", that are equivalent only to themselves. That's why string ""aabb"" is equivalent only to itself and to string ""bbaa"".",WRONG_ANSWER,"def g(a, b, a, b, d, c, l):
    e = True
    for i in range(l):
        if a[b+i] != b[d+i]:
            e = False
    if e:
        return True
    
    if l % 2 != 0:
        return False
    f = l//2
     
    return (g(a, b, f, b, d, f, f) and g(a, f, a, b, f, c, f)) or (g(a, b, f, b, f, c, f) and g(a, f, a, b, d, f, f))

a = input()
b = input()
l = len(a)

if g(a, 0, l, b, 0, l, l):
    print(""YES"")
else:
    print(""NO"")","import k
import f

def j(d):

    c = [True] * (d + 1)
    c[0] = c[1] = False

    for i in range(2, int(f.sqrt(d)) + 1):
        if c[i]:
            for j in range(i * i, d + 1, i):
                c[j] = False
    return c

def e():

    b = k.stdin.read().strip().split()
    if not b:
        return
    n = int(b[0])

    g = n + 1
    i = j(g)

    k = 1 if n <= 2 else 2
    a = []
    
    for h in range(2, g + 1):
        if n <= 2:

            a.append(1)
        else:

            a.append(1 if i[h] else 2)

    k.stdout.write(str(k) + ""\n"")
    k.stdout.write("" "".join(map(str, a)) + ""\n"")

if __name__ == '__main__':
    e()"
331,A2,Oh Sweet Beaverette,PROGRAMMING,"['data structures', 'sortings']","— Oh my sweet Beaverette, would you fancy a walk along a wonderful woodland belt with me?  

 — Of course, my Smart Beaver! Let us enjoy the splendid view together. How about Friday night? 

At this point the Smart Beaver got rushing. Everything should be perfect by Friday, so he needed to prepare the belt to the upcoming walk. He needed to cut down several trees.

Let's consider the woodland belt as a sequence of trees. Each tree *i* is described by the esthetic appeal *a**i* — some trees are very esthetically pleasing, others are 'so-so', and some trees are positively ugly!

The Smart Beaver calculated that he needed the following effects to win the Beaverette's heart: 
 -  The first objective is to please the Beaverette: the sum of esthetic appeal of the remaining trees must be maximum possible; -  the second objective is to surprise the Beaverette: the esthetic appeal of the first and the last trees in the resulting belt must be the same; -  and of course, the walk should be successful: there must be at least two trees in the woodland belt left. 
Now help the Smart Beaver! Which trees does he need to cut down to win the Beaverette's heart?","The first line contains a single integer *n* — the initial number of trees in the woodland belt, 2<=≤<=*n*. The second line contains space-separated integers *a**i* — the esthetic appeals of each tree. All esthetic appeals do not exceed 109 in their absolute value.
 -  to get 30 points, you need to solve the problem with constraints: *n*<=≤<=100 (subproblem A1); -  to get 100 points, you need to solve the problem with constraints: *n*<=≤<=3·105 (subproblems A1+A2).","In the first line print two integers — the total esthetic appeal of the woodland belt after the Smart Beaver's intervention and the number of the cut down trees *k*.

In the next line print *k* integers — the numbers of the trees the Beaver needs to cut down. Assume that the trees are numbered from 1 to *n* from left to right.

If there are multiple solutions, print any of them. It is guaranteed that at least two trees have equal esthetic appeal.","['5\n1 2 3 1 2\n', '5\n1 -2 3 1 -2\n']","['8 1\n1 ', '5 2\n2 5 ']",none,WRONG_ANSWER,"from math import f

def j():
    n = int(input())
    l = tuple(map(int, input().split("" "")))
    d = {}
    h = -1 * f
    a = 0
    e = 0
    b = 0
    for i in range(n):
        if l[i] in d:
            d[l[i]][1], d[l[i]][2] = i, b - d[l[i]][2]
        else:
            d[l[i]] = [i, -1, b]
        if l[i] > 0:
            b += l[i]
    for g in d.keys():
        if d[g][1] == -1:
            continue
        if g > 0:
            k = d[g][2] + g
        else:
            k = d[g][2] + (g * 2)
        if k > h:
            h, a, e = k, d[g][0], d[g][1]
    c = list(range(a)) + list(range(e + 1, n))
    for i in range(a + 1, e):
        if l[i] < 0:
            c.append(i)
    c.sort()
    c = [d + 1 for d in c]
    k = len(c)
    return "" "".join([str(h), str(k)]) + ""\n"" + "" "".join([str(d) for d in c])

i = j()
print(i)","import p
input = p.stdin.readline

class a:
    def __init__(o, n, d):
        o.parent = list(range(n))
        o.comp_sum = d[:]
        o.rank = [0] * n

    def h(o, a):
        if o.parent[a] != a:
            o.parent[a] = o.h(o.parent[a])
        return o.parent[a]

    def q(o, a, b):
        l = o.h(a)
        m = o.h(b)
        if l == m:
            return o.comp_sum[l]

        if o.rank[l] < o.rank[m]:
            o.parent[l] = m
            o.comp_sum[m] += o.comp_sum[l]
            return o.comp_sum[m]
        else:
            o.parent[m] = l
            o.comp_sum[l] += o.comp_sum[m]
            if o.rank[l] == o.rank[m]:
                o.rank[l] += 1
            return o.comp_sum[l]

def i():
    n = int(input().strip())
    d = list(map(int, input().split()))

    f = list(map(lambda x: int(x) - 1, input().split()))

    b = [False] * n
    g = a(n, d)

    c = [0] * (n + 1)
    e = 0

    c[n] = 0

    for i in range(n - 1, -1, -1):
        j = f[i]
        b[j] = True

        n = d[j]

        if j - 1 >= 0 and b[j - 1]:
            n = g.q(j, j - 1)

        if j + 1 < n and b[j + 1]:
            n = g.q(j, j + 1)

        k = g.h(j)
        e = max(e, g.comp_sum[k])
        c[i] = e

    for i in range(1, n + 1):
        p.stdout.write(str(c[i]) + ""\n"")
        
if __name__ == '__main__':
    i()"
919,B,Perfect Number,PROGRAMMING,"['binary search', 'brute force', 'dp', 'implementation', 'number theory']","We consider a positive integer perfect, if and only if the sum of its digits is exactly $10$. Given a positive integer $k$, your task is to find the $k$-th smallest perfect positive integer.","A single line with a positive integer $k$ ($1 \leq k \leq 10\,000$).","A single number, denoting the $k$-th smallest perfect integer.","['1\n', '2\n']","['19\n', '28\n']",The first perfect integer is $19$ and the second one is $28$.,TIME_LIMIT_EXCEEDED,"def c(n):
    if n == 0:
        return 0
    else:
        return n % 10 + c(n // 10)

b = []

a = 15000000
for i in range(a):
    if c(i) == 10:
        b.append(i)

print(b[int(input()) - 1])","import l

def c():
    b = l.stdin.read().splitlines()
    n = int(b[0])

    f = []

    k = {}

    for i in range(1, n + 1):
        e, j = b[i].split()
        i = int(j)
        f.append((e, i))
        if e in k:
            k[e] += i
        else:
            k[e] = i

    d = max(k.values())

    a = {e for e, h in k.items() if h == d}

    g = {}

    for e, i in f:
        if e in g:
            g[e] += i
        else:
            g[e] = i

        if g[e] >= d and e in a:
            print(e)
            return

if __name__ == ""__main__"":
    c()"
109,A,Lucky Sum of Digits,PROGRAMMING,"['brute force', 'implementation']","Petya loves lucky numbers. We all know that lucky numbers are the positive integers whose decimal representations contain only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.

Petya wonders eagerly what minimum lucky number has the sum of digits equal to *n*. Help him cope with the task.",The single line contains an integer *n* (1<=≤<=*n*<=≤<=106) — the sum of digits of the required lucky number.,"Print on the single line the result — the minimum lucky number, whose sum of digits equals *n*. If such number does not exist, print -1.","['11\n', '10\n']","['47\n', '-1\n']",none,WRONG_ANSWER,"import e
a=[4,7]
sum=int(input())

def b(a, m, V):

    if (V == 0):
        return 0

    c = e.maxsize

    for i in range(0, m):
        if (a[i] <= V):
            d = b(a, m, V - a[i])

            if (d != e.maxsize and d + 1 < c):
                c = d + 1
    return c
a=b(a,2,sum)
if a<sum:
    for i in range(a):
        if 4*i+7*(a-1)==sum:
            print(""4""*i+""7""*(a-1))
            break
else:
    print(-1)","def b(x):
    """"""
    Count how many times x can be divided by 2.
    Returns the exponent of the largest power of 2 dividing x.
    """"""
    a = 0
    while x % 2 == 0:
        x //= 2
        a += 1
    return a

def e():
    import j

    d = j.stdin.read().strip().split()
    if not d:
        return
    n = int(d[0])

    i = list(map(int, d[1:n+1]))

    f = -1
    for h in i:
        c = b(h)
        if c > f:
            f = c

    g = 2 ** f

    a = sum(1 for h in i if h % g == 0)

    print(g, a)

if __name__ == '__main__':
    e()"
320,B,Ping-Pong (Easy Version),PROGRAMMING,"['dfs and similar', 'graphs']","In this problem at each moment you have a set of intervals. You can move from interval (*a*,<=*b*) from our set to interval (*c*,<=*d*) from our set if and only if *c*<=&lt;<=*a*<=&lt;<=*d* or *c*<=&lt;<=*b*<=&lt;<=*d*. Also there is a path from interval *I*1 from our set to interval *I*2 from our set if there is a sequence of successive moves starting from *I*1 so that we can reach *I*2.

Your program should handle the queries of the following two types:
 1.  ""1 x y"" (*x*<=&lt;<=*y*) — add the new interval (*x*,<=*y*) to the set of intervals. The length of the new interval is guaranteed to be strictly greater than all the previous intervals.1.  ""2 a b"" (*a*<=≠<=*b*) — answer the question: is there a path from *a*-th (one-based) added interval to *b*-th (one-based) added interval? 
Answer all the queries. Note, that initially you have an empty set of intervals.","The first line of the input contains integer *n* denoting the number of queries, (1<=≤<=*n*<=≤<=100). Each of the following lines contains a query as described above. All numbers in the input are integers and don't exceed 109 by their absolute value.

It's guaranteed that all queries are correct.","For each query of the second type print ""YES"" or ""NO"" on a separate line depending on the answer.",['5\n1 1 5\n1 5 11\n2 1 2\n1 2 9\n2 1 2\n'],['NO\nYES\n'],none,WRONG_ANSWER,"import f
input = lambda: f.stdin.readline().rstrip()

class a:
	def __init__(e, n):
		e.parent = list(range(n))
 
	def c(e, a):
		b = a
		while a != e.parent[a]:
			a = e.parent[a]
		while b != a:
			e.parent[b], b = a, e.parent[b]
		return a
 
	def d(e, a, b):
		e.parent[e.c(b)] = e.c(a)

N = int(input())
g = a(N)
A = []
for _ in range(N):
    t,x,y = map(int, input().split())
    if t==1:
        m = len(A)
        for i,(a,b) in enumerate(A):
            if a<x<b or a<y<b:
                g.d(i,m)
        A.append((x,y))
    else:
        if g.c(x-1)==g.c(y-1):
            print('YES')
        else:
            print('NO')","import g

def e():

    d = g.stdin.read().split()
    n = int(d[0])
    k = int(d[1])
    
    a = list(map(int, d[2:2+n]))
    t = list(map(int, d[2+n:2+2*n]))

    a = 0

    c = [0] * n
    for i in range(n):
        if t[i] == 1:
            a += a[i]
        else:
            c[i] = a[i]

    b = sum(c[:k])
    f = b
    for i in range(k, n):

        b += c[i] - c[i - k]
        if b > f:
            f = b

    print(a + f)

if __name__ == '__main__':
    e()"
851,B,Arpa and an exam about geometry,PROGRAMMING,"['geometry', 'math']","Arpa is taking a geometry exam. Here is the last problem of the exam.

You are given three points *a*,<=*b*,<=*c*.

Find a point and an angle such that if we rotate the page around the point by the angle, the new position of *a* is the same as the old position of *b*, and the new position of *b* is the same as the old position of *c*.

Arpa is doubting if the problem has a solution or not (i.e. if there exists a point and an angle satisfying the condition). Help Arpa determine if the question has a solution or not.","The only line contains six integers *a**x*,<=*a**y*,<=*b**x*,<=*b**y*,<=*c**x*,<=*c**y* (|*a**x*|,<=|*a**y*|,<=|*b**x*|,<=|*b**y*|,<=|*c**x*|,<=|*c**y*|<=≤<=109). It's guaranteed that the points are distinct.","Print ""Yes"" if the problem has a solution, ""No"" otherwise.

You can print each letter in any case (upper or lower).","['0 1 1 1 1 0\n', '1 1 0 0 1000 1000\n']","['Yes\n', 'No\n']","In the first sample test, rotate the page around (0.5, 0.5) by <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/9d845923f4d356a48d8ede337db0303821311f0c.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>.

In the second sample test, you can't find any solution.",RUNTIME_ERROR,"from math import a
from math import j
from math import h
def i():
    b, c, d, e, f, g = map(int, input().split())
    
    k = 0
    if b - d != 0:
        k = (c - e)/(b - d)
    b = e - k*d
    if g == k*f + b:
        print('No')
        return
    
    d = 2*(b*(e - g) + d*(g - c) + f*(c - e))
    x = ((b**2 + c**2)*(e - g) + (d**2 + e**2)*(g - c) + (f**2 + g**2)*(c - e))/d
    y = ((b**2 + c**2)*(f - d) + (d**2 + e**2)*(b - f) + (f**2 + g**2)*(d - b))/d
    
    a = j((d - b)**2 + (e - c)**2)
    b = j((f - d)**2 + (g - e)**2)
    r = j((b - x)**2 + (c - y)**2)
    if a(h(a)/(2*r)) != a(h(b)/(2*r)):
        print('No')
        return
    
    print('Yes')
    
i()","import h

def g():

    e = h.stdin.read().split()
    n = int(e[0])
    k = int(e[1])
    b = e[2]

    f = {}
    for a in b:
        if a in f:
            f[a] += 1
        else:
            f[a] = 1

    d = sorted(f.values(), reverse=True)
    i = 0

    for c in d:
        if k <= 0:
            break

        j = min(c, k)
        i += j * j
        k -= j

    print(i)

if __name__ == '__main__':
    g()"
0,none,none,none,['none'],"As we all know Barney's job is ""PLEASE"" and he has not much to do at work. That's why he started playing ""cups and key"". In this game there are three identical cups arranged in a line from left to right. Initially key to Barney's heart is under the middle cup.

Then at one turn Barney swaps the cup in the middle with any of other two cups randomly (he choses each with equal probability), so the chosen cup becomes the middle one. Game lasts *n* turns and Barney independently choses a cup to swap with the middle one within each turn, and the key always remains in the cup it was at the start.

After *n*-th turn Barney asks a girl to guess which cup contains the key. The girl points to the middle one but Barney was distracted while making turns and doesn't know if the key is under the middle cup. That's why he asked you to tell him the probability that girl guessed right.

Number *n* of game turns can be extremely large, that's why Barney did not give it to you. Instead he gave you an array *a*1,<=*a*2,<=...,<=*a**k* such that 

in other words, *n* is multiplication of all elements of the given array.

Because of precision difficulties, Barney asked you to tell him the answer as an irreducible fraction. In other words you need to find it as a fraction *p*<=/<=*q* such that , where  is the greatest common divisor. Since *p* and *q* can be extremely large, you only need to find the remainders of dividing each of them by 109<=+<=7.

Please note that we want  of *p* and *q* to be 1, not  of their remainders after dividing by 109<=+<=7.","The first line of input contains a single integer *k* (1<=≤<=*k*<=≤<=105) — the number of elements in array Barney gave you.

The second line contains *k* integers *a*1,<=*a*2,<=...,<=*a**k* (1<=≤<=*a**i*<=≤<=1018) — the elements of the array.",In the only line of output print a single string *x*<=/<=*y* where *x* is the remainder of dividing *p* by 109<=+<=7 and *y* is the remainder of dividing *q* by 109<=+<=7.,"['1\n2\n', '3\n1 1 1\n']","['1/2\n', '0/1\n']",none,WRONG_ANSWER,"from fractions import a
k=int(input(""""))
L=[int(i) for i in input("""").split()]
N=1
for i in L:
    N*=i
N=float(N)
def P(N):
    b=float(1.00/3.00)*( (-1.00)**N*2.00**(1-N)+1.00)
    return a.from_float(b).limit_denominator()
b=P(N)
print(str(b.numerator)+""/""+str(b.denominator))","def j():
    import k
    b = k.stdin.read().split()
    if not b:
        return
    a = int(b[0])
    b = int(b[1])
    n = int(b[2])
    f = 1000000007

    def e(h):
        while h:
            d = h % 10
            if d != a and d != b:
                return False
            h //= 10
        return True

    if a == b:
        s = a * n
        i = 1 if e(s) else 0
        k.stdout.write(str(i))
        return

    c = [1] * (n + 1)
    d = [1] * (n + 1)
    for i in range(1, n + 1):
        c[i] = c[i - 1] * i % f
    d[n] = pow(c[n], f - 2, f)
    for i in range(n, 0, -1):
        d[i - 1] = d[i] * i % f

    def g(k):
        return c[n] * d[k] % f * d[n - k] % f

    a = 0

    for x in range(n + 1):
        s = a * x + b * (n - x)
        if e(s):
            a = (a + g(x)) % f

    k.stdout.write(str(a))

if __name__ == '__main__':
    j()"
799,A,Carrot Cakes,PROGRAMMING,"['brute force', 'implementation']","In some game by Playrix it takes *t* minutes for an oven to bake *k* carrot cakes, all cakes are ready at the same moment *t* minutes after they started baking. Arkady needs at least *n* cakes to complete a task, but he currently don't have any. However, he has infinitely many ingredients and one oven. Moreover, Arkady can build one more similar oven to make the process faster, it would take *d* minutes to build the oven. While the new oven is being built, only old one can bake cakes, after the new oven is built, both ovens bake simultaneously. Arkady can't build more than one oven.

Determine if it is reasonable to build the second oven, i.e. will it decrease the minimum time needed to get *n* cakes or not. If the time needed with the second oven is the same as with one oven, then it is unreasonable.","The only line contains four integers *n*, *t*, *k*, *d* (1<=≤<=*n*,<=*t*,<=*k*,<=*d*<=≤<=1<=000) — the number of cakes needed, the time needed for one oven to bake *k* cakes, the number of cakes baked at the same time, the time needed to build the second oven.","If it is reasonable to build the second oven, print ""YES"". Otherwise print ""NO"".","['8 6 4 5\n', '8 6 4 6\n', '10 3 11 4\n', '4 2 1 4\n']","['YES\n', 'NO\n', 'NO\n', 'YES\n']","In the first example it is possible to get 8 cakes in 12 minutes using one oven. The second oven can be built in 5 minutes, so after 6 minutes the first oven bakes 4 cakes, the second oven bakes 4 more ovens after 11 minutes. Thus, it is reasonable to build the second oven. 

In the second example it doesn't matter whether we build the second oven or not, thus it takes 12 minutes to bake 8 cakes in both cases. Thus, it is unreasonable to build the second oven.

In the third example the first oven bakes 11 cakes in 3 minutes, that is more than needed 10. It is unreasonable to build the second oven, because its building takes more time that baking the needed number of cakes using the only oven.",WRONG_ANSWER,"def c():
    (n, t, k, d) = map(int ,input().split())

    a = t/k*n
    b = d + t/k*n/2

    return (a > b)

t = 1
for _ in range(t):
    print(""YES"" if c() else ""NO"")","import i

def g():

    e = i.stdin.read().split()

    n = int(e[0])

    j = list(map(int, e[1:n+1]))

    f = 0
    h = n - 1

    b = 0
    d = 0
    a = 0
    c = 0

    while f <= h:

        if b <= d:
            b += j[f]
            a += 1
            f += 1
        else:

            d += j[h]
            c += 1
            h -= 1

    print(a, c)

if __name__ == ""__main__"":
    g()"
255,A,Greg's Workout,PROGRAMMING,['implementation'],"Greg is a beginner bodybuilder. Today the gym coach gave him the training plan. All it had was *n* integers *a*1,<=*a*2,<=...,<=*a**n*. These numbers mean that Greg needs to do exactly *n* exercises today. Besides, Greg should repeat the *i*-th in order exercise *a**i* times.

Greg now only does three types of exercises: ""chest"" exercises, ""biceps"" exercises and ""back"" exercises. Besides, his training is cyclic, that is, the first exercise he does is a ""chest"" one, the second one is ""biceps"", the third one is ""back"", the fourth one is ""chest"", the fifth one is ""biceps"", and so on to the *n*-th exercise.

Now Greg wonders, which muscle will get the most exercise during his training. We know that the exercise Greg repeats the maximum number of times, trains the corresponding muscle the most. Help Greg, determine which muscle will get the most training.","The first line contains integer *n* (1<=≤<=*n*<=≤<=20). The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=25) — the number of times Greg repeats the exercises.","Print word ""chest"" (without the quotes), if the chest gets the most exercise, ""biceps"" (without the quotes), if the biceps gets the most exercise and print ""back"" (without the quotes) if the back gets the most exercise.

It is guaranteed that the input is such that the answer to the problem is unambiguous.","['2\n2 8\n', '3\n5 1 10\n', '7\n3 3 2 7 9 6 8\n']","['biceps\n', 'back\n', 'chest\n']","In the first sample Greg does 2 chest, 8 biceps and zero back exercises, so the biceps gets the most exercises.

In the second sample Greg does 5 chest, 1 biceps and 10 back exercises, so the back gets the most exercises.

In the third sample Greg does 18 chest, 12 biceps and 8 back exercises, so the chest gets the most exercise.",OK,"from sys import d, setrecursionlimit, stdout

def c():

    n = int(d.readline())
    b = [int(s) for s in d.readline().split()]
    k = 0
    a = [0]*3

    for i in range(n):
        a[k] += b[i]
        k = (k + 1) % 3

    if a[0] > a[1] and a[0] > a[2]:
        print('chest')
    elif a[1] > a[0] and a[1] > a[2]:
        print('biceps')
    else:
        print('back')

if __name__ == '__main__':
    c()","import f

def c(g: str) -> str:

    g = g.rstrip('\n')

    if len(g) == 1 or g.isupper() or g[1:].isupper():

        return g.swapcase()
    else:
        return g

if __name__ == '__main__':

    b = f.stdin.readlines()
    e = []
    for a in b:

        e.append(c(a))

    for d in e:
        print(d)"
349,B,Color the Fence,PROGRAMMING,"['data structures', 'dp', 'greedy', 'implementation']","Igor has fallen in love with Tanya. Now Igor wants to show his feelings and write a number on the fence opposite to Tanya's house. Igor thinks that the larger the number is, the more chance to win Tanya's heart he has. 

Unfortunately, Igor could only get *v* liters of paint. He did the math and concluded that digit *d* requires *a**d* liters of paint. Besides, Igor heard that Tanya doesn't like zeroes. That's why Igor won't use them in his number.

Help Igor find the maximum number he can write on the fence.","The first line contains a positive integer *v* (0<=≤<=*v*<=≤<=106). The second line contains nine positive integers *a*1,<=*a*2,<=...,<=*a*9 (1<=≤<=*a**i*<=≤<=105).","Print the maximum number Igor can write on the fence. If he has too little paint for any digit (so, he cannot write anything), print -1.","['5\n5 4 3 2 1 2 3 4 5\n', '2\n9 11 1 12 5 8 9 10 6\n', '0\n1 1 1 1 1 1 1 1 1\n']","['55555\n', '33\n', '-1\n']",none,WRONG_ANSWER,"def f():
    v = int(input())
    c = h()

    b = -1
    a = float('inf')
    for i in range(9, 0, -1):
        if c[i-1] < a:
            a = c[i-1]
            b = i-1

    m = v // a

    if m == 0:
        print(-1)
        return

    j = [b+1] * m
    i = v - m * a
    for i in range(m):
        if i == 0:
            break
        for d in range(9, 0, -1):
            if i + a >= c[d-1] and d > b + 1:
                j[i] = d
                i += a
                i -= c[d-1]
                break

    print(' '.join(map(str, j)))

def input(): return next(l).strip()
def h(): return [int(c) for c in input().split()]
def g(e): print('\n'.join(map(str, e)))

if __name__ == ""__main__"":
    import k
    from os import environ as d
    if 'COMPUTERNAME' in d and 'L2A6HRI' in d['COMPUTERNAME']:
        k.stdout = open('out.txt', 'w')
        k.stdin = open('in.txt', 'r')

    l = iter(k.stdin.readlines())

    f()","def c():
    import f
    b = f.stdin.read().split()
    if not b:
        return
    x = int(b[0])
    y = int(b[1])
    l = int(b[2])
    r = int(b[3])

    i = []
    j = 1
    while j <= r:
        i.append(j)
        if j > r // x:
            break
        j *= x

    l = []
    m = 1
    while m <= r:
        l.append(m)
        if m > r // y:
            break
        m *= y

    h = set()

    for k in i:
        for n in l:
            s = k + n
            if s <= r:
                h.add(s)

            if s > r:
                break

    g = [e for e in h if l <= e <= r]
    g.sort()

    if not g:
        f.stdout.write(str(r - l + 1))
        return
    
    d = 0

    d = max(d, g[0] - l)

    for i in range(len(g) - 1):
        a = g[i + 1] - g[i] - 1
        d = max(d, a)

    d = max(d, r - g[-1])
    
    f.stdout.write(str(d))

if __name__ == '__main__':
    c()"
558,B,Amr and The Large Array,PROGRAMMING,['implementation'],"Amr has got a large array of size *n*. Amr doesn't like large arrays so he intends to make it smaller.

Amr doesn't care about anything in the array except the beauty of it. The beauty of the array is defined to be the maximum number of times that some number occurs in this array. He wants to choose the smallest subsegment of this array such that the beauty of it will be the same as the original array.

Help Amr by choosing the smallest subsegment possible.","The first line contains one number *n* (1<=≤<=*n*<=≤<=105), the size of the array.

The second line contains *n* integers *a**i* (1<=≤<=*a**i*<=≤<=106), representing elements of the array.","Output two integers *l*,<=*r* (1<=≤<=*l*<=≤<=*r*<=≤<=*n*), the beginning and the end of the subsegment chosen respectively.

If there are several possible answers you may output any of them.","['5\n1 1 2 2 1\n', '5\n1 2 2 3 1\n', '6\n1 2 2 1 1 2\n']","['1 5', '2 3', '1 5']","A subsegment *B* of an array *A* from *l* to *r* is an array of size *r* - *l* + 1 where *B*<sub class=""lower-index"">*i*</sub> = *A*<sub class=""lower-index"">*l* + *i* - 1</sub> for all 1 ≤ *i* ≤ *r* - *l* + 1",OK,"from sys import l

def h():
    n = int(l.readline())
    a = list(map(int, l.readline().split()))
    c = [0] * (10 ** 6 + 1)
    i = 0
    for c in a:
        c[c] += 1
        if c[c] > i:
            i = c[c]
    k = 0
    d = 0
    g = [0] * (10 ** 6 + 1)
    f = [0] * (n + 1)
    f[0] = n
    b = 0
    j = n + 1
    e = -1
    f = -1
    while d < n:
        while d < n and b < i:
            f[g[a[d]]] -= 1
            g[a[d]] += 1
            f[g[a[d]]] += 1
            if g[a[d]] > b:
                b = g[a[d]]
            d += 1
        if b == i:
            if d - k < j:
                j = d - k
                e = k + 1
                f = d
        while k < d and b == i:
            f[g[a[k]]] -= 1
            g[a[k]] -= 1
            f[g[a[k]]] += 1
            k += 1
            if f[b] == 0:
                b = b - 1
            else:
                if d - k < j:
                    j = d - k
                    e = k + 1
                    f = d
    print(e, f)

if __name__ == ""__main__"":
    h()","import t

def k():
    import t
    j = t.stdin.read().split()
    if not j:
        return
    n = int(j[0])

    l = []
    i = 1
    for _ in range(n):
        s = []
        for _ in range(n):
            s.append(int(j[i]))
            i += 1
        l.append(s)
    
    a = 10**9

    def f(x, p):
        if x == 0:
            return a
        e = 0
        while x % p == 0:
            e += 1
            x //= p
        return e

    g = [[a] * n for _ in range(n)]
    h = [[a] * n for _ in range(n)]
    p = [[''] * n for _ in range(n)]
    q = [[''] * n for _ in range(n)]

    v = None

    if l[0][0] == 0:
        g[0][0] = h[0][0] = 1
        v = (0, 0)
    else:
        g[0][0] = f(l[0][0], 2)
        h[0][0] = f(l[0][0], 5)

    for j in range(1, n):
        if l[0][j] == 0:
            v = (0, j)
        g[0][j] = g[0][j-1] + (1 if l[0][j] == 0 else f(l[0][j], 2))
        h[0][j] = h[0][j-1] + (1 if l[0][j] == 0 else f(l[0][j], 5))
        p[0][j] = 'R'
        q[0][j] = 'R'

    for i in range(1, n):
        if l[i][0] == 0:
            v = (i, 0)
        g[i][0] = g[i-1][0] + (1 if l[i][0] == 0 else f(l[i][0], 2))
        h[i][0] = h[i-1][0] + (1 if l[i][0] == 0 else f(l[i][0], 5))
        p[i][0] = 'D'
        q[i][0] = 'D'

    for i in range(1, n):
        for j in range(1, n):
            if l[i][j] == 0:
                v = (i, j)
                b = 1
                c = 1
            else:
                b = f(l[i][j], 2)
                c = f(l[i][j], 5)

            if g[i-1][j] < g[i][j-1]:
                g[i][j] = g[i-1][j] + b
                p[i][j] = 'D'
            else:
                g[i][j] = g[i][j-1] + b
                p[i][j] = 'R'

            if h[i-1][j] < h[i][j-1]:
                h[i][j] = h[i-1][j] + c
                q[i][j] = 'D'
            else:
                h[i][j] = h[i][j-1] + c
                q[i][j] = 'R'

    n = g[n-1][n-1]
    o = h[n-1][n-1]
    d = min(n, o)

    if v is not None and d > 1:

        (w, u) = v
        r = []
        r.append('D' * w)
        r.append('R' * u)
        r.append('D' * (n - w - 1))
        r.append('R' * (n - u - 1))
        print(1)
        print(''.join(r))
        return

    r = []
    i, j = n - 1, n - 1
    if n < o:

        while i > 0 or j > 0:
            m = p[i][j]
            r.append(m)
            if m == 'D':
                i -= 1
            else:
                j -= 1
        r = r[::-1]
    else:

        while i > 0 or j > 0:
            m = q[i][j]
            r.append(m)
            if m == 'D':
                i -= 1
            else:
                j -= 1
        r = r[::-1]

    print(d)
    print(''.join(r))

if __name__ == '__main__':
    k()"
796,A,Buying A House,PROGRAMMING,"['brute force', 'implementation']","Zane the wizard had never loved anyone before, until he fell in love with a girl, whose name remains unknown to us.

The girl lives in house *m* of a village. There are *n* houses in that village, lining in a straight line from left to right: house 1, house 2, ..., house *n*. The village is also well-structured: house *i* and house *i*<=+<=1 (1<=≤<=*i*<=&lt;<=*n*) are exactly 10 meters away. In this village, some houses are occupied, and some are not. Indeed, unoccupied houses can be purchased.

You will be given *n* integers *a*1,<=*a*2,<=...,<=*a**n* that denote the availability and the prices of the houses. If house *i* is occupied, and therefore cannot be bought, then *a**i* equals 0. Otherwise, house *i* can be bought, and *a**i* represents the money required to buy it, in dollars.

As Zane has only *k* dollars to spare, it becomes a challenge for him to choose the house to purchase, so that he could live as near as possible to his crush. Help Zane determine the minimum distance from his crush's house to some house he can afford, to help him succeed in his love.","The first line contains three integers *n*, *m*, and *k* (2<=≤<=*n*<=≤<=100, 1<=≤<=*m*<=≤<=*n*, 1<=≤<=*k*<=≤<=100) — the number of houses in the village, the house where the girl lives, and the amount of money Zane has (in dollars), respectively.

The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (0<=≤<=*a**i*<=≤<=100) — denoting the availability and the prices of the houses.

It is guaranteed that *a**m*<==<=0 and that it is possible to purchase some house with no more than *k* dollars.","Print one integer — the minimum distance, in meters, from the house where the girl Zane likes lives to the house Zane can buy.","['5 1 20\n0 27 32 21 19\n', '7 3 50\n62 0 0 0 99 33 22\n', '10 5 100\n1 0 1 0 0 0 0 0 1 1\n']","['40', '30', '20']","In the first sample, with *k* = 20 dollars, Zane can buy only house 5. The distance from house *m* = 1 to house 5 is 10 + 10 + 10 + 10 = 40 meters.

In the second sample, Zane can buy houses 6 and 7. It is better to buy house 6 than house 7, since house *m* = 3 and house 6 are only 30 meters away, while house *m* = 3 and house 7 are 40 meters away.",OK,"a = ""Daniel Mitre""

n, m, k = map(int, input().split())
g = map(int, input().split())

def c(e: int) -> int:
	return abs(e - m)

b = float('inf')
for d, f in zip(range(1, n + 1), g):
	if (f > 0) and (f <= k) and (c(d) < c(b)):
		b = d

print(c(b) * 10)","q = int(input().strip())

a = {}

for _ in range(q):
    d, c = input().split()

    if d in a:
        e = a[d]

        del a[d]
    else:
        e = d

    a[c] = e

print(len(a))

for b, e in a.items():
    print(e, b)"
346,A,Alice and Bob,PROGRAMMING,"['games', 'math', 'number theory']","It is so boring in the summer holiday, isn't it? So Alice and Bob have invented a new game to play. The rules are as follows. First, they get a set of *n* distinct integers. And then they take turns to make the following moves. During each move, either Alice or Bob (the player whose turn is the current) can choose two distinct integers *x* and *y* from the set, such that the set doesn't contain their absolute difference |*x*<=-<=*y*|. Then this player adds integer |*x*<=-<=*y*| to the set (so, the size of the set increases by one).

If the current player has no valid move, he (or she) loses the game. The question is who will finally win the game if both players play optimally. Remember that Alice always moves first.","The first line contains an integer *n* (2<=≤<=*n*<=≤<=100) — the initial number of elements in the set. The second line contains *n* distinct space-separated integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=109) — the elements of the set.","Print a single line with the winner's name. If Alice wins print ""Alice"", otherwise print ""Bob"" (without quotes).","['2\n2 3\n', '2\n5 3\n', '3\n5 6 7\n']","['Alice\n', 'Alice\n', 'Bob\n']","Consider the first test sample. Alice moves first, and the only move she can do is to choose 2 and 3, then to add 1 to the set. Next Bob moves, there is no valid move anymore, so the winner is Alice.",WRONG_ANSWER,"b = int(input())
e = list(map(int, input().split()))

def a(a, b):
	while b > 0:
		d = a % b
		a, b = b, d
	return a

c = a(e[0], e[1])

for n in range(2, b):
	c = a(c, e[n])

print(max(e) // c)","import |

def j(a):

    } = 0
    e = -10**9
    l = 0
    f = -10**9
    k = -10**9
    g = -10**9

    for x in a:
        } += x
        l += x
        if l > e:
            e = l

        if k < 0:
            k = x
        else:
            k += x
        if k > f:
            f = k

    m = 0

    for x in reversed(a):
        m += x
        if m > g:
            g = m

    return }, e, g, f

def h(v, w):

    ~, s, z, c = v
    , t, {, d = w
    
    } = ~ + 
    r = max(s, ~ + t)
    y = max({,  + z)
    b = max(c, d, z + t)
    
    return }, r, y, b

def q():

    o = |.stdin.read().strip().split()
    if not o:
        return
    p = iter(o)
    n = int(next(p))
    m = int(next(p))

    x = [None]
    for _ in range(n):
        l = int(next(p))
        a = [int(next(p)) for _ in range(l)]
        x.append(j(a))

    i = None
    for _ in range(m):
        n = int(next(p))
        u = x[n]
        if i is None:
            i = u
        else:
            i = h(i, u)

    |.stdout.write(str(i[3]) + ""\n"")

if __name__ == '__main__':
    q()"
446,A,DZY Loves Sequences,PROGRAMMING,"['dp', 'implementation', 'two pointers']","DZY has a sequence *a*, consisting of *n* integers.

We'll call a sequence *a**i*,<=*a**i*<=+<=1,<=...,<=*a**j* (1<=≤<=*i*<=≤<=*j*<=≤<=*n*) a subsegment of the sequence *a*. The value (*j*<=-<=*i*<=+<=1) denotes the length of the subsegment.

Your task is to find the longest subsegment of *a*, such that it is possible to change at most one number (change one number to any integer you want) from the subsegment to make the subsegment strictly increasing.

You only need to output the length of the subsegment you find.","The first line contains integer *n* (1<=≤<=*n*<=≤<=105). The next line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=109).",In a single line print the answer to the problem — the maximum length of the required subsegment.,['6\n7 2 3 1 5 6\n'],['5\n'],"You can choose subsegment *a*<sub class=""lower-index"">2</sub>, *a*<sub class=""lower-index"">3</sub>, *a*<sub class=""lower-index"">4</sub>, *a*<sub class=""lower-index"">5</sub>, *a*<sub class=""lower-index"">6</sub> and change its 3rd element (that is *a*<sub class=""lower-index"">4</sub>) to 4.",WRONG_ANSWER,"from collections import defaultdict as dd, deque as dq, Counter as ctr
import p

from re import search
input = lambda: p.stdin.readline().rstrip('\r\n')
 
from bisect import bisect_left as bl
from bisect import bisect_right as br

g = lambda: int(p.stdin.readline().rstrip(""\r\n""))
l = lambda x=int : map(x, p.stdin.readline().rstrip(""\r\n"").split())
i = lambda x=int: list(l(x))
h = lambda: list(map(int, p.stdin.readline().rstrip(""\r\n"")))
j = lambda: list(p.stdin.readline().rstrip(""\r\n""))
e = lambda n: bin(n).replace(""0b"", """")

def o(a,s):
    i=0
    for x in s:
        if i>=len(a):
            break
        if x==a[i]:
            i+=1
    return i==len(a)

r = ['No', 'Yes']
b = ['NO', 'YES']
c = ""YES""
a = ""NO""
s = ""Yes""
n = ""No""
f= p.maxsize
m=1e9+7

from math import log2
import heapq as hq

def k(kase):
    n=g()
    a=i()
    if n==1:
        print(1)
        return
    elif n==2:
        print(2)
        return
    l=[0]*n
    r=[0]*n
    j=0
    for i in range(n):
        while j<n-1 and a[j+1]>a[j] or j<i:
            j+=1
        r[i]=j-i+1
    j=n-1
    for i in range(n-1,-1,-1):
        while j>0 and a[j-1]<a[j] or j>i:
            j-=1
        l[i]=i-j+1
    d=0
    for i in range(1,n-1):
        if a[i-1]+1<a[i+1]:
            d=max(d,l[i-1]+1+r[i+1] )
    print(d)

    pass
if __name__ == ""__main__"":
    q=1

    for i in range(q):
        k(i)","import ~

def s():

    i = ~.stdin.read().split()
    if not i:
        return
    l = iter(i)
    n = int(next(l))
    t = int(next(l))

    a = [int(next(l)) for _ in range(n)]

    e = []
    d = [0] * n
    } = 0
    h = a[0]
    b = 0
    for i in range(n):
        if a[i] != h:

            j = i - 1
            q = j - } + 1
            e.append((}, j, h, q))

            for j in range(}, i):
                d[j] = b
            b += 1

            } = i
            h = a[i]

    j = n - 1
    q = j - } + 1
    e.append((}, j, h, q))
    for j in range(}, n):
        d[j] = b
    b += 1

    v = [0] * len(e)
    for i, (s, e, , r) in enumerate(e):
        g = r * r * 
        v[i] = g + (v[i - 1] if i > 0 else 0)

    def w(m, x):
        if m > x:
            return 0
        return v[x] - (v[m - 1] if m > 0 else 0)

    u = []
    for _ in range(t):

        l = int(next(l)) - 1
        r = int(next(l)) - 1

        c = d[l]
        f = d[r]
        
        if c == f:

            k = r - l + 1
            y = k * k * e[c][2]
        else:

            n = e[c]
            p = n[1] - l + 1
            o = p * p * n[2]

            z = e[f]
            | = r - z[0] + 1
            { = | * | * z[2]

            t = w(c + 1, f - 1)
            
            y = o + t + {
        
        u.append(str(y))

    ~.stdout.write(""\n"".join(u))

if __name__ == ""__main__"":
    s()"
992,A,Nastya and an Array,PROGRAMMING,"['implementation', 'sortings']","Nastya owns too many arrays now, so she wants to delete the least important of them. However, she discovered that this array is magic! Nastya now knows that the array has the following properties:
 -  In one second we can add an arbitrary (possibly negative) integer to all elements of the array that are not equal to zero. -  When all elements of the array become equal to zero, the array explodes. 
Nastya is always busy, so she wants to explode the array as fast as possible. Compute the minimum time in which the array can be exploded.","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=105) — the size of the array.

The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (<=-<=105<=≤<=*a**i*<=≤<=105) — the elements of the array.",Print a single integer — the minimum number of seconds needed to make all elements of the array equal to zero.,"['5\n1 1 1 1 1\n', '3\n2 0 -1\n', '4\n5 -6 -5 1\n']","['1\n', '2\n', '4\n']","In the first example you can add  - 1 to all non-zero elements in one second and make them equal to zero.

In the second example you can add  - 2 on the first second, then the array becomes equal to [0, 0,  - 3]. On the second second you can add 3 to the third (the only non-zero) element.",TIME_LIMIT_EXCEEDED,"def b(a):
  n = len(a)
  e = 0
  while True:
    d = 0
    c = float('inf')
    for i in range(n):
      if a[i] != 0:
        d += 1
        c = min(c, a[i])
    if d == 0:
      return e
    for i in range(n):
      if a[i] != 0:
        a[i] += -c
    e += 1

if __name__ == '__main__':
  a=int(input())
  a = list(map(int,input().split()))
  
  e = b(a)

  print(e)","def d():

    n, m = map(int, input().split())

    b = {}
    for _ in range(m):
        a, f = input().split()
        b[a] = f

    c = input().split()

    e = []
    for g in c:
        if len(b[g]) < len(g):
            e.append(b[g])
        else:
            e.append(g)

    print("" "".join(e))

if __name__ == ""__main__"":
    d()"
416,A,Guess a number!,PROGRAMMING,"['greedy', 'implementation', 'two pointers']","A TV show called ""Guess a number!"" is gathering popularity. The whole Berland, the old and the young, are watching the show.

The rules are simple. The host thinks of an integer *y* and the participants guess it by asking questions to the host. There are four types of acceptable questions:
 -  Is it true that *y* is strictly larger than number *x*? -  Is it true that *y* is strictly smaller than number *x*? -  Is it true that *y* is larger than or equal to number *x*? -  Is it true that *y* is smaller than or equal to number *x*? 
On each question the host answers truthfully, ""yes"" or ""no"".

Given the sequence of questions and answers, find any integer value of *y* that meets the criteria of all answers. If there isn't such value, print ""Impossible"".","The first line of the input contains a single integer *n* (1<=≤<=*n*<=≤<=10000) — the number of questions (and answers). Next *n* lines each contain one question and one answer to it. The format of each line is like that: ""sign x answer"", where the sign is:
 -  ""&gt;"" (for the first type queries), -  ""&lt;"" (for the second type queries), -  ""&gt;="" (for the third type queries), -  ""&lt;="" (for the fourth type queries). 
All values of *x* are integer and meet the inequation <=-<=109<=≤<=*x*<=≤<=109. The answer is an English letter ""Y"" (for ""yes"") or ""N"" (for ""no"").

Consequtive elements in lines are separated by a single space.","Print any of such integers *y*, that the answers to all the queries are correct. The printed number *y* must meet the inequation <=-<=2·109<=≤<=*y*<=≤<=2·109. If there are many answers, print any of them. If such value doesn't exist, print word ""Impossible"" (without the quotes).","['4\n&gt;= 1 Y\n&lt; 3 N\n&lt;= -3 N\n&gt; 55 N\n', '2\n&gt; 100 Y\n&lt; -100 Y\n']","['17\n', 'Impossible\n']",none,RUNTIME_ERROR,"def h(f, g): 
  
    i = zip(g, f) 
  
    z = [x for _, x in sorted(i)] 
      
    return z 
n=int(input())
c=[0]*n
p=[0]*n
d=[0]*n
for i in range(n):
    c[i],p[i]=map(int,input().split())
    d[i]=i
c=h(c,p)
d=h(d,p)
d.reverse()
p.sort(reverse=True)
c.reverse()
a=0
b=0
k=int(input())
l=list(map(int,input().split()))
d=dict()
for i in range(n):
    e=-1
    c=999999999999999999
    for j in range(k):
        if c[i]<=l[j] and l[j]<=c:
            e=j
            c=l[j]
    if c!=999999999999999999:
        a+=1
        b+=p[i]
        l[e]=999999999999999999999999
        d.update({d[i]:e+1})
print(a,b)
for i in sorted(d.keys()):
    print(i+1,d[i]+1)","import l

def f():

    d = l.stdin.read().strip().split()
    if not d:
        return

    n = int(d[0])
    m = int(d[1])

    b = set()
    a = set()

    g = []
    
    e = 2
    for _ in range(m):

        h = int(d[e])
        c = int(d[e + 1])
        e += 2

        b.add(h)
        a.add(c)

        k = n - len(b)
        j = n - len(a)

        i = k * j
        g.append(str(i))

    l.stdout.write("" "".join(g) + "" \n"")

if __name__ == ""__main__"":
    f()"
264,A,Escape from Stones,PROGRAMMING,"['constructive algorithms', 'data structures', 'implementation', 'two pointers']","Squirrel Liss lived in a forest peacefully, but unexpected trouble happens. Stones fall from a mountain. Initially Squirrel Liss occupies an interval [0,<=1]. Next, *n* stones will fall and Liss will escape from the stones. The stones are numbered from 1 to *n* in order.

The stones always fall to the center of Liss's interval. When Liss occupies the interval [*k*<=-<=*d*,<=*k*<=+<=*d*] and a stone falls to *k*, she will escape to the left or to the right. If she escapes to the left, her new interval will be [*k*<=-<=*d*,<=*k*]. If she escapes to the right, her new interval will be [*k*,<=*k*<=+<=*d*].

You are given a string *s* of length *n*. If the *i*-th character of *s* is ""l"" or ""r"", when the *i*-th stone falls Liss will escape to the left or to the right, respectively. Find the sequence of stones' numbers from left to right after all the *n* stones falls.","The input consists of only one line. The only line contains the string *s* (1<=≤<=|*s*|<=≤<=106). Each character in *s* will be either ""l"" or ""r"".",Output *n* lines — on the *i*-th line you should print the *i*-th stone's number from the left.,"['llrlr\n', 'rrlll\n', 'lrlrr\n']","['3\n5\n4\n2\n1\n', '1\n2\n5\n4\n3\n', '2\n4\n5\n3\n1\n']","In the first example, the positions of stones 1, 2, 3, 4, 5 will be <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/58fdb5684df807bfcb705a9da9ce175613362b7d.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>, respectively. So you should print the sequence: 3, 5, 4, 2, 1.",OK,"def c():
    b = input()
    l = [None] * len(b)
    d = 0
    e = len(b)-1
    a = 0
    for c in b:
        a += 1
        if c == 'l':
            l[e] = a
            e -= 1
        else:
            l[d] = a
            d += 1
    for n in l:
        print(n)

if __name__ == ""__main__"":
    c()","def k():
    import l
    b = l.stdin.read().splitlines()
    if not b:
        return

    e = b[0].split()
    n = int(e[0])
    k = int(e[1])

    s = b[1].strip()

    c = [None] * (n + 1)
    c[0] = {0: None}

    for i in range(n):
        c[i + 1] = {}

        if s[i] == '?':
            g = ['W', 'L', 'D']
        else:
            g = [s[i]]

        for d in c[i]:
            for f in g:
                if f == 'W':
                    h = d + 1
                elif f == 'L':
                    h = d - 1
                elif f == 'D':
                    h = d
                else:
                    continue

                if i < n - 1:
                    if abs(h) >= k:
                        continue
                else:

                    if abs(h) != k:
                        continue

                if h not in c[i + 1]:
                    c[i + 1][h] = (d, f)

        if not c[i + 1]:
            break

    if c[n]:

        d = next(iter(c[n].keys()))
        j = []
        a = d

        for i in range(n, 0, -1):
            i, f = c[i][a]
            j.append(f)
            a = i
        j.reverse()
        l.stdout.write("""".join(j))
    else:
        l.stdout.write(""NO"")

if __name__ == '__main__':
    k()"
47,B,Coins,PROGRAMMING,['implementation'],"One day Vasya came across three Berland coins. They didn't have any numbers that's why Vasya didn't understand how their denominations differ. He supposed that if one coin is heavier than the other one, then it should be worth more. Vasya weighed all the three pairs of coins on pan balance scales and told you the results. Find out how the deminations of the coins differ or if Vasya has a mistake in the weighting results. No two coins are equal.","The input data contains the results of all the weighting, one result on each line. It is guaranteed that every coin pair was weighted exactly once. Vasya labelled the coins with letters «A», «B» and «C». Each result is a line that appears as (letter)(&gt; or &lt; sign)(letter). For example, if coin ""A"" proved lighter than coin ""B"", the result of the weighting is A&lt;B.","It the results are contradictory, print Impossible. Otherwise, print without spaces the rearrangement of letters «A», «B» and «C» which represent the coins in the increasing order of their weights.","['A&gt;B\nC&lt;B\nA&gt;C\n', 'A&lt;B\nB&gt;C\nC&gt;A\n']","['CBA', 'ACB']",none,OK,"def d(l):
    i = {'A': set(), 'B': set(), 'C': set()}

    for j in l:
        b, k, c = j[0], j[1], j[2]
        if k == '>':
            i[b].add(c)
        else:
            i[c].add(b)

    e = [a for a in i if not i[a]]
    f = [a for a in i if len(i[a]) == 2]

    if not e or not f:
        return ""Impossible""
    else:
        g = list(set(i.keys()) - set(e + f))[0]
        return e[0] + g + f[0]

l = []
for _ in range(3):
    j = input().strip()
    l.append(j)

h = d(l)
print(h)","import p
import g

def m():

    c = p.stdin.read().split()
    if not c:
        return
    n = int(c[0])
    q = []

    l = 1
    for i in range(n):
        x = int(c[l])
        y = int(c[l+1])
        l += 2

        a = g.atan2(y, x)
        q.append((a, x, y, i))

    q.sort(key=lambda x: x[0])

    b = [0] * n

    n, o = 0, 0

    for a, r, s, f in q:

        h = n + r
        j = o + s
        d = h * h + j * j

        i = n - r
        k = o - s
        e = i * i + k * k

        if d <= e:
            b[f] = 1
            n, o = h, j
        else:
            b[f] = -1
            n, o = i, k

    p.stdout.write("" "".join(str(x) for x in b) + ""\n"")

if __name__ == ""__main__"":
    m()"
302,A,Eugeny and Array,PROGRAMMING,['implementation'],"Eugeny has array *a*<==<=*a*1,<=*a*2,<=...,<=*a**n*, consisting of *n* integers. Each integer *a**i* equals to -1, or to 1. Also, he has *m* queries:
 -  Query number *i* is given as a pair of integers *l**i*, *r**i* (1<=≤<=*l**i*<=≤<=*r**i*<=≤<=*n*). -  The response to the query will be integer 1, if the elements of array *a* can be rearranged so as the sum *a**l**i*<=+<=*a**l**i*<=+<=1<=+<=...<=+<=*a**r**i*<==<=0, otherwise the response to the query will be integer 0. 
Help Eugeny, answer all his queries.","The first line contains integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=2·105). The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (*a**i*<==<=-1,<=1). Next *m* lines contain Eugene's queries. The *i*-th line contains integers *l**i*,<=*r**i* (1<=≤<=*l**i*<=≤<=*r**i*<=≤<=*n*).",Print *m* integers — the responses to Eugene's queries in the order they occur in the input.,"['2 3\n1 -1\n1 1\n1 2\n2 2\n', '5 5\n-1 1 1 1 -1\n1 1\n2 3\n3 5\n2 5\n1 5\n']","['0\n1\n0\n', '0\n1\n0\n1\n0\n']",none,RUNTIME_ERROR,"def c(a,m,l,r):
    d = abs(r-l)+1
    if(d%2 != 0):
        return 0
    b = d//2
    a = d//2
    for i in a:
        if(i==1):
            b = b-1
        else:
            a = a-1
        if(b <= 0 and a <= 0):
            return 1
    return 0

n,m = input().split()
n = int(n)
m = int(m)
for i in range(m):
    l,r = input().split()
    l = int(l)
    r = int(r)
    print(c(a,m,l,r))","def k():
    import p
    from collections import g

    p.setrecursionlimit(10**6)
    e = p.stdin.read().strip().split()
    if not e:
        return
    n = int(e[0])
    m = int(e[1])

    i = [[] for _ in range(n + 1)]

    f = [0] * (n + 1)
    
    j = 2
    for _ in range(m):
        u = int(e[j])
        v = int(e[j + 1])
        j += 2
        i[u].append(v)
        i[v].append(u)
        f[u] += 1
        f[v] += 1

    a = [-1] * (n + 1)
    n = True

    for o in range(1, n + 1):
        if f[o] == 0:

            continue
        if a[o] == -1:
            h = g([o])
            a[o] = 0
            while h:
                d = h.popleft()
                for l in i[d]:
                    if a[l] == -1:
                        a[l] = 1 - a[d]
                        h.append(l)
                    elif a[l] == a[d]:

                        n = False
                        break
                if not n:
                    break
        if not n:
            break

    if not n:
        p.stdout.write(""-1"")
        return

    b = []
    c = []
    for i in range(1, n + 1):
        if f[i] == 0:
            continue
        if a[i] == 0:
            b.append(i)
        else:
            c.append(i)

    m = []
    m.append(str(len(b)))
    if b:
        m.append("" "".join(map(str, b)) + "" "")
    else:
        m.append("""")
    m.append(str(len(c)))
    if c:
        m.append("" "".join(map(str, c)) + "" "")
    else:
        m.append("""")

    p.stdout.write(""\n"".join(m) + ""\n"")

if __name__ == '__main__':
    k()"
102,B,Sum of Digits,PROGRAMMING,['implementation'],"Having watched the last Harry Potter film, little Gerald also decided to practice magic. He found in his father's magical book a spell that turns any number in the sum of its digits. At the moment Gerald learned that, he came across a number *n*. How many times can Gerald put a spell on it until the number becomes one-digit?",The first line contains the only integer *n* (0<=≤<=*n*<=≤<=10100000). It is guaranteed that *n* doesn't contain any leading zeroes.,Print the number of times a number can be replaced by the sum of its digits until it only contains one digit.,"['0\n', '10\n', '991\n']","['0\n', '1\n', '3\n']","In the first sample the number already is one-digit — Herald can't cast a spell.

The second test contains number 10. After one casting of a spell it becomes 1, and here the process is completed. Thus, Gerald can only cast the spell once.

The third test contains number 991. As one casts a spell the following transformations take place: 991 → 19 → 10 → 1. After three transformations the number becomes one-digit.",OK,"import e
input = e.stdin.readline
import math

def a():
    return(int(input()))
def b():
    return(list(map(int,input().split())))
def d():
    s = input()
    return(list(s[:len(s) - 1]))
def c():
    return(map(int,input().split()))

n= str(a())
    
if(len(n) ==1):
    print(0)
else:
    t = 0
    while(True):
        n = str(sum([int(i) for i in n]))
        t = t +1 
        if(len(n)==1):
            print(t)
            break","""""""
This script finds the smallest and largest m-digit numbers 
with a given sum of digits s. If no such numbers exist, it outputs ""-1 -1"".
""""""

import k

def c(m, s):
    """"""
    Constructs the minimum m-digit number with sum of digits s.
    Returns the number as a string or None if impossible.
    """"""

    if s == 0:
        return ""0"" if m == 1 else None
    if s > 9 * m:
        return None

    a = [0] * m

    j = s

    for i in range(m):

        f = 1 if i == 0 else 0
        for d in range(f, 10):

            if j - d < 0:
                break
            if j - d > 9 * (m - i - 1):
                continue
            a[i] = d
            j -= d
            break
    return """".join(str(d) for d in a)

def b(m, s):
    """"""
    Constructs the maximum m-digit number with sum of digits s.
    Returns the number as a string or None if impossible.
    """"""

    if s == 0:
        return ""0"" if m == 1 else None
    if s > 9 * m:
        return None

    a = [0] * m
    j = s

    for i in range(m):

        f = 1 if i == 0 else 0
        for d in range(9, f - 1, -1):
            if j - d < 0:
                continue
            if j - d > 9 * (m - i - 1):
                continue
            a[i] = d
            j -= d
            break
    return """".join(str(d) for d in a)

def g():
    d = k.stdin.readlines()
    for e in d:
        if not e.strip():
            continue
        try:
            m, s = map(int, e.strip().split())
        except ValueError:
            continue
        
        i = c(m, s)
        h = b(m, s)

        if i is None or h is None:
            print(""-1 -1"")
        else:
            print(i, h)

if __name__ == ""__main__"":
    g()"
508,A,Pasha and Pixels,PROGRAMMING,['brute force'],"Pasha loves his phone and also putting his hair up... But the hair is now irrelevant.

Pasha has installed a new game to his phone. The goal of the game is following. There is a rectangular field consisting of *n* row with *m* pixels in each row. Initially, all the pixels are colored white. In one move, Pasha can choose any pixel and color it black. In particular, he can choose the pixel that is already black, then after the boy's move the pixel does not change, that is, it remains black. Pasha loses the game when a 2<=×<=2 square consisting of black pixels is formed. 

Pasha has made a plan of *k* moves, according to which he will paint pixels. Each turn in his plan is represented as a pair of numbers *i* and *j*, denoting respectively the row and the column of the pixel to be colored on the current move.

Determine whether Pasha loses if he acts in accordance with his plan, and if he does, on what move the 2<=×<=2 square consisting of black pixels is formed.","The first line of the input contains three integers *n*,<=*m*,<=*k* (1<=≤<=*n*,<=*m*<=≤<=1000, 1<=≤<=*k*<=≤<=105) — the number of rows, the number of columns and the number of moves that Pasha is going to perform. 

The next *k* lines contain Pasha's moves in the order he makes them. Each line contains two integers *i* and *j* (1<=≤<=*i*<=≤<=*n*, 1<=≤<=*j*<=≤<=*m*), representing the row number and column number of the pixel that was painted during a move.","If Pasha loses, print the number of the move when the 2<=×<=2 square consisting of black pixels is formed.

If Pasha doesn't lose, that is, no 2<=×<=2 square consisting of black pixels is formed during the given *k* moves, print 0.","['2 2 4\n1 1\n1 2\n2 1\n2 2\n', '2 3 6\n2 3\n2 2\n1 3\n2 2\n1 2\n1 1\n', '5 3 7\n2 3\n1 2\n1 1\n4 1\n3 1\n5 3\n3 2\n']","['4\n', '5\n', '0\n']",none,WRONG_ANSWER,"n, m, k = map(int, input().split())

a = set()

def b(i, j):
    c = 0
    for d in range(-1, 2):
        for e in range(-1, 2):
            if (i+d, j+e) in a:
                c += 1
    return c == 3

for f in range(1, k+1):
    i, j = map(int, input().split())
    a.add((i-1, j-1))

    for d in range(-1, 2):
        for e in range(-1, 2):
            if (i-1+d, j-1+e) in a and b(i-1+d, j-1+e):
                print(f)
                exit()

print(0)","def h():
    import k

    e = k.stdin.read().split()
    if not e:
        return

    n = int(e[0])
    i = 1
    f = []

    for _ in range(n - 1):
        u = int(e[i])
        v = int(e[i + 1])
        f.append((u, v))
        i += 2

    d = [0] * (n + 1)
    for i in range(1, n + 1):
        d[i] = int(e[i])
        i += 1

    j = []
    for u, v in f:
        if d[u] != d[v]:
            j.append((u, v))

    if not j:
        k.stdout.write(""YES\n1"")
        return

    b, c = j[0]

    def g(a):
        for u, v in j:
            if a != u and a != v:
                return False
        return True

    if g(b):
        k.stdout.write(""YES\n"" + str(b))
    elif g(c):
        k.stdout.write(""YES\n"" + str(c))
    else:
        k.stdout.write(""NO"")

if __name__ == ""__main__"":
    h()"
664,A,Complicated GCD,PROGRAMMING,"['math', 'number theory']","Greatest common divisor *GCD*(*a*,<=*b*) of two positive integers *a* and *b* is equal to the biggest integer *d* such that both integers *a* and *b* are divisible by *d*. There are many efficient algorithms to find greatest common divisor *GCD*(*a*,<=*b*), for example, Euclid algorithm. 

Formally, find the biggest integer *d*, such that all integers *a*,<=*a*<=+<=1,<=*a*<=+<=2,<=...,<=*b* are divisible by *d*. To make the problem even more complicated we allow *a* and *b* to be up to googol, 10100 — such number do not fit even in 64-bit integer type!",The only line of the input contains two integers *a* and *b* (1<=≤<=*a*<=≤<=*b*<=≤<=10100).,Output one integer — greatest common divisor of all integers from *a* to *b* inclusive.,"['1 2\n', '61803398874989484820458683436563811772030917980576 61803398874989484820458683436563811772030917980576\n']","['1\n', '61803398874989484820458683436563811772030917980576\n']",none,OK,"def b(a, b):
    while b != 0:
        c = a % b
        a = b
        b = c
    return a
x, y = map(int, input().split())
a = set()
if y - x >= 1:
    print(1)
else:
    print(b(x, y))","def d():

    n = int(input().strip())

    c = [100, 20, 10, 5, 1]

    b = 0
    for a in c:

        e = n // a
        b += e

        n %= a

    print(b)

if __name__ == '__main__':
    d()"
225,A,Dice Tower,PROGRAMMING,"['constructive algorithms', 'greedy']","A dice is a cube, its faces contain distinct integers from 1 to 6 as black points. The sum of numbers at the opposite dice faces always equals 7. Please note that there are only two dice (these dices are mirror of each other) that satisfy the given constraints (both of them are shown on the picture on the left).

Alice and Bob play dice. Alice has built a tower from *n* dice. We know that in this tower the adjacent dice contact with faces with distinct numbers. Bob wants to uniquely identify the numbers written on the faces of all dice, from which the tower is built. Unfortunately, Bob is looking at the tower from the face, and so he does not see all the numbers on the faces. Bob sees the number on the top of the tower and the numbers on the two adjacent sides (on the right side of the picture shown what Bob sees).

Help Bob, tell whether it is possible to uniquely identify the numbers on the faces of all the dice in the tower, or not.","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=100) — the number of dice in the tower.

The second line contains an integer *x* (1<=≤<=*x*<=≤<=6) — the number Bob sees at the top of the tower. Next *n* lines contain two space-separated integers each: the *i*-th line contains numbers *a**i*,<=*b**i* (1<=≤<=*a**i*,<=*b**i*<=≤<=6; *a**i*<=≠<=*b**i*) — the numbers Bob sees on the two sidelong faces of the *i*-th dice in the tower.

Consider the dice in the tower indexed from top to bottom from 1 to *n*. That is, the topmost dice has index 1 (the dice whose top face Bob can see). It is guaranteed that it is possible to make a dice tower that will look as described in the input.","Print ""YES"" (without the quotes), if it is possible to to uniquely identify the numbers on the faces of all the dice in the tower. If it is impossible, print ""NO"" (without the quotes).","['3\n6\n3 2\n5 4\n2 4\n', '3\n3\n2 6\n4 1\n5 3\n']","['YES', 'NO']",none,WRONG_ANSWER,"n = int(input())
x = int(input())
c = []
a = {1,2,3,4,5,6}
for i in range(n):
  e = set(map(int, input().split()))
  d = set()
  for v in e:
    d.add(v)
    d.add(7-v)
  if i == 0:
    d.add(x)
  c.append(a - d)

i = 1
if  n == 1:
  print(""YES"")
  exit()
c[1] = c[1] - c[0]
if len(c[1]) == 2:
  print(""NO"")
  exit()

i = 2
while i < n:
  b = c[i] - c[i-1]
  if len(b) == 0:
    print(""NO"")
    exit()
  i += 1
  
  
print(""YES"")","from math import b

Y, W = map(int, input().split())

c = max(Y, W)

g = 7 - c

f = 6

a = b(g, f)

e = g // a
d = f // a

print(f""{e}/{d}"")"
863,C,1-2-3,PROGRAMMING,"['graphs', 'implementation']","Ilya is working for the company that constructs robots. Ilya writes programs for entertainment robots, and his current project is ""Bob"", a new-generation game robot. Ilya's boss wants to know his progress so far. Especially he is interested if Bob is better at playing different games than the previous model, ""Alice"". 

So now Ilya wants to compare his robots' performance in a simple game called ""1-2-3"". This game is similar to the ""Rock-Paper-Scissors"" game: both robots secretly choose a number from the set {1,<=2,<=3} and say it at the same moment. If both robots choose the same number, then it's a draw and noone gets any points. But if chosen numbers are different, then one of the robots gets a point: 3 beats 2, 2 beats 1 and 1 beats 3. 

Both robots' programs make them choose their numbers in such a way that their choice in (*i*<=+<=1)-th game depends only on the numbers chosen by them in *i*-th game. 

Ilya knows that the robots will play *k* games, Alice will choose number *a* in the first game, and Bob will choose *b* in the first game. He also knows both robots' programs and can tell what each robot will choose depending on their choices in previous game. Ilya doesn't want to wait until robots play all *k* games, so he asks you to predict the number of points they will have after the final game.","The first line contains three numbers *k*, *a*, *b* (1<=≤<=*k*<=≤<=1018, 1<=≤<=*a*,<=*b*<=≤<=3). 

Then 3 lines follow, *i*-th of them containing 3 numbers *A**i*,<=1, *A**i*,<=2, *A**i*,<=3, where *A**i*,<=*j* represents Alice's choice in the game if Alice chose *i* in previous game and Bob chose *j* (1<=≤<=*A**i*,<=*j*<=≤<=3). 

Then 3 lines follow, *i*-th of them containing 3 numbers *B**i*,<=1, *B**i*,<=2, *B**i*,<=3, where *B**i*,<=*j* represents Bob's choice in the game if Alice chose *i* in previous game and Bob chose *j* (1<=≤<=*B**i*,<=*j*<=≤<=3).","Print two numbers. First of them has to be equal to the number of points Alice will have, and second of them must be Bob's score after *k* games.","['10 2 1\n1 1 1\n1 1 1\n1 1 1\n2 2 2\n2 2 2\n2 2 2\n', '8 1 1\n2 2 1\n3 3 1\n3 1 3\n1 1 1\n2 1 1\n1 2 3\n', '5 1 1\n1 2 2\n2 2 2\n2 2 2\n1 2 2\n2 2 2\n2 2 2\n']","['1 9\n', '5 2\n', '0 0\n']","In the second example game goes like this:

<img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/1e21b6e200707470571d69c9946ace6b56f5279b.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

The fourth and the seventh game are won by Bob, the first game is draw and the rest are won by Alice.",RUNTIME_ERROR,"k, a, b = [int(i) for i in input().split("" "")]
A = []
B = []
g = 0
k = 0
d = a
i = b
e = []
j = []
p = []
f = 0
for i in range(3):
    A.append(input())
for i in range(3):
    B.append(input())

def a(i,j):
    return int((A[i-1])[2*j-2])

def b(i,j):
    return int((B[i-1])[2*j-2])

if d == i + 1 or d == i - 2:
    g += 1
    e.append(d)
    j.append(i)
    p.append(1)
elif i == d + 1 or i == d - 2:
    k += 1
    e.append(d)
    j.append(i)
    p.append(-1)
else:
    e.append(d)
    j.append(i)
    p.append(0)

for q in range(k-1):
    q = a(d,i)
    r = b(d,i)
    d = q
    i = r
    if d == i + 1 or d == i - 2:
        g += 1
        e.append(d)
        j.append(i)
        p.append(1)
    elif i == d + 1 or i == d - 2:
        k += 1
        e.append(d)
        j.append(i)
        p.append(-1)
    else:
        e.append(d)
        j.append(i)
        p.append(0)
    for r in range(q + 1):
        if d == e[r] and i == j[r]:
            f = 1
            break
    if f == 1:
        break
q += 1
m = q - r
o = p[r:q]
l = (k - len(p)) % m
n = int((k - len(p) - l) / m)
c = 0
h = 0
for i in o:
    if i == 1:
        c += 1
    elif i == -1:
        h += 1
g += c*n
k += h*n
for i in o[:l]:
    if i == 1:
        g += 1
    elif i == -1:
        k += 1

print(g, l = ' ')
print(k)","def g(s):
    """"""
    Computes the prefix function for the string s.
    pi[i] is the length of the longest proper prefix which is also a suffix for s[:i+1].
    """"""
    n = len(s)
    f = [0] * n
    j = 0
    for i in range(1, n):
        while j > 0 and s[i] != s[j]:
            j = f[j - 1]
        if s[i] == s[j]:
            j += 1
        f[i] = j
    return f

def h(s):
    n = len(s)
    f = g(s)

    c = [0] * (n + 1)
    for i in range(n - 1):
        c[f[i]] += 1

    a = f[-1]

    while a > 0 and c[a] == 0:
        a = f[a - 1]
    
    if a > 0:
        return s[:a]
    else:
        return ""Just a legend""

def e():
    import i
    b = i.stdin.read().splitlines()

    for d in b:
        if d.strip():
            s = d.strip()
            print(h(s))

if __name__ == '__main__':
    e()"
808,E,Selling Souvenirs,PROGRAMMING,"['binary search', 'dp', 'greedy', 'ternary search']","After several latest reforms many tourists are planning to visit Berland, and Berland people understood that it's an opportunity to earn money and changed their jobs to attract tourists. Petya, for example, left the IT corporation he had been working for and started to sell souvenirs at the market.

This morning, as usual, Petya will come to the market. Petya has *n* different souvenirs to sell; *i*th souvenir is characterised by its weight *w**i* and cost *c**i*. Petya knows that he might not be able to carry all the souvenirs to the market. So Petya wants to choose a subset of souvenirs such that its total weight is not greater than *m*, and total cost is maximum possible.

Help Petya to determine maximum possible total cost.","The first line contains two integers *n* and *m* (1<=≤<=*n*<=≤<=100000, 1<=≤<=*m*<=≤<=300000) — the number of Petya's souvenirs and total weight that he can carry to the market.

Then *n* lines follow. *i*th line contains two integers *w**i* and *c**i* (1<=≤<=*w**i*<=≤<=3, 1<=≤<=*c**i*<=≤<=109) — the weight and the cost of *i*th souvenir.",Print one number — maximum possible total cost of souvenirs that Petya can carry to the market.,"['1 1\n2 1\n', '2 2\n1 3\n2 2\n', '4 3\n3 10\n2 7\n2 8\n1 1\n']","['0\n', '3\n', '10\n']",none,TIME_LIMIT_EXCEEDED,"def a(w,c,m,n):
    y = [[0 for i in range(m+1)]for i in range(n+1)]
    for i in range(0,n+1):
        for a in range(0,m+1):
            if i==0 or a==0:
               y[i][a] = 0
            elif w[i-1] <= a:
                y[i][a] = max(c[i-1] + y[i-1][a-w[i-1]],  y[i-1][a]);
            else:
                y[i][a] = y[i-1][a]
    return y[n][m]            

p = input()
p = p.split()
x = [int(i) for i in p]
n = x[0]
m = x[1]
w = [0 for i in range(n)]
c = [0 for i in range(n)]     
for j in range(0,n):
    p = input()
    p = p.split()
    x = [int(i) for i in p]
    w[j] = x[0]
    c[j] = x[1]

print(a(w,c,m,n))","import m
import j

def i():

    c = m.stdin.read().strip().split()
    if not c:
        return
    t = int(c[0])
    w = int(c[1])
    b = int(c[2])

    g = j.gcd(w, b)
    h = (w // g) * b

    k = min(w, b)

    b = 0

    b += min(t, k - 1)

    K = t // h
    f = 0
    if t >= k:
        f = (t - k + 1) // h
        f = min(K, f)

    b += f * k

    if K > f:
        n = K - f
        e = t - (f + 1) * h + 1
        g = t - K * h + 1
        b += n * (e + g) // 2

    if b == 0:
        m.stdout.write(""0/1"")
        return
    a = j.gcd(b, t)
    l = b // a
    d = t // a
    m.stdout.write(f""{l}/{d}"")

if __name__ == '__main__':
    i()"
524,A,"Возможно, вы знаете этих людей?",PROGRAMMING,['implementation'],"Основой любой социальной сети является отношение дружбы между двумя пользователями в том или ином смысле. В одной известной социальной сети дружба симметрична, то есть если *a* является другом *b*, то *b* также является другом *a*. 

В этой же сети есть функция, которая демонстрирует множество людей, имеющих высокую вероятность быть знакомыми для пользователя. Эта функция работает следующим образом. Зафиксируем пользователя *x*. Пусть некоторый другой человек *y*, не являющийся другом *x* на текущий момент, является другом не менее, чем для *k*% друзей *x*. Тогда он является предполагаемым другом для *x*.

У каждого человека в социальной сети есть свой уникальный идентификатор — это целое число от 1 до 109. Вам дан список пар пользователей, являющихся друзьями. Определите для каждого упомянутого пользователя множество его предполагаемых друзей.","В первой строке следуют два целых числа *m* и *k* (1<=≤<=*m*<=≤<=100, 0<=≤<=*k*<=≤<=100) — количество пар друзей и необходимый процент общих друзей для того, чтобы считаться предполагаемым другом.

В последующих *m* строках записано по два числа *a**i*,<=*b**i* (1<=≤<=*a**i*,<=*b**i*<=≤<=109, *a**i*<=≠<=*b**i*), обозначающих идентификаторы пользователей, являющихся друзьями. 

Гарантируется, что каждая пара людей фигурирует в списке не более одного раза.","Для всех упомянутых людей в порядке возрастания id выведите информацию о предполагаемых друзьях. Информация должна иметь вид ""*id*:<= *k* *id*1 *id*2 ... *id**k*"", где *id* — это id самого человека, *k* — количество его предполагаемых друзей, а *id*1, *id*2, ..., *id**k* — идентификаторы его предполагаемых друзей в возрастающем порядке.","['5 51\n10 23\n23 42\n39 42\n10 39\n39 58\n', '5 100\n1 2\n1 3\n1 4\n2 3\n2 4\n']","['10: 1 42\n23: 1 39\n39: 1 23\n42: 1 10\n58: 2 10 42\n', '1: 0\n2: 0\n3: 1 4\n4: 1 3\n']",none,WRONG_ANSWER,"def c():
    from collections import a
    
    m, k = [int(i) for i in input().split()]
    
    d = a(set)
    for i in range(m):
        a, b = [int(i) for i in input().split()]
        d[a].add(b)
        d[b].add(a)
    
    b = sorted(d.b())
    for i in b:
        d = []
        for j in b:
            if i != j and len(d[i] & d[j]) >= (len(d[i]) * k + 99) // 100:
                d.append(j)
        print(""{0}: {1} {2}"".format(i, len(d), ' '.join(str(i) for i in d)))
            
    
c()","import f

def c():

    a = f.stdin.read().split()
    if not a:
        return

    s = a[0]
    n = len(s)

    m = int(a[1])

    d = [0] * n
    for i in range(1, n):
        d[i] = d[i - 1] + (1 if s[i - 1] == s[i] else 0)

    e = []
    b = 2
    for _ in range(m):
        l = int(a[b])
        r = int(a[b + 1])
        b += 2

        e.append(str(d[r - 1] - d[l - 1]))

    f.stdout.write(""\n"".join(e))

if __name__ == ""__main__"":
    c()"
9,A,Die Roll,PROGRAMMING,"['math', 'probabilities']","Yakko, Wakko and Dot, world-famous animaniacs, decided to rest from acting in cartoons, and take a leave to travel a bit. Yakko dreamt to go to Pennsylvania, his Motherland and the Motherland of his ancestors. Wakko thought about Tasmania, its beaches, sun and sea. Dot chose Transylvania as the most mysterious and unpredictable place.

But to their great regret, the leave turned to be very short, so it will be enough to visit one of the three above named places. That's why Yakko, as the cleverest, came up with a truly genius idea: let each of the three roll an ordinary six-sided die, and the one with the highest amount of points will be the winner, and will take the other two to the place of his/her dreams.

Yakko thrown a die and got Y points, Wakko — W points. It was Dot's turn. But she didn't hurry. Dot wanted to know for sure what were her chances to visit Transylvania.

It is known that Yakko and Wakko are true gentlemen, that's why if they have the same amount of points with Dot, they will let Dot win.",The only line of the input file contains two natural numbers Y and W — the results of Yakko's and Wakko's die rolls.,"Output the required probability in the form of irreducible fraction in format «A/B», where A — the numerator, and B — the denominator. If the required probability equals to zero, output «0/1». If the required probability equals to 1, output «1/1».",['4 2\n'],['1/2\n'],"Dot will go to Transylvania, if she is lucky to roll 4, 5 or 6 points.",WRONG_ANSWER,"e = list(map(int,input().split()))
c = max(e)
d = 6 - c + 1

def b(a , b) :
    if a % b == 0 : return b
    return b(b , a % b)

a = b(6 , d)
print(a)
print(d // a , 6 // a)","def b():

    s = input().strip()

    c = ""hello""

    j = 0

    for a in s:

        if a == c[j]:
            j += 1

            if j == len(c):
                break

    print(""YES"" if j == len(c) else ""NO"")

if __name__ == ""__main__"":
    b()"
106,A,Card Game,PROGRAMMING,['implementation'],"There is a card game called ""Durak"", which means ""Fool"" in Russian. The game is quite popular in the countries that used to form USSR. The problem does not state all the game's rules explicitly — you can find them later yourselves if you want.

To play durak you need a pack of 36 cards. Each card has a suit (""S"", ""H"", ""D"" and ""C"") and a rank (in the increasing order ""6"", ""7"", ""8"", ""9"", ""T"", ""J"", ""Q"", ""K"" and ""A""). At the beginning of the game one suit is arbitrarily chosen as trump. 

The players move like that: one player puts one or several of his cards on the table and the other one should beat each of them with his cards.

A card beats another one if both cards have similar suits and the first card has a higher rank then the second one. Besides, a trump card can beat any non-trump card whatever the cards’ ranks are. In all other cases you can not beat the second card with the first one.

You are given the trump suit and two different cards. Determine whether the first one beats the second one or not.","The first line contains the tramp suit. It is ""S"", ""H"", ""D"" or ""C"".

The second line contains the description of the two different cards. Each card is described by one word consisting of two symbols. The first symbol stands for the rank (""6"", ""7"", ""8"", ""9"", ""T"", ""J"", ""Q"", ""K"" and ""A""), and the second one stands for the suit (""S"", ""H"", ""D"" and ""C"").","Print ""YES"" (without the quotes) if the first cards beats the second one. Otherwise, print ""NO"" (also without the quotes).","['H\nQH 9S\n', 'S\n8D 6D\n', 'C\n7H AS\n']","['YES\n', 'YES', 'NO']",none,WRONG_ANSWER,"import a,math
a.setrecursionlimit(10**8)
'''
def fun():
    for i in range(16):
        for j in range(4):
            if i&(1<<j):
                print(j,end='')
        print()
import binarytree
from collections import deque
bst = binarytree.tree(height=4,is_perfect=True)
print(bst)
def s(bst):
    if bst:
        bst.left,bst.right = bst.right,bst.left
        s(bst.right)
        s(bst.left)
s(bst)
print(bst)
'''
s = input()
p = input().split(' ')
c = ['6','7','8','9','T','J','Q','K','A']
print('YES' if s == p[0][1] or (p[0][1] == p[1][1] and\
    c.index(p[0][0])>c.index(p[1][0])) else 'NO')","def d(u, r, s, l, m, e, h, f, g):

    j = l - r
    k = m - s

    if j >= 0:
        b = e[u]
    else:
        b = h[u]

    if k >= 0:
        c = f[u]
    else:
        c = g[u]

    return abs(j) <= b and abs(k) <= c

def p():
    import t

    i = t.stdin.read().split()

    if not i:
        return
    t = int(i[0])
    r = int(i[1])
    s = int(i[2])
    l = int(i[3])
    m = int(i[4])
    w = i[5].strip()

    e = [0] * (t + 1)
    h = [0] * (t + 1)
    f = [0] * (t + 1)
    g = [0] * (t + 1)
    
    for i in range(1, t + 1):

        e[i] = e[i - 1]
        h[i] = h[i - 1]
        f[i] = f[i - 1]
        g[i] = g[i - 1]
        v = w[i - 1]
        if v == 'E':
            e[i] += 1
        elif v == 'W':
            h[i] += 1
        elif v == 'N':
            f[i] += 1
        elif v == 'S':
            g[i] += 1

    o, n = 1, t
    a = -1
    while o <= n:
        q = (o + n) // 2
        if d(q, r, s, l, m, e, h, f, g):
            a = q
            n = q - 1
        else:
            o = q + 1

    print(a if a != -1 else -1)

if __name__ == '__main__':
    p()"
476,B,Dreamoon and WiFi,PROGRAMMING,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']","Dreamoon is standing at the position 0 on a number line. Drazil is sending a list of commands through Wi-Fi to Dreamoon's smartphone and Dreamoon follows them.

Each command is one of the following two types: 
 1.  Go 1 unit towards the positive direction, denoted as '+' 1.  Go 1 unit towards the negative direction, denoted as '-' 
But the Wi-Fi condition is so poor that Dreamoon's smartphone reports some of the commands can't be recognized and Dreamoon knows that some of them might even be wrong though successfully recognized. Dreamoon decides to follow every recognized command and toss a fair coin to decide those unrecognized ones (that means, he moves to the 1 unit to the negative or positive direction with the same probability 0.5). 

You are given an original list of commands sent by Drazil and list received by Dreamoon. What is the probability that Dreamoon ends in the position originally supposed to be final by Drazil's commands?","The first line contains a string *s*1 — the commands Drazil sends to Dreamoon, this string consists of only the characters in the set {'+', '-'}. 

The second line contains a string *s*2 — the commands Dreamoon's smartphone recognizes, this string consists of only the characters in the set {'+', '-', '?'}. '?' denotes an unrecognized command.

Lengths of two strings are equal and do not exceed 10.",Output a single real number corresponding to the probability. The answer will be considered correct if its relative or absolute error doesn't exceed 10<=-<=9.,"['++-+-\n+-+-+\n', '+-+-\n+-??\n', '+++\n??-\n']","['1.000000000000\n', '0.500000000000\n', '0.000000000000\n']","For the first sample, both *s*<sub class=""lower-index"">1</sub> and *s*<sub class=""lower-index"">2</sub> will lead Dreamoon to finish at the same position  + 1. 

For the second sample, *s*<sub class=""lower-index"">1</sub> will lead Dreamoon to finish at position 0, while there are four possibilites for *s*<sub class=""lower-index"">2</sub>: {""+-++"", ""+-+-"", ""+--+"", ""+---""} with ending position {+2, 0, 0, -2} respectively. So there are 2 correct cases out of 4, so the probability of finishing at the correct position is 0.5. 

For the third sample, *s*<sub class=""lower-index"">2</sub> could only lead us to finish at positions {+1, -1, -3}, so the probability to finish at the correct position  + 3 is 0.",OK,"import t, threading
import k
import v
from os import n
from collections import defaultdict, Counter, deque
from bisect import *
from string import ascii_lowercase
from functools import cmp_to_key
import heapq

def h(a, b):
    return (a*b)//(k.gcd(a,b))
 
 
q= lambda:str(input())
g = lambda: int(input())
l = lambda: map(int, input().split())
i = lambda: list(map(int, input().split()))
f = lambda n: chr(ord('a') + n)
b = lambda c: ord(c) - ord('a')

def d(n):
    if n==1:
        return 1
    else:
        return n*d(n-1)
   
def r():
    o=q()
    p=q()
    q=0
    e=0
    u =0
    for i in range(len(o)):
        if o[i]==""+"":
            e+=1
        else:
            e-=1
    for i in range(len(p)):
        if p[i]==""+"":
            u+=1
        elif p[i]==""-"":
            u-=1
        elif p[i]==""?"":
            q+=1

    t=abs(e-u)

    if t>q or (q-t)%2:
        print(0.000000000000)
    else:
        m = k.comb(q,t+((q-t)//2))
        c = pow(2,q)

        a = (m*1.0)/c
        print(""{:.11f}"".format(a))

def j():
    t = 1
    if n.exists(""/Users/nitishkumar/Documents/Template_Codes/Python/CP/Codeforces/input.txt""):
        t.stdin = open(""/Users/nitishkumar/Documents/Template_Codes/Python/CP/Codeforces/input.txt"", 'r')
        t.stdout = open(""/Users/nitishkumar/Documents/Template_Codes/Python/CP/Codeforces/output.txt"", 'w')
        s = v.v()
        print(""--- %s seconds ---"" % (v.v() - s))
 
 
    t.setrecursionlimit(10**5)
 
 
    r()
 
 
if __name__ == '__main__':
    j()","""""""
We are given an n*n matrix initially filled with zeroes.
We must set exactly k ones such that the matrix is symmetric
with respect to the main diagonal and is lexicographically maximal.
A symmetric matrix has matrix[i][j] == matrix[j][i] for all i, j.
For off-diagonal entries, setting a one implies setting both (i,j)
and (j,i) to 1 (cost = 2 ones), while a diagonal
entry (i,i) costs just 1.
To achieve lexicographical maximality,
we want the earliest (in row‐major order) cells to be 1 if possible,
provided we can complete the matrix while keeping the total count exactly k.

We build a list of “free decisions” corresponding to the independent cells:
•   For each diagonal (i,i): cost = 1.
•   For each off–diagonal cell (i,j) with i < j: cost = 2.
They are sorted by their row–major order position (the first appearance is used as order).

We then greedily decide in that order:
For each free decision, if setting it to 1 (i.e. “using its cost”) still allows 
the remaining free decisions to sum up to exactly the remaining target,
we choose 1 here. Otherwise, we leave it at 0.
To quickly check the feasibility with remaining free decisions,
we precompute suffix counts: how many diagonal (cost 1) and off–diagonal (cost 2) decisions remain.
This gives an upper bound on the maximum ones that can be added.

Finally, we construct the full symmetric matrix accordingly.
If it turns out that we cannot exactly allocate k ones, we output -1.
""""""

def n():
    import q
    c = q.stdin.read().split()
    if not c:
        return
    try:
        n = int(c[0])
        k = int(c[1])
    except:
        return

    if k > n * n:
        q.stdout.write(""-1"")
        return

    e = []
    for i in range(n):

        k = i * n + i
        e.append((k, i, i, 1))
        for j in range(i+1, n):
            k = i * n + j
            e.append((k, i, j, 2))
    e.sort(key=lambda x: x[0])
    L = len(e)

    o = [0]*(L+1)
    p = [0]*(L+1)
    for i in range(L-1, -1, -1):
        k, r, c, b = e[i]
        o[i] = o[i+1]
        p[i] = p[i+1]
        if b == 1:
            o[i] += 1
        else:
            p[i] += 1

    d = [0]*L
    m = k
    for i in range(L):
        k, r, c, b = e[i]

        a = False
        if m - b >= 0:
            j = o[i+1] + 2 * p[i+1]
            if m - b <= j:

                if o[i+1] == 0:
                    if (m - b) % 2 == 0:
                        a = True
                else:
                    a = True

        if a:
            d[i] = 1
            m -= b

    if m != 0:
        q.stdout.write(""-1"")
        return

    i = [[0]*n for _ in range(n)]
    for f, g in enumerate(e):
        k, i, j, b = g
        if d[f]:
            i[i][j] = 1
            if i != j:
                i[j][i] = 1

    l = []
    for i in range(n):
        h = "" "".join(str(x) for x in i[i]) + "" ""
        l.append(h)
    q.stdout.write(""\n"".join(l) + ""\n"")

if __name__ == '__main__':
    n()"
401,C,Team,PROGRAMMING,"['constructive algorithms', 'greedy', 'implementation']","Now it's time of Olympiads. Vanya and Egor decided to make his own team to take part in a programming Olympiad. They've been best friends ever since primary school and hopefully, that can somehow help them in teamwork.

For each team Olympiad, Vanya takes his play cards with numbers. He takes only the cards containing numbers 1 and 0. The boys are very superstitious. They think that they can do well at the Olympiad if they begin with laying all the cards in a row so that:
 -  there wouldn't be a pair of any side-adjacent cards with zeroes in a row; -  there wouldn't be a group of three consecutive cards containing numbers one. 
Today Vanya brought *n* cards with zeroes and *m* cards with numbers one. The number of cards was so much that the friends do not know how to put all those cards in the described way. Help them find the required arrangement of the cards or else tell the guys that it is impossible to arrange cards in such a way.",The first line contains two integers: *n* (1<=≤<=*n*<=≤<=106) — the number of cards containing number 0; *m* (1<=≤<=*m*<=≤<=106) — the number of cards containing number 1.,"In a single line print the required sequence of zeroes and ones without any spaces. If such sequence is impossible to obtain, print -1.","['1 2\n', '4 8\n', '4 10\n', '1 5\n']","['101\n', '110110110101\n', '11011011011011\n', '-1\n']",none,TIME_LIMIT_EXCEEDED,"from time import sleep as sle
from math import *
from random import randint as ri
 
def a(a,b):
	if a == b:
		return a
	elif a > b:
		return a(a-b,b)
	else:
		return a(b,a)

def b(x):
	print()
	for s in x:
		print(s)

def c():
	n,m = map(int,input().split())
	if (n-1) <= m and (m-2) <= 2*n:
		if m == (n-1):
			print('%s0'%('01'*m))
		elif m == n:
			print('01'*m)
		else:
			L = []
			while n >= 1 and m >= 1:
				L += ['1','0']
				n,m = n-1,m-1
			L += ['1']
			m -= 1
			while m >= 1:
				L[L.index('1')] = '11'
				m -= 1
			print(''.join(L))
	else:
		print(-1)

c()","import {
{.setrecursionlimit(300000)
from math import r, e

def s():
    h = {.stdin.read().split()
    if not h:
        return
    p = iter(h)
    n = int(next(p))

     = [[] for _ in range(n+1)]
    for _ in range(n-1):
        u = int(next(p)); v = int(next(p))
        [u].append(v)
        [v].append(u)

    } = [0]*(n+1)
    ~ = [0]*(n+1)
    i = [0]*(n+1)
    y = [0]*(n+1)
    | = 0
    def j(u, p):
        nonlocal |
        | += 1
        }[u] = |
        y[u] = p
        for v in [u]:
            if v == p:
                continue
            i[v] = i[u] + 1
            j(v, u)
        ~[u] = |
    j(1, 0)

    a = e(r(n)) + 1
     = [[0]*(n+1) for _ in range(a)]
    for i in range(1, n+1):
        [0][i] = y[i]
    for j in range(1, a):
        for i in range(1, n+1):
            [j][i] = [j-1][[j-1][i]] if [j-1][i] else 0

    def q(a, b):
        if i[a] < i[b]:
            a, b = b, a
        l = i[a] - i[b]
        j = 0
        while l:
            if l & 1:
                a = [j][a]
            l //= 2
            j += 1
        if a == b:
            return a
        for j in range(a-1, -1, -1):
            if [j][a] != [j][b]:
                a = [j][a]
                b = [j][b]
        return y[a]
    
    def o(u, v):
        return }[u] <= }[v] and ~[u] >= ~[v]

    t = [0]*(n+1)
    g = 1
    
    w = []
    q = int(next(p))
    for _ in range(q):
        k = int(next(p))
        if k <= 0:
            w.append(""0"")
            continue
        if k == 1:

            next(p)
            w.append(""0"")
            continue
        m = []
        for i in range(k):
            m.append(int(next(p)))

        for v in m:
            t[v] = g

        d = False
        for v in m:
            for u in [v]:
                if t[u] == g:
                    d = True
                    break
            if d:
                break
        if d:
            w.append(""-1"")
            g += 1
            continue

         = m[:]
        .sort(key=lambda x: }[x])
        m = len()
        for i in range(m-1):
            .append(q([i], [i+1]))
         = list(set())
        .sort(key=lambda x: }[x])

         = {v: [] for v in }
        z = []
        for v in :
            while z and not (}[z[-1]] <= }[v] <= ~[z[-1]]):
                z.pop()
            if z:
                [z[-1]].append(v)
            z.append(v)

        n = {v: (t[v] == g) for v in }

        c = 0
        def k(u):
            nonlocal c
            b = 1 if n[u] else 0
            for f in [u]:
                b += k(f)
            if (not n[u]) and b >= 2:
                c += 1
                return 0
            return b
        x = k([0])
        if x >= 2:
            if not n[[0]]:
                c += 1
            else:
                c = -1
        w.append(str(c))
        g += 1
    {.stdout.write(""\n"".join(w))
    
if __name__ == '__main__':
    s()"
346,B,Lucky Common Subsequence,PROGRAMMING,"['dp', 'strings']","In mathematics, a subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements. For example, the sequence BDF is a subsequence of ABCDEF. A substring of a string is a continuous subsequence of the string. For example, BCD is a substring of ABCDEF.

You are given two strings *s*1, *s*2 and another string called *virus*. Your task is to find the longest common subsequence of *s*1 and *s*2, such that it doesn't contain *virus* as a substring.","The input contains three strings in three separate lines: *s*1, *s*2 and *virus* (1<=≤<=|*s*1|,<=|*s*2|,<=|*virus*|<=≤<=100). Each string consists only of uppercase English letters.","Output the longest common subsequence of *s*1 and *s*2 without *virus* as a substring. If there are multiple answers, any of them will be accepted. 

If there is no valid common subsequence, output 0.","['AJKEQSLOBSROFGZ\nOVGURWZLWVLUXTH\nOZ\n', 'AA\nA\nA\n']","['ORZ\n', '0\n']",none,RUNTIME_ERROR,"def b(n,a,b):
    for i in range(len(a)):
        if(a[i] in b):
            return a[i]
    return -1
t=int(input())
for i in range(t):
    n, m = map(int, input().split())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))
    a = b(n, a, b)
    if(a==-1):
        print(""NO"")
    else:
        print(""YES"")
        print(1, a)","def d():
    import f

    a = f.stdin.read().strip().split()
    if not a:
        return

    n = int(a[0])

    c = list(map(int, a[1:]))

    m = (n + 1) // 2
    for i in range(m, 0, -1):

        b = i - 1
        e = n - i

        c[b:e+1] = c[b:e+1][::-1]

    f.stdout.write("" "".join(map(str, c)))

if __name__ == '__main__':
    d()"
664,A,Complicated GCD,PROGRAMMING,"['math', 'number theory']","Greatest common divisor *GCD*(*a*,<=*b*) of two positive integers *a* and *b* is equal to the biggest integer *d* such that both integers *a* and *b* are divisible by *d*. There are many efficient algorithms to find greatest common divisor *GCD*(*a*,<=*b*), for example, Euclid algorithm. 

Formally, find the biggest integer *d*, such that all integers *a*,<=*a*<=+<=1,<=*a*<=+<=2,<=...,<=*b* are divisible by *d*. To make the problem even more complicated we allow *a* and *b* to be up to googol, 10100 — such number do not fit even in 64-bit integer type!",The only line of the input contains two integers *a* and *b* (1<=≤<=*a*<=≤<=*b*<=≤<=10100).,Output one integer — greatest common divisor of all integers from *a* to *b* inclusive.,"['1 2\n', '61803398874989484820458683436563811772030917980576 61803398874989484820458683436563811772030917980576\n']","['1\n', '61803398874989484820458683436563811772030917980576\n']",none,TIME_LIMIT_EXCEEDED,"def c(a,b):
    a = 1
    for j in range(a,b+1):
        for i in range(2,j//2+1):
            if j%i == 0:
                a = 0
                break
        if a == 1: 
            return True

def b(a, b):  
    if a == 0 : 
        return b  
      
    return b(b%a, a) 
a,b = map(int,input().split())

if c(a,b):
    print(1)
else:
    print(b(a,b))","def a():

    n = int(input().strip())

    b = pow(5, n, 100)

    print(f""{b:02d}"")

if __name__ == ""__main__"":
    a()"
281,A,Word Capitalization,PROGRAMMING,"['implementation', 'strings']","Capitalization is writing a word with its first letter as a capital letter. Your task is to capitalize the given word.

Note, that during capitalization all the letters except the first one remains unchanged.",A single line contains a non-empty word. This word consists of lowercase and uppercase English letters. The length of the word will not exceed 103.,Output the given word after capitalization.,"['ApPLe\n', 'konjac\n']","['ApPLe\n', 'Konjac\n']",none,OK,"s=str(input())
b='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
a='abcdefghijklmnopqrstuvwxyz'
e=''
if s[0] in b:
    print(s)
else:
    c=a.c(s[0])
    d=b[c]
    e = d
    for i in range (1,len(s)):
        e+=s[i]
    print(e)","def b(n):

    a = 0
    c = 5
    while n // c:
        a += n // c
        c *= 5
    return a

def d(m):

    h, f = 0, 5 * (m + 1)
    while h < f:
        j = (h + f) // 2
        if b(j) < m:
            h = j + 1
        else:
            f = j

    if b(h) == m:
        return h
    else:
        return None

def i():
    import l
    g = l.stdin.read().strip().split()
    if not g:
        return
    m = int(g[0])

    e = d(m)
    
    if e is None:

        l.stdout.write(""0"")
    else:

        k = []
        n = e
        while b(n) == m:
            k.append(n)
            n += 1

        l.stdout.write(str(len(k)) + ""\n"")

        l.stdout.write("" "".join(map(str, k)) + "" "")
        
if __name__ == '__main__':
    i()"
75,C,Modified GCD,PROGRAMMING,"['binary search', 'number theory']","Well, here is another math class task. In mathematics, GCD is the greatest common divisor, and it's an easy task to calculate the GCD between two positive integers.

A common divisor for two positive numbers is a number which both numbers are divisible by.

But your teacher wants to give you a harder task, in this task you have to find the greatest common divisor *d* between two integers *a* and *b* that is in a given range from *low* to *high* (inclusive), i.e. *low*<=≤<=*d*<=≤<=*high*. It is possible that there is no common divisor in the given range.

You will be given the two integers *a* and *b*, then *n* queries. Each query is a range from *low* to *high* and you have to answer each query.","The first line contains two integers *a* and *b*, the two integers as described above (1<=≤<=*a*,<=*b*<=≤<=109). The second line contains one integer *n*, the number of queries (1<=≤<=*n*<=≤<=104). Then *n* lines follow, each line contains one query consisting of two integers, *low* and *high* (1<=≤<=*low*<=≤<=*high*<=≤<=109).","Print *n* lines. The *i*-th of them should contain the result of the *i*-th query in the input. If there is no common divisor in the given range for any query, you should print -1 as a result for this query.",['9 27\n3\n1 5\n10 11\n9 11\n'],['3\n-1\n9\n'],none,WRONG_ANSWER,"""""""
Input
The first line contains two integers a and b, the two integers as described above (1 ≤ a, b ≤ 109). The second line contains one integer n, the number of queries (1 ≤ n ≤ 104). Then n lines follow, each line contains one query consisting of two integers, low and high (1 ≤ low ≤ high ≤ 109).

Output
Print n lines. The i-th of them should contain the result of the i-th query in the input. If there is no common divisor in the given range for any query, you should print -1 as a result for this query.

""""""
from math import d

a, b = map(int, input().split())
g = d(a, b)

def b(v):
    c = []

    for i in range(3, v):
        if v % i == 0:
            c.append(i)
    return c

c = b(g)
n = int(input())
for _ in range(n):
    f, e = map(int, input().split())

    a = []
    for f in c:
        if e - f < f - 1:
            continue
        else:
            a.append(e // f * f)
    print(max(a) if a else -1)","import w

def h():

    c = w.stdin.read().splitlines()
    if not c:
        return

    n = int(c[0])

    a = list(map(int, c[1].split()))

    m = int(c[2])
    
    v = n

    u = [0] * (4 * v)
    e = [0] * (4 * v)
    
    def b(d, l, r):
        """"""Recursively build the segment tree for the segment [l, r].""""""
        if l == r:
            u[d] = a[l]
        else:
            i = (l + r) // 2
            b(2 * d + 1, l, i)
            b(2 * d + 2, i + 1, r)
            u[d] = min(u[2 * d + 1], u[2 * d + 2])
    
    def l(d, l, r):
        """"""Propagate lazy update at node idx to its children.""""""
        if e[d] != 0:
            u[d] += e[d]
            if l != r:
                e[2 * d + 1] += e[d]
                e[2 * d + 2] += e[d]
            e[d] = 0

    def x(d, l, r, m, n, y):
        """"""Update the segment tree over the query range [ql, qr] by adding 'value'.""""""
        l(d, l, r)
        if m > r or n < l:
            return
        if m <= l and r <= n:
            e[d] += y
            l(d, l, r)
            return
        i = (l + r) // 2
        x(2 * d + 1, l, i, m, n, y)
        x(2 * d + 2, i + 1, r, m, n, y)
        u[d] = min(u[2 * d + 1], u[2 * d + 2])
    
    def o(d, l, r, m, n):
        """"""Return the minimum value in the range [ql, qr].""""""
        if m > r or n < l:
            return float('inf')
        l(d, l, r)
        if m <= l and r <= n:
            return u[d]
        i = (l + r) // 2
        f = o(2 * d + 1, l, i, m, n)
        t = o(2 * d + 2, i + 1, r, m, n)
        return min(f, t)

    b(0, 0, v - 1)
    
    j = []

    for i in range(3, 3 + m):
        k = list(map(int, c[i].split()))

        if len(k) == 2:
            g, s = k[0], k[1]

            if g <= s:
                p = o(0, 0, v - 1, g, s)
            else:
                q = o(0, 0, v - 1, g, v - 1)
                r = o(0, 0, v - 1, 0, s)
                p = min(q, r)
            j.append(str(p))

        elif len(k) == 3:
            g, s, v = k[0], k[1], k[2]
            if g <= s:
                x(0, 0, v - 1, g, s, v)
            else:
                x(0, 0, v - 1, g, v - 1, v)
                x(0, 0, v - 1, 0, s, v)

    w.stdout.write(""\n"".join(j))

if __name__ == '__main__':
    h()"
25,A,IQ test,PROGRAMMING,['brute force'],"Bob is preparing to pass IQ test. The most frequent task in this test is to find out which one of the given *n* numbers differs from the others. Bob observed that one number usually differs from the others in evenness. Help Bob — to check his answers, he needs a program that among the given *n* numbers finds one that is different in evenness.","The first line contains integer *n* (3<=≤<=*n*<=≤<=100) — amount of numbers in the task. The second line contains *n* space-separated natural numbers, not exceeding 100. It is guaranteed, that exactly one of these numbers differs from the others in evenness.",Output index of number that differs from the others in evenness. Numbers are numbered from 1 in the input order.,"['5\n2 4 7 8 10\n', '4\n1 2 1 1\n']","['3\n', '2\n']",none,OK,"def c(n, e):
    a = 0
    f = 0
    b = -1
    g = -1
    
    for i, d in enumerate(e):
        if d % 2 == 0:
            a += 1
            b = i
        else:
            f += 1
            g = i
        
        if a > 1 and f == 1:
            return g + 1
        elif f > 1 and a == 1:
            return b + 1

n = int(input())
e = list(map(int, input().split()))

h = c(n, e)

print(h)","import j

def g():

    d = j.stdin.read().splitlines()
    if not d:
        return
    s = d[0].strip()
    h = d[1].strip()
    k = int(d[2].strip())
    
    n = len(s)

    f = [False] * 26
    for i, c in enumerate(h):
        f[i] = (c == '1')

    i = set()
    
    b = 131

    for i in range(n):
        a = 0
        h = 0

        for j in range(i, n):

            e = ord(s[j]) - ord('a')

            if not f[e]:
                a += 1

            if a > k:
                break

            h = h * b + (e + 1)

            i.add(h)

    print(len(i))

if __name__ == '__main__':
    g()"
789,B,Masha and geometric depression,PROGRAMMING,"['brute force', 'implementation', 'math']","Masha really loves algebra. On the last lesson, her strict teacher Dvastan gave she new exercise.

You are given geometric progression *b* defined by two integers *b*1 and *q*. Remind that a geometric progression is a sequence of integers *b*1,<=*b*2,<=*b*3,<=..., where for each *i*<=&gt;<=1 the respective term satisfies the condition *b**i*<==<=*b**i*<=-<=1·*q*, where *q* is called the common ratio of the progression. Progressions in Uzhlyandia are unusual: both *b*1 and *q* can equal 0. Also, Dvastan gave Masha *m* ""bad"" integers *a*1,<=*a*2,<=...,<=*a**m*, and an integer *l*.

Masha writes all progression terms one by one onto the board (including repetitive) while condition |*b**i*|<=≤<=*l* is satisfied (|*x*| means absolute value of *x*). There is an exception: if a term equals one of the ""bad"" integers, Masha skips it (doesn't write onto the board) and moves forward to the next term.

But the lesson is going to end soon, so Masha has to calculate how many integers will be written on the board. In order not to get into depression, Masha asked you for help: help her calculate how many numbers she will write, or print ""inf"" in case she needs to write infinitely many integers.","The first line of input contains four integers *b*1, *q*, *l*, *m* (-109<=≤<=*b*1,<=*q*<=≤<=109, 1<=≤<=*l*<=≤<=109, 1<=≤<=*m*<=≤<=105) — the initial term and the common ratio of progression, absolute value of maximal number that can be written on the board and the number of ""bad"" integers, respectively.

The second line contains *m* distinct integers *a*1,<=*a*2,<=...,<=*a**m* (-109<=≤<=*a**i*<=≤<=109) — numbers that will never be written on the board.","Print the only integer, meaning the number of progression terms that will be written on the board if it is finite, or ""inf"" (without quotes) otherwise.","['3 2 30 4\n6 14 25 48\n', '123 1 2143435 4\n123 11 -5453 141245\n', '123 1 2143435 4\n54343 -13 6 124\n']","['3', '0', 'inf']","In the first sample case, Masha will write integers 3, 12, 24. Progression term 6 will be skipped because it is a ""bad"" integer. Terms bigger than 24 won't be written because they exceed *l* by absolute value.

In the second case, Masha won't write any number because all terms are equal 123 and this is a ""bad"" integer.

In the third case, Masha will write infinitely integers 123.",OK,"def b():
    a, q, l, m = map(int, input().split())
    a = set(map(int, input().split()))

    if a == 0:
        if 0 in a:
            return 0
        else:
            return 'inf'

    if q == 0:
        if abs(a) > l:
            return 0

        if a in a:
            if 0 in a:
                return 0
            else:
                return 'inf'
        else:
            if 0 in a:
                return 1
            else:
                return 'inf'

    if q == 1:
        if abs(a) > l or a in a:
            return 0
        else:
            return 'inf'

    if q == -1:
        if abs(a) > l or a in a and -a in a:
            return 0
        else:
            return 'inf'

    c = 0
    b = a
    while True:
        if abs(b) > l:
            break

        if b not in a:
            c += 1

        b *= q

    return c

if __name__ == '__main__':

    print(b())","def a():

    n = int(input().strip())
    
    c = """"
    b = 1

    while len(c) < n:
        c += str(b)
        b += 1

    print(c[n-1])

if __name__ == ""__main__"":
    a()"
41,A,Translation,PROGRAMMING,"['implementation', 'strings']","The translation from the Berland language into the Birland language is not an easy task. Those languages are very similar: a berlandish word differs from a birlandish word with the same meaning a little: it is spelled (and pronounced) reversely. For example, a Berlandish word code corresponds to a Birlandish word edoc. However, it's easy to make a mistake during the «translation». Vasya translated word *s* from Berlandish into Birlandish as *t*. Help him: find out if he translated the word correctly.","The first line contains word *s*, the second line contains word *t*. The words consist of lowercase Latin letters. The input data do not consist unnecessary spaces. The words are not empty and their lengths do not exceed 100 symbols.","If the word *t* is a word *s*, written reversely, print YES, otherwise print NO.","['code\nedoc\n', 'abb\naba\n', 'code\ncode\n']","['YES\n', 'NO\n', 'NO\n']",none,OK,"import d

def input():    return d.stdin.readline().strip()
def b():   return int(input())
def c():   return map(int, d.stdin.readline().strip().split()) 
def a(): return list(map(int, d.stdin.readline().strip().split())) 

n=input()
m=input()
l=list(n)
s=[]
for i in range(len(n)-1,-1,-1):
    s.append(n[i])
k="""".join(s)
if(m==k):
    print(""YES"")
else:
    print(""NO"")","def d():
    import e

    b = e.stdin.read().split()
    if not b:
        return
    n = int(b[0])

    c = 0
    f = 0

    i = 1
    while True:

        a = i * (i + 1) // 2
        f += a

        if f > n:
            break
        c = i
        i += 1

    print(c)

if __name__ == ""__main__"":
    d()"
992,D,Nastya and a Game,PROGRAMMING,"['brute force', 'implementation', 'math']","Nastya received one more array on her birthday, this array can be used to play a traditional Byteland game on it. However, to play the game the players should first select such a subsegment of the array that , where *p* is the product of all integers on the given array, *s* is their sum, and *k* is a given constant for all subsegments. 

Nastya wonders how many subsegments of the array fit the described conditions. A subsegment of an array is several consecutive integers of the array.","The first line contains two integers *n* and *k* (1<=≤<=*n*<=≤<=2·105, 1<=≤<=*k*<=≤<=105), where *n* is the length of the array and *k* is the constant described above.

The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=108) — the elements of the array.",In the only line print the number of subsegments such that the ratio between the product and the sum on them is equal to *k*.,"['1 1\n1\n', '4 2\n6 3 8 1\n']","['1\n', '2\n']","In the first example the only subsegment is [1]. The sum equals 1, the product equals 1, so it suits us because <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/627b2899a459d42fe3b2ca04fc812d4132b5f2ca.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>.

There are two suitable subsegments in the second example — [6, 3] and [3, 8, 1]. Subsegment [6, 3] has sum 9 and product 18, so it suits us because <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/107ecd38fde9817d6565e2059ccd064562470543.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>. Subsegment [3, 8, 1] has sum 12 and product 24, so it suits us because <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/8abc1793efa3061313ddd52d670a94b430133564.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>.",RUNTIME_ERROR,"def d(A, k):
    n = len(A)
    S = [0]
    P = [1]
    c = 0
    b = 0
    a = 0
    for i in range(n):
        S.append(S[-1]+A[i])

        while P[-1]*A[i] > k*S[-1]:
            b = c
            P[-1] = P[-1]//P[c]
            P[c] = 1
            c+=1
            
        P.append(P[-1]*A[i])
        if P[-1] % k==0:
            for j in range(b, len(P)):
                if (P[-1]//P[j]) % k==0:
                    e = P[-1]//(k*P[j])
                    if S[-1]-S[j]==e:
                        a+=1
    return a

n, k = [int(x) for x in input().split()]
A = [int(x) for x in input().split()]
print(d(A))","def d():

    import f
    c = f.stdin.read().split()

    if not c:
        return
    n = int(c[0])
    m = int(c[1])

    e = list(map(int, c[2:]))

    e.sort()

    a = float('inf')

    for i in range(m - n + 1):
        b = e[i + n - 1] - e[i]
        if b < a:
            a = b

    print(a)

if __name__ == ""__main__"":
    d()"
272,A,Dima and Friends,PROGRAMMING,"['implementation', 'math']","Dima and his friends have been playing hide and seek at Dima's place all night. As a result, Dima's place got messy. In the morning they decided that they need to clean the place.

To decide who exactly would clean the apartment, the friends want to play a counting-out game. First, all the guys stand in a circle, and then each of them shows some number of fingers on one hand (one to five), and then the boys count in a circle, starting from Dima, the number of people, respective to the total number of fingers shown. The person on who the countdown stops will clean the apartment.

For example, if Dima and one of his friends played hide and seek, and 7 fingers were shown during the counting-out, then Dima would clean the place. If there were 2 or say, 8 fingers shown, then his friend would clean the place.

Dima knows how many fingers each of his friends will show during the counting-out. Now he is interested in the number of ways to show some number of fingers on one hand (one to five), so that he did not have to clean the place. Help Dima.","The first line contains integer *n* (1<=≤<=*n*<=≤<=100) — the number of Dima's friends. Dima himself isn't considered to be his own friend. The second line contains *n* positive integers, not exceeding 5, representing, how many fingers the Dima's friends will show. 

The numbers in the lines are separated by a single space.",In a single line print the answer to the problem.,"['1\n1\n', '1\n2\n', '2\n3 5\n']","['3\n', '2\n', '3\n']","In the first sample Dima can show 1, 3 or 5 fingers. If Dima shows 3 fingers, then the counting-out will go like that: Dima, his friend, Dima, his friend.

In the second sample Dima can show 2 or 4 fingers.",WRONG_ANSWER,"def b():
    return [int(x) for x in input().split()]

import math as m
n, a = int(input()), b()
sum = 0
for i in range(n):
    if(a[i]%2==0):
        sum+=4//a[i]
    else:
        sum+=m.ceil(6/(a[i]+1))
print(sum)","def c():

    s = input().strip()

    d = ""hello""
    b = 0

    for a in s:

        if b < len(d) and a == d[b]:
            b += 1

        if b == len(d):
            break

    if b == len(d):
        print(""YES"")
    else:
        print(""NO"")
    
if __name__ == ""__main__"":
    c()"
801,B,Valued Keys,PROGRAMMING,"['constructive algorithms', 'greedy', 'strings']","You found a mysterious function *f*. The function takes two strings *s*1 and *s*2. These strings must consist only of lowercase English letters, and must be the same length.

The output of the function *f* is another string of the same length. The *i*-th character of the output is equal to the minimum of the *i*-th character of *s*1 and the *i*-th character of *s*2.

For example, *f*(""ab"", ""ba"") = ""aa"", and *f*(""nzwzl"", ""zizez"") = ""niwel"".

You found two strings *x* and *y* of the same length and consisting of only lowercase English letters. Find any string *z* such that *f*(*x*,<=*z*)<==<=*y*, or print -1 if no such string *z* exists.","The first line of input contains the string *x*.

The second line of input contains the string *y*.

Both *x* and *y* consist only of lowercase English letters, *x* and *y* have same length and this length is between 1 and 100.","If there is no string *z* such that *f*(*x*,<=*z*)<==<=*y*, print -1.

Otherwise, print a string *z* such that *f*(*x*,<=*z*)<==<=*y*. If there are multiple possible answers, print any of them. The string *z* should be the same length as *x* and *y* and consist only of lowercase English letters.","['ab\naa\n', 'nzwzl\nniwel\n', 'ab\nba\n']","['ba\n', 'xiyez\n', '-1\n']","The first case is from the statement.

Another solution for the second case is ""zizez""

There is no solution for the third case. That is, there is no *z* such that *f*(""ab"", *z*) =  ""ba"".",OK,"def a(x, y):
    return -1 if any(x[i] < y[i] for i in range(len(x))) else y

def f(x, y):
    return ''.join([min(x[i], y[i]) for i in range(len(x))])

if __name__ == '__main__':
    print(a(input(), input()))","import d

def b():

    a = d.stdin.read().split()
    if not a:
        return
    
    k = int(a[0])
    d = int(a[1])

    if k == 1:
        print(d)
        return

    if d == 0:
        print(""No solution"")
        return

    c = str(d) + ""0"" * (k - 1)
    print(c)

if __name__ == ""__main__"":
    b()"
250,A,Paper Work,PROGRAMMING,['greedy'],"Polycarpus has been working in the analytic department of the ""F.R.A.U.D."" company for as much as *n* days. Right now his task is to make a series of reports about the company's performance for the last *n* days. We know that the main information in a day report is value *a**i*, the company's profit on the *i*-th day. If *a**i* is negative, then the company suffered losses on the *i*-th day.

Polycarpus should sort the daily reports into folders. Each folder should include data on the company's performance for several consecutive days. Of course, the information on each of the *n* days should be exactly in one folder. Thus, Polycarpus puts information on the first few days in the first folder. The information on the several following days goes to the second folder, and so on.

It is known that the boss reads one daily report folder per day. If one folder has three or more reports for the days in which the company suffered losses (*a**i*<=&lt;<=0), he loses his temper and his wrath is terrible.

Therefore, Polycarpus wants to prepare the folders so that none of them contains information on three or more days with the loss, and the number of folders is minimal.

Write a program that, given sequence *a**i*, will print the minimum number of folders.","The first line contains integer *n* (1<=≤<=*n*<=≤<=100), *n* is the number of days. The second line contains a sequence of integers *a*1,<=*a*2,<=...,<=*a**n* (|*a**i*|<=≤<=100), where *a**i* means the company profit on the *i*-th day. It is possible that the company has no days with the negative *a**i*.","Print an integer *k* — the required minimum number of folders. In the second line print a sequence of integers *b*1, *b*2, ..., *b**k*, where *b**j* is the number of day reports in the *j*-th folder.

If there are multiple ways to sort the reports into *k* days, print any of them.","['11\n1 2 3 -4 -5 -6 5 -5 -6 -7 6\n', '5\n0 -1 100 -1 0\n']","['3\n5 3 3 ', '1\n5 ']","Here goes a way to sort the reports from the first sample into three folders: 

In the second sample you can put all five reports in one folder.",WRONG_ANSWER,"import l

input = l.stdin.readline

def f():
    return (int(input()))

def g():
    return (list(map(int, input().split())))

def h():
    s = input()
    return (list(s[:len(s) - 1]))

def i():
    return (map(int, input().split()))

def d(a):
    e = []
    m = 2
    b = 0
    for i in range(len(a)):
        if a[i]<0:
            if m == 0:
                e.append(str(b))
                m = 2
                b = 0
            m -= 1
        b +=1
        if i == len(a)-1:
            e.append(str(b))
            return e

    return e

if __name__ == '__main__':
    c = f()
    j = g()
    print(j)
    k = d(j)
    print(len(k))
    print(' '.join(k))","import f

def e():

    d = f.stdin.read().split()

    n = int(d[0])
    m = int(d[1])

    a = list(map(int, d[2:2+n]))

    c = [0] * (m + 1)

    for b in a:
        c[b] += 1

    g = 0
    for i in range(1, m):
        for j in range(i+1, m+1):
            g += c[i] * c[j]

    print(g)
    
if __name__ == ""__main__"":
    e()"
765,A,Neverending competitions,PROGRAMMING,"['implementation', 'math']","There are literally dozens of snooker competitions held each year, and team Jinotega tries to attend them all (for some reason they prefer name ""snookah"")! When a competition takes place somewhere far from their hometown, Ivan, Artsem and Konstantin take a flight to the contest and back.

Jinotega's best friends, team Base have found a list of their itinerary receipts with information about departure and arrival airports. Now they wonder, where is Jinotega now: at home or at some competition far away? They know that: 
 -  this list contains all Jinotega's flights in this year (in arbitrary order), -  Jinotega has only flown from his hometown to a snooker contest and back, -  after each competition Jinotega flies back home (though they may attend a competition in one place several times), -  and finally, at the beginning of the year Jinotega was at home. 
Please help them to determine Jinotega's location!","In the first line of input there is a single integer *n*: the number of Jinotega's flights (1<=≤<=*n*<=≤<=100). In the second line there is a string of 3 capital Latin letters: the name of Jinotega's home airport. In the next *n* lines there is flight information, one flight per line, in form ""XXX-&gt;YYY"", where ""XXX"" is the name of departure airport ""YYY"" is the name of arrival airport. Exactly one of these airports is Jinotega's home airport.

It is guaranteed that flights information is consistent with the knowledge of Jinotega's friends, which is described in the main part of the statement.","If Jinotega is now at home, print ""home"" (without quotes), otherwise print ""contest"".","['4\nSVO\nSVO-&gt;CDG\nLHR-&gt;SVO\nSVO-&gt;LHR\nCDG-&gt;SVO\n', '3\nSVO\nSVO-&gt;HKT\nHKT-&gt;SVO\nSVO-&gt;RAP\n']","['home\n', 'contest\n']","In the first sample Jinotega might first fly from SVO to CDG and back, and then from SVO to LHR and back, so now they should be at home. In the second sample Jinotega must now be at RAP because a flight from RAP back to SVO is not on the list.",WRONG_ANSWER,"from collections import a
def b(h,d):
    if(len(d[h])==len(d)-1):
        return ""home""
    return ""contest""
n = int(input())
h = input()
d = a(list)
for i in range(n):
    l = input().split(""->"")
    d[l[0]].append(l[-1])
print(b(h,d))","import e

def c():

    n, d = map(int, e.stdin.readline().split())
    
    d = 0
    a = 0

    for _ in range(d):

        b = e.stdin.readline().strip()

        if '0' in b:
            a += 1
            d = max(d, a)
        else:

            a = 0

    print(d)

if __name__ == '__main__':
    c()"
518,B,Tanya and Postcard,PROGRAMMING,"['greedy', 'implementation', 'strings']","Little Tanya decided to present her dad a postcard on his Birthday. She has already created a message — string *s* of length *n*, consisting of uppercase and lowercase English letters. Tanya can't write yet, so she found a newspaper and decided to cut out the letters and glue them into the postcard to achieve string *s*. The newspaper contains string *t*, consisting of uppercase and lowercase English letters. We know that the length of string *t* greater or equal to the length of the string *s*.

The newspaper may possibly have too few of some letters needed to make the text and too many of some other letters. That's why Tanya wants to cut some *n* letters out of the newspaper and make a message of length exactly *n*, so that it looked as much as possible like *s*. If the letter in some position has correct value and correct letter case (in the string *s* and in the string that Tanya will make), then she shouts joyfully ""YAY!"", and if the letter in the given position has only the correct value but it is in the wrong case, then the girl says ""WHOOPS"".

Tanya wants to make such message that lets her shout ""YAY!"" as much as possible. If there are multiple ways to do this, then her second priority is to maximize the number of times she says ""WHOOPS"". Your task is to help Tanya make the message.","The first line contains line *s* (1<=≤<=|*s*|<=≤<=2·105), consisting of uppercase and lowercase English letters — the text of Tanya's message.

The second line contains line *t* (|*s*|<=≤<=|*t*|<=≤<=2·105), consisting of uppercase and lowercase English letters — the text written in the newspaper.

Here |*a*| means the length of the string *a*.","Print two integers separated by a space:
 -  the first number is the number of times Tanya shouts ""YAY!"" while making the message, -  the second number is the number of times Tanya says ""WHOOPS"" while making the message.","['AbC\nDCbA\n', 'ABC\nabc\n', 'abacaba\nAbaCaBA\n']","['3 0\n', '0 3\n', '3 4\n']",none,WRONG_ANSWER,"from collections import c

s = input()
t = input()
a = c(int)
for c in s:
    a[c] += 1
b = c(int)
for c in t:
    b[c] += 1
d = 0
for c in set(s):
    d += min(a[c], b[c])
print('%d %d' % (d, len(s) - d))","from itertools import a

def b():

    d = list(map(int, input().split()))

    e = False
    c = False

    for f in a(d, 3):

        a, b, c = sorted(f)

        if a + b > c:
            e = True

        elif a + b == c:
            c = True

    if e:
        print(""TRIANGLE"")
    elif c:
        print(""SEGMENT"")
    else:
        print(""IMPOSSIBLE"")

if __name__ == ""__main__"":
    b()"
914,D,Bash and a Tough Math Puzzle,PROGRAMMING,"['data structures', 'number theory']","Bash likes playing with arrays. He has an array *a*1,<=*a*2,<=... *a**n* of *n* integers. He likes to guess the greatest common divisor (gcd) of different segments of the array. Of course, sometimes the guess is not correct. However, Bash will be satisfied if his guess is almost correct.

Suppose he guesses that the gcd of the elements in the range [*l*,<=*r*] of *a* is *x*. He considers the guess to be almost correct if he can change at most one element in the segment such that the gcd of the segment is *x* after making the change. Note that when he guesses, he doesn't actually change the array — he just wonders if the gcd of the segment can be made *x*. Apart from this, he also sometimes makes changes to the array itself.

Since he can't figure it out himself, Bash wants you to tell him which of his guesses are almost correct. Formally, you have to process *q* queries of one of the following forms:
 -  1<=*l*<=*r*<=*x* — Bash guesses that the gcd of the range [*l*,<=*r*] is *x*. Report if this guess is almost correct. -  2<=*i*<=*y* — Bash sets *a**i* to *y*. 
Note: The array is 1-indexed.","The first line contains an integer *n* (1<=≤<=*n*<=≤<=5·105)  — the size of the array.

The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=109)  — the elements of the array.

The third line contains an integer *q* (1<=≤<=*q*<=≤<=4·105)  — the number of queries.

The next *q* lines describe the queries and may have one of the following forms:
 -  1<=*l*<=*r*<=*x* (1<=≤<=*l*<=≤<=*r*<=≤<=*n*,<=1<=≤<=*x*<=≤<=109). -  2<=*i*<=*y* (1<=≤<=*i*<=≤<=*n*,<=1<=≤<=*y*<=≤<=109). 
Guaranteed, that there is at least one query of first type.","For each query of first type, output ""YES"" (without quotes) if Bash's guess is almost correct and ""NO"" (without quotes) otherwise.","['3\n2 6 3\n4\n1 1 2 2\n1 1 3 3\n2 1 9\n1 1 3 2\n', '5\n1 2 3 4 5\n6\n1 1 4 2\n2 3 6\n1 1 4 2\n1 1 5 2\n2 5 10\n1 1 5 2\n']","['YES\nYES\nNO\n', 'NO\nYES\nNO\nYES\n']","In the first sample, the array initially is {2, 6, 3}. 

For query 1, the first two numbers already have their gcd as 2.

For query 2, we can achieve a gcd of 3 by changing the first element of the array to 3. Note that the changes made during queries of type 1 are temporary and do not get reflected in the array. 

After query 3, the array is now {9, 6, 3}.

 For query 4, no matter which element you change, you cannot get the gcd of the range to be 2.",WRONG_ANSWER,"import f
input = f.stdin.buffer.readline

def b(a, b):
    while b:
        a,b = b,a%b
    return a

n = int(input())

A = [int(x) for x in input().split()]
B = [0] * n + A
for i in range(n, 2 * n):
    B[i // 2] = b(B[i], B[i // 2])

q = int(input())
for _ in range(q):
    S = [int(x) for x in input().split()]
    if S[0] == 1:
        _,l,r,x = S
        l -= 1
        
        a = 0
        c = 3 * n
        
        l += n
        r += n
        while l < r:
            if l & 1 and B[l] % x:
                c = l
                a += 1
            if r & 1 and B[r - 1] % x:
                c = r - 1
                a += 1
            l += 1
            l //= 2
            r //= 2

        while c < n:
            d = 2 * c
            e = 2 * c + 1

            if B[d] % x:
                a += B[e] % x
                c = d
            else:
                a += B[d] % x
                c = e
        if a <= 1:
            print('YES')
        else:
            print('NO')

    else:
        _,i,y = S
        i -= 1

        i += n
        B[i] = y
        i //= 2
        while i:
            B[i] = b(B[2 * i], B[2 * i + 1])
            i //= 2","import g

def c():

    e = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]
    a = 0
    b = -1

    for d in e:
        print(d)
        g.stdout.flush()
        f = input().strip()
        if f == ""yes"":
            a += 1
            b = d

        if a >= 2:
            print(""composite"")
            g.stdout.flush()
            return

    if a == 1:
        if b * b <= 100:
            print(b * b)
            g.stdout.flush()
            f = input().strip()
            if f == ""yes"":
                print(""composite"")
                g.stdout.flush()
                return

    print(""prime"")
    g.stdout.flush()

if __name__ == ""__main__"":
    c()"
509,A,Maximum in Table,PROGRAMMING,"['brute force', 'implementation']","An *n*<=×<=*n* table *a* is defined as follows:
 -  The first row and the first column contain ones, that is: *a**i*,<=1<==<=*a*1,<=*i*<==<=1 for all *i*<==<=1,<=2,<=...,<=*n*. -  Each of the remaining numbers in the table is equal to the sum of the number above it and the number to the left of it. In other words, the remaining elements are defined by the formula *a**i*,<=*j*<==<=*a**i*<=-<=1,<=*j*<=+<=*a**i*,<=*j*<=-<=1. 
These conditions define all the values in the table.

You are given a number *n*. You need to determine the maximum value in the *n*<=×<=*n* table defined by the rules above.",The only line of input contains a positive integer *n* (1<=≤<=*n*<=≤<=10) — the number of rows and columns of the table.,Print a single line containing a positive integer *m* — the maximum value in the table.,"['1\n', '5\n']","['1', '70']",In the second test the rows of the table look as follows:,OK,"def a(n):
    if n == 0:
        return 1
    else:
        return n * a(n-1)
n=int(input())
a=2*(n-1)
b=a//2
if n==1:
    print(1)
else:
    print(a(a)//(a(b)*a(a-b)))","def d():
    import h
    c = h.stdin.read().strip().splitlines()
    if not c:
        return

    n, m = map(int, c[0].split())

    j = [0] * n

    for i in range(1, m + 1):

        i = list(map(int, c[i].split()))

        f = i[0]
        a = 0
        for b in range(1, n):

            if i[b] > f:
                f = i[b]
                a = b

        j[a] += 1

    g = 0
    e = j[0]
    for b in range(1, n):
        if j[b] > e:
            e = j[b]
            g = b

    print(g + 1)

if __name__ == ""__main__"":
    d()"
350,B,Resort,PROGRAMMING,['graphs'],"Valera's finally decided to go on holiday! He packed up and headed for a ski resort.

Valera's fancied a ski trip but he soon realized that he could get lost in this new place. Somebody gave him a useful hint: the resort has *n* objects (we will consider the objects indexed in some way by integers from 1 to *n*), each object is either a hotel or a mountain.

Valera has also found out that the ski resort had multiple ski tracks. Specifically, for each object *v*, the resort has at most one object *u*, such that there is a ski track built from object *u* to object *v*. We also know that no hotel has got a ski track leading from the hotel to some object.

Valera is afraid of getting lost on the resort. So he wants you to come up with a path he would walk along. The path must consist of objects *v*1,<=*v*2,<=...,<=*v**k* (*k*<=≥<=1) and meet the following conditions:
 1.  Objects with numbers *v*1,<=*v*2,<=...,<=*v**k*<=-<=1 are mountains and the object with number *v**k* is the hotel. 1.  For any integer *i* (1<=≤<=*i*<=&lt;<=*k*), there is exactly one ski track leading from object *v**i*. This track goes to object *v**i*<=+<=1. 1.  The path contains as many objects as possible (*k* is maximal). 
Help Valera. Find such path that meets all the criteria of our hero!","The first line contains integer *n* (1<=≤<=*n*<=≤<=105) — the number of objects.

The second line contains *n* space-separated integers *type*1,<=*type*2,<=...,<=*type**n* — the types of the objects. If *type**i* equals zero, then the *i*-th object is the mountain. If *type**i* equals one, then the *i*-th object is the hotel. It is guaranteed that at least one object is a hotel.

The third line of the input contains *n* space-separated integers *a*1,<=*a*2,<=...,<=*a**n* (0<=≤<=*a**i*<=≤<=*n*) — the description of the ski tracks. If number *a**i* equals zero, then there is no such object *v*, that has a ski track built from *v* to *i*. If number *a**i* doesn't equal zero, that means that there is a track built from object *a**i* to object *i*.","In the first line print *k* — the maximum possible path length for Valera. In the second line print *k* integers *v*1,<=*v*2,<=...,<=*v**k* — the path. If there are multiple solutions, you can print any of them.","['5\n0 0 0 0 1\n0 1 2 3 4\n', '5\n0 0 1 0 1\n0 1 2 2 4\n', '4\n1 0 0 0\n2 3 4 2\n']","['5\n1 2 3 4 5\n', '2\n4 5\n', '1\n1\n']",none,OK,"def e():
	n = int(input())
	b = list(map(int,input().split()))
	d = list(map(int,input().split()))
	c = [0]*n
	for i in range(n):
		d[i] -=1
		if d[i]!=-1:
			c[d[i]]+=1
	a = []
	g = [False]*n
	for i in range(n):
		if b[i]==1:
			s = i
			f = []
			while d[s]!=-1 and c[d[s]]<=1:
				f.append(s)
				s = d[s]
			f.append(s)
			if len(f)>len(a):
				a = f
	a = a[::-1]
	print(len(a))
	for i in a:
		print(i+1,end=' ')

t = 1

for i in range(t):
	e()","def b():
    import d

    a = d.stdin.read().split()
    if not a:
        return

    n = int(a[0])

    a = list(map(int, a[1:1+n]))

    c = 0

    for i in range(n - 1):
        if a[i] > a[i+1]:
            c += a[i] - a[i+1]

    d.stdout.write(str(c))

if __name__ == '__main__':
    b()"
115,A,Party,PROGRAMMING,"['dfs and similar', 'graphs', 'trees']","A company has *n* employees numbered from 1 to *n*. Each employee either has no immediate manager or exactly one immediate manager, who is another employee with a different number. An employee *A* is said to be the superior of another employee *B* if at least one of the following is true:
 -  Employee *A* is the immediate manager of employee *B* -  Employee *B* has an immediate manager employee *C* such that employee *A* is the superior of employee *C*. 
The company will not have a managerial cycle. That is, there will not exist an employee who is the superior of his/her own immediate manager.

Today the company is going to arrange a party. This involves dividing all *n* employees into several groups: every employee must belong to exactly one group. Furthermore, within any single group, there must not be two employees *A* and *B* such that *A* is the superior of *B*.

What is the minimum number of groups that must be formed?","The first line contains integer *n* (1<=≤<=*n*<=≤<=2000) — the number of employees.

The next *n* lines contain the integers *p**i* (1<=≤<=*p**i*<=≤<=*n* or *p**i*<==<=-1). Every *p**i* denotes the immediate manager for the *i*-th employee. If *p**i* is -1, that means that the *i*-th employee does not have an immediate manager. 

It is guaranteed, that no employee will be the immediate manager of him/herself (*p**i*<=≠<=*i*). Also, there will be no managerial cycles.",Print a single integer denoting the minimum number of groups that will be formed in the party.,['5\n-1\n1\n2\n1\n-1\n'],['3\n'],"For the first example, three groups are sufficient, for example: 
 -  Employee 1 -  Employees 2 and 4 -  Employees 3 and 5",WRONG_ANSWER,"n = int(input())
e = [[] for _ in range(n+1)]
for i in range(1, n+1):
    h = int(input())
    if h != -1:
        e[h].append(i)
        print(e)

def d(g, c):
    f = c
    print (c)
    for b in e[g]:
        f = max(f, d(b, c+1))
    return f

a = 0
for i in range(1, n+1):
    a = max(a, d(i, 1))

print(a)","def b():
    import c
    a = c.stdin.read().strip().split()

    n = int(a[0])

    f = [0] + [int(x) for x in a[1:n+1]]

    for i in range(1, n + 1):
        a = i
        b = f[a]
        c = f[b]

        if f[c] == a:
            print(""YES"")
            return

    print(""NO"")

if __name__ == ""__main__"":
    b()"
109,A,Lucky Sum of Digits,PROGRAMMING,"['brute force', 'implementation']","Petya loves lucky numbers. We all know that lucky numbers are the positive integers whose decimal representations contain only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.

Petya wonders eagerly what minimum lucky number has the sum of digits equal to *n*. Help him cope with the task.",The single line contains an integer *n* (1<=≤<=*n*<=≤<=106) — the sum of digits of the required lucky number.,"Print on the single line the result — the minimum lucky number, whose sum of digits equals *n*. If such number does not exist, print -1.","['11\n', '10\n']","['47\n', '-1\n']",none,TIME_LIMIT_EXCEEDED,"def b(n):
    return 0 if n==0 else  int(n%10)+b(n//10)
n = int(input())
a = 0
for i in range(10**6):
    if(b(i)==n):
        if i==4 or i==7 or i==47 or i==74:
            c = i
            a = 1
            break
        else:
            continue
if(a):
    print(c)
else:
    print(-1)","from collections import a
import j

def g():

    f = j.stdin.readlines()

    if len(f) < 3:

        return
    
    d = f[0].strip()
    e = f[1].strip()
    h = f[2].strip()

    c = d + e
    b = a(c)

    i = a(h)

    if b == i:
        print(""YES"")
    else:
        print(""NO"")

if __name__ == ""__main__"":
    g()"
347,A,Difference Row,PROGRAMMING,"['constructive algorithms', 'implementation', 'sortings']","You want to arrange *n* integers *a*1,<=*a*2,<=...,<=*a**n* in some order in a row. Let's define the value of an arrangement as the sum of differences between all pairs of adjacent integers.

More formally, let's denote some arrangement as a sequence of integers *x*1,<=*x*2,<=...,<=*x**n*, where sequence *x* is a permutation of sequence *a*. The value of such an arrangement is (*x*1<=-<=*x*2)<=+<=(*x*2<=-<=*x*3)<=+<=...<=+<=(*x**n*<=-<=1<=-<=*x**n*).

Find the largest possible value of an arrangement. Then, output the lexicographically smallest sequence *x* that corresponds to an arrangement of the largest possible value.","The first line of the input contains integer *n* (2<=≤<=*n*<=≤<=100). The second line contains *n* space-separated integers *a*1, *a*2, ..., *a**n* (|*a**i*|<=≤<=1000).","Print the required sequence *x*1,<=*x*2,<=...,<=*x**n*. Sequence *x* should be the lexicographically smallest permutation of *a* that corresponds to an arrangement of the largest possible value.",['5\n100 -100 50 0 -50\n'],['100 -50 0 50 -100 \n'],"In the sample test case, the value of the output arrangement is (100 - ( - 50)) + (( - 50) - 0) + (0 - 50) + (50 - ( - 100)) = 200. No other arrangement has a larger value, and among all arrangements with the value of 200, the output arrangement is the lexicographically smallest one.

Sequence *x*<sub class=""lower-index"">1</sub>, *x*<sub class=""lower-index"">2</sub>, ... , *x*<sub class=""lower-index"">*p*</sub> is lexicographically smaller than sequence *y*<sub class=""lower-index"">1</sub>, *y*<sub class=""lower-index"">2</sub>, ... , *y*<sub class=""lower-index"">*p*</sub> if there exists an integer *r* (0 ≤ *r* &lt; *p*) such that *x*<sub class=""lower-index"">1</sub> = *y*<sub class=""lower-index"">1</sub>, *x*<sub class=""lower-index"">2</sub> = *y*<sub class=""lower-index"">2</sub>, ... , *x*<sub class=""lower-index"">*r*</sub> = *y*<sub class=""lower-index"">*r*</sub> and *x*<sub class=""lower-index"">*r* + 1</sub> &lt; *y*<sub class=""lower-index"">*r* + 1</sub>.",OK,"def a():
    n = int(input())
    b = sorted(list(map(int, input().split(' '))))
    c = b[0]
    b[0] = b[-1]
    b[-1] = c
    print(' '.join(map(str, b)))

a()","import e

def d(f):

    f = abs(f)

    if f == 0:
        return 0
    
    n = 0
    g = 0

    while True:
        n += 1
        g += n

        if g >= f and (g - f) % 2 == 0:
            break
    return n

def c():
    a = e.stdin.readlines()

    for b in a:
        b = b.strip()
        if not b:
            continue
        try:
            x = int(b)
        except ValueError:

            continue

        print(d(x))

if __name__ == ""__main__"":
    c()"
20,C,Dijkstra?,PROGRAMMING,"['graphs', 'shortest paths']",You are given a weighted undirected graph. The vertices are enumerated from 1 to *n*. Your task is to find the shortest path between the vertex 1 and the vertex *n*.,"The first line contains two integers *n* and *m* (2<=≤<=*n*<=≤<=105,<=0<=≤<=*m*<=≤<=105), where *n* is the number of vertices and *m* is the number of edges. Following *m* lines contain one edge each in form *a**i*, *b**i* and *w**i* (1<=≤<=*a**i*,<=*b**i*<=≤<=*n*,<=1<=≤<=*w**i*<=≤<=106), where *a**i*,<=*b**i* are edge endpoints and *w**i* is the length of the edge.

It is possible that the graph has loops and multiple edges between pair of vertices.","Write the only integer -1 in case of no path. Write the shortest path in opposite case. If there are many solutions, print any of them.","['5 6\n1 2 2\n2 5 5\n2 3 4\n1 4 1\n4 3 3\n3 5 1\n', '5 6\n1 2 2\n2 5 5\n2 3 4\n1 4 1\n4 3 3\n3 5 1\n']","['1 4 3 5 ', '1 4 3 5 ']",none,MEMORY_LIMIT_EXCEEDED,"from collections import c
from heapq import h, g

def e(f, n, d, r):
    i = [(0, n, -1)]
    while i:
        a, b, k = g(i) 

        if b in r:
            continue

        r[b] = k
        if b == d:
            return r

        for w, j in f[b]:
            if j not in r:
                h(i, (w+a, j, b))
    return None

def m():
    n, m = map(int, input().split())
    f = c(list)

    for _ in range(m):
        a,b, w = map(int, input().split())
        f[a].append((w, b))
        f[b].append((w, a))

    r = e(f, 1, n, dict()) 
    if r == None:
        print(-1)
        return;

    l = []
    b = n
    while b > -1:
        l.append(b)
        b = r[b]
    print("" "".join(map(str, l[::-1])))
        

import o
import q
o.setrecursionlimit(1 << 30)
q.stack_size(1 << 27)
p = q.Thread(target=m)
p.n(); p.join()","def c():
    import g

    b = g.stdin.read().split()
    if not b:
        return

    n = int(b[0])
    e = list(map(int, b[1:]))

    a = {i: 0 for i in range(1, 8)}
    for d in e:
        a[d] += 1

    if a[5] > 0 or a[7] > 0:
        print(-1)
        return

    A = a[4]
    C = a[3]
    B = a[2] - a[4]

    if B < 0:
        print(-1)
        return

    if a[1] != A + B + C:
        print(-1)
        return

    if a[2] != A + B:
        print(-1)
        return

    if a[1] != a[2] + a[3]:
        print(-1)
        return

    if a[6] != B + C:
        print(-1)
        return

    f = []

    for _ in range(A):
        f.append(""1 2 4"")

    for _ in range(B):
        f.append(""1 2 6"")

    for _ in range(C):
        f.append(""1 3 6"")

    g.stdout.write(""\n"".join(f) + ""\n"")

if __name__ == ""__main__"":
    c()"
