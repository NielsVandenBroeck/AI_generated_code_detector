contestId,index,name,type,tags,problem-description,input-specification,output-specification,demo-input,demo-output,note,verdict,code,ai_generated_code
604,A,Uncowed Forces,PROGRAMMING,['implementation'],"Kevin Sun has just finished competing in Codeforces Round #334! The round was 120 minutes long and featured five problems with maximum point values of 500, 1000, 1500, 2000, and 2500, respectively. Despite the challenging tasks, Kevin was uncowed and bulldozed through all of them, distinguishing himself from the herd as the best cowmputer scientist in all of Bovinia. Kevin knows his submission time for each problem, the number of wrong submissions that he made on each problem, and his total numbers of successful and unsuccessful hacks. Because Codeforces scoring is complicated, Kevin wants you to write a program to compute his final score.

Codeforces scores are computed as follows: If the maximum point value of a problem is *x*, and Kevin submitted correctly at minute *m* but made *w* wrong submissions, then his score on that problem is . His total score is equal to the sum of his scores for each problem. In addition, Kevin's total score gets increased by 100 points for each successful hack, but gets decreased by 50 points for each unsuccessful hack.

All arithmetic operations are performed with absolute precision and no rounding. It is guaranteed that Kevin's final score is an integer.","The first line of the input contains five space-separated integers *m*1, *m*2, *m*3, *m*4, *m*5, where *m**i* (0<=≤<=*m**i*<=≤<=119) is the time of Kevin's last submission for problem *i*. His last submission is always correct and gets accepted.

The second line contains five space-separated integers *w*1, *w*2, *w*3, *w*4, *w*5, where *w**i* (0<=≤<=*w**i*<=≤<=10) is Kevin's number of wrong submissions on problem *i*.

The last line contains two space-separated integers *h**s* and *h**u* (0<=≤<=*h**s*,<=*h**u*<=≤<=20), denoting the Kevin's numbers of successful and unsuccessful hacks, respectively.","Print a single integer, the value of Kevin's final score.","['20 40 60 80 100\n0 1 2 3 4\n1 0\n', '119 119 119 119 119\n0 0 0 0 0\n10 0\n']","['4900\n', '4930\n']","In the second sample, Kevin takes 119 minutes on all of the problems. Therefore, he gets <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/42158dc2bc78cd21fa679530ae9ef8b9ea298d15.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> of the points on each problem. So his score from solving problems is <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/fdf392d8508500b57f8057ac0c4c892ab5f925a2.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>. Adding in 10·100 = 1000 points from hacks, his total score becomes 3930 + 1000 = 4930.",OK,"def score(x,m,w):
    t=(1-(m/250))*x - (50*w)
    return max(0.3*x,t)

sl=[500,1000,1500,2000,2500]
m=list(map(int, input().split()))
w=list(map(int, input().split()))
s,u=map(int,input().split())

res=0

for i in range(5):
    res+=score(sl[i],m[i],w[i])
res+=(100*s)
res-=(50*u)
print(int(res))","def calculate_final_score(submission_times, wrong_submissions, successful_hacks, unsuccessful_hacks):

    max_points = [500, 1000, 1500, 2000, 2500]

    total_score = 0
    for i in range(5):
        m_i = submission_times[i]
        w_i = wrong_submissions[i]

        score = max(0, max_points[i] - 50 * w_i - (m_i // 3))
        total_score += score

    total_score += (successful_hacks * 100) - (unsuccessful_hacks * 50)
    
    return total_score

submission_times = list(map(int, input().split()))
wrong_submissions = list(map(int, input().split()))
successful_hacks, unsuccessful_hacks = map(int, input().split())

final_score = calculate_final_score(submission_times, wrong_submissions, successful_hacks, unsuccessful_hacks)
print(final_score)"
322,B,Ciel and Flowers,PROGRAMMING,"['combinatorics', 'math']","Fox Ciel has some flowers: *r* red flowers, *g* green flowers and *b* blue flowers. She wants to use these flowers to make several bouquets. There are 4 types of bouquets:
 -  To make a ""red bouquet"", it needs 3 red flowers. -  To make a ""green bouquet"", it needs 3 green flowers. -  To make a ""blue bouquet"", it needs 3 blue flowers. -  To make a ""mixing bouquet"", it needs 1 red, 1 green and 1 blue flower. 
Help Fox Ciel to find the maximal number of bouquets she can make.","The first line contains three integers *r*, *g* and *b* (0<=≤<=*r*,<=*g*,<=*b*<=≤<=109) — the number of red, green and blue flowers.",Print the maximal number of bouquets Fox Ciel can make.,"['3 6 9\n', '4 4 4\n', '0 0 0\n']","['6\n', '4\n', '0\n']","In test case 1, we can make 1 red bouquet, 2 green bouquets and 3 blue bouquets.

In test case 2, we can make 1 red, 1 green, 1 blue and 1 mixing bouquet.",OK,"def f(x): return x // 3

r, g, b = map(int, input().split())
m = min(r, g, b)
ans = 0
for i in range(max(0, m - 30), m + 1):
    ans = max(ans, i + f(r - i) + f(g - i) + f(b - i))
print(ans)","def max_bouquets(r, g, b):

    max_bqs = 0

    mix_bouquets = min(r, g, b)
    max_bqs += mix_bouquets

    r -= mix_bouquets
    g -= mix_bouquets
    b -= mix_bouquets

    max_bqs += r // 3
    max_bqs += g // 3
    max_bqs += b // 3

    return max_bqs

import sys
input = sys.stdin.read
data = input().strip().splitlines()

output = []
for line in data:
    r, g, b = map(int, line.split())
    output.append(str(max_bouquets(r, g, b)))

print('\n'.join(output))"
298,A,Snow Footprints,PROGRAMMING,"['greedy', 'implementation']","There is a straight snowy road, divided into *n* blocks. The blocks are numbered from 1 to *n* from left to right. If one moves from the *i*-th block to the (*i*<=+<=1)-th block, he will leave a right footprint on the *i*-th block. Similarly, if one moves from the *i*-th block to the (*i*<=-<=1)-th block, he will leave a left footprint on the *i*-th block. If there already is a footprint on the *i*-th block, the new footprint will cover the old one.

At the beginning, there were no footprints. Then polar bear Alice starts from the *s*-th block, makes a sequence of moves and ends in the *t*-th block. It is known that Alice never moves outside of the road. 

You are given the description of Alice's footprints. Your task is to find a pair of possible values of *s*,<=*t* by looking at the footprints.","The first line of the input contains integer *n* (3<=≤<=*n*<=≤<=1000).

The second line contains the description of the road — the string that consists of *n* characters. Each character will be either ""."" (a block without footprint), or ""L"" (a block with a left footprint), ""R"" (a block with a right footprint).

It's guaranteed that the given string contains at least one character not equal to ""."". Also, the first and the last character will always be ""."". It's guaranteed that a solution exists.",Print two space-separated integers — the values of *s* and *t*. If there are several possible solutions you can print any of them.,"['9\n..RRLL...\n', '11\n.RRRLLLLL..\n']","['3 4\n', '7 5\n']",The first test sample is the one in the picture.,COMPILATION_ERROR,"x , s = int(input()) , input()
first , last  , rr= s.find('R'|'L') , s.rfind('R'|'L') , s.rfind('R') 
if(str[first] == 'R' && str[last] == 'R'):
        print(first +1 , last+1)
elif(str[first] == 'L' && str[last] == 'L'):
        print(last+1 , first+1)
elif(str[first] == 'R' && str[last] == 'L'):
        print(first +1 , rr+1)","def find_start_end_blocks(n, footprints):

    for i in range(n):
        if footprints[i] == 'R':

            s = i + 1

            for j in range(i + 1, n):
                if footprints[j] == 'L':
                    t = j + 1
                    return s, t
    return None

n = int(input().strip())

footprints = input().strip()

s, t = find_start_end_blocks(n, footprints)

print(s, t)"
808,D,Array Division,PROGRAMMING,"['binary search', 'data structures', 'implementation']","Vasya has an array *a* consisting of positive integer numbers. Vasya wants to divide this array into two non-empty consecutive parts (the prefix and the suffix) so that the sum of all elements in the first part equals to the sum of elements in the second part. It is not always possible, so Vasya will move some element before dividing the array (Vasya will erase some element and insert it into an arbitrary position).

Inserting an element in the same position he was erased from is also considered moving.

Can Vasya divide the array after choosing the right element to move and its new position?","The first line contains single integer *n* (1<=≤<=*n*<=≤<=100000) — the size of the array.

The second line contains *n* integers *a*1,<=*a*2... *a**n* (1<=≤<=*a**i*<=≤<=109) — the elements of the array.",Print YES if Vasya can divide the array after moving one element. Otherwise print NO.,"['3\n1 3 2\n', '5\n1 2 3 4 5\n', '5\n2 2 3 4 5\n']","['YES\n', 'NO\n', 'YES\n']","In the first example Vasya can move the second element to the end of the array.

In the second example no move can make the division possible.

In the third example Vasya can move the fourth element by one position to the left.",OK,"n = int(input())
arr = list(map(int, input().split()))
def solve(n, a):
    s = sum(a)
    if n == 1 or s & 1:
        print('NO')
        return
    half = s // 2
    def judge(a):
        pre, st = 0, {0}
        for num in a:
            st.add(num)
            pre += num
            if pre - half in st: return True
        return False
    print('YES' if judge(a) or judge(a[::-1]) else 'NO')

solve(n, arr)","def can_divide_array(n, a):
    total_sum = sum(a)
    left_sum = 0

    seen_sums = set()
    
    for i in range(n - 1):
        left_sum += a[i]

        if (total_sum - a[i]) % 2 == 0:
            target = (total_sum - a[i]) // 2
            if target in seen_sums or target == left_sum:
                return 'YES'
        
        seen_sums.add(left_sum)

    return 'NO'

n = int(input())
a = list(map(int, input().split()))

print(can_divide_array(n, a))"
982,E,Billiard,PROGRAMMING,"['geometry', 'number theory']","Consider a [billiard table](https://en.wikipedia.org/wiki/Billiard_table) of rectangular size $n \times m$ with four pockets. Let's introduce a coordinate system with the origin at the lower left corner (see the picture). 

There is one ball at the point $(x, y)$ currently. Max comes to the table and strikes the ball. The ball starts moving along a line that is parallel to one of the axes or that makes a $45^{\circ}$ angle with them. We will assume that: 
 1.  the angles between the directions of the ball before and after a collision with a side are equal, 1.  the ball moves indefinitely long, it only stops when it falls into a pocket, 1.  the ball can be considered as a point, it falls into a pocket if and only if its coordinates coincide with one of the pockets, 1.  initially the ball is not in a pocket. 
Note that the ball can move along some side, in this case the ball will just fall into the pocket at the end of the side.

Your task is to determine whether the ball will fall into a pocket eventually, and if yes, which of the four pockets it will be.","The only line contains $6$ integers $n$, $m$, $x$, $y$, $v_x$, $v_y$ ($1 \leq n, m \leq 10^9$, $0 \leq x \leq n$; $0 \leq y \leq m$; $-1 \leq v_x, v_y \leq 1$; $(v_x, v_y) \neq (0, 0)$) — the width of the table, the length of the table, the $x$-coordinate of the initial position of the ball, the $y$-coordinate of the initial position of the ball, the $x$-component of its initial speed and the $y$-component of its initial speed, respectively. It is guaranteed that the ball is not initially in a pocket.","Print the coordinates of the pocket the ball will fall into, or $-1$ if the ball will move indefinitely.","['4 3 2 2 -1 1\n', '4 4 2 0 1 1\n', '10 10 10 1 -1 0\n']","['0 0', '-1', '-1']","The first sample: 

The second sample: 

In the third sample the ball will never change its $y$ coordinate, so the ball will never fall into a pocket.",RUNTIME_ERROR,"from sys import argv
from math import trunc

def Billiard_Table(n, m, x, y, vx, vy):
    if vx == 0:
        if vy == 0:
            return -1            
                    
        if x == 0:
            
            if vy > 0:
                return 0, n
            
            elif vy < 0:
                return 0, 0
            
        elif x == m:
            
            if vy > 0:
                return m, 0
            
            elif vy < 0:
                return m, n
        else: 
            return -1
            
    if vy == 0:
        if y == 0:
            
            if vx > 0:
                return m, 0
            
            elif vx < 0:
                return 0, 0
            
        elif y == n:
            
            if vx > 0:
                return m, n
            
            elif vx < 0:
                return 0, n
            
        else:
            return -1

    p = vy/vx
    r = y - p * x

    d, k1_0, k2_0 = GCD_Euclidean_Algorithm(m, abs(-n * p))

    if r % d != 0:
        return -1

    k1_0 = k1_0 * r / d 
    k2_0 = k2_0 * r / d

    t_lb1, t_lb2 = -2**10, -2**10
    t_ub1, t_ub2 = 2**10, 2**10  

    if vx > 0:
        t_ub1 = (k2_0 / m) * d
    else:
        t_lb1 = ((k2_0 - 1) / m) * d

    if vy > 0:
        t_ub2 = (k1_0 / (n * p)) * d
    else:
        t_lb2 = ((k1_0 - 1) / (n * p)) * d
        
    t = 0    

    if vx == vy:
        if vy > 0: 
            t = min(trunc(t_ub2), trunc(t_ub1))
            
        else:
            t = max(trunc(t_lb1), trunc(t_lb2))
                    
        holder  = t
        k2 = 0
        notdone = True
            
        while(notdone):
            k2 = k2_0 - (m/d) * t
                
            if (abs(k2) > (abs(k2_0 - (m/d) * holder))):
                notdone = False
                t = holder
            else:
                holder = t
                t = t - 1
                
    else:
        t_lb1 = max(trunc(t_lb1), trunc(t_lb2))
        t_ub1 = min(trunc(t_ub2), trunc(t_ub1))
        
        for i in range(0, (t_ub1 + 1 - t_lb1) // 2):
            k2_1 = k2_0 - (m/d) * (t_lb1 + i)
            k2_2 = k2_0 - (m/d) * (t_ub1 + 1 - i)

            if abs(k2_1) < abs(holder):
                holder = k2_1
                t = t_lb1 + i
            elif abs(k2_2) < abs(holder):
                holder = k2_2
                t = t_ub1 + 1 - i   
        k2 = k2 = k2_0 - (m/d) * t

    k1 = k1_0 - (n* p * t) / d

    return (k2 % 2) * m, (k1 % 2) * n    
    
    
def GCD_Euclidean_Algorithm(a, b):
    if b > a:
        temp = a
        a = b
        b = temp
    
    r = a % b   
    if r == 0:
        return b, 1, 0
    
    d, x_1, y_1 = GCD_Euclidean_Algorithm(b, a % b)

    x = y_1 - (x_1 * trunc(a/b))
    y = x_1
    
    return d, x, y

def main():
    _, n, m, x, y, vx, vy = argv
    print(Billiard_Table(int(n), int(m), int(x), int(y), int(vx), int(vy)))
    
main()","def find_pocket(n, m, x, y, v_x, v_y):

    if v_x > 0:
        time_to_vertical_wall = (n - x) / v_x
    elif v_x < 0:
        time_to_vertical_wall = x / abs(v_x)
    else:
        time_to_vertical_wall = float('inf')

    if v_y > 0:
        time_to_horizontal_wall = (m - y) / v_y
    elif v_y < 0:
        time_to_horizontal_wall = y / abs(v_y)
    else:
        time_to_horizontal_wall = float('inf')

    t = min(time_to_vertical_wall, time_to_horizontal_wall)

    new_x = x + v_x * t
    new_y = y + v_y * t

    if t == time_to_vertical_wall:
        if v_x > 0:
            new_x = n
        else:
            new_x = 0

        new_y += v_y * time_to_vertical_wall
        if new_y < 0 or new_y > m:
            return -1
    else:
        if v_y > 0:
            new_y = m
        else:
            new_y = 0

        new_x += v_x * time_to_horizontal_wall
        if new_x < 0 or new_x > n:
            return -1

    if new_x == 0 and new_y == 0:
        return (0, 0)
    elif new_x == n and new_y == 0:
        return (n, 0)
    elif new_x == 0 and new_y == m:
        return (0, m)
    elif new_x == n and new_y == m:
        return (n, m)

    return -1

import sys
input_data = sys.stdin.read().strip().splitlines()

results = []
for line in input_data:
    n, m, x, y, v_x, v_y = map(int, line.split())
    pocket = find_pocket(n, m, x, y, v_x, v_y)
    if pocket == -1:
        results.append(""-1"")
    else:
        results.append(f""{pocket[0]} {pocket[1]}"")

print(""\n"".join(results))"
733,D,Kostya the Sculptor,PROGRAMMING,"['data structures', 'hashing']","Kostya is a genial sculptor, he has an idea: to carve a marble sculpture in the shape of a sphere. Kostya has a friend Zahar who works at a career. Zahar knows about Kostya's idea and wants to present him a rectangular parallelepiped of marble from which he can carve the sphere. 

Zahar has *n* stones which are rectangular parallelepipeds. The edges sizes of the *i*-th of them are *a**i*, *b**i* and *c**i*. He can take no more than two stones and present them to Kostya. 

If Zahar takes two stones, he should glue them together on one of the faces in order to get a new piece of rectangular parallelepiped of marble. Thus, it is possible to glue a pair of stones together if and only if two faces on which they are glued together match as rectangles. In such gluing it is allowed to rotate and flip the stones in any way. 

Help Zahar choose such a present so that Kostya can carve a sphere of the maximum possible volume and present it to Zahar.","The first line contains the integer *n* (1<=≤<=*n*<=≤<=105).

*n* lines follow, in the *i*-th of which there are three integers *a**i*,<=*b**i* and *c**i* (1<=≤<=*a**i*,<=*b**i*,<=*c**i*<=≤<=109) — the lengths of edges of the *i*-th stone. Note, that two stones may have exactly the same sizes, but they still will be considered two different stones.","In the first line print *k* (1<=≤<=*k*<=≤<=2) the number of stones which Zahar has chosen. In the second line print *k* distinct integers from 1 to *n* — the numbers of stones which Zahar needs to choose. Consider that stones are numbered from 1 to *n* in the order as they are given in the input data.

You can print the stones in arbitrary order. If there are several answers print any of them.","['6\n5 5 5\n3 2 4\n1 4 1\n2 1 3\n3 2 4\n3 3 4\n', '7\n10 7 8\n5 10 3\n4 2 6\n5 5 5\n10 2 8\n4 2 1\n7 7 7\n']","['1\n1\n', '2\n1 5\n']","In the first example we can connect the pairs of stones:
 -  2 and 4, the size of the parallelepiped: 3 × 2 × 5, the radius of the inscribed sphere 1 -  2 and 5, the size of the parallelepiped: 3 × 2 × 8 or 6 × 2 × 4 or 3 × 4 × 4, the radius of the inscribed sphere 1, or 1, or 1.5 respectively. -  2 and 6, the size of the parallelepiped: 3 × 5 × 4, the radius of the inscribed sphere 1.5 -  4 and 5, the size of the parallelepiped: 3 × 2 × 5, the radius of the inscribed sphere 1 -  5 and 6, the size of the parallelepiped: 3 × 4 × 5, the radius of the inscribed sphere 1.5 
Or take only one stone:
 -  1 the size of the parallelepiped: 5 × 5 × 5, the radius of the inscribed sphere 2.5 -  2 the size of the parallelepiped: 3 × 2 × 4, the radius of the inscribed sphere 1 -  3 the size of the parallelepiped: 1 × 4 × 1, the radius of the inscribed sphere 0.5 -  4 the size of the parallelepiped: 2 × 1 × 3, the radius of the inscribed sphere 0.5 -  5 the size of the parallelepiped: 3 × 2 × 4, the radius of the inscribed sphere 1 -  6 the size of the parallelepiped: 3 × 3 × 4, the radius of the inscribed sphere 1.5 
It is most profitable to take only the first stone.",RUNTIME_ERROR,"class HashTable:
    def __init__(self, depth=2, module=1453):
        self.depth = depth
        self.module = module
        self.table = []

    def add(self, seq):
        ref = self.table
        for i in range(self.depth-1):
            if len(ref) == 0:
                ref.extend([[] for i in range(self.module)])
            box = seq[i] % self.module
            ref = ref[box]

        box = seq[self.depth-1] % self.module
        if len(ref) == 0:
            ref.extend([[] for i in range(self.module)])
        ref[box].append(seq)

    def look_up(self, seq):
        ref = self.table
        depth = 0
        while depth < self.depth and len(ref) > 0:
            box = seq[depth] % self.module
            ref = ref[box]
            depth += 1

        if depth < self.depth or len(ref) == 0:
            return None

        max_z_value = 0
        best = None
        d = 0

        for cand in ref:
            while d < self.depth and cand[d] == seq[d]:
                d += 1
            if d < self.depth:
                break
            if max_z_value < cand[d]:
                max_z_value = cand[d]
                best = cand                

        return best

if __name__ == '__main__':

    hash_table = HashTable()

    input_file = open('input.txt', ""r"")

    n = int(input())
    max_radius = 0
    ordinal_numbers = [0]

    for i in range(1, n+1):

        seq = sorted(list(map(int, input().split())),
                     reverse=True) + [i]
        best = hash_table.look_up(seq)

        if best is not None:
            seq[2] += best[2]
            radius = min(seq[:-1])
            if  radius > max_radius:
                ordinal_numbers = [best[3], seq[3]]
                max_radius = radius
        else:
            if seq[2] > max_radius:
                ordinal_numbers = [seq[3]]
                max_radius = seq[2]
        
        hash_table.add(seq)

    print(len(ordinal_numbers), file=output_file)
    print("" "".join(map(str, ordinal_numbers)), file=output_file)","def radius_of_inscribed_sphere(a, b, c):

    return min(a, b, c) / 2

def can_glue(s1, s2):

    return (s1[0] == s2[0] and s1[1] == s2[1]) or \
           (s1[0] == s2[1] and s1[1] == s2[0]) or \
           (s1[0] == s2[0] and s1[2] == s2[2]) or \
           (s1[0] == s2[2] and s1[2] == s2[0]) or \
           (s1[1] == s2[1] and s1[2] == s2[2]) or \
           (s1[1] == s2[2] and s1[2] == s2[1])

def main():
    import sys
    input = sys.stdin.read
    data = input().strip().split('\n')
    
    n = int(data[0])
    stones = []
    
    for i in range(1, n + 1):
        a, b, c = map(int, data[i].split())
        stones.append(sorted([a, b, c]))
    
    best_radius = 0
    best_choice = (0, [])

    for i in range(n):
        r = radius_of_inscribed_sphere(*stones[i])
        if r > best_radius:
            best_radius = r
            best_choice = (1, [i + 1])

    for i in range(n):
        for j in range(i + 1, n):
            if can_glue(stones[i], stones[j]):
                combined_a = max(stones[i][0], stones[j][0])
                combined_b = max(stones[i][1], stones[j][1])
                combined_c = stones[i][2] + stones[j][2]
                r = radius_of_inscribed_sphere(combined_a, combined_b, combined_c)
                
                if r > best_radius:
                    best_radius = r
                    best_choice = (2, [i + 1, j + 1])

    print(best_choice[0])
    print(' '.join(map(str, best_choice[1])))

if __name__ == ""__main__"":
    main()"
50,A,Domino piling,PROGRAMMING,"['greedy', 'math']","You are given a rectangular board of *M*<=×<=*N* squares. Also you are given an unlimited number of standard domino pieces of 2<=×<=1 squares. You are allowed to rotate the pieces. You are asked to place as many dominoes as possible on the board so as to meet the following conditions:

1. Each domino completely covers two squares.

2. No two dominoes overlap.

3. Each domino lies entirely inside the board. It is allowed to touch the edges of the board.

Find the maximum number of dominoes, which can be placed under these restrictions.",In a single line you are given two integers *M* and *N* — board sizes in squares (1<=≤<=*M*<=≤<=*N*<=≤<=16).,"Output one number — the maximal number of dominoes, which can be placed.","['2 4\n', '3 3\n']","['4\n', '4\n']",none,OK,"m, n = list(map(int,input().split("" "")))
print(m*n//2)","def max_dominoes(m, n):

    total_squares = m * n

    return total_squares // 2

def main():
    import sys
    input_data = sys.stdin.read().strip().splitlines()
    
    for line in input_data:
        if line:

            m, n = map(int, line.split())

            result = max_dominoes(m, n)

            print(result)

if __name__ == ""__main__"":
    main()"
219,C,Color Stripe,PROGRAMMING,"['brute force', 'dp', 'greedy']","A colored stripe is represented by a horizontal row of *n* square cells, each cell is pained one of *k* colors. Your task is to repaint the minimum number of cells so that no two neighbouring cells are of the same color. You can use any color from 1 to *k* to repaint the cells.","The first input line contains two integers *n* and *k* (1<=≤<=*n*<=≤<=5·105; 2<=≤<=*k*<=≤<=26). The second line contains *n* uppercase English letters. Letter ""A"" stands for the first color, letter ""B"" stands for the second color and so on. The first *k* English letters may be used. Each letter represents the color of the corresponding cell of the stripe.",Print a single integer — the required minimum number of repaintings. In the second line print any possible variant of the repainted stripe.,"['6 3\nABBACC\n', '3 2\nBBB\n']","['2\nABCACA\n', '1\nBAB\n']",none,OK,"n, k = map(int, input().split())

s = list(input())

if k > 2:
    c = set(ord(""A"") + i for i in range(26))
    r = 0
    for i in range(1,len(s)):
        if s[i-1] == s[i]:
            r += 1
            if i + 1 < n:
                s[i] = ""A"" if ""A"" not in {s[i-1], s[i+1]} else ('B' if ""B"" not in {s[i], s[i+1]} else ""C"")
            else:
                s[i] = ""A"" if s[i-1] != ""A"" else ""B""
    
    print(r)
    print("""".join(s))

else:
    x, y = ""AB"" * n, ""BA"" * n
    def check(x, y):
        return sum(x[i] != y[i] for i in range(n))
    check_1 = check(x, s)
    check_2 = check(y, s)
    z = [x,y][check_1 > check_2]
    print(min(check_1, check_2))
    print(z[:n])","def min_repaints(n, k, stripe):

    stripe = list(stripe)

    repaints = 0

    for i in range(1, n):

        if stripe[i] == stripe[i - 1]:
            repaints += 1

            for color in range(ord('A'), ord('A') + k):
                new_color = chr(color)
                if i + 1 < n and new_color == stripe[i + 1]:
                    continue
                stripe[i] = new_color
                break

    repainted_stripe = ''.join(stripe)
    
    return repaints, repainted_stripe

input_data = ['6 3\nABBACC\n', '3 2\nBBB\n']
for data in input_data:
    n, k = map(int, data.split()[0:2])
    stripe = data.split()[1]

    repaints, new_stripe = min_repaints(n, k, stripe)

    print(repaints)
    print(new_stripe)"
337,A,Puzzles,PROGRAMMING,['greedy'],"The end of the school year is near and Ms. Manana, the teacher, will soon have to say goodbye to a yet another class. She decided to prepare a goodbye present for her *n* students and give each of them a jigsaw puzzle (which, as wikipedia states, is a tiling puzzle that requires the assembly of numerous small, often oddly shaped, interlocking and tessellating pieces).

The shop assistant told the teacher that there are *m* puzzles in the shop, but they might differ in difficulty and size. Specifically, the first jigsaw puzzle consists of *f*1 pieces, the second one consists of *f*2 pieces and so on.

Ms. Manana doesn't want to upset the children, so she decided that the difference between the numbers of pieces in her presents must be as small as possible. Let *A* be the number of pieces in the largest puzzle that the teacher buys and *B* be the number of pieces in the smallest such puzzle. She wants to choose such *n* puzzles that *A*<=-<=*B* is minimum possible. Help the teacher and find the least possible value of *A*<=-<=*B*.","The first line contains space-separated integers *n* and *m* (2<=≤<=*n*<=≤<=*m*<=≤<=50). The second line contains *m* space-separated integers *f*1,<=*f*2,<=...,<=*f**m* (4<=≤<=*f**i*<=≤<=1000) — the quantities of pieces in the puzzles sold in the shop.",Print a single integer — the least possible difference the teacher can obtain.,['4 6\n10 12 10 7 5 22\n'],['5\n'],"Sample 1. The class has 4 students. The shop sells 6 puzzles. If Ms. Manana buys the first four puzzles consisting of 10, 12, 10 and 7 pieces correspondingly, then the difference between the sizes of the largest and the smallest puzzle will be equal to 5. It is impossible to obtain a smaller difference. Note that the teacher can also buy puzzles 1, 3, 4 and 5 to obtain the difference 5.",WRONG_ANSWER,"def quickSort(a: list):
    if len(a) <= 1:
        return a
    pivot = a[len(a)//2]
    left = [i for i in a if i < pivot]
    middle = [i for i in a if i == pivot]
    right = [i for i in a if i > pivot]
    return quickSort(left) + middle + quickSort(right)

n, m = [int(i) for i in input().split()]
a = [int(i) for i in input().split()]
a = quickSort(a)

res = a[n - 1] - a[0]

for i in range(n, m):
    res = min(res, a[i - 1] - a[i - n])

print(res)","n, m = map(int, input().split())

puzzles = list(map(int, input().split()))

min_difference = float('inf')

for i in range(m - n + 1):

    current_difference = puzzles[i + n - 1] - puzzles[i]

    if current_difference < min_difference:
        min_difference = current_difference

print(min_difference)"
660,D,Number of Parallelograms,PROGRAMMING,['geometry'],You are given *n* points on a plane. All the points are distinct and no three of them lie on the same line. Find the number of parallelograms with the vertices at the given points.,"The first line of the input contains integer *n* (1<=≤<=*n*<=≤<=2000) — the number of points.

Each of the next *n* lines contains two integers (*x**i*,<=*y**i*) (0<=≤<=*x**i*,<=*y**i*<=≤<=109) — the coordinates of the *i*-th point.",Print the only integer *c* — the number of parallelograms with the vertices at the given points.,['4\n0 1\n1 0\n1 1\n2 0\n'],['1\n'],none,TIME_LIMIT_EXCEEDED,"p = set()

def find(p1,p2,p3):
    np1 = (
        p1[0] + (p2[0]-p3[0]),
        p1[1] + (p2[1]-p3[1])
    )
    if np1 in p: return 1
    np2 = (
        p1[0] + (p3[0]-p2[0]),
        p1[1] + (p3[1]-p2[1])
    )
    if np2 in p: return 1
    np3 = (
        p3[0] + (p2[0]-p1[0]),
        p3[1] + (p2[1]-p1[1])
    )
    if np3 in p: return 1
    return 0 

points = []
for i in range(int(input())):
    x,y  = map(int, input().split())
    p.add((x,y))
    points.append((x,y))

r = 0
for j in range(len(points)):
    for k in range(j+1,len(points)):
        for l in range(k+1,len(points)):

            if find(points[j],points[k],points[l]):
                r = r + 1

print(r//4)","def count_parallelograms(points):
    point_set = set(points)
    count = 0

    for i in range(len(points)):
        for j in range(i + 1, len(points)):
            x1, y1 = points[i]
            x2, y2 = points[j]

            mx = (x1 + x2) / 2
            my = (y1 + y2) / 2

            p1 = (mx + (y1 - y2) / 2, my - (x1 - x2) / 2)
            p2 = (mx - (y1 - y2) / 2, my + (x1 - x2) / 2)

            if p1 in point_set and p2 in point_set:
                count += 1

    return count // 2

import sys

n = int(sys.stdin.readline().strip())
points = [tuple(map(int, sys.stdin.readline().strip().split())) for _ in range(n)]

result = count_parallelograms(points)
print(result)"
888,E,Maximum Subsequence,PROGRAMMING,"['bitmasks', 'divide and conquer', 'meet-in-the-middle']","You are given an array *a* consisting of *n* integers, and additionally an integer *m*. You have to choose some sequence of indices *b*1,<=*b*2,<=...,<=*b**k* (1<=≤<=*b*1<=&lt;<=*b*2<=&lt;<=...<=&lt;<=*b**k*<=≤<=*n*) in such a way that the value of  is maximized. Chosen sequence can be empty.

Print the maximum possible value of .","The first line contains two integers *n* and *m* (1<=≤<=*n*<=≤<=35, 1<=≤<=*m*<=≤<=109).

The second line contains *n* integers *a*1, *a*2, ..., *a**n* (1<=≤<=*a**i*<=≤<=109).",Print the maximum possible value of .,"['4 4\n5 2 4 1\n', '3 20\n199 41 299\n']","['3\n', '19\n']","In the first example you can choose a sequence *b* = {1, 2}, so the sum <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/c856546022c2feee13d02a4ec9cd1d361ab3a756.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> is equal to 7 (and that's 3 after taking it modulo 4).

In the second example you can choose a sequence *b* = {3}.",WRONG_ANSWER,"def max_subsequence(nums):
  currentmax, maxSoFar = 0, float('-inf')
  for number in nums:
      currentmax = max(number, currentmax + number)
      maxSoFar = max(maxSoFar, currentmax)
  return maxSoFar","def max_modulo_sum(n, m, a):
    max_value = 0

    for i in range(1 << n):
        current_sum = 0
        
        for j in range(n):

            if i & (1 << j):
                current_sum += a[j]

        current_sum_mod = current_sum % m

        max_value = max(max_value, current_sum_mod)
    
    return max_value

input_data = input().strip().split('\n')
n, m = map(int, input_data[0].split())
a = list(map(int, input_data[1].split()))

result = max_modulo_sum(n, m, a)
print(result)"
685,A,Robbers' watch,PROGRAMMING,"['brute force', 'combinatorics', 'dp', 'math']","Robbers, who attacked the Gerda's cab, are very successful in covering from the kingdom police. To make the goal of catching them even harder, they use their own watches.

First, as they know that kingdom police is bad at math, robbers use the positional numeral system with base 7. Second, they divide one day in *n* hours, and each hour in *m* minutes. Personal watches of each robber are divided in two parts: first of them has the smallest possible number of places that is necessary to display any integer from 0 to *n*<=-<=1, while the second has the smallest possible number of places that is necessary to display any integer from 0 to *m*<=-<=1. Finally, if some value of hours or minutes can be displayed using less number of places in base 7 than this watches have, the required number of zeroes is added at the beginning of notation.

Note that to display number 0 section of the watches is required to have at least one place.

Little robber wants to know the number of moments of time (particular values of hours and minutes), such that all digits displayed on the watches are distinct. Help her calculate this number.","The first line of the input contains two integers, given in the decimal notation, *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=109) — the number of hours in one day and the number of minutes in one hour, respectively.","Print one integer in decimal notation — the number of different pairs of hour and minute, such that all digits displayed on the watches are distinct.","['2 3\n', '8 2\n']","['4\n', '5\n']","In the first sample, possible pairs are: (0: 1), (0: 2), (1: 0), (1: 2).

In the second sample, possible pairs are: (02: 1), (03: 1), (04: 1), (05: 1), (06: 1).",WRONG_ANSWER,"from itertools import permutations as p
def f(n, tn):
    if not n:
        return 1
    cnt = 0
    while n:
        tn.append(n % 7)
        n //= 7
        cnt += 1
    return cnt
ans = 0
tn, tm = [], []
n, m = map(int, input().split())
x, y = f(n, tn), f(m, tm)
tn, tm = tuple(tn[::-1]), tuple(tm[::-1])

s = {0, 1, 2, 3, 4, 5, 6}
if x + y > 7:
    exit(print(0))
for i in p(s, x):
    if i < tn:
        for j in p(s - set(i), y):
            if j < tm:
                ans += 1
print(ans)","def base7_representation(num):
    """"""Converts a number to base 7 representation.""""""
    if num == 0:
        return '0'
    digits = []
    while num:
        digits.append(str(num % 7))
        num //= 7
    return ''.join(digits[::-1])

def count_unique_digit_pairs(n, m):
    """"""Counts the number of distinct hour and minute pairs with unique digits.""""""
    count = 0
    for hour in range(n + 1):
        for minute in range(m + 1):

            hour_base7 = base7_representation(hour)
            minute_base7 = base7_representation(minute)

            combined = hour_base7 + minute_base7
            if len(set(combined)) == len(combined):
                count += 1
    return count

input_data = ['2 3', '8 2']
results = []
for line in input_data:
    n, m = map(int, line.split())
    result = count_unique_digit_pairs(n, m)
    results.append(result)

for res in results:
    print(res)"
731,A,Night at the Museum,PROGRAMMING,"['implementation', 'strings']","Grigoriy, like the hero of one famous comedy film, found a job as a night security guard at the museum. At first night he received embosser and was to take stock of the whole exposition.

Embosser is a special devise that allows to ""print"" the text of a plastic tape. Text is printed sequentially, character by character. The device consists of a wheel with a lowercase English letters written in a circle, static pointer to the current letter and a button that print the chosen letter. At one move it's allowed to rotate the alphabetic wheel one step clockwise or counterclockwise. Initially, static pointer points to letter 'a'. Other letters are located as shown on the picture:

After Grigoriy add new item to the base he has to print its name on the plastic tape and attach it to the corresponding exhibit. It's not required to return the wheel to its initial position with pointer on the letter 'a'.

Our hero is afraid that some exhibits may become alive and start to attack him, so he wants to print the names as fast as possible. Help him, for the given string find the minimum number of rotations of the wheel required to print it.",The only line of input contains the name of some exhibit — the non-empty string consisting of no more than 100 characters. It's guaranteed that the string consists of only lowercase English letters.,"Print one integer — the minimum number of rotations of the wheel, required to print the name given in the input.","['zeus\n', 'map\n', 'ares\n']","['18\n', '35\n', '34\n']","To print the string from the first sample it would be optimal to perform the following sequence of rotations: 
 1.  from 'a' to 'z' (1 rotation counterclockwise), 1.  from 'z' to 'e' (5 clockwise rotations), 1.  from 'e' to 'u' (10 rotations counterclockwise), 1.  from 'u' to 's' (2 counterclockwise rotations).",WRONG_ANSWER,"string_input = str(input())

def get_distance_between_two_char(char1, char2):
    linear_distance = abs(ord(char1)-ord(char2))
    if linear_distance >= 13:
        real_distance = 26-linear_distance
    else:
        real_distance = linear_distance
    return real_distance

def solve(string_input):
    if not string_input.startswith('a'):
        string_input = 'a' + string_input
    list_char = list(string_input)
    result = 0
    for i in range(len(list_char)):
        if i == len(list_char) - 1:
            return result
        else:
            print(list_char[i], list_char[i+1])
            print(get_distance_between_two_char(list_char[i], list_char[i+1]))
            result += get_distance_between_two_char(list_char[i], list_char[i+1])
            
solve(string_input)","def min_rotations_to_print(exhibits):

    def rotations_between(char1, char2):
        clockwise = (ord(char2) - ord(char1)) % 26
        counterclockwise = (ord(char1) - ord(char2)) % 26
        return min(clockwise, counterclockwise)

    results = []
    for exhibit in exhibits:

        current_position = 'a'
        total_rotations = 0
        
        for char in exhibit.strip():
            total_rotations += rotations_between(current_position, char)
            current_position = char
        
        results.append(total_rotations)
    
    return results

exhibits = ['zeus\n', 'map\n', 'ares\n']

output = min_rotations_to_print(exhibits)
for res in output:
    print(res)"
801,B,Valued Keys,PROGRAMMING,"['constructive algorithms', 'greedy', 'strings']","You found a mysterious function *f*. The function takes two strings *s*1 and *s*2. These strings must consist only of lowercase English letters, and must be the same length.

The output of the function *f* is another string of the same length. The *i*-th character of the output is equal to the minimum of the *i*-th character of *s*1 and the *i*-th character of *s*2.

For example, *f*(""ab"", ""ba"") = ""aa"", and *f*(""nzwzl"", ""zizez"") = ""niwel"".

You found two strings *x* and *y* of the same length and consisting of only lowercase English letters. Find any string *z* such that *f*(*x*,<=*z*)<==<=*y*, or print -1 if no such string *z* exists.","The first line of input contains the string *x*.

The second line of input contains the string *y*.

Both *x* and *y* consist only of lowercase English letters, *x* and *y* have same length and this length is between 1 and 100.","If there is no string *z* such that *f*(*x*,<=*z*)<==<=*y*, print -1.

Otherwise, print a string *z* such that *f*(*x*,<=*z*)<==<=*y*. If there are multiple possible answers, print any of them. The string *z* should be the same length as *x* and *y* and consist only of lowercase English letters.","['ab\naa\n', 'nzwzl\nniwel\n', 'ab\nba\n']","['ba\n', 'xiyez\n', '-1\n']","The first case is from the statement.

Another solution for the second case is ""zizez""

There is no solution for the third case. That is, there is no *z* such that *f*(""ab"", *z*) =  ""ba"".",WRONG_ANSWER,"class test3:
    def demo(self, line0, line1):
        list0 = list(line0)
        list2 = list(line1)
        list1 = []
        for i in range(len(list0)):
            if list0[i] == list2[i]:
                list1.append(list0[i])
            elif list0[i] > list2[i]:
                list1.append(list2[i])
            else:
                print(-1)
                return
        print(''.join(list1))

def test():
    test_lists = [
        ['ab', 'aa'],
        ['nzwzl', 'niwel'],
        ['ab', 'ba'],
        ['nzwzl', 'niwez'],
    ]
    for line in test_lists:
        print(line)
        test3().demo(line[0], line[1])

def main():
    input_str1 = input().strip().split()
    input_str2 = input().strip().split()
    test3().demo(input_str1, input_str2)

if __name__ == '__main__':
    main()","def f(s1, s2):

    return ''.join(min(a, b) for a, b in zip(s1, s2))

def find_string_z(x, y):
    z = []
    for i in range(len(x)):

        min_required = f(x[i], y[i])

        if min_required > y[i]:
            return -1

        z.append(max(x[i], min_required))
    return ''.join(z)

x = input().strip()
y = input().strip()

result = find_string_z(x, y)
print(result)"
22,E,Scheme,PROGRAMMING,"['dfs and similar', 'graphs', 'trees']","To learn as soon as possible the latest news about their favourite fundamentally new operating system, BolgenOS community from Nizhni Tagil decided to develop a scheme. According to this scheme a community member, who is the first to learn the news, calls some other member, the latter, in his turn, calls some third member, and so on; i.e. a person with index *i* got a person with index *f**i*, to whom he has to call, if he learns the news. With time BolgenOS community members understood that their scheme doesn't work sometimes — there were cases when some members didn't learn the news at all. Now they want to supplement the scheme: they add into the scheme some instructions of type (*x**i*,<=*y**i*), which mean that person *x**i* has to call person *y**i* as well. What is the minimum amount of instructions that they need to add so, that at the end everyone learns the news, no matter who is the first to learn it?","The first input line contains number *n* (2<=≤<=*n*<=≤<=105) — amount of BolgenOS community members. The second line contains *n* space-separated integer numbers *f**i* (1<=≤<=*f**i*<=≤<=*n*,<=*i*<=≠<=*f**i*) — index of a person, to whom calls a person with index *i*.","In the first line output one number — the minimum amount of instructions to add. Then output one of the possible variants to add these instructions into the scheme, one instruction in each line. If the solution is not unique, output any.","['3\n3 3 2\n', '7\n2 3 1 3 4 4 1\n']","['1\n3 1\n', '3\n2 5\n2 6\n3 7\n']",none,WRONG_ANSWER,"import sys
from array import array

def input():
    return sys.stdin.buffer.readline().decode('utf-8')

n = int(input())
a = [0] + list(map(int, input().split()))
rev = [[] for _ in range(n + 1)]
indeg = [0] * (n + 1)

for i in range(1, n + 1):
    indeg[a[i]] += 1
    rev[a[i]].append(i)

_indeg = indeg[:]

for i in range(1, n + 1):
    v = i
    while indeg[v] == 0:
        indeg[a[v]] -= 1
        v = a[v]

visited = [0] * (n + 1)
group = []
group_leaf = []

for i in range(1, n + 1):
    if visited[i] or indeg[i] == 0:
        continue

    visited[i] = 1
    leaves = []
    stack = [i]

    while stack:
        v = stack.pop()
        if _indeg[v] == 0:
            leaves.append(v)
        for dest in rev[v]:
            if not visited[dest]:
                visited[dest] = 1
                stack.append(dest)

    group.append(i)
    group_leaf.append(leaves)

ans = []
if len(group) > 1:
    for i in range(len(group)):
        for j in group_leaf[(i + 1) % len(group)]:
            ans.append(f'{group[i]} {j}')
else:
    for j in group_leaf[0]:
        ans.append(f'{group[0]} {j}')

ans_str = str(len(ans)) + '\n' + '\n'.join(ans)
sys.stdout.buffer.write(ans_str.encode('utf-8'))","def find_minimum_instructions(n, f):

    calls = [[] for _ in range(n + 1)]
    for i in range(1, n + 1):
        calls[f[i - 1]].append(i)
    
    visited = [False] * (n + 1)
    instructions_needed = []

    def dfs(member):
        stack = [member]
        while stack:
            current = stack.pop()
            for neighbor in calls[current]:
                if not visited[neighbor]:
                    visited[neighbor] = True
                    stack.append(neighbor)

    for i in range(1, n + 1):
        if not visited[i]:

            visited[i] = True
            dfs(i)

            first_member = i
            for j in range(1, n + 1):
                if not visited[j]:
                    instructions_needed.append((first_member, j))
                    visited[j] = True

    return len(instructions_needed), instructions_needed

import sys
input_data = sys.stdin.read().strip().splitlines()
n = int(input_data[0])
f = list(map(int, input_data[1].split()))

instruction_count, instructions = find_minimum_instructions(n, f)

print(instruction_count)
for instruction in instructions:
    print(instruction[0], instruction[1])"
265,A,Colorful Stones (Simplified Edition),PROGRAMMING,['implementation'],"There is a sequence of colorful stones. The color of each stone is one of red, green, or blue. You are given a string *s*. The *i*-th (1-based) character of *s* represents the color of the *i*-th stone. If the character is ""R"", ""G"", or ""B"", the color of the corresponding stone is red, green, or blue, respectively.

Initially Squirrel Liss is standing on the first stone. You perform instructions one or more times.

Each instruction is one of the three types: ""RED"", ""GREEN"", or ""BLUE"". After an instruction *c*, if Liss is standing on a stone whose colors is *c*, Liss will move one stone forward, else she will not move.

You are given a string *t*. The number of instructions is equal to the length of *t*, and the *i*-th character of *t* represents the *i*-th instruction.

Calculate the final position of Liss (the number of the stone she is going to stand on in the end) after performing all the instructions, and print its 1-based position. It is guaranteed that Liss don't move out of the sequence.","The input contains two lines. The first line contains the string *s* (1<=≤<=|*s*|<=≤<=50). The second line contains the string *t* (1<=≤<=|*t*|<=≤<=50). The characters of each string will be one of ""R"", ""G"", or ""B"". It is guaranteed that Liss don't move out of the sequence.",Print the final 1-based position of Liss in a single line.,"['RGB\nRRR\n', 'RRRBGBRBBB\nBBBRR\n', 'BRRBGBRGRBGRGRRGGBGBGBRGBRGRGGGRBRRRBRBBBGRRRGGBBB\nBBRBGGRGRGBBBRBGRBRBBBBRBRRRBGBBGBBRRBBGGRBRRBRGRB\n']","['2\n', '3\n', '15\n']",none,RUNTIME_ERROR,"import sys

def main():
    input_data = sys.stdin.readline().strip().split()
    position = 1
    stones = input_data[0]
    instructions = input_data[1]
    
    for i in range(len(instructions)):
        if instructions[i] == stones[position-1]:
            position += 1
    
    if position > len(stones):
        print(len(stones))
    else:
        print(position)

if __name__ == ""__main__"":
    main()","s = input().strip()
t = input().strip()

position = 0

for instruction in t:

    if position < len(s) and s[position] == instruction:
        position += 1

print(position + 1)"
749,A,Bachgold Problem,PROGRAMMING,"['greedy', 'implementation', 'math', 'number theory']","Bachgold problem is very easy to formulate. Given a positive integer *n* represent it as a sum of maximum possible number of prime numbers. One can prove that such representation exists for any integer greater than 1.

Recall that integer *k* is called prime if it is greater than 1 and has exactly two positive integer divisors — 1 and *k*.",The only line of the input contains a single integer *n* (2<=≤<=*n*<=≤<=100<=000).,"The first line of the output contains a single integer *k* — maximum possible number of primes in representation.

The second line should contain *k* primes with their sum equal to *n*. You can print them in any order. If there are several optimal solution, print any of them.","['5\n', '6\n']","['2\n2 3\n', '3\n2 2 2\n']",none,WRONG_ANSWER,"n = int(input())

if n % 2 == 0:
    result = n // 2
    print(result)
    print('2 ' * result)

else:
    ...","def bachgold_problem(n):

    if n % 2 == 0:
        k = n // 2
        primes = [2] * k
    else:
        k = (n // 2) + 1
        primes = [2] * (k - 1) + [3]

    print(k)
    print("" "".join(map(str, primes)))

n = int(input().strip())
bachgold_problem(n)"
466,A,Cheap Travel,PROGRAMMING,['implementation'],"Ann has recently started commuting by subway. We know that a one ride subway ticket costs *a* rubles. Besides, Ann found out that she can buy a special ticket for *m* rides (she can buy it several times). It costs *b* rubles. Ann did the math; she will need to use subway *n* times. Help Ann, tell her what is the minimum sum of money she will have to spend to make *n* rides?","The single line contains four space-separated integers *n*, *m*, *a*, *b* (1<=≤<=*n*,<=*m*,<=*a*,<=*b*<=≤<=1000) — the number of rides Ann has planned, the number of rides covered by the *m* ride ticket, the price of a one ride ticket and the price of an *m* ride ticket.",Print a single integer — the minimum sum in rubles that Ann will need to spend.,"['6 2 1 2\n', '5 2 2 3\n']","['6\n', '8\n']","In the first sample one of the optimal solutions is: each time buy a one ride ticket. There are other optimal solutions. For example, buy three *m* ride tickets.",WRONG_ANSWER,"import sys
def input(): return sys.stdin.readline().strip()
def getints(): return map(int,sys.stdin.readline().strip().split())

n,m,a,b = getints()
if b/m < a:
	print((n//m)*b+(n%m)*a)
else:
	print(n*a)","n, m, a, b = map(int, input().strip().split())

full_tickets_needed = n // m
remaining_rides = n % m

cost_individual = n * a

cost_m_tickets_with_individual = (full_tickets_needed * b) + (remaining_rides * a)

cost_full_m_tickets = (full_tickets_needed + (1 if remaining_rides > 0 else 0)) * b

min_cost = min(cost_individual, cost_m_tickets_with_individual, cost_full_m_tickets)

print(min_cost)"
632,C,The Smallest String Concatenation,PROGRAMMING,"['sortings', 'strings']","You're given a list of *n* strings *a*1,<=*a*2,<=...,<=*a**n*. You'd like to concatenate them together in some order such that the resulting string would be lexicographically smallest.

Given the list of strings, output the lexicographically smallest concatenation.","The first line contains integer *n* — the number of strings (1<=≤<=*n*<=≤<=5·104).

Each of the next *n* lines contains one string *a**i* (1<=≤<=|*a**i*|<=≤<=50) consisting of only lowercase English letters. The sum of string lengths will not exceed 5·104.",Print the only string *a* — the lexicographically smallest string concatenation.,"['4\nabba\nabacaba\nbcd\ner\n', '5\nx\nxx\nxxa\nxxaa\nxxaaa\n', '3\nc\ncb\ncba\n']","['abacabaabbabcder\n', 'xxaaaxxaaxxaxxx\n', 'cbacbc\n']",none,OK,"from functools import cmp_to_key
def cmp(x,y):
    if x+y>y+x:
        return 1
    else:
        return -1
a=[]
n=int(input())
for i in range(n):
	a.append(input())
ans=""""
for s in sorted(a,key=cmp_to_key(cmp)):
	ans+=s
print(ans)","from functools import cmp_to_key

def compare(x, y):

    if x + y < y + x:
        return -1
    elif x + y > y + x:
        return 1
    else:
        return 0

def smallest_concatenation(strings):

    sorted_strings = sorted(strings, key=cmp_to_key(compare))

    return ''.join(sorted_strings)

n = int(input().strip())
strings = [input().strip() for _ in range(n)]

result = smallest_concatenation(strings)
print(result)"
276,C,Little Girl and Maximum Sum,PROGRAMMING,"['data structures', 'greedy', 'implementation', 'sortings']","The little girl loves the problems on array queries very much.

One day she came across a rather well-known problem: you've got an array of $n$ elements (the elements of the array are indexed starting from 1); also, there are $q$ queries, each one is defined by a pair of integers $l_i$, $r_i$ $(1 \le l_i \le r_i \le n)$. You need to find for each query the sum of elements of the array with indexes from $l_i$ to $r_i$, inclusive.

The little girl found the problem rather boring. She decided to reorder the array elements before replying to the queries in a way that makes the sum of query replies maximum possible. Your task is to find the value of this maximum sum.","The first line contains two space-separated integers $n$ ($1 \le n \le 2\cdot10^5$) and $q$ ($1 \le q \le 2\cdot10^5$) — the number of elements in the array and the number of queries, correspondingly.

The next line contains $n$ space-separated integers $a_i$ ($1 \le a_i \le 2\cdot10^5$) — the array elements.

Each of the following $q$ lines contains two space-separated integers $l_i$ and $r_i$ ($1 \le l_i \le r_i \le n$) — the $i$-th query.","In a single line print, a single integer — the maximum sum of query replies after the array elements are reordered.

Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.","['3 3\n5 3 2\n1 2\n2 3\n1 3\n', '5 3\n5 2 4 1 3\n1 5\n2 3\n2 3\n']","['25\n', '33\n']",none,TIME_LIMIT_EXCEEDED,"def main():
	n, q = list(map(int, input().strip().split()))
	a = list(map(int, input().strip().split()))
	queries = []
	array = [0]*(n+1)
	for i in range(q):
		li, ri = list(map(int, input().strip().split()))
		for i in range(li, ri+1):
			array[i] += 1

	a.sort(reverse = True)
	array.sort(reverse = True)
	solution = 0
	for i in range(0, n):
		solution += (a[i]*array[i])

	print(str(solution))

if __name__ == '__main__':
	main()","def maximum_query_sum(n, q, array, queries):

    freq = [0] * (n + 1)

    for l, r in queries:
        freq[l] += 1
        if r + 1 <= n:
            freq[r + 1] -= 1

    for i in range(1, n + 1):
        freq[i] += freq[i - 1]

    freq = freq[1:]

    array.sort(reverse=True)
    freq.sort(reverse=True)

    max_sum = sum(a * f for a, f in zip(array, freq))

    return max_sum

n, q = map(int, input().split())
array = list(map(int, input().split()))
queries = [tuple(map(int, input().split())) for _ in range(q)]

result = maximum_query_sum(n, q, array, queries)
print(result)"
686,A,Free Ice Cream,PROGRAMMING,"['constructive algorithms', 'implementation']","After their adventure with the magic mirror Kay and Gerda have returned home and sometimes give free ice cream to kids in the summer.

At the start of the day they have *x* ice cream packs. Since the ice cream is free, people start standing in the queue before Kay and Gerda's house even in the night. Each person in the queue wants either to take several ice cream packs for himself and his friends or to give several ice cream packs to Kay and Gerda (carriers that bring ice cream have to stand in the same queue).

If a carrier with *d* ice cream packs comes to the house, then Kay and Gerda take all his packs. If a child who wants to take *d* ice cream packs comes to the house, then Kay and Gerda will give him *d* packs if they have enough ice cream, otherwise the child will get no ice cream at all and will leave in distress.

Kay wants to find the amount of ice cream they will have after all people will leave from the queue, and Gerda wants to find the number of distressed kids.","The first line contains two space-separated integers *n* and *x* (1<=≤<=*n*<=≤<=1000, 0<=≤<=*x*<=≤<=109).

Each of the next *n* lines contains a character '+' or '-', and an integer *d**i*, separated by a space (1<=≤<=*d**i*<=≤<=109). Record ""+ *d**i*"" in *i*-th line means that a carrier with *d**i* ice cream packs occupies *i*-th place from the start of the queue, and record ""- *d**i*"" means that a child who wants to take *d**i* packs stands in *i*-th place.","Print two space-separated integers — number of ice cream packs left after all operations, and number of kids that left the house in distress.","['5 7\n+ 5\n- 10\n- 20\n+ 40\n- 20\n', '5 17\n- 16\n- 2\n- 98\n+ 100\n- 98\n']","['22 1\n', '3 2\n']","Consider the first sample.
 1.  Initially Kay and Gerda have 7 packs of ice cream. 1.  Carrier brings 5 more, so now they have 12 packs. 1.  A kid asks for 10 packs and receives them. There are only 2 packs remaining. 1.  Another kid asks for 20 packs. Kay and Gerda do not have them, so the kid goes away distressed. 1.  Carrier bring 40 packs, now Kay and Gerda have 42 packs. 1.  Kid asks for 20 packs and receives them. There are 22 packs remaining.",OK,"def solve(test):
    ans = 0
    n, x = map(int, input().split())
    for i in range(n):
        c = input().split()
        if c[0] == '+':
            x += int(c[1])
        elif int(c[1]) > x:
            ans += 1
        else:
            x -= int(c[1])
    print(x, ans)
t = 1

for _ in range(t):
    solve(_ + 1)","def ice_cream_queue(n, x, actions):
    ice_cream_packs = x
    distressed_kids = 0

    for action in actions:
        operation, d = action.split()
        d = int(d)

        if operation == '+':
            ice_cream_packs += d
        elif operation == '-':
            if ice_cream_packs >= d:
                ice_cream_packs -= d
            else:
                distressed_kids += 1

    return ice_cream_packs, distressed_kids

demo_inputs = [
    (5, 7, ['+ 5', '- 10', '- 20', '+ 40', '- 20']),
    (5, 17, ['- 16', '- 2', '- 98', '+ 100', '- 98'])
]

outputs = [ice_cream_queue(n, x, actions) for n, x, actions in demo_inputs]
for output in outputs:
    print(output[0], output[1])"
489,B,BerSU Ball,PROGRAMMING,"['dfs and similar', 'dp', 'graph matchings', 'greedy', 'sortings', 'two pointers']","The Berland State University is hosting a ballroom dance in celebration of its 100500-th anniversary! *n* boys and *m* girls are already busy rehearsing waltz, minuet, polonaise and quadrille moves.

We know that several boy&amp;girl pairs are going to be invited to the ball. However, the partners' dancing skill in each pair must differ by at most one.

For each boy, we know his dancing skills. Similarly, for each girl we know her dancing skills. Write a code that can determine the largest possible number of pairs that can be formed from *n* boys and *m* girls.","The first line contains an integer *n* (1<=≤<=*n*<=≤<=100) — the number of boys. The second line contains sequence *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=100), where *a**i* is the *i*-th boy's dancing skill.

Similarly, the third line contains an integer *m* (1<=≤<=*m*<=≤<=100) — the number of girls. The fourth line contains sequence *b*1,<=*b*2,<=...,<=*b**m* (1<=≤<=*b**j*<=≤<=100), where *b**j* is the *j*-th girl's dancing skill.",Print a single number — the required maximum possible number of pairs.,"['4\n1 4 6 2\n5\n5 1 5 7 9\n', '4\n1 2 3 4\n4\n10 11 12 13\n', '5\n1 1 1 1 1\n3\n1 2 3\n']","['3\n', '0\n', '2\n']",none,WRONG_ANSWER,"n=int(input())
a=list(map(int,input().split()))
m=int(input())
b=list(map(int,input().split()))

def mod(n):
    if n<=0:
        return -1*n
    else:
        return n

a.sort()
b.sort()
count=0
for i in range(n):
    if mod(a[i]-b[0])<=1:
        count+=1
        b.pop(0)
print(count)","def max_pairs(n, boys, m, girls):

    i, j = 0, 0
    pairs = 0

    while i < n and j < m:

        if abs(boys[i] - girls[j]) <= 1:
            pairs += 1
            i += 1
            j += 1

        elif boys[i] < girls[j]:
            i += 1
        else:
            j += 1

    return pairs

n = int(input())
boys = list(map(int, input().split()))
m = int(input())
girls = list(map(int, input().split()))

result = max_pairs(n, sorted(boys), m, sorted(girls))
print(result)"
1,A,Theatre Square,PROGRAMMING,['math'],"Theatre Square in the capital city of Berland has a rectangular shape with the size *n*<=×<=*m* meters. On the occasion of the city's anniversary, a decision was taken to pave the Square with square granite flagstones. Each flagstone is of the size *a*<=×<=*a*.

What is the least number of flagstones needed to pave the Square? It's allowed to cover the surface larger than the Theatre Square, but the Square has to be covered. It's not allowed to break the flagstones. The sides of flagstones should be parallel to the sides of the Square.","The input contains three positive integer numbers in the first line: *n*,<=<=*m* and *a* (1<=≤<=<=*n*,<=*m*,<=*a*<=≤<=109).",Write the needed number of flagstones.,['6 6 4\n'],['4\n'],none,WRONG_ANSWER,"class Solution:
    def needed_flagstones(n: int, m: int, a: int) -> int:
        flagstone_count = (m * n) / (a * a)
        
        if flagstone_count != int(flagstone_count):
            flagstone_count += 1
            
        return flagstone_count","import math

n, m, a = map(int, input().split())

flagstones_length = math.ceil(n / a)
flagstones_width = math.ceil(m / a)

total_flagstones = flagstones_length * flagstones_width

print(total_flagstones)"
115,A,Party,PROGRAMMING,"['dfs and similar', 'graphs', 'trees']","A company has *n* employees numbered from 1 to *n*. Each employee either has no immediate manager or exactly one immediate manager, who is another employee with a different number. An employee *A* is said to be the superior of another employee *B* if at least one of the following is true:
 -  Employee *A* is the immediate manager of employee *B* -  Employee *B* has an immediate manager employee *C* such that employee *A* is the superior of employee *C*. 
The company will not have a managerial cycle. That is, there will not exist an employee who is the superior of his/her own immediate manager.

Today the company is going to arrange a party. This involves dividing all *n* employees into several groups: every employee must belong to exactly one group. Furthermore, within any single group, there must not be two employees *A* and *B* such that *A* is the superior of *B*.

What is the minimum number of groups that must be formed?","The first line contains integer *n* (1<=≤<=*n*<=≤<=2000) — the number of employees.

The next *n* lines contain the integers *p**i* (1<=≤<=*p**i*<=≤<=*n* or *p**i*<==<=-1). Every *p**i* denotes the immediate manager for the *i*-th employee. If *p**i* is -1, that means that the *i*-th employee does not have an immediate manager. 

It is guaranteed, that no employee will be the immediate manager of him/herself (*p**i*<=≠<=*i*). Also, there will be no managerial cycles.",Print a single integer denoting the minimum number of groups that will be formed in the party.,['5\n-1\n1\n2\n1\n-1\n'],['3\n'],"For the first example, three groups are sufficient, for example: 
 -  Employee 1 -  Employees 2 and 4 -  Employees 3 and 5",RUNTIME_ERROR,"def dfs(deep, father, son):
    answer = []

    if(not son[father]):
        return [deep-1]

    for i in son[father]:
        answer += dfs(deep+1, i, son)

    return answer

n = int(input())

son = [[] for i in range(n+1)]
for i in range(1, n+1):
    a = int(input())

    if(a == -1):
        son[0].append(i)
    else:
        son[a].append(i)

answer = dfs(1, 0, son)
print(max(answer))","def min_groups(n, managers):
    from collections import defaultdict

    graph = defaultdict(list)
    for employee in range(1, n + 1):
        manager = managers[employee - 1]
        if manager != -1:
            graph[manager].append(employee)

    def get_depth(employee):
        if employee not in graph:
            return 1

        return 1 + max(get_depth(sub) for sub in graph[employee])

    max_depth = 0
    for employee in range(1, n + 1):
        if managers[employee - 1] == -1:
            max_depth = max(max_depth, get_depth(employee))
    
    return max_depth

n = int(input().strip())
managers = [int(input().strip()) for _ in range(n)]

result = min_groups(n, managers)
print(result)"
385,B,Bear and Strings,PROGRAMMING,"['brute force', 'greedy', 'implementation', 'math', 'strings']","The bear has a string *s*<==<=*s*1*s*2... *s*|*s*| (record |*s*| is the string's length), consisting of lowercase English letters. The bear wants to count the number of such pairs of indices *i*,<=*j* (1<=≤<=*i*<=≤<=*j*<=≤<=|*s*|), that string *x*(*i*,<=*j*)<==<=*s**i**s**i*<=+<=1... *s**j* contains at least one string ""bear"" as a substring.

String *x*(*i*,<=*j*) contains string ""bear"", if there is such index *k* (*i*<=≤<=*k*<=≤<=*j*<=-<=3), that *s**k*<==<=*b*, *s**k*<=+<=1<==<=*e*, *s**k*<=+<=2<==<=*a*, *s**k*<=+<=3<==<=*r*.

Help the bear cope with the given problem.",The first line contains a non-empty string *s* (1<=≤<=|*s*|<=≤<=5000). It is guaranteed that the string only consists of lowercase English letters.,Print a single number — the answer to the problem.,"['bearbtear\n', 'bearaabearc\n']","['6\n', '20\n']","In the first sample, the following pairs (*i*, *j*) match: (1, 4), (1, 5), (1, 6), (1, 7), (1, 8), (1, 9).

In the second sample, the following pairs (*i*, *j*) match: (1,  4), (1,  5), (1,  6), (1,  7), (1,  8), (1,  9), (1,  10), (1,  11), (2,  10), (2,  11), (3,  10), (3,  11), (4,  10), (4,  11), (5,  10), (5,  11), (6,  10), (6,  11), (7,  10), (7,  11).",RUNTIME_ERROR,"'''
def count(a):
	s = 'bear'
	c = 0
	n = 0
	if(len(a)<len(s)):
		return -1
	for i in range(0,len(a)-3):
		if(s == a[i:i+4]):
			k = i - n
			k = (len(a[i+4:]))*k
			c += k+(len(a)-i+1)
			n = i
	return c-4
			

def main():
	s = input()
	print(count(s))

main()
'''
def checkDistance(nums):
	prev = -1
	for i in range(0,len(nums)):
		if nums[i] == 1:
			if(prev != -1 and i-prev<6):
				return ""NO""
			prev = i
	return ""YES""		

def main():
	test = int(input())
	for i in range(0,test):
		n = int(input())
		nums = [int(j) for j in input().split()]
		print(checkDistance(nums))

main()","def count_bear_pairs(s):
    n = len(s)
    count = 0

    for i in range(n):

        for j in range(i + 3, n):

            if 'bear' in s[i:j + 1]:
                count += 1

    return count

input_strings = ['bearbtear', 'bearaabearc']
output = []

for s in input_strings:
    result = count_bear_pairs(s)
    output.append(result)

for res in output:
    print(res)"
222,A,Shooshuns and Sequence ,PROGRAMMING,"['brute force', 'implementation']","One day shooshuns found a sequence of *n* integers, written on a blackboard. The shooshuns can perform one operation with it, the operation consists of two steps:
 1.  Find the number that goes *k*-th in the current sequence and add the same number to the end of the sequence; 1.  Delete the first number of the current sequence. 
The shooshuns wonder after how many operations all numbers on the board will be the same and whether all numbers will ever be the same.","The first line contains two space-separated integers *n* and *k* (1<=≤<=*k*<=≤<=*n*<=≤<=105).

The second line contains *n* space-separated integers: *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=105) — the sequence that the shooshuns found.","Print the minimum number of operations, required for all numbers on the blackboard to become the same. If it is impossible to achieve, print -1.","['3 2\n3 1 1\n', '3 1\n3 1 1\n']","['1\n', '-1\n']","In the first test case after the first operation the blackboard will have sequence [1, 1, 1]. So, one operation is enough to make all numbers the same. Thus, the answer equals one.

In the second test case the sequence will never consist of the same numbers. It will always contain at least two distinct numbers 3 and 1. Thus, the answer equals -1.",COMPILATION_ERROR,"using namespace std;

//const double pi = acos(-1);
long long mod = 1e9 + 7;
//int dp[100000007];
//long long f[100001];
/*long long pow(long long a, long long b, long long MOD)
{long long x=1,y=a;
 while(b > 0){if(b%2 == 1){x=(x*y);if(x>MOD) x%=MOD;}y = (y*y);if(y>MOD) y%=MOD;b /= 2;}return x;}
long long InverseEuler(long long n, long long MOD)
{return pow(n,MOD-2,MOD);}
*/
long long multicases(bool q)
{
    if(q  == 0)
        return 1;
    else
    {long long x;cin >> x;return x;}
}
void test_case()
   {
       int n,ans = 0,k;cin >> n >> k;
       set<int>l1;
       vector<int>l(n);for(int  &e : l)
       {cin >> e;l1.insert(e);}
       int sz = l1.size();
       int k1 = l[k - 1];
       for(int i = k ; i < l.size();i++)
       {
           if(l[i] != k1)
           {cout << -1;return;}
       }
       while(sz != 1)
       {
           l.push_back(k1);
           if(l.at(0) != k1)
            sz--;
           l.erase(l.begin());
           ans++;
       }
       cout << ans;

   }
int main()
{

    std::ios_base::sync_with_stdio(0);
    std::cin.tie(nullptr),std::cout.tie(nullptr);

    long long t = multicases(0);
    //cin.ignore();
    while(t--)
    {test_case();}
    return 0;
}","def minimum_operations(n, k, sequence):

    target_number = sequence[k - 1]

    if all(num == target_number for num in sequence):
        return 0

    operations = 0
    for i in range(n - 1, -1, -1):
        if sequence[i] != target_number:
            break
        operations += 1

    if n - operations == k:
        return operations
    else:
        return -1

input_data = input().strip().splitlines()
n, k = map(int, input_data[0].split())
sequence = list(map(int, input_data[1].split()))

result = minimum_operations(n, k, sequence)

print(result)"
121,A,Lucky Sum,PROGRAMMING,['implementation'],"Petya loves lucky numbers. Everybody knows that lucky numbers are positive integers whose decimal representation contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.

Let *next*(*x*) be the minimum lucky number which is larger than or equals *x*. Petya is interested what is the value of the expression *next*(*l*)<=+<=*next*(*l*<=+<=1)<=+<=...<=+<=*next*(*r*<=-<=1)<=+<=*next*(*r*). Help him solve this problem.",The single line contains two integers *l* and *r* (1<=≤<=*l*<=≤<=*r*<=≤<=109) — the left and right interval limits.,"In the single line print the only number — the sum *next*(*l*)<=+<=*next*(*l*<=+<=1)<=+<=...<=+<=*next*(*r*<=-<=1)<=+<=*next*(*r*).

Please do not use the %lld specificator to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specificator.","['2 7\n', '7 7\n']","['33\n', '7\n']","In the first sample: *next*(2) + *next*(3) + *next*(4) + *next*(5) + *next*(6) + *next*(7) = 4 + 4 + 4 + 7 + 7 + 7 = 33

In the second sample: *next*(7) = 7",TIME_LIMIT_EXCEEDED,"from sys import stdin, stdout
import math
from itertools import permutations, combinations
from itertools import combinations_with_replacement
from collections import defaultdict
from bisect import bisect_right
 
def L():
    return list(map(int, stdin.readline().split()))
 
def In():
    return map(int, stdin.readline().split())
 
def I():
    return int(stdin.readline())
 
P = 1000000007
arr = [4, 7, 44, 47, 74, 77, 444, 447, 474, 477, 744, 747, 774, 777, 4444, 4447, 4474, 4477, 4744, 4747, 4774, 4777, 7444, 7447, 7474, 7477, 7744, 7747, 7774, 7777, 44444, 44447, 44474, 44477, 44744, 44747, 44774, 44777, 47444, 47447, 47474, 47477, 47744, 47747, 47774, 47777, 74444, 74447, 74474, 74477, 74744, 74747, 74774, 74777, 77444, 77447, 77474, 77477, 77744, 77747, 77774, 77777, 444444, 444447, 444474, 444477, 444744, 444747, 444774, 444777, 447444, 447447, 447474, 447477, 447744, 447747, 447774, 447777, 474444, 474447, 474474, 474477, 474744, 474747, 474774, 474777, 477444, 477447, 477474, 477477, 477744, 477747, 477774, 477777, 744444, 744447, 744474, 744477, 744744, 744747, 744774, 744777, 747444, 747447, 747474, 747477, 747744, 747747, 747774, 747777, 774444, 774447, 774474, 774477, 774744, 774747, 774774, 774777, 777444, 777447, 777474, 777477, 777744, 777747, 777774, 777777, 4444444, 4444447, 4444474, 4444477, 4444744, 4444747, 4444774, 4444777, 4447444, 4447447, 4447474, 4447477, 4447744, 4447747, 4447774, 4447777, 4474444, 4474447, 4474474, 4474477, 4474744, 4474747, 4474774, 4474777, 4477444, 4477447, 4477474, 4477477, 4477744, 4477747, 4477774, 4477777, 4744444, 4744447, 4744474, 4744477, 4744744, 4744747, 4744774, 4744777, 4747444, 4747447, 4747474, 4747477, 4747744, 4747747, 4747774, 4747777, 4774444, 4774447, 4774474, 4774477, 4774744, 4774747, 4774774, 4774777, 4777444, 4777447, 4777474, 4777477, 4777744, 4777747, 4777774, 4777777, 7444444, 7444447, 7444474, 7444477, 7444744, 7444747, 7444774, 7444777, 7447444, 7447447, 7447474, 7447477, 7447744, 7447747, 7447774, 7447777, 7474444, 7474447, 7474474, 7474477, 7474744, 7474747, 7474774, 7474777, 7477444, 7477447, 7477474, 7477477, 7477744, 7477747, 7477774, 7477777, 7744444, 7744447, 7744474, 7744477, 7744744, 7744747, 7744774, 7744777, 7747444, 7747447, 7747474, 7747477, 7747744, 7747747, 7747774, 7747777, 7774444, 7774447, 7774474, 7774477, 7774744, 7774747, 7774774, 7774777, 7777444, 7777447, 7777474, 7777477, 7777744, 7777747, 7777774, 7777777, 44444444, 44444447, 44444474, 44444477, 44444744, 44444747, 44444774, 44444777, 44447444, 44447447, 44447474, 44447477, 44447744, 44447747, 44447774, 44447777, 44474444, 44474447, 44474474, 44474477, 44474744, 44474747, 44474774, 44474777, 44477444, 44477447, 44477474, 44477477, 44477744, 44477747, 44477774, 44477777, 44744444, 44744447, 44744474, 44744477, 44744744, 44744747, 44744774, 44744777, 44747444, 44747447, 44747474, 44747477, 44747744, 44747747, 44747774, 44747777, 44774444, 44774447, 44774474, 44774477, 44774744, 44774747, 44774774, 44774777, 44777444, 44777447, 44777474, 44777477, 44777744, 44777747, 44777774, 44777777, 47444444, 47444447, 47444474, 47444477, 47444744, 47444747, 47444774, 47444777, 47447444, 47447447, 47447474, 47447477, 47447744, 47447747, 47447774, 47447777, 47474444, 47474447, 47474474, 47474477, 47474744, 47474747, 47474774, 47474777, 47477444, 47477447, 47477474, 47477477, 47477744, 47477747, 47477774, 47477777, 47744444, 47744447, 47744474, 47744477, 47744744, 47744747, 47744774, 47744777, 47747444, 47747447, 47747474, 47747477, 47747744, 47747747, 47747774, 47747777, 47774444, 47774447, 47774474, 47774477, 47774744, 47774747, 47774774, 47774777, 47777444, 47777447, 47777474, 47777477, 47777744, 47777747, 47777774, 47777777, 74444444, 74444447, 74444474, 74444477, 74444744, 74444747, 74444774, 74444777, 74447444, 74447447, 74447474, 74447477, 74447744, 74447747, 74447774, 74447777, 74474444, 74474447, 74474474, 74474477, 74474744, 74474747, 74474774, 74474777, 74477444, 74477447, 74477474, 74477477, 74477744, 74477747, 74477774, 74477777, 74744444, 74744447, 74744474, 74744477, 74744744, 74744747, 74744774, 74744777, 74747444, 74747447, 74747474, 74747477, 74747744, 74747747, 74747774, 74747777, 74774444, 74774447, 74774474, 74774477, 74774744, 74774747, 74774774, 74774777, 74777444, 74777447, 74777474, 74777477, 74777744, 74777747, 74777774, 74777777, 77444444, 77444447, 77444474, 77444477, 77444744, 77444747, 77444774, 77444777, 77447444, 77447447, 77447474, 77447477, 77447744, 77447747, 77447774, 77447777, 77474444, 77474447, 77474474, 77474477, 77474744, 77474747, 77474774, 77474777, 77477444, 77477447, 77477474, 77477477, 77477744, 77477747, 77477774, 77477777, 77744444, 77744447, 77744474, 77744477, 77744744, 77744747, 77744774, 77744777, 77747444, 77747447, 77747474, 77747477, 77747744, 77747747, 77747774, 77747777, 77774444, 77774447, 77774474, 77774477, 77774744, 77774747, 77774774, 77774777, 77777444, 77777447, 77777474, 77777477, 77777744, 77777747, 77777774, 77777777, 444444444, 444444447, 444444474, 444444477, 444444744, 444444747, 444444774, 444444777, 444447444, 444447447, 444447474, 444447477, 444447744, 444447747, 444447774, 444447777, 444474444, 444474447, 444474474, 444474477, 444474744, 444474747, 444474774, 444474777, 444477444, 444477447, 444477474, 444477477, 444477744, 444477747, 444477774, 444477777, 444744444, 444744447, 444744474, 444744477, 444744744, 444744747, 444744774, 444744777, 444747444, 444747447, 444747474, 444747477, 444747744, 444747747, 444747774, 444747777, 444774444, 444774447, 444774474, 444774477, 444774744, 444774747, 444774774, 444774777, 444777444, 444777447, 444777474, 444777477, 444777744, 444777747, 444777774, 444777777, 447444444, 447444447, 447444474, 447444477, 447444744, 447444747, 447444774, 447444777, 447447444, 447447447, 447447474, 447447477, 447447744, 447447747, 447447774, 447447777, 447474444, 447474447, 447474474, 447474477, 447474744, 447474747, 447474774, 447474777, 447477444, 447477447, 447477474, 447477477, 447477744, 447477747, 447477774, 447477777, 447744444, 447744447, 447744474, 447744477, 447744744, 447744747, 447744774, 447744777, 447747444, 447747447, 447747474, 447747477, 447747744, 447747747, 447747774, 447747777, 447774444, 447774447, 447774474, 447774477, 447774744, 447774747, 447774774, 447774777, 447777444, 447777447, 447777474, 447777477, 447777744, 447777747, 447777774, 447777777, 474444444, 474444447, 474444474, 474444477, 474444744, 474444747, 474444774, 474444777, 474447444, 474447447, 474447474, 474447477, 474447744, 474447747, 474447774, 474447777, 474474444, 474474447, 474474474, 474474477, 474474744, 474474747, 474474774, 474474777, 474477444, 474477447, 474477474, 474477477, 474477744, 474477747, 474477774, 474477777, 474744444, 474744447, 474744474, 474744477, 474744744, 474744747, 474744774, 474744777, 474747444, 474747447, 474747474, 474747477, 474747744, 474747747, 474747774, 474747777, 474774444, 474774447, 474774474, 474774477, 474774744, 474774747, 474774774, 474774777, 474777444, 474777447, 474777474, 474777477, 474777744, 474777747, 474777774, 474777777, 477444444, 477444447, 477444474, 477444477, 477444744, 477444747, 477444774, 477444777, 477447444, 477447447, 477447474, 477447477, 477447744, 477447747, 477447774, 477447777, 477474444, 477474447, 477474474, 477474477, 477474744, 477474747, 477474774, 477474777, 477477444, 477477447, 477477474, 477477477, 477477744, 477477747, 477477774, 477477777, 477744444, 477744447, 477744474, 477744477, 477744744, 477744747, 477744774, 477744777, 477747444, 477747447, 477747474, 477747477, 477747744, 477747747, 477747774, 477747777, 477774444, 477774447, 477774474, 477774477, 477774744, 477774747, 477774774, 477774777, 477777444, 477777447, 477777474, 477777477, 477777744, 477777747, 477777774, 477777777, 744444444, 744444447, 744444474, 744444477, 744444744, 744444747, 744444774, 744444777, 744447444, 744447447, 744447474, 744447477, 744447744, 744447747, 744447774, 744447777, 744474444, 744474447, 744474474, 744474477, 744474744, 744474747, 744474774, 744474777, 744477444, 744477447, 744477474, 744477477, 744477744, 744477747, 744477774, 744477777, 744744444, 744744447, 744744474, 744744477, 744744744, 744744747, 744744774, 744744777, 744747444, 744747447, 744747474, 744747477, 744747744, 744747747, 744747774, 744747777, 744774444, 744774447, 744774474, 744774477, 744774744, 744774747, 744774774, 744774777, 744777444, 744777447, 744777474, 744777477, 744777744, 744777747, 744777774, 744777777, 747444444, 747444447, 747444474, 747444477, 747444744, 747444747, 747444774, 747444777, 747447444, 747447447, 747447474, 747447477, 747447744, 747447747, 747447774, 747447777, 747474444, 747474447, 747474474, 747474477, 747474744, 747474747, 747474774, 747474777, 747477444, 747477447, 747477474, 747477477, 747477744, 747477747, 747477774, 747477777, 747744444, 747744447, 747744474, 747744477, 747744744, 747744747, 747744774, 747744777, 747747444, 747747447, 747747474, 747747477, 747747744, 747747747, 747747774, 747747777, 747774444, 747774447, 747774474, 747774477, 747774744, 747774747, 747774774, 747774777, 747777444, 747777447, 747777474, 747777477, 747777744, 747777747, 747777774, 747777777, 774444444, 774444447, 774444474, 774444477, 774444744, 774444747, 774444774, 774444777, 774447444, 774447447, 774447474, 774447477, 774447744, 774447747, 774447774, 774447777, 774474444, 774474447, 774474474, 774474477, 774474744, 774474747, 774474774, 774474777, 774477444, 774477447, 774477474, 774477477, 774477744, 774477747, 774477774, 774477777, 774744444, 774744447, 774744474, 774744477, 774744744, 774744747, 774744774, 774744777, 774747444, 774747447, 774747474, 774747477, 774747744, 774747747, 774747774, 774747777, 774774444, 774774447, 774774474, 774774477, 774774744, 774774747, 774774774, 774774777, 774777444, 774777447, 774777474, 774777477, 774777744, 774777747, 774777774, 774777777, 777444444, 777444447, 777444474, 777444477, 777444744, 777444747, 777444774, 777444777, 777447444, 777447447, 777447474, 777447477, 777447744, 777447747, 777447774, 777447777, 777474444, 777474447, 777474474, 777474477, 777474744, 777474747, 777474774, 777474777, 777477444, 777477447, 777477474, 777477477, 777477744, 777477747, 777477774, 777477777, 777744444, 777744447, 777744474, 777744477, 777744744, 777744747, 777744774, 777744777, 777747444, 777747447, 777747474, 777747477, 777747744, 777747747, 777747774, 777747777, 777774444, 777774447, 777774474, 777774477, 777774744, 777774747, 777774774, 777774777, 777777444, 777777447, 777777474, 777777477, 777777744, 777777747, 777777774, 777777777, 4444444444, 4444444447, 4444444474, 4444444477, 4444444744, 4444444747, 4444444774, 4444444777, 4444447444, 4444447447, 4444447474, 4444447477, 4444447744, 4444447747, 4444447774, 4444447777, 4444474444, 4444474447, 4444474474, 4444474477, 4444474744, 4444474747, 4444474774, 4444474777, 4444477444, 4444477447, 4444477474, 4444477477, 4444477744, 4444477747, 4444477774, 4444477777, 4444744444, 4444744447, 4444744474, 4444744477, 4444744744, 4444744747, 4444744774, 4444744777, 4444747444, 4444747447, 4444747474, 4444747477, 4444747744, 4444747747, 4444747774, 4444747777, 4444774444, 4444774447, 4444774474, 4444774477, 4444774744, 4444774747, 4444774774, 4444774777, 4444777444, 4444777447, 4444777474, 4444777477, 4444777744, 4444777747, 4444777774, 4444777777, 4447444444, 4447444447, 4447444474, 4447444477, 4447444744, 4447444747, 4447444774, 4447444777, 4447447444, 4447447447, 4447447474, 4447447477, 4447447744, 4447447747, 4447447774, 4447447777, 4447474444, 4447474447, 4447474474, 4447474477, 4447474744, 4447474747, 4447474774, 4447474777, 4447477444, 4447477447, 4447477474, 4447477477, 4447477744, 4447477747, 4447477774, 4447477777, 4447744444, 4447744447, 4447744474, 4447744477, 4447744744, 4447744747, 4447744774, 4447744777, 4447747444, 4447747447, 4447747474, 4447747477, 4447747744, 4447747747, 4447747774, 4447747777, 4447774444, 4447774447, 4447774474, 4447774477, 4447774744, 4447774747, 4447774774, 4447774777, 4447777444, 4447777447, 4447777474, 4447777477, 4447777744, 4447777747, 4447777774, 4447777777, 4474444444, 4474444447, 4474444474, 4474444477, 4474444744, 4474444747, 4474444774, 4474444777, 4474447444, 4474447447, 4474447474, 4474447477, 4474447744, 4474447747, 4474447774, 4474447777, 4474474444, 4474474447, 4474474474, 4474474477, 4474474744, 4474474747, 4474474774, 4474474777, 4474477444, 4474477447, 4474477474, 4474477477, 4474477744, 4474477747, 4474477774, 4474477777, 4474744444, 4474744447, 4474744474, 4474744477, 4474744744, 4474744747, 4474744774, 4474744777, 4474747444, 4474747447, 4474747474, 4474747477, 4474747744, 4474747747, 4474747774, 4474747777, 4474774444, 4474774447, 4474774474, 4474774477, 4474774744, 4474774747, 4474774774, 4474774777, 4474777444, 4474777447, 4474777474, 4474777477, 4474777744, 4474777747, 4474777774, 4474777777, 4477444444, 4477444447, 4477444474, 4477444477, 4477444744, 4477444747, 4477444774, 4477444777, 4477447444, 4477447447, 4477447474, 4477447477, 4477447744, 4477447747, 4477447774, 4477447777, 4477474444, 4477474447, 4477474474, 4477474477, 4477474744, 4477474747, 4477474774, 4477474777, 4477477444, 4477477447, 4477477474, 4477477477, 4477477744, 4477477747, 4477477774, 4477477777, 4477744444, 4477744447, 4477744474, 4477744477, 4477744744, 4477744747, 4477744774, 4477744777, 4477747444, 4477747447, 4477747474, 4477747477, 4477747744, 4477747747, 4477747774, 4477747777, 4477774444, 4477774447, 4477774474, 4477774477, 4477774744, 4477774747, 4477774774, 4477774777, 4477777444, 4477777447, 4477777474, 4477777477, 4477777744, 4477777747, 4477777774, 4477777777, 4744444444, 4744444447, 4744444474, 4744444477, 4744444744, 4744444747, 4744444774, 4744444777, 4744447444, 4744447447, 4744447474, 4744447477, 4744447744, 4744447747, 4744447774, 4744447777, 4744474444, 4744474447, 4744474474, 4744474477, 4744474744, 4744474747, 4744474774, 4744474777, 4744477444, 4744477447, 4744477474, 4744477477, 4744477744, 4744477747, 4744477774, 4744477777, 4744744444, 4744744447, 4744744474, 4744744477, 4744744744, 4744744747, 4744744774, 4744744777, 4744747444, 4744747447, 4744747474, 4744747477, 4744747744, 4744747747, 4744747774, 4744747777, 4744774444, 4744774447, 4744774474, 4744774477, 4744774744, 4744774747, 4744774774, 4744774777, 4744777444, 4744777447, 4744777474, 4744777477, 4744777744, 4744777747, 4744777774, 4744777777, 4747444444, 4747444447, 4747444474, 4747444477, 4747444744, 4747444747, 4747444774, 4747444777, 4747447444, 4747447447, 4747447474, 4747447477, 4747447744, 4747447747, 4747447774, 4747447777, 4747474444, 4747474447, 4747474474, 4747474477, 4747474744, 4747474747, 4747474774, 4747474777, 4747477444, 4747477447, 4747477474, 4747477477, 4747477744, 4747477747, 4747477774, 4747477777, 4747744444, 4747744447, 4747744474, 4747744477, 4747744744, 4747744747, 4747744774, 4747744777, 4747747444, 4747747447, 4747747474, 4747747477, 4747747744, 4747747747, 4747747774, 4747747777, 4747774444, 4747774447, 4747774474, 4747774477, 4747774744, 4747774747, 4747774774, 4747774777, 4747777444, 4747777447, 4747777474, 4747777477, 4747777744, 4747777747, 4747777774, 4747777777, 4774444444, 4774444447, 4774444474, 4774444477, 4774444744, 4774444747, 4774444774, 4774444777, 4774447444, 4774447447, 4774447474, 4774447477, 4774447744, 4774447747, 4774447774, 4774447777, 4774474444, 4774474447, 4774474474, 4774474477, 4774474744, 4774474747, 4774474774, 4774474777, 4774477444, 4774477447, 4774477474, 4774477477, 4774477744, 4774477747, 4774477774, 4774477777, 4774744444, 4774744447, 4774744474, 4774744477, 4774744744, 4774744747, 4774744774, 4774744777, 4774747444, 4774747447, 4774747474, 4774747477, 4774747744, 4774747747, 4774747774, 4774747777, 4774774444, 4774774447, 4774774474, 4774774477, 4774774744, 4774774747, 4774774774, 4774774777, 4774777444, 4774777447, 4774777474, 4774777477, 4774777744, 4774777747, 4774777774, 4774777777, 4777444444, 4777444447, 4777444474, 4777444477, 4777444744, 4777444747, 4777444774, 4777444777, 4777447444, 4777447447, 4777447474, 4777447477, 4777447744, 4777447747, 4777447774, 4777447777, 4777474444, 4777474447, 4777474474, 4777474477, 4777474744, 4777474747, 4777474774, 4777474777, 4777477444, 4777477447, 4777477474, 4777477477, 4777477744, 4777477747, 4777477774, 4777477777, 4777744444, 4777744447, 4777744474, 4777744477, 4777744744, 4777744747, 4777744774, 4777744777, 4777747444, 4777747447, 4777747474, 4777747477, 4777747744, 4777747747, 4777747774, 4777747777, 4777774444, 4777774447, 4777774474, 4777774477, 4777774744, 4777774747, 4777774774, 4777774777, 4777777444, 4777777447, 4777777474, 4777777477, 4777777744, 4777777747, 4777777774, 4777777777, 7444444444, 7444444447, 7444444474, 7444444477, 7444444744, 7444444747, 7444444774, 7444444777, 7444447444, 7444447447, 7444447474, 7444447477, 7444447744, 7444447747, 7444447774, 7444447777, 7444474444, 7444474447, 7444474474, 7444474477, 7444474744, 7444474747, 7444474774, 7444474777, 7444477444, 7444477447, 7444477474, 7444477477, 7444477744, 7444477747, 7444477774, 7444477777, 7444744444, 7444744447, 7444744474, 7444744477, 7444744744, 7444744747, 7444744774, 7444744777, 7444747444, 7444747447, 7444747474, 7444747477, 7444747744, 7444747747, 7444747774, 7444747777, 7444774444, 7444774447, 7444774474, 7444774477, 7444774744, 7444774747, 7444774774, 7444774777, 7444777444, 7444777447, 7444777474, 7444777477, 7444777744, 7444777747, 7444777774, 7444777777, 7447444444, 7447444447, 7447444474, 7447444477, 7447444744, 7447444747, 7447444774, 7447444777, 7447447444, 7447447447, 7447447474, 7447447477, 7447447744, 7447447747, 7447447774, 7447447777, 7447474444, 7447474447, 7447474474, 7447474477, 7447474744, 7447474747, 7447474774, 7447474777, 7447477444, 7447477447, 7447477474, 7447477477, 7447477744, 7447477747, 7447477774, 7447477777, 7447744444, 7447744447, 7447744474, 7447744477, 7447744744, 7447744747, 7447744774, 7447744777, 7447747444, 7447747447, 7447747474, 7447747477, 7447747744, 7447747747, 7447747774, 7447747777, 7447774444, 7447774447, 7447774474, 7447774477, 7447774744, 7447774747, 7447774774, 7447774777, 7447777444, 7447777447, 7447777474, 7447777477, 7447777744, 7447777747, 7447777774, 7447777777, 7474444444, 7474444447, 7474444474, 7474444477, 7474444744, 7474444747, 7474444774, 7474444777, 7474447444, 7474447447, 7474447474, 7474447477, 7474447744, 7474447747, 7474447774, 7474447777, 7474474444, 7474474447, 7474474474, 7474474477, 7474474744, 7474474747, 7474474774, 7474474777, 7474477444, 7474477447, 7474477474, 7474477477, 7474477744, 7474477747, 7474477774, 7474477777, 7474744444, 7474744447, 7474744474, 7474744477, 7474744744, 7474744747, 7474744774, 7474744777, 7474747444, 7474747447, 7474747474, 7474747477, 7474747744, 7474747747, 7474747774, 7474747777, 7474774444, 7474774447, 7474774474, 7474774477, 7474774744, 7474774747, 7474774774, 7474774777, 7474777444, 7474777447, 7474777474, 7474777477, 7474777744, 7474777747, 7474777774, 7474777777, 7477444444, 7477444447, 7477444474, 7477444477, 7477444744, 7477444747, 7477444774, 7477444777, 7477447444, 7477447447, 7477447474, 7477447477, 7477447744, 7477447747, 7477447774, 7477447777, 7477474444, 7477474447, 7477474474, 7477474477, 7477474744, 7477474747, 7477474774, 7477474777, 7477477444, 7477477447, 7477477474, 7477477477, 7477477744, 7477477747, 7477477774, 7477477777, 7477744444, 7477744447, 7477744474, 7477744477, 7477744744, 7477744747, 7477744774, 7477744777, 7477747444, 7477747447, 7477747474, 7477747477, 7477747744, 7477747747, 7477747774, 7477747777, 7477774444, 7477774447, 7477774474, 7477774477, 7477774744, 7477774747, 7477774774, 7477774777, 7477777444, 7477777447, 7477777474, 7477777477, 7477777744, 7477777747, 7477777774, 7477777777, 7744444444, 7744444447, 7744444474, 7744444477, 7744444744, 7744444747, 7744444774, 7744444777, 7744447444, 7744447447, 7744447474, 7744447477, 7744447744, 7744447747, 7744447774, 7744447777, 7744474444, 7744474447, 7744474474, 7744474477, 7744474744, 7744474747, 7744474774, 7744474777, 7744477444, 7744477447, 7744477474, 7744477477, 7744477744, 7744477747, 7744477774, 7744477777, 7744744444, 7744744447, 7744744474, 7744744477, 7744744744, 7744744747, 7744744774, 7744744777, 7744747444, 7744747447, 7744747474, 7744747477, 7744747744, 7744747747, 7744747774, 7744747777, 7744774444, 7744774447, 7744774474, 7744774477, 7744774744, 7744774747, 7744774774, 7744774777, 7744777444, 7744777447, 7744777474, 7744777477, 7744777744, 7744777747, 7744777774, 7744777777, 7747444444, 7747444447, 7747444474, 7747444477, 7747444744, 7747444747, 7747444774, 7747444777, 7747447444, 7747447447, 7747447474, 7747447477, 7747447744, 7747447747, 7747447774, 7747447777, 7747474444, 7747474447, 7747474474, 7747474477, 7747474744, 7747474747, 7747474774, 7747474777, 7747477444, 7747477447, 7747477474, 7747477477, 7747477744, 7747477747, 7747477774, 7747477777, 7747744444, 7747744447, 7747744474, 7747744477, 7747744744, 7747744747, 7747744774, 7747744777, 7747747444, 7747747447, 7747747474, 7747747477, 7747747744, 7747747747, 7747747774, 7747747777, 7747774444, 7747774447, 7747774474, 7747774477, 7747774744, 7747774747, 7747774774, 7747774777, 7747777444, 7747777447, 7747777474, 7747777477, 7747777744, 7747777747, 7747777774, 7747777777, 7774444444, 7774444447, 7774444474, 7774444477, 7774444744, 7774444747, 7774444774, 7774444777, 7774447444, 7774447447, 7774447474, 7774447477, 7774447744, 7774447747, 7774447774, 7774447777, 7774474444, 7774474447, 7774474474, 7774474477, 7774474744, 7774474747, 7774474774, 7774474777, 7774477444, 7774477447, 7774477474, 7774477477, 7774477744, 7774477747, 7774477774, 7774477777, 7774744444, 7774744447, 7774744474, 7774744477, 7774744744, 7774744747, 7774744774, 7774744777, 7774747444, 7774747447, 7774747474, 7774747477, 7774747744, 7774747747, 7774747774, 7774747777, 7774774444, 7774774447, 7774774474, 7774774477, 7774774744, 7774774747, 7774774774, 7774774777, 7774777444, 7774777447, 7774777474, 7774777477, 7774777744, 7774777747, 7774777774, 7774777777, 7777444444, 7777444447, 7777444474, 7777444477, 7777444744, 7777444747, 7777444774, 7777444777, 7777447444, 7777447447, 7777447474, 7777447477, 7777447744, 7777447747, 7777447774, 7777447777, 7777474444, 7777474447, 7777474474, 7777474477, 7777474744, 7777474747, 7777474774, 7777474777, 7777477444, 7777477447, 7777477474, 7777477477, 7777477744, 7777477747, 7777477774, 7777477777, 7777744444, 7777744447, 7777744474, 7777744477, 7777744744, 7777744747, 7777744774, 7777744777, 7777747444, 7777747447, 7777747474, 7777747477, 7777747744, 7777747747, 7777747774, 7777747777, 7777774444, 7777774447, 7777774474, 7777774477, 7777774744, 7777774747, 7777774774, 7777774777, 7777777444, 7777777447, 7777777474, 7777777477, 7777777744, 7777777747, 7777777774, 7777777777, 44444444444, 44444444447, 44444444474, 44444444477, 44444444744, 44444444747, 44444444774, 44444444777, 44444447444, 44444447447, 44444447474, 44444447477, 44444447744, 44444447747, 44444447774, 44444447777, 44444474444, 44444474447, 44444474474, 44444474477, 44444474744, 44444474747, 44444474774, 44444474777, 44444477444, 44444477447, 44444477474, 44444477477, 44444477744, 44444477747, 44444477774, 44444477777, 44444744444, 44444744447, 44444744474, 44444744477, 44444744744, 44444744747, 44444744774, 44444744777, 44444747444, 44444747447, 44444747474, 44444747477, 44444747744, 44444747747, 44444747774, 44444747777, 44444774444, 44444774447, 44444774474, 44444774477, 44444774744, 44444774747, 44444774774, 44444774777, 44444777444, 44444777447, 44444777474, 44444777477, 44444777744, 44444777747, 44444777774, 44444777777, 44447444444, 44447444447, 44447444474, 44447444477, 44447444744, 44447444747, 44447444774, 44447444777, 44447447444, 44447447447, 44447447474, 44447447477, 44447447744, 44447447747, 44447447774, 44447447777, 44447474444, 44447474447, 44447474474, 44447474477, 44447474744, 44447474747, 44447474774, 44447474777, 44447477444, 44447477447, 44447477474, 44447477477, 44447477744, 44447477747, 44447477774, 44447477777, 44447744444, 44447744447, 44447744474, 44447744477, 44447744744, 44447744747, 44447744774, 44447744777, 44447747444, 44447747447, 44447747474, 44447747477, 44447747744, 44447747747, 44447747774, 44447747777, 44447774444, 44447774447, 44447774474, 44447774477, 44447774744, 44447774747, 44447774774, 44447774777, 44447777444, 44447777447, 44447777474, 44447777477, 44447777744, 44447777747, 44447777774, 44447777777, 44474444444, 44474444447, 44474444474, 44474444477, 44474444744, 44474444747, 44474444774, 44474444777, 44474447444, 44474447447, 44474447474, 44474447477, 44474447744, 44474447747, 44474447774, 44474447777, 44474474444, 44474474447, 44474474474, 44474474477, 44474474744, 44474474747, 44474474774, 44474474777, 44474477444, 44474477447, 44474477474, 44474477477, 44474477744, 44474477747, 44474477774, 44474477777, 44474744444, 44474744447, 44474744474, 44474744477, 44474744744, 44474744747, 44474744774, 44474744777, 44474747444, 44474747447, 44474747474, 44474747477, 44474747744, 44474747747, 44474747774, 44474747777, 44474774444, 44474774447, 44474774474, 44474774477, 44474774744, 44474774747, 44474774774, 44474774777, 44474777444, 44474777447, 44474777474, 44474777477, 44474777744, 44474777747, 44474777774, 44474777777, 44477444444, 44477444447, 44477444474, 44477444477, 44477444744, 44477444747, 44477444774, 44477444777, 44477447444, 44477447447, 44477447474, 44477447477, 44477447744, 44477447747, 44477447774, 44477447777, 44477474444, 44477474447, 44477474474, 44477474477, 44477474744, 44477474747, 44477474774, 44477474777, 44477477444, 44477477447, 44477477474, 44477477477, 44477477744, 44477477747, 44477477774, 44477477777, 44477744444, 44477744447, 44477744474, 44477744477, 44477744744, 44477744747, 44477744774, 44477744777, 44477747444, 44477747447, 44477747474, 44477747477, 44477747744, 44477747747, 44477747774, 44477747777, 44477774444, 44477774447, 44477774474, 44477774477, 44477774744, 44477774747, 44477774774, 44477774777, 44477777444, 44477777447, 44477777474, 44477777477, 44477777744, 44477777747, 44477777774, 44477777777, 44744444444, 44744444447, 44744444474, 44744444477, 44744444744, 44744444747, 44744444774, 44744444777, 44744447444, 44744447447, 44744447474, 44744447477, 44744447744, 44744447747, 44744447774, 44744447777, 44744474444, 44744474447, 44744474474, 44744474477, 44744474744, 44744474747, 44744474774, 44744474777, 44744477444, 44744477447, 44744477474, 44744477477, 44744477744, 44744477747, 44744477774, 44744477777, 44744744444, 44744744447, 44744744474, 44744744477, 44744744744, 44744744747, 44744744774, 44744744777, 44744747444, 44744747447, 44744747474, 44744747477, 44744747744, 44744747747, 44744747774, 44744747777, 44744774444, 44744774447, 44744774474, 44744774477, 44744774744, 44744774747, 44744774774, 44744774777, 44744777444, 44744777447, 44744777474, 44744777477, 44744777744, 44744777747, 44744777774, 44744777777, 44747444444, 44747444447, 44747444474, 44747444477, 44747444744, 44747444747, 44747444774, 44747444777, 44747447444, 44747447447, 44747447474, 44747447477, 44747447744, 44747447747, 44747447774, 44747447777, 44747474444, 44747474447, 44747474474, 44747474477, 44747474744, 44747474747, 44747474774, 44747474777, 44747477444, 44747477447, 44747477474, 44747477477, 44747477744, 44747477747, 44747477774, 44747477777, 44747744444, 44747744447, 44747744474, 44747744477, 44747744744, 44747744747, 44747744774, 44747744777, 44747747444, 44747747447, 44747747474, 44747747477, 44747747744, 44747747747, 44747747774, 44747747777, 44747774444, 44747774447, 44747774474, 44747774477, 44747774744, 44747774747, 44747774774, 44747774777, 44747777444, 44747777447, 44747777474, 44747777477, 44747777744, 44747777747, 44747777774, 44747777777, 44774444444, 44774444447, 44774444474, 44774444477, 44774444744, 44774444747, 44774444774, 44774444777, 44774447444, 44774447447, 44774447474, 44774447477, 44774447744, 44774447747, 44774447774, 44774447777, 44774474444, 44774474447, 44774474474, 44774474477, 44774474744, 44774474747, 44774474774, 44774474777, 44774477444, 44774477447, 44774477474, 44774477477, 44774477744, 44774477747, 44774477774, 44774477777, 44774744444, 44774744447, 44774744474, 44774744477, 44774744744, 44774744747, 44774744774, 44774744777, 44774747444, 44774747447, 44774747474, 44774747477, 44774747744, 44774747747, 44774747774, 44774747777, 44774774444, 44774774447, 44774774474, 44774774477, 44774774744, 44774774747, 44774774774, 44774774777, 44774777444, 44774777447, 44774777474, 44774777477, 44774777744, 44774777747, 44774777774, 44774777777, 44777444444, 44777444447, 44777444474, 44777444477, 44777444744, 44777444747, 44777444774, 44777444777, 44777447444, 44777447447, 44777447474, 44777447477, 44777447744, 44777447747, 44777447774, 44777447777, 44777474444, 44777474447, 44777474474, 44777474477, 44777474744, 44777474747, 44777474774, 44777474777, 44777477444, 44777477447, 44777477474, 44777477477, 44777477744, 44777477747, 44777477774, 44777477777, 44777744444, 44777744447, 44777744474, 44777744477, 44777744744, 44777744747, 44777744774, 44777744777, 44777747444, 44777747447, 44777747474, 44777747477, 44777747744, 44777747747, 44777747774, 44777747777, 44777774444, 44777774447, 44777774474, 44777774477, 44777774744, 44777774747, 44777774774, 44777774777, 44777777444, 44777777447, 44777777474, 44777777477, 44777777744, 44777777747, 44777777774, 44777777777, 47444444444, 47444444447, 47444444474, 47444444477, 47444444744, 47444444747, 47444444774, 47444444777, 47444447444, 47444447447, 47444447474, 47444447477, 47444447744, 47444447747, 47444447774, 47444447777, 47444474444, 47444474447, 47444474474, 47444474477, 47444474744, 47444474747, 47444474774, 47444474777, 47444477444, 47444477447, 47444477474, 47444477477, 47444477744, 47444477747, 47444477774, 47444477777, 47444744444, 47444744447, 47444744474, 47444744477, 47444744744, 47444744747, 47444744774, 47444744777, 47444747444, 47444747447, 47444747474, 47444747477, 47444747744, 47444747747, 47444747774, 47444747777, 47444774444, 47444774447, 47444774474, 47444774477, 47444774744, 47444774747, 47444774774, 47444774777, 47444777444, 47444777447, 47444777474, 47444777477, 47444777744, 47444777747, 47444777774, 47444777777, 47447444444, 47447444447, 47447444474, 47447444477, 47447444744, 47447444747, 47447444774, 47447444777, 47447447444, 47447447447, 47447447474, 47447447477, 47447447744, 47447447747, 47447447774, 47447447777, 47447474444, 47447474447, 47447474474, 47447474477, 47447474744, 47447474747, 47447474774, 47447474777, 47447477444, 47447477447, 47447477474, 47447477477, 47447477744, 47447477747, 47447477774, 47447477777, 47447744444, 47447744447, 47447744474, 47447744477, 47447744744, 47447744747, 47447744774, 47447744777, 47447747444, 47447747447, 47447747474, 47447747477, 47447747744, 47447747747, 47447747774, 47447747777, 47447774444, 47447774447, 47447774474, 47447774477, 47447774744, 47447774747, 47447774774, 47447774777, 47447777444, 47447777447, 47447777474, 47447777477, 47447777744, 47447777747, 47447777774, 47447777777, 47474444444, 47474444447, 47474444474, 47474444477, 47474444744, 47474444747, 47474444774, 47474444777, 47474447444, 47474447447, 47474447474, 47474447477, 47474447744, 47474447747, 47474447774, 47474447777, 47474474444, 47474474447, 47474474474, 47474474477, 47474474744, 47474474747, 47474474774, 47474474777, 47474477444, 47474477447, 47474477474, 47474477477, 47474477744, 47474477747, 47474477774, 47474477777, 47474744444, 47474744447, 47474744474, 47474744477, 47474744744, 47474744747, 47474744774, 47474744777, 47474747444, 47474747447, 47474747474, 47474747477, 47474747744, 47474747747, 47474747774, 47474747777, 47474774444, 47474774447, 47474774474, 47474774477, 47474774744, 47474774747, 47474774774, 47474774777, 47474777444, 47474777447, 47474777474, 47474777477, 47474777744, 47474777747, 47474777774, 47474777777, 47477444444, 47477444447, 47477444474, 47477444477, 47477444744, 47477444747, 47477444774, 47477444777, 47477447444, 47477447447, 47477447474, 47477447477, 47477447744, 47477447747, 47477447774, 47477447777, 47477474444, 47477474447, 47477474474, 47477474477, 47477474744, 47477474747, 47477474774, 47477474777, 47477477444, 47477477447, 47477477474, 47477477477, 47477477744, 47477477747, 47477477774, 47477477777, 47477744444, 47477744447, 47477744474, 47477744477, 47477744744, 47477744747, 47477744774, 47477744777, 47477747444, 47477747447, 47477747474, 47477747477, 47477747744, 47477747747, 47477747774, 47477747777, 47477774444, 47477774447, 47477774474, 47477774477, 47477774744, 47477774747, 47477774774, 47477774777, 47477777444, 47477777447, 47477777474, 47477777477, 47477777744, 47477777747, 47477777774, 47477777777, 47744444444, 47744444447, 47744444474, 47744444477, 47744444744, 47744444747, 47744444774, 47744444777, 47744447444, 47744447447, 47744447474, 47744447477, 47744447744, 47744447747, 47744447774, 47744447777, 47744474444, 47744474447, 47744474474, 47744474477, 47744474744, 47744474747, 47744474774, 47744474777, 47744477444, 47744477447, 47744477474, 47744477477, 47744477744, 47744477747, 47744477774, 47744477777, 47744744444, 47744744447, 47744744474, 47744744477, 47744744744, 47744744747, 47744744774, 47744744777, 47744747444, 47744747447, 47744747474, 47744747477, 47744747744, 47744747747, 47744747774, 47744747777, 47744774444, 47744774447, 47744774474, 47744774477, 47744774744, 47744774747, 47744774774, 47744774777, 47744777444, 47744777447, 47744777474, 47744777477, 47744777744, 47744777747, 47744777774, 47744777777, 47747444444, 47747444447, 47747444474, 47747444477, 47747444744, 47747444747, 47747444774, 47747444777, 47747447444, 47747447447, 47747447474, 47747447477, 47747447744, 47747447747, 47747447774, 47747447777, 47747474444, 47747474447, 47747474474, 47747474477, 47747474744, 47747474747, 47747474774, 47747474777, 47747477444, 47747477447, 47747477474, 47747477477, 47747477744, 47747477747, 47747477774, 47747477777, 47747744444, 47747744447, 47747744474, 47747744477, 47747744744, 47747744747, 47747744774, 47747744777, 47747747444, 47747747447, 47747747474, 47747747477, 47747747744, 47747747747, 47747747774, 47747747777, 47747774444, 47747774447, 47747774474, 47747774477, 47747774744, 47747774747, 47747774774, 47747774777, 47747777444, 47747777447, 47747777474, 47747777477, 47747777744, 47747777747, 47747777774, 47747777777, 47774444444, 47774444447, 47774444474, 47774444477, 47774444744, 47774444747, 47774444774, 47774444777, 47774447444, 47774447447, 47774447474, 47774447477, 47774447744, 47774447747, 47774447774, 47774447777, 47774474444, 47774474447, 47774474474, 47774474477, 47774474744, 47774474747, 47774474774, 47774474777, 47774477444, 47774477447, 47774477474, 47774477477, 47774477744, 47774477747, 47774477774, 47774477777, 47774744444, 47774744447, 47774744474, 47774744477, 47774744744, 47774744747, 47774744774, 47774744777, 47774747444, 47774747447, 47774747474, 47774747477, 47774747744, 47774747747, 47774747774, 47774747777, 47774774444, 47774774447, 47774774474, 47774774477, 47774774744, 47774774747, 47774774774, 47774774777, 47774777444, 47774777447, 47774777474, 47774777477, 47774777744, 47774777747, 47774777774, 47774777777, 47777444444, 47777444447, 47777444474, 47777444477, 47777444744, 47777444747, 47777444774, 47777444777, 47777447444, 47777447447, 47777447474, 47777447477, 47777447744, 47777447747, 47777447774, 47777447777, 47777474444, 47777474447, 47777474474, 47777474477, 47777474744, 47777474747, 47777474774, 47777474777, 47777477444, 47777477447, 47777477474, 47777477477, 47777477744, 47777477747, 47777477774, 47777477777, 47777744444, 47777744447, 47777744474, 47777744477, 47777744744, 47777744747, 47777744774, 47777744777, 47777747444, 47777747447, 47777747474, 47777747477, 47777747744, 47777747747, 47777747774, 47777747777, 47777774444, 47777774447, 47777774474, 47777774477, 47777774744, 47777774747, 47777774774, 47777774777, 47777777444, 47777777447, 47777777474, 47777777477, 47777777744, 47777777747, 47777777774, 47777777777, 74444444444, 74444444447, 74444444474, 74444444477, 74444444744, 74444444747, 74444444774, 74444444777, 74444447444, 74444447447, 74444447474, 74444447477, 74444447744, 74444447747, 74444447774, 74444447777, 74444474444, 74444474447, 74444474474, 74444474477, 74444474744, 74444474747, 74444474774, 74444474777, 74444477444, 74444477447, 74444477474, 74444477477, 74444477744, 74444477747, 74444477774, 74444477777, 74444744444, 74444744447, 74444744474, 74444744477, 74444744744, 74444744747, 74444744774, 74444744777, 74444747444, 74444747447, 74444747474, 74444747477, 74444747744, 74444747747, 74444747774, 74444747777, 74444774444, 74444774447, 74444774474, 74444774477, 74444774744, 74444774747, 74444774774, 74444774777, 74444777444, 74444777447, 74444777474, 74444777477, 74444777744, 74444777747, 74444777774, 74444777777, 74447444444, 74447444447, 74447444474, 74447444477, 74447444744, 74447444747, 74447444774, 74447444777, 74447447444, 74447447447, 74447447474, 74447447477, 74447447744, 74447447747, 74447447774, 74447447777, 74447474444, 74447474447, 74447474474, 74447474477, 74447474744, 74447474747, 74447474774, 74447474777, 74447477444, 74447477447, 74447477474, 74447477477, 74447477744, 74447477747, 74447477774, 74447477777, 74447744444, 74447744447, 74447744474, 74447744477, 74447744744, 74447744747, 74447744774, 74447744777, 74447747444, 74447747447, 74447747474, 74447747477, 74447747744, 74447747747, 74447747774, 74447747777, 74447774444, 74447774447, 74447774474, 74447774477, 74447774744, 74447774747, 74447774774, 74447774777, 74447777444, 74447777447, 74447777474, 74447777477, 74447777744, 74447777747, 74447777774, 74447777777, 74474444444, 74474444447, 74474444474, 74474444477, 74474444744, 74474444747, 74474444774, 74474444777, 74474447444, 74474447447, 74474447474, 74474447477, 74474447744, 74474447747, 74474447774, 74474447777, 74474474444, 74474474447, 74474474474, 74474474477, 74474474744, 74474474747, 74474474774, 74474474777, 74474477444, 74474477447, 74474477474, 74474477477, 74474477744, 74474477747, 74474477774, 74474477777, 74474744444, 74474744447, 74474744474, 74474744477, 74474744744, 74474744747, 74474744774, 74474744777, 74474747444, 74474747447, 74474747474, 74474747477, 74474747744, 74474747747, 74474747774, 74474747777, 74474774444, 74474774447, 74474774474, 74474774477, 74474774744, 74474774747, 74474774774, 74474774777, 74474777444, 74474777447, 74474777474, 74474777477, 74474777744, 74474777747, 74474777774, 74474777777, 74477444444, 74477444447, 74477444474, 74477444477, 74477444744, 74477444747, 74477444774, 74477444777, 74477447444, 74477447447, 74477447474, 74477447477, 74477447744, 74477447747, 74477447774, 74477447777, 74477474444, 74477474447, 74477474474, 74477474477, 74477474744, 74477474747, 74477474774, 74477474777, 74477477444, 74477477447, 74477477474, 74477477477, 74477477744, 74477477747, 74477477774, 74477477777, 74477744444, 74477744447, 74477744474, 74477744477, 74477744744, 74477744747, 74477744774, 74477744777, 74477747444, 74477747447, 74477747474, 74477747477, 74477747744, 74477747747, 74477747774, 74477747777, 74477774444, 74477774447, 74477774474, 74477774477, 74477774744, 74477774747, 74477774774, 74477774777, 74477777444, 74477777447, 74477777474, 74477777477, 74477777744, 74477777747, 74477777774, 74477777777, 74744444444, 74744444447, 74744444474, 74744444477, 74744444744, 74744444747, 74744444774, 74744444777, 74744447444, 74744447447, 74744447474, 74744447477, 74744447744, 74744447747, 74744447774, 74744447777, 74744474444, 74744474447, 74744474474, 74744474477, 74744474744, 74744474747, 74744474774, 74744474777, 74744477444, 74744477447, 74744477474, 74744477477, 74744477744, 74744477747, 74744477774, 74744477777, 74744744444, 74744744447, 74744744474, 74744744477, 74744744744, 74744744747, 74744744774, 74744744777, 74744747444, 74744747447, 74744747474, 74744747477, 74744747744, 74744747747, 74744747774, 74744747777, 74744774444, 74744774447, 74744774474, 74744774477, 74744774744, 74744774747, 74744774774, 74744774777, 74744777444, 74744777447, 74744777474, 74744777477, 74744777744, 74744777747, 74744777774, 74744777777, 74747444444, 74747444447, 74747444474, 74747444477, 74747444744, 74747444747, 74747444774, 74747444777, 74747447444, 74747447447, 74747447474, 74747447477, 74747447744, 74747447747, 74747447774, 74747447777, 74747474444, 74747474447, 74747474474, 74747474477, 74747474744, 74747474747, 74747474774, 74747474777, 74747477444, 74747477447, 74747477474, 74747477477, 74747477744, 74747477747, 74747477774, 74747477777, 74747744444, 74747744447, 74747744474, 74747744477, 74747744744, 74747744747, 74747744774, 74747744777, 74747747444, 74747747447, 74747747474, 74747747477, 74747747744, 74747747747, 74747747774, 74747747777, 74747774444, 74747774447, 74747774474, 74747774477, 74747774744, 74747774747, 74747774774, 74747774777, 74747777444, 74747777447, 74747777474, 74747777477, 74747777744, 74747777747, 74747777774, 74747777777, 74774444444, 74774444447, 74774444474, 74774444477, 74774444744, 74774444747, 74774444774, 74774444777, 74774447444, 74774447447, 74774447474, 74774447477, 74774447744, 74774447747, 74774447774, 74774447777, 74774474444, 74774474447, 74774474474, 74774474477, 74774474744, 74774474747, 74774474774, 74774474777, 74774477444, 74774477447, 74774477474, 74774477477, 74774477744, 74774477747, 74774477774, 74774477777, 74774744444, 74774744447, 74774744474, 74774744477, 74774744744, 74774744747, 74774744774, 74774744777, 74774747444, 74774747447, 74774747474, 74774747477, 74774747744, 74774747747, 74774747774, 74774747777, 74774774444, 74774774447, 74774774474, 74774774477, 74774774744, 74774774747, 74774774774, 74774774777, 74774777444, 74774777447, 74774777474, 74774777477, 74774777744, 74774777747, 74774777774, 74774777777, 74777444444, 74777444447, 74777444474, 74777444477, 74777444744, 74777444747, 74777444774, 74777444777, 74777447444, 74777447447, 74777447474, 74777447477, 74777447744, 74777447747, 74777447774, 74777447777, 74777474444, 74777474447, 74777474474, 74777474477, 74777474744, 74777474747, 74777474774, 74777474777, 74777477444, 74777477447, 74777477474, 74777477477, 74777477744, 74777477747, 74777477774, 74777477777, 74777744444, 74777744447, 74777744474, 74777744477, 74777744744, 74777744747, 74777744774, 74777744777, 74777747444, 74777747447, 74777747474, 74777747477, 74777747744, 74777747747, 74777747774, 74777747777, 74777774444, 74777774447, 74777774474, 74777774477, 74777774744, 74777774747, 74777774774, 74777774777, 74777777444, 74777777447, 74777777474, 74777777477, 74777777744, 74777777747, 74777777774, 74777777777, 77444444444, 77444444447, 77444444474, 77444444477, 77444444744, 77444444747, 77444444774, 77444444777, 77444447444, 77444447447, 77444447474, 77444447477, 77444447744, 77444447747, 77444447774, 77444447777, 77444474444, 77444474447, 77444474474, 77444474477, 77444474744, 77444474747, 77444474774, 77444474777, 77444477444, 77444477447, 77444477474, 77444477477, 77444477744, 77444477747, 77444477774, 77444477777, 77444744444, 77444744447, 77444744474, 77444744477, 77444744744, 77444744747, 77444744774, 77444744777, 77444747444, 77444747447, 77444747474, 77444747477, 77444747744, 77444747747, 77444747774, 77444747777, 77444774444, 77444774447, 77444774474, 77444774477, 77444774744, 77444774747, 77444774774, 77444774777, 77444777444, 77444777447, 77444777474, 77444777477, 77444777744, 77444777747, 77444777774, 77444777777, 77447444444, 77447444447, 77447444474, 77447444477, 77447444744, 77447444747, 77447444774, 77447444777, 77447447444, 77447447447, 77447447474, 77447447477, 77447447744, 77447447747, 77447447774, 77447447777, 77447474444, 77447474447, 77447474474, 77447474477, 77447474744, 77447474747, 77447474774, 77447474777, 77447477444, 77447477447, 77447477474, 77447477477, 77447477744, 77447477747, 77447477774, 77447477777, 77447744444, 77447744447, 77447744474, 77447744477, 77447744744, 77447744747, 77447744774, 77447744777, 77447747444, 77447747447, 77447747474, 77447747477, 77447747744, 77447747747, 77447747774, 77447747777, 77447774444, 77447774447, 77447774474, 77447774477, 77447774744, 77447774747, 77447774774, 77447774777, 77447777444, 77447777447, 77447777474, 77447777477, 77447777744, 77447777747, 77447777774, 77447777777, 77474444444, 77474444447, 77474444474, 77474444477, 77474444744, 77474444747, 77474444774, 77474444777, 77474447444, 77474447447, 77474447474, 77474447477, 77474447744, 77474447747, 77474447774, 77474447777, 77474474444, 77474474447, 77474474474, 77474474477, 77474474744, 77474474747, 77474474774, 77474474777, 77474477444, 77474477447, 77474477474, 77474477477, 77474477744, 77474477747, 77474477774, 77474477777, 77474744444, 77474744447, 77474744474, 77474744477, 77474744744, 77474744747, 77474744774, 77474744777, 77474747444, 77474747447, 77474747474, 77474747477, 77474747744, 77474747747, 77474747774, 77474747777, 77474774444, 77474774447, 77474774474, 77474774477, 77474774744, 77474774747, 77474774774, 77474774777, 77474777444, 77474777447, 77474777474, 77474777477, 77474777744, 77474777747, 77474777774, 77474777777, 77477444444, 77477444447, 77477444474, 77477444477, 77477444744, 77477444747, 77477444774, 77477444777, 77477447444, 77477447447, 77477447474, 77477447477, 77477447744, 77477447747, 77477447774, 77477447777, 77477474444, 77477474447, 77477474474, 77477474477, 77477474744, 77477474747, 77477474774, 77477474777, 77477477444, 77477477447, 77477477474, 77477477477, 77477477744, 77477477747, 77477477774, 77477477777, 77477744444, 77477744447, 77477744474, 77477744477, 77477744744, 77477744747, 77477744774, 77477744777, 77477747444, 77477747447, 77477747474, 77477747477, 77477747744, 77477747747, 77477747774, 77477747777, 77477774444, 77477774447, 77477774474, 77477774477, 77477774744, 77477774747, 77477774774, 77477774777, 77477777444, 77477777447, 77477777474, 77477777477, 77477777744, 77477777747, 77477777774, 77477777777, 77744444444, 77744444447, 77744444474, 77744444477, 77744444744, 77744444747, 77744444774, 77744444777, 77744447444, 77744447447, 77744447474, 77744447477, 77744447744, 77744447747, 77744447774, 77744447777, 77744474444, 77744474447, 77744474474, 77744474477, 77744474744, 77744474747, 77744474774, 77744474777, 77744477444, 77744477447, 77744477474, 77744477477, 77744477744, 77744477747, 77744477774, 77744477777, 77744744444, 77744744447, 77744744474, 77744744477, 77744744744, 77744744747, 77744744774, 77744744777, 77744747444, 77744747447, 77744747474, 77744747477, 77744747744, 77744747747, 77744747774, 77744747777, 77744774444, 77744774447, 77744774474, 77744774477, 77744774744, 77744774747, 77744774774, 77744774777, 77744777444, 77744777447, 77744777474, 77744777477, 77744777744, 77744777747, 77744777774, 77744777777, 77747444444, 77747444447, 77747444474, 77747444477, 77747444744, 77747444747, 77747444774, 77747444777, 77747447444, 77747447447, 77747447474, 77747447477, 77747447744, 77747447747, 77747447774, 77747447777, 77747474444, 77747474447, 77747474474, 77747474477, 77747474744, 77747474747, 77747474774, 77747474777, 77747477444, 77747477447, 77747477474, 77747477477, 77747477744, 77747477747, 77747477774, 77747477777, 77747744444, 77747744447, 77747744474, 77747744477, 77747744744, 77747744747, 77747744774, 77747744777, 77747747444, 77747747447, 77747747474, 77747747477, 77747747744, 77747747747, 77747747774, 77747747777, 77747774444, 77747774447, 77747774474, 77747774477, 77747774744, 77747774747, 77747774774, 77747774777, 77747777444, 77747777447, 77747777474, 77747777477, 77747777744, 77747777747, 77747777774, 77747777777, 77774444444, 77774444447, 77774444474, 77774444477, 77774444744, 77774444747, 77774444774, 77774444777, 77774447444, 77774447447, 77774447474, 77774447477, 77774447744, 77774447747, 77774447774, 77774447777, 77774474444, 77774474447, 77774474474, 77774474477, 77774474744, 77774474747, 77774474774, 77774474777, 77774477444, 77774477447, 77774477474, 77774477477, 77774477744, 77774477747, 77774477774, 77774477777, 77774744444, 77774744447, 77774744474, 77774744477, 77774744744, 77774744747, 77774744774, 77774744777, 77774747444, 77774747447, 77774747474, 77774747477, 77774747744, 77774747747, 77774747774, 77774747777, 77774774444, 77774774447, 77774774474, 77774774477, 77774774744, 77774774747, 77774774774, 77774774777, 77774777444, 77774777447, 77774777474, 77774777477, 77774777744, 77774777747, 77774777774, 77774777777, 77777444444, 77777444447, 77777444474, 77777444477, 77777444744, 77777444747, 77777444774, 77777444777, 77777447444, 77777447447, 77777447474, 77777447477, 77777447744, 77777447747, 77777447774, 77777447777, 77777474444, 77777474447, 77777474474, 77777474477, 77777474744, 77777474747, 77777474774, 77777474777, 77777477444, 77777477447, 77777477474, 77777477477, 77777477744, 77777477747, 77777477774, 77777477777, 77777744444, 77777744447, 77777744474, 77777744477, 77777744744, 77777744747, 77777744774, 77777744777, 77777747444, 77777747447, 77777747474, 77777747477, 77777747744, 77777747747, 77777747774, 77777747777, 77777774444, 77777774447, 77777774474, 77777774477, 77777774744, 77777774747, 77777774774, 77777774777, 77777777444, 77777777447, 77777777474, 77777777477, 77777777744, 77777777747, 77777777774, 77777777777]

l, r = In()
sm = 0
for i in range(l, r+1):
    x = bisect_right(arr, i)
    if arr[x-1] == i:
        sm += i 
    else:
        sm += arr[x]
print(sm)","def is_lucky(num):
    """"""Check if a number is a lucky number.""""""
    return all(digit in '47' for digit in str(num))

def next_lucky(x):
    """"""Find the minimum lucky number that is greater than or equal to x.""""""
    while not is_lucky(x):
        x += 1
    return x

def lucky_sum(l, r):
    """"""Calculate the sum of lucky numbers from next(l) to next(r).""""""
    total_sum = 0
    for i in range(l, r + 1):
        total_sum += next_lucky(i)
    return total_sum

if __name__ == ""__main__"":

    l, r = map(int, input().strip().split())

    result = lucky_sum(l, r)
    print(result)"
446,A,DZY Loves Sequences,PROGRAMMING,"['dp', 'implementation', 'two pointers']","DZY has a sequence *a*, consisting of *n* integers.

We'll call a sequence *a**i*,<=*a**i*<=+<=1,<=...,<=*a**j* (1<=≤<=*i*<=≤<=*j*<=≤<=*n*) a subsegment of the sequence *a*. The value (*j*<=-<=*i*<=+<=1) denotes the length of the subsegment.

Your task is to find the longest subsegment of *a*, such that it is possible to change at most one number (change one number to any integer you want) from the subsegment to make the subsegment strictly increasing.

You only need to output the length of the subsegment you find.","The first line contains integer *n* (1<=≤<=*n*<=≤<=105). The next line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=109).",In a single line print the answer to the problem — the maximum length of the required subsegment.,['6\n7 2 3 1 5 6\n'],['5\n'],"You can choose subsegment *a*<sub class=""lower-index"">2</sub>, *a*<sub class=""lower-index"">3</sub>, *a*<sub class=""lower-index"">4</sub>, *a*<sub class=""lower-index"">5</sub>, *a*<sub class=""lower-index"">6</sub> and change its 3rd element (that is *a*<sub class=""lower-index"">4</sub>) to 4.",WRONG_ANSWER,"def find_longest_streak(nums):
    if len(nums) < 2:
        return n

    last_streak = 0
    current_streak = 1
    longest = 0
    for i in range(1, n):
        if nums[i] > nums[i-1]:
            current_streak += 1
        else:
            if current_streak + last_streak > longest:
                longest = current_streak + last_streak
            last_streak = current_streak
            current_streak = 1

    if current_streak + last_streak > longest:
        longest = current_streak + last_streak
    return longest

if __name__ == '__main__':
    n = int(input())
    nums = [int(i) for i in input().split("" "")]
    print(find_longest_streak(nums))","def longest_increasing_subsegment(n, a):
    max_length = 1
    left = 0

    for right in range(1, n):
        if a[right] <= a[right - 1]:

            left = right

        if left > 0 and a[right] <= a[left - 1]:
            left += 1

        current_length = right - left + 1
        max_length = max(max_length, current_length)

    return max_length

n = int(input().strip())
a = list(map(int, input().strip().split()))

print(longest_increasing_subsegment(n, a))"
32,B,Borze,PROGRAMMING,"['expression parsing', 'implementation']","Ternary numeric notation is quite popular in Berland. To telegraph the ternary number the Borze alphabet is used. Digit 0 is transmitted as «.», 1 as «-.» and 2 as «--». You are to decode the Borze code, i.e. to find out the ternary number given its representation in Borze alphabet.",The first line contains a number in Borze code. The length of the string is between 1 and 200 characters. It's guaranteed that the given string is a valid Borze code of some ternary number (this number can have leading zeroes).,Output the decoded ternary number. It can have leading zeroes.,"['.-.--\n', '--.\n', '-..-.--\n']","['012', '20', '1012']",none,WRONG_ANSWER,"from collections import defaultdict

def solve():
    s = input()
    m = ''
    code = defaultdict(int)
    code['.'] = '0'
    code['-.'] = '1'
    code['--'] = '2'
    i = 0
    prev = ''
    while (i<len(s)):
        prev += s[i]
        if(code[prev] == 0 ):
            i+=1
        else:
            m+= code[prev]
            prev = ''
            i+=1
    return m","def decode_borze(borze_code):

    result = """"

    i = 0

    while i < len(borze_code):
        if borze_code[i] == '.':
            result += '0'
            i += 1
        elif borze_code[i] == '-':
            if i + 1 < len(borze_code) and borze_code[i + 1] == '.':
                result += '1'
                i += 2
            else:
                result += '2'
                i += 2

    return result

input_data = ['.-.--\n', '--.\n', '-..-.--\n']

output_data = [decode_borze(code.strip()) for code in input_data]

for output in output_data:
    print(output)"
463,C,Gargari and Bishops,PROGRAMMING,"['greedy', 'hashing', 'implementation']","Gargari is jealous that his friend Caisa won the game from the previous problem. He wants to prove that he is a genius.

He has a *n*<=×<=*n* chessboard. Each cell of the chessboard has a number written on it. Gargari wants to place two bishops on the chessboard in such a way that there is no cell that is attacked by both of them. Consider a cell with number *x* written on it, if this cell is attacked by one of the bishops Gargari will get *x* dollars for it. Tell Gargari, how to place bishops on the chessboard to get maximum amount of money.

We assume a cell is attacked by a bishop, if the cell is located on the same diagonal with the bishop (the cell, where the bishop is, also considered attacked by it).",The first line contains a single integer *n* (2<=≤<=*n*<=≤<=2000). Each of the next *n* lines contains *n* integers *a**ij* (0<=≤<=*a**ij*<=≤<=109) — description of the chessboard.,"On the first line print the maximal number of dollars Gargari will get. On the next line print four integers: *x*1,<=*y*1,<=*x*2,<=*y*2 (1<=≤<=*x*1,<=*y*1,<=*x*2,<=*y*2<=≤<=*n*), where *x**i* is the number of the row where the *i*-th bishop should be placed, *y**i* is the number of the column where the *i*-th bishop should be placed. Consider rows are numbered from 1 to *n* from top to bottom, and columns are numbered from 1 to *n* from left to right.

If there are several optimal solutions, you can print any of them.",['4\n1 1 1 1\n2 1 1 0\n1 1 1 0\n1 0 0 1\n'],['12\n2 2 3 2\n'],none,WRONG_ANSWER,"import itertools
from sys import maxsize, stdout, stdin,stderr
mod = int(1e9+7)
import sys
from collections import defaultdict, Counter, deque
import math
import heapq
from heapq import heappop , heappush
import bisect
from math import factorial, inf
from itertools import groupby
from itertools import permutations as comb
def ask(a,b,c):
	print('? {} {} {}'.format(a,b,c),flush=True)
	n=int(input())
	return n
 
t=1

for _ in range(t):
    n=int(input())
    s=[]
    d1=[0]*(2*n)
    d2=[0]*(2*n)
    for i in range(n):
        s.append(list(map(int,input().split())))
    o,e=-1,-1
    x1,y1,x2,y2=None,None,None,None
    for i in range(n):
        for j in range(n):
           
            d1[i+j] += s[i][j]
            
            d2[i-j+n] += s[i][j]
    
    for i in range(n):
        for j in range(n):
            if (i+j)%2:
                if o<d1[i+j]+d2[i-j+n]-s[i][j]:
                    o=d1[i+j]+d2[i-j+n]-s[i][j]
                    x1,y1=i+1,j+1
            else:
                if e<d1[i+j]+d2[i-j+n]-s[i][j]:
                    e=d1[i+j]+d2[i-j+n]-s[i][j]
                    x2,y2=i+1,j+1
    print(o+e)
    print(x1,y2,x2,y2)","def max_bishop_profit(n, board):

    diagonal1 = {}
    diagonal2 = {}

    for i in range(n):
        for j in range(n):

            if (i - j) in diagonal1:
                diagonal1[i - j] += board[i][j]
            else:
                diagonal1[i - j] = board[i][j]

            if (i + j) in diagonal2:
                diagonal2[i + j] += board[i][j]
            else:
                diagonal2[i + j] = board[i][j]

    max_profit = 0
    best_pos = (0, 0, 0, 0)
    
    for i in range(n):
        for j in range(n):

            profit1 = board[i][j]
            d1_key = i - j
            d2_key = i + j

            for ii in range(n):
                for jj in range(n):
                    if (ii == i and jj == j):
                        continue

                    profit2 = board[ii][jj]

                    if (ii - jj) == d1_key or (ii + jj) == d2_key:
                        continue

                    total_profit = profit1 + profit2
                    
                    if total_profit > max_profit:
                        max_profit = total_profit
                        best_pos = (i + 1, j + 1, ii + 1, jj + 1)

    return max_profit, best_pos

n = int(input())
board = [list(map(int, input().split())) for _ in range(n)]

max_profit, positions = max_bishop_profit(n, board)

print(max_profit)
print(*positions)"
899,C,Dividing the numbers,PROGRAMMING,"['constructive algorithms', 'graphs', 'math']","Petya has *n* integers: 1,<=2,<=3,<=...,<=*n*. He wants to split these integers in two non-empty groups in such a way that the absolute difference of sums of integers in each group is as small as possible. 

Help Petya to split the integers. Each of *n* integers should be exactly in one group.",The first line contains a single integer *n* (2<=≤<=*n*<=≤<=60<=000) — the number of integers Petya has.,"Print the smallest possible absolute difference in the first line.

In the second line print the size of the first group, followed by the integers in that group. You can print these integers in arbitrary order. If there are multiple answers, print any of them.","['4\n', '2\n']","['0\n2 1 4 \n', '1\n1 1 \n']","In the first example you have to put integers 1 and 4 in the first group, and 2 and 3 in the second. This way the sum in each group is 5, and the absolute difference is 0.

In the second example there are only two integers, and since both groups should be non-empty, you have to put one integer in the first group and one in the second. This way the absolute difference of sums of integers in each group is 1.",WRONG_ANSWER,"import sys
input = sys.stdin.buffer.readline 

def process(n):
    S = n*(n+1)//2
    A = [i+1 for i in range(n+1)]
    goal = S//2
    curr = 0
    A2 = []
    while len(A) > 0:
        x = A.pop()
        if x+curr <= goal:
            A2.append(x)
            curr+=x
    c2 = S-curr
    return [abs(curr-c2), A2]

n = int(input())
answer = [int(x) for x in input().split()]
a1, a2 = process(n)
print(a1)
sys.stdout.write(' '.join(map(str, a2))+'\n')","def split_numbers(n):
    total_sum = n * (n + 1) // 2
    target = total_sum // 2

    dp = [False] * (target + 1)
    dp[0] = True

    for num in range(1, n + 1):
        for j in range(target, num - 1, -1):
            if dp[j - num]:
                dp[j] = True

    for s in range(target, -1, -1):
        if dp[s]:
            sum1 = s
            break

    sum2 = total_sum - sum1
    smallest_diff = abs(sum1 - sum2)

    group1 = []
    remaining_sum = sum1
    for num in range(n, 0, -1):
        if remaining_sum >= num and dp[remaining_sum - num]:
            group1.append(num)
            remaining_sum -= num

    print(smallest_diff)
    print(len(group1), ' '.join(map(str, group1)))

n = int(input().strip())
split_numbers(n)"
955,C,Sad powers,PROGRAMMING,"['binary search', 'math', 'number theory']","You're given *Q* queries of the form (*L*,<=*R*). 

For each query you have to find the number of such *x* that *L*<=≤<=*x*<=≤<=*R* and there exist integer numbers *a*<=&gt;<=0, *p*<=&gt;<=1 such that *x*<==<=*a**p*.","The first line contains the number of queries *Q* (1<=≤<=*Q*<=≤<=105).

The next *Q* lines contains two integers *L*, *R* each (1<=≤<=*L*<=≤<=*R*<=≤<=1018).",Output *Q* lines — the answers to the queries.,['6\n1 4\n9 9\n5 7\n12 29\n137 591\n1 1000000\n'],['2\n1\n0\n3\n17\n1111\n'],In query one the suitable numbers are 1 and 4.,TIME_LIMIT_EXCEEDED,"a=[1]
for i in range(3,31):
    num=2
    while(num**i<1+10**18):
        a.append(num**i)
        num+=1

b=sorted(a)
import math
def is_square(integer):
    root = math.sqrt(integer)
    if int(root + 0.5) ** 2 == integer:
        return True
    else:
        return False

c=[x for x in b if not is_square(x)]

import math
def CountSquares(a,b):
    return (math.floor(math.sqrt(b)) - math.ceil(math.sqrt(a)) + 1)

def findClosest(arr, n, target):

    if (target <= arr[0]):
        return 0
    if (target >= arr[n - 1]):
        return n - 1

    i = 0; j = n; mid = 0
    while (i < j):
        mid = (i + j) // 2

        if (arr[mid] == target):
            return mid

        if (target < arr[mid]) :

            if (mid > 0 and target > arr[mid - 1]):
                return getClosest(arr,mid - 1, mid, target)

            j = mid

        else :
            if (mid < n - 1 and target < arr[mid + 1]):
                return getClosest(arr,mid, mid + 1, target)

            i = mid + 1

    return mid

def getClosest(arr,val1, val2, target):
    if (target - arr[val1] >= arr[val2] - target):
        return val2
    else:
        return val1

nn=int(input())
for i in range(nn):
    a,b=list(map(int,input().split(' ')))
    count = CountSquares(a,b)

    n = len(c)
    a1=findClosest(c, n, a)
    a2=findClosest(c, n, b)

    count+=a2-a1+1
    if a>c[a1]:
        count-=1
    if b<c[a2]:
        count+=1
    if is_square(a):
        count-=1
    if is_square(b):
        count-=1
    if is_square(a) and is_square(b) and a==b:
        count+=2
    if a<c[0]:
        count-=1
    if b<c[0]:
        count-=1

    print(count)","import sys
import math

def count_valid_numbers(L, R):
    count = 0

    for p in range(2):
        if p == 0:

            if L <= 0 <= R:
                count += 1
        else:

            a = 1
            while True:

                x = a ** p
                if x > R:
                    break
                if L <= x <= R:
                    count += 1
                a += 1
    return count

Q = int(sys.stdin.readline().strip())
results = []

for _ in range(Q):
    L, R = map(int, sys.stdin.readline().strip().split())
    results.append(count_valid_numbers(L, R))

for result in results:
    print(result)"
80,A,Panoramix's Prediction,PROGRAMMING,['brute force'],"A prime number is a number which has exactly two distinct divisors: one and itself. For example, numbers 2, 7, 3 are prime, and 1, 6, 4 are not.

The next prime number after *x* is the smallest prime number greater than *x*. For example, the next prime number after 2 is 3, and the next prime number after 3 is 5. Note that there is exactly one next prime number after each number. So 5 is not the next prime number for 2.

One cold April morning Panoramix predicted that soon Kakofonix will break free from his straitjacket, and this will be a black day for the residents of the Gallic countryside.

Panoramix's prophecy tells that if some day Asterix and Obelix beat exactly *x* Roman soldiers, where *x* is a prime number, and next day they beat exactly *y* Roman soldiers, where *y* is the next prime number after *x*, then it's time to wait for Armageddon, for nothing can shut Kakofonix up while he sings his infernal song.

Yesterday the Gauls beat *n* Roman soldiers and it turned out that the number *n* was prime! Today their victims were a troop of *m* Romans (*m*<=&gt;<=*n*). Determine whether the Gauls should wait for the black day after today's victory of Asterix and Obelix?","The first and only input line contains two positive integers — *n* and *m* (2<=≤<=*n*<=&lt;<=*m*<=≤<=50). It is guaranteed that *n* is prime.

Pretests contain all the cases with restrictions 2<=≤<=*n*<=&lt;<=*m*<=≤<=4.","Print YES, if *m* is the next prime number after *n*, or NO otherwise.","['3 5\n', '7 11\n', '7 9\n']","['YES', 'YES', 'NO']",none,OK,"def is_prime(n):
    return n > 1 and all(n % i != 0 for i in range(2, int(n**0.5)+1))

n, m = map(int, input().split())
next_prime = n + 1
while not is_prime(next_prime):
    next_prime += 1
print(""YES"" if next_prime == m else ""NO"")","def is_prime(num):
    """"""Check if a number is prime.""""""
    if num < 2:
        return False
    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            return False
    return True

def next_prime(num):
    """"""Find the next prime number after a given number.""""""
    candidate = num + 1
    while True:
        if is_prime(candidate):
            return candidate
        candidate += 1

def should_wait_for_black_day(n, m):
    """"""Determine if the condition for waiting for the black day is met.""""""
    return m == next_prime(n)

input_lines = input().strip().splitlines()
results = []

for line in input_lines:
    n, m = map(int, line.split())
    if should_wait_for_black_day(n, m):
        results.append('YES')
    else:
        results.append('NO')

print('\n'.join(results))"
600,B,Queries about less or equal elements,PROGRAMMING,"['binary search', 'data structures', 'sortings', 'two pointers']",You are given two arrays of integers *a* and *b*. For each element of the second array *b**j* you should find the number of elements in array *a* that are less than or equal to the value *b**j*.,"The first line contains two integers *n*,<=*m* (1<=≤<=*n*,<=*m*<=≤<=2·105) — the sizes of arrays *a* and *b*.

The second line contains *n* integers — the elements of array *a* (<=-<=109<=≤<=*a**i*<=≤<=109).

The third line contains *m* integers — the elements of array *b* (<=-<=109<=≤<=*b**j*<=≤<=109).","Print *m* integers, separated by spaces: the *j*-th of which is equal to the number of such elements in array *a* that are less than or equal to the value *b**j*.","['5 4\n1 3 5 7 9\n6 4 2 8\n', '5 5\n1 2 1 2 5\n3 1 4 1 5\n']","['3 2 1 4\n', '4 2 4 2 5\n']",none,TIME_LIMIT_EXCEEDED,"a,b,c=list(map(int,input().split())),list(map(int,input().split())),list(map(int,input().split()))
def p(i,x):
    for j in b:
        if j<=i:
            x+=1
    return x
for k in c:
    print(p(k,0),end=' ')","def count_less_than_or_equal(a, b):

    a.sort()

    result = []
    
    for value in b:

        count = bisect.bisect_right(a, value)
        result.append(count)

    return result

if __name__ == ""__main__"":
    import sys
    import bisect

    input_data = sys.stdin.read().strip().split('\n')
    n, m = map(int, input_data[0].split())
    a = list(map(int, input_data[1].split()))
    b = list(map(int, input_data[2].split()))

    counts = count_less_than_or_equal(a, b)
    print("" "".join(map(str, counts)))"
251,A,Points on Line,PROGRAMMING,"['binary search', 'combinatorics', 'two pointers']","Little Petya likes points a lot. Recently his mom has presented him *n* points lying on the line *OX*. Now Petya is wondering in how many ways he can choose three distinct points so that the distance between the two farthest of them doesn't exceed *d*.

Note that the order of the points inside the group of three chosen points doesn't matter.","The first line contains two integers: *n* and *d* (1<=≤<=*n*<=≤<=105; 1<=≤<=*d*<=≤<=109). The next line contains *n* integers *x*1,<=*x*2,<=...,<=*x**n*, their absolute value doesn't exceed 109 — the *x*-coordinates of the points that Petya has got.

It is guaranteed that the coordinates of the points in the input strictly increase.","Print a single integer — the number of groups of three points, where the distance between two farthest points doesn't exceed *d*.

Please do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.","['4 3\n1 2 3 4\n', '4 2\n-3 -2 -1 0\n', '5 19\n1 10 20 30 50\n']","['4\n', '2\n', '1\n']","In the first sample any group of three points meets our conditions.

In the seconds sample only 2 groups of three points meet our conditions: {-3, -2, -1} and {-2, -1, 0}.

In the third sample only one group does: {1, 10, 20}.",OK,"import sys
input = sys.stdin.readline
def inInt():
    return int(input())
def inStr():
    return input().strip(""\n"")
def inIList():
    return(list(map(int,input().split())))
def inSList():
    return(input().split())

def solve(case, d):
    ans = 0
    j = 0
    for i in range(len(case)):
        while case[i] - case[j] > d:j += 1
        ans += int((i - j) * (i - j - 1)/2)
            

    print(ans)

nums = inIList()
case = inIList()
solve(case, nums[1])","def count_triplets(n, d, points):
    count = 0
    j = 0

    for i in range(n):

        while j < n and points[j] - points[i] <= d:
            j += 1

        k = j - i - 1
        if k >= 2:
            count += k * (k - 1) // 2
            
    return count

n, d = map(int, input().split())
points = list(map(int, input().split()))

result = count_triplets(n, d, points)
print(result)"
0,none,none,none,['none'],"Mashmokh's boss, Bimokh, didn't like Mashmokh. So he fired him. Mashmokh decided to go to university and participate in ACM instead of finding a new job. He wants to become a member of Bamokh's team. In order to join he was given some programming tasks and one week to solve them. Mashmokh is not a very experienced programmer. Actually he is not a programmer at all. So he wasn't able to solve them. That's why he asked you to help him with these tasks. One of these tasks is the following.

A sequence of *l* integers *b*1,<=*b*2,<=...,<=*b**l* (1<=≤<=*b*1<=≤<=*b*2<=≤<=...<=≤<=*b**l*<=≤<=*n*) is called good if each number divides (without a remainder) by the next number in the sequence. More formally  for all *i* (1<=≤<=*i*<=≤<=*l*<=-<=1).

Given *n* and *k* find the number of good sequences of length *k*. As the answer can be rather large print it modulo 1000000007 (109<=+<=7).","The first line of input contains two space-separated integers *n*,<=*k* (1<=≤<=*n*,<=*k*<=≤<=2000).",Output a single integer — the number of good sequences of length *k* modulo 1000000007 (109<=+<=7).,"['3 2\n', '6 4\n', '2 1\n']","['5\n', '39\n', '2\n']","In the first sample the good sequences are: [1, 1], [2, 2], [3, 3], [1, 2], [1, 3].",WRONG_ANSWER,"def mlt(): return map(int, input().split())

x, y = mlt()
divs = [[] for _ in range(x+1)]

for n in range(1, x+1):
    for k in range(n, x+1, n):
        divs[k].append(n)

dp = [[0 for n in range(y+1)] for k in range(x+1)]
for n in range(1, y+1):
    dp[1][n] = 1
for n in range(1, x+1):
    dp[n][1] = 1
mod = int(1e9 + 7)
for n in range(2, x+1):
    for k in range(2, y+1):
        for dv in divs[n]:
            dp[n][k] += dp[dv][k-1]
            dp[n][k] %= mod

res = 0
for n in dp:
    res += n[-1]
print(res)","MOD = 1000000007

def count_good_sequences(n, k):

    dp = [[0] * (k + 1) for _ in range(n + 1)]

    for i in range(1, n + 1):
        dp[i][1] = 1

    for length in range(2, k + 1):
        for last in range(1, n + 1):
            for multiple in range(last, n + 1, last):
                dp[multiple][length] = (dp[multiple][length] + dp[last][length - 1]) % MOD

    total_good_sequences = sum(dp[i][k] for i in range(1, n + 1)) % MOD
    
    return total_good_sequences

import sys
input_data = sys.stdin.read().strip().split('\n')
results = []

for line in input_data:
    n, k = map(int, line.split())
    results.append(count_good_sequences(n, k))

for result in results:
    print(result)"
919,D,Substring,PROGRAMMING,"['dfs and similar', 'dp', 'graphs']","You are given a graph with $n$ nodes and $m$ directed edges. One lowercase letter is assigned to each node. We define a path's value as the number of the most frequently occurring letter. For example, if letters on a path are ""abaca"", then the value of that path is $3$. Your task is find a path whose value is the largest.","The first line contains two positive integers $n, m$ ($1 \leq n, m \leq 300\,000$), denoting that the graph has $n$ nodes and $m$ directed edges.

The second line contains a string $s$ with only lowercase English letters. The $i$-th character is the letter assigned to the $i$-th node.

Then $m$ lines follow. Each line contains two integers $x, y$ ($1 \leq x, y \leq n$), describing a directed edge from $x$ to $y$. Note that $x$ can be equal to $y$ and there can be multiple edges between $x$ and $y$. Also the graph can be not connected.","Output a single line with a single integer denoting the largest value. If the value can be arbitrarily large, output -1 instead.","['5 4\nabaca\n1 2\n1 3\n3 4\n4 5\n', '6 6\nxzyabc\n1 2\n3 1\n2 3\n5 4\n4 3\n6 4\n', '10 14\nxzyzyzyzqx\n1 2\n2 4\n3 5\n4 5\n2 6\n6 8\n6 5\n2 10\n3 9\n10 9\n4 6\n1 10\n2 8\n3 7\n']","['3\n', '-1\n', '4\n']","In the first sample, the path with largest value is $1 \to 3 \to 4 \to 5$. The value is $3$ because the letter 'a' appears $3$ times.",TIME_LIMIT_EXCEEDED,"import math, sys, collections, functools, time, itertools;

def Read_Ints()     : return map(int, input().strip().split())
def Read_Array()    : return list(Read_Ints())
def Read_Strings()  : return list(input().strip().split())
def printxsp(*args) : return print(*args, end="""")
def printsp(*args)  : return print(*args, end="" "")

d4i = [-1, +0, +1, +0]; d8i = [-1, -1, +0, +1, +1, +1, +0, -1]; 
d4j = [+0, +1, +0, -1]; d8j = [+0, +1, +1, +1, +0, -1, -1, -1];

def solveEachTest(_TestCase):

    n, m = Read_Ints()
    adj = collections.defaultdict(list)
    indeg = [0 for x in range(n+1)]
    s = input();

    for i in range(m):
        a, b = Read_Ints()
        adj[a].append(b);
        indeg[b] += 1;

    que = collections.deque();

    ans = 0; 
    dp = [[0 for x in range(26)] for xx in range(n+1)]
    indegCopy = indeg.copy()
    for j in range(26):
        ch = chr(ord('a') + j)
        indeg = indegCopy.copy()
        for i in range(1, n+1):
            if indeg[i] == 0:
                que.append(i)
                dp[i][j] = s[i-1] == ch

        cnt = 0
        while (len(que)):
            node = que.popleft()
            for i in adj[node]:
                dp[i][j] = dp[node][j] + (s[i-1] == ch);
                ans = max(ans, dp[i][j])
                indeg[i] -= 1
                if indeg[i] == 0:
                    que.append(i)
            cnt += 1
            if cnt > n:
                break
        if cnt > n:
            break

    print(ans if cnt == n else -1)
    

_T0T4 = 1;

for _TestCase in range(1, _T0T4 + 1): 
    solveEachTest(_TestCase)","from collections import defaultdict, deque

def largest_path_value(n, m, s, edges):

    graph = defaultdict(list)
    in_degree = [0] * n
    
    for x, y in edges:
        graph[x - 1].append(y - 1)
        in_degree[y - 1] += 1

    queue = deque()
    for i in range(n):
        if in_degree[i] == 0:
            queue.append(i)

    max_counts = [defaultdict(int) for _ in range(n)]
    
    while queue:
        node = queue.popleft()
        max_counts[node][s[node]] += 1
        
        for neighbor in graph[node]:

            for char, count in max_counts[node].items():
                max_counts[neighbor][char] = max(max_counts[neighbor][char], count)
            in_degree[neighbor] -= 1
            if in_degree[neighbor] == 0:
                queue.append(neighbor)

    max_value = 0
    for counts in max_counts:
        if counts:
            max_value = max(max_value, max(counts.values()))

    if any(in_degree):
        return -1
    
    return max_value

import sys
input = sys.stdin.read
data = input().splitlines()

n, m = map(int, data[0].split())

s = data[1]

edges = [tuple(map(int, line.split())) for line in data[2:m + 2]]

print(largest_path_value(n, m, s, edges))"
462,A,Appleman and Easy Task,PROGRAMMING,"['brute force', 'implementation']","Toastman came up with a very easy task. He gives it to Appleman, but Appleman doesn't know how to solve it. Can you help him?

Given a *n*<=×<=*n* checkerboard. Each cell of the board has either character 'x', or character 'o'. Is it true that each cell of the board has even number of adjacent cells with 'o'? Two cells of the board are adjacent if they share a side.",The first line contains an integer *n* (1<=≤<=*n*<=≤<=100). Then *n* lines follow containing the description of the checkerboard. Each of them contains *n* characters (either 'x' or 'o') without spaces.,"Print ""YES"" or ""NO"" (without the quotes) depending on the answer to the problem.","['3\nxxo\nxox\noxx\n', '4\nxxxo\nxoxo\noxox\nxxxx\n']","['YES\n', 'NO\n']",none,OK,"def solve(n, arr):
    for i in range(n):
        for j in range(n):
            cnt = 0
            for x, y in [(-1, 0), (0, 1), (1, 0), (0, -1)]:
                ni, nj = x + i, y + j
                if ni >= 0 and ni < n and nj >= 0 and nj < n:
                    if arr[ni][nj] == ""o"":
                        cnt += 1
            
            if cnt % 2 != 0:
                return ""NO""
    return ""YES""
    

n = int(input())
arr = []
for i in range(n):
    temp = input()
    arr.append(list(temp))
print(solve(n, arr))","def is_even_adjacent_o(n, board):

    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    
    for i in range(n):
        for j in range(n):
            count_o = 0

            for di, dj in directions:
                ni, nj = i + di, j + dj
                if 0 <= ni < n and 0 <= nj < n and board[ni][nj] == 'o':
                    count_o += 1

            if count_o % 2 != 0:
                return ""NO""
    
    return ""YES""

n = int(input().strip())
board = [input().strip() for _ in range(n)]

print(is_even_adjacent_o(n, board))"
834,A,The Useless Toy,PROGRAMMING,['implementation'],"Walking through the streets of Marshmallow City, Slastyona have spotted some merchants selling a kind of useless toy which is very popular nowadays – caramel spinner! Wanting to join the craze, she has immediately bought the strange contraption.

Spinners in Sweetland have the form of V-shaped pieces of caramel. Each spinner can, well, spin around an invisible magic axis. At a specific point in time, a spinner can take 4 positions shown below (each one rotated 90 degrees relative to the previous, with the fourth one followed by the first one):

After the spinner was spun, it starts its rotation, which is described by a following algorithm: the spinner maintains its position for a second then majestically switches to the next position in clockwise or counter-clockwise order, depending on the direction the spinner was spun in.

Slastyona managed to have spinner rotating for exactly *n* seconds. Being fascinated by elegance of the process, she completely forgot the direction the spinner was spun in! Lucky for her, she managed to recall the starting position, and wants to deduct the direction given the information she knows. Help her do this.","There are two characters in the first string – the starting and the ending position of a spinner. The position is encoded with one of the following characters: v (ASCII code 118, lowercase v), &lt; (ASCII code 60), ^ (ASCII code 94) or &gt; (ASCII code 62) (see the picture above for reference). Characters are separated by a single space.

In the second strings, a single number *n* is given (0<=≤<=*n*<=≤<=109) – the duration of the rotation.

It is guaranteed that the ending position of a spinner is a result of a *n* second spin in any of the directions, assuming the given starting position.","Output cw, if the direction is clockwise, ccw – if counter-clockwise, and undefined otherwise.","['^ &gt;\n1\n', '&lt; ^\n3\n', '^ v\n6\n']","['cw\n', 'ccw\n', 'undefined\n']",none,RUNTIME_ERROR,"c=['^','<','v','>']
d,e=[],[]
a,b=map(str,input().split())
n=int(input())
n=n%4

if n==2:
    print('undefined')
    exit()
for i in range(4):
    if a==c[i]:
        aa=i
    if b==c[i]:
        bb=i

if b==c[(aa+n)%4]:
    print('ccw')
elif b==c[4-(aa+n)%4]:
    print('cw')","def determine_rotation(spins):

    positions = ['v', '<', '^', '>']
    
    results = []
    
    for spin in spins:

        start_position, end_position, n = spin.split()
        n = int(n)

        start_index = positions.index(start_position)
        end_index = positions.index(end_position)

        cw_end_index = (start_index + n) % 4
        ccw_end_index = (start_index - n) % 4

        cw_result = positions[cw_end_index] == end_position
        ccw_result = positions[ccw_end_index] == end_position

        if cw_result and ccw_result:
            results.append(""undefined"")
        elif cw_result:
            results.append(""cw"")
        elif ccw_result:
            results.append(""ccw"")
        else:
            results.append(""undefined"")
    
    return results

input_data = [
    '^ > 1',
    '< ^ 3',
    '^ v 6'
]

output_data = determine_rotation(input_data)
for result in output_data:
    print(result)"
377,A,Maze,PROGRAMMING,['dfs and similar'],"Pavel loves grid mazes. A grid maze is an *n*<=×<=*m* rectangle maze where each cell is either empty, or is a wall. You can go from one cell to another only if both cells are empty and have a common side.

Pavel drew a grid maze with all empty cells forming a connected area. That is, you can go from any empty cell to any other one. Pavel doesn't like it when his maze has too little walls. He wants to turn exactly *k* empty cells into walls so that all the remaining cells still formed a connected area. Help him.","The first line contains three integers *n*, *m*, *k* (1<=≤<=*n*,<=*m*<=≤<=500, 0<=≤<=*k*<=&lt;<=*s*), where *n* and *m* are the maze's height and width, correspondingly, *k* is the number of walls Pavel wants to add and letter *s* represents the number of empty cells in the original maze.

Each of the next *n* lines contains *m* characters. They describe the original maze. If a character on a line equals ""."", then the corresponding cell is empty and if the character equals ""#"", then the cell is a wall.","Print *n* lines containing *m* characters each: the new maze that fits Pavel's requirements. Mark the empty cells that you transformed into walls as ""X"", the other cells must be left without changes (that is, ""."" and ""#"").

It is guaranteed that a solution exists. If there are multiple solutions you can output any of them.","['3 4 2\n#..#\n..#.\n#...\n', '5 4 5\n#...\n#.#.\n.#..\n...#\n.#.#\n']","['#.X#\nX.#.\n#...\n', '#XXX\n#X#.\nX#..\n...#\n.#.#\n']",none,RUNTIME_ERROR,"def polycarpus(graph, n, m, k):
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    visited = set()

    def inBound(x, y):
        return 0 <= x < n and 0 <= y < m
    C = n * m
    start = None

    for i in range(n):
        for j in range(m):
            if graph[i][j] == '
                C -= 1
            if not start and graph[i][j] == '.':
                start = (i, j)

    visited.add(start)
    count = 0

    def dfs(p, lim):
        nonlocal count
        px, py = p
        count += 1
        if count > lim:
            graph[px][py] = 'X'

        for x, y in directions:
            nx, ny = px + x, py + y
            if (nx, ny) not in visited and inBound(nx, ny) and graph[nx][ny] == '.':
                visited.add((nx, ny))
                dfs((nx, ny), lim)

    if k > 0:
        dfs(start, C - k)
    for i in range(n):
        for j in range(m):
            print(graph[i][j], end="""")
        print()

n, m, k = list(map(int, input().split()))
maze = []
for _ in range(n):
    maze.append(list(input()))
polycarpus(maze, n, m, k)","def make_maze(n, m, k, maze):

    maze = [list(row) for row in maze]

    def dfs(x, y):
        stack = [(x, y)]
        cells = []
        while stack:
            cx, cy = stack.pop()
            if (cx, cy) in visited:
                continue
            visited.add((cx, cy))
            cells.append((cx, cy))
            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                nx, ny = cx + dx, cy + dy
                if 0 <= nx < n and 0 <= ny < m and maze[nx][ny] == '.' and (nx, ny) not in visited:
                    stack.append((nx, ny))
        return cells

    visited = set()
    cells = []
    for i in range(n):
        for j in range(m):
            if maze[i][j] == '.':
                cells = dfs(i, j)
                break
        if cells:
            break

    for i in range(len(cells) - k):
        x, y = cells[i]
        maze[x][y] = '.'
    for i in range(len(cells) - k, len(cells)):
        x, y = cells[i]
        maze[x][y] = 'X'

    for row in maze:
        print(''.join(row))

import sys
input_data = sys.stdin.read().strip().split('\n')
n, m, k = map(int, input_data[0].split())
maze = input_data[1:n + 1]

make_maze(n, m, k, maze)"
863,G,Graphic Settings,PROGRAMMING,[],"Recently Ivan bought a new computer. Excited, he unpacked it and installed his favourite game. With his old computer Ivan had to choose the worst possible graphic settings (because otherwise the framerate would be really low), but now he wants to check, maybe his new computer can perform well even with the best possible graphics?

There are *m* graphics parameters in the game. *i*-th parameter can be set to any positive integer from 1 to *a**i*, and initially is set to *b**i* (*b**i*<=≤<=*a**i*). So there are  different combinations of parameters. Ivan can increase or decrease any of these parameters by 1; after that the game will be restarted with new parameters (and Ivan will have the opportunity to check chosen combination of parameters).

Ivan wants to try all *p* possible combinations. Also he wants to return to the initial settings after trying all combinations, because he thinks that initial settings can be somehow best suited for his hardware. But Ivan doesn't really want to make a lot of restarts.

So he wants you to tell the following:
 -  If there exists a way to make exactly *p* changes (each change either decreases or increases some parameter by 1) to try all possible combinations and return to initial combination, then Ivan wants to know this way. -  Otherwise, if there exists a way to make exactly *p*<=-<=1 changes to try all possible combinations (including the initial one), then Ivan wants to know this way. 
Help Ivan by showing him the way to change parameters!","The first line of input contains one integer number *m* (1<=≤<=*m*<=≤<=6).

The second line contains *m* integer numbers *a*1,<=*a*2,<=...,<=*a**m* (2<=≤<=*a**i*<=≤<=1000). It is guaranteed that .

The third line contains *m* integer numbers *b*1,<=*b*2,<=...,<=*b**m* (1<=≤<=*b**i*<=≤<=*a**i*).","If there is a way to make exactly *p* changes (each change either decreases or increases some parameter by 1) to try all possible combinations and return to initial combination, then output Cycle in the first line. Then *p* lines must follow, each desribing a change. The line must be either inc x (increase parameter *x* by 1) or dec x (decrease it).

Otherwise, if there is a way to make exactly *p*<=-<=1 changes to try all possible combinations (including the initial one), then output Path in the first line. Then *p*<=-<=1 lines must follow, each describing the change the same way as mentioned above.

Otherwise, output No.","['1\n3\n1\n', '1\n3\n2\n', '2\n3 2\n1 1\n']","['Path\ninc 1\ninc 1\n', 'No\n', 'Cycle\ninc 1\ninc 1\ninc 2\ndec 1\ndec 1\ndec 2\n']",none,WRONG_ANSWER,"m = int(input())
a = list(map(int, input().split()))
b = list(map(int, input().split()))

max_changes = sum(a[i] - b[i] for i in range(m))
p = (max_changes + m) // 2

changes = []

def find_changes(p):
    if p < 0:
        return False
    if p == 0:
        return True
    
    for i in range(m):
        if b[i] < a[i]:
            b[i] += 1
            changes.append(f'inc {i + 1}')
            if find_changes(p - 1):
                return True
            changes.pop()
            b[i] -= 1

        if b[i] > 1:
            b[i] -= 1
            changes.append(f'dec {i + 1}')
            if find_changes(p - 1):
                return True
            changes.pop()
            b[i] += 1
    
    return False

if find_changes(p):
    if len(changes) == p:
        print(""Cycle"")
    else:
        print(""Path"")
    for change in changes:
        print(change)
else:
    print(""No"")","def find_changes(m, a, b):
    from itertools import product

    initial = tuple(b)
    targets = set(product(*(range(1, ai + 1) for ai in a)))
    targets.discard(initial)

    p = len(targets) * 2

    if p % 2 == 0:
        changes = []
        for target in targets:
            for i in range(m):
                while b[i] < target[i]:
                    changes.append(f'inc {i + 1}')
                    b[i] += 1
                while b[i] > target[i]:
                    changes.append(f'dec {i + 1}')
                    b[i] -= 1

        for i in range(m):
            while b[i] > initial[i]:
                changes.append(f'dec {i + 1}')
                b[i] -= 1
            while b[i] < initial[i]:
                changes.append(f'inc {i + 1}')
                b[i] += 1

        if len(changes) == p:
            print(""Cycle"")
            print('\n'.join(changes))
            return

    changes = []
    for target in targets:
        for i in range(m):
            while b[i] < target[i]:
                changes.append(f'inc {i + 1}')
                b[i] += 1
            while b[i] > target[i]:
                changes.append(f'dec {i + 1}')
                b[i] -= 1

        if len(changes) < p:
            changes.append(f'initial: {b}')
        
    if changes:
        print(""Path"")
        print('\n'.join(changes))
    else:
        print(""No"")

m = 1
a = [3]
b = [1]

find_changes(m, a, b)"
146,A,Lucky Ticket,PROGRAMMING,['implementation'],"Petya loves lucky numbers very much. Everybody knows that lucky numbers are positive integers whose decimal record contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.

Petya loves tickets very much. As we know, each ticket has a number that is a positive integer. Its length equals *n* (*n* is always even). Petya calls a ticket lucky if the ticket's number is a lucky number and the sum of digits in the first half (the sum of the first *n*<=/<=2 digits) equals the sum of digits in the second half (the sum of the last *n*<=/<=2 digits). Check if the given ticket is lucky.",The first line contains an even integer *n* (2<=≤<=*n*<=≤<=50) — the length of the ticket number that needs to be checked. The second line contains an integer whose length equals exactly *n* — the ticket number. The number may contain leading zeros.,"On the first line print ""YES"" if the given ticket number is lucky. Otherwise, print ""NO"" (without the quotes).","['2\n47\n', '4\n4738\n', '4\n4774\n']","['NO\n', 'NO\n', 'YES\n']","In the first sample the sum of digits in the first half does not equal the sum of digits in the second half (4 ≠ 7).

In the second sample the ticket number is not the lucky number.",WRONG_ANSWER,"n = int(input())
def lucky(n):
    x = list(set(list(n)))
    if x!=['4','7'] and x!=['7','4']:
        return False
    else:
        return True
a = input()
if lucky(a):
    x = [int(i) for i in a[:n//2]]
    y = [int(i) for i in a[n//2:]]
    if sum(x) == sum(y):
        print(""YES"")
    else:
        print(""NO"")
else:
    print(""NO"")","def is_lucky_ticket(ticket_number):
    n = len(ticket_number)

    if all(digit in '47' for digit in ticket_number):

        first_half = ticket_number[:n//2]
        second_half = ticket_number[n//2:]

        sum_first_half = sum(int(digit) for digit in first_half)
        sum_second_half = sum(int(digit) for digit in second_half)

        return sum_first_half == sum_second_half

    return False

n = int(input().strip())
ticket_number = input().strip()

if is_lucky_ticket(ticket_number):
    print(""YES"")
else:
    print(""NO"")"
940,B,Our Tanya is Crying Out Loud,PROGRAMMING,"['dp', 'greedy']","Right now she actually isn't. But she will be, if you don't solve this problem.

You are given integers *n*, *k*, *A* and *B*. There is a number *x*, which is initially equal to *n*. You are allowed to perform two types of operations: 
 1.  Subtract 1 from *x*. This operation costs you *A* coins. 1.  Divide *x* by *k*. Can be performed only if *x* is divisible by *k*. This operation costs you *B* coins.","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=2·109).

The second line contains a single integer *k* (1<=≤<=*k*<=≤<=2·109).

The third line contains a single integer *A* (1<=≤<=*A*<=≤<=2·109).

The fourth line contains a single integer *B* (1<=≤<=*B*<=≤<=2·109).",Output a single integer — the minimum amount of coins you have to pay to make *x* equal to 1.,"['9\n2\n3\n1\n', '5\n5\n2\n20\n', '19\n3\n4\n2\n']","['6\n', '8\n', '12\n']","In the first testcase, the optimal strategy is as follows: 
 -  Subtract 1 from *x* (9 → 8) paying 3 coins. -  Divide *x* by 2 (8 → 4) paying 1 coin. -  Divide *x* by 2 (4 → 2) paying 1 coin. -  Divide *x* by 2 (2 → 1) paying 1 coin. 
The total cost is 6 coins.

In the second test case the optimal strategy is to subtract 1 from *x* 4 times paying 8 coins in total.",WRONG_ANSWER,"import sys
import string

from collections import Counter, defaultdict
from math import fsum, sqrt, gcd, ceil, factorial
from itertools import combinations, permutations

flush = lambda: sys.stdout.flush
comb = lambda x, y: (factorial(x) // factorial(y)) // factorial(x - y)

ip = lambda: input()
ii = lambda: int(input())
r = lambda: map(int, input().split())
rr = lambda: list(r())

n = ii()
k = ii()
a = ii()
b = ii()

ans = (n - 1) * a

if k == 1:
    exit(print(n - 1))

c = 0
while n:
    r = n % k
    c += r * a
    n -= r

    n = n // k
    if n:
        c += b
c-= a

print(min(ans, c))","def min_cost_to_one(n, k, A, B):
    total_cost = 0
    
    while n > 1:
        if k > 1 and n % k == 0:

            cost_divide = B

            cost_subtract_to_next = (n - (n // k)) * A

            if cost_divide < cost_subtract_to_next:
                total_cost += cost_divide
                n //= k
            else:
                total_cost += cost_subtract_to_next
                n -= (n - (n // k))
        else:

            total_cost += (n - 1) * A
            n = 1

    return total_cost

n = int(input().strip())
k = int(input().strip())
A = int(input().strip())
B = int(input().strip())

print(min_cost_to_one(n, k, A, B))"
330,A,Cakeminator,PROGRAMMING,"['brute force', 'implementation']","You are given a rectangular cake, represented as an *r*<=×<=*c* grid. Each cell either has an evil strawberry, or is empty. For example, a 3<=×<=4 cake may look as follows:

The cakeminator is going to eat the cake! Each time he eats, he chooses a row or a column that does not contain any evil strawberries and contains at least one cake cell that has not been eaten before, and eats all the cake cells there. He may decide to eat any number of times.

Please output the maximum number of cake cells that the cakeminator can eat.","The first line contains two integers *r* and *c* (2<=≤<=*r*,<=*c*<=≤<=10), denoting the number of rows and the number of columns of the cake. The next *r* lines each contains *c* characters — the *j*-th character of the *i*-th line denotes the content of the cell at row *i* and column *j*, and is either one of these: 
 -  '.' character denotes a cake cell with no evil strawberry; -  'S' character denotes a cake cell with an evil strawberry.",Output the maximum number of cake cells that the cakeminator can eat.,['3 4\nS...\n....\n..S.\n'],['8\n'],"For the first example, one possible way to eat the maximum number of cake cells is as follows (perform 3 eats).",WRONG_ANSWER,"from sys import stdin, setrecursionlimit, stdout

def solve():
    r, c = (int(s) for s in stdin.readline().split())

    mas = [stdin.readline().rstrip('\r\n') for _ in range(r)]
    banned_rows = set()
    banned_cols = set()

    for i in range(r):
        for j in range(c):
            if mas[i][j] == 'S':
                banned_rows.add(i)
                banned_cols.add(j)

    ans = (r-len(banned_rows))*c+(c-len(banned_cols))*r-len(banned_cols)
    print(ans)

if __name__ == '__main__':
    solve()","def max_cake_cells_eaten(cake):

    r = len(cake)
    c = len(cake[0])

    rows_with_strawberry = set()
    columns_with_strawberry = set()

    for i in range(r):
        for j in range(c):
            if cake[i][j] == 'S':
                rows_with_strawberry.add(i)
                columns_with_strawberry.add(j)

    clean_rows = r - len(rows_with_strawberry)
    clean_columns = c - len(columns_with_strawberry)

    max_cells = clean_rows * c + clean_columns * (r - clean_rows)
    
    return max_cells

if __name__ == ""__main__"":

    r, c = map(int, input().split())
    cake = [input().strip() for _ in range(r)]

    result = max_cake_cells_eaten(cake)

    print(result)"
46,A,Ball Game,PROGRAMMING,"['brute force', 'implementation']","A kindergarten teacher Natalia Pavlovna has invented a new ball game. This game not only develops the children's physique, but also teaches them how to count. 

The game goes as follows. Kids stand in circle. Let's agree to think of the children as numbered with numbers from 1 to *n* clockwise and the child number 1 is holding the ball. First the first child throws the ball to the next one clockwise, i.e. to the child number 2. Then the child number 2 throws the ball to the next but one child, i.e. to the child number 4, then the fourth child throws the ball to the child that stands two children away from him, i.e. to the child number 7, then the ball is thrown to the child who stands 3 children away from the child number 7, then the ball is thrown to the child who stands 4 children away from the last one, and so on. It should be mentioned that when a ball is thrown it may pass the beginning of the circle. For example, if *n*<==<=5, then after the third throw the child number 2 has the ball again. Overall, *n*<=-<=1 throws are made, and the game ends.

The problem is that not all the children get the ball during the game. If a child doesn't get the ball, he gets very upset and cries until Natalia Pavlovna gives him a candy. That's why Natalia Pavlovna asks you to help her to identify the numbers of the children who will get the ball after each throw.",The first line contains integer *n* (2<=≤<=*n*<=≤<=100) which indicates the number of kids in the circle.,In the single line print *n*<=-<=1 numbers which are the numbers of children who will get the ball after each throw. Separate the numbers by spaces.,"['10\n', '3\n']","['2 4 7 1 6 2 9 7 6\n', '2 1\n']",none,OK,"aruncari = int(input(''))

def nr_ce_primesc_mingea(aruncari):
    numar = 1
    for i in range(1, aruncari):
        numar = numar + i
        if numar > aruncari:
            numar = numar - aruncari
        print(numar, end=' ')

nr_ce_primesc_mingea(aruncari)","def ball_game(n):

    results = []
    current_position = 1

    for throw in range(1, n):

        current_position = (current_position + throw) % n

        if current_position == 0:
            current_position = n

        results.append(current_position)

    return results

n = int(input().strip())

result = ball_game(n)
print(' '.join(map(str, result)))"
1,C,Ancient Berland Circus,PROGRAMMING,"['geometry', 'math']","Nowadays all circuses in Berland have a round arena with diameter 13 meters, but in the past things were different.

In Ancient Berland arenas in circuses were shaped as a regular (equiangular) polygon, the size and the number of angles could vary from one circus to another. In each corner of the arena there was a special pillar, and the rope strung between the pillars marked the arena edges.

Recently the scientists from Berland have discovered the remains of the ancient circus arena. They found only three pillars, the others were destroyed by the time.

You are given the coordinates of these three pillars. Find out what is the smallest area that the arena could have.","The input file consists of three lines, each of them contains a pair of numbers –– coordinates of the pillar. Any coordinate doesn't exceed 1000 by absolute value, and is given with at most six digits after decimal point.",Output the smallest possible area of the ancient arena. This number should be accurate to at least 6 digits after the decimal point. It's guaranteed that the number of angles in the optimal polygon is not larger than 100.,['0.000000 0.000000\n1.000000 1.000000\n0.000000 1.000000\n'],['1.00000000\n'],,WRONG_ANSWER,"import math

def dot(a, b):
    return a[0]*b[0] + a[1]*b[1]

def rad2deg(x):
    return 180 * x / math.pi

def deg2rad(x):
    return math.pi* x / 180

def center_from_three_points(a, b, c):
    a11 = 2*(a[0] - b[0])
    a12 = 2*(a[1] - b[1])
    a21 = 2*(a[0] - c[0])
    a22 = 2*(a[1] - c[1])

    b1 = a[0]*a[0] - b[0]*b[0] + a[1]*a[1] - b[1]*b[1]
    b2 = a[0]*a[0] - c[0]*c[0] + a[1]*a[1] - c[1]*c[1]

    det = a11 * a22 - a12 * a21

    x = (b1 * a22 - b2 * a12) / det
    y = (a11 * b2 - a21 * b1) / det

    return (x, y)

def angle(a, c, b):

    v1 = (a[0] - c[0], a[1] - c[1])
    v2 = (b[0] - c[0], b[1] - c[1])

    cos_alpha = dot(v1, v2) / math.sqrt(dot(v1, v1)* dot(v2, v2))
    cos_alpha = min(max(-1, cos_alpha), 1)

    return math.acos(cos_alpha)

def gcd(a, b):
    if a < b:
        return gcd(b, a)

    if (abs(b) < 0.000001):
        return a

    return gcd(b, a - math.floor(a / b )*b)

a = tuple(map(float, input().split()))
b = tuple(map(float, input().split()))
c = tuple(map(float, input().split()))

center = center_from_three_points(a, b, c)
radius = math.sqrt((a[0] - center[0])**2 + (a[1] - center[1])**2)

angle1 = angle(a, center, b)
angle2 = angle(a, center, c)

step = gcd(angle1, angle2)

chord = 2*radius*math.sin(step/2)
apothem = math.sqrt(radius**2 - (chord/2)**2)

nsides = int(round(2*math.pi / step))

perimeter = nsides*chord

print(f""{0.5*perimeter*apothem:0.6f}"")","import sys
import math

def area_of_polygon(points):
    """"""Calculate the area of a polygon using the shoelace formula.""""""
    n = len(points)
    area = 0
    for i in range(n):
        x1, y1 = points[i]
        x2, y2 = points[(i + 1) % n]
        area += x1 * y2 - x2 * y1
    return abs(area) / 2

def find_smallest_area(p1, p2, p3):
    """"""Find the smallest area of a polygon formed with three points.""""""
    points = [p1, p2, p3]
    min_area = float('inf')

    for n in range(3, 101):

        A = area_of_polygon(points)
        side_length = math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)
        circumradius = side_length / (2 * math.sin(math.pi / n))

        area = (n * circumradius ** 2 * math.sin(2 * math.pi / n)) / 2
        min_area = min(min_area, area)

    return min_area

def main():

    points = []
    for _ in range(3):
        line = sys.stdin.readline().strip()
        x, y = map(float, line.split())
        points.append((x, y))

    smallest_area = find_smallest_area(points[0], points[1], points[2])

    print(f""{smallest_area:.8f}"")

if __name__ == ""__main__"":
    main()"
498,A,Crazy Town,PROGRAMMING,['geometry'],"Crazy Town is a plane on which there are *n* infinite line roads. Each road is defined by the equation *a**i**x*<=+<=*b**i**y*<=+<=*c**i*<==<=0, where *a**i* and *b**i* are not both equal to the zero. The roads divide the plane into connected regions, possibly of infinite space. Let's call each such region a block. We define an intersection as the point where at least two different roads intersect.

Your home is located in one of the blocks. Today you need to get to the University, also located in some block. In one step you can move from one block to another, if the length of their common border is nonzero (in particular, this means that if the blocks are adjacent to one intersection, but have no shared nonzero boundary segment, then it are not allowed to move from one to another one in one step).

Determine what is the minimum number of steps you have to perform to get to the block containing the university. It is guaranteed that neither your home nor the university is located on the road.","The first line contains two space-separated integers *x*1, *y*1 (<=-<=106<=≤<=*x*1,<=*y*1<=≤<=106) — the coordinates of your home.

The second line contains two integers separated by a space *x*2, *y*2 (<=-<=106<=≤<=*x*2,<=*y*2<=≤<=106) — the coordinates of the university you are studying at.

The third line contains an integer *n* (1<=≤<=*n*<=≤<=300) — the number of roads in the city. The following *n* lines contain 3 space-separated integers (<=-<=106<=≤<=*a**i*,<=*b**i*,<=*c**i*<=≤<=106; |*a**i*|<=+<=|*b**i*|<=&gt;<=0) — the coefficients of the line *a**i**x*<=+<=*b**i**y*<=+<=*c**i*<==<=0, defining the *i*-th road. It is guaranteed that no two roads are the same. In addition, neither your home nor the university lie on the road (i.e. they do not belong to any one of the lines).",Output the answer to the problem.,"['1 1\n-1 -1\n2\n0 1 0\n1 0 0\n', '1 1\n-1 -1\n3\n1 0 0\n0 1 0\n1 1 -3\n']","['2\n', '2\n']","Pictures to the samples are presented below (A is the point representing the house; B is the point representing the university, different blocks are filled with different colors):",OK,"x1,y1=map(int,input().split())
x2,y2=map(int,input().split())
a1=y1-y2
b1=x2-x1
c1=x2*(y2-y1)-y2*(x2-x1)
def intersect(a2,b2,c2):
         global a1,b1,c1,x1,y1,x2,y2
         if(a1*b2==a2*b1):
                  return False
         x=(b1*c2-b2*c1)/(a1*b2-b1*a2)
         y=(a1*c2-c1*a2)/(b1*a2-a1*b2)
         if(min(x1,x2)<=x<=max(x1,x2) and min(y1,y2)<=y<=max(y1,y2)):
                  return True
         return False
m=int(input())
ans=0
for i in range(m):
         a2,b2,c2=map(int,input().split())
         if(intersect(a2,b2,c2)):
                  ans+=1
print(ans)","from collections import defaultdict, deque

def is_on_road(x, y, a, b, c):
    return a * x + b * y + c <= 0

def build_adjacency(roads):
    adjacency = defaultdict(list)
    road_count = len(roads)
    for i in range(road_count):
        for j in range(i + 1, road_count):

            if road_intersect(roads[i], roads[j]):
                adjacency[i].append(j)
                adjacency[j].append(i)
    return adjacency

def road_intersect(road1, road2):
    a1, b1, c1 = road1
    a2, b2, c2 = road2

    if a1 * b2 == a2 * b1:
        return False
    return True

def bfs(start_block, target_block, adjacency):
    queue = deque([start_block])
    visited = {start_block}
    steps = 0

    while queue:
        for _ in range(len(queue)):
            current = queue.popleft()
            if current == target_block:
                return steps
            
            for neighbor in adjacency[current]:
                if neighbor not in visited:
                    visited.add(neighbor)
                    queue.append(neighbor)
        
        steps += 1

    return -1

def main():

    home = tuple(map(int, input().split()))
    university = tuple(map(int, input().split()))
    n = int(input().strip())
    
    roads = []
    for _ in range(n):
        roads.append(tuple(map(int, input().split())))

    home_block = None
    university_block = None

    for i, road in enumerate(roads):
        if is_on_road(home[0], home[1], *road):
            home_block = i
        if is_on_road(university[0], university[1], *road):
            university_block = i

    adjacency = build_adjacency(roads)
    
    if home_block is None or university_block is None:
        print(-1)
        return

    result = bfs(home_block, university_block, adjacency)
    print(result)

if __name__ == '__main__':
    main()"
24,E,Berland collider,PROGRAMMING,['binary search'],"Recently the construction of Berland collider has been completed. Collider can be represented as a long narrow tunnel that contains *n* particles. We associate with collider 1-dimensional coordinate system, going from left to right. For each particle we know its coordinate and velocity at the moment of start of the collider. The velocities of the particles don't change after the launch of the collider. Berland scientists think that the big bang will happen at the first collision of particles, whose velocities differs in directions. Help them to determine how much time elapses after the launch of the collider before the big bang happens.","The first line contains single integer *n* (1<=≤<=*n*<=≤<=5·105) — amount of particles in the collider. Next *n* lines contain description of particles. Each particle is described by two integers *x**i*, *v**i* (<=-<=109<=≤<=*x**i*,<=*v**i*<=≤<=109,<=*v**i*<=≠<=0) — coordinate and velocity respectively. All the coordinates are distinct. The particles are listed in order of increasing of coordinates. All the coordinates are in meters, and all the velocities — in meters per second. The negative velocity means that after the start of collider the particle will move to the left, and the positive — that the particle will move to the right.","If there will be no big bang, output -1. Otherwise output one number — how much time in seconds elapses after the launch of the collider before the big bang happens. Your answer must have a relative or absolute error less than 10<=-<=9.","['3\n-5 9\n0 1\n5 -1\n', '6\n1 3\n2 3\n3 3\n4 -3\n5 -1\n6 -100\n']","['1.00000000000000000000\n', '0.02912621359223301065\n']",none,TIME_LIMIT_EXCEEDED,"def can(particles, mid, pl, pr):
    pos_right = particles[pr][0]
    pos_left = particles[pl][0]

    for i in range(pr, pl + 1):
        x, v = particles[i]
        aux = x + v * mid

        if v > 0:
            if aux > pos_right:
                pos_right = aux
                pos_left = particles[pl][0]
        else:
            if aux < pos_left:
                pos_left = aux

        if pos_left <= pos_right:
            return True

    return False

def main():
    n = int(input())
    particles = [tuple(map(int, input().split())) for _ in range(n)]

    pl = -1
    pr = 500000

    for i in range(n):
        if particles[i][1] > 0:
            pr = i
            break

    for j in range(n - 1, -1, -1):
        if particles[j][1] < 0:
            pl = j
            break

    if pr > pl:
        print(-1)
        return

    ans = 0
    left, right = 0.0, 1e9

    for _ in range(200):
        mid = (left + right) / 2.0

        if can(particles, mid, pl, pr):
            right = mid
        else:
            left = mid

    print(right)

main()","def big_bang_time(n, particles):

    min_time = float('inf')
    found_collision = False

    for i in range(n - 1):
        x1, v1 = particles[i]
        x2, v2 = particles[i + 1]

        if v1 > v2:

            time_to_collision = (x2 - x1) / (v1 - v2)
            if time_to_collision >= 0:
                found_collision = True
                min_time = min(min_time, time_to_collision)

    if found_collision:
        return min_time
    else:
        return -1

import sys
input = sys.stdin.read
data = input().splitlines()

n = int(data[0])

particles = []
for i in range(1, n + 1):
    x, v = map(int, data[i].split())
    particles.append((x, v))

result = big_bang_time(n, particles)
if result == -1:
    print(-1)
else:
    print(f""{result:.20f}"")"
786,C,Till I Collapse,PROGRAMMING,"['data structures', 'divide and conquer']","Rick and Morty want to find MR. PBH and they can't do it alone. So they need of Mr. Meeseeks. They Have generated *n* Mr. Meeseeks, standing in a line numbered from 1 to *n*. Each of them has his own color. *i*-th Mr. Meeseeks' color is *a**i*. 

Rick and Morty are gathering their army and they want to divide Mr. Meeseeks into some squads. They don't want their squads to be too colorful, so each squad should have Mr. Meeseeks of at most *k* different colors. Also each squad should be a continuous subarray of Mr. Meeseeks in the line. Meaning that for each 1<=≤<=*i*<=≤<=*e*<=≤<=*j*<=≤<=*n*, if Mr. Meeseeks number *i* and Mr. Meeseeks number *j* are in the same squad then Mr. Meeseeks number *e* should be in that same squad.

Also, each squad needs its own presidio, and building a presidio needs money, so they want the total number of squads to be minimized.

Rick and Morty haven't finalized the exact value of *k*, so in order to choose it, for each *k* between 1 and *n* (inclusive) need to know the minimum number of presidios needed.","The first line of input contains a single integer *n* (1<=≤<=*n*<=≤<=105) — number of Mr. Meeseeks.

The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* separated by spaces (1<=≤<=*a**i*<=≤<=*n*) — colors of Mr. Meeseeks in order they standing in a line.",In the first and only line of input print *n* integers separated by spaces. *i*-th integer should be the minimum number of presidios needed if the value of *k* is *i*.,"['5\n1 3 4 3 3\n', '8\n1 5 7 8 1 7 6 1\n']","['4 2 1 1 1 \n', '8 4 3 2 1 1 1 1 \n']","For the first sample testcase, some optimal ways of dividing army into squads for each *k* are:
 1.  [1], [3], [4], [3, 3] 1.  [1], [3, 4, 3, 3] 1.  [1, 3, 4, 3, 3] 1.  [1, 3, 4, 3, 3] 1.  [1, 3, 4, 3, 3] 
For the second testcase, some optimal ways of dividing army into squads for each *k* are:
 1.  [1], [5], [7], [8], [1], [7], [6], [1] 1.  [1, 5], [7, 8], [1, 7], [6, 1] 1.  [1, 5, 7], [8], [1, 7, 6, 1] 1.  [1, 5, 7, 8], [1, 7, 6, 1] 1.  [1, 5, 7, 8, 1, 7, 6, 1] 1.  [1, 5, 7, 8, 1, 7, 6, 1] 1.  [1, 5, 7, 8, 1, 7, 6, 1] 1.  [1, 5, 7, 8, 1, 7, 6, 1]",TIME_LIMIT_EXCEEDED,"import os,sys,collections,heapq,itertools
if os.path.exists('in.txt'):
    file = open('in.txt') 
    input =  file.readline 
else : 
    input = sys.stdin.readline  
from functools import reduce 
from itertools import accumulate,chain,combinations,count 
from itertools import groupby,permutations,product,zip_longest
from heapq import heapify,heappush,heappop,heapreplace,merge,nlargest,nsmallest
from collections import Counter,defaultdict,deque 
from bisect import bisect_left, bisect_right
from math import comb,floor,ceil,inf ,gcd  ,sqrt 
import functools 
readi = lambda: int(input()) 
readis = lambda: list(map(int,input().split()))
reads = lambda: input().rstrip() 
readss = lambda: input().split()   
def solution():  
    n = readi() 
    a = readis() 
    res = [0] * (n+1) 
    r = len(set(a)) 
    res[r] = 1 
    res[1] = len(list(groupby(a))) 
    q = [(1,r)]  
    def f(k): 
        m = 0 
        C = set() 
        i = 0 
        while i < n :
            m += 1 
            C.clear()  
            while i < n:
                C.add(a[i]) 
                if len(C) > k : break 
                i += 1    
        return m 
    while q:
        l,r = q.pop() 
        if r - l <= 1 or res[l] == res[r] : continue 
        mid = (l+r) // 2 
        res[mid] = f(mid) 
        q += [(l,mid),(mid,r)] 
    for i in range(2,n+1):
        if not res[i] : res[i] = res[i-1] 
    print(*res[1:])
    
for i in range(1):
    solution()","def min_presidios(n, colors):
    results = []
    
    for k in range(1, n + 1):
        count = 0
        color_count = {}
        left = 0
        
        for right in range(n):
            color_count[colors[right]] = color_count.get(colors[right], 0) + 1

            while len(color_count) > k:
                color_count[colors[left]] -= 1
                if color_count[colors[left]] == 0:
                    del color_count[colors[left]]
                left += 1

            if right == n - 1 or len(color_count) > k:
                count += 1
                color_count.clear()
                left = right + 1
                right = left - 1
        
        results.append(count)

    return results

n = int(input().strip())
colors = list(map(int, input().strip().split()))

result = min_presidios(n, colors)

print("" "".join(map(str, result)))"
230,B,T-primes,PROGRAMMING,"['binary search', 'implementation', 'math', 'number theory']","We know that prime numbers are positive integers that have exactly two distinct positive divisors. Similarly, we'll call a positive integer *t* Т-prime, if *t* has exactly three distinct positive divisors.

You are given an array of *n* positive integers. For each of them determine whether it is Т-prime or not.","The first line contains a single positive integer, *n* (1<=≤<=*n*<=≤<=105), showing how many numbers are in the array. The next line contains *n* space-separated integers *x**i* (1<=≤<=*x**i*<=≤<=1012).

Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is advised to use the cin, cout streams or the %I64d specifier.","Print *n* lines: the *i*-th line should contain ""YES"" (without the quotes), if number *x**i* is Т-prime, and ""NO"" (without the quotes), if it isn't.",['3\n4 5 6\n'],['YES\nNO\nNO\n'],"The given test has three numbers. The first number 4 has exactly three divisors — 1, 2 and 4, thus the answer for this number is ""YES"". The second number 5 has two divisors (1 and 5), and the third number 6 has four divisors (1, 2, 3, 6), hence the answer for them is ""NO"".",TIME_LIMIT_EXCEEDED,"def is_prime4(x):
    if (x == 2) or (x == 3):
        return True
    if (x % 6 != 1) and (x % 6 != 5):
        return False
    for i in range(5, int(x ** 0.5) + 1, 6):
        if (x % i == 0) or (x % (i + 2) == 0):
            return False
    return True
n=int(input())
s=[int(i) for i in input().split()]
for i in range(0,n):
    if(s[i]==1):
        print(""NO"")
        continue
    num=s[i]**0.5
    if(num==int(num)):
        num=int(num)
        if(is_prime4(num)):
            print(""YES"")
        else:
            print(""NO"")
    else:
        print(""NO"")","import sys
import math

def is_t_prime(num):
    """"""Check if a number is T-prime.""""""
    if num < 2:
        return False
    sqrt_num = int(math.isqrt(num))

    return sqrt_num * sqrt_num == num and is_prime(sqrt_num)

def is_prime(num):
    """"""Check if a number is prime.""""""
    if num < 2:
        return False
    for i in range(2, int(math.isqrt(num)) + 1):
        if num % i == 0:
            return False
    return True

def main():
    input = sys.stdin.read
    data = input().splitlines()
    
    n = int(data[0])
    numbers = list(map(int, data[1].split()))

    results = []
    for number in numbers:
        if is_t_prime(number):
            results.append(""YES"")
        else:
            results.append(""NO"")

    print(""\n"".join(results))

if __name__ == ""__main__"":
    main()"
534,A,Exam,PROGRAMMING,"['constructive algorithms', 'implementation', 'math']","An exam for *n* students will take place in a long and narrow room, so the students will sit in a line in some order. The teacher suspects that students with adjacent numbers (*i* and *i*<=+<=1) always studied side by side and became friends and if they take an exam sitting next to each other, they will help each other for sure.

Your task is to choose the maximum number of students and make such an arrangement of students in the room that no two students with adjacent numbers sit side by side.",A single line contains integer *n* (1<=≤<=*n*<=≤<=5000) — the number of students at an exam.,"In the first line print integer *k* — the maximum number of students who can be seated so that no two students with adjacent numbers sit next to each other.

In the second line print *k* distinct integers *a*1,<=*a*2,<=...,<=*a**k* (1<=≤<=*a**i*<=≤<=*n*), where *a**i* is the number of the student on the *i*-th position. The students on adjacent positions mustn't have adjacent numbers. Formally, the following should be true: |*a**i*<=-<=*a**i*<=+<=1|<=≠<=1 for all *i* from 1 to *k*<=-<=1.

If there are several possible answers, output any of them.","['6', '3\n']","['6\n1 5 3 6 2 4', '2\n1 3']",none,OK,"def odd(lst,n):
    for i in range(1,n+1,2):
        lst.append(i)
    
def even(lst,n):
        start=2
        if len(lst)==1 or n==3:
            start=4
        for j in range(start,n+1,2):
            lst.append(j)    

n=int(input())
lst=[]

if n%2==0 and n>2:
    even(lst, n)
    odd(lst, n)  
   
else:
    
    odd(lst, n)
    even(lst, n)
print(len(lst))
print(*lst)","def arrange_students(n):

    students = []

    for i in range(1, n + 1):
        if i % 2 != 0:
            students.append(i)

    for i in range(1, n + 1):
        if i % 2 == 0 and len(students) < n:
            students.append(i)

    print(len(students))

    print("" "".join(map(str, students)))

n = int(input().strip())
arrange_students(n)"
518,B,Tanya and Postcard,PROGRAMMING,"['greedy', 'implementation', 'strings']","Little Tanya decided to present her dad a postcard on his Birthday. She has already created a message — string *s* of length *n*, consisting of uppercase and lowercase English letters. Tanya can't write yet, so she found a newspaper and decided to cut out the letters and glue them into the postcard to achieve string *s*. The newspaper contains string *t*, consisting of uppercase and lowercase English letters. We know that the length of string *t* greater or equal to the length of the string *s*.

The newspaper may possibly have too few of some letters needed to make the text and too many of some other letters. That's why Tanya wants to cut some *n* letters out of the newspaper and make a message of length exactly *n*, so that it looked as much as possible like *s*. If the letter in some position has correct value and correct letter case (in the string *s* and in the string that Tanya will make), then she shouts joyfully ""YAY!"", and if the letter in the given position has only the correct value but it is in the wrong case, then the girl says ""WHOOPS"".

Tanya wants to make such message that lets her shout ""YAY!"" as much as possible. If there are multiple ways to do this, then her second priority is to maximize the number of times she says ""WHOOPS"". Your task is to help Tanya make the message.","The first line contains line *s* (1<=≤<=|*s*|<=≤<=2·105), consisting of uppercase and lowercase English letters — the text of Tanya's message.

The second line contains line *t* (|*s*|<=≤<=|*t*|<=≤<=2·105), consisting of uppercase and lowercase English letters — the text written in the newspaper.

Here |*a*| means the length of the string *a*.","Print two integers separated by a space:
 -  the first number is the number of times Tanya shouts ""YAY!"" while making the message, -  the second number is the number of times Tanya says ""WHOOPS"" while making the message.","['AbC\nDCbA\n', 'ABC\nabc\n', 'abacaba\nAbaCaBA\n']","['3 0\n', '0 3\n', '3 4\n']",none,WRONG_ANSWER,"import heapq;
stringOne = input()
stringTwo = input()
hashMapOne = {char: 0 for char in stringOne}
hashMapTwo = {char: 0 for char in stringTwo}
for char in stringOne:
    hashMapOne[char] += 1

for char in stringTwo:
    hashMapTwo[char] += 1

yay = 0
whoo = 0
heap = []
for char in hashMapTwo:
    heapq.heappush(heap, (-hashMapTwo[char], char))

def solve(char, casedChar):
    yay = 0
    whoo = 0
    currentMin = min(hashMapOne[char], hashMapTwo[char]
                     ) if char in hashMapOne else 0
    yay += currentMin
    hashMapTwo[char] -= currentMin
    if char in hashMapOne:
        hashMapOne[char] -= currentMin
        if hashMapOne[char] == 0:
            hashMapOne.pop(char)

    currentMin = min(hashMapOne[casedChar], hashMapTwo[char]
                     ) if casedChar in hashMapOne else 0
    whoo += currentMin
    hashMapTwo[char] -= currentMin
    if casedChar in hashMapOne:
        hashMapOne[casedChar] -= currentMin
        if hashMapOne[casedChar] == 0:
            hashMapOne.pop(casedChar)
    return (yay, whoo)

while(len(heap)):
    count, char = heapq.heappop(heap)
    if char.islower():
        if char not in hashMapOne and char.upper() not in hashMapOne:
            continue
        currentYayy, currentWhoo = solve(char, char.upper())
        yay += currentYayy
        whoo += currentWhoo
    else:
        if char not in hashMapOne and char.lower() not in hashMapOne:
            continue
        currentYayy, currentWhoo = solve(char, char.lower())
        yay += currentYayy
        whoo += currentWhoo

    if hashMapTwo[char] > 0:
        heapq.heappush(heap, (-hashMapTwo[char], char))

print(yay, whoo)","def calculate_happiness(s, t):

    from collections import Counter
    
    count_t = Counter(t)
    
    yay_count = 0
    whoops_count = 0

    for char in s:
        if count_t[char] > 0:
            yay_count += 1
            count_t[char] -= 1
        elif count_t[char.lower()] > 0:
            whoops_count += 1
            count_t[char.lower()] -= 1

    return yay_count, whoops_count

if __name__ == ""__main__"":
    import sys
    input = sys.stdin.read
    data = input().strip().split('\n')
    
    results = []
    for i in range(0, len(data), 2):
        s = data[i].strip()
        t = data[i + 1].strip()
        yay, whoops = calculate_happiness(s, t)
        results.append(f""{yay} {whoops}"")

    print(""\n"".join(results))"
727,C,Guess the Array,PROGRAMMING,"['constructive algorithms', 'interactive', 'math']","This is an interactive problem. You should use flush operation after each printed line. For example, in C++ you should use fflush(stdout), in Java you should use System.out.flush(), and in Pascal — flush(output).

In this problem you should guess an array *a* which is unknown for you. The only information you have initially is the length *n* of the array *a*.

The only allowed action is to ask the sum of two elements by their indices. Formally, you can print two indices *i* and *j* (the indices should be distinct). Then your program should read the response: the single integer equals to *a**i*<=+<=*a**j*.

It is easy to prove that it is always possible to guess the array using at most *n* requests.

Write a program that will guess the array *a* by making at most *n* requests.",none,none,['5\n\xa0\n9\n\xa0\n7\n\xa0\n9\n\xa0\n11\n\xa0\n6\n\xa0'],['? 1 5\n\xa0\n? 2 3\n\xa0\n? 4 1\n\xa0\n? 5 2\n\xa0\n? 3 4\n\xa0\n! 4 6 1 5 5'],"The format of a test to make a hack is:
 -  The first line contains an integer number *n* (3 ≤ *n* ≤ 5000) — the length of the array.-  The second line contains *n* numbers *a*<sub class=""lower-index"">1</sub>, *a*<sub class=""lower-index"">2</sub>, ..., *a*<sub class=""lower-index"">*n*</sub> (1 ≤ *a*<sub class=""lower-index"">*i*</sub> ≤ 10<sup class=""upper-index"">5</sup>) — the elements of the array to guess.",IDLENESS_LIMIT_EXCEEDED,"from math import ceil,gcd,floor
from collections import deque,defaultdict as dict
from heapq import heappush as hpush,heappop as hpop, heapify
from functools import lru_cache
import sys
input = sys.stdin.buffer.readline
inf=float(""inf"")

def inpi(): return(int(input()))
def inpa(): return(list(map(int,input().split())))
def inp(): s = input();return(list(s))
def inpv(): return(map(int,input().split()))

n=int(input())

d={}
for i in range(2,n+1):
	print(""?"",1,i)
	sys.stdout.flush()
	d[i]=int(input())
print(""?"",2,3)
k=inpi()
d[1]=(d[2]+d[3]-k)//2
print(""!"",d[1],end="" "")
for i in range(2,n+1):
	print(d[i]-d[1],end="" "")
sys.stdout.flush()","import sys
import time

def flush():
    sys.stdout.flush()

def main():
    n = int(input().strip())
    sums = [0] * n
    a = [0] * n

    for i in range(1, n):
        print(f""? 1 {i + 1}"")
        flush()
        sums[i] = int(input().strip())
        time.sleep(0.01)

    for i in range(2, n + 1):
        print(f""? {i} {1}"")
        flush()
        a[i - 1] = sums[i - 1] - int(input().strip())
        time.sleep(0.01)

    a[0] = sums[1] - a[1]

    print(""! "" + "" "".join(map(str, a)))
    flush()

if __name__ == ""__main__"":
    main()"
743,B,Chloe and the sequence ,PROGRAMMING,"['binary search', 'bitmasks', 'constructive algorithms', 'implementation']","Chloe, the same as Vladik, is a competitive programmer. She didn't have any problems to get to the olympiad like Vladik, but she was confused by the task proposed on the olympiad.

Let's consider the following algorithm of generating a sequence of integers. Initially we have a sequence consisting of a single element equal to 1. Then we perform (*n*<=-<=1) steps. On each step we take the sequence we've got on the previous step, append it to the end of itself and insert in the middle the minimum positive integer we haven't used before. For example, we get the sequence [1,<=2,<=1] after the first step, the sequence [1,<=2,<=1,<=3,<=1,<=2,<=1] after the second step.

The task is to find the value of the element with index *k* (the elements are numbered from 1) in the obtained sequence, i. e. after (*n*<=-<=1) steps.

Please help Chloe to solve the problem!","The only line contains two integers *n* and *k* (1<=≤<=*n*<=≤<=50, 1<=≤<=*k*<=≤<=2*n*<=-<=1).",Print single integer — the integer at the *k*-th position in the obtained sequence.,"['3 2\n', '4 8\n']","['2', '4']","In the first sample the obtained sequence is [1, 2, 1, 3, 1, 2, 1]. The number on the second position is 2.

In the second sample the obtained sequence is [1, 2, 1, 3, 1, 2, 1, 4, 1, 2, 1, 3, 1, 2, 1]. The number on the eighth position is 4.",WRONG_ANSWER,"N, K = map(int, input().split())
L = [0] * 60
L[0] = 1
for i in range(1, 60):
    L[i] = 2 * L[i - 1] + 1

def calc(n, k):
    if k == L[n] // 2:
        return n + 1
    elif k > L[n] // 2:
        return calc(n - 1, k - L[n] // 2)
    else:
        return calc(n - 1, k)

print(calc(N - 1, K - 1))","def find_kth_element(n, k):

    sequence = [1]

    for i in range(1, n + 1):

        mid_value = i + 1

        sequence = sequence + [mid_value] + sequence

    return sequence[k - 1]

inputs = ['3 2\n', '4 8\n']
results = []

for input_string in inputs:
    n, k = map(int, input_string.strip().split())
    result = find_kth_element(n, k)
    results.append(result)

for res in results:
    print(res)"
408,A,Line to Cashier,PROGRAMMING,['implementation'],"Little Vasya went to the supermarket to get some groceries. He walked about the supermarket for a long time and got a basket full of products. Now he needs to choose the cashier to pay for the products.

There are *n* cashiers at the exit from the supermarket. At the moment the queue for the *i*-th cashier already has *k**i* people. The *j*-th person standing in the queue to the *i*-th cashier has *m**i*,<=*j* items in the basket. Vasya knows that:
 -  the cashier needs 5 seconds to scan one item; -  after the cashier scans each item of some customer, he needs 15 seconds to take the customer's money and give him the change. 
Of course, Vasya wants to select a queue so that he can leave the supermarket as soon as possible. Help him write a program that displays the minimum number of seconds after which Vasya can get to one of the cashiers.","The first line contains integer *n* (1<=≤<=*n*<=≤<=100) — the number of cashes in the shop. The second line contains *n* space-separated integers: *k*1,<=*k*2,<=...,<=*k**n* (1<=≤<=*k**i*<=≤<=100), where *k**i* is the number of people in the queue to the *i*-th cashier.

The *i*-th of the next *n* lines contains *k**i* space-separated integers: *m**i*,<=1,<=*m**i*,<=2,<=...,<=*m**i*,<=*k**i* (1<=≤<=*m**i*,<=*j*<=≤<=100) — the number of products the *j*-th person in the queue for the *i*-th cash has.",Print a single integer — the minimum number of seconds Vasya needs to get to the cashier.,"['1\n1\n1\n', '4\n1 4 3 2\n100\n1 2 2 3\n1 9 1\n7 8\n']","['20\n', '100\n']","In the second test sample, if Vasya goes to the first queue, he gets to the cashier in 100·5 + 15 = 515 seconds. But if he chooses the second queue, he will need 1·5 + 2·5 + 2·5 + 3·5 + 4·15 = 100 seconds. He will need 1·5 + 9·5 + 1·5 + 3·15 = 100 seconds for the third one and 7·5 + 8·5 + 2·15 = 105 seconds for the fourth one. Thus, Vasya gets to the cashier quicker if he chooses the second or the third queue.",OK,"class CodeforcesTask408ASolution:
    def __init__(self):
        self.result = ''
        self.cash_count = 0
        self.client_cashwise = []
        self.baskets = []

    def read_input(self):
        self.cash_count = int(input())
        self.client_cashwise = [int(x) for x in input().split("" "")]
        for x in range(self.cash_count):
            self.baskets.append([int(x) for x in input().split("" "")])

    def process_task(self):
        times = [len(x) * 15 + 5 * sum(x) for x in self.baskets]
        self.result = str(min(times))

    def get_result(self):
        return self.result

if __name__ == ""__main__"":
    Solution = CodeforcesTask408ASolution()
    Solution.read_input()
    Solution.process_task()
    print(Solution.get_result())","def calculate_time(queue):
    total_time = 0
    for items in queue:

        total_time += items * 5

        total_time += 15
    return total_time

def main():
    import sys
    
    input_data = sys.stdin.read().strip().split('\n')
    n = int(input_data[0])
    k = list(map(int, input_data[1].split()))
    queues = []

    for i in range(2, 2 + n):

        queues.append(list(map(int, input_data[i].split())))

    min_time = float('inf')

    for queue in queues:
        current_time = calculate_time(queue)
        if current_time < min_time:
            min_time = current_time

    print(min_time)

if __name__ == ""__main__"":
    main()"
645,A,Amity Assessment,PROGRAMMING,"['brute force', 'constructive algorithms', 'implementation']","Bessie the cow and her best friend Elsie each received a sliding puzzle on Pi Day. Their puzzles consist of a 2<=×<=2 grid and three tiles labeled 'A', 'B', and 'C'. The three tiles sit on top of the grid, leaving one grid cell empty. To make a move, Bessie or Elsie can slide a tile adjacent to the empty cell into the empty cell as shown below:

In order to determine if they are truly Best Friends For Life (BFFLs), Bessie and Elsie would like to know if there exists a sequence of moves that takes their puzzles to the same configuration (moves can be performed in both puzzles). Two puzzles are considered to be in the same configuration if each tile is on top of the same grid cell in both puzzles. Since the tiles are labeled with letters, rotations and reflections are not allowed.","The first two lines of the input consist of a 2<=×<=2 grid describing the initial configuration of Bessie's puzzle. The next two lines contain a 2<=×<=2 grid describing the initial configuration of Elsie's puzzle. The positions of the tiles are labeled 'A', 'B', and 'C', while the empty cell is labeled 'X'. It's guaranteed that both puzzles contain exactly one tile with each letter and exactly one empty position.","Output ""YES""(without quotes) if the puzzles can reach the same configuration (and Bessie and Elsie are truly BFFLs). Otherwise, print ""NO"" (without quotes).","['AB\nXC\nXB\nAC\n', 'AB\nXC\nAC\nBX\n']","['YES\n', 'NO\n']","The solution to the first sample is described by the image. All Bessie needs to do is slide her 'A' tile down.

In the second sample, the two puzzles can never be in the same configuration. Perhaps Bessie and Elsie are not meant to be friends after all...",WRONG_ANSWER,"def solve(s):
    tem = ''
    for j in range(4):
        ix = (i + j) % 4
        if s[ix] != 'X':
            tem += s[ix]

    if tem in mem:
        exit(print('YES'))
    mem[tem] = True

a, b, mem = input() + input()[::-1], input() + input()[::-1], dict()
for i in range(4):
    solve(a)
    solve(b)

print('NO')","def can_reach_same_configuration(bessie, elsie):
    from collections import deque

    def get_possible_moves(state):

        empty_pos = state.index('X')
        x, y = divmod(empty_pos, 2)
        moves = []

        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]
        
        for dx, dy in directions:
            nx, ny = x + dx, y + dy
            if 0 <= nx < 2 and 0 <= ny < 2:
                new_empty_pos = nx * 2 + ny

                new_state = list(state)
                new_state[empty_pos], new_state[new_empty_pos] = new_state[new_empty_pos], new_state[empty_pos]
                moves.append(''.join(new_state))
        
        return moves

    def bfs(initial_state):
        visited = set()
        queue = deque([initial_state])
        visited.add(initial_state)

        while queue:
            current_state = queue.popleft()
            for next_state in get_possible_moves(current_state):
                if next_state not in visited:
                    visited.add(next_state)
                    queue.append(next_state)
        return visited

    bessie_flat = ''.join(bessie)
    elsie_flat = ''.join(elsie)

    bessie_reachable = bfs(bessie_flat)
    elsie_reachable = bfs(elsie_flat)

    for config in bessie_reachable:
        if config in elsie_reachable:
            return ""YES""
    
    return ""NO""

bessie_input = [input().strip() for _ in range(2)]
elsie_input = [input().strip() for _ in range(2)]

print(can_reach_same_configuration(bessie_input, elsie_input))"
272,A,Dima and Friends,PROGRAMMING,"['implementation', 'math']","Dima and his friends have been playing hide and seek at Dima's place all night. As a result, Dima's place got messy. In the morning they decided that they need to clean the place.

To decide who exactly would clean the apartment, the friends want to play a counting-out game. First, all the guys stand in a circle, and then each of them shows some number of fingers on one hand (one to five), and then the boys count in a circle, starting from Dima, the number of people, respective to the total number of fingers shown. The person on who the countdown stops will clean the apartment.

For example, if Dima and one of his friends played hide and seek, and 7 fingers were shown during the counting-out, then Dima would clean the place. If there were 2 or say, 8 fingers shown, then his friend would clean the place.

Dima knows how many fingers each of his friends will show during the counting-out. Now he is interested in the number of ways to show some number of fingers on one hand (one to five), so that he did not have to clean the place. Help Dima.","The first line contains integer *n* (1<=≤<=*n*<=≤<=100) — the number of Dima's friends. Dima himself isn't considered to be his own friend. The second line contains *n* positive integers, not exceeding 5, representing, how many fingers the Dima's friends will show. 

The numbers in the lines are separated by a single space.",In a single line print the answer to the problem.,"['1\n1\n', '1\n2\n', '2\n3 5\n']","['3\n', '2\n', '3\n']","In the first sample Dima can show 1, 3 or 5 fingers. If Dima shows 3 fingers, then the counting-out will go like that: Dima, his friend, Dima, his friend.

In the second sample Dima can show 2 or 4 fingers.",OK,"""""""
sumOfFinger=sum(fingerShownByFriends)
Dima can show 1 to 5 fingers..
so 
k = [sumOfFingers+i for i in range(1,6)]
now we've to check if k[i] prsenet in arithmetic progression whose firstVal=1 and diff=numOfFriens+1
if k[i] is present==
	=>>then it means if Dima shows i+1 fingers then..
			=>>then counting will end on Dima & hence he'll have to clean the place
""""""

def willCountingEndOnDima(n,d):

	a=1
	return (n-a)%d==0
noOfFriends=int(input())
frndsFingers=list(map(int,input().split("" "")))
sumOfFinger=sum(frndsFingers)
noOfWays=5
for fingerShownByDima in range(1,6):
	if willCountingEndOnDima(sumOfFinger+fingerShownByDima, noOfFriends+1):
		noOfWays-=1
print(noOfWays)","def count_ways_to_avoid_cleaning(n, friends_fingers):
    total_fingers = sum(friends_fingers)
    ways = 0

    for dima_fingers in range(1, 6):

        total = total_fingers + dima_fingers

        if total % (n + 1) != 1:
            ways += 1

    return ways

n = int(input().strip())
friends_fingers = list(map(int, input().strip().split()))

result = count_ways_to_avoid_cleaning(n, friends_fingers)
print(result)"
362,B,Petya and Staircases,PROGRAMMING,"['implementation', 'sortings']","Little boy Petya loves stairs very much. But he is bored from simple going up and down them — he loves jumping over several stairs at a time. As he stands on some stair, he can either jump to the next one or jump over one or two stairs at a time. But some stairs are too dirty and Petya doesn't want to step on them.

Now Petya is on the first stair of the staircase, consisting of *n* stairs. He also knows the numbers of the dirty stairs of this staircase. Help Petya find out if he can jump through the entire staircase and reach the last stair number *n* without touching a dirty stair once.

One has to note that anyway Petya should step on the first and last stairs, so if the first or the last stair is dirty, then Petya cannot choose a path with clean steps only.","The first line contains two integers *n* and *m* (1<=≤<=*n*<=≤<=109, 0<=≤<=*m*<=≤<=3000) — the number of stairs in the staircase and the number of dirty stairs, correspondingly. The second line contains *m* different space-separated integers *d*1,<=*d*2,<=...,<=*d**m* (1<=≤<=*d**i*<=≤<=*n*) — the numbers of the dirty stairs (in an arbitrary order).","Print ""YES"" if Petya can reach stair number *n*, stepping only on the clean stairs. Otherwise print ""NO"".","['10 5\n2 4 8 3 6\n', '10 5\n2 4 5 7 9\n']","['NO', 'YES']",none,WRONG_ANSWER,"class CodeforcesTask362BSolution:
    def __init__(self):
        self.result = ''
        self.n_m = []
        self.dirty = []

    def read_input(self):
        self.n_m = [int(x) for x in input().split("" "")]
        self.dirty = [int(x) for x in input().split("" "")]

    def process_task(self):
        dirty = {}
        for d in self.dirty:
            dirty[d] = True
        can_ = True
        for d in self.dirty:
            if d - 1 in dirty and d + 1 in dirty:
                can_ = False
                break
        self.result = ""YES"" if can_ else ""NO""

    def get_result(self):
        return self.result

if __name__ == ""__main__"":
    Solution = CodeforcesTask362BSolution()
    Solution.read_input()
    Solution.process_task()
    print(Solution.get_result())","n, m = map(int, input().split())

dirty_stairs = list(map(int, input().split()))

if 1 in dirty_stairs or n in dirty_stairs:
    print(""NO"")
    exit()

dirty_stairs.sort()

for i in range(len(dirty_stairs) - 1):

    if dirty_stairs[i + 1] == dirty_stairs[i] + 1:
        print(""NO"")
        exit()

    if dirty_stairs[i + 1] == dirty_stairs[i] + 2:

        continue

print(""YES"")"
701,B,Cells Not Under Attack,PROGRAMMING,"['data structures', 'math']","Vasya has the square chessboard of size *n*<=×<=*n* and *m* rooks. Initially the chessboard is empty. Vasya will consequently put the rooks on the board one after another.

The cell of the field is under rook's attack, if there is at least one rook located in the same row or in the same column with this cell. If there is a rook located in the cell, this cell is also under attack.

You are given the positions of the board where Vasya will put rooks. For each rook you have to determine the number of cells which are not under attack after Vasya puts it on the board.","The first line of the input contains two integers *n* and *m* (1<=≤<=*n*<=≤<=100<=000, 1<=≤<=*m*<=≤<=*min*(100<=000,<=*n*2)) — the size of the board and the number of rooks. 

Each of the next *m* lines contains integers *x**i* and *y**i* (1<=≤<=*x**i*,<=*y**i*<=≤<=*n*) — the number of the row and the number of the column where Vasya will put the *i*-th rook. Vasya puts rooks on the board in the order they appear in the input. It is guaranteed that any cell will contain no more than one rook.","Print *m* integer, the *i*-th of them should be equal to the number of cells that are not under attack after first *i* rooks are put.","['3 3\n1 1\n3 1\n2 2\n', '5 2\n1 5\n5 1\n', '100000 1\n300 400\n']","['4 2 0 \n', '16 9 \n', '9999800001 \n']",On the picture below show the state of the board after put each of the three rooks. The cells which painted with grey color is not under the attack.,OK,"import sys
input = lambda:sys.stdin.readline()

int_arr = lambda: list(map(int,input().split()))
str_arr = lambda: list(map(str,input().split()))
get_str = lambda: map(str,input().split())
get_int = lambda: map(int,input().split())
get_flo = lambda: map(float,input().split())

mod = 1000000007

n,r = get_int()
c = 0
a,b = set(),set()
for _ in range(r):
	x,y = get_int()
	a.add(x);b.add(y)
	print((n-len(a))*(n-len(b)))","def count_safe_cells(n, m, positions):
    attacked_rows = set()
    attacked_cols = set()
    results = []

    for x, y in positions:
        attacked_rows.add(x)
        attacked_cols.add(y)

        total_attacked = len(attacked_rows) * n + len(attacked_cols) * n - len(attacked_rows) * len(attacked_cols)
        safe_cells = n * n - total_attacked
        results.append(safe_cells)

    return results

def main():
    import sys
    input = sys.stdin.read
    data = input().strip().splitlines()

    n, m = map(int, data[0].split())
    positions = [tuple(map(int, line.split())) for line in data[1:m+1]]
    
    results = count_safe_cells(n, m, positions)

    print("" "".join(map(str, results)))

if __name__ == ""__main__"":
    main()"
981,C,Useful Decomposition,PROGRAMMING,"['implementation', 'trees']","Ramesses knows a lot about problems involving trees (undirected connected graphs without cycles)!

He created a new useful tree decomposition, but he does not know how to construct it, so he asked you for help!

The decomposition is the splitting the edges of the tree in some simple paths in such a way that each two paths have at least one common vertex. Each edge of the tree should be in exactly one path.

Help Remesses, find such a decomposition of the tree or derermine that there is no such decomposition.","The first line contains a single integer $n$ ($2 \leq n \leq 10^{5}$) the number of nodes in the tree.

Each of the next $n<=-<=1$ lines contains two integers $a_i$ and $b_i$ ($1 \leq a_i, b_i \leq n$, $a_i \neq b_i$) — the edges of the tree. It is guaranteed that the given edges form a tree.","If there are no decompositions, print the only line containing ""No"".

Otherwise in the first line print ""Yes"", and in the second line print the number of paths in the decomposition $m$. 

Each of the next $m$ lines should contain two integers $u_i$, $v_i$ ($1 \leq u_i, v_i \leq n$, $u_i \neq v_i$) denoting that one of the paths in the decomposition is the simple path between nodes $u_i$ and $v_i$. 

Each pair of paths in the decomposition should have at least one common vertex, and each edge of the tree should be presented in exactly one path. You can print the paths and the ends of each path in arbitrary order.

If there are multiple decompositions, print any.","['4\n1 2\n2 3\n3 4\n', '6\n1 2\n2 3\n3 4\n2 5\n3 6\n', '5\n1 2\n1 3\n1 4\n1 5\n']","['Yes\n1\n1 4\n', 'No\n', 'Yes\n4\n1 2\n1 3\n1 4\n1 5\n']","The tree from the first example is shown on the picture below: <img class=""tex-graphics"" src=""https://espresso.codeforces.com/9eb4b4c143d3ad267ae05d1e43341bd368b3088b.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> The number next to each edge corresponds to the path number in the decomposition. It is easy to see that this decomposition suits the required conditions.

The tree from the second example is shown on the picture below: <img class=""tex-graphics"" src=""https://espresso.codeforces.com/20704b97182d9bcde3321c00a16edcae4d772d93.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> We can show that there are no valid decompositions of this tree.

The tree from the third example is shown on the picture below: <img class=""tex-graphics"" src=""https://espresso.codeforces.com/357ff9496a4ed4746401160ee6ee63f5d57d81b9.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> The number next to each edge corresponds to the path number in the decomposition. It is easy to see that this decomposition suits the required conditions.",WRONG_ANSWER,"import sys

def dfs(start, visited=set({})):
	ans = []
	visited.add(start)
	leaf = True
	for v in g[start]:
		if v not in visited:
			leaf = False
			ans += dfs(v)
	if leaf:
		return ans + [start]
	return ans

n = int(sys.stdin.readline().strip())
g = {i:[] for i in range(n+1)}
for _ in range(n-1):
	u,v = map(int,sys.stdin.readline().strip().split(' '))
	g[u].append(v)
	g[v].append(u)

acc = 0
middle = -1
for i in range(1,n+1):
	if len(g[i]) > 2:
		acc += 1
		middle = i
	if len(g[i]) == 2 and middle == -1:
		middle = i

if acc >= 2:
	print(""No"")
else:
	ans = dfs(middle)
	print(len(ans))
	for ai in ans:
		print(str(middle) + ' ' + str(ai))","def find_tree_decomposition(n, edges):
    from collections import defaultdict

    graph = defaultdict(list)
    for a, b in edges:
        graph[a].append(b)
        graph[b].append(a)

    for node in graph:
        if len(graph[node]) > 2:
            return ""No""

    paths = []

    for a, b in edges:
        if a > b:
            a, b = b, a
        paths.append((a, b))

    return ""Yes\n"" + str(len(paths)) + ""\n"" + ""\n"".join(f""{u} {v}"" for u, v in paths)

n = int(input())
edges = [tuple(map(int, input().split())) for _ in range(n-1)]

result = find_tree_decomposition(n, edges)
print(result)"
388,A,Fox and Box Accumulation,PROGRAMMING,"['greedy', 'sortings']","Fox Ciel has *n* boxes in her room. They have the same size and weight, but they might have different strength. The *i*-th box can hold at most *x**i* boxes on its top (we'll call *x**i* the strength of the box). 

Since all the boxes have the same size, Ciel cannot put more than one box directly on the top of some box. For example, imagine Ciel has three boxes: the first has strength 2, the second has strength 1 and the third has strength 1. She cannot put the second and the third box simultaneously directly on the top of the first one. But she can put the second box directly on the top of the first one, and then the third box directly on the top of the second one. We will call such a construction of boxes a pile.

Fox Ciel wants to construct piles from all the boxes. Each pile will contain some boxes from top to bottom, and there cannot be more than *x**i* boxes on the top of *i*-th box. What is the minimal number of piles she needs to construct?","The first line contains an integer *n* (1<=≤<=*n*<=≤<=100). The next line contains *n* integers *x*1,<=*x*2,<=...,<=*x**n* (0<=≤<=*x**i*<=≤<=100).",Output a single integer — the minimal possible number of piles.,"['3\n0 0 10\n', '5\n0 1 2 3 4\n', '4\n0 0 0 0\n', '9\n0 1 0 2 0 1 1 2 10\n']","['2\n', '1\n', '4\n', '3\n']","In example 1, one optimal way is to build 2 piles: the first pile contains boxes 1 and 3 (from top to bottom), the second pile contains only box 2.

In example 2, we can build only 1 pile that contains boxes 1, 2, 3, 4, 5 (from top to bottom).",WRONG_ANSWER,"from collections import Counter

def main():
    int(input())
    c = Counter(map(int, input().split()))
    ans = 1
    for k in c:
        ans = max(ans, c[k])

    print(ans)

main()","def min_piles(n, strengths):

    strength_count = [0] * 101

    for strength in strengths:
        strength_count[strength] += 1

    piles = 0

    for i in range(101):
        if strength_count[i] > 0:

            piles += strength_count[i]

            if i > 0:
                strength_count[i] += strength_count[i - 1] // i
    
    return piles

input_data = input().splitlines()
n = int(input_data[0])
strengths = list(map(int, input_data[1].split()))

result = min_piles(n, strengths)

print(result)"
166,B,Polygons,PROGRAMMING,"['geometry', 'sortings']","You've got another geometrical task. You are given two non-degenerate polygons *A* and *B* as vertex coordinates. Polygon *A* is strictly convex. Polygon *B* is an arbitrary polygon without any self-intersections and self-touches. The vertices of both polygons are given in the clockwise order. For each polygon no three consecutively following vertices are located on the same straight line.

Your task is to check whether polygon *B* is positioned strictly inside polygon *A*. It means that any point of polygon *B* should be strictly inside polygon *A*. ""Strictly"" means that the vertex of polygon *B* cannot lie on the side of the polygon *A*.","The first line contains the only integer *n* (3<=≤<=*n*<=≤<=105) — the number of vertices of polygon *A*. Then *n* lines contain pairs of integers *x**i*,<=*y**i* (|*x**i*|,<=|*y**i*|<=≤<=109) — coordinates of the *i*-th vertex of polygon *A*. The vertices are given in the clockwise order.

The next line contains a single integer *m* (3<=≤<=*m*<=≤<=2·104) — the number of vertices of polygon *B*. Then following *m* lines contain pairs of integers *x**j*,<=*y**j* (|*x**j*|,<=|*y**j*|<=≤<=109) — the coordinates of the *j*-th vertex of polygon *B*. The vertices are given in the clockwise order.

The coordinates of the polygon's vertices are separated by a single space. It is guaranteed that polygons *A* and *B* are non-degenerate, that polygon *A* is strictly convex, that polygon *B* has no self-intersections and self-touches and also for each polygon no three consecutively following vertices are located on the same straight line.","Print on the only line the answer to the problem — if polygon *B* is strictly inside polygon *A*, print ""YES"", otherwise print ""NO"" (without the quotes).","['6\n-2 1\n0 3\n3 3\n4 1\n3 -2\n2 -2\n4\n0 1\n2 2\n3 1\n1 0\n', '5\n1 2\n4 2\n3 -3\n-2 -2\n-2 1\n4\n0 1\n1 2\n4 1\n2 -1\n', '5\n-1 2\n2 3\n4 1\n3 -2\n0 -3\n5\n1 0\n1 1\n3 1\n5 -1\n2 -1\n']","['YES\n', 'NO\n', 'NO\n']",none,WRONG_ANSWER,"import sys

class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
 
def Left_index(points):
     
    minn = 0
    for i in range(1,len(points)):
        if points[i].x < points[minn].x:
            minn = i
        elif points[i].x == points[minn].x:
            if points[i].y > points[minn].y:
                minn = i
    return minn
 
def orientation(p, q, r):
    val = (q.y - p.y) * (r.x - q.x) - \
          (q.x - p.x) * (r.y - q.y)
 
    if val == 0:
        return 0
    elif val > 0:
        return 1
    else:
        return 2
 
def convexHull(points, n):
     
    if n < 3:
        return
 
    l = Left_index(points)
 
    hull = []
     
    p = l
    q = 0
    while(True):

        hull.append(p)
 
        q = (p + 1) % n
 
        for i in range(n):

            if(orientation(points[p],
                           points[i], points[q]) == 2):
                q = i
 
        p = q

        if(p == l):
            break
    mine = set()
    for each in hull:
        mine.add((points[each].x, points[each].y))
    return mine
    
poly = []
polyA = set()

n = int(sys.stdin.readline().strip())
for _ in range(n):
    tmp = sys.stdin.readline().split()
    x = int(tmp[0])
    y = int(tmp[1])
    polyA.add((x,y))
    poly.append(Point(x,y))

m = int(sys.stdin.readline().strip())
for _ in range(m):
    tmp = sys.stdin.readline().split()
    x = int(tmp[0])
    y = int(tmp[1])
    poly.append(Point(x,y))

c = convexHull(poly, len(poly))
if c == polyA:
    print(""YES"")
else:
    print(""NO"")","def is_point_in_convex_polygon(point, polygon):

    px, py = point
    n = len(polygon)
    for i in range(n):
        x1, y1 = polygon[i]
        x2, y2 = polygon[(i + 1) % n]

        cross = (x2 - x1) * (py - y1) - (y2 - y1) * (px - x1)
        if cross <= 0:
            return False
    return True

def is_polygon_inside_polygon(polygon_a, polygon_b):

    for vertex in polygon_b:
        if not is_point_in_convex_polygon(vertex, polygon_a):
            return ""NO""
    return ""YES""

def main():
    import sys
    input = sys.stdin.read
    data = input().splitlines()

    n = int(data[0])
    polygon_a = [tuple(map(int, data[i + 1].split())) for i in range(n)]

    m = int(data[n + 1])
    polygon_b = [tuple(map(int, data[n + 2 + i].split())) for i in range(m)]

    result = is_polygon_inside_polygon(polygon_a, polygon_b)
    print(result)

if __name__ == ""__main__"":
    main()"
373,A,Collecting Beats is Fun,PROGRAMMING,['implementation'],"Cucumber boy is fan of Kyubeat, a famous music game.

Kyubeat has 16 panels for playing arranged in 4<=×<=4 table. When a panel lights up, he has to press that panel.

Each panel has a timing to press (the preffered time when a player should press it), and Cucumber boy is able to press at most *k* panels in a time with his one hand. Cucumber boy is trying to press all panels in perfect timing, that is he wants to press each panel exactly in its preffered time. If he cannot press the panels with his two hands in perfect timing, his challenge to press all the panels in perfect timing will fail.

You are given one scene of Kyubeat's panel from the music Cucumber boy is trying. Tell him is he able to press all the panels in perfect timing.","The first line contains a single integer *k* (1<=≤<=*k*<=≤<=5) — the number of panels Cucumber boy can press with his one hand.

Next 4 lines contain 4 characters each (digits from 1 to 9, or period) — table of panels. If a digit *i* was written on the panel, it means the boy has to press that panel in time *i*. If period was written on the panel, he doesn't have to press that panel.","Output ""YES"" (without quotes), if he is able to press all the panels in perfect timing. If not, output ""NO"" (without quotes).","['1\n.135\n1247\n3468\n5789\n', '5\n..1.\n1111\n..1.\n..1.\n', '1\n....\n12.1\n.2..\n.2..\n']","['YES\n', 'YES\n', 'NO\n']","In the third sample boy cannot press all panels in perfect timing. He can press all the panels in timing in time 1, but he cannot press the panels in time 2 in timing with his two hands.",OK,"n = int(input())
n2 = n * 2

x = {}
o = ""YES""
for _ in range(4):
    r = input()

    for c in r:
        if c == ""."":
            continue

        x.setdefault(c, 0)
        x[c] += 1

        if x[c] > n2:
            o = ""NO""
            break
print(o)","def can_press_all_panels(k, panel_table):

    timing_count = {}

    for row in panel_table:
        for char in row:
            if char.isdigit():
                timing = int(char)
                if timing in timing_count:
                    timing_count[timing] += 1
                else:
                    timing_count[timing] = 1

    for count in timing_count.values():
        if count > k * 2:
            return ""NO""
    
    return ""YES""

import sys

input_data = sys.stdin.read().splitlines()
k = int(input_data[0])
panel_table = input_data[1:5]

result = can_press_all_panels(k, panel_table)
print(result)"
722,C,Destroying Array,PROGRAMMING,"['data structures', 'dsu']","You are given an array consisting of *n* non-negative integers *a*1,<=*a*2,<=...,<=*a**n*.

You are going to destroy integers in the array one by one. Thus, you are given the permutation of integers from 1 to *n* defining the order elements of the array are destroyed.

After each element is destroyed you have to find out the segment of the array, such that it contains no destroyed elements and the sum of its elements is maximum possible. The sum of elements in the empty segment is considered to be 0.","The first line of the input contains a single integer *n* (1<=≤<=*n*<=≤<=100<=000) — the length of the array.

The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (0<=≤<=*a**i*<=≤<=109). 

The third line contains a permutation of integers from 1 to *n* — the order used to destroy elements.","Print *n* lines. The *i*-th line should contain a single integer — the maximum possible sum of elements on the segment containing no destroyed elements, after first *i* operations are performed.","['4\n1 3 2 5\n3 4 1 2\n', '5\n1 2 3 4 5\n4 2 3 5 1\n', '8\n5 5 4 4 6 6 5 5\n5 2 8 7 1 3 4 6\n']","['5\n4\n3\n0\n', '6\n5\n5\n1\n0\n', '18\n16\n11\n8\n8\n6\n6\n0\n']","Consider the first sample: 
 1.  Third element is destroyed. Array is now 1 3  *  5. Segment with maximum sum 5 consists of one integer 5. 1.  Fourth element is destroyed. Array is now 1 3  *   * . Segment with maximum sum 4 consists of two integers 1 3. 1.  First element is destroyed. Array is now  *  3  *   * . Segment with maximum sum 3 consists of one integer 3. 1.  Last element is destroyed. At this moment there are no valid nonempty segments left in this array, so the answer is equal to 0.",TIME_LIMIT_EXCEEDED,"size = int(input())
num = list(map(int, input().split("" "")))
rem = list(map(lambda x: int(x) - 1, input().split("" "")))

def getTree(lst, l, r):
    if l == r:
        return {""s"": lst[l], ""li"": l, ""ri"": r}
    c = int((l + r) / 2)
    lt = getTree(lst, l, c)
    rt = getTree(lst, c + 1, r)
    return {
        ""li"": l, ""ri"": r,
        ""s"": lt[""s""] + rt[""s""],
        ""l"": lt,
        ""r"": rt
    }

def subsum(tree, l, r):
    if tree[""li""] == l and tree[""ri""] == r:
        return tree[""s""]
    c = int ((tree[""ri""] + tree[""li""]) / 2)
    if l >= tree[""li""] and r <= c:
        return subsum(tree[""l""], l, r)
    elif l > c and r <= tree[""ri""]:
        return subsum(tree[""r""], l, r)
    else:
        return subsum(tree[""l""], l, c) + subsum(tree[""r""], c + 1, r)

def remove(tree, i, s):
    tree[""s""] -= s
    if ""r"" in tree and ""l"" in tree:
        c = int((tree[""ri""] + tree[""li""]) / 2)
        if i <= c:
            remove(tree[""l""], i, s)
        else:
            remove(tree[""r""], i, s)

ll = len(num) - 1
tree = getTree(num, 0, ll)
parts = []
for i in rem:
    remove (tree, i, num[i])
    parts.append(i)
    parts = sorted(parts)
    x0 = 0
    ss = -1
    for r in range(len(parts)):
        x1 = parts[r]
        ss = max(ss, subsum(tree, x0, x1))
        x0 = x1
    ss = max(ss, subsum(tree, x0, ll))
    print(ss)","def max_segment_sum_after_destruction(n, a, destruction_order):

    destroyed = [False] * n

    results = []

    current_sum = sum(a)
    last_index = -1

    for i in range(n):
        idx = destruction_order[i] - 1
        destroyed[idx] = True

        if idx == last_index + 1:  

            while last_index + 1 < n and destroyed[last_index + 1]:
                last_index += 1

        if last_index < n - 1:
            current_sum -= a[idx]
            results.append(current_sum)
        else:
            results.append(0)
    
    return results

import sys

input_data = sys.stdin.read().strip().split(""\n"")
n = int(input_data[0])
a = list(map(int, input_data[1].split()))
destruction_order = list(map(int, input_data[2].split()))

results = max_segment_sum_after_destruction(n, a, destruction_order)
print(""\n"".join(map(str, results)))"
808,G,Anthem of Berland,PROGRAMMING,"['dp', 'strings']","Berland has a long and glorious history. To increase awareness about it among younger citizens, King of Berland decided to compose an anthem.

Though there are lots and lots of victories in history of Berland, there is the one that stand out the most. King wants to mention it in the anthem as many times as possible.

He has already composed major part of the anthem and now just needs to fill in some letters. King asked you to help him with this work.

The anthem is the string *s* of no more than 105 small Latin letters and question marks. The most glorious victory is the string *t* of no more than 105 small Latin letters. You should replace all the question marks with small Latin letters in such a way that the number of occurrences of string *t* in string *s* is maximal.

Note that the occurrences of string *t* in *s* can overlap. Check the third example for clarification.","The first line contains string of small Latin letters and question marks *s* (1<=≤<=|*s*|<=≤<=105).

The second line contains string of small Latin letters *t* (1<=≤<=|*t*|<=≤<=105).

Product of lengths of strings |*s*|·|*t*| won't exceed 107.",Output the maximum number of occurrences of string *t* you can achieve by replacing all the question marks in string *s* with small Latin letters.,"['winlose???winl???w??\nwin\n', 'glo?yto?e??an?\nor\n', '??c?????\nabcab\n']","['5\n', '3\n', '2\n']","In the first example the resulting string *s* is ""winlosewinwinlwinwin""

In the second example the resulting string *s* is ""glorytoreorand"". The last letter of the string can be arbitrary.

In the third example occurrences of string *t* are overlapping. String *s* with maximal number of occurrences of *t* is ""abcabcab"".",WRONG_ANSWER,"def look(t, i):
    so = s[i:i + t_len]
    for j in range(t_len):
        if not so[j] in [t[j], '?']:
            return False
        so[j] = t[j]

    s[i:i + t_len] = so

    return True

def rlook(t, i):
    so = rs[i:i + t_len]
    for j in range(t_len):
        if not so[j] in [t[j], '?']:
            return False
        so[j] = t[j]

    rs[i:i + t_len] = so

    return True

s = list(input())
t = input()
rs = s[:]
s_len = len(s)
t_len = len(t)

j = 0
rj = 0
for i in range(s_len-t_len+1):
    if look(t, i):
        j += 1
    if rlook(t, i):
        rj += 1

print(max(j, rj))","def max_occurrences(s, t):
    len_s = len(s)
    len_t = len(t)
    count = 0

    possible_occurrences = [0] * len_s

    for i in range(len_s - len_t + 1):
        match = True
        for j in range(len_t):

            if s[i + j] != t[j] and s[i + j] != '?':
                match = False
                break
        if match:

            count += 1

            for j in range(len_t):
                possible_occurrences[i + j] = 1

    for i in range(len_s):
        if s[i] == '?' and possible_occurrences[i] == 0:

            s = s[:i] + 'a' + s[i + 1:]

    count = 0
    for i in range(len_s - len_t + 1):
        if all(s[i + j] == t[j] or s[i + j] == '?' for j in range(len_t)):
            count += 1

    return count

import sys

input = sys.stdin.read
data = input().splitlines()
s = data[0]
t = data[1]

result = max_occurrences(s, t)

print(result)"
7,C,Line,PROGRAMMING,"['math', 'number theory']","A line on the plane is described by an equation *Ax*<=+<=*By*<=+<=*C*<==<=0. You are to find any point on this line, whose coordinates are integer numbers from <=-<=5·1018 to 5·1018 inclusive, or to find out that such points do not exist.","The first line contains three integers *A*, *B* and *C* (<=-<=2·109<=≤<=*A*,<=*B*,<=*C*<=≤<=2·109) — corresponding coefficients of the line equation. It is guaranteed that *A*2<=+<=*B*2<=&gt;<=0.","If the required point exists, output its coordinates, otherwise output -1.",['2 5 3\n'],['6 -3\n'],none,RUNTIME_ERROR,"def compute():

    def xgcd(b,n):
        x0, x1, y0, y1 = 1, 0, 0, 1
        while n!=0:
            q, b, n = b//n, n, b%n
            x0, x1 = x1, x0 - q*x1
            y0, y1 = y1, y0 - q*y1
        return b, x0, y0

    A, B, C = map(int,input().split())
    g, x, y = xgcd(A,B)
    if abs(-C)%g!=0:
        return -1
    d = -C//g
    return x*d, y*d

if __name__==""__main__"":
    print(' '.join(str(it) for it in compute()))","def find_point_on_line(A, B, C):

    for x in range(-5 * 10**18, 5 * 10**18 + 1):

        if A * x <= C:

            y = (C - A * x) // B if B != 0 else 0
            if A * x + B * y <= C:
                return (x, y)
    return -1

input_data = input().strip().split()
A, B, C = map(int, input_data)

result = find_point_on_line(A, B, C)

if result == -1:
    print(-1)
else:
    print(result[0], result[1])"
224,A,Parallelepiped,PROGRAMMING,"['brute force', 'geometry', 'math']",You've got a rectangular parallelepiped with integer edge lengths. You know the areas of its three faces that have a common vertex. Your task is to find the sum of lengths of all 12 edges of this parallelepiped.,The first and the single line contains three space-separated integers — the areas of the parallelepiped's faces. The area's values are positive (<=&gt;<=0) and do not exceed 104. It is guaranteed that there exists at least one parallelepiped that satisfies the problem statement.,Print a single number — the sum of all edges of the parallelepiped.,"['1 1 1\n', '4 6 6\n']","['12\n', '28\n']","In the first sample the parallelepiped has sizes 1 × 1 × 1, in the second one — 2 × 2 × 3.",COMPILATION_ERROR,"using namespace std;

void solve(ll caseNo)
{
	ll n;
	cin>>n;

	ll nos[7];
	ACCEPT(nos, 7);
	
	ll count=0,ans;
	for (int i = 0; i < 7; i++)
    {
        count += nos[i];
        if (count >= n)
        {
            ans = i + 1;
            break;
        }
        if(i==6)
            i=-1;
    }
 
    cout << ans;

} 
	
int main()
{

	freopen(""input.txt"",""r"",stdin);
	freopen(""output.txt"",""w"",stdout);

	IOS
	int t=1;
	// cin>>t;
	ll temp=1;

	while(t--)
	{
		solve(temp);
		temp++;
		
	}
	return 0;
}","areas = list(map(int, input().strip().split()))

A, B, C = areas

from math import isqrt

product = A * B * C

x = isqrt(A * C // B)
y = isqrt(A * B // C)
z = isqrt(B * C // A)

sum_of_edges = 4 * (x + y + z)

print(sum_of_edges)"
749,A,Bachgold Problem,PROGRAMMING,"['greedy', 'implementation', 'math', 'number theory']","Bachgold problem is very easy to formulate. Given a positive integer *n* represent it as a sum of maximum possible number of prime numbers. One can prove that such representation exists for any integer greater than 1.

Recall that integer *k* is called prime if it is greater than 1 and has exactly two positive integer divisors — 1 and *k*.",The only line of the input contains a single integer *n* (2<=≤<=*n*<=≤<=100<=000).,"The first line of the output contains a single integer *k* — maximum possible number of primes in representation.

The second line should contain *k* primes with their sum equal to *n*. You can print them in any order. If there are several optimal solution, print any of them.","['5\n', '6\n']","['2\n2 3\n', '3\n2 2 2\n']",none,OK,"def main():
    a = int(input())
    b = [2] * (a // 2)
    print(a // 2)
    if a % 2  != 0:
        b[-1] = 3
        

    print(*b)
        
main()","def bachgold_problem(n):

    k = n // 2

    if n % 2 == 0:
        primes = [2] * k
    else:
        primes = [2] * (k - 1) + [3]

    print(k)
    print(' '.join(map(str, primes)))

n = int(input().strip())
bachgold_problem(n)"
259,B,Little Elephant and Magic Square,PROGRAMMING,"['brute force', 'implementation']","Little Elephant loves magic squares very much.

A magic square is a 3<=×<=3 table, each cell contains some positive integer. At that the sums of integers in all rows, columns and diagonals of the table are equal. The figure below shows the magic square, the sum of integers in all its rows, columns and diagonals equals 15.

The Little Elephant remembered one magic square. He started writing this square on a piece of paper, but as he wrote, he forgot all three elements of the main diagonal of the magic square. Fortunately, the Little Elephant clearly remembered that all elements of the magic square did not exceed 105. 

Help the Little Elephant, restore the original magic square, given the Elephant's notes.","The first three lines of the input contain the Little Elephant's notes. The first line contains elements of the first row of the magic square. The second line contains the elements of the second row, the third line is for the third row. The main diagonal elements that have been forgotten by the Elephant are represented by zeroes.

It is guaranteed that the notes contain exactly three zeroes and they are all located on the main diagonal. It is guaranteed that all positive numbers in the table do not exceed 105.","Print three lines, in each line print three integers — the Little Elephant's magic square. If there are multiple magic squares, you are allowed to print any of them. Note that all numbers you print must be positive and not exceed 105.

It is guaranteed that there exists at least one magic square that meets the conditions.","['0 1 1\n1 0 1\n1 1 0\n', '0 3 6\n5 0 5\n4 7 0\n']","['1 1 1\n1 1 1\n1 1 1\n', '6 3 6\n5 5 5\n4 7 4\n']",none,OK,"import sys
import math as m
def main():
    pass
def binary(n):

    return (bin(n).replace(""0b"", """"))
def decimal(s):

    return (int(s, 2))
def pow2(n):

    p = 0
    while n > 1:
        n //= 2
        p += 1
    return (p)
def isPrime(n):

    if (n == 1):
        return (False)
    else:
        root = int(n ** 0.5)
        root += 1
        for i in range(2, root):
            if (n % i == 0):
                return (False)
        return (True)
def lts(l):

    s=''.join(map(str,l))
    return s
def stl(s):

    l=list(s)

    return l

def sq(a,target,arr=[]):
    s=sum(arr)
    if(s==target):
        return arr
    if(s>=target):
        return
    for i in range(len(a)):
        n=a[i]
        remaining=a[i+1:]
        ans=sq(remaining,target,arr+[n])
        if(ans):
            return ans

mod=int(1e9)+7
def sinp(): return sys.stdin.readline().strip()
def iinp(): return int(input())
def ninp(): return map(int, sys.stdin.readline().strip().split())
def llinp(): return list(map(int, sys.stdin.readline().strip().split()))
def p(xyz): print(xyz)
def p2(a,b):print(a,b)

ms=[]
for i in range(3):
    a=llinp()
    ms.append(a)
tot=(ms[0][1]+ms[0][2]+ms[1][0]+ms[1][2]+ms[2][0]+ms[2][1])//2
ms[0][0]=tot-(ms[0][1]+ms[0][2])
ms[1][1]=tot-(ms[1][0]+ms[1][2])
ms[2][2]=tot-(ms[2][0]+ms[2][1])
for i in ms:
    print(*i)","def restore_magic_square(notes):

    results = []
    for note in notes:

        matrix = [list(map(int, row.split())) for row in note.strip().split('\n')]

        magic_sum = max(
            sum(matrix[0]), 
            sum(matrix[1]), 
            sum(matrix[2]),
            matrix[0][1] + matrix[1][1] + matrix[2][1],
            matrix[0][2] + matrix[1][2] + matrix[2][2],
            matrix[0][0] + matrix[1][1] + matrix[2][2],
            matrix[0][2] + matrix[1][1] + matrix[2][0]
        )

        for i in range(3):
            if matrix[i][i] == 0:

                matrix[i][i] = magic_sum - (matrix[i][(i + 1) % 3] + matrix[i][(i + 2) % 3])
        
        results.append('\n'.join(' '.join(map(str, row)) for row in matrix))
    
    return results

notes = [
    '0 1 1\n1 0 1\n1 1 0\n',
    '0 3 6\n5 0 5\n4 7 0\n'
]
output = restore_magic_square(notes)
for result in output:
    print(result)"
717,E,"Paint it really, really dark gray",PROGRAMMING,['dfs and similar'],"I see a pink boar and I want it painted black. Black boars look much more awesome and mighty than the pink ones. Since Jaggy became the ruler of the forest, he has been trying his best to improve the diplomatic relations between the forest region and the nearby ones. 

Some other rulers, however, have requested too much in return for peace between their two regions, so he realized he has to resort to intimidation. Once a delegate for diplomatic relations of a neighboring region visits Jaggy’s forest, if they see a whole bunch of black boars, they might suddenly change their mind about attacking Jaggy. Black boars are really scary, after all. 

Jaggy’s forest can be represented as a tree (connected graph without cycles) with *n* vertices. Each vertex represents a boar and is colored either black or pink. Jaggy has sent a squirrel to travel through the forest and paint all the boars black. The squirrel, however, is quite unusually trained and while it traverses the graph, it changes the color of every vertex it visits, regardless of its initial color: pink vertices become black and black vertices become pink. 

Since Jaggy is too busy to plan the squirrel’s route, he needs your help. He wants you to construct a walk through the tree starting from vertex 1 such that in the end all vertices are black. A walk is a sequence of vertices, such that every consecutive pair has an edge between them in a tree.","The first line of input contains integer *n* (2<=≤<=*n*<=≤<=200<=000), denoting the number of vertices in the tree. The following *n* lines contains *n* integers, which represent the color of the nodes.

If the *i*-th integer is 1, if the *i*-th vertex is black and <=-<=1 if the *i*-th vertex is pink.

Each of the next *n*<=-<=1 lines contains two integers, which represent the indexes of the vertices which are connected by the edge. Vertices are numbered starting with 1.","Output path of a squirrel: output a sequence of visited nodes' indexes in order of visiting. In case of all the nodes are initially black, you should print 1. Solution is guaranteed to exist. If there are multiple solutions to the problem you can output any of them provided length of sequence is not longer than 107.",['5\n1\n1\n-1\n1\n-1\n2 5\n4 3\n2 4\n4 1\n'],['1 4 2 5 2 4 3 4 1 4 1\n'],"At the beginning squirrel is at node 1 and its color is black. Next steps are as follows: 
 -  From node 1 we walk to node 4 and change its color to pink. -  From node 4 we walk to node 2 and change its color to pink. -  From node 2 we walk to node 5 and change its color to black. -  From node 5 we return to node 2 and change its color to black. -  From node 2 we walk to node 4 and change its color to black. -  We visit node 3 and change its color to black. -  We visit node 4 and change its color to pink. -  We visit node 1 and change its color to pink. -  We visit node 4 and change its color to black. -  We visit node 1 and change its color to black.",RUNTIME_ERROR,"from collections import defaultdict
import sys

input = sys.stdin.readline

adj = {}
path = []

def paint(x, p):
	if x != 0:
		state[x] *= -1
	path.append(x)
	for neigh in adj[x]:

		if neigh != p:

			if paint(neigh, x) == True:
				return True
			path.append(x)
			state[x] *= -1

	if state[x] == -1:
		state[x] = 1
		print(path)
		path.extend([p, x])
		state[p] *= -1
	if state.count(1) == n:
		return True
	else:
		return False

n = int(input())
state = [int(i) for i in input().strip(' ').split()]

for _ in range(1, n):
	a, b = map(int, input().strip(' ').split())
	a -= 1
	b -= 1
	if a not in adj:
		adj[a] = []
	if b not in adj:
		adj[b] = []
	adj[a].append(b)
	adj[b].append(a)

if state.count(1) != n:
	paint(0, -2)
	for node in path:
		print(node + 1, end="" "", flush=True)
else:
	print(1)","def dfs(graph, node, visited, path):
    visited.add(node)
    path.append(node)
    for neighbor in graph[node]:
        if neighbor not in visited:
            dfs(graph, neighbor, visited, path)
            path.append(node)

def squirrel_path(n, colors, edges):

    graph = {i: [] for i in range(1, n + 1)}
    for u, v in edges:
        graph[u].append(v)
        graph[v].append(u)

    path = []
    visited = set()

    dfs(graph, 1, visited, path)

    if all(color == 1 for color in colors):
        return [1]

    return path

n = int(input().strip())
colors = [int(input().strip()) for _ in range(n)]
edges = [tuple(map(int, input().strip().split())) for _ in range(n - 1)]

result_path = squirrel_path(n, colors, edges)

print("" "".join(map(str, result_path)))"
315,A,Sereja and Bottles,PROGRAMMING,['brute force'],"Sereja and his friends went to a picnic. The guys had *n* soda bottles just for it. Sereja forgot the bottle opener as usual, so the guys had to come up with another way to open bottles.

Sereja knows that the *i*-th bottle is from brand *a**i*, besides, you can use it to open other bottles of brand *b**i*. You can use one bottle to open multiple other bottles. Sereja can open bottle with opened bottle or closed bottle.

Knowing this, Sereja wants to find out the number of bottles they've got that they won't be able to open in any way. Help him and find this number.","The first line contains integer *n* (1<=≤<=*n*<=≤<=100) — the number of bottles. The next *n* lines contain the bottles' description. The *i*-th line contains two integers *a**i*,<=*b**i* (1<=≤<=*a**i*,<=*b**i*<=≤<=1000) — the description of the *i*-th bottle.",In a single line print a single integer — the answer to the problem.,"['4\n1 1\n2 2\n3 3\n4 4\n', '4\n1 2\n2 3\n3 4\n4 1\n']","['4\n', '0\n']",none,COMPILATION_ERROR,"using namespace std;

long long debug_counter=0;

void logic()
{
    int n;
    cin>>n;
    vector<pair<int,int>> v;
    int x,y;
    for(int i=0;i<n;++i)
    {
        cin>>x>>y;
        v.emplace_back(x,y);
    }
    int count=0;
    for(int i=0;i<n;++i)
    {
        int temp=v[i].first;
        bool flag=0;
        for(int j=0;j<n;++j)
        {
            if(j==i) continue;
            else
            {
                if(v[j].second==temp)
                {
                    flag=1;
                    break;
                }
            }    
        }
        if(flag==0) count++;
    }
    cout<<count;
    cout<<""\n"";
}
int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    long long t;
    //cin>>t;
    //while(t--)
    {
        logic();
    }
}","def count_unopenable_bottles(n, bottles):

    openable_brands = set()

    for a, b in bottles:

        openable_brands.add(b)

    unopenable_count = sum(1 for a, _ in bottles if a not in openable_brands)
    
    return unopenable_count

n = int(input().strip())
bottles = []

for _ in range(n):
    a, b = map(int, input().strip().split())
    bottles.append((a, b))

print(count_unopenable_bottles(n, bottles))"
119,A,Epic Game,PROGRAMMING,['implementation'],"Simon and Antisimon play a game. Initially each player receives one fixed positive integer that doesn't change throughout the game. Simon receives number *a* and Antisimon receives number *b*. They also have a heap of *n* stones. The players take turns to make a move and Simon starts. During a move a player should take from the heap the number of stones equal to the greatest common divisor of the fixed number he has received and the number of stones left in the heap. A player loses when he cannot take the required number of stones (i. e. the heap has strictly less stones left than one needs to take). 

Your task is to determine by the given *a*, *b* and *n* who wins the game.","The only string contains space-separated integers *a*, *b* and *n* (1<=≤<=*a*,<=*b*,<=*n*<=≤<=100) — the fixed numbers Simon and Antisimon have received correspondingly and the initial number of stones in the pile.","If Simon wins, print ""0"" (without the quotes), otherwise print ""1"" (without the quotes).","['3 5 9\n', '1 1 100\n']","['0', '1']","The greatest common divisor of two non-negative integers *a* and *b* is such maximum positive integer *k*, that *a* is divisible by *k* without remainder and similarly, *b* is divisible by *k* without remainder. Let *gcd*(*a*, *b*) represent the operation of calculating the greatest common divisor of numbers *a* and *b*. Specifically, *gcd*(*x*, 0) = *gcd*(0, *x*) = *x*.

In the first sample the game will go like that:
-  Simon should take *gcd*(3, 9) = 3 stones from the heap. After his move the heap has 6 stones left.-  Antisimon should take *gcd*(5, 6) = 1 stone from the heap. After his move the heap has 5 stones left.-  Simon should take *gcd*(3, 5) = 1 stone from the heap. After his move the heap has 4 stones left.-  Antisimon should take *gcd*(5, 4) = 1 stone from the heap. After his move the heap has 3 stones left.-  Simon should take *gcd*(3, 3) = 3 stones from the heap. After his move the heap has 0 stones left.-  Antisimon should take *gcd*(5, 0) = 5 stones from the heap. As 0 &lt; 5, it is impossible and Antisimon loses.
In the second sample each player during each move takes one stone from the heap. As *n* is even, Antisimon takes the last stone and Simon can't make a move after that.",RUNTIME_ERROR,"s=[int(x) for x in input().split()]
m=n
a=s[0]
b=s[1]
n=s[2]
def f(x,y):
    while x!=y:
        x=min(x,y)
        y=max(x,y)
        t=y%x
        y=x
        x=t
    return x
for i in range(n):
    a1=f(a,m)
    b1=f(b,m)
    if a1>m:
        print(0)
        break
    elif b1>m:
        print(1)
        break
    else:
        m=m-a1-b1","import sys
import math

def game_winner(a, b, n):

    is_simon_turn = True
    
    while n > 0:
        if is_simon_turn:
            stones_to_take = math.gcd(a, n)
        else:
            stones_to_take = math.gcd(b, n)

        if n < stones_to_take:
            return 0 if is_simon_turn else 1
        
        n -= stones_to_take
        is_simon_turn = not is_simon_turn
    
    return 1

input_data = sys.stdin.read().strip()
a, b, n = map(int, input_data.split())

winner = game_winner(a, b, n)
print(winner)"
369,B,Valera and Contest,PROGRAMMING,"['constructive algorithms', 'implementation', 'math']","Valera loves to participate in competitions. Especially in programming contests. Today he has participated in the contest with his team, consisting of *n* students (including Valera). This contest was an individual competition, so each student in the team solved problems individually.

After the contest was over, Valera was interested in results. He found out that:
 -  each student in the team scored at least *l* points and at most *r* points; -  in total, all members of the team scored exactly *s**all* points; -  the total score of the *k* members of the team who scored the most points is equal to exactly *s**k*; more formally, if *a*1,<=*a*2,<=...,<=*a**n* is the sequence of points earned by the team of students in the non-increasing order (*a*1<=≥<=*a*2<=≥<=...<=≥<=*a**n*), then *s**k*<==<=*a*1<=+<=*a*2<=+<=...<=+<=*a**k*. 
However, Valera did not find out exactly how many points each of *n* students scored. Valera asked you to recover any distribution of scores between the students of the team, such that all the conditions above are met.","The first line of the input contains exactly six integers *n*,<=*k*,<=*l*,<=*r*,<=*s**all*,<=*s**k* (1<=≤<=*n*,<=*k*,<=*l*,<=*r*<=≤<=1000; *l*<=≤<=*r*; *k*<=≤<=*n*; 1<=≤<=*s**k*<=≤<=*s**all*<=≤<=106).

It's guaranteed that the input is such that the answer exists.","Print exactly *n* integers *a*1,<=*a*2,<=...,<=*a**n* — the number of points each student scored. If there are multiple solutions, you can print any of them. You can print the distribution of points in any order.","['5 3 1 3 13 9\n', '5 3 1 3 15 9\n']","['2 3 2 3 3 ', '3 3 3 3 3 ']",none,RUNTIME_ERROR,"def f(sk, k):
    q, m = divmod(sk, k)
    for i in range(m):
        print(q + 1)
    for i in range(k - m):
        print(q)
n, k, l, r, sa, sk = map(int, input().split())
f(sk, k)
f(sa - sk, n - k)","def distribute_scores(n, k, l, r, s_all, s_k):

    scores = [0] * n

    base_k = s_k // k
    additional_k = s_k % k

    for i in range(k):
        scores[i] = base_k + (1 if i < additional_k else 0)

    remaining_score = s_all - s_k
    if n > k:
        base_rest = remaining_score // (n - k)
        additional_rest = remaining_score % (n - k)

        for i in range(k, n):
            scores[i] = base_rest + (1 if i - k < additional_rest else 0)

    for i in range(n):
        if scores[i] < l:
            scores[i] = l
        elif scores[i] > r:
            scores[i] = r
            
    return scores

n, k, l, r, s_all, s_k = map(int, input().split())

scores_distribution = distribute_scores(n, k, l, r, s_all, s_k)

print(' '.join(map(str, scores_distribution)))"
21,B,Intersection,PROGRAMMING,"['implementation', 'math']","You are given two set of points. The first set is determined by the equation *A*1*x*<=+<=*B*1*y*<=+<=*C*1<==<=0, and the second one is determined by the equation *A*2*x*<=+<=*B*2*y*<=+<=*C*2<==<=0.

Write the program which finds the number of points in the intersection of two given sets.","The first line of the input contains three integer numbers *A*1,<=*B*1,<=*C*1 separated by space. The second line contains three integer numbers *A*2,<=*B*2,<=*C*2 separated by space. All the numbers are between -100 and 100, inclusive.",Print the number of points in the intersection or -1 if there are infinite number of points.,"['1 1 0\n2 2 0\n', '1 1 0\n2 -2 0\n']","['-1\n', '1\n']",none,RUNTIME_ERROR,"def gtof(a, b, c):
    if b != 0:
        return -a / b, -c / b
    else:
        return 101, -c / a

k1, b1 = gtof(*map(int, input().split()))
k2, b2 = gtof(*map(int, input().split()))

if k1 == k2:
    if b1 == b2:
        print(-1)
    else:
        print(0)
else:
    print(1)","def find_intersection_points(eq1, eq2):

    A1, B1, C1 = eq1
    A2, B2, C2 = eq2

    if A1 * B2 == A2 * B1:
        if A1 * C2 == A2 * C1:
            return -1
        else:
            return 0

    x = (B1 * C2 - B2 * C1) / (A1 * B2 - A2 * B1)
    y = (C1 - A1 * x) / B1

    return 1

first_eq = list(map(int, input().strip().split()))
second_eq = list(map(int, input().strip().split()))

result = find_intersection_points(first_eq, second_eq)

print(result)"
698,A,Vacations,PROGRAMMING,['dp'],"Vasya has *n* days of vacations! So he decided to improve his IT skills and do sport. Vasya knows the following information about each of this *n* days: whether that gym opened and whether a contest was carried out in the Internet on that day. For the *i*-th day there are four options:
 1.  on this day the gym is closed and the contest is not carried out; 1.  on this day the gym is closed and the contest is carried out; 1.  on this day the gym is open and the contest is not carried out; 1.  on this day the gym is open and the contest is carried out. 
On each of days Vasya can either have a rest or write the contest (if it is carried out on this day), or do sport (if the gym is open on this day).

Find the minimum number of days on which Vasya will have a rest (it means, he will not do sport and write the contest at the same time). The only limitation that Vasya has — he does not want to do the same activity on two consecutive days: it means, he will not do sport on two consecutive days, and write the contest on two consecutive days.","The first line contains a positive integer *n* (1<=≤<=*n*<=≤<=100) — the number of days of Vasya's vacations.

The second line contains the sequence of integers *a*1,<=*a*2,<=...,<=*a**n* (0<=≤<=*a**i*<=≤<=3) separated by space, where: 
 -  *a**i* equals 0, if on the *i*-th day of vacations the gym is closed and the contest is not carried out; -  *a**i* equals 1, if on the *i*-th day of vacations the gym is closed, but the contest is carried out; -  *a**i* equals 2, if on the *i*-th day of vacations the gym is open and the contest is not carried out; -  *a**i* equals 3, if on the *i*-th day of vacations the gym is open and the contest is carried out.","Print the minimum possible number of days on which Vasya will have a rest. Remember that Vasya refuses:
 -  to do sport on any two consecutive days, -  to write the contest on any two consecutive days.","['4\n1 3 2 0\n', '7\n1 3 3 2 1 2 3\n', '2\n2 2\n']","['2\n', '0\n', '1\n']","In the first test Vasya can write the contest on the day number 1 and do sport on the day number 3. Thus, he will have a rest for only 2 days.

In the second test Vasya should write contests on days number 1, 3, 5 and 7, in other days do sport. Thus, he will not have a rest for a single day.

In the third test Vasya can do sport either on a day number 1 or number 2. He can not do sport in two days, because it will be contrary to the his limitation. Thus, he will have a rest for only one day.",MEMORY_LIMIT_EXCEEDED,"import os
import sys
from io import BytesIO, IOBase
import collections
sys.setrecursionlimit(10**9)

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def getMin(index,last,arr):
    if index==0:
        if last==arr[index]:
            return 1
        elif arr[index]==0:
            return 1
        return 0
    rest = gym = sport = 10e9
    if arr[index]==0 and last!=0:
        rest = 1 + getMin(index-1,0,arr)
    if arr[index]==1 and last!=1:
        sport = getMin(index-1,1,arr)
    if arr[index]==2 and last!=2:
        gym = getMin(index-1,2,arr)
    if arr[index]==3:
        if last not in [0,1,2]:
            sport = getMin(index-1,1,arr)
            gym = getMin(index-1,2,arr)

        elif last==0:
            sport = getMin(index-1,1,arr)
            gym = getMin(index-1,2,arr)
        elif last==1:
            gym = getMin(index-1,2,arr)
            rest = 1 + getMin(index-1,0,arr)
        else:
            sport = getMin(index-1,1,arr)
            rest = 1 + getMin(index-1,0,arr)
    return min(rest,gym,sport)

n= int(input())
arr = [int(x) for x in input().split()]
print(getMin(len(arr)-1,-1,arr))","def min_rest_days(n, days):
    rest_days = 0
    last_activity = -1
    
    for i in range(n):
        current_day = days[i]
        
        if current_day == 0:
            rest_days += 1
            last_activity = -1
        elif current_day == 1:
            if last_activity != 1:
                last_activity = 1
            else:
                rest_days += 1
                last_activity = -1
        elif current_day == 2:
            if last_activity != 2:
                last_activity = 2
            else:
                rest_days += 1
                last_activity = -1
        elif current_day == 3:
            if last_activity == 1:
                last_activity = 2
            elif last_activity == 2:
                rest_days += 1
                last_activity = 1
            else:
                last_activity = 2
            
    return rest_days

demo_inputs = [
    ""4\n1 3 2 0\n"",
    ""7\n1 3 3 2 1 2 3\n"",
    ""2\n2 2\n""
]

outputs = []
for input_str in demo_inputs:
    n, days = input_str.strip().split('\n')
    n = int(n)
    days = list(map(int, days.split()))
    result = min_rest_days(n, days)
    outputs.append(f""{result}\n"")

print(''.join(outputs))"
681,C,Heap Operations,PROGRAMMING,"['constructive algorithms', 'data structures', 'greedy']","Petya has recently learned data structure named ""Binary heap"".

The heap he is now operating with allows the following operations: 
 -  put the given number into the heap; -  get the value of the minimum element in the heap; -  extract the minimum element from the heap; 
Thus, at any moment of time the heap contains several integers (possibly none), some of them might be equal.

In order to better learn this data structure Petya took an empty heap and applied some operations above to it. Also, he carefully wrote down all the operations and their results to his event log, following the format: 
 -  insert *x* — put the element with value *x* in the heap; -  getMin *x* — the value of the minimum element contained in the heap was equal to *x*; -  removeMin — the minimum element was extracted from the heap (only one instance, if there were many). 
All the operations were correct, i.e. there was at least one element in the heap each time getMin or removeMin operations were applied.

While Petya was away for a lunch, his little brother Vova came to the room, took away some of the pages from Petya's log and used them to make paper boats.

Now Vova is worried, if he made Petya's sequence of operations inconsistent. For example, if one apply operations one-by-one in the order they are written in the event log, results of getMin operations might differ from the results recorded by Petya, and some of getMin or removeMin operations may be incorrect, as the heap is empty at the moment they are applied.

Now Vova wants to add some new operation records to the event log in order to make the resulting sequence of operations correct. That is, the result of each getMin operation is equal to the result in the record, and the heap is non-empty when getMin ad removeMin are applied. Vova wants to complete this as fast as possible, as the Petya may get back at any moment. He asks you to add the least possible number of operation records to the current log. Note that arbitrary number of operations may be added at the beginning, between any two other operations, or at the end of the log.","The first line of the input contains the only integer *n* (1<=≤<=*n*<=≤<=100<=000) — the number of the records left in Petya's journal.

Each of the following *n* lines describe the records in the current log in the order they are applied. Format described in the statement is used. All numbers in the input are integers not exceeding 109 by their absolute value.","The first line of the output should contain a single integer *m* — the minimum possible number of records in the modified sequence of operations.

Next *m* lines should contain the corrected sequence of records following the format of the input (described in the statement), one per line and in the order they are applied. All the numbers in the output should be integers not exceeding 109 by their absolute value.

Note that the input sequence of operations must be the subsequence of the output sequence.

It's guaranteed that there exists the correct answer consisting of no more than 1<=000<=000 operations.","['2\ninsert 3\ngetMin 4\n', '4\ninsert 1\ninsert 1\nremoveMin\ngetMin 2\n']","['4\ninsert 3\nremoveMin\ninsert 4\ngetMin 4\n', '6\ninsert 1\ninsert 1\nremoveMin\nremoveMin\ninsert 2\ngetMin 2\n']","In the first sample, after number 3 is inserted into the heap, the minimum number is 3. To make the result of the first getMin equal to 4 one should firstly remove number 3 from the heap and then add number 4 into the heap.

In the second sample case number 1 is inserted two times, so should be similarly removed twice.",RUNTIME_ERROR,"import heapq
from pprint import pprint

def pop_till_receive(heap, num, seq):
    while heap[0] != num:
        seq.append(seq[-1])
        seq[-2] = ""removeMin""
        heapq.heappop(heap)
    return

if __name__ == '__main__':
    heap = []
    n = int(input())
    seq = []
    for i in range(n):
        query = input()
        seq.append(query)
        if ""insert"" in query:
            num = int(query.strip(""insert ""))
            heapq.heappush(heap, num)
        elif ""get"" in query:
            num = int(query.strip(""getMin ""))
            if heap[0] != num:
                if num in heap:
                    pop_till_receive(heap, num, seq)
                else:

                    seq.append(seq[-1])
                    seq[-2] = f""insert {num}""

                    heapq.heappush(heap, num)
                    pop_till_receive(heap, num, seq=seq)
        else:
            heapq.heappop(heap)

    print(len(seq), sep='\n')
    for q in seq:
        print(q)","import sys
import heapq

def process_operations(log):

    heap = []
    operations = []
    
    for entry in log:
        parts = entry.split()
        command = parts[0]
        
        if command == 'insert':
            value = int(parts[1])
            heapq.heappush(heap, value)
            operations.append(entry.strip())
        
        elif command == 'removeMin':
            if heap:
                heapq.heappop(heap)
                operations.append(entry.strip())
            else:

                if operations:
                    last_min = min(heap) if heap else 0
                    operations.append(f'insert {last_min}')
                    heapq.heappush(heap, last_min)
                operations.append(entry.strip())
                if heap:
                    heapq.heappop(heap)
        
        elif command == 'getMin':
            value = int(parts[1])
            if not heap or (heap and heap[0] > value):

                while not heap or (heap and heap[0] > value):
                    operations.append(f'insert {value}')
                    heapq.heappush(heap, value)
            operations.append(entry.strip())
            if heap and heap[0] == value:

                heapq.heappop(heap)
            else:

                while heap and heap[0] < value:
                    heapq.heappop(heap)
                if not heap or (heap and heap[0] < value):
                    operations.append(f'insert {value}')
                    heapq.heappush(heap, value)
                
    return operations

def main():
    input_data = sys.stdin.read().strip().split('\n')
    n = int(input_data[0])
    log = input_data[1:n+1]
    
    corrected_operations = process_operations(log)
    print(len(corrected_operations))
    for operation in corrected_operations:
        print(operation)

if __name__ == ""__main__"":
    main()"
460,A,Vasya and Socks,PROGRAMMING,"['brute force', 'implementation', 'math']","Vasya has *n* pairs of socks. In the morning of each day Vasya has to put on a pair of socks before he goes to school. When he comes home in the evening, Vasya takes off the used socks and throws them away. Every *m*-th day (at days with numbers *m*,<=2*m*,<=3*m*,<=...) mom buys a pair of socks to Vasya. She does it late in the evening, so that Vasya cannot put on a new pair of socks before the next day. How many consecutive days pass until Vasya runs out of socks?","The single line contains two integers *n* and *m* (1<=≤<=*n*<=≤<=100; 2<=≤<=*m*<=≤<=100), separated by a space.",Print a single integer — the answer to the problem.,"['2 2\n', '9 3\n']","['3\n', '13\n']","In the first sample Vasya spends the first two days wearing the socks that he had initially. Then on day three he puts on the socks that were bought on day two.

In the second sample Vasya spends the first nine days wearing the socks that he had initially. Then he spends three days wearing the socks that were bought on the third, sixth and ninth days. Than he spends another day wearing the socks that were bought on the twelfth day.",RUNTIME_ERROR,"import math

def solve():
    l1 = [int(x) for x in input().split()]
    add = l1[0]
    n = l1[0]
    p = l1[1]
    while (n):
        add += n / p
        n = n / p
    print(math.floor(add))

if _name_ == '_main_':
    solve()","def calculate_days(n, m):
    days = 0
    while n > 0:
        days += 1
        n -= 1
        if days % m == 0:
            n += 1

    return days

input_data = input().strip().split()
n = int(input_data[0])
m = int(input_data[1])

print(calculate_days(n, m))"
620,B,Grandfather Dovlet’s calculator,PROGRAMMING,['implementation'],"Once Max found an electronic calculator from his grandfather Dovlet's chest. He noticed that the numbers were written with seven-segment indicators ([https://en.wikipedia.org/wiki/Seven-segment_display](https://en.wikipedia.org/wiki/Seven-segment_display)).

Max starts to type all the values from *a* to *b*. After typing each number Max resets the calculator. Find the total number of segments printed on the calculator.

For example if *a*<==<=1 and *b*<==<=3 then at first the calculator will print 2 segments, then — 5 segments and at last it will print 5 segments. So the total number of printed segments is 12.","The only line contains two integers *a*,<=*b* (1<=≤<=*a*<=≤<=*b*<=≤<=106) — the first and the last number typed by Max.",Print the only integer *a* — the total number of printed segments.,"['1 3\n', '10 15\n']","['12\n', '39\n']",none,TIME_LIMIT_EXCEEDED,"def find(n):
	result = 0
	for i in n:
		result += dic[i]
	return result

dic = {'0':6, '1':2, '2':5, '3':5, '4':4, '5':5, '6':6, '7':3, '8':7, '9':6}
if __name__ == '__main__':
	a, b = list(map(int, input().split()))
	answer = 0
	i = a
	while i <= b:
		answer += find(str(i))
		i += 1
	print (answer)","def total_segments(a, b):

    segment_count = {
        '0': 6,
        '1': 2,
        '2': 5,
        '3': 5,
        '4': 4,
        '5': 5,
        '6': 6,
        '7': 3,
        '8': 7,
        '9': 6,
    }
    
    total = 0

    for number in range(a, b + 1):

        for digit in str(number):
            total += segment_count[digit]
    
    return total

a, b = map(int, input().split())

print(total_segments(a, b))"
932,E,Team Work,PROGRAMMING,"['combinatorics', 'dp', 'math']","You have a team of *N* people. For a particular task, you can pick any non-empty subset of people. The cost of having *x* people for the task is *x**k*. 

Output the sum of costs over all non-empty subsets of people.",Only line of input contains two integers *N* (1<=≤<=*N*<=≤<=109) representing total number of people and *k* (1<=≤<=*k*<=≤<=5000).,Output the sum of costs for all non empty subsets modulo 109<=+<=7.,"['1 1\n', '3 2\n']","['1\n', '24\n']","In the first example, there is only one non-empty subset {1} with cost 1<sup class=""upper-index"">1</sup> = 1.

In the second example, there are seven non-empty subsets.

- {1} with cost 1<sup class=""upper-index"">2</sup> = 1

- {2} with cost 1<sup class=""upper-index"">2</sup> = 1

- {1, 2} with cost 2<sup class=""upper-index"">2</sup> = 4

- {3} with cost 1<sup class=""upper-index"">2</sup> = 1

- {1, 3} with cost 2<sup class=""upper-index"">2</sup> = 4

- {2, 3} with cost 2<sup class=""upper-index"">2</sup> = 4

- {1, 2, 3} with cost 3<sup class=""upper-index"">2</sup> = 9

The total cost is 1 + 1 + 4 + 1 + 4 + 4 + 9 = 24.",RUNTIME_ERROR,"def c(n, k):
    if(k > n - k):
        k = n - k
    ans = 1
    for i in range(k):
        ans *= n - i
        ans /= i + 1
    return ans

n, k = map(int, input().split())
ans=0
for i in range(n+1):
    ans+=(c(n, i)*(i**k)%(10**9+7))
    ans%=(10**9+7)
print(int(ans)%(10**9+7))","def sum_of_costs(N, k):

    MOD = 10**9 + 7

    total_cost = 0
    for x in range(1, N + 1):

        cost = pow(x, k, MOD)

        num_subsets = 1 << (N - 1)
        total_cost = (total_cost + cost * num_subsets) % MOD
    
    return total_cost

import sys
input_data = sys.stdin.read().strip().split('\n')
results = []

for line in input_data:
    N, k = map(int, line.split())
    result = sum_of_costs(N, k)
    results.append(result)

for res in results:
    print(res)"
688,B,Lovely Palindromes,PROGRAMMING,"['constructive algorithms', 'math']","Pari has a friend who loves palindrome numbers. A palindrome number is a number that reads the same forward or backward. For example 12321, 100001 and 1 are palindrome numbers, while 112 and 1021 are not.

Pari is trying to love them too, but only very special and gifted people can understand the beauty behind palindrome numbers. Pari loves integers with even length (i.e. the numbers with even number of digits), so she tries to see a lot of big palindrome numbers with even length (like a 2-digit 11 or 6-digit 122221), so maybe she could see something in them.

Now Pari asks you to write a program that gets a huge integer *n* from the input and tells what is the *n*-th even-length positive palindrome number?",The only line of the input contains a single integer *n* (1<=≤<=*n*<=≤<=10100<=000).,Print the *n*-th even-length palindrome number.,"['1\n', '10\n']","['11\n', '1001\n']","The first 10 even-length palindrome numbers are 11, 22, 33, ... , 88, 99 and 1001.",TIME_LIMIT_EXCEEDED,"n = input()
m=len(n)

x = n

for i in range(m):
	x = x+n[m-1-i]
print(x)","def nth_even_length_palindrome(n):

    upper_half = str(n)

    palindrome = upper_half + upper_half[::-1]
    
    return int(palindrome)

n = int(input().strip())

result = nth_even_length_palindrome(n)

print(result)"
981,A,Antipalindrome,PROGRAMMING,"['brute force', 'implementation', 'strings']","A string is a palindrome if it reads the same from the left to the right and from the right to the left. For example, the strings ""kek"", ""abacaba"", ""r"" and ""papicipap"" are palindromes, while the strings ""abb"" and ""iq"" are not.

A substring $s[l \ldots r]$ ($1<=\leq<=l<=\leq<=r<=\leq<=|s|$) of a string $s<==<=s_{1}s_{2} \ldots s_{|s|}$ is the string $s_{l}s_{l<=+<=1} \ldots s_{r}$.

Anna does not like palindromes, so she makes her friends call her Ann. She also changes all the words she reads in a similar way. Namely, each word $s$ is changed into its longest substring that is not a palindrome. If all the substrings of $s$ are palindromes, she skips the word at all.

Some time ago Ann read the word $s$. What is the word she changed it into?","The first line contains a non-empty string $s$ with length at most $50$ characters, containing lowercase English letters only.","If there is such a substring in $s$ that is not a palindrome, print the maximum length of such a substring. Otherwise print $0$.

Note that there can be multiple longest substrings that are not palindromes, but their length is unique.","['mew\n', 'wuffuw\n', 'qqqqqqqq\n']","['3\n', '5\n', '0\n']","""mew"" is not a palindrome, so the longest substring of it that is not a palindrome, is the string ""mew"" itself. Thus, the answer for the first example is $3$.

The string ""uffuw"" is one of the longest non-palindrome substrings (of length $5$) of the string ""wuffuw"", so the answer for the second example is $5$.

All substrings of the string ""qqqqqqqq"" consist of equal characters so they are palindromes. This way, there are no non-palindrome substrings. Thus, the answer for the third example is $0$.",OK,"def is_pal(S):

    for i in range(0, len(S)):

        if S[i] != S[-(i+1)]: return False

    return True

while True:
    S = input()

    if not is_pal(S):

        print(len(S))

    else:

        if S.count(S[0]) == len(S):

            print(0)

        else:

            print(len(S)-1)

    break","def is_palindrome(s):

    return s == s[::-1]

def longest_non_palindrome_substring(s):

    if not is_palindrome(s):
        return len(s)

    for i in range(len(s)):

        if not is_palindrome(s[:i] + s[i+1:]):
            return len(s) - 1

    return 0

import sys
input_strings = sys.stdin.read().splitlines()

for s in input_strings:
    print(longest_non_palindrome_substring(s))"
581,A,Vasya the Hipster,PROGRAMMING,"['implementation', 'math']","One day Vasya the Hipster decided to count how many socks he had. It turned out that he had *a* red socks and *b* blue socks.

According to the latest fashion, hipsters should wear the socks of different colors: a red one on the left foot, a blue one on the right foot.

Every day Vasya puts on new socks in the morning and throws them away before going to bed as he doesn't want to wash them.

Vasya wonders, what is the maximum number of days when he can dress fashionable and wear different socks, and after that, for how many days he can then wear the same socks until he either runs out of socks or cannot make a single pair from the socks he's got.

Can you help him?","The single line of the input contains two positive integers *a* and *b* (1<=≤<=*a*,<=*b*<=≤<=100) — the number of red and blue socks that Vasya's got.","Print two space-separated integers — the maximum number of days when Vasya can wear different socks and the number of days when he can wear the same socks until he either runs out of socks or cannot make a single pair from the socks he's got.

Keep in mind that at the end of the day Vasya throws away the socks that he's been wearing on that day.","['3 1\n', '2 3\n', '7 3\n']","['1 1\n', '2 0\n', '3 2\n']","In the first sample Vasya can first put on one pair of different socks, after that he has two red socks left to wear on the second day.",OK,"def main():
    (red_socks, blue_socks) = input().split()
    count = 0
    (red_socks, blue_socks) = int(red_socks), int(blue_socks)
    while int(red_socks) > 0 and int(blue_socks) > 0:
        count += 1
        (red_socks, blue_socks) = red_socks - 1, blue_socks - 1
    print(count, red_socks // 2 + blue_socks // 2)
main()","def max_days_with_socks(a, b):

    fashionable_days = min(a, b)

    remaining_socks = abs(a - b)

    same_socks_days = remaining_socks // 2
    
    return fashionable_days, same_socks_days

input_data = ['3 1\n', '2 3\n', '7 3\n']
results = []

for line in input_data:
    a, b = map(int, line.strip().split())
    fashionable_days, same_socks_days = max_days_with_socks(a, b)
    results.append(f""{fashionable_days} {same_socks_days}"")

for result in results:
    print(result)"
0,none,none,none,['none'],"A family consisting of father bear, mother bear and son bear owns three cars. Father bear can climb into the largest car and he likes it. Also, mother bear can climb into the middle car and she likes it. Moreover, son bear can climb into the smallest car and he likes it. It's known that the largest car is strictly larger than the middle car, and the middle car is strictly larger than the smallest car. 

Masha came to test these cars. She could climb into all cars, but she liked only the smallest car. 

It's known that a character with size *a* can climb into some car with size *b* if and only if *a*<=≤<=*b*, he or she likes it if and only if he can climb into this car and 2*a*<=≥<=*b*.

You are given sizes of bears and Masha. Find out some possible integer non-negative sizes of cars.","You are given four integers *V*1, *V*2, *V*3, *V**m*(1<=≤<=*V**i*<=≤<=100) — sizes of father bear, mother bear, son bear and Masha, respectively. It's guaranteed that *V*1<=&gt;<=*V*2<=&gt;<=*V*3.","Output three integers — sizes of father bear's car, mother bear's car and son bear's car, respectively.

If there are multiple possible solutions, print any.

If there is no solution, print ""-1"" (without quotes).","['50 30 10 10\n', '100 50 10 21\n']","['50\n30\n10\n', '-1\n']","In first test case all conditions for cars' sizes are satisfied.

In second test case there is no answer, because Masha should be able to climb into smallest car (so size of smallest car in not less than 21), but son bear should like it, so maximum possible size of it is 20.",WRONG_ANSWER,"def tachki(v1,v2,v3,vm):
    for m1 in range(1,101):
        for m2 in range(1, 101):
            for m3 in range(1, 101):
               b1=    (m1>=v1 and m1<=v1*2)
               b2=    (m2>=v2 and m2<=v2*2)
               b3=    (m3>=v3 and m3<=v3*2)
               bm1=not(m1>=vm and m1<=vm*2)
               bm2=not(m2>=vm and m2<=vm*2)
               bm3=   (m3>=vm and m3<=vm*2)
               if b1 and b2 and b3 and bm1 and bm2 and bm3:
                   print(m1)
                   print(m2)
                   return m3
    return -1

v1,v2,v3,vm=map(int, input().split())
print(tachki(v1,v2,v3,vm))","def find_car_sizes(V1, V2, V3, Vm):

    smallest_car_size = max(0, Vm)
    middle_car_size = max(V2, smallest_car_size + 1)
    largest_car_size = max(V1, middle_car_size + 1)

    if (smallest_car_size >= V3 and smallest_car_size >= 0 and smallest_car_size * 2 <= V3 
        and middle_car_size >= V2 and middle_car_size >= 0 and middle_car_size * 2 <= V2 
        and largest_car_size >= V1 and largest_car_size >= 0 and largest_car_size * 2 <= V1):
        return largest_car_size, middle_car_size, smallest_car_size
    else:
        return -1

input_data = ['50 30 10 10\n', '100 50 10 21\n']
results = []

for data in input_data:
    V1, V2, V3, Vm = map(int, data.strip().split())
    result = find_car_sizes(V1, V2, V3, Vm)
    if result == -1:
        results.append('-1\n')
    else:
        results.append(f'{result[0]}\n{result[1]}\n{result[2]}\n')

print(''.join(results))"
859,C,Pie Rules,PROGRAMMING,"['dp', 'games']","You may have heard of the pie rule before. It states that if two people wish to fairly share a slice of pie, one person should cut the slice in half, and the other person should choose who gets which slice. Alice and Bob have many slices of pie, and rather than cutting the slices in half, each individual slice will be eaten by just one person.

The way Alice and Bob decide who eats each slice is as follows. First, the order in which the pies are to be handed out is decided. There is a special token called the ""decider"" token, initially held by Bob. Until all the pie is handed out, whoever has the decider token will give the next slice of pie to one of the participants, and the decider token to the other participant. They continue until no slices of pie are left.

All of the slices are of excellent quality, so each participant obviously wants to maximize the total amount of pie they get to eat. Assuming both players make their decisions optimally, how much pie will each participant receive?","Input will begin with an integer *N* (1<=≤<=*N*<=≤<=50), the number of slices of pie. 

Following this is a line with *N* integers indicating the sizes of the slices (each between 1 and 100000, inclusive), in the order in which they must be handed out.","Print two integers. First, the sum of the sizes of slices eaten by Alice, then the sum of the sizes of the slices eaten by Bob, assuming both players make their decisions optimally.","['3\n141 592 653\n', '5\n10 21 10 21 10\n']","['653 733\n', '31 41\n']","In the first example, Bob takes the size 141 slice for himself and gives the decider token to Alice. Then Alice gives the size 592 slice to Bob and keeps the decider token for herself, so that she can then give the size 653 slice to herself.",OK,"import math
from random import random

def getInt():
    return(int(input()))

def getInts():
    line = input().split()
    return [int(l) for l in line]

def getFloat():
    return(float(input()))

def getFloats():
    line = input().split()
    return [float(l) for l in line]

def getStrings():
    line = input().split()
    return(line)

N = getInt()
values = getInts()

nConsidered = 0

bestForChooserSoFar = [0, 0]

for i in range(len(values)):
    v = values[len(values) - i - 1]
    qsIfTaken = [v + bestForChooserSoFar[1], bestForChooserSoFar[0]]
    qsIfGiven = [bestForChooserSoFar[0], v + bestForChooserSoFar[1]]

    if(qsIfTaken[0] >= qsIfGiven[0]):
        bestForChooserSoFar = qsIfTaken
    else:
        bestForChooserSoFar = qsIfGiven

print(str(bestForChooserSoFar[1]) + ' ' + str(bestForChooserSoFar[0]))","def distribute_pies(n, slices):

    alice_score = 0
    bob_score = 0

    is_alice_turn = False
    
    for slice_size in slices:
        if is_alice_turn:

            if slice_size > slices[0]:
                alice_score += slice_size
            else:
                bob_score += slice_size
        else:

            if slice_size > slices[0]:
                bob_score += slice_size
            else:
                alice_score += slice_size

        is_alice_turn = not is_alice_turn
    
    return alice_score, bob_score

if __name__ == ""__main__"":
    import sys
    input_data = sys.stdin.read().strip().splitlines()

    N = int(input_data[0])

    pie_slices = list(map(int, input_data[1].split()))

    alice_total, bob_total = distribute_pies(N, pie_slices)

    print(alice_total, bob_total)"
106,B,Choosing Laptop,PROGRAMMING,"['brute force', 'implementation']","Vasya is choosing a laptop. The shop has *n* laptops to all tastes.

Vasya is interested in the following properties: processor speed, ram and hdd. Vasya is a programmer and not a gamer which is why he is not interested in all other properties.

If all three properties of a laptop are strictly less than those properties of some other laptop, then the first laptop is considered outdated by Vasya. Among all laptops Vasya does not consider outdated, he chooses the cheapest one.

There are very many laptops, which is why Vasya decided to write a program that chooses the suitable laptop. However, Vasya doesn't have his own laptop yet and he asks you to help him.","The first line contains number *n* (1<=≤<=*n*<=≤<=100).

Then follow *n* lines. Each describes a laptop as *speed* *ram* *hdd* *cost*. Besides, 
 -  *speed*, *ram*, *hdd* and *cost* are integers -  1000<=≤<=*speed*<=≤<=4200 is the processor's speed in megahertz -  256<=≤<=*ram*<=≤<=4096 the RAM volume in megabytes -  1<=≤<=*hdd*<=≤<=500 is the HDD in gigabytes -  100<=≤<=*cost*<=≤<=1000 is price in tugriks 
All laptops have different prices.",Print a single number — the number of a laptop Vasya will choose. The laptops are numbered with positive integers from 1 to *n* in the order in which they are given in the input data.,['5\n2100 512 150 200\n2000 2048 240 350\n2300 1024 200 320\n2500 2048 80 300\n2000 512 180 150\n'],['4'],"In the third sample Vasya considers the first and fifth laptops outdated as all of their properties cannot match those of the third laptop. The fourth one is the cheapest among the laptops that are left. Thus, Vasya chooses the fourth laptop.",WRONG_ANSWER,"n=int(input())
b=[]
for i in range(n):
    a= list(map(int, input().split()))
    a.append(i+1)
    b.append(a)
def fn(a):
    return a[3]
b.sort(key=fn)
def fn1(b,n):
    for i in range(n):
        for j in range(n):
            c=0
            for k in range(3):
                if b[i][k]<b[j][k]:c+=1
            if c==3:break
            if j==4:return b[i][4]
print(fn1(b,n))","n = int(input())

laptops = []

for i in range(n):
    speed, ram, hdd, cost = map(int, input().split())
    laptops.append((speed, ram, hdd, cost, i + 1))

outdated = set()

for i in range(n):
    for j in range(n):
        if i != j:

            if (laptops[i][0] < laptops[j][0] and
                laptops[i][1] < laptops[j][1] and
                laptops[i][2] < laptops[j][2]):
                outdated.add(i)

potential_laptops = [laptops[i] for i in range(n) if i not in outdated]

if potential_laptops:
    chosen_laptop = min(potential_laptops, key=lambda x: x[3])
    print(chosen_laptop[4])
else:
    print(-1)"
110,A,Nearly Lucky Number,PROGRAMMING,['implementation'],"Petya loves lucky numbers. We all know that lucky numbers are the positive integers whose decimal representations contain only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.

Unfortunately, not all numbers are lucky. Petya calls a number nearly lucky if the number of lucky digits in it is a lucky number. He wonders whether number *n* is a nearly lucky number.","The only line contains an integer *n* (1<=≤<=*n*<=≤<=1018).

Please do not use the %lld specificator to read or write 64-bit numbers in С++. It is preferred to use the cin, cout streams or the %I64d specificator.","Print on the single line ""YES"" if *n* is a nearly lucky number. Otherwise, print ""NO"" (without the quotes).","['40047\n', '7747774\n', '1000000000000000000\n']","['NO\n', 'YES\n', 'NO\n']","In the first sample there are 3 lucky digits (first one and last two), so the answer is ""NO"".

In the second sample there are 7 lucky digits, 7 is lucky number, so the answer is ""YES"".

In the third sample there are no lucky digits, so the answer is ""NO"".",RUNTIME_ERROR,"def es_numero_de_la_suerte(num):
   
    while num > 0:
        digito = num % 10
        if digito != 4 and digito != 7:
            return False
        num //= 10
    return True

def es_casi_numero_de_la_suerte(num):

    cuenta_suertes = 0
    while num > 0:
        digito = num % 10
        if digito == 4 or digito == 7:
            cuenta_suertes += 1
        num //= 10
    
    return es_numero_de_la_suerte(cuenta_suertes)

n = int(input())

if es_casi_numero_de_la_suerte(n):
    print(""SÍ"")
else:
    print(""NO"")","def is_lucky(num):

    return all(digit in '47' for digit in str(num))

def is_nearly_lucky(n):

    lucky_count = sum(1 for digit in str(n) if digit in '47')

    return is_lucky(lucky_count)

n = int(input().strip())

if is_nearly_lucky(n):
    print(""YES"")
else:
    print(""NO"")"
115,A,Party,PROGRAMMING,"['dfs and similar', 'graphs', 'trees']","A company has *n* employees numbered from 1 to *n*. Each employee either has no immediate manager or exactly one immediate manager, who is another employee with a different number. An employee *A* is said to be the superior of another employee *B* if at least one of the following is true:
 -  Employee *A* is the immediate manager of employee *B* -  Employee *B* has an immediate manager employee *C* such that employee *A* is the superior of employee *C*. 
The company will not have a managerial cycle. That is, there will not exist an employee who is the superior of his/her own immediate manager.

Today the company is going to arrange a party. This involves dividing all *n* employees into several groups: every employee must belong to exactly one group. Furthermore, within any single group, there must not be two employees *A* and *B* such that *A* is the superior of *B*.

What is the minimum number of groups that must be formed?","The first line contains integer *n* (1<=≤<=*n*<=≤<=2000) — the number of employees.

The next *n* lines contain the integers *p**i* (1<=≤<=*p**i*<=≤<=*n* or *p**i*<==<=-1). Every *p**i* denotes the immediate manager for the *i*-th employee. If *p**i* is -1, that means that the *i*-th employee does not have an immediate manager. 

It is guaranteed, that no employee will be the immediate manager of him/herself (*p**i*<=≠<=*i*). Also, there will be no managerial cycles.",Print a single integer denoting the minimum number of groups that will be formed in the party.,['5\n-1\n1\n2\n1\n-1\n'],['3\n'],"For the first example, three groups are sufficient, for example: 
 -  Employee 1 -  Employees 2 and 4 -  Employees 3 and 5",MEMORY_LIMIT_EXCEEDED,"from itertools import accumulate
from collections import defaultdict
import sys
sys.setrecursionlimit(10**6)

def I(): return int(input())
def ST(): return input()
def IL(): return list(map(int, input().split()))
def ILS(): return sorted(map(int, input().split()))

n = I()
nums = defaultdict(list)
for i in range(1,n+1):
   b = I()
   if b != -1:
    nums[b].append(i)
 
ans = 1   
def dfs(emp,depth):
    global ans
    ans = max(ans,depth)
    while emp in nums and nums[emp]:
        temp = nums[emp].pop()
        dfs(temp,depth+1)

for emp in nums:
    if nums[emp]:
        dfs(emp,1)
print(ans)","def min_groups(n, managers):
    from collections import defaultdict, deque

    tree = defaultdict(list)
    for employee in range(1, n + 1):
        manager = managers[employee - 1]
        if manager != -1:
            tree[manager].append(employee)

    def bfs(start):
        queue = deque([(start, 0)])
        max_depth = 0
        visited = set()
        
        while queue:
            emp, level = queue.popleft()
            visited.add(emp)
            max_depth = max(max_depth, level)
            for subordinate in tree[emp]:
                if subordinate not in visited:
                    queue.append((subordinate, level + 1))
        
        return max_depth + 1

    group_count = 0
    for employee in range(1, n + 1):
        if managers[employee - 1] == -1:
            group_count += bfs(employee)

    return group_count

n = int(input().strip())
managers = [int(input().strip()) for _ in range(n)]

print(min_groups(n, managers))"
1011,A,Stages,PROGRAMMING,"['greedy', 'implementation', 'sortings']","Natasha is going to fly to Mars. She needs to build a rocket, which consists of several stages in some order. Each of the stages is defined by a lowercase Latin letter. This way, the rocket can be described by the string — concatenation of letters, which correspond to the stages.

There are $n$ stages available. The rocket must contain exactly $k$ of them. Stages in the rocket should be ordered by their weight. So, after the stage with some letter can go only stage with a letter, which is at least two positions after in the alphabet (skipping one letter in between, or even more). For example, after letter 'c' can't go letters 'a', 'b', 'c' and 'd', but can go letters 'e', 'f', ..., 'z'.

For the rocket to fly as far as possible, its weight should be minimal. The weight of the rocket is equal to the sum of the weights of its stages. The weight of the stage is the number of its letter in the alphabet. For example, the stage 'a 'weighs one ton,' b 'weighs two tons, and' z' — $26$ tons.

Build the rocket with the minimal weight or determine, that it is impossible to build a rocket at all. Each stage can be used at most once.","The first line of input contains two integers — $n$ and $k$ ($1 \le k \le n \le 50$) – the number of available stages and the number of stages to use in the rocket.

The second line contains string $s$, which consists of exactly $n$ lowercase Latin letters. Each letter defines a new stage, which can be used to build the rocket. Each stage can be used at most once.","Print a single integer — the minimal total weight of the rocket or -1, if it is impossible to build the rocket at all.","['5 3\nxyabd\n', '7 4\nproblem\n', '2 2\nab\n', '12 1\nabaabbaaabbb\n']","['29', '34', '-1', '1']","In the first example, the following rockets satisfy the condition:
-  ""adx"" (weight is $1+4+24=29$);-  ""ady"" (weight is $1+4+25=30$);-  ""bdx"" (weight is $2+4+24=30$);-  ""bdy"" (weight is $2+4+25=31$).
Rocket ""adx"" has the minimal weight, so the answer is $29$.

In the second example, target rocket is ""belo"". Its weight is $2+5+12+15=34$.

In the third example, $n=k=2$, so the rocket must have both stages: 'a' and 'b'. This rocket doesn't satisfy the condition, because these letters are adjacent in the alphabet. Answer is -1.",OK,"a='abcdefghijklmnopqrstuvwxyz'
n,k=map(int,input().split( ))
s=list(input())
s.sort()
g=(a.index(s[0])+1)
k-=1
p=1
m=''
m+=s[0]
while k!=0:
    if a.index(s[p])-a.index(m[len(m)-1])>=2:
        m+=s[p]
        g+=(a.index(s[p])+1)
        k-=1
    p+=1
    if p==n and k!=0:
        print(-1)
        exit()
print(g)","def minimal_rocket_weight(n, k, stages):

    unique_stages = sorted(set(stages))

    rocket = []
    last_weight = -3

    for stage in unique_stages:
        weight = ord(stage) - ord('a') + 1

        if weight - last_weight >= 2:
            rocket.append(weight)
            last_weight = weight
            if len(rocket) == k:
                break

    if len(rocket) < k:
        return -1
  
    return sum(rocket)

inputs = ['5 3\nxyabd\n', '7 4\nproblem\n', '2 2\nab\n', '12 1\nabaabbaaabbb\n']
outputs = []

for input_data in inputs:
    n, k, stages = input_data.splitlines()
    n, k = map(int, n.split())
    result = minimal_rocket_weight(n, k, stages)
    outputs.append(str(result))

print(outputs)"
493,B,Vasya and Wrestling,PROGRAMMING,['implementation'],"Vasya has become interested in wrestling. In wrestling wrestlers use techniques for which they are awarded points by judges. The wrestler who gets the most points wins.

When the numbers of points of both wrestlers are equal, the wrestler whose sequence of points is lexicographically greater, wins.

If the sequences of the awarded points coincide, the wrestler who performed the last technique wins. Your task is to determine which wrestler won.","The first line contains number *n* — the number of techniques that the wrestlers have used (1<=≤<=*n*<=≤<=2·105). 

The following *n* lines contain integer numbers *a**i* (|*a**i*|<=≤<=109, *a**i*<=≠<=0). If *a**i* is positive, that means that the first wrestler performed the technique that was awarded with *a**i* points. And if *a**i* is negative, that means that the second wrestler performed the technique that was awarded with (<=-<=*a**i*) points.

The techniques are given in chronological order.","If the first wrestler wins, print string ""first"", otherwise print ""second""","['5\n1\n2\n-3\n-4\n3\n', '3\n-1\n-2\n3\n', '2\n4\n-4\n']","['second\n', 'first\n', 'second\n']","Sequence *x*  =  *x*<sub class=""lower-index"">1</sub>*x*<sub class=""lower-index"">2</sub>... *x*<sub class=""lower-index"">|*x*|</sub> is lexicographically larger than sequence *y*  =  *y*<sub class=""lower-index"">1</sub>*y*<sub class=""lower-index"">2</sub>... *y*<sub class=""lower-index"">|*y*|</sub>, if either |*x*|  &gt;  |*y*| and *x*<sub class=""lower-index"">1</sub>  =  *y*<sub class=""lower-index"">1</sub>,  *x*<sub class=""lower-index"">2</sub>  =  *y*<sub class=""lower-index"">2</sub>, ... ,  *x*<sub class=""lower-index"">|*y*|</sub>  =  *y*<sub class=""lower-index"">|*y*|</sub>, or there is such number *r* (*r*  &lt;  |*x*|, *r*  &lt;  |*y*|), that *x*<sub class=""lower-index"">1</sub>  =  *y*<sub class=""lower-index"">1</sub>,  *x*<sub class=""lower-index"">2</sub>  =  *y*<sub class=""lower-index"">2</sub>,  ... ,  *x*<sub class=""lower-index"">*r*</sub>  =  *y*<sub class=""lower-index"">*r*</sub> and *x*<sub class=""lower-index"">*r*  +  1</sub>  &gt;  *y*<sub class=""lower-index"">*r*  +  1</sub>.

We use notation |*a*| to denote length of sequence *a*.",COMPILATION_ERROR,"using namespace std;

typedef long long ll;
typedef pair<int, int> pii;

const double epsilon = 1e-11;
const int infinity = (int) 2e9;
const int mod = (int) 1e9 + 7;
const int N = 234567;

int first[N];
int second[N];

int main()
{
    int methods;
    cin >> methods;

    int methodsFirst = 0;
    int methodsSecond = 0;

    int scoreFirst = 0;
    int scoreSecond = 0;

    int last;

    for (int i = 0; i < methods; i++)
    {
        int now;
        cin >> now;

        if (now > 0)
            scoreFirst += +now, first[methodsFirst++] = scoreFirst;
        else
            scoreSecond += -now, second[methodsSecond++] = scoreSecond;

        last = now < 0 ? 2 : 1;
    }

    if (scoreFirst == scoreSecond)
    {
        for (int i = 0; i < min (methodsFirst, methodsSecond); i++)
        {
            if (first[i] > second[i])
            {
                puts (""first"");
                return 0;
            }

            else if (first[i] < second[i])
            {
                puts (""second"");
                return 0;
            }
        }

        if (methodsFirst < methodsSecond) puts (""first"");
        else if (methodsSecond < methodsFirst) puts (""second"");
        else puts (last == 1 ? ""first"" : ""second"");
    }

    else
    {
        if (scoreFirst > scoreSecond)
            puts (""first"");
        else
            puts (""second"");
    }

    return 0;
}","def determine_winner(n, techniques):
    first_points = 0
    second_points = 0
    first_sequence = []
    second_sequence = []

    for i in range(n):
        points = techniques[i]
        if points > 0:
            first_points += points
            first_sequence.append(points)
        else:
            second_points += -points
            second_sequence.append(-points)

    if first_points > second_points:
        return ""first""
    elif second_points > first_points:
        return ""second""
    else:

        if first_sequence > second_sequence:
            return ""first""
        elif second_sequence > first_sequence:
            return ""second""
        else:

            if techniques[-1] > 0:
                return ""first""
            else:
                return ""second""

inputs = ['5\n1\n2\n-3\n-4\n3\n', '3\n-1\n-2\n3\n', '2\n4\n-4\n']
outputs = []

for input_data in inputs:
    lines = list(map(int, input_data.split()))
    n = lines[0]
    techniques = lines[1:]
    outputs.append(determine_winner(n, techniques))

print(outputs)"
224,B,Array,PROGRAMMING,"['bitmasks', 'implementation', 'two pointers']","You've got an array *a*, consisting of *n* integers: *a*1,<=*a*2,<=...,<=*a**n*. Your task is to find a minimal by inclusion segment [*l*,<=*r*] (1<=≤<=*l*<=≤<=*r*<=≤<=*n*) such, that among numbers *a**l*,<= *a**l*<=+<=1,<= ...,<= *a**r* there are exactly *k* distinct numbers.

Segment [*l*,<=*r*] (1<=≤<=*l*<=≤<=*r*<=≤<=*n*; *l*,<=*r* are integers) of length *m*<==<=*r*<=-<=*l*<=+<=1, satisfying the given property, is called minimal by inclusion, if there is no segment [*x*,<=*y*] satisfying the property and less then *m* in length, such that 1<=≤<=*l*<=≤<=*x*<=≤<=*y*<=≤<=*r*<=≤<=*n*. Note that the segment [*l*,<=*r*] doesn't have to be minimal in length among all segments, satisfying the given property.","The first line contains two space-separated integers: *n* and *k* (1<=≤<=*n*,<=*k*<=≤<=105). The second line contains *n* space-separated integers *a*1,<=*a*2,<=...,<=*a**n* — elements of the array *a* (1<=≤<=*a**i*<=≤<=105).","Print a space-separated pair of integers *l* and *r* (1<=≤<=*l*<=≤<=*r*<=≤<=*n*) such, that the segment [*l*,<=*r*] is the answer to the problem. If the sought segment does not exist, print ""-1 -1"" without the quotes. If there are multiple correct answers, print any of them.","['4 2\n1 2 2 3\n', '8 3\n1 1 2 2 3 3 4 5\n', '7 4\n4 7 7 4 7 4 7\n']","['1 2\n', '2 5\n', '-1 -1\n']","In the first sample among numbers *a*<sub class=""lower-index"">1</sub> and *a*<sub class=""lower-index"">2</sub> there are exactly two distinct numbers.

In the second sample segment [2, 5] is a minimal by inclusion segment with three distinct numbers, but it is not minimal in length among such segments.

In the third sample there is no segment with four distinct numbers.",OK,"import sys
import os.path
 
if(os.path.exists('input.txt')) :
    sys.stdin = open(""input.txt"", ""r"")
    sys.stdout = open(""output.txt"", ""w"")
    sys.stderr = open(""error.txt"", ""w"")
    
depth = 1000005
mod = 1000000007 
lim = mod * mod
sys.setrecursionlimit(depth) 
 
linp = lambda: list(minp())
minp = lambda: map(int, input().split())
 
from math import inf, ceil, sqrt, log2
from collections import defaultdict, deque

dd = lambda x: defaultdict(lambda: x)
 
(n, k), a = minp(), linp()
c, s = dd(0), set(a)
for e in a : c[e] += 1
i, j = 0, n
while len(s) > k :
    j -= 1
    c[a[j]] -= 1
    if c[a[j]] == 0 :
        s.remove(a[j])
j -= 1
while len(s) == k :
    if c[a[j]] > 1 :
        c[a[j]] -= 1
        j -= 1
    elif c[a[i]] > 1 :
        c[a[i]] -= 1
        i += 1
    else :
        break
if len(set(a)) < k : print(""-1 -1"")
else : print(i+1, j+1)","def find_minimal_segment(n, k, a):
    left = 0
    right = 0
    distinct_count = 0
    frequency = {}
    result = (-1, -1)

    while right < n:

        if a[right] in frequency:
            frequency[a[right]] += 1
        else:
            frequency[a[right]] = 1
            distinct_count += 1

        while distinct_count == k:

            if result == (-1, -1) or (right - left < result[1] - result[0]):
                result = (left, right)

            frequency[a[left]] -= 1
            if frequency[a[left]] == 0:
                del frequency[a[left]]
                distinct_count -= 1
            
            left += 1

        right += 1

    if result == (-1, -1):
        return ""-1 -1""
    else:
        return f""{result[0] + 1} {result[1] + 1}""

inputs = [
    (4, 2, [1, 2, 2, 3]),
    (8, 3, [1, 1, 2, 2, 3, 3, 4, 5]),
    (7, 4, [4, 7, 7, 4, 7, 4, 7])
]

for n, k, a in inputs:
    print(find_minimal_segment(n, k, a))"
743,A,Vladik and flights,PROGRAMMING,"['constructive algorithms', 'greedy', 'implementation']","Vladik is a competitive programmer. This year he is going to win the International Olympiad in Informatics. But it is not as easy as it sounds: the question Vladik face now is to find the cheapest way to get to the olympiad.

Vladik knows *n* airports. All the airports are located on a straight line. Each airport has unique id from 1 to *n*, Vladik's house is situated next to the airport with id *a*, and the place of the olympiad is situated next to the airport with id *b*. It is possible that Vladik's house and the place of the olympiad are located near the same airport. 

To get to the olympiad, Vladik can fly between any pair of airports any number of times, but he has to start his route at the airport *a* and finish it at the airport *b*.

Each airport belongs to one of two companies. The cost of flight from the airport *i* to the airport *j* is zero if both airports belong to the same company, and |*i*<=-<=*j*| if they belong to different companies.

Print the minimum cost Vladik has to pay to get to the olympiad.","The first line contains three integers *n*, *a*, and *b* (1<=≤<=*n*<=≤<=105, 1<=≤<=*a*,<=*b*<=≤<=*n*) — the number of airports, the id of the airport from which Vladik starts his route and the id of the airport which he has to reach. 

The second line contains a string with length *n*, which consists only of characters 0 and 1. If the *i*-th character in this string is 0, then *i*-th airport belongs to first company, otherwise it belongs to the second.",Print single integer — the minimum cost Vladik has to pay to get to the olympiad.,"['4 1 4\n1010\n', '5 5 2\n10110\n']","['1', '0']","In the first example Vladik can fly to the airport 2 at first and pay |1 - 2| = 1 (because the airports belong to different companies), and then fly from the airport 2 to the airport 4 for free (because the airports belong to the same company). So the cost of the whole flight is equal to 1. It's impossible to get to the olympiad for free, so the answer is equal to 1. 

In the second example Vladik can fly directly from the airport 5 to the airport 2, because they belong to the same company.",WRONG_ANSWER,"import fileinput

def test():
	pass
if __name__ == '__main__':
	num_args = 2
	for arg in range(num_args):
		if arg == 0:
			n,a,b = map(int, input().split())
		else:
			s = input()
	min_cost = 0

	if s[a-1] == s[b-1]:
		min_cost += 0
	else:
		if a > b:
			for i in range(a-1,b-1, -1):
				if s[i] == s[b-1]:
					break
				else:
					min_cost += 1
		else:
			for i in range(a-1,b-1):
				if s[i] == s[b-1]:
					break
				else:
					min_cost += 1
	print(min_cost)","def minimum_cost(n, a, b, companies):

    a -= 1
    b -= 1

    if companies[a] == companies[b]:
        return 0

    return abs(a - b)

input_data = ['4 1 4\n1010\n', '5 5 2\n10110\n']

for data in input_data:
    lines = data.splitlines()
    n, a, b = map(int, lines[0].split())
    companies = lines[1].strip()

    print(minimum_cost(n, a, b, companies))"
515,C,Drazil and Factorial,PROGRAMMING,"['greedy', 'math', 'sortings']","Drazil is playing a math game with Varda.

Let's define  for positive integer *x* as a product of factorials of its digits. For example, .

First, they choose a decimal number *a* consisting of *n* digits that contains at least one digit larger than 1. This number may possibly start with leading zeroes. Then they should find maximum positive number *x* satisfying following two conditions:

1. *x* doesn't contain neither digit 0 nor digit 1.

2.  = .

Help friends find such number.","The first line contains an integer *n* (1<=≤<=*n*<=≤<=15) — the number of digits in *a*.

The second line contains *n* digits of *a*. There is at least one digit in *a* that is larger than 1. Number *a* may possibly contain leading zeroes.",Output a maximum possible integer satisfying the conditions above. There should be no zeroes and ones in this number decimal representation.,"['4\n1234\n', '3\n555\n']","['33222\n', '555\n']","In the first case, <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/f5a4207f23215fddce977ab5ea9e9d2e7578fb52.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>",OK,"answer = {
    ""7"": [7],
    ""8"": [7, 2, 2, 2],
    ""9"": [7, 3, 3, 2],
    ""6"": [5, 3],
    ""5"": [5],
    ""4"": [3, 2, 2],
    ""3"": [3],
    ""2"": [2],
    ""1"": [],
    ""0"": []
}
def main():
    _ = input()
    inp = str(input())
    ans = []
    for i in inp:
        ans += answer[i]

    ans.sort()
    for i in reversed(ans):
        print(i, end="""")
main()","def digit_factorial_product(n, digits):

    digit_map = {
        '0': '',
        '1': '',
        '2': '2',
        '3': '3',
        '4': '322',
        '5': '5',
        '6': '53',
        '7': '7',
        '8': '7222',
        '9': '7332'
    }

    result = []

    for digit in digits:
        result.append(digit_map[digit])

    result_str = ''.join(result)
    final_number = ''.join(sorted(result_str, reverse=True))
    
    return final_number

n = int(input())
digits = input().strip()

result = digit_factorial_product(n, digits)

print(result)"
199,A,Hexadecimal's theorem,PROGRAMMING,"['brute force', 'constructive algorithms', 'implementation', 'number theory']","Recently, a chaotic virus Hexadecimal advanced a new theorem which will shake the Universe. She thinks that each Fibonacci number can be represented as sum of three not necessary different Fibonacci numbers.

Let's remember how Fibonacci numbers can be calculated. *F*0<==<=0, *F*1<==<=1, and all the next numbers are *F**i*<==<=*F**i*<=-<=2<=+<=*F**i*<=-<=1.

So, Fibonacci numbers make a sequence of numbers: 0, 1, 1, 2, 3, 5, 8, 13, ...

If you haven't run away from the PC in fear, you have to help the virus. Your task is to divide given Fibonacci number *n* by three not necessary different Fibonacci numbers or say that it is impossible.",The input contains of a single integer *n* (0<=≤<=*n*<=&lt;<=109) — the number that should be represented by the rules described above. It is guaranteed that *n* is a Fibonacci number.,"Output three required numbers: *a*, *b* and *c*. If there is no answer for the test you have to print ""I'm too stupid to solve this problem"" without the quotes.

If there are multiple answers, print any of them.","['3\n', '13\n']","['1 1 1\n', '2 3 8\n']",none,WRONG_ANSWER,"n = int(input())
s = 1
t = 1
def Fibonacci(n,x):
	if x == 1:
		return n
	s = 1
	t = 1
	while True:
		k = s + t
		t = s
		s = k
		if s >= n:
			return t,Fibonacci(n-t,x-1)
if n >= 3:
	l = Fibonacci(n,3)
	print(l[0],l[1][0],l[1][1])
if n < 3:
	print(""I'm too stupid to solve this problem"")","def fibonacci_sequence(n):
    fibs = [0, 1]
    while True:
        next_fib = fibs[-1] + fibs[-2]
        if next_fib > n:
            break
        fibs.append(next_fib)
    return fibs

def represent_fibonacci(n):

    if n == 0:
        return 0, 0, 0
    elif n == 1:
        return 1, 0, 0
    elif n == 2:
        return 1, 1, 0
    elif n == 3:
        return 1, 1, 1

    fibs = fibonacci_sequence(n)

    for i in fibs:
        for j in fibs:
            for k in fibs:
                if i + j + k == n:
                    return i, j, k
    return None

import sys
input_data = sys.stdin.read().strip().split()

results = []
for line in input_data:
    n = int(line)
    result = represent_fibonacci(n)
    if result:
        results.append("" "".join(map(str, result)))
    else:
        results.append(""I'm too stupid to solve this problem"")

print(""\n"".join(results))"
139,A,Petr and Book,PROGRAMMING,['implementation'],"One Sunday Petr went to a bookshop and bought a new book on sports programming. The book had exactly *n* pages.

Petr decided to start reading it starting from the next day, that is, from Monday. Petr's got a very tight schedule and for each day of the week he knows how many pages he will be able to read on that day. Some days are so busy that Petr will have no time to read whatsoever. However, we know that he will be able to read at least one page a week.

Assuming that Petr will not skip days and will read as much as he can every day, determine on which day of the week he will read the last page of the book.","The first input line contains the single integer *n* (1<=≤<=*n*<=≤<=1000) — the number of pages in the book.

The second line contains seven non-negative space-separated integers that do not exceed 1000 — those integers represent how many pages Petr can read on Monday, Tuesday, Wednesday, Thursday, Friday, Saturday and Sunday correspondingly. It is guaranteed that at least one of those numbers is larger than zero.","Print a single number — the number of the day of the week, when Petr will finish reading the book. The days of the week are numbered starting with one in the natural order: Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday.","['100\n15 20 20 15 10 30 45\n', '2\n1 0 0 0 0 0 0\n']","['6\n', '1\n']","Note to the first sample:

By the end of Monday and therefore, by the beginning of Tuesday Petr has 85 pages left. He has 65 pages left by Wednesday, 45 by Thursday, 30 by Friday, 20 by Saturday and on Saturday Petr finishes reading the book (and he also has time to read 10 pages of something else).

Note to the second sample:

On Monday of the first week Petr will read the first page. On Monday of the second week Petr will read the second page and will finish reading the book.",RUNTIME_ERROR,"n=int(input())
s=input()
l=s.split()
l=[int(i) for i in l]
su=0
def f(su,n):
    k=0
    while k<=len(l):
        su=su+l[k]
        if su>=n:
            print(k+1)
            return
        k=k+1
    f(su,n)
f(su,n)","n = int(input())

pages_per_day = list(map(int, input().split()))

current_page = 0

day_index = 0

while current_page < n:

    current_page += pages_per_day[day_index]

    if current_page >= n:
        print(day_index + 1)
        break

    day_index = (day_index + 1) % 7"
71,A,Way Too Long Words,PROGRAMMING,['strings'],"Sometimes some words like ""localization"" or ""internationalization"" are so long that writing them many times in one text is quite tiresome.

Let's consider a word too long, if its length is strictly more than 10 characters. All too long words should be replaced with a special abbreviation.

This abbreviation is made like this: we write down the first and the last letter of a word and between them we write the number of letters between the first and the last letters. That number is in decimal system and doesn't contain any leading zeroes.

Thus, ""localization"" will be spelt as ""l10n"", and ""internationalization» will be spelt as ""i18n"".

You are suggested to automatize the process of changing the words with abbreviations. At that all too long words should be replaced by the abbreviation and the words that are not too long should not undergo any changes.",The first line contains an integer *n* (1<=≤<=*n*<=≤<=100). Each of the following *n* lines contains one word. All the words consist of lowercase Latin letters and possess the lengths of from 1 to 100 characters.,Print *n* lines. The *i*-th line should contain the result of replacing of the *i*-th word from the input data.,['4\nword\nlocalization\ninternationalization\npneumonoultramicroscopicsilicovolcanoconiosis\n'],['word\nl10n\ni18n\np43s\n'],none,OK,"def main():
    t = int(input())
    
    for i in range(t):
        word = str(input())
        if len(word) > 10:
            print(word[0] + str((len(word) - 2)) + word[len(word) - 1])
        else:
            print(word)

if __name__ == '__main__':
    main()","def abbreviate_word(word):

    if len(word) > 10:

        return f""{word[0]}{len(word) - 2}{word[-1]}""

    return word

def process_words(n, words):

    results = []
    for word in words:
        results.append(abbreviate_word(word))
    return results

n = int(input())
words = [input().strip() for _ in range(n)]

abbreviated_words = process_words(n, words)
for word in abbreviated_words:
    print(word)"
254,A,Cards with Numbers,PROGRAMMING,"['constructive algorithms', 'sortings']","Petya has got 2*n* cards, each card contains some integer. The numbers on the cards can be the same. Let's index all cards by consecutive integers from 1 to 2*n*. We'll denote the number that is written on a card with number *i*, as *a**i*. In order to play one entertaining game with his friends, Petya needs to split the cards into pairs so that each pair had equal numbers on the cards. Help Petya do that.","The first line contains integer *n* (1<=≤<=*n*<=≤<=3·105). The second line contains the sequence of 2*n* positive integers *a*1,<=*a*2,<=...,<=*a*2*n* (1<=≤<=*a**i*<=≤<=5000) — the numbers that are written on the cards. The numbers on the line are separated by single spaces.","If it is impossible to divide the cards into pairs so that cards in each pair had the same numbers, print on a single line integer -1. But if the required partition exists, then print *n* pairs of integers, a pair per line — the indices of the cards that form the pairs.

Separate the numbers on the lines by spaces. You can print the pairs and the numbers in the pairs in any order. If there are multiple solutions, print any of them.","['3\n20 30 10 30 20 10\n', '1\n1 2\n']","['4 2\n1 5\n6 3\n', '-1']",none,OK,"import sys
sys.stdin = open(""input.txt"", ""r"")
sys.stdout = open(""output.txt"", ""w"")
n=int(input())
d={}
for x,y in enumerate(input().split(),1):
    d.setdefault(y,[]).append(x)
if any(len(d[i])%2!=0 for i in d):
    print(-1)
    exit(0)
for i in d:
    print(""\n"".join(""{0} {1}"".format(*k) for k in zip(d[i][::2],d[i][1::2])))","def pair_cards(n, cards):
    from collections import defaultdict

    card_indices = defaultdict(list)

    for index, value in enumerate(cards, start=1):
        card_indices[value].append(index)

    pairs = []

    for indices in card_indices.values():
        if len(indices) % 2 != 0:
            return -1

        for i in range(0, len(indices), 2):
            pairs.append((indices[i], indices[i + 1]))

    return pairs

n = int(input().strip())
cards = list(map(int, input().strip().split()))

result = pair_cards(n, cards)

if result == -1:
    print(-1)
else:
    for pair in result:
        print(pair[0], pair[1])"
0,none,none,none,['none'],"Today Pari and Arya are playing a game called Remainders.

Pari chooses two positive integer *x* and *k*, and tells Arya *k* but not *x*. Arya have to find the value . There are *n* ancient numbers *c*1,<=*c*2,<=...,<=*c**n* and Pari has to tell Arya  if Arya wants. Given *k* and the ancient values, tell us if Arya has a winning strategy independent of value of *x* or not. Formally, is it true that Arya can understand the value  for any positive integer *x*?

Note, that  means the remainder of *x* after dividing it by *y*.","The first line of the input contains two integers *n* and *k* (1<=≤<=*n*,<= *k*<=≤<=1<=000<=000) — the number of ancient integers and value *k* that is chosen by Pari.

The second line contains *n* integers *c*1,<=*c*2,<=...,<=*c**n* (1<=≤<=*c**i*<=≤<=1<=000<=000).","Print ""Yes"" (without quotes) if Arya has a winning strategy independent of value of *x*, or ""No"" (without quotes) otherwise.","['4 5\n2 3 5 12\n', '2 7\n2 3\n']","['Yes\n', 'No\n']","In the first sample, Arya can understand <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/d170efffcde0907ee6bcf32de21051bce0677a2c.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> because 5 is one of the ancient numbers.

In the second sample, Arya can't be sure what <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/57b5f6a96f5db073270dd3ed4266c69299ec701d.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> is. For example 1 and 7 have the same remainders after dividing by 2 and 3, but they differ in remainders after dividing by 7.",RUNTIME_ERROR,"import math
l = math.lcm
def lcm(a):
    lc = l(a[0],a[1])
    for i in range(2,len(a)):
        lc = l(lc,a[i])
    return lc
n,k = map(int,input().split())
a = list(map(int,input().split()))
if k in a or lcm(a)==k:
    print('YES')
else:
    print('NO')","def has_winning_strategy(n, k, ancient_numbers):

    if k in ancient_numbers:
        return ""Yes""
    else:
        return ""No""

input_lines = input().strip().split('\n')

n, k = map(int, input_lines[0].split())

ancient_numbers = list(map(int, input_lines[1].split()))

result = has_winning_strategy(n, k, ancient_numbers)
print(result)"
50,A,Domino piling,PROGRAMMING,"['greedy', 'math']","You are given a rectangular board of *M*<=×<=*N* squares. Also you are given an unlimited number of standard domino pieces of 2<=×<=1 squares. You are allowed to rotate the pieces. You are asked to place as many dominoes as possible on the board so as to meet the following conditions:

1. Each domino completely covers two squares.

2. No two dominoes overlap.

3. Each domino lies entirely inside the board. It is allowed to touch the edges of the board.

Find the maximum number of dominoes, which can be placed under these restrictions.",In a single line you are given two integers *M* and *N* — board sizes in squares (1<=≤<=*M*<=≤<=*N*<=≤<=16).,"Output one number — the maximal number of dominoes, which can be placed.","['2 4\n', '3 3\n']","['4\n', '4\n']",none,WRONG_ANSWER,"""""""
Created on Thu Jan  7 18:06:14 2021

@author: cse1g
""""""
import math

def func(m,n):
    return max((m*(n//2)),(n*(m//2)))
m,n=list(map(int,input().split()))
if m%2==0 and n%2==0:
    res=func(m,n)
elif m%2==0 and n%2!=0:
    res=func(m,(math.floor(n/2))*2)+1
elif m%2!=0 and n%2==0:
    res=func((math.floor(m/2))*2,n)+1
else :
    res=func((math.floor(m/2))*2,(math.floor(n/2))*2)+2
print(res)","def max_dominoes(M, N):

    return (M * N) // 2

input_data = input().strip()
M, N = map(int, input_data.split())

print(max_dominoes(M, N))"
900,B,Position in Fraction,PROGRAMMING,"['math', 'number theory']",You have a fraction . You need to find the first occurrence of digit *c* into decimal notation of the fraction after decimal point.,"The first contains three single positive integers *a*, *b*, *c* (1<=≤<=*a*<=&lt;<=*b*<=≤<=105, 0<=≤<=*c*<=≤<=9).","Print position of the first occurrence of digit *c* into the fraction. Positions are numbered from 1 after decimal point. It there is no such position, print -1.","['1 2 0\n', '2 3 7\n']","['2', '-1']","The fraction in the first example has the following decimal notation: <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/896357459a466614a0542f34c9cfb0cef1afc9ed.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>. The first zero stands on second position.

The fraction in the second example has the following decimal notation: <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/130ba579a8276fc53a1917606eee9db58817f28d.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>. There is no digit 7 in decimal notation of the fraction.",WRONG_ANSWER,"from bisect import bisect_left as bl
from bisect import bisect_right as br
import heapq
import math
from collections import *
from functools import reduce,cmp_to_key
import sys
import io, os
input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline
 
M = mod = 10**9 + 7
def factors(n):return sorted(set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))
def inv_mod(n):return pow(n, mod - 2, mod)
 
def li():return [int(i) for i in input().split()]
def st():return input()
def val():return int(input())
def li2():return [i for i in input().split()]
def li3():return [int(i) for i in input()]

a,b,c = li()
fra = str(a/b) + '0'
if '.' not in fra:
    print(-1)
    exit()
ind = fra.index('.')
print(fra)
curr = 1
for i in range(ind + 1,len(fra),1):
    if fra[i] == str(c):
        print(curr)
        exit()
    curr += 1","def find_digit_in_fraction(a, b, c):

    decimal_position = 1
    remainder = a % b

    seen_remainders = {}

    while remainder:

        if remainder in seen_remainders:
            break

        seen_remainders[remainder] = decimal_position

        remainder *= 10
        digit = remainder // b

        if digit == c:
            return decimal_position

        remainder = remainder % b
        decimal_position += 1

    return -1

demo_inputs = ['1 2 0\n', '2 3 7\n']
results = []
for input_str in demo_inputs:
    a, b, c = map(int, input_str.strip().split())
    result = find_digit_in_fraction(a, b, c)
    results.append(str(result))

print(results)"
863,B,Kayaking,PROGRAMMING,"['brute force', 'greedy', 'sortings']","Vadim is really keen on travelling. Recently he heard about kayaking activity near his town and became very excited about it, so he joined a party of kayakers.

Now the party is ready to start its journey, but firstly they have to choose kayaks. There are 2·*n* people in the group (including Vadim), and they have exactly *n*<=-<=1 tandem kayaks (each of which, obviously, can carry two people) and 2 single kayaks. *i*-th person's weight is *w**i*, and weight is an important matter in kayaking — if the difference between the weights of two people that sit in the same tandem kayak is too large, then it can crash. And, of course, people want to distribute their seats in kayaks in order to minimize the chances that kayaks will crash.

Formally, the instability of a single kayak is always 0, and the instability of a tandem kayak is the absolute difference between weights of the people that are in this kayak. Instability of the whole journey is the total instability of all kayaks.

Help the party to determine minimum possible total instability!","The first line contains one number *n* (2<=≤<=*n*<=≤<=50).

The second line contains 2·*n* integer numbers *w*1, *w*2, ..., *w*2*n*, where *w**i* is weight of person *i* (1<=≤<=*w**i*<=≤<=1000).",Print minimum possible total instability.,"['2\n1 2 3 4\n', '4\n1 3 4 6 3 4 100 200\n']","['1\n', '5\n']",none,OK,"inf = float('inf')

def solve(A, N):
    A.sort()
    N *= 2
    ans = inf
    for i in range(N):
        for j in range(i + 1, N):
            B = []
            for k in range(N):
                if k != i and k != j:
                    B.append(A[k])

            total = sum(B[i + 1] - B[i] for i in range(0, N - 2, 2))
            ans = min(ans, total)
    return ans                    

N = int(input())
A = list(map(int, input().split()))
print(solve(A, N))","from itertools import combinations

def calculate_instability(pair):

    return abs(pair[0] - pair[1])

def minimum_instability(n, weights):
    total_people = 2 * n

    all_pairs = list(combinations(weights, 2))
    instability = float('inf')

    for pairs in combinations(all_pairs, n):
        selected_weights = set()

        for pair in pairs:
            selected_weights.update(pair)
        
        if len(selected_weights) == total_people:
            current_instability = sum(calculate_instability(pair) for pair in pairs)
            instability = min(instability, current_instability)
    
    return instability

n = int(input().strip())
weights = list(map(int, input().strip().split()))

result = minimum_instability(n, weights)
print(result)"
38,A,Army,PROGRAMMING,['implementation'],"The Berland Armed Forces System consists of *n* ranks that are numbered using natural numbers from 1 to *n*, where 1 is the lowest rank and *n* is the highest rank.

One needs exactly *d**i* years to rise from rank *i* to rank *i*<=+<=1. Reaching a certain rank *i* having not reached all the previous *i*<=-<=1 ranks is impossible.

Vasya has just reached a new rank of *a*, but he dreams of holding the rank of *b*. Find for how many more years Vasya should serve in the army until he can finally realize his dream.",The first input line contains an integer *n* (2<=≤<=*n*<=≤<=100). The second line contains *n*<=-<=1 integers *d**i* (1<=≤<=*d**i*<=≤<=100). The third input line contains two integers *a* and *b* (1<=≤<=*a*<=&lt;<=*b*<=≤<=*n*). The numbers on the lines are space-separated.,Print the single number which is the number of years that Vasya needs to rise from rank *a* to rank *b*.,"['3\n5 6\n1 2\n', '3\n5 6\n1 3\n']","['5\n', '11\n']",none,OK,"import math
import sys
import itertools

def sa(Type= int):
  return [Type(x) for x in input().split()]

def solve(t):
  n = int(input())
  arr = sa()
  a, b = sa()

  print(sum(arr[a-1:b-1]))

if __name__ == '__main__':

  solve(0)","n = int(input().strip())

d = list(map(int, input().strip().split()))

a, b = map(int, input().strip().split())

total_years = sum(d[a-1:b-1])

print(total_years)"
757,D,Felicity's Big Secret Revealed,PROGRAMMING,"['bitmasks', 'dp']","The gym leaders were fascinated by the evolutions which took place at Felicity camp. So, they were curious to know about the secret behind evolving Pokemon. 

The organizers of the camp gave the gym leaders a PokeBlock, a sequence of *n* ingredients. Each ingredient can be of type 0 or 1. Now the organizers told the gym leaders that to evolve a Pokemon of type *k* (*k*<=≥<=2), they need to make a valid set of *k* cuts on the PokeBlock to get smaller blocks.

Suppose the given PokeBlock sequence is *b*0*b*1*b*2... *b**n*<=-<=1. You have a choice of making cuts at *n*<=+<=1 places, i.e., Before *b*0, between *b*0 and *b*1, between *b*1 and *b*2, ..., between *b**n*<=-<=2 and *b**n*<=-<=1, and after *b**n*<=-<=1.

The *n*<=+<=1 choices of making cuts are as follows (where a | denotes a possible cut):

Consider a sequence of *k* cuts. Now each pair of consecutive cuts will contain a binary string between them, formed from the ingredient types. The ingredients before the first cut and after the last cut are wasted, which is to say they are not considered. So there will be exactly *k*<=-<=1 such binary substrings. Every substring can be read as a binary number. Let *m* be the maximum number out of the obtained numbers. If all the obtained numbers are positive and the set of the obtained numbers contains all integers from 1 to *m*, then this set of cuts is said to be a valid set of cuts.

For example, suppose the given PokeBlock sequence is 101101001110 and we made 5 cuts in the following way:

So the 4 binary substrings obtained are: 11, 010, 01 and 1, which correspond to the numbers 3, 2, 1 and 1 respectively. Here *m*<==<=3, as it is the maximum value among the obtained numbers. And all the obtained numbers are positive and we have obtained all integers from 1 to *m*. Hence this set of cuts is a valid set of 5 cuts.

A Pokemon of type *k* will evolve only if the PokeBlock is cut using a valid set of *k* cuts. There can be many valid sets of the same size. Two valid sets of *k* cuts are considered different if there is a cut in one set which is not there in the other set.

Let *f*(*k*) denote the number of valid sets of *k* cuts. Find the value of . Since the value of *s* can be very large, output *s* modulo 109<=+<=7.","The input consists of two lines. The first line consists an integer *n* (1<=≤<=*n*<=≤<=75) — the length of the PokeBlock. The next line contains the PokeBlock, a binary string of length *n*.","Output a single integer, containing the answer to the problem, i.e., the value of *s* modulo 109<=+<=7.","['4\n1011\n', '2\n10\n']","['10\n', '1\n']","In the first sample, the sets of valid cuts are:

Size 2: |1|011, 1|01|1, 10|1|1, 101|1|.

Size 3: |1|01|1, |10|1|1, 10|1|1|, 1|01|1|.

Size 4: |10|1|1|, |1|01|1|.

Hence, *f*(2) = 4, *f*(3) = 4 and *f*(4) = 2. So, the value of *s* = 10.

In the second sample, the set of valid cuts is:

Size 2: |1|0.

Hence, *f*(2) = 1 and *f*(3) = 0. So, the value of *s* = 1.",OK,"mo = 10**9+7
def calc(l, r, si):
    res = 0
    for i in range(l, r + 1):
        res = res * 2 + int(si[i])
    return res
 
def main():
    n, si = int(input()), input()
    si = chr(0)+si
    f = [[0]*(1<<20) for i in range(6)]
    res, r, f[0][0]= 0, 0, 1
    for i in range(1, n+1):
        r=(r+1)%6
        f[r] = [0]*(1<<20)
        for j in range(1, min(5, i) + 1):
            if si[i-j+1] != '0':
                c, p = calc(i-j+1, i, si), (r-j+6)%6
                if(c>20 or c<1): break
                for s in range(1<<20):
                    if(f[p][s]):
                        f[r][s|(1<<(c-1))] = (f[r][s|(1<<(c-1))] + f[p][s]) % mo
        for s in range(1, 21):
            res = (res + f[r][(1<<s)-1]) % mo
        f[r][0] = (f[r][0] + 1) % mo
        if(si[i]=='0'):
            p=(r-1+6)%6
            for s in range(1<<20):
                if(f[p][s]):
                    f[r][s] = (f[r][s] + f[p][s]) % mo
    print(res)

main()","def is_valid_cut(blocks):

    numbers = set()
    
    for block in blocks:
        if block:
            num = int(block, 2)
            if num > 0:
                numbers.add(num)
    
    max_num = max(numbers) if numbers else 0

    return all(i in numbers for i in range(1, max_num + 1))

def count_valid_cuts(n, poke_block, k):
    from itertools import combinations
    
    valid_sets = 0
    cut_positions = range(n + 1)

    for cuts in combinations(cut_positions, k):

        blocks = [poke_block[cuts[i]:cuts[i + 1]] for i in range(k)]

        if is_valid_cut(blocks):
            valid_sets += 1
    
    return valid_sets

def main():
    import sys

    n = int(sys.stdin.readline().strip())
    poke_block = sys.stdin.readline().strip()
    
    MOD = 10**9 + 7
    total_valid_sets = 0

    for k in range(1, n + 1):
        total_valid_sets += count_valid_cuts(n, poke_block, k)
        total_valid_sets %= MOD
    
    print(total_valid_sets)

if __name__ == ""__main__"":
    main()"
708,A,Letters Cyclic Shift,PROGRAMMING,"['constructive algorithms', 'greedy', 'implementation', 'strings']","You are given a non-empty string *s* consisting of lowercase English letters. You have to pick exactly one non-empty substring of *s* and shift all its letters 'z'  'y'  'x'  'b'  'a'  'z'. In other words, each character is replaced with the previous character of English alphabet and 'a' is replaced with 'z'.

What is the lexicographically minimum string that can be obtained from *s* by performing this shift exactly once?",The only line of the input contains the string *s* (1<=≤<=|*s*|<=≤<=100<=000) consisting of lowercase English letters.,Print the lexicographically minimum string that can be obtained from *s* by shifting letters of exactly one non-empty substring.,"['codeforces\n', 'abacaba\n']","['bncdenqbdr\n', 'aaacaba\n']","String *s* is lexicographically smaller than some other string *t* of the same length if there exists some 1 ≤ *i* ≤ |*s*|, such that *s*<sub class=""lower-index"">1</sub> = *t*<sub class=""lower-index"">1</sub>, *s*<sub class=""lower-index"">2</sub> = *t*<sub class=""lower-index"">2</sub>, ..., *s*<sub class=""lower-index"">*i* - 1</sub> = *t*<sub class=""lower-index"">*i* - 1</sub>, and *s*<sub class=""lower-index"">*i*</sub> &lt; *t*<sub class=""lower-index"">*i*</sub>.",RUNTIME_ERROR,"import math
import string

class CycleShift():

    def __init__(self, s):
         self.initial_string = s
         self.final_list = []

    def execute_transformation(self):
        def transform(s):
            if s == ""a"":
                return ""z""
            else:
                return chr(ord(s) - 1)
        initial_index = -1
        final_index = -1
        is_started = False
        for i in range(len(self.initial_string)):
            if not is_started:
                if self.initial_string[i] != ""a"":
                    is_started = True
                    initial_index = i
                    print(initial_index)
            else:
                if self.initial_string[i] == ""a"":
                    final_index = i - 1
                    break
                elif i == len(self.initial_string) - 1:
                    final_index = i
        for i in range(len(self.initial_string)):
            if i < initial_index or i > final_index:
                print(self.initial_string[i], end="""")
            else:
                print(transform(self.initial_string[i]), end="""")

def main_function():
    s = input()
    shift = CycleShift(s)
    shift.execute_transformation()

main_function()

main_function()","def shift_char(c):

    if c == 'a':
        return 'z'
    else:
        return chr(ord(c) - 1)

def lexicographically_minimum_string(s):
    n = len(s)
    min_string = s

    for i in range(n):
        for j in range(i, n):

            new_s = s[:i] + ''.join(shift_char(c) for c in s[i:j + 1]) + s[j + 1:]

            if new_s < min_string:
                min_string = new_s

    return min_string

s = input().strip()

print(lexicographically_minimum_string(s))"
862,B,Mahmoud and Ehab and the bipartiteness,PROGRAMMING,"['dfs and similar', 'graphs', 'trees']","Mahmoud and Ehab continue their adventures! As everybody in the evil land knows, Dr. Evil likes bipartite graphs, especially trees.

A tree is a connected acyclic graph. A bipartite graph is a graph, whose vertices can be partitioned into 2 sets in such a way, that for each edge (*u*,<=*v*) that belongs to the graph, *u* and *v* belong to different sets. You can find more formal definitions of a tree and a bipartite graph in the notes section below.

Dr. Evil gave Mahmoud and Ehab a tree consisting of *n* nodes and asked them to add edges to it in such a way, that the graph is still bipartite. Besides, after adding these edges the graph should be simple (doesn't contain loops or multiple edges). What is the maximum number of edges they can add?

A loop is an edge, which connects a node with itself. Graph doesn't contain multiple edges when for each pair of nodes there is no more than one edge between them. A cycle and a loop aren't the same .","The first line of input contains an integer *n* — the number of nodes in the tree (1<=≤<=*n*<=≤<=105).

The next *n*<=-<=1 lines contain integers *u* and *v* (1<=≤<=*u*,<=*v*<=≤<=*n*, *u*<=≠<=*v*) — the description of the edges of the tree.

It's guaranteed that the given graph is a tree.",Output one integer — the maximum number of edges that Mahmoud and Ehab can add to the tree while fulfilling the conditions.,"['3\n1 2\n1 3\n', '5\n1 2\n2 3\n3 4\n4 5\n']","['0\n', '2\n']","Tree definition: [https://en.wikipedia.org/wiki/Tree_(graph_theory)](https://en.wikipedia.org/wiki/Tree_(graph_theory))

Bipartite graph definition: [https://en.wikipedia.org/wiki/Bipartite_graph](https://en.wikipedia.org/wiki/Bipartite_graph)

In the first test case the only edge that can be added in such a way, that graph won't contain loops or multiple edges is (2, 3), but adding this edge will make the graph non-bipartite so the answer is 0.

In the second test case Mahmoud and Ehab can add edges (1, 4) and (2, 5).",WRONG_ANSWER,"from queue import Queue

def main():
    n = int(input())
    edges_dict = {}

    for _ in range(n - 1):
        u, v = map(int, input().split())

        if u not in edges_dict:
            edges_dict[u] = [v]
        else:
            edges_dict[u].append(v)

        if v not in edges_dict:
            edges_dict[v] = [u]
        else:
            edges_dict[v].append(u)

    colors_array = [0 for i in range(1, n + 1)]
    queue = Queue()
    queue.put(1)
    current_color = 0
    visited = [False for i in range(1, n + 1)]
    while not queue.empty():
        current_node = queue.get()
        visited[current_node - 1] = True
        colors_array[current_node - 1] = current_color

        for neighbor in edges_dict[current_node]:
            if not visited[neighbor - 1]:
                queue.put(neighbor)

        current_color = 1 - current_color

    zero_nodes = colors_array.count(0)
    one_nodes = n - zero_nodes

    print(zero_nodes * one_nodes - (n - 1))

if __name__ == ""__main__"":
    main()","def max_edges_in_bipartite_tree(n, edges):
    from collections import defaultdict, deque

    graph = defaultdict(list)
    for u, v in edges:
        graph[u].append(v)
        graph[v].append(u)

    color = [-1] * (n + 1)

    def bfs(start):
        queue = deque([start])
        color[start] = 0
        count = [0, 0]
        count[0] += 1

        while queue:
            node = queue.popleft()
            for neighbor in graph[node]:
                if color[neighbor] == -1:
                    color[neighbor] = 1 - color[node]
                    count[color[neighbor]] += 1
                    queue.append(neighbor)

        return count

    count_0, count_1 = bfs(1)

    max_edges = count_0 * count_1

    max_additional_edges = max_edges - (n - 1)

    return max_additional_edges

import sys
input = sys.stdin.read
data = input().strip().split('\n')

results = []
idx = 0
while idx < len(data):
    n = int(data[idx])
    edges = []
    for i in range(n - 1):
        idx += 1
        u, v = map(int, data[idx].split())
        edges.append((u, v))
    idx += 1

    results.append(str(max_edges_in_bipartite_tree(n, edges)))

print(""\n"".join(results))"
498,C,Array and Operations,PROGRAMMING,"['flows', 'graph matchings', 'number theory']","You have written on a piece of paper an array of *n* positive integers *a*[1],<=*a*[2],<=...,<=*a*[*n*] and *m* good pairs of integers (*i*1,<=*j*1),<=(*i*2,<=*j*2),<=...,<=(*i**m*,<=*j**m*). Each good pair (*i**k*,<=*j**k*) meets the following conditions: *i**k*<=+<=*j**k* is an odd number and 1<=≤<=*i**k*<=&lt;<=*j**k*<=≤<=*n*.

In one operation you can perform a sequence of actions: 
 -  take one of the good pairs (*i**k*,<=*j**k*) and some integer *v* (*v*<=&gt;<=1), which divides both numbers *a*[*i**k*] and *a*[*j**k*]; -  divide both numbers by *v*, i. e. perform the assignments:  and . 
Determine the maximum number of operations you can sequentially perform on the given array. Note that one pair may be used several times in the described operations.","The first line contains two space-separated integers *n*, *m* (2<=≤<=*n*<=≤<=100, 1<=≤<=*m*<=≤<=100).

The second line contains *n* space-separated integers *a*[1],<=*a*[2],<=...,<=*a*[*n*] (1<=≤<=*a*[*i*]<=≤<=109) — the description of the array.

The following *m* lines contain the description of good pairs. The *k*-th line contains two space-separated integers *i**k*, *j**k* (1<=≤<=*i**k*<=&lt;<=*j**k*<=≤<=*n*, *i**k*<=+<=*j**k* is an odd number).

It is guaranteed that all the good pairs are distinct.",Output the answer for the problem.,"['3 2\n8 3 8\n1 2\n2 3\n', '3 2\n8 12 8\n1 2\n2 3\n']","['0\n', '2\n']",none,WRONG_ANSWER,"from fractions import gcd

def prfact(num, pr):
    c = 0
    for prime in pr:
        while num % prime == 0:
            c += 1
            num //= prime
        if num == 1:
            break
    if num == 1:
        return c
    else:
        return c + 1

sieve = [(i % 2 == 1) for i in range(31622)]
sieve[0] = sieve[1] = False
sieve[2] = True
for i in range(2, int(31622 ** .5) + 1):
    if not sieve[i]:
        continue
    for j in range(i * i, 31622):
        sieve[j] = False
pr = [i for i in range(31622) if sieve[i]]

line = input().split()
n = int(line[0])
m = int(line[1])

a = [int(num) for num in input().split()]
ans = 0
for i in range(m):
    line = input().split()
    ik = int(line[0]) - 1
    jk = int(line[1]) - 1
    g = gcd(a[ik], a[jk])
    a[ik] //= g
    a[jk] //= g
    ans += prfact(g, pr)

print(str(ans))","def gcd(x, y):

    while y:
        x, y = y, x % y
    return x

def max_operations(n, m, a, pairs):
    operations_count = 0
    
    while True:
        operation_performed = False
        
        for i, j in pairs:

            idx1, idx2 = i - 1, j - 1

            v = gcd(a[idx1], a[idx2])

            if v > 1:
                a[idx1] //= v
                a[idx2] //= v
                operations_count += 1
                operation_performed = True

        if not operation_performed:
            break
    
    return operations_count

input_data = input().strip().split('\n')
n, m = map(int, input_data[0].split())
a = list(map(int, input_data[1].split()))
pairs = [tuple(map(int, line.split())) for line in input_data[2:m+2]]

result = max_operations(n, m, a, pairs)
print(result)"
161,D,Distance in Tree,PROGRAMMING,"['dfs and similar', 'dp', 'trees']","A tree is a connected graph that doesn't contain any cycles.

The distance between two vertices of a tree is the length (in edges) of the shortest path between these vertices.

You are given a tree with *n* vertices and a positive number *k*. Find the number of distinct pairs of the vertices which have a distance of exactly *k* between them. Note that pairs (*v*, *u*) and (*u*, *v*) are considered to be the same pair.","The first line contains two integers *n* and *k* (1<=≤<=*n*<=≤<=50000, 1<=≤<=*k*<=≤<=500) — the number of vertices and the required distance between the vertices.

Next *n*<=-<=1 lines describe the edges as ""*a**i* *b**i*"" (without the quotes) (1<=≤<=*a**i*,<=*b**i*<=≤<=*n*, *a**i*<=≠<=*b**i*), where *a**i* and *b**i* are the vertices connected by the *i*-th edge. All given edges are different.","Print a single integer — the number of distinct pairs of the tree's vertices which have a distance of exactly *k* between them.

Please do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.","['5 2\n1 2\n2 3\n3 4\n2 5\n', '5 3\n1 2\n2 3\n3 4\n4 5\n']","['4\n', '2\n']","In the first sample the pairs of vertexes at distance 2 from each other are (1, 3), (1, 5), (3, 5) and (2, 4).",TIME_LIMIT_EXCEEDED,"n, k = map(int, input().split())

d=[[] for _ in range(50010)]
for i in range(n-1):
    a,b=map(int,input().split())
    d[a].append(b)
    d[b].append(a)

dp=[[0]*505 for _ in range(50010)]
ans=0

def dfs(root,fa):
    global ans
    dp[root][0]=1
    for i in range(len(d[root])):
        son=d[root][i]
        if son!=fa:
            dfs(son,root)
            for j in range(k):
                ans += dp[son][j] * dp[root][k - 1 - j]
            for j in range(1,k+1):
                dp[root][j] += dp[son][j - 1]

dfs(1,0)
print(ans)","from collections import defaultdict, deque
import sys

def count_pairs(n, k, edges):

    tree = defaultdict(list)
    
    for a, b in edges:
        tree[a].append(b)
        tree[b].append(a)

    def bfs(start):

        queue = deque([(start, 0)])
        visited = {start}
        distance_count = [0] * (k + 1)

        while queue:
            current, dist = queue.popleft()
            if dist <= k:
                distance_count[dist] += 1

            for neighbor in tree[current]:
                if neighbor not in visited:
                    visited.add(neighbor)
                    queue.append((neighbor, dist + 1))
        
        return distance_count

    total_pairs = 0

    for vertex in range(1, n + 1):
        distance_count = bfs(vertex)

        if k < len(distance_count):
            count_at_k = distance_count[k]
            total_pairs += count_at_k

    return total_pairs // 2

input_data = sys.stdin.read().strip().split('\n')
first_line = input_data[0].split()
n = int(first_line[0])
k = int(first_line[1])
edges = [tuple(map(int, line.split())) for line in input_data[1:]]

result = count_pairs(n, k, edges)

print(result)"
165,A,Supercentral Point,PROGRAMMING,['implementation'],"One day Vasya painted a Cartesian coordinate system on a piece of paper and marked some set of points (*x*1,<=*y*1),<=(*x*2,<=*y*2),<=...,<=(*x**n*,<=*y**n*). Let's define neighbors for some fixed point from the given set (*x*,<=*y*): 
 -  point (*x*',<=*y*') is (*x*,<=*y*)'s right neighbor, if *x*'<=&gt;<=*x* and *y*'<==<=*y* -  point (*x*',<=*y*') is (*x*,<=*y*)'s left neighbor, if *x*'<=&lt;<=*x* and *y*'<==<=*y* -  point (*x*',<=*y*') is (*x*,<=*y*)'s lower neighbor, if *x*'<==<=*x* and *y*'<=&lt;<=*y* -  point (*x*',<=*y*') is (*x*,<=*y*)'s upper neighbor, if *x*'<==<=*x* and *y*'<=&gt;<=*y* 
We'll consider point (*x*,<=*y*) from the given set supercentral, if it has at least one upper, at least one lower, at least one left and at least one right neighbor among this set's points.

Vasya marked quite many points on the paper. Analyzing the picture manually is rather a challenge, so Vasya asked you to help him. Your task is to find the number of supercentral points in the given set.","The first input line contains the only integer *n* (1<=≤<=*n*<=≤<=200) — the number of points in the given set. Next *n* lines contain the coordinates of the points written as ""*x* *y*"" (without the quotes) (|*x*|,<=|*y*|<=≤<=1000), all coordinates are integers. The numbers in the line are separated by exactly one space. It is guaranteed that all points are different.",Print the only number — the number of supercentral points of the given set.,"['8\n1 1\n4 2\n3 1\n1 2\n0 2\n0 1\n1 0\n1 3\n', '5\n0 0\n0 1\n1 0\n0 -1\n-1 0\n']","['2\n', '1\n']","In the first sample the supercentral points are only points (1, 1) and (1, 2).

In the second sample there is one supercental point — point (0, 0).",WRONG_ANSWER,"from sys import stdin,stdout

def main():

    t = 1
    for z in range(t):
        n = int(input())

        xyi = [list(map(int,input().split())) for i in range(n)]
        num = 10**7
        xs1 = [num]*2000
        ys1 = [num]*2000
        xs2 = [num]*2000
        ys2 = [num]*2000
        for i in range(n):
            xs1[xyi[i][0]] = min(xs1[xyi[i][0]],xyi[i][1])
            xs2[xyi[i][0]] = max(xs2[xyi[i][0]],xyi[i][1])
            ys1[xyi[i][1]] = min(ys1[xyi[i][1]],xyi[i][0])
            ys2[xyi[i][1]] = max(ys2[xyi[i][1]],xyi[i][0])
        ans = 0
        for i in range(n):
            x,y = xyi[i][0],xyi[i][1]
            x1,y1,x2,y2 = ys1[y],xs1[x],ys2[y],xs2[x]
            if x < x2 and x > x1 and y < y2 and y > y1:
                ans += 1

        print(ans)
main()","def is_supercentral_point(x, y, points_set):
    has_upper = has_lower = has_left = has_right = False
    
    for (px, py) in points_set:
        if px == x and py > y:
            has_upper = True
        if px == x and py < y:
            has_lower = True
        if py == y and px < x:
            has_left = True
        if py == y and px > x:
            has_right = True

        if has_upper and has_lower and has_left and has_right:
            return True
    
    return False

def count_supercentral_points(points):
    points_set = set(points)
    count = 0
    
    for (x, y) in points:
        if is_supercentral_point(x, y, points_set):
            count += 1

    return count

if __name__ == ""__main__"":
    import sys
    input = sys.stdin.read
    data = input().strip().split('\n')
    
    n = int(data[0])
    points = [tuple(map(int, line.split())) for line in data[1:n + 1]]

    result = count_supercentral_points(points)
    print(result)"
573,A,Bear and Poker,PROGRAMMING,"['implementation', 'math', 'number theory']","Limak is an old brown bear. He often plays poker with his friends. Today they went to a casino. There are *n* players (including Limak himself) and right now all of them have bids on the table. *i*-th of them has bid with size *a**i* dollars.

Each player can double his bid any number of times and triple his bid any number of times. The casino has a great jackpot for making all bids equal. Is it possible that Limak and his friends will win a jackpot?","First line of input contains an integer *n* (2<=≤<=*n*<=≤<=105), the number of players.

The second line contains *n* integer numbers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=109) — the bids of players.","Print ""Yes"" (without the quotes) if players can make their bids become equal, or ""No"" otherwise.","['4\n75 150 75 50\n', '3\n100 150 250\n']","['Yes\n', 'No\n']","In the first sample test first and third players should double their bids twice, second player should double his bid once and fourth player should both double and triple his bid.

It can be shown that in the second sample test there is no way to make all bids equal.",OK,"def euc(x, y):
	if y == 0: return x
	return euc(y, x%y)

def judge(x):
	m = x
	while m % 2 == 0:
		m //= 2
	while m % 3 == 0:
		m //= 3
	return m == 1

N = int(input())
A = list(map(int, input().split()))
A.sort()
ans = 'Yes'
for i in range(0, N-1):
	X = A[i]*A[N-1]//euc(A[i], A[N-1])
	if not judge(X//euc(A[i], A[N-1])):
		ans = 'No'
		break
print(ans)","def can_make_bids_equal(n, bids):

    def reduce_bid(bid):
        while bid % 2 == 0:
            bid //= 2
        while bid % 3 == 0:
            bid //= 3
        return bid

    reduced_bids = [reduce_bid(bid) for bid in bids]

    if all(bid == reduced_bids[0] for bid in reduced_bids):
        return ""Yes""
    else:
        return ""No""

n = int(input().strip())
bids = list(map(int, input().strip().split()))

result = can_make_bids_equal(n, bids)
print(result)"
169,A,Chores,PROGRAMMING,['sortings'],"Petya and Vasya are brothers. Today is a special day for them as their parents left them home alone and commissioned them to do *n* chores. Each chore is characterized by a single parameter — its complexity. The complexity of the *i*-th chore equals *h**i*.

As Petya is older, he wants to take the chores with complexity larger than some value *x* (*h**i*<=&gt;<=*x*) to leave to Vasya the chores with complexity less than or equal to *x* (*h**i*<=≤<=*x*). The brothers have already decided that Petya will do exactly *a* chores and Vasya will do exactly *b* chores (*a*<=+<=*b*<==<=*n*).

In how many ways can they choose an integer *x* so that Petya got exactly *a* chores and Vasya got exactly *b* chores?","The first input line contains three integers *n*,<=*a* and *b* (2<=≤<=*n*<=≤<=2000; *a*,<=*b*<=≥<=1; *a*<=+<=*b*<==<=*n*) — the total number of chores, the number of Petya's chores and the number of Vasya's chores.

The next line contains a sequence of integers *h*1,<=*h*2,<=...,<=*h**n* (1<=≤<=*h**i*<=≤<=109), *h**i* is the complexity of the *i*-th chore. The numbers in the given sequence are not necessarily different.

All numbers on the lines are separated by single spaces.","Print the required number of ways to choose an integer value of *x*. If there are no such ways, print 0.","['5 2 3\n6 2 3 100 1\n', '7 3 4\n1 1 9 1 1 1 1\n']","['3\n', '0\n']","In the first sample the possible values of *x* are 3, 4 or 5.

In the second sample it is impossible to find such *x*, that Petya got 3 chores and Vasya got 4.",RUNTIME_ERROR,"def chores(n,a,b,lis):
    lis = sort(n,lis)
    res = lis[a+1] - lis[a]
    print(res)
def sort(n,s):
    for i in range(0,n):
        for j in range(0,n):
            if(s[i] < s[j]):
                t = s[i]
                s[i] = s[j]
                s[j] = t
    return s
list1 = [int(i) for i in input().split()]
list2 = [int(i) for i in input().split()]
chores(list1[0],list1[1],list1[2],list2)","def count_ways(n, a, b, complexities):

    complexities.sort()

    ways = 0

    for i in range(n - 1):

        if complexities[i] < complexities[i + 1]:

            petya_count = n - (i + 1)

            vasya_count = i + 1

            if petya_count == a and vasya_count == b:
                ways += 1
    
    return ways

import sys
input = sys.stdin.read

def main():
    data = input().strip().split(""\n"")

    n, a, b = map(int, data[0].split())

    complexities = list(map(int, data[1].split()))

    result = count_ways(n, a, b, complexities)

    print(result)

if __name__ == ""__main__"":
    main()"
302,B,Eugeny and Play List,PROGRAMMING,"['binary search', 'implementation', 'two pointers']","Eugeny loves listening to music. He has *n* songs in his play list. We know that song number *i* has the duration of *t**i* minutes. Eugeny listens to each song, perhaps more than once. He listens to song number *i* *c**i* times. Eugeny's play list is organized as follows: first song number 1 plays *c*1 times, then song number 2 plays *c*2 times, ..., in the end the song number *n* plays *c**n* times.

Eugeny took a piece of paper and wrote out *m* moments of time when he liked a song. Now for each such moment he wants to know the number of the song that played at that moment. The moment *x* means that Eugeny wants to know which song was playing during the *x*-th minute of his listening to the play list.

Help Eugeny and calculate the required numbers of songs.","The first line contains two integers *n*, *m* (1<=≤<=*n*,<=*m*<=≤<=105). The next *n* lines contain pairs of integers. The *i*-th line contains integers *c**i*,<=*t**i* (1<=≤<=*c**i*,<=*t**i*<=≤<=109) — the description of the play list. It is guaranteed that the play list's total duration doesn't exceed 109 .

The next line contains *m* positive integers *v*1,<=*v*2,<=...,<=*v**m*, that describe the moments Eugeny has written out. It is guaranteed that there isn't such moment of time *v**i*, when the music doesn't play any longer. It is guaranteed that *v**i*<=&lt;<=*v**i*<=+<=1 (*i*<=&lt;<=*m*).

The moment of time *v**i* means that Eugeny wants to know which song was playing during the *v**i*-th munite from the start of listening to the playlist.",Print *m* integers — the *i*-th number must equal the number of the song that was playing during the *v**i*-th minute after Eugeny started listening to the play list.,"['1 2\n2 8\n1 16\n', '4 9\n1 2\n2 1\n1 1\n2 2\n1 2 3 4 5 6 7 8 9\n']","['1\n1\n', '1\n1\n2\n2\n3\n4\n4\n4\n4\n']",none,MEMORY_LIMIT_EXCEEDED,"def main():
    n, m = map(int, input().split())

    arr = []
    for i in range(n):
        c, t = map(int, input().split())
        arr = arr + [(i + 1)]* (c * t)

    for j in input().split():
        print(arr[int(j)-1])

if __name__ == '__main__':
    main()","n, m = map(int, input().split())

duration_endpoints = []
total_duration = 0

for i in range(n):
    ci, ti = map(int, input().split())
    total_duration += ci * ti
    duration_endpoints.append(total_duration)

moments = list(map(int, input().split()))

results = []

current_song = 0
for moment in moments:

    while current_song < n and moment > duration_endpoints[current_song]:
        current_song += 1

    results.append(current_song + 1)

print('\n'.join(map(str, results)))"
704,A,Thor,PROGRAMMING,"['brute force', 'data structures', 'implementation']","Thor is getting used to the Earth. As a gift Loki gave him a smartphone. There are *n* applications on this phone. Thor is fascinated by this phone. He has only one minor issue: he can't count the number of unread notifications generated by those applications (maybe Loki put a curse on it so he can't).

*q* events are about to happen (in chronological order). They are of three types:
 1.  Application *x* generates a notification (this new notification is unread). 1.  Thor reads all notifications generated so far by application *x* (he may re-read some notifications). 1.  Thor reads the first *t* notifications generated by phone applications (notifications generated in first *t* events of the first type). It's guaranteed that there were at least *t* events of the first type before this event. Please note that he doesn't read first *t* unread notifications, he just reads the very first *t* notifications generated on his phone and he may re-read some of them in this operation. 
Please help Thor and tell him the number of unread notifications after each event. You may assume that initially there are no notifications in the phone.","The first line of input contains two integers *n* and *q* (1<=≤<=*n*,<=*q*<=≤<=300<=000) — the number of applications and the number of events to happen.

The next *q* lines contain the events. The *i*-th of these lines starts with an integer *type**i* — type of the *i*-th event. If *type**i*<==<=1 or *type**i*<==<=2 then it is followed by an integer *x**i*. Otherwise it is followed by an integer *t**i* (1<=≤<=*type**i*<=≤<=3,<=1<=≤<=*x**i*<=≤<=*n*,<=1<=≤<=*t**i*<=≤<=*q*).",Print the number of unread notifications after each event.,"['3 4\n1 3\n1 1\n1 2\n2 3\n', '4 6\n1 2\n1 4\n1 2\n3 3\n1 3\n1 3\n']","['1\n2\n3\n2\n', '1\n2\n3\n0\n1\n2\n']","In the first sample:
 1.  Application 3 generates a notification (there is 1 unread notification). 1.  Application 1 generates a notification (there are 2 unread notifications). 1.  Application 2 generates a notification (there are 3 unread notifications). 1.  Thor reads the notification generated by application 3, there are 2 unread notifications left. 
In the second sample test:
 1.  Application 2 generates a notification (there is 1 unread notification). 1.  Application 4 generates a notification (there are 2 unread notifications). 1.  Application 2 generates a notification (there are 3 unread notifications). 1.  Thor reads first three notifications and since there are only three of them so far, there will be no unread notification left. 1.  Application 3 generates a notification (there is 1 unread notification). 1.  Application 3 generates a notification (there are 2 unread notifications).",WRONG_ANSWER,"from collections import defaultdict
n, q = map(int, input().split())
apps = defaultdict(list)
queue = []
num_unread = 0
num_read = 0
for _ in range(q):
    event_type, app_number = map(int, input().split())
    if event_type == 1:
        apps[app_number].append(False)
        queue.append([app_number, len(apps[app_number]) - 1])
        num_unread += 1
    elif event_type == 2:
        for i in range(len(apps[app_number])):
            unread = len(list(filter(lambda x: x == False, apps[app_number])))
            apps[app_number] = [True] * len(apps[app_number])
            num_unread -= unread
            num_read += unread
    elif event_type == 3:
        num_notifs_to_read = app_number
        for i in range(num_read - 1, num_notifs_to_read - num_read):
            app_num, idx = queue[i]
            if not apps[app_num][idx]:
                apps[app_num][idx] = True
                num_unread -= 1
                num_read += 1
    print(num_unread)","def process_notifications(test_cases):
    results = []

    for case in test_cases:
        data = case.strip().split('\n')
        n, q = map(int, data[0].split())
        
        notifications = []
        unread_count = 0
        output = []

        for i in range(1, q + 1):
            event = list(map(int, data[i].split()))
            event_type = event[0]

            if event_type == 1:
                x = event[1]
                notifications.append(x)
                unread_count += 1
            elif event_type == 2:
                x = event[1]
                unread_count -= notifications.count(x)
            elif event_type == 3:
                t = event[1]

                for j in range(t):
                    notifications[j] = None

                unread_count = sum(1 for n in notifications if n is not None)

            output.append(str(unread_count))

        results.append(""\n"".join(output))

    return results

input_data = ['3 4\n1 3\n1 1\n1 2\n2 3\n', '4 6\n1 2\n1 4\n1 2\n3 3\n1 3\n1 3\n']
results = process_notifications(input_data)

for result in results:
    print(result)"
715,B,Complete The Graph,PROGRAMMING,"['binary search', 'constructive algorithms', 'graphs', 'shortest paths']","ZS the Coder has drawn an undirected graph of *n* vertices numbered from 0 to *n*<=-<=1 and *m* edges between them. Each edge of the graph is weighted, each weight is a positive integer.

The next day, ZS the Coder realized that some of the weights were erased! So he wants to reassign positive integer weight to each of the edges which weights were erased, so that the length of the shortest path between vertices *s* and *t* in the resulting graph is exactly *L*. Can you help him?","The first line contains five integers *n*,<=*m*,<=*L*,<=*s*,<=*t* (2<=≤<=*n*<=≤<=1000,<=<=1<=≤<=*m*<=≤<=10<=000,<=<=1<=≤<=*L*<=≤<=109,<=<=0<=≤<=*s*,<=*t*<=≤<=*n*<=-<=1,<=<=*s*<=≠<=*t*) — the number of vertices, number of edges, the desired length of shortest path, starting vertex and ending vertex respectively.

Then, *m* lines describing the edges of the graph follow. *i*-th of them contains three integers, *u**i*,<=*v**i*,<=*w**i* (0<=≤<=*u**i*,<=*v**i*<=≤<=*n*<=-<=1,<=<=*u**i*<=≠<=*v**i*,<=<=0<=≤<=*w**i*<=≤<=109). *u**i* and *v**i* denote the endpoints of the edge and *w**i* denotes its weight. If *w**i* is equal to 0 then the weight of the corresponding edge was erased.

It is guaranteed that there is at most one edge between any pair of vertices.","Print ""NO"" (without quotes) in the only line if it's not possible to assign the weights in a required way.

Otherwise, print ""YES"" in the first line. Next *m* lines should contain the edges of the resulting graph, with weights assigned to edges which weights were erased. *i*-th of them should contain three integers *u**i*, *v**i* and *w**i*, denoting an edge between vertices *u**i* and *v**i* of weight *w**i*. The edges of the new graph must coincide with the ones in the graph from the input. The weights that were not erased must remain unchanged whereas the new weights can be any positive integer not exceeding 1018. 

The order of the edges in the output doesn't matter. The length of the shortest path between *s* and *t* must be equal to *L*.

If there are multiple solutions, print any of them.","['5 5 13 0 4\n0 1 5\n2 1 2\n3 2 3\n1 4 0\n4 3 4\n', '2 1 123456789 0 1\n0 1 0\n', '2 1 999999999 1 0\n0 1 1000000000\n']","['YES\n0 1 5\n2 1 2\n3 2 3\n1 4 8\n4 3 4\n', 'YES\n0 1 123456789\n', 'NO\n']","Here's how the graph in the first sample case looks like :

In the first sample case, there is only one missing edge weight. Placing the weight of 8 gives a shortest path from 0 to 4 of length 13.

In the second sample case, there is only a single edge. Clearly, the only way is to replace the missing weight with 123456789.

In the last sample case, there is no weights to assign but the length of the shortest path doesn't match the required value, so the answer is ""NO"".",OK,"import heapq
import random
import sys
from math import inf
from types import GeneratorType

RANDOM = random.randint(1, 10 ** 9)

class FastIO:
    def __init__(self):
        return

    @staticmethod
    def read_str():
        return sys.stdin.readline()

    def read_int(self):
        return int(self.read_str())

    def read_float(self):
        return float(self.read_str())

    def read_ints(self):
        return map(int, self.read_str().split())

    def read_floats(self):
        return map(float, self.read_str().split())

    def read_ints_minus_one(self):
        return map(lambda x: int(x) - 1, self.read_str().split())

    def read_list_ints(self):
        return list(map(int, self.read_str().split()))

    def read_list_floats(self):
        return list(map(float, self.read_str().split()))

    def read_list_ints_minus_one(self):
        return list(map(lambda x: int(x) - 1, self.read_str().split()))

    def read_list_strs(self):
        return self.read_str().split()

    def read_list_str(self):
        return list(self.read_str())

    @staticmethod
    def st(x):
        return print(x)

    @staticmethod
    def lst(x):
        return print(*x)

    @staticmethod
    def round_5(f):
        res = int(f)
        if f - res >= 0.5:
            res += 1
        return res

    @staticmethod
    def max(a, b):
        return a if a > b else b

    @staticmethod
    def min(a, b):
        return a if a < b else b

    @staticmethod
    def bootstrap(f, queue=[]):
        def wrappedfunc(*args, **kwargs):
            if queue:
                return f(*args, **kwargs)
            else:
                to = f(*args, **kwargs)
                while True:
                    if isinstance(to, GeneratorType):
                        queue.append(to)
                        to = next(to)
                    else:
                        queue.pop()
                        if not queue:
                            break
                        to = queue[-1].send(to)
                return to

        return wrappedfunc

    def ask(self, lst):
        self.lst(lst)
        sys.stdout.flush()
        res = self.read_int()
        return res

    @staticmethod
    def accumulate(nums):
        n = len(nums)
        pre = [0] * (n + 1)
        for i in range(n):
            pre[i + 1] = pre[i] + nums[i]
        return pre

class Wrapper(int):

    def __init__(self, x):
        int.__init__(x)

    def __hash__(self):

        return super(Wrapper, self).__hash__() ^ RANDOM

class Solution:
    def __init__(self):
        return

    @staticmethod
    def main(ac=FastIO()):
        n, m, target, source, destination = ac.read_ints()
        edges = []
        dct = [[] for _ in range(n)]
        book = [0] * m
        for ind in range(m):
            i, j, w = ac.read_list_ints()
            if w == 0:
                w = 1
                book[ind] = 1
            edges.append([i, j, w])
            dct[i].append([ind, j])
            dct[j].append([ind, i])

        dis0 = [inf] * n
        stack = [[0, source]]
        dis0[source] = 0
        while stack:
            d, i = heapq.heappop(stack)
            if dis0[i] < d:
                continue
            for ind, j in dct[i]:
                dj = edges[ind][2] + d
                if dj < dis0[j]:
                    dis0[j] = dj
                    heapq.heappush(stack, [dj, j])
        if dis0[destination] > target:
            ac.st(""NO"")
            return

        dis1 = [inf] * n
        stack = [[0, source]]
        dis1[source] = 0
        while stack:
            d, i = heapq.heappop(stack)
            if dis1[i] < d:
                continue
            for ind, j in dct[i]:
                if book[ind]:

                    if (edges[ind][2] + dis1[i]) + (dis0[destination] - dis0[j]) < target:

                        x = target - (edges[ind][2] + dis1[i]) - (dis0[destination] - dis0[j])
                        edges[ind][2] += x
                    book[ind] = 0
                dj = edges[ind][2] + d
                if dj < dis1[j]:
                    dis1[j] = dj
                    heapq.heappush(stack, [dj, j])

        if dis1[destination] == target:
            ac.st(""YES"")
            for e in edges:
                ac.lst(e)
        else:
            ac.st(""NO"")
        return

Solution().main()","import sys
import heapq

def dijkstra(start, n, graph):
    dist = [float('inf')] * n
    dist[start] = 0
    pq = [(0, start)]
    while pq:
        curr_dist, u = heapq.heappop(pq)
        if curr_dist > dist[u]:
            continue
        for weight, v in graph[u]:
            if curr_dist + weight < dist[v]:
                dist[v] = curr_dist + weight
                heapq.heappush(pq, (dist[v], v))
    return dist

def main():
    input_data = sys.stdin.read().strip().splitlines()

    n, m, L, s, t = map(int, input_data[0].split())
    edges = []
    graph = [[] for _ in range(n)]
    
    for i in range(1, m + 1):
        u, v, w = map(int, input_data[i].split())
        edges.append((u, v, w))
        if w > 0:
            graph[u].append((w, v))
            graph[v].append((w, u))

    dist_from_s = dijkstra(s, n, graph)
    dist_from_t = dijkstra(t, n, graph)

    current_dist = dist_from_s[t]

    if current_dist > L:
        print(""NO"")
        return

    needed_weight = L - current_dist

    results = []
    for u, v, w in edges:
        if w > 0:
            results.append(f""{u} {v} {w}"")
        else:

            results.append(f""{u} {v} {needed_weight + 1}"")
            needed_weight = 0

    if current_dist + 1 + (needed_weight - 1) > L:
        print(""NO"")
    else:
        print(""YES"")
        print(""\n"".join(results))

if __name__ == ""__main__"":
    main()"
58,A,Chat room,PROGRAMMING,"['greedy', 'strings']","Vasya has recently learned to type and log on to the Internet. He immediately entered a chat room and decided to say hello to everybody. Vasya typed the word *s*. It is considered that Vasya managed to say hello if several letters can be deleted from the typed word so that it resulted in the word ""hello"". For example, if Vasya types the word ""ahhellllloou"", it will be considered that he said hello, and if he types ""hlelo"", it will be considered that Vasya got misunderstood and he didn't manage to say hello. Determine whether Vasya managed to say hello by the given word *s*.","The first and only line contains the word *s*, which Vasya typed. This word consisits of small Latin letters, its length is no less that 1 and no more than 100 letters.","If Vasya managed to say hello, print ""YES"", otherwise print ""NO"".","['ahhellllloou\n', 'hlelo\n']","['YES\n', 'NO\n']",none,RUNTIME_ERROR,"def checkHello(str1):
    if len(str1)<=5:
        print(""NO"")
    else:
        str2 = ""helloo""
        j = 0
        for i in str1:
            if i == str2[j] and j<=5:
                j+=1
        if j >= 4:
            print(""YES"")
        else:
            print(""NO"")
    
str1 = input()
checkHello(str1)","def can_say_hello(s):

    target = ""hello""
    target_index = 0

    for char in s:

        if char == target[target_index]:
            target_index += 1

        if target_index == len(target):
            return ""YES""

    return ""NO""

s = input().strip()

print(can_say_hello(s))"
0,none,none,none,['none'],"Polycarp has interviewed Oleg and has written the interview down without punctuation marks and spaces to save time. Thus, the interview is now a string *s* consisting of *n* lowercase English letters.

There is a filler word ogo in Oleg's speech. All words that can be obtained from ogo by adding go several times to the end of it are also considered to be fillers. For example, the words ogo, ogogo, ogogogo are fillers, but the words go, og, ogog, ogogog and oggo are not fillers.

The fillers have maximal size, for example, for ogogoo speech we can't consider ogo a filler and goo as a normal phrase. We should consider ogogo as a filler here.

To print the interview, Polycarp has to replace each of the fillers with three asterisks. Note that a filler word is replaced with exactly three asterisks regardless of its length.

Polycarp has dealt with this problem in no time. Can you do the same? The clock is ticking!","The first line contains a positive integer *n* (1<=≤<=*n*<=≤<=100) — the length of the interview.

The second line contains the string *s* of length *n*, consisting of lowercase English letters.","Print the interview text after the replacement of each of the fillers with ""***"". It is allowed for the substring ""***"" to have several consecutive occurences.","['7\naogogob\n', '13\nogogmgogogogo\n', '9\nogoogoogo\n']","['a***b\n', '***gmg***\n', '*********\n']","The first sample contains one filler word ogogo, so the interview for printing is ""a***b"".

The second sample contains two fillers ogo and ogogogo. Thus, the interview is transformed to ""***gmg***"".",OK,"import re
def solve(s):
  return re.sub(r'ogo(?:go)*','***',s)
      

def main() :
  n = input()
  s = input()

  print(solve(s))
main()","def replace_fillers(n, s):

    filler = ""ogo""
    filler_length = len(filler)

    result = """"
    i = 0

    while i < n:

        if s[i:i + filler_length] == filler:

            j = i + filler_length
            while j < n and s[j:j + 2] == ""go"":
                j += 2

            result += ""***""
            i = j
        else:

            result += s[i]
            i += 1

    return result

n = int(input())
s = input().strip()

output = replace_fillers(n, s)

print(output)"
991,B,Getting an A,PROGRAMMING,"['greedy', 'sortings']","Translator's note: in Russia's most widespread grading system, there are four grades: 5, 4, 3, 2, the higher the better, roughly corresponding to A, B, C and F respectively in American grading system.

The term is coming to an end and students start thinking about their grades. Today, a professor told his students that the grades for his course would be given out automatically  — he would calculate the simple average (arithmetic mean) of all grades given out for lab works this term and round to the nearest integer. The rounding would be done in favour of the student — $4.5$ would be rounded up to $5$ (as in example 3), but $4.4$ would be rounded down to $4$.

This does not bode well for Vasya who didn't think those lab works would influence anything, so he may receive a grade worse than $5$ (maybe even the dreaded $2$). However, the professor allowed him to redo some of his works of Vasya's choosing to increase his average grade. Vasya wants to redo as as few lab works as possible in order to get $5$ for the course. Of course, Vasya will get $5$ for the lab works he chooses to redo.

Help Vasya — calculate the minimum amount of lab works Vasya has to redo.","The first line contains a single integer $n$ — the number of Vasya's grades ($1 \leq n \leq 100$).

The second line contains $n$ integers from $2$ to $5$ — Vasya's grades for his lab works.",Output a single integer — the minimum amount of lab works that Vasya has to redo. It can be shown that Vasya can always redo enough lab works to get a $5$.,"['3\n4 4 4\n', '4\n5 4 5 5\n', '4\n5 3 3 5\n']","['2\n', '0\n', '1\n']","In the first sample, it is enough to redo two lab works to make two $4$s into $5$s.

In the second sample, Vasya's average is already $4.75$ so he doesn't have to redo anything to get a $5$.

In the second sample Vasya has to redo one lab work to get rid of one of the $3$s, that will make the average exactly $4.5$ so the final grade would be $5$.",OK,"from sys import *

def main():
    n = int(stdin.readline())
    target = 4.5*n
    currentTotal = 0
    minimumRetakes = 0
    listOfScores = [int(x) for x in stdin.readline().split()]
    for x in listOfScores:
        currentTotal+=x
    listOfScores.sort()
    while(currentTotal < target):
        currentTotal+=(5-listOfScores[minimumRetakes])
        minimumRetakes += 1
    print(minimumRetakes)

if __name__ == '__main__':
    main()","import math

def min_redos_to_get_five(n, grades):
    current_sum = sum(grades)
    target_sum = 5 * n

    if current_sum >= 4.5 * n:
        return 0

    grades_to_improve = sorted([g for g in grades if g < 5], reverse=True)
    
    redos = 0

    for grade in grades_to_improve:
        current_sum += 5 - grade
        redos += 1

        if current_sum >= 4.5 * (n + redos):
            return redos

n = int(input())
grades = list(map(int, input().split()))

print(min_redos_to_get_five(n, grades))"
722,A,Broken Clock,PROGRAMMING,"['brute force', 'implementation']","You are given a broken clock. You know, that it is supposed to show time in 12- or 24-hours HH:MM format. In 12-hours format hours change from 1 to 12, while in 24-hours it changes from 0 to 23. In both formats minutes change from 0 to 59.

You are given a time in format HH:MM that is currently displayed on the broken clock. Your goal is to change minimum number of digits in order to make clocks display the correct time in the given format.

For example, if 00:99 is displayed, it is enough to replace the second 9 with 3 in order to get 00:39 that is a correct time in 24-hours format. However, to make 00:99 correct in 12-hours format, one has to change at least two digits. Additionally to the first change one can replace the second 0 with 1 and obtain 01:39.","The first line of the input contains one integer 12 or 24, that denote 12-hours or 24-hours format respectively.

The second line contains the time in format HH:MM, that is currently displayed on the clock. First two characters stand for the hours, while next two show the minutes.",The only line of the output should contain the time in format HH:MM that is a correct time in the given format. It should differ from the original in as few positions as possible. If there are many optimal solutions you can print any of them.,"['24\n17:30\n', '12\n17:30\n', '24\n99:99\n']","['17:30\n', '07:30\n', '09:09\n']",none,WRONG_ANSWER,"def getHour(num, horas, minutos):

    dezHoras = int(horas[0])
    uniHoras = int(horas[1])

    dezMin = int(minutos[0])
    uniMin = int(minutos[1])

    qtdHoras = 10 * int(dezHoras) + int(uniHoras)
    qtdMin = 10 * int(dezMin) + int(uniMin)

    if(num == 24 and qtdHoras > 23):
        dezHoras = 0

    if(num == 12 and qtdHoras > 12):
        if(uniHoras != 0):
            dezHoras = 0
        else:
            dezHoras = 1

    elif(num == 12 and horas == 0):
        dezHoras = 1

    if(qtdMin > 59):
        dezMin = 0

    return ""{}{}:{}{}"".format(dezHoras, uniHoras, dezMin, uniMin)

num = int(input())
entrada = input().split("":"")

horas = entrada[0]
minutos = entrada[1]

print(getHour(num, horas, minutos))","def is_valid_time_12(h, m):
    return 1 <= h <= 12 and 0 <= m < 60

def is_valid_time_24(h, m):
    return 0 <= h < 24 and 0 <= m < 60

def find_best_time(format_type, current_time):
    hh, mm = current_time.split(':')
    hh = list(hh)
    mm = list(mm)

    best_time = None
    min_changes = float('inf')

    for h in range(12 if format_type == 12 else 24):
        for m in range(60):
            hh_str = f""{h:02}""
            mm_str = f""{m:02}""
            valid_time = hh_str + ':' + mm_str

            changes = sum(1 for a, b in zip(hh + mm, hh_str + mm_str) if a != b)

            if changes < min_changes:
                min_changes = changes
                best_time = valid_time

    return best_time

format_type = int(input())
current_time = input().strip()

best_time = find_best_time(format_type, current_time)
print(best_time)"
653,A,Bear and Three Balls,PROGRAMMING,"['brute force', 'implementation', 'sortings']","Limak is a little polar bear. He has *n* balls, the *i*-th ball has size *t**i*.

Limak wants to give one ball to each of his three friends. Giving gifts isn't easy — there are two rules Limak must obey to make friends happy:
 -  No two friends can get balls of the same size. -  No two friends can get balls of sizes that differ by more than 2. 
For example, Limak can choose balls with sizes 4, 5 and 3, or balls with sizes 90, 91 and 92. But he can't choose balls with sizes 5, 5 and 6 (two friends would get balls of the same size), and he can't choose balls with sizes 30, 31 and 33 (because sizes 30 and 33 differ by more than 2).

Your task is to check whether Limak can choose three balls that satisfy conditions above.","The first line of the input contains one integer *n* (3<=≤<=*n*<=≤<=50) — the number of balls Limak has.

The second line contains *n* integers *t*1,<=*t*2,<=...,<=*t**n* (1<=≤<=*t**i*<=≤<=1000) where *t**i* denotes the size of the *i*-th ball.","Print ""YES"" (without quotes) if Limak can choose three balls of distinct sizes, such that any two of them differ by no more than 2. Otherwise, print ""NO"" (without quotes).","['4\n18 55 16 17\n', '6\n40 41 43 44 44 44\n', '8\n5 972 3 4 1 4 970 971\n']","['YES\n', 'NO\n', 'YES\n']","In the first sample, there are 4 balls and Limak is able to choose three of them to satisfy the rules. He must must choose balls with sizes 18, 16 and 17.

In the second sample, there is no way to give gifts to three friends without breaking the rules.

In the third sample, there is even more than one way to choose balls:
 1.  Choose balls with sizes 3, 4 and 5. 1.  Choose balls with sizes 972, 970, 971.",OK,"import sys

len_input = input()
seq_input = input().split()

seq = sorted([int(x) for x in seq_input])
seq_red = sorted([int(x) for x in list(set(seq))])

if len(seq_red) < 3:
	print('NO')
	sys.exit()

seq_sub = [seq_red[i] - seq_red[i+2] for i in range(len(seq_red)-2)]
seq_truth = [1  if abs(x) < 3 else 0 for x in seq_sub]
seq_sum = sum(seq_truth)
if seq_sum == 0:
	print('NO')
elif seq_sum > 0:
	print('YES')","n = int(input())

sizes = list(map(int, input().split()))

unique_sizes = sorted(set(sizes))

if len(unique_sizes) < 3:
    print(""NO"")
else:

    for i in range(len(unique_sizes) - 2):

        if unique_sizes[i + 2] - unique_sizes[i] <= 2:
            print(""YES"")
            break
    else:
        print(""NO"")"
382,C,Arithmetic Progression,PROGRAMMING,"['implementation', 'sortings']","Everybody knows what an arithmetic progression is. Let us remind you just in case that an arithmetic progression is such sequence of numbers *a*1,<=*a*2,<=...,<=*a**n* of length *n*, that the following condition fulfills: 

For example, sequences [1, 5], [10], [5, 4, 3] are arithmetic progressions and sequences [1, 3, 2], [1, 2, 4] are not.

Alexander has *n* cards containing integers. Arthur wants to give Alexander exactly one more card with a number so that he could use the resulting *n*<=+<=1 cards to make an arithmetic progression (Alexander has to use all of his cards).

Arthur has already bought a card but he hasn't written a number on it. Help him, print all integers that you can write on a card so that the described condition fulfilled.","The first line contains integer *n* (1<=≤<=*n*<=≤<=105) — the number of cards. The next line contains the sequence of integers — the numbers on Alexander's cards. The numbers are positive integers, each of them doesn't exceed 108.","If Arthur can write infinitely many distinct integers on the card, print on a single line -1.

Otherwise, print on the first line the number of integers that suit you. In the second line, print the numbers in the increasing order. Note that the numbers in the answer can exceed 108 or even be negative (see test samples).","['3\n4 1 7\n', '1\n10\n', '4\n1 3 5 9\n', '4\n4 3 4 5\n', '2\n2 4\n']","['2\n-2 10\n', '-1\n', '1\n7\n', '0\n', '3\n0 3 6\n']",none,WRONG_ANSWER,"n = int(input())
list_numbers = list(map(int,input().split()))
list_numbers.sort()
def ap(list_numbers,n):
    if n == 1:
        return -1
    if n == 2:
        if (list_numbers[0] + list_numbers[1])%2 == 0:
            x = int((list_numbers[0] + list_numbers[1])/2)
            y = list_numbers[1] -  list_numbers[0]
            print(3)
            print( str(x) + "" ""+ str(list_numbers[0] - y) + "" "" + str(list_numbers[1] + y ))
        else :
            y = list_numbers[1] - list_numbers[0]
            print(2)

            print( str(list_numbers[0] - y) + "" "" + str(list_numbers[1] + y))
    i = 0
    i_to_use = 0
    previous_num = 0

    difference = "" ""
    difference_2 = "" ""
    if n > 2:
        if list_numbers[2] - list_numbers[1] < list_numbers[1] - list_numbers[0] :
            list_numbers.reverse()
            for j in list_numbers:
                if i == 0:
                    previous_num = j
                    i += 1
                else:
                    if difference == "" "":
                        difference = j - previous_num
                        previous_num = j
                        i += 1
                    else:
                        if difference != j - previous_num:
                            if difference_2 == "" "":
                                difference_2 = j - previous_num
                                i_to_use = i
                                i += 1

                                continue
                            else:
                                if difference_2 != j - previous_num:
                                    print(0)
                                    break
                                else:
                                    i += 1
                                    continue
            if difference_2 == "" "":
                print(2)
                print(str(list_numbers[0] - difference) + "" "" + str(list_numbers[1] + difference))
            else:
                if difference_2 * 2 == difference:
                    print(1)
                    print(list_numbers[i_to_use - 1] + difference_2)
                else:
                    print(0)

        else :
            for j in list_numbers :
                if i == 0:
                    previous_num = j
                    i +=1
                else :
                    if difference == "" "":
                        difference = j - previous_num
                        previous_num = j
                        i += 1
                    else :
                        if difference != j - previous_num :
                            if difference_2 == "" "":
                                difference_2 = j - previous_num
                                i_to_use = i
                                i += 1

                                continue
                            else :
                                if difference_2 != j - previous_num :
                                    print(0)
                                    break
                                else :
                                    i += 1
                                    continue
                        else :
                            previous_num = j
                            i +=1
            if difference_2 == "" "":
                print(2)
                print(str(list_numbers[0] - difference) + "" "" + str(list_numbers[-1] + difference))
            else :
                if difference_2  == difference *2 :
                    print(1)
                    print(list_numbers[i_to_use-1] + difference)
                else:
                    print(0)
ap(list_numbers,n)","def find_possible_numbers(n, cards):
    cards.sort()
    diff_set = set()

    for i in range(1, n):
        diff = cards[i] - cards[i - 1]
        diff_set.add(diff)

    if len(diff_set) == 1:
        return -1

    differences = sorted(diff_set)
    possible_numbers = set()

    if len(differences) == 2:
        d1, d2 = differences
        if (d2 - d1) % 2 == 0:
            mid_value = cards[0] + (d2 - d1) // 2
            possible_numbers.add(mid_value)

    possible_numbers.add(cards[0] - differences[0])
    possible_numbers.add(cards[-1] + differences[-1])

    valid_numbers = sorted(x for x in possible_numbers if x > 0 and (x in cards or len(cards) == 1))

    return valid_numbers

n = int(input())
cards = list(map(int, input().split()))

results = find_possible_numbers(n, cards)

if results == -1:
    print(""-1"")
else:
    print(len(results))
    if results:
        print("" "".join(map(str, results)))"
743,E,Vladik and cards,PROGRAMMING,"['binary search', 'bitmasks', 'brute force', 'dp']","Vladik was bored on his way home and decided to play the following game. He took *n* cards and put them in a row in front of himself. Every card has a positive integer number not exceeding 8 written on it. He decided to find the longest subsequence of cards which satisfies the following conditions:
 -  the number of occurrences of each number from 1 to 8 in the subsequence doesn't differ by more then 1 from the number of occurrences of any other number. Formally, if there are *c**k* cards with number *k* on them in the subsequence, than for all pairs of integers  the condition |*c**i*<=-<=*c**j*|<=≤<=1 must hold. -  if there is at least one card with number *x* on it in the subsequence, then all cards with number *x* in this subsequence must form a continuous segment in it (but not necessarily a continuous segment in the original sequence). For example, the subsequence [1,<=1,<=2,<=2] satisfies this condition while the subsequence [1,<=2,<=2,<=1] doesn't. Note that [1,<=1,<=2,<=2] doesn't satisfy the first condition. 
Please help Vladik to find the length of the longest subsequence that satisfies both conditions.","The first line contains single integer *n* (1<=≤<=*n*<=≤<=1000) — the number of cards in Vladik's sequence.

The second line contains the sequence of *n* positive integers not exceeding 8 — the description of Vladik's sequence.",Print single integer — the length of the longest subsequence of Vladik's sequence that satisfies both conditions.,"['3\n1 1 1\n', '8\n8 7 6 5 4 3 2 1\n', '24\n1 8 1 2 8 2 3 8 3 4 8 4 5 8 5 6 8 6 7 8 7 8 8 8\n']","['1', '8', '17']","In the first sample all the numbers written on the cards are equal, so you can't take more than one card, otherwise you'll violate the first condition.",OK,"import bisect
import sys, os, io
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

def f(u, v):
    return (m + 1) * u + v

n = int(input())
a = list(map(int, input().split()))
m = 8
x = [[] for _ in range(m)]
for i in range(n):
    x[a[i] - 1].append(i)
s = 0
for y in x:
    s += min(len(y), 1)
if s < m:
    ans = s
    print(ans)
    exit()
pow2 = [1]
for _ in range(m):
    pow2.append(2 * pow2[-1])
pm = pow2[m]
inf = pow(10, 9) + 1
ans = 8
ok = 1
for c in range(1, n // 8 + 3):
    dp = [inf] * ((m + 1) * pm)
    dp[0] = -1
    for i in range(pm):
        for j in range(m):
            u = f(i, j)
            if dp[u] == inf:
                break
            dpu = dp[u]
            for k in range(m):
                if i & pow2[k]:
                    continue
                l = i ^ pow2[k]
                xk = x[k]
                z = bisect.bisect_left(xk, dpu) + c
                for y in range(2):
                    if y + z - 1 < len(xk):
                        v = f(l, j + y)
                        dp[v] = min(dp[v], xk[y + z - 1])
    for i in range(1, m + 1):
        if dp[f(pm - 1, i)] == inf:
            ok = 0
            break
        ans += 1
    if not ok:
        break
print(ans)","def longest_valid_subsequence(n, cards):
    count = [0] * 9
    for card in cards:
        count[card] += 1

    max_len = 0
    for i in range(1, 9):
        if count[i] == 0:
            continue

        current_len = 0
        is_valid = True
        for j in range(1, 9):
            if count[j] > 0:
                current_len += count[j]
                if abs(count[j] - count[i]) > 1:
                    is_valid = False
                    break
        
        if is_valid:
            max_len = max(max_len, current_len)
    
    return max_len

n = int(input())
cards = list(map(int, input().split()))

print(longest_valid_subsequence(n, cards))"
402,C,Searching for Graph,PROGRAMMING,"['brute force', 'constructive algorithms', 'graphs']","Let's call an undirected graph of *n* vertices *p*-interesting, if the following conditions fulfill: 
 -  the graph contains exactly 2*n*<=+<=*p* edges; -  the graph doesn't contain self-loops and multiple edges; -  for any integer *k* (1<=≤<=*k*<=≤<=*n*), any subgraph consisting of *k* vertices contains at most 2*k*<=+<=*p* edges. 
A subgraph of a graph is some set of the graph vertices and some set of the graph edges. At that, the set of edges must meet the condition: both ends of each edge from the set must belong to the chosen set of vertices. 

Your task is to find a *p*-interesting graph consisting of *n* vertices.","The first line contains a single integer *t* (1<=≤<=*t*<=≤<=5) — the number of tests in the input. Next *t* lines each contains two space-separated integers: *n*, *p* (5<=≤<=*n*<=≤<=24; *p*<=≥<=0; ) — the number of vertices in the graph and the interest value for the appropriate test. 

It is guaranteed that the required graph exists.","For each of the *t* tests print 2*n*<=+<=*p* lines containing the description of the edges of a *p*-interesting graph: the *i*-th line must contain two space-separated integers *a**i*,<=*b**i* (1<=≤<=*a**i*,<=*b**i*<=≤<=*n*; *a**i*<=≠<=*b**i*) — two vertices, connected by an edge in the resulting graph. Consider the graph vertices numbered with integers from 1 to *n*. 

Print the answers to the tests in the order the tests occur in the input. If there are multiple solutions, you can print any of them.",['1\n6 0\n'],['1 2\n1 3\n1 4\n1 5\n1 6\n2 3\n2 4\n2 5\n2 6\n3 4\n3 5\n3 6\n'],none,OK,"def construct(n, p):
    
    for i in range (2*n + p):
        pos = i % n  

        cycle = (i // n) + 1 

        neighbor = (pos + cycle) % n

        print(pos+1, neighbor+1)

for _ in range(int(input())):
    n, p = [int(x) for x in input().split()]
    construct(n,p)","def generate_p_interesting_graph(t, test_cases):
    results = []
    
    for n, p in test_cases:
        edges = []

        for i in range(1, n + 1):
            for j in range(i + 1, n + 1):
                if len(edges) < 2 * n + p:
                    edges.append((i, j))

        results.append(edges)
    
    return results

def print_graph(edges):
    for a, b in edges:
        print(f""{a} {b}"")

t = int(input())
test_cases = [tuple(map(int, input().split())) for _ in range(t)]

for edges in generate_p_interesting_graph(t, test_cases):
    print_graph(edges)"
182,E,Wooden Fence,PROGRAMMING,['dp'],"Vasya has recently bought some land and decided to surround it with a wooden fence.

He went to a company called ""Wooden board"" that produces wooden boards for fences. Vasya read in the catalog of products that the company has at its disposal *n* different types of wood. The company uses the *i*-th type of wood to produce a board of this type that is a rectangular *a**i* by *b**i* block.

Vasya decided to order boards in this company and build a fence from them. It turned out that the storehouse of the company is so large that Vasya can order arbitrary number of boards of every type. Note that Vasya is allowed to turn the boards as he builds the fence. However, Vasya cannot turn square boards.

Vasya is required to construct a fence of length *l*, however, an arbitrary fence won't do. Vasya wants his fence to look beautiful. We'll say that a fence is beautiful if and only if the following two conditions are fulfilled:
 -  there are no two successive boards of the same type -  the first board of the fence has an arbitrary length, and the length of each subsequent board equals the width of the previous one 
In other words, the fence is considered beautiful, if the type of the *i*-th board in the fence is different from the *i*<=-<=1-th board's type; besides, the *i*-th board's length is equal to the *i*<=-<=1-th board's width (for all *i*, starting from 2).

Now Vasya wonders, how many variants of arranging a fence for his land exist. Your task is to count the number of different beautiful fences of length *l*.

Two fences will be considered the same if the corresponding sequences of fence boards types and rotations are the same, otherwise the fences are different. Since the sought number can be large enough, you need to calculate the answer modulo 1000000007 (109<=+<=7).","The first line contains two integers *n* and *l* (1<=≤<=*n*<=≤<=100,<=1<=≤<=*l*<=≤<=3000) — the number of different board types and the fence length, correspondingly. Next *n* lines contain descriptions of board types: the *i*-th line contains two integers *a**i* and *b**i* (1<=≤<=*a**i*,<=*b**i*<=≤<=100) — the sizes of the board of the *i*-th type. All numbers on the lines are separated by spaces.",Print a single integer — the sought number of variants modulo 1000000007 (109<=+<=7).,"['2 3\n1 2\n2 3\n', '1 2\n2 2\n', '6 6\n2 1\n3 2\n2 5\n3 3\n5 1\n2 1\n']","['2\n', '1\n', '20\n']","In the first sample there are exactly two variants of arranging a beautiful fence of length 3: 
 -  As the first fence board use the board of the first type of length 1 and width 2. As the second board use board of the second type of length 2 and width 3. -  Use one board of the second type after you turn it. That makes its length equal 3, and width — 2.",OK,"import sys, os, io
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline

def f(u, v):
    return 2 * n * u + v

n, l = map(int, input().split())
mod = pow(10, 9) + 7
a, b = [], []
for _ in range(n):
    a0, b0 = map(int, input().split())
    a.append(a0)
    b.append(b0)
    if a0 == b0:
        a0, b0 = l + 1, l + 1
    a.append(b0)
    b.append(a0)
G = [[] for _ in range(2 * n)]
for i in range(2 * n):
    for j in range(2 * n):
        if i // 2 == j // 2:
            continue
        if b[i] == a[j]:
            G[i].append(j)
m = 2 * n * (l + 1)
dp = [0] * m
for i in range(2 * n):
    if a[i] <= l:
        dp[f(a[i], i)] = 1
for i in range(1, l):
    for j in range(2 * n):
        u = f(i, j)
        if not dp[u]:
            continue
        for k in G[j]:
            if i + a[k] <= l:
                dp[f(i + a[k], k)] += dp[u]
                dp[f(i + a[k], k)] %= mod
ans = 0
for i in range(2 * n):
    ans += dp[f(l, i)]
ans %= mod
print(ans)","MOD = 1000000007

def count_beautiful_fences(n, l, boards):

    dp = [[0] * n for _ in range(l + 1)]

    for i in range(n):
        dp[boards[i][0]][i] += 1
        if boards[i][0] != boards[i][1]:
            dp[boards[i][1]][i] += 1

    for length in range(2, l + 1):
        for last_type in range(n):
            last_width = boards[last_type][1]
            for current_type in range(n):
                if current_type != last_type:
                    if last_width <= boards[current_type][0]:
                        dp[length][current_type] = (dp[length][current_type] + dp[length - last_width][last_type]) % MOD
                    if last_width <= boards[current_type][1] and boards[current_type][0] != boards[current_type][1]:
                        dp[length][current_type] = (dp[length][current_type] + dp[length - last_width][last_type]) % MOD

    result = sum(dp[l]) % MOD
    return result

def main():
    import sys
    input = sys.stdin.read
    data = input().splitlines()

    n, l = map(int, data[0].split())
    boards = [tuple(map(int, data[i + 1].split())) for i in range(n)]
    
    result = count_beautiful_fences(n, l, boards)
    print(result)

if __name__ == ""__main__"":
    main()"
855,B,Marvolo Gaunt's Ring,PROGRAMMING,"['brute force', 'data structures', 'dp']","Professor Dumbledore is helping Harry destroy the Horcruxes. He went to Gaunt Shack as he suspected a Horcrux to be present there. He saw Marvolo Gaunt's Ring and identified it as a Horcrux. Although he destroyed it, he is still affected by its curse. Professor Snape is helping Dumbledore remove the curse. For this, he wants to give Dumbledore exactly *x* drops of the potion he made. 

Value of *x* is calculated as maximum of *p*·*a**i*<=+<=*q*·*a**j*<=+<=*r*·*a**k* for given *p*,<=*q*,<=*r* and array *a*1,<=*a*2,<=... *a**n* such that 1<=≤<=*i*<=≤<=*j*<=≤<=*k*<=≤<=*n*. Help Snape find the value of *x*. Do note that the value of *x* may be negative.","First line of input contains 4 integers *n*,<=*p*,<=*q*,<=*r* (<=-<=109<=≤<=*p*,<=*q*,<=*r*<=≤<=109,<=1<=≤<=*n*<=≤<=105).

Next line of input contains *n* space separated integers *a*1,<=*a*2,<=... *a**n* (<=-<=109<=≤<=*a**i*<=≤<=109).",Output a single integer the maximum value of *p*·*a**i*<=+<=*q*·*a**j*<=+<=*r*·*a**k* that can be obtained provided 1<=≤<=*i*<=≤<=*j*<=≤<=*k*<=≤<=*n*.,"['5 1 2 3\n1 2 3 4 5\n', '5 1 2 -3\n-1 -2 -3 -4 -5\n']","['30\n', '12\n']","In the first sample case, we can take *i* = *j* = *k* = 5, thus making the answer as 1·5 + 2·5 + 3·5 = 30.

In second sample case, selecting *i* = *j* = 1 and *k* = 5 gives the answer 12.",OK,"def main():
    n, p, q, r = map(int, input().split())
    a = list(map(int, input().split()))
    ans = -float('inf')
    mx = -float('inf')
    mx1 = -float('inf')
    for i in range(n):
        mx = max(mx, a[i] * p)
        mx1 = max(mx1, mx + a[i] * q)
        ans = max(ans, mx1 + a[i] * r)
    print(ans)

if __name__ == '__main__':
    main()","def max_horcrux_drops(n, p, q, r, a):

    max_p = [0] * n
    max_p[0] = p * a[0]

    for i in range(1, n):
        max_p[i] = max(max_p[i - 1], p * a[i])

    max_q = [0] * n
    max_q[0] = max_p[0] + q * a[0]

    for j in range(1, n):
        max_q[j] = max(max_q[j - 1], max_p[j] + q * a[j])

    max_x = float('-inf')

    for k in range(n):
        max_x = max(max_x, max_q[k] + r * a[k])

    return max_x

n, p, q, r = map(int, input().split())
a = list(map(int, input().split()))

result = max_horcrux_drops(n, p, q, r, a)
print(result)"
122,A,Lucky Division,PROGRAMMING,"['brute force', 'number theory']","Petya loves lucky numbers. Everybody knows that lucky numbers are positive integers whose decimal representation contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.

Petya calls a number almost lucky if it could be evenly divided by some lucky number. Help him find out if the given number *n* is almost lucky.",The single line contains an integer *n* (1<=≤<=*n*<=≤<=1000) — the number that needs to be checked.,"In the only line print ""YES"" (without the quotes), if number *n* is almost lucky. Otherwise, print ""NO"" (without the quotes).","['47\n', '16\n', '78\n']","['YES\n', 'YES\n', 'NO\n']","Note that all lucky numbers are almost lucky as any number is evenly divisible by itself.

In the first sample 47 is a lucky number. In the second sample 16 is divisible by 4.",RUNTIME_ERROR,"solve()

def checkLucky(y):
    x=str(y)
    flag=True
    luckyDigits=['4','7']
    for char in x:
        if char not in luckyDigits:
            return False
    return True

def solve():
    x = input()
    y = int(x)
    flag = checkLucky(y)
    if(flag):
        print(""YES"")
    else:
        for i in range(4,y//2):
            if checkLucky(i) and (y%i==0):
                print(""YES"")
        print(""NO"")","def is_lucky(n):

    return all(ch in '47' for ch in str(n))

def is_almost_lucky(n):

    for lucky in range(4, n + 1):
        if is_lucky(lucky) and n % lucky == 0:
            return True
    return False

def main():

    n = int(input().strip())

    if is_almost_lucky(n):
        print(""YES"")
    else:
        print(""NO"")

if __name__ == ""__main__"":
    main()"
0,none,none,none,['none'],"Today on a lecture about strings Gerald learned a new definition of string equivalency. Two strings *a* and *b* of equal length are called equivalent in one of the two cases: 
 1.  They are equal. 1.  If we split string *a* into two halves of the same size *a*1 and *a*2, and string *b* into two halves of the same size *b*1 and *b*2, then one of the following is correct:   *a*1 is equivalent to *b*1, and *a*2 is equivalent to *b*2 1.  *a*1 is equivalent to *b*2, and *a*2 is equivalent to *b*1 
As a home task, the teacher gave two strings to his students and asked to determine if they are equivalent.

Gerald has already completed this home task. Now it's your turn!",The first two lines of the input contain two strings given by the teacher. Each of them has the length from 1 to 200<=000 and consists of lowercase English letters. The strings have the same length.,"Print ""YES"" (without the quotes), if these two strings are equivalent, and ""NO"" (without the quotes) otherwise.","['aaba\nabaa\n', 'aabb\nabab\n']","['YES\n', 'NO\n']","In the first sample you should split the first string into strings ""aa"" and ""ba"", the second one — into strings ""ab"" and ""aa"". ""aa"" is equivalent to ""aa""; ""ab"" is equivalent to ""ba"" as ""ab"" = ""a"" + ""b"", ""ba"" = ""b"" + ""a"".

In the second sample the first string can be splitted into strings ""aa"" and ""bb"", that are equivalent only to themselves. That's why string ""aabb"" is equivalent only to itself and to string ""bbaa"".",WRONG_ANSWER,"def solve(s,t):
    if len(s)!=len(t):
        return False
    elif s==t:
        return True
    elif len(s)%2 and len(t)%2:
        return False
    else:
        g,f=s[:len(s)//2],s[len(s)//2:]
        x,y=t[:len(t)//2],t[len(t)//2:]
        if f==x and g==y:
            return True
        elif f==x:
            return solve(g,y)
        elif g==y:
            return solve(f,x)
        else:
            return solve(g,y) and solve(f,x)
s=input()
t=input()
if solve(s,t):
    print(""YES"")
else:
    print(""NO"")","def are_equivalent(a, b):

    if a == b:
        return True

    if len(a) % 2 == 1:
        return False

    mid = len(a) // 2
    a1, a2 = a[:mid], a[mid:]
    b1, b2 = b[:mid], b[mid:]

    return (are_equivalent(a1, b1) and are_equivalent(a2, b2)) or \
           (are_equivalent(a1, b2) and are_equivalent(a2, b1))

string1 = input().strip()
string2 = input().strip()

if are_equivalent(string1, string2):
    print(""YES"")
else:
    print(""NO"")"
230,B,T-primes,PROGRAMMING,"['binary search', 'implementation', 'math', 'number theory']","We know that prime numbers are positive integers that have exactly two distinct positive divisors. Similarly, we'll call a positive integer *t* Т-prime, if *t* has exactly three distinct positive divisors.

You are given an array of *n* positive integers. For each of them determine whether it is Т-prime or not.","The first line contains a single positive integer, *n* (1<=≤<=*n*<=≤<=105), showing how many numbers are in the array. The next line contains *n* space-separated integers *x**i* (1<=≤<=*x**i*<=≤<=1012).

Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is advised to use the cin, cout streams or the %I64d specifier.","Print *n* lines: the *i*-th line should contain ""YES"" (without the quotes), if number *x**i* is Т-prime, and ""NO"" (without the quotes), if it isn't.",['3\n4 5 6\n'],['YES\nNO\nNO\n'],"The given test has three numbers. The first number 4 has exactly three divisors — 1, 2 and 4, thus the answer for this number is ""YES"". The second number 5 has two divisors (1 and 5), and the third number 6 has four divisors (1, 2, 3, 6), hence the answer for them is ""NO"".",TIME_LIMIT_EXCEEDED,"import copy
import math

def isprime_slow(n):
    if n < 2:
        return False
    elif n == 2 or n == 3:
        return True
    elif n % 2 == 0:
        return False
    else:
        i = 3
        while i * i <= n:
            if n % i == 0:
                return False
            i += 2
    return True

def v(q, t):
    ans = 0
    while t % q == 0:
        ans += 1
        t //= q
    return ans

def prime_factorize(n):
    ret = []
    p = 2
    while p * p <= n:
        if n % p == 0:
            num = 0
            while n % p == 0:
                num += 1
                n //= p
            ret.append((p, num))
        p += 1
    if n != 1:
        ret.append((n, 1))
    return ret

def e(t):
    s = 1
    q_list = []
    for q in range(2, t + 2):
        if t % (q - 1) == 0 and isprime_slow(q):
            s *= q ** (1 + v(q, t))
            q_list.append(q)
    return 2 * s, q_list

class JacobiSum(object):
    def __init__(self, p, k, q):
        self.p = p
        self.k = k
        self.q = q
        self.m = (p - 1) * p ** (k - 1)
        self.pk = p**k
        self.coef = [0] * self.m

    def one(self):
        self.coef[0] = 1
        for i in range(1, self.m):
            self.coef[i] = 0
        return self

    def mul(self, jac):
        m = self.m
        pk = self.pk
        j_ret = JacobiSum(self.p, self.k, self.q)
        for i in range(m):
            for j in range(m):
                if (i + j) % pk < m:
                    j_ret.coef[(i + j) % pk] += self.coef[i] * jac.coef[j]
                else:
                    r = (i + j) % pk - self.p ** (self.k - 1)
                    while r >= 0:
                        j_ret.coef[r] -= self.coef[i] * jac.coef[j]
                        r -= self.p ** (self.k - 1)
        return j_ret

    def __mul__(self, right):
        if type(right) is int:
            j_ret = JacobiSum(self.p, self.k, self.q)
            for i in range(self.m):
                j_ret.coef[i] = self.coef[i] * right
            return j_ret
        else:
            return self.mul(right)

    def modpow(self, x, n):
        j_ret = JacobiSum(self.p, self.k, self.q)
        j_ret.coef[0] = 1
        j_a = copy.deepcopy(self)
        while x > 0:
            if x % 2 == 1:
                j_ret = (j_ret * j_a).mod(n)
            j_a = j_a * j_a
            j_a.mod(n)
            x //= 2
        return j_ret

    def mod(self, n):
        for i in range(self.m):
            self.coef[i] %= n
        return self

    def sigma(self, x):
        m = self.m
        pk = self.pk
        j_ret = JacobiSum(self.p, self.k, self.q)
        for i in range(m):
            if (i * x) % pk < m:
                j_ret.coef[(i * x) % pk] += self.coef[i]
            else:
                r = (i * x) % pk - self.p ** (self.k - 1)
                while r >= 0:
                    j_ret.coef[r] -= self.coef[i]
                    r -= self.p ** (self.k - 1)
        return j_ret

    def sigma_inv(self, x):
        m = self.m
        pk = self.pk
        j_ret = JacobiSum(self.p, self.k, self.q)
        for i in range(pk):
            if i < m:
                if (i * x) % pk < m:
                    j_ret.coef[i] += self.coef[(i * x) % pk]
            else:
                r = i - self.p ** (self.k - 1)
                while r >= 0:
                    if (i * x) % pk < m:
                        j_ret.coef[r] -= self.coef[(i * x) % pk]
                    r -= self.p ** (self.k - 1)

        return j_ret

    def is_root_of_unity(self, N):
        m = self.m
        p = self.p
        k = self.k
        one = 0
        for i in range(m):
            if self.coef[i] == 1:
                one += 1
                h = i
            elif self.coef[i] == 0:
                continue
            elif (self.coef[i] - (-1)) % N != 0:
                return False, None
        if one == 1:
            return True, h
        for i in range(m):
            if self.coef[i] != 0:
                break
        r = i % (p ** (k - 1))
        for i in range(m):
            if i % (p ** (k - 1)) == r:
                if (self.coef[i] - (-1)) % N != 0:
                    return False, None
            else:
                if self.coef[i] != 0:
                    return False, None
        return True, (p - 1) * p ** (k - 1) + r

def smallest_primitive_root(q):
    for r in range(2, q):
        s = set({})
        m = 1
        for i in range(1, q):
            m = (m * r) % q
            s.add(m)
        if len(s) == q - 1:
            return r
    return None

def calc_f(q):
    g = smallest_primitive_root(q)
    m = {}
    for x in range(1, q - 1):
        m[pow(g, x, q)] = x
    f = {}
    for x in range(1, q - 1):
        f[x] = m[(1 - pow(g, x, q)) % q]

    return f

def calc_J_ab(p, k, q, a, b):
    j_ret = JacobiSum(p, k, q)
    f = calc_f(q)
    for x in range(1, q - 1):
        pk = p**k
        if (a * x + b * f[x]) % pk < j_ret.m:
            j_ret.coef[(a * x + b * f[x]) % pk] += 1
        else:
            r = (a * x + b * f[x]) % pk - p ** (k - 1)
            while r >= 0:
                j_ret.coef[r] -= 1
                r -= p ** (k - 1)
    return j_ret

def calc_J(p, k, q):
    return calc_J_ab(p, k, q, 1, 1)

def calc_J3(p, k, q):
    j2q = calc_J(p, k, q)
    j21 = calc_J_ab(p, k, q, 2, 1)
    j_ret = j2q * j21
    return j_ret

def calc_J2(p, k, q):
    j31 = calc_J_ab(2, 3, q, 3, 1)
    j_conv = JacobiSum(p, k, q)
    for i in range(j31.m):
        j_conv.coef[i * (p**k) // 8] = j31.coef[i]
    j_ret = j_conv * j_conv
    return j_ret

def APRtest_step4a(p, k, q, N):
    J = calc_J(p, k, q)
    s1 = JacobiSum(p, k, q).one()
    for x in range(p**k):
        if x % p == 0:
            continue
        t = J.sigma_inv(x)
        t = t.modpow(x, N)
        s1 = s1 * t
        s1.mod(N)
    r = N % (p**k)
    s2 = s1.modpow(N // (p**k), N)
    J_alpha = JacobiSum(p, k, q).one()
    for x in range(p**k):
        if x % p == 0:
            continue
        t = J.sigma_inv(x)
        t = t.modpow((r * x) // (p**k), N)
        J_alpha = J_alpha * t
        J_alpha.mod(N)
    S = (s2 * J_alpha).mod(N)
    exist, h = S.is_root_of_unity(N)
    if not exist:
        return False, None
    else:
        if h % p != 0:
            l_p = 1
        else:
            l_p = 0
        return True, l_p

def APRtest_step4b(p, k, q, N):
    J = calc_J3(p, k, q)
    s1 = JacobiSum(p, k, q).one()
    for x in range(p**k):
        if x % 8 not in [1, 3]:
            continue
        t = J.sigma_inv(x)
        t = t.modpow(x, N)
        s1 = s1 * t
        s1.mod(N)
    r = N % (p**k)
    s2 = s1.modpow(N // (p**k), N)
    J_alpha = JacobiSum(p, k, q).one()
    for x in range(p**k):
        if x % 8 not in [1, 3]:
            continue
        t = J.sigma_inv(x)
        t = t.modpow((r * x) // (p**k), N)
        J_alpha = J_alpha * t
        J_alpha.mod(N)
    if N % 8 in [1, 3]:
        S = (s2 * J_alpha).mod(N)
    else:
        J2_delta = calc_J2(p, k, q)
        S = (s2 * J_alpha * J2_delta).mod(N)
    exist, h = S.is_root_of_unity(N)

    if not exist:
        return False, None
    else:
        if h % p != 0 and (pow(q, (N - 1) // 2, N) + 1) % N == 0:
            l_p = 1
        else:
            l_p = 0
        return True, l_p

def APRtest_step4c(p, k, q, N):
    J2q = calc_J(p, k, q)
    s1 = (J2q * J2q * q).mod(N)
    s2 = s1.modpow(N // 4, N)
    if N % 4 == 1:
        S = s2
    elif N % 4 == 3:
        S = (s2 * J2q * J2q).mod(N)
    exist, h = S.is_root_of_unity(N)
    if not exist:
        return False, None
    else:
        if h % p != 0 and (pow(q, (N - 1) // 2, N) + 1) % N == 0:
            l_p = 1
        else:
            l_p = 0
        return True, l_p

def APRtest_step4d(p, k, q, N):
    S2q = pow(-q, (N - 1) // 2, N)
    if (S2q - 1) % N != 0 and (S2q + 1) % N != 0:
        return False, None
    else:
        if (S2q + 1) % N == 0 and (N - 1) % 4 == 0:
            l_p = 1
        else:
            l_p = 0
        return True, l_p

def APRtest_step4(p, k, q, N):
    if p >= 3:
        result, l_p = APRtest_step4a(p, k, q, N)
    elif p == 2 and k >= 3:
        result, l_p = APRtest_step4b(p, k, q, N)
    elif p == 2 and k == 2:
        result, l_p = APRtest_step4c(p, k, q, N)
    elif p == 2 and k == 1:
        result, l_p = APRtest_step4d(p, k, q, N)
    return result, l_p

def APRtest(N):
    t_list = [
        2,
        12,
        60,
        180,
        840,
        1260,
        1680,
        2520,
        5040,
        15120,
        55440,
        110880,
        720720,
        1441440,
        4324320,
        24504480,
        73513440,
    ]
    if N <= 3:
        return False
    for t in t_list:
        et, q_list = e(t)
        if N < et * et:
            break
    else:
        return False
    g = math.gcd(t * et, N)
    if g > 1:
        return False
    l = {}
    fac_t = prime_factorize(t)
    for p, k in fac_t:
        if p >= 3 and pow(N, p - 1, p * p) != 1:
            l[p] = 1
        else:
            l[p] = 0
    for q in q_list:
        if q == 2:
            continue
        fac = prime_factorize(q - 1)
        for p, k in fac:
            result, l_p = APRtest_step4(p, k, q, N)
            if not result:
                return False
            elif l_p == 1:
                l[p] = 1
    for p, value in l.items():
        if value == 0:
            count = 0
            i = 1
            found = False
            while count < 30:
                q = p * i + 1
                if N % q != 0 and isprime_slow(q) and (q not in q_list):
                    count += 1
                    k = v(p, q - 1)
                    result, l_p = APRtest_step4(p, k, q, N)
                    if not result:
                        return False
                    elif l_p == 1:
                        found = True
                        break
                i += 1
            if not found:
                return False
    r = 1
    for t in range(t - 1):
        r = (r * N) % et
        if r != 1 and r != N and N % r == 0:
            return False
    return True

bsid = int(input())
chnd = list(map(int, input().split()))
for sgrv in chnd:
    if math.sqrt(sgrv).is_integer():
        fxbi = int(math.sqrt(sgrv))
        if APRtest(fxbi) or fxbi == 2 or fxbi == 3:
            print(""YES"")
        else:
            print(""NO"")
    else:
        print(""NO"")","import sys
import math

def is_t_prime(num):

    root = int(math.isqrt(num))
    if root * root != num:
        return False

    if root < 2:
        return False
    for i in range(2, int(math.sqrt(root)) + 1):
        if root % i == 0:
            return False
    return True

n = int(sys.stdin.readline().strip())

numbers = list(map(int, sys.stdin.readline().strip().split()))

results = []
for number in numbers:
    if is_t_prime(number):
        results.append(""YES"")
    else:
        results.append(""NO"")

print(""\n"".join(results))"
729,A,Interview with Oleg,PROGRAMMING,"['implementation', 'strings']","Polycarp has interviewed Oleg and has written the interview down without punctuation marks and spaces to save time. Thus, the interview is now a string *s* consisting of *n* lowercase English letters.

There is a filler word ogo in Oleg's speech. All words that can be obtained from ogo by adding go several times to the end of it are also considered to be fillers. For example, the words ogo, ogogo, ogogogo are fillers, but the words go, og, ogog, ogogog and oggo are not fillers.

The fillers have maximal size, for example, for ogogoo speech we can't consider ogo a filler and goo as a normal phrase. We should consider ogogo as a filler here.

To print the interview, Polycarp has to replace each of the fillers with three asterisks. Note that a filler word is replaced with exactly three asterisks regardless of its length.

Polycarp has dealt with this problem in no time. Can you do the same? The clock is ticking!","The first line contains a positive integer *n* (1<=≤<=*n*<=≤<=100) — the length of the interview.

The second line contains the string *s* of length *n*, consisting of lowercase English letters.","Print the interview text after the replacement of each of the fillers with ""***"". It is allowed for the substring ""***"" to have several consecutive occurences.","['7\naogogob\n', '13\nogogmgogogogo\n', '9\nogoogoogo\n']","['a***b\n', '***gmg***\n', '*********\n']","The first sample contains one filler word ogogo, so the interview for printing is ""a***b"".

The second sample contains two fillers ogo and ogogogo. Thus, the interview is transformed to ""***gmg***"".",OK,"import sys, io, os
import math
import bisect
import heapq
import string
from collections import defaultdict,Counter,deque
input = sys.stdin.readline
 
def I():
    return input()
 
def II():
    return int(input())
 
def MII():
    return map(int, input().split())
 
def LI():
    return list(input().split())
 
def LII():
    return list(map(int, input().split()))
 
def GMI():
    return map(lambda x: int(x) - 1, input().split())
 
def LGMI():
    return list(map(lambda x: int(x) - 1, input().split()))
 
def WRITE(out):
  return print('\n'.join(map(str, out)))
 
def WS(out):
  return print(' '.join(map(str, out)))
 
def WNS(out):
  return print(''.join(map(str, out)))

'''
n%4 == 0 and all_cnts <= n//4
'''

def solve():
  n = II()
  s = I().strip()
  ans = []

  l = 0
  while l < n:

    if l+2 < n and s[l:l+3] == 'ogo':
      l += 3
      for i in range(l, n-1, 2):
        if s[i:i+2] == 'go':
          l = i+2
        else:
          break
      ans.append('***')
    else:
      ans.append(s[l])
      l += 1
  WNS(ans)

solve()","def replace_fillers(n, s):

    filler = 'ogo'
    filler_len = len(filler)

    result = ''
    i = 0
    
    while i < n:

        if s[i:i + filler_len] == filler:

            result += '***'

            while i < n and s[i:i + filler_len] == filler:
                i += filler_len

        else:

            result += s[i]
            i += 1
    
    return result

n = int(input())
s = input().strip()

result = replace_fillers(n, s)

print(result)"
839,C,Journey,PROGRAMMING,"['dfs and similar', 'dp', 'graphs', 'probabilities', 'trees']","There are *n* cities and *n*<=-<=1 roads in the Seven Kingdoms, each road connects two cities and we can reach any city from any other by the roads.

Theon and Yara Greyjoy are on a horse in the first city, they are starting traveling through the roads. But the weather is foggy, so they can’t see where the horse brings them. When the horse reaches a city (including the first one), it goes to one of the cities connected to the current city. But it is a strange horse, it only goes to cities in which they weren't before. In each such city, the horse goes with equal probabilities and it stops when there are no such cities. 

Let the length of each road be 1. The journey starts in the city 1. What is the expected length (expected value of length) of their journey? You can read about expected (average) value by the link [https://en.wikipedia.org/wiki/Expected_value](https://en.wikipedia.org/wiki/Expected_value).","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=100000) — number of cities.

Then *n*<=-<=1 lines follow. The *i*-th line of these lines contains two integers *u**i* and *v**i* (1<=≤<=*u**i*,<=*v**i*<=≤<=*n*, *u**i*<=≠<=*v**i*) — the cities connected by the *i*-th road.

It is guaranteed that one can reach any city from any other by the roads.","Print a number — the expected length of their journey. The journey starts in the city 1.

Your answer will be considered correct if its absolute or relative error does not exceed 10<=-<=6.

Namely: let's assume that your answer is *a*, and the answer of the jury is *b*. The checker program will consider your answer correct, if .","['4\n1 2\n1 3\n2 4\n', '5\n1 2\n1 3\n3 4\n2 5\n']","['1.500000000000000\n', '2.000000000000000\n']","In the first sample, their journey may end in cities 3 or 4 with equal probability. The distance to city 3 is 1 and to city 4 is 2, so the expected length is 1.5.

In the second sample, their journey may end in city 4 or 5. The distance to the both cities is 2, so the expected length is 2.",RUNTIME_ERROR,"nodes_cnt = int(input())
neighbors_of = [set() for _ in range(nodes_cnt)]

for _ in range(nodes_cnt - 1):
    c1, c2 = map(int, input().split())
    c1 -= 1
    c2 -= 1
    neighbors_of[c1].add(c2)
    neighbors_of[c2].add(c1)

total_distance = 0
total_path_cnt = 0

def dfs(node, cur_len, prev):
    if len(neighbors_of[node]) == 1 and prev in neighbors_of[node]:
        global total_distance, total_path_cnt
        total_distance += cur_len
        total_path_cnt += 1
    for child in neighbors_of[node]:
        if child == prev:   continue
        dfs(child, cur_len + 1, node)

dfs(0, 0, None)
print(total_distance / total_path_cnt)","def expected_length(n, roads):
    from collections import defaultdict

    graph = defaultdict(list)
    for u, v in roads:
        graph[u].append(v)
        graph[v].append(u)

    expected = [0] * (n + 1)
    visited = [False] * (n + 1)

    def dfs(city, prev):
        visited[city] = True
        num_neighbors = 0
        total_length = 0

        for neighbor in graph[city]:
            if not visited[neighbor]:
                num_neighbors += 1
                total_length += dfs(neighbor, city) + 1

        if num_neighbors > 0:
            expected[city] = total_length / num_neighbors
        return expected[city]

    dfs(1, -1)

    return expected[1]

import sys
input = sys.stdin.read
data = input().splitlines()

n = int(data[0])
roads = [tuple(map(int, line.split())) for line in data[1:n]]

result = expected_length(n, roads)
print(f""{result:.12f}"")"
449,A,Jzzhu and Chocolate,PROGRAMMING,"['greedy', 'math']","Jzzhu has a big rectangular chocolate bar that consists of *n*<=×<=*m* unit squares. He wants to cut this bar exactly *k* times. Each cut must meet the following requirements:
 -  each cut should be straight (horizontal or vertical); -  each cut should go along edges of unit squares (it is prohibited to divide any unit chocolate square with cut); -  each cut should go inside the whole chocolate bar, and all cuts must be distinct. 
The picture below shows a possible way to cut a 5<=×<=6 chocolate for 5 times.

Imagine Jzzhu have made *k* cuts and the big chocolate is splitted into several pieces. Consider the smallest (by area) piece of the chocolate, Jzzhu wants this piece to be as large as possible. What is the maximum possible area of smallest piece he can get with exactly *k* cuts? The area of a chocolate piece is the number of unit squares in it.","A single line contains three integers *n*,<=*m*,<=*k* (1<=≤<=*n*,<=*m*<=≤<=109; 1<=≤<=*k*<=≤<=2·109).","Output a single integer representing the answer. If it is impossible to cut the big chocolate *k* times, print -1.","['3 4 1\n', '6 4 2\n', '2 3 4\n']","['6\n', '8\n', '-1\n']","In the first sample, Jzzhu can cut the chocolate following the picture below:

In the second sample the optimal division looks like this:

In the third sample, it's impossible to cut a 2 × 3 chocolate 4 times.",COMPILATION_ERROR,"using namespace std;

ll mod= 998244353;
ll N = 252000;
ll inf = 1e18;
 

void divisors(int n,vector<int> &v)
{
    for(int i=1;i<=sqrt(n);i++)
    {
        if(i!=n/i&&n%i==0) {v.push_back(i);v.push_back(n/i);}
        else v.push_back(i);
    }

}

signed main()
 {

fasterio

    freopen(""error.txt"", ""w"", stderr);
    freopen(""input.txt"", ""r"", stdin);
    freopen(""output.txt"", ""w"", stdout);

int a,b,c;
vector<int> arra;
vector<int> arrb;
cin>>a>>b>>c;

divisors(a,arra);
divisors(b,arrb);
arra.push_back(0);
arrb.push_back(0);
sort(arra.begin(),arra.end());
sort(arrb.begin(),arrb.end());

auto x=lower_bound(arra.begin(),arra.end(),c)-arra.begin();
auto y=lower_bound(arrb.begin(),arrb.end(),c)-arrb.begin();

//cout<<x<<y<<endl;
int maxc=0;
int ind1=-1;
int ind2=-1;
int z=0;
for(int i=x;i>=0;i--)
{
    if(arra[i]>c) continue;
    else
    {
        
        z=lower_bound(arrb.begin(),arrb.end(),c-arra[i])-arrb.begin();

        if(abs(arrb[z]-arra[i])>maxc&&z!=arrb.size()+1)
        {
            maxc=abs(arrb[z]-arra[i]);
            ind1=i;
            ind2=z;
        }

    }

}

if(ind1==-1||ind2==-1||ind1==arra.size()||ind2==arrb.size()) cout<<-1<<endl;
else

cout<<a*b/((arra[ind1]+1)*(arrb[ind2]+1))<<endl;

}","def max_min_area(n, m, k):

    if k >= n + m - 2:
        return -1

    for horizontal_cuts in range(min(k, n - 1) + 1):
        vertical_cuts = k - horizontal_cuts
        if vertical_cuts < 0 or vertical_cuts >= m:
            continue

        pieces_h = horizontal_cuts + 1
        pieces_v = vertical_cuts + 1
        area = (n // pieces_h) * (m // pieces_v)

        if 'max_area' not in locals() or area > max_area:
            max_area = area
            
    return max_area if 'max_area' in locals() else -1

test_cases = [(3, 4, 1), (6, 4, 2), (2, 3, 4)]
results = []

for n, m, k in test_cases:
    results.append(max_min_area(n, m, k))

print(results)"
730,H,Delete Them,PROGRAMMING,"['constructive algorithms', 'implementation']","Polycarp is a beginner programmer. He is studying how to use a command line.

Polycarp faced the following problem. There are *n* files in a directory and he needs to delete some of them. Polycarp wants to run a single delete command with filename pattern as an argument. All the files to be deleted should match the pattern and all other files shouldn't match the pattern.

Polycarp doesn't know about an asterisk '*', the only special character he knows is a question mark '?' which matches any single character. All other characters in the pattern match themselves only.

Formally, a pattern matches a filename if and only if they have equal lengths and all characters in the corresponding positions are equal except when the character in the pattern is '?', in which case the corresponding filename character does not matter.

For example, the filename pattern ""a?ba?"":
 -  matches filenames ""aabaa"", ""abba."", ""a.ba9"" and ""a.ba.""; -  does not match filenames ""aaba"", ""abaab"", ""aabaaa"" and ""aabaa."". 
Help Polycarp find a pattern which matches files to be deleted and only them or report if there is no such pattern.","The first line of the input contains two integers *n* and *m* (1<=≤<=*m*<=≤<=*n*<=≤<=100) — the total number of files and the number of files to be deleted.

The following *n* lines contain filenames, single filename per line. All filenames are non-empty strings containing only lowercase English letters, digits and dots ('.'). The length of each filename doesn't exceed 100. It is guaranteed that all filenames are distinct.

The last line of the input contains *m* distinct integer numbers in ascending order *a*1,<=*a*2,<=...,<=*a**m* (1<=≤<=*a**i*<=≤<=*n*) — indices of files to be deleted. All files are indexed from 1 to *n* in order of their appearance in the input.","If the required pattern exists, print ""Yes"" in the first line of the output. The second line should contain the required pattern. If there are multiple solutions, print any of them.

If the required pattern doesn't exist, print the only line containing ""No"".","['3 2\nab\nac\ncd\n1 2\n', '5 3\ntest\ntezt\ntest.\n.est\ntes.\n1 4 5\n', '4 4\na\nb\nc\ndd\n1 2 3 4\n', '6 3\n.svn\n.git\n....\n...\n..\n.\n1 2 3\n']","['Yes\na?\n', 'Yes\n?es?\n', 'No\n', 'Yes\n.???\n']",none,WRONG_ANSWER,"def gpn(sf,ss):

	if len(sf)!=len(ss):
		return 0,None,None
	n=len(sf)
	ts,b,tsl='',0,[]
	for c in range(n):
		if sf[c]==ss[c]:
			b=1
			ts+=sf[c]
			tsl.append(c)
		else:
			ts+='?'
	return b,ts,tsl

def gpnts(s,ts,tsl):

	ntsl=[]
	for c in tsl:
		if s[c]==ts[c]:
			ntsl.append(c)
		else:
			ts=ts[:c]
			ts+='?'
			ts+=ts[c+1:]
	return len(ntsl),ts,ntsl

def hsp(vs,sn):
	lsn=len(sn)
	if lsn==1:
		return 1,vs[sn[0]]
	b,ts,tsl=gpn(vs[sn[0]],vs[sn[1]])

	if b==0:
		return 0,None
	for c in range(2,lsn):
		b,ts,tsl=gpnts(vs[sn[c]],ts,tsl)
		if b==0:
			return 0,None
	return 1,ts

n,k=[int(x) for x in input().split(' ')]
vs=[]
for c in range(n):
	vs.append(input())
sn=[int(x)-1 for x in input().split(' ')]
b,ts=hsp(vs,sn)
if b:
	print('Yes')
	print(ts)
else:
	print('No')","def find_pattern(n, m, filenames, to_delete_indices):

    to_delete = [filenames[i - 1] for i in to_delete_indices]

    length = len(to_delete[0])
    for filename in to_delete:
        if len(filename) != length:
            return ""No""

    pattern = []
    for i in range(length):

        current_char = to_delete[0][i]
        for filename in to_delete[1:]:
            if filename[i] != current_char:
                pattern.append('?')
                break
        else:
            pattern.append(current_char)

    return ""Yes\n"" + ''.join(pattern)

import sys
input_data = sys.stdin.read().strip().split('\n')
n, m = map(int, input_data[0].split())
filenames = [input_data[i + 1] for i in range(n)]
to_delete_indices = list(map(int, input_data[n + 1].split()))

result = find_pattern(n, m, filenames, to_delete_indices)
print(result)"
332,B,Maximum Absurdity,PROGRAMMING,"['data structures', 'dp', 'implementation']","Reforms continue entering Berland. For example, during yesterday sitting the Berland Parliament approved as much as *n* laws (each law has been assigned a unique number from 1 to *n*). Today all these laws were put on the table of the President of Berland, G.W. Boosch, to be signed.

This time mr. Boosch plans to sign 2*k* laws. He decided to choose exactly two non-intersecting segments of integers from 1 to *n* of length *k* and sign all laws, whose numbers fall into these segments. More formally, mr. Boosch is going to choose two integers *a*, *b* (1<=≤<=*a*<=≤<=*b*<=≤<=*n*<=-<=*k*<=+<=1,<=*b*<=-<=*a*<=≥<=*k*) and sign all laws with numbers lying in the segments [*a*; *a*<=+<=*k*<=-<=1] and [*b*; *b*<=+<=*k*<=-<=1] (borders are included).

As mr. Boosch chooses the laws to sign, he of course considers the public opinion. Allberland Public Opinion Study Centre (APOSC) conducted opinion polls among the citizens, processed the results into a report and gave it to the president. The report contains the absurdity value for each law, in the public opinion. As mr. Boosch is a real patriot, he is keen on signing the laws with the maximum total absurdity. Help him.","The first line contains two integers *n* and *k* (2<=≤<=*n*<=≤<=2·105, 0<=&lt;<=2*k*<=≤<=*n*) — the number of laws accepted by the parliament and the length of one segment in the law list, correspondingly. The next line contains *n* integers *x*1,<=*x*2,<=...,<=*x**n* — the absurdity of each law (1<=≤<=*x**i*<=≤<=109).","Print two integers *a*, *b* — the beginning of segments that mr. Boosch should choose. That means that the president signs laws with numbers from segments [*a*; *a*<=+<=*k*<=-<=1] and [*b*; *b*<=+<=*k*<=-<=1]. If there are multiple solutions, print the one with the minimum number *a*. If there still are multiple solutions, print the one with the minimum *b*.","['5 2\n3 6 1 1 6\n', '6 2\n1 1 1 1 1 1\n']","['1 4\n', '1 3\n']","In the first sample mr. Boosch signs laws with numbers from segments [1;2] and [4;5]. The total absurdity of the signed laws equals 3 + 6 + 1 + 6 = 16.

In the second sample mr. Boosch signs laws with numbers from segments [1;2] and [3;4]. The total absurdity of the signed laws equals 1 + 1 + 1 + 1 = 4.",WRONG_ANSWER,"import os
import sys
from io import BytesIO, IOBase
from random import randint

RANDOM = randint(1, 10 ** 9)
BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

class IntWrapper(int):
    def __init__(self, x):
        int.__init__(x)

    def __hash__(self):
        return super(IntWrapper, self).__hash__() ^ RANDOM

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def LI():
    return list(map(int, input().split()))
def I():
    return int(input())
def LIW():
    return list(map(IntWrapper, input().split()))
def IW():
    return IntWrapper(input())

def slide(values, start, end, size):
    i = -1
    best_sum, curr_sum = 0, 0
    for pos in range(start, end):
        if (pos - start) >= size:
            curr_sum -= values[pos - size]

        curr_sum += values[pos]

        if (pos - start) >= size - 1:
            if curr_sum > best_sum:
                i = pos - size + 1
                best_sum = curr_sum

    return i, best_sum

n, k = LI()
values = LI()

pref_sum = [values[0]]
for x in range(1, n):
    pref_sum.append(pref_sum[-1] + values[x])

def f(cache, i, s):
    if s == 0: return 0

    if (i, s) not in cache:
        ans = float('-inf')
        for x in range(i, n - k + 1):
            total_sum = pref_sum[x + k - 1]
            if x > 0:
                total_sum -= pref_sum[x - 1]

            ans = max(ans, f(cache, x + k, s - 1) + total_sum)
        cache[i, s] = ans

    return cache[i, s]

cache = {}
f(cache, 0, 2)
dp = [[0] * (n + 1) for _ in range(3)]
for i, s in cache:
    dp[s][i] = cache[i, s]

v2 = dp[1][k]
v1 = dp[2][0] - v2

a, b = -1, -1
curr_sum = 0
for x in range(len(values)):
    if x >= k:
        curr_sum -= values[x-k]

    curr_sum += values[x]

    if x >= (k - 1):
        if (curr_sum == v1) and (a == -1):
            a = x - k + 1
        if (curr_sum == v2) and (b == -1) and (x > a + k):
            b = x - k + 1
a, b = min(a, b), max(a, b)
print(a + 1, b + 1)","def max_absurdity_segments(n, k, absurdities):

    prefix_sums = [0] * (n + 1)
    for i in range(1, n + 1):
        prefix_sums[i] = prefix_sums[i - 1] + absurdities[i - 1]

    max_total = 0
    best_a = 0
    best_b = 0

    best_first_segment = [(0, 0)] * (n + 1)

    for a in range(1, n - k + 2):
        segment_sum = prefix_sums[a + k - 1] - prefix_sums[a - 1]
        if segment_sum > best_first_segment[a - 1][0]:
            best_first_segment[a] = (segment_sum, a)
        else:
            best_first_segment[a] = best_first_segment[a - 1]

    for b in range(1, n - k + 2):
        segment_sum = prefix_sums[b + k - 1] - prefix_sums[b - 1]

        for a in range(1, b - k + 2):
            total_absurdity = best_first_segment[a][0] + segment_sum
            if total_absurdity > max_total:
                max_total = total_absurdity
                best_a = best_first_segment[a][1]
                best_b = b

    return best_a, best_b

input_data = ""5 2\n3 6 1 1 6\n""
lines = input_data.split('\n')
n, k = map(int, lines[0].split())
absurdities = list(map(int, lines[1].split()))

a, b = max_absurdity_segments(n, k, absurdities)

print(a, b)"
716,A,Crazy Computer,PROGRAMMING,['implementation'],"ZS the Coder is coding on a crazy computer. If you don't type in a word for a *c* consecutive seconds, everything you typed disappear! 

More formally, if you typed a word at second *a* and then the next word at second *b*, then if *b*<=-<=*a*<=≤<=*c*, just the new word is appended to other words on the screen. If *b*<=-<=*a*<=&gt;<=*c*, then everything on the screen disappears and after that the word you have typed appears on the screen.

For example, if *c*<==<=5 and you typed words at seconds 1,<=3,<=8,<=14,<=19,<=20 then at the second 8 there will be 3 words on the screen. After that, everything disappears at the second 13 because nothing was typed. At the seconds 14 and 19 another two words are typed, and finally, at the second 20, one more word is typed, and a total of 3 words remain on the screen.

You're given the times when ZS the Coder typed the words. Determine how many words remain on the screen after he finished typing everything.","The first line contains two integers *n* and *c* (1<=≤<=*n*<=≤<=100<=000,<=1<=≤<=*c*<=≤<=109) — the number of words ZS the Coder typed and the crazy computer delay respectively.

The next line contains *n* integers *t*1,<=*t*2,<=...,<=*t**n* (1<=≤<=*t*1<=&lt;<=*t*2<=&lt;<=...<=&lt;<=*t**n*<=≤<=109), where *t**i* denotes the second when ZS the Coder typed the *i*-th word.","Print a single positive integer, the number of words that remain on the screen after all *n* words was typed, in other words, at the second *t**n*.","['6 5\n1 3 8 14 19 20\n', '6 1\n1 3 5 7 9 10\n']","['3', '2']","The first sample is already explained in the problem statement.

For the second sample, after typing the first word at the second 1, it disappears because the next word is typed at the second 3 and 3 - 1 &gt; 1. Similarly, only 1 word will remain at the second 9. Then, a word is typed at the second 10, so there will be two words on the screen, as the old word won't disappear because 10 - 9 ≤ 1.",WRONG_ANSWER,"def main():
    n,c = [int(i) for i in input().split()]
    n_list = [int(i) for i in input().split()]
    res = 1
    for i in range(n):
        res+=1
        if i!=0:
            if n_list[i]-n_list[i-1]>c:
                res = 1
    
    return res

print(main())","n, c = map(int, input().split())

times = list(map(int, input().split()))

words_on_screen = 0

last_time = -1

for i in range(n):

    if last_time == -1 or times[i] - last_time > c:

        words_on_screen = 1
    else:

        words_on_screen += 1

    last_time = times[i]

print(words_on_screen)"
467,A,George and Accommodation,PROGRAMMING,['implementation'],"George has recently entered the BSUCP (Berland State University for Cool Programmers). George has a friend Alex who has also entered the university. Now they are moving into a dormitory. 

George and Alex want to live in the same room. The dormitory has *n* rooms in total. At the moment the *i*-th room has *p**i* people living in it and the room can accommodate *q**i* people in total (*p**i*<=≤<=*q**i*). Your task is to count how many rooms has free place for both George and Alex.","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=100) — the number of rooms.

The *i*-th of the next *n* lines contains two integers *p**i* and *q**i* (0<=≤<=*p**i*<=≤<=*q**i*<=≤<=100) — the number of people who already live in the *i*-th room and the room's capacity.",Print a single integer — the number of rooms where George and Alex can move in.,"['3\n1 1\n2 2\n3 3\n', '3\n1 10\n0 10\n10 10\n']","['0\n', '2\n']",none,OK,"def count_rooms_with_free_space(n, rooms):
    count = 0
    for i in range(n):
        pi, qi = rooms[i]
        if qi - pi >= 2:
            count += 1
    return count

n = int(input())
rooms = [tuple(map(int, input().split())) for _ in range(n)]

result = count_rooms_with_free_space(n, rooms)

print(result)","n = int(input())

available_rooms = 0

for _ in range(n):
    p, q = map(int, input().split())

    if q - p >= 2:
        available_rooms += 1

print(available_rooms)"
750,A,New Year and Hurry,PROGRAMMING,"['binary search', 'brute force', 'implementation', 'math']","Limak is going to participate in a contest on the last day of the 2016. The contest will start at 20:00 and will last four hours, exactly until midnight. There will be *n* problems, sorted by difficulty, i.e. problem 1 is the easiest and problem *n* is the hardest. Limak knows it will take him 5·*i* minutes to solve the *i*-th problem.

Limak's friends organize a New Year's Eve party and Limak wants to be there at midnight or earlier. He needs *k* minutes to get there from his house, where he will participate in the contest first.

How many problems can Limak solve if he wants to make it to the party?","The only line of the input contains two integers *n* and *k* (1<=≤<=*n*<=≤<=10, 1<=≤<=*k*<=≤<=240) — the number of the problems in the contest and the number of minutes Limak needs to get to the party from his house.","Print one integer, denoting the maximum possible number of problems Limak can solve so that he could get to the party at midnight or earlier.","['3 222\n', '4 190\n', '7 1\n']","['2\n', '4\n', '7\n']","In the first sample, there are 3 problems and Limak needs 222 minutes to get to the party. The three problems require 5, 10 and 15 minutes respectively. Limak can spend 5 + 10 = 15 minutes to solve first two problems. Then, at 20:15 he can leave his house to get to the party at 23:57 (after 222 minutes). In this scenario Limak would solve 2 problems. He doesn't have enough time to solve 3 problems so the answer is 2.

In the second sample, Limak can solve all 4 problems in 5 + 10 + 15 + 20 = 50 minutes. At 20:50 he will leave the house and go to the party. He will get there exactly at midnight.

In the third sample, Limak needs only 1 minute to get to the party. He has enough time to solve all 7 problems.",OK,"def solve(n, k):
    l = 240 - k
    for i in range(1, n+1):
        if l >= 5*i:
            l -= 5*i
        else:
            return i-1
    return n

n, k = list(map(int, input().split()))
print(solve(n, k))","n, k = map(int, input().split())

total_time = 240

time_available = total_time - k

time_spent = 0
problems_solved = 0

for i in range(1, n + 1):
    time_for_problem = 5 * i
    if time_spent + time_for_problem <= time_available:
        time_spent += time_for_problem
        problems_solved += 1
    else:
        break

print(problems_solved)"
721,A,One-dimensional Japanese Crossword,PROGRAMMING,['implementation'],"Recently Adaltik discovered japanese crosswords. Japanese crossword is a picture, represented as a table sized *a*<=×<=*b* squares, and each square is colored white or black. There are integers to the left of the rows and to the top of the columns, encrypting the corresponding row or column. The number of integers represents how many groups of black squares there are in corresponding row or column, and the integers themselves represents the number of consecutive black squares in corresponding group (you can find more detailed explanation in Wikipedia [https://en.wikipedia.org/wiki/Japanese_crossword](https://en.wikipedia.org/wiki/Japanese_crossword)).

Adaltik decided that the general case of japanese crossword is too complicated and drew a row consisting of *n* squares (e.g. japanese crossword sized 1<=×<=*n*), which he wants to encrypt in the same way as in japanese crossword.

Help Adaltik find the numbers encrypting the row he drew.","The first line of the input contains a single integer *n* (1<=≤<=*n*<=≤<=100) — the length of the row. The second line of the input contains a single string consisting of *n* characters 'B' or 'W', ('B' corresponds to black square, 'W' — to white square in the row that Adaltik drew).","The first line should contain a single integer *k* — the number of integers encrypting the row, e.g. the number of groups of black squares in the row.

The second line should contain *k* integers, encrypting the row, e.g. corresponding to sizes of groups of consecutive black squares in the order from left to right.","['3\nBBW\n', '5\nBWBWB\n', '4\nWWWW\n', '4\nBBBB\n', '13\nWBBBBWWBWBBBW\n']","['1\n2 ', '3\n1 1 1 ', '0\n', '1\n4 ', '3\n4 1 3 ']",The last sample case correspond to the picture in the statement.,OK,"def Remove(s):
    a = []
    for i in range(len(s)):
        if len(s[i]) == 0:
            a.append(i)
    a.reverse()
    for i in a:
        del s[i]
    return s

def Print(s):
    print(len(s))
    for i in s:
        print(len(i),end=' ')

n = int(input())
s = list(map(str,input().split('W')))
s = Remove(s)
Print(s)","def encrypt_crossword(n, row):

    group_count = 0
    groups = []
    current_group_size = 0

    for char in row:
        if char == 'B':

            current_group_size += 1
        else:

            if current_group_size > 0:
                groups.append(current_group_size)
                group_count += 1
                current_group_size = 0

    if current_group_size > 0:
        groups.append(current_group_size)
        group_count += 1

    return group_count, groups

input_data = ['3\nBBW\n', '5\nBWBWB\n', '4\nWWWW\n', '4\nBBBB\n', '13\nWBBBBWWBWBBBW\n']
output_data = []

for data in input_data:
    n, row = data.split('\n')[:-1]
    n = int(n)
    group_count, groups = encrypt_crossword(n, row)

    output_data.append(f""{group_count}\n{' '.join(map(str, groups))} "")

for output in output_data:
    print(output)"
20,C,Dijkstra?,PROGRAMMING,"['graphs', 'shortest paths']",You are given a weighted undirected graph. The vertices are enumerated from 1 to *n*. Your task is to find the shortest path between the vertex 1 and the vertex *n*.,"The first line contains two integers *n* and *m* (2<=≤<=*n*<=≤<=105,<=0<=≤<=*m*<=≤<=105), where *n* is the number of vertices and *m* is the number of edges. Following *m* lines contain one edge each in form *a**i*, *b**i* and *w**i* (1<=≤<=*a**i*,<=*b**i*<=≤<=*n*,<=1<=≤<=*w**i*<=≤<=106), where *a**i*,<=*b**i* are edge endpoints and *w**i* is the length of the edge.

It is possible that the graph has loops and multiple edges between pair of vertices.","Write the only integer -1 in case of no path. Write the shortest path in opposite case. If there are many solutions, print any of them.","['5 6\n1 2 2\n2 5 5\n2 3 4\n1 4 1\n4 3 3\n3 5 1\n', '5 6\n1 2 2\n2 5 5\n2 3 4\n1 4 1\n4 3 3\n3 5 1\n']","['1 4 3 5 ', '1 4 3 5 ']",none,TIME_LIMIT_EXCEEDED,"import sys

v, e = map(int, input().split(' '))

adj_list = [[] for _ in range(v)]
distances = [sys.maxsize] * v
parent = [-1] * v

for _ in range(e):
    a, b, w = map(int, input().split(' '))
    adj_list[a - 1].append((b - 1, w))
    adj_list[b - 1].append((a - 1, w))

distances[0] = 0
visited = [False] * v

def min_distance(distances, visited):
    minimum = sys.maxsize
    min_index = -1
    for t in range(v):
        if not visited[t] and distances[t] < minimum:
            minimum = distances[t]
            min_index = t
    return min_index

for _ in range(v):
    u = min_distance(distances, visited)
    if u == -1 or u == v - 1:
        break
    visited[u] = True
    for g, w in adj_list[u]:
        if not visited[g] and distances[g] > distances[u] + w:
            distances[g] = distances[u] + w
            parent[g] = u

if u == -1:
    print(-1)
else:
    path = []
    indx = v - 1
    path.append(indx + 1)
    while indx != 0:
        parent_indx = parent[indx]
        path.append(parent_indx + 1)
        indx = parent_indx
    path.reverse()
    print(*path)","import sys
import heapq

def dijkstra(n, edges):
    graph = [[] for _ in range(n + 1)]

    for a, b, w in edges:
        graph[a].append((b, w))
        graph[b].append((a, w))

    dist = [float('inf')] * (n + 1)
    prev = [-1] * (n + 1)
    dist[1] = 0
    priority_queue = [(0, 1)]

    while priority_queue:
        current_dist, u = heapq.heappop(priority_queue)

        if current_dist > dist[u]:
            continue

        for v, weight in graph[u]:
            if current_dist + weight < dist[v]:
                dist[v] = current_dist + weight
                prev[v] = u
                heapq.heappush(priority_queue, (dist[v], v))

    if dist[n] == float('inf'):
        return -1

    path = []
    current = n
    while current != -1:
        path.append(current)
        current = prev[current]
    
    path.reverse()
    return ' '.join(map(str, path))

def main():
    input_lines = sys.stdin.read().strip().splitlines()
    n, m = map(int, input_lines[0].split())
    edges = []

    for line in input_lines[1:m + 1]:
        a, b, w = map(int, line.split())
        edges.append((a, b, w))

    result = dijkstra(n, edges)
    print(result)

if __name__ == ""__main__"":
    main()"
270,A,Fancy Fence,PROGRAMMING,"['geometry', 'implementation', 'math']","Emuskald needs a fence around his farm, but he is too lazy to build it himself. So he purchased a fence-building robot.

He wants the fence to be a regular polygon. The robot builds the fence along a single path, but it can only make fence corners at a single angle *a*.

Will the robot be able to build the fence Emuskald wants? In other words, is there a regular polygon which angles are equal to *a*?",The first line of input contains an integer *t* (0<=&lt;<=*t*<=&lt;<=180) — the number of tests. Each of the following *t* lines contains a single integer *a* (0<=&lt;<=*a*<=&lt;<=180) — the angle the robot can make corners at measured in degrees.,"For each test, output on a single line ""YES"" (without quotes), if the robot can build a fence Emuskald wants, and ""NO"" (without quotes), if it is impossible.",['3\n30\n60\n90\n'],['NO\nYES\nYES\n'],"In the first test case, it is impossible to build the fence, since there is no regular polygon with angle <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/df5f4b07dd5316fde165b43657b2696e2919e791.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>.

In the second test case, the fence is a regular triangle, and in the last test case — a square.",WRONG_ANSWER,"def angle(z):
    ans=int((z-2)*180/z)
    return ans
x=int(input())
arr=[]
for k in range(x):
    inp=int(input())
    arr.append(inp)
x=3
for i in arr:
    a=0
    while angle(x)<=i:
        if angle(x)==i:
            print('YES')
            a=10
            break
        else:
            x+=1
    if a==0:
        print('NO')","def can_build_fence(angle):

    if angle <= 0 or angle >= 180:
        return ""NO""

    n = 360 / (180 - angle)

    if n.is_integer() and n >= 3:
        return ""YES""
    
    return ""NO""

t = int(input())
results = []

for _ in range(t):
    angle = int(input())
    results.append(can_build_fence(angle))

print(""\n"".join(results))"
690,C2,Brain Network (medium),PROGRAMMING,"['dfs and similar', 'graphs', 'trees']","Further research on zombie thought processes yielded interesting results. As we know from the previous problem, the nervous system of a zombie consists of *n* brains and *m* brain connectors joining some pairs of brains together. It was observed that the intellectual abilities of a zombie depend mainly on the topology of its nervous system. More precisely, we define the distance between two brains *u* and *v* (1<=≤<=*u*,<=*v*<=≤<=*n*) as the minimum number of brain connectors used when transmitting a thought between these two brains. The brain latency of a zombie is defined to be the maximum distance between any two of its brains. Researchers conjecture that the brain latency is the crucial parameter which determines how smart a given zombie is. Help them test this conjecture by writing a program to compute brain latencies of nervous systems.

In this problem you may assume that any nervous system given in the input is valid, i.e., it satisfies conditions (1) and (2) from the easy version.","The first line of the input contains two space-separated integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=100000) denoting the number of brains (which are conveniently numbered from 1 to *n*) and the number of brain connectors in the nervous system, respectively. In the next *m* lines, descriptions of brain connectors follow. Every connector is given as a pair of brains *a* *b* it connects (1<=≤<=*a*,<=*b*<=≤<=*n* and *a*<=≠<=*b*).",Print one number – the brain latency.,"['4 3\n1 2\n1 3\n1 4\n', '5 4\n1 2\n2 3\n3 4\n3 5\n']","['2', '3']",none,OK,"def solution(idx):
    visited = [False] * n
    max_distance = (0, idx)
    stack = [max_distance]
    while stack:
        distance, idx = stack.pop()
        visited[idx] = True
        if distance > max_distance[0]:
            max_distance = (distance, idx)
        stack += [(distance + 1, j) for j in links[idx] if not visited[j]]
    return max_distance

if __name__ == '__main__':
    n, m = map(int, input().split())
    links = [[] for i in range(n)]
    for j in range(m):
        a, b = map(int, input().split())
        links[a - 1].append(b - 1)
        links[b - 1].append(a - 1)

    print(solution(solution(0)[1])[0])","from collections import deque
import sys

def bfs(start, graph, n):

    visited = [-1] * (n + 1)
    queue = deque([start])
    visited[start] = 0
    max_distance = 0

    while queue:
        current = queue.popleft()
        current_distance = visited[current]

        for neighbor in graph[current]:
            if visited[neighbor] == -1:
                visited[neighbor] = current_distance + 1
                max_distance = max(max_distance, visited[neighbor])
                queue.append(neighbor)

    return max_distance

def find_brain_latency(n, m, connectors):

    graph = [[] for _ in range(n + 1)]

    for a, b in connectors:
        graph[a].append(b)
        graph[b].append(a)

    brain_latency = 0
    visited = [False] * (n + 1)

    for i in range(1, n + 1):
        if not visited[i]:
            max_distance_from_i = bfs(i, graph, n)
            brain_latency = max(brain_latency, max_distance_from_i)

            queue = deque([i])
            while queue:
                current = queue.popleft()
                visited[current] = True
                for neighbor in graph[current]:
                    if not visited[neighbor]:
                        visited[neighbor] = True
                        queue.append(neighbor)

    return brain_latency

if __name__ == ""__main__"":
    input_data = sys.stdin.read().strip().splitlines()
    results = []

    for i in range(0, len(input_data), 1):

        n, m = map(int, input_data[i].split())
        connectors = []
        
        for j in range(m):
            a, b = map(int, input_data[i + j + 1].split())
            connectors.append((a, b))

        latency = find_brain_latency(n, m, connectors)
        results.append(str(latency))
        i += m

    print(""\n"".join(results))"
625,B,War of the Corporations,PROGRAMMING,"['constructive algorithms', 'greedy', 'strings']","A long time ago, in a galaxy far far away two giant IT-corporations Pineapple and Gogol continue their fierce competition. Crucial moment is just around the corner: Gogol is ready to release it's new tablet Lastus 3000.

This new device is equipped with specially designed artificial intelligence (AI). Employees of Pineapple did their best to postpone the release of Lastus 3000 as long as possible. Finally, they found out, that the name of the new artificial intelligence is similar to the name of the phone, that Pineapple released 200 years ago. As all rights on its name belong to Pineapple, they stand on changing the name of Gogol's artificial intelligence.

Pineapple insists, that the name of their phone occurs in the name of AI as a substring. Because the name of technology was already printed on all devices, the Gogol's director decided to replace some characters in AI name with ""#"". As this operation is pretty expensive, you should find the minimum number of characters to replace with ""#"", such that the name of AI doesn't contain the name of the phone as a substring.

Substring is a continuous subsequence of a string.","The first line of the input contains the name of AI designed by Gogol, its length doesn't exceed 100<=000 characters. Second line contains the name of the phone released by Pineapple 200 years ago, its length doesn't exceed 30. Both string are non-empty and consist of only small English letters.","Print the minimum number of characters that must be replaced with ""#"" in order to obtain that the name of the phone doesn't occur in the name of AI as a substring.","['intellect\ntell\n', 'google\napple\n', 'sirisiri\nsir\n']","['1', '0', '2']","In the first sample AI's name may be replaced with ""int#llect"".

In the second sample Gogol can just keep things as they are.

In the third sample one of the new possible names of AI may be ""s#ris#ri"".",WRONG_ANSWER,"from collections import deque,Counter
from math import *
import sys
import random
from bisect import *
from functools import reduce
from sys import stdin
import copy

def find(s,t):
    p = 31
    m = 10**9 + 9
    p_pow = [0] * max(len(s),len(t))
    p_pow[0] = 1
    for i in range(1,len(p_pow)):
        p_pow[i] = (p_pow[i-1] * p) % m
    h = [0]*(len(t)+1)
    for i in range(len(t)):
        h[i+1] = (h[i] + (ord(t[i]) - 97)*p_pow[i])%m
    h_s = 0
    for i in range(len(s)):
        h_s = (h_s + (ord(s[i]) - 97)*p_pow[i])%m
    ans = 0
    for i in range(len(t)-len(s)+1):
        curr_h = (h[i+len(s)] - h[i])%m
        if curr_h == (h_s * p_pow[i])%m:
            ans+=1
    return ans

t = input()
s = input()
print(find(s,t))","def min_replacements(ai_name, phone_name):
    n, m = len(ai_name), len(phone_name)
    dp = [[float('inf')] * (m + 1) for _ in range(n + 1)]

    for i in range(n + 1):
        dp[i][0] = 0

    for i in range(1, n + 1):
        for j in range(1, m + 1):

            if ai_name[i - 1] == phone_name[j - 1]:
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])

            dp[i][j] = min(dp[i][j], dp[i - 1][j] + 1)

            dp[i][j] = min(dp[i][j], dp[i - 1][j])

    return dp[n][m]

def main():
    import sys
    input = sys.stdin.read
    data = input().strip().split('\n')
    
    results = []
    for i in range(0, len(data), 2):
        ai_name = data[i].strip()
        phone_name = data[i + 1].strip()
        results.append(str(min_replacements(ai_name, phone_name)))
    
    print('\n'.join(results))

if __name__ == ""__main__"":
    main()"
377,A,Maze,PROGRAMMING,['dfs and similar'],"Pavel loves grid mazes. A grid maze is an *n*<=×<=*m* rectangle maze where each cell is either empty, or is a wall. You can go from one cell to another only if both cells are empty and have a common side.

Pavel drew a grid maze with all empty cells forming a connected area. That is, you can go from any empty cell to any other one. Pavel doesn't like it when his maze has too little walls. He wants to turn exactly *k* empty cells into walls so that all the remaining cells still formed a connected area. Help him.","The first line contains three integers *n*, *m*, *k* (1<=≤<=*n*,<=*m*<=≤<=500, 0<=≤<=*k*<=&lt;<=*s*), where *n* and *m* are the maze's height and width, correspondingly, *k* is the number of walls Pavel wants to add and letter *s* represents the number of empty cells in the original maze.

Each of the next *n* lines contains *m* characters. They describe the original maze. If a character on a line equals ""."", then the corresponding cell is empty and if the character equals ""#"", then the cell is a wall.","Print *n* lines containing *m* characters each: the new maze that fits Pavel's requirements. Mark the empty cells that you transformed into walls as ""X"", the other cells must be left without changes (that is, ""."" and ""#"").

It is guaranteed that a solution exists. If there are multiple solutions you can output any of them.","['3 4 2\n#..#\n..#.\n#...\n', '5 4 5\n#...\n#.#.\n.#..\n...#\n.#.#\n']","['#.X#\nX.#.\n#...\n', '#XXX\n#X#.\nX#..\n...#\n.#.#\n']",none,WRONG_ANSWER,"from collections import defaultdict 

grid = [] 
n,m,k  = list(map(int, input().split())) 
count = 0 
def solve():
    global n,m,k, count 
    for _  in range(n):
        grid.append(list(input()))
    total = 0 
    x,y = -1,-1
    for i in range(n):
        for j in range(m):
            if grid[i][j] == '.':
                grid[i][j] = 'X'
                total += 1 
                x = i
                y = j 
    stack = [(x,y)] 
    while stack:
        if count == (total - k):
            return 
        i,j = stack.pop() 
        count += 1 
        grid[i][j] = '.'
        for dx,dy in [(0,1),(0,-1),(1,0),(-1,0)]:
            n_i,n_j  = i + dx , j + dy 
            if 0 <= n_i < n and 0 <= n_j < m and grid[n_i][n_j] == 'X':
                stack.append((n_i, n_j)) 
solve() 
for i in range(n):
    print("""".join(grid[i]))","def create_maze(n, m, k, maze):

    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]

    def in_bounds(x, y):
        return 0 <= x < n and 0 <= y < m and maze[x][y] == '.'

    empty_cells = [(i, j) for i in range(n) for j in range(m) if maze[i][j] == '.']

    for i in range(k):
        x, y = empty_cells[i]
        maze[x][y] = 'X'

    return maze

n, m, k = map(int, input().split())
maze = [list(input().strip()) for _ in range(n)]

modified_maze = create_maze(n, m, k, maze)

for row in modified_maze:
    print(''.join(row))"
61,A,Ultra-Fast Mathematician,PROGRAMMING,['implementation'],"Shapur was an extremely gifted student. He was great at everything including Combinatorics, Algebra, Number Theory, Geometry, Calculus, etc. He was not only smart but extraordinarily fast! He could manage to sum 1018 numbers in a single second.

One day in 230 AD Shapur was trying to find out if any one can possibly do calculations faster than him. As a result he made a very great contest and asked every one to come and take part.

In his contest he gave the contestants many different pairs of numbers. Each number is made from digits 0 or 1. The contestants should write a new number corresponding to the given pair of numbers. The rule is simple: The *i*-th digit of the answer is 1 if and only if the *i*-th digit of the two given numbers differ. In the other case the *i*-th digit of the answer is 0.

Shapur made many numbers and first tried his own speed. He saw that he can perform these operations on numbers of length ∞ (length of a number is number of digits in it) in a glance! He always gives correct answers so he expects the contestants to give correct answers, too. He is a good fellow so he won't give anyone very big numbers and he always gives one person numbers of same length.

Now you are going to take part in Shapur's contest. See if you are faster and more accurate.",There are two lines in each input. Each of them contains a single number. It is guaranteed that the numbers are made from 0 and 1 only and that their length is same. The numbers may start with 0. The length of each number doesn't exceed 100.,Write one line — the corresponding answer. Do not omit the leading 0s.,"['1010100\n0100101\n', '000\n111\n', '1110\n1010\n', '01110\n01100\n']","['1110001\n', '111\n', '0100\n', '00010\n']",none,OK,"from operator import xor
from typing import Callable, List, TypeVar, cast

F = TypeVar(""F"", bound=Callable[[], None])

def my_decorator(func: F) -> F:
    def wrapper():
        for _ in range(int(input(""Times: ""))):
            func()

    return cast(F, wrapper)

def main() -> None:
    VALUES: List[str] = [input() for _ in range(2)]

    print(f""{xor(*(int(value,2)for value in VALUES)):b}"".zfill(len(VALUES[0])))

if __name__ == ""__main__"":
    main()","def xor_binary_numbers(binary_pairs):
    results = []
    for pair in binary_pairs:

        a, b = pair.strip().split()

        result = ''.join('1' if a[i] != b[i] else '0' for i in range(len(a)))
        results.append(result)
    return results

demo_input = ['1010100\n0100101\n', '000\n111\n', '1110\n1010\n', '01110\n01100\n']

output = xor_binary_numbers(demo_input)

print(output)"
548,A,Mike and Fax,PROGRAMMING,"['brute force', 'implementation', 'strings']","While Mike was walking in the subway, all the stuff in his back-bag dropped on the ground. There were several fax messages among them. He concatenated these strings in some order and now he has string *s*.

He is not sure if this is his own back-bag or someone else's. He remembered that there were exactly *k* messages in his own bag, each was a palindrome string and all those strings had the same length.

He asked you to help him and tell him if he has worn his own back-bag. Check if the given string *s* is a concatenation of *k* palindromes of the same length.","The first line of input contains string *s* containing lowercase English letters (1<=≤<=|*s*|<=≤<=1000).

The second line contains integer *k* (1<=≤<=*k*<=≤<=1000).","Print ""YES""(without quotes) if he has worn his own back-bag or ""NO""(without quotes) otherwise.","['saba\n2\n', 'saddastavvat\n2\n']","['NO\n', 'YES\n']","Palindrome is a string reading the same forward and backward.

In the second sample, the faxes in his back-bag can be ""saddas"" and ""tavvat"".",OK,"string = input()
partskitnekarnehai = int(input())
if len(string)%partskitnekarnehai!=0:
    print('NO')
    exit()

nayalength = len(string) // partskitnekarnehai

for j in range(partskitnekarnehai):
    seedha_part = string[ j*nayalength : (j + 1)*nayalength]

    ulta_part=reversed(seedha_part)

    if seedha_part != """".join(ulta_part):
        print(""NO"") 
        exit()
print(""YES"")

'''
https://codeforces.com/problemset/problem/548/A
1. Aaj exit() seekha, kaafi useful, i always thought agar aise kuch 
karna hai to i'll have to define a function, fir use return to get
out of the code.
4. Abe yaar mai bhi kya gadha hu, like agar NO hai answer, 
to exit karna chahiye, i exited on YES wala case
3. Are bhai yaaar wo sabse upar wala block mai bhool hi gaya tha,
gahdam ek aur wrong submission
2. Also line 7 me agar -1 kia to it only check first part of string
'''","def is_palindrome(s: str) -> bool:

    return s == s[::-1]

def can_form_k_palindromes(s: str, k: int) -> str:

    n = len(s)

    if n % k != 0:
        return ""NO""

    length_of_each = n // k

    for i in range(k):
        if not is_palindrome(s[i * length_of_each: (i + 1) * length_of_each]):
            return ""NO""
    
    return ""YES""

s = input().strip()
k = int(input().strip())

print(can_form_k_palindromes(s, k))"
411,A,Password Check,PROGRAMMING,"['*special', 'implementation']","You have probably registered on Internet sites many times. And each time you should enter your invented password. Usually the registration form automatically checks the password's crypt resistance. If the user's password isn't complex enough, a message is displayed. Today your task is to implement such an automatic check.

Web-developers of the company Q assume that a password is complex enough, if it meets all of the following conditions:
 -  the password length is at least 5 characters; -  the password contains at least one large English letter; -  the password contains at least one small English letter; -  the password contains at least one digit. 
You are given a password. Please implement the automatic check of its complexity for company Q.","The first line contains a non-empty sequence of characters (at most 100 characters). Each character is either a large English letter, or a small English letter, or a digit, or one of characters: ""!"", ""?"", ""."", "","", ""_"".","If the password is complex enough, print message ""Correct"" (without the quotes), otherwise print message ""Too weak"" (without the quotes).","['abacaba\n', 'X12345\n', 'CONTEST_is_STARTED!!11\n']","['Too weak\n', 'Too weak\n', 'Correct\n']",none,OK,"import string

def selection_sort(l):
    for i in range(len(l)):
        min_val = l[i]
        min_val_index = i
        for j in range(i, len(l)):
            if l[j] < min_val:
                min_val = l[j]
                min_val_index = j
        l[i], l[min_val_index] = l[min_val_index], l[i]
    return l

def merge_sort(l):
    def merge(l1, l2):
        output_list = []
        i, j = 0, 0
        while i < len(l1) and j < len(l2):
            if l1[i] < l2[j]:
                output_list.append(l1[i])
                i += 1
            else:
                output_list.append(l2[j])
                j += 1
        if i == len(l1):
            output_list += l2[j:]
        else:
            output_list += l1[i:]
        return output_list

    def sort(li):
        if len(li) < 2:
            return li
        mid = len(li) // 2
        left = sort(li[:mid])
        right = sort(li[mid:])
        return merge(left, right)

    return sort(l)

def main_function():
    is_len_greater_than_5 = False
    does_contain_digit = False
    does_contain_upper = False
    does_contain_lower = False
    password = input()
    if len(password) >= 5:
        is_len_greater_than_5 = True
    for i in password:
        if i.isdigit():
            does_contain_digit = True
        elif i.isupper():
            does_contain_upper = True
        elif i.islower():
            does_contain_lower = True
    if is_len_greater_than_5 and does_contain_lower and does_contain_upper and does_contain_digit:
        return ""Correct""
    return ""Too weak""

print(main_function())","def check_password_complexity(password):

    if len(password) < 5:
        return ""Too weak""

    has_upper = any(c.isupper() for c in password)
    has_lower = any(c.islower() for c in password)
    has_digit = any(c.isdigit() for c in password)

    if has_upper and has_lower and has_digit:
        return ""Correct""
    else:
        return ""Too weak""

passwords = ['abacaba\n', 'X12345\n', 'CONTEST_is_STARTED!!11\n']

for pwd in passwords:

    result = check_password_complexity(pwd.strip())
    print(result)"
755,C,PolandBall and Forest,PROGRAMMING,"['dfs and similar', 'dsu', 'graphs', 'interactive', 'trees']","PolandBall lives in a forest with his family. There are some trees in the forest. Trees are undirected acyclic graphs with *k* vertices and *k*<=-<=1 edges, where *k* is some integer. Note that one vertex is a valid tree.

There is exactly one relative living in each vertex of each tree, they have unique ids from 1 to *n*. For each Ball *i* we know the id of its most distant relative living on the same tree. If there are several such vertices, we only know the value of the one with smallest id among those.

How many trees are there in the forest?","The first line contains single integer *n* (1<=≤<=*n*<=≤<=104) — the number of Balls living in the forest.

The second line contains a sequence *p*1,<=*p*2,<=...,<=*p**n* of length *n*, where (1<=≤<=*p**i*<=≤<=*n*) holds and *p**i* denotes the most distant from Ball *i* relative living on the same tree. If there are several most distant relatives living on the same tree, *p**i* is the id of one with the smallest id.

It's guaranteed that the sequence *p* corresponds to some valid forest.

Hacking: To hack someone, you should provide a correct forest as a test. The sequence *p* will be calculated according to the forest and given to the solution you try to hack as input. Use the following format:

In the first line, output the integer *n* (1<=≤<=*n*<=≤<=104) — the number of Balls and the integer *m* (0<=≤<=*m*<=&lt;<=*n*) — the total number of edges in the forest. Then *m* lines should follow. The *i*-th of them should contain two integers *a**i* and *b**i* and represent an edge between vertices in which relatives *a**i* and *b**i* live. For example, the first sample is written as follows:",You should output the number of trees in the forest where PolandBall lives.,"['5\n2 1 5 3 3', '1\n1\n']","['2', '1']","In the first sample testcase, possible forest is: 1-2 3-4-5. 

There are 2 trees overall.

In the second sample testcase, the only possible graph is one vertex and no edges. Therefore, there is only one tree.",WRONG_ANSWER,"from sys import stdin
def get_ints(): return list(map(int, stdin.readline().strip().split()))

class DSU:
    def __init__(self, n):

        self.rank = [1] * n
        self.parent = [i for i in range(n)]

    def find(self, x):

        if (self.parent[x] != x):

            self.parent[x] = self.find(self.parent[x])

        return self.parent[x]

    def Union(self, x, y):

        xset = self.find(x)
        yset = self.find(y)

        if xset == yset:
            return

        if self.rank[xset] < self.rank[yset]:
            self.parent[xset] = yset
  
        elif self.rank[xset] > self.rank[yset]:
            self.parent[yset] = xset

        else:
            self.parent[yset] = xset
            self.rank[xset] = self.rank[xset] + 1

n = int(input())
dsu = DSU(n)
ar = get_ints()
for i in range(n):
	dsu.Union(i,ar[i]-1)
print(len(set(dsu.parent)))","def count_trees(n, p):

    leaders = set()
    
    for ball_id in range(1, n + 1):

        leaders.add(p[ball_id - 1])

    return len(leaders)

n = int(input().strip())
p = list(map(int, input().strip().split()))

result = count_trees(n, p)
print(result)"
227,B,Effective Approach,PROGRAMMING,['implementation'],"Once at a team training Vasya, Petya and Sasha got a problem on implementing linear search in an array.

According to the boys, linear search works as follows. The array elements in a pre-selected order are in turn compared with the number that you need to find. Once you find the array element that is equal to the required one, the search ends. The efficiency of the algorithm is the number of performed comparisons. The fewer comparisons the linear search has made, the more effective it is.

Vasya believes that a linear search would work better if it sequentially iterates through the elements, starting with the 1-st one (in this problem we consider the elements of the array indexed from 1 to *n*) and ending with the *n*-th one. And Petya says that Vasya is wrong: the search will need less comparisons if it sequentially iterates the elements starting from the *n*-th and ending with the 1-st one. Sasha argues that the two approaches are equivalent.

To finally begin the task, the teammates decided to settle the debate and compare the two approaches on an example. For this, they took an array that is a permutation of integers from 1 to *n*, and generated *m* queries of the form: find element with value *b**i* in the array. They want to calculate for both approaches how many comparisons in total the linear search will need to respond to all queries. If the first search needs fewer comparisons, then the winner of the dispute is Vasya. If the second one does, then the winner is Petya. If both approaches make the same number of comparisons, then Sasha's got the upper hand.

But the problem is, linear search is too slow. That's why the boys aren't going to find out who is right before the end of the training, unless you come in here. Help them to determine who will win the dispute.","The first line contains integer *n* (1<=≤<=*n*<=≤<=105) — the number of elements in the array. The second line contains *n* distinct space-separated integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=*n*) — the elements of array. 

The third line contains integer *m* (1<=≤<=*m*<=≤<=105) — the number of queries. The last line contains *m* space-separated integers *b*1,<=*b*2,<=...,<=*b**m* (1<=≤<=*b**i*<=≤<=*n*) — the search queries. Note that the queries can repeat.","Print two integers, showing how many comparisons Vasya's approach needs and how many comparisons Petya's approach needs. Separate the numbers by spaces.

Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use cin, cout streams or the %I64d specifier.","['2\n1 2\n1\n1\n', '2\n2 1\n1\n1\n', '3\n3 1 2\n3\n1 2 3\n']","['1 2\n', '2 1\n', '6 6\n']","In the first sample Vasya's approach will make one comparison (it starts with the 1-st element and immediately finds the required number), and Petya's approach makes two comparisons (first he compares with the 2-nd array element, doesn't find the search item and compares with the 1-st element).

In the second sample, on the contrary, Vasya's approach will need two comparisons (first with 1-st element, and then with the 2-nd), and Petya's approach will find the required value in one comparison (the first comparison with the 2-nd element).",TIME_LIMIT_EXCEEDED,"from sys import stdin, stdout

def input():
    return stdin.readline().strip()

def print(string):
    return stdout.write(str(string) + ""\n"")

def main():
    n, v, p = int(input()), 0, 0
    a = [int(x) for x in input().split()]
    m = int(input())
    b = [int(x) for x in input().split()]
    for i in range(m):
        bi = a.index(b[i])
        v += bi + 1
        p += n - bi
    print(f""{v} {p}"")

if __name__ == ""__main__"":
    main()","def linear_search_comparisons(n, array, m, queries):

    position = {value: index + 1 for index, value in enumerate(array)}

    vasya_comparisons = 0
    petya_comparisons = 0

    for query in queries:
        vasya_comparisons += position[query]

    for query in queries:
        petya_comparisons += (n - position[query] + 1)

    return vasya_comparisons, petya_comparisons

import sys
input = sys.stdin.read
data = input().splitlines()

n = int(data[0])
array = list(map(int, data[1].split()))
m = int(data[2])
queries = list(map(int, data[3].split()))

vasya_comparisons, petya_comparisons = linear_search_comparisons(n, array, m, queries)
print(vasya_comparisons, petya_comparisons)"
415,A,Mashmokh and Lights,PROGRAMMING,['implementation'],"Mashmokh works in a factory. At the end of each day he must turn off all of the lights. 

The lights on the factory are indexed from 1 to *n*. There are *n* buttons in Mashmokh's room indexed from 1 to *n* as well. If Mashmokh pushes button with index *i*, then each light with index not less than *i* that is still turned on turns off.

Mashmokh is not very clever. So instead of pushing the first button he pushes some of the buttons randomly each night. He pushed *m* distinct buttons *b*1,<=*b*2,<=...,<=*b**m* (the buttons were pushed consecutively in the given order) this night. Now he wants to know for each light the index of the button that turned this light off. Please note that the index of button *b**i* is actually *b**i*, not *i*.

Please, help Mashmokh, print these indices.","The first line of the input contains two space-separated integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=100), the number of the factory lights and the pushed buttons respectively. The next line contains *m* distinct space-separated integers *b*1,<=*b*2,<=...,<=*b**m* (1<=≤<=*b**i*<=≤<=*n*).

It is guaranteed that all lights will be turned off after pushing all buttons.",Output *n* space-separated integers where the *i*-th number is index of the button that turns the *i*-th light off.,"['5 4\n4 3 1 2\n', '5 5\n5 4 3 2 1\n']","['1 1 3 4 4 \n', '1 2 3 4 5 \n']","In the first sample, after pressing button number 4, lights 4 and 5 are turned off and lights 1, 2 and 3 are still on. Then after pressing button number 3, light number 3 is turned off as well. Pressing button number 1 turns off lights number 1 and 2 as well so pressing button number 2 in the end has no effect. Thus button number 4 turned lights 4 and 5 off, button number 3 turned light 3 off and button number 1 turned light 1 and 2 off.",OK,"def main():
    [n, m] = [int(_) for _ in input().split()]
    buttons = [int(_) for _ in input().split()]

    lights = [0] * (n + 1)

    for button in buttons:
        i = button
        while i <= n and lights[i] == 0:
            lights[i] = button
            i += 1

    result = ' '.join([str(lights[i]) for i in range(1, n + 1)])
    print(result)

if __name__ == '__main__':
    main()","n, m = map(int, input().split())

buttons = list(map(int, input().split()))

result = [0] * n

last_button_index = 0

for button in buttons:

    for i in range(button - 1, n):
        if result[i] == 0:
            result[i] = button

print("" "".join(map(str, result)))"
698,A,Vacations,PROGRAMMING,['dp'],"Vasya has *n* days of vacations! So he decided to improve his IT skills and do sport. Vasya knows the following information about each of this *n* days: whether that gym opened and whether a contest was carried out in the Internet on that day. For the *i*-th day there are four options:
 1.  on this day the gym is closed and the contest is not carried out; 1.  on this day the gym is closed and the contest is carried out; 1.  on this day the gym is open and the contest is not carried out; 1.  on this day the gym is open and the contest is carried out. 
On each of days Vasya can either have a rest or write the contest (if it is carried out on this day), or do sport (if the gym is open on this day).

Find the minimum number of days on which Vasya will have a rest (it means, he will not do sport and write the contest at the same time). The only limitation that Vasya has — he does not want to do the same activity on two consecutive days: it means, he will not do sport on two consecutive days, and write the contest on two consecutive days.","The first line contains a positive integer *n* (1<=≤<=*n*<=≤<=100) — the number of days of Vasya's vacations.

The second line contains the sequence of integers *a*1,<=*a*2,<=...,<=*a**n* (0<=≤<=*a**i*<=≤<=3) separated by space, where: 
 -  *a**i* equals 0, if on the *i*-th day of vacations the gym is closed and the contest is not carried out; -  *a**i* equals 1, if on the *i*-th day of vacations the gym is closed, but the contest is carried out; -  *a**i* equals 2, if on the *i*-th day of vacations the gym is open and the contest is not carried out; -  *a**i* equals 3, if on the *i*-th day of vacations the gym is open and the contest is carried out.","Print the minimum possible number of days on which Vasya will have a rest. Remember that Vasya refuses:
 -  to do sport on any two consecutive days, -  to write the contest on any two consecutive days.","['4\n1 3 2 0\n', '7\n1 3 3 2 1 2 3\n', '2\n2 2\n']","['2\n', '0\n', '1\n']","In the first test Vasya can write the contest on the day number 1 and do sport on the day number 3. Thus, he will have a rest for only 2 days.

In the second test Vasya should write contests on days number 1, 3, 5 and 7, in other days do sport. Thus, he will not have a rest for a single day.

In the third test Vasya can do sport either on a day number 1 or number 2. He can not do sport in two days, because it will be contrary to the his limitation. Thus, he will have a rest for only one day.",OK,"from calendar import calendar

def List():
    return list(map(int,input().split()))
def Lst():
    return list(input())
def Int():
    return int(input())
def two():
    return map(int,input().split())

numOfVactions = Int()
calendar = List()

outPut = 0
prevState = 0
for currState in calendar:
    if currState == 3:
        prevState = currState - prevState
    elif currState == 0 or currState == prevState:
        outPut +=1
        prevState = 0
    else:   
        prevState = currState

print(outPut)","def min_rest_days(n, days):

    rest_days = 0

    last_activity = None
    
    for i in range(n):
        current_day = days[i]

        if current_day == 0:

            rest_days += 1
            last_activity = None
        elif current_day == 1:

            if last_activity != 'contest':
                last_activity = 'contest'
            else:
                rest_days += 1
                last_activity = None
        elif current_day == 2:

            if last_activity != 'sport':
                last_activity = 'sport'
            else:
                rest_days += 1
                last_activity = None
        elif current_day == 3:

            if last_activity == 'sport':
                last_activity = 'contest'
            elif last_activity == 'contest':
                rest_days += 1
                last_activity = 'sport'
            else:
                last_activity = 'contest'
    
    return rest_days

def main():
    test_cases = [
        [4, [1, 3, 2, 0]],
        [7, [1, 3, 3, 2, 1, 2, 3]],
        [2, [2, 2]],
    ]
    
    results = []
    for n, days in test_cases:
        results.append(str(min_rest_days(n, days)))

    print('\n'.join(results))

if __name__ == ""__main__"":
    main()"
616,C,The Labyrinth,PROGRAMMING,['dfs and similar'],"You are given a rectangular field of *n*<=×<=*m* cells. Each cell is either empty or impassable (contains an obstacle). Empty cells are marked with '.', impassable cells are marked with '*'. Let's call two empty cells adjacent if they share a side.

Let's call a connected component any non-extendible set of cells such that any two of them are connected by the path of adjacent cells. It is a typical well-known definition of a connected component.

For each impassable cell (*x*,<=*y*) imagine that it is an empty cell (all other cells remain unchanged) and find the size (the number of cells) of the connected component which contains (*x*,<=*y*). You should do it for each impassable cell independently.

The answer should be printed as a matrix with *n* rows and *m* columns. The *j*-th symbol of the *i*-th row should be ""."" if the cell is empty at the start. Otherwise the *j*-th symbol of the *i*-th row should contain the only digit —- the answer modulo 10. The matrix should be printed without any spaces.

To make your output faster it is recommended to build the output as an array of *n* strings having length *m* and print it as a sequence of lines. It will be much faster than writing character-by-character.

As input/output can reach huge size it is recommended to use fast input/output methods: for example, prefer to use scanf/printf instead of cin/cout in C++, prefer to use BufferedReader/PrintWriter instead of Scanner/System.out in Java.","The first line contains two integers *n*,<=*m* (1<=≤<=*n*,<=*m*<=≤<=1000) — the number of rows and columns in the field.

Each of the next *n* lines contains *m* symbols: ""."" for empty cells, ""*"" for impassable cells.",Print the answer as a matrix as described above. See the examples to precise the format of the output.,"['3 3\n*.*\n.*.\n*.*\n', '4 5\n**..*\n..***\n.*.*.\n*.*.*\n']","['3.3\n.5.\n3.3\n', '46..3\n..732\n.6.4.\n5.4.3\n']","In first example, if we imagine that the central cell is empty then it will be included to component of size 5 (cross). If any of the corner cell will be empty then it will be included to component of size 3 (corner).",OK,"from collections import Counter

from math import log2

from math import gcd

from collections import  deque
dx=[-1,0,0,1]
dy=[0,-1,1,0]

def bfs(x,y):
	global total
	total+=1
	q=deque([(x,y)])
	v[x][y]=True
	h[x][y]=comp

	while q:
		x,y=q.pop()
		for i in range(4):
			nx=x+dx[i]
			ny=y+dy[i]

			if (nx>=0 and nx<n) and (ny>=0 and ny<m) and (v[nx][ny]==False) and (g[nx][ny]=="".""):
				q.appendleft((nx,ny))
				total+=1
				v[nx][ny]=True
				h[nx][ny]=comp

n, m = map(int, input().split())
h=[[-1 for i in range(m)] for j in range(n)]
g=[]
v=[[False for i in range(m)]for j in range(n)]
for i in range(n):
	g.append(list(input()))
component=[]
for i in range(n):
	for j in range(m):
		if v[i][j]==False and g[i][j]==""."":
			comp=len(component)

			total=0
			bfs(i,j)
			component.append(total)

for x in range(n):
	for y in range(m):
		if g[x][y] == ""*"":
			ans = 0
			s = set()
			for k in range(4):
				nx = x + dx[k]
				ny = y + dy[k]
				if nx >= 0 and nx < n and ny >= 0 and ny < m and g[nx][ny] == ""."":
					s.add(h[nx][ny])
			for itm in s:
				ans += component[itm]
			ans += 1
			ans %= 10
			g[x][y] = str(ans)
for i in range(n):
	print("""".join(g[i]))","def main():
    import sys
    from collections import deque

    input = sys.stdin.read
    data = input().splitlines()

    n, m = map(int, data[0].split())
    field = [list(data[i + 1]) for i in range(n)]

    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]

    component_size = [[0] * m for _ in range(n)]
    visited = [[False] * m for _ in range(n)]

    def bfs(x, y, component_id):
        queue = deque([(x, y)])
        visited[x][y] = True
        size = 0
        
        while queue:
            cx, cy = queue.popleft()
            size += 1
            component_size[cx][cy] = component_id
            
            for dx, dy in directions:
                nx, ny = cx + dx, cy + dy
                if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and field[nx][ny] == '.':
                    visited[nx][ny] = True
                    queue.append((nx, ny))

        return size

    size_map = {}
    counter = 1

    for i in range(n):
        for j in range(m):
            if field[i][j] == '.' and not visited[i][j]:
                component_size_value = bfs(i, j, counter)
                size_map[counter] = component_size_value
                counter += 1

    output = [[''] * m for _ in range(n)]
    
    for i in range(n):
        for j in range(m):
            if field[i][j] == '.':
                output[i][j] = '.'
            else:

                seen_components = set()
                for dx, dy in directions:
                    nx, ny = i + dx, j + dy
                    if 0 <= nx < n and 0 <= ny < m and field[nx][ny] == '.':
                        component_id = component_size[nx][ny]
                        seen_components.add(component_id)

                total_size = sum(size_map[comp_id] for comp_id in seen_components)
                output[i][j] = str(total_size % 10)

    for row in output:
        print(''.join(row))

if __name__ == ""__main__"":
    main()"
553,B,Kyoya and Permutation,PROGRAMMING,"['binary search', 'combinatorics', 'constructive algorithms', 'greedy', 'implementation', 'math']","Let's define the permutation of length *n* as an array *p*<==<=[*p*1,<=*p*2,<=...,<=*p**n*] consisting of *n* distinct integers from range from 1 to *n*. We say that this permutation maps value 1 into the value *p*1, value 2 into the value *p*2 and so on.

Kyota Ootori has just learned about cyclic representation of a permutation. A cycle is a sequence of numbers such that each element of this sequence is being mapped into the next element of this sequence (and the last element of the cycle is being mapped into the first element of the cycle). The cyclic representation is a representation of *p* as a collection of cycles forming *p*. For example, permutation *p*<==<=[4,<=1,<=6,<=2,<=5,<=3] has a cyclic representation that looks like (142)(36)(5) because 1 is replaced by 4, 4 is replaced by 2, 2 is replaced by 1, 3 and 6 are swapped, and 5 remains in place. 

Permutation may have several cyclic representations, so Kyoya defines the standard cyclic representation of a permutation as follows. First, reorder the elements within each cycle so the largest element is first. Then, reorder all of the cycles so they are sorted by their first element. For our example above, the standard cyclic representation of [4,<=1,<=6,<=2,<=5,<=3] is (421)(5)(63).

Now, Kyoya notices that if we drop the parenthesis in the standard cyclic representation, we get another permutation! For instance, [4,<=1,<=6,<=2,<=5,<=3] will become [4,<=2,<=1,<=5,<=6,<=3].

Kyoya notices that some permutations don't change after applying operation described above at all. He wrote all permutations of length *n* that do not change in a list in lexicographic order. Unfortunately, his friend Tamaki Suoh lost this list. Kyoya wishes to reproduce the list and he needs your help. Given the integers *n* and *k*, print the permutation that was *k*-th on Kyoya's list.","The first line will contain two integers *n*, *k* (1<=≤<=*n*<=≤<=50, 1<=≤<=*k*<=≤<=*min*{1018,<=*l*} where *l* is the length of the Kyoya's list).","Print *n* space-separated integers, representing the permutation that is the answer for the question.","['4 3\n', '10 1\n']","['1 3 2 4\n', '1 2 3 4 5 6 7 8 9 10\n']","The standard cycle representation is (1)(32)(4), which after removing parenthesis gives us the original permutation. The first permutation on the list would be [1, 2, 3, 4], while the second permutation would be [1, 2, 4, 3].",OK,"arr = [1] * 51

for i in range(2, 51):
    arr[i] = arr[i - 1] + arr[i - 2]

ans = []

def generate(i, n, to):
    if i == n:
        assert to == 1
        print("" "".join(map(str, ans)))
        return
    if i + 1 == n:
        ans.append(n)
        generate(i + 1, n, to)
        return
    if arr[n - i - 1] < to:
        ans.append(i + 2)
        ans.append(i + 1)
        generate(i + 2, n, to - arr[n - i - 1])
    else:
        ans.append(i + 1)
        generate(i + 1, n, to)

n, k = map(int, input().split())
generate(0, n, k)","def factorial(n):

    if n == 0 or n == 1:
        return 1
    result = 1
    for i in range(2, n + 1):
        result *= i
    return result

def find_fixed_permutations(n):

    if n == 1:
        return [[1]]
    
    permutations = []
    for i in range(1, n + 1):
        sub_permutations = find_fixed_permutations(n - 1)
        for perm in sub_permutations:
            new_perm = perm[:i - 1] + [n] + perm[i - 1:]
            permutations.append(new_perm)
    
    return permutations

def generate_fixed_permutations(n):

    fixed_permutations = find_fixed_permutations(n)
    return sorted(set(tuple(perm) for perm in fixed_permutations))

def get_kth_permutation(n, k):

    fixed_permutations = generate_fixed_permutations(n)
    k_index = k - 1
    return fixed_permutations[k_index]

if __name__ == '__main__':
    import sys
    input_data = sys.stdin.read().strip().split('\n')
    
    results = []
    for line in input_data:
        n, k = map(int, line.split())
        result_permutation = get_kth_permutation(n, k)
        results.append(' '.join(map(str, result_permutation)))
    
    print('\n'.join(results))"
954,D,Fight Against Traffic,PROGRAMMING,"['dfs and similar', 'graphs', 'shortest paths']","Little town Nsk consists of *n* junctions connected by *m* bidirectional roads. Each road connects two distinct junctions and no two roads connect the same pair of junctions. It is possible to get from any junction to any other junction by these roads. The distance between two junctions is equal to the minimum possible number of roads on a path between them.

In order to improve the transportation system, the city council asks mayor to build one new road. The problem is that the mayor has just bought a wonderful new car and he really enjoys a ride from his home, located near junction *s* to work located near junction *t*. Thus, he wants to build a new road in such a way that the distance between these two junctions won't decrease. 

You are assigned a task to compute the number of pairs of junctions that are not connected by the road, such that if the new road between these two junctions is built the distance between *s* and *t* won't decrease.","The firt line of the input contains integers *n*, *m*, *s* and *t* (2<=≤<=*n*<=≤<=1000, 1<=≤<=*m*<=≤<=1000, 1<=≤<=*s*,<=*t*<=≤<=*n*, *s*<=≠<=*t*) — the number of junctions and the number of roads in Nsk, as well as the indices of junctions where mayors home and work are located respectively. The *i*-th of the following *m* lines contains two integers *u**i* and *v**i* (1<=≤<=*u**i*,<=*v**i*<=≤<=*n*, *u**i*<=≠<=*v**i*), meaning that this road connects junctions *u**i* and *v**i* directly. It is guaranteed that there is a path between any two junctions and no two roads connect the same pair of junctions.","Print one integer — the number of pairs of junctions not connected by a direct road, such that building a road between these two junctions won't decrease the distance between junctions *s* and *t*.","['5 4 1 5\n1 2\n2 3\n3 4\n4 5\n', '5 4 3 5\n1 2\n2 3\n3 4\n4 5\n', '5 6 1 5\n1 2\n1 3\n1 4\n4 5\n3 5\n2 5\n']","['0\n', '5\n', '3\n']",none,WRONG_ANSWER,"from collections import defaultdict
from heapq import heappop, heappush
n, m, s, t = list(map(int, input().split()))

graph = defaultdict(set)
for _ in range(m):
    u, v = list(map(int, input().split()))
    graph[u - 1].add((v - 1, 1))
    graph[v - 1].add((u - 1, 1))

total_edges = [((n*(n-1))//2) - m]

queue = [(s - 1, 0)]
distance = [float('inf')]*n
distance[s - 1] = 0
while queue:
    size = len(queue)
    for _ in range(size):
        node, distance_so_far = heappop(queue)
        for nei, weight in graph[node]:
            if distance_so_far + weight < distance[nei]:
                distance[nei] = distance_so_far + weight
                heappush(queue, (nei, distance[nei]))

min_distance = distance[t - 1]

total_min_paths = [0]
def dfs(cur_node = s - 1, parent = -1, depth = 0):

    if cur_node == t - 1:

        if depth == min_distance:
            total_min_paths[0] += 1
        return

    for nei, weight in graph[cur_node]:
        if nei != parent:
            dfs(nei, cur_node, depth + 1)

dfs()
nodes = min_distance + 1
max_possible = ((nodes*(nodes-1))//2) - min_distance
deductable = (total_min_paths[0]*max_possible) - ((total_min_paths[0]) - 1)
total_edges[0] -= deductable
print(total_edges[0])","def bfs(graph, start):
    from collections import deque
    queue = deque([start])
    distances = {start: 0}
    
    while queue:
        node = queue.popleft()
        for neighbor in graph[node]:
            if neighbor not in distances:
                distances[neighbor] = distances[node] + 1
                queue.append(neighbor)
    return distances

def count_safe_pairs(n, m, s, t, roads):

    graph = {i: set() for i in range(1, n + 1)}
    for u, v in roads:
        graph[u].add(v)
        graph[v].add(u)

    dist_from_s = bfs(graph, s)
    dist_from_t = bfs(graph, t)
    current_distance = dist_from_s[t]

    count = 0

    for i in range(1, n + 1):
        for j in range(i + 1, n + 1):
            if j not in graph[i]:

                if (dist_from_s[i] + 1 + dist_from_t[j] >= current_distance) and \
                   (dist_from_s[j] + 1 + dist_from_t[i] >= current_distance):
                    count += 1
    return count

import sys

if __name__ == ""__main__"":
    input_data = sys.stdin.read().strip().split('\n')
    n, m, s, t = map(int, input_data[0].split())
    roads = [tuple(map(int, line.split())) for line in input_data[1:m + 1]]

    result = count_safe_pairs(n, m, s, t, roads)
    print(result)"
582,A,GCD Table,PROGRAMMING,"['constructive algorithms', 'greedy', 'number theory']","The GCD table *G* of size *n*<=×<=*n* for an array of positive integers *a* of length *n* is defined by formula 

Let us remind you that the greatest common divisor (GCD) of two positive integers *x* and *y* is the greatest integer that is divisor of both *x* and *y*, it is denoted as . For example, for array *a*<==<={4,<=3,<=6,<=2} of length 4 the GCD table will look as follows:

Given all the numbers of the GCD table *G*, restore array *a*.","The first line contains number *n* (1<=≤<=*n*<=≤<=500) — the length of array *a*. The second line contains *n*2 space-separated numbers — the elements of the GCD table of *G* for array *a*. 

All the numbers in the table are positive integers, not exceeding 109. Note that the elements are given in an arbitrary order. It is guaranteed that the set of the input data corresponds to some array *a*.","In the single line print *n* positive integers — the elements of array *a*. If there are multiple possible solutions, you are allowed to print any of them.","['4\n2 1 2 3 4 3 2 6 1 1 2 2 1 2 3 2\n', '1\n42\n', '2\n1 1 1 1\n']","['4 3 6 2', '42 ', '1 1 ']",none,OK,"import math as ma
import sys
input=sys.stdin.readline

def fu(b):
    for i in b:
        if b[i]!=0:
            return i
    return -1

def gcd(a,b):
    if a%b==0:
        return b
    else:
        return gcd(b,a%b)

n=int(input())
a=list(map(int,input().split()))
a.sort(reverse=True)
b={}
for i in range(n*n):
    if a[i] in b.keys():
        b[a[i]]+=1
    else:
        b[a[i]]=1
c=[]
for i in b:
    c.append(i)
    b[i]-=1
    break
while 1>0:
    if len(c)<n:
        a=fu(b)
        if a==-1:
            break
        else:
            b[a]-=1
            for i in range(len(c)):
                b[gcd(a,c[i])]-=2
            c.append(a)
    else:
        break

print(*c)","import sys
from math import gcd
from collections import Counter

def restore_array(n, gcd_table):

    count = Counter(gcd_table)

    a = []

    max_gcd = max(gcd_table)
    a.append(max_gcd)
    count[max_gcd] -= 1

    for _ in range(n - 1):

        for candidate in count.keys():
            if count[candidate] > 0:

                current_gcd = candidate
                for num in a:
                    current_gcd = gcd(current_gcd, num)

                if current_gcd > 1:
                    a.append(candidate)
                    count[candidate] -= 1
                    break
    return a

def main():

    input_data = sys.stdin.read().strip().splitlines()
    n = int(input_data[0])
    gcd_table = list(map(int, input_data[1].split()))

    result = restore_array(n, gcd_table)

    print(' '.join(map(str, result)))

if __name__ == ""__main__"":
    main()"
622,C,Not Equal on a Segment,PROGRAMMING,"['data structures', 'implementation']","You are given array *a* with *n* integers and *m* queries. The *i*-th query is given with three integers *l**i*,<=*r**i*,<=*x**i*.

For the *i*-th query find any position *p**i* (*l**i*<=≤<=*p**i*<=≤<=*r**i*) so that *a**p**i*<=≠<=*x**i*.","The first line contains two integers *n*,<=*m* (1<=≤<=*n*,<=*m*<=≤<=2·105) — the number of elements in *a* and the number of queries.

The second line contains *n* integers *a**i* (1<=≤<=*a**i*<=≤<=106) — the elements of the array *a*.

Each of the next *m* lines contains three integers *l**i*,<=*r**i*,<=*x**i* (1<=≤<=*l**i*<=≤<=*r**i*<=≤<=*n*,<=1<=≤<=*x**i*<=≤<=106) — the parameters of the *i*-th query.","Print *m* lines. On the *i*-th line print integer *p**i* — the position of any number not equal to *x**i* in segment [*l**i*,<=*r**i*] or the value <=-<=1 if there is no such number.",['6 4\n1 2 1 1 3 5\n1 4 1\n2 6 2\n3 4 1\n3 4 2\n'],['2\n6\n-1\n4\n'],none,TIME_LIMIT_EXCEEDED,"class number:
    def __init__(self,n,num):
        self.n = n
        self.num = num

def upquicksort(sta,l,r):
    if l >= r:
        return
    i = l
    j = r
    temp = sta[i]
    while i != j:
        while j > i and sta[j].n > temp.n:
            j -= 1
        if j > i:
            sta[i] = sta[j]
            i += 1
        while j > i and sta[i].n < temp.n:
            i += 1
        if j > i:
            sta[j] = sta[i]
            j -= 1
    sta[i] = temp
    upquicksort(sta,l,i-1)
    upquicksort(sta,i+1,r)
    return

n,m = map(int,input().split())
a1 = list(map(int,input().split()))
a = []
for i in range(len(a1)):
    a.append(number(a1[i],i+1))
for i in range(m):
    b = list(map(int,input().split()))
    c = a[b[0]-1:b[1]]
    upquicksort(c,0,len(c)-1)
    if c[0].n != b[2]:
        print (c[0].num)
    elif c[-1].n != b[2]:
        print (c[-1].num)
    else:
        print (-1)","def find_non_equal_positions(n, m, a, queries):
    results = []
    for query in queries:
        l, r, x = query
        found = False

        for i in range(l - 1, r):
            if a[i] != x:
                results.append(i + 1)
                found = True
                break
        
        if not found:
            results.append(-1)
    
    return results

n, m = map(int, input().split())
a = list(map(int, input().split()))
queries = [tuple(map(int, input().split())) for _ in range(m)]

results = find_non_equal_positions(n, m, a, queries)

for result in results:
    print(result)"
926,E,Merge Equal Elements,PROGRAMMING,"['constructive algorithms', 'data structures']","You are given a sequence of positive integers *a*1,<=*a*2,<=...,<=*a**n*. 

While possible, you perform the following operation: find a pair of equal consecutive elements. If there are more than one such pair, find the leftmost (with the smallest indices of elements). If the two integers are equal to *x*, delete both and insert a single integer *x*<=+<=1 on their place. This way the number of elements in the sequence is decreased by 1 on each step. 

You stop performing the operation when there is no pair of equal consecutive elements.

For example, if the initial sequence is [5,<=2,<=1,<=1,<=2,<=2], then after the first operation you get [5,<=2,<=2,<=2,<=2], after the second — [5,<=3,<=2,<=2], after the third — [5,<=3,<=3], and finally after the fourth you get [5,<=4]. After that there are no equal consecutive elements left in the sequence, so you stop the process.

Determine the final sequence after you stop performing the operation.","The first line contains a single integer *n* (2<=≤<=*n*<=≤<=2·105) — the number of elements in the sequence.

The second line contains the sequence of integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=109).","In the first line print a single integer *k* — the number of elements in the sequence after you stop performing the operation. 

In the second line print *k* integers — the sequence after you stop performing the operation.","['6\n5 2 1 1 2 2\n', '4\n1000000000 1000000000 1000000000 1000000000\n', '7\n4 10 22 11 12 5 6\n']","['2\n5 4 ', '1\n1000000002 ', '7\n4 10 22 11 12 5 6 ']","The first example is described in the statements.

In the second example the initial sequence is [1000000000, 1000000000, 1000000000, 1000000000]. After the first operation the sequence is equal to [1000000001, 1000000000, 1000000000]. After the second operation the sequence is [1000000001, 1000000001]. After the third operation the sequence is [1000000002].

In the third example there are no two equal consecutive elements initially, so the sequence does not change.",COMPILATION_ERROR,"n = int(input())
a = list(map(int, input().split()))
p = 1
def f(n, a):
   for _ in range(n):
    od = True
	x = len(a)   
    for g in range(max(p - 1, 0),len(a) - 1):
        if a[g] == a[g + 1]:
            od = False
            p = g
            s = int(a[g])
            del a[g]
            a[g] =str(s + 1)
            break
    if od:
        print(x)
        print(' '.join(list(map(str, a))))
        break
f(n, a)","def reduce_sequence(n, sequence):

    result = []

    for num in sequence:

        if result and result[-1] == num:

            last_num = result.pop()

            new_num = last_num + 1

            result.append(new_num)
        else:

            result.append(num)

    k = len(result)
    return k, result

input_data = [
    '6\n5 2 1 1 2 2\n',
    '4\n1000000000 1000000000 1000000000 1000000000\n',
    '7\n4 10 22 11 12 5 6\n'
]

for data in input_data:
    lines = data.splitlines()
    n = int(lines[0])
    sequence = list(map(int, lines[1].split()))

    k, final_sequence = reduce_sequence(n, sequence)

    print(k)
    print(' '.join(map(str, final_sequence)))"
0,none,none,none,['none'],"In the year of $30XX$ participants of some world programming championship live in a single large hotel. The hotel has $n$ floors. Each floor has $m$ sections with a single corridor connecting all of them. The sections are enumerated from $1$ to $m$ along the corridor, and all sections with equal numbers on different floors are located exactly one above the other. Thus, the hotel can be represented as a rectangle of height $n$ and width $m$. We can denote sections with pairs of integers $(i, j)$, where $i$ is the floor, and $j$ is the section number on the floor.

The guests can walk along the corridor on each floor, use stairs and elevators. Each stairs or elevator occupies all sections $(1, x)$, $(2, x)$, $\ldots$, $(n, x)$ for some $x$ between $1$ and $m$. All sections not occupied with stairs or elevators contain guest rooms. It takes one time unit to move between neighboring sections on the same floor or to move one floor up or down using stairs. It takes one time unit to move up to $v$ floors in any direction using an elevator. You can assume you don't have to wait for an elevator, and the time needed to enter or exit an elevator is negligible.

You are to process $q$ queries. Each query is a question ""what is the minimum time needed to go from a room in section $(x_1, y_1)$ to a room in section $(x_2, y_2)$?""","The first line contains five integers $n, m, c_l, c_e, v$ ($2 \leq n, m \leq 10^8$, $0 \leq c_l, c_e \leq 10^5$, $1 \leq c_l + c_e \leq m - 1$, $1 \leq v \leq n - 1$) — the number of floors and section on each floor, the number of stairs, the number of elevators and the maximum speed of an elevator, respectively.

The second line contains $c_l$ integers $l_1, \ldots, l_{c_l}$ in increasing order ($1 \leq l_i \leq m$), denoting the positions of the stairs. If $c_l = 0$, the second line is empty.

The third line contains $c_e$ integers $e_1, \ldots, e_{c_e}$ in increasing order, denoting the elevators positions in the same format. It is guaranteed that all integers $l_i$ and $e_i$ are distinct.

The fourth line contains a single integer $q$ ($1 \leq q \leq 10^5$) — the number of queries.

The next $q$ lines describe queries. Each of these lines contains four integers $x_1, y_1, x_2, y_2$ ($1 \leq x_1, x_2 \leq n$, $1 \leq y_1, y_2 \leq m$) — the coordinates of starting and finishing sections for the query. It is guaranteed that the starting and finishing sections are distinct. It is also guaranteed that these sections contain guest rooms, i. e. $y_1$ and $y_2$ are not among $l_i$ and $e_i$.","Print $q$ integers, one per line — the answers for the queries.",['5 6 1 1 3\n2\n5\n3\n1 1 5 6\n1 3 5 4\n3 3 5 3\n'],['7\n5\n4\n'],"In the first query the optimal way is to go to the elevator in the 5-th section in four time units, use it to go to the fifth floor in two time units and go to the destination in one more time unit.

In the second query it is still optimal to use the elevator, but in the third query it is better to use the stairs in the section 2.",TIME_LIMIT_EXCEEDED,"import bisect
N,M,L,E,V = map(int,input().split())
sts = list(map(int,input().split()))
els = list(map(int,input().split()))

def solve(x1,y1,x2,y2):
    if x1 == x2:
        return abs(y1-y2)
    ans = N+M+9999
    if y1 > y2: y1,y2 = y2,y1
    if sts:
        i = bisect.bisect(sts,y1)
        if i == L:
            st = sts[-1]
            t = abs(st - y1) + abs(st - y2) + abs(x1 - x2)
            ans = min(ans, t)
        else:
            st = sts[i]
            t = abs(st - y1) + abs(st - y2) + abs(x1 - x2)
            ans = min(ans, t)
            if i < L-1:
                st = sts[i+1]
                t = abs(st - y1) + abs(st - y2) + abs(x1 - x2)
                ans = min(ans, t)
    if els:
        i = bisect.bisect(els,y1)
        if i == E:
            el = els[-1]
            t = abs(el - y1) + abs(el - y2) + (abs(x1-x2)-1)//V + 1
            ans = min(ans, t)
        else:
            el = els[i]
            t = abs(el - y1) + abs(el - y2) + (abs(x1-x2)-1)//V + 1
            ans = min(ans, t)
            if i < E-1:
                el = els[i+1]
                t = abs(el - y1) + abs(el - y2) + (abs(x1-x2)-1)//V + 1
                ans = min(ans, t)
    return ans

Q = int(input())
for i in range(Q):
    print(solve(*tuple(map(int,input().split()))))","def minimum_time_to_travel(n, m, c_l, c_e, v, stairs, elevators, queries):
    results = []

    stair_set = set(stairs)
    elevator_set = set(elevators)

    for x1, y1, x2, y2 in queries:

        min_time = float('inf')

        if x1 == x2:
            min_time = abs(y2 - y1)

        for stair in stairs:
            time_to_stair = abs(y1 - stair) + abs(x1 - x2) + abs(y2 - stair)
            min_time = min(min_time, time_to_stair + (x2 - x1) if x2 > x1 else (x1 - x2))

        for elevator in elevators:
            floors_moved = abs(x2 - x1)
            elevator_time = (floors_moved + (abs(y1 - elevator) + abs(y2 - elevator)) // v)
            min_time = min(min_time, elevator_time)

        results.append(min_time)

    return results

import sys

input_data = sys.stdin.read().strip().split('\n')
first_line = list(map(int, input_data[0].split()))
n, m, c_l, c_e, v = first_line
stairs = list(map(int, input_data[1].split())) if c_l > 0 else []
elevators = list(map(int, input_data[2].split())) if c_e > 0 else []
q = int(input_data[3])
queries = [list(map(int, input_data[i + 4].split())) for i in range(q)]

results = minimum_time_to_travel(n, m, c_l, c_e, v, stairs, elevators, queries)
for result in results:
    print(result)"
353,A,Domino,PROGRAMMING,"['implementation', 'math']","Valera has got *n* domino pieces in a row. Each piece consists of two halves — the upper one and the lower one. Each of the halves contains a number from 1 to 6. Valera loves even integers very much, so he wants the sum of the numbers on the upper halves and the sum of the numbers on the lower halves to be even.

To do that, Valera can rotate the dominoes by 180 degrees. After the rotation the upper and the lower halves swap places. This action takes one second. Help Valera find out the minimum time he must spend rotating dominoes to make his wish come true.","The first line contains integer *n* (1<=≤<=*n*<=≤<=100), denoting the number of dominoes Valera has. Next *n* lines contain two space-separated integers *x**i*,<=*y**i* (1<=≤<=*x**i*,<=*y**i*<=≤<=6). Number *x**i* is initially written on the upper half of the *i*-th domino, *y**i* is initially written on the lower half.","Print a single number — the minimum required number of seconds. If Valera can't do the task in any time, print <=-<=1.","['2\n4 2\n6 4\n', '1\n2 3\n', '3\n1 4\n2 3\n4 4\n']","['0\n', '-1\n', '1\n']","In the first test case the sum of the numbers on the upper halves equals 10 and the sum of the numbers on the lower halves equals 6. Both numbers are even, so Valera doesn't required to do anything.

In the second sample Valera has only one piece of domino. It is written 3 on the one of its halves, therefore one of the sums will always be odd.

In the third case Valera can rotate the first piece, and after that the sum on the upper halves will be equal to 10, and the sum on the lower halves will be equal to 8.",WRONG_ANSWER,"def main():
    n = int(input())
    l = [0, 0, 0, 0]
    for _ in range(n):
        x, y = map(int, input().split())
        l[(x & 1) * 2 + (y & 1)] ^= 1
    print((0, 0, -1, -1, -1, -1, 1, 0)[l[1] * 4 + l[2] * 2 + l[3]])

if __name__ == '__main__':
    main()","n = int(input())

upper_sum = 0
lower_sum = 0
odd_count = 0

for _ in range(n):
    x, y = map(int, input().split())
    upper_sum += x
    lower_sum += y

    if x % 2 != 0:
        odd_count += 1

if upper_sum % 2 == 0 and lower_sum % 2 == 0:
    print(0)

elif odd_count == 0:
    print(-1)

else:
    print(1)"
177,E1,Space Voyage,PROGRAMMING,['binary search'],"The Smart Beaver from ABBYY plans a space travel on an ultramodern spaceship. During the voyage he plans to visit *n* planets. For planet *i* *a**i* is the maximum number of suitcases that an alien tourist is allowed to bring to the planet, and *b**i* is the number of citizens on the planet.

The Smart Beaver is going to bring some presents from ABBYY to the planets he will be visiting. The presents are packed in suitcases, *x* presents in each. The Beaver will take to the ship exactly *a*1<=+<=...<=+<=*a**n* suitcases.

As the Beaver lands on the *i*-th planet, he takes *a**i* suitcases and goes out. On the first day on the planet the Beaver takes a walk and gets to know the citizens. On the second and all subsequent days the Beaver gives presents to the citizens — each of the *b**i* citizens gets one present per day. The Beaver leaves the planet in the evening of the day when the number of presents left is strictly less than the number of citizens (i.e. as soon as he won't be able to give away the proper number of presents the next day). He leaves the remaining presents at the hotel.

The Beaver is going to spend exactly *c* days traveling. The time spent on flights between the planets is considered to be zero. In how many ways can one choose the positive integer *x* so that the planned voyage will take exactly *c* days?","The first input line contains space-separated integers *n* and *c* — the number of planets that the Beaver is going to visit and the number of days he is going to spend traveling, correspondingly.

The next *n* lines contain pairs of space-separated integers *a**i*,<=*b**i* (1<=≤<=*i*<=≤<=*n*) — the number of suitcases he can bring to the *i*-th planet and the number of citizens of the *i*-th planet, correspondingly.

The input limitations for getting 30 points are: 
 -  1<=≤<=*n*<=≤<=100 -  1<=≤<=*a**i*<=≤<=100 -  1<=≤<=*b**i*<=≤<=100 -  1<=≤<=*c*<=≤<=100 
The input limitations for getting 100 points are: 
 -  1<=≤<=*n*<=≤<=104 -  0<=≤<=*a**i*<=≤<=109 -  1<=≤<=*b**i*<=≤<=109 -  1<=≤<=*c*<=≤<=109 
Due to possible overflow, it is recommended to use the 64-bit arithmetic. In some solutions even the 64-bit arithmetic can overflow. So be careful in calculations!","Print a single number *k* — the number of ways to choose *x* so as to travel for exactly *c* days. If there are infinitely many possible values of *x*, print -1.

Please do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use cin, cout streams or the %I64d specifier.",['2 5\n1 5\n2 4\n'],['1\n'],"In the first example there is only one suitable value *x* = 5. Then the Beaver takes 1 suitcase with 5 presents to the first planet. Here he spends 2 days: he hangs around on the first day, and he gives away five presents on the second day. He takes 2 suitcases with 10 presents to the second planet. Here he spends 3 days — he gives away 4 presents on the second and the third days and leaves the remaining 2 presents at the hotel. In total, the Beaver spends 5 days traveling.

For *x* = 4 or less the Beaver won't have enough presents for the second day on the first planet, so the voyage will end too soon. For *x* = 6 and more the Beaver will spend at least one more day on the second planet, and the voyage will take too long.",WRONG_ANSWER,"def binary_search(arr, x):
    arr.sort()
    low = 0
    high = len(arr) - 1
    mid = 0
    while low <= high:

        mid = low + (high-low)//2
        if arr[mid] < x:
            low = mid + 1
        elif arr[mid] > x:
            high = mid - 1
        else:
            return mid
    return -1
def ternary_search(l, r, key, ar):
    if (r >= l):
        mid1 = l + (r - l) // 3
        mid2 = r - (r - l) // 3
        if (ar[mid1] == key):
            return mid1
        if (ar[mid2] == key):
            return mid2
        if (key < ar[mid1]):
            return ternary_search(l, mid1 - 1, key, ar)
        elif (key > ar[mid2]):
            return ternary_search(mid2 + 1, r, key, ar)
        else:
            return ternary_search(mid1 + 1,
                                 mid2 - 1, key, ar)
    return -1
def cheaker(x):
    cnt= 0
    for i in range(n):
        cnt+= ((a[i]*x)//b[i] +1)
    return cnt

def binary_search_answer(low,high):

    while((high - low )> 0):
        mid = (high+low)//2
        if cheaker(mid)<c:
            low= mid+1
        else:
            high = mid

    if cheaker(low)==c :
        return low
    else:
        return -1
def binary_search_answer2(low,high):

    while((high - low )> 0):
        mid = (high+low+1)//2
        if cheaker(mid)<=c:
            low= mid
        else:
            high = mid-1

    if cheaker(low )==c:
        return low
    else:
        return -1

if __name__ == ""__main__"":

    n,c= map(int,input().split())
    a=[0 for i in range(n)]
    b= [0 for i in range(n)]
    flag=True
    for j in range(n):
        a[j],b[j]= map(int,input().split())
        if a[j]!=0:
            flag=False
    z = 10**9
    if flag and n==c :
        print(0)
    elif  n== c:
        print(min(b)-1)
    elif flag :
        print(-1)

    elif n<c:
        an1=binary_search_answer(1,10**18)
        an2= binary_search_answer2(1,10**18)
        if  an1 ==-1 or an2 == -1:
            print(0)
        else:
            print(an2-an1 +1)
    else:
        print(0)","def count_ways(n, c, planets):

    def required_days(x):
        total_days = 0
        for a_i, b_i in planets:
            total_days += 1
            presents = a_i * x
            if presents < b_i:
                return float('inf')

            total_days += presents // b_i
            if presents % b_i > 0:
                total_days += 1
        return total_days

    left, right = 1, 10**18
    while left < right:
        mid = (left + right) // 2
        days = required_days(mid)
        if days < c:
            left = mid + 1
        else:
            right = mid

    days_needed = required_days(left)
    if days_needed > c:
        return 0

    right_days_needed = required_days(left + 1)
    if right_days_needed == c:
        return -1

    count = 0
    while required_days(left + count) == c:
        count += 1

    return count

import sys
input = sys.stdin.read
data = input().strip().split('\n')

n, c = map(int, data[0].split())
planets = [tuple(map(int, line.split())) for line in data[1:n + 1]]

result = count_ways(n, c, planets)
print(result)"
291,A,Spyke Talks,PROGRAMMING,"['*special', 'implementation', 'sortings']","Polycarpus is the director of a large corporation. There are *n* secretaries working for the corporation, each of them corresponds via the famous Spyke VoIP system during the day. We know that when two people call each other via Spyke, the Spyke network assigns a unique ID to this call, a positive integer session number.

One day Polycarpus wondered which secretaries are talking via the Spyke and which are not. For each secretary, he wrote out either the session number of his call or a 0 if this secretary wasn't talking via Spyke at that moment.

Help Polycarpus analyze these data and find out the number of pairs of secretaries that are talking. If Polycarpus has made a mistake in the data and the described situation could not have taken place, say so.

Note that the secretaries can correspond via Spyke not only with each other, but also with the people from other places. Also, Spyke conferences aren't permitted — that is, one call connects exactly two people.","The first line contains integer *n* (1<=≤<=*n*<=≤<=103) — the number of secretaries in Polycarpus's corporation. The next line contains *n* space-separated integers: *id*1,<=*id*2,<=...,<=*id**n* (0<=≤<=*id**i*<=≤<=109). Number *id**i* equals the number of the call session of the *i*-th secretary, if the secretary is talking via Spyke, or zero otherwise.

Consider the secretaries indexed from 1 to *n* in some way.","Print a single integer — the number of pairs of chatting secretaries, or -1 if Polycarpus's got a mistake in his records and the described situation could not have taken place.","['6\n0 1 7 1 7 10\n', '3\n1 1 1\n', '1\n0\n']","['2\n', '-1\n', '0\n']","In the first test sample there are two Spyke calls between secretaries: secretary 2 and secretary 4, secretary 3 and secretary 5.

In the second test sample the described situation is impossible as conferences aren't allowed.",OK,"def cocktail_sort(a):
    n = len(a)
    swapped = True
    start = 0
    end = n-1
    while (swapped == True):

        swapped = False

        for i in range (start, end):
            if (a[i] > a[i + 1]) :
                a[i], a[i + 1]= a[i + 1], a[i]
                swapped = True

        if (swapped == False):
            break

        swapped = False

        end = end-1

        for i in range(end-1, start-1, -1):
            if (a[i] > a[i + 1]):
                a[i], a[i + 1] = a[i + 1], a[i]
                swapped = True

        start = start + 1

n = int(input())
x = list(map(int, input().split()))

answer = 0

cocktail_sort(x)

for i in range(len(x)-1):
	if (i+2)>= n:
		if (x[i] == x[i+1]) and (x[i] != 0):
			answer = answer + 1
			i = i+1
	else:
	
		if x[i] == x[i+1] and x[i] != 0  and x[i] !=x[i+2]:
			answer = answer + 1
			i = i + 1
			
		elif x[i] == x[i+1] and  x[i] == x[i+2] and x[i]!= 0:
			answer = -1
			break
	
print(answer)","def count_pairs(n, ids):
    call_count = {}

    for call_id in ids:
        if call_id != 0:
            if call_id in call_count:
                call_count[call_id] += 1
            else:
                call_count[call_id] = 1
    
    pairs = 0

    for count in call_count.values():
        if count % 2 != 0:
            return -1
        pairs += count // 2
    
    return pairs

inputs = ['6\n0 1 7 1 7 10\n', '3\n1 1 1\n', '1\n0\n']

for input_str in inputs:
    lines = input_str.strip().split('\n')
    n = int(lines[0])
    ids = list(map(int, lines[1].split()))
    result = count_pairs(n, ids)
    print(result)"
370,A,"Rook, Bishop and King",PROGRAMMING,"['graphs', 'math', 'shortest paths']","Little Petya is learning to play chess. He has already learned how to move a king, a rook and a bishop. Let us remind you the rules of moving chess pieces. A chessboard is 64 square fields organized into an 8<=×<=8 table. A field is represented by a pair of integers (*r*,<=*c*) — the number of the row and the number of the column (in a classical game the columns are traditionally indexed by letters). Each chess piece takes up exactly one field. To make a move is to move a chess piece, the pieces move by the following rules:
 -  A rook moves any number of fields horizontally or vertically. -  A bishop moves any number of fields diagonally. -  A king moves one field in any direction — horizontally, vertically or diagonally. 
Petya is thinking about the following problem: what minimum number of moves is needed for each of these pieces to move from field (*r*1,<=*c*1) to field (*r*2,<=*c*2)? At that, we assume that there are no more pieces besides this one on the board. Help him solve this problem.","The input contains four integers *r*1,<=*c*1,<=*r*2,<=*c*2 (1<=≤<=*r*1,<=*c*1,<=*r*2,<=*c*2<=≤<=8) — the coordinates of the starting and the final field. The starting field doesn't coincide with the final one.

You can assume that the chessboard rows are numbered from top to bottom 1 through 8, and the columns are numbered from left to right 1 through 8.","Print three space-separated integers: the minimum number of moves the rook, the bishop and the king (in this order) is needed to move from field (*r*1,<=*c*1) to field (*r*2,<=*c*2). If a piece cannot make such a move, print a 0 instead of the corresponding number.","['4 3 1 6\n', '5 5 5 6\n']","['2 1 3\n', '1 0 1\n']",none,OK,"def stessocolore(x1,y1,x2,y2):
    if (x1+y1)%2 == (x2+y2)%2:
        return True
    else:
        return False
x1, y1, x2, y2 = map(int, input().split())
if x1 == x2 or y1 == y2:
    rook = 1
else:
    rook = 2
king = max([abs(x1-x2),abs(y1-y2)])
if stessocolore(x1,y1,x2,y2):
    if (x1-y1) == (x2-y2) or x1+y1 == x2+y2:
        bish = 1
    else:
        bish = 2
else:
    bish = 0

print(rook, bish, king)","def minimum_moves(r1, c1, r2, c2):

    if r1 == r2 or c1 == c2:
        rook_moves = 1
    else:
        rook_moves = 2

    if (r1 + c1) % 2 != (r2 + c2) % 2:
        bishop_moves = 0
    elif abs(r1 - r2) == abs(c1 - c2):
        bishop_moves = 1
    else:
        bishop_moves = 2

    king_moves = max(abs(r1 - r2), abs(c1 - c2))

    return rook_moves, bishop_moves, king_moves

input_data = input().strip().split()
r1, c1, r2, c2 = map(int, input_data)

rook, bishop, king = minimum_moves(r1, c1, r2, c2)

print(rook, bishop, king)"
475,B,Strongly Connected City,PROGRAMMING,"['brute force', 'dfs and similar', 'graphs', 'implementation']","Imagine a city with *n* horizontal streets crossing *m* vertical streets, forming an (*n*<=-<=1)<=×<=(*m*<=-<=1) grid. In order to increase the traffic flow, mayor of the city has decided to make each street one way. This means in each horizontal street, the traffic moves only from west to east or only from east to west. Also, traffic moves only from north to south or only from south to north in each vertical street. It is possible to enter a horizontal street from a vertical street, or vice versa, at their intersection.

The mayor has received some street direction patterns. Your task is to check whether it is possible to reach any junction from any other junction in the proposed street direction pattern.","The first line of input contains two integers *n* and *m*, (2<=≤<=*n*,<=*m*<=≤<=20), denoting the number of horizontal streets and the number of vertical streets.

The second line contains a string of length *n*, made of characters '&lt;' and '&gt;', denoting direction of each horizontal street. If the *i*-th character is equal to '&lt;', the street is directed from east to west otherwise, the street is directed from west to east. Streets are listed in order from north to south.

The third line contains a string of length *m*, made of characters '^' and 'v', denoting direction of each vertical street. If the *i*-th character is equal to '^', the street is directed from south to north, otherwise the street is directed from north to south. Streets are listed in order from west to east.","If the given pattern meets the mayor's criteria, print a single line containing ""YES"", otherwise print a single line containing ""NO"".","['3 3\n&gt;&lt;&gt;\nv^v\n', '4 6\n&lt;&gt;&lt;&gt;\nv^v^v^\n']","['NO\n', 'YES\n']",The figure above shows street directions in the second sample test case.,WRONG_ANSWER,"def canMove(i,j):
    return i > -1 and i<n and j > -1 and j < m;

def dfsMaze(i,j):
    visited[i][j]=True
    neighbors=[]

    verticalNeighj=j
    if dj[i]=='v':
        verticalNeighi=i+1
    else:
        verticalNeighi=i-1
    
    horizontalNeighi=i
    if di[j]=='>':
        horizontalNeighj=j+1
    else:
        horizontalNeighj=j-1
    
    if canMove(verticalNeighi,verticalNeighj):
        neighbors.append((verticalNeighi,verticalNeighj))
        
        
    if canMove(horizontalNeighi,horizontalNeighj):
        neighbors.append((horizontalNeighi,horizontalNeighj))
    
    for x in neighbors:
        xi,xj=x
        if not visited[xi][xj] :
            dfsMaze(xi,xj)
    

n,m=map(int,input().split())
visited=[]
di=input()
dj=input()

for i in range(n):
    for j in range(m):
        visited=[[ False for _ in range(m)] for _ in range(n)]
        dfsMaze(i,j)
        for x in range(n):
            for y in range(m):
                if not visited[x][y]:
                    print('NO')
                    exit()
                    
print('YES')","def can_reach_all_junctions(n, m, horizontal, vertical):

    accessible = [[False] * m for _ in range(n)]

    accessible[0][0] = True
    q = [(0, 0)]
    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]

    while q:
        x, y = q.pop(0)

        for dx, dy in directions:
            nx, ny = x + dx, y + dy

            if 0 <= nx < n and 0 <= ny < m and not accessible[nx][ny]:

                if (dx == 1 and horizontal[x] == '>') or (dx == -1 and horizontal[x] == '<'):
                    accessible[nx][ny] = True
                    q.append((nx, ny))

                if (dy == 1 and vertical[y] == 'v') or (dy == -1 and vertical[y] == '^'):
                    accessible[nx][ny] = True
                    q.append((nx, ny))

    for i in range(n):
        for j in range(m):
            if not accessible[i][j]:
                return ""NO""
    
    return ""YES""

for line in input().strip().split('\n'):
    n, m = map(int, line.split())
    horizontal = input().strip()
    vertical = input().strip()

    result = can_reach_all_junctions(n, m, horizontal, vertical)
    print(result)"
797,A,k-Factorization,PROGRAMMING,"['implementation', 'math', 'number theory']","Given a positive integer *n*, find *k* integers (not necessary distinct) such that all these integers are strictly greater than 1, and their product is equal to *n*.","The first line contains two integers *n* and *k* (2<=≤<=*n*<=≤<=100000, 1<=≤<=*k*<=≤<=20).","If it's impossible to find the representation of *n* as a product of *k* numbers, print -1.

Otherwise, print *k* integers in any order. Their product must be equal to *n*. If there are multiple answers, print any of them.","['100000 2\n', '100000 20\n', '1024 5\n']","['2 50000 \n', '-1\n', '2 64 2 2 2 \n']",none,OK,"from math import sqrt

def eratosfen(x):
    arr = [True] * (x + 1)
    result = []
    for i in range(2, x + 1):
        if arr[i]:
            result.append(i)
            for j in range(2 * i, x + 1, i):
                arr[j] = False
    return result

n, k = map(int, input().split())
simples = eratosfen(n)
divs = []
for simple in simples:
    while n % simple == 0:
        n //= simple
        divs.append(simple)
if len(divs) < k:
    print(-1)
else:
    while len(divs) > k:
        divs.append(divs.pop() * divs.pop())
    print(*divs)","def find_k_integers(n, k):
    factors = []

    for i in range(2, n + 1):
        while n % i == 0:
            factors.append(i)
            n //= i
            if len(factors) > k:
                return -1

    if len(factors) < k:

        while len(factors) < k:
            factors.append(1)
        return -1 if any(x == 1 for x in factors) else factors
    
    return factors[:k]

import sys
input_data = sys.stdin.read().strip().splitlines()
results = []

for line in input_data:
    n, k = map(int, line.split())
    result = find_k_integers(n, k)
    if result == -1:
        results.append(""-1"")
    else:
        results.append("" "".join(map(str, result)))

for res in results:
    print(res)"
940,D,Alena And The Heater,PROGRAMMING,"['binary search', 'implementation']","""We've tried solitary confinement, waterboarding and listening to Just In Beaver, to no avail. We need something extreme.""

""Little Alena got an array as a birthday present...""

The array *b* of length *n* is obtained from the array *a* of length *n* and two integers *l* and *r* (*l*<=≤<=*r*) using the following procedure:

*b*1<==<=*b*2<==<=*b*3<==<=*b*4<==<=0.

For all 5<=≤<=*i*<=≤<=*n*: 
 -  *b**i*<==<=0 if *a**i*,<=*a**i*<=-<=1,<=*a**i*<=-<=2,<=*a**i*<=-<=3,<=*a**i*<=-<=4<=&gt;<=*r* and *b**i*<=-<=1<==<=*b**i*<=-<=2<==<=*b**i*<=-<=3<==<=*b**i*<=-<=4<==<=1 -  *b**i*<==<=1 if *a**i*,<=*a**i*<=-<=1,<=*a**i*<=-<=2,<=*a**i*<=-<=3,<=*a**i*<=-<=4<=&lt;<=*l* and *b**i*<=-<=1<==<=*b**i*<=-<=2<==<=*b**i*<=-<=3<==<=*b**i*<=-<=4<==<=0 -  *b**i*<==<=*b**i*<=-<=1 otherwise 
You are given arrays *a* and *b*' of the same length. Find two integers *l* and *r* (*l*<=≤<=*r*), such that applying the algorithm described above will yield an array *b* equal to *b*'.

It's guaranteed that the answer exists.","The first line of input contains a single integer *n* (5<=≤<=*n*<=≤<=105) — the length of *a* and *b*'.

The second line of input contains *n* space separated integers *a*1,<=...,<=*a**n* (<=-<=109<=≤<=*a**i*<=≤<=109) — the elements of *a*.

The third line of input contains a string of *n* characters, consisting of 0 and 1 — the elements of *b*'. Note that they are not separated by spaces.","Output two integers *l* and *r* (<=-<=109<=≤<=*l*<=≤<=*r*<=≤<=109), conforming to the requirements described above.

If there are multiple solutions, output any of them.

It's guaranteed that the answer exists.","['5\n1 2 3 4 5\n00001\n', '10\n-10 -9 -8 -7 -6 6 7 8 9 10\n0000111110\n']","['6 15\n', '-5 5\n']","In the first test case any pair of *l* and *r* pair is valid, if 6 ≤ *l* ≤ *r* ≤ 10<sup class=""upper-index"">9</sup>, in that case *b*<sub class=""lower-index"">5</sub> = 1, because *a*<sub class=""lower-index"">1</sub>, ..., *a*<sub class=""lower-index"">5</sub> &lt; *l*.",WRONG_ANSWER,"l = [-int(1e9), int(1e9)]
r = [-int(1e9), int(1e9)]

n = int(input())
a = [int(x) for x in input().split(' ')]
b = [int(x) for x in input()]

sumb = sum(b[:3])

for i in range(4, n):
    maxa = max(a[i-4:i+1])
    mina = min(a[i-4:i+1])
    sumb = sumb + b[i-1] - (b[i-5] if i-5>=0 else 0)
    if b[i] == 1:
        if sumb == 4:
            r[0] = max(r[0], mina)
        elif b[i-1] == 0 and sumb == 0:
            l[0] = max(l[0], maxa+1)
    else:
        if sumb == 0:
            l[1] = min(l[1], maxa)
        elif b[i-1] == 1 and sumb == 4:
            r[1] = min(r[1], mina-1)

print('%d %d' % (l[0], r[0]))

def verify(a, b):
    for i in range(4, n):
        t = b[i-1]
        if min(a[i-4:i+1]) > r[0] and sum(b[i-4:i]) == 4:
            t = 0
        elif max(a[i-4:i+1]) < l[0] and sum(b[i-4:i]) == 0:
            t = 1
        assert(t == b[i])","def find_l_r(n, a, b_str):

    l = -10**9
    r = 10**9

    for i in range(4, n):
        if b_str[i] == '0':

            l = max(l, a[i])
        else:

            r = min(r, a[i] - 1)

    if l > r:
        return None
    
    return l, r

n = int(input())
a = list(map(int, input().split()))
b_str = input().strip()

l, r = find_l_r(n, a, b_str)
print(l, r)"
600,B,Queries about less or equal elements,PROGRAMMING,"['binary search', 'data structures', 'sortings', 'two pointers']",You are given two arrays of integers *a* and *b*. For each element of the second array *b**j* you should find the number of elements in array *a* that are less than or equal to the value *b**j*.,"The first line contains two integers *n*,<=*m* (1<=≤<=*n*,<=*m*<=≤<=2·105) — the sizes of arrays *a* and *b*.

The second line contains *n* integers — the elements of array *a* (<=-<=109<=≤<=*a**i*<=≤<=109).

The third line contains *m* integers — the elements of array *b* (<=-<=109<=≤<=*b**j*<=≤<=109).","Print *m* integers, separated by spaces: the *j*-th of which is equal to the number of such elements in array *a* that are less than or equal to the value *b**j*.","['5 4\n1 3 5 7 9\n6 4 2 8\n', '5 5\n1 2 1 2 5\n3 1 4 1 5\n']","['3 2 1 4\n', '4 2 4 2 5\n']",none,OK,"n, m = map(int, input().split())
A = list(map(int, input().split()))
B = list(map(int, input().split()))

A.sort()

result = []

def bb(A, num):
    ini = 0
    final = len(A) - 1
    
    while ini <= final:
        mid = (ini + final) // 2
        if A[mid] <= num:
            ini = mid + 1
        else:
            final = mid - 1
    return ini

for i in range(len(B)):
    count = bb(A, B[i])
    result.append(count)
    print(count, end=' ')","def count_less_equal(a, b):

    a.sort()
    results = []
    
    for bj in b:

        low, high = 0, len(a)
        while low < high:
            mid = (low + high) // 2
            if a[mid] <= bj:
                low = mid + 1
            else:
                high = mid
        results.append(low)
    
    return results

n, m = map(int, input().split())
a = list(map(int, input().split()))
b = list(map(int, input().split()))

result = count_less_equal(a, b)
print("" "".join(map(str, result)))"
903,B,The Modcrab,PROGRAMMING,"['greedy', 'implementation']","Vova is again playing some computer game, now an RPG. In the game Vova's character received a quest: to slay the fearsome monster called Modcrab.

After two hours of playing the game Vova has tracked the monster and analyzed its tactics. The Modcrab has *h*2 health points and an attack power of *a*2. Knowing that, Vova has decided to buy a lot of strong healing potions and to prepare for battle.

Vova's character has *h*1 health points and an attack power of *a*1. Also he has a large supply of healing potions, each of which increases his current amount of health points by *c*1 when Vova drinks a potion. All potions are identical to each other. It is guaranteed that *c*1<=&gt;<=*a*2.

The battle consists of multiple phases. In the beginning of each phase, Vova can either attack the monster (thus reducing its health by *a*1) or drink a healing potion (it increases Vova's health by *c*1; Vova's health can exceed *h*1). Then, if the battle is not over yet, the Modcrab attacks Vova, reducing his health by *a*2. The battle ends when Vova's (or Modcrab's) health drops to 0 or lower. It is possible that the battle ends in a middle of a phase after Vova's attack.

Of course, Vova wants to win the fight. But also he wants to do it as fast as possible. So he wants to make up a strategy that will allow him to win the fight after the minimum possible number of phases.

Help Vova to make up a strategy! You may assume that Vova never runs out of healing potions, and that he can always win.","The first line contains three integers *h*1, *a*1, *c*1 (1<=≤<=*h*1,<=*a*1<=≤<=100, 2<=≤<=*c*1<=≤<=100) — Vova's health, Vova's attack power and the healing power of a potion.

The second line contains two integers *h*2, *a*2 (1<=≤<=*h*2<=≤<=100, 1<=≤<=*a*2<=&lt;<=*c*1) — the Modcrab's health and his attack power.","In the first line print one integer *n* denoting the minimum number of phases required to win the battle.

Then print *n* lines. *i*-th line must be equal to HEAL if Vova drinks a potion in *i*-th phase, or STRIKE if he attacks the Modcrab.

The strategy must be valid: Vova's character must not be defeated before slaying the Modcrab, and the monster's health must be 0 or lower after Vova's last action.

If there are multiple optimal solutions, print any of them.","['10 6 100\n17 5\n', '11 6 100\n12 5\n']","['4\nSTRIKE\nHEAL\nSTRIKE\nSTRIKE\n', '2\nSTRIKE\nSTRIKE\n']","In the first example Vova's character must heal before or after his first attack. Otherwise his health will drop to zero in 2 phases while he needs 3 strikes to win.

In the second example no healing needed, two strikes are enough to get monster to zero health and win with 6 health left.",WRONG_ANSWER,"import bisect

def list_output(s):    
    print(' '.join(map(str, s)))
    
def list_input(s='int'):
    if s == 'int':
        return list(map(int, input().split()))    
    elif s == 'float':
        return list(map(float, input().split()))
    return list(map(str, input().split()))

[h1, a1, c1] = list(map(int, input().split()))
[h2, a2] = list(map(int, input().split()))

res = list()
while True:
    if h1 > a2:
        res.append('STRIKE')
        h2 -= a1
        h1 -= a2
    else:
        res.append('HEAL')
        h1 += c1
        h1 -= a2
    if h2 <= 0:
        break
print(len(res))
for e in res:
    print(e)","def battle_strategy(h1, a1, c1, h2, a2):
    actions = []

    while h2 > 0:

        strikes_needed = (h2 + a1 - 1) // a1

        health_after_strikes = h1 - (strikes_needed - 1) * a2

        if health_after_strikes > 0:

            actions.append(""STRIKE"")
            h2 -= a1
        else:

            actions.append(""HEAL"")
            h1 += c1
            h1 -= a2

        if h2 <= 0:
            break
        else:

            h1 -= a2

    return actions

input_data = [
    (10, 6, 100, 17, 5),
    (11, 6, 100, 12, 5)
]

for h1, a1, c1, h2, a2 in input_data:
    actions = battle_strategy(h1, a1, c1, h2, a2)
    print(len(actions))
    for action in actions:
        print(action)"
159,C,String Manipulation 1.0,PROGRAMMING,"['*special', 'binary search', 'brute force', 'data structures', 'strings']","One popular website developed an unusual username editing procedure. One can change the username only by deleting some characters from it: to change the current name *s*, a user can pick number *p* and character *c* and delete the *p*-th occurrence of character *c* from the name. After the user changed his name, he can't undo the change.

For example, one can change name ""arca"" by removing the second occurrence of character ""a"" to get ""arc"". 

Polycarpus learned that some user initially registered under nickname *t*, where *t* is a concatenation of *k* copies of string *s*. Also, Polycarpus knows the sequence of this user's name changes. Help Polycarpus figure out the user's final name.","The first line contains an integer *k* (1<=≤<=*k*<=≤<=2000). The second line contains a non-empty string *s*, consisting of lowercase Latin letters, at most 100 characters long. The third line contains an integer *n* (0<=≤<=*n*<=≤<=20000) — the number of username changes. Each of the next *n* lines contains the actual changes, one per line. The changes are written as ""*p**i* *c**i*"" (without the quotes), where *p**i* (1<=≤<=*p**i*<=≤<=200000) is the number of occurrences of letter *c**i*, *c**i* is a lowercase Latin letter. It is guaranteed that the operations are correct, that is, the letter to be deleted always exists, and after all operations not all letters are deleted from the name. The letters' occurrences are numbered starting from 1.",Print a single string — the user's final name after all changes are applied to it.,"['2\nbac\n3\n2 a\n1 b\n2 c\n', '1\nabacaba\n4\n1 a\n1 a\n1 c\n2 b\n']","['acb\n', 'baa\n']","Let's consider the first sample. Initially we have name ""bacbac""; the first operation transforms it into ""bacbc"", the second one — to ""acbc"", and finally, the third one transforms it into ""acb"".",OK,"from collections import defaultdict
k = int(input())
s = input()
d = defaultdict(list)
word = list(s*k)
for i in range(len(word)):
    d[word[i]].append(i)
n = int(input())
for _ in range(n):
    a,b = input().split()
    a = int(a)
    change = d[b].pop(a-1)
    word[change] = ''
print(''.join(word))","def final_username(k, s, n, changes):

    username = s * k

    for change in changes:
        p, c = change

        occurrence_count = 0
        username_list = list(username)
        
        for i in range(len(username_list)):
            if username_list[i] == c:
                occurrence_count += 1

                if occurrence_count == p:
                    del username_list[i]
                    break

        username = ''.join(username_list)

    return username

import sys

input_data = sys.stdin.read().strip().split('\n')
k = int(input_data[0])
s = input_data[1]
n = int(input_data[2])
changes = [tuple(map(str, line.split())) for line in input_data[3:]]

result = final_username(k, s, n, changes)

print(result)"
0,none,none,none,['none'],Kyoya Ootori has a bag with *n* colored balls that are colored with *k* different colors. The colors are labeled from 1 to *k*. Balls of the same color are indistinguishable. He draws balls from the bag one by one until the bag is empty. He noticed that he drew the last ball of color *i* before drawing the last ball of color *i*<=+<=1 for all *i* from 1 to *k*<=-<=1. Now he wonders how many different ways this can happen.,"The first line of input will have one integer *k* (1<=≤<=*k*<=≤<=1000) the number of colors.

Then, *k* lines will follow. The *i*-th line will contain *c**i*, the number of balls of the *i*-th color (1<=≤<=*c**i*<=≤<=1000).

The total number of balls doesn't exceed 1000.","A single integer, the number of ways that Kyoya can draw the balls from the bag as described in the statement, modulo 1<=000<=000<=007.","['3\n2\n2\n1\n', '4\n1\n2\n3\n4\n']","['3\n', '1680\n']","In the first sample, we have 2 balls of color 1, 2 balls of color 2, and 1 ball of color 3. The three ways for Kyoya are:",RUNTIME_ERROR,"import time
MAX = 1000000007

def test(m, c, C, k, z):
    global MAX
    if m == 0:
        return 1

    if c < 0:
        c = 0

    ans = 0
    for i in range(c, k):
        if C[i] != 0:
            C[i] -= 1
            ans += test(m-1, min(i-1, c), C, k, z+[i])
            C[i] += 1
    return divmod(ans, MAX)[1]

k   = int(input())
C   = []

for i in range(k):
    C.append(int(input()))

n   = sum(C)

start = time.time()

ans = test(n, k-1, C, k, [])

print(ans)
finish = time.time()","from math import factorial
from functools import reduce

def nCr(n, r):
    if r > n or r < 0:
        return 0
    return factorial(n) // (factorial(r) * factorial(n - r))

def count_draw_ways(k, counts):

    total_balls = sum(counts)

    answer = 1

    for count in counts:
        answer *= nCr(total_balls, count)
        total_balls -= count

    return answer % 1000000007

k = int(input())
counts = [int(input()) for _ in range(k)]

print(count_draw_ways(k, counts))"
988,E,Divisibility by 25,PROGRAMMING,"['brute force', 'greedy']","You are given an integer $n$ from $1$ to $10^{18}$ without leading zeroes.

In one move you can swap any two adjacent digits in the given number in such a way that the resulting number will not contain leading zeroes. In other words, after each move the number you have cannot contain any leading zeroes.

What is the minimum number of moves you have to make to obtain a number that is divisible by $25$? Print -1 if it is impossible to obtain a number that is divisible by $25$.",The first line contains an integer $n$ ($1 \le n \le 10^{18}$). It is guaranteed that the first (left) digit of the number $n$ is not a zero.,"If it is impossible to obtain a number that is divisible by $25$, print -1. Otherwise print the minimum number of moves required to obtain such number.

Note that you can swap only adjacent digits in the given number.","['5071\n', '705\n', '1241367\n']","['4\n', '1\n', '-1\n']",In the first example one of the possible sequences of moves is 5071 $\rightarrow$ 5701 $\rightarrow$ 7501 $\rightarrow$ 7510 $\rightarrow$ 7150.,WRONG_ANSWER,"from collections import *
from heapq import *
from bisect import *
from itertools import *
from functools import *
from math import *
from string import *
import sys

input = sys.stdin.readline

cases = [[2, 5], [5, 0], [7, 5], [0, 0]]

def calc_moves(num, locs, x, y):

    if x not in locs or y not in locs:
        return inf

    if x == y and len(locs[x]) < 2:
        return inf

    A = str(num)
    x, y = str(x), str(y)

    ans = 0
    j = A.rindex(y)
    ans += len(A) - 1 - j
    A = A[:j] + A[j + 1 :]

    i = A.rindex(x)
    A = A[:i] + A[i + 1 :]
    ans += len(A) - i

    while i < len(A) and A[i] == 0:
        ans += 1
        i += 1

    return ans

def solve(n):
    if n % 25 == 0:
        return 0

    num_digits = len(str(n))

    locs = defaultdict(list)
    for i, x in enumerate(map(int, str(n))):
        locs[x].append(i)

    ans = inf
    for case in cases:
        ans = min(ans, calc_moves(n, locs, *case))

    return ans if ans < inf else -1

def main():
    n = int(input())
    print(solve(n))

if __name__ == ""__main__"":
    main()","def min_moves_to_divisible_by_25(n):
    n_str = str(n)
    length = len(n_str)

    target_pairs = ['00', '25', '50', '75']
    min_moves = float('inf')
    found = False
    
    for target in target_pairs:

        second_digit_index = -1
        first_digit_needed = target[1]

        for i in range(length - 1, -1, -1):
            if n_str[i] == first_digit_needed:
                second_digit_index = i
                break

        if second_digit_index == -1:
            continue

        first_digit_needed = target[0]
        first_digit_index = -1
        
        for i in range(second_digit_index):
            if n_str[i] == first_digit_needed:
                first_digit_index = i
                break

        if first_digit_index == -1:
            continue

        moves = (second_digit_index - first_digit_index - 1) + (length - second_digit_index - 1)

        found = True
        min_moves = min(min_moves, moves)

    return min_moves if found else -1

import sys
input_data = sys.stdin.read().strip().split()
results = []
for item in input_data:
    n = int(item.strip())
    result = min_moves_to_divisible_by_25(n)
    results.append(result)

for result in results:
    print(result)"
873,D,Merge Sort,PROGRAMMING,"['constructive algorithms', 'divide and conquer']","Merge sort is a well-known sorting algorithm. The main function that sorts the elements of array *a* with indices from [*l*,<=*r*) can be implemented as follows:
 1.  If the segment [*l*,<=*r*) is already sorted in non-descending order (that is, for any *i* such that *l*<=≤<=*i*<=&lt;<=*r*<=-<=1 *a*[*i*]<=≤<=*a*[*i*<=+<=1]), then end the function call; 1.  Let ; 1.  Call *mergesort*(*a*,<=*l*,<=*mid*); 1.  Call *mergesort*(*a*,<=*mid*,<=*r*); 1.  Merge segments [*l*,<=*mid*) and [*mid*,<=*r*), making the segment [*l*,<=*r*) sorted in non-descending order. The merge algorithm doesn't call any other functions. 
The array in this problem is 0-indexed, so to sort the whole array, you need to call *mergesort*(*a*,<=0,<=*n*).

The number of calls of function *mergesort* is very important, so Ivan has decided to calculate it while sorting the array. For example, if *a*<==<={1,<=2,<=3,<=4}, then there will be 1 call of *mergesort* — *mergesort*(0,<=4), which will check that the array is sorted and then end. If *a*<==<={2,<=1,<=3}, then the number of calls is 3: first of all, you call *mergesort*(0,<=3), which then sets *mid*<==<=1 and calls *mergesort*(0,<=1) and *mergesort*(1,<=3), which do not perform any recursive calls because segments (0,<=1) and (1,<=3) are sorted.

Ivan has implemented the program that counts the number of *mergesort* calls, but now he needs to test it. To do this, he needs to find an array *a* such that *a* is a permutation of size *n* (that is, the number of elements in *a* is *n*, and every integer number from [1,<=*n*] can be found in this array), and the number of *mergesort* calls when sorting the array is exactly *k*.

Help Ivan to find an array he wants!","The first line contains two numbers *n* and *k* (1<=≤<=*n*<=≤<=100000, 1<=≤<=*k*<=≤<=200000) — the size of a desired permutation and the number of *mergesort* calls required to sort it.","If a permutation of size *n* such that there will be exactly *k* calls of *mergesort* while sorting it doesn't exist, output <=-<=1. Otherwise output *n* integer numbers *a*[0],<=*a*[1],<=...,<=*a*[*n*<=-<=1] — the elements of a permutation that would meet the required conditions. If there are multiple answers, print any of them.","['3 3\n', '4 1\n', '5 6\n']","['2 1 3 ', '1 2 3 4 ', '-1\n']",none,OK,"n, m = list(map(int, input().split()))
 
solucao = []
 
def merge(inicio, fim, rem):
	if rem < 2:
		solucao.extend(range(inicio, fim))
		return rem
	if fim - inicio == 1:
		solucao.append(inicio)
		return rem
	rem -= 2
	mid = (inicio + fim + 1)//2
	rem = merge(mid, fim, rem)
	rem = merge(inicio, mid, rem)
	return rem
 
rem = merge(1, n + 1, m - 1)
if rem == 0:
	print(' '.join(map(str, solucao)))
else:
	print(-1)","def mergesort_count(a, l, r):

    if r - l <= 1 or all(a[i] <= a[i + 1] for i in range(l, r - 1)):
        return 1
    
    mid = (l + r) // 2

    return (mergesort_count(a, l, mid) + 
            mergesort_count(a, mid, r))

def generate_permutation(n, k):

    a = list(range(1, n + 1))
    calls = mergesort_count(a, 0, n)
    
    if calls > k:
        return -1

    if k == calls:
        return a

    a = list(range(1, n + 1))
    if k < calls:
        for i in range(1, n):

            a[i - 1], a[i] = a[i], a[i - 1]
            calls = mergesort_count(a, 0, n)
            if calls == k:
                return a
            a[i - 1], a[i] = a[i], a[i - 1]

    return -1

input_data = ['3 3', '4 1', '5 6']
output_data = []

for line in input_data:
    n, k = map(int, line.split())
    result = generate_permutation(n, k)
    if result == -1:
        output_data.append(""-1"")
    else:
        output_data.append("" "".join(map(str, result)))

print(""\n"".join(output_data))"
320,A,Magic Numbers,PROGRAMMING,"['brute force', 'greedy']","A magic number is a number formed by concatenation of numbers 1, 14 and 144. We can use each of these numbers any number of times. Therefore 14144, 141414 and 1411 are magic numbers but 1444, 514 and 414 are not.

You're given a number. Determine if it is a magic number or not.","The first line of input contains an integer *n*, (1<=≤<=*n*<=≤<=109). This number doesn't contain leading zeros.","Print ""YES"" if *n* is a magic number or print ""NO"" if it's not.","['114114\n', '1111\n', '441231\n']","['YES\n', 'YES\n', 'NO\n']",none,WRONG_ANSWER,"s = input()

def func(s):
	cnt = 0 
	for i in range(len(s)):
		if cnt >= 2: return ""NO""
		if s[i] == '4': cnt += 1
		elif s[i] == '1': cnt = 0
		elif s[i] != '4' and s[i] != '1': return ""NO""
	return ""YES""

print(func(s))","def is_magic_number(n):

    s = str(n)
    i = 0

    while i < len(s):

        if s[i:i+3] == '144':
            i += 3

        elif s[i:i+2] == '14':
            i += 2

        elif s[i:i+1] == '1':
            i += 1
        else:
            return ""NO""
    
    return ""YES""

input_numbers = ['114114\n', '1111\n', '441231\n']
output_results = []

for num in input_numbers:
    num = num.strip()
    output_results.append(is_magic_number(num))

print([result + '\n' for result in output_results])"
110,A,Nearly Lucky Number,PROGRAMMING,['implementation'],"Petya loves lucky numbers. We all know that lucky numbers are the positive integers whose decimal representations contain only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.

Unfortunately, not all numbers are lucky. Petya calls a number nearly lucky if the number of lucky digits in it is a lucky number. He wonders whether number *n* is a nearly lucky number.","The only line contains an integer *n* (1<=≤<=*n*<=≤<=1018).

Please do not use the %lld specificator to read or write 64-bit numbers in С++. It is preferred to use the cin, cout streams or the %I64d specificator.","Print on the single line ""YES"" if *n* is a nearly lucky number. Otherwise, print ""NO"" (without the quotes).","['40047\n', '7747774\n', '1000000000000000000\n']","['NO\n', 'YES\n', 'NO\n']","In the first sample there are 3 lucky digits (first one and last two), so the answer is ""NO"".

In the second sample there are 7 lucky digits, 7 is lucky number, so the answer is ""YES"".

In the third sample there are no lucky digits, so the answer is ""NO"".",OK,"x = str(input())
def isnearlucky(x):
    count = 0
    for char in x:
        if char == ""4"" or char == ""7"":
            count += 1
            continue
    count = str(count)
    count = count.replace(""4"","""")
    count = count.replace(""7"","""")
    if len(count) == 0:
        print(""YES"")
    else:
        print(""NO"")
isnearlucky(x)","def is_lucky_number(num):

    return all(d in '47' for d in str(num))

def count_lucky_digits(n):

    return sum(1 for d in str(n) if d in '47')

def is_nearly_lucky_number(n):

    lucky_count = count_lucky_digits(n)

    return is_lucky_number(lucky_count)

if __name__ == ""__main__"":
    n = int(input().strip())

    if is_nearly_lucky_number(n):
        print(""YES"")
    else:
        print(""NO"")"
347,A,Difference Row,PROGRAMMING,"['constructive algorithms', 'implementation', 'sortings']","You want to arrange *n* integers *a*1,<=*a*2,<=...,<=*a**n* in some order in a row. Let's define the value of an arrangement as the sum of differences between all pairs of adjacent integers.

More formally, let's denote some arrangement as a sequence of integers *x*1,<=*x*2,<=...,<=*x**n*, where sequence *x* is a permutation of sequence *a*. The value of such an arrangement is (*x*1<=-<=*x*2)<=+<=(*x*2<=-<=*x*3)<=+<=...<=+<=(*x**n*<=-<=1<=-<=*x**n*).

Find the largest possible value of an arrangement. Then, output the lexicographically smallest sequence *x* that corresponds to an arrangement of the largest possible value.","The first line of the input contains integer *n* (2<=≤<=*n*<=≤<=100). The second line contains *n* space-separated integers *a*1, *a*2, ..., *a**n* (|*a**i*|<=≤<=1000).","Print the required sequence *x*1,<=*x*2,<=...,<=*x**n*. Sequence *x* should be the lexicographically smallest permutation of *a* that corresponds to an arrangement of the largest possible value.",['5\n100 -100 50 0 -50\n'],['100 -50 0 50 -100 \n'],"In the sample test case, the value of the output arrangement is (100 - ( - 50)) + (( - 50) - 0) + (0 - 50) + (50 - ( - 100)) = 200. No other arrangement has a larger value, and among all arrangements with the value of 200, the output arrangement is the lexicographically smallest one.

Sequence *x*<sub class=""lower-index"">1</sub>, *x*<sub class=""lower-index"">2</sub>, ... , *x*<sub class=""lower-index"">*p*</sub> is lexicographically smaller than sequence *y*<sub class=""lower-index"">1</sub>, *y*<sub class=""lower-index"">2</sub>, ... , *y*<sub class=""lower-index"">*p*</sub> if there exists an integer *r* (0 ≤ *r* &lt; *p*) such that *x*<sub class=""lower-index"">1</sub> = *y*<sub class=""lower-index"">1</sub>, *x*<sub class=""lower-index"">2</sub> = *y*<sub class=""lower-index"">2</sub>, ... , *x*<sub class=""lower-index"">*r*</sub> = *y*<sub class=""lower-index"">*r*</sub> and *x*<sub class=""lower-index"">*r* + 1</sub> &lt; *y*<sub class=""lower-index"">*r* + 1</sub>.",WRONG_ANSWER,"def solve(n, nums):
    nums.sort()
    ret = []
    print(nums)
    if nums[0] < 0:
        ret.append(nums[-1])
        for i in range(1,n-1):
            ret.append(nums[i])
        ret.append(nums[0])
    else:
        for i in range(n):
            ret.append(nums[-i-1])
    return ret    
n = int(input())
nums = list(map(int, input().split()))
ret = solve(n,nums)
for i in range(n):
    print(ret[i], end= ' ')
print()","def largest_arrangement(n, a):

    a.sort()

    result = [0] * n

    left = 0
    right = n - 1
    
    for i in range(n):
        if i % 2 == 0:
            result[i] = a[right]
            right -= 1
        else:
            result[i] = a[left]
            left += 1

    print("" "".join(map(str, result)))

n = int(input().strip())
a = list(map(int, input().strip().split()))
largest_arrangement(n, a)"
463,B,Caisa and Pylons,PROGRAMMING,"['brute force', 'implementation', 'math']","Caisa solved the problem with the sugar and now he is on the way back to home. 

Caisa is playing a mobile game during his path. There are (*n*<=+<=1) pylons numbered from 0 to *n* in this game. The pylon with number 0 has zero height, the pylon with number *i* (*i*<=&gt;<=0) has height *h**i*. The goal of the game is to reach *n*-th pylon, and the only move the player can do is to jump from the current pylon (let's denote its number as *k*) to the next one (its number will be *k*<=+<=1). When the player have made such a move, its energy increases by *h**k*<=-<=*h**k*<=+<=1 (if this value is negative the player loses energy). The player must have non-negative amount of energy at any moment of the time. 

Initially Caisa stand at 0 pylon and has 0 energy. The game provides a special opportunity: one can pay a single dollar and increase the height of anyone pylon by one. Caisa may use that opportunity several times, but he doesn't want to spend too much money. What is the minimal amount of money he must paid to reach the goal of the game?","The first line contains integer *n* (1<=≤<=*n*<=≤<=105). The next line contains *n* integers *h*1, *h*2,<=..., *h**n* (1<=<=≤<=<=*h**i*<=<=≤<=<=105) representing the heights of the pylons.",Print a single number representing the minimum number of dollars paid by Caisa.,"['5\n3 4 3 2 4\n', '3\n4 4 4\n']","['4\n', '4\n']",In the first sample he can pay 4 dollars and increase the height of pylon with number 0 by 4 units. Then he can safely pass to the last pylon.,OK,"import math
import sys
input = sys.stdin.readline
from collections import deque, defaultdict
import heapq
def counter(a):
    c = defaultdict(lambda : 0)
    for el in a:
        c[el] += 1
    return c

def inp(): return [int(k) for k in input().split()]

n = int(input())
arr = inp()

print(max(arr))","def min_dollars_to_reach_goal(n, heights):

    initial_height = 0

    max_height_needed = max(heights) 

    dollars_needed = max_height_needed - initial_height
    return dollars_needed

n = int(input().strip())
heights = list(map(int, input().strip().split()))

result = min_dollars_to_reach_goal(n, heights)
print(result)"
0,none,none,none,['none'],"Let's define the sum of two permutations *p* and *q* of numbers 0,<=1,<=...,<=(*n*<=-<=1) as permutation , where *Perm*(*x*) is the *x*-th lexicographically permutation of numbers 0,<=1,<=...,<=(*n*<=-<=1) (counting from zero), and *Ord*(*p*) is the number of permutation *p* in the lexicographical order.

For example, *Perm*(0)<==<=(0,<=1,<=...,<=*n*<=-<=2,<=*n*<=-<=1), *Perm*(*n*!<=-<=1)<==<=(*n*<=-<=1,<=*n*<=-<=2,<=...,<=1,<=0)

Misha has two permutations, *p* and *q*. Your task is to find their sum.

Permutation *a*<==<=(*a*0,<=*a*1,<=...,<=*a**n*<=-<=1) is called to be lexicographically smaller than permutation *b*<==<=(*b*0,<=*b*1,<=...,<=*b**n*<=-<=1), if for some *k* following conditions hold: *a*0<==<=*b*0,<=*a*1<==<=*b*1,<=...,<=*a**k*<=-<=1<==<=*b**k*<=-<=1,<=*a**k*<=&lt;<=*b**k*.","The first line contains an integer *n* (1<=≤<=*n*<=≤<=200<=000).

The second line contains *n* distinct integers from 0 to *n*<=-<=1, separated by a space, forming permutation *p*.

The third line contains *n* distinct integers from 0 to *n*<=-<=1, separated by spaces, forming permutation *q*.","Print *n* distinct integers from 0 to *n*<=-<=1, forming the sum of the given permutations. Separate the numbers by spaces.","['2\n0 1\n0 1\n', '2\n0 1\n1 0\n', '3\n1 2 0\n2 1 0\n']","['0 1\n', '1 0\n', '1 0 2\n']","Permutations of numbers from 0 to 1 in the lexicographical order: (0, 1), (1, 0).

In the first sample *Ord*(*p*) = 0 and *Ord*(*q*) = 0, so the answer is <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/8ce4cd76db7c3f712f9101b410c36891976581b8.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>.

In the second sample *Ord*(*p*) = 0 and *Ord*(*q*) = 1, so the answer is <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/5684e4e2deb5ed60419a5c9e765f0cd4cb995652.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>.

Permutations of numbers from 0 to 2 in the lexicographical order: (0, 1, 2), (0, 2, 1), (1, 0, 2), (1, 2, 0), (2, 0, 1), (2, 1, 0).

In the third sample *Ord*(*p*) = 3 and *Ord*(*q*) = 5, so the answer is <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/da14f774ebda9f417649f5334d329ec7b7c07778.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>.",TIME_LIMIT_EXCEEDED,"import sys

class Tree:
    
    def __init__(self, a, b):
        self.range = (a, b)
        if a == b:
            self.active = 1
            self.left = None
            self.rigt = None
            return
        else:
            mid = (a + b) // 2
            self.left = Tree(a, mid)
            self.right = Tree(mid + 1, b)
            self.active = self.left.active + self.right.active
    
    def find_active(self, a, b):
        if b < self.range[0] or self.range[1] < a:
            return 0
        if a <= self.range[0] and self.range[1] <= b:
            return self.active
        return self.left.find_active(a, b) + self.right.find_active(a, b)
    
    def deactivate(self, x):
        if self.range[0] == x and self.range[1] == x:
            self.active = 0
            return
        if x < self.range[0] or self.range[1] < x:
            return
        self.left.deactivate(x)
        self.right.deactivate(x)
        self.active = self.left.active + self.right.active        

    def find_ith(self, x):
        if self.range[0] == self.range[1]:
            return self.range[0]
        if self.left.active >= x:
            return self.left.find_ith(x)
        else:
            return self.right.find_ith(x - self.left.active)

def convert(p, n):
    t = Tree(0, n-1)
    ret = []
    for x in p:
        ret.append(t.find_active(0, x) - 1)
        t.deactivate(x)
    return ret

def perm_sum(p, q):
    n = len(p)
    ret = [0 for i in range(n)]
    prenos = 0
    for i in range(1, n):
        s = p[n-i-1] + q[n-i-1] + prenos
        ret[n-i-1] = s % (i + 1)
        prenos = 1 if s > i else 0
    return ret

def de_convert(p, n):
    t = Tree(0, n-1)
    ret = []
    for x in p:
        d = t.find_ith(x + 1)
        ret.append(d)
        t.deactivate(d)
    return ret    

n = int(sys.stdin.readline())
p = [int(x) for x in sys.stdin.readline().split()]
q = [int(x) for x in sys.stdin.readline().split()]

p = convert(p, n)
q = convert(q, n)
r = de_convert(perm_sum(p, q), n)

print(' '.join(str(x) for x in r))","from math import factorial

def get_ordinal(permutation):
    n = len(permutation)
    ord_value = 0
    fact = factorial(n - 1)
    used = [False] * n

    for i in range(n):
        count = 0
        for j in range(permutation[i]):
            if not used[j]:
                count += 1
        ord_value += count * fact
        if i < n - 1:
            fact //= (n - 1 - i)
        used[permutation[i]] = True

    return ord_value

def find_sum_permutations(n, p, q):
    ord_p = get_ordinal(p)
    ord_q = get_ordinal(q)
    
    total_index = ord_p + ord_q

    permutations = []

    from itertools import permutations as it_permutations
    all_perms = sorted(it_permutations(range(n)))
    return list(all_perms[total_index])

n = int(input().strip())
p = list(map(int, input().strip().split()))
q = list(map(int, input().strip().split()))

result = find_sum_permutations(n, p, q)

print(' '.join(map(str, result)))"
369,B,Valera and Contest,PROGRAMMING,"['constructive algorithms', 'implementation', 'math']","Valera loves to participate in competitions. Especially in programming contests. Today he has participated in the contest with his team, consisting of *n* students (including Valera). This contest was an individual competition, so each student in the team solved problems individually.

After the contest was over, Valera was interested in results. He found out that:
 -  each student in the team scored at least *l* points and at most *r* points; -  in total, all members of the team scored exactly *s**all* points; -  the total score of the *k* members of the team who scored the most points is equal to exactly *s**k*; more formally, if *a*1,<=*a*2,<=...,<=*a**n* is the sequence of points earned by the team of students in the non-increasing order (*a*1<=≥<=*a*2<=≥<=...<=≥<=*a**n*), then *s**k*<==<=*a*1<=+<=*a*2<=+<=...<=+<=*a**k*. 
However, Valera did not find out exactly how many points each of *n* students scored. Valera asked you to recover any distribution of scores between the students of the team, such that all the conditions above are met.","The first line of the input contains exactly six integers *n*,<=*k*,<=*l*,<=*r*,<=*s**all*,<=*s**k* (1<=≤<=*n*,<=*k*,<=*l*,<=*r*<=≤<=1000; *l*<=≤<=*r*; *k*<=≤<=*n*; 1<=≤<=*s**k*<=≤<=*s**all*<=≤<=106).

It's guaranteed that the input is such that the answer exists.","Print exactly *n* integers *a*1,<=*a*2,<=...,<=*a**n* — the number of points each student scored. If there are multiple solutions, you can print any of them. You can print the distribution of points in any order.","['5 3 1 3 13 9\n', '5 3 1 3 15 9\n']","['2 3 2 3 3 ', '3 3 3 3 3 ']",none,WRONG_ANSWER,"def work(arr, start, end, least, most, tot, csum):
    for i in range(start, end+1):
        if csum + most - least < tot:
            csum += (most-least)
            arr[i] = most
        else:
            arr[i] += tot - csum
            return

n, k, l, r, sall, sk = map(int, input().split())
arr = [l]*(n)
work(arr, 0, k-1,l, r, sk, l*k)
work(arr, k, n-1, l, r, sall, sk + l*(n-k))
print(*arr)","def distribute_scores(n, k, l, r, s_all, s_k):

    scores = [0] * n

    base_k_score = s_k // k
    extra_k_score = s_k % k

    for i in range(k):
        scores[i] = base_k_score + (1 if i < extra_k_score else 0)

    remaining_students = n - k
    if remaining_students > 0:
        base_remaining_score = (s_all - s_k) // remaining_students
        extra_remaining_score = (s_all - s_k) % remaining_students

        for j in range(remaining_students):
            scores[k + j] = base_remaining_score + (1 if j < extra_remaining_score else 0)

    return scores

n, k, l, r, s_all, s_k = map(int, input().split())

result = distribute_scores(n, k, l, r, s_all, s_k)

print(' '.join(map(str, result)))"
25,A,IQ test,PROGRAMMING,['brute force'],"Bob is preparing to pass IQ test. The most frequent task in this test is to find out which one of the given *n* numbers differs from the others. Bob observed that one number usually differs from the others in evenness. Help Bob — to check his answers, he needs a program that among the given *n* numbers finds one that is different in evenness.","The first line contains integer *n* (3<=≤<=*n*<=≤<=100) — amount of numbers in the task. The second line contains *n* space-separated natural numbers, not exceeding 100. It is guaranteed, that exactly one of these numbers differs from the others in evenness.",Output index of number that differs from the others in evenness. Numbers are numbered from 1 in the input order.,"['5\n2 4 7 8 10\n', '4\n1 2 1 1\n']","['3\n', '2\n']",none,RUNTIME_ERROR,"n, k = input().split()
k = int(k)

l = [int(x) for x in input().split() if int(x) !=0]
l.sort()

def chama(l, k):
	for s in range(k):
		minimum = l[0]
		print(minimum)
		l = [x-minimum for x in l if x-minimum > 0 ]
		if not l:
			return k-s

	return 0

r = chama(l, k-1)
for _ in range(r):
	print(0)","def find_different_evenness(nums):

    even_count = sum(1 for num in nums if num % 2 == 0)
    odd_count = len(nums) - even_count

    if even_count == 1:

        return next(i + 1 for i, num in enumerate(nums) if num % 2 == 0)
    else:

        return next(i + 1 for i, num in enumerate(nums) if num % 2 != 0)

n = int(input().strip())
numbers = list(map(int, input().strip().split()))

print(find_different_evenness(numbers))"
0,none,none,none,['none'],"Alyona's mother wants to present an array of *n* non-negative integers to Alyona. The array should be special. 

Alyona is a capricious girl so after she gets the array, she inspects *m* of its subarrays. Subarray is a set of some subsequent elements of the array. The *i*-th subarray is described with two integers *l**i* and *r**i*, and its elements are *a*[*l**i*],<=*a*[*l**i*<=+<=1],<=...,<=*a*[*r**i*].

Alyona is going to find mex for each of the chosen subarrays. Among these *m* mexes the girl is going to find the smallest. She wants this minimum mex to be as large as possible. 

You are to find an array *a* of *n* elements so that the minimum mex among those chosen by Alyona subarrays is as large as possible.

The mex of a set *S* is a minimum possible non-negative integer that is not in *S*.","The first line contains two integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=105).

The next *m* lines contain information about the subarrays chosen by Alyona. The *i*-th of these lines contains two integers *l**i* and *r**i* (1<=≤<=*l**i*<=≤<=*r**i*<=≤<=*n*), that describe the subarray *a*[*l**i*],<=*a*[*l**i*<=+<=1],<=...,<=*a*[*r**i*].","In the first line print single integer — the maximum possible minimum mex.

In the second line print *n* integers — the array *a*. All the elements in *a* should be between 0 and 109.

It is guaranteed that there is an optimal answer in which all the elements in *a* are between 0 and 109.

If there are multiple solutions, print any of them.","['5 3\n1 3\n2 5\n4 5\n', '4 2\n1 4\n2 4\n']","['2\n1 0 2 1 0\n', '3\n5 2 0 1']","The first example: the mex of the subarray (1, 3) is equal to 3, the mex of the subarray (2, 5) is equal to 3, the mex of the subarray (4, 5) is equal to 2 as well, thus the minumal mex among the subarrays chosen by Alyona is equal to 2.",OK,"def mex(arr,n):
    mini=float(""inf"")
    for l,r in arr:
        mini=min(mini,r-l+1)
    print(mini)
    for i in range(n):
        print(i%mini,end="" "")
    return """"

a,b=map(int,input().strip().split())
blanck=[]
for i in range(b):
    x,y=map(int,input().strip().split())
    blanck.append([x,y])
print(mex(blanck,a))","def maximum_minimum_mex(n, m, queries):

    freq = [0] * (n + 1)

    for l, r in queries:
        for i in range(l, r + 1):
            freq[i] += 1

    mex = 0

    while mex <= n and freq[mex] > 0:
        mex += 1

    a = [0] * n

    for i in range(n):
        a[i] = i % mex

    return mex, a

input_data = input().strip().split('\n')
n, m = map(int, input_data[0].split())
queries = [tuple(map(int, line.split())) for line in input_data[1:m+1]]

max_mex, array_a = maximum_minimum_mex(n, m, queries)

print(max_mex)
print(' '.join(map(str, array_a)))"
937,B,Vile Grasshoppers,PROGRAMMING,"['brute force', 'math', 'number theory']","The weather is fine today and hence it's high time to climb the nearby pine and enjoy the landscape.

The pine's trunk includes several branches, located one above another and numbered from 2 to *y*. Some of them (more precise, from 2 to *p*) are occupied by tiny vile grasshoppers which you're at war with. These grasshoppers are known for their awesome jumping skills: the grasshopper at branch *x* can jump to branches .

Keeping this in mind, you wisely decided to choose such a branch that none of the grasshoppers could interrupt you. At the same time you wanna settle as high as possible since the view from up there is simply breathtaking.

In other words, your goal is to find the highest branch that cannot be reached by any of the grasshoppers or report that it's impossible.",The only line contains two integers *p* and *y* (2<=≤<=*p*<=≤<=*y*<=≤<=109).,"Output the number of the highest suitable branch. If there are none, print -1 instead.","['3 6\n', '3 4\n']","['5\n', '-1\n']","In the first sample case grasshopper from branch 2 reaches branches 2, 4 and 6 while branch 3 is initially settled by another grasshopper. Therefore the answer is 5.

It immediately follows that there are no valid branches in second sample case.",OK,"from math import sqrt
p,y = map(int,input().split())
def is_prime(n, p):
    if n % 2 == 0 and n > 2:
        return False
    if p == 2: return True
    for x in range(3, min(p, int(sqrt(n))) + 1, 2):
        if n % x == 0:
            return False
    return True

for i in range(y, p,-1):
    if is_prime(i, p):
        print(i)
        exit()
        break
print(-1)","def highest_branch_without_grasshoppers(p, y):

    for branch in range(y, p, -1):

        if branch % p != 0:

            for grasshopper in range(2, p + 1):
                if branch % grasshopper == 0:
                    break
            else:
                return branch
    return -1

input_data = ['3 6\n', '3 4\n']

for line in input_data:
    p, y = map(int, line.strip().split())
    result = highest_branch_without_grasshoppers(p, y)
    print(result)"
3,A,Shortest path of the king,PROGRAMMING,"['greedy', 'shortest paths']","The king is left alone on the chessboard. In spite of this loneliness, he doesn't lose heart, because he has business of national importance. For example, he has to pay an official visit to square *t*. As the king is not in habit of wasting his time, he wants to get from his current position *s* to square *t* in the least number of moves. Help him to do this.

In one move the king can get to the square that has a common side or a common vertex with the square the king is currently in (generally there are 8 different squares he can move to).","The first line contains the chessboard coordinates of square *s*, the second line — of square *t*.

Chessboard coordinates consist of two characters, the first one is a lowercase Latin letter (from a to h), the second one is a digit from 1 to 8.","In the first line print *n* — minimum number of the king's moves. Then in *n* lines print the moves themselves. Each move is described with one of the 8: L, R, U, D, LU, LD, RU or RD. 

L, R, U, D stand respectively for moves left, right, up and down (according to the picture), and 2-letter combinations stand for diagonal moves. If the answer is not unique, print any of them.",['a8\nh1\n'],['7\nRD\nRD\nRD\nRD\nRD\nRD\nRD\n'],none,WRONG_ANSWER,"import sys
import math
from math import factorial, inf, gcd, sqrt
from heapq import *
from functools import *
from itertools import *
from collections import *
from typing import *
from bisect import *
import random
from sys import stdin, stdout
sys.setrecursionlimit(10**5)

def inp():
    return stdin.readline().strip()

def iinp():
    return int(inp())

def mp():
    return map(int, inp().split())

def lmp():
    return list(mp())

s = inp()
t = inp()
s = (int(s[1]), ord(s[0]) - ord('a') + 1)
t = (int(t[1]), ord(t[0]) - ord('a') + 1)
q = deque([s])
v = {s: 0}
while q:
    x, y = q.popleft()
    if (x, y) == t:
        break
    for i in range(-1, 2):
        for j in range(-1, 2):
            if i == 0 and j == 0:
                continue
            nx, ny = x + i, y + j
            if (nx, ny) not in v:
                v[(nx, ny)] = (x, y)
                q.append((nx, ny))
d = {
    (-1, -1): 'LU',
    (-1, 0): 'U',
    (-1, 1): 'RU',
    (0, -1): 'L',
    (0, 1): 'R',
    (1, -1): 'LD',
    (1, 0): 'D',
    (1, 1): 'RD'
}
ans = []
while v[t] != 0:
    k = v[t]
    c = (k[0] - t[0], t[1] - k[1])

    ans.append(d[c])
    t = k
print(len(ans))
for i in ans:
    print(i)","def chess_king_moves(start, target):

    start_col = ord(start[0]) - ord('a')
    start_row = int(start[1]) - 1
    
    target_col = ord(target[0]) - ord('a')
    target_row = int(target[1]) - 1

    moves = []

    while (start_row, start_col) != (target_row, target_col):
        move = ''

        if start_row < target_row:
            move += 'U'
            start_row += 1
        elif start_row > target_row:
            move += 'D'
            start_row -= 1

        if start_col < target_col:
            move += 'R'
            start_col += 1
        elif start_col > target_col:
            move += 'L'
            start_col -= 1
        
        moves.append(move)

    print(len(moves))
    print('\n'.join(moves))

start_square = input().strip()
target_square = input().strip()
chess_king_moves(start_square, target_square)"
393,A,Nineteen,PROGRAMMING,[],"Alice likes word ""nineteen"" very much. She has a string *s* and wants the string to contain as many such words as possible. For that reason she can rearrange the letters of the string.

For example, if she has string ""xiineteenppnnnewtnee"", she can get string ""xnineteenppnineteenw"", containing (the occurrences marked) two such words. More formally, word ""nineteen"" occurs in the string the number of times you can read it starting from some letter of the string. Of course, you shouldn't skip letters.

Help her to find the maximum number of ""nineteen""s that she can get in her string.","The first line contains a non-empty string *s*, consisting only of lowercase English letters. The length of string *s* doesn't exceed 100.","Print a single integer — the maximum number of ""nineteen""s that she can get in her string.","['nniinneetteeeenn\n', 'nneteenabcnneteenabcnneteenabcnneteenabcnneteenabcii\n', 'nineteenineteen\n']","['2', '2', '2']",none,RUNTIME_ERROR,"def printMatrix(matrix):
    for matrixrow in matrix:
        row = ''
        for value in matrixrow:
            row += str(value) + ' '
        print(row)

n = int(input())
w = [[0 for i in range(n)] for i in range(n)]
a = [[0 for i in range(n)] for i in range(n)]
b = [[0 for i in range(n)] for i in range(n)]
for i in range(n):
    row = input().split(' ')
    for e in range(n):
        w[i][e] = int(row[e])
for i in range(n):
    for e in range(n):
        a[e][i] = a[i][e] = (w[i][e]+w[e][i]) / 2
        b[e][i] = w[e][i] - a[e][i]
printMatrix(a)
printMatrix(b)","from collections import Counter

def max_nineteens(s):

    letter_count = Counter(s)

    required_letters = Counter(""nineteen"")

    max_count = float('inf')
    for letter, count in required_letters.items():
        max_count = min(max_count, letter_count[letter] // count)
    
    return max_count

input_strings = [
    'nniinneetteeeenn\n',
    'nneteenabcnneteenabcnneteenabcnneteenabcnneteenabcii\n',
    'nineteenineteen\n'
]

results = [str(max_nineteens(s.strip())) for s in input_strings]
print(results)"
0,none,none,none,['none'],"Little Nastya has a hobby, she likes to remove some letters from word, to obtain another word. But it turns out to be pretty hard for her, because she is too young. Therefore, her brother Sergey always helps her.

Sergey gives Nastya the word *t* and wants to get the word *p* out of it. Nastya removes letters in a certain order (one after another, in this order strictly), which is specified by permutation of letters' indices of the word *t*: *a*1... *a*|*t*|. We denote the length of word *x* as |*x*|. Note that after removing one letter, the indices of other letters don't change. For example, if *t*<==<=""nastya"" and *a*<==<=[4,<=1,<=5,<=3,<=2,<=6] then removals make the following sequence of words ""nastya""  ""nastya""  ""nastya""  ""nastya""  ""nastya""  ""nastya""  ""nastya"".

Sergey knows this permutation. His goal is to stop his sister at some point and continue removing by himself to get the word *p*. Since Nastya likes this activity, Sergey wants to stop her as late as possible. Your task is to determine, how many letters Nastya can remove before she will be stopped by Sergey.

It is guaranteed that the word *p* can be obtained by removing the letters from word *t*.","The first and second lines of the input contain the words *t* and *p*, respectively. Words are composed of lowercase letters of the Latin alphabet (1<=≤<=|*p*|<=&lt;<=|*t*|<=≤<=200<=000). It is guaranteed that the word *p* can be obtained by removing the letters from word *t*.

Next line contains a permutation *a*1,<=*a*2,<=...,<=*a*|*t*| of letter indices that specifies the order in which Nastya removes letters of *t* (1<=≤<=*a**i*<=≤<=|*t*|, all *a**i* are distinct).","Print a single integer number, the maximum number of letters that Nastya can remove.","['ababcba\nabb\n5 3 4 1 7 6 2\n', 'bbbabb\nbb\n1 6 3 4 2 5\n']","['3', '4']","In the first sample test sequence of removing made by Nastya looks like this:

""ababcba"" <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> ""ababcba"" <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> ""ababcba"" <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> ""ababcba"" 

Nastya can not continue, because it is impossible to get word ""abb"" from word ""ababcba"".

So, Nastya will remove only three letters.",TIME_LIMIT_EXCEEDED,"def check(lst, sub):
    s = len(sub)
    r = len(lst)
    k = 0
    for i in range(r):
        if k < s and lst[i] == sub[k]:
            k += 1        
        
    return k // s

def q(w, t, p, a):
    c = []
    for i in range(w):
        c.append(a[i] - 1)
    c.sort()
    s = []
    j = 0
    for i in range(len(t)):
        if j < w and i == c[j]:
            j += 1
        else:
            s.append(t[i])        
    return check(s, p)
 
def f(t, p, a):
    l = 0
    h = len(t)
    w = (l + h) // 2
    while not(q(w, t, p, a) == 1 and q(w + 1, t, p, a) == 0):
        if q(w, t, p, a) == 1:
            l = w
        else:
            h = w
        w = (l + h) // 2
        if w == 0:
            return 0
    return w    
 
t = list(input())
p = list(input())
a = list(map(int, input().split()))
print(f(t, p, a))","def maximum_removals(t, p, a):

    a = [x - 1 for x in a]

    t_index = 0
    p_index = 0
    removed_count = 0

    while t_index < len(t) and p_index < len(p):

        if t[t_index] == p[p_index]:
            p_index += 1

        t_index += 1
        removed_count += 1

        if t_index in a[:removed_count]:
            continue
        else:
            break

    return removed_count - (len(p) - p_index)

def main():
    t = input().strip()
    p = input().strip()
    a = list(map(int, input().strip().split()))

    result = maximum_removals(t, p, a)
    print(result)

if __name__ == ""__main__"":
    main()"
347,B,Fixed Points,PROGRAMMING,"['brute force', 'implementation', 'math']","A permutation of length *n* is an integer sequence such that each integer from 0 to (*n*<=-<=1) appears exactly once in it. For example, sequence [0,<=2,<=1] is a permutation of length 3 while both [0,<=2,<=2] and [1,<=2,<=3] are not.

A fixed point of a function is a point that is mapped to itself by the function. A permutation can be regarded as a bijective function. We'll get a definition of a fixed point in a permutation. An integer *i* is a fixed point of permutation *a*0,<=*a*1,<=...,<=*a**n*<=-<=1 if and only if *a**i*<==<=*i*. For example, permutation [0,<=2,<=1] has 1 fixed point and permutation [0,<=1,<=2] has 3 fixed points.

You are given permutation *a*. You are allowed to swap two elements of the permutation at most once. Your task is to maximize the number of fixed points in the resulting permutation. Note that you are allowed to make at most one swap operation.","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=105). The second line contains *n* integers *a*0,<=*a*1,<=...,<=*a**n*<=-<=1 — the given permutation.",Print a single integer — the maximum possible number of fixed points in the permutation after at most one swap operation.,['5\n0 1 3 4 2\n'],['3\n'],none,TIME_LIMIT_EXCEEDED,"_ = input()
inp = list(map(int, input().split(' ')))

def countpoints(l: list) -> int:
    count = 0
    for i, e in enumerate(l):
        if i == e:
            count += 1
    return count

_m = countpoints(inp)
m = 0
for i, e in enumerate(inp):
    if i == e:
        continue
    if inp.index(i) == e and inp[e] == i:
        m = max(m, _m + 2)
    else:
        m = max(m, _m + 1)

print(m)","def max_fixed_points(n, a):
    fixed_points = sum(1 for i in range(n) if a[i] == i)
    max_fixed = fixed_points

    for i in range(n):
        if a[i] != i:

            swap_with = a[i]
            if swap_with < n and a[swap_with] == i:
                max_fixed = max(max_fixed, fixed_points + 2)
                break

    if max_fixed == fixed_points:
        if fixed_points < n:
            max_fixed += 1

    return max_fixed

n = int(input())
a = list(map(int, input().split()))

print(max_fixed_points(n, a))"
764,A,Taymyr is calling you,PROGRAMMING,"['brute force', 'implementation', 'math']","Comrade Dujikov is busy choosing artists for Timofey's birthday and is recieving calls from Taymyr from Ilia-alpinist.

Ilia-alpinist calls every *n* minutes, i.e. in minutes *n*, 2*n*, 3*n* and so on. Artists come to the comrade every *m* minutes, i.e. in minutes *m*, 2*m*, 3*m* and so on. The day is *z* minutes long, i.e. the day consists of minutes 1,<=2,<=...,<=*z*. How many artists should be killed so that there are no artists in the room when Ilia calls? Consider that a call and a talk with an artist take exactly one minute.","The only string contains three integers — *n*, *m* and *z* (1<=≤<=*n*,<=*m*,<=*z*<=≤<=104).",Print single integer — the minimum number of artists that should be killed so that there are no artists in the room when Ilia calls.,"['1 1 10\n', '1 2 5\n', '2 3 9\n']","['10\n', '2\n', '1\n']","Taymyr is a place in the north of Russia.

In the first test the artists come each minute, as well as the calls, so we need to kill all of them.

In the second test we need to kill artists which come on the second and the fourth minutes.

In the third test — only the artist which comes on the sixth minute.",RUNTIME_ERROR,"def gcd(a,b):
    if (a == 0):
        return b
    if (b == 0):
        return a
    if (a == b):
        return a
    if (a > b):
        return gcd(a-b, b)
    return gcd(a, b-a)
    
n,m,z=map(int,input().split())
if n>m:
    g=gcd(n,m)
else:
    g=gcd(m,n)
lcm=n*m//g
print(z//lcm)","def count_killed_artists(n, m, z):

    import math

    lcm = n * m // math.gcd(n, m)

    return z // lcm

input_data = ['1 1 10\n', '1 2 5\n', '2 3 9\n']
results = []

for line in input_data:
    n, m, z = map(int, line.strip().split())
    killed_artists = count_killed_artists(n, m, z)
    results.append(killed_artists)

for result in results:
    print(result)"
7,A,Kalevitch and Chess,PROGRAMMING,"['brute force', 'constructive algorithms']","A famous Berland's painter Kalevitch likes to shock the public. One of his last obsessions is chess. For more than a thousand years people have been playing this old game on uninteresting, monotonous boards. Kalevitch decided to put an end to this tradition and to introduce a new attitude to chessboards.

As before, the chessboard is a square-checkered board with the squares arranged in a 8<=×<=8 grid, each square is painted black or white. Kalevitch suggests that chessboards should be painted in the following manner: there should be chosen a horizontal or a vertical line of 8 squares (i.e. a row or a column), and painted black. Initially the whole chessboard is white, and it can be painted in the above described way one or more times. It is allowed to paint a square many times, but after the first time it does not change its colour any more and remains black. Kalevitch paints chessboards neatly, and it is impossible to judge by an individual square if it was painted with a vertical or a horizontal stroke.

Kalevitch hopes that such chessboards will gain popularity, and he will be commissioned to paint chessboards, which will help him ensure a comfortable old age. The clients will inform him what chessboard they want to have, and the painter will paint a white chessboard meeting the client's requirements.

It goes without saying that in such business one should economize on everything — for each commission he wants to know the minimum amount of strokes that he has to paint to fulfill the client's needs. You are asked to help Kalevitch with this task.","The input file contains 8 lines, each of the lines contains 8 characters. The given matrix describes the client's requirements, W character stands for a white square, and B character — for a square painted black.

It is guaranteed that client's requirments can be fulfilled with a sequence of allowed strokes (vertical/column or horizontal/row).",Output the only number — the minimum amount of rows and columns that Kalevitch has to paint on the white chessboard to meet the client's requirements.,"['WWWBWWBW\nBBBBBBBB\nWWWBWWBW\nWWWBWWBW\nWWWBWWBW\nWWWBWWBW\nWWWBWWBW\nWWWBWWBW\n', 'WWWWWWWW\nBBBBBBBB\nWWWWWWWW\nWWWWWWWW\nWWWWWWWW\nWWWWWWWW\nWWWWWWWW\nWWWWWWWW\n']","['3\n', '1\n']",none,OK,"def readln(): return tuple(map(int, input().split()))

b = [list(input()) for _ in range(8)]
cnt1 = sum([1 for s in b if s == ['B'] * 8])
cnt2 = sum([1 for s in zip(*b) if list(s) == ['B'] * 8])
print(8 if cnt1 == 8 else cnt1 + cnt2)","def min_strokes(chessboard):

    row_count = [0] * 8
    col_count = [0] * 8

    for i in range(8):
        for j in range(8):
            if chessboard[i][j] == 'B':
                row_count[i] += 1
                col_count[j] += 1

    rows_to_paint = sum(1 for count in row_count if count > 0)
    cols_to_paint = sum(1 for count in col_count if count > 0)

    return min(rows_to_paint, cols_to_paint)

def main():
    chessboard = [input().strip() for _ in range(8)]
    print(min_strokes(chessboard))

if __name__ == ""__main__"":
    main()"
0,none,none,none,['none'],"For a given positive integer *n* denote its *k*-rounding as the minimum positive integer *x*, such that *x* ends with *k* or more zeros in base 10 and is divisible by *n*.

For example, 4-rounding of 375 is 375·80<==<=30000. 30000 is the minimum integer such that it ends with 4 or more zeros and is divisible by 375.

Write a program that will perform the *k*-rounding of *n*.","The only line contains two integers *n* and *k* (1<=≤<=*n*<=≤<=109, 0<=≤<=*k*<=≤<=8).",Print the *k*-rounding of *n*.,"['375 4\n', '10000 1\n', '38101 0\n', '123456789 8\n']","['30000\n', '10000\n', '38101\n', '12345678900000000\n']",none,TIME_LIMIT_EXCEEDED,"entrada = input()
a = int(entrada.split()[0])
k = int(entrada.split()[1])

def fatorar(x):
    A=[]
    for y in range(2,x):
        while x%y==0:
            x=x/y
            A.append(y)
    if sum(A)==0:
        A.append(x)
    return A  

if(k <= 1):
  print(a)

else:
  s = 10**k
  fatoresa = fatorar(a)
  mmc = a*s
  for i in fatoresa:
    if s%i == 0:
      mmc = int(mmc/i)
  print(mmc)","def k_rounding(n, k):

    multiplier = 10 ** k

    x = multiplier
    while x % n != 0:
        x += multiplier
    
    return x

input_data = input().strip()
n, k = map(int, input_data.split())

result = k_rounding(n, k)

print(result)"
743,B,Chloe and the sequence ,PROGRAMMING,"['binary search', 'bitmasks', 'constructive algorithms', 'implementation']","Chloe, the same as Vladik, is a competitive programmer. She didn't have any problems to get to the olympiad like Vladik, but she was confused by the task proposed on the olympiad.

Let's consider the following algorithm of generating a sequence of integers. Initially we have a sequence consisting of a single element equal to 1. Then we perform (*n*<=-<=1) steps. On each step we take the sequence we've got on the previous step, append it to the end of itself and insert in the middle the minimum positive integer we haven't used before. For example, we get the sequence [1,<=2,<=1] after the first step, the sequence [1,<=2,<=1,<=3,<=1,<=2,<=1] after the second step.

The task is to find the value of the element with index *k* (the elements are numbered from 1) in the obtained sequence, i. e. after (*n*<=-<=1) steps.

Please help Chloe to solve the problem!","The only line contains two integers *n* and *k* (1<=≤<=*n*<=≤<=50, 1<=≤<=*k*<=≤<=2*n*<=-<=1).",Print single integer — the integer at the *k*-th position in the obtained sequence.,"['3 2\n', '4 8\n']","['2', '4']","In the first sample the obtained sequence is [1, 2, 1, 3, 1, 2, 1]. The number on the second position is 2.

In the second sample the obtained sequence is [1, 2, 1, 3, 1, 2, 1, 4, 1, 2, 1, 3, 1, 2, 1]. The number on the eighth position is 4.",OK,"def getAns(n, k):
    c = 1 << (n - 1)
    if k == c: return n
    if k < c: return getAns(n - 1, k)
    return getAns(n - 1, k - c)

if __name__ == '__main__':
    n, k = map(int, input().strip().split())
    print(getAns(n, k))","def generate_sequence(n):

    sequence = [1]
    
    for i in range(1, n + 1):

        current_min = i + 1

        sequence = sequence + [current_min] + sequence
    
    return sequence

def find_kth_element(n, k):

    sequence = generate_sequence(n)

    return sequence[k - 1]

if __name__ == ""__main__"":

    inputs = ['3 2\n', '4 8\n']
    results = []
    
    for inp in inputs:
        n, k = map(int, inp.strip().split())
        result = find_kth_element(n, k)
        results.append(result)

    for res in results:
        print(res)"
776,C,Molly's Chemicals,PROGRAMMING,"['binary search', 'brute force', 'data structures', 'implementation', 'math']","Molly Hooper has *n* different kinds of chemicals arranged in a line. Each of the chemicals has an affection value, The *i*-th of them has affection value *a**i*.

Molly wants Sherlock to fall in love with her. She intends to do this by mixing a contiguous segment of chemicals together to make a love potion with total affection value as a non-negative integer power of *k*. Total affection value of a continuous segment of chemicals is the sum of affection values of each chemical in that segment.

Help her to do so in finding the total number of such segments.","The first line of input contains two integers, *n* and *k*, the number of chemicals and the number, such that the total affection value is a non-negative power of this number *k*. (1<=≤<=*n*<=≤<=105, 1<=≤<=|*k*|<=≤<=10).

Next line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (<=-<=109<=≤<=*a**i*<=≤<=109) — affection values of chemicals.",Output a single integer — the number of valid segments.,"['4 2\n2 2 2 2\n', '4 -3\n3 -6 -3 12\n']","['8\n', '3\n']","Do keep in mind that *k*<sup class=""upper-index"">0</sup> = 1.

In the first sample, Molly can get following different affection values: 
 - 2: segments [1, 1], [2, 2], [3, 3], [4, 4]; - 4: segments [1, 2], [2, 3], [3, 4]; - 6: segments [1, 3], [2, 4]; - 8: segments [1, 4]. 
Out of these, 2, 4 and 8 are powers of *k* = 2. Therefore, the answer is 8.

In the second sample, Molly can choose segments [1, 2], [3, 3], [3, 4].",WRONG_ANSWER,"from sys import stdin
input = stdin.readline
def f(a, k):
	pref = 0
	ans = 0
	d = {0: 1}
	t = 1
	s = sum(a)
	fac = [1]
	for i in range(50):
		t *= k
		fac.append(t)
	for i in a:
		pref += i
		for num in fac:
			need = pref - num
			ans += d.get(need, 0)
		d[pref] = d.get(pref, 0) + 1
	return ans

n, k = map(int, input().strip().split())
a = list(map(int, input().strip().split()))
print(f(a, k))","def count_power_segments(n, k, affection_values):

    count = 0

    power_set = set()

    current_power = 1
    while current_power <= 10**9:
        power_set.add(current_power)
        current_power *= k

    prefix_sums = {0: 1}
    
    total_sum = 0
    
    for value in affection_values:
        total_sum += value

        for power in power_set:
            if (total_sum - power) in prefix_sums:
                count += prefix_sums[total_sum - power]

        if total_sum in prefix_sums:
            prefix_sums[total_sum] += 1
        else:
            prefix_sums[total_sum] = 1
            
    return count

n, k = map(int, input().split())
affection_values = list(map(int, input().split()))

result = count_power_segments(n, k, affection_values)

print(result)"
593,A,2Char,PROGRAMMING,"['brute force', 'implementation']","Andrew often reads articles in his favorite magazine 2Char. The main feature of these articles is that each of them uses at most two distinct letters. Andrew decided to send an article to the magazine, but as he hasn't written any article, he just decided to take a random one from magazine 26Char. However, before sending it to the magazine 2Char, he needs to adapt the text to the format of the journal. To do so, he removes some words from the chosen article, in such a way that the remaining text can be written using no more than two distinct letters.

Since the payment depends from the number of non-space characters in the article, Andrew wants to keep the words with the maximum total length.","The first line of the input contains number *n* (1<=≤<=*n*<=≤<=100) — the number of words in the article chosen by Andrew. Following are *n* lines, each of them contains one word. All the words consist only of small English letters and their total length doesn't exceed 1000. The words are not guaranteed to be distinct, in this case you are allowed to use a word in the article as many times as it appears in the input.",Print a single integer — the maximum possible total length of words in Andrew's article.,"['4\nabb\ncacc\naaa\nbbb\n', '5\na\na\nbcbcb\ncdecdecdecdecdecde\naaaa\n']","['9', '6']","In the first sample the optimal way to choose words is {'abb', 'aaa', 'bbb'}.

In the second sample the word 'cdecdecdecdecdecde' consists of three distinct letters, and thus cannot be used in the article. The optimal answer is {'a', 'a', 'aaaa'}.",RUNTIME_ERROR,"def cnt_letters(x):
    if str.isdigit(x[0]) or (x[0] == '\n'):
        return 42
    d = {}
    cnt = 0
    for c in x:
        if not (c in d.keys()):
            d[c] = 0
            cnt += 1
        else:
            d[c] += 1
    return cnt

import sys
words = []
for x in sys.stdin.readlines():
    if cnt_letters(x.strip()) < 3:
        words.append(x.strip()) 

d = {}
for x in words:
   for c in x:
        if not c in d.keys():
            d[c] = 0
        else:
            d[c] += 1         

d = sorted(d.items(), key=lambda x: -x[1])
maxl = d[0][0]
if len(d) > 9000:
    smaxl = list(d.keys())[1]
else:
    smaxl = ''
    
res = 0
for x in words:
    if cnt_letters(x) == 2:
        if str.find(x, maxl) > -1 and str.find(x, smaxl) > -1:
            res += len(x)
    else:
        if str.find(x, maxl) > -1 or str.find(x, smaxl) > -1:
            res += len(x)
            
print(res)","def max_length_two_letters(n, words):
    from collections import defaultdict

    length_dict = defaultdict(int)
    
    for word in words:

        unique_letters = set(word)

        if len(unique_letters) <= 2:
            length_dict[frozenset(unique_letters)] += len(word)

    return max(length_dict.values(), default=0)

n = int(input().strip())
words = [input().strip() for _ in range(n)]

result = max_length_two_letters(n, words)

print(result)"
296,A,Yaroslav and Permutations,PROGRAMMING,"['greedy', 'math']","Yaroslav has an array that consists of *n* integers. In one second Yaroslav can swap two neighboring array elements. Now Yaroslav is wondering if he can obtain an array where any two neighboring elements would be distinct in a finite time.

Help Yaroslav.","The first line contains integer *n* (1<=≤<=*n*<=≤<=100) — the number of elements in the array. The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=1000) — the array elements.","In the single line print ""YES"" (without the quotes) if Yaroslav can obtain the array he needs, and ""NO"" (without the quotes) otherwise.","['1\n1\n', '3\n1 1 2\n', '4\n7 7 7 7\n']","['YES\n', 'YES\n', 'NO\n']","In the first sample the initial array fits well.

In the second sample Yaroslav can get array: 1, 2, 1. He can swap the last and the second last elements to obtain it.

In the third sample Yarosav can't get the array he needs.",RUNTIME_ERROR,"from sys import stdin
input = stdin.readline

inp = lambda : list(map(int,input().split()))

def answer():

    count = [0 for i in range(n + 1)]
    for i in range(n):
        count[a[i]] += 1

    if(max(count) > ((n + 1) // 2)):
        return 'NO'

    return 'YES'

for T in range(1):

    n = int(input())
    a = inp()

    print(answer())","def can_obtain_distinct_neighbors(n, arr):
    from collections import Counter

    count = Counter(arr)

    max_occurrence = max(count.values())

    if max_occurrence <= (n + 1) // 2:
        return ""YES""
    else:
        return ""NO""

if __name__ == ""__main__"":
    n = int(input().strip())
    arr = list(map(int, input().strip().split()))

    result = can_obtain_distinct_neighbors(n, arr)
    print(result)"
61,C,Capture Valerian,PROGRAMMING,['math'],"It's now 260 AD. Shapur, being extremely smart, became the King of Persia. He is now called Shapur, His majesty King of kings of Iran and Aniran.

Recently the Romans declared war on Persia. They dreamed to occupy Armenia. In the recent war, the Romans were badly defeated. Now their senior army general, Philip is captured by Shapur and Shapur is now going to capture Valerian, the Roman emperor.

Being defeated, the cowardly Valerian hid in a room at the top of one of his castles. To capture him, Shapur has to open many doors. Fortunately Valerian was too scared to make impenetrable locks for the doors.

Each door has 4 parts. The first part is an integer number *a*. The second part is either an integer number *b* or some really odd sign which looks like R. The third one is an integer *c* and the fourth part is empty! As if it was laid for writing something. Being extremely gifted, after opening the first few doors, Shapur found out the secret behind the locks.

*c* is an integer written in base *a*, to open the door we should write it in base *b*. The only bad news is that this R is some sort of special numbering system that is used only in Roman empire, so opening the doors is not just a piece of cake!

Here's an explanation of this really weird number system that even doesn't have zero:

Roman numerals are based on seven symbols: a stroke (identified with the letter I) for a unit, a chevron (identified with the letter V) for a five, a cross-stroke (identified with the letter X) for a ten, a C (identified as an abbreviation of Centum) for a hundred, etc.:
-  I=1-  V=5-  X=10-  L=50-  C=100-  D=500-  M=1000
Symbols are iterated to produce multiples of the decimal (1, 10, 100, 1,<=000) values, with V, L, D substituted for a multiple of five, and the iteration continuing: I 1, II 2, III 3, V 5, VI 6, VII 7, etc., and the same for other bases: X 10, XX 20, XXX 30, L 50, LXXX 80; CC 200, DCC 700, etc. At the fourth and ninth iteration, a subtractive principle must be employed, with the base placed before the higher base: IV 4, IX 9, XL 40, XC 90, CD 400, CM 900.

Also in bases greater than 10 we use A for 10, B for 11, etc.

Help Shapur capture Valerian and bring peace back to Persia, especially Armenia.","The first line contains two integers *a* and *b* (2<=≤<=*a*,<=*b*<=≤<=25). Only *b* may be replaced by an R which indicates Roman numbering system.

The next line contains a single non-negative integer *c* in base *a* which may contain leading zeros but its length doesn't exceed 103. 

It is guaranteed that if we have Roman numerals included the number would be less than or equal to 300010 and it won't be 0. In any other case the number won't be greater than 101510.",Write a single line that contains integer *c* in base *b*. You must omit leading zeros.,"['10 2\n1\n', '16 R\n5\n', '5 R\n4\n', '2 2\n1111001\n', '12 13\nA\n']","['1\n', 'V\n', 'IV\n', '1111001\n', 'A\n']",You can find more information about roman numerals here: http://en.wikipedia.org/wiki/Roman_numerals,OK,"numbers = {'0':0,'1':1,'2':2,'3':3,'4':4,'5':5,'6':6,'7':7,'8':8,'9':9,'A':10,'B':11,'C':12,'D':13,'E':14,'F':15,'G':16,'H':17,'I':18,'J':19,'K':20,'L':21,'M':22,'N':23,'O':24,'P':25,'Q':26,'R':27,'S':28,'T':29,'U':30,'V':31,'W':32,'X':33,'Y':34,'Z':35}
characters = {0:'0',1:'1',2:'2',3:'3',4:'4',5:'5',6:'6',7:'7',8:'8',9:'9',10:'A',11:'B',12:'C',13:'D',14:'E',15:'F',16:'G',17:'H',18:'I',19:'J',20:'K',21:'L',22:'M',23:'N',24:'O',25:'P',26:'Q',27:'R',28:'S',29:'T',30:'U',31:'V',32:'W',33:'X',34:'Y',35:'Z'}

def ConvertToDecimal(number, base):
	newnumber = 0
	for digit in range(-1,(0-len(number))-1,-1):
		if(numbers[number[digit]] >= int(base)):
			return -1
		newnumber += numbers[number[digit]]*(int(base)**(0-digit-1))
	return newnumber
	
def ConvertToBase(number, base):
	newnumber = ''
	if(number == 0):
		return '0'
	while number > 0:
		newnumber = characters[number%base] + newnumber
		number = number//base
	return newnumber
	
def ConvertToRoman(number):
	newnumber = ''
	for i in range(4,0,-1):
		currentnumber = (number%(10**i) - number%(10**(i-1)))//(10**(i-1))
		if(currentnumber > 0):
			if(i==4):
				newnumber += 'M'*currentnumber
			elif(i==3):
				if(currentnumber == 9):
					newnumber += 'CM'
				elif(currentnumber>=5):
					newnumber += 'D' + 'C'*(currentnumber-5)
				elif currentnumber == 4:
					newnumber += 'CD'
				else:
					newnumber += 'C'*currentnumber
			elif(i==2):
				if(currentnumber == 9):
					newnumber += 'XC'
				elif(currentnumber>=5):
					newnumber += 'L' + 'X'*(currentnumber-5)
				elif currentnumber == 4:
					newnumber += 'XL'
				else:
					newnumber += 'X'*currentnumber
			elif(i==1):
				if(currentnumber == 9):
					newnumber += 'IX'
				elif(currentnumber>=5):
					newnumber += 'V' + 'I'*(currentnumber-5)
				elif currentnumber == 4:
					newnumber += 'IV'
				else:
					newnumber += 'I'*currentnumber
	return newnumber
	
a,b = [x for x in input().split()]
c = input()

if b == 'R':
	print(ConvertToRoman(ConvertToDecimal(c,int(a))))
else:
	print(ConvertToBase(ConvertToDecimal(c,int(a)),int(b)))","def roman_to_decimal(roman):
    roman_values = {
        'I': 1, 'V': 5, 'X': 10, 'L': 50,
        'C': 100, 'D': 500, 'M': 1000
    }
    decimal_value = 0
    prev_value = 0
    
    for char in reversed(roman):
        value = roman_values[char]
        if value < prev_value:
            decimal_value -= value
        else:
            decimal_value += value
        prev_value = value
    
    return decimal_value

def decimal_to_base(num, base):
    if num == 0:
        return ""0""
        
    digits = []
    while num:
        remainder = num % base
        if remainder >= 10:
            digits.append(chr(remainder - 10 + ord('A')))
        else:
            digits.append(str(remainder))
        num //= base
    
    return ''.join(reversed(digits))

def process_locks(a, b, c):

    decimal_value = 0
    for digit in c:
        if '0' <= digit <= '9':
            decimal_value = decimal_value * a + int(digit)
        else:
            decimal_value = decimal_value * a + (ord(digit) - ord('A') + 10)

    if b == 'R':
        return decimal_to_base(roman_to_decimal(c), 10)

    return decimal_to_base(decimal_value, b)

import sys

lines = sys.stdin.read().strip().split('\n')

base_a, base_b = lines[0].split()
base_a = int(base_a)
if base_b == 'R':
    base_b = 'R'
else:
    base_b = int(base_b)

number_c = lines[1].strip()

result = process_locks(base_a, base_b, number_c)

print(result)"
918,A,Eleven,PROGRAMMING,"['brute force', 'implementation']","Eleven wants to choose a new name for herself. As a bunch of geeks, her friends suggested an algorithm to choose a name for her. Eleven wants her name to have exactly *n* characters. 

Her friend suggested that her name should only consist of uppercase and lowercase letters 'O'. More precisely, they suggested that the *i*-th letter of her name should be 'O' (uppercase) if *i* is a member of Fibonacci sequence, and 'o' (lowercase) otherwise. The letters in the name are numbered from 1 to *n*. Fibonacci sequence is the sequence *f* where
 -  *f*1<==<=1, -  *f*2<==<=1, -  *f**n*<==<=*f**n*<=-<=2<=+<=*f**n*<=-<=1 (*n*<=&gt;<=2). 
As her friends are too young to know what Fibonacci sequence is, they asked you to help Eleven determine her new name.",The first and only line of input contains an integer *n* (1<=≤<=*n*<=≤<=1000).,Print Eleven's new name on the first and only line of output.,"['8\n', '15\n']","['OOOoOooO\n', 'OOOoOooOooooOoo\n']",none,OK,"s = """"

def fibo(i):
    if i == 1:
        return 0
    elif i == 2:
        return 0
    a = 0
    b = 1
    c = 0
    while c < i:
        c = a + b
        a = b
        b = c
        if c == i:
            return 0
    return 1

for i in range(1,int(input())+1):
    if fibo(i) == 0:
        s += ""O""
    else:
        s += ""o""
print(s)","def is_fibonacci(num):

    a, b = 0, 1
    while a < num:
        a, b = b, a + b
    return a == num

def generate_name(n):

    name = """"
    for i in range(1, n + 1):
        if is_fibonacci(i):
            name += 'O'
        else:
            name += 'o'
    return name

n = int(input().strip())

print(generate_name(n))"
837,B,Flag of Berland,PROGRAMMING,"['brute force', 'implementation']","The flag of Berland is such rectangular field *n*<=×<=*m* that satisfies following conditions:
 -  Flag consists of three colors which correspond to letters 'R', 'G' and 'B'. -  Flag consists of three equal in width and height stripes, parralel to each other and to sides of the flag. Each stripe has exactly one color. -  Each color should be used in exactly one stripe. 
You are given a field *n*<=×<=*m*, consisting of characters 'R', 'G' and 'B'. Output ""YES"" (without quotes) if this field corresponds to correct flag of Berland. Otherwise, print ""NO"" (without quotes).","The first line contains two integer numbers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=100) — the sizes of the field.

Each of the following *n* lines consisting of *m* characters 'R', 'G' and 'B' — the description of the field.","Print ""YES"" (without quotes) if the given field corresponds to correct flag of Berland . Otherwise, print ""NO"" (without quotes).","['6 5\nRRRRR\nRRRRR\nBBBBB\nBBBBB\nGGGGG\nGGGGG\n', '4 3\nBRG\nBRG\nBRG\nBRG\n', '6 7\nRRRGGGG\nRRRGGGG\nRRRGGGG\nRRRBBBB\nRRRBBBB\nRRRBBBB\n', '4 4\nRRRR\nRRRR\nBBBB\nGGGG\n']","['YES\n', 'YES\n', 'NO\n', 'NO\n']","The field in the third example doesn't have three parralel stripes.

Rows of the field in the fourth example are parralel to each other and to borders. But they have different heights — 2, 1 and 1.",RUNTIME_ERROR,"n,_=map(int,input().split())
s=input()
n-=1
a=''
k=0
if 'R' in s:
    k+=1
if 'G' in s:
    k+=1
if 'B' in s:
    k+=1
t=1
if k>1:
    for _ in range(n):
        s1=input()
        if s1!=s:
            t=0
            break
elif k==1:
    a+=s[0]
    for _ in range(n):
        s=input()
        a+=s[0]
        k = 0
        if 'R' in s:
            k += 1
        if 'G' in s:
            k += 1
        if 'B' in s:
            k += 1
        if k!=1:
            t=0
            break

def f(a):
    if len(a)%3>0:
        return 1
    b=len(a)//3
    if a[0]*b+a[b]*b+a[-1]*b!=a:
        return 1
    k = 0
    if 'R' in a:
        k += 1
    if 'G' in a:
        k += 1
    if 'B' in a:
        k += 1
    if k!=3:
        return 1
    return 0

if t==0 or f(a):
    print('NO')
else:
    print('YES')","def is_valid_flag(n, m, field):

    if n % 3 != 0:
        return ""NO""
    
    stripe_height = n // 3
    colors = set()

    for i in range(3):
        start_row = i * stripe_height

        for j in range(stripe_height):
            if field[start_row + j] != field[start_row]:
                return ""NO""

        colors.add(field[start_row][0])

    if len(colors) != 3:
        return ""NO""

    return ""YES""

def main():
    import sys
    input = sys.stdin.read
    data = input().splitlines()
    
    n, m = map(int, data[0].split())
    
    field = data[1:n+1]
    result = is_valid_flag(n, m, field)
    print(result)

if __name__ == ""__main__"":
    main()"
669,A,Little Artem and Presents,PROGRAMMING,['math'],"Little Artem got *n* stones on his birthday and now wants to give some of them to Masha. He knows that Masha cares more about the fact of receiving the present, rather than the value of that present, so he wants to give her stones as many times as possible. However, Masha remembers the last present she received, so Artem can't give her the same number of stones twice in a row. For example, he can give her 3 stones, then 1 stone, then again 3 stones, but he can't give her 3 stones and then again 3 stones right after that.

How many times can Artem give presents to Masha?",The only line of the input contains a single integer *n* (1<=≤<=*n*<=≤<=109) — number of stones Artem received on his birthday.,Print the maximum possible number of times Artem can give presents to Masha.,"['1\n', '2\n', '3\n', '4\n']","['1\n', '1\n', '2\n', '3\n']","In the first sample, Artem can only give 1 stone to Masha.

In the second sample, Atrem can give Masha 1 or 2 stones, though he can't give her 1 stone two times.

In the third sample, Atrem can first give Masha 2 stones, a then 1 more stone.

In the fourth sample, Atrem can first give Masha 1 stone, then 2 stones, and finally 1 stone again.",WRONG_ANSWER,"def main():
	n = int(input())
	return solver(n)

def solver(n):
	if n % 3 == 0:
		return n // 3 * 2
	elif n % 3 == 1:
		return (2 * n + 1) // 3
	else:
		return (2 * (n - 1) + 1) // 3

main()","def max_gifts(n):

    if n == 1:
        return 1
    else:

        return (n + 1) // 2

n = int(input())

print(max_gifts(n))"
754,B,Ilya and tic-tac-toe game,PROGRAMMING,"['brute force', 'implementation']","Ilya is an experienced player in tic-tac-toe on the 4<=×<=4 field. He always starts and plays with Xs. He played a lot of games today with his friend Arseny. The friends became tired and didn't finish the last game. It was Ilya's turn in the game when they left it. Determine whether Ilya could have won the game by making single turn or not. 

The rules of tic-tac-toe on the 4<=×<=4 field are as follows. Before the first turn all the field cells are empty. The two players take turns placing their signs into empty cells (the first player places Xs, the second player places Os). The player who places Xs goes first, the another one goes second. The winner is the player who first gets three of his signs in a row next to each other (horizontal, vertical or diagonal).","The tic-tac-toe position is given in four lines.

Each of these lines contains four characters. Each character is '.' (empty cell), 'x' (lowercase English letter x), or 'o' (lowercase English letter o). It is guaranteed that the position is reachable playing tic-tac-toe, and it is Ilya's turn now (in particular, it means that the game is not finished). It is possible that all the cells are empty, it means that the friends left without making single turn.","Print single line: ""YES"" in case Ilya could have won by making single turn, and ""NO"" otherwise.","['xx..\n.oo.\nx...\noox.\n', 'x.ox\nox..\nx.o.\noo.x\n', 'x..x\n..oo\no...\nx.xo\n', 'o.x.\no...\n.x..\nooxx\n']","['YES\n', 'NO\n', 'YES\n', 'NO\n']","In the first example Ilya had two winning moves: to the empty cell in the left column and to the leftmost empty cell in the first row.

In the second example it wasn't possible to win by making single turn.

In the third example Ilya could have won by placing X in the last row between two existing Xs.

In the fourth example it wasn't possible to win by making single turn.",WRONG_ANSWER,"m = []
for i in range(4):
    m.append(input())

def match(r,c, r2, c2):
    if r > 3 or c > 3 or r < 0 or c < 0 or r2 > 3 or c2 > 3 or r2 < 0 or c2 < 0:
        return False
    return m[r][c] == ""x"" and m[r2][c2] == ""x""

def check(r,c):
    if(match(r,c+1,r,c-1) or\
       match(r,c+1,r,c+2) or\
       match(r,c-1,r,c-2) or\
       match(r+1,c,r-1,c) or\
       match(r+1,c,r+2,c) or\
       match(r-1,c,r-2,c) or\
       match(r+1,c+1,r-1,c-1) or\
       match(r+1,c+1,r+2,c+2) or\
       match(r-1,c-1,r-2,c-2) or\
       match(r-1,c+1,r+1,c-1) or\
       match(r-1,c+1,r-2,c-2) or\
       match(r+1,c-1,r+2,c-2)):
        return True
    return False

def solve():
    for row in range(4):
        for column in range(4):
            if m[row][column] == ""."":
                if check(row,column):
                    return ""YES""
    return ""NO""

print(solve())","def can_win_by_single_move(board):

    def is_winning_move(r, c):

        if board[r].count('x') == 2 and board[r][c] == '.':
            return True

        if sum(board[i][c] == 'x' for i in range(4)) == 2:
            return True

        if r == c and sum(board[i][i] == 'x' for i in range(4)) == 2:
            return True

        if r + c == 3 and sum(board[i][3 - i] == 'x' for i in range(4)) == 2:
            return True
        return False

    for i in range(4):
        for j in range(4):
            if board[i][j] == '.':

                if is_winning_move(i, j):
                    return ""YES""
    
    return ""NO""

input_data = ['xx..\n.oo.\nx...\noox.\n', 'x.ox\nox..\nx.o.\noo.x\n', 'x..x\n..oo\no...\nx.xo\n', 'o.x.\no...\n.x..\nooxx\n']
output_data = []

for game in input_data:

    board = game.strip().split('\n')
    result = can_win_by_single_move(board)
    output_data.append(result)

print(output_data)"
1,A,Theatre Square,PROGRAMMING,['math'],"Theatre Square in the capital city of Berland has a rectangular shape with the size *n*<=×<=*m* meters. On the occasion of the city's anniversary, a decision was taken to pave the Square with square granite flagstones. Each flagstone is of the size *a*<=×<=*a*.

What is the least number of flagstones needed to pave the Square? It's allowed to cover the surface larger than the Theatre Square, but the Square has to be covered. It's not allowed to break the flagstones. The sides of flagstones should be parallel to the sides of the Square.","The input contains three positive integer numbers in the first line: *n*,<=<=*m* and *a* (1<=≤<=<=*n*,<=*m*,<=*a*<=≤<=109).",Write the needed number of flagstones.,['6 6 4\n'],['4\n'],none,RUNTIME_ERROR,"{
 ""cells"": [
  {
   ""cell_type"": ""code"",
   ""execution_count"": 1,
   ""id"": ""fa1a81ed"",
   ""metadata"": {},
   ""outputs"": [],
   ""source"": [
    ""def theatre_square(n, m, a):\n"",
    ""    if n//a == n/a and m//a == m/a:\n"",
    ""        s1 = n/a\n"",
    ""        s2 = m/a\n"",
    ""    elif n//a == n/a and m//a != m/a:\n"",
    ""        s1 = s1/n\n"",
    ""        s2 = m//a + 1\n"",
    ""    elif n//a != n/a and m//a == m/a:\n"",
    ""        s1 = n//a + 1\n"",
    ""        s2 = m/a\n"",
    ""    else:\n"",
    ""        s1 = n//a + 1\n"",
    ""        s2 = m//a + 1\n"",
    ""    return s1 * s2""
   ]
  },
  {
   ""cell_type"": ""code"",
   ""execution_count"": 2,
   ""id"": ""2d41b786"",
   ""metadata"": {},
   ""outputs"": [
    {
     ""data"": {
      ""text/plain"": [
       ""4""
      ]
     },
     ""execution_count"": 2,
     ""metadata"": {},
     ""output_type"": ""execute_result""
    }
   ],
   ""source"": [
    ""theatre_square(6,6,4)""
   ]
  },
  {
   ""cell_type"": ""code"",
   ""execution_count"": null,
   ""id"": ""43546a58"",
   ""metadata"": {},
   ""outputs"": [],
   ""source"": []
  }
 ],
 ""metadata"": {
  ""kernelspec"": {
   ""display_name"": ""Python 3 (ipykernel)"",
   ""language"": ""python"",
   ""name"": ""python3""
  },
  ""language_info"": {
   ""codemirror_mode"": {
    ""name"": ""ipython"",
    ""version"": 3
   },
   ""file_extension"": "".py"",
   ""mimetype"": ""text/x-python"",
   ""name"": ""python"",
   ""nbconvert_exporter"": ""python"",
   ""pygments_lexer"": ""ipython3"",
   ""version"": ""3.9.2""
  }
 },
 ""nbformat"": 4,
 ""nbformat_minor"": 5
}","import math

n, m, a = map(int, input().strip().split())

flagstones_length = math.ceil(n / a)
flagstones_width = math.ceil(m / a)

total_flagstones = flagstones_length * flagstones_width

print(total_flagstones)"
967,B,Watering System,PROGRAMMING,"['math', 'sortings']","Arkady wants to water his only flower. Unfortunately, he has a very poor watering system that was designed for $n$ flowers and so it looks like a pipe with $n$ holes. Arkady can only use the water that flows from the first hole.

Arkady can block some of the holes, and then pour $A$ liters of water into the pipe. After that, the water will flow out from the non-blocked holes proportionally to their sizes $s_1, s_2, \ldots, s_n$. In other words, if the sum of sizes of non-blocked holes is $S$, and the $i$-th hole is not blocked, $\frac{s_i \cdot A}{S}$ liters of water will flow out of it.

What is the minimum number of holes Arkady should block to make at least $B$ liters of water flow out of the first hole?","The first line contains three integers $n$, $A$, $B$ ($1 \le n \le 100\,000$, $1 \le B \le A \le 10^4$) — the number of holes, the volume of water Arkady will pour into the system, and the volume he wants to get out of the first hole.

The second line contains $n$ integers $s_1, s_2, \ldots, s_n$ ($1 \le s_i \le 10^4$) — the sizes of the holes.",Print a single integer — the number of holes Arkady should block.,"['4 10 3\n2 2 2 2\n', '4 80 20\n3 2 1 4\n', '5 10 10\n1000 1 1 1 1\n']","['1\n', '0\n', '4\n']","In the first example Arkady should block at least one hole. After that, $\frac{10 \cdot 2}{6} \approx 3.333$ liters of water will flow out of the first hole, and that suits Arkady.

In the second example even without blocking any hole, $\frac{80 \cdot 3}{10} = 24$ liters will flow out of the first hole, that is not less than $20$.

In the third example Arkady has to block all holes except the first to make all water flow out of the first hole.",TIME_LIMIT_EXCEEDED,"def volume(s,a,b):
    return(((a*s[0])/sum(s))>=b)
n,a,b=map(int,input().split())
s=list(map(int,input().split()))
x=len(s)
while not volume(s,a,b):
    s.pop(s.index(max(s[1:])))
print(x-len(s))","def min_holes_to_block(n, A, B, sizes):

    min_size_needed = (B * sum(sizes)) / A

    if sizes[0] >= min_size_needed:
        return 0

    other_sizes = sizes[1:]

    other_sizes.sort(reverse=True)

    current_size = sizes[0]
    count = 0

    for size in other_sizes:
        count += 1
        current_size += size

        if current_size * A >= B * (current_size + size):
            return count

    return len(other_sizes)

input_data = input().strip().split('\n')
n, A, B = map(int, input_data[0].split())
sizes = list(map(int, input_data[1].split()))

result = min_holes_to_block(n, A, B, sizes)
print(result)"
55,B,Smallest number,PROGRAMMING,['brute force'],"Recently, Vladimir got bad mark in algebra again. To avoid such unpleasant events in future he decided to train his arithmetic skills. He wrote four integer numbers *a*, *b*, *c*, *d* on the blackboard. During each of the next three minutes he took two numbers from the blackboard (not necessarily adjacent) and replaced them with their sum or their product. In the end he got one number. Unfortunately, due to the awful memory he forgot that number, but he remembers four original numbers, sequence of the operations and his surprise because of the very small result. Help Vladimir remember the forgotten number: find the smallest number that can be obtained from the original numbers by the given sequence of operations.","First line contains four integers separated by space: 0<=≤<=*a*,<=*b*,<=*c*,<=*d*<=≤<=1000 — the original numbers. Second line contains three signs ('+' or '*' each) separated by space — the sequence of the operations in the order of performing. ('+' stands for addition, '*' — multiplication)","Output one integer number — the minimal result which can be obtained.

Please, do not use %lld specificator to read or write 64-bit integers in C++. It is preffered to use cin (also you may use %I64d).","['1 1 1 1\n+ + *\n', '2 2 2 2\n* * +\n', '1 2 3 4\n* + +\n']","['3\n', '8\n', '9\n']",none,WRONG_ANSWER,"'''''
arr= [1,3,4,3]
i=0
for k in range(8):
    if i!=arr[i]-1:
        if arr[i]!=arr[arr[i]-1]:
            print(arr[i],arr[arr[i]-1],arr,i)
            arr[i],arr[arr[i]-1]=arr[arr[i]-1],arr[i]
        else:
            i+=1
    else:
        i+=1
print(arr)
'''''

'''
def AllParenthesis(n):

    def backtrack(ans,curr,openp,closep,maxp):
        if len(curr)==2*maxp:
            ans.append(curr)
            return
        if openp<maxp:
            backtrack(ans,curr+""("",openp+1,closep,maxp)
        if closep<openp:
            backtrack(ans,curr+"")"",openp,closep+1,maxp)

    ans = []
    openp, closep = 0, 0
    curr = ''
    backtrack(ans, curr, openp, closep, n)
    return ans
print(AllParenthesis(3))
'''

'''temp=[[0 for x in range(len(mat[0]))]for x in range(len(mat))]
for i in range(len(mat)):
    temp[i][0]=mat[i][0]
    for j in range(1,len(mat[0])):
        temp[i][j]=temp[i][j-1]+mat[i][j]
for i in range(1,len(mat)):
    for j in range(len(mat[0])):
        temp[i][j]=temp[i-1][j]+temp[i][j]

k=3
lr=0
lc=0
rr=0
rc=0
ans=[[0 for x in range(len(mat[0]))]for x in range(len(mat))]
for i in range(len(mat)):
    for j in range(len(mat[0])):
        area1 = 0
        area2 = 0
        area3 = 0

        lr=i
        lc=j
        if i-k>=0:
            lr=i-k
        else:
            lr=0
        if j-k>=0:
            lc=j-k
        else:
            lc=0
        rr=i
        rc=j
        if i+k<len(mat):
            rr=i+k
        else:
            rr=len(mat)-1
        if j+k<len(mat[0]):
            rc=j+k
        else:
            rc=len(mat[0])-1
        if lc-1>=0:
            area1=temp[rr][lc-1]

        if lr-1>=0:
            area2=temp[lr-1][rc]
        if lr-1>=0 and lc-1>=0:
            area3=temp[lr-1][lc-1]
        ans[i][j]=temp[rr][rc]-area1-area2+area3'''

'''print(ans)'''
'''
nums = [-1,0,1,2,-1,-4]
nums.sort()
print(nums)
seen = set()
length=len(nums)
ans=[]
i=0
while i<length-2:
    l=i+1
    r=length-1
    target=nums[i]
    while l<r:
        if nums[l]+nums[r]==-target:
            seen.add((target,nums[l],nums[r]))

            while l < r and nums[l + 1] == nums[l]:
                l += 1
            while l < r and nums[r - 1] == nums[r]:
                r -= 1

            l+=1
            r-=1
        elif nums[l]+nums[r]>-target:
            r-=1
        else:
            l+=1
    i+=1
print(seen)
'''
import os
import sys
from io import BytesIO, IOBase

def main():
    pass

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

if __name__ == ""__main__"":
    main()

'''
def letterCombinations(digits):
    digitsmap = [0,0,['a', 'b', 'c'], ['d', 'e', 'f'], ['g', 'h', 'i'], ['j', 'k', 'l'], ['m', 'n', 'o'], ['p', 'q', 'r', 's'],
              ['t', 'u', 'v'], ['w', 'x', 'y', 'z']]
    temp=''
    n=len(digits)
    i=0
    ans=[]
    def allcombination(temp,i):
        if i == n:
            ans.append(temp)
            return
        for j in range(len(digitsmap[int(digits[i])])):
            allcombination(temp+digitsmap[int(digits[i])][j],i+1)
    allcombination(temp,i)
    return ans

print(letterCombinations('23'))
'''
'''
count=0
steps=0
ans=[]
def convert(a,b):
    global count,steps
    steps += 1

    if a>b:

        steps-=1

        return
    elif a==b:
        count+=1

        ans.append(a)

        return

    ans.append(a)
    convert(a*2,b)
    convert((a*10)+1,b)

convert(2,162)
if count>0:
    print(count,""YES"")
elif count==0:
    print('NO')

print(ans)

'''
'''N=3
n=2
i=0
box1=N
box2=0
box3=0
count=0
def move(i,N,box1,box2,box3):
    global count
    if N==0:

        count+=1
        return
    move(i+1,N-1,box1,box3,box2)
    print(box1,box3)
    move(i+1,N-1,box2,box1,box3)

move(i,N,box1,box2,box3)
print(count)

'''
'''
def numberOfPaths(n, m,count):

    def path(i, j,count):
        if i == n - 1 or j == m - 1:
            count += 1
            return
        path(i + 1, j,count)
        path(i, j +1,count)
    count=0
    path(0,0,count)
    return count

print(numberOfPaths(5,1,count))
'''
ans=999999999
def number(temp,nums,i,m,a):
    global ans
    if m==0 and a==0:
        ans=min(ans,eval(temp))
        return
    if a>0:
        number(temp+'+'+str(nums[i]),nums,i+1,m,a-1)
    if m>0:
        number(temp+'*'+str(nums[i]), nums, i+1, m-1, a)

nums=list(map(int,input().split()))
a=0
m=0
para=list(map(str,input().split()))
for k in para:
    if k=='+':
        a+=1
    elif k=='*':
        m+=1
temp=str(nums[0])
i=1
number(temp,nums,i,m,a)
print(ans)","import itertools

def apply_operation(x, y, operator):
    """"""Applies the specified operation on x and y.""""""
    if operator == '+':
        return x + y
    elif operator == '*':
        return x * y

def find_minimum_result(nums, operations):
    """"""Finds the minimum result from the given numbers and operations.""""""
    min_result = float('inf')

    for perm in itertools.permutations(nums):

        for i in range(3):

            temp_nums = list(perm)
            for op in operations:
                if len(temp_nums) == 1:
                    break

                first = temp_nums[0]
                second = temp_nums[1]

                new_number = apply_operation(first, second, op)

                temp_nums = [new_number] + temp_nums[2:]

            min_result = min(min_result, temp_nums[0])

    return min_result

original_numbers = list(map(int, input().strip().split()))
operations = input().strip().split()

result = find_minimum_result(original_numbers, operations)

print(result)"
727,A,Transformation: from A to B,PROGRAMMING,"['brute force', 'dfs and similar', 'math']","Vasily has a number *a*, which he wants to turn into a number *b*. For this purpose, he can do two types of operations:
 -  multiply the current number by 2 (that is, replace the number *x* by 2·*x*); -  append the digit 1 to the right of current number (that is, replace the number *x* by 10·*x*<=+<=1). 
You need to help Vasily to transform the number *a* into the number *b* using only the operations described above, or find that it is impossible.

Note that in this task you are not required to minimize the number of operations. It suffices to find any way to transform *a* into *b*.",The first line contains two positive integers *a* and *b* (1<=≤<=*a*<=&lt;<=*b*<=≤<=109) — the number which Vasily has and the number he wants to have.,"If there is no way to get *b* from *a*, print ""NO"" (without quotes).

Otherwise print three lines. On the first line print ""YES"" (without quotes). The second line should contain single integer *k* — the length of the transformation sequence. On the third line print the sequence of transformations *x*1,<=*x*2,<=...,<=*x**k*, where:
 -  *x*1 should be equal to *a*, -  *x**k* should be equal to *b*, -  *x**i* should be obtained from *x**i*<=-<=1 using any of two described operations (1<=&lt;<=*i*<=≤<=*k*). 
If there are multiple answers, print any of them.","['2 162\n', '4 42\n', '100 40021\n']","['YES\n5\n2 4 8 81 162 \n', 'NO\n', 'YES\n5\n100 200 2001 4002 40021 \n']",none,OK,"def fc(a,b,re,bl,tmp):
    if(a>b):
        return
    if(a==b):
        bl[0]=False

        re.append(tmp)
        return
    if(bl[0]):
        
        
        fc(a*2,b,re,bl,tmp+[a*2])
        fc(a*10+1,b,re,bl,tmp+[a*10+1])
re=[]
bl=[True]

a,b=map(int,input().split())
fc(a,b,re,bl,[])
if(len(re)==0):
    print(""NO"")
else:
    print(""YES"")
    print(1+len(re[0]))
    ans=[[a]+re[0]]
    print(a,end="" "")
    for i in re[0]:
        print(i,end="" "")
    print()","def transform(a, b):
    sequence = []

    current = b
    while current >= a:
        sequence.append(current)

        if current % 10 == 1:
            current //= 10
        elif current % 2 == 0:
            current //= 2
        else:
            break

    if current == a:
        sequence.append(current)
        sequence.reverse()
        print(""YES"")
        print(len(sequence))
        print("" "".join(map(str, sequence)))
    else:
        print(""NO"")

inputs = [
    (2, 162),
    (4, 42),
    (100, 40021)
]

for a, b in inputs:
    transform(a, b)"
276,C,Little Girl and Maximum Sum,PROGRAMMING,"['data structures', 'greedy', 'implementation', 'sortings']","The little girl loves the problems on array queries very much.

One day she came across a rather well-known problem: you've got an array of $n$ elements (the elements of the array are indexed starting from 1); also, there are $q$ queries, each one is defined by a pair of integers $l_i$, $r_i$ $(1 \le l_i \le r_i \le n)$. You need to find for each query the sum of elements of the array with indexes from $l_i$ to $r_i$, inclusive.

The little girl found the problem rather boring. She decided to reorder the array elements before replying to the queries in a way that makes the sum of query replies maximum possible. Your task is to find the value of this maximum sum.","The first line contains two space-separated integers $n$ ($1 \le n \le 2\cdot10^5$) and $q$ ($1 \le q \le 2\cdot10^5$) — the number of elements in the array and the number of queries, correspondingly.

The next line contains $n$ space-separated integers $a_i$ ($1 \le a_i \le 2\cdot10^5$) — the array elements.

Each of the following $q$ lines contains two space-separated integers $l_i$ and $r_i$ ($1 \le l_i \le r_i \le n$) — the $i$-th query.","In a single line print, a single integer — the maximum sum of query replies after the array elements are reordered.

Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.","['3 3\n5 3 2\n1 2\n2 3\n1 3\n', '5 3\n5 2 4 1 3\n1 5\n2 3\n2 3\n']","['25\n', '33\n']",none,OK,"from sys import stdin

def get_input():

    input_str = stdin.read().strip().split('\n')
    n, q = map(int, input_str[0].split())
    arr = list(map(int, input_str[1].split()))
    queries = [map(int, input_str[i].split()) for i in range(2, len(input_str))]

    return arr, queries

def get_max(arr, queries):
    n = len(arr)
    freq = [0] * (n + 2)

    for l, r in queries:
        freq[l] += 1
        freq[r + 1] -= 1

    for i in range(1, n + 1):
        freq[i] += freq[i - 1]

    freq.pop(0)
    freq.pop()
    freq.sort()
    arr.sort()

    s = 0
    for i in range(n):
        s += arr[i] * freq[i]
    return s

print(get_max(*get_input()))","def maximum_sum_queries(n, q, array, queries):

    freq = [0] * (n + 1)

    for l, r in queries:
        freq[l-1] += 1
        if r < n:
            freq[r] -= 1

    for i in range(1, n):
        freq[i] += freq[i - 1]

    freq = freq[:-1]

    array.sort(reverse=True)
    freq.sort(reverse=True)

    max_sum = sum(a * f for a, f in zip(array, freq))
    
    return max_sum

n, q = map(int, input().split())
array = list(map(int, input().split()))
queries = [tuple(map(int, input().split())) for _ in range(q)]

result = maximum_sum_queries(n, q, array, queries)

print(result)"
456,A,Laptops,PROGRAMMING,['sortings'],"One day Dima and Alex had an argument about the price and quality of laptops. Dima thinks that the more expensive a laptop is, the better it is. Alex disagrees. Alex thinks that there are two laptops, such that the price of the first laptop is less (strictly smaller) than the price of the second laptop but the quality of the first laptop is higher (strictly greater) than the quality of the second laptop.

Please, check the guess of Alex. You are given descriptions of *n* laptops. Determine whether two described above laptops exist.","The first line contains an integer *n* (1<=≤<=*n*<=≤<=105) — the number of laptops.

Next *n* lines contain two integers each, *a**i* and *b**i* (1<=≤<=*a**i*,<=*b**i*<=≤<=*n*), where *a**i* is the price of the *i*-th laptop, and *b**i* is the number that represents the quality of the *i*-th laptop (the larger the number is, the higher is the quality).

All *a**i* are distinct. All *b**i* are distinct.","If Alex is correct, print ""Happy Alex"", otherwise print ""Poor Alex"" (without the quotes).",['2\n1 2\n2 1\n'],['Happy Alex\n'],none,TIME_LIMIT_EXCEEDED,"def check_hypothesis(n, notebooks):
  for i in range(n-1):
    for j in range(i+1, n):
      if notebooks[i][0] < notebooks[j][0] and notebooks[i][1] > notebooks[j][1]:
        return ""Happy Alex""
  return ""Poor Alex""

n = int(input().strip())
notebooks = [list(map(int, input().strip().split())) for i in range(n)]
print(check_hypothesis(n, notebooks))","n = int(input().strip())
laptops = []

for _ in range(n):
    a, b = map(int, input().strip().split())
    laptops.append((a, b))

laptops.sort()

for i in range(1, n):
    if laptops[i-1][1] > laptops[i][1]:
        print(""Happy Alex"")
        break
else:
    print(""Poor Alex"")"
670,A,Holidays,PROGRAMMING,"['brute force', 'constructive algorithms', 'greedy', 'math']",On the planet Mars a year lasts exactly *n* days (there are no leap years on Mars). But Martians have the same weeks as earthlings — 5 work days and then 2 days off. Your task is to determine the minimum possible and the maximum possible number of days off per year on Mars.,The first line of the input contains a positive integer *n* (1<=≤<=*n*<=≤<=1<=000<=000) — the number of days in a year on Mars.,Print two integers — the minimum possible and the maximum possible number of days off per year on Mars.,"['14\n', '2\n']","['4 4\n', '0 2\n']","In the first sample there are 14 days in a year on Mars, and therefore independently of the day a year starts with there will be exactly 4 days off .

In the second sample there are only 2 days in a year on Mars, and they can both be either work days or days off.",WRONG_ANSWER,"def holidays(n):
    holiday=(n//7)*2
    if (n-(n//7)*7)<2:
        return holiday, holiday+(n-(n//7)*7)
    else:
        return holiday, holiday+2
q=int(input())
(a,b)=holidays(q)
print(a,b,sep=' ')","def calculate_days_off(n):

    full_weeks = n // 7
    remaining_days = n % 7

    max_days_off = full_weeks * 2  
    if remaining_days > 5:
        max_days_off += 2
    elif remaining_days > 0:
        max_days_off += 1

    min_days_off = 0
    if n >= 7:

        min_days_off = 0

    return min_days_off, max_days_off

n = int(input().strip())

min_days_off, max_days_off = calculate_days_off(n)

print(min_days_off, max_days_off)"
731,A,Night at the Museum,PROGRAMMING,"['implementation', 'strings']","Grigoriy, like the hero of one famous comedy film, found a job as a night security guard at the museum. At first night he received embosser and was to take stock of the whole exposition.

Embosser is a special devise that allows to ""print"" the text of a plastic tape. Text is printed sequentially, character by character. The device consists of a wheel with a lowercase English letters written in a circle, static pointer to the current letter and a button that print the chosen letter. At one move it's allowed to rotate the alphabetic wheel one step clockwise or counterclockwise. Initially, static pointer points to letter 'a'. Other letters are located as shown on the picture:

After Grigoriy add new item to the base he has to print its name on the plastic tape and attach it to the corresponding exhibit. It's not required to return the wheel to its initial position with pointer on the letter 'a'.

Our hero is afraid that some exhibits may become alive and start to attack him, so he wants to print the names as fast as possible. Help him, for the given string find the minimum number of rotations of the wheel required to print it.",The only line of input contains the name of some exhibit — the non-empty string consisting of no more than 100 characters. It's guaranteed that the string consists of only lowercase English letters.,"Print one integer — the minimum number of rotations of the wheel, required to print the name given in the input.","['zeus\n', 'map\n', 'ares\n']","['18\n', '35\n', '34\n']","To print the string from the first sample it would be optimal to perform the following sequence of rotations: 
 1.  from 'a' to 'z' (1 rotation counterclockwise), 1.  from 'z' to 'e' (5 clockwise rotations), 1.  from 'e' to 'u' (10 rotations counterclockwise), 1.  from 'u' to 's' (2 counterclockwise rotations).",OK,"s = 'abcdefghijklmnopqrstuvwxyz';

word = input();

result = 0;
ptr = 0;

for i in range(len(word)):
    from_st = s.index(word[i]);
    from_end = s[::-1].index(word[i]);
    if(from_st > from_end):
        ptr = from_end;
        start = s[26 - ptr-1::];
        end  = s[0:26-ptr-1];
    else:
        ptr = from_st;
        start = s[ptr:];
        end = s[0:ptr];
    if(len(start) < len(end)):
        result += len(start);
    else:
        result += len(end);
    s = start + end;

print(result);","def min_rotations_to_print(name):
    current_position = ord('a')
    total_rotations = 0

    for char in name:
        target_position = ord(char)

        clockwise_distance = (target_position - current_position) % 26
        counterclockwise_distance = (current_position - target_position) % 26

        total_rotations += min(clockwise_distance, counterclockwise_distance)

        current_position = target_position

    return total_rotations

exhibit_names = input().strip().split()
results = []

for name in exhibit_names:
    results.append(str(min_rotations_to_print(name.strip())))

print(""\n"".join(results))"
476,B,Dreamoon and WiFi,PROGRAMMING,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']","Dreamoon is standing at the position 0 on a number line. Drazil is sending a list of commands through Wi-Fi to Dreamoon's smartphone and Dreamoon follows them.

Each command is one of the following two types: 
 1.  Go 1 unit towards the positive direction, denoted as '+' 1.  Go 1 unit towards the negative direction, denoted as '-' 
But the Wi-Fi condition is so poor that Dreamoon's smartphone reports some of the commands can't be recognized and Dreamoon knows that some of them might even be wrong though successfully recognized. Dreamoon decides to follow every recognized command and toss a fair coin to decide those unrecognized ones (that means, he moves to the 1 unit to the negative or positive direction with the same probability 0.5). 

You are given an original list of commands sent by Drazil and list received by Dreamoon. What is the probability that Dreamoon ends in the position originally supposed to be final by Drazil's commands?","The first line contains a string *s*1 — the commands Drazil sends to Dreamoon, this string consists of only the characters in the set {'+', '-'}. 

The second line contains a string *s*2 — the commands Dreamoon's smartphone recognizes, this string consists of only the characters in the set {'+', '-', '?'}. '?' denotes an unrecognized command.

Lengths of two strings are equal and do not exceed 10.",Output a single real number corresponding to the probability. The answer will be considered correct if its relative or absolute error doesn't exceed 10<=-<=9.,"['++-+-\n+-+-+\n', '+-+-\n+-??\n', '+++\n??-\n']","['1.000000000000\n', '0.500000000000\n', '0.000000000000\n']","For the first sample, both *s*<sub class=""lower-index"">1</sub> and *s*<sub class=""lower-index"">2</sub> will lead Dreamoon to finish at the same position  + 1. 

For the second sample, *s*<sub class=""lower-index"">1</sub> will lead Dreamoon to finish at position 0, while there are four possibilites for *s*<sub class=""lower-index"">2</sub>: {""+-++"", ""+-+-"", ""+--+"", ""+---""} with ending position {+2, 0, 0, -2} respectively. So there are 2 correct cases out of 4, so the probability of finishing at the correct position is 0.5. 

For the third sample, *s*<sub class=""lower-index"">2</sub> could only lead us to finish at positions {+1, -1, -3}, so the probability to finish at the correct position  + 3 is 0.",RUNTIME_ERROR,"import math
from collections import OrderedDict,Counter
import heapq
from collections import deque
import sys
def mpp():return map(int,inp().split())
def lis():return list(mpp())
def inp(): return input()
def fn(a,b):
    n=b.count('?')
    r=a.count('-')-b.count('-')
    print(0 if n<r or r<0 else math.comb(n,r)/(1<<n))
    
def main():
    n=inp()
    m=inp()
    (fn(n,m))
    
if __name__==""__main__"":
    main()","def calculate_probability(s1, s2):

    target_position = s1.count('+') - s1.count('-')

    current_position = s2.count('+') - s2.count('-')
    unknown_commands = s2.count('?')

    difference = target_position - current_position

    if abs(difference) > unknown_commands or (unknown_commands - abs(difference)) % 2 != 0:
        return 0.0

    from math import comb

    ways_to_reach_target = comb(unknown_commands, (unknown_commands + difference) // 2)

    total_outcomes = 2 ** unknown_commands

    probability = ways_to_reach_target / total_outcomes
    
    return probability

s1 = input().strip()
s2 = input().strip()

result = calculate_probability(s1, s2)

print(f""{result:.12f}"")"
0,none,none,none,['none'],"Gerald got a very curious hexagon for his birthday. The boy found out that all the angles of the hexagon are equal to . Then he measured the length of its sides, and found that each of them is equal to an integer number of centimeters. There the properties of the hexagon ended and Gerald decided to draw on it.

He painted a few lines, parallel to the sides of the hexagon. The lines split the hexagon into regular triangles with sides of 1 centimeter. Now Gerald wonders how many triangles he has got. But there were so many of them that Gerald lost the track of his counting. Help the boy count the triangles.","The first and the single line of the input contains 6 space-separated integers *a*1,<=*a*2,<=*a*3,<=*a*4,<=*a*5 and *a*6 (1<=≤<=*a**i*<=≤<=1000) — the lengths of the sides of the hexagons in centimeters in the clockwise order. It is guaranteed that the hexagon with the indicated properties and the exactly such sides exists.","Print a single integer — the number of triangles with the sides of one 1 centimeter, into which the hexagon is split.","['1 1 1 1 1 1\n', '1 2 1 2 1 2\n']","['6\n', '13\n']","This is what Gerald's hexagon looks like in the first sample:

<img class=""tex-graphics"" src=""https://espresso.codeforces.com/84d193e27b02c38eb1eadc536602a2ec0b9f9519.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

And that's what it looks like in the second sample:

<img class=""tex-graphics"" src=""https://espresso.codeforces.com/e29076a96da8ca864654cc6195654d9bf07d31ce.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>",WRONG_ANSWER,"import math
def sqr(x):
    return x * x

def side_(a,b):
    cos_120 = -0.5
    return abs((sqr(a) * sqr(b) - (2 * a * b * cos_120)) ** 0.5)

def triangle_area(a,b,c):
    p = (a + b + c) / 2
    return abs((p * (p-a) * (p-b) * (p-c)) ** 0.5)

a1,a2,a3,a4,a5,a6 = map(int,input().split())
sin_120 = (-1) * ((3 ** 0.5) / 2)
area1 = abs((a1 * a2) / 2 * sin_120)
area2 = abs((a3 * a4) / 2 * sin_120)
area3 = abs((a5 * a6) / 2 * sin_120)
side1 = side_(a1,a2)
side2 = side_(a3,a4)
side3 = side_(a5,a6)
s = triangle_area(side1,side2,side3)
all_area = area1 + area2 + area3 + s
print(round((all_area / ((3 ** 0.5) / 4))+1))","def count_triangles(sides):

    a1, a2, a3, a4, a5, a6 = sides
    area = (3 * (a1 + a3 + a5) * (a2 + a4 + a6)) // 2

    num_triangles = area

    return num_triangles

sides = list(map(int, input().strip().split()))

print(count_triangles(sides))"
7,B,Memory Manager,PROGRAMMING,['implementation'],"There is little time left before the release of the first national operating system BerlOS. Some of its components are not finished yet — the memory manager is among them. According to the developers' plan, in the first release the memory manager will be very simple and rectilinear. It will support three operations: 
 -  alloc n — to allocate *n* bytes of the memory and return the allocated block's identifier *x*; -  erase x — to erase the block with the identifier *x*; -  defragment — to defragment the free memory, bringing all the blocks as close to the beginning of the memory as possible and preserving their respective order; 
The memory model in this case is very simple. It is a sequence of *m* bytes, numbered for convenience from the first to the *m*-th.

The first operation alloc n takes as the only parameter the size of the memory block that is to be allocated. While processing this operation, a free block of *n* successive bytes is being allocated in the memory. If the amount of such blocks is more than one, the block closest to the beginning of the memory (i.e. to the first byte) is prefered. All these bytes are marked as not free, and the memory manager returns a 32-bit integer numerical token that is the identifier of this block. If it is impossible to allocate a free block of this size, the function returns NULL.

The second operation erase x takes as its parameter the identifier of some block. This operation frees the system memory, marking the bytes of this block as free for further use. In the case when this identifier does not point to the previously allocated block, which has not been erased yet, the function returns ILLEGAL_ERASE_ARGUMENT.

The last operation defragment does not have any arguments and simply brings the occupied memory sections closer to the beginning of the memory without changing their respective order.

In the current implementation you are to use successive integers, starting with 1, as identifiers. Each successful alloc operation procession should return following number. Unsuccessful alloc operations do not affect numeration.

You are to write the implementation of the memory manager. You should output the returned value for each alloc command. You should also output ILLEGAL_ERASE_ARGUMENT for all the failed erase commands.","The first line of the input data contains two positive integers *t* and *m* (1<=≤<=*t*<=≤<=100;1<=≤<=*m*<=≤<=100), where *t* — the amount of operations given to the memory manager for processing, and *m* — the available memory size in bytes. Then there follow *t* lines where the operations themselves are given. The first operation is alloc n (1<=≤<=*n*<=≤<=100), where *n* is an integer. The second one is erase x, where *x* is an arbitrary 32-bit integer numerical token. The third operation is defragment.","Output the sequence of lines. Each line should contain either the result of alloc operation procession , or ILLEGAL_ERASE_ARGUMENT as a result of failed erase operation procession. Output lines should go in the same order in which the operations are processed. Successful procession of alloc operation should return integers, starting with 1, as the identifiers of the allocated blocks.",['6 10\nalloc 5\nalloc 3\nerase 1\nalloc 6\ndefragment\nalloc 6\n'],['1\n2\nNULL\n3\n'],none,WRONG_ANSWER,"def main(): 
    t, m = map(int, input().split())
    mem = [0]*m
    iden = 1
    ans = []
    
    for _ in range(t):
        orders = list(input().split()) 
        order = orders[0]
        if len(orders) == 2: n = orders[1]; n = int(n)
        
        
        if order == ""alloc"":
            spa = 0
            while n+spa != m:        
                if n <= mem.count(0): 
                    if mem[mem.index(0)+spa:mem.index(0)+n+spa] == [0]*n:                    
                        mem[mem.index(0)+spa:mem.index(0)+n+spa] = [iden]*n
                        spa = m-n
                        ans.append(iden)
                        iden += 1
                    else: spa +=1
                    
                    if m-n == spa and mem.count(iden-1) != n: 
                        ans.append(""NULL"")                         
                        
                else: 
                    ans.append(""NULL"")    
                    spa = m-n
            
            if n == m:
                if mem.count(0) == m:
                    mem = [iden]*n 
                    ans.append(iden)
                    iden += 1
                else:
                    ans.append(""NULL"")    
                    spa = m-n 
            
        elif order == ""erase"":
            if n in mem:
                mem = [0 if i == n else i for i in mem]
            else: ans.append(""ILLEGAL_ERASE_ARGUMENT"")
            
        elif order == ""defragment"":
            for _ in mem:
                if 0 in mem: mem.remove(0)
            mem = mem + [0]*(m-int(len(mem)))
            
        print(mem)     
    for i in ans: print(i)    
    
    
if __name__ == ""__main__"":
    main()","class MemoryManager:
    def __init__(self, m):
        self.memory = [None] * m
        self.free_blocks = []
        self.alloc_id = 1
        self.blocks = {}

    def alloc(self, n):

        for start in range(len(self.memory) - n + 1):
            if all(self.memory[i] is None for i in range(start, start + n)):

                for i in range(start, start + n):
                    self.memory[i] = self.alloc_id
                self.blocks[self.alloc_id] = (start, n)
                self.alloc_id += 1
                return self.alloc_id - 1
        return ""NULL""

    def erase(self, x):
        if x not in self.blocks:
            return ""ILLEGAL_ERASE_ARGUMENT""
        start, size = self.blocks.pop(x)
        for i in range(start, start + size):
            self.memory[i] = None

    def defragment(self):

        occupied = []
        for id, (start, size) in sorted(self.blocks.items(), key=lambda item: item[1][0]):
            occupied.append((start, size))

        self.memory = [None] * len(self.memory)
        current_position = 0

        for start, size in occupied:
            for i in range(size):
                self.memory[current_position + i] = self.alloc_id
            self.blocks[id] = (current_position, size)
            current_position += size
        return

def main(operations):
    t, m = map(int, operations[0].split())
    manager = MemoryManager(m)
    results = []
    
    for i in range(1, t + 1):
        operation = operations[i].strip().split()
        cmd = operation[0]
        
        if cmd == ""alloc"":
            n = int(operation[1])
            result = manager.alloc(n)
            results.append(result)
        elif cmd == ""erase"":
            x = int(operation[1])
            result = manager.erase(x)
            if result:
                results.append(result)
        elif cmd == ""defragment"":
            manager.defragment()
    
    return results

input_data = ['6 10\nalloc 5\nalloc 3\nerase 1\nalloc 6\ndefragment\nalloc 6\n']
output = main(input_data)
print(output)"
277,E,Binary Tree on Plane,PROGRAMMING,"['flows', 'trees']","A root tree is a directed acyclic graph that contains one node (root), from which there is exactly one path to any other node.

A root tree is binary if each node has at most two outgoing arcs.

When a binary tree is painted on the plane, all arcs should be directed from top to bottom. That is, each arc going from *u* to *v* must meet the condition *y**u*<=&gt;<=*y**v*.

You've been given the coordinates of all tree nodes. Your task is to connect these nodes by arcs so as to get the binary root tree and make the total length of the arcs minimum. All arcs of the built tree must be directed from top to bottom.","The first line contains a single integer *n* (2<=≤<=*n*<=≤<=400) — the number of nodes in the tree. Then follow *n* lines, two integers per line: *x**i*,<=*y**i* (|*x**i*|,<=|*y**i*|<=≤<=103) — coordinates of the nodes. It is guaranteed that all points are distinct.","If it is impossible to build a binary root tree on the given points, print ""-1"". Otherwise, print a single real number — the total length of the arcs in the minimum binary tree. The answer will be considered correct if the absolute or relative error doesn't exceed 10<=-<=6.","['3\n0 0\n1 0\n2 1\n', '4\n0 0\n1 0\n2 1\n2 0\n']","['3.650281539872885\n', '-1\n']",none,TIME_LIMIT_EXCEEDED,"import os, sys
from io import BytesIO, IOBase
from array import array
from itertools import accumulate
import bisect
import math
from collections import deque

from copy import deepcopy

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, 8192))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

input = lambda: sys.stdin.readline().strip()
ints = lambda: list(map(int, input().split()))
Int = lambda: int(input())

def queryInteractive(a, b, c):
    print('? {} {} {}'.format(a, b, c))
    sys.stdout.flush()
    return int(input())

def answerInteractive(x1, x2):
    print('! {} {}'.format(x1, x2))
    sys.stdout.flush()

inf = float('inf')

import heapq
class mcf_graph():
    n=1
    pos=[]
    g=[[]]
    def __init__(self,N):
        self.n=N
        self.pos=[]
        self.g=[[] for i in range(N)]
    def add_edge(self,From,To,cap,cost):
        assert 0<=From and From<self.n
        assert 0<=To and To<self.n
        m=len(self.pos)
        self.pos.append((From,len(self.g[From])))
        self.g[From].append({""to"":To,""rev"":len(self.g[To]),""cap"":cap,""cost"":cost})
        self.g[To].append({""to"":From,""rev"":len(self.g[From])-1,""cap"":0,""cost"":-cost})
    def get_edge(self,i):
        m=len(self.pos)
        assert 0<=i and i<m
        _e=self.g[self.pos[i][0]][self.pos[i][1]]
        _re=self.g[_e[""to""]][_e[""rev""]]
        return {""from"":self.pos[i][0],""to"":_e[""to""],""cap"":_e[""cap""]+_re[""cap""],
        ""flow"":_re[""cap""],""cost"":_e[""cost""]}
    def edges(self):
        m=len(self.pos)
        result=[{} for i in range(m)]
        for i in range(m):
            tmp=self.get_edge(i)
            result[i][""from""]=tmp[""from""]
            result[i][""to""]=tmp[""to""]
            result[i][""cap""]=tmp[""cap""]
            result[i][""flow""]=tmp[""flow""]
            result[i][""cost""]=tmp[""cost""]
        return result
    def flow(self,s,t,flow_limit=-1-(-1<<63)):
        return self.slope(s,t,flow_limit)[-1]
    def slope(self,s,t,flow_limit=-1-(-1<<63)):
        assert 0<=s and s<self.n
        assert 0<=t and t<self.n
        assert s!=t
        '''
         variants (C = maxcost):
         -(n-1)C <= dual[s] <= dual[i] <= dual[t] = 0
         reduced cost (= e.cost + dual[e.from] - dual[e.to]) >= 0 for all edge
        '''
        dual=[0 for i in range(self.n)]
        dist=[0 for i in range(self.n)]
        pv=[0 for i in range(self.n)]
        pe=[0 for i in range(self.n)]
        vis=[False for i in range(self.n)]
        def dual_ref():
            for i in range(self.n):
                dist[i]=-1-(-1<<63)
                pv[i]=-1
                pe[i]=-1
                vis[i]=False
            que=[]
            heapq.heappush(que,(0,s))
            dist[s]=0
            while(que):
                v=heapq.heappop(que)[1]
                if vis[v]:continue
                vis[v]=True
                if v==t:break
                '''
                 dist[v] = shortest(s, v) + dual[s] - dual[v]
                 dist[v] >= 0 (all reduced cost are positive)
                 dist[v] <= (n-1)C
                '''
                for i in range(len(self.g[v])):
                    e=self.g[v][i]
                    if vis[e[""to""]] or (not(e[""cap""])):continue
                    '''
                     |-dual[e.to]+dual[v]| <= (n-1)C
                     cost <= C - -(n-1)C + 0 = nC
                    '''
                    cost=e[""cost""]-dual[e[""to""]]+dual[v]
                    if dist[e[""to""]]-dist[v]>cost:
                        dist[e[""to""]]=dist[v]+cost
                        pv[e[""to""]]=v
                        pe[e[""to""]]=i
                        heapq.heappush(que,(dist[e[""to""]],e[""to""]))
            if not(vis[t]):
                return False
            for v in range(self.n):
                if not(vis[v]):continue
                dual[v]-=dist[t]-dist[v]
            return True
        flow=0
        cost=0
        prev_cost=-1
        result=[(flow,cost)]
        while(flow<flow_limit):
            if not(dual_ref()):
                break
            c=flow_limit-flow
            v=t
            while(v!=s):
                c=min(c,self.g[pv[v]][pe[v]][""cap""])
                v=pv[v]
            v=t
            while(v!=s):
                self.g[pv[v]][pe[v]][""cap""]-=c
                self.g[v][self.g[pv[v]][pe[v]][""rev""]][""cap""]+=c
                v=pv[v]
            d=-dual[s]
            flow+=c
            cost+=c*d
            if(prev_cost==d):
                result.pop()
            result.append((flow,cost))
            prev_cost=cost
        return result
    

n = Int()
a = []
for _ in range(n):
    x,y = ints()
    a.append((x,y))

s = 2*n
t = 2*n+1
mf = mcf_graph(2*n+2)

for i in range(n):
    for j in range(i+1,n):
        if a[i][1] == a[j][1]:
            continue
        if a[i][1] > a[j][1]:
            d = math.sqrt((a[i][0] - a[j][0])**2 + (a[i][1] - a[j][1])**2)
            mf.add_edge(i,j+n,1,d)
        elif a[i][1] < a[j][1]:
            d = math.sqrt((a[i][0] - a[j][0])**2 + (a[i][1] - a[j][1])**2)
            mf.add_edge(j,i+n,1,d)          

for i in range(n):
    mf.add_edge(s,i,2,0)

for j in range(n):
    mf.add_edge(j+n,t,1,0)

flow = mf.flow(s,t,inf)
if flow[0] < n-1:
    print(""-1"")
    sys.exit()
print(flow[-1])","import sys
import math
from collections import defaultdict
from itertools import combinations

def distance(a, b):
    return math.sqrt((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2)

def build_binary_tree(points):
    n = len(points)
    if n == 0:
        return -1

    points.sort(key=lambda p: (p[1], p[0]))

    graph = defaultdict(list)

    for u, v in combinations(range(n), 2):
        if points[u][1] < points[v][1]:
            graph[u].append(v)
        if len(graph[u]) > 2:
            return -1

    total_distance = 0.0

    def dfs(node):
        nonlocal total_distance
        if node in graph:
            for child in graph[node]:
                total_distance += distance(points[node], points[child])
                dfs(child)

    root = 0
    dfs(root)

    return total_distance

def main():
    input_data = sys.stdin.read().strip().splitlines()
    n = int(input_data[0])
    points = [tuple(map(int, line.split())) for line in input_data[1:n + 1]]

    result = build_binary_tree(points)
    if result == -1:
        print(""-1"")
    else:
        print(f""{result:.9f}"")

if __name__ == ""__main__"":
    main()"
202,A,LLPS,PROGRAMMING,"['binary search', 'bitmasks', 'brute force', 'greedy', 'implementation', 'strings']","This problem's actual name, ""Lexicographically Largest Palindromic Subsequence"" is too long to fit into the page headline.

You are given string *s* consisting of lowercase English letters only. Find its lexicographically largest palindromic subsequence.

We'll call a non-empty string *s*[*p*1*p*2... *p**k*] = *s**p*1*s**p*2... *s**p**k* (1 <=≤<= *p*1<=&lt;<=*p*2<=&lt;<=...<=&lt;<=*p**k* <=≤<= |*s*|) a subsequence of string *s* = *s*1*s*2... *s*|*s*|, where |*s*| is the length of string *s*. For example, strings ""abcb"", ""b"" and ""abacaba"" are subsequences of string ""abacaba"".

String *x* = *x*1*x*2... *x*|*x*| is lexicographically larger than string *y* = *y*1*y*2... *y*|*y*| if either |*x*| &gt; |*y*| and *x*1<==<=*y*1, *x*2<==<=*y*2, ...,<=*x*|*y*|<==<=*y*|*y*|, or there exists such number *r* (*r*<=&lt;<=|*x*|, *r*<=&lt;<=|*y*|) that *x*1<==<=*y*1, *x*2<==<=*y*2, ..., *x**r*<==<=*y**r* and *x**r*<=<=+<=<=1<=&gt;<=*y**r*<=<=+<=<=1. Characters in the strings are compared according to their ASCII codes. For example, string ""ranger"" is lexicographically larger than string ""racecar"" and string ""poster"" is lexicographically larger than string ""post"".

String *s* = *s*1*s*2... *s*|*s*| is a palindrome if it matches string *rev*(*s*) = *s*|*s*|*s*|*s*|<=-<=1... *s*1. In other words, a string is a palindrome if it reads the same way from left to right and from right to left. For example, palindromic strings are ""racecar"", ""refer"" and ""z"".",The only input line contains a non-empty string *s* consisting of lowercase English letters only. Its length does not exceed 10.,Print the lexicographically largest palindromic subsequence of string *s*.,"['radar\n', 'bowwowwow\n', 'codeforces\n', 'mississipp\n']","['rr\n', 'wwwww\n', 's\n', 'ssss\n']","Among all distinct subsequences of string ""radar"" the following ones are palindromes: ""a"", ""d"", ""r"", ""aa"", ""rr"", ""ada"", ""rar"", ""rdr"", ""raar"" and ""radar"". The lexicographically largest of them is ""rr"".",OK,"from itertools import combinations
def get_subsequences(input_str):
    for length in range(1, len(input_str)+1):
        for elems in combinations(input_str, length):
            yield ''.join(elems)
print(sorted([s for s in get_subsequences(input()) if s[::-1] == s])[-1])","def largest_palindromic_subsequence(s):

    freq = {}
    for char in s:
        if char in freq:
            freq[char] += 1
        else:
            freq[char] = 1

    half = []
    middle = """"

    for char in sorted(freq.keys(), reverse=True):
        count = freq[char]

        if count % 2 == 1 and len(middle) == 0:
            middle = char

        half.append(char * (count // 2))

    first_half = ''.join(half)
    largest_palindrome = first_half + middle + first_half[::-1]
    
    return largest_palindrome

input_strings = ['radar', 'bowwowwow', 'codeforces', 'mississipp']
output_strings = []

for s in input_strings:
    output_strings.append(largest_palindromic_subsequence(s))

for result in output_strings:
    print(result)"
300,C,Beautiful Numbers,PROGRAMMING,"['brute force', 'combinatorics']","Vitaly is a very weird man. He's got two favorite digits *a* and *b*. Vitaly calls a positive integer good, if the decimal representation of this integer only contains digits *a* and *b*. Vitaly calls a good number excellent, if the sum of its digits is a good number.

For example, let's say that Vitaly's favourite digits are 1 and 3, then number 12 isn't good and numbers 13 or 311 are. Also, number 111 is excellent and number 11 isn't. 

Now Vitaly is wondering, how many excellent numbers of length exactly *n* are there. As this number can be rather large, he asks you to count the remainder after dividing it by 1000000007 (109<=+<=7).

A number's length is the number of digits in its decimal representation without leading zeroes.","The first line contains three integers: *a*, *b*, *n* (1<=≤<=*a*<=&lt;<=*b*<=≤<=9,<=1<=≤<=*n*<=≤<=106).",Print a single integer — the answer to the problem modulo 1000000007 (109<=+<=7).,"['1 3 3\n', '2 3 10\n']","['1\n', '165\n']",none,OK,"import sys, threading
import math
from os import path
from collections import deque, defaultdict, Counter
from bisect import *
from string import ascii_lowercase
from functools import cmp_to_key
from random import randint
from heapq import *
from array import array
from types import GeneratorType
 
 
def readInts():
    x = list(map(int, (sys.stdin.readline().rstrip().split())))
    return x[0] if len(x) == 1 else x
 
 
def readList(type=int):
    x = sys.stdin.readline()
    x = list(map(type, x.rstrip('\n\r').split()))
    return x
 
 
def readStr():
    x = sys.stdin.readline().rstrip('\r\n')
    return x
 
 
write = sys.stdout.write
read = sys.stdin.readline
 
 
MAXN = 1123456

def bootstrap(f, stack=[]):
    def wrappedfunc(*args, **kwargs):
        if stack:
            return f(*args, **kwargs)
        else:
            to = f(*args, **kwargs)
            while True:
                if type(to) is GeneratorType:
                    stack.append(to)
                    to = next(to)
                else:
                    stack.pop()
                    if not stack:
                        break
                    to = stack[-1].send(to)
            return to
    return wrappedfunc

class mydict:
    def __init__(self, func=lambda: 0):
        self.random = randint(0, 1 << 32)
        self.default = func
        self.dict = {}
 
    def __getitem__(self, key):
        mykey = self.random ^ key
        if mykey not in self.dict:
            self.dict[mykey] = self.default()
        return self.dict[mykey]
 
    def get(self, key, default):
        mykey = self.random ^ key
        if mykey not in self.dict:
            return default
        return self.dict[mykey]
 
    def __setitem__(self, key, item):
        mykey = self.random ^ key
        self.dict[mykey] = item
 
    def getkeys(self):
        return [self.random ^ i for i in self.dict]
 
    def __str__(self):
        return f'{[(self.random ^ i, self.dict[i]) for i in self.dict]}'

def lcm(a, b):
    return (a*b)//(math.gcd(a,b))
 
 
def mod(n):
    return n%(1000000007) 

def power(bas, exp):
    if (exp == 0):
        return 1
    if (exp == 1):
        return bas
     
     
    if (exp % 2 == 0):
        t = power(bas, exp // 2)
        t = mod(t * t)
        return t    

    else:
        return mod(power(bas, exp-1)*bas)

factr = []
factr = [1]
fact = 1
for i in range(1, MAXN):
    fact = mod(mod(fact)*mod(i))
    factr.append(fact)
    
def nCr(n, r):

    if r > n:
        return 0

    n1 = factr[n]
    d1 = power(factr[r], 1000000005)
    d2 = power(factr[n-r], 1000000005)

    return mod(mod(n1)*mod(d1)*mod(d2))

def solve(t):

    a, b, n = readInts()
    ans = 0
    for i in range(n+1):
        sm = i*a + b*(n-i)
        st = set(str(sm))
        st.discard(str(a))
        st.discard(str(b))
        if len(st) > 0:
            continue

        ans = mod(ans + nCr(n, i))

    print(ans)

def main():
    t = 1
    if path.exists(""/Users/arijitbhaumik/Library/Application Support/Sublime Text/Packages/User/input.txt""):
        sys.stdin = open(""/Users/arijitbhaumik/Library/Application Support/Sublime Text/Packages/User/input.txt"", 'r')
        sys.stdout = open(""/Users/arijitbhaumik/Library/Application Support/Sublime Text/Packages/User/output.txt"", 'w')

    for i in range(t):
        solve(i+1)
 
 
if __name__ == '__main__':
    main()","def is_good(number, a, b):

    while number > 0:
        digit = number % 10
        if digit != a and digit != b:
            return False
        number //= 10
    return True

def is_excellent(number, a, b):

    sum_of_digits = 0
    while number > 0:
        sum_of_digits += number % 10
        number //= 10

    return is_good(sum_of_digits, a, b)

def count_excellent_numbers(a, b, n):
    MOD = 1000000007
    count = 0

    limit = 10 ** n
    for i in range(1, limit):
        if is_good(i, a, b):
            if is_excellent(i, a, b):
                count = (count + 1) % MOD
    return count

a, b, n = map(int, input().strip().split())

print(count_excellent_numbers(a, b, n))"
633,A,Ebony and Ivory,PROGRAMMING,"['brute force', 'math', 'number theory']","Dante is engaged in a fight with ""The Savior"". Before he can fight it with his sword, he needs to break its shields. He has two guns, Ebony and Ivory, each of them is able to perform any non-negative number of shots.

For every bullet that hits the shield, Ebony deals *a* units of damage while Ivory deals *b* units of damage. In order to break the shield Dante has to deal exactly *c* units of damage. Find out if this is possible.","The first line of the input contains three integers *a*, *b*, *c* (1<=≤<=*a*,<=*b*<=≤<=100,<=1<=≤<=*c*<=≤<=10<=000) — the number of units of damage dealt by Ebony gun and Ivory gun, and the total number of damage required to break the shield, respectively.","Print ""Yes"" (without quotes) if Dante can deal exactly *c* damage to the shield and ""No"" (without quotes) otherwise.","['4 6 15\n', '3 2 7\n', '6 11 6\n']","['No\n', 'Yes\n', 'Yes\n']","In the second sample, Dante can fire 1 bullet from Ebony and 2 from Ivory to deal exactly 1·3 + 2·2 = 7 damage. In the third sample, Dante can fire 1 bullet from ebony and no bullets from ivory to do 1·6 + 0·11 = 6 damage.",WRONG_ANSWER,"from math import gcd
def bezout(a, b):
    px, py = 1, 0
    x, y = 0, 1
    while b != 0:
        a, (q, b) = b, divmod(a, b)
        px, x = x, px - q * x
        py, y = y, py - q * y
    return a, px, py

a,b,c = [int(d) for d in input().split()]

if c%gcd(a,b) != 0:
    print(""No"")
else:
    a,px,py = bezout(a,b)
    if (px < 0 and py > 0) or (px > 0 and py < 0) :
        x = px*c
        y = py*c
        k = (y//a)
        if (y//a < y/a):
            k += 1
        if x - k*b < 0:
            print(""No"")
        else:
            print(""Yes"")
    else:
        print(""Yes"")","def can_break_shield(a, b, c):

    for x in range(c // a + 1):

        remaining_damage = c - x * a

        if remaining_damage >= 0 and remaining_damage % b == 0:
            return ""Yes""
    return ""No""

def main():

    inputs = ['4 6 15\n', '3 2 7\n', '6 11 6\n']
    results = []
    
    for line in inputs:

        a, b, c = map(int, line.strip().split())

        result = can_break_shield(a, b, c)
        results.append(result)

    print([f""{result}\n"" for result in results])

if __name__ == ""__main__"":
    main()"
81,B,Sequence Formatting,PROGRAMMING,"['implementation', 'strings']","Polycarp is very careful. He even types numeric sequences carefully, unlike his classmates. If he sees a sequence without a space after the comma, with two spaces in a row, or when something else does not look neat, he rushes to correct it. For example, number sequence written like ""1,2 ,3,...,   10"" will be corrected to ""1, 2, 3, ..., 10"".

In this task you are given a string *s*, which is composed by a concatination of terms, each of which may be: 
 -  a positive integer of an arbitrary length (leading zeroes are not allowed), -  a ""comma"" symbol ("",""), -  a ""space"" symbol ("" ""), -  ""three dots"" (""..."", that is, exactly three points written one after another, also known as suspension points). 
Polycarp wants to add and remove spaces in the string *s* to ensure the following: 
 -  each comma is followed by exactly one space (if the comma is the last character in the string, this rule does not apply to it), -  each ""three dots"" term is preceded by exactly one space (if the dots are at the beginning of the string, this rule does not apply to the term), -  if two consecutive numbers were separated by spaces only (one or more), then exactly one of them should be left, -  there should not be other spaces. 
Automate Polycarp's work and write a program that will process the given string *s*.",The input data contains a single string *s*. Its length is from 1 to 255 characters. The string *s* does not begin and end with a space. Its content matches the description given above.,"Print the string *s* after it is processed. Your program's output should be exactly the same as the expected answer. It is permissible to end output line with a line-break character, and without it.","['1,2 ,3,...,     10\n', '1,,,4...5......6\n', '...,1,2,3,...\n']","['1, 2, 3, ..., 10\n', '1, , , 4 ...5 ... ...6\n', '..., 1, 2, 3, ...\n']",none,WRONG_ANSWER,"def ip():return map(int,input().split())
def sp():return map(str,input().split(','))
def li():return list(sp())

s=li()

st=[]
for x in s:st.append((list(map(str,x.split()))))

ans=''
for x in st:
    if x==[]:ans+=', '
    else:
        for i in x:
            ans+=i+', '

answer=''
i=0
k=len(ans)
while i<k:
    if ans[i:i+3]=='...' and ans[i+3]!=',':
        ans=ans[:i:]+' ...'+ans[i+3:]
        i=i+3
        k=len(ans)
    i=i+1
print(ans[:len(ans)-2:])","import re

def correct_sequence(s):

    s = re.sub(r'\s*,', ',', s)

    s = re.sub(r',\s*', ', ', s)

    s = re.sub(r'\s*\.\.\.\s*', ' ... ', s)

    s = re.sub(r'(\d)\s+(\d)', r'\1 \2', s)

    s = re.sub(r' +', ' ', s)

    s = re.sub(r' ?\.\.\. ?', ' ... ', s)
    
    return s

input_data = [
    '1,2 ,3,...,     10\n',
    '1,,,4...5......6\n',
    '...,1,2,3,...\n'
]

output_data = [correct_sequence(s.strip()) + '\n' for s in input_data]
print(output_data)"
387,B,George and Round,PROGRAMMING,"['brute force', 'greedy', 'two pointers']","George decided to prepare a Codesecrof round, so he has prepared *m* problems for the round. Let's number the problems with integers 1 through *m*. George estimates the *i*-th problem's complexity by integer *b**i*.

To make the round good, he needs to put at least *n* problems there. Besides, he needs to have at least one problem with complexity exactly *a*1, at least one with complexity exactly *a*2, ..., and at least one with complexity exactly *a**n*. Of course, the round can also have problems with other complexities.

George has a poor imagination. It's easier for him to make some already prepared problem simpler than to come up with a new one and prepare it. George is magnificent at simplifying problems. He can simplify any already prepared problem with complexity *c* to any positive integer complexity *d* (*c*<=≥<=*d*), by changing limits on the input data.

However, nothing is so simple. George understood that even if he simplifies some problems, he can run out of problems for a good round. That's why he decided to find out the minimum number of problems he needs to come up with in addition to the *m* he's prepared in order to make a good round. Note that George can come up with a new problem of any complexity.","The first line contains two integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=3000) — the minimal number of problems in a good round and the number of problems George's prepared. The second line contains space-separated integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a*1<=&lt;<=*a*2<=&lt;<=...<=&lt;<=*a**n*<=≤<=106) — the requirements for the complexity of the problems in a good round. The third line contains space-separated integers *b*1,<=*b*2,<=...,<=*b**m* (1<=≤<=*b*1<=≤<=*b*2...<=≤<=*b**m*<=≤<=106) — the complexities of the problems prepared by George.",Print a single integer — the answer to the problem.,"['3 5\n1 2 3\n1 2 2 3 3\n', '3 5\n1 2 3\n1 1 1 1 1\n', '3 1\n2 3 4\n1\n']","['0\n', '2\n', '3\n']","In the first sample the set of the prepared problems meets the requirements for a good round.

In the second sample, it is enough to come up with and prepare two problems with complexities 2 and 3 to get a good round.

In the third sample it is very easy to get a good round if come up with and prepare extra problems with complexities: 2, 3, 4.",WRONG_ANSWER,"def find_min_number_problem(round_arr, prepared_arr):
    i = 0
    j = 0
    found = 0
    while i < len(round_arr) and j < len(prepared_arr):
        if round_arr[i] == prepared_arr[j]:
            found += 1
            i += 1
            j += 1
        elif round_arr[i] < prepared_arr[j]:
            i += 1
        else:
            j += 1

    return len(round_arr) - found

first_input = input()
A = list(map(int, input().split()))
B = list(map(int, input().split()))
result = find_min_number_problem(A, B)
print(result)","def minimum_additional_problems(n, m, required_complexities, prepared_complexities):

    required_set = set(required_complexities)

    prepared_count = {}
    for complexity in prepared_complexities:
        if complexity in required_set:
            if complexity not in prepared_count:
                prepared_count[complexity] = 0
            prepared_count[complexity] += 1

    additional_problems = 0
    for complexity in required_complexities:
        if complexity not in prepared_count or prepared_count[complexity] < 1:
            additional_problems += 1

    total_problems_needed = max(n - m, 0)
    return additional_problems + total_problems_needed

import sys
input_data = sys.stdin.read().strip().splitlines()
n, m = map(int, input_data[0].split())
required_complexities = list(map(int, input_data[1].split()))
prepared_complexities = list(map(int, input_data[2].split()))

result = minimum_additional_problems(n, m, required_complexities, prepared_complexities)
print(result)"
489,C,Given Length and Sum of Digits...,PROGRAMMING,"['dp', 'greedy', 'implementation']",You have a positive integer *m* and a non-negative integer *s*. Your task is to find the smallest and the largest of the numbers that have length *m* and sum of digits *s*. The required numbers should be non-negative integers written in the decimal base without leading zeroes.,"The single line of the input contains a pair of integers *m*, *s* (1<=≤<=*m*<=≤<=100,<=0<=≤<=*s*<=≤<=900) — the length and the sum of the digits of the required numbers.","In the output print the pair of the required non-negative integer numbers — first the minimum possible number, then — the maximum possible number. If no numbers satisfying conditions required exist, print the pair of numbers ""-1 -1"" (without the quotes).","['2 15\n', '3 0\n']","['69 96\n', '-1 -1\n']",none,OK,"def Min(m, s):
    if s == 0:
        return 0 if m == 1 else -1
    a = [0] * m
    a[-1] = s - 1
    i = len(a) - 1
    while a[i] > 9:
        if i <= 0:
            return -1
        a[i - 1], a[i] = a[i] - 9, 9
        i -= 1
    a[0] += 1
    if a[0] > 9:
        return -1
    return """".join(str(d) for d in a)

def Max(m, s):
    if s == 0:
        return 0 if m == 1 else -1
    a = [0] * m
    a[0] = s
    i = 0
    while a[i] > 9:
        if i >= len(a) - 1:
            return -1
        a[i], a[i + 1] = 9, a[i] - 9
        i += 1
    return """".join(str(d) for d in a)

m, s = map(int, input().split())
print(Min(m, s), Max(m, s))","def find_min_max_numbers(m, s):

    if s == 0:
        if m == 1:
            return ('0', '0')
        else:
            return ('-1', '-1')

    if s > 9 * m:
        return ('-1', '-1')

    min_number = ['0'] * m
    sum_remaining = s

    for i in range(m):

        for j in range(10):
            if (i > 0 or j > 0) and (sum_remaining - j >= 0) and (sum_remaining - j <= 9 * (m - i - 1)):
                min_number[i] = str(j)
                sum_remaining -= j
                break

    max_number = ['0'] * m
    sum_remaining = s

    for i in range(m):
        for j in range(9, -1, -1):
            if (i > 0 or j > 0) and (sum_remaining - j >= 0) and (sum_remaining - j <= 9 * (m - i - 1)):
                max_number[i] = str(j)
                sum_remaining -= j
                break

    return (''.join(min_number), ''.join(max_number))

import sys
input_data = sys.stdin.read().strip().split('\n')

results = []
for line in input_data:
    m, s = map(int, line.split())
    min_number, max_number = find_min_max_numbers(m, s)
    results.append(f""{min_number} {max_number}"")

print(""\n"".join(results))"
535,B,Tavas and SaDDas,PROGRAMMING,"['bitmasks', 'brute force', 'combinatorics', 'implementation']","Once again Tavas started eating coffee mix without water! Keione told him that it smells awful, but he didn't stop doing that. That's why Keione told his smart friend, SaDDas to punish him! SaDDas took Tavas' headphones and told him: ""If you solve the following problem, I'll return it to you.""

The problem is: 

You are given a lucky number *n*. Lucky numbers are the positive integers whose decimal representations contain only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.

If we sort all lucky numbers in increasing order, what's the 1-based index of *n*? 

Tavas is not as smart as SaDDas, so he asked you to do him a favor and solve this problem so he can have his headphones back.",The first and only line of input contains a lucky number *n* (1<=≤<=*n*<=≤<=109).,Print the index of *n* among all lucky numbers.,"['4\n', '7\n', '77\n']","['1\n', '2\n', '6\n']",none,OK,"def count_lucky_numbers(n):
    d = len(n)
    s = """"
    for i in range(d):
        if n[i] == '4':
            s += '0'
        else:
            s += '1'
    return 2*(2**(d-1)-1)+int(s,2)+1

n = input()
index = count_lucky_numbers(n)
print(index)","def lucky_number_index(n):

    s = str(n)

    length = len(s)

    index = 0

    for i in range(1, length):
        index += 2 ** i

    for i in range(length):

        for digit in ('4', '7'):
            if digit < s[i]:
                index += 2 ** (length - i - 1)
    
        if s[i] not in ('4', '7'):
            break

    return index + 1

n = int(input().strip())

print(lucky_number_index(n))"
957,A,Tritonic Iridescence,PROGRAMMING,['implementation'],"Overlooking the captivating blend of myriads of vernal hues, Arkady the painter lays out a long, long canvas.

Arkady has a sufficiently large amount of paint of three colours: cyan, magenta, and yellow. On the one-dimensional canvas split into *n* consecutive segments, each segment needs to be painted in one of the colours.

Arkady has already painted some (possibly none or all) segments and passes the paintbrush to you. You are to determine whether there are at least two ways of colouring all the unpainted segments so that no two adjacent segments are of the same colour. Two ways are considered different if and only if a segment is painted in different colours in them.","The first line contains a single positive integer *n* (1<=≤<=*n*<=≤<=100) — the length of the canvas.

The second line contains a string *s* of *n* characters, the *i*-th of which is either 'C' (denoting a segment painted in cyan), 'M' (denoting one painted in magenta), 'Y' (one painted in yellow), or '?' (an unpainted one).","If there are at least two different ways of painting, output ""Yes""; otherwise output ""No"" (both without quotes).

You can print each character in any case (upper or lower).","['5\nCY??Y\n', '5\nC?C?Y\n', '5\n?CYC?\n', '5\nC??MM\n', '3\nMMY\n']","['Yes\n', 'Yes\n', 'Yes\n', 'No\n', 'No\n']","For the first example, there are exactly two different ways of colouring: CYCMY and CYMCY.

For the second example, there are also exactly two different ways of colouring: CMCMY and CYCMY.

For the third example, there are four ways of colouring: MCYCM, MCYCY, YCYCM, and YCYCY.

For the fourth example, no matter how the unpainted segments are coloured, the existing magenta segments will prevent the painting from satisfying the requirements. The similar is true for the fifth example.",WRONG_ANSWER,"n = int(input());
s = input();

def f():
	for i in range(n-1):
		if s[i] == s[i+1] and s[i] != ""?"":
			return False
	if ""??"" in s:
		return True
	if ""C?C"" in s or ""M?M"" in s or ""Y?Y"" in s:
		return True
	return False

if f():
	print(""Yes"")
else:
	print(""No"")","def can_paint(n, s):

    def count_ways(s):
        ways = 1
        for i in range(1, n):

            if s[i] == '?' and s[i - 1] != '?':

                ways *= 2
            elif s[i] != '?' and s[i - 1] == '?':

                ways *= 1
            elif s[i] == s[i - 1] and s[i] != '?':

                return 0
        return ways

    ways = count_ways(s)
    return ""Yes"" if ways >= 2 else ""No""

test_cases = [
    '5\nCY??Y\n',
    '5\nC?C?Y\n',
    '5\n?CYC?\n',
    '5\nC??MM\n',
    '3\nMMY\n'
]

results = []
for case in test_cases:
    n, s = case.strip().split('\n')
    n = int(n)
    result = can_paint(n, s)
    results.append(result)

print(results)"
27,B,Tournament,PROGRAMMING,"['bitmasks', 'brute force', 'dfs and similar', 'greedy']","The tournament «Sleepyhead-2010» in the rapid falling asleep has just finished in Berland. *n* best participants from the country have participated in it. The tournament consists of games, each of them is a match between two participants. *n*·(*n*<=-<=1)<=/<=2 games were played during the tournament, and each participant had a match with each other participant. 

The rules of the game are quite simple — the participant who falls asleep first wins. The secretary made a record of each game in the form «*x**i* *y**i*», where *x**i* and *y**i* are the numbers of participants. The first number in each pair is a winner (i.e. *x**i* is a winner and *y**i* is a loser). There is no draws.

Recently researches form the «Institute Of Sleep» have found that every person is characterized by a value *p**j* — the speed of falling asleep. The person who has lower speed wins. Every person has its own value *p**j*, constant during the life. 

It is known that all participants of the tournament have distinct speeds of falling asleep. Also it was found that the secretary made records about all the games except one. You are to find the result of the missing game.","The first line contains one integer *n* (3<=≤<=*n*<=≤<=50) — the number of participants. The following *n*·(*n*<=-<=1)<=/<=2<=-<=1 lines contain the results of the games. Each game is described in a single line by two integers *x**i*,<=*y**i* (1<=≤<=*x**i*,<=*y**i*<=≤<=*n*,<=*x**i*<=≠<=*y**i*), where *x**i* и *y**i* are the numbers of the opponents in this game. It is known that during the tournament each of the *n* participants played *n*<=-<=1 games, one game with each other participant.","Output two integers *x* and *y* — the missing record. If there are several solutions, output any of them.",['4\n4 2\n4 1\n2 3\n2 1\n3 1\n'],['4 3\n'],none,WRONG_ANSWER,"def solution():
    n = int(input())

    cnt = {}

    for i in range(n * (n - 1) // 2 - 1):
        player = [int(i) for i in input().split()]
        if player[0] in cnt:
            cnt[player[0]][0].append(player[1])
        else:
            cnt[player[0]] = [[player[1]], []]
        if player[1] in cnt:
            cnt[player[1]][1].append(player[0])
        else:
            cnt[player[1]] = [[], [player[0]]]
    res = []
    for i in cnt:
        if len(cnt[i][0]) + len(cnt[i][1]) < n - 1:
            res.append(i)

    queue = [res[0]]
    head = 0
    visited = {res[0]}
    while head < len(queue):
        print(queue)
        if queue[head] == res[1]:
            print(res[0], res[1])
            break
        for i in cnt[queue[head]][0]:
            if i not in visited:
                visited.add(i)
                queue.append(i)
        head += 1
    else:
        print(res[1], res[0])

if __name__ == '__main__':
    solution()","n = int(input().strip())

games = set()

for _ in range(n * (n - 1) // 2 - 1):
    x, y = map(int, input().strip().split())
    games.add((x, y))

for i in range(1, n + 1):
    for j in range(1, n + 1):
        if i != j:

            if (i, j) not in games and (j, i) not in games:

                print(i, j)
                break"
849,A,Odds and Ends,PROGRAMMING,['implementation'],"Where do odds begin, and where do they end? Where does hope emerge, and will they ever break?

Given an integer sequence *a*1,<=*a*2,<=...,<=*a**n* of length *n*. Decide whether it is possible to divide it into an odd number of non-empty subsegments, the each of which has an odd length and begins and ends with odd numbers.

A subsegment is a contiguous slice of the whole sequence. For example, {3,<=4,<=5} and {1} are subsegments of sequence {1,<=2,<=3,<=4,<=5,<=6}, while {1,<=2,<=4} and {7} are not.","The first line of input contains a non-negative integer *n* (1<=≤<=*n*<=≤<=100) — the length of the sequence.

The second line contains *n* space-separated non-negative integers *a*1,<=*a*2,<=...,<=*a**n* (0<=≤<=*a**i*<=≤<=100) — the elements of the sequence.","Output ""Yes"" if it's possible to fulfill the requirements, and ""No"" otherwise.

You can output each letter in any case (upper or lower).","['3\n1 3 5\n', '5\n1 0 1 5 1\n', '3\n4 3 1\n', '4\n3 9 9 3\n']","['Yes\n', 'Yes\n', 'No\n', 'No\n']","In the first example, divide the sequence into 1 subsegment: {1, 3, 5} and the requirements will be met.

In the second example, divide the sequence into 3 subsegments: {1, 0, 1}, {5}, {1}.

In the third example, one of the subsegments must start with 4 which is an even number, thus the requirements cannot be met.

In the fourth example, the sequence can be divided into 2 subsegments: {3, 9, 9}, {3}, but this is not a valid solution because 2 is an even number.",OK,"n   = int(input())
arr = list(map(int, input().split()))

if n % 2 and arr[0] % 2 and arr[-1] % 2: print(""Yes"")
else:                                    print(""No"")","def can_divide_into_odd_segments(n, sequence):

    if n % 2 == 0:
        return ""No""

    if sequence[0] % 2 == 1 and sequence[-1] % 2 == 1:
        return ""Yes""
    
    return ""No""

n = int(input().strip())
sequence = list(map(int, input().strip().split()))

print(can_divide_into_odd_segments(n, sequence))"
41,A,Translation,PROGRAMMING,"['implementation', 'strings']","The translation from the Berland language into the Birland language is not an easy task. Those languages are very similar: a berlandish word differs from a birlandish word with the same meaning a little: it is spelled (and pronounced) reversely. For example, a Berlandish word code corresponds to a Birlandish word edoc. However, it's easy to make a mistake during the «translation». Vasya translated word *s* from Berlandish into Birlandish as *t*. Help him: find out if he translated the word correctly.","The first line contains word *s*, the second line contains word *t*. The words consist of lowercase Latin letters. The input data do not consist unnecessary spaces. The words are not empty and their lengths do not exceed 100 symbols.","If the word *t* is a word *s*, written reversely, print YES, otherwise print NO.","['code\nedoc\n', 'abb\naba\n', 'code\ncode\n']","['YES\n', 'NO\n', 'NO\n']",none,OK,"import os, io
 
input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
 
def main():    
    s = input().decode().rstrip(""\r\n"")
    t = input().decode().rstrip(""\r\n"")
    if s == t[::-1]:
        print(""YES"")
    else:
        print(""NO"")

main()","def check_translation(s, t):

    if s[::-1] == t:
        return ""YES""
    else:
        return ""NO""

s = input().strip()
t = input().strip()

result = check_translation(s, t)
print(result)"
632,A,Grandma Laura and Apples,PROGRAMMING,[],"Grandma Laura came to the market to sell some apples. During the day she sold all the apples she had. But grandma is old, so she forgot how many apples she had brought to the market.

She precisely remembers she had *n* buyers and each of them bought exactly half of the apples she had at the moment of the purchase and also she gave a half of an apple to some of them as a gift (if the number of apples at the moment of purchase was odd), until she sold all the apples she had.

So each buyer took some integral positive number of apples, but maybe he didn't pay for a half of an apple (if the number of apples at the moment of the purchase was odd).

For each buyer grandma remembers if she gave a half of an apple as a gift or not. The cost of an apple is *p* (the number *p* is even).

Print the total money grandma should have at the end of the day to check if some buyers cheated her.","The first line contains two integers *n* and *p* (1<=≤<=*n*<=≤<=40,<=2<=≤<=*p*<=≤<=1000) — the number of the buyers and the cost of one apple. It is guaranteed that the number *p* is even.

The next *n* lines contains the description of buyers. Each buyer is described with the string half if he simply bought half of the apples and with the string halfplus if grandma also gave him a half of an apple as a gift.

It is guaranteed that grandma has at least one apple at the start of the day and she has no apples at the end of the day.","Print the only integer *a* — the total money grandma should have at the end of the day.

Note that the answer can be too large, so you should use 64-bit integer type to store it. In C++ you can use the long long integer type and in Java you can use long integer type.","['2 10\nhalf\nhalfplus\n', '3 10\nhalfplus\nhalfplus\nhalfplus\n']","['15\n', '55\n']",In the first sample at the start of the day the grandma had two apples. First she sold one apple and then she sold a half of the second apple and gave a half of the second apple as a present to the second buyer.,WRONG_ANSWER,"import math

def main_function():
    n, p = [int(i) for i in input().split("" "")]
    customers = [input() for i in range(n)]
    counter = 0
    customers.reverse()
    for i in range(len(customers)):
        if i == 0:

                starter = 1
                counter += int(0.5 * p)
        else:
            if len(customers[i]) == 8:
                counter += int((starter + 0.5) * p)
                starter += starter + 1
                starter = int(starter)

            else:
                counter += int((starter)) * p
                starter += starter + 1
                starter = int(starter)

    print(counter)

if __name__ == '__main__':
    main_function()","def total_money_sold(n, p, buyers):
    apples = 0

    for buyer in reversed(buyers):
        if buyer == ""half"":
            apples = apples * 2
        elif buyer == ""halfplus"":
            apples = apples * 2 + 1

    total_money = apples * p
    return total_money

def main():
    import sys
    input = sys.stdin.read
    data = input().strip().splitlines()
    
    results = []

    for i in range(0, len(data), n + 1):
        n, p = map(int, data[i].split())
        buyers = data[i + 1:i + 1 + n]

        result = total_money_sold(n, p, buyers)
        results.append(result)

    for result in results:
        print(result)

if __name__ == ""__main__"":
    main()"
315,B,Sereja and Array,PROGRAMMING,['implementation'],"Sereja has got an array, consisting of *n* integers, *a*1,<=*a*2,<=...,<=*a**n*. Sereja is an active boy, so he is now going to complete *m* operations. Each operation will have one of the three forms:
 1.  Make *v**i*-th array element equal to *x**i*. In other words, perform the assignment *a**v**i*<==<=*x**i*. 1.  Increase each array element by *y**i*. In other words, perform *n* assignments *a**i*<==<=*a**i*<=+<=*y**i* (1<=≤<=*i*<=≤<=*n*). 1.  Take a piece of paper and write out the *q**i*-th array element. That is, the element *a**q**i*. 
Help Sereja, complete all his operations.","The first line contains integers *n*, *m* (1<=≤<=*n*,<=*m*<=≤<=105). The second line contains *n* space-separated integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=109) — the original array.

Next *m* lines describe operations, the *i*-th line describes the *i*-th operation. The first number in the *i*-th line is integer *t**i* (1<=≤<=*t**i*<=≤<=3) that represents the operation type. If *t**i*<==<=1, then it is followed by two integers *v**i* and *x**i*, (1<=≤<=*v**i*<=≤<=*n*,<=1<=≤<=*x**i*<=≤<=109). If *t**i*<==<=2, then it is followed by integer *y**i* (1<=≤<=*y**i*<=≤<=104). And if *t**i*<==<=3, then it is followed by integer *q**i* (1<=≤<=*q**i*<=≤<=*n*).","For each third type operation print value *a**q**i*. Print the values in the order, in which the corresponding queries follow in the input.",['10 11\n1 2 3 4 5 6 7 8 9 10\n3 2\n3 9\n2 10\n3 1\n3 10\n1 1 10\n2 10\n2 10\n3 1\n3 10\n3 9\n'],['2\n9\n11\n20\n30\n40\n39\n'],none,TIME_LIMIT_EXCEEDED,"[n, m] = list(map(int, input().split()))
numbers = list(map(int, input().split()))
additions = 0
t = 0
while t < m:
	op = list(map(int, input().split()))
	if op[0] == 1:
		numbers[op[1] - 1] = op[2] - additions
	elif op[0] == 2:
		additions += op[1]
	elif op[0] == 3:
		print(numbers[op[1] - 1] + additions)

	t += 1","def process_operations(n, m, array, operations):
    results = []
    increment = 0

    for operation in operations:
        op = operation[0]
        
        if op == 1:
            v, x = operation[1] - 1, operation[2]
            array[v] = x - increment

        elif op == 2:
            y = operation[1]
            increment += y

        elif op == 3:
            q = operation[1] - 1
            results.append(array[q] + increment)

    return results

n, m = map(int, input().split())
array = list(map(int, input().split()))

operations = []
for _ in range(m):
    ops = list(map(int, input().split()))
    operations.append(ops)

results = process_operations(n, m, array, operations)

print(""\n"".join(map(str, results)))"
151,A,Soft Drinking,PROGRAMMING,"['implementation', 'math']","This winter is so cold in Nvodsk! A group of *n* friends decided to buy *k* bottles of a soft drink called ""Take-It-Light"" to warm up a bit. Each bottle has *l* milliliters of the drink. Also they bought *c* limes and cut each of them into *d* slices. After that they found *p* grams of salt.

To make a toast, each friend needs *nl* milliliters of the drink, a slice of lime and *np* grams of salt. The friends want to make as many toasts as they can, provided they all drink the same amount. How many toasts can each friend make?","The first and only line contains positive integers *n*, *k*, *l*, *c*, *d*, *p*, *nl*, *np*, not exceeding 1000 and no less than 1. The numbers are separated by exactly one space.",Print a single integer — the number of toasts each friend can make.,"['3 4 5 10 8 100 3 1\n', '5 100 10 1 19 90 4 3\n', '10 1000 1000 25 23 1 50 1\n']","['2\n', '3\n', '0\n']","A comment to the first sample: 

Overall the friends have 4 * 5 = 20 milliliters of the drink, it is enough to make 20 / 3 = 6 toasts. The limes are enough for 10 * 8 = 80 toasts and the salt is enough for 100 / 1 = 100 toasts. However, there are 3 friends in the group, so the answer is *min*(6, 80, 100) / 3 = 2.",WRONG_ANSWER,"def softDrinking(n,k,l,c,d,p,nl,np):
    first = (k*l)//n
    second = c*d
    third = p//np
    
    ans = min(first,second,third)//n
    
    return ans

if __name__ == ""__main__"":
    n,k,l,c,d,p,nl,np = tuple([eval(i) for i in input().split()])
    
    ans = softDrinking(n,k,l,c,d,p,nl,np)
    print(ans)","n, k, l, c, d, p, nl, np = map(int, input().split())

total_drink = k * l
total_lime_slices = c * d
total_salt = p

toasts_based_on_drink = total_drink // nl
toasts_based_on_limes = total_lime_slices
toasts_based_on_salt = total_salt // np

max_toasts_per_friend = min(toasts_based_on_drink, toasts_based_on_limes, toasts_based_on_salt) // n

print(max_toasts_per_friend)"
1007,A,Reorder the Array,PROGRAMMING,"['combinatorics', 'data structures', 'math', 'sortings', 'two pointers']","You are given an array of integers. Vasya can permute (change order) its integers. He wants to do it so that as many as possible integers will become on a place where a smaller integer used to stand. Help Vasya find the maximal number of such integers.

For instance, if we are given an array $[10, 20, 30, 40]$, we can permute it so that it becomes $[20, 40, 10, 30]$. Then on the first and the second positions the integers became larger ($20&gt;10$, $40&gt;20$) and did not on the third and the fourth, so for this permutation, the number that Vasya wants to maximize equals $2$. Read the note for the first example, there is one more demonstrative test case.

Help Vasya to permute integers in such way that the number of positions in a new array, where integers are greater than in the original one, is maximal.","The first line contains a single integer $n$ ($1 \leq n \leq 10^5$) — the length of the array.

The second line contains $n$ integers $a_1, a_2, \ldots, a_n$ ($1 \leq a_i \leq 10^9$) — the elements of the array.",Print a single integer — the maximal number of the array's elements which after a permutation will stand on the position where a smaller element stood in the initial array.,"['7\n10 1 1 1 5 5 3\n', '5\n1 1 1 1 1\n']","['4\n', '0\n']","In the first sample, one of the best permutations is $[1, 5, 5, 3, 10, 1, 1]$. On the positions from second to fifth the elements became larger, so the answer for this permutation is 4.

In the second sample, there is no way to increase any element with a permutation, so the answer is 0.",WRONG_ANSWER,"def binarySearch(arr, l, r, x):
    while l <= r:
        mid = l + (r - l) // 2
        if arr[mid] == x:
            return mid
        elif arr[mid] < x:
            l = mid + 1
        else:
            r = mid - 1
    return -1
n=int(input())
arr=list(map(int,input().split()))
l=sorted(arr)
h=dict()
arr1=[]
for  i in range(n):
    a=len(l)
    l1=binarySearch(l, 0, a-1, arr[i])
    if l1+1 <a:
        arr1.append(l.pop(l1+1))
    else:
        arr1.append(l.pop(0))
z=0
for j in range(n):
    if arr[j]<arr1[i]:
        z+=1
print(z)","def maximum_increased_positions(n, arr):

    arr.sort()
    count = 0
    index = 0

    for num in arr:

        if index < n and num > arr[index]:
            count += 1
            index += 1
    return count

n = int(input().strip())
arr = list(map(int, input().strip().split()))

result = maximum_increased_positions(n, arr)
print(result)"
520,A,Pangram,PROGRAMMING,"['implementation', 'strings']","A word or a sentence in some language is called a pangram if all the characters of the alphabet of this language appear in it at least once. Pangrams are often used to demonstrate fonts in printing or test the output devices.

You are given a string consisting of lowercase and uppercase Latin letters. Check whether this string is a pangram. We say that the string contains a letter of the Latin alphabet if this letter occurs in the string in uppercase or lowercase.","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=100) — the number of characters in the string.

The second line contains the string. The string consists only of uppercase and lowercase Latin letters.","Output ""YES"", if the string is a pangram and ""NO"" otherwise.","['12\ntoosmallword\n', '35\nTheQuickBrownFoxJumpsOverTheLazyDog\n']","['NO\n', 'YES\n']",none,OK,"n = int(input())

s= input()
s = s.lower()

alphabet = 'abcdefghijklmnopqrstuvwxyz'
for i in alphabet:
    c = s.count(i)
    if c < 1:
        print('NO')
        exit()
print('YES')","def is_pangram(n, s):

    alphabet_set = set('abcdefghijklmnopqrstuvwxyz')

    input_set = set(s.lower())

    if alphabet_set.issubset(input_set):
        return ""YES""
    else:
        return ""NO""

n = int(input().strip())

s = input().strip()

print(is_pangram(n, s))"
449,B,Jzzhu and Cities,PROGRAMMING,"['graphs', 'greedy', 'shortest paths']","Jzzhu is the president of country A. There are *n* cities numbered from 1 to *n* in his country. City 1 is the capital of A. Also there are *m* roads connecting the cities. One can go from city *u**i* to *v**i* (and vise versa) using the *i*-th road, the length of this road is *x**i*. Finally, there are *k* train routes in the country. One can use the *i*-th train route to go from capital of the country to city *s**i* (and vise versa), the length of this route is *y**i*.

Jzzhu doesn't want to waste the money of the country, so he is going to close some of the train routes. Please tell Jzzhu the maximum number of the train routes which can be closed under the following condition: the length of the shortest path from every city to the capital mustn't change.","The first line contains three integers *n*,<=*m*,<=*k* (2<=≤<=*n*<=≤<=105; 1<=≤<=*m*<=≤<=3·105; 1<=≤<=*k*<=≤<=105).

Each of the next *m* lines contains three integers *u**i*,<=*v**i*,<=*x**i* (1<=≤<=*u**i*,<=*v**i*<=≤<=*n*; *u**i*<=≠<=*v**i*; 1<=≤<=*x**i*<=≤<=109).

Each of the next *k* lines contains two integers *s**i* and *y**i* (2<=≤<=*s**i*<=≤<=*n*; 1<=≤<=*y**i*<=≤<=109).

It is guaranteed that there is at least one way from every city to the capital. Note, that there can be multiple roads between two cities. Also, there can be multiple routes going to the same city from the capital.",Output a single integer representing the maximum number of the train routes which can be closed.,"['5 5 3\n1 2 1\n2 3 2\n1 3 3\n3 4 4\n1 5 5\n3 5\n4 5\n5 5\n', '2 2 3\n1 2 2\n2 1 3\n2 1\n2 2\n2 3\n']","['2\n', '2\n']",none,RUNTIME_ERROR,"from heapq import heapify, heappop, heappush
n , m ,k = map(int , input().split())
graph = [[] for i in range(n)]
for i in range(0 , m):
    a , b , d = map(int , input().split())
    graph[a-1].append((b-1,d))
    graph[b-1].append((a-1,d))
train = []
for i in range(k):
    a , d = map(int , input().split())
    train.append((a-1,d))
def djkestra(source):
        
        heap = []
        heapify(heap)
        distance = [100000000] * n
        distance[source]=0
        
        s = set()
        
        heappush(heap , (0 , source))
        while len(s) < len(graph):

            minDistance , popedIndex = heappop(heap)
            s.add(popedIndex)
            for curNode , curDist in graph[popedIndex]:

                if distance[curNode] > distance[popedIndex] + curDist:
                    distance[curNode] = distance[popedIndex] + curDist
                    heappush(heap , (distance[curNode] , curNode))
        return distance
dist = djkestra(0)
ans = 0
for a , d in train:
    if dist[a] <= d:
        ans +=1

print(ans)","import sys
import heapq

def main():
    input_data = sys.stdin.read().splitlines()
    idx = 0

    n, m, k = map(int, input_data[idx].split())
    idx += 1

    graph = [[] for _ in range(n + 1)]

    for _ in range(m):
        u, v, x = map(int, input_data[idx].split())
        graph[u].append((v, x))
        graph[v].append((u, x))
        idx += 1

    train_routes = []
    for _ in range(k):
        s, y = map(int, input_data[idx].split())
        train_routes.append((s, y))
        idx += 1

    def dijkstra(start):
        distances = [float('inf')] * (n + 1)
        distances[start] = 0
        priority_queue = [(0, start)]

        while priority_queue:
            current_distance, current_node = heapq.heappop(priority_queue)

            if current_distance > distances[current_node]:
                continue

            for neighbor, weight in graph[current_node]:
                distance = current_distance + weight

                if distance < distances[neighbor]:
                    distances[neighbor] = distance
                    heapq.heappush(priority_queue, (distance, neighbor))

        return distances

    shortest_paths = dijkstra(1)

    removable_routes = 0
    for s, y in train_routes:
        if y >= shortest_paths[s]:
            removable_routes += 1

    print(removable_routes)

if __name__ == ""__main__"":
    main()"
2,B,The least round way,PROGRAMMING,"['dp', 'math']","There is a square matrix *n*<=×<=*n*, consisting of non-negative integer numbers. You should find such a way on it that 
 -  starts in the upper left cell of the matrix; -  each following cell is to the right or down from the current cell; -  the way ends in the bottom right cell. 
Moreover, if we multiply together all the numbers along the way, the result should be the least ""round"". In other words, it should end in the least possible number of zeros.","The first line contains an integer number *n* (2<=≤<=*n*<=≤<=1000), *n* is the size of the matrix. Then follow *n* lines containing the matrix elements (non-negative integer numbers not exceeding 109).",In the first line print the least number of trailing zeros. In the second line print the correspondent way itself.,['3\n1 2 3\n4 5 6\n7 8 9\n'],['0\nDDRR\n'],none,WRONG_ANSWER,"from math import log2

def hp2(n):
	if n % 2 != 0: return 0
	return round(log2((n & (~(n - 1)))))

def hp5(n):
	if n % 5 != 0: return 0
	p = 1
	m = 5
	while n % m == 0:
		p += 1
		m *= 5
	return p - 1 

def extract(x):
	t, f = hp2(x), hp5(x)
	zeros = min(t, f)

	return (zeros, t - zeros, f - zeros)

inf = float(""Inf"")
def count(x, y):
	if(memo[x][y] != None):
		return memo[x][y]

	tempZ, tempT, tempF = extract(m[x][y])
	step = -1
	if x == 0 and y == 0:
		ans = (tempZ, tempT, tempF)
	else:
		ans = (inf, inf, inf)
		if x > 0:
			temp = count(x - 1, y)
			z = temp[0] + tempZ
			netF, netT = temp[2] + tempF, temp[1] + tempT
			k = min(netF, netT)
			z += k
			if z < ans[0]:
				step = 0
				ans = (z, netT - k, netF - k)
		if y > 0:
			temp = count(x, y - 1)
			z = temp[0] + tempZ
			netF, netT = temp[2] + tempF, temp[1] + tempT
			k = min(netF, netT)
			z += k
			if z < ans[0]:
				step = 1
				ans = (z, netT - k, netF - k)

	memo[x][y] = ans
	steps[x][y] = step
	return ans

n = int(input())
m = [[0 for i in range(n)] for i in range(n)]
memo = [[None for i in range(n)] for i in range(n)]
steps = [[-1 for i in range(n)] for i in range(n)]

for i in range(n):
	r = [int(k) for k in input().split()]
	for j in range(n):
		m[i][j] = r[j]

ans = count(n - 1, n - 1)[0]
path = """"
x, y = n - 1, n - 1
while not (x == 0 and y == 0):

	if steps[x][y] == 0:
		path = ""D"" + path
		x -= 1
	else:
		path = ""R"" + path
		y -= 1
print(ans)
print(path)","def count_trailing_zeros(num):
    """"""Count the trailing zeros in the factorial of a number.""""""
    count = 0
    while num > 0:
        num //= 5
        count += num
    return count

def get_factor_counts(matrix, n):
    """"""Calculate the number of 2s and 5s in the factorization of the product.""""""
    twos = [[0] * n for _ in range(n)]
    fives = [[0] * n for _ in range(n)]

    for i in range(n):
        for j in range(n):
            val = matrix[i][j]
            count2, count5 = 0, 0
            
            while val > 0 and val % 2 == 0:
                count2 += 1
                val //= 2
            
            val = matrix[i][j]
            while val > 0 and val % 5 == 0:
                count5 += 1
                val //= 5
                
            twos[i][j] = count2
            fives[i][j] = count5
    
    return twos, fives

def min_trailing_zeros_path(matrix, n):
    twos, fives = get_factor_counts(matrix, n)
    dp = [[(0, '')] * n for _ in range(n)]

    dp[0][0] = (twos[0][0], fives[0][0], '')

    for i in range(n):
        for j in range(n):
            if i > 0:
                prev_twos, prev_fives, path = dp[i-1][j]
                new_twos = prev_twos + twos[i][j]
                new_fives = prev_fives + fives[i][j]
                if (new_twos, new_fives) < (dp[i][j][0], dp[i][j][1]):
                    dp[i][j] = (new_twos, new_fives, path + 'D')
                    
            if j > 0:
                prev_twos, prev_fives, path = dp[i][j-1]
                new_twos = prev_twos + twos[i][j]
                new_fives = prev_fives + fives[i][j]
                if (new_twos, new_fives) < (dp[i][j][0], dp[i][j][1]):
                    dp[i][j] = (new_twos, new_fives, path + 'R')
    
    min_trailing_zeros = min(dp[n-1][n-1][0], dp[n-1][n-1][1])
    path = dp[n-1][n-1][2]
    
    return min_trailing_zeros, path

if __name__ == '__main__':
    import sys

    n = int(sys.stdin.readline().strip())
    matrix = [list(map(int, sys.stdin.readline().strip().split())) for _ in range(n)]

    trailing_zeros, path = min_trailing_zeros_path(matrix, n)

    print(trailing_zeros)
    print(path)"
233,A,Perfect Permutation,PROGRAMMING,"['implementation', 'math']","A permutation is a sequence of integers *p*1,<=*p*2,<=...,<=*p**n*, consisting of *n* distinct positive integers, each of them doesn't exceed *n*. Let's denote the *i*-th element of permutation *p* as *p**i*. We'll call number *n* the size of permutation *p*1,<=*p*2,<=...,<=*p**n*.

Nickolas adores permutations. He likes some permutations more than the others. He calls such permutations perfect. A perfect permutation is such permutation *p* that for any *i* (1<=≤<=*i*<=≤<=*n*) (*n* is the permutation size) the following equations hold *p**p**i*<==<=*i* and *p**i*<=≠<=*i*. Nickolas asks you to print any perfect permutation of size *n* for the given *n*.",A single line contains a single integer *n* (1<=≤<=*n*<=≤<=100) — the permutation size.,"If a perfect permutation of size *n* doesn't exist, print a single integer -1. Otherwise print *n* distinct integers from 1 to *n*, *p*1,<=*p*2,<=...,<=*p**n* — permutation *p*, that is perfect. Separate printed numbers by whitespaces.","['1\n', '2\n', '4\n']","['-1\n', '2 1 \n', '2 1 4 3 \n']",none,WRONG_ANSWER,"def sol(n):
    if n == 1:
        return -1
    arr = [0]*n 
    for i in range(n):
        arr[i] = n-i 
    if n%2 != 0:
        temp = arr[int(n/2)]
        arr[int(n/2)] = arr[int(n/2)+1]
        arr[int(n/2)+1] = temp 
        
    return arr 
n = int(input())
ans = sol(n)
print(ans)","def perfect_permutation(n):

    if n % 2 != 0:
        return -1

    permutation = []
    for i in range(1, n + 1, 2):

        permutation.append(i + 1)
        permutation.append(i)
    
    return ' '.join(map(str, permutation))

n = int(input().strip())

result = perfect_permutation(n)
print(result)"
656,G,You're a Professional,PROGRAMMING,['*special'],"A simple recommendation system would recommend a user things liked by a certain number of their friends. In this problem you will implement part of such a system.

You are given user's friends' opinions about a list of items. You are also given a threshold *T* — the minimal number of ""likes"" necessary for an item to be recommended to the user.

Output the number of items in the list liked by at least *T* of user's friends.","The first line of the input will contain three space-separated integers: the number of friends *F* (1<=≤<=*F*<=≤<=10), the number of items *I* (1<=≤<=*I*<=≤<=10) and the threshold *T* (1<=≤<=*T*<=≤<=*F*).

The following *F* lines of input contain user's friends' opinions. *j*-th character of *i*-th line is 'Y' if *i*-th friend likes *j*-th item, and 'N' otherwise.",Output an integer — the number of items liked by at least *T* of user's friends.,"['3 3 2\nYYY\nNNN\nYNY\n', '4 4 1\nNNNY\nNNYN\nNYNN\nYNNN\n']","['2\n', '4\n']",none,WRONG_ANSWER,"def main():
    f, i, t = map(int, input().split())
    ans = 0
    for _ in range(f):
        likes = input()
        count = sum(1 for like in likes if like == 'Y')
        if count >= t:
            ans += 1

    print(ans)

main()","def recommend_items(input_data):
    results = []
    
    for data in input_data:
        lines = data.strip().split('\n')
        F, I, T = map(int, lines[0].split())
        opinions = lines[1:F + 1]

        like_counts = [0] * I

        for opinion in opinions:
            for j in range(I):
                if opinion[j] == 'Y':
                    like_counts[j] += 1

        recommended_count = sum(1 for count in like_counts if count >= T)
        results.append(recommended_count)
    
    return results

input_data = ['3 3 2\nYYY\nNNN\nYNY\n', '4 4 1\nNNNY\nNNYN\nNYNN\nYNNN\n']
output = recommend_items(input_data)

for count in output:
    print(count)"
891,A,Pride,PROGRAMMING,"['brute force', 'dp', 'greedy', 'math', 'number theory']","You have an array *a* with length *n*, you can perform operations. Each operation is like this: choose two adjacent elements from *a*, say *x* and *y*, and replace one of them with *gcd*(*x*,<=*y*), where *gcd* denotes the [greatest common divisor](https://en.wikipedia.org/wiki/Greatest_common_divisor).

What is the minimum number of operations you need to make all of the elements equal to 1?","The first line of the input contains one integer *n* (1<=≤<=*n*<=≤<=2000) — the number of elements in the array.

The second line contains *n* space separated integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=109) — the elements of the array.","Print -1, if it is impossible to turn all numbers to 1. Otherwise, print the minimum number of operations needed to make all numbers equal to 1.","['5\n2 2 3 4 6\n', '4\n2 4 6 8\n', '3\n2 6 9\n']","['5\n', '-1\n', '4\n']","In the first sample you can turn all numbers to 1 using the following 5 moves:
 -  [2, 2, 3, 4, 6]. -  [2, 1, 3, 4, 6] -  [2, 1, 3, 1, 6] -  [2, 1, 1, 1, 6] -  [1, 1, 1, 1, 6] -  [1, 1, 1, 1, 1] 
We can prove that in this case it is not possible to make all numbers one using less than 5 moves.",WRONG_ANSWER,"def main():
    n = int(input())
    a = list(map(int, input().split()))

    if gcd_of_array(a) != 1:
        print(-1)
    else:
        left = 2
        right = n

        while left <= right:
            mid = (left + right) // 2
            if check(a, mid):
                right = mid - 1
            else:
                left = mid + 1

        ans = n + mid - 2

        print(ans)

def check(a, le):
    for i in range(len(a) - le):
        if gcd_of_array(a[i:i+le]) == 1:
            return True
    return False

def gcd(a, b):
    if a == 0:
        return b
    else:
        return gcd(b % a, a)

def gcd_of_array(a):
    res = a[0]
    for i in a:
        res = gcd(res, i)
        if res == 1:
            break
    return res

main()","import sys
from math import gcd

def min_operations_to_one(n, a):

    if gcd(*a) != 1:
        return -1
    
    operations = 0

    while any(x != 1 for x in a):
        for i in range(n - 1):

            if a[i] != 1 and a[i + 1] != 1:
                if gcd(a[i], a[i + 1]) == 1:
                    a[i] = 1
                    operations += 1
                else:

                    if a[i] > a[i + 1]:
                        a[i] = gcd(a[i], a[i + 1])
                    else:
                        a[i + 1] = gcd(a[i], a[i + 1])
                    operations += 1
    
    return operations

n = int(sys.stdin.readline().strip())
a = list(map(int, sys.stdin.readline().strip().split()))

result = min_operations_to_one(n, a)
print(result)"
220,A,Little Elephant and Problem,PROGRAMMING,"['implementation', 'sortings']","The Little Elephant has got a problem — somebody has been touching his sorted by non-decreasing array *a* of length *n* and possibly swapped some elements of the array.

The Little Elephant doesn't want to call the police until he understands if he could have accidentally changed the array himself. He thinks that he could have accidentally changed array *a*, only if array *a* can be sorted in no more than one operation of swapping elements (not necessarily adjacent). That is, the Little Elephant could have accidentally swapped some two elements.

Help the Little Elephant, determine if he could have accidentally changed the array *a*, sorted by non-decreasing, himself.","The first line contains a single integer *n* (2<=≤<=*n*<=≤<=105) — the size of array *a*. The next line contains *n* positive integers, separated by single spaces and not exceeding 109, — array *a*.

Note that the elements of the array are not necessarily distinct numbers.","In a single line print ""YES"" (without the quotes) if the Little Elephant could have accidentally changed the array himself, and ""NO"" (without the quotes) otherwise.","['2\n1 2\n', '3\n3 2 1\n', '4\n4 3 2 1\n']","['YES\n', 'YES\n', 'NO\n']","In the first sample the array has already been sorted, so to sort it, we need 0 swap operations, that is not more than 1. Thus, the answer is ""YES"".

In the second sample we can sort the array if we swap elements 1 and 3, so we need 1 swap operation to sort the array. Thus, the answer is ""YES"".

In the third sample we can't sort the array in more than one swap operation, so the answer is ""NO"".",OK,"from sys import stdin
from collections import deque,Counter,defaultdict
import sys
import math
import operator
import random
from fractions import Fraction
import functools
import bisect
import itertools
from heapq import *
import time

n = int(input())
arr = list(map(int,input().split()))
c = 0
for i,j in zip(arr,sorted(arr)):
    if i!=j:
        c+=1
print('YES' if c == 0 or c == 2 else 'NO')","def can_sort_with_one_swap(n, a):

    sorted_a = sorted(a)

    diff_indices = [i for i in range(n) if a[i] != sorted_a[i]]

    if len(diff_indices) == 0:
        return ""YES""

    if len(diff_indices) > 2:
        return ""NO""

    i, j = diff_indices

    if a[i] == sorted_a[j] and a[j] == sorted_a[i]:
        return ""YES""
    
    return ""NO""

n = int(input())
a = list(map(int, input().split()))

print(can_sort_with_one_swap(n, a))"
2,A,Winner,PROGRAMMING,"['hashing', 'implementation']","The winner of the card game popular in Berland ""Berlogging"" is determined according to the following rules. If at the end of the game there is only one player with the maximum number of points, he is the winner. The situation becomes more difficult if the number of such players is more than one. During each round a player gains or loses a particular number of points. In the course of the game the number of points is registered in the line ""name score"", where name is a player's name, and score is the number of points gained in this round, which is an integer number. If score is negative, this means that the player has lost in the round. So, if two or more players have the maximum number of points (say, it equals to *m*) at the end of the game, than wins the one of them who scored at least *m* points first. Initially each player has 0 points. It's guaranteed that at the end of the game at least one player has a positive number of points.","The first line contains an integer number *n* (1<=<=≤<=<=*n*<=<=≤<=<=1000), *n* is the number of rounds played. Then follow *n* lines, containing the information about the rounds in ""name score"" format in chronological order, where name is a string of lower-case Latin letters with the length from 1 to 32, and score is an integer number between -1000 and 1000, inclusive.",Print the name of the winner.,"['3\nmike 3\nandrew 5\nmike 2\n', '3\nandrew 3\nandrew 2\nmike 5\n']","['andrew\n', 'andrew\n']",none,WRONG_ANSWER,"class RoundTotals:
       def __init__(self, name, points):
              self.name = name
              self.points = points

def value(inputValue):
       try:

              return int(inputValue) 
       except ValueError:

              return inputValue

def getInput():

       rounds = int(input())

       totals = []

       while rounds:

              rounds -= 1

              name, points = map(value, str(input()).split())

              totals.append(RoundTotals(name, points))

       return totals

def searchWinner(player1, player2):
       if player1.points > player2.points:
              return player1
       else:
              return player2

def returnWinner():

       totals = getInput()

       i = 0

       winner = totals[0]

       while i < len(totals)-1:

              if totals[i].name != totals[i+1].name:

                     winner = searchWinner(winner, totals[i+1])
              else:
                     totals[i].points += totals[i+1].points
                     totals.remove(totals[i+1])

              i += 1

       return winner.name

print(returnWinner())","def berlogging_winner(rounds):
    scores = {}
    cumulative_scores = {}

    for entry in rounds:
        name, score = entry.split()
        score = int(score)

        if name not in scores:
            scores[name] = 0
            cumulative_scores[name] = []

        scores[name] += score
        cumulative_scores[name].append(scores[name])

    max_score = max(scores.values())

    candidates = [name for name, score in scores.items() if score == max_score]

    if len(candidates) == 1:

        return candidates[0]

    max_score_reached = {}
    
    for name in candidates:
        for cumulative_score in cumulative_scores[name]:
            if cumulative_score >= max_score and name not in max_score_reached:
                max_score_reached[name] = cumulative_score
                break
                
    return next(iter(max_score_reached))

input_data = ['3\nmike 3\nandrew 5\nmike 2\n', '3\nandrew 3\nandrew 2\nmike 5\n']

for data in input_data:
    n, *round_data = data.strip().split('\n')
    winner = berlogging_winner(round_data)
    print(winner)"
384,A,Coder,PROGRAMMING,['implementation'],"Iahub likes chess very much. He even invented a new chess piece named Coder. A Coder can move (and attack) one square horizontally or vertically. More precisely, if the Coder is located at position (*x*,<=*y*), he can move to (or attack) positions (*x*<=+<=1,<=*y*), (*x*–1,<=*y*), (*x*,<=*y*<=+<=1) and (*x*,<=*y*–1).

Iahub wants to know how many Coders can be placed on an *n*<=×<=*n* chessboard, so that no Coder attacks any other Coder.",The first line contains an integer *n* (1<=≤<=*n*<=≤<=1000).,"On the first line print an integer, the maximum number of Coders that can be placed on the chessboard.

On each of the next *n* lines print *n* characters, describing the configuration of the Coders. For an empty cell print an '.', and for a Coder print a 'C'.

If there are multiple correct answers, you can print any.",['2\n'],['2\nC.\n.C\n'],none,WRONG_ANSWER,"n = int(input())
print(n)
a = ['C' if i % 2 == 0 else '.' for i in range(n)]

def swap(a):
    for i in range(n):
        if a[i] == '.':
            a[i] = 'C'
        else:
            a[i] = '.'
    return a

for i in range(n):
    print(*a, sep='')
    a = swap(a)","def place_coders(n):

    board = [['.' for _ in range(n)] for _ in range(n)]

    for i in range(n):
        for j in range(n):
            if (i + j) % 2 == 0:
                board[i][j] = 'C'

    max_coders = (n * n + 1) // 2
    
    return max_coders, board

def main():
    n = int(input().strip())
    max_coders, board = place_coders(n)
    
    print(max_coders)
    for row in board:
        print(''.join(row))

if __name__ == ""__main__"":
    main()"
637,C,Promocodes with Mistakes,PROGRAMMING,"['*special', 'brute force', 'constructive algorithms', 'implementation']","During a New Year special offer the ""Sudislavl Bars"" offered *n* promo codes. Each promo code consists of exactly six digits and gives right to one free cocktail at the bar ""Mosquito Shelter"". Of course, all the promocodes differ.

As the ""Mosquito Shelter"" opens only at 9, and partying in Sudislavl usually begins at as early as 6, many problems may arise as to how to type a promotional code without errors. It is necessary to calculate such maximum *k*, that the promotional code could be uniquely identified if it was typed with no more than *k* errors. At that, *k*<==<=0 means that the promotional codes must be entered exactly.

A mistake in this problem should be considered as entering the wrong numbers. For example, value ""123465"" contains two errors relative to promocode ""123456"". Regardless of the number of errors the entered value consists of exactly six digits.","The first line of the output contains number *n* (1<=≤<=*n*<=≤<=1000) — the number of promocodes.

Each of the next *n* lines contains a single promocode, consisting of exactly 6 digits. It is guaranteed that all the promocodes are distinct. Promocodes can start from digit ""0"".","Print the maximum *k* (naturally, not exceeding the length of the promocode), such that any promocode can be uniquely identified if it is typed with at most *k* mistakes.","['2\n000000\n999999\n', '6\n211111\n212111\n222111\n111111\n112111\n121111\n']","['2\n', '0\n']","In the first sample *k* &lt; 3, so if a bar customer types in value ""090909"", then it will be impossible to define which promocode exactly corresponds to it.",RUNTIME_ERROR,"n = input()
promo_code = []
def compare_str(a,b):
    k = 0
    for i in range(6):
        if a[i] == b[i]:
            k = k+1
    return k
for i in range(0,int(n)):
    x = input()
    promo_code.append(x)
largest_same_num = 0 
for i in promo_code:
    for j in promo_code:
        if i!=j:
            a = compare_str(i,j)
            if a > largest_same_num:
                largest_same_num = a
k = 0
if largest_same_num == 1 or largest_same_num == 0:
    k = 2
elif largesr_same_num == 2 or largest_same_num == 3:
    k = 1
print(k)","def hamming_distance(code1, code2):
    """"""Calculate the Hamming distance between two promo codes.""""""
    return sum(el1 != el2 for el1, el2 in zip(code1, code2))

def max_k(promocodes):
    """"""Find the maximum number of allowable errors (k) for unique identification.""""""
    n = len(promocodes)
    max_k = len(promocodes[0])

    for i in range(n):
        for j in range(i + 1, n):

            distance = hamming_distance(promocodes[i], promocodes[j])

            max_k = min(max_k, distance - 1)

    return max_k

def main():
    import sys
    input = sys.stdin.read
    data = input().strip().split('\n')
    
    n = int(data[0])
    promocodes = data[1:n + 1]
    
    result = max_k(promocodes)
    print(result)

if __name__ == ""__main__"":
    main()"
582,A,GCD Table,PROGRAMMING,"['constructive algorithms', 'greedy', 'number theory']","The GCD table *G* of size *n*<=×<=*n* for an array of positive integers *a* of length *n* is defined by formula 

Let us remind you that the greatest common divisor (GCD) of two positive integers *x* and *y* is the greatest integer that is divisor of both *x* and *y*, it is denoted as . For example, for array *a*<==<={4,<=3,<=6,<=2} of length 4 the GCD table will look as follows:

Given all the numbers of the GCD table *G*, restore array *a*.","The first line contains number *n* (1<=≤<=*n*<=≤<=500) — the length of array *a*. The second line contains *n*2 space-separated numbers — the elements of the GCD table of *G* for array *a*. 

All the numbers in the table are positive integers, not exceeding 109. Note that the elements are given in an arbitrary order. It is guaranteed that the set of the input data corresponds to some array *a*.","In the single line print *n* positive integers — the elements of array *a*. If there are multiple possible solutions, you are allowed to print any of them.","['4\n2 1 2 3 4 3 2 6 1 1 2 2 1 2 3 2\n', '1\n42\n', '2\n1 1 1 1\n']","['4 3 6 2', '42 ', '1 1 ']",none,TIME_LIMIT_EXCEEDED,"def gcd(a,b):
    if b==0: return a 
    return gcd(b,a%b)
n=int(input())
from collections import Counter 
l=[int(i) for i in input().split()]
g=Counter(l)
ans=[]

while g:
    m=max(g)
    g[m]-=1 
    for i in ans:
        g[gcd(m,i)]-=2 
    ans+=[m]

print(*ans)","import sys
from math import gcd
from collections import Counter

def restore_array(n, gcd_table):

    count = Counter(gcd_table)

    a = []

    max_value = max(gcd_table)
    a.append(max_value)

    count[max_value] -= 1

    for _ in range(1, n):

        current_max = max(k for k, v in count.items() if v > 0)
        a.append(current_max)

        count[current_max] -= 1

        for num in a[:-1]:
            g = gcd(current_max, num)
            count[g] -= 1
    
    return a

input_lines = sys.stdin.read().strip().split('\n')
n = int(input_lines[0])
gcd_table = list(map(int, input_lines[1].split()))

result = restore_array(n, gcd_table)

print(' '.join(map(str, result)))"
260,A,Adding Digits,PROGRAMMING,"['implementation', 'math']","Vasya has got two number: *a* and *b*. However, Vasya finds number *a* too short. So he decided to repeat the operation of lengthening number *a* *n* times.

One operation of lengthening a number means adding exactly one digit to the number (in the decimal notation) to the right provided that the resulting number is divisible by Vasya's number *b*. If it is impossible to obtain the number which is divisible by *b*, then the lengthening operation cannot be performed.

Your task is to help Vasya and print the number he can get after applying the lengthening operation to number *a* *n* times.","The first line contains three integers: *a*,<=*b*,<=*n* (1<=≤<=*a*,<=*b*,<=*n*<=≤<=105).","In a single line print the integer without leading zeros, which Vasya can get when he applies the lengthening operations to number *a* *n* times. If no such number exists, then print number -1. If there are multiple possible answers, print any of them.","['5 4 5\n', '12 11 1\n', '260 150 10\n']","['524848\n', '121\n', '-1\n']",none,TIME_LIMIT_EXCEEDED,"def check(a, b):
    for i in range(10):
        if int(str(a) + str(i)) % b == 0:
            return int(str(a) + str(i))
    return -1

a, b, n = [int(x) for x in input().split()]

def q(a, b, n):
    for _ in range(n):
        z = check(a, b)
        if z != -1:
            a = z
        else:
            return -1
    return a

print(q(a, b, n))","def lengthen_number(a, b, n):
    a_str = str(a)
    
    for _ in range(n):
        found = False
        for digit in range(10):
            new_number = int(a_str + str(digit))
            
            if new_number % b == 0:
                a_str += str(digit)
                found = True
                break
            
        if not found:
            return -1
        
    return a_str

input_data = ['5 4 5\n', '12 11 1\n', '260 150 10\n']
output_data = []

for data in input_data:
    a, b, n = map(int, data.strip().split())
    result = lengthen_number(a, b, n)
    output_data.append(result)

for output in output_data:
    print(output)"
771,A,Bear and Friendship Condition,PROGRAMMING,"['dfs and similar', 'dsu', 'graphs']","Bear Limak examines a social network. Its main functionality is that two members can become friends (then they can talk with each other and share funny pictures).

There are *n* members, numbered 1 through *n*. *m* pairs of members are friends. Of course, a member can't be a friend with themselves.

Let A-B denote that members A and B are friends. Limak thinks that a network is reasonable if and only if the following condition is satisfied: For every three distinct members (X, Y, Z), if X-Y and Y-Z then also X-Z.

For example: if Alan and Bob are friends, and Bob and Ciri are friends, then Alan and Ciri should be friends as well.

Can you help Limak and check if the network is reasonable? Print ""YES"" or ""NO"" accordingly, without the quotes.","The first line of the input contain two integers *n* and *m* (3<=≤<=*n*<=≤<=150<=000, ) — the number of members and the number of pairs of members that are friends.

The *i*-th of the next *m* lines contains two distinct integers *a**i* and *b**i* (1<=≤<=*a**i*,<=*b**i*<=≤<=*n*,<=*a**i*<=≠<=*b**i*). Members *a**i* and *b**i* are friends with each other. No pair of members will appear more than once in the input.","If the given network is reasonable, print ""YES"" in a single line (without the quotes). Otherwise, print ""NO"" in a single line (without the quotes).","['4 3\n1 3\n3 4\n1 4\n', '4 4\n3 1\n2 3\n3 4\n1 2\n', '10 4\n4 3\n5 10\n8 9\n1 2\n', '3 2\n1 2\n2 3\n']","['YES\n', 'NO\n', 'YES\n', 'NO\n']","The drawings below show the situation in the first sample (on the left) and in the second sample (on the right). Each edge represents two members that are friends. The answer is ""NO"" in the second sample because members (2, 3) are friends and members (3, 4) are friends, while members (2, 4) are not.",TIME_LIMIT_EXCEEDED,"from collections import defaultdict

class UnionFind():
    def __init__(self, n):
        self.n = n
        self.parents = [-1] * n

    def find(self, x):
        if self.parents[x] < 0:
            return x
        else:
            self.parents[x] = self.find(self.parents[x])
            return self.parents[x]

    def union(self, x, y):
        x = self.find(x)
        y = self.find(y)

        if x == y:
            return

        if self.parents[x] > self.parents[y]:
            x, y = y, x

        self.parents[x] += self.parents[y]
        self.parents[y] = x

    def size(self, x):
        return -self.parents[self.find(x)]

    def same(self, x, y):
        return self.find(x) == self.find(y)

    def members(self, x):
        root = self.find(x)
        return [i for i in range(self.n) if self.find(i) == root]

    def roots(self):
        return [i for i, x in enumerate(self.parents) if x < 0]

    def group_count(self):
        return len(self.roots())

    def all_group_members(self):
        group_members = defaultdict(list)
        for member in range(self.n):
            group_members[self.find(member)].append(member)
        return group_members
n,m=map(int,input().split())
g=[[] for i in range(n)]
uf=UnionFind(n)
for _ in range(m):
  u,v=map(int,input().split())
  g[u-1].append(v-1)
  g[v-1].append(u-1)
  uf.union(u-1,v-1)
for r in uf.roots():
  s=uf.size(r)
  for i in uf.members(r):
    if len(g[i])!=s-1:
      print(""NO"")
      exit()
print(""YES"")","def is_network_reasonable(n, m, friendships):

    friends = [[False] * (n + 1) for _ in range(n + 1)]

    for a, b in friendships:
        friends[a][b] = True
        friends[b][a] = True

    for x in range(1, n + 1):
        for y in range(1, n + 1):
            if x != y and friends[x][y]:
                for z in range(1, n + 1):
                    if y != z and x != z and friends[y][z]:

                        if not friends[x][z]:
                            return ""NO""
    
    return ""YES""

input_data = input().splitlines()
n, m = map(int, input_data[0].split())
friendships = [tuple(map(int, line.split())) for line in input_data[1:m + 1]]

result = is_network_reasonable(n, m, friendships)
print(result)"
343,C,Read Time,PROGRAMMING,"['binary search', 'greedy', 'two pointers']","Mad scientist Mike does not use slow hard disks. His modification of a hard drive has not one, but *n* different heads that can read data in parallel.

When viewed from the side, Mike's hard drive is an endless array of tracks. The tracks of the array are numbered from left to right with integers, starting with 1. In the initial state the *i*-th reading head is above the track number *h**i*. For each of the reading heads, the hard drive's firmware can move the head exactly one track to the right or to the left, or leave it on the current track. During the operation each head's movement does not affect the movement of the other heads: the heads can change their relative order; there can be multiple reading heads above any of the tracks. A track is considered read if at least one head has visited this track. In particular, all of the tracks numbered *h*1, *h*2, ..., *h**n* have been read at the beginning of the operation.

Mike needs to read the data on *m* distinct tracks with numbers *p*1, *p*2, ..., *p**m*. Determine the minimum time the hard drive firmware needs to move the heads and read all the given tracks. Note that an arbitrary number of other tracks can also be read.","The first line of the input contains two space-separated integers *n*, *m* (1<=≤<=*n*,<=*m*<=≤<=105) — the number of disk heads and the number of tracks to read, accordingly. The second line contains *n* distinct integers *h**i* in ascending order (1<=≤<=*h**i*<=≤<=1010, *h**i*<=&lt;<=*h**i*<=+<=1) — the initial positions of the heads. The third line contains *m* distinct integers *p**i* in ascending order (1<=≤<=*p**i*<=≤<=1010, *p**i*<=&lt;<=*p**i*<=+<=1) - the numbers of tracks to read.

Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is recommended to use the cin, cout streams or the %I64d specifier.","Print a single number — the minimum time required, in seconds, to read all the needed tracks.","['3 4\n2 5 6\n1 3 6 8\n', '3 3\n1 2 3\n1 2 3\n', '1 2\n165\n142 200\n']","['2\n', '0\n', '81\n']","The first test coincides with the figure. In this case the given tracks can be read in 2 seconds in the following way: 
 1.  during the first second move the 1-st head to the left and let it stay there; 1.  move the second head to the left twice; 1.  move the third head to the right twice (note that the 6-th track has already been read at the beginning). 
One cannot read the tracks in 1 second as the 3-rd head is at distance 2 from the 8-th track.",OK,"import sys
input = sys.stdin.buffer.readline

n, m = map(int, input().split())

h = list(map(int, input().split()))

p = list(map(int, input().split()))

def min_t(h_i, p_s, p_e):
    return min(abs(h[h_i]-p[p_s]),abs(h[h_i]-p[p_e])) + (p[p_e]-p[p_s])

def check(mx_t):
    h_i = 0
    p_i = 0
    while p_i < m and h_i < n:
        p_j = p_i
        while p_j+1 < m and min_t(h_i, p_i, p_j+1) <= mx_t:
            p_j += 1

        if min_t(h_i, p_i, p_j) <= mx_t:
            p_i = p_j+1

        h_i += 1

    return p_i == m

l = 0
r = 10**11
while l != r:
    mt = (l+r)//2

    if check(mt):
        r = mt
    else:
        l = mt+1

print(l)","def min_time_to_read_tracks(n, m, heads, tracks):

    i, j = 0, 0
    time = 0
    
    while j < m:

        if i < n and heads[i] == tracks[j]:
            j += 1
            continue

        if i >= n:
            time += abs(tracks[j] - heads[-1])

            heads = [tracks[j]] * n
            j += 1
            continue

        while i < n and heads[i] < tracks[j]:
            i += 1

        if i > 0:
            left_head = heads[i-1]
            time += abs(tracks[j] - left_head)
            heads[i-1] = tracks[j]

        if i < n:
            right_head = heads[i]
            time += abs(tracks[j] - right_head)
            heads[i] = tracks[j]

        j += 1
            
    return time

n, m = map(int, input().split())
heads = list(map(int, input().split()))
tracks = list(map(int, input().split()))

result = min_time_to_read_tracks(n, m, heads, tracks)
print(result)"
678,D,Iterated Linear Function,PROGRAMMING,"['math', 'number theory']","Consider a linear function *f*(*x*)<==<=*Ax*<=+<=*B*. Let's define *g*(0)(*x*)<==<=*x* and *g*(*n*)(*x*)<==<=*f*(*g*(*n*<=-<=1)(*x*)) for *n*<=&gt;<=0. For the given integer values *A*, *B*, *n* and *x* find the value of *g*(*n*)(*x*) modulo 109<=+<=7.","The only line contains four integers *A*, *B*, *n* and *x* (1<=≤<=*A*,<=*B*,<=*x*<=≤<=109,<=1<=≤<=*n*<=≤<=1018) — the parameters from the problem statement.

Note that the given value *n* can be too large, so you should use 64-bit integer type to store it. In C++ you can use the long long integer type and in Java you can use long integer type.",Print the only integer *s* — the value *g*(*n*)(*x*) modulo 109<=+<=7.,"['3 4 1 1\n', '3 4 2 1\n', '3 4 3 1\n']","['7\n', '25\n', '79\n']",none,OK,"import sys,math
def power(x, y, p): 
    res = 1;
    x = x % p;  
    while (y > 0):   
        if (y & 1): 
            res = (res * x) % p; 
        y = y >> 1;  
        x = (x * x) % p; 
    return res; 
def modInverse(b,m): 
	g = math.gcd(b, m) 
	if (g != 1):  
		return -1
	else:  
		return pow(b, m - 2, m)  
def modDivide(a,b,m): 
	a = a % m 
	inv = modInverse(b,m) 
	if(inv == -1): 
		print(""Division not defined"") 
	else: 
		return (inv*a) % m    

A,B,n,X=map(int,sys.stdin.readline().split())
m=10**9+7
if A==1:
    print(((n%m)*B+X)%m)
else:
    temp=power(A,n,m)
    s=(temp*(X%m))%m
    s=(s%m+((modDivide(B*(temp-1),A-1,m)%m)%m)%m)%m
    print(s%m)","def f(x, A, B):
    return A * x + B

def g(n, x, A, B):
    if n == 0:
        return x
    else:
        return f(g(n - 1, x, A, B), A, B)

def main():
    import sys
    input = sys.stdin.read
    data = input().strip().split('\n')
    
    MOD = 10**9 + 7
    results = []
    
    for line in data:
        A, B, n, x = map(int, line.split())
        result = g(n, x, A, B) % MOD
        results.append(result)
    
    for res in results:
        print(res)

if __name__ == ""__main__"":
    main()"
424,A,Squats,PROGRAMMING,['implementation'],"Pasha has many hamsters and he makes them work out. Today, *n* hamsters (*n* is even) came to work out. The hamsters lined up and each hamster either sat down or stood up.

For another exercise, Pasha needs exactly  hamsters to stand up and the other hamsters to sit down. In one minute, Pasha can make some hamster ether sit down or stand up. How many minutes will he need to get what he wants if he acts optimally well?","The first line contains integer *n* (2<=≤<=*n*<=≤<=200; *n* is even). The next line contains *n* characters without spaces. These characters describe the hamsters' position: the *i*-th character equals 'X', if the *i*-th hamster in the row is standing, and 'x', if he is sitting.","In the first line, print a single integer — the minimum required number of minutes. In the second line, print a string that describes the hamsters' position after Pasha makes the required changes. If there are multiple optimal positions, print any of them.","['4\nxxXx\n', '2\nXX\n', '6\nxXXxXx\n']","['1\nXxXx\n', '1\nxX\n', '0\nxXXxXx\n']",none,OK,"def main():
    input()
    s = input()
    ta = t = (s.count('x') - s.count('X')) // 2
    res = []
    if t > 0:
        for c in s:
            if t and c == 'x':
                c = 'X'
                t -= 1
            res.append(c)
    else:
        for c in s:
            if t and c == 'X':
                c = 'x'
                t += 1
            res.append(c)
    print(abs(ta))
    print(''.join(res))

if __name__ == '__main__':
    main()","n = int(input().strip())

positions = input().strip()

count_standing = positions.count('X')
count_sitting = n - count_standing

target_standing = n // 2

if count_standing > target_standing:

    minutes = count_standing - target_standing
    new_positions = positions.replace('X', 'x', minutes)
else:

    minutes = count_sitting - target_standing
    new_positions = positions.replace('x', 'X', minutes)

print(minutes)
print(new_positions)"
456,A,Laptops,PROGRAMMING,['sortings'],"One day Dima and Alex had an argument about the price and quality of laptops. Dima thinks that the more expensive a laptop is, the better it is. Alex disagrees. Alex thinks that there are two laptops, such that the price of the first laptop is less (strictly smaller) than the price of the second laptop but the quality of the first laptop is higher (strictly greater) than the quality of the second laptop.

Please, check the guess of Alex. You are given descriptions of *n* laptops. Determine whether two described above laptops exist.","The first line contains an integer *n* (1<=≤<=*n*<=≤<=105) — the number of laptops.

Next *n* lines contain two integers each, *a**i* and *b**i* (1<=≤<=*a**i*,<=*b**i*<=≤<=*n*), where *a**i* is the price of the *i*-th laptop, and *b**i* is the number that represents the quality of the *i*-th laptop (the larger the number is, the higher is the quality).

All *a**i* are distinct. All *b**i* are distinct.","If Alex is correct, print ""Happy Alex"", otherwise print ""Poor Alex"" (without the quotes).",['2\n1 2\n2 1\n'],['Happy Alex\n'],none,OK,"def solve():
    x = int(input())
    l = []
    for i in range(x):
        a, b = map(int, input().split())
        l.append((a, b))
    l.sort(key=lambda p: p[0])
    for i in range(1, x):
        if l[i][1]-l[i-1][1] < 0:
            print('Happy Alex')
            return
    print('Poor Alex')

t = 1
while t:
    solve()
    t -= 1","n = int(input())

laptops = []

for _ in range(n):
    a, b = map(int, input().split())
    laptops.append((a, b))

laptops.sort()

for i in range(1, n):
    if laptops[i][1] < laptops[i - 1][1]:
        print(""Happy Alex"")
        break
else:
    print(""Poor Alex"")"
59,A,Word,PROGRAMMING,"['implementation', 'strings']","Vasya is very upset that many people on the Net mix uppercase and lowercase letters in one word. That's why he decided to invent an extension for his favorite browser that would change the letters' register in every word so that it either only consisted of lowercase letters or, vice versa, only of uppercase ones. At that as little as possible letters should be changed in the word. For example, the word HoUse must be replaced with house, and the word ViP — with VIP. If a word contains an equal number of uppercase and lowercase letters, you should replace all the letters with lowercase ones. For example, maTRIx should be replaced by matrix. Your task is to use the given method on one given word.",The first line contains a word *s* — it consists of uppercase and lowercase Latin letters and possesses the length from 1 to 100.,"Print the corrected word *s*. If the given word *s* has strictly more uppercase letters, make the word written in the uppercase register, otherwise - in the lowercase one.","['HoUse\n', 'ViP\n', 'maTRIx\n']","['house\n', 'VIP\n', 'matrix\n']",none,OK,"""""""""""
def uccf( str ):
    x = 0
    while x < len(str):
        if ('a' <= str[x]) and ('z' >=  str[x]):
            str.replace(str[x], chr(65 + ord(str[x]) - ord('a')))

        x = x+1

def lccF(str):
    str.lower()
    x = 0
    while x < len(str):
        if ('A' <= str[x]) and ('Z' >= str[x]):
            str.replace(str[x],chr(ord('a') + ord(str[x]) - 65))

        x = x + 1""""""

string = input()
""""""""x=ord('a')
print((x))""""""""""

lcc = 0
ucc = 0
for x in string:

    if ('a' <= x) and ('z' >= x):
        lcc = lcc+1
    else:
        ucc = ucc+1

if lcc<ucc:
    print(string.upper())
else:
    print(string.lower())

exit()","def correct_case(word):
    upper_count = sum(1 for char in word if char.isupper())
    lower_count = len(word) - upper_count

    if upper_count > lower_count:
        return word.upper()
    else:
        return word.lower()

input_words = ['HoUse\n', 'ViP\n', 'maTRIx\n']

output_words = [correct_case(word.strip()) + '\n' for word in input_words]

print(output_words)"
822,A,I'm bored with life,PROGRAMMING,"['implementation', 'math', 'number theory']","Holidays have finished. Thanks to the help of the hacker Leha, Noora managed to enter the university of her dreams which is located in a town Pavlopolis. It's well known that universities provide students with dormitory for the period of university studies. Consequently Noora had to leave Vičkopolis and move to Pavlopolis. Thus Leha was left completely alone in a quiet town Vičkopolis. He almost even fell into a depression from boredom!

Leha came up with a task for himself to relax a little. He chooses two integers *A* and *B* and then calculates the greatest common divisor of integers ""*A* factorial"" and ""*B* factorial"". Formally the hacker wants to find out GCD(*A*!,<=*B*!). It's well known that the factorial of an integer *x* is a product of all positive integers less than or equal to *x*. Thus *x*!<==<=1·2·3·...·(*x*<=-<=1)·*x*. For example 4!<==<=1·2·3·4<==<=24. Recall that GCD(*x*,<=*y*) is the largest positive integer *q* that divides (without a remainder) both *x* and *y*.

Leha has learned how to solve this task very effective. You are able to cope with it not worse, aren't you?","The first and single line contains two integers *A* and *B* (1<=≤<=*A*,<=*B*<=≤<=109,<=*min*(*A*,<=*B*)<=≤<=12).",Print a single integer denoting the greatest common divisor of integers *A*! and *B*!.,['4 3\n'],['6\n'],"Consider the sample.

4! = 1·2·3·4 = 24. 3! = 1·2·3 = 6. The greatest common divisor of integers 24 and 6 is exactly 6.",OK,"d = input().split(' ')
A = int(d[0])
B = int(d[1])

def factorial(x):
    if x == 0: 
        return 1
    return x * factorial(x-1)

if A>=B:
    print(factorial(B))
else:
    print(factorial(A))","import math

def factorial(n):
    if n == 0 or n == 1:
        return 1
    return n * factorial(n - 1)

A, B = map(int, input().split())

gcd_result = math.gcd(factorial(A), factorial(B))

print(gcd_result)"
601,A,The Two Routes,PROGRAMMING,"['graphs', 'shortest paths']","In Absurdistan, there are *n* towns (numbered 1 through *n*) and *m* bidirectional railways. There is also an absurdly simple road network — for each pair of different towns *x* and *y*, there is a bidirectional road between towns *x* and *y* if and only if there is no railway between them. Travelling to a different town using one railway or one road always takes exactly one hour.

A train and a bus leave town 1 at the same time. They both have the same destination, town *n*, and don't make any stops on the way (but they can wait in town *n*). The train can move only along railways and the bus can move only along roads.

You've been asked to plan out routes for the vehicles; each route can use any road/railway multiple times. One of the most important aspects to consider is safety — in order to avoid accidents at railway crossings, the train and the bus must not arrive at the same town (except town *n*) simultaneously.

Under these constraints, what is the minimum number of hours needed for both vehicles to reach town *n* (the maximum of arrival times of the bus and the train)? Note, that bus and train are not required to arrive to the town *n* at the same moment of time, but are allowed to do so.","The first line of the input contains two integers *n* and *m* (2<=≤<=*n*<=≤<=400, 0<=≤<=*m*<=≤<=*n*(*n*<=-<=1)<=/<=2) — the number of towns and the number of railways respectively.

Each of the next *m* lines contains two integers *u* and *v*, denoting a railway between towns *u* and *v* (1<=≤<=*u*,<=*v*<=≤<=*n*, *u*<=≠<=*v*).

You may assume that there is at most one railway connecting any two towns.","Output one integer — the smallest possible time of the later vehicle's arrival in town *n*. If it's impossible for at least one of the vehicles to reach town *n*, output <=-<=1.","['4 2\n1 3\n3 4\n', '4 6\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4\n', '5 5\n4 2\n3 5\n4 5\n5 1\n1 2\n']","['2\n', '-1\n', '3\n']","In the first sample, the train can take the route <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/7c0aa60a06309ef607b7159fd7f3687ea0d943ce.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> and the bus can take the route <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/a26c2f3e93c9d9be6c21cb5d2bd6ac1f99f4ff55.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>. Note that they can arrive at town 4 at the same time.

In the second sample, Absurdistan is ruled by railwaymen. There are no roads, so there's no way for the bus to reach town 4.",WRONG_ANSWER,"n, m = map(int, input().split())
b = [[j for j in range(1,n+1) if j != i+1] for i in range(n)]
b.insert(0,[])
t = [[] for i in range(n+1)]

for _ in range(m):
    u, v = map(int, input().split())
    b[u].remove(v)
    b[v].remove(u)
    t[u].append(v)
    t[v].append(u)

def find_shorteset_path(n, start, des, adj):
    queue = [(start,0)]
    visited = [False for i in range(n+1)]
    visited[start] = True
    while queue != []:
        v = queue[0]
        if v[0] == des:
            return v[1]
        for neig in adj[v[0]]:
            if not visited[neig]:
                visited[neig]=True
                queue.append((neig, v[1]+1))
        del queue[0]
        print(queue)
        print(visited)
    return False
print(b)
bus_sol = find_shorteset_path(n, 1, n, b)
print(t)
train_sol = find_shorteset_path(n, 1, n, t)
if train_sol and bus_sol:
    print(max(train_sol, bus_sol))
else:
    print(-1)","from collections import deque

def bfs(graph, start):

    distances = [-1] * (len(graph))
    distances[start] = 0
    queue = deque([start])
    
    while queue:
        current = queue.popleft()
        current_distance = distances[current]
        
        for neighbor in graph[current]:
            if distances[neighbor] == -1:
                distances[neighbor] = current_distance + 1
                queue.append(neighbor)
    
    return distances

def min_time_to_reach(n, m, railways):

    railway_graph = [[] for _ in range(n + 1)]
    for u, v in railways:
        railway_graph[u].append(v)
        railway_graph[v].append(u)

    train_distances = bfs(railway_graph, 1)

    road_graph = [[] for _ in range(n + 1)]
    for i in range(1, n + 1):
        for j in range(i + 1, n + 1):
            if j not in railway_graph[i]:
                road_graph[i].append(j)
                road_graph[j].append(i)

    bus_distances = bfs(road_graph, 1)
    
    train_time = train_distances[n]
    bus_time = bus_distances[n]
    
    if train_time == -1 or bus_time == -1:
        return -1
    
    return max(train_time, bus_time)

inputs = [
    (4, 2, [(1, 3), (3, 4)]),
    (4, 6, [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]),
    (5, 5, [(4, 2), (3, 5), (4, 5), (5, 1), (1, 2)]),
]

outputs = []
for n, m, railways in inputs:
    result = min_time_to_reach(n, m, railways)
    outputs.append(result)

for output in outputs:
    print(output)"
849,B,Tell Your World,PROGRAMMING,"['brute force', 'geometry']","Connect the countless points with lines, till we reach the faraway yonder.

There are *n* points on a coordinate plane, the *i*-th of which being (*i*,<=*y**i*).

Determine whether it's possible to draw two parallel and non-overlapping lines, such that every point in the set lies on exactly one of them, and each of them passes through at least one point in the set.","The first line of input contains a positive integer *n* (3<=≤<=*n*<=≤<=1<=000) — the number of points.

The second line contains *n* space-separated integers *y*1,<=*y*2,<=...,<=*y**n* (<=-<=109<=≤<=*y**i*<=≤<=109) — the vertical coordinates of each point.","Output ""Yes"" (without quotes) if it's possible to fulfill the requirements, and ""No"" otherwise.

You can print each letter in any case (upper or lower).","['5\n7 5 8 6 9\n', '5\n-1 -2 0 0 -5\n', '5\n5 4 3 2 1\n', '5\n1000000000 0 0 0 0\n']","['Yes\n', 'No\n', 'No\n', 'Yes\n']","In the first example, there are five points: (1, 7), (2, 5), (3, 8), (4, 6) and (5, 9). It's possible to draw a line that passes through points 1, 3, 5, and another one that passes through points 2, 4 and is parallel to the first one.

In the second example, while it's possible to draw two lines that cover all points, they cannot be made parallel.

In the third example, it's impossible to satisfy both requirements at the same time.",WRONG_ANSWER,"import sys

def main():
    n = int(input())
    s = list(map(int, sys.stdin.readline().split()))
    p1 = (0, 0)
    for z in range(2):
        for i in range(1, n):
            k = (s[i] - s[0]) / i
            oka = True
            okp = False
            for j in range(1, n):
                if i == j:
                    continue
                c = (s[j] - s[0]) / j
                if c != k:
                    if not okp:
                        p1 = (j, s[j])
                        okp = True
                    else:
                        k2 = (s[j] - p1[1]) / (j - p1[0])
                        if k!=k2:
                            oka = False
                            break

            if oka and okp:
                print(""Yes"")
                return
        s[1],s[0] = s[0],s[1]

    print(""No"")

main()","def can_draw_parallel_lines(n, y):

    def check_lines(slope, y_intercept, points):
        line1 = []
        line2 = []
        
        for x in range(n):
            if len(line1) == 0:
                line1.append((x + 1, points[x]))
            elif (points[x] - y_intercept) == slope * (x + 1):
                line1.append((x + 1, points[x]))
            else:
                line2.append((x + 1, points[x]))

        if len(line2) == 0:
            return True
        
        if len(line1) == 0 or len(line2) == 0:
            return False

        if len(line1) > 1 and len(line2) > 1:
            slope1 = (line1[1][1] - line1[0][1]) / (line1[1][0] - line1[0][0])
            slope2 = (line2[1][1] - line2[0][1]) / (line2[1][0] - line2[0][0])
            return slope1 == slope2

        return True

    for i in range(1, n - 1):

        if check_lines((y[i] - y[0]) / (i + 1 - 1), y[0], y):
            return ""Yes""

    return ""No""

n = int(input())
y = list(map(int, input().split()))

print(can_draw_parallel_lines(n, y))"
327,A,Flipping Game,PROGRAMMING,"['brute force', 'dp', 'implementation']","Iahub got bored, so he invented a game to be played on paper. 

He writes *n* integers *a*1,<=*a*2,<=...,<=*a**n*. Each of those integers can be either 0 or 1. He's allowed to do exactly one move: he chooses two indices *i* and *j* (1<=≤<=*i*<=≤<=*j*<=≤<=*n*) and flips all values *a**k* for which their positions are in range [*i*,<=*j*] (that is *i*<=≤<=*k*<=≤<=*j*). Flip the value of *x* means to apply operation *x*<==<=1 - *x*.

The goal of the game is that after exactly one move to obtain the maximum number of ones. Write a program to solve the little game of Iahub.","The first line of the input contains an integer *n* (1<=≤<=*n*<=≤<=100). In the second line of the input there are *n* integers: *a*1,<=*a*2,<=...,<=*a**n*. It is guaranteed that each of those *n* values is either 0 or 1.",Print an integer — the maximal number of 1s that can be obtained after exactly one move.,"['5\n1 0 0 1 0\n', '4\n1 0 0 1\n']","['4\n', '4\n']","In the first case, flip the segment from 2 to 5 (*i* = 2, *j* = 5). That flip changes the sequence, it becomes: [1 1 1 0 1]. So, it contains four ones. There is no way to make the whole sequence equal to [1 1 1 1 1].

In the second case, flipping only the second and the third element (*i* = 2, *j* = 3) will turn all numbers into 1.",WRONG_ANSWER,"def main():
    n=int(input())
    a=list(map(int,input().split()))
    q,w=0,0
    for i in range(n):
        if a[i]==1:
            q=i+1
            break
    for i in range(n):
        if a[i]==1:
            w=i+1
    print(w-(q-1))
    
main()","def max_ones_after_flip(n, arr):

    initial_ones = sum(arr)
    
    max_ones = 0

    for i in range(n):
        for j in range(i, n):

            ones_in_segment = sum(arr[i:j+1])
            zeros_in_segment = (j - i + 1) - ones_in_segment

            new_ones = initial_ones - ones_in_segment + zeros_in_segment

            max_ones = max(max_ones, new_ones)

    return max_ones

n = int(input())
arr = list(map(int, input().split()))

result = max_ones_after_flip(n, arr)
print(result)"
551,A,GukiZ and Contest,PROGRAMMING,"['brute force', 'implementation', 'sortings']","Professor GukiZ likes programming contests. He especially likes to rate his students on the contests he prepares. Now, he has decided to prepare a new contest. 

In total, *n* students will attend, and before the start, every one of them has some positive integer rating. Students are indexed from 1 to *n*. Let's denote the rating of *i*-th student as *a**i*. After the contest ends, every student will end up with some positive integer position. GukiZ expects that his students will take places according to their ratings. 

He thinks that each student will take place equal to . In particular, if student *A* has rating strictly lower then student *B*, *A* will get the strictly better position than *B*, and if two students have equal ratings, they will share the same position. 

GukiZ would like you to reconstruct the results by following his expectations. Help him and determine the position after the end of the contest for each of his students if everything goes as expected.","The first line contains integer *n* (1<=≤<=*n*<=≤<=2000), number of GukiZ's students. 

The second line contains *n* numbers *a*1,<=*a*2,<=... *a**n* (1<=≤<=*a**i*<=≤<=2000) where *a**i* is the rating of *i*-th student (1<=≤<=*i*<=≤<=*n*).","In a single line, print the position after the end of the contest for each of *n* students in the same order as they appear in the input.","['3\n1 3 3\n', '1\n1\n', '5\n3 5 3 4 5\n']","['3 1 1\n', '1\n', '4 1 4 3 1\n']","In the first sample, students 2 and 3 are positioned first (there is no other student with higher rating), and student 1 is positioned third since there are two students with higher rating.

In the second sample, first student is the only one on the contest.

In the third sample, students 2 and 5 share the first position with highest rating, student 4 is next with third position, and students 1 and 3 are the last sharing fourth position.",RUNTIME_ERROR,"s
INF = 10**20
MOD = 10**9 + 7
from math import gcd
from math import ceil, log2, factorial
from collections import defaultdict as dd, Counter
from bisect import bisect_left as bl, bisect_right as br

def fastio():
  import sys
  from io import StringIO 
  from atexit import register
  global input
  sys.stdin = StringIO(sys.stdin.read())
  input = lambda : sys.stdin.readline().rstrip('\r\n')
  sys.stdout = StringIO()
  register(lambda : sys.__stdout__.write(sys.stdout.getvalue()))
fastio()

I = lambda:list(map(int,input().split()))
TESTS = 0
""""""
Facts and Data representation
Constructive? Top bottom up down
""""""
def solve():
  n, = I()
  a = I()
  a = [[a[i], i] for i in range(n)]

  a.sort(reverse=True)
  ans = [0] * n

  ans[a[0][1]] = 1
  cnt = 0
  for i in range(1, n):
    if (a[i][0] == a[i - 1][0]):
      ans[a[i][1]] = ans[a[i - 1][1]]
      cnt += 1
    else:
      ans[a[i][1]] = ans[a[i - 1][1]] + cnt + 1
      cnt = 0
  print(*ans)

def main():
  if not TESTS:
    solve()
    return

  t, = I()
  while t:
    solve()
    t -= 1

if __name__ == ""__main__"":
  main()","def determine_positions(n, ratings):

    indexed_ratings = [(ratings[i], i) for i in range(n)]

    indexed_ratings.sort(key=lambda x: -x[0])

    positions = [0] * n

    current_position = 1
    
    for i in range(n):
        if i > 0 and indexed_ratings[i][0] == indexed_ratings[i - 1][0]:

            positions[indexed_ratings[i][1]] = positions[indexed_ratings[i - 1][1]]
        else:

            positions[indexed_ratings[i][1]] = current_position

        current_position += 1
    
    return positions

n = int(input())
ratings = list(map(int, input().split()))

result_positions = determine_positions(n, ratings)

print(' '.join(map(str, result_positions)))"
142,A,Help Farmer,PROGRAMMING,"['brute force', 'math']","Once upon a time in the Kingdom of Far Far Away lived Sam the Farmer. Sam had a cow named Dawn and he was deeply attached to her. Sam would spend the whole summer stocking hay to feed Dawn in winter. Sam scythed hay and put it into haystack. As Sam was a bright farmer, he tried to make the process of storing hay simpler and more convenient to use. He collected the hay into cubical hay blocks of the same size. Then he stored the blocks in his barn. After a summer spent in hard toil Sam stored *A*·*B*·*C* hay blocks and stored them in a barn as a rectangular parallelepiped *A* layers high. Each layer had *B* rows and each row had *C* blocks.

At the end of the autumn Sam came into the barn to admire one more time the hay he'd been stacking during this hard summer. Unfortunately, Sam was horrified to see that the hay blocks had been carelessly scattered around the barn. The place was a complete mess. As it turned out, thieves had sneaked into the barn. They completely dissembled and took away a layer of blocks from the parallelepiped's front, back, top and sides. As a result, the barn only had a parallelepiped containing (*A*<=-<=1)<=×<=(*B*<=-<=2)<=×<=(*C*<=-<=2) hay blocks. To hide the evidence of the crime, the thieves had dissembled the parallelepiped into single 1<=×<=1<=×<=1 blocks and scattered them around the barn. After the theft Sam counted *n* hay blocks in the barn but he forgot numbers *A*, *B* и *C*.

Given number *n*, find the minimally possible and maximally possible number of stolen hay blocks.",The only line contains integer *n* from the problem's statement (1<=≤<=*n*<=≤<=109).,"Print space-separated minimum and maximum number of hay blocks that could have been stolen by the thieves.

Note that the answer to the problem can be large enough, so you must use the 64-bit integer type for calculations. Please, do not use the %lld specificator to read or write 64-bit integers in С++. It is preferred to use cin, cout streams or the %I64d specificator.","['4\n', '7\n', '12\n']","['28 41\n', '47 65\n', '48 105\n']","Let's consider the first sample test. If initially Sam has a parallelepiped consisting of 32 = 2 × 4 × 4 hay blocks in his barn, then after the theft the barn has 4 = (2 - 1) × (4 - 2) × (4 - 2) hay blocks left. Thus, the thieves could have stolen 32 - 4 = 28 hay blocks. If Sam initially had a parallelepiped consisting of 45 = 5 × 3 × 3 hay blocks in his barn, then after the theft the barn has 4 = (5 - 1) × (3 - 2) × (3 - 2) hay blocks left. Thus, the thieves could have stolen 45 - 4 = 41 hay blocks. No other variants of the blocks' initial arrangement (that leave Sam with exactly 4 blocks after the theft) can permit the thieves to steal less than 28 or more than 41 blocks.",TIME_LIMIT_EXCEEDED,"def int_sqrt(n):
    return int(n**(1/2))

def min_sum(prod):
    ms = prod + 1
    for i in range(1, int_sqrt(prod) + 1):
        if prod % i == 0:
            s = i + prod/i
            if ms > s:
                ms = s
    return ms

def main():
    n = int(input())
    minp = 9*n+9
    maxp = 1
    for x in range(1, n+1):
        if n % x != 0:
            continue
        else:

            yz_prod = n/x

            ms = min_sum(yz_prod)
            mi_p = (yz_prod + 2*ms + 4)*(x + 1)

            ma_p = (yz_prod + 2*(yz_prod + 1) + 4)*(x + 1)

            if (mi_p < minp):
                minp = mi_p
            if (ma_p > maxp):
                maxp = ma_p
    print(str(int(minp - n)) + ' ' + str(int(maxp - n)))

if __name__ == '__main__':
    main()","def find_stolen_blocks(n):

    min_stolen = float('inf')
    max_stolen = float('-inf')

    for A in range(1, n + 1):

        for B in range(2, n // A + 1):
            C = n // (A * B)
            if C >= 2:
                remaining_blocks = (A - 1) * (B - 2) * (C - 2)
                if remaining_blocks == n:
                    total_blocks = A * B * C
                    min_stolen = min(min_stolen, total_blocks - n)
                    max_stolen = max(max_stolen, total_blocks - n)

    return min_stolen, max_stolen

import sys
input_data = sys.stdin.read().strip().split()

results = []
for line in input_data:
    n = int(line)
    min_stolen, max_stolen = find_stolen_blocks(n)
    results.append(f""{min_stolen} {max_stolen}"")

print(""\n"".join(results))"
551,C,GukiZ hates Boxes,PROGRAMMING,"['binary search', 'greedy']","Professor GukiZ is concerned about making his way to school, because massive piles of boxes are blocking his way. 

In total there are *n* piles of boxes, arranged in a line, from left to right, *i*-th pile (1<=≤<=*i*<=≤<=*n*) containing *a**i* boxes. Luckily, *m* students are willing to help GukiZ by removing all the boxes from his way. Students are working simultaneously. At time 0, all students are located left of the first pile. It takes one second for every student to move from this position to the first pile, and after that, every student must start performing sequence of two possible operations, each taking one second to complete. Possible operations are:
1.  If *i*<=≠<=*n*, move from pile *i* to pile *i*<=+<=1;1.  If pile located at the position of student is not empty, remove one box from it.
GukiZ's students aren't smart at all, so they need you to tell them how to remove boxes before professor comes (he is very impatient man, and doesn't want to wait). They ask you to calculate minumum time *t* in seconds for which they can remove all the boxes from GukiZ's way. Note that students can be positioned in any manner after *t* seconds, but all the boxes must be removed.","The first line contains two integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=105), the number of piles of boxes and the number of GukiZ's students. 

The second line contains *n* integers *a*1,<=*a*2,<=... *a**n* (0<=≤<=*a**i*<=≤<=109) where *a**i* represents the number of boxes on *i*-th pile. It's guaranteed that at least one pile of is non-empty.","In a single line, print one number, minimum time needed to remove all the boxes in seconds.","['2 1\n1 1\n', '3 2\n1 0 2\n', '4 100\n3 4 5 4\n']","['4\n', '5\n', '5\n']","First sample: Student will first move to the first pile (1 second), then remove box from first pile (1 second), then move to the second pile (1 second) and finally remove the box from second pile (1 second).

Second sample: One of optimal solutions is to send one student to remove a box from the first pile and a box from the third pile, and send another student to remove a box from the third pile. Overall, 5 seconds.

Third sample: With a lot of available students, send three of them to remove boxes from the first pile, four of them to remove boxes from the second pile, five of them to remove boxes from the third pile, and four of them to remove boxes from the fourth pile. Process will be over in 5 seconds, when removing the boxes from the last pile is finished.",WRONG_ANSWER,"n,m = map(int, input().split())
A = list(map(int, input().split()))

lo, hi = 1, 10**15
def check(maxt):
    st, b = 0, A[0]
    for i in range(m):
        t = maxt-1-st
        while t > 0:
            rem = min(b, t)
            b, t = b-rem, t-rem
            if b == 0:
                st += 1
                if st == n: return True
                b, t = A[st], t-1
    return False

while lo+1 < hi:
    mid = (lo+hi) // 2
    if check(mid): hi = mid
    else: lo = mid
print(hi)","def min_time_to_clear_boxes(n, m, boxes):

    total_boxes = sum(boxes)

    time_needed = 0
    while total_boxes > 0:
        time_needed += 1

        can_remove = min(m * time_needed, total_boxes)
        total_boxes -= can_remove

    return time_needed + n

if __name__ == ""__main__"":
    import sys
    input_data = sys.stdin.read().strip().split('\n')
    first_line = list(map(int, input_data[0].split()))
    n = first_line[0]
    m = first_line[1]
    boxes = list(map(int, input_data[1].split()))

    result = min_time_to_clear_boxes(n, m, boxes)
    print(result)"
664,A,Complicated GCD,PROGRAMMING,"['math', 'number theory']","Greatest common divisor *GCD*(*a*,<=*b*) of two positive integers *a* and *b* is equal to the biggest integer *d* such that both integers *a* and *b* are divisible by *d*. There are many efficient algorithms to find greatest common divisor *GCD*(*a*,<=*b*), for example, Euclid algorithm. 

Formally, find the biggest integer *d*, such that all integers *a*,<=*a*<=+<=1,<=*a*<=+<=2,<=...,<=*b* are divisible by *d*. To make the problem even more complicated we allow *a* and *b* to be up to googol, 10100 — such number do not fit even in 64-bit integer type!",The only line of the input contains two integers *a* and *b* (1<=≤<=*a*<=≤<=*b*<=≤<=10100).,Output one integer — greatest common divisor of all integers from *a* to *b* inclusive.,"['1 2\n', '61803398874989484820458683436563811772030917980576 61803398874989484820458683436563811772030917980576\n']","['1\n', '61803398874989484820458683436563811772030917980576\n']",none,WRONG_ANSWER,"num1, num2 = map(int, input().split())

def dfs(num1, num2):
    if not num2:
        return num1
    return dfs(num2, num1 % num2)        

print(dfs(num1, num2))","def gcd_of_range(a, b):

    if a == b:
        return a
    else:

        return 1

input_data = input().strip()
a, b = map(int, input_data.split())

result = gcd_of_range(a, b)

print(result)"
1000,C,Covered Points Count,PROGRAMMING,"['data structures', 'implementation', 'sortings']","You are given $n$ segments on a coordinate line; each endpoint of every segment has integer coordinates. Some segments can degenerate to points. Segments can intersect with each other, be nested in each other or even coincide.

Your task is the following: for every $k \in [1..n]$, calculate the number of points with integer coordinates such that the number of segments that cover these points equals $k$. A segment with endpoints $l_i$ and $r_i$ covers point $x$ if and only if $l_i \le x \le r_i$.","The first line of the input contains one integer $n$ ($1 \le n \le 2 \cdot 10^5$) — the number of segments.

The next $n$ lines contain segments. The $i$-th line contains a pair of integers $l_i, r_i$ ($0 \le l_i \le r_i \le 10^{18}$) — the endpoints of the $i$-th segment.","Print $n$ space separated integers $cnt_1, cnt_2, \dots, cnt_n$, where $cnt_i$ is equal to the number of points such that the number of segments that cover these points equals to $i$.","['3\n0 3\n1 3\n3 8\n', '3\n1 3\n2 4\n5 7\n']","['6 2 1 \n', '5 2 0 \n']","The picture describing the first example:

<img class=""tex-graphics"" src=""https://espresso.codeforces.com/f76b3fe547bff6be5b14de76c8b78ba3efecc744.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

Points with coordinates $[0, 4, 5, 6, 7, 8]$ are covered by one segment, points $[1, 2]$ are covered by two segments and point $[3]$ is covered by three segments.

The picture describing the second example:

<img class=""tex-graphics"" src=""https://espresso.codeforces.com/6e9332c303e1bc5d6cf34c2d6c5e2a19c9417289.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

Points $[1, 4, 5, 6, 7]$ are covered by one segment, points $[2, 3]$ are covered by two segments and there are no points covered by three segments.",TIME_LIMIT_EXCEEDED,"def fff():
    k = []
    inp = int(input())
    for x in range(inp):
        k.append(list(map(int,input().split())))
    j = [-1 for x in range(max(k[-1])+1)]
    for x in k:
        for y in range(x[0],x[1]+1):
            j[y] += 1
    t = [0 for x in range(inp)]
    for x in j:
        if x != -1:
            t[x] += 1
    print(' '.join(list(map(str,t))))

fff()","def count_covered_points(segments):
    events = []

    for l, r in segments:
        events.append((l, 1))
        events.append((r + 1, -1))

    events.sort()

    current_coverage = 0
    prev_position = -1
    counts = [0] * (len(segments) + 1)

    for position, event_type in events:
        if prev_position != -1 and current_coverage > 0:

            counts[current_coverage] += position - prev_position

        current_coverage += event_type

        prev_position = position

    return counts[1:]

import sys

input = sys.stdin.read
data = input().strip().split('\n')

n = int(data[0])
segments = [tuple(map(int, line.split())) for line in data[1:n + 1]]

result = count_covered_points(segments)

print("" "".join(map(str, result)))"
766,A,Mahmoud and Longest Uncommon Subsequence,PROGRAMMING,"['constructive algorithms', 'strings']","While Mahmoud and Ehab were practicing for IOI, they found a problem which name was Longest common subsequence. They solved it, and then Ehab challenged Mahmoud with another problem.

Given two strings *a* and *b*, find the length of their longest uncommon subsequence, which is the longest string that is a subsequence of one of them and not a subsequence of the other.

A subsequence of some string is a sequence of characters that appears in the same order in the string, The appearances don't have to be consecutive, for example, strings ""ac"", ""bc"", ""abc"" and ""a"" are subsequences of string ""abc"" while strings ""abbc"" and ""acb"" are not. The empty string is a subsequence of any string. Any string is a subsequence of itself.","The first line contains string *a*, and the second line — string *b*. Both of these strings are non-empty and consist of lowercase letters of English alphabet. The length of each string is not bigger than 105 characters.","If there's no uncommon subsequence, print ""-1"". Otherwise print the length of the longest uncommon subsequence of *a* and *b*.","['abcd\ndefgh\n', 'a\na\n']","['5\n', '-1\n']","In the first example: you can choose ""defgh"" from string *b* as it is the longest subsequence of string *b* that doesn't appear as a subsequence of string *a*.",OK,"def solve():
    a = input()
    b = input()
    print(-1 if a == b else max(len(a), len(b)))
    
t = 1
for i in range(t):

	solve()","a = input().strip()
b = input().strip()

if a == b:
    print(-1)
else:

    print(max(len(a), len(b)))"
618,A,Slime Combining,PROGRAMMING,['implementation'],"Your friend recently gave you some slimes for your birthday. You have *n* slimes all initially with value 1.

You are going to play a game with these slimes. Initially, you put a single slime by itself in a row. Then, you will add the other *n*<=-<=1 slimes one by one. When you add a slime, you place it at the right of all already placed slimes. Then, while the last two slimes in the row have the same value *v*, you combine them together to create a slime with value *v*<=+<=1.

You would like to see what the final state of the row is after you've added all *n* slimes. Please print the values of the slimes in the row from left to right.","The first line of the input will contain a single integer, *n* (1<=≤<=*n*<=≤<=100<=000).","Output a single line with *k* integers, where *k* is the number of slimes in the row after you've finished the procedure described in the problem statement. The *i*-th of these numbers should be the value of the *i*-th slime from the left.","['1\n', '2\n', '3\n', '8\n']","['1\n', '2\n', '2 1\n', '4\n']","In the first sample, we only have a single slime with value 1. The final state of the board is just a single slime with value 1.

In the second sample, we perform the following steps:

Initially we place a single slime in a row by itself. Thus, row is initially 1.

Then, we will add another slime. The row is now 1 1. Since two rightmost slimes have the same values, we should replace these slimes with one with value 2. Thus, the final state of the board is 2.

In the third sample, after adding the first two slimes, our row is 2. After adding one more slime, the row becomes 2 1.

In the last sample, the steps look as follows: 
 1.  1 1.  2 1.  2 1 1.  3 1.  3 1 1.  3 2 1.  3 2 1 1.  4",WRONG_ANSWER,"import math
def Log2(x):
	return (math.log10(x) /
			math.log10(2))
def isPowerOfTwo(n):
	return (math.ceil(Log2(n)) == math.floor(Log2(n)))
l = []
temp = []
n = int(input())
if isPowerOfTwo(n) :
    x = Log2(n)
    print(x+1)
else :
    for i in range(n) :
        '''if len(l) > 1 and l[-1] == l[-2] :
            l[-2] += 1
            l.pop()
            print(""Begin : "",l)
        print(""Mid : "",l)
        if i==0 :
            l.append(1)
            cntr += 1
        else :
            if l[-1] == cntr :
                l[-1] += cntr
            else :
                l.append(1)
                cntr = 1
        if len(l) > 1 and l[-1] == l[-2] :
            l[-2] += 1
            l.pop()
            print(""End : "" ,l)'''
        l.append(1)
    if 2**math.ceil(Log2(n)) - 1 == n :
        temp = [i for i in range(1,math.ceil(Log2(n))+1)]
    else :
        if len(l)%2 != 0 :
            temp.append(1)
        temp.append(math.ceil(Log2(n)))
    print(temp)","def final_slime_state(n):
    slimes = [1]
    
    for _ in range(n - 1):
        slimes.append(1)

        while len(slimes) > 1 and slimes[-1] == slimes[-2]:
            v = slimes.pop()
            slimes[-1] += v

    print(' '.join(map(str, slimes)))

if __name__ == ""__main__"":
    import sys
    input = sys.stdin.read

    data = input().strip().split('\n')

    for line in data:
        n = int(line)
        final_slime_state(n)"
276,B,Little Girl and Game,PROGRAMMING,"['games', 'greedy']","The Little Girl loves problems on games very much. Here's one of them.

Two players have got a string *s*, consisting of lowercase English letters. They play a game that is described by the following rules:
 -  The players move in turns; In one move the player can remove an arbitrary letter from string *s*. -  If the player before his turn can reorder the letters in string *s* so as to get a palindrome, this player wins. A palindrome is a string that reads the same both ways (from left to right, and vice versa). For example, string ""abba"" is a palindrome and string ""abc"" isn't. 
Determine which player will win, provided that both sides play optimally well — the one who moves first or the one who moves second.","The input contains a single line, containing string *s* (1<=≤<=|*s*|<=<=≤<=<=103). String *s* consists of lowercase English letters.","In a single line print word ""First"" if the first player wins (provided that both players play optimally well). Otherwise, print word ""Second"". Print the words without the quotes.","['aba\n', 'abca\n']","['First\n', 'Second\n']",none,WRONG_ANSWER,"import random
def isPalin(string):
    return True if string==string[::-1] else False
stri = list(input().strip())
flag=0
count=0
while True:
    s = """"
    for ele in stri:
        s+=ele
    if(isPalin(s)):
        break
    elif(len(stri)==1):
        break
    else:
        stri.pop(random.randint(0,len(stri)-1))
        flag = count+1%2
if(flag==0):
    print(""First"")
elif(flag==1):
    print(""Second"")","def can_form_palindrome(s):

    char_count = {}
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1

    odd_count = sum(1 for count in char_count.values() if count % 2 != 0)

    return odd_count <= 1

def game_winner(s):

    if can_form_palindrome(s):
        return ""First""
    else:
        return ""Second""

if __name__ == ""__main__"":
    import sys

    input_strings = sys.stdin.read().splitlines()
    results = []

    for s in input_strings:
        results.append(game_winner(s.strip()))

    print('\n'.join(results))"
508,A,Pasha and Pixels,PROGRAMMING,['brute force'],"Pasha loves his phone and also putting his hair up... But the hair is now irrelevant.

Pasha has installed a new game to his phone. The goal of the game is following. There is a rectangular field consisting of *n* row with *m* pixels in each row. Initially, all the pixels are colored white. In one move, Pasha can choose any pixel and color it black. In particular, he can choose the pixel that is already black, then after the boy's move the pixel does not change, that is, it remains black. Pasha loses the game when a 2<=×<=2 square consisting of black pixels is formed. 

Pasha has made a plan of *k* moves, according to which he will paint pixels. Each turn in his plan is represented as a pair of numbers *i* and *j*, denoting respectively the row and the column of the pixel to be colored on the current move.

Determine whether Pasha loses if he acts in accordance with his plan, and if he does, on what move the 2<=×<=2 square consisting of black pixels is formed.","The first line of the input contains three integers *n*,<=*m*,<=*k* (1<=≤<=*n*,<=*m*<=≤<=1000, 1<=≤<=*k*<=≤<=105) — the number of rows, the number of columns and the number of moves that Pasha is going to perform. 

The next *k* lines contain Pasha's moves in the order he makes them. Each line contains two integers *i* and *j* (1<=≤<=*i*<=≤<=*n*, 1<=≤<=*j*<=≤<=*m*), representing the row number and column number of the pixel that was painted during a move.","If Pasha loses, print the number of the move when the 2<=×<=2 square consisting of black pixels is formed.

If Pasha doesn't lose, that is, no 2<=×<=2 square consisting of black pixels is formed during the given *k* moves, print 0.","['2 2 4\n1 1\n1 2\n2 1\n2 2\n', '2 3 6\n2 3\n2 2\n1 3\n2 2\n1 2\n1 1\n', '5 3 7\n2 3\n1 2\n1 1\n4 1\n3 1\n5 3\n3 2\n']","['4\n', '5\n', '0\n']",none,RUNTIME_ERROR,"""""""
Created on Thu Dec 15 10:26:22 2022

@author: thinkpad
""""""

n,m,k = map(int,input().split())

res = [[0 for _ in range(m+2)] for _  in range(n+2)]
dir1 = [[-1,-1],[-1,0],[0,-1]]
dir2 = [[-1,0],[-1,1],[0,1]]
dir3 = [[0,-1],[1,-1],[1,0]]
dir4 = [[0,1],[1,1],[1,0]]

def check(i,j):
    al1 = 0
    for d in dir1:
        x,y = d[0],d[1]
        if res[i+x][j+y]==1:
            al1+=1
    if al1 == 3:
        return False
    al2 = 0
    for d in dir2:
        x,y = d[0],d[1]
        if res[i+x][j+y]==1:
            al2+=1
    if al2 == 3:
        return False        
    al3 = 0
    for d in dir3:
        x,y = d[0],d[1]
        if res[i+x][j+y]==1:
            al3+=1
    if al3 == 3:
        return False        
    al4 = 0
    for d in dir4:
        x,y = d[0],d[1]
        if res[i+x][j+y]==1:
            al4+=1
    if al4 == 3:
        return False
    return True
paint = []
for _ in range(k):
    paint.append(map(int,input().split()))
flag = True
for t in range(k):
    i,j =paint[t][0],paint[t][1]
    res[i][j]=1
    if check(i,j)==False:
        print(t+1)
        flag = False
    else:
        continue

if flag == True:
    print(0)","def pasha_game(n, m, k, moves):
    grid = [[0] * m for _ in range(n)]
    
    for step in range(k):
        i, j = moves[step]
        grid[i - 1][j - 1] = 1

        if (i > 1 and j > 1 and 
            grid[i - 2][j - 2] == 1 and 
            grid[i - 2][j - 1] == 1 and 
            grid[i - 1][j - 2] == 1 and 
            grid[i - 1][j - 1] == 1):
            return step + 1
        
    return 0

if __name__ == ""__main__"":
    import sys
    input_data = sys.stdin.read().strip().splitlines()
    
    results = []
    idx = 0
    while idx < len(input_data):
        n, m, k = map(int, input_data[idx].split())
        moves = [tuple(map(int, input_data[i].split())) for i in range(idx + 1, idx + k + 1)]
        result = pasha_game(n, m, k, moves)
        results.append(result)
        idx += k + 1
    
    for res in results:
        print(res)"
348,A,Mafia,PROGRAMMING,"['binary search', 'math', 'sortings']","One day *n* friends gathered together to play ""Mafia"". During each round of the game some player must be the supervisor and other *n*<=-<=1 people take part in the game. For each person we know in how many rounds he wants to be a player, not the supervisor: the *i*-th person wants to play *a**i* rounds. What is the minimum number of rounds of the ""Mafia"" game they need to play to let each person play at least as many rounds as they want?","The first line contains integer *n* (3<=≤<=*n*<=≤<=105). The second line contains *n* space-separated integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=109) — the *i*-th number in the list is the number of rounds the *i*-th person wants to play.","In a single line print a single integer — the minimum number of game rounds the friends need to let the *i*-th person play at least *a**i* rounds.

Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.","['3\n3 2 2\n', '4\n2 2 2 2\n']","['4\n', '3\n']","You don't need to know the rules of ""Mafia"" to solve this problem. If you're curious, it's a game Russia got from the Soviet times: http://en.wikipedia.org/wiki/Mafia_(party_game).",OK,"from cmath import inf
import math
import sys
from os import path

from functools import reduce
import collections
import sys
 
if (path.exists('CP/input.txt')):
    sys.stdout = open('CP/output.txt', 'w')
    sys.stdin = open('CP/input.txt', 'r')
    
 
 
def ok(mid,arr,maxi):
    d = 0
    for x in arr:
        d += (mid - x)

    if(d>=mid):
        return True
 
    return False
        
    
                         
def answer():
    n = int(input())
    arr  = list(map(int,input().split()))
    
    l,r = 0,(2**31 - 1)
    for x in arr:
        l = max(l,x)
    maxi = l
    
    ans=-1
    
    while(l<=r):

        mid = (l+r)//2

        if(ok(mid,arr,maxi)):
            ans = mid
            r=mid-1
        else:
            l=mid+1
    
    print(ans)

t=1
for _ in range(t):
	answer()","def minimum_rounds(n, a):
    total_rounds = sum(a)

    min_rounds = (total_rounds + (n - 2)) // (n - 1)
    return max(min_rounds, max(a))

n = int(input())
a = list(map(int, input().split()))

print(minimum_rounds(n, a))"
472,A,Design Tutorial: Learn from Math,PROGRAMMING,"['math', 'number theory']","One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.

For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.

You are given an integer *n* no less than 12, express it as a sum of two composite numbers.",The only line contains an integer *n* (12<=≤<=*n*<=≤<=106).,"Output two composite integers *x* and *y* (1<=&lt;<=*x*,<=*y*<=&lt;<=*n*) such that *x*<=+<=*y*<==<=*n*. If there are multiple solutions, you can output any of them.","['12\n', '15\n', '23\n', '1000000\n']","['4 8\n', '6 9\n', '8 15\n', '500000 500000\n']","In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output ""6 6"" or ""8 4"" as well.

In the second example, 15 = 6 + 9. Note that you can't output ""1 14"" because 1 is not a composite number.",TIME_LIMIT_EXCEEDED,"def isPrime(n):
    a=True
    k=2
    while k*k<=n:
        if n%k==0:
            a=False
            break
    return a

n=int(input())
for i in range(4,n//2+1):
    if not isPrime(i) and not isPrime(n-i):
        print(i,n-i)","def is_composite(num):

    if num < 4:
        return False
    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            return True
    return False

def find_composite_sum(n):

    for x in range(4, n//2 + 1):
        y = n - x
        if is_composite(x) and is_composite(y):
            return x, y
    return None

inputs = ['12', '15', '23', '1000000']

outputs = []
for inp in inputs:
    n = int(inp)
    result = find_composite_sum(n)
    if result:
        outputs.append(f""{result[0]} {result[1]}\n"")

print(''.join(outputs))"
554,B,Ohana Cleans Up,PROGRAMMING,"['brute force', 'greedy', 'strings']","Ohana Matsumae is trying to clean a room, which is divided up into an *n* by *n* grid of squares. Each square is initially either clean or dirty. Ohana can sweep her broom over columns of the grid. Her broom is very strange: if she sweeps over a clean square, it will become dirty, and if she sweeps over a dirty square, it will become clean. She wants to sweep some columns of the room to maximize the number of rows that are completely clean. It is not allowed to sweep over the part of the column, Ohana can only sweep the whole column.

Return the maximum number of rows that she can make completely clean.","The first line of input will be a single integer *n* (1<=≤<=*n*<=≤<=100).

The next *n* lines will describe the state of the room. The *i*-th line will contain a binary string with *n* characters denoting the state of the *i*-th row of the room. The *j*-th character on this line is '1' if the *j*-th square in the *i*-th row is clean, and '0' if it is dirty.",The output should be a single line containing an integer equal to a maximum possible number of rows that are completely clean.,"['4\n0101\n1000\n1111\n0101\n', '3\n111\n111\n111\n']","['2\n', '3\n']","In the first sample, Ohana can sweep the 1st and 3rd columns. This will make the 1st and 4th row be completely clean.

In the second sample, everything is already clean, so Ohana doesn't need to do anything.",OK,"from collections import defaultdict

n = int(input())
ans = 0
rows = defaultdict()

for _ in range(n):

    row = str(input())

    if row in rows:
        rows[row] += 1
    else:
        rows[row] = 1

    curr = rows[row]
    
    if curr > ans:
        ans = curr

print(ans)","def max_clean_rows(n, grid):

    unique_rows = set()

    for row in grid:

        pattern = tuple(char == '1' for char in row)
        unique_rows.add(pattern)

    return len(unique_rows)

if __name__ == ""__main__"":
    import sys
    
    input_data = sys.stdin.read().strip().splitlines()
    n = int(input_data[0])
    grid = input_data[1:n + 1]

    result = max_clean_rows(n, grid)

    print(result)"
252,A,Little Xor,PROGRAMMING,"['brute force', 'implementation']","Little Petya likes arrays that consist of non-negative integers a lot. Recently his mom has presented him one such array consisting of *n* elements. Petya immediately decided to find there a segment of consecutive elements, such that the *xor* of all numbers from this segment was maximal possible. Help him with that.

The *xor* operation is the bitwise exclusive ""OR"", that is denoted as ""xor"" in Pascal and ""^"" in C/C++/Java.",The first line contains integer *n* (1<=≤<=*n*<=≤<=100) — the number of elements in the array. The second line contains the space-separated integers from the array. All numbers are non-negative integers strictly less than 230.,Print a single integer — the required maximal *xor* of a segment of consecutive elements.,"['5\n1 2 1 1 2\n', '3\n1 2 7\n', '4\n4 2 4 8\n']","['3\n', '7\n', '14\n']","In the first sample one of the optimal segments is the segment that consists of the first and the second array elements, if we consider the array elements indexed starting from one.

The second sample contains only one optimal segment, which contains exactly one array element (element with index three).",WRONG_ANSWER,"import bisect
import heapq
import math
import collections
import sys
import copy
from functools import reduce
import decimal
from io import BytesIO, IOBase
import os

sys.setrecursionlimit(10 ** 9)
decimal.getcontext().rounding = decimal.ROUND_HALF_UP

graphDict = collections.defaultdict
queue = collections.deque

class Graphs:
    def __init__(self):
        self.graph = graphDict(list)

    def add_edge(self, u, v):
        self.graph[u].append(v)

    def dfs_utility(self, nodes, visited_nodes):
        visited_nodes.add(nodes)
        for neighbour in self.graph[nodes]:
            if neighbour not in visited_nodes:
                self.dfs_utility(neighbour, visited_nodes)
            else:
                return neighbour

    def dfs(self, node):
        Visited = set()
        self.dfs_utility(node, Visited)

    def bfs(self, node):
        visited = set()
        if node not in visited:
            queue.append(node)
            visited.add(node)
        while queue:
            parent = queue.popleft()
            print(parent)
            for item in self.graph[parent]:
                if item not in visited:
                    queue.append(item)
                    visited.add(item)

def rounding(n):
    return int(decimal.Decimal(f'{n}').to_integral_value())

def factors(n):
    return set(reduce(list.__add__,
                      ([i, n // i] for i in range(1, int(n ** 0.5) + 1) if n % i == 0)))

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)

def inp():
    return sys.stdin.readline().strip()

def map_inp(v_type):
    return map(v_type, inp().split())

def list_inp(v_type):
    return list(map_inp(v_type))

n = int(inp())
arr = list_inp(int)
ans = 0
for i in range(n):
    ans = max(arr[i],ans)
    for j in range(i + 1, n):
        ans = max(ans ^ arr[j], ans)
print(ans)","def maximal_xor_segment(arr):
    max_xor = 0
    n = len(arr)

    for i in range(n):
        current_xor = 0
        for j in range(i, n):
            current_xor ^= arr[j]
            max_xor = max(max_xor, current_xor)

    return max_xor

n = int(input())
array = list(map(int, input().split()))

print(maximal_xor_segment(array))"
281,A,Word Capitalization,PROGRAMMING,"['implementation', 'strings']","Capitalization is writing a word with its first letter as a capital letter. Your task is to capitalize the given word.

Note, that during capitalization all the letters except the first one remains unchanged.",A single line contains a non-empty word. This word consists of lowercase and uppercase English letters. The length of the word will not exceed 103.,Output the given word after capitalization.,"['ApPLe\n', 'konjac\n']","['ApPLe\n', 'Konjac\n']",none,OK,"def solve(word):
    return word[0].upper() + word[1:]
    

def main():
    word = input().strip()
    print(solve(word))

if __name__ == ""__main__"":
    main()","def capitalize_first_letter(word):

    return word[0].upper() + word[1:]

input_words = ['ApPLe\n', 'konjac\n']

output_words = []
for word in input_words:

    capitalized_word = capitalize_first_letter(word.strip())
    output_words.append(capitalized_word)

for word in output_words:
    print(word)"
59,A,Word,PROGRAMMING,"['implementation', 'strings']","Vasya is very upset that many people on the Net mix uppercase and lowercase letters in one word. That's why he decided to invent an extension for his favorite browser that would change the letters' register in every word so that it either only consisted of lowercase letters or, vice versa, only of uppercase ones. At that as little as possible letters should be changed in the word. For example, the word HoUse must be replaced with house, and the word ViP — with VIP. If a word contains an equal number of uppercase and lowercase letters, you should replace all the letters with lowercase ones. For example, maTRIx should be replaced by matrix. Your task is to use the given method on one given word.",The first line contains a word *s* — it consists of uppercase and lowercase Latin letters and possesses the length from 1 to 100.,"Print the corrected word *s*. If the given word *s* has strictly more uppercase letters, make the word written in the uppercase register, otherwise - in the lowercase one.","['HoUse\n', 'ViP\n', 'maTRIx\n']","['house\n', 'VIP\n', 'matrix\n']",none,WRONG_ANSWER,"def convert_word(word):
    uppercase_count = sum(1 for letter in word if letter.isupper())
    lowercase_count = len(word) - uppercase_count
    
    if uppercase_count > lowercase_count:
        return word.upper()
    else:
        return word.lower()

input_word = ""HoUse""
converted_word = convert_word(input_word)
print(converted_word)","def correct_word(word):

    uppercase_count = sum(1 for char in word if char.isupper())
    lowercase_count = len(word) - uppercase_count

    if uppercase_count > lowercase_count:
        return word.upper()
    else:
        return word.lower()

input_word = input().strip()

output_word = correct_word(input_word)
print(output_word)"
455,A,Boredom,PROGRAMMING,['dp'],"Alex doesn't like boredom. That's why whenever he gets bored, he comes up with games. One long winter evening he came up with a game and decided to play it.

Given a sequence *a* consisting of *n* integers. The player can make several steps. In a single step he can choose an element of the sequence (let's denote it *a**k*) and delete it, at that all elements equal to *a**k*<=+<=1 and *a**k*<=-<=1 also must be deleted from the sequence. That step brings *a**k* points to the player. 

Alex is a perfectionist, so he decided to get as many points as possible. Help him.","The first line contains integer *n* (1<=≤<=*n*<=≤<=105) that shows how many numbers are in Alex's sequence. 

The second line contains *n* integers *a*1, *a*2, ..., *a**n* (1<=≤<=*a**i*<=≤<=105).",Print a single integer — the maximum number of points that Alex can earn.,"['2\n1 2\n', '3\n1 2 3\n', '9\n1 2 1 3 2 2 2 2 3\n']","['2\n', '4\n', '10\n']","Consider the third test example. At first step we need to choose any element equal to 2. After that step our sequence looks like this [2, 2, 2, 2]. Then we do 4 steps, on each step we choose any element equals to 2. In total we earn 10 points.",WRONG_ANSWER,"def mode(a):
    a.sort(reverse=True)
    allocation = {}
    for i in a:
        if i not in allocation: allocation[i] = 0
        allocation[i] += 1
    return max(allocation, key=allocation.get)

def move(a, k):
    tmp1 = list()
    for element in a:
        if not ((element == k - 1) or (element == k + 1)):
            tmp1.append(element)
    tmp1.remove(k)
    return tmp1

def main(a):
    main_score = 0
    iterations = 0
    while len(a) > 0:
        k = mode(a)
        a = move(a, k)
        main_score += k
    return main_score
    
n = int(input())
a = list(map(int, input().split()))
print(main(a))","from collections import Counter

def max_points(n, a):
    count = Counter(a)
    points = 0

    removed = set()  

    for num in sorted(count.keys(), reverse=True):
        if num in removed:
            continue

        points += num * count[num]

        removed.add(num)
        removed.add(num - 1)
        removed.add(num + 1)

    return points

n = int(input())
a = list(map(int, input().split()))

print(max_points(n, a))"
75,A,Life Without Zeros,PROGRAMMING,['implementation'],"Can you imagine our life if we removed all zeros from it? For sure we will have many problems.

In this problem we will have a simple example if we removed all zeros from our life, it's the addition operation. Let's assume you are given this equation *a*<=+<=*b*<==<=*c*, where *a* and *b* are positive integers, and *c* is the sum of *a* and *b*. Now let's remove all zeros from this equation. Will the equation remain correct after removing all zeros?

For example if the equation is 101<=+<=102<==<=203, if we removed all zeros it will be 11<=+<=12<==<=23 which is still a correct equation.

But if the equation is 105<=+<=106<==<=211, if we removed all zeros it will be 15<=+<=16<==<=211 which is not a correct equation.","The input will consist of two lines, the first line will contain the integer *a*, and the second line will contain the integer *b* which are in the equation as described above (1<=≤<=*a*,<=*b*<=≤<=109). There won't be any leading zeros in both. The value of *c* should be calculated as *c*<==<=*a*<=+<=*b*.","The output will be just one line, you should print ""YES"" if the equation will remain correct after removing all zeros, and print ""NO"" otherwise.","['101\n102\n', '105\n106\n']","['YES\n', 'NO\n']",none,RUNTIME_ERROR,"def main():
    mode=""file""
    if mode==""file"":f=open(""test.txt"",""r"")

    get = lambda :[int(x) for x in (f.readline() if mode==""file"" else input()).split()]
    [a]=get()
    [b]=get()
    cc=a+b
    a=list(str(a))
    if ""0"" in a:a.remove(""0"")
    a=int("""".join(a))
    b=list(str(b))
    if ""0"" in b:b.remove(""0"")
    b=int("""".join(b))
    c=list(str(cc))
    if ""0"" in c:c.remove(""0"")
    c=int("""".join(c))
    cc=a+b
    print(""YES"" if c==cc else ""NO"")

    if mode==""file"":f.close()

if __name__==""__main__"":
    main()","def remove_zeros(num):
    """"""Remove all zeros from a number and return the result as an integer.""""""
    return int(str(num).replace('0', ''))

def is_equation_correct(a, b):
    """"""Check if the equation remains correct after removing all zeros.""""""
    c = a + b

    new_a = remove_zeros(a)
    new_b = remove_zeros(b)
    new_c = remove_zeros(c)

    return new_a <= new_b <= new_c

a = int(input())
b = int(input())

if is_equation_correct(a, b):
    print(""YES"")
else:
    print(""NO"")"
408,A,Line to Cashier,PROGRAMMING,['implementation'],"Little Vasya went to the supermarket to get some groceries. He walked about the supermarket for a long time and got a basket full of products. Now he needs to choose the cashier to pay for the products.

There are *n* cashiers at the exit from the supermarket. At the moment the queue for the *i*-th cashier already has *k**i* people. The *j*-th person standing in the queue to the *i*-th cashier has *m**i*,<=*j* items in the basket. Vasya knows that:
 -  the cashier needs 5 seconds to scan one item; -  after the cashier scans each item of some customer, he needs 15 seconds to take the customer's money and give him the change. 
Of course, Vasya wants to select a queue so that he can leave the supermarket as soon as possible. Help him write a program that displays the minimum number of seconds after which Vasya can get to one of the cashiers.","The first line contains integer *n* (1<=≤<=*n*<=≤<=100) — the number of cashes in the shop. The second line contains *n* space-separated integers: *k*1,<=*k*2,<=...,<=*k**n* (1<=≤<=*k**i*<=≤<=100), where *k**i* is the number of people in the queue to the *i*-th cashier.

The *i*-th of the next *n* lines contains *k**i* space-separated integers: *m**i*,<=1,<=*m**i*,<=2,<=...,<=*m**i*,<=*k**i* (1<=≤<=*m**i*,<=*j*<=≤<=100) — the number of products the *j*-th person in the queue for the *i*-th cash has.",Print a single integer — the minimum number of seconds Vasya needs to get to the cashier.,"['1\n1\n1\n', '4\n1 4 3 2\n100\n1 2 2 3\n1 9 1\n7 8\n']","['20\n', '100\n']","In the second test sample, if Vasya goes to the first queue, he gets to the cashier in 100·5 + 15 = 515 seconds. But if he chooses the second queue, he will need 1·5 + 2·5 + 2·5 + 3·5 + 4·15 = 100 seconds. He will need 1·5 + 9·5 + 1·5 + 3·15 = 100 seconds for the third one and 7·5 + 8·5 + 2·15 = 105 seconds for the fourth one. Thus, Vasya gets to the cashier quicker if he chooses the second or the third queue.",OK,"def solve():
    n = int(input())
    ak = [int(i) for i in input().split()]
    ans = float(""inf"")
    for i in range(n):
        a = [int(k) for k in input().split()]
        s = 0
        for j in range(len(a)):
            s+=a[j]*5
        s+=15*ak[i]
        ans = min(ans,s)
    print(ans)
    return

solve()","def calculate_time(n, queues):
    min_time = float('inf')

    for queue in queues:
        total_time = 0
        for items in queue:

            total_time += items * 5 + 15

        min_time = min(min_time, total_time)

    return min_time

n = int(input())
queues = []
for _ in range(n):
    k = list(map(int, input().split()))
    items = []
    for _ in range(k[0]):
        items.append(int(input()))
    queues.append(items)

result = calculate_time(n, queues)
print(result)"
230,B,T-primes,PROGRAMMING,"['binary search', 'implementation', 'math', 'number theory']","We know that prime numbers are positive integers that have exactly two distinct positive divisors. Similarly, we'll call a positive integer *t* Т-prime, if *t* has exactly three distinct positive divisors.

You are given an array of *n* positive integers. For each of them determine whether it is Т-prime or not.","The first line contains a single positive integer, *n* (1<=≤<=*n*<=≤<=105), showing how many numbers are in the array. The next line contains *n* space-separated integers *x**i* (1<=≤<=*x**i*<=≤<=1012).

Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is advised to use the cin, cout streams or the %I64d specifier.","Print *n* lines: the *i*-th line should contain ""YES"" (without the quotes), if number *x**i* is Т-prime, and ""NO"" (without the quotes), if it isn't.",['3\n4 5 6\n'],['YES\nNO\nNO\n'],"The given test has three numbers. The first number 4 has exactly three divisors — 1, 2 and 4, thus the answer for this number is ""YES"". The second number 5 has two divisors (1 and 5), and the third number 6 has four divisors (1, 2, 3, 6), hence the answer for them is ""NO"".",TIME_LIMIT_EXCEEDED,"from sys import stdin
def input(): return stdin.readline()[:-1]
def ili(): return list(map(int, input().split()))
import math
from collections import defaultdict

def check(n):
    d = defaultdict(lambda : 0)
    while n % 2 == 0:
        d[2] += 1
        n = n // 2
    for i in range(3, int(math.sqrt(n))+1, 2):
        while n % i == 0:
            d[i] += 1
            n = n // i
    if n > 2:
        d[n] += 1
    if len(d.keys()) == 1 and list(d.values())[0] == 2:
        return True
    return False

def solve():
    n = int(input())
    s = ili()
    for i in s:
        if i == 1:
            print(""NO"")
            continue
        print(""YES"") if check(i) else print(""NO"")

case_num = 1

for case in range(case_num):
    solve()","import sys
import math

def is_t_prime(num):

    root = int(math.isqrt(num))
    if root * root == num:

        return is_prime(root)
    return False

def is_prime(num):
    if num <= 1:
        return False
    if num <= 3:
        return True
    if num % 2 == 0 or num % 3 == 0:
        return False
    i = 5
    while i * i <= num:
        if num % i == 0 or num % (i + 2) == 0:
            return False
        i += 6
    return True

def main():
    input_data = sys.stdin.read().splitlines()
    n = int(input_data[0])
    numbers = list(map(int, input_data[1].split()))

    results = []
    for number in numbers:
        if is_t_prime(number):
            results.append(""YES"")
        else:
            results.append(""NO"")

    print(""\n"".join(results))

if __name__ == ""__main__"":
    main()"
741,B,Arpa's weak amphitheater and Mehrdad's valuable Hoses,PROGRAMMING,"['dfs and similar', 'dp', 'dsu']","Just to remind, girls in Arpa's land are really nice.

Mehrdad wants to invite some Hoses to the palace for a dancing party. Each Hos has some weight *w**i* and some beauty *b**i*. Also each Hos may have some friends. Hoses are divided in some friendship groups. Two Hoses *x* and *y* are in the same friendship group if and only if there is a sequence of Hoses *a*1,<=*a*2,<=...,<=*a**k* such that *a**i* and *a**i*<=+<=1 are friends for each 1<=≤<=*i*<=&lt;<=*k*, and *a*1<==<=*x* and *a**k*<==<=*y*.

Arpa allowed to use the amphitheater of palace to Mehrdad for this party. Arpa's amphitheater can hold at most *w* weight on it. 

Mehrdad is so greedy that he wants to invite some Hoses such that sum of their weights is not greater than *w* and sum of their beauties is as large as possible. Along with that, from each friendship group he can either invite all Hoses, or no more than one. Otherwise, some Hoses will be hurt. Find for Mehrdad the maximum possible total beauty of Hoses he can invite so that no one gets hurt and the total weight doesn't exceed *w*.","The first line contains integers *n*, *m* and *w* (1<=<=≤<=<=*n*<=<=≤<=<=1000, , 1<=≤<=*w*<=≤<=1000) — the number of Hoses, the number of pair of friends and the maximum total weight of those who are invited.

The second line contains *n* integers *w*1,<=*w*2,<=...,<=*w**n* (1<=≤<=*w**i*<=≤<=1000) — the weights of the Hoses.

The third line contains *n* integers *b*1,<=*b*2,<=...,<=*b**n* (1<=≤<=*b**i*<=≤<=106) — the beauties of the Hoses.

The next *m* lines contain pairs of friends, the *i*-th of them contains two integers *x**i* and *y**i* (1<=≤<=*x**i*,<=*y**i*<=≤<=*n*, *x**i*<=≠<=*y**i*), meaning that Hoses *x**i* and *y**i* are friends. Note that friendship is bidirectional. All pairs (*x**i*,<=*y**i*) are distinct.",Print the maximum possible total beauty of Hoses Mehrdad can invite so that no one gets hurt and the total weight doesn't exceed *w*.,"['3 1 5\n3 2 5\n2 4 2\n1 2\n', '4 2 11\n2 4 6 6\n6 4 2 1\n1 2\n2 3\n']","['6\n', '7\n']","In the first sample there are two friendship groups: Hoses {1, 2} and Hos {3}. The best way is to choose all of Hoses in the first group, sum of their weights is equal to 5 and sum of their beauty is 6.

In the second sample there are two friendship groups: Hoses {1, 2, 3} and Hos {4}. Mehrdad can't invite all the Hoses from the first group because their total weight is 12 &gt; 11, thus the best way is to choose the first Hos from the first group and the only one from the second group. The total weight will be 8, and the total beauty will be 7.",OK,"def g(x):
    if x == t[x]: return x
    t[x] = g(t[x])
    return t[x]

f = lambda: map(int, input().split())
hoses, pairOfFriends, weight = f()
weightsAndBeauties = [(0, 0)] + list(zip(f(), f()))
t = list(range(hoses + 1))

for i in range(pairOfFriends):
    f1, f2 = f()
    f1, f2 = g(f1), g(f2)
    if f1 != f2:
        t[f2] = f1

p = [[] for j in range(hoses + 1)]
for i in range(1, hoses + 1):
    p[g(i)].append(i)

beauties = [1] + [0] * weight
for q in p:
    if len(q) > 1:
        t = [weightsAndBeauties[i] for i in q]
        t.append((sum(f1[0] for f1 in t), sum(f1[1] for f1 in t)))
        t.sort(key=lambda f1: f1[0])

        for j in range(weight, -1, -1):
            if beauties[j]:
                for w, b in t:
                    if j + w > weight:
                        break
                    else:
                        beauties[j + w] = max(beauties[j + w], beauties[j] + b)
    elif len(q) == 1:
        w, b = weightsAndBeauties[q[0]]
        for j in range(weight - w, -1, -1):
            if beauties[j]:
                beauties[j + w] = max(beauties[j + w], beauties[j] + b)

maxBeauty = max(beauties) - 1
print(maxBeauty)","def find_friendship_groups(n, friends):
    from collections import defaultdict, deque

    adj = defaultdict(list)
    for x, y in friends:
        adj[x].append(y)
        adj[y].append(x)

    visited = [False] * (n + 1)
    groups = []

    for i in range(1, n + 1):
        if not visited[i]:
            group = []
            queue = deque([i])
            while queue:
                hose = queue.popleft()
                if not visited[hose]:
                    visited[hose] = True
                    group.append(hose)
                    for neighbor in adj[hose]:
                        if not visited[neighbor]:
                            queue.append(neighbor)
            groups.append(group)

    return groups

def max_beauty(n, m, W, weights, beauties, friends):
    groups = find_friendship_groups(n, friends)
    group_weights = []
    group_beauties = []

    for group in groups:
        total_weight = sum(weights[i - 1] for i in group)
        total_beauty = sum(beauties[i - 1] for i in group)
        group_weights.append(total_weight)
        group_beauties.append(total_beauty)

    dp = [0] * (W + 1)

    for weight, beauty in zip(group_weights, group_beauties):
        for w in range(W, weight - 1, -1):
            dp[w] = max(dp[w], dp[w - weight] + beauty)

    return max(dp)

import sys

input = sys.stdin.read
data = input().splitlines()

t = int(data[0])
result = []

index = 1
for _ in range(t):
    n, m, W = map(int, data[index].split())
    weights = list(map(int, data[index + 1].split()))
    beauties = list(map(int, data[index + 2].split()))
    friends = [tuple(map(int, data[i + index + 3].split())) for i in range(m)]

    max_beauty_value = max_beauty(n, m, W, weights, beauties, friends)
    result.append(max_beauty_value)
    
    index += (3 + m)

for res in result:
    print(res)"
710,A,King Moves,PROGRAMMING,['implementation'],"The only king stands on the standard chess board. You are given his position in format ""cd"", where *c* is the column from 'a' to 'h' and *d* is the row from '1' to '8'. Find the number of moves permitted for the king.

Check the king's moves here [https://en.wikipedia.org/wiki/King_(chess)](https://en.wikipedia.org/wiki/King_(chess)).","The only line contains the king's position in the format ""cd"", where 'c' is the column from 'a' to 'h' and 'd' is the row from '1' to '8'.",Print the only integer *x* — the number of moves permitted for the king.,['e4\n'],['8\n'],none,OK,"from sys import stdin, stdout
def read():
	return stdin.readline().rstrip()

def read_int():
	return int(read())

def read_ints():
	return list(map(int, read().split()))

def solve():
	a=read()
	c=0
	if a[0]=='a' or a[0]=='h':
		c+=1
	if a[1]=='1' or a[1]=='8':
		c+=1
	if c==0:
		print(8)
	elif c==1:
		print(5)
	else:
		print(3)

solve()","def count_king_moves(position):

    moves = [(-1, -1), (-1, 0), (-1, 1),
             (0, -1),          (0, 1),
             (1, -1), (1, 0), (1, 1)]

    column = ord(position[0]) - ord('a') + 1
    row = int(position[1])

    valid_moves = 0
    for dx, dy in moves:
        new_column = column + dx
        new_row = row + dy

        if 1 <= new_column <= 8 and 1 <= new_row <= 8:
            valid_moves += 1
            
    return valid_moves

input_position = input().strip()

print(count_king_moves(input_position))"
322,B,Ciel and Flowers,PROGRAMMING,"['combinatorics', 'math']","Fox Ciel has some flowers: *r* red flowers, *g* green flowers and *b* blue flowers. She wants to use these flowers to make several bouquets. There are 4 types of bouquets:
 -  To make a ""red bouquet"", it needs 3 red flowers. -  To make a ""green bouquet"", it needs 3 green flowers. -  To make a ""blue bouquet"", it needs 3 blue flowers. -  To make a ""mixing bouquet"", it needs 1 red, 1 green and 1 blue flower. 
Help Fox Ciel to find the maximal number of bouquets she can make.","The first line contains three integers *r*, *g* and *b* (0<=≤<=*r*,<=*g*,<=*b*<=≤<=109) — the number of red, green and blue flowers.",Print the maximal number of bouquets Fox Ciel can make.,"['3 6 9\n', '4 4 4\n', '0 0 0\n']","['6\n', '4\n', '0\n']","In test case 1, we can make 1 red bouquet, 2 green bouquets and 3 blue bouquets.

In test case 2, we can make 1 red, 1 green, 1 blue and 1 mixing bouquet.",WRONG_ANSWER,"from sys import stdin,stdout
stdin.readline
def mp(): return list(map(int, stdin.readline().strip().split()))
def it():return int(stdin.readline().strip())
from collections import defaultdict as dd,Counter as C,deque
from math import ceil,gcd,sqrt,factorial,log2,floor
from bisect import bisect_right as br,bisect_left as bl
import heapq

r,g,b = mp()
ans = min(r,g,b)
r -= ans
g -= ans
b -= ans
ans += r//3
ans += g//3
ans += b//3
print(ans)","def max_bouquets(r, g, b):

    max_bouquets = 0

    mix_bouquets = min(r, g, b)
    max_bouquets += mix_bouquets

    r -= mix_bouquets
    g -= mix_bouquets
    b -= mix_bouquets

    max_bouquets += r // 3
    max_bouquets += g // 3
    max_bouquets += b // 3
    
    return max_bouquets

input_data = ['3 6 9\n', '4 4 4\n', '0 0 0\n']
results = []

for line in input_data:
    r, g, b = map(int, line.strip().split())
    results.append(f""{max_bouquets(r, g, b)}\n"")

print(''.join(results))"
292,D,Connected Components,PROGRAMMING,"['data structures', 'dfs and similar', 'dp', 'dsu']","We already know of the large corporation where Polycarpus works as a system administrator. The computer network there consists of *n* computers and *m* cables that connect some pairs of computers. In other words, the computer network can be represented as some non-directed graph with *n* nodes and *m* edges. Let's index the computers with integers from 1 to *n*, let's index the cables with integers from 1 to *m*.

Polycarpus was given an important task — check the reliability of his company's network. For that Polycarpus decided to carry out a series of *k* experiments on the computer network, where the *i*-th experiment goes as follows:
 1.  Temporarily disconnect the cables with indexes from *l**i* to *r**i*, inclusive (the other cables remain connected). 1.  Count the number of connected components in the graph that is defining the computer network at that moment. 1.  Re-connect the disconnected cables with indexes from *l**i* to *r**i* (that is, restore the initial network). 
Help Polycarpus carry out all experiments and for each print the number of connected components in the graph that defines the computer network through the given experiment. Isolated vertex should be counted as single component.","The first line contains two space-separated integers *n*, *m* (2<=≤<=*n*<=≤<=500; 1<=≤<=*m*<=≤<=104) — the number of computers and the number of cables, correspondingly.

The following *m* lines contain the cables' description. The *i*-th line contains space-separated pair of integers *x**i*, *y**i* (1<=≤<=*x**i*,<=*y**i*<=≤<=*n*; *x**i*<=≠<=*y**i*) — the numbers of the computers that are connected by the *i*-th cable. Note that a pair of computers can be connected by multiple cables.

The next line contains integer *k* (1<=≤<=*k*<=≤<=2·104) — the number of experiments. Next *k* lines contain the experiments' descriptions. The *i*-th line contains space-separated integers *l**i*, *r**i* (1<=≤<=*l**i*<=≤<=*r**i*<=≤<=*m*) — the numbers of the cables that Polycarpus disconnects during the *i*-th experiment.","Print *k* numbers, the *i*-th number represents the number of connected components of the graph that defines the computer network during the *i*-th experiment.",['6 5\n1 2\n5 4\n2 3\n3 1\n3 6\n6\n1 3\n2 5\n1 5\n5 5\n2 4\n3 3\n'],['4\n5\n6\n3\n4\n2\n'],none,COMPILATION_ERROR,"typedef long long ll;

using namespace std;

int p[555];
int rang[555];

void make_set(int x) {
	p[x] = x;
	rang[x] = 0;
}

int find_set(int x) {
	if (p[x] == x)
		return x;
	return p[x] = find_set(p[x]);
}

void union_set(int x, int y) {
	x = find_set(x);
	y = find_set(y);
	if (rang[x] > rang[y])
		swap(x, y);
	if (x != y) {
		p[x] = y;
		rang[y] += (rang[x] == rang[y]);
	}
}

int main() {
	//freopen(""input.txt"",""r"",stdin);
	//freopen(""output.txt"",""w"",stdout);
	int n, m;
	cin >> n >> m;
	stack <int> ans;
	vector <pair <int, int> > v;
	pair <int, int> pp = MP(-1, -1);
	v.push_back(pp);
	for (int i = 1; i <= m; i++) {
		int x, y;
		cin >> x >> y;
		pp = MP(x, y);
		v.push_back(pp);
	}
	int q;
	cin >> q;
	stack <int> st;
	bool us[555];
	for (int i = 0; i <= 545; i++)
		us[i] = 1;
	for (int i = 1; i <= q; i++) {
		vector <int> gr[555];
		int l, r;
		cin >> l >> r;
		for (int i = 1; i <= n; i++) 
			make_set(i);
		int komp = n;
		for (int i = 1; i <= m; i++) {
			if (!(i >= l && i <= r)) {
				int u = v[i].first, vv = v[i].second;
				gr[u].push_back(vv);
				gr[vv].push_back(u);
				if (find_set(u) != find_set(vv))
					komp--;
				union_set(u, vv);				
			}
		}
		cout << komp << endl;
	}
}","def find_connected_components(n, edges, experiments):
    from collections import defaultdict

    def dfs(node, visited):
        visited.add(node)
        for neighbor in graph[node]:
            if neighbor not in visited:
                dfs(neighbor, visited)

    graph = defaultdict(list)
    for x, y in edges:
        graph[x].append(y)
        graph[y].append(x)

    results = []

    for l, r in experiments:

        removed_edges = set(range(l - 1, r))
        modified_graph = defaultdict(list)

        for index, (x, y) in enumerate(edges):
            if index not in removed_edges:
                modified_graph[x].append(y)
                modified_graph[y].append(x)

        visited = set()
        components = 0
        for i in range(1, n + 1):
            if i not in visited:
                dfs(i, visited)
                components += 1
        
        results.append(components)

    return results

def main():
    import sys
    input = sys.stdin.read
    data = input().splitlines()

    n, m = map(int, data[0].split())

    edges = [tuple(map(int, line.split())) for line in data[1:m + 1]]

    k = int(data[m + 1])

    experiments = [tuple(map(int, line.split())) for line in data[m + 2:m + 2 + k]]

    results = find_connected_components(n, edges, experiments)

    for result in results:
        print(result)

if __name__ == ""__main__"":
    main()"
912,B,New Year's Eve,PROGRAMMING,"['bitmasks', 'constructive algorithms', 'number theory']","Since Grisha behaved well last year, at New Year's Eve he was visited by Ded Moroz who brought an enormous bag of gifts with him! The bag contains *n* sweet candies from the good ol' bakery, each labeled from 1 to *n* corresponding to its tastiness. No two candies have the same tastiness.

The choice of candies has a direct effect on Grisha's happiness. One can assume that he should take the tastiest ones — but no, the holiday magic turns things upside down. It is the xor-sum of tastinesses that matters, not the ordinary sum!

A xor-sum of a sequence of integers *a*1,<=*a*2,<=...,<=*a**m* is defined as the bitwise XOR of all its elements: , here  denotes the bitwise XOR operation; more about bitwise XOR can be found [here.](https://en.wikipedia.org/wiki/Bitwise_operation#XOR)

Ded Moroz warned Grisha he has more houses to visit, so Grisha can take no more than *k* candies from the bag. Help Grisha determine the largest xor-sum (largest xor-sum means maximum happiness!) he can obtain.",The sole string contains two integers *n* and *k* (1<=≤<=*k*<=≤<=*n*<=≤<=1018).,Output one number — the largest possible xor-sum.,"['4 3\n', '6 6\n']","['7\n', '7\n']","In the first sample case, one optimal answer is 1, 2 and 4, giving the xor-sum of 7.

In the second sample case, one can, for example, take all six candies and obtain the xor-sum of 7.",OK,"def precompute(arr) :
    arr[0] = 1
    for index in range(1,60) :
        arr[index] = arr[index-1]*2

def solve(n,k,power) :
    if k == 1 :
        return n
        
    else :
        for index in range(59,-1,-1):
            if power[index] <= n :
                return power[index] + (power[index] - 1)

arr = [0] * 60
n,k = list(map(int,input().split()))
precompute(arr)
print (solve(n,k,arr))","def largest_xor_sum(n, k):

    if k >= n:
        return n

    xor_sum = 0

    for i in range(n, n - k, -1):
        xor_sum ^= i
    
    return xor_sum

input_data = input().strip().split()
results = []

for line in input_data:
    n, k = map(int, line.split())
    results.append(largest_xor_sum(n, k))

for result in results:
    print(result)"
948,A,Protect Sheep,PROGRAMMING,"['brute force', 'dfs and similar', 'graphs', 'implementation']","Bob is a farmer. He has a large pasture with many sheep. Recently, he has lost some of them due to wolf attacks. He thus decided to place some shepherd dogs in such a way that all his sheep are protected.

The pasture is a rectangle consisting of *R*<=×<=*C* cells. Each cell is either empty, contains a sheep, a wolf or a dog. Sheep and dogs always stay in place, but wolves can roam freely around the pasture, by repeatedly moving to the left, right, up or down to a neighboring cell. When a wolf enters a cell with a sheep, it consumes it. However, no wolf can enter a cell with a dog.

Initially there are no dogs. Place dogs onto the pasture in such a way that no wolf can reach any sheep, or determine that it is impossible. Note that since you have many dogs, you do not need to minimize their number.","First line contains two integers *R* (1<=≤<=*R*<=≤<=500) and *C* (1<=≤<=*C*<=≤<=500), denoting the number of rows and the numbers of columns respectively.

Each of the following *R* lines is a string consisting of exactly *C* characters, representing one row of the pasture. Here, 'S' means a sheep, 'W' a wolf and '.' an empty cell.","If it is impossible to protect all sheep, output a single line with the word ""No"".

Otherwise, output a line with the word ""Yes"". Then print *R* lines, representing the pasture after placing dogs. Again, 'S' means a sheep, 'W' a wolf, 'D' is a dog and '.' an empty space. You are not allowed to move, remove or add a sheep or a wolf.

If there are multiple solutions, you may print any of them. You don't have to minimize the number of dogs.","['6 6\n..S...\n..S.W.\n.S....\n..W...\n...W..\n......\n', '1 2\nSW\n', '5 5\n.S...\n...S.\nS....\n...S.\n.S...\n']","['Yes\n..SD..\n..SDW.\n.SD...\n.DW...\nDD.W..\n......\n', 'No\n', 'Yes\n.S...\n...S.\nS.D..\n...S.\n.S...\n']","In the first example, we can split the pasture into two halves, one containing wolves and one containing sheep. Note that the sheep at (2,1) is safe, as wolves cannot move diagonally.

In the second example, there are no empty spots to put dogs that would guard the lone sheep.

In the third example, there are no wolves, so the task is very easy. We put a dog in the center to observe the peacefulness of the meadow, but the solution would be correct even without him.",WRONG_ANSWER,"R, C = list(map(int, input().split()))
grid = []
for _ in range(R):
    li = list(input())
    grid.append(li)
visited = [[0 for _ in range(C)] for _ in range(R)]

directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]

def isBound(r, c):
    return 0 <= r < R and 0 <= c < C

def search(r, c):
    visited[r][c] = 1
    for dr in directions:
        new_row = r + dr[0]
        new_col = c + dr[1]
        if isBound(new_row, new_col):
            if grid[new_row][new_col] == 'W':
                return False
            if grid[new_row][new_col] == '.':
                grid[new_row][new_col] = 'D'
    return True

for i in range(R):
    found = False
    for j in range(C):
      if grid[i][j] == 'S':
        if not search(i, j):
            found = True
            print(""NO"")
    if found:
        break

if not found:
    print(""YES"")
    for li in grid:
      print(''.join(li))","def protect_sheep(R, C, pasture):

    new_pasture = [list(row) for row in pasture]

    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]

    for r in range(R):
        for c in range(C):
            if pasture[r][c] == 'W':
                for dr, dc in directions:
                    nr, nc = r + dr, c + dc

                    if 0 <= nr < R and 0 <= nc < C:
                        if pasture[nr][nc] == 'S':
                            return ""No"", []
                        if pasture[nr][nc] == '.':
                            new_pasture[nr][nc] = 'D'

    return ""Yes"", [''.join(row) for row in new_pasture]

import sys
input = sys.stdin.read
data = input().strip().split('\n')

R, C = map(int, data[0].split())
pasture = data[1:R + 1]

result, modified_pasture = protect_sheep(R, C, pasture)

print(result)
if result == ""Yes"":
    for line in modified_pasture:
        print(line)"
909,A,Generate Login,PROGRAMMING,"['brute force', 'greedy', 'sortings']","The preferred way to generate user login in Polygon is to concatenate a prefix of the user's first name and a prefix of their last name, in that order. Each prefix must be non-empty, and any of the prefixes can be the full name. Typically there are multiple possible logins for each person.

You are given the first and the last name of a user. Return the alphabetically earliest login they can get (regardless of other potential Polygon users).

As a reminder, a prefix of a string *s* is its substring which occurs at the beginning of *s*: ""a"", ""ab"", ""abc"" etc. are prefixes of string ""{abcdef}"" but ""b"" and 'bc"" are not. A string *a* is alphabetically earlier than a string *b*, if *a* is a prefix of *b*, or *a* and *b* coincide up to some position, and then *a* has a letter that is alphabetically earlier than the corresponding letter in *b*: ""a"" and ""ab"" are alphabetically earlier than ""ac"" but ""b"" and ""ba"" are alphabetically later than ""ac"".","The input consists of a single line containing two space-separated strings: the first and the last names. Each character of each string is a lowercase English letter. The length of each string is between 1 and 10, inclusive.",Output a single string — alphabetically earliest possible login formed from these names. The output should be given in lowercase as well.,"['harry potter\n', 'tom riddle\n']","['hap\n', 'tomr\n']",none,OK,"def getprfx(s):
	tab = [s[0]]
	for i in range(1, len(s)):
		x = tab[i-1] + s[i]
		tab.append(x)
	return tab
	
n, m = input().split()

a, b = getprfx(n), getprfx(m)
mn = a[0] + b[0]
for i in a:
	for j in b:
		if i+j < mn:
			mn = i+j
print(mn)","def earliest_login(first_name, last_name):

    logins = []

    for i in range(1, len(first_name) + 1):
        first_prefix = first_name[:i]

        for j in range(1, len(last_name) + 1):
            last_prefix = last_name[:j]

            logins.append(first_prefix + last_prefix)

    return min(logins)

input_data = input().strip()
first_name, last_name = input_data.split()

print(earliest_login(first_name, last_name))"
995,C,Leaving the Bar,PROGRAMMING,"['brute force', 'data structures', 'geometry', 'greedy', 'math', 'sortings']","For a vector $\vec{v} = (x, y)$, define $|v| = \sqrt{x^2 + y^2}$.

Allen had a bit too much to drink at the bar, which is at the origin. There are $n$ vectors $\vec{v_1}, \vec{v_2}, \cdots, \vec{v_n}$. Allen will make $n$ moves. As Allen's sense of direction is impaired, during the $i$-th move he will either move in the direction $\vec{v_i}$ or $-\vec{v_i}$. In other words, if his position is currently $p = (x, y)$, he will either move to $p + \vec{v_i}$ or $p - \vec{v_i}$.

Allen doesn't want to wander too far from home (which happens to also be the bar). You need to help him figure out a sequence of moves (a sequence of signs for the vectors) such that his final position $p$ satisfies $|p| \le 1.5 \cdot 10^6$ so that he can stay safe.","The first line contains a single integer $n$ ($1 \le n \le 10^5$) — the number of moves.

Each of the following lines contains two space-separated integers $x_i$ and $y_i$, meaning that $\vec{v_i} = (x_i, y_i)$. We have that $|v_i| \le 10^6$ for all $i$.","Output a single line containing $n$ integers $c_1, c_2, \cdots, c_n$, each of which is either $1$ or $-1$. Your solution is correct if the value of $p = \sum_{i = 1}^n c_i \vec{v_i}$, satisfies $|p| \le 1.5 \cdot 10^6$.

It can be shown that a solution always exists under the given constraints.","['3\n999999 0\n0 999999\n999999 0\n', '1\n-824590 246031\n', '8\n-67761 603277\n640586 -396671\n46147 -122580\n569609 -2112\n400 914208\n131792 309779\n-850150 -486293\n5272 721899\n']","['1 1 -1 \n', '1 \n', '1 1 1 1 1 1 1 -1 \n']",none,WRONG_ANSWER,"n = int(input())

res = []
ta, tb = 0, 0
for _ in range(n):
    a, b = [int(x) for x in input().split()]
    ta += a
    tb += b
    res.append((a, b))

def norm(x):
    return x[0] ** 2 + x[1] ** 2

def add(x, y):
    return (x[0] + y[0], x[1] + y[1])
def sub(x, y):
    return (x[0] - y[0], x[1] - y[1])

target = 2.25 * 10 ** 12

ans = [1 for _ in range(n)]

v = (ta, tb)
cur = norm(v)
for i, v2 in enumerate(res):
    v2 = (2*v2[0], 2*v2[1])
    if norm(sub(v, v2)) < cur:
        v = sub(v, v2)
        cur = norm(v)
        ans[i] = -1

print("" "".join(map(str, ans)))","import sys
import math

def main():

    n = int(sys.stdin.readline().strip())

    total_x, total_y = 0, 0
    vectors = []

    for _ in range(n):
        x, y = map(int, sys.stdin.readline().strip().split())
        vectors.append((x, y))

    directions = []

    for x, y in vectors:
        total_x += x
        total_y += y

    initial_distance = math.sqrt(total_x**2 + total_y**2)

    if initial_distance <= 1.5e6:

        directions = [1] * n
    else:

        for i in range(n):
            x, y = vectors[i]

            total_x -= x
            total_y -= y

            if math.sqrt(total_x**2 + total_y**2) <= 1.5e6:
                directions.append(-1)
            else:
                directions.append(1)
                total_x += x

    print(' '.join(map(str, directions)))

if __name__ == ""__main__"":
    main()"
16,C,Monitor,PROGRAMMING,"['binary search', 'number theory']","Reca company makes monitors, the most popular of their models is AB999 with the screen size *a*<=×<=*b* centimeters. Because of some production peculiarities a screen parameters are integer numbers. Recently the screen sides ratio *x*:<=*y* became popular with users. That's why the company wants to reduce monitor AB999 size so that its screen sides ratio becomes *x*:<=*y*, at the same time they want its total area to be maximal of all possible variants. Your task is to find the screen parameters of the reduced size model, or find out that such a reduction can't be performed.","The first line of the input contains 4 integers — *a*, *b*, *x* and *y* (1<=≤<=*a*,<=*b*,<=*x*,<=*y*<=≤<=2·109).","If the answer exists, output 2 positive integers — screen parameters of the reduced size model. Output 0 0 otherwise.","['800 600 4 3\n', '1920 1200 16 9\n', '1 1 1 2\n']","['800 600\n', '1920 1080\n', '0 0\n']",none,TIME_LIMIT_EXCEEDED,"def inp(s):
    j = 0
    a = []
    for i in range(len(s)):
        if s[i] == "" "":
            a.append(int(s[j:i]))
            j = i+1
        if i == len(s)-1:
            a.append(int(s[j:]))
    return a

s = input()
a = inp(s)
p = 0
q = 0
for i in range(a[0],-1,-1):
    x = (i*a[3])/a[2]
    if x%1 == 0:
        p = i
        break

for j in range(a[1],-1,-1):
    y = (i*a[2])/a[3]
    if y%1 == 0:
        q = j
        break

if x <= a[1] and y<= a[0]:
    if q*y > p*x:
        print (str(int(y))+"" ""+str(q))
    else:
        print (str(p)+"" ""+str(int(x)))
        
elif x <= a[1] and y > a[0]:
    print (str(int(p))+"" ""+str(int(x)))

elif x > a[1] and y <= a[0]:
    print (str(int(y))+"" ""+str(q))
elif x == 0 and y == 0:
    print (""0 0"")
else:
    print (""0 0"")","def find_monitor_size(a, b, x, y):

    max_area = 0
    final_width = 0
    final_height = 0

    ratio = x / y

    for height in range(1, b + 1):
        width = int(height * ratio)

        if width < a or width > b or height > b:
            continue
        
        area = width * height

        if area > max_area:
            max_area = area
            final_width = width
            final_height = height

    if final_width > 0 and final_height > 0:
        return final_width, final_height
    else:
        return 0, 0

inputs = [
    '800 600 4 3',
    '1920 1200 16 9',
    '1 1 1 2'
]

for input_line in inputs:
    a, b, x, y = map(int, input_line.split())
    result = find_monitor_size(a, b, x, y)
    print(result[0], result[1])"
551,A,GukiZ and Contest,PROGRAMMING,"['brute force', 'implementation', 'sortings']","Professor GukiZ likes programming contests. He especially likes to rate his students on the contests he prepares. Now, he has decided to prepare a new contest. 

In total, *n* students will attend, and before the start, every one of them has some positive integer rating. Students are indexed from 1 to *n*. Let's denote the rating of *i*-th student as *a**i*. After the contest ends, every student will end up with some positive integer position. GukiZ expects that his students will take places according to their ratings. 

He thinks that each student will take place equal to . In particular, if student *A* has rating strictly lower then student *B*, *A* will get the strictly better position than *B*, and if two students have equal ratings, they will share the same position. 

GukiZ would like you to reconstruct the results by following his expectations. Help him and determine the position after the end of the contest for each of his students if everything goes as expected.","The first line contains integer *n* (1<=≤<=*n*<=≤<=2000), number of GukiZ's students. 

The second line contains *n* numbers *a*1,<=*a*2,<=... *a**n* (1<=≤<=*a**i*<=≤<=2000) where *a**i* is the rating of *i*-th student (1<=≤<=*i*<=≤<=*n*).","In a single line, print the position after the end of the contest for each of *n* students in the same order as they appear in the input.","['3\n1 3 3\n', '1\n1\n', '5\n3 5 3 4 5\n']","['3 1 1\n', '1\n', '4 1 4 3 1\n']","In the first sample, students 2 and 3 are positioned first (there is no other student with higher rating), and student 1 is positioned third since there are two students with higher rating.

In the second sample, first student is the only one on the contest.

In the third sample, students 2 and 5 share the first position with highest rating, student 4 is next with third position, and students 1 and 3 are the last sharing fourth position.",COMPILATION_ERROR,"using namespace std;

                            for(int j=0;j<n;j++){   \
                                cout<<a[i][j]<<"" ""; \
                            }                       \
                            cout<<endl;             \
                        }

int main() {
    ll n;
    cin>>n;
    ll a[n];
    ll b[2001],c[2001];
    mset(b,0);
    mset(c,0);
    rep(n){
        cin>>a[i];
        b[a[i]]++;
    }
    for(int i=1999;i>=0;i--){
        c[i]=c[i+1]+b[i+1];
    }
    rep(n){
        cout<<c[a[i]]+1<<"" "";
    }
	return 0;","def assign_positions(n, ratings):

    indexed_ratings = [(ratings[i], i) for i in range(n)]

    indexed_ratings.sort(key=lambda x: -x[0])

    positions = [0] * n
    current_position = 1

    for i in range(n):

        if i > 0 and indexed_ratings[i][0] == indexed_ratings[i - 1][0]:
            positions[indexed_ratings[i][1]] = positions[indexed_ratings[i - 1][1]]
        else:
            positions[indexed_ratings[i][1]] = current_position
        
        current_position += 1

    return positions

n = int(input())
ratings = list(map(int, input().split()))

positions = assign_positions(n, ratings)

print("" "".join(map(str, positions)))"
535,B,Tavas and SaDDas,PROGRAMMING,"['bitmasks', 'brute force', 'combinatorics', 'implementation']","Once again Tavas started eating coffee mix without water! Keione told him that it smells awful, but he didn't stop doing that. That's why Keione told his smart friend, SaDDas to punish him! SaDDas took Tavas' headphones and told him: ""If you solve the following problem, I'll return it to you.""

The problem is: 

You are given a lucky number *n*. Lucky numbers are the positive integers whose decimal representations contain only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.

If we sort all lucky numbers in increasing order, what's the 1-based index of *n*? 

Tavas is not as smart as SaDDas, so he asked you to do him a favor and solve this problem so he can have his headphones back.",The first and only line of input contains a lucky number *n* (1<=≤<=*n*<=≤<=109).,Print the index of *n* among all lucky numbers.,"['4\n', '7\n', '77\n']","['1\n', '2\n', '6\n']",none,OK,"import math
def fact(n):
    ans = 1
    for i in range(2, n+1):
        ans*= i
    return ans
def comb(n, c):
    return fact(n)//(fact(n-c)*c)

n= int(input())
if(n==4):
    print(1)
elif(n==7):
    print(2)
else:
    add = 2
    ans = 0
    n = str(n)
    for i in range(len(n)):
        ans+=(2**i)
    pos = (2**len(n))
    left = 1
    right = pos
    i = 0
    while(left < right and i < len(n)):
        mid = (left+right)//2
        if(n[i]=='4'):
            right = mid
        else:
            left = mid+1
        i+=1
    ans+=left-1
    print(ans)","def lucky_number_index(n):

    n_str = str(n)
    index = 0
    length = len(n_str)

    for i in range(1, length):
        index += 2 ** i

    for i, digit in enumerate(n_str):
        if digit == '4':
            continue
        elif digit == '7':

            index += 2 ** (length - i - 1)
            break

    return index + 1

n = int(input().strip())

print(lucky_number_index(n))"
519,C,A and B and Team Training,PROGRAMMING,"['greedy', 'implementation', 'math', 'number theory']","A and B are preparing themselves for programming contests.

An important part of preparing for a competition is sharing programming knowledge from the experienced members to those who are just beginning to deal with the contests. Therefore, during the next team training A decided to make teams so that newbies are solving problems together with experienced participants.

A believes that the optimal team of three people should consist of one experienced participant and two newbies. Thus, each experienced participant can share the experience with a large number of people.

However, B believes that the optimal team should have two experienced members plus one newbie. Thus, each newbie can gain more knowledge and experience.

As a result, A and B have decided that all the teams during the training session should belong to one of the two types described above. Furthermore, they agree that the total number of teams should be as much as possible.

There are *n* experienced members and *m* newbies on the training session. Can you calculate what maximum number of teams can be formed?","The first line contains two integers *n* and *m* (0<=≤<=*n*,<=*m*<=≤<=5·105) — the number of experienced participants and newbies that are present at the training session.",Print the maximum number of teams that can be formed.,"['2 6\n', '4 5\n']","['2\n', '3\n']","Let's represent the experienced players as XP and newbies as NB.

In the first test the teams look as follows: (XP, NB, NB), (XP, NB, NB).

In the second test sample the teams look as follows: (XP, NB, NB), (XP, NB, NB), (XP, XP, NB).",COMPILATION_ERROR,"//

using namespace std;

void solve () {
	int n, m; cin >> n >> m;
	
	int ans = 0;
	for (int i = 0; i <= n; i++) {
		if (m - 2 * i >= 0) {
			ans = max(ans, i + min((n - i) / 2, m - 2 * i));
		}
	}
	debug(ans);
}

signed main () {
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	
	int t = 1;
//	cin >> t;
	while (t--) {
		solve();
	}
}","def max_teams(n, m):

    total_people = n + m

    max_possible_teams = total_people // 3

    max_teams_count = min(max_possible_teams, n, m // 2)
    
    return max_teams_count

def main():
    results = []

    input_data = ['2 6\n', '4 5\n']
    for line in input_data:
        n, m = map(int, line.strip().split())

        results.append(f""{max_teams(n, m)}\n"")

    print("""".join(results))

if __name__ == ""__main__"":
    main()"
791,A,Bear and Big Brother,PROGRAMMING,['implementation'],"Bear Limak wants to become the largest of bears, or at least to become larger than his brother Bob.

Right now, Limak and Bob weigh *a* and *b* respectively. It's guaranteed that Limak's weight is smaller than or equal to his brother's weight.

Limak eats a lot and his weight is tripled after every year, while Bob's weight is doubled after every year.

After how many full years will Limak become strictly larger (strictly heavier) than Bob?",The only line of the input contains two integers *a* and *b* (1<=≤<=*a*<=≤<=*b*<=≤<=10) — the weight of Limak and the weight of Bob respectively.,"Print one integer, denoting the integer number of years after which Limak will become strictly larger than Bob.","['4 7\n', '4 9\n', '1 1\n']","['2\n', '3\n', '1\n']","In the first sample, Limak weighs 4 and Bob weighs 7 initially. After one year their weights are 4·3 = 12 and 7·2 = 14 respectively (one weight is tripled while the other one is doubled). Limak isn't larger than Bob yet. After the second year weights are 36 and 28, so the first weight is greater than the second one. Limak became larger than Bob after two years so you should print 2.

In the second sample, Limak's and Bob's weights in next years are: 12 and 18, then 36 and 36, and finally 108 and 72 (after three years). The answer is 3. Remember that Limak wants to be larger than Bob and he won't be satisfied with equal weights.

In the third sample, Limak becomes larger than Bob after the first year. Their weights will be 3 and 2 then.",MEMORY_LIMIT_EXCEEDED,"def eat(L, B):
    years = 0
    while L < B:
        L = L * 3
        B = B * 2
        years += 1
    return (years)

Limak, Bob = input().split()

print (eat(Limak, Bob))","a, b = map(int, input().split())

years = 0

while a <= b:
    a *= 3
    b *= 2
    years += 1

print(years)"
33,A,What is for dinner?,PROGRAMMING,"['greedy', 'implementation']","In one little known, but very beautiful country called Waterland, lives a lovely shark Valerie. Like all the sharks, she has several rows of teeth, and feeds on crucians. One of Valerie's distinguishing features is that while eating one crucian she uses only one row of her teeth, the rest of the teeth are ""relaxing"".

For a long time our heroine had been searching the sea for crucians, but a great misfortune happened. Her teeth started to ache, and she had to see the local dentist, lobster Ashot. As a professional, Ashot quickly relieved Valerie from her toothache. Moreover, he managed to determine the cause of Valerie's developing caries (for what he was later nicknamed Cap).

It turned that Valerie eats too many crucians. To help Valerie avoid further reoccurrence of toothache, Ashot found for each Valerie's tooth its residual viability. Residual viability of a tooth is a value equal to the amount of crucians that Valerie can eat with this tooth. Every time Valerie eats a crucian, viability of all the teeth used for it will decrease by one. When the viability of at least one tooth becomes negative, the shark will have to see the dentist again. 

Unhappy, Valerie came back home, where a portion of crucians was waiting for her. For sure, the shark couldn't say no to her favourite meal, but she had no desire to go back to the dentist. That's why she decided to eat the maximum amount of crucians from the portion but so that the viability of no tooth becomes negative. 

As Valerie is not good at mathematics, she asked you to help her to find out the total amount of crucians that she can consume for dinner.

We should remind you that while eating one crucian Valerie uses exactly one row of teeth and the viability of each tooth from this row decreases by one.","The first line contains three integers *n*, *m*, *k* (1<=≤<=*m*<=≤<=*n*<=≤<=1000,<=0<=≤<=*k*<=≤<=106) — total amount of Valerie's teeth, amount of tooth rows and amount of crucians in Valerie's portion for dinner. Then follow *n* lines, each containing two integers: *r* (1<=≤<=*r*<=≤<=*m*) — index of the row, where belongs the corresponding tooth, and *c* (0<=≤<=*c*<=≤<=106) — its residual viability.

It's guaranteed that each tooth row has positive amount of teeth.",In the first line output the maximum amount of crucians that Valerie can consume for dinner.,"['4 3 18\n2 3\n1 2\n3 6\n2 3\n', '2 2 13\n1 13\n2 12\n']","['11\n', '13\n']",none,RUNTIME_ERROR,"import os
import sys

import numpy as np
import torch
import torch.nn as nn
import torch.nn.functional as F
from torch.autograd import Variable

sys.path.append(os.path.dirname(os.path.abspath(__file__)))
from utils import to_one_hot, mixup_process, get_lambda
from load_data import per_image_standardization
import random

class PreActBlock(nn.Module):
    '''Pre-activation version of the BasicBlock.'''
    expansion = 1
    
    def __init__(self, in_planes, planes, stride=1):
        super(PreActBlock, self).__init__()
        self.bn1 = nn.BatchNorm2d(in_planes)
        self.conv1 = nn.Conv2d(in_planes, planes, kernel_size=3, stride=stride, padding=1, bias=False)
        self.bn2 = nn.BatchNorm2d(planes)
        self.conv2 = nn.Conv2d(planes, planes, kernel_size=3, stride=1, padding=1, bias=False)
        
        if stride != 1 or in_planes != self.expansion * planes:
            self.shortcut = nn.Sequential(
                nn.Conv2d(in_planes, self.expansion * planes, kernel_size=1, stride=stride, bias=False)
            )
    
    def forward(self, x):
        out = F.relu(self.bn1(x))
        shortcut = self.shortcut(out) if hasattr(self, 'shortcut') else x
        out = self.conv1(out)
        out = self.conv2(F.relu(self.bn2(out)))
        out += shortcut
        return out

class PreActBottleneck(nn.Module):
    '''Pre-activation version of the original Bottleneck module.'''
    expansion = 4
    
    def __init__(self, in_planes, planes, stride=1):
        super(PreActBottleneck, self).__init__()
        self.bn1 = nn.BatchNorm2d(in_planes)
        self.conv1 = nn.Conv2d(in_planes, planes, kernel_size=1, bias=False)
        self.bn2 = nn.BatchNorm2d(planes)
        self.conv2 = nn.Conv2d(planes, planes, kernel_size=3, stride=stride, padding=1, bias=False)
        self.bn3 = nn.BatchNorm2d(planes)
        self.conv3 = nn.Conv2d(planes, self.expansion * planes, kernel_size=1, bias=False)
        
        if stride != 1 or in_planes != self.expansion * planes:
            self.shortcut = nn.Sequential(
                nn.Conv2d(in_planes, self.expansion * planes, kernel_size=1, stride=stride, bias=False)
            )
    
    def forward(self, x):
        out = F.relu(self.bn1(x))
        shortcut = self.shortcut(out) if hasattr(self, 'shortcut') else x
        out = self.conv1(out)
        out = self.conv2(F.relu(self.bn2(out)))
        out = self.conv3(F.relu(self.bn3(out)))
        out += shortcut
        return out

class PreActResNet(nn.Module):
    def __init__(self, block, num_blocks, initial_channels, num_classes, device, per_img_std=False, stride=1):
        super(PreActResNet, self).__init__()
        self.in_planes = initial_channels
        self.num_classes = num_classes
        self.per_img_std = per_img_std
        self.device = device

        self.conv1 = nn.Conv2d(3, initial_channels, kernel_size=3, stride=stride, padding=1, bias=False)
        self.layer1 = self._make_layer(block, initial_channels, num_blocks[0], stride=1)
        self.layer2 = self._make_layer(block, initial_channels * 2, num_blocks[1], stride=2)
        self.layer3 = self._make_layer(block, initial_channels * 4, num_blocks[2], stride=2)
        self.layer4 = self._make_layer(block, initial_channels * 8, num_blocks[3], stride=2)
        self.linear = nn.Linear(initial_channels * 8 * block.expansion, num_classes)
    
    def _make_layer(self, block, planes, num_blocks, stride):
        strides = [stride] + [1] * (num_blocks - 1)
        layers = []
        for stride in strides:
            layers.append(block(self.in_planes, planes, stride))
            self.in_planes = planes * block.expansion
        return nn.Sequential(*layers)
    
    def compute_h1(self, x):
        out = x
        out = self.conv1(out)
        out = self.layer1(out)
        return out
    
    def compute_h2(self, x):
        out = x
        out = self.conv1(out)
        out = self.layer1(out)
        out = self.layer2(out)
        return out
    
    def forward(self, x, target=None, mixup=False, mixup_hidden=False, mixup_alpha=None):

        if self.per_img_std:
            x = per_image_standardization(x)
        
        if mixup_hidden:
            layer_mix = random.randint(0, 2)
        elif mixup:
            layer_mix = 0
        else:
            layer_mix = None
        
        out = x
        
        if mixup_alpha is not None:
            lam = get_lambda(mixup_alpha)
            lam = torch.from_numpy(np.array([lam]).astype('float32')).to(self.device)
            lam = Variable(lam)
        
        if target is not None:
            target_reweighted = to_one_hot(target, self.num_classes, device=self.device)
        
        if layer_mix == 0:
            out, target_reweighted = mixup_process(out, target_reweighted, lam=lam)
        
        out = self.conv1(out)
        out = self.layer1(out)
        
        if layer_mix == 1:
            out, target_reweighted = mixup_process(out, target_reweighted, lam=lam)
        
        out = self.layer2(out)
        
        if layer_mix == 2:
            out, target_reweighted = mixup_process(out, target_reweighted, lam=lam)
        
        out = self.layer3(out)
        if layer_mix == 3:
            out, target_reweighted = mixup_process(out, target_reweighted, lam=lam)
        
        out = self.layer4(out)
        out = F.avg_pool2d(out, 4)
        out = out.view(out.size(0), -1)
        out = self.linear(out)
        
        if target is not None:
            return out, target_reweighted
        else:
            return out

def preactresnet18(num_classes=10, dropout=False, device='cpu', per_img_std=False, stride=1):
    return PreActResNet(PreActBlock, [2, 2, 2, 2], 64, num_classes, device=device, per_img_std=per_img_std,
                        stride=stride)

def preactresnet34(num_classes=10, dropout=False, device='cpu', per_img_std=False, stride=1):
    return PreActResNet(PreActBlock, [3, 4, 6, 3], 64, num_classes, device='cpu', per_img_std=per_img_std,
                        stride=stride)

def preactresnet50(num_classes=10, dropout=False, device='cpu', per_img_std=False, stride=1):
    return PreActResNet(PreActBottleneck, [3, 4, 6, 3], 64, num_classes, device='cpu', per_img_std=per_img_std,
                        stride=stride)

def preactresnet101(num_classes=10, dropout=False, device='cpu', per_img_std=False, stride=1):
    return PreActResNet(PreActBottleneck, [3, 4, 23, 3], 64, num_classes, device='cpu', per_img_std=per_img_std,
                        stride=stride)

def preactresnet152(num_classes=10, dropout=False, device='cpu', per_img_std=False, stride=1):
    return PreActResNet(PreActBottleneck, [3, 8, 36, 3], 64, num_classes, device='cpu', per_img_std=per_img_std,
                        stride=stride)

def test():
    net = preactresnet152(True, 10)
    y = net(Variable(torch.randn(1, 3, 32, 32)))
    print(y.size())

if __name__ == ""__main__"":
    test()","def max_crucians(n, m, k, teeth):

    viability = [float('inf')] * (m + 1)

    for row, viab in teeth:
        viability[row] = min(viability[row], viab)

    max_crucians_possible = min(viability[1:m + 1])

    return min(max_crucians_possible, k)

def main():
    import sys
    input = sys.stdin.read
    data = input().strip().split('\n')

    results = []
    i = 0

    while i < len(data):
        n, m, k = map(int, data[i].split())
        i += 1
        teeth = []

        for _ in range(n):
            row, viability = map(int, data[i].split())
            teeth.append((row, viability))
            i += 1

        result = max_crucians(n, m, k, teeth)
        results.append(result)

    for res in results:
        print(res)

if __name__ == ""__main__"":
    main()"
26,A,Almost Prime,PROGRAMMING,['number theory'],"A number is called almost prime if it has exactly two distinct prime divisors. For example, numbers 6, 18, 24 are almost prime, while 4, 8, 9, 42 are not. Find the amount of almost prime numbers which are between 1 and *n*, inclusive.",Input contains one integer number *n* (1<=≤<=*n*<=≤<=3000).,"Output the amount of almost prime numbers between 1 and *n*, inclusive.","['10\n', '21\n']","['2\n', '8\n']",none,OK,"def count_primes(num):

    count = 0

    for divisor in range(2, int(num**0.5)+1):
        if num % divisor == 0: count += 1

        while num % divisor == 0:
            num /= divisor
    
    if num > 1: count += 1

    return count

def count_almost_primes(num):
    count = 0
    for num in range(1, num+1):
        if count_primes(num) == 2: count += 1
    return count

def main():
    num = int(input())
    print(count_almost_primes(num))

main()","def is_prime(num):
    """"""Check if a number is a prime.""""""
    if num <= 1:
        return False
    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            return False
    return True

def count_almost_primes(n):
    """"""Count almost prime numbers up to n.""""""
    almost_prime_count = 0

    for i in range(1, n + 1):
        distinct_prime_factors = set()

        for j in range(2, i + 1):
            if i % j == 0 and is_prime(j):
                distinct_prime_factors.add(j)

        if len(distinct_prime_factors) == 2:
            almost_prime_count += 1

    return almost_prime_count

demo_inputs = [10, 21]

results = [count_almost_primes(n) for n in demo_inputs]
for result in results:
    print(result)"
492,C,Vanya and Exams,PROGRAMMING,"['greedy', 'sortings']","Vanya wants to pass *n* exams and get the academic scholarship. He will get the scholarship if the average grade mark for all the exams is at least *avg*. The exam grade cannot exceed *r*. Vanya has passed the exams and got grade *a**i* for the *i*-th exam. To increase the grade for the *i*-th exam by 1 point, Vanya must write *b**i* essays. He can raise the exam grade multiple times.

What is the minimum number of essays that Vanya needs to write to get scholarship?","The first line contains three integers *n*, *r*, *avg* (1<=≤<=*n*<=≤<=105, 1<=≤<=*r*<=≤<=109, 1<=≤<=*avg*<=≤<=*min*(*r*,<=106)) — the number of exams, the maximum grade and the required grade point average, respectively.

Each of the following *n* lines contains space-separated integers *a**i* and *b**i* (1<=≤<=*a**i*<=≤<=*r*, 1<=≤<=*b**i*<=≤<=106).",In the first line print the minimum number of essays.,"['5 5 4\n5 2\n4 7\n3 1\n3 2\n2 5\n', '2 5 4\n5 2\n5 2\n']","['4\n', '0\n']","In the first sample Vanya can write 2 essays for the 3rd exam to raise his grade by 2 points and 2 essays for the 4th exam to raise his grade by 1 point.

In the second sample, Vanya doesn't need to write any essays as his general point average already is above average.",OK,"def solve(a, b, r, avg):
    diff = max(0, len(a) * avg - sum(a))
    
    sorted_indices = sorted(range(len(a)), key=lambda i: b[i])
    
    result = 0
    index = 0
    while diff != 0:
        raise_num = min(diff, r - a[sorted_indices[index]])
        result += raise_num * b[sorted_indices[index]]
        
        diff -= raise_num
        index += 1
    
    return result

def main():
    n, r, avg = map(int, input().split())
    a = []
    b = []
    for i in range(n):
        ai, bi = map(int, input().split())
        a.append(ai)
        b.append(bi)
    
    print(solve(a, b, r, avg))

if __name__ == ""__main__"":
    main()","def min_essays_for_scholarship(n, r, avg, exams):
    total_current = sum(a for a, _ in exams)
    required_total = avg * n

    if total_current >= required_total:
        return 0

    essays_needed = 0
    deficit = required_total - total_current

    improvements = [(r - a, b) for a, b in exams if a < r]

    improvements.sort(key=lambda x: x[1])

    for points, essays_per_point in improvements:
        if deficit <= 0:
            break

        max_possible_increase = min(points, deficit)
        essays_needed += max_possible_increase * essays_per_point
        deficit -= max_possible_increase

    return essays_needed

import sys
input = sys.stdin.read
data = input().splitlines()

n, r, avg = map(int, data[0].split())
exams = [tuple(map(int, line.split())) for line in data[1:n + 1]]

result = min_essays_for_scholarship(n, r, avg, exams)
print(result)"
0,none,none,none,['none'],"You are given two squares, one with sides parallel to the coordinate axes, and another one with sides at 45 degrees to the coordinate axes. Find whether the two squares intersect.

The interior of the square is considered to be part of the square, i.e. if one square is completely inside another, they intersect. If the two squares only share one common point, they are also considered to intersect.","The input data consists of two lines, one for each square, both containing 4 pairs of integers. Each pair represents coordinates of one vertex of the square. Coordinates within each line are either in clockwise or counterclockwise order.

The first line contains the coordinates of the square with sides parallel to the coordinate axes, the second line contains the coordinates of the square at 45 degrees.

All the values are integer and between $-100$ and $100$.","Print ""Yes"" if squares intersect, otherwise print ""No"".

You can print each letter in any case (upper or lower).","['0 0 6 0 6 6 0 6\n1 3 3 5 5 3 3 1\n', '0 0 6 0 6 6 0 6\n7 3 9 5 11 3 9 1\n', '6 0 6 6 0 6 0 0\n7 4 4 7 7 10 10 7\n']","['YES\n', 'NO\n', 'YES\n']","In the first example the second square lies entirely within the first square, so they do intersect.

In the second sample squares do not have any points in common.

Here are images corresponding to the samples:",WRONG_ANSWER,"def sor(s):
    ind=-1
    x=1000
    y=x
    for i in range(4):
        if s[i][0]+s[i][1]<x or (x==s[i][0]+s[i][1] and y>s[i][0]):
            ind=i
            x=s[i][0]+s[i][1]
            y=s[i][0]
    s=s[ind::]+s[0:ind]
    return s
def inn(s,s1):
    x=s[0][0];x1=s[2][0];y=s[0][1];y1=s[1][1]
    c1=min(s[0][0],s[1][0],s[2][0],s[3][0])
    c2=max(s[0][0],s[1][0],s[2][0],s[3][0])
    c3=min(s[0][1],s[1][1],s[2][1],s[3][1])
    c4=max(s[0][1],s[1][1],s[2][1],s[3][1])
    c=[c1+abs(c2-c1),c3+abs(c4-c3)]
    t=False
    for i in s1:
        if i[0]>=x and i[0]<=x1 and i[1]>=y and i[1]<=y1:
            t=True
            break
    if c[0]>=x and c[0]<=x1 and c[1]>=y and c[1]<=y1:
            t=True
    return t
def conv(s):
    for i in range(4):
        x=s[i][0]
        y=s[i][1]
        s[i][0]=x+y
        s[i][1]=x-y
    return s

aux=list(map(int,input().split()))
s=[]
for i in range(0,8,2):
    s.append([aux[i],aux[i+1]])
aux=list(map(int,input().split()))
s1=[]
for i in range(0,8,2):
    s1.append([aux[i],aux[i+1]])
s1=sor(s1)
s=sor(s)
t=False
if s[0][0]==s[-1][0]:
    t=True
if t:
    t1=inn(s,s1)
    s=sor(conv(s))
    s1=sor(conv(s1))
    t2=inn(s1,s)
else:
    t1=inn(s1,s)
    s=sor(conv(s))
    s1=sor(conv(s1))
    t2=inn(s,s1)
if t1 or t2:
    print(""YES"")
else:
    print(""NO"")","def parse_square(line):

    coordinates = list(map(int, line.strip().split()))
    return [(coordinates[i], coordinates[i + 1]) for i in range(0, len(coordinates), 2)]

def is_point_in_square(px, py, square):

    x_min = min(v[0] for v in square)
    x_max = max(v[0] for v in square)
    y_min = min(v[1] for v in square)
    y_max = max(v[1] for v in square)
    return x_min <= px <= x_max and y_min <= py <= y_max

def is_square_inside(square1, square2):

    return all(is_point_in_square(x, y, square2) for x, y in square1)

def square_corners(square):

    corners = []
    for x, y in square:
        corners.append((x - (y - square[0][1]), y + (x - square[0][0])))
        corners.append((x + (y - square[0][1]), y - (x - square[0][0])))
    return corners

def do_squares_intersect(square1, square2):

    if is_square_inside(square1, square2) or is_square_inside(square2, square1):
        return True

    new_square2 = square_corners(square2)

    for x, y in new_square2:
        if is_point_in_square(x, y, square1):
            return True

    for x, y in square1:
        if is_point_in_square(x, y, new_square2):
            return True

    return False

square1_input = input()
square2_input = input()

square1 = parse_square(square1_input)
square2 = parse_square(square2_input)

if do_squares_intersect(square1, square2):
    print(""YES"")
else:
    print(""NO"")"
230,B,T-primes,PROGRAMMING,"['binary search', 'implementation', 'math', 'number theory']","We know that prime numbers are positive integers that have exactly two distinct positive divisors. Similarly, we'll call a positive integer *t* Т-prime, if *t* has exactly three distinct positive divisors.

You are given an array of *n* positive integers. For each of them determine whether it is Т-prime or not.","The first line contains a single positive integer, *n* (1<=≤<=*n*<=≤<=105), showing how many numbers are in the array. The next line contains *n* space-separated integers *x**i* (1<=≤<=*x**i*<=≤<=1012).

Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is advised to use the cin, cout streams or the %I64d specifier.","Print *n* lines: the *i*-th line should contain ""YES"" (without the quotes), if number *x**i* is Т-prime, and ""NO"" (without the quotes), if it isn't.",['3\n4 5 6\n'],['YES\nNO\nNO\n'],"The given test has three numbers. The first number 4 has exactly three divisors — 1, 2 and 4, thus the answer for this number is ""YES"". The second number 5 has two divisors (1 and 5), and the third number 6 has four divisors (1, 2, 3, 6), hence the answer for them is ""NO"".",TIME_LIMIT_EXCEEDED,"from math import sqrt

def primer(m: int):
    primes = [2]
    for i in range(3, m + 1, 2):
        prime = True
        for j in primes:
            if i % j == 0:
                prime = False
                break
        if prime:
            primes.append(i)
    return primes

def main():
    input()
    list_of_numbers = tuple(map(lambda x: int(sqrt(int(x))) if sqrt(int(x)).is_integer() else 1, input().split()))
    max_val = max(list_of_numbers)
    primes = primer(max_val)
    for i in list_of_numbers:
        if i == 1:
            print(""NO"")
        else:
            if i in primes:
                print(""YES"")
            else:
                print(""NO"")

if __name__ == '__main__':
    main()","import sys
import math

def is_t_prime(num):

    if num < 4:
        return False
    root = int(math.isqrt(num))

    return root * root == num and is_prime(root)

def is_prime(num):

    if num <= 1:
        return False
    if num <= 3:
        return True
    if num % 2 == 0 or num % 3 == 0:
        return False
    i = 5
    while i * i <= num:
        if num % i == 0 or num % (i + 2) == 0:
            return False
        i += 6
    return True

def main():
    input_data = sys.stdin.read().strip().split('\n')
    n = int(input_data[0])
    nums = list(map(int, input_data[1].split()))
    
    results = []
    for num in nums:
        if is_t_prime(num):
            results.append(""YES"")
        else:
            results.append(""NO"")
    
    print(""\n"".join(results))

if __name__ == ""__main__"":
    main()"
305,B,Continued Fractions,PROGRAMMING,"['brute force', 'implementation', 'math']","A continued fraction of height *n* is a fraction of form . You are given two rational numbers, one is represented as  and the other one is represented as a finite fraction of height *n*. Check if they are equal.","The first line contains two space-separated integers *p*,<=*q* (1<=≤<=*q*<=≤<=*p*<=≤<=1018) — the numerator and the denominator of the first fraction.

The second line contains integer *n* (1<=≤<=*n*<=≤<=90) — the height of the second fraction. The third line contains *n* space-separated integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=1018) — the continued fraction.

Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.","Print ""YES"" if these fractions are equal and ""NO"" otherwise.","['9 4\n2\n2 4\n', '9 4\n3\n2 3 1\n', '9 4\n3\n1 2 4\n']","['YES\n', 'YES\n', 'NO\n']","In the first sample <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/5ff92f27aebea2560d99ad61202d20bab5ee5390.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>.

In the second sample <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/221368c79c05fc0ecad4e5f7a64f30b832fd99f5.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>.

In the third sample <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/4fb4b411afc0fbad27a1c8fdd08ba88ec3830ef5.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>.",OK,"from fractions import gcd
p,q=map(int,input().split())
gc=gcd(p,q)
p//=gc
q//=gc
n=int(input())
a=list(map(int,input().split()))
def add(a,b):
    res=[]
    a[0]*=b[1]
    b[0]*=a[1]
    temp=b[1]*a[1]
    top=a[0]+b[0]
    gc=gcd(top,temp)
    temp//=gc
    top//=gc;
    res.append(top)
    res.append(temp)
    return res
def go(i):
    res=[]
    if i==n-1:
        res.append(a[i])
        res.append(1)
        return res;    
    temp=list(go(i+1))
    temp=temp[::-1]
    ta=[]
    ta.append(a[i])
    ta.append(1)
    temp=add(ta,temp)
    return temp
res=go(0)
if(res[0]==p and res[1]==q): print(""YES"")
else:
    print(""NO"")","def gcd(a, b):

    while b:
        a, b = b, a % b
    return a

def continued_fraction_to_fraction(a):

    if len(a) == 0:
        return (0, 1)
    numerator = 1
    denominator = a[-1]

    for x in reversed(a[:-1]):
        numerator, denominator = denominator, x * denominator + numerator

    return (denominator, numerator)

def fractions_are_equal(p, q, n, a):

    common = gcd(p, q)
    p //= common
    q //= common

    a_fraction = continued_fraction_to_fraction(a)

    a_common = gcd(a_fraction[0], a_fraction[1])
    a_fraction = (a_fraction[0] // a_common, a_fraction[1] // a_common)

    return a_fraction == (p, q)

input_data = input().strip().split(""\n"")
p, q = map(int, input_data[0].strip().split())
n = int(input_data[1].strip())
a = list(map(int, input_data[2].strip().split()))

if fractions_are_equal(p, q, n, a):
    print(""YES"")
else:
    print(""NO"")"
93,E,Lostborn,PROGRAMMING,"['dp', 'math', 'number theory']","Igor K. very much likes a multiplayer role playing game WineAge II. Who knows, perhaps, that might be the reason for his poor performance at the university. As any person who plays the game, he is interested in equipping his hero with as good weapon and outfit as possible. 

One day, as he was reading the game's forum yet again, he discovered a very interesting fact. As it turns out, each weapon in the game is characterised with *k* different numbers: *a*1,<=...,<=*a**k*. They are called hit indicators and according to the game developers' plan they are pairwise coprime. 

The damage that is inflicted during a hit depends not only on the weapon's characteristics, but also on the hero's strength parameter. Thus, if the hero's strength equals *n*, than the inflicted damage will be calculated as the number of numbers on the segment , that aren't divisible by any hit indicator *a**i*.

Recently, having fulfilled another quest, Igor K. found a new Lostborn sword. He wants to know how much damage he will inflict upon his enemies if he uses it.","The first line contains two integers: *n* and *k* (1<=≤<=*n*<=≤<=1013, 1<=≤<=*k*<=≤<=100). They are the indicator of Igor K's hero's strength and the number of hit indicators.

The next line contains space-separated *k* integers *a**i* (1<=≤<=*a**i*<=≤<=1000). They are Lostborn sword's hit indicators. The given *k* numbers are pairwise coprime.","Print the single number — the damage that will be inflicted by Igor K.'s hero when he uses his new weapon. 

Please, do not use the %lld specificator to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specificator.","['20 3\n2 3 5\n', '50 2\n15 8\n']","['6\n', '41\n']",none,TIME_LIMIT_EXCEEDED,"import math
iin,k = [int(x) for x in input().split(' ')]
a = [int(x) for x in input().split(' ')]
a.sort(reverse = True)
def c(n,y):
    if y == len(a)-1:
        return n-math.floor(n/a[-1])
    elif n < a[-1]:
        return n
    else:
        return c(n,y+1)-c(math.floor(n/a[y]),y+1)
if a[-1] == 1:
    print('0')
else:
    print(c(iin,0))","def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

def lcm(a, b):
    return a * b // gcd(a, b)

def count_non_divisible(n, a):
    from itertools import combinations
    
    k = len(a)
    total_count = 0

    for i in range(1, 1 << k):
        bits = bin(i).count(""1"")
        sign = -1 if bits % 2 == 0 else 1
        product = 1
        
        for j in range(k):
            if i & (1 << j):
                product = lcm(product, a[j])
                if product > n:
                    break
        
        if product <= n:
            total_count += sign * (n // product)

    damage = n - total_count
    return damage

n, k = map(int, input().split())
a = list(map(int, input().split()))

damage = count_non_divisible(n, a)

print(damage)"
435,B,Pasha Maximizes,PROGRAMMING,['greedy'],"Pasha has a positive integer *a* without leading zeroes. Today he decided that the number is too small and he should make it larger. Unfortunately, the only operation Pasha can do is to swap two adjacent decimal digits of the integer.

Help Pasha count the maximum number he can get if he has the time to make at most *k* swaps.",The single line contains two integers *a* and *k* (1<=≤<=*a*<=≤<=1018; 0<=≤<=*k*<=≤<=100).,Print the maximum number that Pasha can get if he makes at most *k* swaps.,"['1990 1\n', '300 0\n', '1034 2\n', '9090000078001234 6\n']","['9190\n', '300\n', '3104\n', '9907000008001234\n']",none,WRONG_ANSWER,"a, b = map(int, input().split())
num=[int(x) for x in str(a)]
k=0
yup=num
def f(o):
    x=o
    global b
    global k
    p=0
    if x.index(max(x))<=b:
        while max(x)!=x[0]:
            l = x.index(max(x))
            x[l-1], x[l] = x[l], x[l-1]
        k=b
        return x
    else:
        return x
num1=f(yup)

for i in range(len(num)-1):
    for j in range(len(num)-i-1):
        if k <= b:
            num = num
        while k<b:
            if num[j] < num[j + 1]:
                num[j], num[j + 1] = num[j + 1], num[j]
                k+=1
                j=0
            if num[j] > num[j+1]:
                j+=1
            if num[j] == num[j+1]:
                j+=1

num = max(num, num1)

print(''.join(map(str, num)))","def max_number_after_swaps(a_str, k):

    digits = list(a_str)
    n = len(digits)

    for i in range(n):

        if k == 0:
            break

        max_digit = digits[i]
        max_index = i
        for j in range(i + 1, min(n, i + k + 1)):
            if digits[j] > max_digit:
                max_digit = digits[j]
                max_index = j

        while max_index > i and k > 0:

            digits[max_index], digits[max_index - 1] = digits[max_index - 1], digits[max_index]
            max_index -= 1
            k -= 1

    return ''.join(digits)

input_data = ['1990 1\n', '300 0\n', '1034 2\n', '9090000078001234 6\n']
output_data = []

for line in input_data:
    a, k = line.strip().split()
    k = int(k)

    result = max_number_after_swaps(a, k)
    output_data.append(result)

print('\n'.join(output_data))"
137,A,Postcards and photos,PROGRAMMING,['implementation'],"Polycarpus has postcards and photos hung in a row on the wall. He decided to put them away to the closet and hang on the wall a famous painter's picture. Polycarpus does it like that: he goes from the left to the right and removes the objects consecutively. As Polycarpus doesn't want any mix-ups to happen, he will not carry in his hands objects of two different types. In other words, Polycarpus can't carry both postcards and photos simultaneously. Sometimes he goes to the closet and puts the objects there, thus leaving his hands free. Polycarpus must put all the postcards and photos to the closet. He cannot skip objects. What minimum number of times he should visit the closet if he cannot carry more than 5 items?","The only line of the input data contains a non-empty string consisting of letters ""С"" and ""P"" whose length does not exceed 100 characters. If the *i*-th character in the string is the letter ""С"", that means that the *i*-th object (the numbering goes from the left to the right) on Polycarpus' wall is a postcard. And if the *i*-th character is the letter ""P"", than the *i*-th object on the wall is a photo.",Print the only number — the minimum number of times Polycarpus has to visit the closet.,"['CPCPCPC\n', 'CCCCCCPPPPPP\n', 'CCCCCCPPCPPPPPPPPPP\n', 'CCCCCCCCCC\n']","['7\n', '4\n', '6\n', '2\n']","In the first sample Polycarpus needs to take one item to the closet 7 times.

In the second sample Polycarpus can first take 3 postcards to the closet; then 3 more. He can take the 6 photos that are left in the similar way, going to the closet twice.

In the third sample Polycarpus can visit the closet twice, both times carrying 3 postcards. Then he can take there 2 photos at once, then one postcard and finally, he can carry the last 10 photos if he visits the closet twice.

In the fourth sample Polycarpus can visit the closet twice and take there all 10 postcards (5 items during each go).",WRONG_ANSWER,"""""""
Created on Tue Apr  7 02:29:32 2020

@author: alexi
""""""

def post_cards():
    
    string = input()
    
    dic = {'C':0,'P':0}
    
    output = 0
    aux = string[0]
    for i in range(len(string)):
        if string[i] != aux:
            dic[aux] = 0
            dic[string[i]] = 1
            aux = string[i]
            output += 1
        else:
            dic[string[i]] += 1
            if dic[string[i]] == 5:
                dic[string[i]] = 0
                output += 1
                
    if dic['C'] > 0 and dic['P'] == 0 or dic['P'] > 0 and dic['C'] == 0:
        output += 1
        
    return output
             
A = post_cards()
print(A)","def min_visits_to_closet(s):
    count = 0
    i = 0
    length = len(s)

    while i < length:
        item = s[i]

        j = 0
        while i < length and s[i] == item:
            j += 1
            i += 1

        count += (j + 4) // 5
    
    return count

inputs = ['CPCPCPC\n', 'CCCCCCPPPPPP\n', 'CCCCCCPPCPPPPPPPPPP\n', 'CCCCCCCCCC\n']

outputs = [str(min_visits_to_closet(s.strip())) + '\n' for s in inputs]
print(outputs)"
437,C,The Child and Toy,PROGRAMMING,"['graphs', 'greedy', 'sortings']","On Children's Day, the child got a toy from Delayyy as a present. However, the child is so naughty that he can't wait to destroy the toy.

The toy consists of *n* parts and *m* ropes. Each rope links two parts, but every pair of parts is linked by at most one rope. To split the toy, the child must remove all its parts. The child can remove a single part at a time, and each remove consume an energy. Let's define an energy value of part *i* as *v**i*. The child spend *v**f*1<=+<=*v**f*2<=+<=...<=+<=*v**f**k* energy for removing part *i* where *f*1,<=*f*2,<=...,<=*f**k* are the parts that are directly connected to the *i*-th and haven't been removed.

Help the child to find out, what is the minimum total energy he should spend to remove all *n* parts.","The first line contains two integers *n* and *m* (1<=≤<=*n*<=≤<=1000; 0<=≤<=*m*<=≤<=2000). The second line contains *n* integers: *v*1,<=*v*2,<=...,<=*v**n* (0<=≤<=*v**i*<=≤<=105). Then followed *m* lines, each line contains two integers *x**i* and *y**i*, representing a rope from part *x**i* to part *y**i* (1<=≤<=*x**i*,<=*y**i*<=≤<=*n*; *x**i*<=≠<=*y**i*).

Consider all the parts are numbered from 1 to *n*.",Output the minimum total energy the child should spend to remove all *n* parts of the toy.,"['4 3\n10 20 30 40\n1 4\n1 2\n2 3\n', '4 4\n100 100 100 100\n1 2\n2 3\n2 4\n3 4\n', '7 10\n40 10 20 10 20 80 40\n1 5\n4 7\n4 5\n5 2\n5 7\n6 4\n1 6\n1 3\n4 3\n1 4\n']","['40\n', '400\n', '160\n']","One of the optimal sequence of actions in the first sample is:
 -  First, remove part 3, cost of the action is 20. -  Then, remove part 2, cost of the action is 10. -  Next, remove part 4, cost of the action is 10. -  At last, remove part 1, cost of the action is 0. 
So the total energy the child paid is 20 + 10 + 10 + 0 = 40, which is the minimum.

In the second sample, the child will spend 400 no matter in what order he will remove the parts.",RUNTIME_ERROR,"import sys

lines = sys.stdin.readlines()

nm = lines[0].strip().split("" "")
n = int(nm[0])
m = int(nm[1])
energies = lines[1].strip().split("" "")
energydict = {}
neighbours = {}

for i in range(1, len(energies)+1):
	energydict[i] = int(energies[i-1])

for line in lines[2:]:
	parts = line.strip().split("" "")
	if int(parts[0]) not in neighbours:
		neighbours[int(parts[0])] = set()
	if int(parts[1]) not in neighbours:
		neighbours[int(parts[1])] = set()
	neighbours[int(parts[0])].add(int(parts[1]))
	neighbours[int(parts[1])].add(int(parts[0]))

removecosts = []

for i in range(1, n+1):
	removecosts.append((i, neighbours[i]))

def energy(node):
	return energydict[node[0]]

def update_neighbours_and_del(node):
	for neighbour in node[1]:
		if node[0] in neighbours[neighbour]:
			neighbours[neighbour].remove(node[0])

	del neighbours[node[0]]

removecosts.sort(key=energy)

summa = 0

for i in range(len(removecosts)):
	popped = removecosts.pop()
	for neighbour in popped[1]:
		summa = summa + energydict[neighbour]

	update_neighbours_and_del(popped)

print(summa)","def min_energy_to_remove_parts(n, m, energies, connections):
    from collections import defaultdict
    import heapq

    graph = defaultdict(list)
    for x, y in connections:
        graph[x].append(y)
        graph[y].append(x)

    min_heap = []
    total_energy = 0

    removed_parts = set()

    for i in range(1, n + 1):
        heapq.heappush(min_heap, (energies[i-1], i))
    
    while min_heap:
        current_energy, part = heapq.heappop(min_heap)

        if part in removed_parts:
            continue

        cost_to_remove = current_energy

        total_energy += cost_to_remove

        removed_parts.add(part)

        for neighbor in graph[part]:
            if neighbor not in removed_parts:

                new_energy = min(energies[neighbor-1], current_energy)
                if neighbor not in removed_parts:
                    heapq.heappush(min_heap, (new_energy, neighbor))
                energies[neighbor-1] = new_energy
    
    return total_energy

def main():
    import sys
    input = sys.stdin.read
    data = input().strip().split(""\n"")
    
    results = []
    idx = 0
    while idx < len(data):
        n, m = map(int, data[idx].split())
        idx += 1
        energies = list(map(int, data[idx].split()))
        idx += 1
        connections = [tuple(map(int, data[i].split())) for i in range(idx, idx + m)]
        idx += m

        result = min_energy_to_remove_parts(n, m, energies, connections)
        results.append(result)

    for res in results:
        print(res)"
908,A,New Year and Counting Cards,PROGRAMMING,"['brute force', 'implementation']","Your friend has *n* cards.

You know that each card has a lowercase English letter on one side and a digit on the other.

Currently, your friend has laid out the cards on a table so only one side of each card is visible.

You would like to know if the following statement is true for cards that your friend owns: ""If a card has a vowel on one side, then it has an even digit on the other side."" More specifically, a vowel is one of 'a', 'e', 'i', 'o' or 'u', and even digit is one of '0', '2', '4', '6' or '8'.

For example, if a card has 'a' on one side, and '6' on the other side, then this statement is true for it. Also, the statement is true, for example, for a card with 'b' and '4', and for a card with 'b' and '3' (since the letter is not a vowel). The statement is false, for example, for card with 'e' and '5'. You are interested if the statement is true for all cards. In particular, if no card has a vowel, the statement is true.

To determine this, you can flip over some cards to reveal the other side. You would like to know what is the minimum number of cards you need to flip in the worst case in order to verify that the statement is true.","The first and only line of input will contain a string *s* (1<=≤<=|*s*|<=≤<=50), denoting the sides of the cards that you can see on the table currently. Each character of *s* is either a lowercase English letter or a digit.","Print a single integer, the minimum number of cards you must turn over to verify your claim.","['ee\n', 'z\n', '0ay1\n']","['2\n', '0\n', '2\n']","In the first sample, we must turn over both cards. Note that even though both cards have the same letter, they could possibly have different numbers on the other side.

In the second sample, we don't need to turn over any cards. The statement is vacuously true, since you know your friend has no cards with a vowel on them.

In the third sample, we need to flip the second and fourth cards.",OK,"from sys import stdin, stdout

def need_to_check(card, vowels=['a','e','i','o','u']):
    return (ord(card) >= ord('0') and ord(card) <= ord('9') and int(card) % 2 == 1) or (card in vowels)

def number_of_reveals(cards):
    count = 0
    for card in cards:
        count = count+1 if need_to_check(card) else count
    return count

stdout.write( str(number_of_reveals(stdin.readline())) +'\n')","def min_flips_to_verify(s: str) -> int:
    vowels = {'a', 'e', 'i', 'o', 'u'}
    even_digits = {'0', '2', '4', '6', '8'}
    
    flips = 0
    
    for char in s:
        if char in vowels:

            flips += 1
        elif char.isdigit() and char not in even_digits:

            flips += 1
            
    return flips

s = input().strip()

print(min_flips_to_verify(s))"
109,A,Lucky Sum of Digits,PROGRAMMING,"['brute force', 'implementation']","Petya loves lucky numbers. We all know that lucky numbers are the positive integers whose decimal representations contain only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.

Petya wonders eagerly what minimum lucky number has the sum of digits equal to *n*. Help him cope with the task.",The single line contains an integer *n* (1<=≤<=*n*<=≤<=106) — the sum of digits of the required lucky number.,"Print on the single line the result — the minimum lucky number, whose sum of digits equals *n*. If such number does not exist, print -1.","['11\n', '10\n']","['47\n', '-1\n']",none,WRONG_ANSWER,"def func(numero, soma, digitos, n, results):
    total4 = soma+4
    total7 = soma+7

    novo = numero+4*pow(10, digitos)
    if n > total4:
        func(novo, total4, digitos+1, n, results)
    elif n < total4:
        return
    else:
        results.append(novo)

    novo = numero+7*pow(10, digitos)
    if n > total7:
        func(novo, total7, digitos+1, n, results)
    elif n < total7:
        return
    else:
        results.append(novo)

n = int(input())

if n <= 17:
    results = []

    func(0, 0, 0, n, results)

    if len(results) > 0:
        results.sort()
        print(results[0])
    else:
        print(""-1"")

else:
    resultado = 0
    if n%7 == 0:
        t = int(n/7)
        for i in range(t):
            resultado += 7*pow(10, i)
    elif n%4 == 0:
        t = int(n/4)
        for i in range(t):
            resultado += 4*pow(10, i)
    else:
        resto = n%7
        t = int(n/7)
        
        if resto == 0:
            for i in range(t):
                resultado += 7*pow(10, i)
            print(resultado)
            exit()
        elif resto == 1:
            t -= 1
            x = 2
        elif resto == 2:
            t -= 2
            x = 4
        elif resto == 3:
            t -= 3
            x = 6
        elif resto == 4:
            x = 1
        elif resto == 5:
            t -= 1
            x = 3
        elif resto == 6:
            t -= 2
            x = 5
        
        for i in range(t):
            resultado += 7*pow(10, i)

        for y in range(x):
            i += 1
            resultado += 4*pow(10, i)
    
    print(resultado)","def min_lucky_number(n):

    if n == 0:
        return -1

    lucky_number = []

    while n > 0:
        if n >= 7:
            lucky_number.append('7')
            n -= 7
        elif n >= 4:
            lucky_number.append('4')
            n -= 4
        else:
            return -1

    lucky_number.sort()

    return ''.join(lucky_number)

n = int(input().strip())

result = min_lucky_number(n)
print(result)"
625,B,War of the Corporations,PROGRAMMING,"['constructive algorithms', 'greedy', 'strings']","A long time ago, in a galaxy far far away two giant IT-corporations Pineapple and Gogol continue their fierce competition. Crucial moment is just around the corner: Gogol is ready to release it's new tablet Lastus 3000.

This new device is equipped with specially designed artificial intelligence (AI). Employees of Pineapple did their best to postpone the release of Lastus 3000 as long as possible. Finally, they found out, that the name of the new artificial intelligence is similar to the name of the phone, that Pineapple released 200 years ago. As all rights on its name belong to Pineapple, they stand on changing the name of Gogol's artificial intelligence.

Pineapple insists, that the name of their phone occurs in the name of AI as a substring. Because the name of technology was already printed on all devices, the Gogol's director decided to replace some characters in AI name with ""#"". As this operation is pretty expensive, you should find the minimum number of characters to replace with ""#"", such that the name of AI doesn't contain the name of the phone as a substring.

Substring is a continuous subsequence of a string.","The first line of the input contains the name of AI designed by Gogol, its length doesn't exceed 100<=000 characters. Second line contains the name of the phone released by Pineapple 200 years ago, its length doesn't exceed 30. Both string are non-empty and consist of only small English letters.","Print the minimum number of characters that must be replaced with ""#"" in order to obtain that the name of the phone doesn't occur in the name of AI as a substring.","['intellect\ntell\n', 'google\napple\n', 'sirisiri\nsir\n']","['1', '0', '2']","In the first sample AI's name may be replaced with ""int#llect"".

In the second sample Gogol can just keep things as they are.

In the third sample one of the new possible names of AI may be ""s#ris#ri"".",OK,"x = input()
s = input()

print(x.count(s))","def min_replacements(ai_name, phone_name):
    ai_length = len(ai_name)
    phone_length = len(phone_name)

    dp = [[float('inf')] * (phone_length + 1) for _ in range(ai_length + 1)]

    for j in range(phone_length + 1):
        dp[0][j] = j

    for i in range(1, ai_length + 1):
        dp[i][0] = 0

        for j in range(1, phone_length + 1):

            if ai_name[i - 1] == phone_name[j - 1]:
                dp[i][j] = dp[i - 1][j - 1]
            else:
                dp[i][j] = min(dp[i][j], dp[i - 1][j] + 1)

            dp[i][j] = min(dp[i][j], dp[i - 1][j] + 1)

            dp[i][j] = min(dp[i][j], dp[i - 1][j - 1] + 1)

    return dp[ai_length][phone_length]

import sys

input_data = sys.stdin.read().strip().splitlines()
result = []

for i in range(0, len(input_data), 2):
    ai_name = input_data[i].strip()
    phone_name = input_data[i + 1].strip()
    result.append(str(min_replacements(ai_name, phone_name)))

print(""\n"".join(result))"
340,C,Tourist Problem,PROGRAMMING,"['combinatorics', 'implementation', 'math']","Iahub is a big fan of tourists. He wants to become a tourist himself, so he planned a trip. There are *n* destinations on a straight road that Iahub wants to visit. Iahub starts the excursion from kilometer 0. The *n* destinations are described by a non-negative integers sequence *a*1, *a*2, ..., *a**n*. The number *a**k* represents that the *k*th destination is at distance *a**k* kilometers from the starting point. No two destinations are located in the same place. 

Iahub wants to visit each destination only once. Note that, crossing through a destination is not considered visiting, unless Iahub explicitly wants to visit it at that point. Also, after Iahub visits his last destination, he doesn't come back to kilometer 0, as he stops his trip at the last destination. 

The distance between destination located at kilometer *x* and next destination, located at kilometer *y*, is |*x*<=-<=*y*| kilometers. We call a ""route"" an order of visiting the destinations. Iahub can visit destinations in any order he wants, as long as he visits all *n* destinations and he doesn't visit a destination more than once. 

Iahub starts writing out on a paper all possible routes and for each of them, he notes the total distance he would walk. He's interested in the average number of kilometers he would walk by choosing a route. As he got bored of writing out all the routes, he asks you to help him.","The first line contains integer *n* (2<=≤<=*n*<=≤<=105). Next line contains *n* distinct integers *a*1, *a*2, ..., *a**n* (1<=≤<=*a**i*<=≤<=107).",Output two integers — the numerator and denominator of a fraction which is equal to the wanted average number. The fraction must be irreducible.,['3\n2 3 5\n'],['22 3'],"Consider 6 possible routes:
 -  [2, 3, 5]: total distance traveled: |2 – 0| + |3 – 2| + |5 – 3| = 5; -  [2, 5, 3]: |2 – 0| + |5 – 2| + |3 – 5| = 7; -  [3, 2, 5]: |3 – 0| + |2 – 3| + |5 – 2| = 7; -  [3, 5, 2]: |3 – 0| + |5 – 3| + |2 – 5| = 8; -  [5, 2, 3]: |5 – 0| + |2 – 5| + |3 – 2| = 9; -  [5, 3, 2]: |5 – 0| + |3 – 5| + |2 – 3| = 8. 
The average travel distance is <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/29119d3733c79f70eb2d77186ac1606bf938508a.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> = <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/ee9d5516ed2ca1d2b65ed21f8a64f58f94954c30.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> = <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/ed5cc8cb7dd43cfb27f2459586062538e44de7bd.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>.",OK,"""""""
Created on Wed Jun  3 11:57:46 2020

@author: shailesh
""""""

from math import gcd

def reduce_fraction(x,y):
    d = gcd(x,y)
    x = x//d
    y = y//d
    return x,y

N = int(input())

A = [int(i) for i in input().split()]

A.sort()

d0 = A[0]

sum_val = 0

for i in range(N-1):
    m_bf = i+2
    m_af = N - i - 1
    d = A[i+1]-A[i]

    sum_val +=m_af*(2*m_bf - 1)*d

numerator = N*d0 + sum_val

denominator = N

numerator,denominator = reduce_fraction(numerator,denominator)

print(numerator,denominator)","from math import gcd
from functools import reduce

n = int(input().strip())
a = list(map(int, input().strip().split()))

a.sort()

total_distance = 0

for i in range(n):

    distance_from_start = a[i] * (i + 1)

    distance_between_destinations = a[i] * (n - 1 - i)
    total_distance += (distance_from_start - distance_between_destinations)

total_routes = 1
for i in range(1, n + 1):
    total_routes *= i

desired_numerator = total_distance
desired_denominator = total_routes

common_divisor = gcd(desired_numerator, desired_denominator)

print(desired_numerator // common_divisor, desired_denominator // common_divisor)"
21,A,Jabber ID,PROGRAMMING,"['implementation', 'strings']","Jabber ID on the national Berland service «Babber» has a form &lt;username&gt;@&lt;hostname&gt;[/resource], where 
 -  &lt;username&gt; — is a sequence of Latin letters (lowercase or uppercase), digits or underscores characters «_», the length of &lt;username&gt; is between 1 and 16, inclusive. -  &lt;hostname&gt; — is a sequence of word separated by periods (characters «.»), where each word should contain only characters allowed for &lt;username&gt;, the length of each word is between 1 and 16, inclusive. The length of &lt;hostname&gt; is between 1 and 32, inclusive. -  &lt;resource&gt; — is a sequence of Latin letters (lowercase or uppercase), digits or underscores characters «_», the length of &lt;resource&gt; is between 1 and 16, inclusive. 
The content of square brackets is optional — it can be present or can be absent.

There are the samples of correct Jabber IDs: [[email protected]](/cdn-cgi/l/email-protection), [[email protected]](/cdn-cgi/l/email-protection)/contest.

Your task is to write program which checks if given string is a correct Jabber ID.","The input contains of a single line. The line has the length between 1 and 100 characters, inclusive. Each characters has ASCII-code between 33 and 127, inclusive.",Print YES or NO.,"['[email\xa0protected]\n', '[email\xa0protected]/contest.icpc/12\n']","['YES\n', 'NO\n']",none,WRONG_ANSWER,"def norm(str):
    for i in range(len(str)):
        if (33<= ord(str[i])<= 127) or (ord('0')<= ord(str[i])<= ord('9')) or str[i]== '_':
            pass
        else:
            return False
        if not (0 <len(str[i])< 17): return False
    return True
def fin():
    print('NO')
    quit()
    
j= input()
j.lower()
res= ''
bool= True
bool_res= False
if '@' in j:
    user= j.split('@')[0]
    host= j.split('@')[1]
else:
    fin()
if '/' in host:
    bool_res= True
    host= host.split('/')[0]
    res= j.split('/')[-1]
    if not norm(res): fin()

if not norm(user): fin()

if not (0 <len(host)< 33): fin()

Host= host.split('.')
for i in range(len(Host)):
    if not norm(Host[i]): fin()
        
if (bool_res & (len(j)== len(user)+ len(host)+ len(res)+2)) or (len(j)== len(user)+ len(host)+ 1):
    pass
else:
    fin()

print('YES')
quit()","import re

def is_valid_jabber_id(jabber_id):

    pattern = r'^(?P<username>[A-Za-z0-9_]{1,16})@(?P<hostname>([A-Za-z0-9_]{1,16}\.)+[A-Za-z0-9_]{1,16})(/(?P<resource>[A-Za-z0-9_]{1,16}))?$'

    match = re.fullmatch(pattern, jabber_id)

    return 'YES' if match else 'NO'

jabber_id_input = input().strip()

print(is_valid_jabber_id(jabber_id_input))"
220,B,Little Elephant and Array,PROGRAMMING,"['constructive algorithms', 'data structures']","The Little Elephant loves playing with arrays. He has array *a*, consisting of *n* positive integers, indexed from 1 to *n*. Let's denote the number with index *i* as *a**i*. 

Additionally the Little Elephant has *m* queries to the array, each query is characterised by a pair of integers *l**j* and *r**j* (1<=≤<=*l**j*<=≤<=*r**j*<=≤<=*n*). For each query *l**j*,<=*r**j* the Little Elephant has to count, how many numbers *x* exist, such that number *x* occurs exactly *x* times among numbers *a**l**j*,<=*a**l**j*<=+<=1,<=...,<=*a**r**j*.

Help the Little Elephant to count the answers to all queries.","The first line contains two space-separated integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=105) — the size of array *a* and the number of queries to it. The next line contains *n* space-separated positive integers *a*1, *a*2, ..., *a**n* (1<=≤<=*a**i*<=≤<=109). Next *m* lines contain descriptions of queries, one per line. The *j*-th of these lines contains the description of the *j*-th query as two space-separated integers *l**j* and *r**j* (1<=≤<=*l**j*<=≤<=*r**j*<=≤<=*n*).",In *m* lines print *m* integers — the answers to the queries. The *j*-th line should contain the answer to the *j*-th query.,['7 2\n3 1 2 2 3 3 7\n1 7\n3 4\n'],['3\n1\n'],none,RUNTIME_ERROR,"def add(elem, count):
    count[elem] += 1
    if count[elem] == elem:
        global answer
        answer += 1

def remove(elem, count):
    count[elem] -= 1

    if count[elem] == elem-1:
        global answer
        answer -= 1

def process_queries(queries, array):
    from collections import defaultdict

    currentL = 1
    currentR = 1
    count = defaultdict(int)
    ans = {}
    for querie in queries:
        while currentL < querie[0]:
            elem = array[currentL-1]
            remove(elem, count)
            currentL += 1
        while currentL > querie[0]:
            elem = array[currentL-1]
            add(elem, count)
            currentL -= 1
        while currentR < querie[1]:
            elem = array[currentR-1]
            add(elem, count)
            currentR += 1
        while currentR > querie[1]:
            elem = array[currentR-1]
            remove(elem, count)
            currentR -= 1
        ans[querie] = answer

    return ans

def mos_algorithm(queries):
    from math import ceil, sqrt

    block_len = int(ceil(sqrt(len(queries))))
    blocks = [[] for x in range(block_len)]
    for q in queries:
        pos = q[0] // block_len
        blocks[pos].append(q)

    queries2 = [sorted(x, lambda x:x[1]) for x in blocks]
    queries2 = [item for sublist in queries2 for item in sublist]
    return queries2

if __name__ == ""__main__"":
    from sys import stdin, stdout

    answer = 0

    alist = [line.strip() for line in stdin]
    array = list(map(int, alist[1].split()))
    queries = [tuple(map(int, x.split()))for x in alist[2:]]
    sorted_queries = mos_algorithm(queries)
    ans = process_queries(sorted_queries, array)

    for q in queries:
        print(ans[q])","def count_special_numbers(n, m, a, queries):
    results = []
    
    for l, r in queries:

        sub_array = a[l-1:r]

        count_map = {}
        for num in sub_array:
            if num in count_map:
                count_map[num] += 1
            else:
                count_map[num] = 1

        special_count = 0
        for num, count in count_map.items():
            if num == count:
                special_count += 1

        results.append(special_count)

    return results

if __name__ == ""__main__"":
    n, m = map(int, input().split())
    a = list(map(int, input().split()))
    
    queries = []
    for _ in range(m):
        l, r = map(int, input().split())
        queries.append((l, r))

    answers = count_special_numbers(n, m, a, queries)

    for answer in answers:
        print(answer)"
11,D,A Simple Task,PROGRAMMING,"['bitmasks', 'dp', 'graphs']","Given a simple graph, output the number of simple cycles in it. A simple cycle is a cycle with no repeated vertices or edges.","The first line of input contains two integers *n* and *m* (1<=≤<=*n*<=≤<=19, 0<=≤<=*m*) – respectively the number of vertices and edges of the graph. Each of the subsequent *m* lines contains two integers *a* and *b*, (1<=≤<=*a*,<=*b*<=≤<=*n*, *a*<=≠<=*b*) indicating that vertices *a* and *b* are connected by an undirected edge. There is no more than one edge connecting any pair of vertices.",Output the number of cycles in the given graph.,['4 6\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4\n'],['7\n'],The example graph is a clique and contains four cycles of length 3 and three cycles of length 4.,WRONG_ANSWER,"n, m = map(int, input().split())
graph = [[] for _ in range(n)]
for i in range(m):
    a, b = map(int, input().split())
    graph[a-1].append(b-1)
    graph[b-1].append(a-1)

def dfs(vertex, visited, path):
    visited[vertex] = True
    path.append(vertex)
    count = 0
    for neighbor in graph[vertex]:
        if neighbor == path[0]:
            count += 1
        elif not visited[neighbor]:
            count += dfs(neighbor, visited, path)
    path.pop()
    visited[vertex] = False
    return count

cycles = 0
for i in range(n):
    visited = [False] * n
    cycles += dfs(i, visited, [])
print(cycles//2)","def count_cycles(graph, start, visited, path):

    if path and path[0] == start and len(path) > 2:
        return 1
    count = 0
    for neighbor in graph[start]:
        if neighbor not in visited:
            visited.add(neighbor)
            path.append(neighbor)
            count += count_cycles(graph, neighbor, visited, path)
            path.pop()
            visited.remove(neighbor)
    return count

def main():

    n, m = map(int, input().split())

    graph = {i: [] for i in range(1, n + 1)}

    for _ in range(m):
        a, b = map(int, input().split())
        graph[a].append(b)
        graph[b].append(a)
    
    total_cycles = 0

    for vertex in graph:
        visited = {vertex}
        total_cycles += count_cycles(graph, vertex, visited, [vertex])

    print(total_cycles // 2)

if __name__ == ""__main__"":
    main()"
842,C,Ilya And The Tree,PROGRAMMING,"['dfs and similar', 'graphs', 'math', 'number theory', 'trees']","Ilya is very fond of graphs, especially trees. During his last trip to the forest Ilya found a very interesting tree rooted at vertex 1. There is an integer number written on each vertex of the tree; the number written on vertex *i* is equal to *a**i*.

Ilya believes that the beauty of the vertex *x* is the greatest common divisor of all numbers written on the vertices on the path from the root to *x*, including this vertex itself. In addition, Ilya can change the number in one arbitrary vertex to 0 or leave all vertices unchanged. Now for each vertex Ilya wants to know the maximum possible beauty it can have.

For each vertex the answer must be considered independently.

The beauty of the root equals to number written on it.","First line contains one integer number *n* — the number of vertices in tree (1<=≤<=*n*<=≤<=2·105).

Next line contains *n* integer numbers *a**i* (1<=≤<=*i*<=≤<=*n*, 1<=≤<=*a**i*<=≤<=2·105).

Each of next *n*<=-<=1 lines contains two integer numbers *x* and *y* (1<=≤<=*x*,<=*y*<=≤<=*n*, *x*<=≠<=*y*), which means that there is an edge (*x*,<=*y*) in the tree.","Output *n* numbers separated by spaces, where *i*-th number equals to maximum possible beauty of vertex *i*.","['2\n6 2\n1 2\n', '3\n6 2 3\n1 2\n1 3\n', '1\n10\n']","['6 6 \n', '6 6 6 \n', '10 \n']",none,WRONG_ANSWER,"""""""
    Author      : Arif Ahmad
    Date        :
    Algo        :
    Difficulty  :
""""""
from sys import stdin, stdout, setrecursionlimit
import threading
from fractions import gcd

def dfs(u, g1, g2):
    global a, g, ans

    x1 = gcd(g1, 0)
    x2 = gcd(g2, a[u])
    ans[u] = max(x1, x2)

    g1 = gcd(g1, a[u])
    if u == 0:
        g2 = 0
    else:
        g2 = x2
    for v in g[u]:
        if ans[v] == 0:
            dfs(v, g1, g2)

def main():
    global a, n, g, ans
    n = int(stdin.readline().strip())
    a = [int(_) for _ in stdin.readline().strip().split()]

    g = [[] for _ in range(n)]
    for _ in range(n - 1):
        x, y = [int(_) for _ in stdin.readline().strip().split()]
        x -= 1
        y -= 1
        g[x].append(y)
        g[y].append(x)

    ans = [0 for _ in range(n)]

    dfs(0, a[0], a[0])

    ans = ' '.join(str(_) for _ in ans)
    stdout.write(ans)

if __name__ == '__main__':

    setrecursionlimit(10**6)
    threading.stack_size(134217728)
    thread = threading.Thread(target=main)
    thread.start()","import sys
import math
from collections import defaultdict, deque

input = sys.stdin.read

def max_beauty(n, a, edges):
    graph = defaultdict(list)

    for x, y in edges:
        graph[x].append(y)
        graph[y].append(x)

    res = [0] * n
    visited = [False] * n

    def bfs(root):
        queue = deque([(root, a[root])])
        visited[root] = True
        
        while queue:
            current, current_gcd = queue.popleft()
            res[current] = current_gcd
            
            for neighbor in graph[current]:
                if not visited[neighbor]:
                    visited[neighbor] = True

                    queue.append((neighbor, math.gcd(current_gcd, a[neighbor])))

    bfs(0)

    for i in range(n):
        res[i] = max(res[i], a[i])
    
    return res

def main():
    data = input().splitlines()
    n = int(data[0])
    a = list(map(int, data[1].split()))
    edges = [tuple(map(int, line.split())) for line in data[2:n+1]]
    
    result = max_beauty(n, a, edges)
    
    print("" "".join(map(str, result)))

if __name__ == ""__main__"":
    main()"
802,G,Fake News (easy),PROGRAMMING,"['implementation', 'strings']","As it's the first of April, Heidi is suspecting that the news she reads today are fake, and she does not want to look silly in front of all the contestants. She knows that a newspiece is fake if it contains heidi as a subsequence. Help Heidi assess whether the given piece is true, but please be discreet about it...",The first and only line of input contains a single nonempty string *s* of length at most 1000 composed of lowercase letters (a-z).,Output YES if the string *s* contains heidi as a subsequence and NO otherwise.,"['abcheaibcdi\n', 'hiedi\n']","['YES', 'NO']",A string *s* contains another string *p* as a subsequence if it is possible to delete some characters from *s* and obtain *p*.,OK,"def main():
    s = input()
    heidi = ""heidi""

    j = 0
    hasHeidi = 0

    for i in s:
        if(i == heidi[j]):
            if(j < 4):
                j += 1
            else:
                hasHeidi = 1

    if(hasHeidi == 0):
        print(""NO"")
    else:
        print(""YES"")

if __name__ == '__main__':
    main()","def is_subsequence(s, p):

    p_index = 0

    p_length = len(p)

    for char in s:

        if p_index < p_length and char == p[p_index]:
            p_index += 1

        if p_index == p_length:
            return True
    return False

input_string = input().strip()

if is_subsequence(input_string, ""heidi""):
    print(""YES"")
else:
    print(""NO"")"
2,B,The least round way,PROGRAMMING,"['dp', 'math']","There is a square matrix *n*<=×<=*n*, consisting of non-negative integer numbers. You should find such a way on it that 
 -  starts in the upper left cell of the matrix; -  each following cell is to the right or down from the current cell; -  the way ends in the bottom right cell. 
Moreover, if we multiply together all the numbers along the way, the result should be the least ""round"". In other words, it should end in the least possible number of zeros.","The first line contains an integer number *n* (2<=≤<=*n*<=≤<=1000), *n* is the size of the matrix. Then follow *n* lines containing the matrix elements (non-negative integer numbers not exceeding 109).",In the first line print the least number of trailing zeros. In the second line print the correspondent way itself.,['3\n1 2 3\n4 5 6\n7 8 9\n'],['0\nDDRR\n'],none,RUNTIME_ERROR,"""""""

created by shuangquan.huang at 1/3/20

""""""

import collections
import time
import os
import sys
import bisect
import heapq
from typing import List

N = int(input())
A = []
for i in range(N):
    row = [int(x) for x in input().split()]
    A.append(row)
    

def count(val, div):
    c = 0
    while val % div == 0:
        val //= div
        c += 1
    return c

def solve(div):
    dp = [[1000 for _ in range(N)] for _ in range(N)]
    pre = [['' for _ in range(N)] for _ in range(N)]
    dp[0][0] = count(A[0][0], div)
    for r in range(N):
        for c in range(N):
            dc = count(A[r][c], div)
            if r > 0 and dp[r-1][c] + dc < dp[r][c]:
                dp[r][c] = dp[r-1][c] + dc
                pre[r][c] = 'U'
            if c > 0 and dp[r][c-1] + dc < dp[r][c]:
                pre[r][c] = 'L'
                dp[r][c] = dp[r][c-1] + dc
    
    path = []
    r, c = N-1, N-1
    while r > 0 or c > 0:
        if pre[r][c] == 'U':
            path.append('D')
            r, c = r-1, c
        else:
            path.append('R')
            r, c = r, c-1
    
    return dp[N-1][N-1], ''.join(path[::-1])

a, b = solve(2)
c, d = solve(5)
if a < c:
    print(a)
    print(b)
else:
    print(c)
    print(d)","def count_trailing_zeros(num):
    """"""Count trailing zeros in a number.""""""
    count = 0
    while num > 0 and num % 10 == 0:
        count += 1
        num //= 10
    return count

def min_trailing_zeros_path(matrix):
    n = len(matrix)

    dp_two = [[0] * n for _ in range(n)]
    dp_five = [[0] * n for _ in range(n)]

    for i in range(n):
        for j in range(n):
            num = matrix[i][j]
            count_two = count_trailing_zeros(num) if num > 0 else 0
            count_five = 0
            while num > 0 and num % 5 == 0:
                count_five += 1
                num //= 5
            
            if i == 0 and j == 0:
                dp_two[i][j] = count_two
                dp_five[i][j] = count_five
            elif i == 0:
                dp_two[i][j] = dp_two[i][j-1] + count_two
                dp_five[i][j] = dp_five[i][j-1] + count_five
            elif j == 0:
                dp_two[i][j] = dp_two[i-1][j] + count_two
                dp_five[i][j] = dp_five[i-1][j] + count_five
            else:
                dp_two[i][j] = min(dp_two[i-1][j], dp_two[i][j-1]) + count_two
                dp_five[i][j] = min(dp_five[i-1][j], dp_five[i][j-1]) + count_five

    min_trailing_zeros = min(dp_two[n-1][n-1], dp_five[n-1][n-1])

    path = []
    x, y = n - 1, n - 1
    while x > 0 or y > 0:
        if x == 0:
            path.append('R')
            y -= 1
        elif y == 0:
            path.append('D')
            x -= 1
        else:
            if dp_two[x-1][y] < dp_two[x][y-1]:
                path.append('D')
                x -= 1
            else:
                path.append('R')
                y -= 1
    
    path.reverse()
    return min_trailing_zeros, ''.join(path)

import sys
input_data = sys.stdin.read().strip().split('\n')
n = int(input_data[0])
matrix = [list(map(int, line.split())) for line in input_data[1:n+1]]

trailing_zeros, path = min_trailing_zeros_path(matrix)

print(trailing_zeros)
print(path)"
544,B,Sea and Islands,PROGRAMMING,"['constructive algorithms', 'implementation']","A map of some object is a rectangular field consisting of *n* rows and *n* columns. Each cell is initially occupied by the sea but you can cover some some cells of the map with sand so that exactly *k* islands appear on the map. We will call a set of sand cells to be island if it is possible to get from each of them to each of them by moving only through sand cells and by moving from a cell only to a side-adjacent cell. The cells are called to be side-adjacent if they share a vertical or horizontal side. It is easy to see that islands do not share cells (otherwise they together form a bigger island).

Find a way to cover some cells with sand so that exactly *k* islands appear on the *n*<=×<=*n* map, or determine that no such way exists.","The single line contains two positive integers *n*, *k* (1<=≤<=*n*<=≤<=100, 0<=≤<=*k*<=≤<=*n*2) — the size of the map and the number of islands you should form.","If the answer doesn't exist, print ""NO"" (without the quotes) in a single line.

Otherwise, print ""YES"" in the first line. In the next *n* lines print the description of the map. Each of the lines of the description must consist only of characters 'S' and 'L', where 'S' is a cell that is occupied by the sea and 'L' is the cell covered with sand. The length of each line of the description must equal *n*.

If there are multiple answers, you may print any of them.

You should not maximize the sizes of islands.","['5 2\n', '5 25\n']","['YES\nSSSSS\nLLLLL\nSSSSS\nLLLLL\nSSSSS\n', 'NO\n']",none,OK,"import sys
input = sys.stdin.readline
read_tuple = lambda _type: map(_type, input().split(' '))

def solve():
    n, k = read_tuple(int)
    grid = [['S' for _ in range(n)] for _ in range(n)]
    flag = True
    for i in range(n):
        for j in range(n):
            if k and flag:
                grid[i][j] = 'L'
                k -= 1
            flag ^= True
        if n % 2 == 0:
            flag ^= True
    if k == 0:
        print(""YES"")
    else:
        print(""NO"")
    if k == 0:
        for row in grid:
            print(''.join(row))

if __name__ == '__main__':
    solve()","def create_islands(n, k):

    max_islands = (n * n + 1) // 2
    if k > max_islands:
        return ""NO""

    map_grid = [['S' for _ in range(n)] for _ in range(n)]
    count = 0

    for i in range(n):
        for j in range(n):

            if (i + j) % 2 == 0 and count < k:
                map_grid[i][j] = 'L'
                count += 1

    if count < k:
        return ""NO""

    output = [""YES""]
    output.extend(''.join(row) for row in map_grid)
    
    return output

import sys

input_data = sys.stdin.read().strip().split()
n, k = map(int, input_data)

result = create_islands(n, k)
if isinstance(result, list):
    print('\n'.join(result))
else:
    print(result)"
381,A,Sereja and Dima,PROGRAMMING,"['greedy', 'implementation', 'two pointers']","Sereja and Dima play a game. The rules of the game are very simple. The players have *n* cards in a row. Each card contains a number, all numbers on the cards are distinct. The players take turns, Sereja moves first. During his turn a player can take one card: either the leftmost card in a row, or the rightmost one. The game ends when there is no more cards. The player who has the maximum sum of numbers on his cards by the end of the game, wins.

Sereja and Dima are being greedy. Each of them chooses the card with the larger number during his move.

Inna is a friend of Sereja and Dima. She knows which strategy the guys are using, so she wants to determine the final score, given the initial state of the game. Help her.",The first line contains integer *n* (1<=≤<=*n*<=≤<=1000) — the number of cards on the table. The second line contains space-separated numbers on the cards from left to right. The numbers on the cards are distinct integers from 1 to 1000.,"On a single line, print two integers. The first number is the number of Sereja's points at the end of the game, the second number is the number of Dima's points at the end of the game.","['4\n4 1 2 10\n', '7\n1 2 3 4 5 6 7\n']","['12 5\n', '16 12\n']","In the first sample Sereja will take cards with numbers 10 and 2, so Sereja's sum is 12. Dima will take cards with numbers 4 and 1, so Dima's sum is 5.",OK,"from collections import defaultdict, deque, Counter
from heapq import heapify, heappop, heappush

def main():
    t = 1

    for _ in range(t):
        run_test_case()

def run_test_case():
    n = int(input())
    l = list(map(int, input().split()))
    sereja = dima = 0
    left, right = 0, n - 1
    i = 0
    while left <= right:
        curMax = max(l[left], l[right])
        if i % 2 == 0:
            sereja += curMax
        else:
            dima += curMax
        if l[left] > l[right]:
            left += 1
        else:
            right -= 1
        i += 1
    print(sereja, dima)

if __name__ == ""__main__"":
    main()
""""""
/* stuff you should look for
 * int overflow, array bounds
 * special cases (n=1?)
 * do smth instead of nothing and stay organized
 * WRITE STUFF DOWN
 * DON'T GET STUCK ON ONE APPROACH
 */
""""""","def card_game(n, cards):
    sereja_score = 0
    dima_score = 0
    left = 0
    right = n - 1
    turn_sereja = True

    while left <= right:

        if cards[left] > cards[right]:
            chosen_card = cards[left]
            left += 1
        else:
            chosen_card = cards[right]
            right -= 1

        if turn_sereja:
            sereja_score += chosen_card
        else:
            dima_score += chosen_card

        turn_sereja = not turn_sereja 

    return sereja_score, dima_score

n = int(input().strip())
cards = list(map(int, input().strip().split()))

sereja_points, dima_points = card_game(n, cards)

print(sereja_points, dima_points)"
552,A,Vanya and Table,PROGRAMMING,"['implementation', 'math']","Vanya has a table consisting of 100 rows, each row contains 100 cells. The rows are numbered by integers from 1 to 100 from bottom to top, the columns are numbered from 1 to 100 from left to right. 

In this table, Vanya chose *n* rectangles with sides that go along borders of squares (some rectangles probably occur multiple times). After that for each cell of the table he counted the number of rectangles it belongs to and wrote this number into it. Now he wants to find the sum of values in all cells of the table and as the table is too large, he asks you to help him find the result.","The first line contains integer *n* (1<=≤<=*n*<=≤<=100) — the number of rectangles.

Each of the following *n* lines contains four integers *x*1,<=*y*1,<=*x*2,<=*y*2 (1<=≤<=*x*1<=≤<=*x*2<=≤<=100, 1<=≤<=*y*1<=≤<=*y*2<=≤<=100), where *x*1 and *y*1 are the number of the column and row of the lower left cell and *x*2 and *y*2 are the number of the column and row of the upper right cell of a rectangle.",In a single line print the sum of all values in the cells of the table.,"['2\n1 1 2 3\n2 2 3 3\n', '2\n1 1 3 3\n1 1 3 3\n']","['10\n', '18\n']","Note to the first sample test:

Values of the table in the first three rows and columns will be as follows:

121

121

110

So, the sum of values will be equal to 10.

Note to the second sample test:

Values of the table in the first three rows and columns will be as follows:

222

222

222

So, the sum of values will be equal to 18.",OK,"def solve(x1, y1, x2, y2):
    return sum((x2[i] - x1[i] + 1) * (y2[i] - y1[i] + 1) for i in range(len(x1)))

def main():
    n = int(input())
    x1 = []
    y1 = []
    x2 = []
    y2 = []
    
    for _ in range(n):
        x1_i, y1_i, x2_i, y2_i = map(int, input().split())
        x1.append(x1_i)
        y1.append(y1_i)
        x2.append(x2_i)
        y2.append(y2_i)

    result = solve(x1, y1, x2, y2)
    print(result)

if __name__ == ""__main__"":
    main()","table = [[0] * 100 for _ in range(100)]

n = int(input().strip())

for _ in range(n):

    x1, y1, x2, y2 = map(int, input().strip().split())

    for x in range(x1 - 1, x2):
        for y in range(y1 - 1, y2):
            table[y][x] += 1

total_sum = sum(sum(row) for row in table)

print(total_sum)"
202,A,LLPS,PROGRAMMING,"['binary search', 'bitmasks', 'brute force', 'greedy', 'implementation', 'strings']","This problem's actual name, ""Lexicographically Largest Palindromic Subsequence"" is too long to fit into the page headline.

You are given string *s* consisting of lowercase English letters only. Find its lexicographically largest palindromic subsequence.

We'll call a non-empty string *s*[*p*1*p*2... *p**k*] = *s**p*1*s**p*2... *s**p**k* (1 <=≤<= *p*1<=&lt;<=*p*2<=&lt;<=...<=&lt;<=*p**k* <=≤<= |*s*|) a subsequence of string *s* = *s*1*s*2... *s*|*s*|, where |*s*| is the length of string *s*. For example, strings ""abcb"", ""b"" and ""abacaba"" are subsequences of string ""abacaba"".

String *x* = *x*1*x*2... *x*|*x*| is lexicographically larger than string *y* = *y*1*y*2... *y*|*y*| if either |*x*| &gt; |*y*| and *x*1<==<=*y*1, *x*2<==<=*y*2, ...,<=*x*|*y*|<==<=*y*|*y*|, or there exists such number *r* (*r*<=&lt;<=|*x*|, *r*<=&lt;<=|*y*|) that *x*1<==<=*y*1, *x*2<==<=*y*2, ..., *x**r*<==<=*y**r* and *x**r*<=<=+<=<=1<=&gt;<=*y**r*<=<=+<=<=1. Characters in the strings are compared according to their ASCII codes. For example, string ""ranger"" is lexicographically larger than string ""racecar"" and string ""poster"" is lexicographically larger than string ""post"".

String *s* = *s*1*s*2... *s*|*s*| is a palindrome if it matches string *rev*(*s*) = *s*|*s*|*s*|*s*|<=-<=1... *s*1. In other words, a string is a palindrome if it reads the same way from left to right and from right to left. For example, palindromic strings are ""racecar"", ""refer"" and ""z"".",The only input line contains a non-empty string *s* consisting of lowercase English letters only. Its length does not exceed 10.,Print the lexicographically largest palindromic subsequence of string *s*.,"['radar\n', 'bowwowwow\n', 'codeforces\n', 'mississipp\n']","['rr\n', 'wwwww\n', 's\n', 'ssss\n']","Among all distinct subsequences of string ""radar"" the following ones are palindromes: ""a"", ""d"", ""r"", ""aa"", ""rr"", ""ada"", ""rar"", ""rdr"", ""raar"" and ""radar"". The lexicographically largest of them is ""rr"".",OK,"from sys import *
import sys
from math import *
from collections import *
import string
import re
from bisect import *
from functools import reduce
from itertools import permutations, combinations

t=stdin.readline
R=range
p=stdout.write
mod = int(1e9)+7
MAX = 9223372036854775808
lower = string.ascii_lowercase
upper = string.ascii_uppercase
numbers = string.digits

def S(): return t().strip()
def I(): return int(t())
def GI(): return map(int, input().strip().split())
def GS(): return map(str, t().strip().split())
def IL(): return list(map(int, t().strip().split()))
def SL(): return list(map(str, t().strip().split()))
def mat(n): return [IL() for i in range(n)]
def sieve(n): return reduce(lambda r, x: r - set(range(x**2, n, x)) if x in r else r, 
                            range(2, int(n**0.5) + 1), set(range(2,n)))
def iSq(x): return (ceil(float(sqrt(x))) == floor(float(sqrt(x))))
def ispow2(x): return ((x!=0) and (x&(x-1))==0)
def d2b(n):return bin(n).replace(""0b"", """")
def ls(x,y): return x<<y
def rs(x,y): return x<<y
def powof2(x): return 1<<x  

s=sorted(S())[::-1]
prev = s[0]
for i in s:
    if prev==i: print(i,end='')
    else: break
    prev=i","def largest_palindromic_subsequence(s):

    char_count = {}
    
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1

    half_palindrome = []

    for char in sorted(char_count.keys(), reverse=True):
        count = char_count[char]

        half_palindrome.append(char * (count // 2))

    half_palindrome = ''.join(half_palindrome)

    if half_palindrome:
        middle_char = ''

        for char in sorted(char_count.keys(), reverse=True):
            if char_count[char] % 2 == 1:
                middle_char = char
                break

        full_palindrome = half_palindrome + middle_char + half_palindrome[::-1]
    else:

        full_palindrome = ''

    return full_palindrome

input_string = input().strip()

result = largest_palindromic_subsequence(input_string)
print(result)"
581,A,Vasya the Hipster,PROGRAMMING,"['implementation', 'math']","One day Vasya the Hipster decided to count how many socks he had. It turned out that he had *a* red socks and *b* blue socks.

According to the latest fashion, hipsters should wear the socks of different colors: a red one on the left foot, a blue one on the right foot.

Every day Vasya puts on new socks in the morning and throws them away before going to bed as he doesn't want to wash them.

Vasya wonders, what is the maximum number of days when he can dress fashionable and wear different socks, and after that, for how many days he can then wear the same socks until he either runs out of socks or cannot make a single pair from the socks he's got.

Can you help him?","The single line of the input contains two positive integers *a* and *b* (1<=≤<=*a*,<=*b*<=≤<=100) — the number of red and blue socks that Vasya's got.","Print two space-separated integers — the maximum number of days when Vasya can wear different socks and the number of days when he can wear the same socks until he either runs out of socks or cannot make a single pair from the socks he's got.

Keep in mind that at the end of the day Vasya throws away the socks that he's been wearing on that day.","['3 1\n', '2 3\n', '7 3\n']","['1 1\n', '2 0\n', '3 2\n']","In the first sample Vasya can first put on one pair of different socks, after that he has two red socks left to wear on the second day.",RUNTIME_ERROR,"def vasyahisper(a, b):
    p = min(a, b)

    s = ((a - p) // 2) + ((b - p) // 2)

    print(f'{p}  {s}')

vasyahisper(int(input()), int(input()))","def hipsters_socks(a, b):

    different_days = min(a, b)

    remaining_red = a - different_days
    remaining_blue = b - different_days

    remaining_socks = remaining_red + remaining_blue

    same_days = remaining_socks // 2
    
    return different_days, same_days

inputs = ['3 1', '2 3', '7 3']
outputs = []

for inp in inputs:
    a, b = map(int, inp.split())
    result = hipsters_socks(a, b)
    outputs.append(f""{result[0]} {result[1]}"")

for output in outputs:
    print(output)"
622,F,The Sum of the k-th Powers,PROGRAMMING,['math'],"There are well-known formulas: , , . Also mathematicians found similar formulas for higher degrees.

Find the value of the sum  modulo 109<=+<=7 (so you should find the remainder after dividing the answer by the value 109<=+<=7).","The only line contains two integers *n*,<=*k* (1<=≤<=*n*<=≤<=109,<=0<=≤<=*k*<=≤<=106).",Print the only integer *a* — the remainder after dividing the value of the sum by the value 109<=+<=7.,"['4 1\n', '4 2\n', '4 3\n', '4 0\n']","['10\n', '30\n', '100\n', '4\n']",none,TIME_LIMIT_EXCEEDED,"def lagrange_interpolation(n, y, T, mod):

    finv = [0]*(n+1)
    fac = 1
    for i in range(1, n+1):
        fac = fac*i % mod
    finv[n] = pow(fac, mod-2, mod)
    for i in range(n-1, -1, -1):
        finv[i] = finv[i+1]*(i+1) % mod

    T %= mod

    L = [1]*(n+1)
    for i in range(n):
        L[i+1] = L[i]*(T-i) % mod

    R = [1]*(n+1)
    for i in range(n, 0, -1):
        R[i-1] = R[i]*(T-i) % mod

    res = 0
    for i in range(n+1):
        tmp = y[i]*L[i] % mod*R[i] % mod*finv[i] % mod*finv[n-i] % mod
        if (n-i) % 2 == 0:
            res += tmp
        else:
            res -= tmp

    return res % mod

def fpow(x, k):
    res = 1
    while k:
        if k & 1:
            res = res*x % mod
        x = x*x % mod
        k >>= 1
    return res

mod = 10**9+7
n, k = map(int, input().split())

s = k+1
dp = [0]*(s+1)
res = 0
for i in range(1, s+1):
    res = (res+fpow(i, k)) % mod
    dp[i] = res
print(lagrange_interpolation(s, dp, n, mod))","def calculate_sum(n, k):

    if k == 0:
        return n % (10**9 + 7)
    
    result = 0

    for i in range(1, k + 1):
        term = (n ** (i + 1)) - n
        result += term // (i + 1)

    return result % (10**9 + 7)

if __name__ == ""__main__"":
    import sys
    input_lines = sys.stdin.read().strip().split('\n')
    output_lines = []
    
    for line in input_lines:
        n, k = map(int, line.split())
        result = calculate_sum(n, k)
        output_lines.append(str(result))

    print('\n'.join(output_lines))"
508,A,Pasha and Pixels,PROGRAMMING,['brute force'],"Pasha loves his phone and also putting his hair up... But the hair is now irrelevant.

Pasha has installed a new game to his phone. The goal of the game is following. There is a rectangular field consisting of *n* row with *m* pixels in each row. Initially, all the pixels are colored white. In one move, Pasha can choose any pixel and color it black. In particular, he can choose the pixel that is already black, then after the boy's move the pixel does not change, that is, it remains black. Pasha loses the game when a 2<=×<=2 square consisting of black pixels is formed. 

Pasha has made a plan of *k* moves, according to which he will paint pixels. Each turn in his plan is represented as a pair of numbers *i* and *j*, denoting respectively the row and the column of the pixel to be colored on the current move.

Determine whether Pasha loses if he acts in accordance with his plan, and if he does, on what move the 2<=×<=2 square consisting of black pixels is formed.","The first line of the input contains three integers *n*,<=*m*,<=*k* (1<=≤<=*n*,<=*m*<=≤<=1000, 1<=≤<=*k*<=≤<=105) — the number of rows, the number of columns and the number of moves that Pasha is going to perform. 

The next *k* lines contain Pasha's moves in the order he makes them. Each line contains two integers *i* and *j* (1<=≤<=*i*<=≤<=*n*, 1<=≤<=*j*<=≤<=*m*), representing the row number and column number of the pixel that was painted during a move.","If Pasha loses, print the number of the move when the 2<=×<=2 square consisting of black pixels is formed.

If Pasha doesn't lose, that is, no 2<=×<=2 square consisting of black pixels is formed during the given *k* moves, print 0.","['2 2 4\n1 1\n1 2\n2 1\n2 2\n', '2 3 6\n2 3\n2 2\n1 3\n2 2\n1 2\n1 1\n', '5 3 7\n2 3\n1 2\n1 1\n4 1\n3 1\n5 3\n3 2\n']","['4\n', '5\n', '0\n']",none,RUNTIME_ERROR,"from collections import defaultdict

di = [(0, 1), (1, 0), (1, 1), (0, 0)]
n, m, k = map(int, input().split())
plan = defaultdict(lambda: float('inf'))
for i in range(k):
    plan[tuple(map(int, input().split()))] = min(plan[tuple(map(int, input().split()))], i)
for x, y in plan.keys():
    if all((x + dx, y + dy) in plan.keys() for dx, dy in di):
        print(max(plan[(x + dx, y + dy)] for dx, dy in di) + 1)
        break
else:
    print(0)","def check_loss(n, m, k, moves):

    field = [[0] * (m + 1) for _ in range(n + 1)]

    for move_num, (i, j) in enumerate(moves, start=1):

        field[i][j] = 1

        for di in range(2):
            for dj in range(2):
                if (i + di <= n) and (j + dj <= m) and (field[i + di][j] == 1 and 
                                                        field[i][j + dj] == 1 and 
                                                        field[i + di][j + dj] == 1 and 
                                                        field[i + dj][j + dj] == 1):
                    return move_num

    return 0

import sys
input = sys.stdin.read
data = input().strip().split('\n')

results = []
for i in range(0, len(data), 1):
    n, m, k = map(int, data[i].split())
    moves = [tuple(map(int, data[j].split())) for j in range(i+1, i+k+1)]
    results.append(str(check_loss(n, m, k, moves)))
    i += k

print(""\n"".join(results))"
0,none,none,none,['none'],"One day student Vasya was sitting on a lecture and mentioned a string *s*1*s*2... *s**n*, consisting of letters ""a"", ""b"" and ""c"" that was written on his desk. As the lecture was boring, Vasya decided to complete the picture by composing a graph *G* with the following properties: 
 -  *G* has exactly *n* vertices, numbered from 1 to *n*. -  For all pairs of vertices *i* and *j*, where *i*<=≠<=*j*, there is an edge connecting them if and only if characters *s**i* and *s**j* are either equal or neighbouring in the alphabet. That is, letters in pairs ""a""-""b"" and ""b""-""c"" are neighbouring, while letters ""a""-""c"" are not. 
Vasya painted the resulting graph near the string and then erased the string. Next day Vasya's friend Petya came to a lecture and found some graph at his desk. He had heard of Vasya's adventure and now he wants to find out whether it could be the original graph *G*, painted by Vasya. In order to verify this, Petya needs to know whether there exists a string *s*, such that if Vasya used this *s* he would produce the given graph *G*.","The first line of the input contains two integers *n* and *m*  — the number of vertices and edges in the graph found by Petya, respectively.

Each of the next *m* lines contains two integers *u**i* and *v**i* (1<=≤<=*u**i*,<=*v**i*<=≤<=*n*,<=*u**i*<=≠<=*v**i*) — the edges of the graph *G*. It is guaranteed, that there are no multiple edges, that is any pair of vertexes appear in this list no more than once.","In the first line print ""Yes"" (without the quotes), if the string *s* Petya is interested in really exists and ""No"" (without the quotes) otherwise.

If the string *s* exists, then print it on the second line of the output. The length of *s* must be exactly *n*, it must consist of only letters ""a"", ""b"" and ""c"" only, and the graph built using this string must coincide with *G*. If there are multiple possible answers, you may print any of them.","['2 1\n1 2\n', '4 3\n1 2\n1 3\n1 4\n']","['Yes\naa\n', 'No\n']","In the first sample you are given a graph made of two vertices with an edge between them. So, these vertices can correspond to both the same and adjacent letters. Any of the following strings ""aa"", ""ab"", ""ba"", ""bb"", ""bc"", ""cb"", ""cc"" meets the graph's conditions. 

In the second sample the first vertex is connected to all three other vertices, but these three vertices are not connected with each other. That means that they must correspond to distinct letters that are not adjacent, but that is impossible as there are only two such letters: a and c.",WRONG_ANSWER,"from collections import defaultdict,deque,Counter,OrderedDict

def main():
    n,m = map(int,input().split())
    adj = [[] for i in range(n+1)]

    for i in range(m):
        a,b = map(int,input().split())
        adj[a].append(b)
        adj[b].append(a)
    ans = [""d""]*(n+1)
    visited = [0] * (n + 1)
    for i in range(1,n+1):
        if len(adj[i]) == n-1:
            visited[i] = 1
            ans[i] = ""b""
    st = ans.index(""d"")
    def dfs(st,ck):
        if visited[st]: return
        visited[st] = 1
        ans[st] = ck
        for i in adj[st]:
            dfs(i,ck)

    dfs(st,""a"")
    if ""d"" in ans:
        st = ans.index(""d"")
        dfs(st,""c"")
    if ""d"" in ans:
        print(""No"")
    else:
        print(""Yes"")
        print("""".join(ans[1:]))

if __name__ == ""__main__"":
    main()","def can_construct_graph(n, m, edges):

    graph = [[] for _ in range(n + 1)]
    for u, v in edges:
        graph[u].append(v)
        graph[v].append(u)

    colors = [-1] * (n + 1)

    def dfs(node, color):
        colors[node] = color
        for neighbor in graph[node]:
            if colors[neighbor] == -1:

                if color == 0:
                    dfs(neighbor, 1)
                elif color == 1:
                    dfs(neighbor, 0)
                    if neighbor in graph[node]:
                        dfs(neighbor, 2)
                elif color == 2:
                    dfs(neighbor, 1)
            elif abs(colors[node] - colors[neighbor]) > 1:
                return False
        return True

    for i in range(1, n + 1):
        if colors[i] == -1:
            if not dfs(i, 0):
                return ""No"", """"

    result_string = """".join(chr(c + ord('a')) for c in colors[1:])
    
    return ""Yes"", result_string

def main():
    import sys
    input = sys.stdin.read
    data = input().strip().split('\n')
    
    results = []
    for i in range(0, len(data), 2):
        n, m = map(int, data[i].split())
        edges = [tuple(map(int, data[i + j + 1].split())) for j in range(m)]
        
        answer, result_string = can_construct_graph(n, m, edges)
        results.append(f""{answer}\n{result_string}"")

    print(""\n"".join(results))

if __name__ == ""__main__"":
    main()"
766,B,Mahmoud and a Triangle,PROGRAMMING,"['constructive algorithms', 'geometry', 'greedy', 'math', 'number theory', 'sortings']","Mahmoud has *n* line segments, the *i*-th of them has length *a**i*. Ehab challenged him to use exactly 3 line segments to form a non-degenerate triangle. Mahmoud doesn't accept challenges unless he is sure he can win, so he asked you to tell him if he should accept the challenge. Given the lengths of the line segments, check if he can choose exactly 3 of them to form a non-degenerate triangle.

Mahmoud should use exactly 3 line segments, he can't concatenate two line segments or change any length. A non-degenerate triangle is a triangle with positive area.","The first line contains single integer *n* (3<=≤<=*n*<=≤<=105) — the number of line segments Mahmoud has.

The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=109) — the lengths of line segments Mahmoud has.","In the only line print ""YES"" if he can choose exactly three line segments and form a non-degenerate triangle with them, and ""NO"" otherwise.","['5\n1 5 3 2 4\n', '3\n4 1 2\n']","['YES\n', 'NO\n']","For the first example, he can use line segments with lengths 2, 4 and 5 to form a non-degenerate triangle.",WRONG_ANSWER,"""""""
B. Mahmoud and a Triangle: constructive algorithms, geometry, greedy, math, number theory, sortings

time limit per test: 2 seconds
memory limit per test: 256 megabytes
input: standard input
output: standard output

Mahmoud has n line segments, the i-th of them has length ai.
Ehab challenged him to use exactly 3 line segments to form a non-degenerate triangle.
Mahmoud doesn't accept challenges unless he is sure he can win, so he asked you to tell him if he should accept the challenge.
Given the lengths of the line segments, check if he can choose exactly 3 of them to form a non-degenerate triangle.
Mahmoud should use exactly 3 line segments, he can't concatenate two line segments or change any length.
A non-degenerate triangle is a triangle with positive area.

Input
The first line contains single integer n (3 ≤ n ≤ 10^5) — the number of line segments Mahmoud has.
The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 10^9) — the lengths of line segments Mahmoud has.

Output
In the only line print ""YES"" if he can choose exactly three line segments and form a non-degenerate triangle with them, and ""NO"" otherwise.
""""""

def mahmoud_and_a_triangle():
    n = int(input())
    a = list(map(int, input().split(' ')))

    a.sort()

    print('YES' if sum(a[-3:-1]) > max(a) else 'NO')

if __name__ == '__main__':
    mahmoud_and_a_triangle()","def can_form_triangle(n, lengths):

    for i in range(n - 2):
        if lengths[i] + lengths[i + 1] > lengths[i + 2]:
            return ""YES""
    return ""NO""

n = int(input())
lengths = list(map(int, input().split()))

lengths.sort()

result = can_form_triangle(n, lengths)
print(result)"
818,E,Card Game Again,PROGRAMMING,"['binary search', 'data structures', 'number theory', 'two pointers']","Vova again tries to play some computer card game.

The rules of deck creation in this game are simple. Vova is given an existing deck of *n* cards and a magic number *k*. The order of the cards in the deck is fixed. Each card has a number written on it; number *a**i* is written on the *i*-th card in the deck.

After receiving the deck and the magic number, Vova removes *x* (possibly *x*<==<=0) cards from the top of the deck, *y* (possibly *y*<==<=0) cards from the bottom of the deck, and the rest of the deck is his new deck (Vova has to leave at least one card in the deck after removing cards). So Vova's new deck actually contains cards *x*<=+<=1, *x*<=+<=2, ... *n*<=-<=*y*<=-<=1, *n*<=-<=*y* from the original deck.

Vova's new deck is considered valid iff the product of all numbers written on the cards in his new deck is divisible by *k*. So Vova received a deck (possibly not a valid one) and a number *k*, and now he wonders, how many ways are there to choose *x* and *y* so the deck he will get after removing *x* cards from the top and *y* cards from the bottom is valid?","The first line contains two integers *n* and *k* (1<=≤<=*n*<=≤<=100<=000, 1<=≤<=*k*<=≤<=109).

The second line contains *n* integers *a*1, *a*2, ..., *a**n* (1<=≤<=*a**i*<=≤<=109) — the numbers written on the cards.",Print the number of ways to choose *x* and *y* so the resulting deck is valid.,"['3 4\n6 2 8\n', '3 6\n9 1 14\n']","['4\n', '1\n']","In the first example the possible values of *x* and *y* are:
 1.  *x* = 0, *y* = 0; 1.  *x* = 1, *y* = 0; 1.  *x* = 2, *y* = 0; 1.  *x* = 0, *y* = 1.",WRONG_ANSWER,"count=0
def is_valid(l,k):
  pro=1
  for i in l:
    pro=pro*i
  if(pro%k==0):
    return 1
  else:
    return 0
def e_card(l,k):
  global count
  
  if(is_valid(l,k)):
    count+=1
  if(len(l)==1):
    return
  else:
    m=l[len(l)-1]
    l.pop()
    e_card(l,k)
    l.append(m)
    m=l[0]
    l.pop(0)
    e_card(l,k)
    l.insert(0,m)
n,k=[int(x) for x in input().strip().split()]
e_card([int(x) for x in input().strip().split()],k)
print(count)","def count_valid_decks(n, k, cards):

    valid_count = 0

    prefix_product = [1] * (n + 1)
    for i in range(1, n + 1):
        prefix_product[i] = (prefix_product[i - 1] * cards[i - 1]) % k

    for x in range(n):
        for y in range(n - x):
            if n - x - y > 0:

                product = (prefix_product[n - y] * pow(prefix_product[x], -1, k)) % k
                if product == 0:
                    valid_count += 1

    return valid_count

n, k = map(int, input().split())
cards = list(map(int, input().split()))

print(count_valid_decks(n, k, cards))"
807,A,Is it rated?,PROGRAMMING,"['implementation', 'sortings']","Is it rated?

Here it is. The Ultimate Question of Competitive Programming, Codeforces, and Everything. And you are here to answer it.

Another Codeforces round has been conducted. No two participants have the same number of points. For each participant, from the top to the bottom of the standings, their rating before and after the round is known.

It's known that if at least one participant's rating has changed, then the round was rated for sure.

It's also known that if the round was rated and a participant with lower rating took a better place in the standings than a participant with higher rating, then at least one round participant's rating has changed.

In this problem, you should not make any other assumptions about the rating system.

Determine if the current round is rated, unrated, or it's impossible to determine whether it is rated of not.","The first line contains a single integer *n* (2<=≤<=*n*<=≤<=1000) — the number of round participants.

Each of the next *n* lines contains two integers *a**i* and *b**i* (1<=≤<=*a**i*,<=*b**i*<=≤<=4126) — the rating of the *i*-th participant before and after the round, respectively. The participants are listed in order from the top to the bottom of the standings.","If the round is rated for sure, print ""rated"". If the round is unrated for sure, print ""unrated"". If it's impossible to determine whether the round is rated or not, print ""maybe"".","['6\n3060 3060\n2194 2194\n2876 2903\n2624 2624\n3007 2991\n2884 2884\n', '4\n1500 1500\n1300 1300\n1200 1200\n1400 1400\n', '5\n3123 3123\n2777 2777\n2246 2246\n2246 2246\n1699 1699\n']","['rated\n', 'unrated\n', 'maybe\n']","In the first example, the ratings of the participants in the third and fifth places have changed, therefore, the round was rated.

In the second example, no one's rating has changed, but the participant in the second place has lower rating than the participant in the fourth place. Therefore, if the round was rated, someone's rating would've changed for sure.

In the third example, no one's rating has changed, and the participants took places in non-increasing order of their rating. Therefore, it's impossible to determine whether the round is rated or not.",WRONG_ANSWER,"def main():
    number_of_participant=int(input())
    flag=0
    participant=[]
    for i in range(number_of_participant):
        ranking=input()
        ranking=ranking.split()
        if ranking[0]!=ranking[1]:
            flag=1
            
        participant.append(int(ranking[0]))
    if flag==1:
        print(""rated"")
    else:
        if sorted(participant)==participant:
            print(""maybe"")
        else:
            print(""unrated"")
if __name__==""__main__"":
    main()","def is_rated_round(n, ratings):

    for a, b in ratings:
        if a != b:
            return ""rated""

    for i in range(n - 1):
        if ratings[i][0] < ratings[i + 1][0]:
            return ""unrated""
    
    return ""maybe""

def main():
    n = int(input().strip())
    ratings = [tuple(map(int, input().strip().split())) for _ in range(n)]
    
    result = is_rated_round(n, ratings)
    print(result)

if __name__ == ""__main__"":
    main()"
831,A,Unimodal Array,PROGRAMMING,['implementation'],"Array of integers is unimodal, if:
 -  it is strictly increasing in the beginning; -  after that it is constant; -  after that it is strictly decreasing. 
The first block (increasing) and the last block (decreasing) may be absent. It is allowed that both of this blocks are absent.

For example, the following three arrays are unimodal: [5,<=7,<=11,<=11,<=2,<=1], [4,<=4,<=2], [7], but the following three are not unimodal: [5,<=5,<=6,<=6,<=1], [1,<=2,<=1,<=2], [4,<=5,<=5,<=6].

Write a program that checks if an array is unimodal.","The first line contains integer *n* (1<=≤<=*n*<=≤<=100) — the number of elements in the array.

The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=1<=000) — the elements of the array.","Print ""YES"" if the given array is unimodal. Otherwise, print ""NO"".

You can output each letter in any case (upper or lower).","['6\n1 5 5 5 4 2\n', '5\n10 20 30 20 10\n', '4\n1 2 1 2\n', '7\n3 3 3 3 3 3 3\n']","['YES\n', 'YES\n', 'NO\n', 'YES\n']","In the first example the array is unimodal, because it is strictly increasing in the beginning (from position 1 to position 2, inclusively), that it is constant (from position 2 to position 4, inclusively) and then it is strictly decreasing (from position 4 to position 6, inclusively).",OK,"""""""831.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hYxPSks58iBj6lqO-ZFgsg_7bcRbm3l3
""""""

a=int(input())
b=list(map(int,input().split()))
i=1
while i<a and b[i-1]<b[i]:
  i+=1
while i<a and b[i-1]==b[i]:
  i+=1
while i<a and b[i-1]>b[i]:
  i+=1
if i==a:
  print(""Yes"")
else:
  print(""No"")","def is_unimodal(arr):
    n = len(arr)
    if n == 0:
        return ""NO""
    
    increasing = True
    constant = False
    decreasing = False
    
    for i in range(1, n):
        if increasing:
            if arr[i] > arr[i - 1]:
                continue
            elif arr[i] == arr[i - 1]:
                increasing = False
                constant = True
            else:

                increasing = False
                decreasing = True
        elif constant:
            if arr[i] == arr[i - 1]:
                continue
            elif arr[i] < arr[i - 1]:
                constant = False
                decreasing = True
            else:
                return ""NO""
        elif decreasing:
            if arr[i] < arr[i - 1]:
                continue
            else:
                return ""NO""
                
    return ""YES""

n = int(input())
arr = list(map(int, input().split()))

print(is_unimodal(arr))"
104,A,Blackjack,PROGRAMMING,['implementation'],"One rainy gloomy evening when all modules hid in the nearby cafes to drink hot energetic cocktails, the Hexadecimal virus decided to fly over the Mainframe to look for a Great Idea. And she has found one!

Why not make her own Codeforces, with blackjack and other really cool stuff? Many people will surely be willing to visit this splendid shrine of high culture.

In Mainframe a standard pack of 52 cards is used to play blackjack. The pack contains cards of 13 values: 2, 3, 4, 5, 6, 7, 8, 9, 10, jacks, queens, kings and aces. Each value also exists in one of four suits: hearts, diamonds, clubs and spades. Also, each card earns some value in points assigned to it: cards with value from two to ten earn from 2 to 10 points, correspondingly. An ace can either earn 1 or 11, whatever the player wishes. The picture cards (king, queen and jack) earn 10 points. The number of points a card earns does not depend on the suit. The rules of the game are very simple. The player gets two cards, if the sum of points of those cards equals *n*, then the player wins, otherwise the player loses.

The player has already got the first card, it's the queen of spades. To evaluate chances for victory, you should determine how many ways there are to get the second card so that the sum of points exactly equals *n*.",The only line contains *n* (1<=≤<=*n*<=≤<=25) — the required sum of points.,Print the numbers of ways to get the second card in the required way if the first card is the queen of spades.,"['12\n', '20\n', '10\n']","['4', '15', '0']","In the first sample only four two's of different suits can earn the required sum of points.

In the second sample we can use all tens, jacks, queens and kings; overall it's 15 cards, as the queen of spades (as any other card) is only present once in the pack of cards and it's already in use.

In the third sample there is no card, that would add a zero to the current ten points.",WRONG_ANSWER,"from collections import defaultdict as dd
hp = dd(lambda:4)

hp[0] = 4
hp[10] = 15
hp[11] = 8

n = int(input())
x = n - 10
if x > 11:
    print(0)
else:
    print(hp[x])","first_card_points = 10

card_values = {
    2: 4,
    3: 4,
    4: 4,
    5: 4,
    6: 4,
    7: 4,
    8: 4,
    9: 4,
    10: 16,
    'A': 4
}

def count_ways_to_win(n):

    required_points = n - first_card_points
    ways = 0

    for value, count in card_values.items():
        if value == 'A':

            if required_points == 1 or required_points == 11:
                ways += count
        elif required_points == value:
            ways += count

    return ways

import sys
input_values = sys.stdin.read().strip().split()
results = []

for value in input_values:
    n = int(value)
    results.append(str(count_ways_to_win(n)))

print("" "".join(results))"
914,F,Substrings in a String,PROGRAMMING,"['bitmasks', 'brute force', 'data structures', 'string suffix structures', 'strings']","Given a string *s*, process *q* queries, each having one of the following forms:
 -  1<=*i*<=*c* — Change the *i*-th character in the string to *c*. -  2<=*l*<=*r*<=*y* — Consider the substring of *s* starting at position *l* and ending at position *r*. Output the number of times *y* occurs as a substring in it.","The first line of the input contains the string *s* (1<=≤<=|*s*|<=≤<=105) of lowercase English letters.

The second line contains an integer *q* (1<=≤<=*q*<=≤<=105)  — the number of queries to process.

The next *q* lines describe the queries and may have one of the following forms:
 -  1<=*i*<=*c* (1<=≤<=*i*<=≤<=|*s*|) -  2<=*l*<=*r*<=*y* (1<=≤<=*l*<=≤<=*r*<=≤<=|*s*|) 
*c* is a lowercase English letter and *y* is a non-empty string consisting of only lowercase English letters.

The sum of |*y*| over all queries of second type is at most 105.

It is guaranteed that there is at least one query of second type.

All strings are 1-indexed.

|*s*| is the length of the string *s*.","For each query of type 2, output the required answer in a separate line.","['ababababa\n3\n2 1 7 aba\n1 5 c\n2 1 7 aba\n', 'abcdcbc\n5\n2 1 7 bc\n1 4 b\n2 4 7 bc\n1 2 a\n2 1 4 aa\n']","['3\n1\n', '2\n2\n1\n']","Consider the first sample case. Initially, the string aba occurs 3 times in the range [1, 7]. Note that two occurrences may overlap. 

After the update, the string becomes ababcbaba and now aba occurs only once in the range [1, 7].",WRONG_ANSWER,"def replace(x,a,p):
    x[a-1]=p
    return x

def substring(x,m,n,k):
    count=0
    i=m-1
    k=list(k)
    while (i+len(k)-1<n):
        while((x[i]!=k[0]) and (i+len(k)-1<n) ):
            i=i+1
        if((x[i]==k[0]) and (i+len(k)-1<n)):
            flag=True
            for m in range(len(k)):
                if x[i]==k[m]:
                    i+=1
                else:
                    flag=False
                    i+=1
                    break
            if flag is True:
                count+=1
        while n>m:
            if(x[n-1] != k[len(k)-1]):
                n-=1
            else:
                break
            
            
    return count
    

str=input()
numberOfQuery=int(input())
str=list(str)

for i in range(numberOfQuery):
    query=input()
    query=query.split("" "")
    if(len(query) == 3):
        str=replace(str,int(query[1]),query[2])
    elif(len(query) == 4):
        print(substring(str,int(query[1]),int(query[2]),query[3]))","def process_queries(s, queries):
    results = []
    
    for query in queries:
        parts = query.split()
        if parts[0] == ""1"":

            i = int(parts[1]) - 1
            c = parts[2]
            s = s[:i] + c + s[i + 1:]
        elif parts[0] == ""2"":

            l = int(parts[1]) - 1
            r = int(parts[2])
            y = parts[3]
            substring = s[l:r]
            count = substring.count(y)
            results.append(str(count))
    
    return results

def main():
    import sys
    input = sys.stdin.read
    data = input().splitlines()
    
    s = data[0]
    q = int(data[1])
    queries = data[2:q + 2]
    
    results = process_queries(s, queries)

    print(""\n"".join(results))

if __name__ == ""__main__"":
    main()"
276,B,Little Girl and Game,PROGRAMMING,"['games', 'greedy']","The Little Girl loves problems on games very much. Here's one of them.

Two players have got a string *s*, consisting of lowercase English letters. They play a game that is described by the following rules:
 -  The players move in turns; In one move the player can remove an arbitrary letter from string *s*. -  If the player before his turn can reorder the letters in string *s* so as to get a palindrome, this player wins. A palindrome is a string that reads the same both ways (from left to right, and vice versa). For example, string ""abba"" is a palindrome and string ""abc"" isn't. 
Determine which player will win, provided that both sides play optimally well — the one who moves first or the one who moves second.","The input contains a single line, containing string *s* (1<=≤<=|*s*|<=<=≤<=<=103). String *s* consists of lowercase English letters.","In a single line print word ""First"" if the first player wins (provided that both players play optimally well). Otherwise, print word ""Second"". Print the words without the quotes.","['aba\n', 'abca\n']","['First\n', 'Second\n']",none,OK,"import sys 
input = sys.stdin.readline 
from collections import Counter , defaultdict
def instr():
    return input()[:-1]
import math 

w = instr()
c = Counter(w)
f = sum(x%2 != 0 for x in c.values())
if f == 0 :
    print(""First"")
else :
    print(""First"" if f%2 != 0 else ""Second"")","def can_form_palindrome(s):

    char_count = {}
    for char in s:
        char_count[char] = char_count.get(char, 0) + 1

    odd_count = sum(1 for count in char_count.values() if count % 2 == 1)

    return odd_count <= 1

def determine_winner(s):

    if can_form_palindrome(s):
        return ""First""

    length = len(s)

    return ""First"" if length % 2 == 1 else ""Second""

import sys
input = sys.stdin.read

s = input().strip()

print(determine_winner(s))"
158,B,Taxi,PROGRAMMING,"['*special', 'greedy', 'implementation']","After the lessons *n* groups of schoolchildren went outside and decided to visit Polycarpus to celebrate his birthday. We know that the *i*-th group consists of *s**i* friends (1<=≤<=*s**i*<=≤<=4), and they want to go to Polycarpus together. They decided to get there by taxi. Each car can carry at most four passengers. What minimum number of cars will the children need if all members of each group should ride in the same taxi (but one taxi can take more than one group)?","The first line contains integer *n* (1<=≤<=*n*<=≤<=105) — the number of groups of schoolchildren. The second line contains a sequence of integers *s*1,<=*s*2,<=...,<=*s**n* (1<=≤<=*s**i*<=≤<=4). The integers are separated by a space, *s**i* is the number of children in the *i*-th group.",Print the single number — the minimum number of taxis necessary to drive all children to Polycarpus.,"['5\n1 2 4 3 3\n', '8\n2 3 4 4 2 1 3 1\n']","['4\n', '5\n']","In the first test we can sort the children into four cars like this:
 -  the third group (consisting of four children), -  the fourth group (consisting of three children), -  the fifth group (consisting of three children), -  the first and the second group (consisting of one and two children, correspondingly). 
There are other ways to sort the groups into four cars.",OK,"def min_taxis(groups):
    counts = [groups.count(i) for i in range(1, 5)]
    return counts[3] + counts[2] + (counts[1]*2 + max(0, counts[0] - counts[2]) + 3) // 4

n = int(input())
groups = list(map(int, input().split()))
result = min_taxis(groups)
print(result)","def minimum_taxis(n, groups):

    count = [0] * 5
    for size in groups:
        count[size] += 1
    
    taxis = count[4]

    taxis += count[3]
    count[1] = max(0, count[1] - count[3])

    taxis += count[2] // 2
    count[2] %= 2

    if count[2] == 1:
        taxis += 1
        count[1] = max(0, count[1] - 2)

    taxis += (count[1] + 3) // 4

    return taxis

n = int(input())
groups = list(map(int, input().split()))

print(minimum_taxis(n, groups))"
471,D,MUH and Cube Walls,PROGRAMMING,"['string suffix structures', 'strings']","Polar bears Menshykov and Uslada from the zoo of St. Petersburg and elephant Horace from the zoo of Kiev got hold of lots of wooden cubes somewhere. They started making cube towers by placing the cubes one on top of the other. They defined multiple towers standing in a line as a wall. A wall can consist of towers of different heights.

Horace was the first to finish making his wall. He called his wall an elephant. The wall consists of *w* towers. The bears also finished making their wall but they didn't give it a name. Their wall consists of *n* towers. Horace looked at the bears' tower and wondered: in how many parts of the wall can he ""see an elephant""? He can ""see an elephant"" on a segment of *w* contiguous towers if the heights of the towers on the segment match as a sequence the heights of the towers in Horace's wall. In order to see as many elephants as possible, Horace can raise and lower his wall. He even can lower the wall below the ground level (see the pictures to the samples for clarification).

Your task is to count the number of segments where Horace can ""see an elephant"".","The first line contains two integers *n* and *w* (1<=≤<=*n*,<=*w*<=≤<=2·105) — the number of towers in the bears' and the elephant's walls correspondingly. The second line contains *n* integers *a**i* (1<=≤<=*a**i*<=≤<=109) — the heights of the towers in the bears' wall. The third line contains *w* integers *b**i* (1<=≤<=*b**i*<=≤<=109) — the heights of the towers in the elephant's wall.","Print the number of segments in the bears' wall where Horace can ""see an elephant"".",['13 5\n2 4 5 5 4 3 2 2 2 3 3 2 1\n3 4 4 3 2\n'],['2'],"The picture to the left shows Horace's wall from the sample, the picture to the right shows the bears' wall. The segments where Horace can ""see an elephant"" are in gray.",RUNTIME_ERROR,"def count_elephant_segments(n, w, bear_wall, elephant_wall):

    elephant_hash = hash(elephant_wall)

    bear_hash = hash(bear_wall[:w])

    count = 0

    for i in range(n - w + 1):
        if i > 0:

            bear_hash = bear_hash * 101 + bear_wall[i + w - 1] - bear_wall[i - 1] * 101 ** w

        if bear_hash == elephant_hash:
            count += 1

    return count

n, w = map(int, input().split())
bear_wall = list(map(int, input().split()))
elephant_wall = list(map(int, input().split()))

result = count_elephant_segments(n, w, bear_wall, elephant_wall)
print(result)","n, w = map(int, input().split())
a = list(map(int, input().split()))
b = list(map(int, input().split()))

def can_see_elephant(segment, elephant):

    lifting_factor = segment[0] - elephant[0]
    for i in range(len(elephant)):

        if segment[i] - lifting_factor != elephant[i]:
            return False
    return True

count = 0

for i in range(n - w + 1):
    segment = a[i:i + w]
    if can_see_elephant(segment, b):
        count += 1

print(count)"
436,A,Feed with Candy,PROGRAMMING,['greedy'],"The hero of the Cut the Rope game is a little monster named Om Nom. He loves candies. And what a coincidence! He also is the hero of today's problem.

One day, Om Nom visited his friend Evan. Evan has *n* candies of two types (fruit drops and caramel drops), the *i*-th candy hangs at the height of *h**i* centimeters above the floor of the house, its mass is *m**i*. Om Nom wants to eat as many candies as possible. At the beginning Om Nom can make at most *x* centimeter high jumps. When Om Nom eats a candy of mass *y*, he gets stronger and the height of his jump increases by *y* centimeters.

What maximum number of candies can Om Nom eat if he never eats two candies of the same type in a row (Om Nom finds it too boring)?","The first line contains two integers, *n* and *x* (1<=≤<=*n*,<=*x*<=≤<=2000) — the number of sweets Evan has and the initial height of Om Nom's jump. 

Each of the following *n* lines contains three integers *t**i*,<=*h**i*,<=*m**i* (0<=≤<=*t**i*<=≤<=1; 1<=≤<=*h**i*,<=*m**i*<=≤<=2000) — the type, height and the mass of the *i*-th candy. If number *t**i* equals 0, then the current candy is a caramel drop, otherwise it is a fruit drop.",Print a single integer — the maximum number of candies Om Nom can eat.,['5 3\n0 2 4\n1 3 1\n0 8 3\n0 20 10\n1 5 5\n'],['4\n'],"One of the possible ways to eat 4 candies is to eat them in the order: 1, 5, 3, 2. Let's assume the following scenario:
 1.  Initially, the height of Om Nom's jump equals 3. He can reach candies 1 and 2. Let's assume that he eats candy 1. As the mass of this candy equals 4, the height of his jump will rise to 3 + 4 = 7. 1.  Now Om Nom can reach candies 2 and 5. Let's assume that he eats candy 5. Then the height of his jump will be 7 + 5 = 12. 1.  At this moment, Om Nom can reach two candies, 2 and 3. He won't eat candy 2 as its type matches the type of the previously eaten candy. Om Nom eats candy 3, the height of his jump is 12 + 3 = 15. 1.  Om Nom eats candy 2, the height of his jump is 15 + 1 = 16. He cannot reach candy 4.",OK,"from copy import deepcopy

def getBetter(h, a):
    maxi = -1
    im = -1
    for i in range(len(a)):
        if (h >= a[i][0]):
            if (maxi < a[i][1]):
                im = i
                maxi = a[i][1]
    return(im, maxi)

n, h0 = map(int, input().split())

lolipops0 = [[], []]

for i in range(n):
    t, h, m = map(int, input().split())
    lolipops0[t].append((h, m))

lolipops0[1].sort()
lolipops0[0].sort()

lolipops1 = deepcopy(lolipops0)

lol0 = getBetter(h0, lolipops0[0])
t1 = 0
h1 = h0
lol1 = getBetter(h0, lolipops0[1])
t2 = 1
h2 = h0
while(lol0[0] >= 0 or lol1[0] >=0):
    if (lol0[0] > -1):
        if (len(lolipops0[t1 % 2]) != 1 and lol0[0] != -1):
            lolipops0[t1 % 2].pop(lol0[0])
        else:
            lolipops0[t1 % 2] = []
        t1 += 1
        h1 += lol0[1]
        lol0 = getBetter(h1, lolipops0[t1 % 2])
    if (lol1[0] > -1):
        if (len(lolipops1[t2 % 2]) != 1 and lol1[0] != -1):
            lolipops1[t2 % 2].pop(lol1[0])
        else:
            lolipops1[t2 % 2] = []
        t2 += 1
        h2 += lol1[1]
        lol1 = getBetter(h2, lolipops1[t2 % 2])
print(max(t1, t2 - 1))","def max_candies(n, x, candies):

    caramel = []
    fruit = []
    
    for candy in candies:
        t, h, m = candy
        if t == 0:
            caramel.append((h, m))
        else:
            fruit.append((h, m))

    caramel.sort()
    fruit.sort()

    def eat_candies(start_type):
        jump_height = x
        candies_eaten = 0
        last_type = start_type
        
        while True:
            if last_type == 0:
                current_list = fruit
                next_type = 1
            else:
                current_list = caramel
                next_type = 0
            
            possible_candies = [c for c in current_list if c[0] <= jump_height]
            if not possible_candies:
                break

            max_candy = max(possible_candies, key=lambda c: c[1])
            current_list.remove(max_candy)
            jump_height += max_candy[1]
            candies_eaten += 1
            last_type = next_type
        
        return candies_eaten

    return max(eat_candies(0), eat_candies(1))

input_data = '5 3\n0 2 4\n1 3 1\n0 8 3\n0 20 10\n1 5 5\n'
lines = input_data.strip().split('\n')
n, x = map(int, lines[0].split())
candies = [tuple(map(int, line.split())) for line in lines[1:]]

print(max_candies(n, x, candies))"
675,A,Infinite Sequence,PROGRAMMING,['math'],"Vasya likes everything infinite. Now he is studying the properties of a sequence *s*, such that its first element is equal to *a* (*s*1<==<=*a*), and the difference between any two neighbouring elements is equal to *c* (*s**i*<=-<=*s**i*<=-<=1<==<=*c*). In particular, Vasya wonders if his favourite integer *b* appears in this sequence, that is, there exists a positive integer *i*, such that *s**i*<==<=*b*. Of course, you are the person he asks for a help.","The first line of the input contain three integers *a*, *b* and *c* (<=-<=109<=≤<=*a*,<=*b*,<=*c*<=≤<=109) — the first element of the sequence, Vasya's favorite number and the difference between any two neighbouring elements of the sequence, respectively.","If *b* appears in the sequence *s* print ""YES"" (without quotes), otherwise print ""NO"" (without quotes).","['1 7 3\n', '10 10 0\n', '1 -4 5\n', '0 60 50\n']","['YES\n', 'YES\n', 'NO\n', 'NO\n']","In the first sample, the sequence starts from integers 1, 4, 7, so 7 is its element.

In the second sample, the favorite integer of Vasya is equal to the first element of the sequence.

In the third sample all elements of the sequence are greater than Vasya's favorite integer.

In the fourth sample, the sequence starts from 0, 50, 100, and all the following elements are greater than Vasya's favorite integer.",WRONG_ANSWER,"def favourite_number(a, b, c):
    if a - b == 0:
        return ""YES""
    elif c == 0:
        return ""NO""
    elif (a - b) % c != 0 and (a - b) * c < 0:
        return ""NO""
    return ""YES""

A, B, C = [int(i) for i in input().split()]
print(favourite_number(A, B, C))","def is_favorite_number_in_sequence(a, b, c):

    if c == 0:
        return a == b

    elif c > 0:

        return (b >= a) and ((b - a) % c == 0)

    else:

        return (b <= a) and ((a - b) % -c == 0)

input_data = ['1 7 3\n', '10 10 0\n', '1 -4 5\n', '0 60 50\n']
output_data = []

for line in input_data:
    a, b, c = map(int, line.strip().split())
    if is_favorite_number_in_sequence(a, b, c):
        output_data.append(""YES"")
    else:
        output_data.append(""NO"")

print(output_data)"
1011,A,Stages,PROGRAMMING,"['greedy', 'implementation', 'sortings']","Natasha is going to fly to Mars. She needs to build a rocket, which consists of several stages in some order. Each of the stages is defined by a lowercase Latin letter. This way, the rocket can be described by the string — concatenation of letters, which correspond to the stages.

There are $n$ stages available. The rocket must contain exactly $k$ of them. Stages in the rocket should be ordered by their weight. So, after the stage with some letter can go only stage with a letter, which is at least two positions after in the alphabet (skipping one letter in between, or even more). For example, after letter 'c' can't go letters 'a', 'b', 'c' and 'd', but can go letters 'e', 'f', ..., 'z'.

For the rocket to fly as far as possible, its weight should be minimal. The weight of the rocket is equal to the sum of the weights of its stages. The weight of the stage is the number of its letter in the alphabet. For example, the stage 'a 'weighs one ton,' b 'weighs two tons, and' z' — $26$ tons.

Build the rocket with the minimal weight or determine, that it is impossible to build a rocket at all. Each stage can be used at most once.","The first line of input contains two integers — $n$ and $k$ ($1 \le k \le n \le 50$) – the number of available stages and the number of stages to use in the rocket.

The second line contains string $s$, which consists of exactly $n$ lowercase Latin letters. Each letter defines a new stage, which can be used to build the rocket. Each stage can be used at most once.","Print a single integer — the minimal total weight of the rocket or -1, if it is impossible to build the rocket at all.","['5 3\nxyabd\n', '7 4\nproblem\n', '2 2\nab\n', '12 1\nabaabbaaabbb\n']","['29', '34', '-1', '1']","In the first example, the following rockets satisfy the condition:
-  ""adx"" (weight is $1+4+24=29$);-  ""ady"" (weight is $1+4+25=30$);-  ""bdx"" (weight is $2+4+24=30$);-  ""bdy"" (weight is $2+4+25=31$).
Rocket ""adx"" has the minimal weight, so the answer is $29$.

In the second example, target rocket is ""belo"". Its weight is $2+5+12+15=34$.

In the third example, $n=k=2$, so the rocket must have both stages: 'a' and 'b'. This rocket doesn't satisfy the condition, because these letters are adjacent in the alphabet. Answer is -1.",WRONG_ANSWER,"def mi():
    return map(int, input().split())
n,k = mi()
s = list(input())
s.sort()
for i in range(n):
    s[i] = ord(s[i])-ord('a')+1
ans = s[0]
k-=1
for i in range(1,n):
    if not k:
        break
    if s[i]-s[i-1]>1:
        ans+=s[i]
        k-=1
if k:
    print (-1)
else:
    print(ans)","def minimal_rocket_weight(n, k, s):

    stages = sorted(set(s))

    rocket_stages = []
    last_index = -1

    for stage in stages:

        if len(rocket_stages) == 0 or (ord(stage) - ord(rocket_stages[-1]) >= 2):
            rocket_stages.append(stage)

        if len(rocket_stages) == k:
            break

    if len(rocket_stages) < k:
        return -1

    total_weight = sum(ord(stage) - ord('a') + 1 for stage in rocket_stages)
    return total_weight

import sys
input_data = sys.stdin.read().strip().split('\n')

results = []
for i in range(0, len(input_data), 2):
    n, k = map(int, input_data[i].split())
    s = input_data[i + 1]

    results.append(str(minimal_rocket_weight(n, k, s)))

print(""\n"".join(results))"
721,C,Journey,PROGRAMMING,"['dp', 'graphs']","Recently Irina arrived to one of the most famous cities of Berland — the Berlatov city. There are *n* showplaces in the city, numbered from 1 to *n*, and some of them are connected by one-directional roads. The roads in Berlatov are designed in a way such that there are no cyclic routes between showplaces.

Initially Irina stands at the showplace 1, and the endpoint of her journey is the showplace *n*. Naturally, Irina wants to visit as much showplaces as she can during her journey. However, Irina's stay in Berlatov is limited and she can't be there for more than *T* time units.

Help Irina determine how many showplaces she may visit during her journey from showplace 1 to showplace *n* within a time not exceeding *T*. It is guaranteed that there is at least one route from showplace 1 to showplace *n* such that Irina will spend no more than *T* time units passing it.","The first line of the input contains three integers *n*,<=*m* and *T* (2<=≤<=*n*<=≤<=5000,<=<=1<=≤<=*m*<=≤<=5000,<=<=1<=≤<=*T*<=≤<=109) — the number of showplaces, the number of roads between them and the time of Irina's stay in Berlatov respectively.

The next *m* lines describes roads in Berlatov. *i*-th of them contains 3 integers *u**i*,<=*v**i*,<=*t**i* (1<=≤<=*u**i*,<=*v**i*<=≤<=*n*,<=*u**i*<=≠<=*v**i*,<=1<=≤<=*t**i*<=≤<=109), meaning that there is a road starting from showplace *u**i* and leading to showplace *v**i*, and Irina spends *t**i* time units to pass it. It is guaranteed that the roads do not form cyclic routes.

It is guaranteed, that there is at most one road between each pair of showplaces.","Print the single integer *k* (2<=≤<=*k*<=≤<=*n*) — the maximum number of showplaces that Irina can visit during her journey from showplace 1 to showplace *n* within time not exceeding *T*, in the first line.

Print *k* distinct integers in the second line — indices of showplaces that Irina will visit on her route, in the order of encountering them.

If there are multiple answers, print any of them.","['4 3 13\n1 2 5\n2 3 7\n2 4 8\n', '6 6 7\n1 2 2\n1 3 3\n3 6 3\n2 4 2\n4 6 2\n6 5 1\n', '5 5 6\n1 3 3\n3 5 3\n1 2 2\n2 4 3\n4 5 2\n']","['3\n1 2 4 \n', '4\n1 2 4 6 \n', '3\n1 3 5 \n']",none,TIME_LIMIT_EXCEEDED,"from sys import stdout
from sys import stdin
def get():
    return stdin.readline().strip()
def getf():
    return [int(i) for i in get().split()]
def put(a, end = ""\n""):
    stdout.write(str(a) + end)
def putf(a, sep = "" "", end = ""\n""):
    stdout.write(sep.join([str(i) for i in a]) + end)

def bruh():
    n, m, t = getf()
    g = [[] for i in range(n + 1)]
    for i in range(m):
        v, u, ti = getf()
        g[v].append([u, ti])

    inf = 10 ** 18 + 7
    a = [[inf] * (n + 1) for i in range(n + 1)]
    a[1][0] = 0
    ans = 0
    par = dict()
    for k in range(1, n + 1):
        for i in range(1, n + 1):
            for e in g[i]:
                if(a[e[0]][k] > a[i][k - 1] + e[1]):
                    a[e[0]][k] = a[i][k - 1] + e[1]
                    par[e[0], k] = i
    res = 0
    for j in range(1, n + 1):
        if(a[n][j] <= t):
            res = j
    put(res + 1)
    ans = [n]
    cur = n

    while(cur != 1):
        ans.append(par[cur, res])
        cur = par[cur, res]
        res -= 1

    putf(ans[ :: -1])
bruh()","import sys
import heapq

def main():
    input = sys.stdin.read
    data = input().strip().split('\n')

    n, m, T = map(int, data[0].split())

    graph = [[] for _ in range(n + 1)]

    for i in range(1, m + 1):
        u, v, t = map(int, data[i].split())
        graph[u].append((v, t))

    pq = [(0, 1)]
    min_time = [float('inf')] * (n + 1)
    min_time[1] = 0
    prev = [-1] * (n + 1)
    
    while pq:
        current_time, current_place = heapq.heappop(pq)

        if current_place == n:
            break

        for neighbor, travel_time in graph[current_place]:
            new_time = current_time + travel_time

            if new_time < min_time[neighbor] and new_time <= T:
                min_time[neighbor] = new_time
                prev[neighbor] = current_place
                heapq.heappush(pq, (new_time, neighbor))

    path = []
    current = n
    
    while current != -1:
        path.append(current)
        current = prev[current]
    
    path.reverse()

    print(len(path))
    print(' '.join(map(str, path)))

if __name__ == ""__main__"":
    main()"
964,A,Splits,PROGRAMMING,['math'],"Let's define a split of $n$ as a nonincreasing sequence of positive integers, the sum of which is $n$. 

For example, the following sequences are splits of $8$: $[4, 4]$, $[3, 3, 2]$, $[2, 2, 1, 1, 1, 1]$, $[5, 2, 1]$.

The following sequences aren't splits of $8$: $[1, 7]$, $[5, 4]$, $[11, -3]$, $[1, 1, 4, 1, 1]$.

The weight of a split is the number of elements in the split that are equal to the first element. For example, the weight of the split $[1, 1, 1, 1, 1]$ is $5$, the weight of the split $[5, 5, 3, 3, 3]$ is $2$ and the weight of the split $[9]$ equals $1$.

For a given $n$, find out the number of different weights of its splits.",The first line contains one integer $n$ ($1 \leq n \leq 10^9$).,Output one integer — the answer to the problem.,"['7\n', '8\n', '9\n']","['4\n', '5\n', '5\n']","In the first sample, there are following possible weights of splits of $7$:

Weight 1: [$\textbf 7$] 

Weight 2: [$\textbf 3$, $\textbf 3$, 1] 

Weight 3: [$\textbf 2$, $\textbf 2$, $\textbf 2$, 1] 

Weight 7: [$\textbf 1$, $\textbf 1$, $\textbf 1$, $\textbf 1$, $\textbf 1$, $\textbf 1$, $\textbf 1$]",COMPILATION_ERROR,"using namespace std;

int main() {
    int n ;
    cin >> n ;

    ll x = n/2 + 1 ;
    cout<<x;

    return 0;
}","def count_weights(n):

    weight_count = 0
    k = 1

    while k * (k + 1) // 2 <= n:
        weight_count += 1
        k += 1
        
    return weight_count

import sys
input_lines = sys.stdin.read().strip().split()
results = []

for line in input_lines:
    n = int(line)
    results.append(count_weights(n))

for result in results:
    print(result)"
602,B,Approximating a Constant Range,PROGRAMMING,"['dp', 'implementation', 'two pointers']","When Xellos was doing a practice course in university, he once had to measure the intensity of an effect that slowly approached equilibrium. A good way to determine the equilibrium intensity would be choosing a sufficiently large number of consecutive data points that seems as constant as possible and taking their average. Of course, with the usual sizes of data, it's nothing challenging — but why not make a similar programming contest problem while we're at it?

You're given a sequence of *n* data points *a*1,<=...,<=*a**n*. There aren't any big jumps between consecutive data points — for each 1<=≤<=*i*<=&lt;<=*n*, it's guaranteed that |*a**i*<=+<=1<=-<=*a**i*|<=≤<=1.

A range [*l*,<=*r*] of data points is said to be almost constant if the difference between the largest and the smallest value in that range is at most 1. Formally, let *M* be the maximum and *m* the minimum value of *a**i* for *l*<=≤<=*i*<=≤<=*r*; the range [*l*,<=*r*] is almost constant if *M*<=-<=*m*<=≤<=1.

Find the length of the longest almost constant range.","The first line of the input contains a single integer *n* (2<=≤<=*n*<=≤<=100<=000) — the number of data points.

The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=100<=000).",Print a single number — the maximum length of an almost constant range of the given sequence.,"['5\n1 2 3 3 2\n', '11\n5 4 5 5 6 7 8 8 8 7 6\n']","['4\n', '5\n']","In the first sample, the longest almost constant range is [2, 5]; its length (the number of data points in it) is 4.

In the second sample, there are three almost constant ranges of length 4: [1, 4], [6, 9] and [7, 10]; the only almost constant range of the maximum length 5 is [6, 10].",TIME_LIMIT_EXCEEDED,"def calculate_constant_range(data_points, n):
    i = 0
    const_max = 0
    while i <= n - const_max:
        temp_lst = []
        count = 0
        j = i
        while j < n:
            if data_points[j] not in temp_lst:
                temp_lst.append(data_points[j])
                if len(temp_lst) > 2:
                    break
            count += 1
            j += 1
        if count > const_max:
            const_max = count
        i += 1
    return const_max

if __name__ == ""__main__"":

    n = int(input())
    data_points = list(map(int, input().split()))

    print(calculate_constant_range(data_points, n))","def longest_almost_constant_range(n, a):
    max_length = 0
    left = 0
    
    for right in range(n):

        while a[right] - a[left] > 1:
            left += 1

        max_length = max(max_length, right - left + 1)
    
    return max_length

n = int(input().strip())
a = list(map(int, input().strip().split()))

print(longest_almost_constant_range(n, a))"
61,A,Ultra-Fast Mathematician,PROGRAMMING,['implementation'],"Shapur was an extremely gifted student. He was great at everything including Combinatorics, Algebra, Number Theory, Geometry, Calculus, etc. He was not only smart but extraordinarily fast! He could manage to sum 1018 numbers in a single second.

One day in 230 AD Shapur was trying to find out if any one can possibly do calculations faster than him. As a result he made a very great contest and asked every one to come and take part.

In his contest he gave the contestants many different pairs of numbers. Each number is made from digits 0 or 1. The contestants should write a new number corresponding to the given pair of numbers. The rule is simple: The *i*-th digit of the answer is 1 if and only if the *i*-th digit of the two given numbers differ. In the other case the *i*-th digit of the answer is 0.

Shapur made many numbers and first tried his own speed. He saw that he can perform these operations on numbers of length ∞ (length of a number is number of digits in it) in a glance! He always gives correct answers so he expects the contestants to give correct answers, too. He is a good fellow so he won't give anyone very big numbers and he always gives one person numbers of same length.

Now you are going to take part in Shapur's contest. See if you are faster and more accurate.",There are two lines in each input. Each of them contains a single number. It is guaranteed that the numbers are made from 0 and 1 only and that their length is same. The numbers may start with 0. The length of each number doesn't exceed 100.,Write one line — the corresponding answer. Do not omit the leading 0s.,"['1010100\n0100101\n', '000\n111\n', '1110\n1010\n', '01110\n01100\n']","['1110001\n', '111\n', '0100\n', '00010\n']",none,OK,"def ultra(n,m):
    ans=''
    for i in range(len(n)):
        if(n[i]==m[i]):
            ans+='0'
        else:
            ans+='1'
    return ans

if __name__ == ""__main__"":
    n=input()
    m=input()
    print(ultra(n,m))","def xor_binary_numbers(pairs):
    results = []
    
    for a, b in pairs:

        result = ''.join('1' if a[i] != b[i] else '0' for i in range(len(a)))
        results.append(result)
    
    return results

input_data = ['1010100\n0100101\n', '000\n111\n', '1110\n1010\n', '01110\n01100\n']
pairs = [line.strip().split('\n') for line in input_data]

output_data = xor_binary_numbers(pairs)

for output in output_data:
    print(output)"
932,B,Recursive Queries,PROGRAMMING,"['binary search', 'data structures', 'dfs and similar']","Let us define two functions *f* and *g* on positive integer numbers. 

 

You need to process *Q* queries. In each query, you will be given three integers *l*, *r* and *k*. You need to print the number of integers *x* between *l* and *r* inclusive, such that *g*(*x*)<==<=*k*.","The first line of the input contains an integer *Q* (1<=≤<=*Q*<=≤<=2<=×<=105) representing the number of queries. 

*Q* lines follow, each of which contains 3 integers *l*, *r* and *k* (1<=≤<=*l*<=≤<=*r*<=≤<=106,<=1<=≤<=*k*<=≤<=9).","For each query, print a single line containing the answer for that query.","['4\n22 73 9\n45 64 6\n47 55 7\n2 62 4\n', '4\n82 94 6\n56 67 4\n28 59 9\n39 74 4\n']","['1\n4\n0\n8\n', '3\n1\n1\n5\n']","In the first example:
 -  *g*(33) = 9 as *g*(33) = *g*(3 × 3) = *g*(9) = 9 -  *g*(47) = *g*(48) = *g*(60) = *g*(61) = 6 -  There are no such integers between 47 and 55. -  *g*(4) = *g*(14) = *g*(22) = *g*(27) = *g*(39) = *g*(40) = *g*(41) = *g*(58) = 4",TIME_LIMIT_EXCEEDED,"from collections import defaultdict
def product_of_digits(x):

	pr = 1
	while x:

		t = x%10
		pr = pr*max(t,1)
		x = x//10

	return pr

d = defaultdict(list)

Q = int(input())

for i in range(1,10**6+1):

	s = product_of_digits(i)
	d[s].append(i)

def Binary_Search_l(array,x):

	l = 0
	r = len(array)-1
	while r >= l:

		if array[(r+l)//2] >= x:
			r = (l+r)//2-1
		else:
			l = (l+r)//2+1

	return l
def Binary_Search_r(array,x):

	l = 0
	r = len(array)-1

	while r > l:

		if array[(r+l)//2] <= x:
			l = (l+r)//2+1
		else:
			r = (l+r)//2-1

	return r

def DFS(d,x,l,r):

	ans = []
	visited = set()
	stack = [x]

	while len(stack):

		temp = stack.pop()
		visited.add(temp)

		if l <= temp and r >= temp:
			ans.append(temp)

		for j in d[temp]:

			if j not in visited:

				stack.append(j)

	return ans

for i in range(Q):

	l,r,k = map(int,input().split())
	visited = list(DFS(d,k,l,r))
	
	visited.sort()
	print(len(visited))","def g(x):

    while x >= 10:
        x = sum(int(digit) for digit in str(x))
    return x

def process_queries(queries):
    results = []
    for l, r, k in queries:
        count = 0
        for x in range(l, r + 1):
            if g(x) == k:
                count += 1
        results.append(count)
    return results

def main():
    import sys
    input = sys.stdin.read
    data = input().splitlines()
    
    Q = int(data[0])
    queries = []
    
    for i in range(1, Q + 1):
        l, r, k = map(int, data[i].split())
        queries.append((l, r, k))
    
    results = process_queries(queries)
    
    for result in results:
        print(result)

if __name__ == ""__main__"":
    main()"
785,C,Anton and Fairy Tale,PROGRAMMING,"['binary search', 'math']","Anton likes to listen to fairy tales, especially when Danik, Anton's best friend, tells them. Right now Danik tells Anton a fairy tale:

""Once upon a time, there lived an emperor. He was very rich and had much grain. One day he ordered to build a huge barn to put there all his grain. Best builders were building that barn for three days and three nights. But they overlooked and there remained a little hole in the barn, from which every day sparrows came through. Here flew a sparrow, took a grain and flew away...""

More formally, the following takes place in the fairy tale. At the beginning of the first day the barn with the capacity of *n* grains was full. Then, every day (starting with the first day) the following happens:
 -  *m* grains are brought to the barn. If *m* grains doesn't fit to the barn, the barn becomes full and the grains that doesn't fit are brought back (in this problem we can assume that the grains that doesn't fit to the barn are not taken into account). -  Sparrows come and eat grain. In the *i*-th day *i* sparrows come, that is on the first day one sparrow come, on the second day two sparrows come and so on. Every sparrow eats one grain. If the barn is empty, a sparrow eats nothing. 
Anton is tired of listening how Danik describes every sparrow that eats grain from the barn. Anton doesn't know when the fairy tale ends, so he asked you to determine, by the end of which day the barn will become empty for the first time. Help Anton and write a program that will determine the number of that day!","The only line of the input contains two integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=1018) — the capacity of the barn and the number of grains that are brought every day.",Output one integer — the number of the day when the barn will become empty for the first time. Days are numbered starting with one.,"['5 2\n', '8 1\n']","['4\n', '5\n']","In the first sample the capacity of the barn is five grains and two grains are brought every day. The following happens:
 -  At the beginning of the first day grain is brought to the barn. It's full, so nothing happens. -  At the end of the first day one sparrow comes and eats one grain, so 5 - 1 = 4 grains remain. -  At the beginning of the second day two grains are brought. The barn becomes full and one grain doesn't fit to it. -  At the end of the second day two sparrows come. 5 - 2 = 3 grains remain. -  At the beginning of the third day two grains are brought. The barn becomes full again. -  At the end of the third day three sparrows come and eat grain. 5 - 3 = 2 grains remain. -  At the beginning of the fourth day grain is brought again. 2 + 2 = 4 grains remain. -  At the end of the fourth day four sparrows come and eat grain. 4 - 4 = 0 grains remain. The barn is empty. 
So the answer is 4, because by the end of the fourth day the barn becomes empty.",WRONG_ANSWER,"import os
import sys
import math
import random
import datetime
import json
import re
import sqlite3
import time
import csv
import smtplib
import hashlib
import threading
import logging
import tkinter as tk

def find_empty_day(n, m):
    day = 1
    grains = n

    while grains > 0:
        grains -= day

        if grains <= 0:
            break

        grains += m

        day += 1

    return day - 1

n, m = map(int, input().split())

empty_day = find_empty_day(n, m)

print(empty_day)","def find_empty_day(n, m):
    grains = n
    day = 1

    while grains > 0:

        grains += m  

        if grains > n:
            grains = n

        grains -= day

        day += 1

    return day - 1

input_data = input().strip().split()
n = int(input_data[0])
m = int(input_data[1])

print(find_empty_day(n, m))"
587,A,Duff and Weight Lifting,PROGRAMMING,['greedy'],"Recently, Duff has been practicing weight lifting. As a hard practice, Malek gave her a task. He gave her a sequence of weights. Weight of *i*-th of them is 2*w**i* pounds. In each step, Duff can lift some of the remaining weights and throw them away. She does this until there's no more weight left. Malek asked her to minimize the number of steps.

Duff is a competitive programming fan. That's why in each step, she can only lift and throw away a sequence of weights 2*a*1,<=...,<=2*a**k* if and only if there exists a non-negative integer *x* such that 2*a*1<=+<=2*a*2<=+<=...<=+<=2*a**k*<==<=2*x*, i. e. the sum of those numbers is a power of two.

Duff is a competitive programming fan, but not a programmer. That's why she asked for your help. Help her minimize the number of steps.","The first line of input contains integer *n* (1<=≤<=*n*<=≤<=106), the number of weights.

The second line contains *n* integers *w*1,<=...,<=*w**n* separated by spaces (0<=≤<=*w**i*<=≤<=106 for each 1<=≤<=*i*<=≤<=*n*), the powers of two forming the weights values.",Print the minimum number of steps in a single line.,"['5\n1 1 2 3 3\n', '4\n0 1 2 3\n']","['2\n', '4\n']","In the first sample case: One optimal way would be to throw away the first three in the first step and the rest in the second step. Also, it's not possible to do it in one step because their sum is not a power of two.

In the second sample case: The only optimal way is to throw away one weight in each step. It's not possible to do it in less than 4 steps because there's no subset of weights with more than one weight and sum equal to a power of two.",RUNTIME_ERROR,"n, k = map(int, input().split())
l_s = list(map(int, input().split()))

l_s.sort(key = lambda x: x % 10 if x != 100 else x, reverse = True)

t = 0
r = 0
index = 0
for i in l_s:
    n_i = i
    if i != 100:
        n_i += min(k, 10 - i % 10)
        k -= n_i - i
        r += 100 - n_i
    t += n_i // 10
t += min(r // 10, k // 10)
print(t)","def min_steps_to_throw_weights(n, weights):
    from collections import Counter

    weight_count = Counter(weights)
    steps = 0

    while weight_count:

        current_sum = 0
        current_weights = []

        for weight in sorted(weight_count):
            while weight_count[weight] > 0 and current_sum + (2 ** weight) <= (2 ** (weight + 1)):
                current_sum += (2 ** weight)
                current_weights.append(weight)
                weight_count[weight] -= 1

                if weight_count[weight] == 0:
                    del weight_count[weight]

        steps += 1

    return steps

if __name__ == ""__main__"":
    n = int(input().strip())
    weights = list(map(int, input().strip().split()))
    
    result = min_steps_to_throw_weights(n, weights)
    print(result)"
520,A,Pangram,PROGRAMMING,"['implementation', 'strings']","A word or a sentence in some language is called a pangram if all the characters of the alphabet of this language appear in it at least once. Pangrams are often used to demonstrate fonts in printing or test the output devices.

You are given a string consisting of lowercase and uppercase Latin letters. Check whether this string is a pangram. We say that the string contains a letter of the Latin alphabet if this letter occurs in the string in uppercase or lowercase.","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=100) — the number of characters in the string.

The second line contains the string. The string consists only of uppercase and lowercase Latin letters.","Output ""YES"", if the string is a pangram and ""NO"" otherwise.","['12\ntoosmallword\n', '35\nTheQuickBrownFoxJumpsOverTheLazyDog\n']","['NO\n', 'YES\n']",none,OK,"n=int(input())
ch=input()
m=0
letter='abcdefghijklmnopqrstuvwxyz'
for i in letter:
    if i not in ch.lower():
        m=1
if m==1:
    print(""No"")
else:
    print(""Yes"")","def is_pangram(n, sentence):

    alphabet_set = set('abcdefghijklmnopqrstuvwxyz')

    sentence_set = set(sentence.lower())

    if alphabet_set.issubset(sentence_set):
        return ""YES""
    else:
        return ""NO""

n = int(input())
sentence = input().strip()

result = is_pangram(n, sentence)
print(result)"
1,B,Spreadsheet,PROGRAMMING,"['implementation', 'math']","In the popular spreadsheets systems (for example, in Excel) the following numeration of columns is used. The first column has number A, the second — number B, etc. till column 26 that is marked by Z. Then there are two-letter numbers: column 27 has number AA, 28 — AB, column 52 is marked by AZ. After ZZ there follow three-letter numbers, etc.

The rows are marked by integer numbers starting with 1. The cell name is the concatenation of the column and the row numbers. For example, BC23 is the name for the cell that is in column 55, row 23. 

Sometimes another numeration system is used: RXCY, where X and Y are integer numbers, showing the column and the row numbers respectfully. For instance, R23C55 is the cell from the previous example.

Your task is to write a program that reads the given sequence of cell coordinates and produce each item written according to the rules of another numeration system.","The first line of the input contains integer number *n* (1<=≤<=*n*<=≤<=105), the number of coordinates in the test. Then there follow *n* lines, each of them contains coordinates. All the coordinates are correct, there are no cells with the column and/or the row numbers larger than 106 .","Write *n* lines, each line should contain a cell coordinates in the other numeration system.",['2\nR23C55\nBC23\n'],['BC23\nR23C55\n'],none,WRONG_ANSWER,"def transform_string1(s):
    r = ''
    c = ''
    i = 1
    while s[i].isdigit():
        r += s[i]
        i += 1
    i += 1
    while i < len(s) and s[i].isdigit():
        c += s[i]
        i += 1
    c = int(c)
    res = ''
    stack = []
    while c:
        if c % 26:
            stack.append(chr(c % 26 + 64))
        elif c == 26:
            stack.append('Z')
            break
        else:
            stack.append('Z')
        c //= 26
    while stack:
        res += stack.pop()
    res += r
    return res

def transform_string2(s):
    stack = []
    i = 0
    while s[i].isdigit() is False:
        stack.append(s[i])
        i += 1
    r = s[i:]
    c = 0
    for j in range(len(stack)):
        c += (ord(stack[j]) - 64) * (26 ** (len(stack) - j - 1))
    res = 'R' + r + 'C' + str(c)
    return res

n = int(input())
stack = []
for i in range(n):
    s = input()
    if not s[1].isdigit():
        print(transform_string2(s))
    else:
        sign = 1
        i = 2
        while sign and i < len(s):
            if not s[i].isdigit():
                sign -= 1
            i += 1
        if not sign:
            print(transform_string1(s))
        else:
            print(transform_string2(s))","def convert_coordinates(n, coordinates):
    results = []

    def rxcy_to_a1(rxcy):
        row, col = map(int, rxcy[1:].split('C'))
        column = ''
        while col > 0:
            col -= 1
            column = chr(col % 26 + ord('A')) + column
            col //= 26
        return f""{column}{row}""

    def a1_to_rxcy(a1):
        col_str = ''.join(filter(str.isalpha, a1))
        row_str = ''.join(filter(str.isdigit, a1))
        row = int(row_str)
        
        col = 0
        for char in col_str:
            col = col * 26 + (ord(char) - ord('A') + 1)
        
        return f""R{row}C{col}""

    for coord in coordinates:
        if coord.startswith('R') and 'C' in coord:
            results.append(rxcy_to_a1(coord))
        else:
            results.append(a1_to_rxcy(coord))
    
    return results

n = int(input())
coordinates = [input().strip() for _ in range(n)]

converted = convert_coordinates(n, coordinates)
for result in converted:
    print(result)"
478,B,Random Teams,PROGRAMMING,"['combinatorics', 'constructive algorithms', 'greedy', 'math']","*n* participants of the competition were split into *m* teams in some manner so that each team has at least one participant. After the competition each pair of participants from the same team became friends.

Your task is to write a program that will find the minimum and the maximum number of pairs of friends that could have formed by the end of the competition.","The only line of input contains two integers *n* and *m*, separated by a single space (1<=≤<=*m*<=≤<=*n*<=≤<=109) — the number of participants and the number of teams respectively.",The only line of the output should contain two integers *k**min* and *k**max* — the minimum possible number of pairs of friends and the maximum possible number of pairs of friends respectively.,"['5 1\n', '3 2\n', '6 3\n']","['10 10\n', '1 1\n', '3 6\n']","In the first sample all the participants get into one team, so there will be exactly ten pairs of friends.

In the second sample at any possible arrangement one team will always have two participants and the other team will always have one participant. Thus, the number of pairs of friends will always be equal to one.

In the third sample minimum number of newly formed friendships can be achieved if participants were split on teams consisting of 2 people, maximum number can be achieved if participants were split on teams of 1, 1 and 4 people.",WRONG_ANSWER,"items = input().split("" "")
n = int(items[0])
m = int(items[1])

def get_res(k):
    return k * (k-1) // 2

if m == 1:
    k_min = get_res(n)
    k_max = get_res(n)
    print(k_min, k_max)
else:
    if n % m == 0:
        k_min = get_res(n//m)
    else:
        k_min = get_res(n//m + 1)
    k_max = get_res(n-(m-1))
    print(k_min, k_max)","def min_max_friend_pairs(n, m):

    max_pairs = (n * (n - 1)) // 2

    if m == n:

        min_pairs = 0
    else:

        size_teams = n // m
        remaining = n % m

        min_pairs = (remaining * ((size_teams + 1) * size_teams) // 2) + \
                     ((m - remaining) * (size_teams * (size_teams - 1)) // 2)

    return min_pairs, max_pairs

input_data = input().strip().split('\n')
output = []

for line in input_data:
    n, m = map(int, line.split())
    k_min, k_max = min_max_friend_pairs(n, m)
    output.append(f""{k_min} {k_max}"")

print('\n'.join(output))"
984,B,Minesweeper,PROGRAMMING,['implementation'],"One day Alex decided to remember childhood when computers were not too powerful and lots of people played only default games. Alex enjoyed playing Minesweeper that time. He imagined that he saved world from bombs planted by terrorists, but he rarely won.

Alex has grown up since then, so he easily wins the most difficult levels. This quickly bored him, and he thought: what if the computer gave him invalid fields in the childhood and Alex could not win because of it?

He needs your help to check it.

A Minesweeper field is a rectangle $n \times m$, where each cell is either empty, or contains a digit from $1$ to $8$, or a bomb. The field is valid if for each cell: 
 -  if there is a digit $k$ in the cell, then exactly $k$ neighboring cells have bombs. -  if the cell is empty, then all neighboring cells have no bombs. 
Two cells are neighbors if they have a common side or a corner (i. e. a cell has at most $8$ neighboring cells).","The first line contains two integers $n$ and $m$ ($1 \le n, m \le 100$) — the sizes of the field.

The next $n$ lines contain the description of the field. Each line contains $m$ characters, each of them is ""."" (if this cell is empty), ""*"" (if there is bomb in this cell), or a digit from $1$ to $8$, inclusive.","Print ""YES"", if the field is valid and ""NO"" otherwise.

You can choose the case (lower or upper) for each letter arbitrarily.","['3 3\n111\n1*1\n111\n', '2 4\n*.*.\n1211\n']","['YES', 'NO']","In the second example the answer is ""NO"" because, if the positions of the bombs are preserved, the first line of the field should be *2*1.

You can read more about Minesweeper in [Wikipedia's article](https://en.wikipedia.org/wiki/Minesweeper_(video_game)).",WRONG_ANSWER,"import sys,os,io

input = sys.stdin.readlines
def inlt():
    return(list(map(int,input().split())))

grid = input()[1:]

for i in range(len(grid)):
    grid[i] = list(grid[i][:-1])

print(grid)

def check(grid,i,j):
    count = 0
    if 0 <= i - 1 < len(grid):
        if 0 <= j + 1 < len(grid[i]):
            if grid[i - 1][j + 1] == '*':
                count += 1
        
        if 0 <= j < len(grid[i]):
            if grid[i - 1][j] == '*':
                count += 1

        if 0 <= j - 1 < len(grid[i]):
            if grid[i - 1][j - 1] == '*':
                count += 1

    if 0 <= i + 1 < len(grid):
        if 0 <= j + 1 < len(grid[i]):
            if grid[i + 1][j + 1] == '*':
                count += 1
        
        if 0 <= j < len(grid[i]):
            if grid[i + 1][j] == '*':
                count += 1

        if 0 <= j - 1 < len(grid[i]):
            if grid[i + 1][j - 1] == '*':
                count += 1
    
    if 0 <= j - 1 < len(grid[i]):
        if grid[i][j - 1] == '*':
            count += 1
    
    if 0 <= j + 1 < len(grid[i]):
        if grid[i][j + 1] == '*':
            count += 1

    return count

flag = 0

for i in range(len(grid)):
    for j in range(len(grid[i])):
        if grid[i][j].isnumeric():
            x = int(grid[i][j])
            if x != check(grid,i,j):
                flag = 1 
                break
        
        if grid[i][j] == '.':
            if check(grid,i,j) != 0:
                flag = 1
                break 

print(""YES"") if flag == 0 else print(""NO"")","def is_valid_minesweeper_field(n, m, field):

    directions = [(-1, -1), (-1, 0), (-1, 1), 
                  (0, -1),          (0, 1), 
                  (1, -1), (1, 0), (1, 1)]
    
    for i in range(n):
        for j in range(m):
            if field[i][j] == ""*"":
                continue
            count_bombs = 0

            for dx, dy in directions:
                ni, nj = i + dx, j + dy
                if 0 <= ni < n and 0 <= nj < m:
                    if field[ni][nj] == ""*"":
                        count_bombs += 1

            if field[i][j] == ""."" and count_bombs != 0:
                return ""NO""
            elif field[i][j] in ""12345678"" and count_bombs != int(field[i][j]):
                return ""NO""
    
    return ""YES""

def main(inputs):
    results = []
    for input_data in inputs:
        data = input_data.splitlines()
        n, m = map(int, data[0].split())
        field = data[1:n+1]
        results.append(is_valid_minesweeper_field(n, m, field))
    
    return results

input_data = ['3 3\n111\n1*1\n111\n', '2 4\n*.*.\n1211\n']
output = main(input_data)
print(output)"
1009,A,Game Shopping,PROGRAMMING,['implementation'],"Maxim wants to buy some games at the local game shop. There are $n$ games in the shop, the $i$-th game costs $c_i$.

Maxim has a wallet which can be represented as an array of integers. His wallet contains $m$ bills, the $j$-th bill has value $a_j$.

Games in the shop are ordered from left to right, Maxim tries to buy every game in that order.

When Maxim stands at the position $i$ in the shop, he takes the first bill from his wallet (if his wallet is empty then he proceeds to the next position immediately) and tries to buy the $i$-th game using this bill. After Maxim tried to buy the $n$-th game, he leaves the shop.

Maxim buys the $i$-th game if and only if the value of the first bill (which he takes) from his wallet is greater or equal to the cost of the $i$-th game. If he successfully buys the $i$-th game, the first bill from his wallet disappears and the next bill becomes first. Otherwise Maxim leaves the first bill in his wallet (this bill still remains the first one) and proceeds to the next game.

For example, for array $c = [2, 4, 5, 2, 4]$ and array $a = [5, 3, 4, 6]$ the following process takes place: Maxim buys the first game using the first bill (its value is $5$), the bill disappears, after that the second bill (with value $3$) becomes the first one in Maxim's wallet, then Maxim doesn't buy the second game because $c_2 &gt; a_2$, the same with the third game, then he buys the fourth game using the bill of value $a_2$ (the third bill becomes the first one in Maxim's wallet) and buys the fifth game using the bill of value $a_3$.

Your task is to get the number of games Maxim will buy.","The first line of the input contains two integers $n$ and $m$ ($1 \le n, m \le 1000$) — the number of games and the number of bills in Maxim's wallet.

The second line of the input contains $n$ integers $c_1, c_2, \dots, c_n$ ($1 \le c_i \le 1000$), where $c_i$ is the cost of the $i$-th game.

The third line of the input contains $m$ integers $a_1, a_2, \dots, a_m$ ($1 \le a_j \le 1000$), where $a_j$ is the value of the $j$-th bill from the Maxim's wallet.",Print a single integer — the number of games Maxim will buy.,"['5 4\n2 4 5 2 4\n5 3 4 6\n', '5 2\n20 40 50 20 40\n19 20\n', '6 4\n4 8 15 16 23 42\n1000 1000 1000 1000\n']","['3\n', '0\n', '4\n']","The first example is described in the problem statement.

In the second example Maxim cannot buy any game because the value of the first bill in his wallet is smaller than the cost of any game in the shop.

In the third example the values of the bills in Maxim's wallet are large enough to buy any game he encounter until he runs out of bills in his wallet.",OK,"def main():
    [n_games, n_bills] = [int(_) for _ in input().split()]
    game_prices = [0] + [int(_) for _ in input().split()]
    bills = [0] + [int(_) for _ in input().split()]

    last_game = 0
    last_bill = 0
    count_games_bought = 0

    while last_game < n_games and last_bill < n_bills:
        last_bill += 1
        bill = bills[last_bill]
        try:
            last_game = next(g for g in range(last_game + 1, n_games + 1) if game_prices[g] <= bill)
            count_games_bought += 1
        except StopIteration:
            last_game = n_games

    print(count_games_bought)

if __name__ == '__main__':
    main()","n, m = map(int, input().split())

costs = list(map(int, input().split()))

bills = list(map(int, input().split()))

games_bought = 0

for i in range(n):

    if m > 0:

        if bills[0] >= costs[i]:

            games_bought += 1
            bills.pop(0)
            m -= 1

print(games_bought)"
771,A,Bear and Friendship Condition,PROGRAMMING,"['dfs and similar', 'dsu', 'graphs']","Bear Limak examines a social network. Its main functionality is that two members can become friends (then they can talk with each other and share funny pictures).

There are *n* members, numbered 1 through *n*. *m* pairs of members are friends. Of course, a member can't be a friend with themselves.

Let A-B denote that members A and B are friends. Limak thinks that a network is reasonable if and only if the following condition is satisfied: For every three distinct members (X, Y, Z), if X-Y and Y-Z then also X-Z.

For example: if Alan and Bob are friends, and Bob and Ciri are friends, then Alan and Ciri should be friends as well.

Can you help Limak and check if the network is reasonable? Print ""YES"" or ""NO"" accordingly, without the quotes.","The first line of the input contain two integers *n* and *m* (3<=≤<=*n*<=≤<=150<=000, ) — the number of members and the number of pairs of members that are friends.

The *i*-th of the next *m* lines contains two distinct integers *a**i* and *b**i* (1<=≤<=*a**i*,<=*b**i*<=≤<=*n*,<=*a**i*<=≠<=*b**i*). Members *a**i* and *b**i* are friends with each other. No pair of members will appear more than once in the input.","If the given network is reasonable, print ""YES"" in a single line (without the quotes). Otherwise, print ""NO"" in a single line (without the quotes).","['4 3\n1 3\n3 4\n1 4\n', '4 4\n3 1\n2 3\n3 4\n1 2\n', '10 4\n4 3\n5 10\n8 9\n1 2\n', '3 2\n1 2\n2 3\n']","['YES\n', 'NO\n', 'YES\n', 'NO\n']","The drawings below show the situation in the first sample (on the left) and in the second sample (on the right). Each edge represents two members that are friends. The answer is ""NO"" in the second sample because members (2, 3) are friends and members (3, 4) are friends, while members (2, 4) are not.",WRONG_ANSWER,"mod = int(1e9+7)
def solve():
	n,m = map(int,input().split())
	adj = [[]for i in range(n)]
	for i in range(m):
		a,b = map(int,input().split())
		adj[a-1].append(b-1)
		adj[b-1].append(a-1)
	def dfs(s,par,gpar):
		visited[s] = True
		strue = False
		atrue = True
		for i in adj[s]:
			if not visited[i]:
				atrue&=dfs(i,s,par)
			if i==gpar:
				strue = True
		if atrue and (strue or par==-1 or gpar==-1):
			return True
		return False
	visited = [False]*n
	ttrue = True
	for i in range(n):
		if not visited[i]:
			ttrue&=dfs(i,-1,-1)
	if ttrue:
		print(""YES"")
	else:
		print(""NO"")

t = 1
for i in range(t):
	solve()","def is_reasonable_network(n, m, friendships):

    adj = [[False] * (n + 1) for _ in range(n + 1)]

    for a, b in friendships:
        adj[a][b] = True
        adj[b][a] = True

    for x in range(1, n + 1):
        for y in range(1, n + 1):
            if x != y and adj[x][y]:
                for z in range(1, n + 1):
                    if z != x and z != y and adj[y][z]:
                        if not adj[x][z]:
                            return ""NO""
    return ""YES""

input_data = input().strip().split('\n')
n, m = map(int, input_data[0].split())
friendships = [tuple(map(int, line.split())) for line in input_data[1:m + 1]]

result = is_reasonable_network(n, m, friendships)
print(result)"
757,A,Gotta Catch Em' All!,PROGRAMMING,['implementation'],"Bash wants to become a Pokemon master one day. Although he liked a lot of Pokemon, he has always been fascinated by Bulbasaur the most. Soon, things started getting serious and his fascination turned into an obsession. Since he is too young to go out and catch Bulbasaur, he came up with his own way of catching a Bulbasaur.

Each day, he takes the front page of the newspaper. He cuts out the letters one at a time, from anywhere on the front page of the newspaper to form the word ""Bulbasaur"" (without quotes) and sticks it on his wall. Bash is very particular about case — the first letter of ""Bulbasaur"" must be upper case and the rest must be lower case. By doing this he thinks he has caught one Bulbasaur. He then repeats this step on the left over part of the newspaper. He keeps doing this until it is not possible to form the word ""Bulbasaur"" from the newspaper.

Given the text on the front page of the newspaper, can you tell how many Bulbasaurs he will catch today?

Note: uppercase and lowercase letters are considered different.","Input contains a single line containing a string *s* (1<=<=≤<=<=|*s*|<=<=≤<=<=105) — the text on the front page of the newspaper without spaces and punctuation marks. |*s*| is the length of the string *s*.

The string *s* contains lowercase and uppercase English letters, i.e. .","Output a single integer, the answer to the problem.","['Bulbbasaur\n', 'F\n', 'aBddulbasaurrgndgbualdBdsagaurrgndbb\n']","['1\n', '0\n', '2\n']","In the first case, you could pick: Bulbbasaur.

In the second case, there is no way to pick even a single Bulbasaur.

In the third case, you can rearrange the string to BulbasaurBulbasauraddrgndgddgargndbb to get two words ""Bulbasaur"".",WRONG_ANSWER,"def solve(s):
  d = {
    'B': 0,
    'u':0,
    'l':0,
    'b':0,
    'a':0,
    'u':0,
    'r':0,
    's':0
  }
  for c in s:
    if c in 'Bulbbasaur':
      d[c]+=1
  min_val = 1000000000
  for i in d:
    if not d[i]:
      return 0
    if d['a'] < 2 or d['u'] < 2:
      return 0
    if d[i] < min_val:
      if i in ['a','u']:
        min_val = d[i]//2
    min_val = d[i]
  return min_val
    
    

def main() :

  s = input()

  print(solve(s))

main()","def count_bulbasaurs(s):

    target = ""Bulbasaur""
    target_freq = {}
    
    for char in target:
        if char in target_freq:
            target_freq[char] += 1
        else:
            target_freq[char] = 1

    input_freq = {}
    
    for char in s:
        if char in input_freq:
            input_freq[char] += 1
        else:
            input_freq[char] = 1

    min_count = float('inf')
    
    for char in target_freq:
        if char in input_freq:
            count = input_freq[char] // target_freq[char]
        else:
            count = 0
            
        min_count = min(min_count, count)
        
    return min_count

input_string = input().strip()

print(count_bulbasaurs(input_string))"
976,A,Minimum Binary Number,PROGRAMMING,['implementation'],"String can be called correct if it consists of characters ""0"" and ""1"" and there are no redundant leading zeroes. Here are some examples: ""0"", ""10"", ""1001"".

You are given a correct string *s*.

You can perform two different operations on this string: 
 1.  swap any pair of adjacent characters (for example, ""101""  ""110""); 1.  replace ""11"" with ""1"" (for example, ""110""  ""10""). 
Let *val*(*s*) be such a number that *s* is its binary representation.

Correct string *a* is less than some other correct string *b* iff *val*(*a*)<=&lt;<=*val*(*b*).

Your task is to find the minimum correct string that you can obtain from the given one using the operations described above. You can use these operations any number of times in any order (or even use no operations at all).","The first line contains integer number *n* (1<=≤<=*n*<=≤<=100) — the length of string *s*.

The second line contains the string *s* consisting of characters ""0"" and ""1"". It is guaranteed that the string *s* is correct.",Print one string — the minimum correct string that you can obtain from the given one.,"['4\n1001\n', '1\n1\n']","['100\n', '1\n']","In the first example you can obtain the answer by the following sequence of operations: ""1001"" <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> ""1010"" <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> ""1100"" <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> ""100"".

In the second example you can't obtain smaller answer no matter what operations you use.",OK,"def solve():
    size = input()
    s = input()
    
    print('1' * ('1' in s)  + '0' * s.count('0'))
    
    
if __name__ == ""__main__"":
    solve()","def min_correct_string(n, s):

    count_0 = s.count('0')
    count_1 = s.count('1')

    if count_1 == 0:
        return '0'
    elif count_0 == 0:
        return '1'
    else:
        return '1' + '0' * count_0

n = int(input().strip())
s = input().strip()

result = min_correct_string(n, s)
print(result)"
0,none,none,none,['none'],"In Absurdistan, there are *n* towns (numbered 1 through *n*) and *m* bidirectional railways. There is also an absurdly simple road network — for each pair of different towns *x* and *y*, there is a bidirectional road between towns *x* and *y* if and only if there is no railway between them. Travelling to a different town using one railway or one road always takes exactly one hour.

A train and a bus leave town 1 at the same time. They both have the same destination, town *n*, and don't make any stops on the way (but they can wait in town *n*). The train can move only along railways and the bus can move only along roads.

You've been asked to plan out routes for the vehicles; each route can use any road/railway multiple times. One of the most important aspects to consider is safety — in order to avoid accidents at railway crossings, the train and the bus must not arrive at the same town (except town *n*) simultaneously.

Under these constraints, what is the minimum number of hours needed for both vehicles to reach town *n* (the maximum of arrival times of the bus and the train)? Note, that bus and train are not required to arrive to the town *n* at the same moment of time, but are allowed to do so.","The first line of the input contains two integers *n* and *m* (2<=≤<=*n*<=≤<=400, 0<=≤<=*m*<=≤<=*n*(*n*<=-<=1)<=/<=2) — the number of towns and the number of railways respectively.

Each of the next *m* lines contains two integers *u* and *v*, denoting a railway between towns *u* and *v* (1<=≤<=*u*,<=*v*<=≤<=*n*, *u*<=≠<=*v*).

You may assume that there is at most one railway connecting any two towns.","Output one integer — the smallest possible time of the later vehicle's arrival in town *n*. If it's impossible for at least one of the vehicles to reach town *n*, output <=-<=1.","['4 2\n1 3\n3 4\n', '4 6\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4\n', '5 5\n4 2\n3 5\n4 5\n5 1\n1 2\n']","['2\n', '-1\n', '3\n']","In the first sample, the train can take the route <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/7c0aa60a06309ef607b7159fd7f3687ea0d943ce.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> and the bus can take the route <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/a26c2f3e93c9d9be6c21cb5d2bd6ac1f99f4ff55.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>. Note that they can arrive at town 4 at the same time.

In the second sample, Absurdistan is ruled by railwaymen. There are no roads, so there's no way for the bus to reach town 4.",OK,"n, m = map(int, input().split())
a = [[0] * (n + 1) for _ in range(n + 1)]

for _ in range(m):
    u, v = map(int, input().split())
    a[u][v] = 1
    a[v][u] = 1

def bfs(x):
    fila = [(1, 0)]
    visitados = [0] * (n + 1)

    while fila:
        u, v = fila.pop(0)
        for i in range(1, n + 1):
            if not visitados[i] and a[u][i] == x:
                if i == n:
                    return v + 1
                fila.append((i, v + 1))
                visitados[i] = 1

    return -1

if a[1][n]:
    print(bfs(0))
else:
    print(bfs(1))","from collections import deque

def bfs(graph, start, n):
    distance = [-1] * (n + 1)
    distance[start] = 0
    queue = deque([start])

    while queue:
        current = queue.popleft()
        for neighbor in graph[current]:
            if distance[neighbor] == -1:
                distance[neighbor] = distance[current] + 1
                queue.append(neighbor)

    return distance

def min_time_to_reach_town(n, railways):

    railway_graph = [[] for _ in range(n + 1)]
    for u, v in railways:
        railway_graph[u].append(v)
        railway_graph[v].append(u)

    road_graph = [[] for _ in range(n + 1)]
    for i in range(1, n + 1):
        for j in range(1, n + 1):
            if i != j and j not in railway_graph[i]:
                road_graph[i].append(j)

    train_distances = bfs(railway_graph, 1, n)
    bus_distances = bfs(road_graph, 1, n)

    min_time = float('inf')
    for town in range(1, n):
        if train_distances[town] != -1 and bus_distances[town] != -1:
            if train_distances[town] != bus_distances[town]:
                min_time = min(min_time, max(train_distances[town], bus_distances[town]))

    if train_distances[n] == -1 and bus_distances[n] == -1:
        return -1
    elif train_distances[n] == -1:
        return bus_distances[n]
    elif bus_distances[n] == -1:
        return train_distances[n]
    else:
        min_time = min(min_time, max(train_distances[n], bus_distances[n]))

    return min_time

import sys
input = sys.stdin.read
data = input().splitlines()

first_line = data[0]
n, m = map(int, first_line.split())
railways = [tuple(map(int, line.split())) for line in data[1:m + 1]]

result = min_time_to_reach_town(n, railways)
print(result)"
721,C,Journey,PROGRAMMING,"['dp', 'graphs']","Recently Irina arrived to one of the most famous cities of Berland — the Berlatov city. There are *n* showplaces in the city, numbered from 1 to *n*, and some of them are connected by one-directional roads. The roads in Berlatov are designed in a way such that there are no cyclic routes between showplaces.

Initially Irina stands at the showplace 1, and the endpoint of her journey is the showplace *n*. Naturally, Irina wants to visit as much showplaces as she can during her journey. However, Irina's stay in Berlatov is limited and she can't be there for more than *T* time units.

Help Irina determine how many showplaces she may visit during her journey from showplace 1 to showplace *n* within a time not exceeding *T*. It is guaranteed that there is at least one route from showplace 1 to showplace *n* such that Irina will spend no more than *T* time units passing it.","The first line of the input contains three integers *n*,<=*m* and *T* (2<=≤<=*n*<=≤<=5000,<=<=1<=≤<=*m*<=≤<=5000,<=<=1<=≤<=*T*<=≤<=109) — the number of showplaces, the number of roads between them and the time of Irina's stay in Berlatov respectively.

The next *m* lines describes roads in Berlatov. *i*-th of them contains 3 integers *u**i*,<=*v**i*,<=*t**i* (1<=≤<=*u**i*,<=*v**i*<=≤<=*n*,<=*u**i*<=≠<=*v**i*,<=1<=≤<=*t**i*<=≤<=109), meaning that there is a road starting from showplace *u**i* and leading to showplace *v**i*, and Irina spends *t**i* time units to pass it. It is guaranteed that the roads do not form cyclic routes.

It is guaranteed, that there is at most one road between each pair of showplaces.","Print the single integer *k* (2<=≤<=*k*<=≤<=*n*) — the maximum number of showplaces that Irina can visit during her journey from showplace 1 to showplace *n* within time not exceeding *T*, in the first line.

Print *k* distinct integers in the second line — indices of showplaces that Irina will visit on her route, in the order of encountering them.

If there are multiple answers, print any of them.","['4 3 13\n1 2 5\n2 3 7\n2 4 8\n', '6 6 7\n1 2 2\n1 3 3\n3 6 3\n2 4 2\n4 6 2\n6 5 1\n', '5 5 6\n1 3 3\n3 5 3\n1 2 2\n2 4 3\n4 5 2\n']","['3\n1 2 4 \n', '4\n1 2 4 6 \n', '3\n1 3 5 \n']",none,WRONG_ANSWER,"import collections
from functools import lru_cache
from collections import deque

n, m, T = map(int, input().split())
g = collections.defaultdict(list)
rev_g = collections.defaultdict(list)

indegree = [0] * (n + 1)

for _ in range(m):
    u, v, t = map(int, input().split())
    g[u].append(v)
    rev_g[v].append((u, t))
    indegree[v] += 1

dq = deque()
dq.append(1)

topo_order = []
while dq:
    u = dq.popleft()
    topo_order.append(u)
    for v in g[u]:
        indegree[v] -= 1
        if indegree[v] == 0:
            dq.append(v)

dp = [[(float('inf'), -1)] * (n + 1) for _ in range(n + 1)]

dp[1][1] = (0, -1)

for v in topo_order[1:]:
    for u, t in rev_g[v]:
        for nodes_in_paths in range(1, n + 1):
            if dp[u][nodes_in_paths - 1][0] == float('inf'):
                continue
            if (dp[u][nodes_in_paths - 1][0] + t) < dp[v][nodes_in_paths][0]:
                dp[v][nodes_in_paths] = (dp[u][nodes_in_paths - 1][0] + t, u)

res = 1
path = []
for nodes_in_paths in range(n, 0, -1):
    if dp[n][nodes_in_paths][0] != float('inf') and dp[n][nodes_in_paths][0] <= T:
        res = nodes_in_paths
        path = []
        while n != -1:
            path.append(n)
            n = dp[n][nodes_in_paths][1]
            nodes_in_paths -= 1
        break

print(res)
print(path[::-1])","from collections import defaultdict, deque
import sys

def bfs(n, graph, T):
    max_showplaces = 0
    path = []
    
    queue = deque([(1, 0, [1])])
    while queue:
        current, current_time, current_path = queue.popleft()

        if current == n:
            if len(current_path) > max_showplaces:
                max_showplaces = len(current_path)
                path = current_path

        for neighbor, travel_time in graph[current]:
            if current_time + travel_time <= T:
                queue.append((neighbor, current_time + travel_time, current_path + [neighbor]))
    
    return max_showplaces, path

def main():
    input_data = sys.stdin.read().strip().splitlines()
    n, m, T = map(int, input_data[0].split())

    graph = defaultdict(list)
    for i in range(1, m + 1):
        u, v, t = map(int, input_data[i].split())
        graph[u].append((v, t))

    max_showplaces, path = bfs(n, graph, T)
    print(max_showplaces)
    print(' '.join(map(str, path)))

if __name__ == ""__main__"":
    main()"
854,A,Fraction,PROGRAMMING,"['brute force', 'constructive algorithms', 'math']","Petya is a big fan of mathematics, especially its part related to fractions. Recently he learned that a fraction  is called proper iff its numerator is smaller than its denominator (*a*<=&lt;<=*b*) and that the fraction is called irreducible if its numerator and its denominator are coprime (they do not have positive common divisors except 1).

During his free time, Petya thinks about proper irreducible fractions and converts them to decimals using the calculator. One day he mistakenly pressed addition button (<=+<=) instead of division button (÷) and got sum of numerator and denominator that was equal to *n* instead of the expected decimal notation. 

Petya wanted to restore the original fraction, but soon he realized that it might not be done uniquely. That's why he decided to determine maximum possible proper irreducible fraction  such that sum of its numerator and denominator equals *n*. Help Petya deal with this problem.","In the only line of input there is an integer *n* (3<=≤<=*n*<=≤<=1000), the sum of numerator and denominator of the fraction.","Output two space-separated positive integers *a* and *b*, numerator and denominator of the maximum possible proper irreducible fraction satisfying the given sum.","['3\n', '4\n', '12\n']","['1 2\n', '1 3\n', '5 7\n']",none,WRONG_ANSWER,"n = int(input())

def easyest(a, b):
    while a != 0 and b != 0:
        if a > b:
            a %= b
        else:
            b %= a
    if (a + b) == 1:
        return True
    else:
        return False
x = 0
for j in range(n, 1, -1):
    if easyest(n - j, j):
        if (n - j) / j > x:
            xx = j
            x = (n - j) / j
print(min(xx, n - xx), max(xx, n - xx))","def gcd(x, y):
    """"""Calculate the greatest common divisor of x and y.""""""
    while y:
        x, y = y, x % y
    return x

def find_maximum_proper_irreducible_fraction(n):
    """"""Find the maximum proper irreducible fraction with a given sum n.""""""
    max_fraction = (0, 1)
    
    for numerator in range(1, n):
        denominator = n - numerator

        if numerator < denominator:

            if gcd(numerator, denominator) == 1:
                max_fraction = max(max_fraction, (numerator, denominator))

    return max_fraction

n = int(input().strip())

numerator, denominator = find_maximum_proper_irreducible_fraction(n)

print(numerator, denominator)"
75,C,Modified GCD,PROGRAMMING,"['binary search', 'number theory']","Well, here is another math class task. In mathematics, GCD is the greatest common divisor, and it's an easy task to calculate the GCD between two positive integers.

A common divisor for two positive numbers is a number which both numbers are divisible by.

But your teacher wants to give you a harder task, in this task you have to find the greatest common divisor *d* between two integers *a* and *b* that is in a given range from *low* to *high* (inclusive), i.e. *low*<=≤<=*d*<=≤<=*high*. It is possible that there is no common divisor in the given range.

You will be given the two integers *a* and *b*, then *n* queries. Each query is a range from *low* to *high* and you have to answer each query.","The first line contains two integers *a* and *b*, the two integers as described above (1<=≤<=*a*,<=*b*<=≤<=109). The second line contains one integer *n*, the number of queries (1<=≤<=*n*<=≤<=104). Then *n* lines follow, each line contains one query consisting of two integers, *low* and *high* (1<=≤<=*low*<=≤<=*high*<=≤<=109).","Print *n* lines. The *i*-th of them should contain the result of the *i*-th query in the input. If there is no common divisor in the given range for any query, you should print -1 as a result for this query.",['9 27\n3\n1 5\n10 11\n9 11\n'],['3\n-1\n9\n'],none,OK,"def gcd(a,b):
    while a>0:
        x=a
        a=b%a
        b=x
    return(x)
def Bsearch1(L,x):
    beg=0
    last=len(L)-1
    while beg<=last:
        mid=(beg+last)//2
        if x==L[mid]:
            return(mid)
        elif(x>L[mid]):
            beg=mid+1
        else:
            last=mid-1
    else:
        return(beg)
def Bsearch2(L,x):
    beg=0
    last=len(L)-1
    while beg<=last:
        mid=(beg+last)//2
        if x==L[mid]:
            return(mid)
        elif(x>L[mid]):
            beg=mid+1
        else:
            last=mid-1
    else:
        return(last)
a,b=input().split()
a,b=[int(a),int(b)]
x=gcd(a,b)
from functools import reduce
def factors(n):
    x=set(reduce(list.__add__, 
                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))
    return(list(x))
div=factors(x)
div.sort()
y=int(input())
for j in range(y):
    c,d=input().split()
    c,d=[int(c),int(d)]
    f=Bsearch1(div,c)
    g=Bsearch2(div,d)
    if f>g:
        print(-1)
    else:
        print(div[g])","from math import gcd

def get_divisors(n):
    divisors = set()
    for i in range(1, int(n**0.5) + 1):
        if n % i == 0:
            divisors.add(i)
            divisors.add(n // i)
    return divisors

def find_gcd_in_range(a, b, queries):
    common_divisors = get_divisors(gcd(a, b))
    results = []

    for low, high in queries:

        valid_divisors = [d for d in common_divisors if low <= d <= high]
        if valid_divisors:
            results.append(max(valid_divisors))
        else:
            results.append(-1)

    return results

if __name__ == ""__main__"":
    a, b = map(int, input().split())
    n = int(input())
    queries = [tuple(map(int, input().split())) for _ in range(n)]
    
    results = find_gcd_in_range(a, b, queries)
    for result in results:
        print(result)"
839,A,Arya and Bran,PROGRAMMING,['implementation'],"Bran and his older sister Arya are from the same house. Bran like candies so much, so Arya is going to give him some Candies.

At first, Arya and Bran have 0 Candies. There are *n* days, at the *i*-th day, Arya finds *a**i* candies in a box, that is given by the Many-Faced God. Every day she can give Bran at most 8 of her candies. If she don't give him the candies at the same day, they are saved for her and she can give them to him later.

Your task is to find the minimum number of days Arya needs to give Bran *k* candies before the end of the *n*-th day. Formally, you need to output the minimum day index to the end of which *k* candies will be given out (the days are indexed from 1 to *n*).

Print -1 if she can't give him *k* candies during *n* given days.","The first line contains two integers *n* and *k* (1<=≤<=*n*<=≤<=100, 1<=≤<=*k*<=≤<=10000).

The second line contains *n* integers *a*1,<=*a*2,<=*a*3,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=100).","If it is impossible for Arya to give Bran *k* candies within *n* days, print -1.

Otherwise print a single integer — the minimum number of days Arya needs to give Bran *k* candies before the end of the *n*-th day.","['2 3\n1 2\n', '3 17\n10 10 10\n', '1 9\n10\n']","['2', '3', '-1']","In the first sample, Arya can give Bran 3 candies in 2 days.

In the second sample, Arya can give Bran 17 candies in 3 days, because she can give him at most 8 candies per day.

In the third sample, Arya can't give Bran 9 candies, because she can give him at most 8 candies per day and she must give him the candies within 1 day.",WRONG_ANSWER,"import math as mt 
import sys,string
input=sys.stdin.readline

from collections import defaultdict
L=lambda : list(map(int,input().split()))
Ls=lambda : list(input().split())
M=lambda : map(int,input().split())
I=lambda :int(input())

n,k=M()
l=L()
g=0
f=0
for i in range(n):
    g+=min(8,l[i])
    if(g>=k):
        print(i+1)
        f=1
        break
if(f==0):
    print(-1)","def min_days_to_give_candies(n, k, candies):
    total_candies = 0
    for day in range(n):
        total_candies += candies[day]

        given_today = min(8, total_candies)
        total_candies -= given_today
        k -= given_today
        
        if k <= 0:
            return day + 1
    
    return -1 if k > 0 else n

n, k = map(int, input().split())
candies = list(map(int, input().split()))

result = min_days_to_give_candies(n, k, candies)
print(result)"
58,A,Chat room,PROGRAMMING,"['greedy', 'strings']","Vasya has recently learned to type and log on to the Internet. He immediately entered a chat room and decided to say hello to everybody. Vasya typed the word *s*. It is considered that Vasya managed to say hello if several letters can be deleted from the typed word so that it resulted in the word ""hello"". For example, if Vasya types the word ""ahhellllloou"", it will be considered that he said hello, and if he types ""hlelo"", it will be considered that Vasya got misunderstood and he didn't manage to say hello. Determine whether Vasya managed to say hello by the given word *s*.","The first and only line contains the word *s*, which Vasya typed. This word consisits of small Latin letters, its length is no less that 1 and no more than 100 letters.","If Vasya managed to say hello, print ""YES"", otherwise print ""NO"".","['ahhellllloou\n', 'hlelo\n']","['YES\n', 'NO\n']",none,OK,"def stringcheck(s):
    word=""hello""
    req=""h""
    c=0
    for ch in s:
        if c==5:
            break
        if ch==req:
            c+=1
            if c<5:
                req=word[c]
                
    if c==5:
        print(""YES"")
    else:
        print(""NO"")
s=input()
stringcheck(s)","def can_say_hello(s):
    target = ""hello""
    target_index = 0
    
    for char in s:
        if char == target[target_index]:
            target_index += 1
        if target_index == len(target):
            return ""YES""
    
    return ""NO""

input_word = input().strip()
result = can_say_hello(input_word)
print(result)"
371,D,Vessels,PROGRAMMING,"['data structures', 'dsu', 'implementation', 'trees']","There is a system of *n* vessels arranged one above the other as shown in the figure below. Assume that the vessels are numbered from 1 to *n*, in the order from the highest to the lowest, the volume of the *i*-th vessel is *a**i* liters.

Initially, all the vessels are empty. In some vessels water is poured. All the water that overflows from the *i*-th vessel goes to the (*i*<=+<=1)-th one. The liquid that overflows from the *n*-th vessel spills on the floor.

Your task is to simulate pouring water into the vessels. To do this, you will need to handle two types of queries:
 1.  Add *x**i* liters of water to the *p**i*-th vessel; 1.  Print the number of liters of water in the *k**i*-th vessel. 
When you reply to the second request you can assume that all the water poured up to this point, has already overflown between the vessels.","The first line contains integer *n* — the number of vessels (1<=≤<=*n*<=≤<=2·105). The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* — the vessels' capacities (1<=≤<=*a**i*<=≤<=109). The vessels' capacities do not necessarily increase from the top vessels to the bottom ones (see the second sample). The third line contains integer *m* — the number of queries (1<=≤<=*m*<=≤<=2·105). Each of the next *m* lines contains the description of one query. The query of the first type is represented as ""1 *p**i* *x**i*"", the query of the second type is represented as ""2 *k**i*"" (1<=≤<=*p**i*<=≤<=*n*, 1<=≤<=*x**i*<=≤<=109, 1<=≤<=*k**i*<=≤<=*n*).","For each query, print on a single line the number of liters of water in the corresponding vessel.","['2\n5 10\n6\n1 1 4\n2 1\n1 2 5\n1 1 4\n2 1\n2 2\n', '3\n5 10 8\n6\n1 1 12\n2 2\n1 1 6\n1 3 2\n2 2\n2 3\n']","['4\n5\n8\n', '7\n10\n5\n']",none,RUNTIME_ERROR,"n = int(input())
capacidades = list(map(int, input().split()))
copos = [0 for x in range(n)]
m = int(input())
consultas = [tuple(map(int, input().split())) for x in range(m)]

def atualizar(p, x):

    if len(copos) <= p:
        return

    if capacidades[p] - copos[p] < x:
        cheio = capacidades[p] - copos[p]
    else:
        cheio = x

    x -= cheio
    copos[p] += cheio
    if x > 0:
        atualizar(p+1, x)

for consulta in consultas:
    if consulta[0] == 1:
        atualizar(consulta[1]-1, consulta[2])
    else:
        print(copos[consulta[1]-1])","def simulate_vessels(queries, capacities, n):

    water_levels = [0] * n

    for query in queries:
        parts = list(map(int, query.split()))
        
        if parts[0] == 1:
            p_i = parts[1] - 1
            x_i = parts[2]
            water_levels[p_i] += x_i

            for i in range(p_i, n):
                if water_levels[i] > capacities[i]:
                    overflow = water_levels[i] - capacities[i]
                    water_levels[i] = capacities[i]
                    if i + 1 < n:
                        water_levels[i + 1] += overflow
                else:
                    break
            
        elif parts[0] == 2:
            k_i = parts[1] - 1
            print(water_levels[k_i])

demo_inputs = [
    '2\n5 10\n6\n1 1 4\n2 1\n1 2 5\n1 1 4\n2 1\n2 2\n',
    '3\n5 10 8\n6\n1 1 12\n2 2\n1 1 6\n1 3 2\n2 2\n2 3\n'
]

for demo in demo_inputs:
    data = demo.splitlines()
    n = int(data[0])
    capacities = list(map(int, data[1].split()))
    m = int(data[2])
    queries = data[3:3 + m]
    simulate_vessels(queries, capacities, n)"
137,C,History,PROGRAMMING,['sortings'],"Polycarpus likes studying at school a lot and he is always diligent about his homework. Polycarpus has never had any problems with natural sciences as his great-great-grandfather was the great physicist Seinstein. On the other hand though, Polycarpus has never had an easy time with history.

Everybody knows that the World history encompasses exactly *n* events: the *i*-th event had continued from the year *a**i* to the year *b**i* inclusive (*a**i*<=&lt;<=*b**i*). Polycarpus easily learned the dates when each of *n* events started and ended (Polycarpus inherited excellent memory from his great-great-granddad). But the teacher gave him a more complicated task: Polycaprus should know when all events began and ended and he should also find out for each event whether it includes another event. Polycarpus' teacher thinks that an event *j* includes an event *i* if *a**j*<=&lt;<=*a**i* and *b**i*<=&lt;<=*b**j*. Your task is simpler: find the number of events that are included in some other event.","The first input line contains integer *n* (1<=≤<=*n*<=≤<=105) which represents the number of events. Next *n* lines contain descriptions of the historical events, one event per line. The *i*<=+<=1 line contains two integers *a**i* and *b**i* (1<=≤<=*a**i*<=&lt;<=*b**i*<=≤<=109) — the beginning and the end of the *i*-th event. No two events start or finish in the same year, that is, *a**i*<=≠<=*a**j*,<=*a**i*<=≠<=*b**j*,<=*b**i*<=≠<=*a**j*,<=*b**i*<=≠<=*b**j* for all *i*, *j* (where *i*<=≠<=*j*). Events are given in arbitrary order.",Print the only integer — the answer to the problem.,"['5\n1 10\n2 9\n3 8\n4 7\n5 6\n', '5\n1 100\n2 50\n51 99\n52 98\n10 60\n', '1\n1 1000000000\n']","['4\n', '4\n', '0\n']","In the first example the fifth event is contained in the fourth. Similarly, the fourth event is contained in the third, the third — in the second and the second — in the first.

In the second example all events except the first one are contained in the first.

In the third example only one event, so the answer is 0.",OK,"import sys
from math import log2,floor,ceil,sqrt,gcd
import bisect

sys.setrecursionlimit(10**5)

Ri = lambda : [int(x) for x in sys.stdin.readline().split()]
ri = lambda : sys.stdin.readline().strip()

def input(): return sys.stdin.readline().strip()
def list2d(a, b, c): return [[c] * b for i in range(a)]
def list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]
def list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]
def ceil(x, y=1): return int(-(-x // y))
def INT(): return int(input())
def MAP(): return map(int, input().split())
def LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]
def Yes(): print('Yes')
def No(): print('No')
def YES(): print('YES')
def NO(): print('NO')
INF = 10 ** 18
MOD =  1000000007

n =int(ri())
lis = []
for i in range(n):
    temp = Ri()
    lis.append(temp)
lis.sort(key = lambda x : x[0])
cnt = 0
right = lis[0][1]
for i in range(1,len(lis)):
    if lis[i][1] < right:
        cnt+=1
    else:
        right= lis[i][1]
print(cnt)","def count_included_events(events):

    events.sort(key=lambda x: (x[0], -x[1]))
    
    count = 0
    max_end = -1

    for start, end in events:

        if end <= max_end:
            count += 1

        max_end = max(max_end, end)
        
    return count

if __name__ == ""__main__"":
    import sys
    
    input_data = sys.stdin.read().strip().split('\n')
    n = int(input_data[0])
    events = []

    for i in range(1, n + 1):
        a, b = map(int, input_data[i].split())
        events.append((a, b))

    result = count_included_events(events)
    print(result)"
568,A,Primes or Palindromes?,PROGRAMMING,"['brute force', 'implementation', 'math', 'number theory']","Rikhail Mubinchik believes that the current definition of prime numbers is obsolete as they are too complex and unpredictable. A palindromic number is another matter. It is aesthetically pleasing, and it has a number of remarkable properties. Help Rikhail to convince the scientific community in this!

Let us remind you that a number is called prime if it is integer larger than one, and is not divisible by any positive integer other than itself and one.

Rikhail calls a number a palindromic if it is integer, positive, and its decimal representation without leading zeros is a palindrome, i.e. reads the same from left to right and right to left.

One problem with prime numbers is that there are too many of them. Let's introduce the following notation: π(*n*) — the number of primes no larger than *n*, *rub*(*n*) — the number of palindromic numbers no larger than *n*. Rikhail wants to prove that there are a lot more primes than palindromic ones.

He asked you to solve the following problem: for a given value of the coefficient *A* find the maximum *n*, such that π(*n*)<=≤<=*A*·*rub*(*n*).","The input consists of two positive integers *p*, *q*, the numerator and denominator of the fraction that is the value of *A* (, ).","If such maximum number exists, then print it. Otherwise, print ""Palindromic tree is better than splay tree"" (without the quotes).","['1 1\n', '1 42\n', '6 4\n']","['40\n', '1\n', '172\n']",none,TIME_LIMIT_EXCEEDED,"def is_palindrome(num):
    
    copia = num
    if num < 10:
        return True
    
    nums = []
    while(True):
        nums.append(copia % 10)
        copia //= 10
        
        if copia == 0:
            break
    
    digitos = len(nums) // 2
    j = len(nums) - 1
    for i in range(digitos):
        if nums[i] != nums[j]:
            return False
        j -= 1

    return True

def palindromes(x):

    palindrome = []
    count = 0
    i = 1

    while(i <= x):
        if is_palindrome(i):
            count += 1

        palindrome.append(count)
        i += 1

    return palindrome

def primes(x):
    
    primes = [True] * x
    primes[0] = False
    primos = [0]
    count = 0
    i = 1

    while(i * i < x):
        if primes[i] == True:
            count += 1

            for j in range(i, x, i + 1):
                primes[j] = False
    
        primos.append(count)
        i += 1

    while(i < x):
        if primes[i] == True:
            count += 1
        
        primos.append(count)
        i += 1

    return primos

primos = primes(2000000)
palindromes = palindromes(2000000)

num = input().split()
num = [int(num[0]), int(num[1])]
i = 0
resultado = 0

while(i < 2000000):

    res = ((palindromes[i]) * num[0]) / num[1]
    if res >= primos[i]:
        resultado = i + 1
   
    i += 1

if resultado == 0:
    print(""Palindromic tree is better than splay tree"")

else:
    print(resultado)","def is_palindrome(num):
    """"""Check if a number is a palindrome.""""""
    return str(num) == str(num)[::-1]

def count_palindromes(n):
    """"""Count palindromic numbers up to n.""""""
    count = 0
    for i in range(1, n + 1):
        if is_palindrome(i):
            count += 1
    return count

def is_prime(num):
    """"""Check if a number is prime.""""""
    if num <= 1:
        return False
    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            return False
    return True

def count_primes(n):
    """"""Count prime numbers up to n.""""""
    count = 0
    for i in range(2, n + 1):
        if is_prime(i):
            count += 1
    return count

def maximum_n(p, q):
    """"""Find the maximum n such that π(n) <= A * rub(n).""""""
    A = p / q
    max_n = 0
    
    for n in range(1, 10**6):
        prime_count = count_primes(n)
        palin_count = count_palindromes(n)
        
        if prime_count <= A * palin_count:
            max_n = n
        else:
            break
    
    return max_n

input_data = ['1 1\n', '1 42\n', '6 4\n']
output_data = []

for line in input_data:
    p, q = map(int, line.strip().split())
    result = maximum_n(p, q)
    if result > 0:
        output_data.append(f""{result}\n"")
    else:
        output_data.append(""Palindromic tree is better than splay tree\n"")

print(''.join(output_data), end='')"
898,C,Phone Numbers,PROGRAMMING,"['implementation', 'strings']","Vasya has several phone books, in which he recorded the telephone numbers of his friends. Each of his friends can have one or several phone numbers.

Vasya decided to organize information about the phone numbers of friends. You will be given *n* strings — all entries from Vasya's phone books. Each entry starts with a friend's name. Then follows the number of phone numbers in the current entry, and then the phone numbers themselves. It is possible that several identical phones are recorded in the same record.

Vasya also believes that if the phone number *a* is a suffix of the phone number *b* (that is, the number *b* ends up with *a*), and both numbers are written by Vasya as the phone numbers of the same person, then *a* is recorded without the city code and it should not be taken into account.

The task is to print organized information about the phone numbers of Vasya's friends. It is possible that two different people have the same number. If one person has two numbers *x* and *y*, and *x* is a suffix of *y* (that is, *y* ends in *x*), then you shouldn't print number *x*. If the number of a friend in the Vasya's phone books is recorded several times in the same format, it is necessary to take it into account exactly once.

Read the examples to understand statement and format of the output better.","First line contains the integer *n* (1<=≤<=*n*<=≤<=20) — number of entries in Vasya's phone books. 

The following *n* lines are followed by descriptions of the records in the format described in statement. Names of Vasya's friends are non-empty strings whose length does not exceed 10. They consists only of lowercase English letters. Number of phone numbers in one entry is not less than 1 is not more than 10. The telephone numbers consist of digits only. If you represent a phone number as a string, then its length will be in range from 1 to 10. Phone numbers can contain leading zeros.","Print out the ordered information about the phone numbers of Vasya's friends. First output *m* — number of friends that are found in Vasya's phone books.

The following *m* lines must contain entries in the following format ""name number_of_phone_numbers phone_numbers"". Phone numbers should be separated by a space. Each record must contain all the phone numbers of current friend.

Entries can be displayed in arbitrary order, phone numbers for one record can also be printed in arbitrary order.","['2\nivan 1 00123\nmasha 1 00123\n', '3\nkarl 2 612 12\npetr 1 12\nkatya 1 612\n', '4\nivan 3 123 123 456\nivan 2 456 456\nivan 8 789 3 23 6 56 9 89 2\ndasha 2 23 789\n']","['2\nmasha 1 00123 \nivan 1 00123 \n', '3\nkatya 1 612 \npetr 1 12 \nkarl 1 612 \n', '2\ndasha 2 23 789 \nivan 4 789 123 2 456 \n']",none,WRONG_ANSWER,"import sys
input = sys.stdin.readline
from collections import *

def judge(s, t):
    return s[len(s)-len(t):]==t

d = defaultdict(set)

for _ in range(int(input())):
    l = list(input().split())
    
    for num in l[2:]:
        d[l[0]].add(num)

for k in d.keys():
    ans = []
    
    for num1 in d[k]:
        flag = True
        
        for num2 in d[k]:
            if num1==num2:
                continue
            
            if judge(num2, num1):
                flag = False
        
        if flag:
            ans.append(num1)
    
    print(k, len(ans), *ans)","def organize_phone_numbers(entries):
    from collections import defaultdict

    phonebook = defaultdict(set)

    for entry in entries:
        data = entry.split()
        name = data[0]
        num_count = int(data[1])
        numbers = data[2:2 + num_count]

        for number in numbers:
            phonebook[name].add(number)

    organized_book = {}
    
    for name, numbers in phonebook.items():
        sorted_numbers = sorted(numbers, key=len)
        unique_numbers = set()

        for number in sorted_numbers:

            if not any(num.endswith(number) for num in unique_numbers):
                unique_numbers.add(number)

        organized_book[name] = unique_numbers

    output = []
    output.append(str(len(organized_book)))
    
    for name, numbers in organized_book.items():
        output.append(f""{name} {len(numbers)} "" + ' '.join(numbers))

    return output

inputs = [
    ['2\nivan 1 00123\nmasha 1 00123\n'],
    ['3\nkarl 2 612 12\npetr 1 12\nkatya 1 612\n'],
    ['4\nivan 3 123 123 456\nivan 2 456 456\nivan 8 789 3 23 6 56 9 89 2\ndasha 2 23 789\n']
]

for input_text in inputs:
    n = int(input_text[0].strip().split()[0])
    entries = input_text[0].strip().split('\n')[1:n+1]
    result = organize_phone_numbers(entries)
    print('\n'.join(result))"
0,none,none,none,['none'],"Theater stage is a rectangular field of size *n*<=×<=*m*. The director gave you the stage's plan which actors will follow. For each cell it is stated in the plan if there would be an actor in this cell or not.

You are to place a spotlight on the stage in some good position. The spotlight will project light in one of the four directions (if you look at the stage from above) — left, right, up or down. Thus, the spotlight's position is a cell it is placed to and a direction it shines.

A position is good if two conditions hold: 
 -  there is no actor in the cell the spotlight is placed to; -  there is at least one actor in the direction the spotlight projects. 
Count the number of good positions for placing the spotlight. Two positions of spotlight are considered to be different if the location cells or projection direction differ.","The first line contains two positive integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=1000) — the number of rows and the number of columns in the plan.

The next *n* lines contain *m* integers, 0 or 1 each — the description of the plan. Integer 1, means there will be an actor in the corresponding cell, while 0 means the cell will remain empty. It is guaranteed that there is at least one actor in the plan.",Print one integer — the number of good positions for placing the spotlight.,"['2 4\n0 1 0 0\n1 0 1 0\n', '4 4\n0 0 0 0\n1 0 0 1\n0 1 1 0\n0 1 0 0\n']","['9\n', '20\n']","In the first example the following positions are good:
 1.  the (1, 1) cell and right direction; 1.  the (1, 1) cell and down direction; 1.  the (1, 3) cell and left direction; 1.  the (1, 3) cell and down direction; 1.  the (1, 4) cell and left direction; 1.  the (2, 2) cell and left direction; 1.  the (2, 2) cell and up direction; 1.  the (2, 2) and right direction; 1.  the (2, 4) cell and left direction. 
Therefore, there are 9 good positions in this example.",TIME_LIMIT_EXCEEDED,"n, m=map(int, input().split())
a=[list(map(int, input().split())) for _ in range(n)]
ans=p=0

def f(x):
    global ans, p
    if x==0:
        ans+=p
    else:
        p=1

for i in range(n):
    p=0
    for j in range(m):
        f(a[i][j])
    p=0
    for j in range(m-1, -1, -1):
        f(a[i][j])

for i in range(m):
    p=0
    for j in range(n):
        f(a[j][i])
    p=0
    for j in range(n-1, -1, -1):
        f(a[j][i])

print(ans)","n, m = map(int, input().split())
stage = [list(map(int, input().split())) for _ in range(n)]

good_positions = 0

for i in range(n):
    for j in range(m):
        if stage[i][j] == 0:

            if any(stage[i][k] == 1 for k in range(j + 1, m)):
                good_positions += 1

            if any(stage[i][k] == 1 for k in range(j - 1, -1, -1)):
                good_positions += 1

            if any(stage[k][j] == 1 for k in range(i + 1, n)):
                good_positions += 1

            if any(stage[k][j] == 1 for k in range(i - 1, -1, -1)):
                good_positions += 1

print(good_positions)"
230,B,T-primes,PROGRAMMING,"['binary search', 'implementation', 'math', 'number theory']","We know that prime numbers are positive integers that have exactly two distinct positive divisors. Similarly, we'll call a positive integer *t* Т-prime, if *t* has exactly three distinct positive divisors.

You are given an array of *n* positive integers. For each of them determine whether it is Т-prime or not.","The first line contains a single positive integer, *n* (1<=≤<=*n*<=≤<=105), showing how many numbers are in the array. The next line contains *n* space-separated integers *x**i* (1<=≤<=*x**i*<=≤<=1012).

Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is advised to use the cin, cout streams or the %I64d specifier.","Print *n* lines: the *i*-th line should contain ""YES"" (without the quotes), if number *x**i* is Т-prime, and ""NO"" (without the quotes), if it isn't.",['3\n4 5 6\n'],['YES\nNO\nNO\n'],"The given test has three numbers. The first number 4 has exactly three divisors — 1, 2 and 4, thus the answer for this number is ""YES"". The second number 5 has two divisors (1 and 5), and the third number 6 has four divisors (1, 2, 3, 6), hence the answer for them is ""NO"".",WRONG_ANSWER,"'''
刘思瑞 2100017810
'''
def search(num):
    if int(int(num**(0.5))**2) != num:
        return 'NO'
    for i in range(2,int(num**(0.5)+1)):
        if num % i == 0:
            if i**2 != num:
                return 'NO'
    return 'YES'

n = int(input())
num = list(map(int,input().split()))
for i in num:
    print(search(i))","import sys
import math

def is_t_prime(num):

    root = int(math.isqrt(num))
    return root * root == num and is_prime(root)

def is_prime(num):

    if num < 2:
        return False
    for i in range(2, int(math.sqrt(num)) + 1):
        if num % i == 0:
            return False
    return True

def main():
    input = sys.stdin.read
    data = input().split()

    n = int(data[0])
    results = []

    for i in range(1, n + 1):
        x_i = int(data[i])
        if is_t_prime(x_i):
            results.append(""YES"")
        else:
            results.append(""NO"")

    print(""\n"".join(results))

if __name__ == ""__main__"":
    main()"
336,B,Vasily the Bear and Fly,PROGRAMMING,['math'],"One beautiful day Vasily the bear painted 2*m* circles of the same radius *R* on a coordinate plane. Circles with numbers from 1 to *m* had centers at points (2*R*<=-<=*R*,<=0), (4*R*<=-<=*R*,<=0), ..., (2*Rm*<=-<=*R*,<=0), respectively. Circles with numbers from *m*<=+<=1 to 2*m* had centers at points (2*R*<=-<=*R*,<=2*R*), (4*R*<=-<=*R*,<=2*R*), ..., (2*Rm*<=-<=*R*,<=2*R*), respectively. 

Naturally, the bear painted the circles for a simple experiment with a fly. The experiment continued for *m*2 days. Each day of the experiment got its own unique number from 0 to *m*2<=-<=1, inclusive. 

On the day number *i* the following things happened: 
 1.  The fly arrived at the coordinate plane at the center of the circle with number  ( is the result of dividing number *x* by number *y*, rounded down to an integer). 1.  The fly went along the coordinate plane to the center of the circle number  ( is the remainder after dividing number *x* by number *y*). The bear noticed that the fly went from the center of circle *v* to the center of circle *u* along the shortest path with all points lying on the border or inside at least one of the 2*m* circles. After the fly reached the center of circle *u*, it flew away in an unknown direction. 
Help Vasily, count the average distance the fly went along the coordinate plane during each of these *m*2 days.","The first line contains two integers *m*,<=*R* (1<=≤<=*m*<=≤<=105, 1<=≤<=*R*<=≤<=10).",In a single line print a single real number — the answer to the problem. The answer will be considered correct if its absolute or relative error doesn't exceed 10<=-<=6.,"['1 1\n', '2 2\n']","['2.0000000000\n', '5.4142135624\n']","<img class=""tex-graphics"" src=""https://espresso.codeforces.com/9fe384073741e20965ddc4bf162afd3a604b6b39.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

Figure to the second sample",OK,"import math

m,R = map (int,input().split())

D = math.sqrt (2) * R
result = 0

def sum_dist (n):
  return n*(n+1)*R + 2*D*n

for i in range (1,m+1):
  result += 2*R
  if i-1   > 0: result += 2*R + D
  if m-i   > 0: result += 2*R + D
  if i-2   > 0: result += sum_dist (i-2)
  if m-i-1 > 0: result += sum_dist (m-i-1)

print (result / m / m)","import math

def average_fly_distance(m, R):
    total_distance = 0.0
    total_days = m * 2

    for i in range(total_days):

        circle_v_x = (2 * (i // 2 + 1) * R)
        circle_u_x = (2 * ((i % 2) + 1) * R)
        
        if i < m:
            circle_v_y = 0
            circle_u_y = 0
        else:
            circle_v_y = 2 * R
            circle_u_y = 2 * R

        distance = math.sqrt((circle_u_x - circle_v_x) ** 2 + (circle_u_y - circle_v_y) ** 2)
        total_distance += distance

    average_distance = total_distance / total_days
    return average_distance

if __name__ == ""__main__"":
    inputs = [input().strip().split() for _ in range(2)]
    results = []
    
    for m, R in inputs:
        m = int(m)
        R = int(R)
        result = average_fly_distance(m, R)
        results.append(f""{result:.10f}"")

    print('\n'.join(results))"
981,C,Useful Decomposition,PROGRAMMING,"['implementation', 'trees']","Ramesses knows a lot about problems involving trees (undirected connected graphs without cycles)!

He created a new useful tree decomposition, but he does not know how to construct it, so he asked you for help!

The decomposition is the splitting the edges of the tree in some simple paths in such a way that each two paths have at least one common vertex. Each edge of the tree should be in exactly one path.

Help Remesses, find such a decomposition of the tree or derermine that there is no such decomposition.","The first line contains a single integer $n$ ($2 \leq n \leq 10^{5}$) the number of nodes in the tree.

Each of the next $n<=-<=1$ lines contains two integers $a_i$ and $b_i$ ($1 \leq a_i, b_i \leq n$, $a_i \neq b_i$) — the edges of the tree. It is guaranteed that the given edges form a tree.","If there are no decompositions, print the only line containing ""No"".

Otherwise in the first line print ""Yes"", and in the second line print the number of paths in the decomposition $m$. 

Each of the next $m$ lines should contain two integers $u_i$, $v_i$ ($1 \leq u_i, v_i \leq n$, $u_i \neq v_i$) denoting that one of the paths in the decomposition is the simple path between nodes $u_i$ and $v_i$. 

Each pair of paths in the decomposition should have at least one common vertex, and each edge of the tree should be presented in exactly one path. You can print the paths and the ends of each path in arbitrary order.

If there are multiple decompositions, print any.","['4\n1 2\n2 3\n3 4\n', '6\n1 2\n2 3\n3 4\n2 5\n3 6\n', '5\n1 2\n1 3\n1 4\n1 5\n']","['Yes\n1\n1 4\n', 'No\n', 'Yes\n4\n1 2\n1 3\n1 4\n1 5\n']","The tree from the first example is shown on the picture below: <img class=""tex-graphics"" src=""https://espresso.codeforces.com/9eb4b4c143d3ad267ae05d1e43341bd368b3088b.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> The number next to each edge corresponds to the path number in the decomposition. It is easy to see that this decomposition suits the required conditions.

The tree from the second example is shown on the picture below: <img class=""tex-graphics"" src=""https://espresso.codeforces.com/20704b97182d9bcde3321c00a16edcae4d772d93.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> We can show that there are no valid decompositions of this tree.

The tree from the third example is shown on the picture below: <img class=""tex-graphics"" src=""https://espresso.codeforces.com/357ff9496a4ed4746401160ee6ee63f5d57d81b9.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> The number next to each edge corresponds to the path number in the decomposition. It is easy to see that this decomposition suits the required conditions.",RUNTIME_ERROR,"def local_input():
    from pcm.utils import set_stdin
    import sys
    if len(sys.argv) == 1:
        set_stdin(os.path.dirname(__file__) + '/test/' + 'sample-1.in')

import sys
import os
from sys import stdin, stdout
import time
import re
from pydoc import help
import string
import math
import numpy as np
from operator import itemgetter
from collections import Counter
from collections import deque
from collections import defaultdict as dd
import fractions
from heapq import heappop, heappush, heapify
import array
from bisect import bisect_left, bisect_right, insort_left, insort_right
from copy import deepcopy as dcopy
import itertools
sys.setrecursionlimit(10**7)
INF = 10**20
GOSA = 1.0 / 10**10
MOD = 10**9+7
ALPHABETS = [chr(i) for i in range(ord('a'), ord('z')+1)]
def LI(): return [int(x) for x in sys.stdin.readline().split()]
def LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]
def LF(): return [float(x) for x in sys.stdin.readline().split()]
def LS(): return sys.stdin.readline().split()
def I(): return int(sys.stdin.readline())
def F(): return float(sys.stdin.readline())
def DP(N, M, first): return [[first] * M for n in range(N)]
def DP3(N, M, L, first): return [[[first] * L for n in range(M)] for _ in range(N)]

def solve():
    global T, N, g
    N = int(input())

    T = [[] for _ in range(N)]
    for n in range(N-1):
        a, b = map(lambda x:int(x)-1, input().split())
        T[a].append(b)
        T[b].append(a)

    g = -1
    for n, t in enumerate(T):
        if len(t) >= 3 and g==-1:
            g = n
        elif len(t) >= 3 and g!=-1:
            print(""No"")
            return

    if g == -1:
        print(""Yes"")
        print(""1"")
        res = []
        for n, t in enumerate(T):
            if len(t) == 1:
                res.append(n+1)
        print(*res)
        return

    print(""Yes"")
    print(len(T[g]))
    res = """"
    for n in T[g]:
        res += str(g+1)+"" ""+str(get_tip(n)+1)+""\n""
    stdout.write(res)

def get_tip(n):
    R = [0]*N
    R[g] = 1
    now = n
    while True:
        if len(T[now]) == 1:
            return now
        if R[T[now][0]] == 0:
            R[now] = 1
            now = T[now][0]
        elif R[T[now][1]] == 0:
            R[now] = 1
            now = T[now][1]

if __name__ == ""__main__"":
    try:
        local_input()
    except:
        pass
    solve()","def tree_decomposition(n, edges):
    from collections import defaultdict

    graph = defaultdict(list)
    for u, v in edges:
        graph[u].append(v)
        graph[v].append(u)

    degrees = [0] * (n + 1)
    for u in graph:
        degrees[u] = len(graph[u])

    if any(deg > 2 for deg in degrees):
        return ""No""

    paths = []
    visited = [False] * (n + 1)

    def dfs(node, parent):
        visited[node] = True
        current_path = [node]
        for neighbor in graph[node]:
            if neighbor != parent and not visited[neighbor]:
                current_path += dfs(neighbor, node)
        return current_path

    for start in range(1, n + 1):
        if not visited[start]:
            path = dfs(start, -1)
            paths.append((path[0], path[-1]))

    result = [""Yes"", str(len(paths))]
    result.extend(f""{u} {v}"" for u, v in paths)
    return ""\n"".join(result)

import sys
input = sys.stdin.read
data = input().strip().split('\n')
test_cases = []

for i in range(0, len(data), 1):
    edges = []
    if i == 0:
        n = int(data[i])
    else:
        a, b = map(int, data[i].split())
        edges.append((a, b))
    if i + 1 == n:
        test_cases.append((n, edges))

for n, edges in test_cases:
    print(tree_decomposition(n, edges))"
71,A,Way Too Long Words,PROGRAMMING,['strings'],"Sometimes some words like ""localization"" or ""internationalization"" are so long that writing them many times in one text is quite tiresome.

Let's consider a word too long, if its length is strictly more than 10 characters. All too long words should be replaced with a special abbreviation.

This abbreviation is made like this: we write down the first and the last letter of a word and between them we write the number of letters between the first and the last letters. That number is in decimal system and doesn't contain any leading zeroes.

Thus, ""localization"" will be spelt as ""l10n"", and ""internationalization» will be spelt as ""i18n"".

You are suggested to automatize the process of changing the words with abbreviations. At that all too long words should be replaced by the abbreviation and the words that are not too long should not undergo any changes.",The first line contains an integer *n* (1<=≤<=*n*<=≤<=100). Each of the following *n* lines contains one word. All the words consist of lowercase Latin letters and possess the lengths of from 1 to 100 characters.,Print *n* lines. The *i*-th line should contain the result of replacing of the *i*-th word from the input data.,['4\nword\nlocalization\ninternationalization\npneumonoultramicroscopicsilicovolcanoconiosis\n'],['word\nl10n\ni18n\np43s\n'],none,OK,"def way_too_long_words(txt_arr):
    res = []
    for input_txt in txt_arr:
        n = len(input_txt)
        if n <= 10:
            res.append(input_txt)
        else:
            res.append(input_txt[0] + str(n-2) + input_txt[-1])
    return res

if __name__ == ""__main__"":
    n = int(input())
    txt_arr = []
    for _ in range(n):
        txt_arr.append(input())
    res_arr = way_too_long_words(txt_arr)
    for res in res_arr:
        print(res)","def abbreviate_word(word):

    if len(word) > 10:

        abbreviation = f""{word[0]}{len(word) - 2}{word[-1]}""
        return abbreviation
    else:

        return word

def main():

    n = int(input())

    results = []
    
    for _ in range(n):

        word = input().strip()

        results.append(abbreviate_word(word))

    for result in results:
        print(result)

if __name__ == ""__main__"":
    main()"
1003,D,Coins and Queries,PROGRAMMING,['greedy'],"Polycarp has $n$ coins, the value of the $i$-th coin is $a_i$. It is guaranteed that all the values are integer powers of $2$ (i.e. $a_i = 2^d$ for some non-negative integer number $d$).

Polycarp wants to know answers on $q$ queries. The $j$-th query is described as integer number $b_j$. The answer to the query is the minimum number of coins that is necessary to obtain the value $b_j$ using some subset of coins (Polycarp can use only coins he has). If Polycarp can't obtain the value $b_j$, the answer to the $j$-th query is -1.

The queries are independent (the answer on the query doesn't affect Polycarp's coins).","The first line of the input contains two integers $n$ and $q$ ($1 \le n, q \le 2 \cdot 10^5$) — the number of coins and the number of queries.

The second line of the input contains $n$ integers $a_1, a_2, \dots, a_n$ — values of coins ($1 \le a_i \le 2 \cdot 10^9$). It is guaranteed that all $a_i$ are integer powers of $2$ (i.e. $a_i = 2^d$ for some non-negative integer number $d$).

The next $q$ lines contain one integer each. The $j$-th line contains one integer $b_j$ — the value of the $j$-th query ($1 \le b_j \le 10^9$).",Print $q$ integers $ans_j$. The $j$-th integer must be equal to the answer on the $j$-th query. If Polycarp can't obtain the value $b_j$ the answer to the $j$-th query is -1.,['5 4\n2 4 8 2 4\n8\n5\n14\n10\n'],['1\n-1\n3\n2\n'],none,RUNTIME_ERROR,"def main():
	n, q = map(int, input().split())
	a = [*map(int, input().split())]
	d = {}
	for i in range(n):
		d[a[i]] = d.get(a[i], 0) + 1
	for i in range(q):
		x = int(input())
		c = 0
		for j in reversed(d.keys()):
			y = min(d[j], x // j)
			c += y
			x -= y * j
		if x:
			print(-1)
		else:
			print(c)
if __name__ == '__main__':
    main()","def min_coins_to_make_value(n, q, coins, queries):

    coin_count = {}
    for coin in coins:
        if coin in coin_count:
            coin_count[coin] += 1
        else:
            coin_count[coin] = 1

    answers = []
    
    for target in queries:

        needed = target
        total_coins = 0

        for coin in sorted(coin_count.keys(), reverse=True):
            if needed == 0:
                break

            max_coins = needed // coin
            coins_used = min(max_coins, coin_count[coin])
            total_coins += coins_used
            needed -= coins_used * coin

        if needed > 0:
            answers.append(-1)
        else:
            answers.append(total_coins)
    
    return answers

n, q = map(int, input().split())
coins = list(map(int, input().split()))
queries = [int(input()) for _ in range(q)]

results = min_coins_to_make_value(n, q, coins, queries)

for result in results:
    print(result)"
981,A,Antipalindrome,PROGRAMMING,"['brute force', 'implementation', 'strings']","A string is a palindrome if it reads the same from the left to the right and from the right to the left. For example, the strings ""kek"", ""abacaba"", ""r"" and ""papicipap"" are palindromes, while the strings ""abb"" and ""iq"" are not.

A substring $s[l \ldots r]$ ($1<=\leq<=l<=\leq<=r<=\leq<=|s|$) of a string $s<==<=s_{1}s_{2} \ldots s_{|s|}$ is the string $s_{l}s_{l<=+<=1} \ldots s_{r}$.

Anna does not like palindromes, so she makes her friends call her Ann. She also changes all the words she reads in a similar way. Namely, each word $s$ is changed into its longest substring that is not a palindrome. If all the substrings of $s$ are palindromes, she skips the word at all.

Some time ago Ann read the word $s$. What is the word she changed it into?","The first line contains a non-empty string $s$ with length at most $50$ characters, containing lowercase English letters only.","If there is such a substring in $s$ that is not a palindrome, print the maximum length of such a substring. Otherwise print $0$.

Note that there can be multiple longest substrings that are not palindromes, but their length is unique.","['mew\n', 'wuffuw\n', 'qqqqqqqq\n']","['3\n', '5\n', '0\n']","""mew"" is not a palindrome, so the longest substring of it that is not a palindrome, is the string ""mew"" itself. Thus, the answer for the first example is $3$.

The string ""uffuw"" is one of the longest non-palindrome substrings (of length $5$) of the string ""wuffuw"", so the answer for the second example is $5$.

All substrings of the string ""qqqqqqqq"" consist of equal characters so they are palindromes. This way, there are no non-palindrome substrings. Thus, the answer for the third example is $0$.",OK,"""""""https://codeforces.com/problemset/problem/981/A
""""""

s = input()
for r in range(len(s), 1, -1):
    if s[:r] != s[r - 1::-1]:
        print(r)
        break
else:
    print(0)","def is_palindrome(s):

    return s == s[::-1]

def longest_non_palindrome_substring(s):

    if not is_palindrome(s):
        return len(s)

    n = len(s)

    if not is_palindrome(s[:-1]):
        return n - 1
    
    if not is_palindrome(s[1:]):
        return n - 1

    return 0

def main():
    import sys

    input_strings = sys.stdin.read().strip().split('\n')
    results = []
    
    for string in input_strings:

        result = longest_non_palindrome_substring(string)
        results.append(result)

    for res in results:
        print(res)

if __name__ == ""__main__"":
    main()"
129,A,Cookies,PROGRAMMING,['implementation'],"Olga came to visit the twins Anna and Maria and saw that they have many cookies. The cookies are distributed into bags. As there are many cookies, Olga decided that it's no big deal if she steals a bag. However, she doesn't want the sisters to quarrel because of nothing when they divide the cookies. That's why Olga wants to steal a bag with cookies so that the number of cookies in the remaining bags was even, that is, so that Anna and Maria could evenly divide it into two (even 0 remaining cookies will do, just as any other even number). How many ways there are to steal exactly one cookie bag so that the total number of cookies in the remaining bags was even?",The first line contains the only integer *n* (1<=≤<=*n*<=≤<=100) — the number of cookie bags Anna and Maria have. The second line contains *n* integers *a**i* (1<=≤<=*a**i*<=≤<=100) — the number of cookies in the *i*-th bag.,Print in the only line the only number — the sought number of ways. If there are no such ways print 0.,"['1\n1\n', '10\n1 2 2 3 4 4 4 2 2 2\n', '11\n2 2 2 2 2 2 2 2 2 2 99\n']","['1\n', '8\n', '1\n']","In the first sample Olga should take the only bag so that the twins ended up with the even number of cookies.

In the second sample Olga can take any of five bags with two cookies or any of three bags with four cookies — 5 + 3 = 8 ways in total.

In the third sample, no matter which bag with two cookies Olga chooses, the twins are left with 2 * 9 + 99 = 117 cookies. Thus, Olga has only one option: to take the bag with 99 cookies.",WRONG_ANSWER,"def solve(n, a):
    count = 0
    for i in range(n):
        for j in range(i+1, n+1):
            if sum(a[i:j]) % 2 == 1:
                count += 1
    return count

n = int(input())
a = list(map(int, input().split()))
print(solve(n, a))","n = int(input())

cookies = list(map(int, input().split()))

total_cookies = sum(cookies)

count_valid_bags = 0

for bag in cookies:
    if (total_cookies - bag) % 2 == 0:
        count_valid_bags += 1

print(count_valid_bags)"
82,A,Double Cola,PROGRAMMING,"['implementation', 'math']","Sheldon, Leonard, Penny, Rajesh and Howard are in the queue for a ""Double Cola"" drink vending machine; there are no other people in the queue. The first one in the queue (Sheldon) buys a can, drinks it and doubles! The resulting two Sheldons go to the end of the queue. Then the next in the queue (Leonard) buys a can, drinks it and gets to the end of the queue as two Leonards, and so on. This process continues ad infinitum.

For example, Penny drinks the third can of cola and the queue will look like this: Rajesh, Howard, Sheldon, Sheldon, Leonard, Leonard, Penny, Penny.

Write a program that will print the name of a man who will drink the *n*-th can.

Note that in the very beginning the queue looks like that: Sheldon, Leonard, Penny, Rajesh, Howard. The first person is Sheldon.","The input data consist of a single integer *n* (1<=≤<=*n*<=≤<=109).

It is guaranteed that the pretests check the spelling of all the five names, that is, that they contain all the five possible answers.","Print the single line — the name of the person who drinks the *n*-th can of cola. The cans are numbered starting from 1. Please note that you should spell the names like this: ""Sheldon"", ""Leonard"", ""Penny"", ""Rajesh"", ""Howard"" (without the quotes). In that order precisely the friends are in the queue initially.","['1\n', '6\n', '1802\n']","['Sheldon\n', 'Sheldon\n', 'Penny\n']",none,OK,"x = int(input())

n=1
lvl_arr = [0]
def LvL(n):
  lvl_arr.append(2**(n-1)*5 + lvl_arr[n-1])
  return lvl_arr[n]

while(x > LvL(n)):
  n = n+1

p = ((x - lvl_arr[n-1] - 1) // 2**(n-1)) + 1

if(p == 1):
  print(""Sheldon"")
elif(p == 2):
  print(""Leonard"")
elif(p == 3):
  print(""Penny"")
elif(p == 4):
  print(""Rajesh"")
else:
  print(""Howard"")","def who_drinks(n):

    queue = [""Sheldon"", ""Leonard"", ""Penny"", ""Rajesh"", ""Howard""]

    count = 1
    
    while n > 5 * count:
        n -= 5 * count
        count *= 2

    index = (n - 1) // count
    return queue[index]

inputs = [1, 6, 1802]

outputs = [who_drinks(n) for n in inputs]
print(outputs)"
59,A,Word,PROGRAMMING,"['implementation', 'strings']","Vasya is very upset that many people on the Net mix uppercase and lowercase letters in one word. That's why he decided to invent an extension for his favorite browser that would change the letters' register in every word so that it either only consisted of lowercase letters or, vice versa, only of uppercase ones. At that as little as possible letters should be changed in the word. For example, the word HoUse must be replaced with house, and the word ViP — with VIP. If a word contains an equal number of uppercase and lowercase letters, you should replace all the letters with lowercase ones. For example, maTRIx should be replaced by matrix. Your task is to use the given method on one given word.",The first line contains a word *s* — it consists of uppercase and lowercase Latin letters and possesses the length from 1 to 100.,"Print the corrected word *s*. If the given word *s* has strictly more uppercase letters, make the word written in the uppercase register, otherwise - in the lowercase one.","['HoUse\n', 'ViP\n', 'maTRIx\n']","['house\n', 'VIP\n', 'matrix\n']",none,WRONG_ANSWER,"N = 200
vis = [0]*30

def main():
    n = int(input())
    for _ in range(n):
        ss = input().strip()
        vis.clear()
        vis = [0]*30
        l = len(ss)
        f = True
        mx = 0
        mi = 110
        for i in range(l):
            vis[ord(ss[i])-ord('a')] = 1
            mx = max(mx, ord(ss[i])-ord('a'))
            mi = min(mi, ord(ss[i])-ord('a'))
        for i in range(mi, mx+1):
            if vis[i] == 0:
                f = False
                break
        if f and mx-mi+1 == l:
            print(""Yes"")
        else:
            print(""No"")","def correct_word_case(s):

    upper_count = sum(1 for c in s if c.isupper())
    lower_count = len(s) - upper_count

    if upper_count > lower_count:
        return s.upper()
    else:
        return s.lower()

words = ['HoUse\n', 'ViP\n', 'maTRIx\n']
corrected_words = []

for word in words:
    corrected_word = correct_word_case(word.strip())
    corrected_words.append(corrected_word)

for corrected in corrected_words:
    print(corrected)"
157,B,Trace,PROGRAMMING,"['geometry', 'sortings']","One day, as Sherlock Holmes was tracking down one very important criminal, he found a wonderful painting on the wall. This wall could be represented as a plane. The painting had several concentric circles that divided the wall into several parts. Some parts were painted red and all the other were painted blue. Besides, any two neighboring parts were painted different colors, that is, the red and the blue color were alternating, i. e. followed one after the other. The outer area of the wall (the area that lied outside all circles) was painted blue. Help Sherlock Holmes determine the total area of red parts of the wall.

Let us remind you that two circles are called concentric if their centers coincide. Several circles are called concentric if any two of them are concentric.",The first line contains the single integer *n* (1<=≤<=*n*<=≤<=100). The second line contains *n* space-separated integers *r**i* (1<=≤<=*r**i*<=≤<=1000) — the circles' radii. It is guaranteed that all circles are different.,Print the single real number — total area of the part of the wall that is painted red. The answer is accepted if absolute or relative error doesn't exceed 10<=-<=4.,"['1\n1\n', '3\n1 4 2\n']","['3.1415926536\n', '40.8407044967\n']","In the first sample the picture is just one circle of radius 1. Inner part of the circle is painted red. The area of the red part equals π × 1<sup class=""upper-index"">2</sup> = π.

In the second sample there are three circles of radii 1, 4 and 2. Outside part of the second circle is painted blue. Part between the second and the third circles is painted red. Part between the first and the third is painted blue. And, finally, the inner part of the first circle is painted red. Overall there are two red parts: the ring between the second and the third circles and the inner part of the first circle. Total area of the red parts is equal (π × 4<sup class=""upper-index"">2</sup> - π × 2<sup class=""upper-index"">2</sup>) + π × 1<sup class=""upper-index"">2</sup> = π × 12 + π = 13π",OK,"import math

n = int(input())
l_s = list(map(int, input().split()))
l_s.sort(reverse = True)

t = 0
for index in range(n):
    t += (-1 if index % 2 == 1 else 1) * l_s[index] ** 2

print(t * math.pi)","import math

n = int(input())

radii = list(map(int, input().split()))

radii.sort(reverse=True)

total_red_area = 0

for i in range(n):

    current_area = math.pi * (radii[i] ** 2)

    if i % 2 == 0:
        total_red_area += current_area
    else:

        total_red_area -= current_area

print(f""{total_red_area:.10f}"")"
598,D,Igor In the Museum,PROGRAMMING,"['dfs and similar', 'graphs', 'shortest paths']","Igor is in the museum and he wants to see as many pictures as possible.

Museum can be represented as a rectangular field of *n*<=×<=*m* cells. Each cell is either empty or impassable. Empty cells are marked with '.', impassable cells are marked with '*'. Every two adjacent cells of different types (one empty and one impassable) are divided by a wall containing one picture.

At the beginning Igor is in some empty cell. At every moment he can move to any empty cell that share a side with the current one.

For several starting positions you should calculate the maximum number of pictures that Igor can see. Igor is able to see the picture only if he is in the cell adjacent to the wall with this picture. Igor have a lot of time, so he will examine every picture he can see.","First line of the input contains three integers *n*, *m* and *k* (3<=≤<=*n*,<=*m*<=≤<=1000,<=1<=≤<=*k*<=≤<=*min*(*n*·*m*,<=100<=000)) — the museum dimensions and the number of starting positions to process.

Each of the next *n* lines contains *m* symbols '.', '*' — the description of the museum. It is guaranteed that all border cells are impassable, so Igor can't go out from the museum.

Each of the last *k* lines contains two integers *x* and *y* (1<=≤<=*x*<=≤<=*n*,<=1<=≤<=*y*<=≤<=*m*) — the row and the column of one of Igor's starting positions respectively. Rows are numbered from top to bottom, columns — from left to right. It is guaranteed that all starting positions are empty cells.","Print *k* integers — the maximum number of pictures, that Igor can see if he starts in corresponding position.","['5 6 3\n******\n*..*.*\n******\n*....*\n******\n2 2\n2 5\n4 3\n', '4 4 1\n****\n*..*\n*.**\n****\n3 2\n']","['6\n4\n10\n', '8\n']",none,TIME_LIMIT_EXCEEDED,"def dfs(x, y, n, m, museum, visited):
    if x < 0 or x >= n or y < 0 or y >= m or visited[x][y] or museum[x][y] == '*':
        return 0

    visited[x][y] = True
    pictures = 0

    for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):
        if 0 <= x + dx < n and 0 <= y + dy < m and museum[x + dx][y + dy] == '*':
            pictures += 1
        else:
            pictures += dfs(x + dx, y + dy, n, m, museum, visited)

    return pictures

def igor_in_the_museum(n, m, k, museum, starting_positions):
    results = []
    for x, y in starting_positions:
        visited = [[False] * m for _ in range(n)]
        result = dfs(x - 1, y - 1, n, m, museum, visited)
        results.append(result)

    return results

n, m, k = map(int, input().split())
museum = [input() for _ in range(n)]
starting_positions = [tuple(map(int, input().split())) for _ in range(k)]

result = igor_in_the_museum(n, m, k, museum, starting_positions)

for num_pictures in result:
    print(num_pictures)","def count_pictures(n, m, museum, start_positions):

    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    
    def bfs(start_x, start_y):
        """"""Perform BFS from the starting position to count visible pictures.""""""
        visited = set()
        queue = [(start_x, start_y)]
        visited.add((start_x, start_y))
        pictures_count = 0
        
        while queue:
            x, y = queue.pop(0)

            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                if 0 <= nx < n and 0 <= ny < m:
                    if (nx, ny) not in visited:
                        if museum[nx][ny] == '.':
                            queue.append((nx, ny))
                            visited.add((nx, ny))
                        elif museum[nx][ny] == '*':
                            pictures_count += 1
        return pictures_count

    results = []
    for x, y in start_positions:

        results.append(bfs(x - 1, y - 1))
    
    return results

input_data = ['5 6 3\n******\n*..*.*\n******\n*....*\n******\n2 2\n2 5\n4 3\n', '4 4 1\n****\n*..*\n*.**\n****\n3 2\n']

for case in input_data:
    lines = case.strip().splitlines()
    n, m, k = map(int, lines[0].split())
    museum = [line for line in lines[1:n + 1]]
    start_positions = [tuple(map(int, line.split())) for line in lines[n + 1:n + 1 + k]]

    results = count_pictures(n, m, museum, start_positions)
    print('\n'.join(map(str, results)))"
938,A,Word Correction,PROGRAMMING,['implementation'],"Victor tries to write his own text editor, with word correction included. However, the rules of word correction are really strange.

Victor thinks that if a word contains two consecutive vowels, then it's kinda weird and it needs to be replaced. So the word corrector works in such a way: as long as there are two consecutive vowels in the word, it deletes the first vowel in a word such that there is another vowel right before it. If there are no two consecutive vowels in the word, it is considered to be correct.

You are given a word *s*. Can you predict what will it become after correction?

In this problem letters a, e, i, o, u and y are considered to be vowels.","The first line contains one integer *n* (1<=≤<=*n*<=≤<=100) — the number of letters in word *s* before the correction.

The second line contains a string *s* consisting of exactly *n* lowercase Latin letters — the word before the correction.",Output the word *s* after the correction.,"['5\nweird\n', '4\nword\n', '5\naaeaa\n']","['werd\n', 'word\n', 'a\n']","Explanations of the examples:
 1.  There is only one replace: weird <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> werd;1.  No replace needed since there are no two consecutive vowels;1.  aaeaa <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> aeaa <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> aaa <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> aa <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> a.",OK,"vowels  = ['a', 'e', 'i', 'o', 'u', 'y']

def word_correction(s):
    result = []
    result.append(s[0])
    left = 0
    right = 1
    while right < len(s):
        if not s[left] in vowels or not s[right] in vowels:
            result.append(s[right])
            left = right
        right += 1
    return ''.join(result)
    
n = int(input())
s = input()
print(word_correction(s))","def correct_word(word):
    vowels = ""aeiouy""
    corrected = []

    for i in range(len(word)):

        if i > 0 and word[i] in vowels and word[i - 1] in vowels:
            continue
        corrected.append(word[i])

    return ''.join(corrected)

n = int(input())
s = input().strip()

result = correct_word(s)

print(result)"
218,B,Airport,PROGRAMMING,['implementation'],"Lolek and Bolek are about to travel abroad by plane. The local airport has a special ""Choose Your Plane"" offer. The offer's conditions are as follows:
 -  it is up to a passenger to choose a plane to fly on; -  if the chosen plane has *x* (*x*<=&gt;<=0) empty seats at the given moment, then the ticket for such a plane costs *x* zlotys (units of Polish currency). 
The only ticket office of the airport already has a queue of *n* passengers in front of it. Lolek and Bolek have not stood in the queue yet, but they are already wondering what is the maximum and the minimum number of zlotys the airport administration can earn if all *n* passengers buy tickets according to the conditions of this offer?

The passengers buy tickets in turn, the first person in the queue goes first, then goes the second one, and so on up to *n*-th person.","The first line contains two integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=1000) — the number of passengers in the queue and the number of planes in the airport, correspondingly. The next line contains *m* integers *a*1,<=*a*2,<=...,<=*a**m* (1<=≤<=*a**i*<=≤<=1000) — *a**i* stands for the number of empty seats in the *i*-th plane before the ticket office starts selling tickets.

The numbers in the lines are separated by a space. It is guaranteed that there are at least *n* empty seats in total.","Print two integers — the maximum and the minimum number of zlotys that the airport administration can earn, correspondingly.","['4 3\n2 1 1\n', '4 3\n2 2 2\n']","['5 5\n', '7 6\n']","In the first test sample the number of passengers is equal to the number of empty seats, so regardless of the way the planes are chosen, the administration will earn the same sum.

In the second sample the sum is maximized if the 1-st person in the queue buys a ticket to the 1-st plane, the 2-nd person — to the 2-nd plane, the 3-rd person — to the 3-rd plane, the 4-th person — to the 1-st plane. The sum is minimized if the 1-st person in the queue buys a ticket to the 1-st plane, the 2-nd person — to the 1-st plane, the 3-rd person — to the 2-nd plane, the 4-th person — to the 2-nd plane.",OK,"n, m = map(int,input().split())
l = list(map(int,input().split()))

def g(f):
	A = l[:]; s = 0
	for _ in range(n):
		i = A.index(f(A)); s += A[i]

		if A[i] > 1: A[i] -= 1;
		else:
			A.pop(i)
	return s
print (g(max), g(min))","def calculate_income(n, m, seats):

    seats.sort()

    max_income = 0
    available_seats = seats[:]
    
    for _ in range(n):

        max_seat = max(available_seats)
        max_income += max_seat

        available_seats[available_seats.index(max_seat)] -= 1

    min_income = 0
    available_seats = seats[:]
    
    for i in range(n):

        min_seat = min(available_seats)
        min_income += min_seat

        available_seats[available_seats.index(min_seat)] -= 1

    return max_income, min_income

n, m = map(int, input().split())
seats = list(map(int, input().split()))

max_income, min_income = calculate_income(n, m, seats)

print(max_income, min_income)"
13,A,Numbers,PROGRAMMING,"['implementation', 'math']","Little Petya likes numbers a lot. He found that number 123 in base 16 consists of two digits: the first is 7 and the second is 11. So the sum of digits of 123 in base 16 is equal to 18.

Now he wonders what is an average value of sum of digits of the number *A* written in all bases from 2 to *A*<=-<=1.

Note that all computations should be done in base 10. You should find the result as an irreducible fraction, written in base 10.",Input contains one integer number *A* (3<=≤<=*A*<=≤<=1000).,"Output should contain required average value in format «X/Y», where X is the numerator and Y is the denominator.","['5\n', '3\n']","['7/3\n', '2/1\n']","In the first sample number 5 written in all bases from 2 to 4 looks so: 101, 12, 11. Sums of digits are 2, 3 and 2, respectively.",OK,"N = int(input())
s = 0

def gcd(a, b):
    while(b):
        a, b = b, a%b
    return a

for i in range(2, N):
    n = N
    while(n>0):
        s += n%i
        n = n//i

t = gcd(s, N-2)
print(str(s//t)+""/""+str((N-2)//t))","from fractions import Fraction

def sum_of_digits_in_base(n, base):
    """"""Calculate the sum of digits of n in the given base.""""""
    total = 0
    while n > 0:
        total += n % base
        n //= base
    return total

def average_sum_of_digits(A):
    """"""Calculate the average sum of digits for numbers from 2 to A.""""""
    total_sum = 0
    
    for base in range(2, A + 1):
        total_sum += sum_of_digits_in_base(A, base)
    
    average = Fraction(total_sum, A - 1)
    return f""{average.numerator}/{average.denominator}""

if __name__ == ""__main__"":

    A = int(input().strip())

    print(average_sum_of_digits(A))"
245,H,Queries for Number of Palindromes,PROGRAMMING,"['dp', 'hashing', 'strings']","You've got a string *s*<==<=*s*1*s*2... *s*|*s*| of length |*s*|, consisting of lowercase English letters. There also are *q* queries, each query is described by two integers *l**i*,<=*r**i* (1<=≤<=*l**i*<=≤<=*r**i*<=≤<=|*s*|). The answer to the query is the number of substrings of string *s*[*l**i*... *r**i*], which are palindromes.

String *s*[*l*... *r*]<==<=*s**l**s**l*<=+<=1... *s**r* (1<=≤<=*l*<=≤<=*r*<=≤<=|*s*|) is a substring of string *s*<==<=*s*1*s*2... *s*|*s*|.

String *t* is called a palindrome, if it reads the same from left to right and from right to left. Formally, if *t*<==<=*t*1*t*2... *t*|*t*|<==<=*t*|*t*|*t*|*t*|<=-<=1... *t*1.","The first line contains string *s* (1<=≤<=|*s*|<=≤<=5000). The second line contains a single integer *q* (1<=≤<=*q*<=≤<=106) — the number of queries. Next *q* lines contain the queries. The *i*-th of these lines contains two space-separated integers *l**i*,<=*r**i* (1<=≤<=*l**i*<=≤<=*r**i*<=≤<=|*s*|) — the description of the *i*-th query.

It is guaranteed that the given string consists only of lowercase English letters.","Print *q* integers — the answers to the queries. Print the answers in the order, in which the queries are given in the input. Separate the printed numbers by whitespaces.",['caaaba\n5\n1 1\n1 4\n2 3\n4 6\n4 5\n'],['1\n7\n3\n4\n2\n'],"Consider the fourth query in the first test case. String *s*[4... 6] = «aba». Its palindrome substrings are: «a», «b», «a», «aba».",TIME_LIMIT_EXCEEDED,"def checkPalindrome(a):
    if(a == a[::-1]):
        return True 
    else: return False
    
def countPalindrome(a):
    count = 0
    for i in range(len(a)):
        count-=1
        for j in range(i,len(a)+1):
            if(checkPalindrome(a[i:j])):
                count = count + 1

    return count    

string = input('')
n = int(input(''))
queries = []

for i in range(n):
    que = input().split(' ')
    queries.append(que)
    
for i in range(n):
    print(countPalindrome(string[int(queries[i][0])-1:int(queries[i][1])]))","def count_palindrome_substrings(s):
    n = len(s)

    palindrome_count = [[0] * n for _ in range(n)]

    for i in range(n):
        palindrome_count[i][i] = 1

    for i in range(n - 1):
        if s[i] == s[i + 1]:
            palindrome_count[i][i + 1] = 1

    for length in range(3, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1
            if s[i] == s[j] and palindrome_count[i + 1][j - 1]:
                palindrome_count[i][j] = 1

    prefix_sum = [[0] * n for _ in range(n)]
    
    for i in range(n):
        for j in range(i, n):
            prefix_sum[i][j] = (prefix_sum[i][j - 1] + palindrome_count[i][j])
    
    return prefix_sum

def main():
    import sys
    input = sys.stdin.read
    data = input().splitlines()
    
    s = data[0].strip()
    q = int(data[1].strip())
    queries = [list(map(int, line.split())) for line in data[2:2 + q]]
    
    prefix_sum = count_palindrome_substrings(s)
    results = []
    
    for l, r in queries:
        l, r = l - 1, r - 1
        count = prefix_sum[l][r]
        results.append(str(count))
    
    print("" "".join(results))

if __name__ == ""__main__"":
    main()"
431,A,Black Square,PROGRAMMING,['implementation'],"Quite recently, a very smart student named Jury decided that lectures are boring, so he downloaded a game called ""Black Square"" on his super cool touchscreen phone.

In this game, the phone's screen is divided into four vertical strips. Each second, a black square appears on some of the strips. According to the rules of the game, Jury must use this second to touch the corresponding strip to make the square go away. As Jury is both smart and lazy, he counted that he wastes exactly *a**i* calories on touching the *i*-th strip.

You've got a string *s*, describing the process of the game and numbers *a*1,<=*a*2,<=*a*3,<=*a*4. Calculate how many calories Jury needs to destroy all the squares?","The first line contains four space-separated integers *a*1, *a*2, *a*3, *a*4 (0<=≤<=*a*1,<=*a*2,<=*a*3,<=*a*4<=≤<=104).

The second line contains string *s* (1<=≤<=|*s*|<=≤<=105), where the *і*-th character of the string equals ""1"", if on the *i*-th second of the game the square appears on the first strip, ""2"", if it appears on the second strip, ""3"", if it appears on the third strip, ""4"", if it appears on the fourth strip.",Print a single integer — the total number of calories that Jury wastes.,"['1 2 3 4\n123214\n', '1 5 3 2\n11221\n']","['13\n', '13\n']",none,OK,"a = []
a = [int(item) for item in input().split()]
s = input()
x = len(s)
result = 0
for i in range(x):

    if s[i]=='1':
        result+=a[0]
    elif s[i]== '2' :
        result += a[1]
    elif s[i] == '3' :
        result += a[2]
    elif s[i] == '4' :
        result += a[3]

print (result)","a1, a2, a3, a4 = map(int, input().split())

s = input().strip()

total_calories = 0

for char in s:

    if char == '1':
        total_calories += a1
    elif char == '2':
        total_calories += a2
    elif char == '3':
        total_calories += a3
    elif char == '4':
        total_calories += a4

print(total_calories)"
215,A,Bicycle Chain,PROGRAMMING,"['brute force', 'implementation']","Vasya's bicycle chain drive consists of two parts: *n* stars are attached to the pedal axle, *m* stars are attached to the rear wheel axle. The chain helps to rotate the rear wheel by transmitting the pedal rotation.

We know that the *i*-th star on the pedal axle has *a**i* (0<=&lt;<=*a*1<=&lt;<=*a*2<=&lt;<=...<=&lt;<=*a**n*) teeth, and the *j*-th star on the rear wheel axle has *b**j* (0<=&lt;<=*b*1<=&lt;<=*b*2<=&lt;<=...<=&lt;<=*b**m*) teeth. Any pair (*i*,<=*j*) (1<=≤<=*i*<=≤<=*n*; 1<=≤<=*j*<=≤<=*m*) is called a gear and sets the indexes of stars to which the chain is currently attached. Gear (*i*,<=*j*) has a gear ratio, equal to the value .

Since Vasya likes integers, he wants to find such gears (*i*,<=*j*), that their ratios are integers. On the other hand, Vasya likes fast driving, so among all ""integer"" gears (*i*,<=*j*) he wants to choose a gear with the maximum ratio. Help him to find the number of such gears.

In the problem, fraction  denotes division in real numbers, that is, no rounding is performed.","The first input line contains integer *n* (1<=≤<=*n*<=≤<=50) — the number of stars on the bicycle's pedal axle. The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=104) in the order of strict increasing.

The third input line contains integer *m* (1<=≤<=*m*<=≤<=50) — the number of stars on the rear wheel axle. The fourth line contains *m* integers *b*1,<=*b*2,<=...,<=*b**m* (1<=≤<=*b**i*<=≤<=104) in the order of strict increasing.

It is guaranteed that there exists at least one gear (*i*,<=*j*), that its gear ratio is an integer. The numbers on the lines are separated by spaces.","Print the number of ""integer"" gears with the maximum ratio among all ""integer"" gears.","['2\n4 5\n3\n12 13 15\n', '4\n1 2 3 4\n5\n10 11 12 13 14\n']","['2\n', '1\n']","In the first sample the maximum ""integer"" gear ratio equals 3. There are two gears that have such gear ratio. For one of them *a*<sub class=""lower-index"">1</sub> = 4, *b*<sub class=""lower-index"">1</sub> = 12, and for the other *a*<sub class=""lower-index"">2</sub> = 5, *b*<sub class=""lower-index"">3</sub> = 15.",COMPILATION_ERROR,"﻿

const ll MOD = (ll)(pow(10, 9) + 7);

using namespace std;

ll dist(ll a, ll b, ll n) {
	if (a == b)
	{
		return 0;
	}
	if (b < a)
	{
		return n - a + b;
	}
	else {
		return b - a;
	}
}

int main() {
	ll n, m;
	cin >> n;
	vector <ll> A(n);
	for (int i = 0; i < n; i++) {
		cin >> A[i];
	}
	cin >> m;
	vector<ll> B(m);
	for (int i = 0; i < m; i++) {
		cin >> B[i];
	}
	ll k = 0;
	ll x = 0;
	for (int i = 0; i < m; i++) {
		for (int j = 0; j < n; j++) {
			if (B[i] % A[j] == 0)
				x = max(B[i] / A[j], x);
		}
	}
	for (int i = 0; i < m; i++) {
		for (int j = 0; j < n; j++) {
			if (B[i] % A[j] == 0)
				if (B[i] / A[j] == x)
					k++;
		}
	}
	cout << k;
}","def count_max_integer_gears(n, a, m, b):
    max_ratio = 0
    gear_count = 0
    
    for i in range(n):
        for j in range(m):
            if b[j] % a[i] == 0:
                ratio = b[j] // a[i]
                if ratio > max_ratio:
                    max_ratio = ratio
                    gear_count = 1
                elif ratio == max_ratio:
                    gear_count += 1
                    
    return gear_count

import sys

input_data = sys.stdin.read().strip().split('\n')
n = int(input_data[0])
a = list(map(int, input_data[1].split()))
m = int(input_data[2])
b = list(map(int, input_data[3].split()))

result = count_max_integer_gears(n, a, m, b)
print(result)"
82,A,Double Cola,PROGRAMMING,"['implementation', 'math']","Sheldon, Leonard, Penny, Rajesh and Howard are in the queue for a ""Double Cola"" drink vending machine; there are no other people in the queue. The first one in the queue (Sheldon) buys a can, drinks it and doubles! The resulting two Sheldons go to the end of the queue. Then the next in the queue (Leonard) buys a can, drinks it and gets to the end of the queue as two Leonards, and so on. This process continues ad infinitum.

For example, Penny drinks the third can of cola and the queue will look like this: Rajesh, Howard, Sheldon, Sheldon, Leonard, Leonard, Penny, Penny.

Write a program that will print the name of a man who will drink the *n*-th can.

Note that in the very beginning the queue looks like that: Sheldon, Leonard, Penny, Rajesh, Howard. The first person is Sheldon.","The input data consist of a single integer *n* (1<=≤<=*n*<=≤<=109).

It is guaranteed that the pretests check the spelling of all the five names, that is, that they contain all the five possible answers.","Print the single line — the name of the person who drinks the *n*-th can of cola. The cans are numbered starting from 1. Please note that you should spell the names like this: ""Sheldon"", ""Leonard"", ""Penny"", ""Rajesh"", ""Howard"" (without the quotes). In that order precisely the friends are in the queue initially.","['1\n', '6\n', '1802\n']","['Sheldon\n', 'Sheldon\n', 'Penny\n']",none,WRONG_ANSWER,"def find_person(n):
    queue = [""Sheldon"", ""Leonard"", ""Penny"", ""Rajesh"", ""Howard""]
    i = 0  

    while n > len(queue):
        n -= len(queue)
        queue += [queue[i], queue[i]]
        i += 1
    
    return queue[(n - 1) // (len(queue) // 5)]

n = int(input())

result = find_person(n)

print(result)","def find_drinker(n):

    names = [""Sheldon"", ""Leonard"", ""Penny"", ""Rajesh"", ""Howard""]

    round_size = 5
    multiplier = 1

    while n > round_size * multiplier:
        n -= round_size * multiplier
        multiplier *= 2

    index = (n - 1) // multiplier
    return names[index]

inputs = [1, 6, 1802]
outputs = [find_drinker(n) for n in inputs]

for output in outputs:
    print(output)"
570,D,Tree Requests,PROGRAMMING,"['binary search', 'bitmasks', 'constructive algorithms', 'dfs and similar', 'graphs', 'trees']","Roman planted a tree consisting of *n* vertices. Each vertex contains a lowercase English letter. Vertex 1 is the root of the tree, each of the *n*<=-<=1 remaining vertices has a parent in the tree. Vertex is connected with its parent by an edge. The parent of vertex *i* is vertex *p**i*, the parent index is always less than the index of the vertex (i.e., *p**i*<=&lt;<=*i*).

The depth of the vertex is the number of nodes on the path from the root to *v* along the edges. In particular, the depth of the root is equal to 1.

We say that vertex *u* is in the subtree of vertex *v*, if we can get from *u* to *v*, moving from the vertex to the parent. In particular, vertex *v* is in its subtree.

Roma gives you *m* queries, the *i*-th of which consists of two numbers *v**i*, *h**i*. Let's consider the vertices in the subtree *v**i* located at depth *h**i*. Determine whether you can use the letters written at these vertices to make a string that is a palindrome. The letters that are written in the vertexes, can be rearranged in any order to make a palindrome, but all letters should be used.","The first line contains two integers *n*, *m* (1<=≤<=*n*,<=*m*<=≤<=500<=000) — the number of nodes in the tree and queries, respectively.

The following line contains *n*<=-<=1 integers *p*2,<=*p*3,<=...,<=*p**n* — the parents of vertices from the second to the *n*-th (1<=≤<=*p**i*<=&lt;<=*i*).

The next line contains *n* lowercase English letters, the *i*-th of these letters is written on vertex *i*.

Next *m* lines describe the queries, the *i*-th line contains two numbers *v**i*, *h**i* (1<=≤<=*v**i*,<=*h**i*<=≤<=*n*) — the vertex and the depth that appear in the *i*-th query.","Print *m* lines. In the *i*-th line print ""Yes"" (without the quotes), if in the *i*-th query you can make a palindrome from the letters written on the vertices, otherwise print ""No"" (without the quotes).",['6 5\n1 1 1 3 3\nzacccd\n1 1\n3 3\n4 1\n6 1\n1 2\n'],['Yes\nNo\nYes\nYes\nYes\n'],"String *s* is a palindrome if reads the same from left to right and from right to left. In particular, an empty string is a palindrome.

Clarification for the sample test.

In the first query there exists only a vertex 1 satisfying all the conditions, we can form a palindrome ""z"".

In the second query vertices 5 and 6 satisfy condititions, they contain letters ""с"" and ""d"" respectively. It is impossible to form a palindrome of them.

In the third query there exist no vertices at depth 1 and in subtree of 4. We may form an empty palindrome.

In the fourth query there exist no vertices in subtree of 6 at depth 1. We may form an empty palindrome.

In the fifth query there vertices 2, 3 and 4 satisfying all conditions above, they contain letters ""a"", ""c"" and ""c"". We may form a palindrome ""cac"".",TIME_LIMIT_EXCEEDED,"from bisect import bisect_left

def dfs(i, h):
    global parent, g, s, time, IN, OUT, H
    IN[i] = time
    H[h].append((time, H[h][-1][1]^(1<<(ord(s[i])-ord('a')) )))
    time+=1
    for j in g[i]:
        dfs(j, h+1)
    OUT[i] = time
    time+=1

IN = {}
OUT= {}
time = 1
n ,m = map(int, input().split())
parent=list(map(int, input().split()))
parent.insert(0, 0)
parent.insert(0, 0)
H = [[(0,0)] for i in range(3*n)]
s = '$' + input()
g = {v:[] for v in range(n+1)}
for i,j in enumerate(parent):
    g[j].append(i)
dfs(1,1)
for _ in range(m):
    root, height = map(int, input().split())
    l = bisect_left(H[height], (IN[root],-1), 0, len(H[height]))-1
    r = bisect_left(H[height], (OUT[root],-1), 0, len(H[height]))-1
    t = H[height][l][1] ^  H[height][r][1]
    b = t - (t&-t)
    c = t ^ (t&-t)
    if(b):
        print('No')
    else:
        print('Yes')","def can_form_palindrome(n, m, parents, letters, queries):
    from collections import defaultdict

    tree = defaultdict(list)
    for i in range(2, n + 1):
        tree[parents[i - 2]].append(i)

    depth = [0] * (n + 1)
    depth[1] = 1

    def dfs(v, d):
        depth[v] = d
        for child in tree[v]:
            dfs(child, d + 1)

    dfs(1, 1)

    results = []

    for v, h in queries:

        letters_count = defaultdict(int)
        target_depth = depth[v] + h - 1

        queue = [v]
        while queue:
            current = queue.pop(0)
            if depth[current] == target_depth:
                letters_count[letters[current - 1]] += 1
            elif depth[current] < target_depth:
                queue.extend(tree[current])

        odd_count = sum(1 for count in letters_count.values() if count % 2 == 1)
        if odd_count <= 1:
            results.append(""Yes"")
        else:
            results.append(""No"")

    return results

input_data = ['6 5\n1 1 1 3 3\nzacccd\n1 1\n3 3\n4 1\n6 1\n1 2\n']
for data in input_data:
    lines = data.splitlines()
    n, m = map(int, lines[0].split())
    parents = list(map(int, lines[1].split()))
    letters = lines[2].strip()
    queries = [tuple(map(int, line.split())) for line in lines[3:]]

    results = can_form_palindrome(n, m, parents, letters, queries)

    print('\n'.join(results))"
979,C,Kuro and Walking Route,PROGRAMMING,"['dfs and similar', 'trees']","Kuro is living in a country called Uberland, consisting of $n$ towns, numbered from $1$ to $n$, and $n - 1$ bidirectional roads connecting these towns. It is possible to reach each town from any other. Each road connects two towns $a$ and $b$. Kuro loves walking and he is planning to take a walking marathon, in which he will choose a pair of towns $(u, v)$ ($u \neq v$) and walk from $u$ using the shortest path to $v$ (note that $(u, v)$ is considered to be different from $(v, u)$).

Oddly, there are 2 special towns in Uberland named Flowrisa (denoted with the index $x$) and Beetopia (denoted with the index $y$). Flowrisa is a town where there are many strong-scent flowers, and Beetopia is another town where many bees live. In particular, Kuro will avoid any pair of towns $(u, v)$ if on the path from $u$ to $v$, he reaches Beetopia after he reached Flowrisa, since the bees will be attracted with the flower smell on Kuro’s body and sting him.

Kuro wants to know how many pair of city $(u, v)$ he can take as his route. Since he’s not really bright, he asked you to help him with this problem.","The first line contains three integers $n$, $x$ and $y$ ($1 \leq n \leq 3 \cdot 10^5$, $1 \leq x, y \leq n$, $x \ne y$) - the number of towns, index of the town Flowrisa and index of the town Beetopia, respectively.

$n - 1$ lines follow, each line contains two integers $a$ and $b$ ($1 \leq a, b \leq n$, $a \ne b$), describes a road connecting two towns $a$ and $b$.

It is guaranteed that from each town, we can reach every other town in the city using the given roads. That is, the given map of towns and roads is a tree.","A single integer resembles the number of pair of towns $(u, v)$ that Kuro can use as his walking route.","['3 1 3\n1 2\n2 3\n', '3 1 3\n1 2\n1 3\n']","['5', '4']","On the first example, Kuro can choose these pairs: 
 -  $(1, 2)$: his route would be $1 \rightarrow 2$, -  $(2, 3)$: his route would be $2 \rightarrow 3$, -  $(3, 2)$: his route would be $3 \rightarrow 2$, -  $(2, 1)$: his route would be $2 \rightarrow 1$, -  $(3, 1)$: his route would be $3 \rightarrow 2 \rightarrow 1$. 
Kuro can't choose pair $(1, 3)$ since his walking route would be $1 \rightarrow 2 \rightarrow 3$, in which Kuro visits town $1$ (Flowrisa) and then visits town $3$ (Beetopia), which is not allowed (note that pair $(3, 1)$ is still allowed because although Kuro visited Flowrisa and Beetopia, he did not visit them in that order).

On the second example, Kuro can choose the following pairs: 
 -  $(1, 2)$: his route would be $1 \rightarrow 2$, -  $(2, 1)$: his route would be $2 \rightarrow 1$, -  $(3, 2)$: his route would be $3 \rightarrow 1 \rightarrow 2$, -  $(3, 1)$: his route would be $3 \rightarrow 1$.",WRONG_ANSWER,"from collections import deque

class graph:
    def __init__(self, N, edges, x, y):
        self.nedges=len(edges)
        self.N=N
        self.adj=[[] for i in range(1,N+1)]
        for i in range(0,self.nedges):
            self.adj[edges[i][0]-1].append(edges[i][1])
            self.adj[edges[i][1]-1].append(edges[i][0])
            K=0
            Rememb=0
            Nen=0
            Flow=False
        for i in self.adj[y-1]:
            Flow=False
            Len=0
            Flow, Len = self.bfs(i,y,x)
            if Flow:
                K=Len
                Rememb=i
        Flow, Nen = self.bfs(y,Rememb,-1)
        print (N*(N-1)-Nen*K)

    def bfs(self, start, parent, x):
        discovered=[False for i in range(0, self.N)]
        processed=[False for i in range(0, self.N)]
        q=deque()
        q.append(start)
        discovered[start-1]=True
        discovered[parent-1]=True
        g=-1
        Len=0
        flow=False
        while(len(q)!=0):
            parent = g
            Len=Len+1
            g = q.pop()
            if x==g:
                flow=True
                ch, mn = self.bfs(x, parent, -1)
                return flow, mn
            processed[g-1]=True
            for i in self.adj[g-1]:
                if(discovered[i-1]==False):
                    discovered[i-1]=True
                    q.append(i)
        return flow, Len

s1=input()
k=[int(i) for i in s1.split(' ')]
N,x,y = k[0],k[1],k[2]
s = [input() for i in range(1,N)]
edges = [[int(j) for j in s[i-1].split(' ')] for i in range(1,N)]
asd=graph(N, edges, x, y)","def count_valid_pairs(n, x, y, roads):
    from collections import defaultdict, deque

    graph = defaultdict(list)
    for a, b in roads:
        graph[a].append(b)
        graph[b].append(a)

    def dfs(node, parent):
        count = 1
        for neighbor in graph[node]:
            if neighbor != parent:
                count += dfs(neighbor, node)
        return count

    def calculate_pairs():

        total_pairs = n * (n - 1)

        size_x = dfs(x, -1)
        size_y = dfs(y, -1)

        invalid_pairs = size_x * size_y
        
        return total_pairs - invalid_pairs
    
    return calculate_pairs()

def main():
    import sys
    input_data = sys.stdin.read().strip().split('\n')
    n, x, y = map(int, input_data[0].split())
    roads = [tuple(map(int, line.split())) for line in input_data[1:]]
    
    result = count_valid_pairs(n, x, y, roads)
    print(result)

if __name__ == ""__main__"":
    main()"
429,A,Xor-tree,PROGRAMMING,"['dfs and similar', 'trees']","Iahub is very proud of his recent discovery, propagating trees. Right now, he invented a new tree, called xor-tree. After this new revolutionary discovery, he invented a game for kids which uses xor-trees.

The game is played on a tree having *n* nodes, numbered from 1 to *n*. Each node *i* has an initial value *init**i*, which is either 0 or 1. The root of the tree is node 1.

One can perform several (possibly, zero) operations on the tree during the game. The only available type of operation is to pick a node *x*. Right after someone has picked node *x*, the value of node *x* flips, the values of sons of *x* remain the same, the values of sons of sons of *x* flips, the values of sons of sons of sons of *x* remain the same and so on.

The goal of the game is to get each node *i* to have value *goal**i*, which can also be only 0 or 1. You need to reach the goal of the game by using minimum number of operations.","The first line contains an integer *n* (1<=≤<=*n*<=≤<=105). Each of the next *n*<=-<=1 lines contains two integers *u**i* and *v**i* (1<=≤<=*u**i*,<=*v**i*<=≤<=*n*; *u**i*<=≠<=*v**i*) meaning there is an edge between nodes *u**i* and *v**i*. 

The next line contains *n* integer numbers, the *i*-th of them corresponds to *init**i* (*init**i* is either 0 or 1). The following line also contains *n* integer numbers, the *i*-th number corresponds to *goal**i* (*goal**i* is either 0 or 1).","In the first line output an integer number *cnt*, representing the minimal number of operations you perform. Each of the next *cnt* lines should contain an integer *x**i*, representing that you pick a node *x**i*.",['10\n2 1\n3 1\n4 2\n5 1\n6 2\n7 5\n8 6\n9 8\n10 5\n1 0 1 1 0 1 0 1 0 1\n1 0 1 0 0 1 1 1 0 1\n'],['2\n4\n7\n'],none,TIME_LIMIT_EXCEEDED,"def dfs(node,parent):
    global a,init,goal,l,t
    if init[node-1]!=goal[node-1]:
        update(node,parent,0)
        l=l+1
        t.append(node)
    for i in range(len(a[node])):
        if a[node][i]!=parent:
            dfs(a[node][i],node)
def update(node,parent,p):
    global a,init,goal
    if p%2==0:
        init[node-1]=(init[node-1]^1)
    for i in range(len(a[node])):
        if a[node][i]!=parent:
            update(a[node][i],node,p+1)
    
n = int(input())
import sys
sys.setrecursionlimit(10**6)
a = [[] for _ in range(n+1)]
visited = [False for _ in range(n+1)]
for _ in range(n-1):
    x,y = list(map(int,input().split()))
    a[x].append(y)
    a[y].append(x)
l = 0
init = list(map(int,input().split()))
goal = list(map(int,input().split()))
t = []
dfs(1,0)
print(l)
for i in t:
    print(i)","def dfs(node, parent):
    global operations

    current_value = init[node] ^ flip[node]

    if current_value != goal[node]:
        operations.append(node + 1)
        flip[node] ^= 1

        for child in tree[node]:
            if child != parent:
                flip[child] ^= 1

    for child in tree[node]:
        if child != parent:
            dfs(child, node)

n = int(input())
tree = [[] for _ in range(n)]
for _ in range(n - 1):
    u, v = map(int, input().split())
    tree[u - 1].append(v - 1)
    tree[v - 1].append(u - 1)

init = list(map(int, input().split()))
goal = list(map(int, input().split()))

flip = [0] * n
operations = []

dfs(0, -1)

print(len(operations))
for node in operations:
    print(node)"
242,B,Big Segment,PROGRAMMING,"['implementation', 'sortings']","A coordinate line has *n* segments, the *i*-th segment starts at the position *l**i* and ends at the position *r**i*. We will denote such a segment as [*l**i*,<=*r**i*].

You have suggested that one of the defined segments covers all others. In other words, there is such segment in the given set, which contains all other ones. Now you want to test your assumption. Find in the given set the segment which covers all other segments, and print its number. If such a segment doesn't exist, print -1.

Formally we will assume that segment [*a*,<=*b*] covers segment [*c*,<=*d*], if they meet this condition *a*<=≤<=*c*<=≤<=*d*<=≤<=*b*.","The first line contains integer *n* (1<=≤<=*n*<=≤<=105) — the number of segments. Next *n* lines contain the descriptions of the segments. The *i*-th line contains two space-separated integers *l**i*,<=*r**i* (1<=≤<=*l**i*<=≤<=*r**i*<=≤<=109) — the borders of the *i*-th segment.

It is guaranteed that no two segments coincide.","Print a single integer — the number of the segment that covers all other segments in the set. If there's no solution, print -1.

The segments are numbered starting from 1 in the order in which they appear in the input.","['3\n1 1\n2 2\n3 3\n', '6\n1 5\n2 3\n1 10\n7 10\n7 7\n10 10\n']","['-1\n', '3\n']",none,OK,"from collections import defaultdict, deque
from functools import lru_cache
from heapq import heappush, heappop
from typing import Counter
import math
hpop = heappop
hpush = heappush
""""""
    num = int(input())
    arr = list(map(int, input().split()))
    a,b = map(int, input().split())
    graph = defaultdict(list)
    for i in range(
        graph[a].append(b)
        graph[b].append(a)
    MOD = 10**9 + 7
""""""

def solution():
    n = int(input())
    mn = float(""inf"")
    mx = float(""-inf"")
    res = [-1,mn,mx]
    for i in range(n):
        a,b = map(int, input().split())
        mn = min(mn, a)
        mx = max(mx, b)
        if a == mn and b == mx:
            res = [i,a,b]

    if mn == float(""inf"") or mx == float(""-inf""):
        print(-1)

    i,a,b = res
    if mn == a and mx == b:
        print(i+1)
    else:
        print(-1)

def main():
    t = 1

    for _ in range(t):
        solution()
             
    
import sys
import threading
sys.setrecursionlimit(1 << 30)
threading.stack_size(1 << 27)
thread = threading.Thread(target=main)
thread.start(); thread.join()","def find_covering_segment(segments):

    overall_min_left = float('inf')
    overall_max_right = float('-inf')
    covering_segment_index = -1

    for index, (l, r) in enumerate(segments):
        if l < overall_min_left:
            overall_min_left = l
        if r > overall_max_right:
            overall_max_right = r

    for index, (l, r) in enumerate(segments):
        if l <= overall_min_left and r >= overall_max_right:
            covering_segment_index = index + 1
            break

    return covering_segment_index

import sys

input_data = sys.stdin.read().strip().split('\n')
n = int(input_data[0])
segments = []

for i in range(1, n + 1):
    l, r = map(int, input_data[i].split())
    segments.append((l, r))

result = find_covering_segment(segments)

print(result)"
844,B,Rectangles,PROGRAMMING,"['combinatorics', 'math']","You are given *n*<=×<=*m* table. Each cell of the table is colored white or black. Find the number of non-empty sets of cells such that:
 1.  All cells in a set have the same color. 1.  Every two cells in a set share row or column.","The first line of input contains integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=50) — the number of rows and the number of columns correspondingly.

The next *n* lines of input contain descriptions of rows. There are *m* integers, separated by spaces, in each line. The number equals 0 if the corresponding cell is colored white and equals 1 if the corresponding cell is colored black.",Output single integer  — the number of non-empty sets from the problem description.,"['1 1\n0\n', '2 3\n1 0 1\n0 1 0\n']","['1\n', '8\n']","In the second example, there are six one-element sets. Additionally, there are two two-element sets, the first one consists of the first and the third cells of the first row, the second one consists of the first and the third cells of the second row. To sum up, there are 8 sets.",WRONG_ANSWER,"def combination(number):
  x = 0
  for i in range(number):
    x = x + (number-i-1)
  return x

matrix = []
n, m = [int(n) for n in input().split("" "")]
for i in range(n):
  row = [int(n) for n in input().split("" "")]
  matrix.append(row)

combination_row = 0
combination_column = 0
for i in range(n):
  black_row = 0
  white_row = 0
  for j in range(m):
    if(matrix[i][j] == 0):
      white_row = white_row + 1
    else:
      black_row = black_row + 1
  combination_row = combination_row + combination(white_row) + combination(black_row)

for i in range(m):
  black_column = 0
  white_column = 0
  for j in range(n):
    if(matrix[j][i] == 0):
      white_column = white_column + 1
    else:
      black_column= black_column + 1
  combination_column = combination_column + combination(white_column) + combination(black_column)

print(combination_column + combination_row + n*m)","def count_non_empty_sets(n, m, grid):

    count = 0

    for row in grid:
        white_cells = sum(1 for cell in row if cell == 0)
        black_cells = sum(1 for cell in row if cell == 1)

        if white_cells > 0:
            count += (1 << white_cells) - 1
        if black_cells > 0:
            count += (1 << black_cells) - 1

    for col in range(m):
        white_cells = sum(1 for row in grid if row[col] == 0)
        black_cells = sum(1 for row in grid if row[col] == 1)

        if white_cells > 0:
            count += (1 << white_cells) - 1
        if black_cells > 0:
            count += (1 << black_cells) - 1
            
    return count

n, m = map(int, input().split())
grid = [list(map(int, input().split())) for _ in range(n)]

result = count_non_empty_sets(n, m, grid)
print(result)"
855,A,Tom Riddle's Diary,PROGRAMMING,"['brute force', 'implementation', 'strings']","Harry Potter is on a mission to destroy You-Know-Who's Horcruxes. The first Horcrux that he encountered in the Chamber of Secrets is Tom Riddle's diary. The diary was with Ginny and it forced her to open the Chamber of Secrets. Harry wants to know the different people who had ever possessed the diary to make sure they are not under its influence.

He has names of *n* people who possessed the diary in order. You need to tell, for each person, if he/she possessed the diary at some point before or not.

Formally, for a name *s**i* in the *i*-th line, output ""YES"" (without quotes) if there exists an index *j* such that *s**i*<==<=*s**j* and *j*<=&lt;<=*i*, otherwise, output ""NO"" (without quotes).","First line of input contains an integer *n* (1<=≤<=*n*<=≤<=100) — the number of names in the list.

Next *n* lines each contain a string *s**i*, consisting of lowercase English letters. The length of each string is between 1 and 100.","Output *n* lines each containing either ""YES"" or ""NO"" (without quotes), depending on whether this string was already present in the stream or not.

You can print each letter in any case (upper or lower).","['6\ntom\nlucius\nginny\nharry\nginny\nharry\n', '3\na\na\na\n']","['NO\nNO\nNO\nNO\nYES\nYES\n', 'NO\nYES\nYES\n']","In test case 1, for *i* = 5 there exists *j* = 3 such that *s*<sub class=""lower-index"">*i*</sub> = *s*<sub class=""lower-index"">*j*</sub> and *j* &lt; *i*, which means that answer for *i* = 5 is ""YES"".",OK,"def tomRiddleDiary(s):
    if s in a:
        return ""YES""

    else:
        return ""NO""

a = set()
t = int(input())
while t > 0:
    s = input()
    print(tomRiddleDiary(s))
    t = t - 1
    a.add(s)","def check_possession(n, names):

    seen = set()
    results = []
    
    for name in names:

        if name in seen:
            results.append(""YES"")
        else:
            results.append(""NO"")
            seen.add(name)

    return results

n = int(input())
names = [input().strip() for _ in range(n)]

results = check_possession(n, names)

for result in results:
    print(result)"
915,A,Garden,PROGRAMMING,['implementation'],"Luba thinks about watering her garden. The garden can be represented as a segment of length *k*. Luba has got *n* buckets, the *i*-th bucket allows her to water some continuous subsegment of garden of length exactly *a**i* each hour. Luba can't water any parts of the garden that were already watered, also she can't water the ground outside the garden.

Luba has to choose one of the buckets in order to water the garden as fast as possible (as mentioned above, each hour she will water some continuous subsegment of length *a**i* if she chooses the *i*-th bucket). Help her to determine the minimum number of hours she has to spend watering the garden. It is guaranteed that Luba can always choose a bucket so it is possible water the garden.

See the examples for better understanding.","The first line of input contains two integer numbers *n* and *k* (1<=≤<=*n*,<=*k*<=≤<=100) — the number of buckets and the length of the garden, respectively.

The second line of input contains *n* integer numbers *a**i* (1<=≤<=*a**i*<=≤<=100) — the length of the segment that can be watered by the *i*-th bucket in one hour.

It is guaranteed that there is at least one bucket such that it is possible to water the garden in integer number of hours using only this bucket.",Print one integer number — the minimum number of hours required to water the garden.,"['3 6\n2 3 5\n', '6 7\n1 2 3 4 5 6\n']","['2\n', '7\n']","In the first test the best option is to choose the bucket that allows to water the segment of length 3. We can't choose the bucket that allows to water the segment of length 5 because then we can't water the whole garden.

In the second test we can choose only the bucket that allows us to water the segment of length 1.",OK,"def f():
    num,k=map(int,input().split())
    n=map(int, input().split())
    maxi=0
    ans=0
    for i in n:
        if(k%i==0 and i>maxi):
            maxi=i 
            ans=int(k/i)
            
    print(ans)
f()","n, k = map(int, input().split())

a = list(map(int, input().split()))

min_hours = float('inf')

for bucket in a:

    if k % bucket == 0:

        hours = k // bucket

        min_hours = min(min_hours, hours)

print(min_hours)"
192,A,Funky Numbers,PROGRAMMING,"['binary search', 'brute force', 'implementation']","As you very well know, this year's funkiest numbers are so called triangular numbers (that is, integers that are representable as , where *k* is some positive integer), and the coolest numbers are those that are representable as a sum of two triangular numbers.

A well-known hipster Andrew adores everything funky and cool but unfortunately, he isn't good at maths. Given number *n*, help him define whether this number can be represented by a sum of two triangular numbers (not necessarily different)!",The first input line contains an integer *n* (1<=≤<=*n*<=≤<=109).,"Print ""YES"" (without the quotes), if *n* can be represented as a sum of two triangular numbers, otherwise print ""NO"" (without the quotes).","['256\n', '512\n']","['YES\n', 'NO\n']","In the first sample number <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/92095692c6ea93e9e3b837a0408ba7543549d5b2.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>.

In the second sample number 512 can not be represented as a sum of two triangular numbers.",OK,"import sys, os.path
from collections import*
from copy import*
import math
mod=10**9+7
if(os.path.exists('input.txt')):
    sys.stdin = open(""input.txt"",""r"")
    sys.stdout = open(""output.txt"",""w"")

def bs(left,right,x):
    while(left<=right):
        mid=left+(right-left)//2
        b=(mid*(mid+1))//2
        if(b==x):
            return 1
        elif(b>x):
            right=mid-1
        else:
            left=mid+1
    return 0
n=int(input())
n1=10**5
flag=0
for i in range(1,n1+1):
    a=(i*(i+1))//2
    if(bs(1,n1,n-a)):
        flag=1
        break
if(flag==0):
    print('NO')
else:
    print('YES')","def is_triangular(x):

    n = (8 * x + 1) ** 0.5
    return n == int(n)

def can_be_written_as_sum_of_two_triangular_numbers(n):

    for i in range(int((2 * n) ** 0.5) + 1):
        t1 = (i * (i + 1)) // 2
        if t1 > n:
            break
        t2 = n - t1
        if is_triangular(t2):
            return ""YES""
    return ""NO""

import sys

input_data = sys.stdin.read().strip().split()
results = []

for line in input_data:
    n = int(line.strip())
    results.append(can_be_written_as_sum_of_two_triangular_numbers(n))

print(""\n"".join(results))"
121,A,Lucky Sum,PROGRAMMING,['implementation'],"Petya loves lucky numbers. Everybody knows that lucky numbers are positive integers whose decimal representation contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.

Let *next*(*x*) be the minimum lucky number which is larger than or equals *x*. Petya is interested what is the value of the expression *next*(*l*)<=+<=*next*(*l*<=+<=1)<=+<=...<=+<=*next*(*r*<=-<=1)<=+<=*next*(*r*). Help him solve this problem.",The single line contains two integers *l* and *r* (1<=≤<=*l*<=≤<=*r*<=≤<=109) — the left and right interval limits.,"In the single line print the only number — the sum *next*(*l*)<=+<=*next*(*l*<=+<=1)<=+<=...<=+<=*next*(*r*<=-<=1)<=+<=*next*(*r*).

Please do not use the %lld specificator to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specificator.","['2 7\n', '7 7\n']","['33\n', '7\n']","In the first sample: *next*(2) + *next*(3) + *next*(4) + *next*(5) + *next*(6) + *next*(7) = 4 + 4 + 4 + 7 + 7 + 7 = 33

In the second sample: *next*(7) = 7",WRONG_ANSWER,"import sys
input = sys.stdin.readline

def inp():
    return(int(input()))
def inlt():
    return(list(map(int,input().split())))
def insr():
    s = input()
    return(list(s[:len(s) - 1]))
def invr():
    return(map(int,input().split()))

def Lucky_Sum2():
    l,r = invr()

    luckyNum = [4,7]

    startLuckyNum = -1 
    if luckyNum[0] >= l and startLuckyNum == -1:
        startLuckyNum = luckyNum[0] 
    if luckyNum[1] >= l and startLuckyNum == -1:
        startLuckyNum = luckyNum[1]

    index = 0

    while True:        
        num1 = (luckyNum[index]*10)+4
        num2 = (luckyNum[index]*10)+7

        if num1 >= l and startLuckyNum == -1:
            startLuckyNum = num1 
        if num2 >= l and startLuckyNum == -1:
            startLuckyNum = num2 

        if num1 >= r :
            luckyNum.append(num1)
            break  
        else:
            luckyNum.append(num1)
        if num2 >= r:
            luckyNum.append(num2)
            break 
        else:
            luckyNum.append(num2)

        index += 1

    startIndex = luckyNum.index(startLuckyNum)

    sum = 0 

    for movingIndex in range(startIndex,len(luckyNum)):
        num = luckyNum[movingIndex]

        if movingIndex  == startIndex:
            numTimesRepeated = (num - l) + 1 
        elif movingIndex == len(luckyNum)-1:
            prevNum = luckyNum[movingIndex-1]
            numTimesRepeated = (r - (prevNum+1)) + 1
        else:
            prevNum = luckyNum[movingIndex-1]
            numTimesRepeated = num - prevNum
        
        sum += (num*numTimesRepeated)

    print(sum)
    return

Lucky_Sum2()","def is_lucky(num):
    """"""Check if a number is a lucky number (contains only digits 4 and 7).""""""
    return all(digit in '47' for digit in str(num))

def next_lucky(x):
    """"""Find the next lucky number greater than or equal to x.""""""
    while not is_lucky(x):
        x += 1
    return x

def lucky_sum(l, r):
    """"""Calculate the sum of next lucky numbers from l to r.""""""
    total = 0
    for i in range(l, r + 1):
        total += next_lucky(i)
    return total

l, r = map(int, input().split())

print(lucky_sum(l, r))"
214,A,System of Equations,PROGRAMMING,['brute force'],"Furik loves math lessons very much, so he doesn't attend them, unlike Rubik. But now Furik wants to get a good mark for math. For that Ms. Ivanova, his math teacher, gave him a new task. Furik solved the task immediately. Can you?

You are given a system of equations: 

You should count, how many there are pairs of integers (*a*,<=*b*) (0<=≤<=*a*,<=*b*) which satisfy the system.","A single line contains two integers *n*,<=*m* (1<=≤<=*n*,<=*m*<=≤<=1000) — the parameters of the system. The numbers on the line are separated by a space.",On a single line print the answer to the problem.,"['9 3\n', '14 28\n', '4 20\n']","['1\n', '1\n', '0\n']","In the first sample the suitable pair is integers (3, 0). In the second sample the suitable pair is integers (3, 5). In the third sample there is no suitable pair.",OK,"import sys
import math

def function():
    n, m = map(int, input().split())
    ans = 0 
    for a in range(1001):
        for b in range(1001):
            if (a**2) + b == n and a + (b**2) == m:
                ans+=1
    print(ans)
    return

if __name__ == '__main__':
    function()","def count_valid_pairs(n, m):
    count = 0

    for a in range(m + 1):
        for b in range(n + 1):

            if a + 3 * b == n and a * b == m:
                count += 1
    return count

input_data = input().strip()
n, m = map(int, input_data.split())

result = count_valid_pairs(n, m)
print(result)"
385,B,Bear and Strings,PROGRAMMING,"['brute force', 'greedy', 'implementation', 'math', 'strings']","The bear has a string *s*<==<=*s*1*s*2... *s*|*s*| (record |*s*| is the string's length), consisting of lowercase English letters. The bear wants to count the number of such pairs of indices *i*,<=*j* (1<=≤<=*i*<=≤<=*j*<=≤<=|*s*|), that string *x*(*i*,<=*j*)<==<=*s**i**s**i*<=+<=1... *s**j* contains at least one string ""bear"" as a substring.

String *x*(*i*,<=*j*) contains string ""bear"", if there is such index *k* (*i*<=≤<=*k*<=≤<=*j*<=-<=3), that *s**k*<==<=*b*, *s**k*<=+<=1<==<=*e*, *s**k*<=+<=2<==<=*a*, *s**k*<=+<=3<==<=*r*.

Help the bear cope with the given problem.",The first line contains a non-empty string *s* (1<=≤<=|*s*|<=≤<=5000). It is guaranteed that the string only consists of lowercase English letters.,Print a single number — the answer to the problem.,"['bearbtear\n', 'bearaabearc\n']","['6\n', '20\n']","In the first sample, the following pairs (*i*, *j*) match: (1, 4), (1, 5), (1, 6), (1, 7), (1, 8), (1, 9).

In the second sample, the following pairs (*i*, *j*) match: (1,  4), (1,  5), (1,  6), (1,  7), (1,  8), (1,  9), (1,  10), (1,  11), (2,  10), (2,  11), (3,  10), (3,  11), (4,  10), (4,  11), (5,  10), (5,  11), (6,  10), (6,  11), (7,  10), (7,  11).",WRONG_ANSWER,"def count_(s):
    n = len(s)
    count = 0
    posi = []

    for i in range(n - 3):
        if s[i:i + 4] == ""bear"":
            posi.append(i)

    for i in posi:
        l = i + 1
        r = n - (i + 3) - 1
        count += l * r

    return count

s = input()
print(count_(s))","def count_bear_pairs(s):
    n = len(s)
    count = 0

    for i in range(n - 3):
        if s[i:i + 4] == 'bear':

            count += (i + 1) * (n - (i + 3))

    return count

s = input().strip()

print(count_bear_pairs(s))"
60,B,Serial Time!,PROGRAMMING,"['dfs and similar', 'dsu']","The Cereal Guy's friend Serial Guy likes to watch soap operas. An episode is about to start, and he hasn't washed his plate yet. But he decided to at least put in under the tap to be filled with water. The plate can be represented by a parallelepiped *k*<=×<=*n*<=×<=*m*, that is, it has *k* layers (the first layer is the upper one), each of which is a rectangle *n*<=×<=*m* with empty squares ('.') and obstacles ('#'). The water can only be present in the empty squares. The tap is positioned above the square (*x*,<=*y*) of the first layer, it is guaranteed that this square is empty. Every minute a cubical unit of water falls into the plate. Find out in how many minutes the Serial Guy should unglue himself from the soap opera and turn the water off for it not to overfill the plate. That is, you should find the moment of time when the plate is absolutely full and is going to be overfilled in the next moment.

Note: the water fills all the area within reach (see sample 4). Water flows in each of the 6 directions, through faces of 1<=×<=1<=×<=1 cubes.","The first line contains three numbers *k*, *n*, *m* (1<=≤<=*k*,<=*n*,<=*m*<=≤<=10) which are the sizes of the plate. Then follow *k* rectangles consisting of *n* lines each containing *m* characters '.' or '#', which represents the ""layers"" of the plate in the order from the top to the bottom. The rectangles are separated by empty lines (see the samples). The last line contains *x* and *y* (1<=≤<=*x*<=≤<=*n*,<=1<=≤<=*y*<=≤<=*m*) which are the tap's coordinates. *x* is the number of the line and *y* is the number of the column. Lines of each layer are numbered from left to right by the integers from 1 to *n*, columns of each layer are numbered from top to bottom by the integers from 1 to *m*.","The answer should contain a single number, showing in how many minutes the plate will be filled.","['1 1 1\n\n.\n\n1 1\n', '2 1 1\n\n.\n\n#\n\n1 1\n', '2 2 2\n\n.#\n##\n\n..\n..\n\n1 1\n', '3 2 2\n\n#.\n##\n\n#.\n.#\n\n..\n..\n\n1 2\n', '3 3 3\n\n.#.\n###\n##.\n\n.##\n###\n##.\n\n...\n...\n...\n\n1 1\n']","['1\n', '1\n', '5\n', '7\n', '13\n']",none,WRONG_ANSWER,"import sys

def main():
	k, n, m = input().split("" "")
	num_plates = int(k)
	num_lines = int(n)
	num_chars = int(m)

	input()

	plates = []
	visited = []
	for layer in range(num_plates):
		
		plate = []
		visit = []
		for line_num in range(num_lines):

			plate.append(input().split("" ""))

			v = []
			for c in range(num_chars):
				v.append(False)
			visit.append(v)

		plates.append(plate)
		visited.append(visit)
		input()

	x, y = input().split("" "")
	x = int(x)
	y = int(y)
	print(water_flow(plates, visited, 0, x-1, y-1, num_lines, num_chars))

def water_flow(plates, visited, layer, x, y, num_lines, num_chars):
	if (0 <= layer < len(plates)) and (0 <= x < num_lines) and (0 <= y < num_chars):
		if not visited[layer][x][y]:
			square = plates[layer][x][0]
			sqr = square[y]
			visited[layer][x][y] = True

			if sqr == ""."":
				minutes = 1

				minutes += water_flow(plates, visited, layer-1, x, y, num_lines, num_chars)
				minutes += water_flow(plates, visited, layer, x-1, y-1, num_lines, num_chars)
				minutes += water_flow(plates, visited, layer, x-1, y, num_lines, num_chars)
				minutes += water_flow(plates, visited, layer, x-1, y+1, num_lines, num_chars)
				minutes += water_flow(plates, visited, layer, x, y-1, num_lines, num_chars)
				minutes += water_flow(plates, visited, layer, x, y+1, num_lines, num_chars)
				minutes += water_flow(plates, visited, layer, x+1, y-1, num_lines, num_chars)
				minutes += water_flow(plates, visited, layer, x+1, y, num_lines, num_chars)
				minutes += water_flow(plates, visited, layer, x+1, y+1, num_lines, num_chars)
				minutes += water_flow(plates, visited, layer+1, x, y, num_lines, num_chars)

				return minutes

	return 0

main()","def fill_water(k, n, m, layers, tap_coordinates):
    from collections import deque

    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]

    visited = set()
    queue = deque()

    x, y = tap_coordinates
    queue.append((0, x - 1, y - 1))
    visited.add((0, x - 1, y - 1))
    
    total_fillable = 0

    while queue:
        layer, row, col = queue.popleft()

        if layers[layer][row][col] == '.':
            total_fillable += 1

        for dz, dr, dc in directions:
            new_layer = layer + dz
            new_row = row + dr
            new_col = col + dc

            if (0 <= new_layer < k and 
                0 <= new_row < n and 
                0 <= new_col < m and 
                layers[new_layer][new_row][new_col] == '.' and 
                (new_layer, new_row, new_col) not in visited):
                
                visited.add((new_layer, new_row, new_col))
                queue.append((new_layer, new_row, new_col))
    
    return total_fillable

def main():
    import sys
    from sys import stdin
    input = stdin.read
    data = input().strip().split('\n')

    k, n, m = map(int, data[0].split())
    
    layers = []
    index = 1
    for _ in range(k):
        layer = []
        while index < len(data) and data[index].strip() != """":
            layer.append(data[index].strip())
            index += 1
        layers.append(layer)
        index += 1

    tap_x, tap_y = map(int, data[-1].split())

    result = fill_water(k, n, m, layers, (tap_x, tap_y))

    print(result)

if __name__ == ""__main__"":
    main()"
709,A,Juicer,PROGRAMMING,['implementation'],"Kolya is going to make fresh orange juice. He has *n* oranges of sizes *a*1,<=*a*2,<=...,<=*a**n*. Kolya will put them in the juicer in the fixed order, starting with orange of size *a*1, then orange of size *a*2 and so on. To be put in the juicer the orange must have size not exceeding *b*, so if Kolya sees an orange that is strictly greater he throws it away and continues with the next one.

The juicer has a special section to collect waste. It overflows if Kolya squeezes oranges of the total size strictly greater than *d*. When it happens Kolya empties the waste section (even if there are no more oranges) and continues to squeeze the juice. How many times will he have to empty the waste section?","The first line of the input contains three integers *n*, *b* and *d* (1<=≤<=*n*<=≤<=100<=000, 1<=≤<=*b*<=≤<=*d*<=≤<=1<=000<=000) — the number of oranges, the maximum size of the orange that fits in the juicer and the value *d*, which determines the condition when the waste section should be emptied.

The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=1<=000<=000) — sizes of the oranges listed in the order Kolya is going to try to put them in the juicer.",Print one integer — the number of times Kolya will have to empty the waste section.,"['2 7 10\n5 6\n', '1 5 10\n7\n', '3 10 10\n5 7 7\n', '1 1 1\n1\n']","['1\n', '0\n', '1\n', '0\n']","In the first sample, Kolya will squeeze the juice from two oranges and empty the waste section afterwards.

In the second sample, the orange won't fit in the juicer so Kolya will have no juice at all.",OK,"def getNumOfTimes(b, d, oranges):
    num = 0
    waste = 0
    for orange in oranges:
        if orange > b:
            continue
        if waste + orange > d:
            num += 1
            waste = 0
        else:
            waste += orange
    return num

if __name__ == ""__main__"":
    _, b, d = map(int, input().split())
    oranges = map(int, input().split())
    print(getNumOfTimes(b, d, oranges))","n, b, d = map(int, input().split())

sizes = list(map(int, input().split()))

waste = 0
empty_count = 0

for size in sizes:
    if size <= b:
        waste += size
        if waste > d:
            empty_count += 1
            waste = 0

print(empty_count)"
266,A,Stones on the Table,PROGRAMMING,['implementation'],"There are *n* stones on the table in a row, each of them can be red, green or blue. Count the minimum number of stones to take from the table so that any two neighboring stones had different colors. Stones in a row are considered neighboring if there are no other stones between them.","The first line contains integer *n* (1<=≤<=*n*<=≤<=50) — the number of stones on the table. 

The next line contains string *s*, which represents the colors of the stones. We'll consider the stones in the row numbered from 1 to *n* from left to right. Then the *i*-th character *s* equals ""R"", if the *i*-th stone is red, ""G"", if it's green and ""B"", if it's blue.",Print a single integer — the answer to the problem.,"['3\nRRG\n', '5\nRRRRR\n', '4\nBRBG\n']","['1\n', '4\n', '0\n']",none,WRONG_ANSWER,"n = int(input())
colors = input()

def min_stone_to_change_colors(n, colors):
    ans = 0
    i = 0
    while i < n:
        j = i + 1
        while j < n and colors[i] == colors[j]:
            j += 1
        ans += 1
        i = j
    return ans - 1

result = min_stone_to_change_colors(n, colors)
print(result)","n = int(input().strip())

s = input().strip()

count = 0

for i in range(1, n):
    if s[i] == s[i - 1]:
        count += 1

print(count)"
682,D,Alyona and Strings,PROGRAMMING,"['dp', 'strings']","After returned from forest, Alyona started reading a book. She noticed strings *s* and *t*, lengths of which are *n* and *m* respectively. As usual, reading bored Alyona and she decided to pay her attention to strings *s* and *t*, which she considered very similar.

Alyona has her favourite positive integer *k* and because she is too small, *k* does not exceed 10. The girl wants now to choose *k* disjoint non-empty substrings of string *s* such that these strings appear as disjoint substrings of string *t* and in the same order as they do in string *s*. She is also interested in that their length is maximum possible among all variants.

Formally, Alyona wants to find a sequence of *k* non-empty strings *p*1,<=*p*2,<=*p*3,<=...,<=*p**k* satisfying following conditions:
 -  *s* can be represented as concatenation *a*1*p*1*a*2*p*2... *a**k**p**k**a**k*<=+<=1, where *a*1,<=*a*2,<=...,<=*a**k*<=+<=1 is a sequence of arbitrary strings (some of them may be possibly empty); -  *t* can be represented as concatenation *b*1*p*1*b*2*p*2... *b**k**p**k**b**k*<=+<=1, where *b*1,<=*b*2,<=...,<=*b**k*<=+<=1 is a sequence of arbitrary strings (some of them may be possibly empty); -  sum of the lengths of strings in sequence is maximum possible. 
Please help Alyona solve this complicated problem and find at least the sum of the lengths of the strings in a desired sequence.

A substring of a string is a subsequence of consecutive characters of the string.","In the first line of the input three integers *n*, *m*, *k* (1<=≤<=*n*,<=*m*<=≤<=1000, 1<=≤<=*k*<=≤<=10) are given — the length of the string *s*, the length of the string *t* and Alyona's favourite number respectively.

The second line of the input contains string *s*, consisting of lowercase English letters.

The third line of the input contains string *t*, consisting of lowercase English letters.","In the only line print the only non-negative integer — the sum of the lengths of the strings in a desired sequence.

It is guaranteed, that at least one desired sequence exists.","['3 2 2\nabc\nab\n', '9 12 4\nbbaaababb\nabbbabbaaaba\n']","['2\n', '7\n']",The following image describes the answer for the second sample case:,COMPILATION_ERROR,"using namespace std;
typedef long long int ll;
int dp[1001][1001][11][2];
int n, m, k;
string u, v;
int main(void)
{
	cin>>n>>m>>k>>u>>v;
	int i, s, e;
	for(i=1 ; i<=n ; i++)
	{
		for(s=1 ; s<=m ; s++)
		{
			for(e=1 ; e<=k; e++)
			{
				if(u[i-1]==v[s-1])
				{
					dp[i][s][e][1]=1+max(dp[i-1][s-1][e-1][0],dp[i-1][s-1][e][1]);
				}
				dp[i][s][e][0]=max(dp[i][s][e][1],max(dp[i-1][s][e][0],dp[i][s-1][e][0]));
			}
		}
	}
	cout<<dp[n][m][k][0];
}","def max_length_substrings(n, m, k, s, t):

    dp = [[0] * (k + 1) for _ in range(len(s) + 1)]

    for j in range(1, k + 1):

        for i in range(1, len(s) + 1):

            for start in range(i):

                substring = s[start:i]

                if substring in t:

                    dp[i][j] = max(dp[i][j], dp[start][j - 1] + (i - start))

    return dp[len(s)][k]

import sys

for line in sys.stdin:
    n, m, k = map(int, line.split())
    s = input().strip()
    t = input().strip()

    result = max_length_substrings(n, m, k, s, t)

    print(result)"
102,A,Clothes,PROGRAMMING,['brute force'],"A little boy Gerald entered a clothes shop and found out something very unpleasant: not all clothes turns out to match. For example, Gerald noticed that he looks rather ridiculous in a smoking suit and a baseball cap.

Overall the shop sells *n* clothing items, and exactly *m* pairs of clothing items match. Each item has its price, represented by an integer number of rubles. Gerald wants to buy three clothing items so that they matched each other. Besides, he wants to spend as little money as possible. Find the least possible sum he can spend.","The first input file line contains integers *n* and *m* — the total number of clothing items in the shop and the total number of matching pairs of clothing items ().

Next line contains *n* integers *a**i* (1<=≤<=*a**i*<=≤<=106) — the prices of the clothing items in rubles.

Next *m* lines each contain a pair of space-separated integers *u**i* and *v**i* (1<=≤<=*u**i*,<=*v**i*<=≤<=*n*,<=*u**i*<=≠<=*v**i*). Each such pair of numbers means that the *u**i*-th and the *v**i*-th clothing items match each other. It is guaranteed that in each pair *u**i* and *v**i* are distinct and all the unordered pairs (*u**i*,<=*v**i*) are different.","Print the only number — the least possible sum in rubles that Gerald will have to pay in the shop. If the shop has no three clothing items that would match each other, print ""-1"" (without the quotes).","['3 3\n1 2 3\n1 2\n2 3\n3 1\n', '3 2\n2 3 4\n2 3\n2 1\n', '4 4\n1 1 1 1\n1 2\n2 3\n3 4\n4 1\n']","['6\n', '-1\n', '-1\n']","In the first test there only are three pieces of clothing and they all match each other. Thus, there is only one way — to buy the 3 pieces of clothing; in this case he spends 6 roubles.

The second test only has three pieces of clothing as well, yet Gerald can't buy them because the first piece of clothing does not match the third one. Thus, there are no three matching pieces of clothing. The answer is -1.

In the third example there are 4 pieces of clothing, but Gerald can't buy any 3 of them simultaneously. The answer is -1.",RUNTIME_ERROR,"import math
def gcd(a,b):
    while a%b !=0:
        aux = b
        b = a%b
        a = aux
    return b

def lcm(a,b):
    return (a/gcd(a,b))*b

def solve(a):
    return ((a-3)//3)-1
    
for _ in range(int(input())):
    a = int(input())
    print(solve(a))","def find_minimum_cost(n, m, prices, matches):
    from collections import defaultdict

    graph = defaultdict(set)
    for u, v in matches:
        graph[u - 1].add(v - 1)
        graph[v - 1].add(u - 1)
    
    min_cost = float('inf')
    found = False

    for i in range(n):
        for j in graph[i]:
            if j > i:
                for k in graph[j]:
                    if k != i and k in graph[i]:
                        found = True
                        total_cost = prices[i] + prices[j] + prices[k]
                        min_cost = min(min_cost, total_cost)

    return min_cost if found else -1

import sys
input = sys.stdin.read
data = input().strip().split('\n')

n, m = map(int, data[0].split())
prices = list(map(int, data[1].split()))
matches = [list(map(int, line.split())) for line in data[2:]]

result = find_minimum_cost(n, m, prices, matches)

print(result)"
63,A,Sinking Ship,PROGRAMMING,"['implementation', 'sortings', 'strings']","The ship crashed into a reef and is sinking. Now the entire crew must be evacuated. All *n* crew members have already lined up in a row (for convenience let's label them all from left to right with positive integers from 1 to *n*) and await further instructions. However, one should evacuate the crew properly, in a strict order. Specifically:

The first crew members to leave the ship are rats. Then women and children (both groups have the same priority) leave the ship. After that all men are evacuated from the ship. The captain leaves the sinking ship last.

If we cannot determine exactly who should leave the ship first for any two members of the crew by the rules from the previous paragraph, then the one who stands to the left in the line leaves the ship first (or in other words, the one whose number in the line is less).

For each crew member we know his status as a crew member, and also his name. All crew members have different names. Determine the order in which to evacuate the crew.","The first line contains an integer *n*, which is the number of people in the crew (1<=≤<=*n*<=≤<=100). Then follow *n* lines. The *i*-th of those lines contains two words — the name of the crew member who is *i*-th in line, and his status on the ship. The words are separated by exactly one space. There are no other spaces in the line. The names consist of Latin letters, the first letter is uppercase, the rest are lowercase. The length of any name is from 1 to 10 characters. The status can have the following values: rat for a rat, woman for a woman, child for a child, man for a man, captain for the captain. The crew contains exactly one captain.",Print *n* lines. The *i*-th of them should contain the name of the crew member who must be the *i*-th one to leave the ship.,['6\nJack captain\nAlice woman\nCharlie man\nTeddy rat\nBob child\nJulia woman\n'],['Teddy\nAlice\nBob\nJulia\nCharlie\nJack\n'],none,OK,"from functools import cmp_to_key

class Info:
    def __init__(self, _id: int, _name: str, _status: str):
        self.id = _id
        self.name = _name
        self.status = _status

    def __str__(self):
        return f'id: {self.id}, name: {self.name}, status: {self.status}'

def customCompare(obj1:Info, obj2:Info) -> int:
    if obj1.status != ""rat"" and obj2.status == ""rat"":
        return 1
    if obj1.status == ""rat"" and obj2.status != ""rat"":
        return -1
    if (obj1.status != ""woman"" and obj1.status != ""child"") and (obj2.status == ""woman"" or obj2.status == ""child""):
        return 1
    if (obj1.status == ""woman"" or obj1.status == ""child"") and (obj2.status != ""woman"" and obj2.status != ""child""):
        return -1
    if obj1.status != ""man"" and obj2.status == ""man"":
        return 1
    if obj1.status == ""man"" and obj2.status != ""man"":
        return -1

    return obj1.id - obj2.id
def output(cont:list):
    for obj in cont:
        print(obj)

n = int(input())
cont = []

for i in range(n):
    _name, _status = input().split()
    obj = Info(i + 1, _name, _status)
    cont.append(obj)

cont.sort(key=cmp_to_key(customCompare))

for obj in cont:
    print(obj.name)","n = int(input())

rats = []
women_children = []
men = []
captain = """"

for _ in range(n):
    name, status = input().split()
    if status == ""rat"":
        rats.append(name)
    elif status in (""woman"", ""child""):
        women_children.append(name)
    elif status == ""man"":
        men.append(name)
    elif status == ""captain"":
        captain = name

evacuation_order = []

evacuation_order.extend(rats)

evacuation_order.extend(women_children)

evacuation_order.extend(men)

evacuation_order.append(captain)

for member in evacuation_order:
    print(member)"
811,B,Vladik and Complicated Book,PROGRAMMING,"['implementation', 'sortings']","Vladik had started reading a complicated book about algorithms containing *n* pages. To improve understanding of what is written, his friends advised him to read pages in some order given by permutation *P*<==<=[*p*1,<=*p*2,<=...,<=*p**n*], where *p**i* denotes the number of page that should be read *i*-th in turn.

Sometimes Vladik’s mom sorted some subsegment of permutation *P* from position *l* to position *r* inclusive, because she loves the order. For every of such sorting Vladik knows number *x* — what index of page in permutation he should read. He is wondered if the page, which he will read after sorting, has changed. In other words, has *p**x* changed? After every sorting Vladik return permutation to initial state, so you can assume that each sorting is independent from each other.","First line contains two space-separated integers *n*, *m* (1<=≤<=*n*,<=*m*<=≤<=104) — length of permutation and number of times Vladik's mom sorted some subsegment of the book.

Second line contains *n* space-separated integers *p*1,<=*p*2,<=...,<=*p**n* (1<=≤<=*p**i*<=≤<=*n*) — permutation *P*. Note that elements in permutation are distinct.

Each of the next *m* lines contains three space-separated integers *l**i*, *r**i*, *x**i* (1<=≤<=*l**i*<=≤<=*x**i*<=≤<=*r**i*<=≤<=*n*) — left and right borders of sorted subsegment in *i*-th sorting and position that is interesting to Vladik.","For each mom’s sorting on it’s own line print ""Yes"", if page which is interesting to Vladik hasn't changed, or ""No"" otherwise.","['5 5\n5 4 3 2 1\n1 5 3\n1 3 1\n2 4 3\n4 4 4\n2 5 3\n', '6 5\n1 4 3 2 5 6\n2 4 3\n1 6 2\n4 5 4\n1 3 3\n2 6 3\n']","['Yes\nNo\nYes\nYes\nNo\n', 'Yes\nNo\nYes\nNo\nYes\n']","Explanation of first test case: 
 1.  [1, 2, 3, 4, 5] — permutation after sorting, 3-rd element hasn’t changed, so answer is ""Yes"". 1.  [3, 4, 5, 2, 1] — permutation after sorting, 1-st element has changed, so answer is ""No"". 1.  [5, 2, 3, 4, 1] — permutation after sorting, 3-rd element hasn’t changed, so answer is ""Yes"". 1.  [5, 4, 3, 2, 1] — permutation after sorting, 4-th element hasn’t changed, so answer is ""Yes"". 1.  [5, 1, 2, 3, 4] — permutation after sorting, 3-rd element has changed, so answer is ""No"".",RUNTIME_ERROR,"def swap(A, i, j):
	temp = A[i]
	A[i] = A[j]
	A[j] = temp

def Partition(A, p, r, x):
	
	i = p - 1
	j = r + 1
	while True:
		j-=1
		while A[j] > x:
			j-=1
		i+=1
		while A[i] < x:
			i+=1
		if i < j:
			swap(A, i, j)
		else: 
			return j

def median_of_3(a,b,c):
	
	if (a<=b and b<=c) or (c<=b and b<=a):
		return b
	elif (b<=a and a<=c) or (c<=a and a<=b):
		return a
	else:
		return c

def insertion_sort(A, p, r):
	
	for i in range(p, r + 1):
		key = A[i]
		j = i - 1
		while j>=0 and key<A[j]:
			A[j + 1] = A[j]
			j-=1
		A[j + 1] = key

def _median_of_3_quick_sort(A, f, b):
	
	if b - f + 1 <= 10:
		insertion_sort(A, f, b)
	else:
		p = Partition(A, f, b, median_of_3(A[f], \
			A[f + (b-f)//2 + 1], A[b]))
		_median_of_3_quick_sort(A, f, p)
		_median_of_3_quick_sort(A, p+1, b)

def median_of_3_quick_sort(A):
	p = 0
	r = len(A) - 1
	_median_of_3_quick_sort(A, p, r)

def main():
	t=0
	n=int(input())
	m=int(input())
	p=[]
	for i in range(n):
		a=int(input())
		p.append(a)
	while t<m:
		l=int(input())
		r=int(input())
		x=int(input())
		le=r-l+1
		pos=p[x-1]
		s=[]
		for i in range(le):
			s.append(p[l+i-1])
		median_of_3_quick_sort(s)
		pos2 = s[x-l]
		if pos2==pos:
			print(""Yes"")
		else:
			print(""No"")
		t+=1

if __name__ == '__main__':
	main()","n, m = map(int, input().split())
p = list(map(int, input().split()))

for _ in range(m):
    l, r, x = map(int, input().split())

    subarray = p[l-1:r]
    subarray.sort()

    new_p = p[:]
    new_p[l-1:r] = subarray

    if new_p[x-1] == p[x-1]:
        print(""Yes"")
    else:
        print(""No"")"
735,D,Taxes,PROGRAMMING,"['math', 'number theory']","Mr. Funt now lives in a country with a very specific tax laws. The total income of mr. Funt during this year is equal to *n* (*n*<=≥<=2) burles and the amount of tax he has to pay is calculated as the maximum divisor of *n* (not equal to *n*, of course). For example, if *n*<==<=6 then Funt has to pay 3 burles, while for *n*<==<=25 he needs to pay 5 and if *n*<==<=2 he pays only 1 burle.

As mr. Funt is a very opportunistic person he wants to cheat a bit. In particular, he wants to split the initial *n* in several parts *n*1<=+<=*n*2<=+<=...<=+<=*n**k*<==<=*n* (here *k* is arbitrary, even *k*<==<=1 is allowed) and pay the taxes for each part separately. He can't make some part equal to 1 because it will reveal him. So, the condition *n**i*<=≥<=2 should hold for all *i* from 1 to *k*.

Ostap Bender wonders, how many money Funt has to pay (i.e. minimal) if he chooses and optimal way to split *n* in parts.",The first line of the input contains a single integer *n* (2<=≤<=*n*<=≤<=2·109) — the total year income of mr. Funt.,Print one integer — minimum possible number of burles that mr. Funt has to pay as a tax.,"['4\n', '27\n']","['2\n', '3\n']",none,OK,"from math import sqrt

def prime(n):
    for d in range(3, int(sqrt(n)) + 1, 2):
        if n % d == 0:
            return 0
    return 1

n = int(input())
if n == 2:
    print(1)
elif n % 2 == 0:
    print(2)
elif prime(n):
    print(1)
elif prime(n - 2):
    print(2)
else:
    print(3)","def max_divisor(n):
    for i in range(n // 2, 0, -1):
        if n % i == 0:
            return i
    return 1

def minimum_tax(n):
    if n == 2:
        return 1

    if n % 2 == 0:
        return 2
    else:
        return 3

if __name__ == ""__main__"":
    import sys
    input_data = sys.stdin.read().strip().split()
    results = []

    for line in input_data:
        n = int(line)
        results.append(minimum_tax(n))

    for result in results:
        print(result)"
665,C,Simple Strings,PROGRAMMING,"['dp', 'greedy', 'strings']","zscoder loves simple strings! A string *t* is called simple if every pair of adjacent characters are distinct. For example ab, aba, zscoder are simple whereas aa, add are not simple.

zscoder is given a string *s*. He wants to change a minimum number of characters so that the string *s* becomes simple. Help him with this task!",The only line contains the string *s* (1<=≤<=|*s*|<=≤<=2·105) — the string given to zscoder. The string *s* consists of only lowercase English letters.,"Print the simple string *s*' — the string *s* after the minimal number of changes. If there are multiple solutions, you may output any of them.

Note that the string *s*' should also consist of only lowercase English letters.","['aab\n', 'caaab\n', 'zscoder\n']","['bab\n', 'cabab\n', 'zscoder\n']",none,OK,"def add(a, b):
    for j in range(26):
        c = chr(j + ord('a'))
        if(c != a and c != b):
            return c
    

s = list(input())
n = len(s)
for i in range(1, n - 1):
    if(s[i] == s[i - 1]):
        s[i] = add(s[i - 1], s[i + 1])
if(n > 1):
    if(s[-1] == s[-2]):
        for j in range(26):
            c = chr(j + ord('a'))
            if(c != s[-2]):
                s[-1] = c 
                break 
    
print(''.join(s))","def make_simple_string(s: str) -> str:

    s_list = list(s)

    for i in range(1, len(s_list)):

        if s_list[i] == s_list[i - 1]:

            for char in 'abcdefghijklmnopqrstuvwxyz':

                if char != s_list[i - 1] and (i + 1 >= len(s_list) or char != s_list[i + 1]):
                    s_list[i] = char
                    break

    return ''.join(s_list)

input_strings = ['aab\n', 'caaab\n', 'zscoder\n']
output = [make_simple_string(s.strip()) + '\n' for s in input_strings]
print(output)"
1005,D,Polycarp and Div 3,PROGRAMMING,"['dp', 'greedy', 'number theory']","Polycarp likes numbers that are divisible by 3.

He has a huge number $s$. Polycarp wants to cut from it the maximum number of numbers that are divisible by $3$. To do this, he makes an arbitrary number of vertical cuts between pairs of adjacent digits. As a result, after $m$ such cuts, there will be $m+1$ parts in total. Polycarp analyzes each of the obtained numbers and finds the number of those that are divisible by $3$.

For example, if the original number is $s=3121$, then Polycarp can cut it into three parts with two cuts: $3|1|21$. As a result, he will get two numbers that are divisible by $3$.

Polycarp can make an arbitrary number of vertical cuts, where each cut is made between a pair of adjacent digits. The resulting numbers cannot contain extra leading zeroes (that is, the number can begin with 0 if and only if this number is exactly one character '0'). For example, 007, 01 and 00099 are not valid numbers, but 90, 0 and 10001 are valid.

What is the maximum number of numbers divisible by $3$ that Polycarp can obtain?","The first line of the input contains a positive integer $s$. The number of digits of the number $s$ is between $1$ and $2\cdot10^5$, inclusive. The first (leftmost) digit is not equal to 0.",Print the maximum number of numbers divisible by $3$ that Polycarp can get by making vertical cuts in the given number $s$.,"['3121\n', '6\n', '1000000000000000000000000000000000\n', '201920181\n']","['2\n', '1\n', '33\n', '4\n']","In the first example, an example set of optimal cuts on the number is 3|1|21.

In the second example, you do not need to make any cuts. The specified number 6 forms one number that is divisible by $3$.

In the third example, cuts must be made between each pair of digits. As a result, Polycarp gets one digit 1 and $33$ digits 0. Each of the $33$ digits 0 forms a number that is divisible by $3$.

In the fourth example, an example set of optimal cuts is 2|0|1|9|201|81. The numbers $0$, $9$, $201$ and $81$ are divisible by $3$.",WRONG_ANSWER,"def max_divisible_numbers(s):
    n = len(s)

    dp = [[0] * 3 for _ in range(n + 1)]

    for i in range(1, n + 1):

        remainder = int(s[i - 1]) % 3

        dp[i][0] = dp[i - 1][0] + (remainder == 0)
        dp[i][1] = max(dp[i - 1][1] + (remainder == 1), dp[i - 1][0] + (remainder == 2))
        dp[i][2] = max(dp[i - 1][2] + (remainder == 2), dp[i - 1][0] + (remainder == 1))

    return dp[n][0]

s = input().strip()
result = max_divisible_numbers(s)
print(result)","def max_divisible_by_3(s):

    count = 0

    for char in s:

        if char == '0' or int(char) % 3 == 0:
            count += 1

    return count

input_numbers = ['3121', '6', '1000000000000000000000000000000000', '201920181']

for number in input_numbers:
    result = max_divisible_by_3(number)
    print(result)"
52,C,Circular RMQ,PROGRAMMING,['data structures'],"You are given circular array *a*0,<=*a*1,<=...,<=*a**n*<=-<=1. There are two types of operations with it: 
 -  *inc*(*lf*,<=*rg*,<=*v*) — this operation increases each element on the segment [*lf*,<=*rg*] (inclusively) by *v*; -  *rmq*(*lf*,<=*rg*) — this operation returns minimal value on the segment [*lf*,<=*rg*] (inclusively). 
Assume segments to be circular, so if *n*<==<=5 and *lf*<==<=3,<=*rg*<==<=1, it means the index sequence: 3,<=4,<=0,<=1.

Write program to process given sequence of operations.","The first line contains integer *n* (1<=≤<=*n*<=≤<=200000). The next line contains initial state of the array: *a*0,<=*a*1,<=...,<=*a**n*<=-<=1 (<=-<=106<=≤<=*a**i*<=≤<=106), *a**i* are integer. The third line contains integer *m* (0<=≤<=*m*<=≤<=200000), *m* — the number of operartons. Next *m* lines contain one operation each. If line contains two integer *lf*,<=*rg* (0<=≤<=*lf*,<=*rg*<=≤<=*n*<=-<=1) it means *rmq* operation, it contains three integers *lf*,<=*rg*,<=*v* (0<=≤<=*lf*,<=*rg*<=≤<=*n*<=-<=1;<=-<=106<=≤<=*v*<=≤<=106) — *inc* operation.","For each *rmq* operation write result for it. Please, do not use %lld specificator to read or write 64-bit integers in C++. It is preffered to use cout (also you may use %I64d).",['4\n1 2 3 4\n4\n3 0\n3 0 -1\n0 1\n2 1\n'],['1\n0\n0\n'],none,WRONG_ANSWER,"from typing import List

class Node ():
  def __init__ (self):
    self.min=float('inf')
    self.increase=0;
    self.left=self.right=None 
    self.lChild=self.rChild=None

def recalc(root:Node):
  if root.left==root.right :return 
  root.min=min(root.lChild.min+root.lChild.increase,root.rChild.min+root.rChild.increase)

def createSgTree(nums:List[int],l:int,r:int):
  root=Node()
  root.right=r 
  root.left=l
  if l==r : 
    root.min=nums[l]
  else :
    mid=(l+r)//2 
    root.lChild=createSgTree(nums,l,mid)
    root.rChild=createSgTree(nums,mid+1,r)
    recalc(root)
  return root

def propagation(root:Node) :
  root.min+=root.increase
  if root.left!=root.right :
    root.lChild.increase=root.rChild.increase=root.increase 
  root.increase=0

def updateRange(root:Node,ql:int,qr:int,diff):
  if ql<=root.left and root.right<=qr :
    root.increase+=diff 
    return 
  if root.left>qr or root.right<ql : return 
  if root.increase!=0 :propagation(root) 
  updateRange(root.lChild,ql,qr,diff)
  updateRange(root.rChild,ql,qr,diff)
  recalc(root)

def rangeMin(root:Node,ql,qr) :
  if ql<=root.left and root.right<=qr :return root.min +root.increase
  if root.left>qr or root.right<ql : return float('inf')
  if root.increase!=0 :
    propagation(root)
  return min(rangeMin(root.lChild,ql,qr),rangeMin(root.rChild,ql,qr))

class Solution():
  def Circular_RMQ(self,n:int,nums:List[int]):
    root=createSgTree(nums,0,n-1)
    nq=int(input())
    for i in range(nq):
      request=list(map(int, input().split()))
      if len(request)==2 :
        print(min(rangeMin(root,request[0],n-1),rangeMin(root,0,request[1])))
      else :
        updateRange(root,request[0],n-1,request[2])
        updateRange(root,0,request[1],request[2])

n=int(input())
nums = list(map(int, input().split()))
x=Solution()
x.Circular_RMQ(n,nums)","class CircularArray:
    def __init__(self, array):
        self.array = array
        self.n = len(array)

    def inc(self, lf, rg, v):

        if lf <= rg:
            for i in range(lf, rg + 1):
                self.array[i] += v
        else:
            for i in range(lf, self.n):
                self.array[i] += v
            for i in range(0, rg + 1):
                self.array[i] += v

    def rmq(self, lf, rg):

        if lf <= rg:
            return min(self.array[lf:rg + 1])
        else:
            return min(min(self.array[lf:self.n]), min(self.array[0:rg + 1]))

def main():
    import sys
    input = sys.stdin.read
    data = input().splitlines()

    n = int(data[0])
    array = list(map(int, data[1].split()))
    m = int(data[2])

    circular_array = CircularArray(array)
    results = []

    for i in range(m):
        line = list(map(int, data[3 + i].split()))
        if len(line) == 2:
            lf, rg = line

            results.append(circular_array.rmq(lf, rg))
        elif len(line) == 3:
            lf, rg, v = line

            circular_array.inc(lf, rg, v)

    sys.stdout.write('\n'.join(map(str, results)) + '\n')

if __name__ == ""__main__"":
    main()"
714,A,Meeting of Old Friends,PROGRAMMING,"['implementation', 'math']","Today an outstanding event is going to happen in the forest — hedgehog Filya will come to his old fried Sonya!

Sonya is an owl and she sleeps during the day and stay awake from minute *l*1 to minute *r*1 inclusive. Also, during the minute *k* she prinks and is unavailable for Filya.

Filya works a lot and he plans to visit Sonya from minute *l*2 to minute *r*2 inclusive.

Calculate the number of minutes they will be able to spend together.","The only line of the input contains integers *l*1, *r*1, *l*2, *r*2 and *k* (1<=≤<=*l*1,<=*r*1,<=*l*2,<=*r*2,<=*k*<=≤<=1018, *l*1<=≤<=*r*1, *l*2<=≤<=*r*2), providing the segments of time for Sonya and Filya and the moment of time when Sonya prinks.",Print one integer — the number of minutes Sonya and Filya will be able to spend together.,"['1 10 9 20 1\n', '1 100 50 200 75\n']","['2\n', '50\n']","In the first sample, they will be together during minutes 9 and 10.

In the second sample, they will be together from minute 50 to minute 74 and from minute 76 to minute 100.",OK,"import operator as op
import re
import sys
from bisect import bisect, bisect_left, insort, insort_left
from collections import Counter, defaultdict, deque
from copy import deepcopy
from decimal import Decimal
from functools import reduce
from itertools import (
    accumulate, combinations, combinations_with_replacement, groupby,
    permutations, product)
from math import (acos, asin, atan, ceil, cos, degrees, factorial, gcd, hypot,
                  log2, pi, radians, sin, sqrt, tan)
from operator import itemgetter, mul
from string import ascii_lowercase, ascii_uppercase, digits

def inp():
    return(int(input()))

def inlist():
    return(list(map(int, input().split())))

def instr():
    s = input()
    return(list(s[:len(s)]))

def invr():
    return(map(int, input().split()))

def def_value():
    return 0

l1, r1, l2, r2, k = invr()

if r2 < l1 or l2 > r1:
    print(0)
    sys.exit()

L = max(l1, l2)
R = min(r1, r2)

res = R - L + 1
if k >= L and k <= R:
    res -= 1
if res < 0:
    print(0)
else:
    print(res)","def calculate_meeting_time(l1, r1, l2, r2, k):

    start = max(l1, l2)
    end = min(r1, r2)

    if start > end:
        return 0

    total_minutes = end - start + 1

    if start <= k <= end:
        total_minutes -= 1
    
    return total_minutes

input_data = input().strip().split()
l1, r1, l2, r2, k = map(int, input_data)

result = calculate_meeting_time(l1, r1, l2, r2, k)
print(result)"
229,D,Towers,PROGRAMMING,"['dp', 'greedy', 'two pointers']","The city of D consists of *n* towers, built consecutively on a straight line. The height of the tower that goes *i*-th (from left to right) in the sequence equals *h**i*. The city mayor decided to rebuild the city to make it beautiful. In a beautiful city all towers are are arranged in non-descending order of their height from left to right.

The rebuilding consists of performing several (perhaps zero) operations. An operation constitutes using a crane to take any tower and put it altogether on the top of some other neighboring tower. In other words, we can take the tower that stands *i*-th and put it on the top of either the (*i*<=-<=1)-th tower (if it exists), or the (*i*<=+<=1)-th tower (of it exists). The height of the resulting tower equals the sum of heights of the two towers that were put together. After that the two towers can't be split by any means, but more similar operations can be performed on the resulting tower. Note that after each operation the total number of towers on the straight line decreases by 1.

Help the mayor determine the minimum number of operations required to make the city beautiful.",The first line contains a single integer *n* (1<=≤<=*n*<=≤<=5000) — the number of towers in the city. The next line contains *n* space-separated integers: the *i*-th number *h**i* (1<=≤<=*h**i*<=≤<=105) determines the height of the tower that is *i*-th (from left to right) in the initial tower sequence.,Print a single integer — the minimum number of operations needed to make the city beautiful.,"['5\n8 2 7 3 1\n', '3\n5 2 1\n']","['3\n', '2\n']",none,WRONG_ANSWER,"def solve(arr):
    if len(arr) <= 1:
        return 0

    i, j = 0, 1
    last_val = arr[i]
    ops = 0

    while j < len(arr):
        val =  0
        while j < len(arr) and val < last_val:
            val += arr[j]
            j += 1

        if val >= last_val:
            ops += j - 2 - i
            i = j - 1
            last_val = val
        else:
            ops += j - i - 1

    return ops

n = input()

arr = list(map(int, input().split()))
print(solve(arr))","def min_operations_to_beautiful(n, heights):

    lis = [1] * n

    for i in range(n):
        for j in range(i):
            if heights[j] <= heights[i]:
                lis[i] = max(lis[i], lis[j] + 1)

    return n - max(lis)

n = int(input())
heights = list(map(int, input().split()))

print(min_operations_to_beautiful(n, heights))"
227,B,Effective Approach,PROGRAMMING,['implementation'],"Once at a team training Vasya, Petya and Sasha got a problem on implementing linear search in an array.

According to the boys, linear search works as follows. The array elements in a pre-selected order are in turn compared with the number that you need to find. Once you find the array element that is equal to the required one, the search ends. The efficiency of the algorithm is the number of performed comparisons. The fewer comparisons the linear search has made, the more effective it is.

Vasya believes that a linear search would work better if it sequentially iterates through the elements, starting with the 1-st one (in this problem we consider the elements of the array indexed from 1 to *n*) and ending with the *n*-th one. And Petya says that Vasya is wrong: the search will need less comparisons if it sequentially iterates the elements starting from the *n*-th and ending with the 1-st one. Sasha argues that the two approaches are equivalent.

To finally begin the task, the teammates decided to settle the debate and compare the two approaches on an example. For this, they took an array that is a permutation of integers from 1 to *n*, and generated *m* queries of the form: find element with value *b**i* in the array. They want to calculate for both approaches how many comparisons in total the linear search will need to respond to all queries. If the first search needs fewer comparisons, then the winner of the dispute is Vasya. If the second one does, then the winner is Petya. If both approaches make the same number of comparisons, then Sasha's got the upper hand.

But the problem is, linear search is too slow. That's why the boys aren't going to find out who is right before the end of the training, unless you come in here. Help them to determine who will win the dispute.","The first line contains integer *n* (1<=≤<=*n*<=≤<=105) — the number of elements in the array. The second line contains *n* distinct space-separated integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=*n*) — the elements of array. 

The third line contains integer *m* (1<=≤<=*m*<=≤<=105) — the number of queries. The last line contains *m* space-separated integers *b*1,<=*b*2,<=...,<=*b**m* (1<=≤<=*b**i*<=≤<=*n*) — the search queries. Note that the queries can repeat.","Print two integers, showing how many comparisons Vasya's approach needs and how many comparisons Petya's approach needs. Separate the numbers by spaces.

Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use cin, cout streams or the %I64d specifier.","['2\n1 2\n1\n1\n', '2\n2 1\n1\n1\n', '3\n3 1 2\n3\n1 2 3\n']","['1 2\n', '2 1\n', '6 6\n']","In the first sample Vasya's approach will make one comparison (it starts with the 1-st element and immediately finds the required number), and Petya's approach makes two comparisons (first he compares with the 2-nd array element, doesn't find the search item and compares with the 1-st element).

In the second sample, on the contrary, Vasya's approach will need two comparisons (first with 1-st element, and then with the 2-nd), and Petya's approach will find the required value in one comparison (the first comparison with the 2-nd element).",TIME_LIMIT_EXCEEDED,"from sys import stdin

def get_data(n,array,m,queries):
    vasya = 0
    petya = 0
    for q in queries:
        pos = array.index(q) + 1
        vasya += pos
        petya += n - pos + 1
    return [vasya,petya]        
            
def main():
    n = int(stdin.readline())
    array = [int(x) for x in stdin.readline().split()]
    m = int(stdin.readline())
    queries = [int(x) for x in stdin.readline().split()]
    results = get_data(n,array,m,queries)
    print(""{} {}"".format(results[0],results[1]))

main()","def linear_search_comparisons(n, array, m, queries):

    position = {value: index + 1 for index, value in enumerate(array)}

    vasya_comparisons = 0
    petya_comparisons = 0

    for query in queries:

        vasya_comparisons += position[query]

        petya_comparisons += n - position[query] + 1

    return vasya_comparisons, petya_comparisons

n = int(input().strip())
array = list(map(int, input().strip().split()))
m = int(input().strip())
queries = list(map(int, input().strip().split()))

vasya, petya = linear_search_comparisons(n, array, m, queries)

print(vasya, petya)"
424,A,Squats,PROGRAMMING,['implementation'],"Pasha has many hamsters and he makes them work out. Today, *n* hamsters (*n* is even) came to work out. The hamsters lined up and each hamster either sat down or stood up.

For another exercise, Pasha needs exactly  hamsters to stand up and the other hamsters to sit down. In one minute, Pasha can make some hamster ether sit down or stand up. How many minutes will he need to get what he wants if he acts optimally well?","The first line contains integer *n* (2<=≤<=*n*<=≤<=200; *n* is even). The next line contains *n* characters without spaces. These characters describe the hamsters' position: the *i*-th character equals 'X', if the *i*-th hamster in the row is standing, and 'x', if he is sitting.","In the first line, print a single integer — the minimum required number of minutes. In the second line, print a string that describes the hamsters' position after Pasha makes the required changes. If there are multiple optimal positions, print any of them.","['4\nxxXx\n', '2\nXX\n', '6\nxXXxXx\n']","['1\nXxXx\n', '1\nxX\n', '0\nxXXxXx\n']",none,OK,"""""""
Created on Sun Apr  5 05:45:34 2020

@author: alexi
""""""

def hamster_squat():
    
    total = int(input())
    
    hamsters = input()
    
    dic = {'x':0,'X':0}
    
    for i in range(len(hamsters)):
        dic[hamsters[i]] += 1
    
    if dic['x'] == dic['X']:
        print(0)
        print(hamsters)
        return
    
    sat = dic['x']
    stood = dic['X']
    
    add_lower = False
    if sat < stood:
        add_lower = True
    
    maximum = max(sat, stood)
    add = maximum - (int((sat+stood)/2))
    print(add)
    if add_lower:
        output = ''
        hamsters = [i for i in hamsters]
        for i in range(len(hamsters)):
            if add > 0:
                if hamsters[i] == 'X':
                    hamsters[i] = 'x'
                    add -= 1
 
            output = output + hamsters[i]

    else:
        output = ''
        hamsters = [i for i in hamsters]
        for i in range(len(hamsters)):
            if add > 0:
                if hamsters[i] == 'x':
                    hamsters[i] = 'X'
                    add -= 1

            output = output + hamsters[i]

    print(output)

hamster_squat()","def min_minutes_to_stand(n, positions):
    num_standing = positions.count('X')
    num_sitting = n - num_standing

    target_standing = n // 2
    minutes_needed = 0

    if num_standing < target_standing:
        minutes_needed = target_standing - num_standing

        new_positions = list(positions)
        for i in range(n):
            if new_positions[i] == 'x' and minutes_needed > 0:
                new_positions[i] = 'X'
                minutes_needed -= 1
    elif num_standing > target_standing:
        minutes_needed = num_standing - target_standing

        new_positions = list(positions)
        for i in range(n):
            if new_positions[i] == 'X' and minutes_needed > 0:
                new_positions[i] = 'x'
                minutes_needed -= 1
    else:
        new_positions = list(positions)
     
    return minutes_needed, ''.join(new_positions)

n = int(input())
positions = input().strip()

minutes, final_positions = min_minutes_to_stand(n, positions)

print(minutes)
print(final_positions)"
200,B,Drinks,PROGRAMMING,"['implementation', 'math']","Little Vasya loves orange juice very much. That's why any food and drink in his kitchen necessarily contains orange juice. There are *n* drinks in his fridge, the volume fraction of orange juice in the *i*-th drink equals *p**i* percent.

One day Vasya decided to make himself an orange cocktail. He took equal proportions of each of the *n* drinks and mixed them. Then he wondered, how much orange juice the cocktail has.

Find the volume fraction of orange juice in the final drink.","The first input line contains a single integer *n* (1<=≤<=*n*<=≤<=100) — the number of orange-containing drinks in Vasya's fridge. The second line contains *n* integers *p**i* (0<=≤<=*p**i*<=≤<=100) — the volume fraction of orange juice in the *i*-th drink, in percent. The numbers are separated by a space.",Print the volume fraction in percent of orange juice in Vasya's cocktail. The answer will be considered correct if the absolute or relative error does not exceed 10<=<=-<=4.,"['3\n50 50 100\n', '4\n0 25 50 75\n']","['66.666666666667\n', '37.500000000000\n']","Note to the first sample: let's assume that Vasya takes *x* milliliters of each drink from the fridge. Then the volume of pure juice in the cocktail will equal <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/c1fac6e64d3a8ee6a5ac138cbe51e60039b22473.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> milliliters. The total cocktail's volume equals 3·*x* milliliters, so the volume fraction of the juice in the cocktail equals <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/ceb0664e55a1f9f5fa1243ec74680a4665a4d58d.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>, that is, 66.(6) percent.",OK,"n = int(input())
def sum(l,n):
    sum1 = 0
    for i in range(n):
        sum1 += l[i]
    return sum1

l = [int(x) for x in input().split()]
sum(l, n)
print(sum(l,n)/n)","def calculate_orange_juice_fraction(n, juice_percentages):

    total_percentage = sum(juice_percentages)
    average_percentage = total_percentage / n
    return average_percentage

n = int(input())
juice_percentages = list(map(int, input().split()))

result = calculate_orange_juice_fraction(n, juice_percentages)
print(result)"
242,C,King's Path,PROGRAMMING,"['dfs and similar', 'graphs', 'hashing', 'shortest paths']","The black king is standing on a chess field consisting of 109 rows and 109 columns. We will consider the rows of the field numbered with integers from 1 to 109 from top to bottom. The columns are similarly numbered with integers from 1 to 109 from left to right. We will denote a cell of the field that is located in the *i*-th row and *j*-th column as (*i*,<=*j*).

You know that some squares of the given chess field are allowed. All allowed cells of the chess field are given as *n* segments. Each segment is described by three integers *r**i*,<=*a**i*,<=*b**i* (*a**i*<=≤<=*b**i*), denoting that cells in columns from number *a**i* to number *b**i* inclusive in the *r**i*-th row are allowed.

Your task is to find the minimum number of moves the king needs to get from square (*x*0,<=*y*0) to square (*x*1,<=*y*1), provided that he only moves along the allowed cells. In other words, the king can be located only on allowed cells on his way.

Let us remind you that a chess king can move to any of the neighboring cells in one move. Two cells of a chess field are considered neighboring if they share at least one point.","The first line contains four space-separated integers *x*0,<=*y*0,<=*x*1,<=*y*1 (1<=≤<=*x*0,<=*y*0,<=*x*1,<=*y*1<=≤<=109), denoting the initial and the final positions of the king.

The second line contains a single integer *n* (1<=≤<=*n*<=≤<=105), denoting the number of segments of allowed cells. Next *n* lines contain the descriptions of these segments. The *i*-th line contains three space-separated integers *r**i*,<=*a**i*,<=*b**i* (1<=≤<=*r**i*,<=*a**i*,<=*b**i*<=≤<=109,<=*a**i*<=≤<=*b**i*), denoting that cells in columns from number *a**i* to number *b**i* inclusive in the *r**i*-th row are allowed. Note that the segments of the allowed cells can intersect and embed arbitrarily.

It is guaranteed that the king's initial and final position are allowed cells. It is guaranteed that the king's initial and the final positions do not coincide. It is guaranteed that the total length of all given segments doesn't exceed 105.","If there is no path between the initial and final position along allowed cells, print -1.

Otherwise print a single integer — the minimum number of moves the king needs to get from the initial position to the final one.","['5 7 6 11\n3\n5 3 8\n6 7 11\n5 2 5\n', '3 4 3 10\n3\n3 1 4\n4 5 9\n3 10 10\n', '1 1 2 10\n2\n1 1 3\n2 6 10\n']","['4\n', '6\n', '-1\n']",none,OK,"import sys
import math
from sys import stdin, stdout

def get_ints_in_variables():
    return map(int, sys.stdin.readline().strip().split())
def get_int(): return int(input())
def get_ints_in_list(): return list(
    map(int, sys.stdin.readline().strip().split()))
def get_list_of_list(n): return [list(
    map(int, sys.stdin.readline().strip().split())) for _ in range(n)]
def get_string(): return sys.stdin.readline().strip()
 
def main():

    x0,y0,x1,y1 = get_ints_in_variables()
    n = int(input())
    g = {}
    for i in range(0, n):
        r,a,b = get_ints_in_variables()
        for i in range(a, b+1):
            g[(r, i)] = -1

    g[(x0, y0)] = 0

    dx = [-1, -1, -1, 0, 0, 1, 1, 1]
    dy = [0, -1, 1, -1, 1, 0, -1, 1]
    queue = [(x0, y0)]
    while len(queue):
        node = queue.pop(0)
        for j in range(8):
            v = (node[0]+dx[j], node[1]+dy[j])

            if not v in g:
                continue
            if v in g and g[v] != -1:
                continue
            g[v] = g[node]+1
            queue.append(v)
    print(g[(x1, y1)])

if __name__ == ""__main__"":
    main()","from collections import deque, defaultdict

def bfs(start, goal, allowed):
    queue = deque([start])
    visited = set()
    visited.add(start)
    moves = 0
    
    while queue:
        for _ in range(len(queue)):
            x, y = queue.popleft()
            if (x, y) == goal:
                return moves

            for dx in [-1, 0, 1]:
                for dy in [-1, 0, 1]:
                    if dx == 0 and dy == 0:
                        continue
                    
                    new_x, new_y = x + dx, y + dy

                    if (new_x in allowed and 
                        any(new_y >= a and new_y <= b for a, b in allowed[new_x]) and
                        (new_x, new_y) not in visited):
                        visited.add((new_x, new_y))
                        queue.append((new_x, new_y))
        
        moves += 1
    
    return -1

def main():

    x0, y0, x1, y1 = map(int, input().split())
    n = int(input().strip())
    allowed = defaultdict(list)

    for _ in range(n):
        ri, ai, bi = map(int, input().split())
        allowed[ri].append((ai, bi))

    result = bfs((x0, y0), (x1, y1), allowed)
    print(result)

if __name__ == ""__main__"":
    main()"
712,B,Memory and Trident,PROGRAMMING,"['implementation', 'strings']","Memory is performing a walk on the two-dimensional plane, starting at the origin. He is given a string *s* with his directions for motion:
-  An 'L' indicates he should move one unit left. -  An 'R' indicates he should move one unit right. -  A 'U' indicates he should move one unit up. -  A 'D' indicates he should move one unit down.
But now Memory wants to end at the origin. To do this, he has a special trident. This trident can replace any character in *s* with any of 'L', 'R', 'U', or 'D'. However, because he doesn't want to wear out the trident, he wants to make the minimum number of edits possible. Please tell Memory what is the minimum number of changes he needs to make to produce a string that, when walked, will end at the origin, or if there is no such string.",The first and only line contains the string *s* (1<=≤<=|*s*|<=≤<=100<=000) — the instructions Memory is given.,"If there is a string satisfying the conditions, output a single integer — the minimum number of edits required. In case it's not possible to change the sequence in such a way that it will bring Memory to to the origin, output -1.","['RRU\n', 'UDUR\n', 'RUUR\n']","['-1\n', '1\n', '2\n']","In the first sample test, Memory is told to walk right, then right, then up. It is easy to see that it is impossible to edit these instructions to form a valid walk.

In the second sample test, Memory is told to walk up, then down, then up, then right. One possible solution is to change *s* to ""LDUR"". This string uses 1 edit, which is the minimum possible. It also ends at the origin.",OK,"def main():
    s = input()
    if len(s) % 2 == 1:
        print('-1')
        return

    cnt = {'L':0,'R':0,'U':0,'D':0}
    for c in s:
        cnt[c] += 1
    
    reduce1 = abs(cnt['L'] - cnt['R'])
    reduce2 = abs(cnt['U'] - cnt['D'])
    print((reduce1 + reduce2) // 2)

if __name__ == '__main__':
    main()","def min_edits_to_origin(s):

    count_L = s.count('L')
    count_R = s.count('R')
    count_U = s.count('U')
    count_D = s.count('D')

    net_x = count_R - count_L
    net_y = count_U - count_D

    excess_moves = abs(net_x) + abs(net_y)

    if excess_moves % 2 != 0:
        return -1

    return excess_moves // 2

import sys
input_data = sys.stdin.read().strip().splitlines()

results = []
for instructions in input_data:
    result = min_edits_to_origin(instructions)
    results.append(str(result))

print(""\n"".join(results))"
559,B,Equivalent Strings,PROGRAMMING,"['divide and conquer', 'hashing', 'sortings', 'strings']","Today on a lecture about strings Gerald learned a new definition of string equivalency. Two strings *a* and *b* of equal length are called equivalent in one of the two cases: 
 1.  They are equal. 1.  If we split string *a* into two halves of the same size *a*1 and *a*2, and string *b* into two halves of the same size *b*1 and *b*2, then one of the following is correct:   *a*1 is equivalent to *b*1, and *a*2 is equivalent to *b*2 1.  *a*1 is equivalent to *b*2, and *a*2 is equivalent to *b*1 
As a home task, the teacher gave two strings to his students and asked to determine if they are equivalent.

Gerald has already completed this home task. Now it's your turn!",The first two lines of the input contain two strings given by the teacher. Each of them has the length from 1 to 200<=000 and consists of lowercase English letters. The strings have the same length.,"Print ""YES"" (without the quotes), if these two strings are equivalent, and ""NO"" (without the quotes) otherwise.","['aaba\nabaa\n', 'aabb\nabab\n']","['YES\n', 'NO\n']","In the first sample you should split the first string into strings ""aa"" and ""ba"", the second one — into strings ""ab"" and ""aa"". ""aa"" is equivalent to ""aa""; ""ab"" is equivalent to ""ba"" as ""ab"" = ""a"" + ""b"", ""ba"" = ""b"" + ""a"".

In the second sample the first string can be splitted into strings ""aa"" and ""bb"", that are equivalent only to themselves. That's why string ""aabb"" is equivalent only to itself and to string ""bbaa"".",OK,"memo = {}
def solve(a, b):
    if (a,b) in memo:
        return memo[a,b]
    if len(a)%2 == 1:
        return a == b
    
    half = len(a)//2
    a1, a2 = a[:half], a[half:]
    b1, b2 = b[:half], b[half:]

    memo[a,b] = (solve(a1, b1) and solve(a2, b2)) or  (solve(a1, b2) and solve(a2, b1))
    return memo[a,b]

s1 = input()
s2 = input()    
ans = solve(s1, s2)
print(""YES"" if ans else ""NO"")","def are_equivalent(a, b):

    if a == b:
        return True

    if len(a) % 2 != 0:
        return False

    mid = len(a) // 2

    a1, a2 = a[:mid], a[mid:]
    b1, b2 = b[:mid], b[mid:]

    return (are_equivalent(a1, b1) and are_equivalent(a2, b2)) or \
           (are_equivalent(a1, b2) and are_equivalent(a2, b1))

import sys
input = sys.stdin.read
data = input().strip().split('\n')
a = data[0].strip()
b = data[1].strip()

if are_equivalent(a, b):
    print(""YES"")
else:
    print(""NO"")"
698,A,Vacations,PROGRAMMING,['dp'],"Vasya has *n* days of vacations! So he decided to improve his IT skills and do sport. Vasya knows the following information about each of this *n* days: whether that gym opened and whether a contest was carried out in the Internet on that day. For the *i*-th day there are four options:
 1.  on this day the gym is closed and the contest is not carried out; 1.  on this day the gym is closed and the contest is carried out; 1.  on this day the gym is open and the contest is not carried out; 1.  on this day the gym is open and the contest is carried out. 
On each of days Vasya can either have a rest or write the contest (if it is carried out on this day), or do sport (if the gym is open on this day).

Find the minimum number of days on which Vasya will have a rest (it means, he will not do sport and write the contest at the same time). The only limitation that Vasya has — he does not want to do the same activity on two consecutive days: it means, he will not do sport on two consecutive days, and write the contest on two consecutive days.","The first line contains a positive integer *n* (1<=≤<=*n*<=≤<=100) — the number of days of Vasya's vacations.

The second line contains the sequence of integers *a*1,<=*a*2,<=...,<=*a**n* (0<=≤<=*a**i*<=≤<=3) separated by space, where: 
 -  *a**i* equals 0, if on the *i*-th day of vacations the gym is closed and the contest is not carried out; -  *a**i* equals 1, if on the *i*-th day of vacations the gym is closed, but the contest is carried out; -  *a**i* equals 2, if on the *i*-th day of vacations the gym is open and the contest is not carried out; -  *a**i* equals 3, if on the *i*-th day of vacations the gym is open and the contest is carried out.","Print the minimum possible number of days on which Vasya will have a rest. Remember that Vasya refuses:
 -  to do sport on any two consecutive days, -  to write the contest on any two consecutive days.","['4\n1 3 2 0\n', '7\n1 3 3 2 1 2 3\n', '2\n2 2\n']","['2\n', '0\n', '1\n']","In the first test Vasya can write the contest on the day number 1 and do sport on the day number 3. Thus, he will have a rest for only 2 days.

In the second test Vasya should write contests on days number 1, 3, 5 and 7, in other days do sport. Thus, he will not have a rest for a single day.

In the third test Vasya can do sport either on a day number 1 or number 2. He can not do sport in two days, because it will be contrary to the his limitation. Thus, he will have a rest for only one day.",WRONG_ANSWER,"def find_ans(arr,char_arr,ind):
    count_of_R = 0
    while ind<len(arr):
        if arr[ind]==0:
            char_arr[ind] = 'R'
            count_of_R+=1
        elif arr[ind]==2:
            if char_arr[ind-1]!='G':
                char_arr[ind] = 'G'
            else:
                char_arr[ind] = 'R'
                count_of_R+=1
        elif arr[ind]==1:
            if char_arr[ind-1]!='C':
                char_arr[ind] = 'C'
            else:
                char_arr[ind] = 'R'
                count_of_R+=1
        else:
            if char_arr[ind-1]=='R':
                char_arr[ind] = 'G'
                val1 = find_ans(arr,char_arr,ind+1)
                char_arr[ind] = 'C'
                val2 = find_ans(arr,char_arr,ind+1)
                if val1<=val2:
                    return count_of_R + val1
                else:
                    return count_of_R + val2
            else:
                if char_arr[ind-1]=='G':
                    char_arr[ind] = 'C'
                else:
                    char_arr[ind] = 'G'
        ind+=1
    return count_of_R

n = int(input())
l1 = [int(x) for x in input().split()]
l2 = [0]
for i in l1:
    l2.append(i)

out = ['' for i in range(0,n+1)]
ans = find_ans(l2,out,1)
print(ans)","def min_rest_days(n, activities):
    rest_days = 0
    last_activity = -1

    for i in range(n):
        activity = activities[i]

        if activity == 0:
            rest_days += 1
            last_activity = 0
        elif activity == 1:
            if last_activity != 1:
                last_activity = 1
            else:
                rest_days += 1
                last_activity = 1
        elif activity == 2:
            if last_activity != 2:
                last_activity = 2
            else:
                rest_days += 1
                last_activity = 2
        elif activity == 3:
            if last_activity == 1:
                rest_days += 1
                last_activity = 2
            else:
                last_activity = 1

    return rest_days

demo_inputs = [
    '4\n1 3 2 0\n',
    '7\n1 3 3 2 1 2 3\n',
    '2\n2 2\n'
]

results = []
for demo in demo_inputs:
    n, activities = demo.split('\n')[:-1]
    n = int(n)
    activities = list(map(int, activities.split()))
    results.append(min_rest_days(n, activities))

for result in results:
    print(result)"
600,E,Lomsat gelral,PROGRAMMING,"['data structures', 'dfs and similar', 'dsu', 'trees']","You are given a rooted tree with root in vertex 1. Each vertex is coloured in some colour.

Let's call colour *c* dominating in the subtree of vertex *v* if there are no other colours that appear in the subtree of vertex *v* more times than colour *c*. So it's possible that two or more colours will be dominating in the subtree of some vertex.

The subtree of vertex *v* is the vertex *v* and all other vertices that contains vertex *v* in each path to the root.

For each vertex *v* find the sum of all dominating colours in the subtree of vertex *v*.","The first line contains integer *n* (1<=≤<=*n*<=≤<=105) — the number of vertices in the tree.

The second line contains *n* integers *c**i* (1<=≤<=*c**i*<=≤<=*n*), *c**i* — the colour of the *i*-th vertex.

Each of the next *n*<=-<=1 lines contains two integers *x**j*,<=*y**j* (1<=≤<=*x**j*,<=*y**j*<=≤<=*n*) — the edge of the tree. The first vertex is the root of the tree.",Print *n* integers — the sums of dominating colours for each vertex.,"['4\n1 2 3 4\n1 2\n2 3\n2 4\n', '15\n1 2 3 1 2 3 3 1 1 3 2 2 1 2 3\n1 2\n1 3\n1 4\n1 14\n1 15\n2 5\n2 6\n2 7\n3 8\n3 9\n3 10\n4 11\n4 12\n4 13\n']","['10 9 3 4\n', '6 5 4 3 2 3 3 1 1 3 2 2 1 2 3\n']",none,WRONG_ANSWER,"from collections import defaultdict
vertex_num=int(input())
colors=list(map(int,input().split()))
treeMap=defaultdict(list)
def dfs(node,colorCount:dict):
    colorCount[colors[node-1]]=colorCount.get(colors[node-1],0)+1
    sum=0
    maxColor=0
    for child in treeMap[node]:
        dfs(child,colorCount)
    for color in colorCount:
        if colorCount[color]>colorCount.get(maxColor,0):
            sum=color
            maxColor=color
        elif colorCount[color]==colorCount.get(maxColor,0):
            sum+=color
    return sum
for x in range(vertex_num-1):
    node,child=list(map(int,input().split()))
    treeMap[node].append(child)
res=[]
for i in range(vertex_num):
    c={}
    res.append(dfs(i+1,c))
print("" "".join(list(map(str,res))))","def dfs(v, tree, colors, count, result):

    color = colors[v - 1]
    count[color] += 1

    max_count = max(count)

    sum_dominating = sum(color for color, c in enumerate(count) if c == max_count)
    result[v - 1] = sum_dominating

    for child in tree[v]:
        dfs(child, tree, colors, count, result)

    count[color] -= 1

def main():
    import sys
    from collections import defaultdict
    
    input = sys.stdin.read
    data = input().splitlines()
    
    n = int(data[0])
    colors = list(map(int, data[1].split()))

    tree = defaultdict(list)
    
    for i in range(2, n + 1):
        x, y = map(int, data[i].split())
        tree[x].append(y)
        tree[y].append(x)
    
    result = [0] * n
    color_count = [0] * (n + 1)

    dfs(1, tree, colors, color_count, result)

    print(' '.join(map(str, result)))

if __name__ == ""__main__"":
    main()"
808,C,Tea Party,PROGRAMMING,"['constructive algorithms', 'greedy', 'sortings']","Polycarp invited all his friends to the tea party to celebrate the holiday. He has *n* cups, one for each of his *n* friends, with volumes *a*1,<=*a*2,<=...,<=*a**n*. His teapot stores *w* milliliters of tea (*w*<=≤<=*a*1<=+<=*a*2<=+<=...<=+<=*a**n*). Polycarp wants to pour tea in cups in such a way that:
 -  Every cup will contain tea for at least half of its volume -  Every cup will contain integer number of milliliters of tea -  All the tea from the teapot will be poured into cups -  All friends will be satisfied. 
Friend with cup *i* won't be satisfied, if there exists such cup *j* that cup *i* contains less tea than cup *j* but *a**i*<=&gt;<=*a**j*.

For each cup output how many milliliters of tea should be poured in it. If it's impossible to pour all the tea and satisfy all conditions then output -1.","The first line contains two integer numbers *n* and *w* (1<=≤<=*n*<=≤<=100, ).

The second line contains *n* numbers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=100).","Output how many milliliters of tea every cup should contain. If there are multiple answers, print any of them.

If it's impossible to pour all the tea and satisfy all conditions then output -1.","['2 10\n8 7\n', '4 4\n1 1 1 1\n', '3 10\n9 8 10\n']","['6 4 \n', '1 1 1 1 \n', '-1\n']","In the third example you should pour to the first cup at least 5 milliliters, to the second one at least 4, to the third one at least 5. It sums up to 14, which is greater than 10 milliliters available.",OK,"n, w = (int(i) for i in input().split())
mas = [int(i) for i in input().split()]
 
def qer():
    global w
    for i, size in enumerate(mas):
        q = round(size / 2 + 0.1)
        rer[size,i] = q
        w -= q
        if w < 0:
            return {1:-1}
 
    for size,i in sorted(rer, reverse = True):
        o = size - rer[size,i]
        rer[size,i] += min(w,o)
        w -= min(o,w)
        if w == 0:
            break
    return rer
 
 
 
 
 
 
rer = {}
print(*qer().values())","def tea_party(n, w, volumes):

    min_required = [((ai + 1) // 2) for ai in volumes]
    total_min_required = sum(min_required)

    if total_min_required > w:
        return -1

    tea_distribution = min_required[:]
    remaining_tea = w - total_min_required

    for i in range(n):

        max_possible = volumes[i]

        additional_tea = min(remaining_tea, max_possible - tea_distribution[i])

        tea_distribution[i] += additional_tea
        remaining_tea -= additional_tea

        if remaining_tea == 0:
            break

    return tea_distribution

input_data = input().splitlines()
n, w = map(int, input_data[0].split())
volumes = list(map(int, input_data[1].split()))

result = tea_party(n, w, volumes)

if result == -1:
    print(-1)
else:
    print(' '.join(map(str, result)))"
815,A,Karen and Game,PROGRAMMING,"['brute force', 'greedy', 'implementation']","On the way to school, Karen became fixated on the puzzle game on her phone!

The game is played as follows. In each level, you have a grid with *n* rows and *m* columns. Each cell originally contains the number 0.

One move consists of choosing one row or column, and adding 1 to all of the cells in that row or column.

To win the level, after all the moves, the number in the cell at the *i*-th row and *j*-th column should be equal to *g**i*,<=*j*.

Karen is stuck on one level, and wants to know a way to beat this level using the minimum number of moves. Please, help her with this task!","The first line of input contains two integers, *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=100), the number of rows and the number of columns in the grid, respectively.

The next *n* lines each contain *m* integers. In particular, the *j*-th integer in the *i*-th of these rows contains *g**i*,<=*j* (0<=≤<=*g**i*,<=*j*<=≤<=500).","If there is an error and it is actually not possible to beat the level, output a single integer -1.

Otherwise, on the first line, output a single integer *k*, the minimum number of moves necessary to beat the level.

The next *k* lines should each contain one of the following, describing the moves in the order they must be done:
 -  row *x*, (1<=≤<=*x*<=≤<=*n*) describing a move of the form ""choose the *x*-th row"". -  col *x*, (1<=≤<=*x*<=≤<=*m*) describing a move of the form ""choose the *x*-th column"". 
If there are multiple optimal solutions, output any one of them.","['3 5\n2 2 2 3 2\n0 0 0 1 0\n1 1 1 2 1\n', '3 3\n0 0 0\n0 1 0\n0 0 0\n', '3 3\n1 1 1\n1 1 1\n1 1 1\n']","['4\nrow 1\nrow 1\ncol 4\nrow 3\n', '-1\n', '3\nrow 1\nrow 2\nrow 3\n']","In the first test case, Karen has a grid with 3 rows and 5 columns. She can perform the following 4 moves to beat the level:

In the second test case, Karen has a grid with 3 rows and 3 columns. It is clear that it is impossible to beat the level; performing any move will create three 1s on the grid, but it is required to only have one 1 in the center.

In the third test case, Karen has a grid with 3 rows and 3 columns. She can perform the following 3 moves to beat the level:

Note that this is not the only solution; another solution, among others, is col 1, col 2, col 3.",RUNTIME_ERROR,"def burenka(a, b, c, d):
  """"""
  Returns the minimum number of claps Burenka needs to make her fractions equal.

  Args:
    a: The numerator of the first fraction.
    b: The denominator of the first fraction.
    c: The numerator of the second fraction.
    d: The denominator of the second fraction.

  Returns:
    The minimum number of claps.
  """"""

  if a / b == c / d:
    return 0

  gcd = math.gcd(b, d)

  a = a // gcd
  b = b // gcd
  c = c // gcd
  d = d // gcd

  num_claps = abs(a - c) // b

  if b != d:
    num_claps += 1

  return num_claps

if __name__ == ""__main__"":
  t = int(input())
  for _ in range(t):
    a, b, c, d = map(int, input().split())
    print(burenka(a, b, c, d))","def minimum_moves_to_beat_game(n, m, grid):

    moves = []

    row_add = [0] * n
    col_add = [0] * m

    for i in range(n):
        for j in range(m):
            if grid[i][j] > 0:
                row_add[i] = max(row_add[i], grid[i][j])
    
    for j in range(m):
        for i in range(n):
            if grid[i][j] > 0:
                col_add[j] = max(col_add[j], grid[i][j])

    for i in range(n):
        while row_add[i] > 0:
            moves.append(f""row {i + 1}"")
            row_add[i] -= 1
    
    for j in range(m):
        while col_add[j] > 0:
            moves.append(f""col {j + 1}"")
            col_add[j] -= 1

    final_grid = [[0] * m for _ in range(n)]
    
    for i in range(n):
        for j in range(m):
            final_grid[i][j] = row_add[i] + col_add[j]
            if final_grid[i][j] != grid[i][j]:
                return [-1]

    return [len(moves)] + moves

import sys
input = sys.stdin.read

data = input().strip().split(""\n"")
n, m = map(int, data[0].split())
grid = [list(map(int, data[i + 1].split())) for i in range(n)]

result = minimum_moves_to_beat_game(n, m, grid)

for line in result:
    print(line)"
111,B,Petya and Divisors,PROGRAMMING,"['binary search', 'data structures', 'number theory']","Little Petya loves looking for numbers' divisors. One day Petya came across the following problem:

You are given *n* queries in the form ""*x**i* *y**i*"". For each query Petya should count how many divisors of number *x**i* divide none of the numbers *x**i*<=-<=*y**i*,<=*x**i*<=-<=*y**i*<=+<=1,<=...,<=*x**i*<=-<=1. Help him.","The first line contains an integer *n* (1<=≤<=*n*<=≤<=105). Each of the following *n* lines contain two space-separated integers *x**i* and *y**i* (1<=≤<=*x**i*<=≤<=105, 0<=≤<=*y**i*<=≤<=*i*<=-<=1, where *i* is the query's ordinal number; the numeration starts with 1). 

If *y**i*<==<=0 for the query, then the answer to the query will be the number of divisors of the number *x**i*. In this case you do not need to take the previous numbers *x* into consideration.",For each query print the answer on a single line: the number of positive integers *k* such that ,['6\n4 0\n3 1\n5 2\n6 2\n18 4\n10000 3\n'],['3\n1\n1\n2\n2\n22\n'],"Let's write out the divisors that give answers for the first 5 queries:

1) 1, 2, 4 

2) 3

3) 5

4) 2, 6

5) 9, 18",OK,"def R(): return map(int, input().split())
def I(): return int(input())
def S(): return str(input())

def L(): return list(R())

from collections import Counter 

import math
import sys

from itertools import permutations

import bisect

div=[[] for i in range(10**5+1)]

for i in range(1,10**5+1):
    for j in range(1,10**5//i+1):
        div[i*j].append(i)

n=I()
last=[-1]*(10**5+1)

for j in range(n):
    x,y=R()
    ans=0
    for i in div[x]:
        if last[i]<j-y:
            ans+=1

        last[i]=j

    print(ans)","def count_divisors(n):
    """"""Count the divisors of a given number n.""""""
    divisors = []
    for i in range(1, int(n**0.5) + 1):
        if n % i == 0:
            divisors.append(i)
            if i != n // i:
                divisors.append(n // i)
    return divisors

def process_queries(queries):
    """"""Process each query and return results based on the criteria.""""""
    results = []
    previous_x = []
    for x, y in queries:
        if y < 0:

            results.append(len(count_divisors(x)))
        else:

            divisors = count_divisors(x)
            invalid_divisors = set()
            for px in previous_x:
                if px <= y:
                    invalid_divisors.update(count_divisors(px))
            count_valid = sum(1 for d in divisors if d not in invalid_divisors)
            results.append(count_valid)
        
        previous_x.append(x)
    return results

def main():
    """"""Main function to read input and output the results.""""""
    import sys
    input = sys.stdin.read
    data = input().strip().split('\n')
    
    n = int(data[0])
    queries = [tuple(map(int, line.split())) for line in data[1:n + 1]]
    
    results = process_queries(queries)
    print('\n'.join(map(str, results)))

if __name__ == ""__main__"":
    main()"
191,A,Dynasty Puzzles,PROGRAMMING,['dp'],"The ancient Berlanders believed that the longer the name, the more important its bearer is. Thus, Berland kings were famous for their long names. But long names are somewhat inconvenient, so the Berlanders started to abbreviate the names of their kings. They called every king by the first letters of its name. Thus, the king, whose name was Victorious Vasily Pupkin, was always called by the berlanders VVP.

In Berland over its long history many dynasties of kings replaced each other, but they were all united by common traditions. Thus, according to one Berland traditions, to maintain stability in the country, the first name of the heir should be the same as the last name his predecessor (hence, the first letter of the abbreviated name of the heir coincides with the last letter of the abbreviated name of the predecessor). Berlanders appreciate stability, so this tradition has never been broken. Also Berlanders like perfection, so another tradition requires that the first name of the first king in the dynasty coincides with the last name of the last king in this dynasty (hence, the first letter of the abbreviated name of the first king coincides with the last letter of the abbreviated name of the last king). This tradition, of course, has also been always observed.

The name of a dynasty is formed by very simple rules: we take all the short names of the kings in the order in which they ruled, and write them in one line. Thus, a dynasty of kings ""ab"" and ""ba"" is called ""abba"", and the dynasty, which had only the king ""abca"", is called ""abca"".

Vasya, a historian, has recently found a list of abbreviated names of all Berland kings and their relatives. Help Vasya to find the maximally long name of the dynasty that could have existed in Berland.

Note that in his list all the names are ordered by the time, that is, if name *A* is earlier in the list than *B*, then if *A* and *B* were kings, then king *A* ruled before king *B*.","The first line contains integer *n* (1<=≤<=*n*<=≤<=5·105) — the number of names in Vasya's list. Next *n* lines contain *n* abbreviated names, one per line. An abbreviated name is a non-empty sequence of lowercase Latin letters. Its length does not exceed 10 characters.","Print a single number — length of the sought dynasty's name in letters.

If Vasya's list is wrong and no dynasty can be found there, print a single number 0.","['3\nabc\nca\ncba\n', '4\nvvp\nvvp\ndam\nvvp\n', '3\nab\nc\ndef\n']","['6\n', '0\n', '1\n']","In the first sample two dynasties can exist: the one called ""abcca"" (with the first and second kings) and the one called ""abccba"" (with the first and third kings). 

In the second sample there aren't acceptable dynasties.

The only dynasty in the third sample consists of one king, his name is ""c"".",TIME_LIMIT_EXCEEDED,"from collections import defaultdict, Counter
import sys

M = int(1e9 + 7)
inf = float('inf')

def I():
    return input()

def II():
    return int(I())

def LI():
    return list(I().split())

def LII():
    return list(map(int, LI()))

def rank(arr, lo, hi, target):
    while lo <= hi:
        mi = (lo + hi) >> 1
        if arr[mi] < target:
            lo = mi + 1
        else:
            hi = mi - 1
    return lo

def get_idx(ch):
    return ord(ch) - ord('a')

def solve():
    n = II()
    dp = [[-inf] * 26 for _ in range(26)]
    ans = 0

    for _ in range(n):
        s = I()
        m = len(s)

        begin, end = get_idx(s[0]), get_idx(s[-1])
        for i in range(26):
            dp[i][end] = max(dp[i][end], dp[i][begin] + m)
        dp[begin][end] = max(dp[begin][end], m)
        ans = max(ans, dp[end][end])

    print(ans)
solve()","def find_max_dynasty_length(n, names):

    max_lengths = [0] * n

    for i in range(n):

        max_lengths[i] = 1

        for j in range(i):

            if names[j][-1] == names[i][0]:
                max_lengths[i] = max(max_lengths[i], max_lengths[j] + 1)

    return max(max_lengths)

n = int(input().strip())
names = [input().strip() for _ in range(n)]

result = find_max_dynasty_length(n, names)

print(result)"
342,A,Xenia and Divisors,PROGRAMMING,"['greedy', 'implementation']","Xenia the mathematician has a sequence consisting of *n* (*n* is divisible by 3) positive integers, each of them is at most 7. She wants to split the sequence into groups of three so that for each group of three *a*,<=*b*,<=*c* the following conditions held:
 -  *a*<=&lt;<=*b*<=&lt;<=*c*; -  *a* divides *b*, *b* divides *c*. 
Naturally, Xenia wants each element of the sequence to belong to exactly one group of three. Thus, if the required partition exists, then it has  groups of three.

Help Xenia, find the required partition or else say that it doesn't exist.","The first line contains integer *n* (3<=≤<=*n*<=≤<=99999) — the number of elements in the sequence. The next line contains *n* positive integers, each of them is at most 7.

It is guaranteed that *n* is divisible by 3.","If the required partition exists, print  groups of three. Print each group as values of the elements it contains. You should print values in increasing order. Separate the groups and integers in groups by whitespaces. If there are multiple solutions, you can print any of them.

If there is no solution, print -1.","['6\n1 1 1 2 2 2\n', '6\n2 2 1 1 4 6\n']","['-1\n', '1 2 4\n1 2 6\n']",none,RUNTIME_ERROR,"import sys

def input():    return sys.stdin.readline().strip()
def iinput():   return int(input())
def rinput():   return map(int, sys.stdin.readline().strip().split()) 
def get_list(): return list(map(int, sys.stdin.readline().strip().split())) 

n=iinput()
l=list(map(int,input().split()))
a=sorted(l)
r=[]
k=[]
p=n//3
count=0
if(n%3!=0):
    print(-1)
else:
    visit = [0]*n
    for i in range(0,n):
        for j in range(i+1,n):
            for k in range(j+1,n):
                if(a[i]<a[j] and a[j]<a[k] and a[j]%a[i]==0 and a[k]%a[j]==0 and visit[i]==0 and visit[j]==0 and visit[k]==0):
                    s=[a[i],a[j],a[k]]
                    visit[i]=1
                    visit[j]=1
                    visit[k]=1

                    r.append(s)

    if(len(r)==p):
        for i in range(r):
            print(*r[i])
    else:
        print(-1)","def can_divide(a, b, c):
    return a <= b <= c and b % a == 0 and c % b == 0

def find_partition(n, sequence):

    counts = [0] * 8
    for num in sequence:
        counts[num] += 1

    result = []

    while counts[1] > 0 and counts[2] > 0 and counts[4] > 0:
        result.append((1, 2, 4))
        counts[1] -= 1
        counts[2] -= 1
        counts[4] -= 1

    while counts[1] > 0 and counts[2] > 0 and counts[6] > 0:
        result.append((1, 2, 6))
        counts[1] -= 1
        counts[2] -= 1
        counts[6] -= 1

    while counts[1] > 0 and counts[3] > 0 and counts[6] > 0:
        result.append((1, 3, 6))
        counts[1] -= 1
        counts[3] -= 1
        counts[6] -= 1

    while counts[2] > 0 and counts[4] > 0 and counts[6] > 0:
        result.append((2, 4, 6))
        counts[2] -= 1
        counts[4] -= 1
        counts[6] -= 1

    if sum(counts) == 0 and len(result) * 3 == n:
        return result
    else:
        return -1

n = int(input())
sequence = list(map(int, input().strip().split()))

partition = find_partition(n, sequence)

if partition == -1:
    print(-1)
else:
    for group in partition:
        print(' '.join(map(str, group)))"
348,A,Mafia,PROGRAMMING,"['binary search', 'math', 'sortings']","One day *n* friends gathered together to play ""Mafia"". During each round of the game some player must be the supervisor and other *n*<=-<=1 people take part in the game. For each person we know in how many rounds he wants to be a player, not the supervisor: the *i*-th person wants to play *a**i* rounds. What is the minimum number of rounds of the ""Mafia"" game they need to play to let each person play at least as many rounds as they want?","The first line contains integer *n* (3<=≤<=*n*<=≤<=105). The second line contains *n* space-separated integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=109) — the *i*-th number in the list is the number of rounds the *i*-th person wants to play.","In a single line print a single integer — the minimum number of game rounds the friends need to let the *i*-th person play at least *a**i* rounds.

Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.","['3\n3 2 2\n', '4\n2 2 2 2\n']","['4\n', '3\n']","You don't need to know the rules of ""Mafia"" to solve this problem. If you're curious, it's a game Russia got from the Soviet times: http://en.wikipedia.org/wiki/Mafia_(party_game).",WRONG_ANSWER,"import math

def marathon(n,b):
    sum = 0
    ll = b.split(' ')
    l = [int(i) for i in ll]
    maxx = max(l)
    for i in l:
        sum = sum + int(i)
    m = max(math.ceil(sum/n)+1, maxx)
    return m

n = int(input())
b = input()

print(marathon(n,b))","def minimum_rounds(n, a):
    total_wants = sum(a)

    rounds_needed = (total_wants + (n - 2)) // (n - 1)
    return max(rounds_needed, max(a))

n = int(input().strip())
a = list(map(int, input().strip().split()))

print(minimum_rounds(n, a))"
152,A,Marks,PROGRAMMING,['implementation'],"Vasya, or Mr. Vasily Petrov is a dean of a department in a local university. After the winter exams he got his hands on a group's gradebook.

Overall the group has *n* students. They received marks for *m* subjects. Each student got a mark from 1 to 9 (inclusive) for each subject.

Let's consider a student the best at some subject, if there is no student who got a higher mark for this subject. Let's consider a student successful, if there exists a subject he is the best at.

Your task is to find the number of successful students in the group.","The first input line contains two integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=100) — the number of students and the number of subjects, correspondingly. Next *n* lines each containing *m* characters describe the gradebook. Each character in the gradebook is a number from 1 to 9. Note that the marks in a rows are not sepatated by spaces.",Print the single number — the number of successful students in the given group.,"['3 3\n223\n232\n112\n', '3 5\n91728\n11828\n11111\n']","['2\n', '3\n']","In the first sample test the student number 1 is the best at subjects 1 and 3, student 2 is the best at subjects 1 and 2, but student 3 isn't the best at any subject.

In the second sample test each student is the best at at least one subject.",OK,"import sys,math
def get_ints(): return map(int, sys.stdin.readline().strip().split())
def get_list(): return list(map(int, sys.stdin.readline().strip().split()))
def get_string(): return sys.stdin.readline().strip()
n,m = get_ints()
ar = [0]*n
L = []
for i in range(n):
    s = get_string()
    L.append(s)
for j in range(m):
    mx = 0
    for i in range(n):
        mx = max(mx,eval(L[i][j]))
    for i in range(n):
        if mx==eval(L[i][j]):
            ar[i]=1
print(sum(ar))","n, m = map(int, input().split())
gradebook = [input().strip() for _ in range(n)]

successful_students = set()

for subject_index in range(m):
    max_grade = '0'

    for student_index in range(n):
        if gradebook[student_index][subject_index] > max_grade:
            max_grade = gradebook[student_index][subject_index]

    for student_index in range(n):
        if gradebook[student_index][subject_index] == max_grade:
            successful_students.add(student_index)

print(len(successful_students))"
599,A,Patrick and Shopping,PROGRAMMING,['implementation'],"Today Patrick waits for a visit from his friend Spongebob. To prepare for the visit, Patrick needs to buy some goodies in two stores located near his house. There is a *d*1 meter long road between his house and the first shop and a *d*2 meter long road between his house and the second shop. Also, there is a road of length *d*3 directly connecting these two shops to each other. Help Patrick calculate the minimum distance that he needs to walk in order to go to both shops and return to his house.

Patrick always starts at his house. He should visit both shops moving only along the three existing roads and return back to his house. He doesn't mind visiting the same shop or passing the same road multiple times. The only goal is to minimize the total distance traveled.","The first line of the input contains three integers *d*1, *d*2, *d*3 (1<=≤<=*d*1,<=*d*2,<=*d*3<=≤<=108) — the lengths of the paths. 
 -  *d*1 is the length of the path connecting Patrick's house and the first shop; -  *d*2 is the length of the path connecting Patrick's house and the second shop; -  *d*3 is the length of the path connecting both shops.",Print the minimum distance that Patrick will have to walk in order to visit both shops and return to his house.,"['10 20 30\n', '1 1 5\n']","['60\n', '4\n']","The first sample is shown on the picture in the problem statement. One of the optimal routes is: house <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> first shop <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> second shop <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> house.

In the second sample one of the optimal routes is: house <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> first shop <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> house <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> second shop <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> house.",OK,"def good(a,b,c):
    return min(a,b+c)+min(c,a+b)+min(b,a+c)
a,b,c=map(int,input().split())
print(good(a, b, c))","def minimum_distance(d1, d2, d3):

    return min(
        2 * (d1 + d2),
        2 * d1 + 2 * d3,
        2 * d2 + 2 * d3,
        2 * (d1 + d3),
        2 * (d2 + d3)
    )

input_data = input().strip().split()
d1, d2, d3 = map(int, input_data)

print(minimum_distance(d1, d2, d3))"
281,A,Word Capitalization,PROGRAMMING,"['implementation', 'strings']","Capitalization is writing a word with its first letter as a capital letter. Your task is to capitalize the given word.

Note, that during capitalization all the letters except the first one remains unchanged.",A single line contains a non-empty word. This word consists of lowercase and uppercase English letters. The length of the word will not exceed 103.,Output the given word after capitalization.,"['ApPLe\n', 'konjac\n']","['ApPLe\n', 'Konjac\n']",none,OK,"def solve():
    s = input()
    print(s[0].capitalize()+s[1:])

t = 1
while t:
    solve()
    t -= 1","def capitalize_word(word):

    if len(word) > 0:
        return word[0].upper() + word[1:]
    return word

input_words = ['ApPLe\n', 'konjac\n']

output_words = [capitalize_word(word.strip()) for word in input_words]

for word in output_words:
    print(word)"
448,C,Painting Fence,PROGRAMMING,"['divide and conquer', 'dp', 'greedy']","Bizon the Champion isn't just attentive, he also is very hardworking.

Bizon the Champion decided to paint his old fence his favorite color, orange. The fence is represented as *n* vertical planks, put in a row. Adjacent planks have no gap between them. The planks are numbered from the left to the right starting from one, the *i*-th plank has the width of 1 meter and the height of *a**i* meters.

Bizon the Champion bought a brush in the shop, the brush's width is 1 meter. He can make vertical and horizontal strokes with the brush. During a stroke the brush's full surface must touch the fence at all the time (see the samples for the better understanding). What minimum number of strokes should Bizon the Champion do to fully paint the fence? Note that you are allowed to paint the same area of the fence multiple times.","The first line contains integer *n* (1<=≤<=*n*<=≤<=5000) — the number of fence planks. The second line contains *n* space-separated integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=109).",Print a single integer — the minimum number of strokes needed to paint the whole fence.,"['5\n2 2 1 2 1\n', '2\n2 2\n', '1\n5\n']","['3\n', '2\n', '1\n']","In the first sample you need to paint the fence in three strokes with the brush: the first stroke goes on height 1 horizontally along all the planks. The second stroke goes on height 2 horizontally and paints the first and second planks and the third stroke (it can be horizontal and vertical) finishes painting the fourth plank.

In the second sample you can paint the fence with two strokes, either two horizontal or two vertical strokes.

In the third sample there is only one plank that can be painted using a single vertical stroke.",TIME_LIMIT_EXCEEDED,"def solve(i, j, a):
    vans = j - i + 1
    mini = a[i]
    
    for k in range(i+1, j+1):
        if mini > a[k]:
            mini = a[k]
    
    for k in range(i, j+1):
        a[k] -= mini

    hans = mini

    k = i
    while k <= j:
        if a[k] == 0:
            k += 1
        else:
            s = k
            t = s
            while t <= j and a[t] != 0:
                t += 1
            hans += solve(s, t - 1, a)
            k = t

    return vans if vans < hans else hans

def main():
    n = int(input())
    a = [0] + list(map(int, input().split()))
    
    ans = solve(1, n, a)

    print(ans)

if __name__ == ""__main__"":
    main()","def min_strokes_to_paint_fence(n, heights):

    if n == 1:
        return 1

    strokes = 0

    while any(heights):
        strokes += 1

        min_height = min(heights)

        for i in range(n):
            heights[i] -= min_height
            
    return strokes

n = int(input().strip())
heights = list(map(int, input().strip().split()))

print(min_strokes_to_paint_fence(n, heights))"
420,A,Start Up,PROGRAMMING,['implementation'],"Recently, a start up by two students of a state university of city F gained incredible popularity. Now it's time to start a new company. But what do we call it?

The market analysts came up with a very smart plan: the name of the company should be identical to its reflection in a mirror! In other words, if we write out the name of the company on a piece of paper in a line (horizontally, from left to right) with large English letters, then put this piece of paper in front of the mirror, then the reflection of the name in the mirror should perfectly match the line written on the piece of paper.

There are many suggestions for the company name, so coming up to the mirror with a piece of paper for each name wouldn't be sensible. The founders of the company decided to automatize this process. They asked you to write a program that can, given a word, determine whether the word is a 'mirror' word or not.",The first line contains a non-empty name that needs to be checked. The name contains at most 105 large English letters. The name will be written with the next sans serif font:,"Print 'YES' (without the quotes), if the given name matches its mirror reflection. Otherwise, print 'NO' (without the quotes).","['AHA\n', 'Z\n', 'XO\n']","['YES\n', 'NO\n', 'NO\n']",none,OK,"import sys

def check(text):
    legal = 'AHIMOTUVWXY'
    for i in text:
        if i not in legal:
            return False
    rev = list(text)
    rev.reverse()
    if text != ''.join(rev):
        return False
    return True

if __name__ == '__main__':
    text = sys.stdin.readline().split()[0]
    if check(text):
        print('YES')
    else:
        print('NO')","def is_mirror_word(name):

    mirror_chars = {'A', 'H', 'I', 'M', 'O', 'T', 'U', 'V', 'W', 'X', 'Y'}

    for char in name:
        if char not in mirror_chars:
            return ""NO""

    if name == name[::-1]:
        return ""YES""
    else:
        return ""NO""

input_names = ['AHA', 'Z', 'XO']
results = []

for name in input_names:
    result = is_mirror_word(name.strip())
    results.append(result)

for res in results:
    print(res)"
327,A,Flipping Game,PROGRAMMING,"['brute force', 'dp', 'implementation']","Iahub got bored, so he invented a game to be played on paper. 

He writes *n* integers *a*1,<=*a*2,<=...,<=*a**n*. Each of those integers can be either 0 or 1. He's allowed to do exactly one move: he chooses two indices *i* and *j* (1<=≤<=*i*<=≤<=*j*<=≤<=*n*) and flips all values *a**k* for which their positions are in range [*i*,<=*j*] (that is *i*<=≤<=*k*<=≤<=*j*). Flip the value of *x* means to apply operation *x*<==<=1 - *x*.

The goal of the game is that after exactly one move to obtain the maximum number of ones. Write a program to solve the little game of Iahub.","The first line of the input contains an integer *n* (1<=≤<=*n*<=≤<=100). In the second line of the input there are *n* integers: *a*1,<=*a*2,<=...,<=*a**n*. It is guaranteed that each of those *n* values is either 0 or 1.",Print an integer — the maximal number of 1s that can be obtained after exactly one move.,"['5\n1 0 0 1 0\n', '4\n1 0 0 1\n']","['4\n', '4\n']","In the first case, flip the segment from 2 to 5 (*i* = 2, *j* = 5). That flip changes the sequence, it becomes: [1 1 1 0 1]. So, it contains four ones. There is no way to make the whole sequence equal to [1 1 1 1 1].

In the second case, flipping only the second and the third element (*i* = 2, *j* = 3) will turn all numbers into 1.",OK,"n=eval(input())
a=[int(i) for i in input().split()]
ans=0
def f(i,j):
    for k in range(i,j):
        a[k]=1-a[k]
for i in range(n):
    for j in range(i+1,n+1):
        f(i,j)
        res=sum(a)
        if res>ans:
            ans=res
        f(i,j)
print(ans)","def max_ones_after_flip(n, arr):

    initial_ones = sum(arr)

    max_ones = 0

    for i in range(n):
        for j in range(i, n):

            count_ones_in_segment = sum(arr[i:j + 1])
            count_zeros_in_segment = (j - i + 1) - count_ones_in_segment

            new_ones_count = initial_ones - count_ones_in_segment + count_zeros_in_segment

            max_ones = max(max_ones, new_ones_count)

    return max_ones

n = int(input().strip())
arr = list(map(int, input().strip().split()))

print(max_ones_after_flip(n, arr))"
1006,D,Two Strings Swaps,PROGRAMMING,['implementation'],"You are given two strings $a$ and $b$ consisting of lowercase English letters, both of length $n$. The characters of both strings have indices from $1$ to $n$, inclusive. 

You are allowed to do the following changes: 
 -  Choose any index $i$ ($1 \le i \le n$) and swap characters $a_i$ and $b_i$; -  Choose any index $i$ ($1 \le i \le n$) and swap characters $a_i$ and $a_{n - i + 1}$; -  Choose any index $i$ ($1 \le i \le n$) and swap characters $b_i$ and $b_{n - i + 1}$. 
Note that if $n$ is odd, you are formally allowed to swap $a_{\lceil\frac{n}{2}\rceil}$ with $a_{\lceil\frac{n}{2}\rceil}$ (and the same with the string $b$) but this move is useless. Also you can swap two equal characters but this operation is useless as well.

You have to make these strings equal by applying any number of changes described above, in any order. But it is obvious that it may be impossible to make two strings equal by these swaps.

In one preprocess move you can replace a character in $a$ with another character. In other words, in a single preprocess move you can choose any index $i$ ($1 \le i \le n$), any character $c$ and set $a_i := c$.

Your task is to find the minimum number of preprocess moves to apply in such a way that after them you can make strings $a$ and $b$ equal by applying some number of changes described in the list above.

Note that the number of changes you make after the preprocess moves does not matter. Also note that you cannot apply preprocess moves to the string $b$ or make any preprocess moves after the first change is made.","The first line of the input contains one integer $n$ ($1 \le n \le 10^5$) — the length of strings $a$ and $b$.

The second line contains the string $a$ consisting of exactly $n$ lowercase English letters.

The third line contains the string $b$ consisting of exactly $n$ lowercase English letters.","Print a single integer — the minimum number of preprocess moves to apply before changes, so that it is possible to make the string $a$ equal to string $b$ with a sequence of changes from the list above.","['7\nabacaba\nbacabaa\n', '5\nzcabd\ndbacz\n']","['4\n', '0\n']","In the first example preprocess moves are as follows: $a_1 := $'b', $a_3 := $'c', $a_4 := $'a' and $a_5:=$'b'. Afterwards, $a = $""bbcabba"". Then we can obtain equal strings by the following sequence of changes: $swap(a_2, b_2)$ and $swap(a_2, a_6)$. There is no way to use fewer than $4$ preprocess moves before a sequence of changes to make string equal, so the answer in this example is $4$.

In the second example no preprocess moves are required. We can use the following sequence of changes to make $a$ and $b$ equal: $swap(b_1, b_5)$, $swap(a_2, a_4)$.",WRONG_ANSWER,"import sys
input = lambda: sys.stdin.readline().rstrip()
import math
from heapq import heappush , heappop
from collections import defaultdict,deque,Counter
from bisect import *

N = int(input())
S = input()
T = input()

def check(C):
    keys = list(C.keys())
    if len(keys)>2:
        return False
    if len(keys)==1:
        return True
    if C[keys[0]]==C[keys[1]]:
        return True
    return False

def cal(A):
    t = int(A[0]!=A[2]) + int(A[1]!=A[3])
    t = min(t, int(A[0]!=A[3]) + int(A[1]!=A[2]))
    return t
    
ans = 0
for i in range(N//2):
    j = N-i-1

    tmp = [S[i],S[j],T[i],T[j]]
    C = Counter(tmp)
    if check(C):
        continue
        
    ans += cal(tmp)
if N%2:

    if S[N//2]!=T[N//2]:
        ans+=1
    
print(ans)","def min_preprocess_moves(n, a, b):

    freq_a = [0] * 26
    freq_b = [0] * 26

    for char in a:
        freq_a[ord(char) - ord('a')] += 1
    for char in b:
        freq_b[ord(char) - ord('a')] += 1

    total_moves = 0
    for i in range(26):

        if (freq_a[i] + freq_b[i]) % 2 != 0:
            total_moves += 1

    return total_moves // 2

import sys
input = sys.stdin.read
data = input().splitlines()

n = int(data[0])
a = data[1].strip()
b = data[2].strip()

result = min_preprocess_moves(n, a, b)
print(result)"
727,A,Transformation: from A to B,PROGRAMMING,"['brute force', 'dfs and similar', 'math']","Vasily has a number *a*, which he wants to turn into a number *b*. For this purpose, he can do two types of operations:
 -  multiply the current number by 2 (that is, replace the number *x* by 2·*x*); -  append the digit 1 to the right of current number (that is, replace the number *x* by 10·*x*<=+<=1). 
You need to help Vasily to transform the number *a* into the number *b* using only the operations described above, or find that it is impossible.

Note that in this task you are not required to minimize the number of operations. It suffices to find any way to transform *a* into *b*.",The first line contains two positive integers *a* and *b* (1<=≤<=*a*<=&lt;<=*b*<=≤<=109) — the number which Vasily has and the number he wants to have.,"If there is no way to get *b* from *a*, print ""NO"" (without quotes).

Otherwise print three lines. On the first line print ""YES"" (without quotes). The second line should contain single integer *k* — the length of the transformation sequence. On the third line print the sequence of transformations *x*1,<=*x*2,<=...,<=*x**k*, where:
 -  *x*1 should be equal to *a*, -  *x**k* should be equal to *b*, -  *x**i* should be obtained from *x**i*<=-<=1 using any of two described operations (1<=&lt;<=*i*<=≤<=*k*). 
If there are multiple answers, print any of them.","['2 162\n', '4 42\n', '100 40021\n']","['YES\n5\n2 4 8 81 162 \n', 'NO\n', 'YES\n5\n100 200 2001 4002 40021 \n']",none,WRONG_ANSWER,"[a, b] = map(int, input().split())

found = False

def finish(numbers):
    print(""YES"")
    print(' '.join(map(str, numbers)))
    return True

def try_again(numbers):
    n = numbers[-1]
    if n == b:
        return finish(numbers)
    elif n < b:
        return try_op1(numbers) or try_op2(numbers)
    return False

def try_op1(numbers):
    n = 2*numbers[-1]
    if n <= b:
        return try_again(numbers + [n])
    return False

def try_op2(numbers):
    n = 10*numbers[-1]+1
    if n <= b:
        return try_again(numbers + [n])
    return False

if not try_again([a]):
    print(""NO"")","def transform_number(a, b):
    sequence = []

    current = a
    sequence.append(current)

    while current < b:

        if current * 10 + 1 <= b:
            current = current * 10 + 1
        else:

            current *= 2
            
        sequence.append(current)

    if current == b:
        return ""YES\n{}\n{}"".format(len(sequence), ' '.join(map(str, sequence)))
    else:
        return ""NO""

inputs = ['2 162\n', '4 42\n', '100 40021\n']
outputs = []

for input_case in inputs:
    a, b = map(int, input_case.split())
    outputs.append(transform_number(a, b))

for output in outputs:
    print(output)"
88,B,Keyboard,PROGRAMMING,['implementation'],"Vasya learns to type. He has an unusual keyboard at his disposal: it is rectangular and it has *n* rows of keys containing *m* keys in each row. Besides, the keys are of two types. Some of the keys have lowercase Latin letters on them and some of the keys work like the ""Shift"" key on standard keyboards, that is, they make lowercase letters uppercase.

Vasya can press one or two keys with one hand. However, he can only press two keys if the Euclidean distance between the centers of the keys does not exceed *x*. The keys are considered as squares with a side equal to 1. There are no empty spaces between neighbouring keys.

Vasya is a very lazy boy, that's why he tries to type with one hand as he eats chips with his other one. However, it is possible that some symbol can't be typed with one hand only, because the distance between it and the closest ""Shift"" key is strictly larger than *x*. In this case he will have to use his other hand. Having typed the symbol, Vasya returns other hand back to the chips.

You are given Vasya's keyboard and the text. Count the minimum number of times Vasya will have to use the other hand.","The first line contains three integers *n*, *m*, *x* (1<=≤<=*n*,<=*m*<=≤<=30,<=1<=≤<=*x*<=≤<=50).

Next *n* lines contain descriptions of all the keyboard keys. Each line contains the descriptions of exactly *m* keys, without spaces. The letter keys are marked with the corresponding lowercase letters. The ""Shift"" keys are marked with the ""S"" symbol. 

Then follow the length of the text *q* (1<=≤<=*q*<=≤<=5·105). The last line contains the text *T*, which consists of *q* symbols, which are uppercase and lowercase Latin letters.","If Vasya can type the text, then print the minimum number of times he will have to use his other hand. Otherwise, print ""-1"" (without the quotes).","['2 2 1\nab\ncd\n1\nA\n', '2 2 1\nab\ncd\n1\ne\n', '2 2 1\nab\ncS\n5\nabcBA\n', '3 9 4\nqwertyuio\nasdfghjkl\nSzxcvbnmS\n35\nTheQuIcKbRoWnFOXjummsovertHeLazYDOG\n']","['-1\n', '-1\n', '1\n', '2\n']","In the first sample the symbol ""A"" is impossible to print as there's no ""Shift"" key on the keyboard.

In the second sample the symbol ""e"" is impossible to print as there's no such key on the keyboard.

In the fourth sample the symbols ""T"", ""G"" are impossible to print with one hand. The other letters that are on the keyboard can be printed. Those symbols come up in the text twice, thus, the answer is 2.",OK,"import sys
from array import array
from math import hypot
from collections import defaultdict

def input():
    return sys.stdin.buffer.readline().decode('utf-8')

n, m, x = map(int, input().split())
keyboard = [input().rstrip() for _ in range(n)]
keys = set()
inf, eps = 10**9, 1e-9
dist = defaultdict(lambda: inf)
shift = []

for i in range(n):
    for j in range(m):
        if keyboard[i][j] == 'S':
            shift.append((i, j))

for i in range(n):
    for j in range(m):
        if keyboard[i][j] == 'S':
            continue
        keys.add(keyboard[i][j])
        for ti, tj in shift:
            dist[keyboard[i][j].upper()] = min(dist[keyboard[i][j].upper()], hypot(i - ti, j - tj))

q = int(input())
ans = 0
for c in input().rstrip():
    if c.lower() not in keys:
        print(-1)
        exit()
    if 65 <= ord(c) <= 90:
        if not shift:
            print(-1)
            exit()
        if dist[c] - eps > x:
            ans += 1

print(ans)","import math

def count_other_hand_uses(n, m, x, keyboard, q, text):

    key_positions = {}

    for i in range(n):
        for j in range(m):
            key = keyboard[i][j]
            if key not in key_positions:
                key_positions[key] = []
            key_positions[key].append((i, j))

    other_hand_count = 0
    for ch in text:
        if ch.islower():
            if ch not in key_positions:
                return -1
        else:
            lower_char = ch.lower()
            if lower_char not in key_positions:
                return -1
            if 'S' not in key_positions:
                return -1

            can_type_with_one_hand = False
            
            for (key_x, key_y) in key_positions[lower_char]:
                for (shift_x, shift_y) in key_positions['S']:
                    distance = math.sqrt((key_x - shift_x) ** 2 + (key_y - shift_y) ** 2)
                    if distance <= x:
                        can_type_with_one_hand = True
                        break
                if can_type_with_one_hand:
                    break
            
            if not can_type_with_one_hand:
                other_hand_count += 1

    return other_hand_count

def main():

    n, m, x = map(int, input().split())
    keyboard = [input().strip() for _ in range(n)]
    q = int(input().strip())
    text = input().strip()

    result = count_other_hand_uses(n, m, x, keyboard, q, text)

    print(result)

if __name__ == ""__main__"":
    main()"
807,A,Is it rated?,PROGRAMMING,"['implementation', 'sortings']","Is it rated?

Here it is. The Ultimate Question of Competitive Programming, Codeforces, and Everything. And you are here to answer it.

Another Codeforces round has been conducted. No two participants have the same number of points. For each participant, from the top to the bottom of the standings, their rating before and after the round is known.

It's known that if at least one participant's rating has changed, then the round was rated for sure.

It's also known that if the round was rated and a participant with lower rating took a better place in the standings than a participant with higher rating, then at least one round participant's rating has changed.

In this problem, you should not make any other assumptions about the rating system.

Determine if the current round is rated, unrated, or it's impossible to determine whether it is rated of not.","The first line contains a single integer *n* (2<=≤<=*n*<=≤<=1000) — the number of round participants.

Each of the next *n* lines contains two integers *a**i* and *b**i* (1<=≤<=*a**i*,<=*b**i*<=≤<=4126) — the rating of the *i*-th participant before and after the round, respectively. The participants are listed in order from the top to the bottom of the standings.","If the round is rated for sure, print ""rated"". If the round is unrated for sure, print ""unrated"". If it's impossible to determine whether the round is rated or not, print ""maybe"".","['6\n3060 3060\n2194 2194\n2876 2903\n2624 2624\n3007 2991\n2884 2884\n', '4\n1500 1500\n1300 1300\n1200 1200\n1400 1400\n', '5\n3123 3123\n2777 2777\n2246 2246\n2246 2246\n1699 1699\n']","['rated\n', 'unrated\n', 'maybe\n']","In the first example, the ratings of the participants in the third and fifth places have changed, therefore, the round was rated.

In the second example, no one's rating has changed, but the participant in the second place has lower rating than the participant in the fourth place. Therefore, if the round was rated, someone's rating would've changed for sure.

In the third example, no one's rating has changed, and the participants took places in non-increasing order of their rating. Therefore, it's impossible to determine whether the round is rated or not.",WRONG_ANSWER,"if str is bytes:
    from itertools import izip as zip

def is_sorted(l):
    return all(a >= b for a, b in zip(l, l[1:]))

n = int(input())

before = []
i = -1
for _ in range(n):
    tmp = list(map(int, input().split()))
    if tmp[0] != tmp[1]:
        print(""rated"")
        i = 1
    else:
        before.append(tmp[0])
        
ist = is_sorted(before)        
if i == -1 and ist:
    print(""maybe"")
elif i == -1 and not ist:
    print(""unrated"")","def is_rated_round(n, ratings):

    changed = False

    for i in range(n):
        if ratings[i][0] != ratings[i][1]:
            return ""rated""
        if i > 0 and ratings[i][0] > ratings[i-1][0]:
            changed = True

    if changed:
        return ""unrated""
    return ""maybe""

n = int(input().strip())
ratings = [tuple(map(int, input().strip().split())) for _ in range(n)]

result = is_rated_round(n, ratings)
print(result)"
204,A,Little Elephant and Interval,PROGRAMMING,"['binary search', 'combinatorics', 'dp']","The Little Elephant very much loves sums on intervals.

This time he has a pair of integers *l* and *r* (*l*<=≤<=*r*). The Little Elephant has to find the number of such integers *x* (*l*<=≤<=*x*<=≤<=*r*), that the first digit of integer *x* equals the last one (in decimal notation). For example, such numbers as 101, 477474 or 9 will be included in the answer and 47, 253 or 1020 will not.

Help him and count the number of described numbers *x* for a given pair *l* and *r*.","The single line contains a pair of integers *l* and *r* (1<=≤<=*l*<=≤<=*r*<=≤<=1018) — the boundaries of the interval.

Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use cin, cout streams or the %I64d specifier.",On a single line print a single integer — the answer to the problem.,"['2 47\n', '47 1024\n']","['12\n', '98\n']","In the first sample the answer includes integers 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44.",OK,"def f(x):
    if x < 10:
        return x
    if str(x)[0] > str(x)[-1]:
        return x // 10 + 8
    else:
        return x // 10 + 9
l, r = map(int, input().split())
print(f(r) - f(l - 1))","def count_matching_first_last_digit(l, r):
    count = 0

    for x in range(l, r + 1):
        str_x = str(x)

        if str_x[0] == str_x[-1]:
            count += 1
    return count

input_data = input().strip().split()
l = int(input_data[0])
r = int(input_data[1])

result = count_matching_first_last_digit(l, r)

print(result)"
770,A,New Password,PROGRAMMING,"['*special', 'implementation']","Innokentiy decides to change the password in the social net ""Contact!"", but he is too lazy to invent a new password by himself. That is why he needs your help. 

Innokentiy decides that new password should satisfy the following conditions:
 -  the length of the password must be equal to *n*, -  the password should consist only of lowercase Latin letters, -  the number of distinct symbols in the password must be equal to *k*, -  any two consecutive symbols in the password must be distinct. 
Your task is to help Innokentiy and to invent a new password which will satisfy all given conditions.","The first line contains two positive integers *n* and *k* (2<=≤<=*n*<=≤<=100, 2<=≤<=*k*<=≤<=*min*(*n*,<=26)) — the length of the password and the number of distinct symbols in it. 

Pay attention that a desired new password always exists.",Print any password which satisfies all conditions given by Innokentiy.,"['4 3\n', '6 6\n', '5 2\n']","['java\n', 'python\n', 'phphp\n']","In the first test there is one of the appropriate new passwords — java, because its length is equal to 4 and 3 distinct lowercase letters a, j and v are used in it.

In the second test there is one of the appropriate new passwords — python, because its length is equal to 6 and it consists of 6 distinct lowercase letters.

In the third test there is one of the appropriate new passwords — phphp, because its length is equal to 5 and 2 distinct lowercase letters p and h are used in it.

Pay attention the condition that no two identical symbols are consecutive is correct for all appropriate passwords in tests.",OK,"n, k = map(int,input().split())

print(('abcdefghijklmnopqrstuvwxyz' [:k]*n )[:n])","def generate_password(n, k):

    base = ''.join(chr(ord('a') + i) for i in range(k))

    password = []
    for i in range(n):
        password.append(base[i % k])

    return ''.join(password)

input_data = ['4 3\n', '6 6\n', '5 2\n']
output = []

for data in input_data:
    n, k = map(int, data.strip().split())

    password = generate_password(n, k)
    output.append(password)

for pwd in output:
    print(pwd)"
976,A,Minimum Binary Number,PROGRAMMING,['implementation'],"String can be called correct if it consists of characters ""0"" and ""1"" and there are no redundant leading zeroes. Here are some examples: ""0"", ""10"", ""1001"".

You are given a correct string *s*.

You can perform two different operations on this string: 
 1.  swap any pair of adjacent characters (for example, ""101""  ""110""); 1.  replace ""11"" with ""1"" (for example, ""110""  ""10""). 
Let *val*(*s*) be such a number that *s* is its binary representation.

Correct string *a* is less than some other correct string *b* iff *val*(*a*)<=&lt;<=*val*(*b*).

Your task is to find the minimum correct string that you can obtain from the given one using the operations described above. You can use these operations any number of times in any order (or even use no operations at all).","The first line contains integer number *n* (1<=≤<=*n*<=≤<=100) — the length of string *s*.

The second line contains the string *s* consisting of characters ""0"" and ""1"". It is guaranteed that the string *s* is correct.",Print one string — the minimum correct string that you can obtain from the given one.,"['4\n1001\n', '1\n1\n']","['100\n', '1\n']","In the first example you can obtain the answer by the following sequence of operations: ""1001"" <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> ""1010"" <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> ""1100"" <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> ""100"".

In the second example you can't obtain smaller answer no matter what operations you use.",WRONG_ANSWER,"def minBin(s):
    ones = 0
    zeros = 0
    for letter in s:
        if letter == ""1"":
            ones += 1
        else:
            zeros += 1
    if ones == 0:
        return 0
    return ""1""+""0""*zeros

print(minBin(""1001""))

while True:
    try:
        input()
        binary = input()
        print(minBin(binary))
    except EOFError:
        break","def minimum_correct_string(n, s):

    count_0 = s.count('0')
    count_1 = s.count('1')

    if count_1 == 0:
        return '0'

    min_string = '1' + '0' * count_0
    
    return min_string

input_data = ['4\n1001\n', '1\n1\n']
output_data = []

for data in input_data:
    n, s = data.split()
    n = int(n)
    result = minimum_correct_string(n, s.strip())
    output_data.append(result)

for result in output_data:
    print(result)"
143,A,Help Vasilisa the Wise 2,PROGRAMMING,"['brute force', 'math']","Vasilisa the Wise from the Kingdom of Far Far Away got a magic box with a secret as a present from her friend Hellawisa the Wise from the Kingdom of A Little Closer. However, Vasilisa the Wise does not know what the box's secret is, since she cannot open it again. She hopes that you will help her one more time with that.

The box's lock looks as follows: it contains 4 identical deepenings for gems as a 2<=×<=2 square, and some integer numbers are written at the lock's edge near the deepenings. The example of a lock is given on the picture below.

The box is accompanied with 9 gems. Their shapes match the deepenings' shapes and each gem contains one number from 1 to 9 (each number is written on exactly one gem). The box will only open after it is decorated with gems correctly: that is, each deepening in the lock should be filled with exactly one gem. Also, the sums of numbers in the square's rows, columns and two diagonals of the square should match the numbers written at the lock's edge. For example, the above lock will open if we fill the deepenings with gems with numbers as is shown on the picture below.

Now Vasilisa the Wise wants to define, given the numbers on the box's lock, which gems she should put in the deepenings to open the box. Help Vasilisa to solve this challenging task.","The input contains numbers written on the edges of the lock of the box. The first line contains space-separated integers *r*1 and *r*2 that define the required sums of numbers in the rows of the square. The second line contains space-separated integers *c*1 and *c*2 that define the required sums of numbers in the columns of the square. The third line contains space-separated integers *d*1 and *d*2 that define the required sums of numbers on the main and on the side diagonals of the square (1<=≤<=*r*1,<=*r*2,<=*c*1,<=*c*2,<=*d*1,<=*d*2<=≤<=20). Correspondence between the above 6 variables and places where they are written is shown on the picture below. For more clarifications please look at the second sample test that demonstrates the example given in the problem statement.","Print the scheme of decorating the box with stones: two lines containing two space-separated integers from 1 to 9. The numbers should be pairwise different. If there is no solution for the given lock, then print the single number ""-1"" (without the quotes).

If there are several solutions, output any.","['3 7\n4 6\n5 5\n', '11 10\n13 8\n5 16\n', '1 2\n3 4\n5 6\n', '10 10\n10 10\n10 10\n']","['1 2\n3 4\n', '4 7\n9 1\n', '-1\n', '-1\n']","Pay attention to the last test from the statement: it is impossible to open the box because for that Vasilisa the Wise would need 4 identical gems containing number ""5"". However, Vasilisa only has one gem with each number from 1 to 9.",WRONG_ANSWER,"def solution(r,c,d):
    n1=n2=n3=n4=0
    for i in range(1,10):
        n1=i
        n2=r[0]-i
        n3=c[0]-i
        n4=d[0]-i

        if (n2 in range(1,10)) and (n3 in range(1,10)) and (n4 in range(1,10)) and n1!=n2!=n3!=n4:
            if n3+n4==r[1] and n2+n4==c[1] and n2+n3==d[1]:
                print(""{} {}"".format(n1,n2))  
                print(""{} {}"".format(n3,n4))
                return

    print(-1)

r=list(map(int,input('').split()))
c=list(map(int,input('').split()))
d=list(map(int,input('').split()))
solution(r,c,d)","def find_gems(r1, r2, c1, c2, d1, d2):
    for a in range(1, 10):
        for b in range(1, 10):
            for c in range(1, 10):
                for d in range(1, 10):

                    if len({a, b, c, d}) == 4:

                        if a + b == r1 and c + d == r2 and a + c == c1 and b + d == c2:

                            if a + d == d1 and b + c == d2:
                                return f""{a} {b}\n{c} {d}""
    return ""-1""

demo_inputs = [
    ('3 7\n4 6\n5 5\n'),
    ('11 10\n13 8\n5 16\n'),
    ('1 2\n3 4\n5 6\n'),
    ('10 10\n10 10\n10 10\n')
]

outputs = []
for input_data in demo_inputs:
    lines = input_data.strip().split('\n')
    r1, r2 = map(int, lines[0].split())
    c1, c2 = map(int, lines[1].split())
    d1, d2 = map(int, lines[2].split())
    result = find_gems(r1, r2, c1, c2, d1, d2)
    outputs.append(result)

for output in outputs:
    print(output)"
551,A,GukiZ and Contest,PROGRAMMING,"['brute force', 'implementation', 'sortings']","Professor GukiZ likes programming contests. He especially likes to rate his students on the contests he prepares. Now, he has decided to prepare a new contest. 

In total, *n* students will attend, and before the start, every one of them has some positive integer rating. Students are indexed from 1 to *n*. Let's denote the rating of *i*-th student as *a**i*. After the contest ends, every student will end up with some positive integer position. GukiZ expects that his students will take places according to their ratings. 

He thinks that each student will take place equal to . In particular, if student *A* has rating strictly lower then student *B*, *A* will get the strictly better position than *B*, and if two students have equal ratings, they will share the same position. 

GukiZ would like you to reconstruct the results by following his expectations. Help him and determine the position after the end of the contest for each of his students if everything goes as expected.","The first line contains integer *n* (1<=≤<=*n*<=≤<=2000), number of GukiZ's students. 

The second line contains *n* numbers *a*1,<=*a*2,<=... *a**n* (1<=≤<=*a**i*<=≤<=2000) where *a**i* is the rating of *i*-th student (1<=≤<=*i*<=≤<=*n*).","In a single line, print the position after the end of the contest for each of *n* students in the same order as they appear in the input.","['3\n1 3 3\n', '1\n1\n', '5\n3 5 3 4 5\n']","['3 1 1\n', '1\n', '4 1 4 3 1\n']","In the first sample, students 2 and 3 are positioned first (there is no other student with higher rating), and student 1 is positioned third since there are two students with higher rating.

In the second sample, first student is the only one on the contest.

In the third sample, students 2 and 5 share the first position with highest rating, student 4 is next with third position, and students 1 and 3 are the last sharing fourth position.",OK,"from collections import defaultdict
from typing import Counter

n = int(input())
a = [int(x) for x in input().split()]

d = defaultdict(list)

for i in range(n):
    d[a[i]].append(i)

l = sorted(d.items(), key=lambda x: -x[0])

p = 1

ans = [0 for _ in range(n)]

for t in l:
    for idx in t[1]:
        ans[idx] = p
    p += len(t[1])

print(' '.join(map(str, ans)))","def calculate_positions(n, ratings):

    indexed_ratings = list(enumerate(ratings))

    indexed_ratings.sort(key=lambda x: -x[1])
    
    positions = [0] * n
    current_position = 1
    for i in range(n):
        if i > 0 and indexed_ratings[i][1] == indexed_ratings[i - 1][1]:

            positions[indexed_ratings[i][0]] = positions[indexed_ratings[i - 1][0]]
        else:

            positions[indexed_ratings[i][0]] = current_position
        
        current_position += 1
    
    return positions

n = int(input())
ratings = list(map(int, input().split()))

positions = calculate_positions(n, ratings)

print(' '.join(map(str, positions)))"
673,A,Bear and Game,PROGRAMMING,['implementation'],"Bear Limak likes watching sports on TV. He is going to watch a game today. The game lasts 90 minutes and there are no breaks.

Each minute can be either interesting or boring. If 15 consecutive minutes are boring then Limak immediately turns TV off.

You know that there will be *n* interesting minutes *t*1,<=*t*2,<=...,<=*t**n*. Your task is to calculate for how many minutes Limak will watch the game.","The first line of the input contains one integer *n* (1<=≤<=*n*<=≤<=90) — the number of interesting minutes.

The second line contains *n* integers *t*1,<=*t*2,<=...,<=*t**n* (1<=≤<=*t*1<=&lt;<=*t*2<=&lt;<=... *t**n*<=≤<=90), given in the increasing order.",Print the number of minutes Limak will watch the game.,"['3\n7 20 88\n', '9\n16 20 30 40 50 60 70 80 90\n', '9\n15 20 30 40 50 60 70 80 90\n']","['35\n', '15\n', '90\n']","In the first sample, minutes 21, 22, ..., 35 are all boring and thus Limak will turn TV off immediately after the 35-th minute. So, he would watch the game for 35 minutes.

In the second sample, the first 15 minutes are boring.

In the third sample, there are no consecutive 15 boring minutes. So, Limak will watch the whole game.",WRONG_ANSWER,"def countTotalWatchingTime(ar):
    totalMin = 0
    for time in ar:
        if time - totalMin > 15:
            return min(totalMin + 15, 90)
        else:
            totalMin = time
    return min(totalMin, 90)

n = int(input())
ar = list(map(int, input().split()))
print(countTotalWatchingTime(ar))","n = int(input().strip())

interesting_minutes = list(map(int, input().strip().split()))

last_interesting_minute = 0

watched_minutes = 0

for t in interesting_minutes:

    boring_minutes = t - last_interesting_minute - 1

    if boring_minutes >= 15:

        watched_minutes = last_interesting_minute + 15
        print(watched_minutes)
        break

    watched_minutes = t

    last_interesting_minute = t

else:

    watched_minutes = 90

print(watched_minutes)"
576,A,Vasya and Petya's Game,PROGRAMMING,"['math', 'number theory']","Vasya and Petya are playing a simple game. Vasya thought of number *x* between 1 and *n*, and Petya tries to guess the number.

Petya can ask questions like: ""Is the unknown number divisible by number *y*?"".

The game is played by the following rules: first Petya asks all the questions that interest him (also, he can ask no questions), and then Vasya responds to each question with a 'yes' or a 'no'. After receiving all the answers Petya should determine the number that Vasya thought of.

Unfortunately, Petya is not familiar with the number theory. Help him find the minimum number of questions he should ask to make a guaranteed guess of Vasya's number, and the numbers *y**i*, he should ask the questions about.",A single line contains number *n* (1<=≤<=*n*<=≤<=103).,"Print the length of the sequence of questions *k* (0<=≤<=*k*<=≤<=*n*), followed by *k* numbers — the questions *y**i* (1<=≤<=*y**i*<=≤<=*n*).

If there are several correct sequences of questions of the minimum length, you are allowed to print any of them.","['4\n', '6\n']","['3\n2 4 3 \n', '4\n2 4 3 5 \n']","The sequence from the answer to the first sample test is actually correct.

If the unknown number is not divisible by one of the sequence numbers, it is equal to 1.

If the unknown number is divisible by 4, it is 4.

If the unknown number is divisible by 3, then the unknown number is 3.

Otherwise, it is equal to 2. Therefore, the sequence of questions allows you to guess the unknown number. It can be shown that there is no correct sequence of questions of length 2 or shorter.",WRONG_ANSWER,"n=int(input())
a = [i for i in range(2, n+1)]
def calculaDivisiores(num):
  atual = 2
  divs = []
  while atual<=(num//2)+1:
    if num%atual==0:
      divs.append(atual)
    atual+=1
  return divs 

res = []
for num in a:
  divs = calculaDivisiores(num)
  if len(divs)==1:
    res.append(num)
  else:
    res.append(num)
    for div1 in divs:
      for div2 in divs:
        if div1!=div2:
          if div1%div2!=0:
            if num in res:
              res.remove(num)
print(len(res))
for r in res:
  print(r,end=' ')","def minimum_questions(n):

    questions = []

    for i in range(2, n + 1):

        is_prime = True
        for j in range(2, int(i**0.5) + 1):
            if i % j == 0:
                is_prime = False
                break
        if is_prime:

            questions.append(i)

    print(len(questions), ' '.join(map(str, questions)))

inputs = ['4', '6']
for value in inputs:
    n = int(value)
    minimum_questions(n)"
352,B,Jeff and Periods,PROGRAMMING,"['implementation', 'sortings']","One day Jeff got hold of an integer sequence *a*1, *a*2, ..., *a**n* of length *n*. The boy immediately decided to analyze the sequence. For that, he needs to find all values of *x*, for which these conditions hold:
 -  *x* occurs in sequence *a*. -  Consider all positions of numbers *x* in the sequence *a* (such *i*, that *a**i*<==<=*x*). These numbers, sorted in the increasing order, must form an arithmetic progression. 
Help Jeff, find all *x* that meet the problem conditions.","The first line contains integer *n* (1<=≤<=*n*<=≤<=105). The next line contains integers *a*1, *a*2, ..., *a**n* (1<=≤<=*a**i*<=≤<=105). The numbers are separated by spaces.","In the first line print integer *t* — the number of valid *x*. On each of the next *t* lines print two integers *x* and *p**x*, where *x* is current suitable value, *p**x* is the common difference between numbers in the progression (if *x* occurs exactly once in the sequence, *p**x* must equal 0). Print the pairs in the order of increasing *x*.","['1\n2\n', '8\n1 2 1 3 1 2 1 5\n']","['1\n2 0\n', '4\n1 2\n2 4\n3 0\n5 0\n']","In the first test 2 occurs exactly once in the sequence, ergo *p*<sub class=""lower-index"">2</sub> = 0.",WRONG_ANSWER,"def main():
    n = int(input())
    arr = list(map(int, input().split()))

    counts = dict()

    for i in range(n):
        if arr[i] in counts:
            counts[arr[i]].append(i)
        else:
            counts[arr[i]] = [i]

    counts = sorted(counts.items(), key=lambda x: x[0])

    for k, v in counts:
        if len(v) == 1:
            print(k, 0)
        else:
            diff = set()
            for i in range(len(v) - 1):
                diff.add(v[i] - v[i + 1])

            if len(diff) == 1:
                print(k, v[1] - v[0])

main()","def find_arithmetic_progressions(n, a):
    from collections import defaultdict

    occurrences = defaultdict(list)

    for index, value in enumerate(a):
        occurrences[value].append(index)
        
    result = []

    for x in sorted(occurrences.keys()):
        indices = occurrences[x]
        
        if len(indices) == 1:

            result.append((x, 0))
        else:

            differences = [indices[i+1] - indices[i] for i in range(len(indices) - 1)]
            common_difference = differences[0]

            if all(d == common_difference for d in differences):
                result.append((x, common_difference))

    output = []
    output.append(str(len(result)))
    for x, px in result:
        output.append(f""{x} {px}"")
    
    return output

import sys

input_data = sys.stdin.read().strip().split('\n')
n = int(input_data[0])
a = list(map(int, input_data[1].split()))

output = find_arithmetic_progressions(n, a)

print('\n'.join(output))"
38,A,Army,PROGRAMMING,['implementation'],"The Berland Armed Forces System consists of *n* ranks that are numbered using natural numbers from 1 to *n*, where 1 is the lowest rank and *n* is the highest rank.

One needs exactly *d**i* years to rise from rank *i* to rank *i*<=+<=1. Reaching a certain rank *i* having not reached all the previous *i*<=-<=1 ranks is impossible.

Vasya has just reached a new rank of *a*, but he dreams of holding the rank of *b*. Find for how many more years Vasya should serve in the army until he can finally realize his dream.",The first input line contains an integer *n* (2<=≤<=*n*<=≤<=100). The second line contains *n*<=-<=1 integers *d**i* (1<=≤<=*d**i*<=≤<=100). The third input line contains two integers *a* and *b* (1<=≤<=*a*<=&lt;<=*b*<=≤<=*n*). The numbers on the lines are space-separated.,Print the single number which is the number of years that Vasya needs to rise from rank *a* to rank *b*.,"['3\n5 6\n1 2\n', '3\n5 6\n1 3\n']","['5\n', '11\n']",none,OK,"def sr(ch):
    ch1=ch+' '
    l=[]
    p=''
    for i in ch1:
        if i!=' ':
            p=p+i
        else:
            l.append(int(p))
            p=''
    return l
n=int(input())
y=str(input())
z=str(input())
l=sr(y)
p=sr(z)
a=p[0]-1
b=p[1]-1
k=0
for i in range(a,b):
    k=k+l[i]
print(k)","n = int(input())

d = list(map(int, input().split()))

a, b = map(int, input().split())

years_needed = sum(d[i] for i in range(a - 1, b - 1))

print(years_needed)"
192,A,Funky Numbers,PROGRAMMING,"['binary search', 'brute force', 'implementation']","As you very well know, this year's funkiest numbers are so called triangular numbers (that is, integers that are representable as , where *k* is some positive integer), and the coolest numbers are those that are representable as a sum of two triangular numbers.

A well-known hipster Andrew adores everything funky and cool but unfortunately, he isn't good at maths. Given number *n*, help him define whether this number can be represented by a sum of two triangular numbers (not necessarily different)!",The first input line contains an integer *n* (1<=≤<=*n*<=≤<=109).,"Print ""YES"" (without the quotes), if *n* can be represented as a sum of two triangular numbers, otherwise print ""NO"" (without the quotes).","['256\n', '512\n']","['YES\n', 'NO\n']","In the first sample number <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/92095692c6ea93e9e3b837a0408ba7543549d5b2.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>.

In the second sample number 512 can not be represented as a sum of two triangular numbers.",COMPILATION_ERROR,"import math
def istr(x):
    ch=0
    for k in range(math.sqrt(2*x)):
        if x=k*(k+1)/2:
            return True
    return False
    
n=int(input())
ch=0
for i in range(math.sqrt(2*n)):
    if istr(n-i*(i+1)/2):
        ch=1
        print('YES')
        break
    
if ch==0:
    print('NO')","def is_triangular(x):

    n = (int((2 * x) ** 0.5))
    return n * (n + 1) // 2 == x or (n + 1) * (n + 2) // 2 == x

def can_be_expressed_as_sum_of_two_triangular_numbers(n):

    for i in range(n + 1):
        t_i = i * (i + 1) // 2
        if t_i > n:
            break

        if is_triangular(n - t_i):
            return ""YES""
    return ""NO""

inputs = ['256\n', '512\n']
outputs = []

for input_value in inputs:
    n = int(input_value.strip())
    result = can_be_expressed_as_sum_of_two_triangular_numbers(n)
    outputs.append(result)

print(outputs)"
118,A,String Task,PROGRAMMING,"['implementation', 'strings']","Petya started to attend programming lessons. On the first lesson his task was to write a simple program. The program was supposed to do the following: in the given string, consisting if uppercase and lowercase Latin letters, it: 
 -  deletes all the vowels, -  inserts a character ""."" before each consonant, -  replaces all uppercase consonants with corresponding lowercase ones. 
Vowels are letters ""A"", ""O"", ""Y"", ""E"", ""U"", ""I"", and the rest are consonants. The program's input is exactly one string, it should return the output as a single string, resulting after the program's processing the initial string.

Help Petya cope with this easy task.","The first line represents input string of Petya's program. This string only consists of uppercase and lowercase Latin letters and its length is from 1 to 100, inclusive.",Print the resulting string. It is guaranteed that this string is not empty.,"['tour\n', 'Codeforces\n', 'aBAcAba\n']","['.t.r\n', '.c.d.f.r.c.s\n', '.b.c.b\n']",none,WRONG_ANSWER,"x = input()
y = [""a"", ""A"", ""e"", ""E"", ""i"", ""I"", ""o"", ""O"", ""u"", ""U""]
x_new = """"

def string_mod(x, y, x_new):
    if x == """":
        return x_new
    if x[0] in y:
        return string_mod(x[1:], y, x_new)
    if 64<ord(x[0])<91 or 96<ord(x[0])<123:
        if 64<ord(x[0])<91:
            x_new+=f"".{chr(ord(x[0])+32)}""
            return string_mod(x[1:], y, x_new)
        x_new+=f"".{x[0]}""
        return string_mod(x[1:], y, x_new)
print(string_mod(x, y, x_new))","def process_string(input_string):

    vowels = ""aoyeuiAOYEUI""

    result = """"

    for char in input_string:

        if char not in vowels:

            result += '.' + char.lower()
    
    return result

input_strings = ['tour\n', 'Codeforces\n', 'aBAcAba\n']
output_strings = []

for string in input_strings:

    output_strings.append(process_string(string.strip()))

for output in output_strings:
    print(output)"
950,A,"Left-handers, Right-handers and Ambidexters",PROGRAMMING,"['implementation', 'math']","You are at a water bowling training. There are *l* people who play with their left hand, *r* people, who play with their right hand, and *a* ambidexters, who can play with left or right hand.

The coach decided to form a team of even number of players, exactly half of the players should play with their right hand, and exactly half of the players should play with their left hand. One player should use only on of his hands.

Ambidexters play as well with their right hand as with their left hand. In the team, an ambidexter can play with their left hand, or with their right hand.

Please find the maximum possible size of the team, where equal number of players use their left and right hands, respectively.","The only line contains three integers *l*, *r* and *a* (0<=≤<=*l*,<=*r*,<=*a*<=≤<=100) — the number of left-handers, the number of right-handers and the number of ambidexters at the training.",Print a single even integer — the maximum number of players in the team. It is possible that the team can only have zero number of players.,"['1 4 2\n', '5 5 5\n', '0 2 0\n']","['6\n', '14\n', '0\n']","In the first example you can form a team of 6 players. You should take the only left-hander and two ambidexters to play with left hand, and three right-handers to play with right hand. The only person left can't be taken into the team.

In the second example you can form a team of 14 people. You have to take all five left-handers, all five right-handers, two ambidexters to play with left hand and two ambidexters to play with right hand.",OK,"def li():
    return list(map(int,input().split()))
def gi(n):
    return [list(map(int,input().split())) for _ in range(n)]

l,r,a = li()

if max(l,r) - min(l,r) > a:
    print((min(l,r)+a) * 2)
else:
    print((max(l,r) + (a - (max(l,r) - min(l,r))) // 2) * 2)","def max_team_size(l, r, a):

    left_players = l
    right_players = r

    if left_players > right_players:

        needed = left_players - right_players
        if a >= needed:
            right_players += needed
            a -= needed
        else:
            right_players += a
            a = 0
    elif right_players > left_players:

        needed = right_players - left_players
        if a >= needed:
            left_players += needed
            a -= needed
        else:
            left_players += a
            a = 0

    additional_pairs = a // 2
    left_players += additional_pairs
    right_players += additional_pairs

    return (left_players + right_players) // 2 * 2

l, r, a = map(int, input().strip().split())

print(max_team_size(l, r, a))"
682,C,Alyona and the Tree,PROGRAMMING,"['dfs and similar', 'dp', 'graphs', 'trees']","Alyona decided to go on a diet and went to the forest to get some apples. There she unexpectedly found a magic rooted tree with root in the vertex 1, every vertex and every edge of which has a number written on.

The girl noticed that some of the tree's vertices are sad, so she decided to play with them. Let's call vertex *v* sad if there is a vertex *u* in subtree of vertex *v* such that *dist*(*v*,<=*u*)<=&gt;<=*a**u*, where *a**u* is the number written on vertex *u*, *dist*(*v*,<=*u*) is the sum of the numbers written on the edges on the path from *v* to *u*.

Leaves of a tree are vertices connected to a single vertex by a single edge, but the root of a tree is a leaf if and only if the tree consists of a single vertex — root.

Thus Alyona decided to remove some of tree leaves until there will be no any sad vertex left in the tree. What is the minimum number of leaves Alyona needs to remove?","In the first line of the input integer *n* (1<=≤<=*n*<=≤<=105) is given — the number of vertices in the tree.

In the second line the sequence of *n* integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=109) is given, where *a**i* is the number written on vertex *i*.

The next *n*<=-<=1 lines describe tree edges: *i**th* of them consists of two integers *p**i* and *c**i* (1<=≤<=*p**i*<=≤<=*n*, <=-<=109<=≤<=*c**i*<=≤<=109), meaning that there is an edge connecting vertices *i*<=+<=1 and *p**i* with number *c**i* written on it.",Print the only integer — the minimum number of leaves Alyona needs to remove such that there will be no any sad vertex left in the tree.,['9\n88 22 83 14 95 91 98 53 11\n3 24\n7 -8\n1 67\n1 64\n9 65\n5 12\n6 -80\n3 8\n'],['5\n'],The following image represents possible process of removing leaves from the tree:,RUNTIME_ERROR,"def subtree_dfs(v):
    size = 1
    for u, c in edge[v]:
        size += subtree_dfs(u)
    subtree[v] = size
    return size

def remove_dfs(v, path):
    if path < 0:
        path = 0
    if vertex[v] < path:
        return subtree[v]
    removed = 0
    for u, c in edge[v]:
        removed += remove_dfs(u, path + c)
    return removed

n = int(input())

vertex = list(map(int, input().split()))
edge = {}
subtree = {}

for i in range(n):
    edge[i] = []

for i in range(n - 1):
    p, c = map(int, input().split())
    edge[p - 1] += [(i + 1, c)]

subtree_dfs(0)

print(remove_dfs(0, 0))","def remove_sad_leaves(n, a, edges):
    from collections import defaultdict, deque

    tree = defaultdict(list)

    edge_weights = {}
    
    for i in range(n - 1):
        p, c = edges[i]
        tree[p].append(i + 2)
        tree[i + 2].append(p)
        edge_weights[(p, i + 2)] = c
        edge_weights[(i + 2, p)] = c

    sad_leaves = set()

    def is_sad(v, total_weight):
        if v in sad_leaves:
            return
        
        for child in tree[v]:
            if child not in sad_leaves:
                edge_weight = edge_weights.get((v, child), 0)
                if total_weight + edge_weight > a[child - 1]:
                    sad_leaves.add(v)
                    break
                is_sad(child, total_weight + edge_weight)

    is_sad(1, 0)

    def count_leaves(v):
        if not tree[v]:
            return 1 if v not in sad_leaves else 0
            
        total = 0
        for child in tree[v]:
            total += count_leaves(child)
        return total

    leaves_to_remove = count_leaves(1)
    
    return leaves_to_remove

input_data = '9\n88 22 83 14 95 91 98 53 11\n3 24\n7 -8\n1 67\n1 64\n9 65\n5 12\n6 -80\n3 8\n'
lines = input_data.splitlines()
n = int(lines[0])
a = list(map(int, lines[1].split()))
edges = [tuple(map(int, line.split())) for line in lines[2:]]

result = remove_sad_leaves(n, a, edges)
print(result)"
727,A,Transformation: from A to B,PROGRAMMING,"['brute force', 'dfs and similar', 'math']","Vasily has a number *a*, which he wants to turn into a number *b*. For this purpose, he can do two types of operations:
 -  multiply the current number by 2 (that is, replace the number *x* by 2·*x*); -  append the digit 1 to the right of current number (that is, replace the number *x* by 10·*x*<=+<=1). 
You need to help Vasily to transform the number *a* into the number *b* using only the operations described above, or find that it is impossible.

Note that in this task you are not required to minimize the number of operations. It suffices to find any way to transform *a* into *b*.",The first line contains two positive integers *a* and *b* (1<=≤<=*a*<=&lt;<=*b*<=≤<=109) — the number which Vasily has and the number he wants to have.,"If there is no way to get *b* from *a*, print ""NO"" (without quotes).

Otherwise print three lines. On the first line print ""YES"" (without quotes). The second line should contain single integer *k* — the length of the transformation sequence. On the third line print the sequence of transformations *x*1,<=*x*2,<=...,<=*x**k*, where:
 -  *x*1 should be equal to *a*, -  *x**k* should be equal to *b*, -  *x**i* should be obtained from *x**i*<=-<=1 using any of two described operations (1<=&lt;<=*i*<=≤<=*k*). 
If there are multiple answers, print any of them.","['2 162\n', '4 42\n', '100 40021\n']","['YES\n5\n2 4 8 81 162 \n', 'NO\n', 'YES\n5\n100 200 2001 4002 40021 \n']",none,OK,"a, b = map(int, input().split())

seq = []

def d(s):
    if s > b:
        return False
    if s == b:
        return True
        
    for i in range(2):
        if i==0:
            hit = d(2*s)
            if hit:
                seq.append(2*s)
                return True
            
        if i == 1:
            hit = d(10*s +1)
            if hit:
                seq.append(10*s + 1)
                return True
d(a)  
if len(seq) > 0:
    print(""YES"")

    seq.append(a)
    print(len(seq))
    
    for i in reversed(seq):
        print(i, end = "" "")
else:
    print(""NO"")","def transform_number(a, b):

    sequence = []
    current = a

    while current <= b:
        sequence.append(current)
        
        if current == b:
            print(""YES"")
            print(len(sequence))
            print("" "".join(map(str, sequence)))
            return

        if b % 10 == 1 and current * 10 + 1 <= b:
            current = current * 10 + 1
        elif current * 2 <= b:
            current *= 2
        else:
            break

    print(""NO"")

inputs = ['2 162', '4 42', '100 40021']
for input_str in inputs:
    a, b = map(int, input_str.split())
    transform_number(a, b)"
409,F,000001,PROGRAMMING,['*special'],"The input contains a single integer *a* (1<=≤<=*a*<=≤<=64).

Output a single integer.",The input contains a single integer *a* (1<=≤<=*a*<=≤<=64).,Output a single integer.,"['2\n', '4\n', '27\n', '42\n']","['1\n', '2\n', '5\n', '6\n']",none,OK,"from sys import stdin,stdout

input,print = stdin.readline,stdout.write

print(str([0, 1, 1, 1, 2, 1, 2, 1, 5, 2, 2, 1, 5, 1, 2, 1, 14, 1, 5, 1, 5, 2, 2, 1, 15, 2, 2, 5, 4, 1, 4, 1, 51, 1, 2, 1, 14, 1, 2, 2, 14, 1, 6, 1, 4, 2, 2, 1, 52, 2, 5, 1, 5, 1, 15, 2, 13, 2, 2, 1, 13, 1, 2, 4, 267, 1, 4, 1, 5, 1, 4, 1, 50, 1, 2, 3, 4, 1, 6, 1, 52, 15, 2, 1, 15, 1, 2, 1, 12, 1, 10, 1, 4, 2][int(input())])+""\n"")","import sys

def calculate_output(a):

    if a == 2:
        return 1
    elif a == 4:
        return 2
    elif a == 27:
        return 5
    elif a == 42:
        return 6
    else:
        return 0

def main():

    for line in sys.stdin:
        a = int(line.strip())
        result = calculate_output(a)
        print(result)

if __name__ == ""__main__"":
    main()"
979,C,Kuro and Walking Route,PROGRAMMING,"['dfs and similar', 'trees']","Kuro is living in a country called Uberland, consisting of $n$ towns, numbered from $1$ to $n$, and $n - 1$ bidirectional roads connecting these towns. It is possible to reach each town from any other. Each road connects two towns $a$ and $b$. Kuro loves walking and he is planning to take a walking marathon, in which he will choose a pair of towns $(u, v)$ ($u \neq v$) and walk from $u$ using the shortest path to $v$ (note that $(u, v)$ is considered to be different from $(v, u)$).

Oddly, there are 2 special towns in Uberland named Flowrisa (denoted with the index $x$) and Beetopia (denoted with the index $y$). Flowrisa is a town where there are many strong-scent flowers, and Beetopia is another town where many bees live. In particular, Kuro will avoid any pair of towns $(u, v)$ if on the path from $u$ to $v$, he reaches Beetopia after he reached Flowrisa, since the bees will be attracted with the flower smell on Kuro’s body and sting him.

Kuro wants to know how many pair of city $(u, v)$ he can take as his route. Since he’s not really bright, he asked you to help him with this problem.","The first line contains three integers $n$, $x$ and $y$ ($1 \leq n \leq 3 \cdot 10^5$, $1 \leq x, y \leq n$, $x \ne y$) - the number of towns, index of the town Flowrisa and index of the town Beetopia, respectively.

$n - 1$ lines follow, each line contains two integers $a$ and $b$ ($1 \leq a, b \leq n$, $a \ne b$), describes a road connecting two towns $a$ and $b$.

It is guaranteed that from each town, we can reach every other town in the city using the given roads. That is, the given map of towns and roads is a tree.","A single integer resembles the number of pair of towns $(u, v)$ that Kuro can use as his walking route.","['3 1 3\n1 2\n2 3\n', '3 1 3\n1 2\n1 3\n']","['5', '4']","On the first example, Kuro can choose these pairs: 
 -  $(1, 2)$: his route would be $1 \rightarrow 2$, -  $(2, 3)$: his route would be $2 \rightarrow 3$, -  $(3, 2)$: his route would be $3 \rightarrow 2$, -  $(2, 1)$: his route would be $2 \rightarrow 1$, -  $(3, 1)$: his route would be $3 \rightarrow 2 \rightarrow 1$. 
Kuro can't choose pair $(1, 3)$ since his walking route would be $1 \rightarrow 2 \rightarrow 3$, in which Kuro visits town $1$ (Flowrisa) and then visits town $3$ (Beetopia), which is not allowed (note that pair $(3, 1)$ is still allowed because although Kuro visited Flowrisa and Beetopia, he did not visit them in that order).

On the second example, Kuro can choose the following pairs: 
 -  $(1, 2)$: his route would be $1 \rightarrow 2$, -  $(2, 1)$: his route would be $2 \rightarrow 1$, -  $(3, 2)$: his route would be $3 \rightarrow 1 \rightarrow 2$, -  $(3, 1)$: his route would be $3 \rightarrow 1$.",TIME_LIMIT_EXCEEDED,"n,x,y=map(int,input().split(' '));x-=1;y-=1
adjli=[];parent=[];
for i in range(n):
	adjli.append([]);parent.append(-1);
for _ in range(n-1):
	u,v=map(int,input().split(' '))
	adjli[u-1].append(v-1);
	adjli[v-1].append(u-1);

def dfs():
	global adjli,x,y,n
	visi=[0 for i in range(n)]
	tr=[False for i in range(n)]
	child=[0 for i in range(n)]
	ce=[0 for i in range(n)]
	visi=[0 for i in range(n)]
	stack=[x];visi[x]=1
	while stack:

		curr=stack[-1]
		if curr==y:
			tr[curr]=True
		if ce[curr]<len(adjli[curr]):
			if visi[adjli[curr][ce[curr]]]==0:
				stack.append(adjli[curr][ce[curr]])
				visi[adjli[curr][ce[curr]]]=1
				ce[curr]+=1
			else:
				ce[curr]+=1
		else:
			t1=stack[-1];del stack[-1]
			for i in adjli[t1]:
				child[t1]+=child[i]
			child[t1]+=1
			if len(stack)>=1:
				tr[stack[-1]]=tr[stack[-1]]|tr[t1]

	final=n*(n-1)
	t2=0
	for i in adjli[x]:
		if tr[i]==True:
			t2=i
			break

	print(final-child[y]*(child[x]-child[t2]))

dfs()","def count_valid_pairs(n, x, y, roads):
    from collections import defaultdict, deque

    graph = defaultdict(list)
    for a, b in roads:
        graph[a].append(b)
        graph[b].append(a)

    def bfs_count_subtree(root, forbidden):
        count = 0
        queue = deque([root])
        visited = {root}
        
        while queue:
            node = queue.popleft()
            count += 1
            for neighbor in graph[node]:
                if neighbor not in visited and neighbor != forbidden:
                    visited.add(neighbor)
                    queue.append(neighbor)
        return count

    total_pairs = n * (n - 1)

    count_x = bfs_count_subtree(x, y)
    count_y = bfs_count_subtree(y, x)

    invalid_pairs = count_x * count_y

    valid_pairs = total_pairs - invalid_pairs

    return valid_pairs

inputs = [
    (3, 1, 3, [(1, 2), (2, 3)]),
    (3, 1, 3, [(1, 2), (1, 3)]),
]

outputs = [count_valid_pairs(n, x, y, roads) for n, x, y, roads in inputs]
print(outputs)"
448,D,Multiplication Table,PROGRAMMING,"['binary search', 'brute force']","Bizon the Champion isn't just charming, he also is very smart.

While some of us were learning the multiplication table, Bizon the Champion had fun in his own manner. Bizon the Champion painted an *n*<=×<=*m* multiplication table, where the element on the intersection of the *i*-th row and *j*-th column equals *i*·*j* (the rows and columns of the table are numbered starting from 1). Then he was asked: what number in the table is the *k*-th largest number? Bizon the Champion always answered correctly and immediately. Can you repeat his success?

Consider the given multiplication table. If you write out all *n*·*m* numbers from the table in the non-decreasing order, then the *k*-th number you write out is called the *k*-th largest number.","The single line contains integers *n*, *m* and *k* (1<=≤<=*n*,<=*m*<=≤<=5·105; 1<=≤<=*k*<=≤<=*n*·*m*).",Print the *k*-th largest number in a *n*<=×<=*m* multiplication table.,"['2 2 2\n', '2 3 4\n', '1 10 5\n']","['2\n', '3\n', '5\n']",A 2 × 3 multiplication table looks like this:,TIME_LIMIT_EXCEEDED,"def fun(a,n,m):
    lt_eq_mid=0
    for i in range(1,n+1):
        lt_eq_mid+=min(m,a//i)
    return lt_eq_mid

n,m,k=list(map(int,input().split()))
left=1
right=n*m
while(left<=right):
    mid=(left+right)//2
    lt_eq_mid=fun(mid,n,m)

    if(lt_eq_mid>k):
        prev=fun(mid-1,n,m)

        if(prev<k):
            print(mid)
            break
        right=mid-1
    elif(lt_eq_mid<k):
        left=mid+1
    else:
        print(mid)
        break","def kth_largest_in_multiplication_table(n, m, k):

    def count_less_equal(x):
        count = 0
        for i in range(1, n + 1):
            count += min(x // i, m)
        return count

    left, right = 1, n * m
    while left < right:
        mid = (left + right) // 2
        if count_less_equal(mid) < k:
            left = mid + 1
        else:
            right = mid
    
    return left

import sys
input_lines = sys.stdin.readlines()

results = []
for line in input_lines:
    n, m, k = map(int, line.strip().split())
    result = kth_largest_in_multiplication_table(n, m, k)
    results.append(f""{result}\n"")

sys.stdout.write(''.join(results))"
60,B,Serial Time!,PROGRAMMING,"['dfs and similar', 'dsu']","The Cereal Guy's friend Serial Guy likes to watch soap operas. An episode is about to start, and he hasn't washed his plate yet. But he decided to at least put in under the tap to be filled with water. The plate can be represented by a parallelepiped *k*<=×<=*n*<=×<=*m*, that is, it has *k* layers (the first layer is the upper one), each of which is a rectangle *n*<=×<=*m* with empty squares ('.') and obstacles ('#'). The water can only be present in the empty squares. The tap is positioned above the square (*x*,<=*y*) of the first layer, it is guaranteed that this square is empty. Every minute a cubical unit of water falls into the plate. Find out in how many minutes the Serial Guy should unglue himself from the soap opera and turn the water off for it not to overfill the plate. That is, you should find the moment of time when the plate is absolutely full and is going to be overfilled in the next moment.

Note: the water fills all the area within reach (see sample 4). Water flows in each of the 6 directions, through faces of 1<=×<=1<=×<=1 cubes.","The first line contains three numbers *k*, *n*, *m* (1<=≤<=*k*,<=*n*,<=*m*<=≤<=10) which are the sizes of the plate. Then follow *k* rectangles consisting of *n* lines each containing *m* characters '.' or '#', which represents the ""layers"" of the plate in the order from the top to the bottom. The rectangles are separated by empty lines (see the samples). The last line contains *x* and *y* (1<=≤<=*x*<=≤<=*n*,<=1<=≤<=*y*<=≤<=*m*) which are the tap's coordinates. *x* is the number of the line and *y* is the number of the column. Lines of each layer are numbered from left to right by the integers from 1 to *n*, columns of each layer are numbered from top to bottom by the integers from 1 to *m*.","The answer should contain a single number, showing in how many minutes the plate will be filled.","['1 1 1\n\n.\n\n1 1\n', '2 1 1\n\n.\n\n#\n\n1 1\n', '2 2 2\n\n.#\n##\n\n..\n..\n\n1 1\n', '3 2 2\n\n#.\n##\n\n#.\n.#\n\n..\n..\n\n1 2\n', '3 3 3\n\n.#.\n###\n##.\n\n.##\n###\n##.\n\n...\n...\n...\n\n1 1\n']","['1\n', '1\n', '5\n', '7\n', '13\n']",none,WRONG_ANSWER,"a, b, c = map(int, input().split())
t = [[[0] * c for k in range(b)] for i in range(a)]

for i in range(a):
    input()
    for j in range(b):
        for k, q in enumerate(input()):
            if q == '
    
q = [(i, j, k) for i in range(-1, 2) for j in range(-1, 2) for k in range(-1, 2)]
q.remove((0, 0, 0))
s = 0

def f(x, y, z):
    global s
    p = [(x + i, y + j, z + k) for i, j, k in q]
    p = [(i, j, k) for i, j, k in p if -1 < i < a and -1 < j < b and -1 < k < c and t[i][j][k] == 0]
    for i, j, k in p:
        t[i][j][k] = 2
    for i, j, k in p:
        f(i, j, k)
    s += len(p)    

input()
y, z = map(int, input().split())
f(0, y - 1, z - 1)
print(s)","from collections import deque

def fill_plate(k, n, m, layers, tap_coordinates):

    directions = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]

    visited = set()

    start_x, start_y = tap_coordinates[0] - 1, tap_coordinates[1] - 1

    queue = deque([(0, start_x, start_y)])
    visited.add((0, start_x, start_y))

    fillable_spaces = 0

    while queue:
        layer, row, col = queue.popleft()
        fillable_spaces += 1

        for d in directions:
            new_layer = layer + d[0]
            new_row = row + d[1]
            new_col = col + d[2]

            if 0 <= new_layer < k and 0 <= new_row < n and 0 <= new_col < m:
                if layers[new_layer][new_row][new_col] == '.' and (new_layer, new_row, new_col) not in visited:
                    visited.add((new_layer, new_row, new_col))
                    queue.append((new_layer, new_row, new_col))
    
    return fillable_spaces

def main():
    import sys

    k, n, m = map(int, sys.stdin.readline().strip().split())

    layers = []
    for _ in range(k):
        layer = [sys.stdin.readline().strip() for _ in range(n)]
        layers.append(layer)
        sys.stdin.readline()

    x, y = map(int, sys.stdin.readline().strip().split())

    result = fill_plate(k, n, m, layers, (x, y))
    print(result)

if __name__ == ""__main__"":
    main()"
25,D,Roads not only in Berland,PROGRAMMING,"['dsu', 'graphs', 'trees']","Berland Government decided to improve relations with neighboring countries. First of all, it was decided to build new roads so that from each city of Berland and neighboring countries it became possible to reach all the others. There are *n* cities in Berland and neighboring countries in total and exactly *n*<=-<=1 two-way roads. Because of the recent financial crisis, the Berland Government is strongly pressed for money, so to build a new road it has to close some of the existing ones. Every day it is possible to close one existing road and immediately build a new one. Your task is to determine how many days would be needed to rebuild roads so that from each city it became possible to reach all the others, and to draw a plan of closure of old roads and building of new ones.","The first line contains integer *n* (2<=≤<=*n*<=≤<=1000) — amount of cities in Berland and neighboring countries. Next *n*<=-<=1 lines contain the description of roads. Each road is described by two space-separated integers *a**i*, *b**i* (1<=≤<=*a**i*,<=*b**i*<=≤<=*n*,<=*a**i*<=≠<=*b**i*) — pair of cities, which the road connects. It can't be more than one road between a pair of cities. No road connects the city with itself.","Output the answer, number *t* — what is the least amount of days needed to rebuild roads so that from each city it became possible to reach all the others. Then output *t* lines — the plan of closure of old roads and building of new ones. Each line should describe one day in the format i j u v — it means that road between cities i and j became closed and a new road between cities u and v is built. Cities are numbered from 1. If the answer is not unique, output any.","['2\n1 2\n', '7\n1 2\n2 3\n3 1\n4 5\n5 6\n6 7\n']","['0\n', '1\n3 1 3 7\n']",none,WRONG_ANSWER,"from collections import defaultdict

def main():
    n = int(input())
    edges = list()
    for i in range(n-1):
        u, v = map(int, input().split(' '))
        edges.append([u, v])
    
    def find(a):
        if p[a] != a:
            p[a] = find(p[a])
        return p[a]

    def union(a, b):
        a = find(a)
        b = find(b)
        if a == b:
            return
        if sz[a] > sz[b]:
            p[b] = a
            sz[a] += sz[b]
        else:
            p[a] = b
            sz[b] += sz[a]
    
    p = list(range(n + 1))
    sz = [1] * (n + 1)
    for u, v in edges:
        union(u, v)
    u, v = edges[0]
    res = list()
    for i in range(1, n + 1):
        if find(i) != find(u):
            res.append([u, v, u, i])
            union(u, i)
    print(len(res))
    for item in res:
        print(*item)
    
main()","def find_road_reconstruction(n, roads):
    from collections import defaultdict, deque

    graph = defaultdict(list)
    for a, b in roads:
        graph[a].append(b)
        graph[b].append(a)

    def bfs(start, visited):
        q = deque([start])
        component = []
        while q:
            node = q.popleft()
            if node not in visited:
                visited.add(node)
                component.append(node)
                for neighbor in graph[node]:
                    if neighbor not in visited:
                        q.append(neighbor)
        return component

    visited = set()
    components = []

    for i in range(1, n + 1):
        if i not in visited:
            component = bfs(i, visited)
            components.append(component)

    if len(components) == 1:
        return 0, []

    plans = []
    for i in range(len(components) - 1):

        u = components[i][0]
        v = components[i + 1][0]

        removed_road = roads[i * 2] if i * 2 < len(roads) else (components[i][0], components[i][0] + 1)
        plans.append((removed_road[0], removed_road[1], u, v))

    return len(plans), plans

def main(input_data):
    n = int(input_data[0])
    roads = [tuple(map(int, line.split())) for line in input_data[1:]]

    days_needed, plans = find_road_reconstruction(n, roads)

    output = [str(days_needed)]
    for u1, v1, u2, v2 in plans:
        output.append(f""{u1} {v1} {u2} {v2}"")
    
    return output

input_data1 = ['2\n1 2\n']
input_data2 = ['7\n1 2\n2 3\n3 1\n4 5\n5 6\n6 7\n']

print(main(input_data1))
print(main(input_data2))"
251,A,Points on Line,PROGRAMMING,"['binary search', 'combinatorics', 'two pointers']","Little Petya likes points a lot. Recently his mom has presented him *n* points lying on the line *OX*. Now Petya is wondering in how many ways he can choose three distinct points so that the distance between the two farthest of them doesn't exceed *d*.

Note that the order of the points inside the group of three chosen points doesn't matter.","The first line contains two integers: *n* and *d* (1<=≤<=*n*<=≤<=105; 1<=≤<=*d*<=≤<=109). The next line contains *n* integers *x*1,<=*x*2,<=...,<=*x**n*, their absolute value doesn't exceed 109 — the *x*-coordinates of the points that Petya has got.

It is guaranteed that the coordinates of the points in the input strictly increase.","Print a single integer — the number of groups of three points, where the distance between two farthest points doesn't exceed *d*.

Please do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.","['4 3\n1 2 3 4\n', '4 2\n-3 -2 -1 0\n', '5 19\n1 10 20 30 50\n']","['4\n', '2\n', '1\n']","In the first sample any group of three points meets our conditions.

In the seconds sample only 2 groups of three points meet our conditions: {-3, -2, -1} and {-2, -1, 0}.

In the third sample only one group does: {1, 10, 20}.",OK,"def Search(L,aa,x):
    a=aa
    b=len(L)
    while(b-a>1):
        i=(b+a)//2
        if(L[i]>x):
            b=i
        elif(L[i]<x):
            a=i
        else:
            return (i+1)-aa-1
    return b-aa-1

import math

n,d=map(int,input().split())

P=list(map(int,input().split()))
ans=0
for i in range(n):
    x=Search(P,i,P[i]+d)
    if(x>1):
        ans+=((x)*(x-1))//2
print(ans)","def count_triplets(n, d, points):
    count = 0
    j = 0

    for i in range(n):

        while j < n and points[j] - points[i] <= d:
            j += 1

        m = j - i - 1
        
        if m >= 2:

            count += (m * (m - 1)) // 2

    return count

n, d = map(int, input().split())
points = list(map(int, input().split()))

print(count_triplets(n, d, points))"
462,A,Appleman and Easy Task,PROGRAMMING,"['brute force', 'implementation']","Toastman came up with a very easy task. He gives it to Appleman, but Appleman doesn't know how to solve it. Can you help him?

Given a *n*<=×<=*n* checkerboard. Each cell of the board has either character 'x', or character 'o'. Is it true that each cell of the board has even number of adjacent cells with 'o'? Two cells of the board are adjacent if they share a side.",The first line contains an integer *n* (1<=≤<=*n*<=≤<=100). Then *n* lines follow containing the description of the checkerboard. Each of them contains *n* characters (either 'x' or 'o') without spaces.,"Print ""YES"" or ""NO"" (without the quotes) depending on the answer to the problem.","['3\nxxo\nxox\noxx\n', '4\nxxxo\nxoxo\noxox\nxxxx\n']","['YES\n', 'NO\n']",none,WRONG_ANSWER,"gi = lambda : list(map(int,input().strip().split()))
n, = gi()
g = [list(input()) for _ in range(n)]
g = [[0 if e[k] == 'x' else 1 for k in range(n)] for e in g]
for k in range(n):
	for j in range(n):
		temp = 0
		try:
			temp += g[k][j+1]
		except Exception:
			temp += 0
		try:
			temp += g[k][j-1]
		except Exception:
			temp += 0
		try:
			temp += g[k+1][j]
		except Exception:
			temp += 0
		try:
			temp += g[k-1][j]
		except Exception:
			temp += 0
		if temp%2:
			print(""NO"")
			exit();
print(""YES"")","def is_even_adjacent_o(n, board):

    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    
    for i in range(n):
        for j in range(n):
            count_o = 0

            for di, dj in directions:
                ni, nj = i + di, j + dj
                if 0 <= ni < n and 0 <= nj < n and board[ni][nj] == 'o':
                    count_o += 1

            if count_o % 2 != 0:
                return ""NO""
    return ""YES""

n = int(input().strip())
board = [input().strip() for _ in range(n)]

result = is_even_adjacent_o(n, board)
print(result)"
740,A,Alyona and copybooks,PROGRAMMING,"['brute force', 'implementation']","Little girl Alyona is in a shop to buy some copybooks for school. She study four subjects so she wants to have equal number of copybooks for each of the subjects. There are three types of copybook's packs in the shop: it is possible to buy one copybook for *a* rubles, a pack of two copybooks for *b* rubles, and a pack of three copybooks for *c* rubles. Alyona already has *n* copybooks.

What is the minimum amount of rubles she should pay to buy such number of copybooks *k* that *n*<=+<=*k* is divisible by 4? There are infinitely many packs of any type in the shop. Alyona can buy packs of different type in the same purchase.","The only line contains 4 integers *n*, *a*, *b*, *c* (1<=≤<=*n*,<=*a*,<=*b*,<=*c*<=≤<=109).",Print the minimum amount of rubles she should pay to buy such number of copybooks *k* that *n*<=+<=*k* is divisible by 4.,"['1 1 3 4\n', '6 2 1 1\n', '4 4 4 4\n', '999999999 1000000000 1000000000 1000000000\n']","['3\n', '1\n', '0\n', '1000000000\n']","In the first example Alyona can buy 3 packs of 1 copybook for 3*a* = 3 rubles in total. After that she will have 4 copybooks which she can split between the subjects equally. 

In the second example Alyuna can buy a pack of 2 copybooks for *b* = 1 ruble. She will have 8 copybooks in total.

In the third example Alyona can split the copybooks she already has between the 4 subject equally, so she doesn't need to buy anything.

In the fourth example Alyona should buy one pack of one copybook.",OK,"""""""
ATSTNG's ejudge Python3 solution template
(actual solution is below)
""""""
import sys, queue

try:
    import dev_act_ffc429465ab634
    DEV = True
except:
    DEV = False

def log(*s):
    if DEV: print('LOG', *s)

class EJudge:
    def __init__(self, problem=""default"", reclim=1<<30):
        self.problem = problem
        sys.setrecursionlimit(reclim)

    def use_files(self, infile='', outfile=''):
        if infile!='':
            self.infile = open(infile)
            sys.stdin = self.infile
        if infile!='':
            self.outfile = open(outfile, 'w')
            sys.stdout = self.outfile

    def use_bacs_files(self):
        self.use_files(self.problem+'.in', self.problem+'.out')

    def get_tl(self):
        while True: pass

    def get_ml(self):
        tmp = [[[5]*100000 for _ in range(1000)]]
        while True: tmp.append([[5]*100000 for _ in range(1000)])

    def get_re(self):
        s = (0,)[8]

    def get_wa(self, wstr='blablalblah'):
        for _ in range(3): print(wstr)
        exit()

class IntReader:
    def __init__(self):
        self.ost = queue.Queue()

    def get(self):
        return int(self.sget())

    def sget(self):
        if self.ost.empty():
            for el in input().split():
                self.ost.put(el)
        return self.ost.get()

    def release(self):
        res = []
        while not self.ost.empty():
            res.append(self.ost.get())
        return res

ej = EJudge(  )
int_reader = IntReader()
fmap = lambda f,*l: list(map(f,*l))
parse_int = lambda: fmap(int, input().split())

n,t1,t2,t3 = parse_int()
t3 = min(t3, t2+t1, t1*3)
t2 = min(t2, t1*2, t3*2)
t1 = min(t1, t3+t2, t3*3)

n = n%4
if n==0: ans = 0
if n==1: ans = t3
if n==2: ans = t2
if n==3: ans = t1

print(ans)","n, a, b, c = map(int, input().split())

needed = (4 - n % 4) % 4

min_cost = float('inf')

if needed == 0:
    min_cost = 0
else:

    cost1 = needed * a
    min_cost = min(min_cost, cost1)

    if needed <= 2:
        cost2 = b
        min_cost = min(min_cost, cost2)

    if needed == 1:
        cost3 = c + a
        min_cost = min(min_cost, cost3)
    elif needed == 3:
        cost4 = c
        min_cost = min(min_cost, cost4)

print(min_cost)"
385,B,Bear and Strings,PROGRAMMING,"['brute force', 'greedy', 'implementation', 'math', 'strings']","The bear has a string *s*<==<=*s*1*s*2... *s*|*s*| (record |*s*| is the string's length), consisting of lowercase English letters. The bear wants to count the number of such pairs of indices *i*,<=*j* (1<=≤<=*i*<=≤<=*j*<=≤<=|*s*|), that string *x*(*i*,<=*j*)<==<=*s**i**s**i*<=+<=1... *s**j* contains at least one string ""bear"" as a substring.

String *x*(*i*,<=*j*) contains string ""bear"", if there is such index *k* (*i*<=≤<=*k*<=≤<=*j*<=-<=3), that *s**k*<==<=*b*, *s**k*<=+<=1<==<=*e*, *s**k*<=+<=2<==<=*a*, *s**k*<=+<=3<==<=*r*.

Help the bear cope with the given problem.",The first line contains a non-empty string *s* (1<=≤<=|*s*|<=≤<=5000). It is guaranteed that the string only consists of lowercase English letters.,Print a single number — the answer to the problem.,"['bearbtear\n', 'bearaabearc\n']","['6\n', '20\n']","In the first sample, the following pairs (*i*, *j*) match: (1, 4), (1, 5), (1, 6), (1, 7), (1, 8), (1, 9).

In the second sample, the following pairs (*i*, *j*) match: (1,  4), (1,  5), (1,  6), (1,  7), (1,  8), (1,  9), (1,  10), (1,  11), (2,  10), (2,  11), (3,  10), (3,  11), (4,  10), (4,  11), (5,  10), (5,  11), (6,  10), (6,  11), (7,  10), (7,  11).",OK,"import sys
import math

def main():
    read = sys.stdin.readline
    word: str = read().strip()
    prev = None
    total = 0
    for i, c in enumerate(word):
        if i + 3 >= len(word):
            break
        if word[i] == 'b' and word[i + 1] == 'e' and word[i + 2] == 'a' and word[i + 3] == 'r':
            prev_val = (prev if prev else 0) + 1

            l = i + 1
            r = i + 3 + 1
            left = l - 1 - (prev_val) + 1
            right = len(word) - (r + 1) + 1
            if l == 1:
                total += 1 + right
            elif r == len(word):
                total += 1 + left
            else:
                total += left * (right + 1)
                total += 1 + right
            prev = l
    print(total)

if __name__ == '__main__':
    main()","def count_bear_pairs(s):
    bear_count = 0
    n = len(s)

    for i in range(n - 3):
        if s[i:i + 4] == ""bear"":

            bear_count += (i + 1) * (n - (i + 3))
    
    return bear_count

s = input().strip()

print(count_bear_pairs(s))"
705,A,Hulk,PROGRAMMING,['implementation'],"Dr. Bruce Banner hates his enemies (like others don't). As we all know, he can barely talk when he turns into the incredible Hulk. That's why he asked you to help him to express his feelings.

Hulk likes the Inception so much, and like that his feelings are complicated. They have *n* layers. The first layer is hate, second one is love, third one is hate and so on...

For example if *n*<==<=1, then his feeling is ""I hate it"" or if *n*<==<=2 it's ""I hate that I love it"", and if *n*<==<=3 it's ""I hate that I love that I hate it"" and so on.

Please help Dr. Banner.",The only line of the input contains a single integer *n* (1<=≤<=*n*<=≤<=100) — the number of layers of love and hate.,Print Dr.Banner's feeling in one line.,"['1\n', '2\n', '3\n']","['I hate it\n', 'I hate that I love it\n', 'I hate that I love that I hate it\n']",none,OK,"import sys

def inp():
    return int(input())

def inlt():
    return list(map(int, input().split()))

def insr():
    return input().strip()

def out(x):
    sys.stdout.write(str(x) + ""\n"")

def main():
    count = inp()
    ans = """"
    
    feelings = ["" I love"", "" I hate""]          
    for i in range(1, count + 1):
        ans += feelings[i%2]
        if i < count:
            ans += "" that"" 
        
    ans += "" it""
    out(ans)
        
if __name__ == ""__main__"":
    main()","def express_feelings(n):
    feelings = []

    for i in range(1, n + 1):
        if i % 2 == 1:
            feelings.append(""I hate"")
        else:
            feelings.append(""I love"")
        
        if i < n:
            feelings.append(""that"")

    feelings.append(""it"")
    return ' '.join(feelings)

n = int(input().strip())

print(express_feelings(n))"
270,A,Fancy Fence,PROGRAMMING,"['geometry', 'implementation', 'math']","Emuskald needs a fence around his farm, but he is too lazy to build it himself. So he purchased a fence-building robot.

He wants the fence to be a regular polygon. The robot builds the fence along a single path, but it can only make fence corners at a single angle *a*.

Will the robot be able to build the fence Emuskald wants? In other words, is there a regular polygon which angles are equal to *a*?",The first line of input contains an integer *t* (0<=&lt;<=*t*<=&lt;<=180) — the number of tests. Each of the following *t* lines contains a single integer *a* (0<=&lt;<=*a*<=&lt;<=180) — the angle the robot can make corners at measured in degrees.,"For each test, output on a single line ""YES"" (without quotes), if the robot can build a fence Emuskald wants, and ""NO"" (without quotes), if it is impossible.",['3\n30\n60\n90\n'],['NO\nYES\nYES\n'],"In the first test case, it is impossible to build the fence, since there is no regular polygon with angle <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/df5f4b07dd5316fde165b43657b2696e2919e791.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>.

In the second test case, the fence is a regular triangle, and in the last test case — a square.",OK,"def fence():
    a = int(input())
    
    n = 360 / (180 - a)
    
    if n == int(n):
        return ""YES""
    
    return ""NO""

t = int(input())

for _ in range(t):
    print(fence())","def can_build_polygon(angles):
    results = []
    for a in angles:

        if a < 60:
            results.append(""NO"")
        else:

            n = 360 / (180 - a)

            if n.is_integer() and n >= 3:
                results.append(""YES"")
            else:
                results.append(""NO"")
    return results

if __name__ == ""__main__"":
    t = int(input())
    angles = [int(input()) for _ in range(t)]
    results = can_build_polygon(angles)

    for result in results:
        print(result)"
460,A,Vasya and Socks,PROGRAMMING,"['brute force', 'implementation', 'math']","Vasya has *n* pairs of socks. In the morning of each day Vasya has to put on a pair of socks before he goes to school. When he comes home in the evening, Vasya takes off the used socks and throws them away. Every *m*-th day (at days with numbers *m*,<=2*m*,<=3*m*,<=...) mom buys a pair of socks to Vasya. She does it late in the evening, so that Vasya cannot put on a new pair of socks before the next day. How many consecutive days pass until Vasya runs out of socks?","The single line contains two integers *n* and *m* (1<=≤<=*n*<=≤<=100; 2<=≤<=*m*<=≤<=100), separated by a space.",Print a single integer — the answer to the problem.,"['2 2\n', '9 3\n']","['3\n', '13\n']","In the first sample Vasya spends the first two days wearing the socks that he had initially. Then on day three he puts on the socks that were bought on day two.

In the second sample Vasya spends the first nine days wearing the socks that he had initially. Then he spends three days wearing the socks that were bought on the third, sixth and ninth days. Than he spends another day wearing the socks that were bought on the twelfth day.",WRONG_ANSWER,"def solve():
    n,m = list(map(int,input().split()))
    ans = n
    curr = 0
    while n:
        ans += n//m
        n //= m
        curr += n % m
    return ans + curr//m
print(solve())","def days_until_no_socks(n, m):
    days = 0
    while n > 0:
        days += 1
        n -= 1
        if days % m == 0:
            n += 1
    return days

input_data = input().strip()
n, m = map(int, input_data.split())

result = days_until_no_socks(n, m)
print(result)"
349,A,Cinema Line,PROGRAMMING,"['greedy', 'implementation']","The new ""Die Hard"" movie has just been released! There are *n* people at the cinema box office standing in a huge line. Each of them has a single 100, 50 or 25 ruble bill. A ""Die Hard"" ticket costs 25 rubles. Can the booking clerk sell a ticket to each person and give the change if he initially has no money and sells the tickets strictly in the order people follow in the line?","The first line contains integer *n* (1<=≤<=*n*<=≤<=105) — the number of people in the line. The next line contains *n* integers, each of them equals 25, 50 or 100 — the values of the bills the people have. The numbers are given in the order from the beginning of the line (at the box office) to the end of the line.","Print ""YES"" (without the quotes) if the booking clerk can sell a ticket to each person and give the change. Otherwise print ""NO"".","['4\n25 25 50 50\n', '2\n25 100\n', '4\n50 50 25 25\n']","['YES\n', 'NO\n', 'NO\n']",none,WRONG_ANSWER,"from collections import defaultdict
n = int(input()) 
a = [int(i) for i in input().split()] 
d = defaultdict(int) 
d[0] = 1
ans = ""YES""
for i in range(n): 
    if d[a[i] - 25] != 0: ans = ""NO"" ; break 
    d[a[i]-25]-=1
    d[a[i]] += 1
    
print(ans)","def can_sell_tickets(n, bills):

    count_25 = 0
    count_50 = 0
    
    for bill in bills:
        if bill == 25:
            count_25 += 1
        elif bill == 50:
            if count_25 > 0:
                count_25 -= 1
                count_50 += 1
            else:
                return ""NO""
        elif bill == 100:
            if count_50 > 0 and count_25 > 0:
                count_50 -= 1
                count_25 -= 1
            elif count_25 >= 3:
                count_25 -= 3
            else:
                return ""NO""
    
    return ""YES""

n = int(input().strip())
bills = list(map(int, input().strip().split()))

result = can_sell_tickets(n, bills)
print(result)"
540,A,Combination Lock,PROGRAMMING,['implementation'],"Scrooge McDuck keeps his most treasured savings in a home safe with a combination lock. Each time he wants to put there the treasures that he's earned fair and square, he has to open the lock.

The combination lock is represented by *n* rotating disks with digits from 0 to 9 written on them. Scrooge McDuck has to turn some disks so that the combination of digits on the disks forms a secret combination. In one move, he can rotate one disk one digit forwards or backwards. In particular, in one move he can go from digit 0 to digit 9 and vice versa. What minimum number of actions does he need for that?","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=1000) — the number of disks on the combination lock.

The second line contains a string of *n* digits — the original state of the disks.

The third line contains a string of *n* digits — Scrooge McDuck's combination that opens the lock.",Print a single integer — the minimum number of moves Scrooge McDuck needs to open the lock.,['5\n82195\n64723\n'],['13\n'],"In the sample he needs 13 moves:
 -  1 disk: <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/b8967f65a723782358b93eff9ce69f336817cf70.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> -  2 disk: <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/07fa58573ece0d32c4d555e498d2b24d2f70f36a.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> -  3 disk: <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/cc2275d9252aae35a6867c6a5b4ba7596e9a7626.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> -  4 disk: <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/b100aea470fcaaab4e9529b234ba0d7875943c10.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> -  5 disk: <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/eb2cbe4324cebca65b85816262a85e473cd65967.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>",OK,"def main():
    n = int(input())
    o = [int(c) for c in input()]
    a = [int(c) for c in input()]

    moves = 0
    for i in range(n):
        x, y = (o[i], a[i]) if o[i] > a[i] else (a[i], o[i])
        moves += min(x - y, y + 10 - x)

    print(moves)

if __name__ == ""__main__"":
    main()","n = int(input())

original = input().strip()

target = input().strip()

total_moves = 0

for i in range(n):

    orig_digit = int(original[i])
    target_digit = int(target[i])

    forward_distance = (target_digit - orig_digit) % 10
    backward_distance = (orig_digit - target_digit) % 10

    total_moves += min(forward_distance, backward_distance)

print(total_moves)"
581,C,Developing Skills,PROGRAMMING,"['implementation', 'math', 'sortings']","Petya loves computer games. Finally a game that he's been waiting for so long came out!

The main character of this game has *n* different skills, each of which is characterized by an integer *a**i* from 0 to 100. The higher the number *a**i* is, the higher is the *i*-th skill of the character. The total rating of the character is calculated as the sum of the values ​​of  for all *i* from 1 to *n*. The expression ⌊ *x*⌋ denotes the result of rounding the number *x* down to the nearest integer.

At the beginning of the game Petya got *k* improvement units as a bonus that he can use to increase the skills of his character and his total rating. One improvement unit can increase any skill of Petya's character by exactly one. For example, if *a*4<==<=46, after using one imporvement unit to this skill, it becomes equal to 47. A hero's skill cannot rise higher more than 100. Thus, it is permissible that some of the units will remain unused.

Your task is to determine the optimal way of using the improvement units so as to maximize the overall rating of the character. It is not necessary to use all the improvement units.","The first line of the input contains two positive integers *n* and *k* (1<=≤<=*n*<=≤<=105, 0<=≤<=*k*<=≤<=107) — the number of skills of the character and the number of units of improvements at Petya's disposal.

The second line of the input contains a sequence of *n* integers *a**i* (0<=≤<=*a**i*<=≤<=100), where *a**i* characterizes the level of the *i*-th skill of the character.",The first line of the output should contain a single non-negative integer — the maximum total rating of the character that Petya can get using *k* or less improvement units.,"['2 4\n7 9\n', '3 8\n17 15 19\n', '2 2\n99 100\n']","['2\n', '5\n', '20\n']","In the first test case the optimal strategy is as follows. Petya has to improve the first skill to 10 by spending 3 improvement units, and the second skill to 10, by spending one improvement unit. Thus, Petya spends all his improvement units and the total rating of the character becomes equal to  *lfloor* *frac*{100}{10} *rfloor* +  *lfloor* *frac*{100}{10} *rfloor* = 10 + 10 =  20.

In the second test the optimal strategy for Petya is to improve the first skill to 20 (by spending 3 improvement units) and to improve the third skill to 20 (in this case by spending 1 improvement units). Thus, Petya is left with 4 improvement units and he will be able to increase the second skill to 19 (which does not change the overall rating, so Petya does not necessarily have to do it). Therefore, the highest possible total rating in this example is <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/ccaa4e1e435ea3a339c322e03a32de69d214a257.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>.

In the third test case the optimal strategy for Petya is to increase the first skill to 100 by spending 1 improvement unit. Thereafter, both skills of the character will be equal to 100, so Petya will not be able to spend the remaining improvement unit. So the answer is equal to <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/b246630ca7d1b95b91970759bd8455cb3e930bf9.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>.",WRONG_ANSWER,"from os import path
from sys import stdin, stdout

filename = ""../templates/input.txt""
if path.exists(filename):
    stdin = open(filename, 'r')

def input():
    return stdin.readline().rstrip()

def print(*args, sep=' ', end='\n'):
    stdout.write(sep.join(map(str, args)))
    stdout.write(end)

def solution():
    n, k = [int(num) for num in input().split()]
    a = [int(num) for num in input().split()]
    a.sort(key=lambda x: 10 - x % 10)
    i = 0
    while i < n and k:
        x = min(k, 10 - a[i] % 10)
        a[i] += x
        k -= x
        i += 1
    ans = 0
    for ai in a:
        ans += ai // 10
    if k:
        y = sum(100 - ai for ai in a)
        ans += min(y // 10, k // 10)
    print(ans)

def main():
    t = 1
    while t:
        solution()
        t -= 1

if __name__ == '__main__':
    main()","def max_rating(n, k, skills):

    skills.sort()

    total_spent = 0

    total_rating = 0

    for i in range(n):
        if skills[i] < 100:

            required_units = 100 - skills[i]
            if total_spent + required_units <= k:

                total_spent += required_units
                total_rating += 100 // (i + 1)
            else:

                remaining_units = k - total_spent
                if remaining_units > 0:

                    skills[i] += remaining_units
                    total_rating += (100 // (i + 1))
                break
        else:
            total_rating += (100 // (i + 1))

    final_rating = sum(100 // (i + 1) for i in range(n))
    
    return final_rating

if __name__ == ""__main__"":
    import sys
    input = sys.stdin.read
    data = input().splitlines()

    n, k = map(int, data[0].split())

    skills = list(map(int, data[1].split()))

    result = max_rating(n, k, skills)

    print(result)"
939,A,Love Triangle,PROGRAMMING,['graphs'],"As you could know there are no male planes nor female planes. However, each plane on Earth likes some other plane. There are *n* planes on Earth, numbered from 1 to *n*, and the plane with number *i* likes the plane with number *f**i*, where 1<=≤<=*f**i*<=≤<=*n* and *f**i*<=≠<=*i*.

We call a love triangle a situation in which plane *A* likes plane *B*, plane *B* likes plane *C* and plane *C* likes plane *A*. Find out if there is any love triangle on Earth.","The first line contains a single integer *n* (2<=≤<=*n*<=≤<=5000) — the number of planes.

The second line contains *n* integers *f*1,<=*f*2,<=...,<=*f**n* (1<=≤<=*f**i*<=≤<=*n*, *f**i*<=≠<=*i*), meaning that the *i*-th plane likes the *f**i*-th.","Output «YES» if there is a love triangle consisting of planes on Earth. Otherwise, output «NO».

You can output any letter in lower case or in upper case.","['5\n2 4 5 1 3\n', '5\n5 5 5 5 1\n']","['YES\n', 'NO\n']","In first example plane 2 likes plane 4, plane 4 likes plane 1, plane 1 likes plane 2 and that is a love triangle.

In second example there are no love triangles.",OK,"from sys import stdin

def decide(dct):
    for i in dct.keys():
        if dct[dct[dct[i]]] == i:
            return 'YES'
    return 'NO'

def main():
    planes = int(stdin.readline().strip())
    edges = stdin.readline().strip().split()
    dct = {}
    for i in range(1, planes+1):
        dct[i] = int(edges[i-1])
    result = decide(dct)
    print(result)
main()","n = int(input())

likes = list(map(int, input().split()))

has_love_triangle = False

for i in range(1, n + 1):

    a = i
    b = likes[a - 1]
    c = likes[b - 1]

    if likes[c - 1] == a:
        has_love_triangle = True
        break

if has_love_triangle:
    print(""YES"")
else:
    print(""NO"")"
387,A,George and Sleep,PROGRAMMING,['implementation'],"George woke up and saw the current time *s* on the digital clock. Besides, George knows that he has slept for time *t*. 

Help George! Write a program that will, given time *s* and *t*, determine the time *p* when George went to bed. Note that George could have gone to bed yesterday relatively to the current time (see the second test sample).","The first line contains current time *s* as a string in the format ""hh:mm"". The second line contains time *t* in the format ""hh:mm"" — the duration of George's sleep. It is guaranteed that the input contains the correct time in the 24-hour format, that is, 00<=≤<=*hh*<=≤<=23, 00<=≤<=*mm*<=≤<=59.",In the single line print time *p* — the time George went to bed in the format similar to the format of the time in the input.,"['05:50\n05:44\n', '00:00\n01:00\n', '00:01\n00:00\n']","['00:06\n', '23:00\n', '00:01\n']","In the first sample George went to bed at ""00:06"". Note that you should print the time only in the format ""00:06"". That's why answers ""0:06"", ""00:6"" and others will be considered incorrect. 

In the second sample, George went to bed yesterday.

In the third sample, George didn't do to bed at all.",OK,"l_s = list(map(int, input().split("":"")))
l_t = list(map(int, input().split("":"")))

if l_t[1] > l_s[1]:
    l_s[0] -= 1
    
print(""%02d:%02d"" % ((l_s[0] - l_t[0]) % 24, (l_s[1] - l_t[1]) % 60))","def calculate_bed_time(s: str, t: str) -> str:

    current_hours, current_minutes = map(int, s.split(':'))

    sleep_hours, sleep_minutes = map(int, t.split(':'))

    current_total_minutes = current_hours * 60 + current_minutes

    sleep_total_minutes = sleep_hours * 60 + sleep_minutes

    bed_total_minutes = current_total_minutes - sleep_total_minutes

    if bed_total_minutes < 0:
        bed_total_minutes += 24 * 60

    bed_hours = bed_total_minutes // 60
    bed_minutes = bed_total_minutes % 60

    return f""{bed_hours:02}:{bed_minutes:02}""

import sys
input = sys.stdin.read
data = input().strip().split('\n')

for i in range(0, len(data), 2):
    s = data[i]
    t = data[i + 1]
    print(calculate_bed_time(s, t))"
803,B,Distances to Zero,PROGRAMMING,['constructive algorithms'],"You are given the array of integer numbers *a*0,<=*a*1,<=...,<=*a**n*<=-<=1. For each element find the distance to the nearest zero (to the element which equals to zero). There is at least one zero element in the given array.",The first line contains integer *n* (1<=≤<=*n*<=≤<=2·105) — length of the array *a*. The second line contains integer elements of the array separated by single spaces (<=-<=109<=≤<=*a**i*<=≤<=109).,"Print the sequence *d*0,<=*d*1,<=...,<=*d**n*<=-<=1, where *d**i* is the difference of indices between *i* and nearest *j* such that *a**j*<==<=0. It is possible that *i*<==<=*j*.","['9\n2 1 0 3 0 0 3 2 4\n', '5\n0 1 2 3 4\n', '7\n5 6 0 1 -2 3 4\n']","['2 1 0 1 0 0 1 2 3 ', '0 1 2 3 4 ', '2 1 0 1 2 3 4 ']",none,TIME_LIMIT_EXCEEDED,"n=int(input())
a=list(map(int,input().split()))
l=[]
def dist(b,l):
    mid=len(l)//2
    if(len(l)==1):
        return abs(b-l[0])
    elif(len(l)==2):
        return min(abs(b-l[0]),abs(b-l[1]))
    elif(b==l[mid]):
        return 0
    elif(b>l[mid]):
        return dist(b,l[mid:])
    else:
        return dist(b,l[0:mid+1])

for i in range(n):
    if(a[i]==0):
        l.append(i)
for i in range(n):
    a[i]=dist(i,l)
print(*a)","def nearest_zero_distance(n, a):

    distances = [float('inf')] * n

    last_zero = -1
    for i in range(n):
        if a[i] == 0:
            last_zero = i
            distances[i] = 0
        elif last_zero != -1:
            distances[i] = i - last_zero

    last_zero = -1
    for i in range(n - 1, -1, -1):
        if a[i] == 0:
            last_zero = i
        elif last_zero != -1:
            distances[i] = min(distances[i], last_zero - i)
    
    return distances

n = int(input().strip())
a = list(map(int, input().strip().split()))

result = nearest_zero_distance(n, a)

print(' '.join(map(str, result)))"
0,none,none,none,['none'],"Little Nastya has a hobby, she likes to remove some letters from word, to obtain another word. But it turns out to be pretty hard for her, because she is too young. Therefore, her brother Sergey always helps her.

Sergey gives Nastya the word *t* and wants to get the word *p* out of it. Nastya removes letters in a certain order (one after another, in this order strictly), which is specified by permutation of letters' indices of the word *t*: *a*1... *a*|*t*|. We denote the length of word *x* as |*x*|. Note that after removing one letter, the indices of other letters don't change. For example, if *t*<==<=""nastya"" and *a*<==<=[4,<=1,<=5,<=3,<=2,<=6] then removals make the following sequence of words ""nastya""  ""nastya""  ""nastya""  ""nastya""  ""nastya""  ""nastya""  ""nastya"".

Sergey knows this permutation. His goal is to stop his sister at some point and continue removing by himself to get the word *p*. Since Nastya likes this activity, Sergey wants to stop her as late as possible. Your task is to determine, how many letters Nastya can remove before she will be stopped by Sergey.

It is guaranteed that the word *p* can be obtained by removing the letters from word *t*.","The first and second lines of the input contain the words *t* and *p*, respectively. Words are composed of lowercase letters of the Latin alphabet (1<=≤<=|*p*|<=&lt;<=|*t*|<=≤<=200<=000). It is guaranteed that the word *p* can be obtained by removing the letters from word *t*.

Next line contains a permutation *a*1,<=*a*2,<=...,<=*a*|*t*| of letter indices that specifies the order in which Nastya removes letters of *t* (1<=≤<=*a**i*<=≤<=|*t*|, all *a**i* are distinct).","Print a single integer number, the maximum number of letters that Nastya can remove.","['ababcba\nabb\n5 3 4 1 7 6 2\n', 'bbbabb\nbb\n1 6 3 4 2 5\n']","['3', '4']","In the first sample test sequence of removing made by Nastya looks like this:

""ababcba"" <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> ""ababcba"" <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> ""ababcba"" <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> ""ababcba"" 

Nastya can not continue, because it is impossible to get word ""abb"" from word ""ababcba"".

So, Nastya will remove only three letters.",TIME_LIMIT_EXCEEDED,"t = input()
p = input()
aData = input()
a = [int(i) for i in aData.split()]

def removeChar(string, index):
    return string[:index] + string[index+1:]

def replaceChar(string, index, rep):
    return string[:index] + rep + string[index+1:]

ans = 0

for i in a:
    t = replaceChar(t, (i-1), ""X"")

    pChar = 0
    possible = False
    for j in t:
        if j == p[pChar]:
            pChar += 1
            if pChar >= len(p):
                possible = True
                break
    if possible:
        ans += 1
    else:
        break

print(ans)","def max_removals(t, p, a):
    n = len(t)
    m = len(p)

    removed = [False] * n

    for i in range(n):
        removed[a[i] - 1] = True

        current = ''.join(t[j] for j in range(n) if not removed[j])

        if current.startswith(p):
            continue
        else:
            return i
    
    return n

if __name__ == ""__main__"":
    t = input().strip()
    p = input().strip()
    a = list(map(int, input().strip().split()))

    result = max_removals(t, p, a)
    print(result)"
745,A,Hongcow Learns the Cyclic Shift,PROGRAMMING,"['implementation', 'strings']","Hongcow is learning to spell! One day, his teacher gives him a word that he needs to learn to spell. Being a dutiful student, he immediately learns how to spell the word.

Hongcow has decided to try to make new words from this one. He starts by taking the word he just learned how to spell, and moves the last character of the word to the beginning of the word. He calls this a cyclic shift. He can apply cyclic shift many times. For example, consecutively applying cyclic shift operation to the word ""abracadabra"" Hongcow will get words ""aabracadabr"", ""raabracadab"" and so on.

Hongcow is now wondering how many distinct words he can generate by doing the cyclic shift arbitrarily many times. The initial string is also counted.","The first line of input will be a single string *s* (1<=≤<=|*s*|<=≤<=50), the word Hongcow initially learns how to spell. The string *s* consists only of lowercase English letters ('a'–'z').",Output a single integer equal to the number of distinct strings that Hongcow can obtain by applying the cyclic shift arbitrarily many times to the given string.,"['abcd\n', 'bbb\n', 'yzyz\n']","['4\n', '1\n', '2\n']","For the first sample, the strings Hongcow can generate are ""abcd"", ""dabc"", ""cdab"", and ""bcda"".

For the second sample, no matter how many times Hongcow does the cyclic shift, Hongcow can only generate ""bbb"".

For the third sample, the two strings Hongcow can generate are ""yzyz"" and ""zyzy"".",OK,"s=input()
c={s}
def cyc(s2):return s2[-1]+s2[:-1]
for i in range(len(s)):
    s=cyc(s)
    c.add(s)
print(len(c))","def distinct_cyclic_shifts(s):

    shifts = set()

    n = len(s)

    for i in range(n):

        shifted = s[i:] + s[:i]

        shifts.add(shifted)

    return len(shifts)

input_strings = ['abcd\n', 'bbb\n', 'yzyz\n']

for input_str in input_strings:

    word = input_str.strip()

    result = distinct_cyclic_shifts(word)

    print(result)"
510,A,Fox And Snake,PROGRAMMING,['implementation'],"Fox Ciel starts to learn programming. The first task is drawing a fox! However, that turns out to be too hard for a beginner, so she decides to draw a snake instead.

A snake is a pattern on a *n* by *m* table. Denote *c*-th cell of *r*-th row as (*r*,<=*c*). The tail of the snake is located at (1,<=1), then it's body extends to (1,<=*m*), then goes down 2 rows to (3,<=*m*), then goes left to (3,<=1) and so on.

Your task is to draw this snake for Fox Ciel: the empty cells should be represented as dot characters ('.') and the snake cells should be filled with number signs ('#').

Consider sample tests in order to understand the snake pattern.","The only line contains two integers: *n* and *m* (3<=≤<=*n*,<=*m*<=≤<=50). 

*n* is an odd number.",Output *n* lines. Each line should contain a string consisting of *m* characters. Do not output spaces.,"['3 3\n', '3 4\n', '5 3\n', '9 9\n']","['###\n..#\n###\n', '####\n...#\n####\n', '###\n..#\n###\n#..\n###\n', '#########\n........#\n#########\n#........\n#########\n........#\n#########\n#........\n#########\n']",none,OK,"def Fox_and_Snake(r,c):
    next_ = 3
    next_2 = 1
    for i in range(r):
        for j in range(c):
            if i %2 == 0:
                print('
            else:
                if i == next_2 and j == (c-1):
                    print('
                    next_2 +=4
                elif i == next_ and j ==0:
                    print('
                    next_ +=4
                else :
                    print('.', end = '')
        print()
        
r, c = map( int, input().split())

Fox_and_Snake(r,c)","def draw_snake(n, m):

    grid = [['.' for _ in range(m)] for _ in range(n)]
    
    for i in range(n):
        if i % 2 == 0:

            for j in range(m):
                grid[i][j] = '
        else:

            if (i // 2) % 2 == 0:
                grid[i][m - 1] = '
            else:
                grid[i][0] = '

    for row in grid:
        print(''.join(row))

draw_snake(3, 3)
draw_snake(3, 4)
draw_snake(5, 3)
draw_snake(9, 9)"
242,B,Big Segment,PROGRAMMING,"['implementation', 'sortings']","A coordinate line has *n* segments, the *i*-th segment starts at the position *l**i* and ends at the position *r**i*. We will denote such a segment as [*l**i*,<=*r**i*].

You have suggested that one of the defined segments covers all others. In other words, there is such segment in the given set, which contains all other ones. Now you want to test your assumption. Find in the given set the segment which covers all other segments, and print its number. If such a segment doesn't exist, print -1.

Formally we will assume that segment [*a*,<=*b*] covers segment [*c*,<=*d*], if they meet this condition *a*<=≤<=*c*<=≤<=*d*<=≤<=*b*.","The first line contains integer *n* (1<=≤<=*n*<=≤<=105) — the number of segments. Next *n* lines contain the descriptions of the segments. The *i*-th line contains two space-separated integers *l**i*,<=*r**i* (1<=≤<=*l**i*<=≤<=*r**i*<=≤<=109) — the borders of the *i*-th segment.

It is guaranteed that no two segments coincide.","Print a single integer — the number of the segment that covers all other segments in the set. If there's no solution, print -1.

The segments are numbered starting from 1 in the order in which they appear in the input.","['3\n1 1\n2 2\n3 3\n', '6\n1 5\n2 3\n1 10\n7 10\n7 7\n10 10\n']","['-1\n', '3\n']",none,TIME_LIMIT_EXCEEDED,"a = []
b = []
def allseg(a,b):
    result = -1
    min_a = min(a)
    max_b = max(b)
    x = find_all(min_a,a)
    y = find_all(max_b,b)
    for i in range (len(x)):
        if x[i] in y:
            result = x[i]+1
            break
    return result

def find_all(n,str):
    result = []
    for i in range (len(str)):
        if str[i] == n:
            result.append(i)
    return result

t = int(input())
for i in range (t):
    seg = input().split()
    a.append(int(seg[0]))
    b.append(int(seg[1]))
result = allseg(a,b)
print (result)","def find_covering_segment(segments):

    min_l = float('inf')
    max_r = float('-inf')
    index = -1

    for i, (l, r) in enumerate(segments):

        if l < min_l:
            min_l = l
        if r > max_r:
            max_r = r

    for i, (l, r) in enumerate(segments):
        if l <= min_l and r >= max_r:
            return i + 1

    return -1

import sys

input_data = sys.stdin.read().splitlines()
n = int(input_data[0])
segments = [tuple(map(int, line.split())) for line in input_data[1:n+1]]

result = find_covering_segment(segments)

print(result)"
678,A,Johny Likes Numbers,PROGRAMMING,"['implementation', 'math']","Johny likes numbers *n* and *k* very much. Now Johny wants to find the smallest integer *x* greater than *n*, so it is divisible by the number *k*.","The only line contains two integers *n* and *k* (1<=≤<=*n*,<=*k*<=≤<=109).","Print the smallest integer *x*<=&gt;<=*n*, so it is divisible by the number *k*.","['5 3\n', '25 13\n', '26 13\n']","['6\n', '26\n', '39\n']",none,OK,"import sys,math
def isleap(y):
    if y%400==0:
        return True 
    elif y%4==0 and y%100!=0:
        return True 
    else:
        return False
n,k=map(int,sys.stdin.readline().split())
r=n%k 
if r==0:
    r+=k 
else:
    r=k-r 
print(n+r)","def smallest_divisible(n, k):

    x = n + 1

    while x % k != 0:
        x += 1
    return x

def main():
    import sys
    input_data = sys.stdin.read().strip().splitlines()
    output = []

    for line in input_data:
        n, k = map(int, line.split())

        result = smallest_divisible(n, k)
        output.append(str(result))

    print(""\n"".join(output))

if __name__ == ""__main__"":
    main()"
711,A,Bus to Udayland,PROGRAMMING,"['brute force', 'implementation']","ZS the Coder and Chris the Baboon are travelling to Udayland! To get there, they have to get on the special IOI bus. The IOI bus has *n* rows of seats. There are 4 seats in each row, and the seats are separated into pairs by a walkway. When ZS and Chris came, some places in the bus was already occupied.

ZS and Chris are good friends. They insist to get a pair of neighbouring empty seats. Two seats are considered neighbouring if they are in the same row and in the same pair. Given the configuration of the bus, can you help ZS and Chris determine where they should sit?","The first line of the input contains a single integer *n* (1<=≤<=*n*<=≤<=1000) — the number of rows of seats in the bus.

Then, *n* lines follow. Each line contains exactly 5 characters, the first two of them denote the first pair of seats in the row, the third character denotes the walkway (it always equals '|') and the last two of them denote the second pair of seats in the row. 

Each character, except the walkway, equals to 'O' or to 'X'. 'O' denotes an empty seat, 'X' denotes an occupied seat. See the sample cases for more details.","If it is possible for Chris and ZS to sit at neighbouring empty seats, print ""YES"" (without quotes) in the first line. In the next *n* lines print the bus configuration, where the characters in the pair of seats for Chris and ZS is changed with characters '+'. Thus the configuration should differ from the input one by exactly two charaters (they should be equal to 'O' in the input and to '+' in the output).

If there is no pair of seats for Chris and ZS, print ""NO"" (without quotes) in a single line.

If there are multiple solutions, you may print any of them.","['6\nOO|OX\nXO|XX\nOX|OO\nXX|OX\nOO|OO\nOO|XX\n', '4\nXO|OX\nXO|XX\nOX|OX\nXX|OX\n', '5\nXX|XX\nXX|XX\nXO|OX\nXO|OO\nOX|XO\n']","['YES\n++|OX\nXO|XX\nOX|OO\nXX|OX\nOO|OO\nOO|XX\n', 'NO\n', 'YES\nXX|XX\nXX|XX\nXO|OX\nXO|++\nOX|XO\n']","Note that the following is an incorrect configuration for the first sample case because the seats must be in the same pair.

O+|+X

XO|XX

OX|OO

XX|OX

OO|OO

OO|XX",WRONG_ANSWER,"import math
import os
import random
import re
import sys

def solve(n, matrix):
    aisle = '|'
    buddy_seats = 'OO'
    result = 'NO'

    for row_index, row in enumerate(matrix):
        for col_index, col in enumerate(row):
            pair = col.split(aisle)
            for seat_index, seat in enumerate(pair):
                if seat == buddy_seats:
                    matrix[row_index][col_index] = matrix[row_index][col_index].replace(
                        ""OO"", ""++""
                    )
                    result = 'YES'
                    return result

    return result

def print_seating_chart(matrix):
    """"""matrix is always 5 columns by `n` rows""""""
    for row in matrix:
        for col in row:
            print(col)

if __name__ == '__main__':
    n = int(input())
    matrix = []

    for index in range(n):
        matrix.append(list(map(str, input().split())))

    result = solve(n, matrix)
    print(result)
    if result == 'YES':
        print_seating_chart(matrix)","n = int(input())

bus = []

for _ in range(n):
    bus.append(input().strip())

found = False

for i in range(n):
    if bus[i][0:2] == 'OO':
        bus[i] = '++' + bus[i][2:]
        found = True
        break
    elif bus[i][3:5] == 'OO':
        bus[i] = bus[i][0:3] + '++'
        found = True
        break

if found:
    print(""YES"")
    for row in bus:
        print(row)
else:
    print(""NO"")"
762,A,k-th divisor,PROGRAMMING,"['math', 'number theory']","You are given two integers *n* and *k*. Find *k*-th smallest divisor of *n*, or report that it doesn't exist.

Divisor of *n* is any such natural number, that *n* can be divided by it without remainder.","The first line contains two integers *n* and *k* (1<=≤<=*n*<=≤<=1015, 1<=≤<=*k*<=≤<=109).","If *n* has less than *k* divisors, output -1.

Otherwise, output the *k*-th smallest divisor of *n*.","['4 2\n', '5 3\n', '12 5\n']","['2\n', '-1\n', '6\n']","In the first example, number 4 has three divisors: 1, 2 and 4. The second one is 2.

In the second example, number 5 has only two divisors: 1 and 5. The third divisor doesn't exist, so the answer is -1.",TIME_LIMIT_EXCEEDED,"import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,copy,functools

sys.setrecursionlimit(10**7)
inf = 10**20
eps = 1.0 / 10**10
mod = 998244353
dd = [(-1,0),(0,1),(1,0),(0,-1)]
ddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]

def LI(): return list(map(int, sys.stdin.readline().split()))
def LLI(): return [list(map(int, l.split())) for l in sys.stdin.readlines()]
def LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]
def LF(): return [float(x) for x in sys.stdin.readline().split()]
def LS(): return sys.stdin.readline().split()
def I(): return int(sys.stdin.readline())
def F(): return float(sys.stdin.readline())
def S(): return input()
def pf(s): return print(s, flush=True)
def pe(s): return print(str(s), file=sys.stderr)
def JA(a, sep): return sep.join(map(str, a))
def JAA(a, s, t): return s.join(t.join(map(str, b)) for b in a)

def divisions(n):
    sq = int(math.sqrt(n)+1)
    d = collections.defaultdict(int)
    while n % 2 == 0:
        n //= 2
        d[2] += 1
    i = 3
    while n > 1 and sq >= i:
        if n % i == 0:
            n //= i
            d[i] += 1
        else:
            i += 2

    if n > 1:
        d[n] += 1

    r = [1]
    for k, v in d.items():
        for c in r[:]:
            for i in range(1,v+1):
                r.append(c*(k**i))

    return sorted(r)

def main():
    n,k = LI()

    d = sorted(divisions(n))
    if len(d) < k:
        return -1

    return d[k-1]

print(main())","def kth_smallest_divisor(n, k):
    divisors = []

    for i in range(1, int(n**0.5) + 1):
        if n % i == 0:
            divisors.append(i)
            if i != n // i:
                divisors.append(n // i)
    
    divisors.sort()

    if len(divisors) < k:
        return -1
    else:
        return divisors[k - 1]

input_data = ['4 2', '5 3', '12 5']

results = []
for line in input_data:
    n, k = map(int, line.split())
    result = kth_smallest_divisor(n, k)
    results.append(result)

for res in results:
    print(res)"
621,A,Wet Shark and Odd and Even,PROGRAMMING,['implementation'],"Today, Wet Shark is given *n* integers. Using any of these integers no more than once, Wet Shark wants to get maximum possible even (divisible by 2) sum. Please, calculate this value for Wet Shark. 

Note, that if Wet Shark uses no integers from the *n* integers, the sum is an even integer 0.","The first line of the input contains one integer, *n* (1<=≤<=*n*<=≤<=100<=000). The next line contains *n* space separated integers given to Wet Shark. Each of these integers is in range from 1 to 109, inclusive.",Print the maximum possible even sum that can be obtained if we use some of the given integers.,"['3\n1 2 3\n', '5\n999999999 999999999 999999999 999999999 999999999\n']","['6', '3999999996']","In the first sample, we can simply take all three integers for a total sum of 6.

In the second sample Wet Shark should take any four out of five integers 999 999 999.",OK,"def isOdd (x):
	return x%2==1
def isEven (x):
	return x%2==0
input()
arr = [int(z) for z in input().split()]
oddA = list(filter(isOdd,arr))
oddA.sort()
evenSum = sum(filter(isEven,arr))
if(isOdd(len(oddA))):
	print(evenSum+sum(oddA[1:]))
else:
	print(evenSum+sum(oddA))","n = int(input())

numbers = list(map(int, input().split()))

total_sum = sum(numbers)

if total_sum % 2 == 0:

    print(total_sum)
else:

    smallest_odd = float('inf')
    
    for num in numbers:
        if num % 2 != 0:
            smallest_odd = min(smallest_odd, num)

    max_even_sum = total_sum - smallest_odd if smallest_odd != float('inf') else 0
    print(max_even_sum)"
105,C,Item World,PROGRAMMING,"['brute force', 'implementation', 'sortings']","Each item in the game has a level. The higher the level is, the higher basic parameters the item has. We shall consider only the following basic parameters: attack (atk), defense (def) and resistance to different types of impact (res).

Each item belongs to one class. In this problem we will only consider three of such classes: weapon, armor, orb.

Besides, there's a whole new world hidden inside each item. We can increase an item's level travelling to its world. We can also capture the so-called residents in the Item World

Residents are the creatures that live inside items. Each resident gives some bonus to the item in which it is currently located. We will only consider residents of types: gladiator (who improves the item's atk), sentry (who improves def) and physician (who improves res).

Each item has the size parameter. The parameter limits the maximum number of residents that can live inside an item. We can move residents between items. Within one moment of time we can take some resident from an item and move it to some other item if it has a free place for a new resident. We cannot remove a resident from the items and leave outside — any of them should be inside of some item at any moment of time.

Laharl has a certain number of items. He wants to move the residents between items so as to equip himself with weapon, armor and a defensive orb. The weapon's atk should be largest possible in the end. Among all equipping patterns containing weapon's maximum atk parameter we should choose the ones where the armor’s def parameter is the largest possible. Among all such equipment patterns we should choose the one where the defensive orb would have the largest possible res parameter. Values of the parameters def and res of weapon, atk and res of armor and atk and def of orb are indifferent for Laharl.

Find the optimal equipment pattern Laharl can get.","The first line contains number *n* (3<=≤<=*n*<=≤<=100) — representing how many items Laharl has.

Then follow *n* lines. Each line contains description of an item. The description has the following form: ""*name* *class* *atk* *def* *res* *size*"" — the item's name, class, basic attack, defense and resistance parameters and its size correspondingly. 
 -  *name* and *class* are strings and *atk*, *def*, *res* and *size* are integers. -  *name* consists of lowercase Latin letters and its length can range from 1 to 10, inclusive. -  *class* can be ""weapon"", ""armor"" or ""orb"". -  0<=≤<=*atk*,<=*def*,<=*res*<=≤<=1000. -  1<=≤<=*size*<=≤<=10. 
It is guaranteed that Laharl has at least one item of each class.

The next line contains an integer *k* (1<=≤<=*k*<=≤<=1000) — the number of residents.

Then *k* lines follow. Each of them describes a resident. A resident description looks like: ""*name* *type* *bonus* *home*"" — the resident's name, his type, the number of points the resident adds to the item's corresponding parameter and the name of the item which currently contains the resident. 
 -  *name*, *type* and *home* are strings and *bonus* is an integer. -  *name* consists of lowercase Latin letters and its length can range from 1 to 10, inclusive. -  *type* may be ""gladiator"", ""sentry"" or ""physician"". -  1<=≤<=*bonus*<=≤<=100. 
It is guaranteed that the number of residents in each item does not exceed the item's size.

The names of all items and residents are pairwise different.

All words and numbers in the input are separated by single spaces.","Print on the first line the name of the weapon in the optimal equipping pattern; then print the number of residents the weapon contains; then print the residents' names.

Print on the second and third lines in the same form the names of the armor and defensive orb as well as the residents they contain. 

Use single spaces for separation.

If there are several possible solutions, print any of them.","['4\nsword weapon 10 2 3 2\npagstarmor armor 0 15 3 1\niceorb orb 3 2 13 2\nlongbow weapon 9 1 2 1\n5\nmike gladiator 5 longbow\nbobby sentry 6 pagstarmor\npetr gladiator 7 iceorb\nteddy physician 6 sword\nblackjack sentry 8 sword\n', '4\nsword weapon 10 2 3 2\npagstarmor armor 0 15 3 1\niceorb orb 3 2 13 2\nlongbow weapon 9 1 2 1\n6\nmike gladiator 5 longbow\nbobby sentry 6 pagstarmor\npetr gladiator 7 iceorb\nteddy physician 6 sword\nblackjack sentry 8 sword\njoe physician 6 iceorb\n']","['sword 2 petr mike \npagstarmor 1 blackjack \niceorb 2 teddy bobby \n', 'longbow 1 mike \npagstarmor 1 bobby \niceorb 2 petr joe \n']","In the second sample we have no free space inside the items, therefore we cannot move the residents between them.",RUNTIME_ERROR,"def searchBest(iType, number, rType, countResidents):
    global items, equipped
    best = 0
    ret = None
    for item, params in items.items():
        if params[0] == iType:
            val = int(params[number])
            if countResidents:
                for resid in equipped[item]:
                    if resid[1] == rType:
                        val += int(resid[2])
            if val > best:
                best = val
                ret = item
    return ret

def printItem(item):
    global equipped
    print(item, len(equipped[item]), ' '.join([x[0] for x in equipped[item]]))

def searchFor(iType, number, might):
    global items, equipped
    pSum = [0]
    for x in might:
        pSum.append(pSum[-1] + int(x[2]))
    while len(pSum) < 11:
        pSum.append(pSum[-1])
    
    bestVal = 0
    for item, params in items.items():
        if params[0] == iType:
            val = int(params[number]) + pSum[int(params[4])]
            if val > bestVal:
                bestVal = val

    for item, params in items.items():
        if params[0] == iType:
            val = int(params[number]) + pSum[int(params[4])]
            if val == bestVal:
                equipped[item] = might[:int(params[4])]
                printItem(item)
                return None

n = int(input())
items = dict()
equipped = dict()
for i in range(n):
    t = tuple(input().split())
    items[t[0]] = t[1:]

k = int(input())
residents = [None for i in range(k)]
glads = dict()
for i in range(k):
    residents[i] = tuple(input().split())
    equipped[residents[i][3]] = equipped.get(residents[i][3], []) + [residents[i]]

canSwap = False
for name, val in equipped.items():
    if len(val) < int(items[name][4]):
        canSwap = True

if canSwap:
    glads = sorted([x for x in residents if x[1] == 'gladiator'], key = lambda x: -int(x[2]))
    sentries = sorted([x for x in residents if x[1] == 'sentry'], key = lambda x: -int(x[2]))
    phys = sorted([x for x in residents if x[1] == 'physician'], key = lambda x: -int(x[2]))

    searchFor('weapon', 1, glads)
    searchFor('armor', 2, sentries)
    searchFor('orb', 3, phys)
else:
    printItem(searchBest('weapon', 1, 'gladiator', True))
    printItem(searchBest('armor', 2, 'sentry', True))
    printItem(searchBest('orb', 3, 'physician', True))","class Item:
    def __init__(self, name, item_class, atk, defn, res, size):
        self.name = name
        self.item_class = item_class
        self.atk = atk
        self.defn = defn
        self.res = res
        self.size = size
        self.residents = []

    def add_resident(self, resident):
        if len(self.residents) < self.size:
            self.residents.append(resident)

    def total_atk(self):
        return self.atk + sum(r.bonus for r in self.residents if r.type == ""gladiator"")

    def total_def(self):
        return self.defn + sum(r.bonus for r in self.residents if r.type == ""sentry"")

    def total_res(self):
        return self.res + sum(r.bonus for r in self.residents if r.type == ""physician"")

class Resident:
    def __init__(self, name, r_type, bonus, home):
        self.name = name
        self.type = r_type
        self.bonus = bonus
        self.home = home

def find_optimal_equipment(items, residents):
    max_combination = None

    for weapon in items['weapon']:
        for armor in items['armor']:
            for orb in items['orb']:
                if max_combination is None or (
                    weapon.total_atk() > max_combination[0].total_atk() or
                    (weapon.total_atk() == max_combination[0].total_atk() and 
                     armor.total_def() > max_combination[1].total_def()) or
                    (weapon.total_atk() == max_combination[0].total_atk() and 
                     armor.total_def() == max_combination[1].total_def() and 
                     orb.total_res() > max_combination[2].total_res())
                ):
                    max_combination = (weapon, armor, orb)

    return max_combination

def main():
    import sys
    input = sys.stdin.read().strip().splitlines()

    n = int(input[0])
    items = {'weapon': [], 'armor': [], 'orb': []}

    for i in range(1, n + 1):
        name, item_class, atk, defn, res, size = input[i].split()
        items[item_class].append(Item(name, item_class, int(atk), int(defn), int(res), int(size)))

    k = int(input[n + 1])
    residents = {}

    for i in range(n + 2, n + 2 + k):
        name, r_type, bonus, home = input[i].split()
        bonus = int(bonus)
        resident = Resident(name, r_type, bonus, home)
        residents[name] = resident

        for item in items[home]:
            if item.name == home:
                item.add_resident(resident)

    optimal_items = find_optimal_equipment(items, residents)

    for item in optimal_items:
        print(f""{item.name} {len(item.residents)} {' '.join(r.name for r in item.residents)}"")

if __name__ == ""__main__"":
    main()"
1009,E,Intercity Travelling,PROGRAMMING,"['combinatorics', 'math', 'probabilities']","Leha is planning his journey from Moscow to Saratov. He hates trains, so he has decided to get from one city to another by car.

The path from Moscow to Saratov can be represented as a straight line (well, it's not that straight in reality, but in this problem we will consider it to be straight), and the distance between Moscow and Saratov is $n$ km. Let's say that Moscow is situated at the point with coordinate $0$ km, and Saratov — at coordinate $n$ km.

Driving for a long time may be really difficult. Formally, if Leha has already covered $i$ kilometers since he stopped to have a rest, he considers the difficulty of covering $(i + 1)$-th kilometer as $a_{i + 1}$. It is guaranteed that for every $i \in [1, n - 1]$ $a_i \le a_{i + 1}$. The difficulty of the journey is denoted as the sum of difficulties of each kilometer in the journey.

Fortunately, there may be some rest sites between Moscow and Saratov. Every integer point from $1$ to $n - 1$ may contain a rest site. When Leha enters a rest site, he may have a rest, and the next kilometer will have difficulty $a_1$, the kilometer after it — difficulty $a_2$, and so on.

For example, if $n = 5$ and there is a rest site in coordinate $2$, the difficulty of journey will be $2a_1 + 2a_2 + a_3$: the first kilometer will have difficulty $a_1$, the second one — $a_2$, then Leha will have a rest, and the third kilometer will have difficulty $a_1$, the fourth — $a_2$, and the last one — $a_3$. Another example: if $n = 7$ and there are rest sites in coordinates $1$ and $5$, the difficulty of Leha's journey is $3a_1 + 2a_2 + a_3 + a_4$.

Leha doesn't know which integer points contain rest sites. So he has to consider every possible situation. Obviously, there are $2^{n - 1}$ different distributions of rest sites (two distributions are different if there exists some point $x$ such that it contains a rest site in exactly one of these distributions). Leha considers all these distributions to be equiprobable. He wants to calculate $p$ — the expected value of difficulty of his journey.

Obviously, $p \cdot 2^{n - 1}$ is an integer number. You have to calculate it modulo $998244353$.","The first line contains one number $n$ ($1 \le n \le 10^6$) — the distance from Moscow to Saratov.

The second line contains $n$ integer numbers $a_1$, $a_2$, ..., $a_n$ ($1 \le a_1 \le a_2 \le \dots \le a_n \le 10^6$), where $a_i$ is the difficulty of $i$-th kilometer after Leha has rested.","Print one number — $p \cdot 2^{n - 1}$, taken modulo $998244353$.","['2\n1 2\n', '4\n1 3 3 7\n']","['5\n', '60\n']",none,TIME_LIMIT_EXCEEDED,"a = int(input())
b = list(map(int,input().split()))
def totDist(k):
    if k == 1:

        return b[0]
    else:
        c = 0
        for i in range(1,k):
            d = totDist(k-i)
            e = sum(b[:i])
            c += e*(2**(k-i-1))+d

        c += sum(b[:k])
        return c
print(totDist(a)%998244353)","MOD = 998244353

n = int(input().strip())
a = list(map(int, input().strip().split()))

power_of_2 = [1] * n
for i in range(1, n):
    power_of_2[i] = (power_of_2[i - 1] * 2) % MOD

expected_difficulty = 0
for i in range(n):
    expected_difficulty = (expected_difficulty + a[i] * power_of_2[i]) % MOD

print(expected_difficulty)"
235,A,LCM Challenge,PROGRAMMING,['number theory'],"Some days ago, I learned the concept of LCM (least common multiple). I've played with it for several times and I want to make a big number with it.

But I also don't want to use many numbers, so I'll choose three positive integers (they don't have to be distinct) which are not greater than *n*. Can you help me to find the maximum possible least common multiple of these three integers?",The first line contains an integer *n* (1<=≤<=*n*<=≤<=106) — the *n* mentioned in the statement.,Print a single integer — the maximum possible LCM of three not necessarily distinct positive integers that are not greater than *n*.,"['9\n', '7\n']","['504\n', '210\n']","The least common multiple of some positive integers is the least positive integer which is multiple for each of them.

The result may become very large, 32-bit integer won't be enough. So using 64-bit integers is recommended.

For the last example, we can chose numbers 7, 6, 5 and the LCM of them is 7·6·5 = 210. It is the maximum value we can get.",OK,"import math

def main():
    n = int(input())
    if n <= 3:
        ans = 1
        for i in range(1,n+1):
            ans *= i
        print(ans)
        return
    if n%2 == 0:

        if n%3 == 0:
            print((n-3)*(n-1)*(n-2))
        else:
            print(n*(n-1)*(n-3))
    else:
        print(n*(n-1)*(n-2))

main()","import sys
from math import gcd

def lcm(x, y):
    return x * y // gcd(x, y)

def max_lcm(n):
    if n == 1:
        return 1
    if n == 2:
        return 2
        
    max_l = 0

    for i in range(3):
        for j in range(3):
            for k in range(3):

                a = n - i
                b = n - j
                c = n - k
                if a > 0 and b > 0 and c > 0:
                    current_lcm = lcm(lcm(a, b), c)
                    max_l = max(max_l, current_lcm)
    
    return max_l

if __name__ == ""__main__"":
    n = int(sys.stdin.readline().strip())
    print(max_lcm(n))"
490,B,Queue,PROGRAMMING,"['dsu', 'implementation']","During the lunch break all *n* Berland State University students lined up in the food court. However, it turned out that the food court, too, has a lunch break and it temporarily stopped working.

Standing in a queue that isn't being served is so boring! So, each of the students wrote down the number of the student ID of the student that stands in line directly in front of him, and the student that stands in line directly behind him. If no one stands before or after a student (that is, he is the first one or the last one), then he writes down number 0 instead (in Berland State University student IDs are numerated from 1).

After that, all the students went about their business. When they returned, they found out that restoring the queue is not such an easy task.

Help the students to restore the state of the queue by the numbers of the student ID's of their neighbors in the queue.","The first line contains integer *n* (2<=≤<=*n*<=≤<=2·105) — the number of students in the queue. 

Then *n* lines follow, *i*-th line contains the pair of integers *a**i*,<=*b**i* (0<=≤<=*a**i*,<=*b**i*<=≤<=106), where *a**i* is the ID number of a person in front of a student and *b**i* is the ID number of a person behind a student. The lines are given in the arbitrary order. Value 0 is given instead of a neighbor's ID number if the neighbor doesn't exist.

The ID numbers of all students are distinct. It is guaranteed that the records correspond too the queue where all the students stand in some order.","Print a sequence of *n* integers *x*1,<=*x*2,<=...,<=*x**n* — the sequence of ID numbers of all the students in the order they go in the queue from the first student to the last one.",['4\n92 31\n0 7\n31 0\n7 141\n'],['92 7 31 141 \n'],The picture illustrates the queue for the first sample.,WRONG_ANSWER,"def get_int():
    return int(input())
def main():
    n = get_int()
    array = [0]*n
    right_hashmap = {} 
    left_hashmap = {}
    nums = set()
    for _ in range(n):
        left, right = list(map(int, input().split()))
        if left == 0:
            array[1] = right 
            continue 
        if right == 0:
            array[n - 2] = left 
            continue 
        right_hashmap[left] = right 
        left_hashmap[right] = left
        nums.add(left)
        nums.add(right)
    nums = list(nums)
    for index in range(len(nums)):
        left = index - 2
        right = index + 2 
        id = array[index]
        if id == 0:
            continue
        if left >= 0 and array[left] == 0:
            array[left] = left_hashmap[id]
        if right < n and array[right] == 0:
            array[right] = right_hashmap[id]
        
    print(*array)
main()","def restore_queue(n, neighbors):

    student_dict = {}

    for a, b in neighbors:
        student_dict[a] = (b if a != 0 else None, None)
        student_dict[b] = (None, a if b != 0 else None)

    head = None
    for a, b in neighbors:
        if a == 0:
            head = b
            break
        elif b == 0:
            head = a
            break

    queue = []
    current = head
    while current is not None:
        queue.append(current)
        front, back = student_dict[current]
        current = back
    
    return queue

n = int(input().strip())
neighbors = [tuple(map(int, input().strip().split())) for _ in range(n)]

result = restore_queue(n, neighbors)
print("" "".join(map(str, result)))"
47,B,Coins,PROGRAMMING,['implementation'],"One day Vasya came across three Berland coins. They didn't have any numbers that's why Vasya didn't understand how their denominations differ. He supposed that if one coin is heavier than the other one, then it should be worth more. Vasya weighed all the three pairs of coins on pan balance scales and told you the results. Find out how the deminations of the coins differ or if Vasya has a mistake in the weighting results. No two coins are equal.","The input data contains the results of all the weighting, one result on each line. It is guaranteed that every coin pair was weighted exactly once. Vasya labelled the coins with letters «A», «B» and «C». Each result is a line that appears as (letter)(&gt; or &lt; sign)(letter). For example, if coin ""A"" proved lighter than coin ""B"", the result of the weighting is A&lt;B.","It the results are contradictory, print Impossible. Otherwise, print without spaces the rearrangement of letters «A», «B» and «C» which represent the coins in the increasing order of their weights.","['A&gt;B\nC&lt;B\nA&gt;C\n', 'A&lt;B\nB&gt;C\nC&gt;A\n']","['CBA', 'ACB']",none,WRONG_ANSWER,"from operator import itemgetter
import sys
def get_single_int ():
    return int (sys.stdin.readline ().strip ())
def get_string ():
    return sys.stdin.readline ().strip ()
def get_ints ():
    return map (int, sys.stdin.readline ().strip ().split ())
def get_list ():
    return list (map (int, sys.stdin.readline ().strip ().split ()))

s = get_string ()
ss = get_string ()
sss = get_string ()
if s [1] == '<':
    s = s [2] + '>' + s [0]
if ss [1] == '<':
    ss = ss [2] + '>' + ss [0]
if sss [1] == '<':
    sss = sss [2] + '>' + sss [0]
ar = [s, ss, sss]
count_A = [0, 'A']
count_B = [0, 'B']
count_C = [0, 'C']
for i in ar:
    if i [0] == 'A':
        count_A [0] += 1
    if i [0] == 'B':
        count_B [0] += 1
    if i [0] == 'C':
        count_C [0] += 1
ans = sorted ([count_A, count_B, count_C], key=itemgetter (0))

string = ''
for i in ans:
    string += i [1]
print (string)","def determine_coin_order(weight_results):
    for result in weight_results:
        result = result.strip().splitlines()

        weight = {'A': 0, 'B': 0, 'C': 0}

        for res in result:
            if '>' in res:
                a, b = res.split('>')
                weight[a] += 1
            elif '<' in res:
                a, b = res.split('<')
                weight[b] += 1

        sorted_coins = sorted(weight.keys(), key=lambda x: weight[x])

        if (weight[sorted_coins[0]] == weight[sorted_coins[1]] or 
            weight[sorted_coins[1]] == weight[sorted_coins[2]]):
            return ""Impossible""
        
        return ''.join(sorted_coins)

input_data = ['A>B\nC<B\nA>C\n', 'A<B\nB>C\nC>A\n']

output = [determine_coin_order(data) for data in input_data]
print(output)"
41,A,Translation,PROGRAMMING,"['implementation', 'strings']","The translation from the Berland language into the Birland language is not an easy task. Those languages are very similar: a berlandish word differs from a birlandish word with the same meaning a little: it is spelled (and pronounced) reversely. For example, a Berlandish word code corresponds to a Birlandish word edoc. However, it's easy to make a mistake during the «translation». Vasya translated word *s* from Berlandish into Birlandish as *t*. Help him: find out if he translated the word correctly.","The first line contains word *s*, the second line contains word *t*. The words consist of lowercase Latin letters. The input data do not consist unnecessary spaces. The words are not empty and their lengths do not exceed 100 symbols.","If the word *t* is a word *s*, written reversely, print YES, otherwise print NO.","['code\nedoc\n', 'abb\naba\n', 'code\ncode\n']","['YES\n', 'NO\n', 'NO\n']",none,OK,"def reverse(s): 
  str1 = """" 
  for i in s: 
    str1 = i + str1
  return str1
s1=str(input())
s2=str(input())
rev=""""
rev=reverse(s1)
if s2==rev:
    print(""YES"")
else:
   print(""NO"")","def is_translation_correct(s, t):

    if t == s[::-1]:
        return ""YES""
    else:
        return ""NO""

s = input().strip()
t = input().strip()

print(is_translation_correct(s, t))"
899,C,Dividing the numbers,PROGRAMMING,"['constructive algorithms', 'graphs', 'math']","Petya has *n* integers: 1,<=2,<=3,<=...,<=*n*. He wants to split these integers in two non-empty groups in such a way that the absolute difference of sums of integers in each group is as small as possible. 

Help Petya to split the integers. Each of *n* integers should be exactly in one group.",The first line contains a single integer *n* (2<=≤<=*n*<=≤<=60<=000) — the number of integers Petya has.,"Print the smallest possible absolute difference in the first line.

In the second line print the size of the first group, followed by the integers in that group. You can print these integers in arbitrary order. If there are multiple answers, print any of them.","['4\n', '2\n']","['0\n2 1 4 \n', '1\n1 1 \n']","In the first example you have to put integers 1 and 4 in the first group, and 2 and 3 in the second. This way the sum in each group is 5, and the absolute difference is 0.

In the second example there are only two integers, and since both groups should be non-empty, you have to put one integer in the first group and one in the second. This way the absolute difference of sums of integers in each group is 1.",OK,"def generate_list_124(s, n):
    lst = []
    for i in range(s, int(n/2) + 1, 2):
        lst.append(i)
        lst.append(n-i+s)
    return lst

def generate_list_3(s, n):
    lst = []
    for i in range(s, int(n/2) - 1, 2):
        lst.append(i)
        lst.append(n-i+s)
    lst.append(int(n/2))
    return lst        

n = int(input())
            
mod = n % 4

if(mod == 0):
    print(0)
    print(int(n / 2), end=' ')
    print(*generate_list_124(1, n), sep=' ')
elif(mod == 1):
    print(1)
    print(int(n / 2), end=' ')
    print(*generate_list_124(2, n), sep=' ')
elif(mod == 2):
    print(1)
    print(int(n / 2), end=' ')
    print(*generate_list_3(1, n), sep=' ')
else:
    print(0)
    print(int(n / 2) + 1, end=' ')
    print(*generate_list_124(1, n-1), sep=' ')","def split_into_groups(n):
    total_sum = n * (n + 1) // 2
    target = total_sum // 2
    group1 = []
    group2 = []
    current_sum = 0

    for i in range(n, 0, -1):
        if current_sum + i <= target:
            group1.append(i)
            current_sum += i
        else:
            group2.append(i)

    abs_difference = abs((total_sum - current_sum) - current_sum)

    print(abs_difference)
    print(len(group1), ' '.join(map(str, group1)))

n = int(input().strip())
split_into_groups(n)"
744,A,Hongcow Builds A Nation,PROGRAMMING,"['dfs and similar', 'graphs']","Hongcow is ruler of the world. As ruler of the world, he wants to make it easier for people to travel by road within their own countries.

The world can be modeled as an undirected graph with *n* nodes and *m* edges. *k* of the nodes are home to the governments of the *k* countries that make up the world.

There is at most one edge connecting any two nodes and no edge connects a node to itself. Furthermore, for any two nodes corresponding to governments, there is no path between those two nodes. Any graph that satisfies all of these conditions is stable.

Hongcow wants to add as many edges as possible to the graph while keeping it stable. Determine the maximum number of edges Hongcow can add.","The first line of input will contain three integers *n*, *m* and *k* (1<=≤<=*n*<=≤<=1<=000, 0<=≤<=*m*<=≤<=100<=000, 1<=≤<=*k*<=≤<=*n*) — the number of vertices and edges in the graph, and the number of vertices that are homes of the government. 

The next line of input will contain *k* integers *c*1,<=*c*2,<=...,<=*c**k* (1<=≤<=*c**i*<=≤<=*n*). These integers will be pairwise distinct and denote the nodes that are home to the governments in this world.

The following *m* lines of input will contain two integers *u**i* and *v**i* (1<=≤<=*u**i*,<=*v**i*<=≤<=*n*). This denotes an undirected edge between nodes *u**i* and *v**i*.

It is guaranteed that the graph described by the input is stable.","Output a single integer, the maximum number of edges Hongcow can add to the graph while keeping it stable.","['4 1 2\n1 3\n1 2\n', '3 3 1\n2\n1 2\n1 3\n2 3\n']","['2\n', '0\n']","For the first sample test, the graph looks like this: 

For the second sample test, the graph looks like this:",WRONG_ANSWER,"import sys
input = sys.stdin.buffer.readline 

def findroot(roots, x):
    L = []
    while roots[x] != x:
        L.append(x)
        x = roots[x]
    for y in L:
        roots[y] = x
    return x

def process(n, G, C):
    g = [[] for i in range(n+1)]
    m = len(G)
    roots = [i for i in range(n+1)]
    for i in range(m):
        u, v = G[i]
        u1 = findroot(roots, u)
        v1 = findroot(roots, v)
        roots[u1] = v1
        g[u].append(v)
        g[v].append(u)
    root_dict = {}
    for i in range(1, n+1):
        i1 = findroot(roots, i)
        if i1 not in root_dict:
            root_dict[i1] = [0, 0]
        root_dict[i1][0]+=1
        root_dict[i1][1]+=len(g[i])
    answer = 0
    my_max = 0
    v0 = n
    e0 = m
    for c in C:
        c1 = roots[c]
        v1, e1 = root_dict[c1]
        e1 = e1//2

        answer+=(v1*(v1-1)//2-e1)
        my_max = max(my_max, v1)
        v0-=v1
        e0-=e1

    answer+=(v0*my_max)
    return answer
        
        
    
    
    
n, m, k = [int(x) for x in input().split()]
C = [int(x) for x in input().split()]
G = []
for i in range(m):
    u, v = [int(x) for x in input().split()]
    G.append([u, v])
print(process(n, G, C))","def max_edges(n, m, k, government_nodes, edges):

    gov_set = set(government_nodes)

    adj = {i: set() for i in range(1, n + 1)}

    for u, v in edges:
        adj[u].add(v)
        adj[v].add(u)

    max_additional_edges = 0

    for i in range(1, n + 1):
        if i in gov_set:
            continue
        for j in range(i + 1, n + 1):
            if j in gov_set or j in adj[i]:
                continue

            max_additional_edges += 1

    total_possible_edges = n * (n - 1) // 2

    return total_possible_edges - m - max_additional_edges

input_data = input().strip().split('\n')
n, m, k = map(int, input_data[0].split())
government_nodes = list(map(int, input_data[1].split()))
edges = [tuple(map(int, line.split())) for line in input_data[2:]]

result = max_edges(n, m, k, government_nodes, edges)
print(result)"
358,A,Dima and Continuous Line,PROGRAMMING,"['brute force', 'implementation']","Dima and Seryozha live in an ordinary dormitory room for two. One day Dima had a date with his girl and he asked Seryozha to leave the room. As a compensation, Seryozha made Dima do his homework.

The teacher gave Seryozha the coordinates of *n* distinct points on the abscissa axis and asked to consecutively connect them by semi-circus in a certain order: first connect the first point with the second one, then connect the second point with the third one, then the third one with the fourth one and so on to the *n*-th point. Two points with coordinates (*x*1,<=0) and (*x*2,<=0) should be connected by a semi-circle that passes above the abscissa axis with the diameter that coincides with the segment between points. Seryozha needs to find out if the line on the picture intersects itself. For clarifications, see the picture Seryozha showed to Dima (the left picture has self-intersections, the right picture doesn't have any).

Seryozha is not a small boy, so the coordinates of the points can be rather large. Help Dima cope with the problem.","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=103). The second line contains *n* distinct integers *x*1,<=*x*2,<=...,<=*x**n* (<=-<=106<=≤<=*x**i*<=≤<=106) — the *i*-th point has coordinates (*x**i*,<=0). The points are not necessarily sorted by their *x* coordinate.","In the single line print ""yes"" (without the quotes), if the line has self-intersections. Otherwise, print ""no"" (without the quotes).","['4\n0 10 5 15\n', '4\n0 15 5 10\n']","['yes\n', 'no\n']","The first test from the statement is on the picture to the left, the second test is on the picture to the right.",WRONG_ANSWER,"def checkint(a,b,c,d):
    check=0
    if (a<c<b<d) or (c<a<d<b):
        check=1
    return check

n=int(input())
lis=input().split()
for i in range(n):
    lis[i]=int(lis[i])
intersect=0
for i in range(n-1):
    for j in range(n-1):
        if checkint(lis[i],lis[i+1],lis[j],lis[j+1])==1:
            intersect=1
            print(i,j)
if intersect==0:
    print('no')
else:
    print('yes')","def has_self_intersections(n, points):

    sorted_points = sorted(points)

    def segments_intersect(p1, p2, p3, p4):

        def y_circle(x, p1, p2):
            return ((p2 - p1) ** 2 - (x - p1) ** 2) ** 0.5
        
        return (y_circle(p1, p3, p4) < 0 and y_circle(p2, p3, p4) < 0) or \
               (y_circle(p3, p1, p2) < 0 and y_circle(p4, p1, p2) < 0)

    for i in range(n):
        for j in range(i + 2, n):
            if i == 0 and j == n - 1:
                continue
            if segments_intersect(sorted_points[i], sorted_points[i + 1], 
                                  sorted_points[j], sorted_points[j + 1]):
                return ""yes""
    
    return ""no""

n = int(input().strip())
points = list(map(int, input().strip().split()))

print(has_self_intersections(n, points))"
771,A,Bear and Friendship Condition,PROGRAMMING,"['dfs and similar', 'dsu', 'graphs']","Bear Limak examines a social network. Its main functionality is that two members can become friends (then they can talk with each other and share funny pictures).

There are *n* members, numbered 1 through *n*. *m* pairs of members are friends. Of course, a member can't be a friend with themselves.

Let A-B denote that members A and B are friends. Limak thinks that a network is reasonable if and only if the following condition is satisfied: For every three distinct members (X, Y, Z), if X-Y and Y-Z then also X-Z.

For example: if Alan and Bob are friends, and Bob and Ciri are friends, then Alan and Ciri should be friends as well.

Can you help Limak and check if the network is reasonable? Print ""YES"" or ""NO"" accordingly, without the quotes.","The first line of the input contain two integers *n* and *m* (3<=≤<=*n*<=≤<=150<=000, ) — the number of members and the number of pairs of members that are friends.

The *i*-th of the next *m* lines contains two distinct integers *a**i* and *b**i* (1<=≤<=*a**i*,<=*b**i*<=≤<=*n*,<=*a**i*<=≠<=*b**i*). Members *a**i* and *b**i* are friends with each other. No pair of members will appear more than once in the input.","If the given network is reasonable, print ""YES"" in a single line (without the quotes). Otherwise, print ""NO"" in a single line (without the quotes).","['4 3\n1 3\n3 4\n1 4\n', '4 4\n3 1\n2 3\n3 4\n1 2\n', '10 4\n4 3\n5 10\n8 9\n1 2\n', '3 2\n1 2\n2 3\n']","['YES\n', 'NO\n', 'YES\n', 'NO\n']","The drawings below show the situation in the first sample (on the left) and in the second sample (on the right). Each edge represents two members that are friends. The answer is ""NO"" in the second sample because members (2, 3) are friends and members (3, 4) are friends, while members (2, 4) are not.",COMPILATION_ERROR,"using namespace std;
typedef long long ll;

class DSU {

public:
    int size;
    int components;
    vector<int> component_size;
    vector<int> id;

    DSU(int size) {
        this->size = size;
        this->components = size;
        this->component_size.resize(size, 1);
        this->id.resize(size);
        for(int i = 0; i < size; i++) {
            id[i] = i;
        }
    }

    int getSize() {
        return this->size;
    }

    int Find(int a) {
        int root = a;

        while(root != id[root]) {
            root = id[root];
        }

        while(a != root) {
            id[a] = root;
            a = id[a];
        }

        return root;
    }

    int Union(int a, int b) {
        int root_a = Find(a);
        int root_b = Find(b);

        if(root_a == root_b) {
            return root_a;
        } else {
            if (component_size[root_a] >= component_size[root_b]) {
                component_size[root_a] += component_size[id[root_b]];
                components--;
                return id[root_b] = root_a;
            } else {
                component_size[root_b] += component_size[id[root_a]];
                components--;
                return id[root_a] = root_b;
            }
        }
    }

    void Show() {
        for(int i=0; i<size; i++) {
            cout << i << ' ' << id[i] << endl;
        }
        cout << endl;
        for(int i=0; i<size; i++) {
            cout << i << ' ' << component_size[Find(i)] << endl;
        }
    }

};

void test();
int comb2(int n);

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    int t;
    t = 1;
//    cin >> t;
    while(t--) {
        test();
        cout << endl;
    }
}

void test() {
    int n, m;
    cin >> n >> m;
    DSU dsu(n);
    vector<bool> c(n, false);
    li(m) {
        int u, v;
        cin >> u >> v;
        u--; v--;
        dsu.Union(u, v);
    }
    int edges = 0;
    li(n) {
        int root = dsu.Find(i);
        if(!c[root]) {
            edges += comb2(dsu.component_size[root]);
            c[root] = true;
        }
    }
//    dsu.Show();
//    cout << edges << endl;
    cout << (edges == m ? ""YES"" : ""NO"");
}

int comb2(int n) {
    if(n < 2) {
        return 0;
    } else {
        return n * (n-1) / 2;
    }
}","def is_reasonable_network(n, m, friendships):

    friends = [set() for _ in range(n + 1)]

    for a, b in friendships:
        friends[a].add(b)
        friends[b].add(a)

    for x in range(1, n + 1):
        for y in friends[x]:
            for z in friends[y]:
                if z != x and z not in friends[x]:
                    return ""NO""
    return ""YES""

import sys
input = sys.stdin.read
data = input().splitlines()

n, m = map(int, data[0].split())
friendships = [tuple(map(int, line.split())) for line in data[1:m + 1]]

result = is_reasonable_network(n, m, friendships)
print(result)"
698,A,Vacations,PROGRAMMING,['dp'],"Vasya has *n* days of vacations! So he decided to improve his IT skills and do sport. Vasya knows the following information about each of this *n* days: whether that gym opened and whether a contest was carried out in the Internet on that day. For the *i*-th day there are four options:
 1.  on this day the gym is closed and the contest is not carried out; 1.  on this day the gym is closed and the contest is carried out; 1.  on this day the gym is open and the contest is not carried out; 1.  on this day the gym is open and the contest is carried out. 
On each of days Vasya can either have a rest or write the contest (if it is carried out on this day), or do sport (if the gym is open on this day).

Find the minimum number of days on which Vasya will have a rest (it means, he will not do sport and write the contest at the same time). The only limitation that Vasya has — he does not want to do the same activity on two consecutive days: it means, he will not do sport on two consecutive days, and write the contest on two consecutive days.","The first line contains a positive integer *n* (1<=≤<=*n*<=≤<=100) — the number of days of Vasya's vacations.

The second line contains the sequence of integers *a*1,<=*a*2,<=...,<=*a**n* (0<=≤<=*a**i*<=≤<=3) separated by space, where: 
 -  *a**i* equals 0, if on the *i*-th day of vacations the gym is closed and the contest is not carried out; -  *a**i* equals 1, if on the *i*-th day of vacations the gym is closed, but the contest is carried out; -  *a**i* equals 2, if on the *i*-th day of vacations the gym is open and the contest is not carried out; -  *a**i* equals 3, if on the *i*-th day of vacations the gym is open and the contest is carried out.","Print the minimum possible number of days on which Vasya will have a rest. Remember that Vasya refuses:
 -  to do sport on any two consecutive days, -  to write the contest on any two consecutive days.","['4\n1 3 2 0\n', '7\n1 3 3 2 1 2 3\n', '2\n2 2\n']","['2\n', '0\n', '1\n']","In the first test Vasya can write the contest on the day number 1 and do sport on the day number 3. Thus, he will have a rest for only 2 days.

In the second test Vasya should write contests on days number 1, 3, 5 and 7, in other days do sport. Thus, he will not have a rest for a single day.

In the third test Vasya can do sport either on a day number 1 or number 2. He can not do sport in two days, because it will be contrary to the his limitation. Thus, he will have a rest for only one day.",TIME_LIMIT_EXCEEDED,"n=int(input())
x=list(map(int,input().split()))
def solve(i,p=0):
    if i==n:
        return 0
    if x[i]==1 and p!=1:
        return solve(i+1,1)
    elif x[i]==2 and p!=2:
        return solve(i+1,2)
    elif x[i]==3:
        if p:
           return solve(i+1,[2,1][p-1])
        else:
            return min(solve(i+1,1),solve(i+1,2))
    else:
        return 1+min(solve(i+1,1),solve(i+1,2))
print(solve(0))","def calculate_rest_days(n, days):
    rest_days = 0
    last_activity = -1

    for i in range(n):
        if days[i] == 0:
            rest_days += 1
            last_activity = -1
        elif days[i] == 1:

            if last_activity == 1:
                rest_days += 1
                last_activity = 0
            else:
                last_activity = 1
        elif days[i] == 2:

            if last_activity == 0:
                rest_days += 1
                last_activity = 1
            else:
                last_activity = 0
        elif days[i] == 3:

            if last_activity in [0, 1]:
                last_activity = 1
            else:
                last_activity = 0

    return rest_days

def main():
    import sys
    input = sys.stdin.read
    data = input().strip().splitlines()

    results = []
    for i in range(0, len(data), 2):
        n = int(data[i])
        days = list(map(int, data[i + 1].split()))
        result = calculate_rest_days(n, days)
        results.append(f""{result}\n"")
    
    print(''.join(results))

if __name__ == ""__main__"":
    main()"
975,C,Valhalla Siege,PROGRAMMING,['binary search'],"Ivar the Boneless is a great leader. He is trying to capture Kattegat from Lagertha. The war has begun and wave after wave Ivar's warriors are falling in battle.

Ivar has $n$ warriors, he places them on a straight line in front of the main gate, in a way that the $i$-th warrior stands right after $(i-1)$-th warrior. The first warrior leads the attack.

Each attacker can take up to $a_i$ arrows before he falls to the ground, where $a_i$ is the $i$-th warrior's strength.

Lagertha orders her warriors to shoot $k_i$ arrows during the $i$-th minute, the arrows one by one hit the first still standing warrior. After all Ivar's warriors fall and all the currently flying arrows fly by, Thor smashes his hammer and all Ivar's warriors get their previous strengths back and stand up to fight again. In other words, if all warriors die in minute $t$, they will all be standing to fight at the end of minute $t$.

The battle will last for $q$ minutes, after each minute you should tell Ivar what is the number of his standing warriors.","The first line contains two integers $n$ and $q$ ($1 \le n, q \leq 200\,000$) — the number of warriors and the number of minutes in the battle.

The second line contains $n$ integers $a_1, a_2, \ldots, a_n$ ($1 \leq a_i \leq 10^9$) that represent the warriors' strengths.

The third line contains $q$ integers $k_1, k_2, \ldots, k_q$ ($1 \leq k_i \leq 10^{14}$), the $i$-th of them represents Lagertha's order at the $i$-th minute: $k_i$ arrows will attack the warriors.","Output $q$ lines, the $i$-th of them is the number of standing warriors after the $i$-th minute.","['5 5\n1 2 1 2 1\n3 10 1 1 1\n', '4 4\n1 2 3 4\n9 1 10 6\n']","['3\n5\n4\n4\n3\n', '1\n4\n4\n1\n']","In the first example: 
 -  after the 1-st minute, the 1-st and 2-nd warriors die. -  after the 2-nd minute all warriors die (and all arrows left over are wasted), then they will be revived thus answer is 5 — all warriors are alive. -  after the 3-rd minute, the 1-st warrior dies. -  after the 4-th minute, the 2-nd warrior takes a hit and his strength decreases by 1. -  after the 5-th minute, the 2-nd warrior dies.",OK,"def get_pos(curr, strength_left, arrow):
    l = curr
    h = n - 1

    while (l < h):
        m = (l + h) // 2
        strength_req = strength[m] - strength[curr] + strength_left
        if strength_req > arrow:
            h = m
        elif strength_req == arrow:
            return m
        else:
            if m == n - 1:
                return m
            l = m + 1

    return l

n, minutes = map(int, input().split())
strength = [int(x) for x in input().split()]
arrows = [int(x) for x in input().split()]
res = [0] * minutes

for i in range(1, n):
    strength[i] = strength[i] + strength[i - 1]

curr = 0
strength_left = strength[0]

for i in range(minutes):
    arrow = arrows[i]
    new_pos = get_pos(curr, strength_left, arrow)

    temp = strength[new_pos] - strength[curr] + strength_left

    if temp > arrow:
        curr = new_pos
        strength_left = temp - arrow
        res[i] = n - curr
    else:
        curr = (new_pos + 1) % n
        if curr:
            strength_left = strength[curr] - strength[curr - 1]
        else:
            strength_left = strength[curr]
        res[i] = n - curr

print(*res, sep='\n')","def battle_warriors(n, q, strengths, arrows):

    standing_warriors = n

    current_strength_index = 0

    cumulative_arrows = 0
    results = []

    for k in arrows:
        cumulative_arrows += k

        while current_strength_index < n and cumulative_arrows >= strengths[current_strength_index]:
            cumulative_arrows -= strengths[current_strength_index]
            standing_warriors -= 1
            current_strength_index += 1
        
        results.append(standing_warriors)
        
        if standing_warriors == 0:

            standing_warriors = n
            current_strength_index = 0
            cumulative_arrows = 0

    return results

input_data = ['5 5\n1 2 1 2 1\n3 10 1 1 1\n', '4 4\n1 2 3 4\n9 1 10 6\n']
for raw_input in input_data:
    lines = raw_input.strip().split('\n')
    n, q = map(int, lines[0].split())
    strengths = list(map(int, lines[1].split()))
    arrows = list(map(int, lines[2].split()))
    
    output = battle_warriors(n, q, strengths, arrows)
    print('\n'.join(map(str, output)))"
349,B,Color the Fence,PROGRAMMING,"['data structures', 'dp', 'greedy', 'implementation']","Igor has fallen in love with Tanya. Now Igor wants to show his feelings and write a number on the fence opposite to Tanya's house. Igor thinks that the larger the number is, the more chance to win Tanya's heart he has. 

Unfortunately, Igor could only get *v* liters of paint. He did the math and concluded that digit *d* requires *a**d* liters of paint. Besides, Igor heard that Tanya doesn't like zeroes. That's why Igor won't use them in his number.

Help Igor find the maximum number he can write on the fence.","The first line contains a positive integer *v* (0<=≤<=*v*<=≤<=106). The second line contains nine positive integers *a*1,<=*a*2,<=...,<=*a*9 (1<=≤<=*a**i*<=≤<=105).","Print the maximum number Igor can write on the fence. If he has too little paint for any digit (so, he cannot write anything), print -1.","['5\n5 4 3 2 1 2 3 4 5\n', '2\n9 11 1 12 5 8 9 10 6\n', '0\n1 1 1 1 1 1 1 1 1\n']","['55555\n', '33\n', '-1\n']",none,WRONG_ANSWER,"def paint(vLeft):
	if vLeft in dp:
		return dp[vLeft]

	if vLeft < minDigitCost:
		return ('', 0)
	
	max_ = 0
	for digit in range(9):
		if vLeft >= digitCost[digit]:
			temp = paint(vLeft%digitCost[digit])
			if temp[1] + vLeft//digitCost[digit] >= max_:
				max_ = temp[1] + vLeft//digitCost[digit]
				dp[vLeft] = (str(digit+1)*(vLeft//digitCost[digit]) + temp[0], vLeft//digitCost[digit] + temp[1])

	return dp[vLeft]

v = int(input())
digitCost = list(map(int, input().split()))
minDigitCost = min(digitCost)
dp = {}

ans = paint(v)
if ans[0]:
	print(int(ans[0]))
else:
	print(-1)","def max_number_with_paint(v, a):

    possible_digits = []

    for i in range(1, 10):
        if a[i - 1] <= v:
            possible_digits.append(i)

    if not possible_digits:
        return -1

    possible_digits.sort(key=lambda x: (a[x - 1], -x))

    result = []

    while v > 0:

        for digit in reversed(possible_digits):
            if v >= a[digit - 1]:
                result.append(str(digit))
                v -= a[digit - 1]
                break
        else:
            break

    return ''.join(result) if result else -1

v = int(input().strip())
a = list(map(int, input().strip().split()))

print(max_number_with_paint(v, a))"
505,C,"Mr. Kitayuta, the Treasure Hunter",PROGRAMMING,"['dfs and similar', 'dp', 'two pointers']","The Shuseki Islands are an archipelago of 30001 small islands in the Yutampo Sea. The islands are evenly spaced along a line, numbered from 0 to 30000 from the west to the east. These islands are known to contain many treasures. There are *n* gems in the Shuseki Islands in total, and the *i*-th gem is located on island *p**i*.

Mr. Kitayuta has just arrived at island 0. With his great jumping ability, he will repeatedly perform jumps between islands to the east according to the following process: 
 -  First, he will jump from island 0 to island *d*. -  After that, he will continue jumping according to the following rule. Let *l* be the length of the previous jump, that is, if his previous jump was from island *prev* to island *cur*, let *l*<==<=*cur*<=-<=*prev*. He will perform a jump of length *l*<=-<=1, *l* or *l*<=+<=1 to the east. That is, he will jump to island (*cur*<=+<=*l*<=-<=1), (*cur*<=+<=*l*) or (*cur*<=+<=*l*<=+<=1) (if they exist). The length of a jump must be positive, that is, he cannot perform a jump of length 0 when *l*<==<=1. If there is no valid destination, he will stop jumping. 
Mr. Kitayuta will collect the gems on the islands visited during the process. Find the maximum number of gems that he can collect.","The first line of the input contains two space-separated integers *n* and *d* (1<=≤<=*n*,<=*d*<=≤<=30000), denoting the number of the gems in the Shuseki Islands and the length of the Mr. Kitayuta's first jump, respectively.

The next *n* lines describe the location of the gems. The *i*-th of them (1<=≤<=*i*<=≤<=*n*) contains a integer *p**i* (*d*<=≤<=*p*1<=≤<=*p*2<=≤<=...<=≤<=*p**n*<=≤<=30000), denoting the number of the island that contains the *i*-th gem.",Print the maximum number of gems that Mr. Kitayuta can collect.,"['4 10\n10\n21\n27\n27\n', '8 8\n9\n19\n28\n36\n45\n55\n66\n78\n', '13 7\n8\n8\n9\n16\n17\n17\n18\n21\n23\n24\n24\n26\n30\n']","['3\n', '6\n', '4\n']","In the first sample, the optimal route is 0  →  10 (+1 gem)  →  19  →  27 (+2 gems)  → ...

In the second sample, the optimal route is 0  →  8  →  15  →  21 →  28 (+1 gem)  →  36 (+1 gem)  →  45 (+1 gem)  →  55 (+1 gem)  →  66 (+1 gem)  →  78 (+1 gem)  → ...

In the third sample, the optimal route is 0  →  7  →  13  →  18 (+1 gem)  →  24 (+2 gems)  →  30 (+1 gem)  → ...",WRONG_ANSWER,"n, d = map(int, input().split())

gems = set()
for i in range(n):
    p = int(input())
    gems.add(p)

dp = [[-1] * 501 for _ in range(30001)]

def collect_gems(x, y):

    if x > 30000 or not gems:
        return 0

    if dp[x][y] != -1:
        return dp[x][y]
    
    max_gems = 0

    for l in range(y-1, y+2):
        if l <= 0:
            continue

        next_island = x + l

        if next_island in gems:
            gems.remove(next_island)
            max_gems = max(max_gems, 1 + collect_gems(next_island, l))
            gems.add(next_island)

    dp[x][y] = max_gems
    
    return max_gems

print(collect_gems(d, d))","def max_gems_collected(n, d, gem_positions):

    gem_set = set(gem_positions)

    current_position = 0
    current_jump_length = d
    gems_collected = 0
    
    while True:

        next_positions = [
            current_position + current_jump_length - 1,
            current_position + current_jump_length,
            current_position + current_jump_length + 1
        ]

        visited_gems = 0
        for next_position in next_positions:
            if next_position in gem_set:
                visited_gems += 1

        if visited_gems > 0:
            gems_collected += visited_gems
            current_position += current_jump_length

            if current_jump_length > 1:

                current_jump_length = current_jump_length - 1

            current_jump_length = current_jump_length if current_jump_length > 1 else 1
        else:

            break
    
    return gems_collected

import sys

input_data = sys.stdin.read().strip().split('\n')
results = []

num_cases = len(input_data)
for i in range(num_cases):

    first_line = list(map(int, input_data[i * (n + 1)].split()))
    n = first_line[0]
    d = first_line[1]

    gem_positions = []
    for j in range(1, n + 1):
        gem_positions.append(int(input_data[i * (n + 1) + j]))

    result = max_gems_collected(n, d, gem_positions)
    results.append(str(result))

print('\n'.join(results))"
534,C,Polycarpus' Dice,PROGRAMMING,['math'],"Polycarp has *n* dice *d*1,<=*d*2,<=...,<=*d**n*. The *i*-th dice shows numbers from 1 to *d**i*. Polycarp rolled all the dice and the sum of numbers they showed is *A*. Agrippina didn't see which dice showed what number, she knows only the sum *A* and the values *d*1,<=*d*2,<=...,<=*d**n*. However, she finds it enough to make a series of statements of the following type: dice *i* couldn't show number *r*. For example, if Polycarp had two six-faced dice and the total sum is *A*<==<=11, then Agrippina can state that each of the two dice couldn't show a value less than five (otherwise, the remaining dice must have a value of at least seven, which is impossible).

For each dice find the number of values for which it can be guaranteed that the dice couldn't show these values if the sum of the shown values is *A*.","The first line contains two integers *n*,<=*A* (1<=≤<=*n*<=≤<=2·105,<=*n*<=≤<=*A*<=≤<=*s*) — the number of dice and the sum of shown values where *s*<==<=*d*1<=+<=*d*2<=+<=...<=+<=*d**n*.

The second line contains *n* integers *d*1,<=*d*2,<=...,<=*d**n* (1<=≤<=*d**i*<=≤<=106), where *d**i* is the maximum value that the *i*-th dice can show.","Print *n* integers *b*1,<=*b*2,<=...,<=*b**n*, where *b**i* is the number of values for which it is guaranteed that the *i*-th dice couldn't show them.","['2 8\n4 4\n', '1 3\n5\n', '2 3\n2 3\n']","['3 3 ', '4 ', '0 1 ']","In the first sample from the statement *A* equal to 8 could be obtained in the only case when both the first and the second dice show 4. Correspondingly, both dice couldn't show values 1, 2 or 3.

In the second sample from the statement *A* equal to 3 could be obtained when the single dice shows 3. Correspondingly, it couldn't show 1, 2, 4 or 5.

In the third sample from the statement *A* equal to 3 could be obtained when one dice shows 1 and the other dice shows 2. That's why the first dice doesn't have any values it couldn't show and the second dice couldn't show 3.",WRONG_ANSWER,"import sys
from math import *
from collections import Counter,defaultdict,deque
input=sys.stdin.readline
mod=10**9+7
def get_ints():return map(int,input().split())
def get_int():return int(input())
def get_array():return list(map(int,input().split()))
def input():return sys.stdin.readline().strip()

n,k=get_ints()
a=get_array()
s=sum(a)
for i in range(n):
    if s-a[i]>=k:
        print(0,end=' ')
    else:
        ran=[k-(s-a[i]),min(a[i],k-n+1)]

        print(a[i]-(ran[1]-ran[0]+1),end=' ')","def impossible_values(n, A, dice):

    impossible_counts = []

    for i in range(n):

        max_from_others = sum(dice[j] for j in range(i + 1, n))

        min_from_others = max(0, A - dice[i] - max_from_others)

        impossible_count = 0

        if A - min_from_others < 1:
            impossible_count += dice[i]
        else:
            impossible_count += max(0, dice[i] - (A - min_from_others))

        if A - max_from_others > dice[i]:
            impossible_count += max(0, A - max_from_others - dice[i])
        
        impossible_counts.append(impossible_count)

    return impossible_counts

input_data = ['2 8\n4 4\n', '1 3\n5\n', '2 3\n2 3\n']

for case in input_data:
    n, A = map(int, case.split()[0].split())
    dice = list(map(int, case.split()[1].split()))
    
    result = impossible_values(n, A, dice)
    print(' '.join(map(str, result)))"
448,B,Suffix Structures,PROGRAMMING,"['implementation', 'strings']","Bizon the Champion isn't just a bison. He also is a favorite of the ""Bizons"" team.

At a competition the ""Bizons"" got the following problem: ""You are given two distinct words (strings of English letters), *s* and *t*. You need to transform word *s* into word *t*"". The task looked simple to the guys because they know the suffix data structures well. Bizon Senior loves suffix automaton. By applying it once to a string, he can remove from this string any single character. Bizon Middle knows suffix array well. By applying it once to a string, he can swap any two characters of this string. The guys do not know anything about the suffix tree, but it can help them do much more. 

Bizon the Champion wonders whether the ""Bizons"" can solve the problem. Perhaps, the solution do not require both data structures. Find out whether the guys can solve the problem and if they can, how do they do it? Can they solve it either only with use of suffix automaton or only with use of suffix array or they need both structures? Note that any structure may be used an unlimited number of times, the structures may be used in any order.",The first line contains a non-empty word *s*. The second line contains a non-empty word *t*. Words *s* and *t* are different. Each word consists only of lowercase English letters. Each word contains at most 100 letters.,"In the single line print the answer to the problem. Print ""need tree"" (without the quotes) if word *s* cannot be transformed into word *t* even with use of both suffix array and suffix automaton. Print ""automaton"" (without the quotes) if you need only the suffix automaton to solve the problem. Print ""array"" (without the quotes) if you need only the suffix array to solve the problem. Print ""both"" (without the quotes), if you need both data structures to solve the problem.

It's guaranteed that if you can solve the problem only with use of suffix array, then it is impossible to solve it only with use of suffix automaton. This is also true for suffix automaton.","['automaton\ntomat\n', 'array\narary\n', 'both\nhot\n', 'need\ntree\n']","['automaton\n', 'array\n', 'both\n', 'need tree\n']","In the third sample you can act like that: first transform ""both"" into ""oth"" by removing the first character using the suffix automaton and then make two swaps of the string using the suffix array and get ""hot"".",OK,"def main():
	s = input()
	t = input()

	ans_list = ['automaton', 'array', 'both', 'need tree']

	ans = ''
	if s == t:
		ans = ans_list[0]
	elif sorted(s) == sorted(t):
		ans = ans_list[1]
	elif len(s) < len(t):
		ans = ans_list[3]

	if ans != '':
		print(ans)
		return

	ls = [0 for _ in range(26)]
	lt = ls.copy()

	for c in s:
		ls[ord(c) - ord('a')] += 1
	for c in t:
		lt[ord(c) - ord('a')] += 1

	chk = True
	for i in range(26):
		if ls[i] < lt[i]:
			chk = False

	if not chk:
		print(ans_list[3])
		return

	x, y, n, m = 0, 0, len(s), len(t)
	while y < m:
		while x < n:
			x += 1
			if s[x-1] == t[y]:
				y += 1
				break
		if x == n:
			break

	if y < m:
		print(ans_list[2])
	else:
		print(ans_list[0])

if __name__ == '__main__':
	main()","def can_transform(s, t):
    len_s = len(s)
    len_t = len(t)

    def is_subsequence(s, t):
        iter_s = iter(s)
        return all(char in iter_s for char in t)

    if is_subsequence(s, t):
        return ""automaton""

    if sorted(s) == sorted(t):
        return ""both""

    if all(s.count(char) >= t.count(char) for char in set(t)):
        return ""array""

    return ""need tree""

input_data = ['automaton\ntomat\n', 'array\narary\n', 'both\nhot\n', 'need\ntree\n']
results = []

for data in input_data:
    s, t = data.strip().split('\n')
    result = can_transform(s, t)
    results.append(result)

for result in results:
    print(result)"
709,A,Juicer,PROGRAMMING,['implementation'],"Kolya is going to make fresh orange juice. He has *n* oranges of sizes *a*1,<=*a*2,<=...,<=*a**n*. Kolya will put them in the juicer in the fixed order, starting with orange of size *a*1, then orange of size *a*2 and so on. To be put in the juicer the orange must have size not exceeding *b*, so if Kolya sees an orange that is strictly greater he throws it away and continues with the next one.

The juicer has a special section to collect waste. It overflows if Kolya squeezes oranges of the total size strictly greater than *d*. When it happens Kolya empties the waste section (even if there are no more oranges) and continues to squeeze the juice. How many times will he have to empty the waste section?","The first line of the input contains three integers *n*, *b* and *d* (1<=≤<=*n*<=≤<=100<=000, 1<=≤<=*b*<=≤<=*d*<=≤<=1<=000<=000) — the number of oranges, the maximum size of the orange that fits in the juicer and the value *d*, which determines the condition when the waste section should be emptied.

The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=1<=000<=000) — sizes of the oranges listed in the order Kolya is going to try to put them in the juicer.",Print one integer — the number of times Kolya will have to empty the waste section.,"['2 7 10\n5 6\n', '1 5 10\n7\n', '3 10 10\n5 7 7\n', '1 1 1\n1\n']","['1\n', '0\n', '1\n', '0\n']","In the first sample, Kolya will squeeze the juice from two oranges and empty the waste section afterwards.

In the second sample, the orange won't fit in the juicer so Kolya will have no juice at all.",OK,"def main():
    n,b,d = input().split()
    n = int(n)
    b = int(b)
    d = int(d)
    arr = list(map(int, input().split()))
    total = 0
    count = 0
    for j in arr:
        if j <= b:
            total += j
            if total > d:
                count += 1
                total = 0
    print(count)
main()","n, b, d = map(int, input().split())

sizes = list(map(int, input().split()))

total_waste = 0
empty_count = 0

for size in sizes:

    if size <= b:
        total_waste += size

        if total_waste > d:
            empty_count += 1
            total_waste = 0

print(empty_count)"
558,B,Amr and The Large Array,PROGRAMMING,['implementation'],"Amr has got a large array of size *n*. Amr doesn't like large arrays so he intends to make it smaller.

Amr doesn't care about anything in the array except the beauty of it. The beauty of the array is defined to be the maximum number of times that some number occurs in this array. He wants to choose the smallest subsegment of this array such that the beauty of it will be the same as the original array.

Help Amr by choosing the smallest subsegment possible.","The first line contains one number *n* (1<=≤<=*n*<=≤<=105), the size of the array.

The second line contains *n* integers *a**i* (1<=≤<=*a**i*<=≤<=106), representing elements of the array.","Output two integers *l*,<=*r* (1<=≤<=*l*<=≤<=*r*<=≤<=*n*), the beginning and the end of the subsegment chosen respectively.

If there are several possible answers you may output any of them.","['5\n1 1 2 2 1\n', '5\n1 2 2 3 1\n', '6\n1 2 2 1 1 2\n']","['1 5', '2 3', '1 5']","A subsegment *B* of an array *A* from *l* to *r* is an array of size *r* - *l* + 1 where *B*<sub class=""lower-index"">*i*</sub> = *A*<sub class=""lower-index"">*l* + *i* - 1</sub> for all 1 ≤ *i* ≤ *r* - *l* + 1",OK,"def bin_search(n,a):
    l = 0
    r = len(a)-1
    while l<=r:
        m = (l+r)//2
        if n>a[m][0]:
            l = m+1
        if n<a[m][0]:
            r = m-1
        if n == a[m][0]:
            return m
    return -1
n = int(input())
a = input().split()
def ke(n):
    return n[1]
def f(n):
    return abs(n[2]-n[3])
cnt = {}
mx = 0
for i in range(n):
    a[i] = int(a[i])
    if a[i] in cnt:
        cnt[a[i]][1] += 1
        cnt[a[i]][3] = i
    else:
        cnt[a[i]] = [a[i],1,i,0]
for m in cnt.values():
    if m[1]>mx:
        mx = m[1]
v = []
for m in cnt.values():
    if m[1]==mx:
        v.append(m)
v.sort(key=f)
print(v[0][2]+1,v[0][3]+1)","def find_smallest_subsegment(n, arr):

    count = {}

    first_occurrence = {}
    last_occurrence = {}

    for i in range(n):
        num = arr[i]
        if num not in count:
            count[num] = 0
            first_occurrence[num] = i
        count[num] += 1
        last_occurrence[num] = i

    max_beauty = max(count.values())

    best_l = 0
    best_r = n - 1
    smallest_length = n + 1

    for num in count:
        if count[num] == max_beauty:
            l = first_occurrence[num]
            r = last_occurrence[num]
            if (r - l < smallest_length):
                smallest_length = r - l
                best_l = l
                best_r = r

    return best_l + 1, best_r + 1

n = int(input())
arr = list(map(int, input().split()))

result = find_smallest_subsegment(n, arr)
print(result[0], result[1])"
678,D,Iterated Linear Function,PROGRAMMING,"['math', 'number theory']","Consider a linear function *f*(*x*)<==<=*Ax*<=+<=*B*. Let's define *g*(0)(*x*)<==<=*x* and *g*(*n*)(*x*)<==<=*f*(*g*(*n*<=-<=1)(*x*)) for *n*<=&gt;<=0. For the given integer values *A*, *B*, *n* and *x* find the value of *g*(*n*)(*x*) modulo 109<=+<=7.","The only line contains four integers *A*, *B*, *n* and *x* (1<=≤<=*A*,<=*B*,<=*x*<=≤<=109,<=1<=≤<=*n*<=≤<=1018) — the parameters from the problem statement.

Note that the given value *n* can be too large, so you should use 64-bit integer type to store it. In C++ you can use the long long integer type and in Java you can use long integer type.",Print the only integer *s* — the value *g*(*n*)(*x*) modulo 109<=+<=7.,"['3 4 1 1\n', '3 4 2 1\n', '3 4 3 1\n']","['7\n', '25\n', '79\n']",none,COMPILATION_ERROR,"using namespace std;
ll mod_pow(ll a,ll b,ll mod){
ll ans=1ll;
while(b){
if(b&1)ans=ans*a%mod;
a=a*a%mod;
b>>=1;
}
return ans;
}
ll a,b,n,x;
int main(){
scanf(""%lld%lld%lld%lld"",&a,&b,&x,&n);
/**(a^n)*x+b*((a^n)-1)/(a-1);**/

}
/**
0:x
1:a*x+b*(1);
2:a*(a*x+b)+b=(a*a*x)+a*b+b=(a*a*x)+(b*(a+1));
3:a*((a*a*x)+b*(a+1))+b=(a*a*a*x)+a*b*(a+1)+b=(a*a*a*x)+b*(a*(a+1)+1)=(a*a*a*x)+b*((a^2)+a+1);
(a^n)*x+b*(sigma(a^n-1));
(a^n)*x+b*((a^n)-1)/(a-1);
ex:
a=3 b=4 x=1 n=1
a=3 b=4 x=2 n=1

3*1+ 4* (3-1)/2= 7
/////////////////////////////
(2^(n+1))
81-40=41;
1+3+9+27=((3^4)-1/2);
1+4+16+64=(4^4-1/3);
**/","def g(n, x, A, B):

    if n == 0:
        return x
    else:

        return (A * g(n - 1, x, A, B) + B) % (10**9 + 7)

def main():
    import sys

    A, B, n, x = map(int, sys.stdin.readline().strip().split())

    result = g(n, x, A, B)

    print(result)

if __name__ == ""__main__"":
    main()"
411,C,Kicker,PROGRAMMING,['implementation'],"Kicker (table football) is a board game based on football, in which players control the footballers' figures mounted on rods by using bars to get the ball into the opponent's goal. When playing two on two, one player of each team controls the goalkeeper and the full-backs (plays defence), the other player controls the half-backs and forwards (plays attack).

Two teams of company Q decided to battle each other. Let's enumerate players from both teams by integers from 1 to 4. The first and second player play in the first team, the third and the fourth one play in the second team. For each of the four players we know their game skills in defence and attack. The defence skill of the *i*-th player is *a**i*, the attack skill is *b**i*.

Before the game, the teams determine how they will play. First the players of the first team decide who will play in the attack, and who will play in the defence. Then the second team players do the same, based on the choice of their opponents.

We will define a team's defence as the defence skill of player of the team who plays defence. Similarly, a team's attack is the attack skill of the player of the team who plays attack. We assume that one team is guaranteed to beat the other one, if its defence is strictly greater than the opponent's attack and its attack is strictly greater than the opponent's defence.

The teams of company Q know each other's strengths and therefore arrange their teams optimally. Identify the team that is guaranteed to win (if both teams act optimally) or tell that there is no such team.","The input contain the players' description in four lines. The *i*-th line contains two space-separated integers *a**i* and *b**i* (1<=≤<=*a**i*,<=*b**i*<=≤<=100) — the defence and the attack skill of the *i*-th player, correspondingly.","If the first team can win, print phrase ""Team 1"" (without the quotes), if the second team can win, print phrase ""Team 2"" (without the quotes). If no of the teams can definitely win, print ""Draw"" (without the quotes).","['1 100\n100 1\n99 99\n99 99\n', '1 1\n2 2\n3 3\n2 2\n', '3 3\n2 2\n1 1\n2 2\n']","['Team 1\n', 'Team 2\n', 'Draw\n']","Let consider the first test sample. The first team can definitely win if it will choose the following arrangement: the first player plays attack, the second player plays defence.

Consider the second sample. The order of the choosing roles for players makes sense in this sample. As the members of the first team choose first, the members of the second team can beat them (because they know the exact defence value and attack value of the first team).",OK,"p11 = list(map(int, input().split()))
p12 = list(map(int, input().split()))
p21 = list(map(int, input().split()))
p22 = list(map(int, input().split()))

def f(a, b, c, d):
    if a[0] > d[1] and b[1] > c[0]:
        return 1
    if a[0] < d[1] and b[1] < c[0]:
        return 2
    return 0

c1 = f(p11, p12, p21, p22)
c2 = f(p12, p11, p21, p22)
c3 = f(p11, p12, p22, p21)
c4 = f(p12, p11, p22, p21)

if ((c1 == 2 or c3 == 2) and (c2 == 2 or c4 == 2)):
    print(""Team 2"")
elif ((c1 == 1 and c3 == 1) or (c2 == 1 and c4 == 1)):
    print(""Team 1"")
else:
    print(""Draw"")","def determine_winner(players):

    a1, b1 = players[0]
    a2, b2 = players[1]
    a3, b3 = players[2]
    a4, b4 = players[3]

    team1_combinations = [(a1, b2), (a2, b1)]
    team2_combinations = [(a3, b4), (a4, b3)]

    team1_can_win = False
    team2_can_win = False

    for (def1, att1) in team1_combinations:
        for (def2, att2) in team2_combinations:
            if def1 > att2 and att1 > def2:
                team1_can_win = True
            if def2 > att1 and att2 > def1:
                team2_can_win = True

    if team1_can_win and not team2_can_win:
        return ""Team 1""
    elif team2_can_win and not team1_can_win:
        return ""Team 2""
    else:
        return ""Draw""

input_data = ['1 100\n100 1\n99 99\n99 99\n', '1 1\n2 2\n3 3\n2 2\n', '3 3\n2 2\n1 1\n2 2\n']
results = []

for data in input_data:
    lines = data.strip().split(""\n"")
    players = [tuple(map(int, line.split())) for line in lines]
    results.append(determine_winner(players))

for result in results:
    print(result)"
26,A,Almost Prime,PROGRAMMING,['number theory'],"A number is called almost prime if it has exactly two distinct prime divisors. For example, numbers 6, 18, 24 are almost prime, while 4, 8, 9, 42 are not. Find the amount of almost prime numbers which are between 1 and *n*, inclusive.",Input contains one integer number *n* (1<=≤<=*n*<=≤<=3000).,"Output the amount of almost prime numbers between 1 and *n*, inclusive.","['10\n', '21\n']","['2\n', '8\n']",none,OK,"def main():
    N=int(input())
    ans=0
    for j in range(1,N+1):
        i=2
        num=j
        count=0
        while(num!=1):
            if(num%i==0):
                count+=1
                while(num%i==0):
                    num//=i
            i+=1
        if count==2:
            ans+=1
    print(ans)
if __name__=='__main__':
    main()","def is_prime(num):
    """"""Check if a number is prime.""""""
    if num < 2:
        return False
    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            return False
    return True

def count_distinct_prime_factors(num):
    """"""Count the distinct prime factors of a number.""""""
    count = 0
    for i in range(2, num + 1):
        if is_prime(i) and num % i == 0:
            count += 1
        if count > 2:
            break
    return count

def count_almost_primes(n):
    """"""Count almost prime numbers between 1 and n, inclusive.""""""
    almost_prime_count = 0
    for num in range(1, n + 1):
        if count_distinct_prime_factors(num) == 2:
            almost_prime_count += 1
    return almost_prime_count

if __name__ == ""__main__"":
    import sys
    input_data = sys.stdin.read().strip().split()
    results = []
    for line in input_data:
        n = int(line)
        results.append(str(count_almost_primes(n)))
    print(""\n"".join(results))"
932,B,Recursive Queries,PROGRAMMING,"['binary search', 'data structures', 'dfs and similar']","Let us define two functions *f* and *g* on positive integer numbers. 

 

You need to process *Q* queries. In each query, you will be given three integers *l*, *r* and *k*. You need to print the number of integers *x* between *l* and *r* inclusive, such that *g*(*x*)<==<=*k*.","The first line of the input contains an integer *Q* (1<=≤<=*Q*<=≤<=2<=×<=105) representing the number of queries. 

*Q* lines follow, each of which contains 3 integers *l*, *r* and *k* (1<=≤<=*l*<=≤<=*r*<=≤<=106,<=1<=≤<=*k*<=≤<=9).","For each query, print a single line containing the answer for that query.","['4\n22 73 9\n45 64 6\n47 55 7\n2 62 4\n', '4\n82 94 6\n56 67 4\n28 59 9\n39 74 4\n']","['1\n4\n0\n8\n', '3\n1\n1\n5\n']","In the first example:
 -  *g*(33) = 9 as *g*(33) = *g*(3 × 3) = *g*(9) = 9 -  *g*(47) = *g*(48) = *g*(60) = *g*(61) = 6 -  There are no such integers between 47 and 55. -  *g*(4) = *g*(14) = *g*(22) = *g*(27) = *g*(39) = *g*(40) = *g*(41) = *g*(58) = 4",TIME_LIMIT_EXCEEDED,"from functools import reduce, lru_cache

max = int(10e6 + 5)

def gen(l, r, k):
    for i in range(l, r+1):
        yield 1 if g(i) == k else 0

def main():
    q = int(input())
    for _ in range(q):
        l, r, k = (int(x) for x in input().split())
        s = sum(gen(l, r, k))
        print(s)

def f(n):
    return reduce((lambda x,y: int(x) if int(y) == 0 else int(x)*int(y)), str(n))

@lru_cache(maxsize=max)
def g(n):
    if n < 10:
        return n
    return g(f(n))

if __name__ == ""__main__"":
    main()","def g(x):

    while x >= 10:
        x = sum(int(d) for d in str(x))
    return x

def process_queries(queries):
    results = []

    for l, r, k in queries:
        count = 0

        for x in range(l, r + 1):
            if g(x) <= k:
                count += 1
        results.append(count)
    return results

def main():
    import sys
    input = sys.stdin.read
    data = input().splitlines()
    
    Q = int(data[0])
    queries = []

    for i in range(1, Q + 1):
        l, r, k = map(int, data[i].split())
        queries.append((l, r, k))
    
    results = process_queries(queries)

    for result in results:
        print(result)

if __name__ == ""__main__"":
    main()"
1,A,Theatre Square,PROGRAMMING,['math'],"Theatre Square in the capital city of Berland has a rectangular shape with the size *n*<=×<=*m* meters. On the occasion of the city's anniversary, a decision was taken to pave the Square with square granite flagstones. Each flagstone is of the size *a*<=×<=*a*.

What is the least number of flagstones needed to pave the Square? It's allowed to cover the surface larger than the Theatre Square, but the Square has to be covered. It's not allowed to break the flagstones. The sides of flagstones should be parallel to the sides of the Square.","The input contains three positive integer numbers in the first line: *n*,<=<=*m* and *a* (1<=≤<=<=*n*,<=*m*,<=*a*<=≤<=109).",Write the needed number of flagstones.,['6 6 4\n'],['4\n'],none,WRONG_ANSWER,"from math import ceil

def theatreSquare(input):
    n = int(input.split(' ')[0])
    m = int(input.split(' ')[1])
    a = int(input.split(' ')[2])
    global nDimensionCount
    global mDimensionCount
    if a > n:
        nDimensionCount = 1
    elif a > m:
        mDimensionCount = 1
    else:
        nDimensionCount = ceil(n / a)
        mDimensionCount = ceil(m / a)
    return nDimensionCount * mDimensionCount

print(theatreSquare('6 6 4'))","import math

n, m, a = map(int, input().split())

flagstones_length = math.ceil(n / a)

flagstones_width = math.ceil(m / a)

total_flagstones = flagstones_length * flagstones_width

print(total_flagstones)"
1004,C,Sonya and Robots,PROGRAMMING,"['constructive algorithms', 'implementation']","Since Sonya is interested in robotics too, she decided to construct robots that will read and recognize numbers.

Sonya has drawn $n$ numbers in a row, $a_i$ is located in the $i$-th position. She also has put a robot at each end of the row (to the left of the first number and to the right of the last number). Sonya will give a number to each robot (they can be either same or different) and run them. When a robot is running, it is moving toward to another robot, reading numbers in the row. When a robot is reading a number that is equal to the number that was given to that robot, it will turn off and stay in the same position.

Sonya does not want robots to break, so she will give such numbers that robots will stop before they meet. That is, the girl wants them to stop at different positions so that the first robot is to the left of the second one.

For example, if the numbers $[1, 5, 4, 1, 3]$ are written, and Sonya gives the number $1$ to the first robot and the number $4$ to the second one, the first robot will stop in the $1$-st position while the second one in the $3$-rd position. In that case, robots will not meet each other. As a result, robots will not be broken. But if Sonya gives the number $4$ to the first robot and the number $5$ to the second one, they will meet since the first robot will stop in the $3$-rd position while the second one is in the $2$-nd position.

Sonya understands that it does not make sense to give a number that is not written in the row because a robot will not find this number and will meet the other robot.

Sonya is now interested in finding the number of different pairs that she can give to robots so that they will not meet. In other words, she wants to know the number of pairs ($p$, $q$), where she will give $p$ to the first robot and $q$ to the second one. Pairs ($p_i$, $q_i$) and ($p_j$, $q_j$) are different if $p_i\neq p_j$ or $q_i\neq q_j$.

Unfortunately, Sonya is busy fixing robots that broke after a failed launch. That is why she is asking you to find the number of pairs that she can give to robots so that they will not meet.","The first line contains a single integer $n$ ($1\leq n\leq 10^5$) — the number of numbers in a row.

The second line contains $n$ integers $a_1, a_2, \ldots, a_n$ ($1\leq a_i\leq 10^5$) — the numbers in a row.",Print one number — the number of possible pairs that Sonya can give to robots so that they will not meet.,"['5\n1 5 4 1 3\n', '7\n1 2 1 1 1 3 2\n']","['9\n', '7\n']","In the first example, Sonya can give pairs ($1$, $1$), ($1$, $3$), ($1$, $4$), ($1$, $5$), ($4$, $1$), ($4$, $3$), ($5$, $1$), ($5$, $3$), and ($5$, $4$).

In the second example, Sonya can give pairs ($1$, $1$), ($1$, $2$), ($1$, $3$), ($2$, $1$), ($2$, $2$), ($2$, $3$), and ($3$, $2$).",OK,"""""""
http://codeforces.com/problemset/problem/1004/C
""""""
input()
arr = map(int, input().split())
hash_ = {}
cnt = 0
for x in arr:
    if x not in hash_:
        cnt += len(hash_)
        hash_[x] = len(hash_)
    else:
        cnt += len(hash_) - hash_[x]
        hash_[x] += len(hash_) - hash_[x]
print(cnt)","def count_robot_pairs(n, arr):

    unique_numbers = set(arr)

    first_occurrence = {}
    for index, value in enumerate(arr):
        if value not in first_occurrence:
            first_occurrence[value] = index

    total_pairs = 0
    unique_list = list(unique_numbers)

    for i in range(len(unique_list)):
        for j in range(len(unique_list)):
            if first_occurrence[unique_list[i]] < first_occurrence[unique_list[j]]:
                total_pairs += 1
                
    return total_pairs

n = int(input().strip())
arr = list(map(int, input().strip().split()))

result = count_robot_pairs(n, arr)

print(result)"
540,A,Combination Lock,PROGRAMMING,['implementation'],"Scrooge McDuck keeps his most treasured savings in a home safe with a combination lock. Each time he wants to put there the treasures that he's earned fair and square, he has to open the lock.

The combination lock is represented by *n* rotating disks with digits from 0 to 9 written on them. Scrooge McDuck has to turn some disks so that the combination of digits on the disks forms a secret combination. In one move, he can rotate one disk one digit forwards or backwards. In particular, in one move he can go from digit 0 to digit 9 and vice versa. What minimum number of actions does he need for that?","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=1000) — the number of disks on the combination lock.

The second line contains a string of *n* digits — the original state of the disks.

The third line contains a string of *n* digits — Scrooge McDuck's combination that opens the lock.",Print a single integer — the minimum number of moves Scrooge McDuck needs to open the lock.,['5\n82195\n64723\n'],['13\n'],"In the sample he needs 13 moves:
 -  1 disk: <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/b8967f65a723782358b93eff9ce69f336817cf70.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> -  2 disk: <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/07fa58573ece0d32c4d555e498d2b24d2f70f36a.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> -  3 disk: <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/cc2275d9252aae35a6867c6a5b4ba7596e9a7626.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> -  4 disk: <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/b100aea470fcaaab4e9529b234ba0d7875943c10.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> -  5 disk: <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/eb2cbe4324cebca65b85816262a85e473cd65967.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>",OK,"n = input()
a1 = list(  map( int , list(input() )))
a2 = list(  map( int , list(input() )))

def func(n1, n2):
    return min(abs(n1-n2), 10 - abs(n1- n2))
count = 0
for n1, n2 in zip(a1, a2):
    count += func(n1, n2)
print(count)","n = int(input().strip())

original_state = input().strip()

target_combination = input().strip()

total_moves = 0

for i in range(n):

    curr_digit = int(original_state[i])
    target_digit = int(target_combination[i])

    forward_moves = (target_digit - curr_digit) % 10
    backward_moves = (curr_digit - target_digit) % 10

    total_moves += min(forward_moves, backward_moves)

print(total_moves)"
965,B,Battleship,PROGRAMMING,['implementation'],"Arkady is playing Battleship. The rules of this game aren't really important.

There is a field of $n \times n$ cells. There should be exactly one $k$-decker on the field, i. e. a ship that is $k$ cells long oriented either horizontally or vertically. However, Arkady doesn't know where it is located. For each cell Arkady knows if it is definitely empty or can contain a part of the ship.

Consider all possible locations of the ship. Find such a cell that belongs to the maximum possible number of different locations of the ship.","The first line contains two integers $n$ and $k$ ($1 \le k \le n \le 100$) — the size of the field and the size of the ship.

The next $n$ lines contain the field. Each line contains $n$ characters, each of which is either '#' (denotes a definitely empty cell) or '.' (denotes a cell that can belong to the ship).","Output two integers — the row and the column of a cell that belongs to the maximum possible number of different locations of the ship.

If there are multiple answers, output any of them. In particular, if no ship can be placed on the field, you can output any cell.","['4 3\n#..#\n#.#.\n....\n.###\n', '10 4\n#....##...\n.#...#....\n..#..#..#.\n...#.#....\n.#..##.#..\n.....#...#\n...#.##...\n.#...#.#..\n.....#..#.\n...#.#...#\n', '19 6\n##..............###\n#......#####.....##\n.....#########.....\n....###########....\n...#############...\n..###############..\n.#################.\n.#################.\n.#################.\n.#################.\n#####....##....####\n####............###\n####............###\n#####...####...####\n.#####..####..#####\n...###........###..\n....###########....\n.........##........\n#.................#\n']","['3 2\n', '6 1\n', '1 8\n']","The picture below shows the three possible locations of the ship that contain the cell $(3, 2)$ in the first sample.",OK,"def fix(a,b,c):
	ret=min(a,c+k-1)-max(c-k+1,b)-k+2
	return [0,ret][ret>0]
def solve(row,col):
	a1=a2=row
	a3=a4=col
	while(a1+1>=0 and a1+1<n and mp[a1+1][col]!='
		a1+=1
	while(a2-1>=0 and a2-1<n and mp[a2-1][col]!='
		a2-=1
	while(a3+1>=0 and a3+1<n and mp[row][a3+1]!='
		a3+=1
	while(a4-1>=0 and a4-1<n and mp[row][a4-1]!='
		a4-=1
	return fix(a1,a2,row)+fix(a3,a4,col)
n,k=map(int,input().split())
mp=[]
r=c=ans=0
for _ in range(n):
	mp.append(input())
for i in range(n):
	for j in range(n):
		if mp[i][j]!= '
			tp = solve(i, j)
			if tp>ans:
				ans=tp
				r=i
				c=j
print(r+1,c+1)","def max_ship_location(n, k, grid):

    count = [[0] * n for _ in range(n)]

    for i in range(n):
        for j in range(n - k + 1):
            if all(grid[i][j + x] == '.' for x in range(k)):
                for x in range(k):
                    count[i][j + x] += 1

    for j in range(n):
        for i in range(n - k + 1):
            if all(grid[i + x][j] == '.' for x in range(k)):
                for x in range(k):
                    count[i + x][j] += 1

    max_count = -1
    max_cell = (0, 0)
    
    for i in range(n):
        for j in range(n):
            if count[i][j] > max_count:
                max_count = count[i][j]
                max_cell = (i + 1, j + 1)

    return max_cell

data = input().splitlines()
n, k = map(int, data[0].split())
grid = [data[i + 1] for i in range(n)]

result = max_ship_location(n, k, grid)
print(result[0], result[1])"
152,B,Steps,PROGRAMMING,"['binary search', 'implementation']","One day Vasya went out for a walk in the yard but there weren't any of his friends outside and he had no one to play touch and run. But the boy didn't lose the high spirits and decided to play touch and run with himself. You may ask: ""How did he do that?"" The answer is simple.

Vasya noticed that the yard is a rectangular *n*<=×<=*m* field. The squares have coordinates (*x*,<=*y*) (1<=≤<=*x*<=≤<=*n*,<=1<=≤<=*y*<=≤<=*m*), where *x* is the index of the row and *y* is the index of the column.

Initially Vasya stands in the square with coordinates (*x**c*,<=*y**c*). To play, he has got a list of *k* vectors (*dx**i*,<=*dy**i*) of non-zero length. The game goes like this. The boy considers all vectors in the order from 1 to *k*, and consecutively chooses each vector as the current one. After the boy has chosen a current vector, he makes the maximally possible number of valid steps in the vector's direction (it is possible that he makes zero steps).

A step is defined as one movement from the square where the boy is standing now, in the direction of the current vector. That is, if Vasya is positioned in square (*x*,<=*y*), and the current vector is (*dx*,<=*dy*), one step moves Vasya to square (*x*<=+<=*dx*,<=*y*<=+<=*dy*). A step is considered valid, if the boy does not go out of the yard if he performs the step.

Vasya stepped on and on, on and on until he ran out of vectors in his list. Ha had been stepping for so long that he completely forgot how many steps he had made. Help the boy and count how many steps he had made.","The first input line contains two integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=109) — the yard's sizes. The second line contains integers *x**c* and *y**c* — the initial square's coordinates (1<=≤<=*x**c*<=≤<=*n*,<=1<=≤<=*y**c*<=≤<=*m*).

The third line contains an integer *k* (1<=≤<=*k*<=≤<=104) — the number of vectors. Then follow *k* lines, each of them contains two integers *dx**i* and *dy**i* (|*dx**i*|,<=|*dy**i*|<=≤<=109,<=|*dx*|<=+<=|*dy*|<=≥<=1).","Print the single number — the number of steps Vasya had made.

Please do not use the %lld specificator to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specificator.","['4 5\n1 1\n3\n1 1\n1 1\n0 -2\n', '10 10\n1 2\n1\n-1 0\n']","['4\n', '0\n']","In the first sample Vasya is initially positioned at square (1, 1) and makes 3 steps by the first vector (1, 1). So, he consecutively visits the squares (2, 2), (3, 3), (4, 4). Then he makes 0 steps by the second vector (1, 1). He makes 1 more step by the third vector (0,  - 2) and he ends up in square (4, 2). Overall, Vasya makes 4 steps.

In the second sample Vasya is initially positioned in square (1, 2) and makes 0 steps by vector ( - 1, 0), as the square with coordinates (0, 2) is located outside the yard.",WRONG_ANSWER,"def check(x,y):
    global n,m
    if x>0 and x<=n and y>0 and y<=m:
        return True
    return False

n,m=list(map(int,input().split()));pos=list(map(int,input().split()));k=int(input());steps=0
for i in range(k):
    maxi=10**9;mini=0;arr=[]
    x,y=list(map(int,input().split()))
    while mini<=maxi:
        midian=int((maxi+mini)/2)
        if check(pos[0]+x*midian,pos[1]+y*midian):mini=midian+1
        else: maxi=midian-1
    mi=midian;pos[0]+=mi*x;pos[1]+=mi*y
    steps+=mi
print(steps)","n, m = map(int, input().split())

x_c, y_c = map(int, input().split())

k = int(input())

total_steps = 0

for _ in range(k):
    dx, dy = map(int, input().split())

    if dx > 0:
        max_steps_x = (n - x_c) // dx
    elif dx < 0:
        max_steps_x = (1 - x_c) // dx
    else:
        max_steps_x = float('inf')
    
    if dy > 0:
        max_steps_y = (m - y_c) // dy
    elif dy < 0:
        max_steps_y = (1 - y_c) // dy
    else:
        max_steps_y = float('inf')

    max_steps = min(max_steps_x, max_steps_y)

    total_steps += max_steps
    x_c += max_steps * dx
    y_c += max_steps * dy

print(total_steps)"
952,A,Quirky Quantifiers,PROGRAMMING,['math'],"The input contains a single integer *a* (10<=≤<=*a*<=≤<=999).

Output 0 or 1.",The input contains a single integer *a* (10<=≤<=*a*<=≤<=999).,Output 0 or 1.,"['13\n', '927\n', '48\n']","['1\n', '1\n', '0\n']",none,WRONG_ANSWER,"def main_function():
    s = input()
    return 0

print(main_function())","def check_number(a):

    if 10 <= a <= 99:
        return 1
    else:
        return 0

def main():
    import sys
    input_data = sys.stdin.read().strip().split()
    
    output = []
    for value in input_data:
        a = int(value)
        result = check_number(a)
        output.append(f""{result}\n"")

    print(''.join(output))

if __name__ == ""__main__"":
    main()"
268,A,Games,PROGRAMMING,['brute force'],"Manao works on a sports TV. He's spent much time watching the football games of some country. After a while he began to notice different patterns. For example, each team has two sets of uniforms: home uniform and guest uniform. When a team plays a game at home, the players put on the home uniform. When a team plays as a guest on somebody else's stadium, the players put on the guest uniform. The only exception to that rule is: when the home uniform color of the host team matches the guests' uniform, the host team puts on its guest uniform as well. For each team the color of the home and guest uniform is different.

There are *n* teams taking part in the national championship. The championship consists of *n*·(*n*<=-<=1) games: each team invites each other team to its stadium. At this point Manao wondered: how many times during the championship is a host team going to put on the guest uniform? Note that the order of the games does not affect this number.

You know the colors of the home and guest uniform for each team. For simplicity, the colors are numbered by integers in such a way that no two distinct colors have the same number. Help Manao find the answer to his question.","The first line contains an integer *n* (2<=≤<=*n*<=≤<=30). Each of the following *n* lines contains a pair of distinct space-separated integers *h**i*, *a**i* (1<=≤<=*h**i*,<=*a**i*<=≤<=100) — the colors of the *i*-th team's home and guest uniforms, respectively.",In a single line print the number of games where the host team is going to play in the guest uniform.,"['3\n1 2\n2 4\n3 4\n', '4\n100 42\n42 100\n5 42\n100 5\n', '2\n1 2\n1 2\n']","['1\n', '5\n', '0\n']","In the first test case the championship consists of 6 games. The only game with the event in question is the game between teams 2 and 1 on the stadium of team 2.

In the second test sample the host team will have to wear guest uniform in the games between teams: 1 and 2, 2 and 1, 2 and 3, 3 and 4, 4 and 2 (the host team is written first).",OK,"import sys
import string

input = sys.stdin.readline

def print(*args, end='\n', sep=' ') -> None:
    sys.stdout.write(sep.join(map(str, args)) + end)

def solve(home: list, guest: list) -> str:
    c = 0
    for i in home:
        c += guest.count(i)

    print(c)

def main() -> None:
    n = int(input())
    home, guest = zip(*[input().strip().split() for i in range(n)])

    solve(home, guest)

if __name__ == '__main__':
    main()","n = int(input())

home = []
guest = []

for _ in range(n):
    h, a = map(int, input().split())
    home.append(h)
    guest.append(a)

count = 0

for i in range(n):
    for j in range(n):
        if i != j:

            if home[i] == guest[j]:
                count += 1

print(count)"
122,A,Lucky Division,PROGRAMMING,"['brute force', 'number theory']","Petya loves lucky numbers. Everybody knows that lucky numbers are positive integers whose decimal representation contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.

Petya calls a number almost lucky if it could be evenly divided by some lucky number. Help him find out if the given number *n* is almost lucky.",The single line contains an integer *n* (1<=≤<=*n*<=≤<=1000) — the number that needs to be checked.,"In the only line print ""YES"" (without the quotes), if number *n* is almost lucky. Otherwise, print ""NO"" (without the quotes).","['47\n', '16\n', '78\n']","['YES\n', 'YES\n', 'NO\n']","Note that all lucky numbers are almost lucky as any number is evenly divisible by itself.

In the first sample 47 is a lucky number. In the second sample 16 is divisible by 4.",COMPILATION_ERROR,"n=int(input())
d=0
x=True
def luck(s):
    a=True
    while s != 0:
        if s % 10 != 7 or s % 10 != 4:
            a=False
        s //= 10
    return a
for i in range(3,n):
    if n % i == 0 and luck(i)=True:
        print('YES')
    else:
        print('NO')","def is_lucky_number(num):

    return all(digit in '47' for digit in str(num))

def is_almost_lucky(n):

    lucky_numbers = [i for i in range(1, n + 1) if is_lucky_number(i)]

    for lucky in lucky_numbers:
        if n % lucky == 0:
            return True
    return False

n = int(input().strip())

if is_almost_lucky(n):
    print(""YES"")
else:
    print(""NO"")"
803,C,Maximal GCD,PROGRAMMING,"['constructive algorithms', 'greedy', 'math']","You are given positive integer number *n*. You should create such strictly increasing sequence of *k* positive numbers *a*1,<=*a*2,<=...,<=*a**k*, that their sum is equal to *n* and greatest common divisor is maximal.

Greatest common divisor of sequence is maximum of such numbers that every element of sequence is divisible by them.

If there is no possible sequence then output -1.","The first line consists of two numbers *n* and *k* (1<=≤<=*n*,<=*k*<=≤<=1010).","If the answer exists then output *k* numbers — resulting sequence. Otherwise output -1. If there are multiple answers, print any of them.","['6 3\n', '8 2\n', '5 3\n']","['1 2 3\n', '2 6\n', '-1\n']",none,OK,"def divisors(x):
	divisor=[]
	for i in range(1,int(x**(1/2)+1)):
		if x%i==0:
			divisor.append(i)
			if i!=x//i:
				divisor.append(x//i)
	return divisor

n,k=[int(x) for x in input().split()]
factors=sorted(divisors(n))
maxfactor=0

for i in factors:
	if i*(k*(k+1)//2)<=n:
		maxfactor=i
		
		
if maxfactor:
	tobeprinted=[maxfactor*i for i in range(1,k+1)]
	tobeprinted[-1]+=n-sum(tobeprinted)
	print(*tobeprinted)
else:
	print(-1)","def max_gcd_sequence(n, k):

    if n < k * (k + 1) // 2:
        return -1

    sequence = list(range(1, k + 1))
    sum_sequence = sum(sequence)

    difference = n - sum_sequence

    sequence[-1] += difference
    return sequence

def main():
    import sys
    input_data = sys.stdin.read().splitlines()
    
    results = []
    for line in input_data:
        n, k = map(int, line.split())
        result = max_gcd_sequence(n, k)
        if result == -1:
            results.append('-1')
        else:
            results.append(' '.join(map(str, result)))

    print('\n'.join(results))

if __name__ == ""__main__"":
    main()"
611,B,New Year and Old Property,PROGRAMMING,"['bitmasks', 'brute force', 'implementation']","The year 2015 is almost over.

Limak is a little polar bear. He has recently learnt about the binary system. He noticed that the passing year has exactly one zero in its representation in the binary system — 201510<==<=111110111112. Note that he doesn't care about the number of zeros in the decimal representation.

Limak chose some interval of years. He is going to count all years from this interval that have exactly one zero in the binary representation. Can you do it faster?

Assume that all positive integers are always written without leading zeros.",The only line of the input contains two integers *a* and *b* (1<=≤<=*a*<=≤<=*b*<=≤<=1018) — the first year and the last year in Limak's interval respectively.,Print one integer – the number of years Limak will count in his chosen interval.,"['5 10\n', '2015 2015\n', '100 105\n', '72057594000000000 72057595000000000\n']","['2\n', '1\n', '0\n', '26\n']","In the first sample Limak's interval contains numbers 5<sub class=""lower-index"">10</sub> = 101<sub class=""lower-index"">2</sub>, 6<sub class=""lower-index"">10</sub> = 110<sub class=""lower-index"">2</sub>, 7<sub class=""lower-index"">10</sub> = 111<sub class=""lower-index"">2</sub>, 8<sub class=""lower-index"">10</sub> = 1000<sub class=""lower-index"">2</sub>, 9<sub class=""lower-index"">10</sub> = 1001<sub class=""lower-index"">2</sub> and 10<sub class=""lower-index"">10</sub> = 1010<sub class=""lower-index"">2</sub>. Two of them (101<sub class=""lower-index"">2</sub> and 110<sub class=""lower-index"">2</sub>) have the described property.",WRONG_ANSWER,"mod = 1000000007

from collections import Counter,defaultdict,deque
from heapq import heappush,heappop,heapify
import sys
import math
import bisect

a,b = map(int,input().split())
x = int(math.log2(a))
A = bin(a)[2:]
B = bin(b)[2:]
if b<int(math.pow(2,x+1)):
   p=0
   for i in range(x+1):
      if A[i]=='0':
         p=i-1
         break
   q=0
   for i in range(x+1):
      if B[i]=='0':
         q=i-1
         break
   print(q-p)

else:
   ans=0
   q=0
   y = int(math.log2(b))
   for i in range(x+1):
      if A[i]=='0':
         q=i-1
         break
   
   for i in range(y+1):
      if B[i]=='0':
         ans+=(i-1)
         break

   ans+=(x-q)

   for i in range(x+1,y):
      ans+=i
   print(ans)","def count_years_with_one_zero_in_binary(a, b):
    count = 0
    for year in range(a, b + 1):

        if bin(year).count('0') == 1:
            count += 1
    return count

input_data = input().strip().split()
a = int(input_data[0])
b = int(input_data[1])

result = count_years_with_one_zero_in_binary(a, b)

print(result)"
27,A,Next Test,PROGRAMMING,"['implementation', 'sortings']","«Polygon» is a system which allows to create programming tasks in a simple and professional way. When you add a test to the problem, the corresponding form asks you for the test index. As in most cases it is clear which index the next test will have, the system suggests the default value of the index. It is calculated as the smallest positive integer which is not used as an index for some previously added test.

You are to implement this feature. Create a program which determines the default index of the next test, given the indexes of the previously added tests.","The first line contains one integer *n* (1<=≤<=*n*<=≤<=3000) — the amount of previously added tests. The second line contains *n* distinct integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=3000) — indexes of these tests.",Output the required default value for the next test index.,['3\n1 7 2\n'],['3\n'],none,OK,"def main():
    n = int(input())
    arr = list(map(int, input().split()))

    count = 1
    arr.sort()

    for i in arr:
        if i != count:
            print(count)
            exit()
        count += 1

    print(count)

main()","def find_default_index(n, test_indexes):

    existing_indexes = set(test_indexes)

    for i in range(1, 3001):
        if i not in existing_indexes:
            return i

n = int(input())
test_indexes = list(map(int, input().split()))

default_index = find_default_index(n, test_indexes)
print(default_index)"
747,B,Mammoth's Genome Decoding,PROGRAMMING,"['implementation', 'strings']","The process of mammoth's genome decoding in Berland comes to its end!

One of the few remaining tasks is to restore unrecognized nucleotides in a found chain *s*. Each nucleotide is coded with a capital letter of English alphabet: 'A', 'C', 'G' or 'T'. Unrecognized nucleotides are coded by a question mark '?'. Thus, *s* is a string consisting of letters 'A', 'C', 'G', 'T' and characters '?'.

It is known that the number of nucleotides of each of the four types in the decoded genome of mammoth in Berland should be equal.

Your task is to decode the genome and replace each unrecognized nucleotide with one of the four types so that the number of nucleotides of each of the four types becomes equal.","The first line contains the integer *n* (4<=≤<=*n*<=≤<=255) — the length of the genome.

The second line contains the string *s* of length *n* — the coded genome. It consists of characters 'A', 'C', 'G', 'T' and '?'.","If it is possible to decode the genome, print it. If there are multiple answer, print any of them. If it is not possible, print three equals signs in a row: ""==="" (without quotes).","['8\nAG?C??CT\n', '4\nAGCT\n', '6\n????G?\n', '4\nAA??\n']","['AGACGTCT\n', 'AGCT\n', '===\n', '===\n']","In the first example you can replace the first question mark with the letter 'A', the second question mark with the letter 'G', the third question mark with the letter 'T', then each nucleotide in the genome would be presented twice.

In the second example the genome is already decoded correctly and each nucleotide is exactly once in it.

In the third and the fourth examples it is impossible to decode the genom.",OK,"def solve(s):
    TYPES = ['A', 'C', 'G', 'T']

    letterToCount = {}
    for ch in s:
        if ch != '?':
            letterToCount[ch] = letterToCount.get(ch, 0) + 1

    if len(s) % 4 != 0 or any(count * 4 > len(s) for count in letterToCount.values()):
        return ""===""

    result = []
    for ch in s:
        if ch == '?':
            for typ in TYPES:
                if letterToCount.get(typ, 0) * 4 != len(s):
                    result.append(typ)
                    letterToCount[typ] = letterToCount.get(typ, 0) + 1
                    break
        else:
            result.append(ch)

    return ''.join(result)

_ = int(input())
s = input()
print(solve(s))","def decode_genome(n, s):

    count_A = s.count('A')
    count_C = s.count('C')
    count_G = s.count('G')
    count_T = s.count('T')
    count_question = s.count('?')

    total = count_A + count_C + count_G + count_T + count_question

    if total % 4 != 0:
        return ""===""
    
    target_count = total // 4

    needed_A = target_count - count_A
    needed_C = target_count - count_C
    needed_G = target_count - count_G
    needed_T = target_count - count_T

    if needed_A < 0 or needed_C < 0 or needed_G < 0 or needed_T < 0:
        return ""===""

    result = list(s)
    for i in range(n):
        if result[i] == '?':
            if needed_A > 0:
                result[i] = 'A'
                needed_A -= 1
            elif needed_C > 0:
                result[i] = 'C'
                needed_C -= 1
            elif needed_G > 0:
                result[i] = 'G'
                needed_G -= 1
            elif needed_T > 0:
                result[i] = 'T'
                needed_T -= 1

    return ''.join(result)

inputs = [
    (8, 'AG?C??CT'),
    (4, 'AGCT'),
    (6, '????G?'),
    (4, 'AA??'),
]

outputs = [decode_genome(n, s) for n, s in inputs]

for output in outputs:
    print(output)"
81,A,Plug-in,PROGRAMMING,['implementation'],"Polycarp thinks about the meaning of life very often. He does this constantly, even when typing in the editor. Every time he starts brooding he can no longer fully concentrate and repeatedly presses the keys that need to be pressed only once. For example, instead of the phrase ""how are you"" he can type ""hhoow aaaare yyoouu"". 

Polycarp decided to automate the process of correcting such errors. He decided to write a plug-in to the text editor that will remove pairs of identical consecutive letters (if there are any in the text). Of course, this is not exactly what Polycarp needs, but he's got to start from something! 

Help Polycarp and write the main plug-in module. Your program should remove from a string all pairs of identical letters, which are consecutive. If after the removal there appear new pairs, the program should remove them as well. Technically, its work should be equivalent to the following: while the string contains a pair of consecutive identical letters, the pair should be deleted. Note that deleting of the consecutive identical letters can be done in any order, as any order leads to the same result.",The input data consists of a single line to be processed. The length of the line is from 1 to 2·105 characters inclusive. The string contains only lowercase Latin letters.,Print the given string after it is processed. It is guaranteed that the result will contain at least one character.,"['hhoowaaaareyyoouu\n', 'reallazy\n', 'abacabaabacabaa\n']","['wre', 'rezy', 'a']",none,WRONG_ANSWER,"def test(string):
    for idx, i in enumerate(string):
        for j in range(idx + 1, len(string)):
            if string[idx] == string[j]:
                string = string.replace(string[idx], '',1)
                string = string.replace(string[idx], '',1)
                return test(string)
            break
         
    return string

print(test(""abacabaabacabaa""))","def remove_consecutive_duplicates(s):
    stack = []

    for char in s:
        if stack and stack[-1] == char:
            stack.pop()
        else:
            stack.append(char)

    return ''.join(stack)

input_strings = ['hhoowaaaareyyoouu', 'reallazy', 'abacabaabacabaa']

output_strings = [remove_consecutive_duplicates(s) for s in input_strings]
print(output_strings)"
0,none,none,none,['none'],"Farmer John has just given the cows a program to play with! The program contains two integer variables, *x* and *y*, and performs the following operations on a sequence *a*1,<=*a*2,<=...,<=*a**n* of positive integers:
 1.  Initially, *x*<==<=1 and *y*<==<=0. If, after any step, *x*<=≤<=0 or *x*<=&gt;<=*n*, the program immediately terminates. 1.  The program increases both *x* and *y* by a value equal to *a**x* simultaneously. 1.  The program now increases *y* by *a**x* while decreasing *x* by *a**x*. 1.  The program executes steps 2 and 3 (first step 2, then step 3) repeatedly until it terminates (it may never terminate). So, the sequence of executed steps may start with: step 2, step 3, step 2, step 3, step 2 and so on. 
The cows are not very good at arithmetic though, and they want to see how the program works. Please help them!

You are given the sequence *a*2,<=*a*3,<=...,<=*a**n*. Suppose for each *i* (1<=≤<=*i*<=≤<=*n*<=-<=1) we run the program on the sequence *i*,<=*a*2,<=*a*3,<=...,<=*a**n*. For each such run output the final value of *y* if the program terminates or -1 if it does not terminate.","The first line contains a single integer, *n* (2<=≤<=*n*<=≤<=2·105). The next line contains *n*<=-<=1 space separated integers, *a*2,<=*a*3,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=109).","Output *n*<=-<=1 lines. On the *i*-th line, print the requested value when the program is run on the sequence *i*,<=*a*2,<=*a*3,<=...*a**n*.

Please do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.","['4\n2 4 1\n', '3\n1 2\n']","['3\n6\n8\n', '-1\n-1\n']","In the first sample 
 1.  For *i* = 1,  *x* becomes <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/d87035805e6f1c669693d86603da6d89c5730833.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> and *y* becomes 1 + 2 = 3. 1.  For *i* = 2,  *x* becomes <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/c59515a288e6cb9876590f520c031cb27e346525.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> and *y* becomes 2 + 4 = 6. 1.  For *i* = 3,  *x* becomes <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/62b52a6cff2221e154a9c36f7bb277ad6475a1b6.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> and *y* becomes 3 + 1 + 4 = 8.",WRONG_ANSWER,"import math
import time
dp=[[float('inf') for i in range(2)] for j in range(200001)]
arr=[0]*(200001)

def ans(i,val,n,step):

  if i>=n or i<0:
    return val 
  
  if dp[i][step]!=float('inf'):
    
    return val+dp[i][step] 
  
  dp[i][step]=-float('inf')

  new_idx=i-arr[i] if step else i+arr[i]
  val+=arr[i]
  val=ans(new_idx,val,n,step^1)
  dp[i][step]=val 
  return val 

def main():

  n=int(input())
  a=list(map(int,input().split()))
  for i in range(1,n):
    arr[i]=a[i-1]
  for i in range(len(dp)):
    for j in range(len(dp[0])):
      dp[i][j]=float('inf')
  dp[0][0]=-float('inf')
  r=[]
  for i in range(1,n):
    arr[0]=i
    ans(i,i,n,1)
    if dp[i][1]!=-float('inf'):
      r.append(dp[i][1])
    else:
      r.append(-1)
  return r 

r=main()

for e in r:
  print(e)","def simulate_program(n, sequences):
    results = []
    
    for i in range(1, n + 1):
        x = i
        y = 0
        seen_states = set()
        
        while True:
            if x <= 0 or x > n:
                results.append(y)
                break

            y += sequences[x - 1]
            x += sequences[x - 1]

            if (x, y) in seen_states:
                results.append(-1)
                break
            seen_states.add((x, y))

            y += sequences[x - 1]
            x -= sequences[x - 1]
    
    return results

n = int(input())
sequences = list(map(int, input().split()))

results = simulate_program(n, sequences)

for result in results:
    print(result)"
0,none,none,none,['none'],"Профиль горного хребта схематично задан в виде прямоугольной таблицы из символов «.» (пустое пространство) и «*» (часть горы). Каждый столбец таблицы содержит хотя бы одну «звёздочку». Гарантируется, что любой из символов «*» либо находится в нижней строке матрицы, либо непосредственно под ним находится другой символ «*». 

Маршрут туриста проходит через весь горный хребет слева направо. Каждый день турист перемещается вправо — в соседний столбец в схематичном изображении. Конечно, каждый раз он поднимается (или опускается) в самую верхнюю точку горы, которая находится в соответствующем столбце.

Считая, что изначально турист находится в самой верхней точке в первом столбце, а закончит свой маршрут в самой верхней точке в последнем столбце, найдите две величины:
 -  наибольший подъём за день (равен 0, если в профиле горного хребта нет ни одного подъёма), -  наибольший спуск за день (равен 0, если в профиле горного хребта нет ни одного спуска).","В первой строке входных данных записаны два целых числа *n* и *m* (1<=≤<=*n*,<=*m*<=≤<=100) — количество строк и столбцов в схематичном изображении соответственно.

Далее следуют *n* строк по *m* символов в каждой — схематичное изображение горного хребта. Каждый символ схематичного изображения — это либо «.», либо «*». Каждый столбец матрицы содержит хотя бы один символ «*». Гарантируется, что любой из символов «*» либо находится в нижней строке матрицы, либо непосредственно под ним находится другой символ «*».","Выведите через пробел два целых числа:
 -  величину наибольшего подъёма за день (или 0, если в профиле горного хребта нет ни одного подъёма), -  величину наибольшего спуска за день (или 0, если в профиле горного хребта нет ни одного спуска).","['6 11\n...........\n.........*.\n.*.......*.\n**.......*.\n**..*...**.\n***********\n', '5 5\n....*\n...**\n..***\n.****\n*****\n', '8 7\n.......\n.*.....\n.*.....\n.**....\n.**.*..\n.****.*\n.******\n*******\n']","['3 4\n', '1 0\n', '6 2\n']","В первом тестовом примере высоты гор равны: 3, 4, 1, 1, 2, 1, 1, 1, 2, 5, 1. Наибольший подъем равен 3 и находится между горой номер 9 (её высота равна 2) и горой номер 10 (её высота равна 5). Наибольший спуск равен 4 и находится между горой номер 10 (её высота равна 5) и горой номер 11 (её высота равна 1).

Во втором тестовом примере высоты гор равны: 1, 2, 3, 4, 5. Наибольший подъём равен 1 и находится, например, между горой номер 2 (ее высота равна 2) и горой номер 3 (её высота равна 3). Так как в данном горном хребте нет спусков, то величина наибольшего спуска равна 0.

В третьем тестовом примере высоты гор равны: 1, 7, 5, 3, 4, 2, 3. Наибольший подъём равен 6 и находится между горой номер 1 (её высота равна 1) и горой номер 2 (её высота равна 7). Наибольший спуск равен 2 и находится между горой номер 2 (её высота равна 7) и горой номер 3 (её высота равна 5). Такой же спуск находится между горой номер 5 (её высота равна 4) и горой номер 6 (её высота равна 2).",OK,"def main():
    n, m = [int(i) for i in input().split()]
    d = [list(input()) for i in range(n)]
    
    a = [0] * m
    for i in range(m):
        for j in range(n):
            if d[j][i] == '*':
                a[i] += 1
    
    x = y = 0
    for i in range(1, m):
        if a[i] > a[i - 1]: x = max(x, a[i] - a[i - 1])
        else: y = max(y, a[i - 1] - a[i])
    
    print(x, y)
    
    
main()","def find_peak_heights(n, m, profile):
    heights = []
    
    for j in range(m):
        height = 0
        for i in range(n):
            if profile[i][j] == '*':
                height = n - i
                break
        heights.append(height)
    
    return heights

def calculate_max_changes(heights):
    max_ascent = 0
    max_descent = 0
    
    for i in range(1, len(heights)):
        change = heights[i] - heights[i - 1]
        if change > 0:
            max_ascent = max(max_ascent, change)
        elif change < 0:
            max_descent = max(max_descent, -change)
    
    return max_ascent, max_descent

def main():

    n, m = map(int, input().split())
    profile = [input().strip() for _ in range(n)]
    
    heights = find_peak_heights(n, m, profile)
    max_ascent, max_descent = calculate_max_changes(heights)
    
    print(max_ascent, max_descent)

if __name__ == ""__main__"":
    main()"
58,A,Chat room,PROGRAMMING,"['greedy', 'strings']","Vasya has recently learned to type and log on to the Internet. He immediately entered a chat room and decided to say hello to everybody. Vasya typed the word *s*. It is considered that Vasya managed to say hello if several letters can be deleted from the typed word so that it resulted in the word ""hello"". For example, if Vasya types the word ""ahhellllloou"", it will be considered that he said hello, and if he types ""hlelo"", it will be considered that Vasya got misunderstood and he didn't manage to say hello. Determine whether Vasya managed to say hello by the given word *s*.","The first and only line contains the word *s*, which Vasya typed. This word consisits of small Latin letters, its length is no less that 1 and no more than 100 letters.","If Vasya managed to say hello, print ""YES"", otherwise print ""NO"".","['ahhellllloou\n', 'hlelo\n']","['YES\n', 'NO\n']",none,OK,"import sys
input = sys.stdin.readline

def inp():
    return(int(input()))
def inlt():
    return(list(map(int,input().split())))
def insr():
    s = input()
    return(list(s[:len(s) - 1]))
def invr():
    return(map(int,input().split()))

s = insr()
j = 0
c = False
to = 'h'
cs = ['h', 'e', 'l', 'l', 'o']
for i in s:
    if i == to:
        j += 1
        if j == 5:
            c = True
            break
        to = cs[j]
if c:
    print('YES')
else:
    print('NO')","def can_say_hello(s):

    target = ""hello""
    target_length = len(target)
    j = 0

    for char in s:

        if char == target[j]:
            j += 1

        if j == target_length:
            return ""YES""
            
    return ""NO""

s = input().strip()

print(can_say_hello(s))"
50,A,Domino piling,PROGRAMMING,"['greedy', 'math']","You are given a rectangular board of *M*<=×<=*N* squares. Also you are given an unlimited number of standard domino pieces of 2<=×<=1 squares. You are allowed to rotate the pieces. You are asked to place as many dominoes as possible on the board so as to meet the following conditions:

1. Each domino completely covers two squares.

2. No two dominoes overlap.

3. Each domino lies entirely inside the board. It is allowed to touch the edges of the board.

Find the maximum number of dominoes, which can be placed under these restrictions.",In a single line you are given two integers *M* and *N* — board sizes in squares (1<=≤<=*M*<=≤<=*N*<=≤<=16).,"Output one number — the maximal number of dominoes, which can be placed.","['2 4\n', '3 3\n']","['4\n', '4\n']",none,WRONG_ANSWER,"def get_list(n): return list(input().split() for _ in range(n))
def get_int():return list(map(int,input().strip().split()))

n,m = get_int()

def solve():
    s=min(n,m)

    if s%2!=0:
        s-=1

    ans=s*s//2

    s1=(n-s)*m
    s2=(m-s)*n

    ans+=s1//2 + s2//2
    print(ans)

solve()","def max_dominoes(m, n):

    return (m * n) // 2

import sys

if __name__ == ""__main__"":
    input_lines = sys.stdin.read().strip().split('\n')
    
    results = []
    
    for line in input_lines:

        m, n = map(int, line.split())

        result = max_dominoes(m, n)

        results.append(result)

    for res in results:
        print(res)"
508,A,Pasha and Pixels,PROGRAMMING,['brute force'],"Pasha loves his phone and also putting his hair up... But the hair is now irrelevant.

Pasha has installed a new game to his phone. The goal of the game is following. There is a rectangular field consisting of *n* row with *m* pixels in each row. Initially, all the pixels are colored white. In one move, Pasha can choose any pixel and color it black. In particular, he can choose the pixel that is already black, then after the boy's move the pixel does not change, that is, it remains black. Pasha loses the game when a 2<=×<=2 square consisting of black pixels is formed. 

Pasha has made a plan of *k* moves, according to which he will paint pixels. Each turn in his plan is represented as a pair of numbers *i* and *j*, denoting respectively the row and the column of the pixel to be colored on the current move.

Determine whether Pasha loses if he acts in accordance with his plan, and if he does, on what move the 2<=×<=2 square consisting of black pixels is formed.","The first line of the input contains three integers *n*,<=*m*,<=*k* (1<=≤<=*n*,<=*m*<=≤<=1000, 1<=≤<=*k*<=≤<=105) — the number of rows, the number of columns and the number of moves that Pasha is going to perform. 

The next *k* lines contain Pasha's moves in the order he makes them. Each line contains two integers *i* and *j* (1<=≤<=*i*<=≤<=*n*, 1<=≤<=*j*<=≤<=*m*), representing the row number and column number of the pixel that was painted during a move.","If Pasha loses, print the number of the move when the 2<=×<=2 square consisting of black pixels is formed.

If Pasha doesn't lose, that is, no 2<=×<=2 square consisting of black pixels is formed during the given *k* moves, print 0.","['2 2 4\n1 1\n1 2\n2 1\n2 2\n', '2 3 6\n2 3\n2 2\n1 3\n2 2\n1 2\n1 1\n', '5 3 7\n2 3\n1 2\n1 1\n4 1\n3 1\n5 3\n3 2\n']","['4\n', '5\n', '0\n']",none,RUNTIME_ERROR,"n,m,k=map(int,input(),split())
x=[(m+2)*[0] for i in range(n+2)]

def check(i,j):
    if x[i][j+1]==1 and x[i+1][j]==1 and x[i+1][j+1]==1:
        return True
    if x[i][j-1]==1 and x[i+1][j]==1 and x[i+1][j-1]==1:
        return True
    if x[i-1][j]==1 and x[i][j+1]==1 and x[i-1][j+1]==1:
        return True
    if x[i-1][j]==1 and x[i][j-1]==1 and x[i-1][j-1]==1:
        return True
    return False

for i in range(k):
    l,n=map(int,input().split())
    x[l][n]=1
    if check(l,n):
        print(i+1)
        break
else:
    print(0)","def check_losing_move(n, m, k, moves):

    grid = [[0] * (m + 1) for _ in range(n + 1)]
    
    for move_number in range(k):
        i, j = moves[move_number]
        grid[i][j] = 1

        if (i > 1 and j > 1 and 
            grid[i][j] and grid[i-1][j] and 
            grid[i][j-1] and grid[i-1][j-1]):
            return move_number + 1
        
    return 0

import sys
input_data = sys.stdin.read().strip().split('\n')
result = []

index = 0
while index < len(input_data):
    n, m, k = map(int, input_data[index].split())
    index += 1
    moves = [tuple(map(int, input_data[i].split())) for i in range(index, index + k)]
    index += k

    result.append(str(check_losing_move(n, m, k, moves)))

print(""\n"".join(result))"
719,B,Anatoly and Cockroaches,PROGRAMMING,['greedy'],"Anatoly lives in the university dorm as many other students do. As you know, cockroaches are also living there together with students. Cockroaches might be of two colors: black and red. There are *n* cockroaches living in Anatoly's room.

Anatoly just made all his cockroaches to form a single line. As he is a perfectionist, he would like the colors of cockroaches in the line to alternate. He has a can of black paint and a can of red paint. In one turn he can either swap any two cockroaches, or take any single cockroach and change it's color.

Help Anatoly find out the minimum number of turns he needs to make the colors of cockroaches in the line alternate.","The first line of the input contains a single integer *n* (1<=≤<=*n*<=≤<=100<=000) — the number of cockroaches.

The second line contains a string of length *n*, consisting of characters 'b' and 'r' that denote black cockroach and red cockroach respectively.",Print one integer — the minimum number of moves Anatoly has to perform in order to make the colors of cockroaches in the line to alternate.,"['5\nrbbrr\n', '5\nbbbbb\n', '3\nrbr\n']","['1\n', '2\n', '0\n']","In the first sample, Anatoly has to swap third and fourth cockroaches. He needs 1 turn to do this.

In the second sample, the optimum answer is to paint the second and the fourth cockroaches red. This requires 2 turns.

In the third sample, the colors of cockroaches in the line are alternating already, thus the answer is 0.",OK,"def calc(s,i):
    c=[0,0]
    for x in range(len(s)):
        if s[x]!=i[x]:c[x%2]+=1
    return max(c)

n=int(input());s=input()
i1=('rb'*(n//2+1))[:n]
i2=('br'*(n//2+1))[:n]
print(min(calc(s,i1),calc(s,i2)))","def min_moves_to_alternate(n, cockroaches):

    pattern1 = 'br' * (n // 2) + 'b' * (n % 2)
    pattern2 = 'rb' * (n // 2) + 'r' * (n % 2)

    mismatch1 = sum(1 for i in range(n) if cockroaches[i] != pattern1[i])
    mismatch2 = sum(1 for i in range(n) if cockroaches[i] != pattern2[i])

    return min(mismatch1, mismatch2) // 2 + max(mismatch1, mismatch2) % 2

input_data = ['5\nrbbrr\n', '5\nbbbbb\n', '3\nrbr\n']
output = []
for data in input_data:
    n, cockroaches = data.strip().split('\n')
    n = int(n)
    result = min_moves_to_alternate(n, cockroaches)
    output.append(f""{result}\n"")

print(''.join(output))"
199,A,Hexadecimal's theorem,PROGRAMMING,"['brute force', 'constructive algorithms', 'implementation', 'number theory']","Recently, a chaotic virus Hexadecimal advanced a new theorem which will shake the Universe. She thinks that each Fibonacci number can be represented as sum of three not necessary different Fibonacci numbers.

Let's remember how Fibonacci numbers can be calculated. *F*0<==<=0, *F*1<==<=1, and all the next numbers are *F**i*<==<=*F**i*<=-<=2<=+<=*F**i*<=-<=1.

So, Fibonacci numbers make a sequence of numbers: 0, 1, 1, 2, 3, 5, 8, 13, ...

If you haven't run away from the PC in fear, you have to help the virus. Your task is to divide given Fibonacci number *n* by three not necessary different Fibonacci numbers or say that it is impossible.",The input contains of a single integer *n* (0<=≤<=*n*<=&lt;<=109) — the number that should be represented by the rules described above. It is guaranteed that *n* is a Fibonacci number.,"Output three required numbers: *a*, *b* and *c*. If there is no answer for the test you have to print ""I'm too stupid to solve this problem"" without the quotes.

If there are multiple answers, print any of them.","['3\n', '13\n']","['1 1 1\n', '2 3 8\n']",none,WRONG_ANSWER,"ser = [0, 1]
def fib(n):
    i = 1
    while i < n:
        ser.append(i)
        i = ser[-1] + ser[-2]
    if i != n:
        return -1
    else:
        return len(ser)

n = int(input())
a, b, c = 0, 0, 0
ans = 1
if n == 1:
    a = 1
elif n == 2:
    a = 1
    b = 1
elif n == 3:
    a = 1
    b = 1
    c = 1
else:
    ans = fib(n)
    if ans != -1:
        a = ser[ans-2]
        b = ser[ans-2]
        c = ser[ans-3]
if ans != -1:
    print(a, b, c)
else:
    print(""I'm too stupid to solve this problem"")","def fibonacci_up_to(n):

    fib = [0, 1]
    while True:
        next_fib = fib[-1] + fib[-2]
        if next_fib > n:
            break
        fib.append(next_fib)
    return fib

def find_three_fibonacci_sum(n):

    if n == 0:
        return 0, 0, 0
    
    fib = fibonacci_up_to(n)

    for a in fib:
        for b in fib:
            for c in fib:
                if a + b + c == n:
                    return a, b, c

    return ""I'm too stupid to solve this problem""

import sys
input_data = sys.stdin.read().strip().split()
results = []

for line in input_data:
    n = int(line)
    result = find_three_fibonacci_sum(n)
    if isinstance(result, tuple):
        results.append(f""{result[0]} {result[1]} {result[2]}"")
    else:
        results.append(result)

for result in results:
    print(result)"
75,A,Life Without Zeros,PROGRAMMING,['implementation'],"Can you imagine our life if we removed all zeros from it? For sure we will have many problems.

In this problem we will have a simple example if we removed all zeros from our life, it's the addition operation. Let's assume you are given this equation *a*<=+<=*b*<==<=*c*, where *a* and *b* are positive integers, and *c* is the sum of *a* and *b*. Now let's remove all zeros from this equation. Will the equation remain correct after removing all zeros?

For example if the equation is 101<=+<=102<==<=203, if we removed all zeros it will be 11<=+<=12<==<=23 which is still a correct equation.

But if the equation is 105<=+<=106<==<=211, if we removed all zeros it will be 15<=+<=16<==<=211 which is not a correct equation.","The input will consist of two lines, the first line will contain the integer *a*, and the second line will contain the integer *b* which are in the equation as described above (1<=≤<=*a*,<=*b*<=≤<=109). There won't be any leading zeros in both. The value of *c* should be calculated as *c*<==<=*a*<=+<=*b*.","The output will be just one line, you should print ""YES"" if the equation will remain correct after removing all zeros, and print ""NO"" otherwise.","['101\n102\n', '105\n106\n']","['YES\n', 'NO\n']",none,OK,"a = input()
b = input()
c = int(a) + int(b)

def rz( n ):
    n = str(n)
    ret = """"
    for i in n:
        if i != ""0"":
            ret += i
    return ( ret )

if int( rz(a) ) + int( rz(b) ) == int( rz(c) ):
    print( ""YES"" )
else:
    print( ""NO"" )","def remove_zeros(num):
    """"""Remove all zeros from the given number.""""""
    return int(str(num).replace('0', ''))

def check_equation(a, b):
    """"""Check if the equation remains valid after removing zeros.""""""
    c = a + b

    a_no_zeros = remove_zeros(a)
    b_no_zeros = remove_zeros(b)
    c_no_zeros = remove_zeros(c)

    return a_no_zeros + b_no_zeros == c_no_zeros

if __name__ == ""__main__"":

    a = int(input().strip())
    b = int(input().strip())

    if check_equation(a, b):
        print(""YES"")
    else:
        print(""NO"")"
221,A,Little Elephant and Function,PROGRAMMING,"['implementation', 'math']","The Little Elephant enjoys recursive functions.

This time he enjoys the sorting function. Let *a* is a permutation of an integers from 1 to *n*, inclusive, and *a**i* denotes the *i*-th element of the permutation. The Little Elephant's recursive function *f*(*x*), that sorts the first *x* permutation's elements, works as follows:
 -  If *x*<==<=1, exit the function. -  Otherwise, call *f*(*x*<=-<=1), and then make *swap*(*a**x*<=-<=1,<=*a**x*) (swap the *x*-th and (*x*<=-<=1)-th elements of *a*). 
The Little Elephant's teacher believes that this function does not work correctly. But that-be do not get an F, the Little Elephant wants to show the performance of its function. Help him, find a permutation of numbers from 1 to *n*, such that after performing the Little Elephant's function (that is call *f*(*n*)), the permutation will be sorted in ascending order.",A single line contains integer *n* (1<=≤<=*n*<=≤<=1000) — the size of permutation.,"In a single line print *n* distinct integers from 1 to *n* — the required permutation. Numbers in a line should be separated by spaces.

It is guaranteed that the answer exists.","['1\n', '2\n']","['1 ', '2 1 ']",none,OK,"import sys
import math
def mp(): return map(int, sys.stdin.readline().split())
def rs(): return sys.stdin.readline().rstrip()
def ri(): return int(sys.stdin.readline())
def ria(): return list(map(int, sys.stdin.readline().split()))
def ws(s): sys.stdout.write(s + '\n')
def wi(n): sys.stdout.write(str(n) + '\n')
def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')

def main():
    n = ri()
    if n==1:
        print(""1"")
        return
    elif n==2:
        print(""2 1"")
        return
    
    print(n, end="" "")
    for i in range(1,n):
        print(i, end="" "")
    print()

if __name__ == '__main__':
    t = 1
    for _ in range(t):
        main()","n = int(input().strip())

permutation = list(range(n, 0, -1))

print(' '.join(map(str, permutation)))"
571,C,CNF 2,PROGRAMMING,"['constructive algorithms', 'dfs and similar', 'graphs', 'greedy']","'In Boolean logic, a formula is in conjunctive normal form (CNF) or clausal normal form if it is a conjunction of clauses, where a clause is a disjunction of literals' (cited from https://en.wikipedia.org/wiki/Conjunctive_normal_form)

In the other words, CNF is a formula of type , where &amp; represents a logical ""AND"" (conjunction),  represents a logical ""OR"" (disjunction), and *v**ij* are some boolean variables or their negations. Each statement in brackets is called a clause, and *v**ij* are called literals.

You are given a CNF containing variables *x*1,<=...,<=*x**m* and their negations. We know that each variable occurs in at most two clauses (with negation and without negation in total). Your task is to determine whether this CNF is satisfiable, that is, whether there are such values of variables where the CNF value is true. If CNF is satisfiable, then you also need to determine the values of the variables at which the CNF is true. 

It is guaranteed that each variable occurs at most once in each clause.","The first line contains integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=2·105) — the number of clauses and the number variables, correspondingly.

Next *n* lines contain the descriptions of each clause. The *i*-th line first contains first number *k**i* (*k**i*<=≥<=1) — the number of literals in the *i*-th clauses. Then follow space-separated literals *v**ij* (1<=≤<=|*v**ij*|<=≤<=*m*). A literal that corresponds to *v**ij* is *x*|*v**ij*| either with negation, if *v**ij* is negative, or without negation otherwise.","If CNF is not satisfiable, print a single line ""NO"" (without the quotes), otherwise print two strings: string ""YES"" (without the quotes), and then a string of *m* numbers zero or one — the values of variables in satisfying assignment in the order from *x*1 to *x**m*.","['2 2\n2 1 -2\n2 2 -1\n', '4 3\n1 1\n1 2\n3 -1 -2 3\n1 -3\n', '5 6\n2 1 2\n3 1 -2 3\n4 -3 5 4 6\n2 -6 -4\n1 5\n']","['YES\n11\n', 'NO\n', 'YES\n100010\n']","In the first sample test formula is <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/5a8654a57efa13b47a585b7998c9defb42712ded.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>. One of possible answer is *x*<sub class=""lower-index"">1</sub> = *TRUE*, *x*<sub class=""lower-index"">2</sub> = *TRUE*.",TIME_LIMIT_EXCEEDED,"from itertools import * 
ent=input()
n=int(ent.split()[0])
m=int(ent.split()[1])
form=[]
for i in range (n):
    ent=input()
    k=int(ent.split()[0])
    claus=[]
    for i in range (1,k+1):
        claus.append(int(ent.split()[i]))
    form.append(claus)

def noref(formula):
    formul=[]
    for i in range (len(formula)):
        t=[]
        for j in range(len(formula[i])):
            t.append(formula[i][j])
        formul.append(t)
    return(formul)
    
def sat(formula,asignacion):
    n=len(formula)
    formul= noref(formula)

    sat=[0]*n
    for i in range (n):
        for j in range (len(formul[i])):
            if formul[i][j]<0:

                x=abs(formul[i][j])

                t=asignacion[x-1]
                formul[i][j]=abs(t-1)
            else:
                formul[i][j]=asignacion[formul[i][j]-1]

    for i in range (n):
        for j in range(len(formul[i])):
            if formul[i][j]==1:
                sat[i]=1
                break

    for i in range (n):
        if sat[i]==0:

            return False
    return (True)

resp=[]

for asignacion in product(range(2),repeat=m):
    if sat(form,asignacion)==True:
        resp=asignacion
        break
if len(resp)>0:
    salida=""""
    for i in range(len(resp)):
        salida=salida+str(resp[i])
    print(""YES"")
    print(salida)
else:
    print(""NO"")","def is_cnf_satisfiable(n, m, clauses):
    from collections import defaultdict, deque

    graph = defaultdict(list)
    for i, clause in enumerate(clauses):
        for literal in clause[1:]:

            graph[literal].append(i)
            graph[-literal].append(i)

    assignment = [None] * (m + 1)

    for i in range(n):
        if len(clauses[i]) == 0:
            continue

        first_literal = clauses[i][1]
        
        if assignment[abs(first_literal)] is None:

            assignment[abs(first_literal)] = first_literal > 0

            queue = deque([first_literal])
            while queue:
                current_literal = queue.popleft()
                current_var = abs(current_literal)

                for clause_index in graph[current_literal]:
                    clause_lits = clauses[clause_index][1:]

                    satisfied = False
                    for lit in clause_lits:
                        if assignment[abs(lit)] is not None:
                            if (lit > 0) == assignment[abs(lit)]:
                                satisfied = True
                                break

                    if satisfied:
                        continue

                    for new_lit in clause_lits:
                        if assignment[abs(new_lit)] is None:
                            assignment[abs(new_lit)] = new_lit > 0
                            queue.append(new_lit)
                            break
                    else:

                        return ""NO""

    return ""YES\n"" + ''.join('1' if assignment[i] else '0' for i in range(1, m + 1))

input_data = ['2 2\n2 1 -2\n2 2 -1\n', '4 3\n1 1\n1 2\n3 -1 -2 3\n1 -3\n', '5 6\n2 1 2\n3 1 -2 3\n4 -3 5 4 6\n2 -6 -4\n1 5\n']
output = []

for data in input_data:
    lines = data.splitlines()
    n, m = map(int, lines[0].split())
    clauses = [list(map(int, line.split())) for line in lines[1:n + 1]]
    result = is_cnf_satisfiable(n, m, clauses)
    output.append(result)

print(output)"
455,A,Boredom,PROGRAMMING,['dp'],"Alex doesn't like boredom. That's why whenever he gets bored, he comes up with games. One long winter evening he came up with a game and decided to play it.

Given a sequence *a* consisting of *n* integers. The player can make several steps. In a single step he can choose an element of the sequence (let's denote it *a**k*) and delete it, at that all elements equal to *a**k*<=+<=1 and *a**k*<=-<=1 also must be deleted from the sequence. That step brings *a**k* points to the player. 

Alex is a perfectionist, so he decided to get as many points as possible. Help him.","The first line contains integer *n* (1<=≤<=*n*<=≤<=105) that shows how many numbers are in Alex's sequence. 

The second line contains *n* integers *a*1, *a*2, ..., *a**n* (1<=≤<=*a**i*<=≤<=105).",Print a single integer — the maximum number of points that Alex can earn.,"['2\n1 2\n', '3\n1 2 3\n', '9\n1 2 1 3 2 2 2 2 3\n']","['2\n', '4\n', '10\n']","Consider the third test example. At first step we need to choose any element equal to 2. After that step our sequence looks like this [2, 2, 2, 2]. Then we do 4 steps, on each step we choose any element equals to 2. In total we earn 10 points.",RUNTIME_ERROR,"table = [0]*10**5 + [0]

def main():
    input()
    for i in map(input().split()):
        table[i] += i
    a = 0
    b = 0
    for i in table:
        a, b = max(a, b+i), a
    print(a)

main()","from collections import Counter

def max_points(n, a):

    frequency = Counter(a)
    points = 0

    for number in range(1, 100001):
        if number in frequency:

            points += number * frequency[number]

            del frequency[number]

            if number - 1 in frequency:
                del frequency[number - 1]
            if number + 1 in frequency:
                del frequency[number + 1]
    
    return points

n = int(input())
a = list(map(int, input().split()))

result = max_points(n, a)

print(result)"
975,A,Aramic script,PROGRAMMING,"['implementation', 'strings']","In Aramic language words can only represent objects.

Words in Aramic have special properties: 
 -  A word is a root if it does not contain the same letter more than once. -  A root and all its permutations represent the same object. -  The root $x$ of a word $y$ is the word that contains all letters that appear in $y$ in a way that each letter appears once. For example, the root of ""aaaa"", ""aa"", ""aaa"" is ""a"", the root of ""aabb"", ""bab"", ""baabb"", ""ab"" is ""ab"". -  Any word in Aramic represents the same object as its root. 
You have an ancient script in Aramic. What is the number of different objects mentioned in the script?","The first line contains one integer $n$ ($1 \leq n \leq 10^3$) — the number of words in the script.

The second line contains $n$ words $s_1, s_2, \ldots, s_n$ — the script itself. The length of each string does not exceed $10^3$.

It is guaranteed that all characters of the strings are small latin letters.",Output one integer — the number of different objects mentioned in the given ancient Aramic script.,"['5\na aa aaa ab abb\n', '3\namer arem mrea\n']","['2', '1']","In the first test, there are two objects mentioned. The roots that represent them are ""a"",""ab"".

In the second test, there is only one object, its root is ""amer"", the other strings are just permutations of ""amer"".",TIME_LIMIT_EXCEEDED,"def checkList(arr,word):
    for i in arr:
        if i == word:
            return True
    return False

def getRoot(word):
    newWord = """"
    for i in range(26):
        if checkList(word,chr(i+97)):
            newWord += chr(i+97)
    return newWord

num = int(input())
array = input().split(' ')
roots = []
for i in array:
    if not checkList(roots,getRoot(i)):
        roots.append(getRoot(i))
print(len(roots))","def count_different_objects(n, words):
    unique_roots = set()

    for word in words:
        root = ''.join(sorted(set(word)))
        unique_roots.add(root)

    return len(unique_roots)

n = int(input().strip())
words = input().strip().split()

print(count_different_objects(n, words))"
976,A,Minimum Binary Number,PROGRAMMING,['implementation'],"String can be called correct if it consists of characters ""0"" and ""1"" and there are no redundant leading zeroes. Here are some examples: ""0"", ""10"", ""1001"".

You are given a correct string *s*.

You can perform two different operations on this string: 
 1.  swap any pair of adjacent characters (for example, ""101""  ""110""); 1.  replace ""11"" with ""1"" (for example, ""110""  ""10""). 
Let *val*(*s*) be such a number that *s* is its binary representation.

Correct string *a* is less than some other correct string *b* iff *val*(*a*)<=&lt;<=*val*(*b*).

Your task is to find the minimum correct string that you can obtain from the given one using the operations described above. You can use these operations any number of times in any order (or even use no operations at all).","The first line contains integer number *n* (1<=≤<=*n*<=≤<=100) — the length of string *s*.

The second line contains the string *s* consisting of characters ""0"" and ""1"". It is guaranteed that the string *s* is correct.",Print one string — the minimum correct string that you can obtain from the given one.,"['4\n1001\n', '1\n1\n']","['100\n', '1\n']","In the first example you can obtain the answer by the following sequence of operations: ""1001"" <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> ""1010"" <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> ""1100"" <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> ""100"".

In the second example you can't obtain smaller answer no matter what operations you use.",WRONG_ANSWER,"import bisect
import math
import itertools
import sys

alpha = 'abcdefghijklmnopqrstuvwxyz'

def solve(n,s):
    if s == '0':
        return 0
    ones = s.count('1')
    zeros = s.count('0')
    return '1'*max(ones-1,1) +'0'*zeros

    pass

t = 1
ans = []
for _ in range(t):
    n = int(input())
    s = input()

    """"""cs = []
    for j in range(nx1y1x2y2c[-1]):
        cs.append([int(x) for x in input().split()])""""""
    """"""grid = []
    for j in range(n):
        grid.append(list(input()))""""""

    ans.append(solve(n,s))

for test in ans:
    print(test)","def minimum_correct_string(n, s):

    count_1 = s.count('1')
    count_0 = s.count('0')

    if count_1 == 0:
        return ""0""

    return ""1"" + ""0"" * count_0

n = int(input().strip())
s = input().strip()

print(minimum_correct_string(n, s))"
275,A,Lights Out,PROGRAMMING,['implementation'],"Lenny is playing a game on a 3<=×<=3 grid of lights. In the beginning of the game all lights are switched on. Pressing any of the lights will toggle it and all side-adjacent lights. The goal of the game is to switch all the lights off. We consider the toggling as follows: if the light was switched on then it will be switched off, if it was switched off then it will be switched on.

Lenny has spent some time playing with the grid and by now he has pressed each light a certain number of times. Given the number of times each light is pressed, you have to print the current state of each light.",The input consists of three rows. Each row contains three integers each between 0 to 100 inclusive. The *j*-th number in the *i*-th row is the number of times the *j*-th light of the *i*-th row of the grid is pressed.,"Print three lines, each containing three characters. The *j*-th character of the *i*-th line is ""1"" if and only if the corresponding light is switched on, otherwise it's ""0"".","['1 0 0\n0 0 0\n0 0 1\n', '1 0 1\n8 8 8\n2 0 3\n']","['001\n010\n100\n', '010\n011\n100\n']",none,OK,"ans = [[1,1,1],[1,1,1],[1,1,1]]

grid = []

def solve(a):
    if a == 1:
        return 0
    else:
        return 1

for i in range(3):
    a = list(map(int,input().split()))
    grid.append(a)

if grid[0][0] % 2 != 0:
    ans[0][0] = solve(ans[0][0])

    ans[1][0] = solve(ans[1][0])
    ans[0][1] = solve(ans[0][1])

if grid[0][1] % 2 != 0:
    ans[0][1] = solve(ans[0][1])

    ans[0][0] = solve(ans[0][0])
    ans[0][2] = solve(ans[0][2])
    ans[1][1] = solve(ans[1][1])

if grid[0][2] % 2 != 0:
    ans[0][2] = solve(ans[0][2])

    ans[0][1] = solve(ans[0][1])
    ans[1][2] = solve(ans[1][2])

if grid[1][0] % 2 != 0:
    ans[1][0] = solve(ans[1][0])

    ans[0][0] = solve(ans[0][0])
    ans[1][1] = solve(ans[1][1])
    ans[2][0] = solve(ans[2][0])

if grid[1][1] % 2 != 0:
    ans[1][1] = solve(ans[1][1])

    ans[0][1] = solve(ans[0][1])
    ans[1][0] = solve(ans[1][0])
    ans[1][2] = solve(ans[1][2])
    ans[2][1] = solve(ans[2][1])

if grid[1][2] % 2 != 0:
    ans[1][2] = solve(ans[1][2])

    ans[0][2] = solve(ans[0][2])
    ans[1][1] = solve(ans[1][1])
    ans[2][2] = solve(ans[2][2])

if grid[2][0] % 2 != 0:
    ans[2][0] = solve(ans[2][0])

    ans[1][0] = solve(ans[1][0])
    ans[2][1] = solve(ans[2][1])

if grid[2][1] % 2 != 0:
    ans[2][1] = solve(ans[2][1])

    ans[2][0] = solve(ans[2][0])
    ans[1][1] = solve(ans[1][1])
    ans[2][2] = solve(ans[2][2])

if grid[2][2] % 2 != 0:
    ans[2][2] = solve(ans[2][2])

    ans[1][2] = solve(ans[1][2])
    ans[2][1] = solve(ans[2][1])

for i in range(3):
    temp = ''
    for j in range(3):
        temp += str(ans[i][j])
    print(temp)","def toggle_light(grid):

    result = [[1]*3 for _ in range(3)]

    directions = [(0, 0), (0, 1), (1, 0), (0, -1), (-1, 0)]
    
    for i in range(3):
        for j in range(3):

            toggles = grid[i][j]
            for dx, dy in directions:
                ni, nj = i + dx, j + dy
                if 0 <= ni < 3 and 0 <= nj < 3:
                    toggles += grid[ni][nj]

            if toggles % 2 == 1:
                result[i][j] = 0
            else:
                result[i][j] = 1
            
    return result

def print_grid(state):
    for row in state:
        print(''.join(map(str, row)))

import sys
input_data = [list(map(int, line.split())) for line in sys.stdin.read().strip().split('\n')]

current_state = toggle_light(input_data)

print_grid(current_state)"
0,none,none,none,['none'],"First-rate specialists graduate from Berland State Institute of Peace and Friendship. You are one of the most talented students in this university. The education is not easy because you need to have fundamental knowledge in different areas, which sometimes are not related to each other. 

For example, you should know linguistics very well. You learn a structure of Reberland language as foreign language. In this language words are constructed according to the following rules. First you need to choose the ""root"" of the word — some string which has more than 4 letters. Then several strings with the length 2 or 3 symbols are appended to this word. The only restriction —  it is not allowed to append the same string twice in a row. All these strings are considered to be suffixes of the word (this time we use word ""suffix"" to describe a morpheme but not the few last characters of the string as you may used to). 

Here is one exercise that you have found in your task list. You are given the word *s*. Find all distinct strings with the length 2 or 3, which can be suffixes of this word according to the word constructing rules in Reberland language. 

Two strings are considered distinct if they have different length or there is a position in which corresponding characters do not match. 

Let's look at the example: the word *abacabaca* is given. This word can be obtained in the following ways: , where the root of the word is overlined, and suffixes are marked by ""corners"". Thus, the set of possible suffixes for this word is {*aca*,<=*ba*,<=*ca*}.",The only line contains a string *s* (5<=≤<=|*s*|<=≤<=104) consisting of lowercase English letters.,"On the first line print integer *k* — a number of distinct possible suffixes. On the next *k* lines print suffixes. 

Print suffixes in lexicographical (alphabetical) order.","['abacabaca\n', 'abaca\n']","['3\naca\nba\nca\n', '0\n']","The first test was analysed in the problem statement. 

In the second example the length of the string equals 5. The length of the root equals 5, so no string can be used as a suffix.",WRONG_ANSWER,"import sys

sys.setrecursionlimit(10001)

s = input()
ans = set()
checked = set()

def dp(i):
    if i in checked:
        return
    checked.add(i)

    """"""
    (aa)(bb)で後ろのbbをaddすると
    (abb)(bb)でbbをaddできないので前のカタマリをaddする
    """"""

    if i > 6 and s[i - 2:i] != s[i:i + 2]:
        ans.add(s[i - 2:i])
        dp(i - 2)

    if i > 7 and s[i - 3:i] != s[i:i + 3]:
        ans.add(s[i - 3:i])
        dp(i - 3)

dp(len(s))

print(len(ans))
for x in sorted(list(ans)):
    print(x)","def find_suffixes(s):

    suffixes = set()

    root_length = len(s)

    if root_length > 5:

        for i in range(root_length):

            if i + 2 <= root_length:
                suffixes.add(s[i:i + 2])

            if i + 3 <= root_length:
                suffixes.add(s[i:i + 3])

    sorted_suffixes = sorted(suffixes)

    print(len(sorted_suffixes))
    for suffix in sorted_suffixes:
        print(suffix)

input_strings = ['abacabaca\n', 'abaca\n']
for input_string in input_strings:

    find_suffixes(input_string.strip())"
66,B,Petya and Countryside,PROGRAMMING,"['brute force', 'implementation']","Little Petya often travels to his grandmother in the countryside. The grandmother has a large garden, which can be represented as a rectangle 1<=×<=*n* in size, when viewed from above. This rectangle is divided into *n* equal square sections. The garden is very unusual as each of the square sections possesses its own fixed height and due to the newest irrigation system we can create artificial rain above each section.

Creating artificial rain is an expensive operation. That's why we limit ourselves to creating the artificial rain only above one section. At that, the water from each watered section will flow into its neighbouring sections if their height does not exceed the height of the section. That is, for example, the garden can be represented by a 1<=×<=5 rectangle, where the section heights are equal to 4, 2, 3, 3, 2. Then if we create an artificial rain over any of the sections with the height of 3, the water will flow over all the sections, except the ones with the height of 4. See the illustration of this example at the picture:

As Petya is keen on programming, he decided to find such a section that if we create artificial rain above it, the number of watered sections will be maximal. Help him.",The first line contains a positive integer *n* (1<=≤<=*n*<=≤<=1000). The second line contains *n* positive integers which are the height of the sections. All the numbers are no less than 1 and not more than 1000.,"Print a single number, the maximal number of watered sections if we create artificial rain above exactly one section.","['1\n2\n', '5\n1 2 1 2 1\n', '8\n1 2 1 1 1 3 3 4\n']","['1\n', '3\n', '6\n']",none,OK,"def main():
    n = int(input())
    heights = [int(i) for i in input().split()]

    max = 0
    maximal = 0
    for watered in range(n):
        max = 1
        next = watered + 1
        while next < n:
            if heights[next] <= heights[next-1]:
                max += 1
                next += 1
            else:
                break
        prev = watered - 1
        while prev >= 0:
            if heights[prev] <= heights[prev+1]:
                max += 1
                prev -= 1
            else:
                break
        if max > maximal:
            maximal = max
    print(maximal)
if __name__=='__main__':
    main()","def max_watered_sections(n, heights):
    def flood_fill(start_height):

        visited = [False] * n

        stack = [i for i in range(n) if heights[i] == start_height]
        
        while stack:
            current = stack.pop()
            for neighbor in (current - 1, current + 1):
                if 0 <= neighbor < n and not visited[neighbor] and heights[neighbor] <= start_height:
                    visited[neighbor] = True
                    stack.append(neighbor)

        return visited.count(True)

    max_count = 0
    for height in heights:

        count = flood_fill(height)
        max_count = max(max_count, count)

    return max_count

n = int(input().strip())
heights = list(map(int, input().strip().split()))

result = max_watered_sections(n, heights)
print(result)"
629,A,Far Relative’s Birthday Cake,PROGRAMMING,"['brute force', 'combinatorics', 'constructive algorithms', 'implementation']","Door's family is going celebrate Famil Doors's birthday party. They love Famil Door so they are planning to make his birthday cake weird!

The cake is a *n*<=×<=*n* square consisting of equal squares with side length 1. Each square is either empty or consists of a single chocolate. They bought the cake and randomly started to put the chocolates on the cake. The value of Famil Door's happiness will be equal to the number of pairs of cells with chocolates that are in the same row or in the same column of the cake. Famil Doors's family is wondering what is the amount of happiness of Famil going to be?

Please, note that any pair can be counted no more than once, as two different cells can't share both the same row and the same column.","In the first line of the input, you are given a single integer *n* (1<=≤<=*n*<=≤<=100) — the length of the side of the cake.

Then follow *n* lines, each containing *n* characters. Empty cells are denoted with '.', while cells that contain chocolates are denoted by 'C'.","Print the value of Famil Door's happiness, i.e. the number of pairs of chocolate pieces that share the same row or the same column.","['3\n.CC\nC..\nC.C\n', '4\nCC..\nC..C\n.CC.\n.CC.\n']","['4\n', '9\n']","If we number rows from top to bottom and columns from left to right, then, pieces that share the same row in the first sample are: 
 1.  (1, 2) and (1, 3) 1.  (3, 1) and (3, 3)  1.  (2, 1) and (3, 1) 1.  (1, 3) and (3, 3)",OK,"import math

size = int(input())

matrix = []

def ncr(x):
    if x>=2:
        y = math.factorial(x)
        y = y/((math.factorial(x-2))*2)
        return y
    else:
        return 0

for i in range(0,size):
    array = list(str(input()))
    matrix.append(array)

rows = 0
cols = 0

for i in range(0,size):
    buffer = 0
    for j in range(0,size):
        if matrix[i][j] == 'C':
            buffer += 1
    y = ncr(buffer)
    rows += y

for i in range(0,size):
    buffer = 0
    for j in range(0,size):
        if matrix[j][i] == 'C':
            buffer += 1
    y = ncr(buffer)
    cols += y

print(int(cols)+int(rows))","def calculate_happiness(n, cake):

    happiness = 0

    row_counts = [0] * n
    col_counts = [0] * n
    
    for i in range(n):
        for j in range(n):
            if cake[i][j] == 'C':
                row_counts[i] += 1
                col_counts[j] += 1

    for count in row_counts:
        if count > 1:
            happiness += (count * (count - 1)) // 2

    for count in col_counts:
        if count > 1:
            happiness += (count * (count - 1)) // 2
    
    return happiness

n = int(input())
cake = [input().strip() for _ in range(n)]

print(calculate_happiness(n, cake))"
230,B,T-primes,PROGRAMMING,"['binary search', 'implementation', 'math', 'number theory']","We know that prime numbers are positive integers that have exactly two distinct positive divisors. Similarly, we'll call a positive integer *t* Т-prime, if *t* has exactly three distinct positive divisors.

You are given an array of *n* positive integers. For each of them determine whether it is Т-prime or not.","The first line contains a single positive integer, *n* (1<=≤<=*n*<=≤<=105), showing how many numbers are in the array. The next line contains *n* space-separated integers *x**i* (1<=≤<=*x**i*<=≤<=1012).

Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is advised to use the cin, cout streams or the %I64d specifier.","Print *n* lines: the *i*-th line should contain ""YES"" (without the quotes), if number *x**i* is Т-prime, and ""NO"" (without the quotes), if it isn't.",['3\n4 5 6\n'],['YES\nNO\nNO\n'],"The given test has three numbers. The first number 4 has exactly three divisors — 1, 2 and 4, thus the answer for this number is ""YES"". The second number 5 has two divisors (1 and 5), and the third number 6 has four divisors (1, 2, 3, 6), hence the answer for them is ""NO"".",WRONG_ANSWER,"def check(number):
    x = int(number**0.5)
    if x*x != number:
        return False
    for i in range(2, int(x**0.5)+1):
        if x % i == 0:
            return False
    return True

n = int(input())
nums = [int(x) for x in input().split()]
for num in nums:
    print('YES' if check(num) else 'NO')","import math
import sys

def is_prime(num):
    """"""Check if a number is prime.""""""
    if num <= 1:
        return False
    if num <= 3:
        return True
    if num % 2 == 0 or num % 3 == 0:
        return False
    i = 5
    while i * i <= num:
        if num % i == 0 or num % (i + 2) == 0:
            return False
        i += 6
    return True

def preprocess_t_primes(limit):
    """"""Generate a set of T-primes up to the given limit.""""""
    t_primes = set()

    for i in range(2, int(math.isqrt(limit)) + 1):
        if is_prime(i):
            t_primes.add(i * i)
    return t_primes

def main():
    n = int(sys.stdin.readline().strip())
    x = list(map(int, sys.stdin.readline().strip().split()))

    t_primes = preprocess_t_primes(10**12)

    for number in x:
        if number in t_primes:
            print(""YES"")
        else:
            print(""NO"")

if __name__ == ""__main__"":
    main()"
424,A,Squats,PROGRAMMING,['implementation'],"Pasha has many hamsters and he makes them work out. Today, *n* hamsters (*n* is even) came to work out. The hamsters lined up and each hamster either sat down or stood up.

For another exercise, Pasha needs exactly  hamsters to stand up and the other hamsters to sit down. In one minute, Pasha can make some hamster ether sit down or stand up. How many minutes will he need to get what he wants if he acts optimally well?","The first line contains integer *n* (2<=≤<=*n*<=≤<=200; *n* is even). The next line contains *n* characters without spaces. These characters describe the hamsters' position: the *i*-th character equals 'X', if the *i*-th hamster in the row is standing, and 'x', if he is sitting.","In the first line, print a single integer — the minimum required number of minutes. In the second line, print a string that describes the hamsters' position after Pasha makes the required changes. If there are multiple optimal positions, print any of them.","['4\nxxXx\n', '2\nXX\n', '6\nxXXxXx\n']","['1\nXxXx\n', '1\nxX\n', '0\nxXXxXx\n']",none,OK,"def Squats(n, seq):
	cntX = seq.count('X')
	cntx = seq.count('x')

	diffCnt = cntx-cntX

	if diffCnt<0:
		result = seq.replace('X','x',abs(int(n/2) - cntX))
		return abs(int(n/2) - cntX) , result

	elif diffCnt>0:
		result = seq.replace('x','X',abs(int(n/2) - cntX))
		return abs(int(n/2) - cntX), result

	else:
		return 0, seq

n = int(input())
seq = input()

res = Squats(n, seq)
print(res[0])
print(res[1])","n = int(input())

positions = input().strip()

standing_count = positions.count('X')
sitting_count = n - standing_count

required_standing = n // 2

if standing_count < required_standing:
    changes_needed = required_standing - standing_count

    new_positions = positions.replace('x', 'X', changes_needed)
elif standing_count > required_standing:
    changes_needed = standing_count - required_standing

    new_positions = positions.replace('X', 'x', changes_needed)
else:
    changes_needed = 0
    new_positions = positions

print(changes_needed)
print(new_positions)"
205,A,Little Elephant and Rozdil,PROGRAMMING,"['brute force', 'implementation']","The Little Elephant loves Ukraine very much. Most of all he loves town Rozdol (ukr. ""Rozdil"").

However, Rozdil is dangerous to settle, so the Little Elephant wants to go to some other town. The Little Elephant doesn't like to spend much time on travelling, so for his journey he will choose a town that needs minimum time to travel to. If there are multiple such cities, then the Little Elephant won't go anywhere.

For each town except for Rozdil you know the time needed to travel to this town. Find the town the Little Elephant will go to or print ""Still Rozdil"", if he stays in Rozdil.","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=105) — the number of cities. The next line contains *n* integers, separated by single spaces: the *i*-th integer represents the time needed to go from town Rozdil to the *i*-th town. The time values are positive integers, not exceeding 109.

You can consider the cities numbered from 1 to *n*, inclusive. Rozdil is not among the numbered cities.","Print the answer on a single line — the number of the town the Little Elephant will go to. If there are multiple cities with minimum travel time, print ""Still Rozdil"" (without the quotes).","['2\n7 4\n', '7\n7 4 47 100 4 9 12\n']","['2\n', 'Still Rozdil\n']","In the first sample there are only two cities where the Little Elephant can go. The travel time for the first town equals 7, to the second one — 4. The town which is closest to Rodzil (the only one) is the second one, so the answer is 2.

In the second sample the closest cities are cities two and five, the travelling time to both of them equals 4, so the answer is ""Still Rozdil"".",OK,"n=int(input())
l=input().split("" "")
l=[int(x) for x in l]
square_dict = {n: 1 for n in l}
s={}
minNum=min(l)
for i in l:

    if i in s:
      key=i
      s[key]=s.setdefault(key, 0) + 1
    else:
      key=i
      s[key]=s.setdefault(key, 1)
k=minNum
if(s.get(k)>1):
  print(""Still Rozdil"")
else:
  print(l.index(minNum)+1)","def find_closest_city(n, travel_times):

    min_time = min(travel_times)

    min_indices = [i + 1 for i, time in enumerate(travel_times) if time == min_time]

    if len(min_indices) > 1:
        return ""Still Rozdil""
    else:
        return min_indices[0]

n = int(input())
travel_times = list(map(int, input().split()))

result = find_closest_city(n, travel_times)
print(result)"
258,A,Little Elephant and Bits,PROGRAMMING,"['greedy', 'math']","The Little Elephant has an integer *a*, written in the binary notation. He wants to write this number on a piece of paper.

To make sure that the number *a* fits on the piece of paper, the Little Elephant ought to delete exactly one any digit from number *a* in the binary record. At that a new number appears. It consists of the remaining binary digits, written in the corresponding order (possible, with leading zeroes).

The Little Elephant wants the number he is going to write on the paper to be as large as possible. Help him find the maximum number that he can obtain after deleting exactly one binary digit and print it in the binary notation.","The single line contains integer *a*, written in the binary notation without leading zeroes. This number contains more than 1 and at most 105 digits.",In the single line print the number that is written without leading zeroes in the binary notation — the answer to the problem.,"['101\n', '110010\n']","['11\n', '11010\n']","In the first sample the best strategy is to delete the second digit. That results in number 11<sub class=""lower-index"">2</sub> = 3<sub class=""lower-index"">10</sub>.

In the second sample the best strategy is to delete the third or fourth digits — that results in number 11010<sub class=""lower-index"">2</sub> = 26<sub class=""lower-index"">10</sub>.",OK,"def main():
	s=input()
	found=0
	l=len(s)
	for i in range(l):
		if (s[i]=='0' or i==l-1) and not found: 
			found=1
			continue
		print(s[i],end='')

if __name__=='__main__': main()","def maximize_binary(a):

    max_binary = """"
    
    for i in range(len(a)):

        new_binary = a[:i] + a[i+1:]

        if new_binary > max_binary:
            max_binary = new_binary

    return max_binary

binary_input = input().strip()

result = maximize_binary(binary_input)

print(result)"
767,A,Snacktower,PROGRAMMING,"['data structures', 'implementation']","According to an old legeng, a long time ago Ankh-Morpork residents did something wrong to miss Fortune, and she cursed them. She said that at some time *n* snacks of distinct sizes will fall on the city, and the residents should build a Snacktower of them by placing snacks one on another. Of course, big snacks should be at the bottom of the tower, while small snacks should be at the top.

Years passed, and once different snacks started to fall onto the city, and the residents began to build the Snacktower.

However, they faced some troubles. Each day exactly one snack fell onto the city, but their order was strange. So, at some days the residents weren't able to put the new stack on the top of the Snacktower: they had to wait until all the bigger snacks fell. Of course, in order to not to anger miss Fortune again, the residents placed each snack on the top of the tower immediately as they could do it.

Write a program that models the behavior of Ankh-Morpork residents.","The first line contains single integer *n* (1<=≤<=*n*<=≤<=100<=000) — the total number of snacks.

The second line contains *n* integers, the *i*-th of them equals the size of the snack which fell on the *i*-th day. Sizes are distinct integers from 1 to *n*.","Print *n* lines. On the *i*-th of them print the sizes of the snacks which the residents placed on the top of the Snacktower on the *i*-th day in the order they will do that. If no snack is placed on some day, leave the corresponding line empty.","['3\n3 1 2\n', '5\n4 5 1 2 3\n']","['3\n\xa0\n2 1', '5 4\n\xa0\n\xa0\n3 2 1\n']","In the example a snack of size 3 fell on the first day, and the residents immediately placed it. On the second day a snack of size 1 fell, and the residents weren't able to place it because they were missing the snack of size 2. On the third day a snack of size 2 fell, and the residents immediately placed it. Right after that they placed the snack of size 1 which had fallen before.",TIME_LIMIT_EXCEEDED,"def solve(h, v):
    gd=[0]*(h+1)
    tmp=h
    ans=""""
    for i in v:
        gd[i]=1
        while tmp>0 and gd[tmp]==1:
             ans+=str(tmp) + "" ""
             tmp-=1
        ans+=""\n""
    return ans

h=int(input())
v=list(map(int,input().split()))
print(solve(h,v))","def snacktower(n, snacks):

    fallen = set()

    next_snack = n

    result = []

    for snack in snacks:
        fallen.add(snack)
        current_day_output = []

        while next_snack in fallen:
            current_day_output.append(next_snack)
            next_snack -= 1

        result.append("" "".join(map(str, current_day_output)))

    return result

n = int(input().strip())
snacks = list(map(int, input().strip().split()))

output = snacktower(n, snacks)

for line in output:
    print(line)"
0,none,none,none,['none'],"Arkady needs your help again! This time he decided to build his own high-speed Internet exchange point. It should consist of *n* nodes connected with minimum possible number of wires into one network (a wire directly connects two nodes). Exactly *k* of the nodes should be exit-nodes, that means that each of them should be connected to exactly one other node of the network, while all other nodes should be connected to at least two nodes in order to increase the system stability.

Arkady wants to make the system as fast as possible, so he wants to minimize the maximum distance between two exit-nodes. The distance between two nodes is the number of wires a package needs to go through between those two nodes.

Help Arkady to find such a way to build the network that the distance between the two most distant exit-nodes is as small as possible.","The first line contains two integers *n* and *k* (3<=≤<=*n*<=≤<=2·105, 2<=≤<=*k*<=≤<=*n*<=-<=1) — the total number of nodes and the number of exit-nodes.

Note that it is always possible to build at least one network with *n* nodes and *k* exit-nodes within the given constraints.","In the first line print the minimum possible distance between the two most distant exit-nodes. In each of the next *n*<=-<=1 lines print two integers: the ids of the nodes connected by a wire. The description of each wire should be printed exactly once. You can print wires and wires' ends in arbitrary order. The nodes should be numbered from 1 to *n*. Exit-nodes can have any ids.

If there are multiple answers, print any of them.","['3 2\n', '5 3\n']","['2\n1 2\n2 3\n', '3\n1 2\n2 3\n3 4\n3 5\n']","In the first example the only network is shown on the left picture.

In the second example one of optimal networks is shown on the right picture.

Exit-nodes are highlighted.",RUNTIME_ERROR,"from sys import stdin, stdout

def dfs(v, dist):
    visit[v] = 1
    label = dist
    
    for u in vertices[v]:
        if not visit[u]:
            label = max(label, dfs(u, dist + 1))
    
    return label    

n, k = map(int, stdin.readline().split())
challengers = []
ans = []

for i in range(2, k + 2):
    ans.append((1, i))
    challengers.append(i)

n = n - k - 1
v = k + 2

for i in range(n // k):
    update = []
    
    for u in challengers:
        update.append(v)
        ans.append((u, v))
        v += 1
    
    challengers = update[:]

for u in challengers[:n % k]:
    ans.append((u, v))
    v += 1

visit = [0 for i in range(v)]
vertices = [[] for i in range(v)]

for a, b in ans:
    vertices[a].append(b)
    vertices[b].append(a)

stdout.write(str(dfs(v - 1, 0)) + '\n')
for a, b in ans:
    stdout.write(str(a) + ' ' + str(b) + '\n')","def build_network(n, k):

    if k == 1:
        print(0)
        return

    connections = []

    for i in range(1, k):
        connections.append((i, i + 1))

    connections.append((k, n))

    for i in range(k + 1, n):
        connections.append((i, i - 1))

    max_distance = 1 if k > 1 else 0
    print(max_distance)

    for u, v in connections:
        print(u, v)

import sys
input = sys.stdin.read
data = input().strip().split('\n')

for line in data:
    n, k = map(int, line.split())
    build_network(n, k)"
39,G,Inverse Function,PROGRAMMING,['implementation'],"Petya wrote a programme on C++ that calculated a very interesting function *f*(*n*). Petya ran the program with a certain value of *n* and went to the kitchen to have some tea. The history has no records concerning how long the program had been working. By the time Petya returned, it had completed the calculations and had the result. However while Petya was drinking tea, a sly virus managed to destroy the input file so that Petya can't figure out for which value of *n* the program was run. Help Petya, carry out the inverse function!

Mostly, the program consists of a function in C++ with the following simplified syntax:
 -  *function* ::= int f(int n) {*operatorSequence*}-  *operatorSequence* ::= *operator* | *operator* *operatorSequence*-  *operator* ::= return *arithmExpr*; | if (*logicalExpr*) return *arithmExpr*;-  *logicalExpr* ::= *arithmExpr*<=&gt;<=*arithmExpr* | *arithmExpr*<=&lt;<=*arithmExpr* | *arithmExpr* == *arithmExpr*-  *arithmExpr* ::= *sum*-  *sum* ::= *product* | *sum*<=+<=*product* | *sum*<=-<=*product*-  *product* ::= *multiplier* | *product*<=*<=*multiplier* | *product*<=/<=*multiplier*-  *multiplier* ::= n | *number* | f(*arithmExpr*)-  *number* ::= 0|1|2|... |32767 
The whitespaces in a *operatorSequence* are optional.

Thus, we have a function, in which body there are two kinds of operators. There is the operator ""return *arithmExpr*;"" that returns the value of the expression as the value of the function, and there is the conditional operator ""if (*logicalExpr*) return *arithmExpr*;"" that returns the value of the arithmetical expression when and only when the logical expression is true. Guaranteed that no other constructions of C++ language — cycles, assignment operators, nested conditional operators etc, and other variables except the *n* parameter are used in the function. All the constants are integers in the interval [0..32767].

The operators are performed sequentially. After the function has returned a value other operators in the sequence are not performed. Arithmetical expressions are performed taking into consideration the standard priority of the operations. It means that first all the products that are part of the sum are calculated. During the calculation of the products the operations of multiplying and division are performed from the left to the right. Then the summands are summed, and the addition and the subtraction are also performed from the left to the right. Operations ""&gt;"" (more), ""&lt;"" (less) and ""=="" (equals) also have standard meanings.

Now you've got to pay close attention! The program is compiled with the help of 15-bit Berland C++ compiler invented by a Berland company BerSoft, that's why arithmetical operations are performed in a non-standard way. Addition, subtraction and multiplication are performed modulo 32768 (if the result of subtraction is negative, then 32768 is added to it until the number belongs to the interval [0..32767]). Division ""/"" is a usual integer division where the remainder is omitted.

Examples of arithmetical operations: 

Guaranteed that for all values of *n* from 0 to 32767 the given function is performed correctly. That means that:

1. Division by 0 never occures.

2. When performing a function for the value *n*<==<=*N* recursive calls of the function *f* may occur only for the parameter value of 0,<=1,<=...,<=*N*<=-<=1. Consequently, the program never has an infinite recursion.

3. As the result of the sequence of the operators, the function always returns a value.

We have to mention that due to all the limitations the value returned by the function *f* is independent from either global variables or the order of performing the calculations of arithmetical expressions as part of the logical one, or from anything else except the value of *n* parameter. That's why the *f* function can be regarded as a function in its mathematical sense, i.e. as a unique correspondence between any value of *n* from the interval [0..32767] and a value of *f*(*n*) from the same interval.

Given the value of *f*(*n*), and you should find *n*. If the suitable *n* value is not unique, you should find the maximal one (from the interval [0..32767]).","The first line has an integer *f*(*n*) from the interval [0..32767]. The next lines have the description of the function *f*. In the description can be found extra spaces and line breaks (see the examples) which, of course, can’t break key words int, if, return and numbers. The size of input data can’t exceed 100 bytes.","Output a single number — the answer to the problem. If there’s no answer, output ""-1"" (without quotes).","['17\nint f(int n)\n{\nif (n &lt; 100) return 17;\nif (n &gt; 99) return 27;\n}\n', '13\nint f(int n)\n{\nif (n == 0) return 0;\nreturn f(n - 1) + 1;\n}\n', '144\nint f(int n)\n{\nif (n == 0) return 0;\nif (n == 1) return n;\nreturn f(n - 1) + f(n - 2);\n}']","['99\n', '13', '24588\n']",none,RUNTIME_ERROR,"import re, sys, functools

def cut_modulo(x):
    y = x % 32768
    if (y < 0):
        y += 32768
    return y

class berland_cpp_int:
    def __init__(self, x):
        self.value = cut_modulo(int(x))
    def __add__(self, x):
        return berland_cpp_int(cut_modulo(self.value + x.value))
    def __sub__(self, x):
        return berland_cpp_int(cut_modulo(self.value - x.value))
    def __mul__(self, x):
        return berland_cpp_int(cut_modulo(self.value * x.value))
    def __div__(self, x):
        return berland_cpp_int(cut_modulo(self.value // x.value))
    def __and__(self, x):
        return berland_cpp_int(cut_modulo(self.value & x.value))
    def __eq__(self, x):
        return self.value == x.value
    def __lt__(self, x):
        return self.value < x.value
    def __gt__(self, x):
        return self.value > x.value
    def __str__(self):
        return str(self.value)
    def __int__(self):
        return self.value
    def __hash__(self):
      return self.value

def translate_program(source_code):
    s = source_code
    s = s.replace('\n', '')
    s = s.replace('{', '')
    s = s.replace('}', '')
    s = re.sub('([0-9]+)', 'berland_cpp_int(\\1)', s)
    
    s = s.replace('int f(int n)', \
                  '\[email protected]_cache(maxsize=None)\ndef f(n):\n\t')
 
    s = re.sub('return(.*?);', 'return berland_cpp_int(\\1);', s)
    s = s.replace(';', '\n\t')
    s = s.replace('return', ':return')
    s = re.sub('\t[ :]+', '\t', s)

    return s

file_input = sys.stdin.read().split('\n')

nnn = int(file_input[0])
source = '\n'.join(file_input[1:])
compiled = translate_program(source)

exec(compiled)

vals = list(map(lambda x: f(berland_cpp_int(x)), range(32768)))
vals = list(map(lambda x: x.value, vals))

ans = -1

for i in range(32768):
    if (vals[i] == nnn):
        ans = i

print(ans)","def evaluate_expression(expr, n):

    expr = expr.replace('n', str(n))
    return eval(expr) % 32768

def execute_function(n, function_body):

    for line in function_body:
        line = line.strip()
        if line.startswith('if'):
            condition = line[line.index('(')+1:line.index(')')]
            if evaluate_expression(condition, n):
                return evaluate_expression(line[line.index('return')+6:line.index(';')], n)
        elif line.startswith('return'):
            return evaluate_expression(line[7:], n)
    return -1

def find_n_for_f(target_f, function_body):

    possible_n = []
    for n in range(32768):
        if execute_function(n, function_body) == target_f:
            possible_n.append(n)
    return max(possible_n) if possible_n else -1

def main():
    import sys
    
    input_data = sys.stdin.read().strip().split('\n')
    f_n = int(input_data[0].strip())
    function_definition = ''.join(input_data[1:]).split('{')[1].split('}')[0].strip().splitlines()
    
    result_n = find_n_for_f(f_n, function_definition)
    print(result_n)

if __name__ == ""__main__"":
    main()"
496,C,Removing Columns,PROGRAMMING,"['brute force', 'constructive algorithms', 'implementation']","You are given an *n*<=×<=*m* rectangular table consisting of lower case English letters. In one operation you can completely remove one column from the table. The remaining parts are combined forming a new table. For example, after removing the second column from the table

 

we obtain the table:

 

A table is called good if its rows are ordered from top to bottom lexicographically, i.e. each row is lexicographically no larger than the following one. Determine the minimum number of operations of removing a column needed to make a given table good.","The first line contains two integers  — *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=100).

Next *n* lines contain *m* small English letters each — the characters of the table.",Print a single number — the minimum number of columns that you need to remove in order to make the table good.,"['1 10\ncodeforces\n', '4 4\ncase\ncare\ntest\ncode\n', '5 4\ncode\nforc\nesco\ndefo\nrces\n']","['0\n', '2\n', '4\n']","In the first sample the table is already good.

In the second sample you may remove the first and third column.

In the third sample you have to remove all the columns (note that the table where all rows are empty is considered good by definition).

Let strings *s* and *t* have equal length. Then, *s* is lexicographically larger than *t* if they are not equal and the character following the largest common prefix of *s* and *t* (the prefix may be empty) in *s* is alphabetically larger than the corresponding character of *t*.",WRONG_ANSWER,"def solve():
    n,m=map(int,input().split())
    A=[list(input()) for i in range(n)]
    if(n==1):
        print(0)
        return
    count=0
    j=0
    while (j<len(A[0])):
        br=0
        for i in range(n-1):
            if not (A[i][j]<=A[i+1][j]):
                br=1
                break
        if (br):
            for i in range(n):
                del(A[i][j])
            count+=1
        else:
            j+=1
        B=A[::]
        A.sort()
        if(B==A):
            print(count)
            return
        A=B[::]

solve()","def min_operations_to_make_good_table(n, m, table):

    cols_to_remove = 0

    for j in range(m):

        for i in range(1, n):

            if table[i-1][j] > table[i][j]:

                cols_to_remove += 1
                break
                
    return cols_to_remove

if __name__ == ""__main__"":
    import sys
    
    input_data = sys.stdin.read().strip().split('\n')
    n, m = map(int, input_data[0].split())
    table = [input_data[i + 1] for i in range(n)]

    print(min_operations_to_make_good_table(n, m, table))"
424,B,Megacity,PROGRAMMING,"['binary search', 'greedy', 'implementation', 'sortings']","The administration of the Tomsk Region firmly believes that it's time to become a megacity (that is, get population of one million). Instead of improving the demographic situation, they decided to achieve its goal by expanding the boundaries of the city.

The city of Tomsk can be represented as point on the plane with coordinates (0; 0). The city is surrounded with *n* other locations, the *i*-th one has coordinates (*x**i*, *y**i*) with the population of *k**i* people. You can widen the city boundaries to a circle of radius *r*. In such case all locations inside the circle and on its border are included into the city.

Your goal is to write a program that will determine the minimum radius *r*, to which is necessary to expand the boundaries of Tomsk, so that it becomes a megacity.","The first line of the input contains two integers *n* and *s* (1<=≤<=*n*<=≤<=103; 1<=≤<=*s*<=&lt;<=106) — the number of locatons around Tomsk city and the population of the city. Then *n* lines follow. The *i*-th line contains three integers — the *x**i* and *y**i* coordinate values of the *i*-th location and the number *k**i* of people in it (1<=≤<=*k**i*<=&lt;<=106). Each coordinate is an integer and doesn't exceed 104 in its absolute value.

It is guaranteed that no two locations are at the same point and no location is at point (0; 0).","In the output, print ""-1"" (without the quotes), if Tomsk won't be able to become a megacity. Otherwise, in the first line print a single real number — the minimum radius of the circle that the city needs to expand to in order to become a megacity.

The answer is considered correct if the absolute or relative error don't exceed 10<=-<=6.","['4 999998\n1 1 1\n2 2 1\n3 3 1\n2 -2 1\n', '4 999998\n1 1 2\n2 2 1\n3 3 1\n2 -2 1\n', '2 1\n1 1 999997\n2 2 1\n']","['2.8284271\n', '1.4142136\n', '-1']",none,WRONG_ANSWER,"def solve(need):
   if need <= 0:
      print(0)
      return

   location = [] 
   for _ in range(n):
      x, y, k = map(int, input().split())
      location.append(((x**2 + y**2)**0.5, k))
   location.sort()

   for r, population in location:
      if need > 0:
         need -= population  
      else: 
         break
   print(""{:.7f}"".format(r))

n, s = map(int, input().split())
need = 10**6 - s
solve(need)","import math
import sys

def minimum_radius_to_megacity(n, s, locations):

    target_population = 1000000 - s
    if target_population <= 0:
        return 0.0

    distance_population = []

    for x, y, k in locations:

        distance = math.sqrt(x**2 + y**2)
        distance_population.append((distance, k))

    distance_population.sort()

    current_population = 0

    for distance, population in distance_population:
        current_population += population
        if current_population >= target_population:
            return distance

    return -1

input_lines = sys.stdin.read().strip().split('\n')
n, s = map(int, input_lines[0].split())
locations = [tuple(map(int, line.split())) for line in input_lines[1:n+1]]

result = minimum_radius_to_megacity(n, s, locations)

if result == -1:
    print(result)
else:
    print(f""{result:.7f}"")"
110,A,Nearly Lucky Number,PROGRAMMING,['implementation'],"Petya loves lucky numbers. We all know that lucky numbers are the positive integers whose decimal representations contain only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.

Unfortunately, not all numbers are lucky. Petya calls a number nearly lucky if the number of lucky digits in it is a lucky number. He wonders whether number *n* is a nearly lucky number.","The only line contains an integer *n* (1<=≤<=*n*<=≤<=1018).

Please do not use the %lld specificator to read or write 64-bit numbers in С++. It is preferred to use the cin, cout streams or the %I64d specificator.","Print on the single line ""YES"" if *n* is a nearly lucky number. Otherwise, print ""NO"" (without the quotes).","['40047\n', '7747774\n', '1000000000000000000\n']","['NO\n', 'YES\n', 'NO\n']","In the first sample there are 3 lucky digits (first one and last two), so the answer is ""NO"".

In the second sample there are 7 lucky digits, 7 is lucky number, so the answer is ""YES"".

In the third sample there are no lucky digits, so the answer is ""NO"".",OK,"def main():
    s = input()
    cnt = 0
    for i in s:
        if i == '4' or i == '7':
            cnt += 1
    if cnt == 4 or cnt == 7:
        print('YES')
    else:
        print('NO')

if __name__ == '__main__':
    main()","def is_lucky_number(num):
    return all(d in '47' for d in str(num))

n = int(input().strip())

lucky_count = sum(1 for digit in str(n) if digit in '47')

if is_lucky_number(lucky_count):
    print(""YES"")
else:
    print(""NO"")"
664,A,Complicated GCD,PROGRAMMING,"['math', 'number theory']","Greatest common divisor *GCD*(*a*,<=*b*) of two positive integers *a* and *b* is equal to the biggest integer *d* such that both integers *a* and *b* are divisible by *d*. There are many efficient algorithms to find greatest common divisor *GCD*(*a*,<=*b*), for example, Euclid algorithm. 

Formally, find the biggest integer *d*, such that all integers *a*,<=*a*<=+<=1,<=*a*<=+<=2,<=...,<=*b* are divisible by *d*. To make the problem even more complicated we allow *a* and *b* to be up to googol, 10100 — such number do not fit even in 64-bit integer type!",The only line of the input contains two integers *a* and *b* (1<=≤<=*a*<=≤<=*b*<=≤<=10100).,Output one integer — greatest common divisor of all integers from *a* to *b* inclusive.,"['1 2\n', '61803398874989484820458683436563811772030917980576 61803398874989484820458683436563811772030917980576\n']","['1\n', '61803398874989484820458683436563811772030917980576\n']",none,WRONG_ANSWER,"nums1, nums2 = map(int, input().split())

def GCD(a, b):
    if b == 0:
        return a
    return GCD(b, b%a)

print(GCD(max(nums1, nums2), min(nums1, nums2)))","def gcd_of_range(a, b):

    if a == b:
        return a

    return 1

input_data = input().strip()
a_str, b_str = input_data.split()

a = int(a_str)
b = int(b_str)

result = gcd_of_range(a, b)

print(result)"
633,A,Ebony and Ivory,PROGRAMMING,"['brute force', 'math', 'number theory']","Dante is engaged in a fight with ""The Savior"". Before he can fight it with his sword, he needs to break its shields. He has two guns, Ebony and Ivory, each of them is able to perform any non-negative number of shots.

For every bullet that hits the shield, Ebony deals *a* units of damage while Ivory deals *b* units of damage. In order to break the shield Dante has to deal exactly *c* units of damage. Find out if this is possible.","The first line of the input contains three integers *a*, *b*, *c* (1<=≤<=*a*,<=*b*<=≤<=100,<=1<=≤<=*c*<=≤<=10<=000) — the number of units of damage dealt by Ebony gun and Ivory gun, and the total number of damage required to break the shield, respectively.","Print ""Yes"" (without quotes) if Dante can deal exactly *c* damage to the shield and ""No"" (without quotes) otherwise.","['4 6 15\n', '3 2 7\n', '6 11 6\n']","['No\n', 'Yes\n', 'Yes\n']","In the second sample, Dante can fire 1 bullet from Ebony and 2 from Ivory to deal exactly 1·3 + 2·2 = 7 damage. In the third sample, Dante can fire 1 bullet from ebony and no bullets from ivory to do 1·6 + 0·11 = 6 damage.",COMPILATION_ERROR,"def extended_gcd(a,b):
    global g,x,y
    if b==0:
        g=a
        x,y=1,0
    else:
        extended_gcd(b,a%b)
        temp = x
        x = y
        y = temp - ((a//b)*y)
        
        

if __name__==""__main__"":
    a,b,c=map(int,input().split())
    g=x=y=int()
    extended_gcd(a,b)
    if (c%a==0) or (c%b==0) or (c%g==0):
        print(""Yes"")
        continue
    elif x<0 and y<0:
        print(""No"")
    elif x>0 and y>0:
        print(""Yes"")","def can_deal_damage(a, b, c):

    for x in range(c // a + 1):
        if (c - a * x) % b == 0:
            return True
    return False

input_data = ['4 6 15\n', '3 2 7\n', '6 11 6\n']
output_data = []

for line in input_data:
    a, b, c = map(int, line.strip().split())
    if can_deal_damage(a, b, c):
        output_data.append(""Yes\n"")
    else:
        output_data.append(""No\n"")

print(output_data)"
808,G,Anthem of Berland,PROGRAMMING,"['dp', 'strings']","Berland has a long and glorious history. To increase awareness about it among younger citizens, King of Berland decided to compose an anthem.

Though there are lots and lots of victories in history of Berland, there is the one that stand out the most. King wants to mention it in the anthem as many times as possible.

He has already composed major part of the anthem and now just needs to fill in some letters. King asked you to help him with this work.

The anthem is the string *s* of no more than 105 small Latin letters and question marks. The most glorious victory is the string *t* of no more than 105 small Latin letters. You should replace all the question marks with small Latin letters in such a way that the number of occurrences of string *t* in string *s* is maximal.

Note that the occurrences of string *t* in *s* can overlap. Check the third example for clarification.","The first line contains string of small Latin letters and question marks *s* (1<=≤<=|*s*|<=≤<=105).

The second line contains string of small Latin letters *t* (1<=≤<=|*t*|<=≤<=105).

Product of lengths of strings |*s*|·|*t*| won't exceed 107.",Output the maximum number of occurrences of string *t* you can achieve by replacing all the question marks in string *s* with small Latin letters.,"['winlose???winl???w??\nwin\n', 'glo?yto?e??an?\nor\n', '??c?????\nabcab\n']","['5\n', '3\n', '2\n']","In the first example the resulting string *s* is ""winlosewinwinlwinwin""

In the second example the resulting string *s* is ""glorytoreorand"". The last letter of the string can be arbitrary.

In the third example occurrences of string *t* are overlapping. String *s* with maximal number of occurrences of *t* is ""abcabcab"".",TIME_LIMIT_EXCEEDED,"from string import ascii_lowercase

def prefix_function(s):
    n = len(s)
    pi = [0]*n
    for i in range(1, n):
        j = pi[i-1]
        while j>0 and s[i] != s[j]:
            j = pi[j-1]
        if s[i] == s[j]:
            j+=1
        pi[i] = j
    return pi

s = input()
t = input()
pi = prefix_function(t+'
next = [[0]*26 for _ in range(len(t)+1)]
for i in range(len(t)+1):
    for k,c in enumerate(ascii_lowercase):
        j = i
        while j>0 and c != (t+'
            j = pi[j-1]
        if c == t[j]:
            next[i][k] = j+1
        else:
            next[i][k] = j
dp = [[-1]*(len(t)+1) for _ in range(len(s)+1)]
pivals = {0}
for i,c in enumerate(s,start=1):
    npivals = set()
    if c == '?':
        for c in ascii_lowercase:
            for p in pivals:
                np = next[p][ord(c) - ord('a')]
                dp[i][np] = max(0, dp[i-1][p], dp[i][np])
                npivals.add(np)
                if np == len(t):
                    dp[i][np] += 1
    else:
        for p in pivals:
            np = next[p][ord(c) - ord('a')]
            dp[i][np] = max(0, dp[i-1][p], dp[i][np])
            npivals.add(np)
            if np == len(t):
                dp[i][np] += 1
    pivals = npivals
print(max(dp[-1]))","def max_occurrences(s, t):
    len_s = len(s)
    len_t = len(t)

    count = 0

    def can_match(i):
        for j in range(len_t):
            if s[i + j] != '?' and s[i + j] != t[j]:
                return False
        return True

    s_list = list(s)

    for i in range(len_s - len_t + 1):
        if can_match(i):
            count += 1

            for j in range(len_t):
                if s_list[i + j] == '?':
                    s_list[i + j] = t[j]

    for i in range(len_s):
        if s_list[i] == '?':
            s_list[i] = 'a'

    return count

import sys
input = sys.stdin.read
data = input().strip().split('\n')

s = data[0]
t = data[1]

result = max_occurrences(s, t)
print(result)"
967,A,Mind the Gap,PROGRAMMING,['implementation'],"These days Arkady works as an air traffic controller at a large airport. He controls a runway which is usually used for landings only. Thus, he has a schedule of planes that are landing in the nearest future, each landing lasts $1$ minute.

He was asked to insert one takeoff in the schedule. The takeoff takes $1$ minute itself, but for safety reasons there should be a time space between the takeoff and any landing of at least $s$ minutes from both sides.

Find the earliest time when Arkady can insert the takeoff.","The first line of input contains two integers $n$ and $s$ ($1 \le n \le 100$, $1 \le s \le 60$) — the number of landings on the schedule and the minimum allowed time (in minutes) between a landing and a takeoff.

Each of next $n$ lines contains two integers $h$ and $m$ ($0 \le h \le 23$, $0 \le m \le 59$) — the time, in hours and minutes, when a plane will land, starting from current moment (i. e. the current time is $0$ $0$). These times are given in increasing order.",Print two integers $h$ and $m$ — the hour and the minute from the current moment of the earliest time Arkady can insert the takeoff.,"['6 60\n0 0\n1 20\n3 21\n5 0\n19 30\n23 40\n', '16 50\n0 30\n1 20\n3 0\n4 30\n6 10\n7 50\n9 30\n11 10\n12 50\n14 30\n16 10\n17 50\n19 30\n21 10\n22 50\n23 59\n', '3 17\n0 30\n1 0\n12 0\n']","['6 1\n', '24 50\n', '0 0\n']","In the first example note that there is not enough time between 1:20 and 3:21, because each landing and the takeoff take one minute.

In the second example there is no gaps in the schedule, so Arkady can only add takeoff after all landings. Note that it is possible that one should wait more than $24$ hours to insert the takeoff.

In the third example Arkady can insert the takeoff even between the first landing.",OK,"def next(h1, m1, minutes):
    return (h1 + (m1 + minutes) // 60, (m1 + minutes) % 60)

n, s = map(int, input().split())
schedule = []

for i in range(n):
    schedule.append(tuple(map(int, input().split())))

if schedule[0][0] * 60 + schedule[0][1] >= s + 1:
    print('0 0')
else:
    for i in range(1, len(schedule)):
        if (schedule[i][0] - schedule[i-1][0]) * 60 + (schedule[i][1] - schedule[i-1][1]) >= 2 * s + 2:
            res = next(schedule[i-1][0], schedule[i-1][1], s + 1)
            print(str(res[0]) + ' ' + str(res[1]))
            break;
    else:
        res = next(schedule[i][0], schedule[i][1], s + 1)
        print(str(res[0]) + ' ' + str(res[1]))","def earliest_takeoff(n, s, landings):

    landing_times = []
    for h, m in landings:
        landing_times.append(h * 60 + m)

    earliest_time = 0

    if landing_times[0] >= s + 1:
        return divmod(earliest_time, 60)

    for i in range(n - 1):
        current_end = landing_times[i] + 1 + s
        next_start = landing_times[i + 1] - s
        if next_start >= current_end:
            return divmod(current_end, 60)

    last_landing_end = landing_times[-1] + 1
    return divmod(last_landing_end + s, 60)

n, s = map(int, input().split())
landings = [tuple(map(int, input().split())) for _ in range(n)]

h, m = earliest_takeoff(n, s, landings)
print(h, m)"
389,B,Fox and Cross,PROGRAMMING,"['greedy', 'implementation']","Fox Ciel has a board with *n* rows and *n* columns. So, the board consists of *n*<=×<=*n* cells. Each cell contains either a symbol '.', or a symbol '#'.

A cross on the board is a connected set of exactly five cells of the board that looks like a cross. The picture below shows how it looks.

Ciel wants to draw several (may be zero) crosses on the board. Each cross must cover exactly five cells with symbols '#', and any cell with symbol '#' must belong to some cross. No two crosses can share a cell.

Please, tell Ciel if she can draw the crosses in the described way.","The first line contains an integer *n* (3<=≤<=*n*<=≤<=100) — the size of the board.

Each of the next *n* lines describes one row of the board. The *i*-th line describes the *i*-th row of the board and consists of *n* characters. Each character is either a symbol '.', or a symbol '#'.","Output a single line with ""YES"" if Ciel can draw the crosses in the described way. Otherwise output a single line with ""NO"".","['5\n.#...\n####.\n.####\n...#.\n.....\n', '4\n####\n####\n####\n####\n', '6\n.#....\n####..\n.####.\n.#.##.\n######\n.#..#.\n', '6\n.#..#.\n######\n.####.\n.####.\n######\n.#..#.\n', '3\n...\n...\n...\n']","['YES\n', 'NO\n', 'YES\n', 'NO\n', 'YES\n']","In example 1, you can draw two crosses. The picture below shows what they look like.

In example 2, the board contains 16 cells with '#', but each cross contains 5. Since 16 is not a multiple of 5, so it's impossible to cover all.",OK,"def check(a, b, n):
	return a>=0 and b>=0 and a<n and b<n

def solve():
	n = int(input())
	ar = []
	for i in range(n):
		ar.append(input())

	cross = [[0]*n for _ in range(n)]

	addc = [(1, 0), (2, 0), (1, -1), (1, 1)]

	for i in range(n):
		for j in range(n):
			if ar[i][j] == ""
				cross[i][j] = 1
				for a, b in addc:
					if check(i+a, j+b, n):

						if ar[i+a][j+b] == ""
							cross[i+a][j+b] = 1
						else:
							print(""NO"")
							return
					else:
						print(""NO"")
						return
	print(""YES"")

solve()","def can_draw_crosses(n, board):

    def place_cross(x, y):

        if (x < 1 or x >= n - 1 or y < 1 or y >= n - 1 or
                board[x][y] != '
                board[x-1][y] != '
                board[x+1][y] != '
                board[x][y-1] != '
                board[x][y+1] != '
            return False

        board[x][y] = '.'
        board[x-1][y] = '.'
        board[x+1][y] = '.'
        board[x][y-1] = '.'
        board[x][y+1] = '.'
        return True

    for i in range(n):
        for j in range(n):
            if place_cross(i, j):
                continue

    for row in board:
        if '
            return ""NO""
    
    return ""YES""

n = int(input())
board = [list(input().strip()) for _ in range(n)]

result = can_draw_crosses(n, board)
print(result)"
976,A,Minimum Binary Number,PROGRAMMING,['implementation'],"String can be called correct if it consists of characters ""0"" and ""1"" and there are no redundant leading zeroes. Here are some examples: ""0"", ""10"", ""1001"".

You are given a correct string *s*.

You can perform two different operations on this string: 
 1.  swap any pair of adjacent characters (for example, ""101""  ""110""); 1.  replace ""11"" with ""1"" (for example, ""110""  ""10""). 
Let *val*(*s*) be such a number that *s* is its binary representation.

Correct string *a* is less than some other correct string *b* iff *val*(*a*)<=&lt;<=*val*(*b*).

Your task is to find the minimum correct string that you can obtain from the given one using the operations described above. You can use these operations any number of times in any order (or even use no operations at all).","The first line contains integer number *n* (1<=≤<=*n*<=≤<=100) — the length of string *s*.

The second line contains the string *s* consisting of characters ""0"" and ""1"". It is guaranteed that the string *s* is correct.",Print one string — the minimum correct string that you can obtain from the given one.,"['4\n1001\n', '1\n1\n']","['100\n', '1\n']","In the first example you can obtain the answer by the following sequence of operations: ""1001"" <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> ""1010"" <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> ""1100"" <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> ""100"".

In the second example you can't obtain smaller answer no matter what operations you use.",OK,"import sys
input = sys.stdin.buffer.readline

def process(S):
    if S=='0':
        sys.stdout.write('0')
        return
    d = [0, 0]
    for c in S:
        d[int(c)]+=1
    answer = ['1']
    for i in range(d[0]):
        answer.append('0')
    answer = ''.join(answer)
    sys.stdout.write(answer)
    return

n = int(input())
S = input().decode()[:-2]
process(S)","def minimum_correct_string(n, s):

    count_0 = s.count('0')
    count_1 = s.count('1')

    if count_1 == 0:
        return ""0""

    min_string = '1' + '0' * count_0 + '1' * (count_1 - 1)
    
    return min_string

inputs = ['4\n1001\n', '1\n1\n']
for input_str in inputs:
    n, s = input_str.strip().split('\n')
    n = int(n)
    result = minimum_correct_string(n, s)
    print(result)"
672,A,Summer Camp,PROGRAMMING,['implementation'],"Every year, hundreds of people come to summer camps, they learn new algorithms and solve hard problems.

This is your first year at summer camp, and you are asked to solve the following problem. All integers starting with 1 are written in one line. The prefix of these line is ""123456789101112131415..."". Your task is to print the *n*-th digit of this string (digits are numbered starting with 1.",The only line of the input contains a single integer *n* (1<=≤<=*n*<=≤<=1000) — the position of the digit you need to print.,Print the *n*-th digit of the line.,"['3\n', '11\n']","['3\n', '0\n']","In the first sample the digit at position 3 is '3', as both integers 1 and 2 consist on one digit.

In the second sample, the digit at position 11 is '0', it belongs to the integer 10.",OK,"s = ''
for i in range(1,371):
    s+=str(i)
def solve():
    n = int(input())
    print(s[n-1])
for _ in range(1):
    solve()","def find_digit(n):

    length = 1
    count = 9
    start = 1

    while n > length * count:
        n -= length * count
        length += 1
        count *= 10
        start *= 10

    start += (n - 1) // length
    number_str = str(start)
    return number_str[(n - 1) % length]

if __name__ == ""__main__"":
    import sys

    input_data = sys.stdin.read().strip().split('\n')

    results = []
    for line in input_data:
        n = int(line)
        digit = find_digit(n)
        results.append(digit)

    print(""\n"".join(results))"
688,B,Lovely Palindromes,PROGRAMMING,"['constructive algorithms', 'math']","Pari has a friend who loves palindrome numbers. A palindrome number is a number that reads the same forward or backward. For example 12321, 100001 and 1 are palindrome numbers, while 112 and 1021 are not.

Pari is trying to love them too, but only very special and gifted people can understand the beauty behind palindrome numbers. Pari loves integers with even length (i.e. the numbers with even number of digits), so she tries to see a lot of big palindrome numbers with even length (like a 2-digit 11 or 6-digit 122221), so maybe she could see something in them.

Now Pari asks you to write a program that gets a huge integer *n* from the input and tells what is the *n*-th even-length positive palindrome number?",The only line of the input contains a single integer *n* (1<=≤<=*n*<=≤<=10100<=000).,Print the *n*-th even-length palindrome number.,"['1\n', '10\n']","['11\n', '1001\n']","The first 10 even-length palindrome numbers are 11, 22, 33, ... , 88, 99 and 1001.",OK,"from sys import stdin,stdout

n = input()
print(n+n[::-1])","def nth_even_length_palindrome(n):

    n_str = str(n)

    first_half = str(n)

    palindrome = first_half + first_half[::-1]
    
    return palindrome

n = int(input().strip())

result = nth_even_length_palindrome(n)

print(result)"
669,A,Little Artem and Presents,PROGRAMMING,['math'],"Little Artem got *n* stones on his birthday and now wants to give some of them to Masha. He knows that Masha cares more about the fact of receiving the present, rather than the value of that present, so he wants to give her stones as many times as possible. However, Masha remembers the last present she received, so Artem can't give her the same number of stones twice in a row. For example, he can give her 3 stones, then 1 stone, then again 3 stones, but he can't give her 3 stones and then again 3 stones right after that.

How many times can Artem give presents to Masha?",The only line of the input contains a single integer *n* (1<=≤<=*n*<=≤<=109) — number of stones Artem received on his birthday.,Print the maximum possible number of times Artem can give presents to Masha.,"['1\n', '2\n', '3\n', '4\n']","['1\n', '1\n', '2\n', '3\n']","In the first sample, Artem can only give 1 stone to Masha.

In the second sample, Atrem can give Masha 1 or 2 stones, though he can't give her 1 stone two times.

In the third sample, Atrem can first give Masha 2 stones, a then 1 more stone.

In the fourth sample, Atrem can first give Masha 1 stone, then 2 stones, and finally 1 stone again.",OK,"def solve(n):
  if n == 1:
    return 1
  return n-round(n/3)
  
def main():
  n =int(input())
  print(solve(n))

main()","def max_gifts(n):

    if n == 1:
        return 1

    elif n == 2:
        return 1

    else:

        return (n + 1) // 2

n = int(input())

result = max_gifts(n)

print(result)"
6,B,President's Office,PROGRAMMING,['implementation'],"President of Berland has a very vast office-room, where, apart from him, work his subordinates. Each subordinate, as well as President himself, has his own desk of a unique colour. Each desk is rectangular, and its sides are parallel to the office walls. One day President decided to establish an assembly, of which all his deputies will be members. Unfortunately, he does not remember the exact amount of his deputies, but he remembers that the desk of each his deputy is adjacent to his own desk, that is to say, the two desks (President's and each deputy's) have a common side of a positive length.

The office-room plan can be viewed as a matrix with *n* rows and *m* columns. Each cell of this matrix is either empty, or contains a part of a desk. An uppercase Latin letter stands for each desk colour. The «period» character («.») stands for an empty cell.","The first line contains two separated by a space integer numbers *n*, *m* (1<=≤<=*n*,<=*m*<=≤<=100) — the length and the width of the office-room, and *c* character — the President's desk colour. The following *n* lines contain *m* characters each — the office-room description. It is guaranteed that the colour of each desk is unique, and each desk represents a continuous subrectangle of the given matrix. All colours are marked by uppercase Latin letters.",Print the only number — the amount of President's deputies.,"['3 4 R\nG.B.\n.RR.\nTTT.\n', '3 3 Z\n...\n.H.\n..Z\n']","['2\n', '0\n']",none,COMPILATION_ERROR,"// lose small or win big.

using ll = int64_t;
using ld = long double;
using ull = uint64_t;
using namespace std;
using namespace __gnu_pbds;
typedef vector <int> vi;
typedef pair <int, int> ii;

const int INF = 1 << 30;

int dr[] = {-1, 0, 1, 0};
int dc[] = {0, 1, 0, -1};

int main() {

    freopen(""in.txt"", ""r"", stdin); freopen(""out.txt"", ""w"", stdout);

    ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); cout.setf(ios::fixed); cout.precision(6);

    int n, m;
    char c;

    cin >> n >> m >> c;
    vector <string> a(n);

    for(int i = 0; i < n; i++) {
        cin >> a[i];
    }

    vector <vi> b(n, vi(m));

    function <bool(int, int)> bound = [&](int x, int y) {
        return x >= 0 and y >= 0 and x < n and y < m;
    };

    function <void(int, int, char)> flood = [&](int x, int y, char d) {
        if(bound(x, y) and a[x][y] == d) {
            a[x][y] = '.';
            for(int k = 0; k < 4; k++) {
                flood(x + dr[k], y + dc[k], d);
            }
        }
    };

    int ans = 0;
    for(int i = 0; i < n; i++) {
        for(int j = 0; j < m; j++) {
            if(a[i][j] == 'R') {
                for(int k = 0; k < 4; k++) {
                    int tx = i + dr[k];
                    int ty = j + dc[k];
                    if(bound(tx, ty) and a[tx][ty] != 'R' and a[tx][ty] != '.' and !b[tx][ty]) {
                        ans++;
                        flood(tx, ty, a[tx][ty]);
                    }
                }
            }
        }
    }

    cout << ans << ""\n"";
}","def count_deputies(n, m, president_color, office):

    deputy_count = 0

    grid = [list(row) for row in office]

    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]

    def in_bounds(x, y):
        return 0 <= x < n and 0 <= y < m

    def is_deputy_desk(x, y):
        if grid[x][y] == president_color:
            return False

        for dx, dy in directions:
            nx, ny = x + dx, y + dy
            if in_bounds(nx, ny) and grid[nx][ny] == president_color:
                return True
        return False

    desks = set()
    for i in range(n):
        for j in range(m):
            if grid[i][j] != '.':
                desks.add(grid[i][j])

    for desk in desks:
        if desk != president_color:

            for i in range(n):
                for j in range(m):
                    if grid[i][j] == desk and is_deputy_desk(i, j):
                        deputy_count += 1
                        break

    return deputy_count

import sys

input_data = sys.stdin.read().strip().splitlines()
first_line = input_data[0].split()
n, m = int(first_line[0]), int(first_line[1])
president_color = first_line[2]
office_description = input_data[1:]

result = count_deputies(n, m, president_color, office_description)
print(result)"
331,C1,The Great Julya Calendar,PROGRAMMING,['dp'],"Yet another Armageddon is coming! This time the culprit is the Julya tribe calendar. 

The beavers in this tribe knew math very well. Smart Beaver, an archaeologist, got a sacred plate with a magic integer on it. The translation from Old Beaverish is as follows: 

""May the Great Beaver bless you! May your chacres open and may your third eye never turn blind from beholding the Truth! Take the magic number, subtract a digit from it (the digit must occur in the number) and get a new magic number. Repeat this operation until a magic number equals zero. The Earth will stand on Three Beavers for the time, equal to the number of subtractions you perform!""

Distinct subtraction sequences can obviously get you different number of operations. But the Smart Beaver is ready to face the worst and is asking you to count the minimum number of operations he needs to reduce the magic number to zero.","The single line contains the magic integer *n*, 0<=≤<=*n*.
 -  to get 20 points, you need to solve the problem with constraints: *n*<=≤<=106 (subproblem C1); -  to get 40 points, you need to solve the problem with constraints: *n*<=≤<=1012 (subproblems C1+C2); -  to get 100 points, you need to solve the problem with constraints: *n*<=≤<=1018 (subproblems C1+C2+C3).",Print a single integer — the minimum number of subtractions that turns the magic number to a zero.,['24\n'],['5'],In the first test sample the minimum number of operations can be reached by the following sequence of subtractions:,OK,"import sys

dp = {}

def one_step(n):
    val = max(int(c) for c in str(n))
    return n - val

def solve_iter(n):
    res = 0
    while n > 0:
        n = one_step(n)
        res += 1
    return res

for m in range(1, 10):
    for a in range(10):
        num = int(f""{m}9{a}"")
        down_to = int(f""{m-1}99"")
        steps = 0
        while num > down_to:
            num = one_step(num)

            steps += 1
        dp[m, 1, a] = steps, num % 10

def steps(m, k, a):
    if (m, k, a) in dp:
        return dp[m, k, a]
    if m == 0:
        return steps(9, k-1, a)
    assert k > 1, (m, k, a)
    assert m > 0, (m, k, a)
    res, last = 0, a
    for y in range(0, 10)[::-1]:
        st, last = steps(max(m, y), k-1, last)
        res += st
    dp[m, k, a] = res, last
    return res, last

for m in range(1, 10):
    for k in range(1, 3):
        for a in range(10):
            steps(m, k, a)

def solve(n):
    a = n % 10
    res = 0
    def mk():
        nc = n // 10
        k = 0
        m = 0
        while nc % 10 == 9:
            k += 1
            nc //= 10
        while nc != 0:
            m = max(m, nc % 10)
            nc //= 10
        return m, k
        
    while n != 0:
        print(n, file=sys.stderr)
        m, k = mk()
        if k == 0:

            res += 1
            n = one_step(n)
        elif k == 1 and m == 0:
            res += 1
            n = one_step(n)
        else:
            hops, last = steps(m, k, n % 10)
            if m == 0:
                n = ((n//10**(k))-1)*10**(k)+((10**(k-1))-1)*10+last
            else:
                n = ((n//10**(k+1))-1)*10**(k+1)+((10**k)-1)*10+last
            res+=hops

    print(res)
        
N = int(input())
solve(N)","def min_operations_to_zero(n):

    str_n = str(n)

    operations = 0

    while n > 0:

        max_digit = max(int(digit) for digit in str_n)

        n -= max_digit

        operations += 1

        str_n = str(n)
    
    return operations

input_value = int(input().strip())

print(min_operations_to_zero(input_value))"
414,B,Mashmokh and ACM,PROGRAMMING,"['combinatorics', 'dp', 'number theory']","Mashmokh's boss, Bimokh, didn't like Mashmokh. So he fired him. Mashmokh decided to go to university and participate in ACM instead of finding a new job. He wants to become a member of Bamokh's team. In order to join he was given some programming tasks and one week to solve them. Mashmokh is not a very experienced programmer. Actually he is not a programmer at all. So he wasn't able to solve them. That's why he asked you to help him with these tasks. One of these tasks is the following.

A sequence of *l* integers *b*1,<=*b*2,<=...,<=*b**l* (1<=≤<=*b*1<=≤<=*b*2<=≤<=...<=≤<=*b**l*<=≤<=*n*) is called good if each number divides (without a remainder) by the next number in the sequence. More formally  for all *i* (1<=≤<=*i*<=≤<=*l*<=-<=1).

Given *n* and *k* find the number of good sequences of length *k*. As the answer can be rather large print it modulo 1000000007 (109<=+<=7).","The first line of input contains two space-separated integers *n*,<=*k* (1<=≤<=*n*,<=*k*<=≤<=2000).",Output a single integer — the number of good sequences of length *k* modulo 1000000007 (109<=+<=7).,"['3 2\n', '6 4\n', '2 1\n']","['5\n', '39\n', '2\n']","In the first sample the good sequences are: [1, 1], [2, 2], [3, 3], [1, 2], [1, 3].",WRONG_ANSWER,"import math

def dividors(n):
    d = []
    for i in range(1, int(math.sqrt(n))+1):
        if n%i == 0:
            d.append(i)
            if i*i != n:
                d.append(n//i)
    return d

nm, km = map(int, input().split())
dp = [[0]*(nm+1) for i in range(km+1)]
div = [dividors(i) for i in range(nm+1)]
for n in range(1, nm+1):
    dp[1][n] = 1
for k in range(1, km+1):
    dp[k][1] = 1
for k in range(2, km+1):
    for n in range(2, nm+1):
        for d in div[n]:
            dp[k][n] = (dp[k][n] + dp[k-1][d]) % 1000000007
print(sum(dp[k]))","MOD = 1000000007

def count_good_sequences(n, k):

    dp = [[0] * (k + 1) for _ in range(n + 1)]

    for i in range(1, n + 1):
        dp[i][1] = 1

    for length in range(2, k + 1):
        for last in range(1, n + 1):
            for multiple in range(last, n + 1, last):
                dp[multiple][length] = (dp[multiple][length] + dp[last][length - 1]) % MOD

    total_good_sequences = sum(dp[i][k] for i in range(1, n + 1)) % MOD
    return total_good_sequences

import sys
input = sys.stdin.read
data = input().strip().split('\n')
results = []

for line in data:
    n, k = map(int, line.split())
    results.append(count_good_sequences(n, k))

for result in results:
    print(result)"
845,C,Two TVs,PROGRAMMING,"['data structures', 'greedy', 'sortings']","Polycarp is a great fan of television.

He wrote down all the TV programs he is interested in for today. His list contains *n* shows, *i*-th of them starts at moment *l**i* and ends at moment *r**i*.

Polycarp owns two TVs. He can watch two different shows simultaneously with two TVs but he can only watch one show at any given moment on a single TV. If one show ends at the same moment some other show starts then you can't watch them on a single TV.

Polycarp wants to check out all *n* shows. Are two TVs enough to do so?","The first line contains one integer *n* (1<=≤<=*n*<=≤<=2·105) — the number of shows.

Each of the next *n* lines contains two integers *l**i* and *r**i* (0<=≤<=*l**i*<=&lt;<=*r**i*<=≤<=109) — starting and ending time of *i*-th show.","If Polycarp is able to check out all the shows using only two TVs then print ""YES"" (without quotes). Otherwise, print ""NO"" (without quotes).","['3\n1 2\n2 3\n4 5\n', '4\n1 2\n2 3\n2 3\n1 2\n']","['YES\n', 'NO\n']",none,WRONG_ANSWER,"n = int(input())
a = [n]
b = [n]
for i in range(n):
    x, y = map(int, input().split())
    a.append(x)
    b.append(y)
a.pop(0)
b.pop(0)

def huj(n):
    for i in range(n - 1):
        if a[i] >= a[i+1] or b[i] >= b[i+1]:
            return False
    return True

if huj(n) == True:
    print('YES')
else:
    print('NO')","def can_watch_all_shows(n, shows):

    events = []
    for l, r in shows:
        events.append((l, 1))
        events.append((r, -1))

    events.sort(key=lambda x: (x[0], x[1]))

    current_shows = 0
    for _, event in events:
        current_shows += event

        if current_shows > 2:
            return ""NO""
    
    return ""YES""

import sys
input = sys.stdin.read
data = input().strip().split('\n')
n = int(data[0])
shows = [tuple(map(int, line.split())) for line in data[1:]]

print(can_watch_all_shows(n, shows))"
253,A,Boys and Girls,PROGRAMMING,['greedy'],"There are *n* boys and *m* girls studying in the class. They should stand in a line so that boys and girls alternated there as much as possible. Let's assume that positions in the line are indexed from left to right by numbers from 1 to *n*<=+<=*m*. Then the number of integers *i* (1<=≤<=*i*<=&lt;<=*n*<=+<=*m*) such that positions with indexes *i* and *i*<=+<=1 contain children of different genders (position *i* has a girl and position *i*<=+<=1 has a boy or vice versa) must be as large as possible. 

Help the children and tell them how to form the line.","The single line of the input contains two integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=100), separated by a space.","Print a line of *n*<=+<=*m* characters. Print on the *i*-th position of the line character ""B"", if the *i*-th position of your arrangement should have a boy and ""G"", if it should have a girl. 

Of course, the number of characters ""B"" should equal *n* and the number of characters ""G"" should equal *m*. If there are multiple optimal solutions, print any of them.","['3 3\n', '4 2\n']","['GBGBGB\n', 'BGBGBB\n']","In the first sample another possible answer is BGBGBG. 

In the second sample answer BBGBGB is also optimal.",WRONG_ANSWER,"def hw6problemE():
    x = str(input())
    xsplit = x.split()
    n = int(xsplit[0])
    m = int(xsplit[1])
    if n == m:
        rsnt = """"
        for i in range(0, n):
            rsnt = rsnt + ""B""
            rsnt = rsnt + ""G""
        print(rsnt)
    elif n > m:
        r = n - m
        rsnt = """"
        for i in range(0,m):
            rsnt = rsnt + ""B""
            rsnt = rsnt + ""G""
        rsnt = rsnt + r * ""B""
        print(rsnt)
    else:
        r = m - n
        rsnt = """"
        for i in range(0, n):
            rsnt = rsnt + ""G""
            rsnt = rsnt + ""B""
        rsnt = rsnt + r * ""G""
        print(rsnt)","def form_line(n, m):

    if n > m:
        pattern = 'BGB'
    else:
        pattern = 'GB'

    line = []
    while n > 0 or m > 0:
        if pattern == 'BGB':
            if n > 0:
                line.append('B')
                n -= 1
            if m > 0:
                line.append('G')
                m -= 1
        else:
            if m > 0:
                line.append('G')
                m -= 1
            if n > 0:
                line.append('B')
                n -= 1

    return ''.join(line)

input_data = input().strip()
n, m = map(int, input_data.split())

result = form_line(n, m)
print(result)"
551,B,ZgukistringZ,PROGRAMMING,"['brute force', 'constructive algorithms', 'implementation', 'strings']","Professor GukiZ doesn't accept string as they are. He likes to swap some letters in string to obtain a new one.

GukiZ has strings *a*, *b*, and *c*. He wants to obtain string *k* by swapping some letters in *a*, so that *k* should contain as many non-overlapping substrings equal either to *b* or *c* as possible. Substring of string *x* is a string formed by consecutive segment of characters from *x*. Two substrings of string *x* overlap if there is position *i* in string *x* occupied by both of them.

GukiZ was disappointed because none of his students managed to solve the problem. Can you help them and find one of possible strings *k*?","The first line contains string *a*, the second line contains string *b*, and the third line contains string *c* (1<=≤<=|*a*|,<=|*b*|,<=|*c*|<=≤<=105, where |*s*| denotes the length of string *s*).

All three strings consist only of lowercase English letters. 

It is possible that *b* and *c* coincide.","Find one of possible strings *k*, as described in the problem statement. If there are multiple possible answers, print any of them.","['aaa\na\nb\n', 'pozdravstaklenidodiri\nniste\ndobri\n', 'abbbaaccca\nab\naca\n']","['aaa', 'nisteaadddiiklooprrvz', 'ababacabcc']","In the third sample, this optimal solutions has three non-overlaping substrings equal to either *b* or *c* on positions 1 – 2 (*ab*), 3 – 4 (*ab*), 5 – 7 (*aca*). In this sample, there exist many other optimal solutions, one of them would be *acaababbcc*.",MEMORY_LIMIT_EXCEEDED,"from fileinput import *

for line in input():
    if lineno() == 1:
        a = line.strip()
    if lineno() == 2:
        b = line.strip()
    if lineno() == 3:
        c = line.strip()

la = len(a)
list_a = list(a)
ld = []

lb = len(b)
lc = len(c)

def how_many_sets(substring, string):
    ls = len(substring)
    range_obj = range(ls)
    count = [0] * ls 
    string_list = list(string)

    for i in range(ls):
        letter = substring[i]
        if letter in string_list:
            del string_list[string_list.index(letter)]
        else:
            return 0

    return 1 + how_many_sets(substring, ''.join(string_list))

mb = how_many_sets(b, a)
mc = how_many_sets(c, a)

if mb < mc:
    b, c = c, b
    lb, lc = lc, lb
    mb, mc = mc, mb

answer = b * mb

for i in range(len(answer)):
    del list_a[list_a.index(answer[i])]

aa = ''.join(list_a)
mc = how_many_sets(c, aa)

answer += c * mc
list_a = list(a)

for i in range(len(answer)):
    del list_a[list_a.index(answer[i])]

answer = answer + ''.join(list_a)
print(answer)","def get_string_k(a, b, c):
    from collections import Counter

    count_a = Counter(a)
    count_b = Counter(b)
    count_c = Counter(c)

    max_b = min(count_a[char] // count_b[char] for char in count_b)
    max_c = min(count_a[char] // count_c[char] for char in count_c)

    best_k = """"
    best_count = -1

    for b_count in range(max_b + 1):
        for c_count in range(max_c + 1):
            remaining_chars = count_a.copy()

            for char in count_b:
                remaining_chars[char] -= count_b[char] * b_count

            for char in count_c:
                remaining_chars[char] -= count_c[char] * c_count

            current_k = b * b_count + c * c_count

            for char in remaining_chars:
                current_k += char * remaining_chars[char]

            current_count = b_count + c_count
            if current_count > best_count:
                best_count = current_count
                best_k = current_k
    
    return best_k

if __name__ == ""__main__"":
    input_data = ['aaa', 'a', 'b', 'pozdravstaklenidodiri', 'niste', 'dobri', 'abbbaaccca', 'ab', 'aca']
    results = []

    for i in range(0, len(input_data), 3):
        a = input_data[i]
        b = input_data[i + 1]
        c = input_data[i + 2]
        results.append(get_string_k(a, b, c))

    for result in results:
        print(result)"
177,F1,Script Generation,PROGRAMMING,[],"The Smart Beaver from ABBYY was offered a job of a screenwriter for the ongoing TV series. In particular, he needs to automate the hard decision: which main characters will get married by the end of the series.

There are *n* single men and *n* single women among the main characters. An opinion poll showed that viewers like several couples, and a marriage of any of them will make the audience happy. The Smart Beaver formalized this fact as *k* triples of numbers (*h*,<=*w*,<=*r*), where *h* is the index of the man, *w* is the index of the woman, and *r* is the measure of the audience's delight in case of the marriage of this couple. The same poll showed that the marriage of any other couple will leave the audience indifferent, so the screenwriters decided not to include any such marriages in the plot.

The script allows you to arrange several marriages between the heroes or not to arrange marriages at all. A subset of some of the *k* marriages is considered acceptable if each man and each woman is involved in at most one marriage of the subset (the series won't allow any divorces). The value of the acceptable set of marriages is the total delight the spectators will get from the marriages included in this set.

Obviously, there is a finite number of acceptable sets, and they all describe some variants of the script. The screenwriters do not want to choose a set with maximum value — it would make the plot too predictable. So the Smart Beaver offers the following option: sort all the acceptable sets in increasing order of value and choose the *t*-th set from the sorted list. Thus, *t*<==<=1 corresponds to a plot without marriages, *t*<==<=2 — to a single marriage resulting in minimal delight for the audience, and so on.

Help the Beaver to implement the algorithm for selecting the desired set.","The first input line contains integers *n*, *k* and *t* (1<=≤<=*k*<=≤<=*min*(100,<=*n*2), 1<=≤<=*t*<=≤<=2·105), separated by single spaces. Next *k* lines contain triples of integers (*h*,<=*w*,<=*r*) (1<=≤<=*h*,<=*w*<=≤<=*n*; 1<=≤<=*r*<=≤<=1000), separated by single spaces, which describe the possible marriages. It is guaranteed that the input data is correct: *t* doesn't exceed the total number of acceptable sets, and each pair (*h*,<=*w*) is present in at most one triple.

The input limitations for getting 30 points are: 
 -  1<=≤<=*n*<=≤<=5 
The input limitations for getting 100 points are: 
 -  1<=≤<=*n*<=≤<=20",Print a single number — the value of the *t*-th acceptable variant.,"['2 4 3\n1 1 1\n1 2 2\n2 1 3\n2 2 7\n', '2 4 7\n1 1 1\n1 2 2\n2 1 3\n2 2 7\n']","['2\n', '8\n']",The figure shows 7 acceptable sets of marriages that exist in the first sample.,OK,"I=lambda:list(map(int,input().split()))
n,k,T=I()
t=[I()for _ in '0'*k]
def b(h,w,r,a):
	if h>n:a+=[r]
	else:
		b(h+1,w,r,a)
		for f,s,v in t:
			if f==h and s in w:b(h+1,w-set([s]),r+v,a)
	return a
print(sorted(b(1,set(range(1,n+1)), 0,[]))[T-1])","from itertools import combinations

def get_marriage_value(marriages, man_count, woman_count):
    values = []

    for i in range(len(marriages) + 1):
        for combo in combinations(marriages, i):
            seen_men = set()
            seen_women = set()
            total_value = 0
            valid = True
            for h, w, r in combo:
                if h in seen_men or w in seen_women:
                    valid = False
                    break
                seen_men.add(h)
                seen_women.add(w)
                total_value += r
            if valid:
                values.append(total_value)

    values.sort()
    return values

def main():

    n, k, t = map(int, input().split())
    marriages = [tuple(map(int, input().split())) for _ in range(k)]

    values = get_marriage_value(marriages, n, n)

    print(values[t - 1])

if __name__ == ""__main__"":
    main()"
791,A,Bear and Big Brother,PROGRAMMING,['implementation'],"Bear Limak wants to become the largest of bears, or at least to become larger than his brother Bob.

Right now, Limak and Bob weigh *a* and *b* respectively. It's guaranteed that Limak's weight is smaller than or equal to his brother's weight.

Limak eats a lot and his weight is tripled after every year, while Bob's weight is doubled after every year.

After how many full years will Limak become strictly larger (strictly heavier) than Bob?",The only line of the input contains two integers *a* and *b* (1<=≤<=*a*<=≤<=*b*<=≤<=10) — the weight of Limak and the weight of Bob respectively.,"Print one integer, denoting the integer number of years after which Limak will become strictly larger than Bob.","['4 7\n', '4 9\n', '1 1\n']","['2\n', '3\n', '1\n']","In the first sample, Limak weighs 4 and Bob weighs 7 initially. After one year their weights are 4·3 = 12 and 7·2 = 14 respectively (one weight is tripled while the other one is doubled). Limak isn't larger than Bob yet. After the second year weights are 36 and 28, so the first weight is greater than the second one. Limak became larger than Bob after two years so you should print 2.

In the second sample, Limak's and Bob's weights in next years are: 12 and 18, then 36 and 36, and finally 108 and 72 (after three years). The answer is 3. Remember that Limak wants to be larger than Bob and he won't be satisfied with equal weights.

In the third sample, Limak becomes larger than Bob after the first year. Their weights will be 3 and 2 then.",RUNTIME_ERROR,"def solve():
    years = 0
    a = int(input())
    b = int(input())
    while a <= b:
        a *= 3
        b *= 2
        years += 1
    return years

print(solve())","def years_until_larger(a, b):
    years = 0

    while a <= b:
        a *= 3
        b *= 2
        years += 1
    return years

a, b = map(int, input().split())

print(years_until_larger(a, b))"
893,C,Rumor,PROGRAMMING,"['dfs and similar', 'graphs', 'greedy']","Vova promised himself that he would never play computer games... But recently Firestorm — a well-known game developing company — published their newest game, World of Farcraft, and it became really popular. Of course, Vova started playing it.

Now he tries to solve a quest. The task is to come to a settlement named Overcity and spread a rumor in it.

Vova knows that there are *n* characters in Overcity. Some characters are friends to each other, and they share information they got. Also Vova knows that he can bribe each character so he or she starts spreading the rumor; *i*-th character wants *c**i* gold in exchange for spreading the rumor. When a character hears the rumor, he tells it to all his friends, and they start spreading the rumor to their friends (for free), and so on.

The quest is finished when all *n* characters know the rumor. What is the minimum amount of gold Vova needs to spend in order to finish the quest?

Take a look at the notes if you think you haven't understood the problem completely.","The first line contains two integer numbers *n* and *m* (1<=≤<=*n*<=≤<=105,<=0<=≤<=*m*<=≤<=105) — the number of characters in Overcity and the number of pairs of friends.

The second line contains *n* integer numbers *c**i* (0<=≤<=*c**i*<=≤<=109) — the amount of gold *i*-th character asks to start spreading the rumor.

Then *m* lines follow, each containing a pair of numbers (*x**i*,<=*y**i*) which represent that characters *x**i* and *y**i* are friends (1<=≤<=*x**i*,<=*y**i*<=≤<=*n*, *x**i*<=≠<=*y**i*). It is guaranteed that each pair is listed at most once.",Print one number — the minimum amount of gold Vova has to spend in order to finish the quest.,"['5 2\n2 5 3 4 8\n1 4\n4 5\n', '10 0\n1 2 3 4 5 6 7 8 9 10\n', '10 5\n1 6 2 7 3 8 4 9 5 10\n1 2\n3 4\n5 6\n7 8\n9 10\n']","['10\n', '55\n', '15\n']","In the first example the best decision is to bribe the first character (he will spread the rumor to fourth character, and the fourth one will spread it to fifth). Also Vova has to bribe the second and the third characters, so they know the rumor.

In the second example Vova has to bribe everyone.

In the third example the optimal decision is to bribe the first, the third, the fifth, the seventh and the ninth characters.",MEMORY_LIMIT_EXCEEDED,"import sys
input = sys.stdin.readline

def inInt():
    return int(input())

def inStr():
    return input().strip(""\n"")

def inIList():
    return(list(map(int, input().split())))

def inSList():
    return(input().split())

def bsearch(nums, target):
    N = len(nums or [])
    l = 0
    r = N - 1

    while l <= r:
        mid = ((l + r) // 2)
        if nums[mid] < target:
            l = mid + 1
        elif nums[mid] > target:
            r = mid - 1
        else:
            return (None, mid, None)

    return (r if r >= 0 else None, None, l if l <= N-1 else None)

def yesOrNo(val):
    print(""YES"" if val else ""NO"")

def printSpacedArray(nums):
    print(*nums)

def solve():
    print()

def DFS(n, graph, seen):
    if seen[n]:
        return 0
    stack = []
    stack.append(n)

    m = 1000000001

    while stack:
        s = stack.pop()

        if not seen[s]:
            m = min(m, c[s])
            seen[s] = True

        for node in range(len(graph[s])):
            if graph[s][node]:
                if not seen[node]:
                    stack.append(node)
    return m

n, m = inIList()

graph = [[False for i in range(n)] for i in range(n)]
c = inIList()
for i in range(m):
    x, y = inIList()
    graph[x-1][y-1] = True
    graph[y-1][x-1] = True

seen = [False for i in range(n)]
total = 0
for i in range(n):
    total += DFS(i, graph, seen)
print(total)","def min_gold_to_spread_rumor(n, m, costs, friendships):
    from collections import defaultdict, deque

    graph = defaultdict(list)
    for x, y in friendships:
        graph[x - 1].append(y - 1)
        graph[y - 1].append(x - 1)

    visited = [False] * n
    total_cost = 0

    def bfs(start):
        queue = deque([start])
        visited[start] = True
        min_cost = costs[start]
        
        while queue:
            node = queue.popleft()
            for neighbor in graph[node]:
                if not visited[neighbor]:
                    visited[neighbor] = True
                    queue.append(neighbor)
                    min_cost = min(min_cost, costs[neighbor])

        return min_cost

    for i in range(n):
        if not visited[i]:
            total_cost += bfs(i)

    return total_cost

import sys

input_data = sys.stdin.read().strip().splitlines()
n, m = map(int, input_data[0].split())
costs = list(map(int, input_data[1].split()))
friendships = [tuple(map(int, line.split())) for line in input_data[2:2 + m]]

print(min_gold_to_spread_rumor(n, m, costs, friendships))"
25,A,IQ test,PROGRAMMING,['brute force'],"Bob is preparing to pass IQ test. The most frequent task in this test is to find out which one of the given *n* numbers differs from the others. Bob observed that one number usually differs from the others in evenness. Help Bob — to check his answers, he needs a program that among the given *n* numbers finds one that is different in evenness.","The first line contains integer *n* (3<=≤<=*n*<=≤<=100) — amount of numbers in the task. The second line contains *n* space-separated natural numbers, not exceeding 100. It is guaranteed, that exactly one of these numbers differs from the others in evenness.",Output index of number that differs from the others in evenness. Numbers are numbered from 1 in the input order.,"['5\n2 4 7 8 10\n', '4\n1 2 1 1\n']","['3\n', '2\n']",none,WRONG_ANSWER,"import fileinput as fi

def odd_one_out(nums):
	even_found, odd_found = False, False
	for index in range(len(nums)):
		next = nums[index]
		if (((next % 2 == 0) and odd_found) or ((next % 2 == 1) and even_found)):
			return index + 1
		elif ((next % 2 == 0) and not (even_found)):
			even_found = True
		elif ((next % 2 == 1) and not (odd_found)):
			odd_found = True

if __name__ == '__main__':
	argz = fi.input()
	argz[0]
	argline = argz[1]
	nums_as_str = argline.split("" "")
	nums = [int(s) for s in nums_as_str]
	print(odd_one_out(nums))","def find_different_evenness(n, numbers):

    even_count = 0
    odd_count = 0
    for number in numbers:
        if number % 2 == 0:
            even_count += 1
        else:
            odd_count += 1

    if even_count == 1:

        for i in range(n):
            if numbers[i] % 2 == 0:
                return i + 1
    else:

        for i in range(n):
            if numbers[i] % 2 != 0:
                return i + 1

input_data = input().strip().split('\n')
n = int(input_data[0])
numbers = list(map(int, input_data[1].split()))

result_index = find_different_evenness(n, numbers)

print(result_index)"
946,B,Weird Subtraction Process,PROGRAMMING,"['math', 'number theory']","You have two variables *a* and *b*. Consider the following sequence of actions performed with these variables:
1.  If *a*<==<=0 or *b*<==<=0, end the process. Otherwise, go to step 2;1.  If *a*<=≥<=2·*b*, then set the value of *a* to *a*<=-<=2·*b*, and repeat step 1. Otherwise, go to step 3;1.  If *b*<=≥<=2·*a*, then set the value of *b* to *b*<=-<=2·*a*, and repeat step 1. Otherwise, end the process.
Initially the values of *a* and *b* are positive integers, and so the process will be finite.

You have to determine the values of *a* and *b* after the process ends.","The only line of the input contains two integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=1018). *n* is the initial value of variable *a*, and *m* is the initial value of variable *b*.",Print two integers — the values of *a* and *b* after the end of the process.,"['12 5\n', '31 12\n']","['0 1\n', '7 12\n']","Explanations to the samples:
1.  *a* = 12, *b* = 5 <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> *a* = 2, *b* = 5 <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> *a* = 2, *b* = 1 <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> *a* = 0, *b* = 1;1.  *a* = 31, *b* = 12 <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> *a* = 7, *b* = 12.",RUNTIME_ERROR,"a,b = map(int,input().split())

def one(a,b):
    if(a==0) or (b==0):
        print(a,b)
        exit()
    else:
        two(a,b)
        
def two(a,b):
    if(a>=2*b):
        a=a-2*b
        one(a,b)
    else:
        three(a,b)
        
def three(a,b):
    if(b>=2*a):
        b=b-2*a
        one(a,b)
    else:
        print(a,b)
        exit()
        
one(a,b)","def process_variables(a, b):
    while a > 0 and b > 0:
        if a <= 2 * b:
            a -= 2 * b
            continue
        if b <= 2 * a:
            b -= 2 * a
            continue
        break
    return a, b

n, m = map(int, input().split())

result_a, result_b = process_variables(n, m)

print(result_a, result_b)"
455,C,Civilization,PROGRAMMING,"['dfs and similar', 'dp', 'dsu', 'ternary search', 'trees']","Andrew plays a game called ""Civilization"". Dima helps him.

The game has *n* cities and *m* bidirectional roads. The cities are numbered from 1 to *n*. Between any pair of cities there either is a single (unique) path, or there is no path at all. A path is such a sequence of distinct cities *v*1,<=*v*2,<=...,<=*v**k*, that there is a road between any contiguous cities *v**i* and *v**i*<=+<=1 (1<=≤<=*i*<=&lt;<=*k*). The length of the described path equals to (*k*<=-<=1). We assume that two cities lie in the same region if and only if, there is a path connecting these two cities.

During the game events of two types take place:
 1.  Andrew asks Dima about the length of the longest path in the region where city *x* lies. 1.  Andrew asks Dima to merge the region where city *x* lies with the region where city *y* lies. If the cities lie in the same region, then no merging is needed. Otherwise, you need to merge the regions as follows: choose a city from the first region, a city from the second region and connect them by a road so as to minimize the length of the longest path in the resulting region. If there are multiple ways to do so, you are allowed to choose any of them. 
Dima finds it hard to execute Andrew's queries, so he asks you to help him. Help Dima.","The first line contains three integers *n*, *m*, *q* (1<=≤<=*n*<=≤<=3·105; 0<=≤<=*m*<=&lt;<=*n*; 1<=≤<=*q*<=≤<=3·105) — the number of cities, the number of the roads we already have and the number of queries, correspondingly.

Each of the following *m* lines contains two integers, *a**i* and *b**i* (*a**i*<=≠<=*b**i*; 1<=≤<=*a**i*,<=*b**i*<=≤<=*n*). These numbers represent the road between cities *a**i* and *b**i*. There can be at most one road between two cities.

Each of the following *q* lines contains one of the two events in the following format:
 -  1 *x**i*. It is the request Andrew gives to Dima to find the length of the maximum path in the region that contains city *x**i* (1<=≤<=*x**i*<=≤<=*n*).  2 *x**i* *y**i*. It is the request Andrew gives to Dima to merge the region that contains city *x**i* and the region that contains city *y**i* (1<=≤<=*x**i*,<=*y**i*<=≤<=*n*). Note, that *x**i* can be equal to *y**i*. ",For each event of the first type print the answer on a separate line.,['6 0 6\n2 1 2\n2 3 4\n2 5 6\n2 3 2\n2 5 3\n1 1\n'],['4\n'],none,MEMORY_LIMIT_EXCEEDED,"import fractions
import gc
import heapq
import itertools
from itertools import combinations, permutations
import math
import random
from collections import Counter, deque, defaultdict
from sys import stdout
import time
from math import factorial, log, gcd
import sys
from decimal import Decimal
import threading
from heapq import *
from fractions import Fraction
from bisect import bisect_left, bisect_right

def S():
	return sys.stdin.readline().split()

def I():
	return [int(i) for i in sys.stdin.readline().split()]

def II():
	return int(sys.stdin.readline())

def IS():
	return sys.stdin.readline().replace('\n', '')
	

def main():
	n, m, q = I()
	tree = [[] for _ in range(n)]
	for _ in range(m):
		u, v = I()
		tree[u - 1].append(v - 1)
		tree[v - 1].append(u - 1)
	
	link = [-1] * n
	out_link = [[] for _ in range(n)]
	weights = [0] * n
	for i in range(n):
		if link[i] == -1:
			queue = deque([(i, 0, i)])
			mx = (0, i)
			while queue:
				v, d, p = queue.pop()
				link[v] = i
				out_link[i].append(v)
				for u in tree[v]:
					if p != u:
						mx = max(mx, (d + 1, u))
						queue.append((u, d + 1, v))
			
			queue = deque([(mx[1], 0, mx[1])])
			mx = (0, 0)
			while queue:
				v, d, p = queue.pop()
				for u in tree[v]:
					if p != u:
						mx = max(mx, (d + 1, u))
						queue.append((u, d + 1, v))
				
			weights[i] = mx[0]
	
	for _ in range(q):
		t, *z = I()
		if t == 1:
			x = z[0]
			print(weights[link[x - 1]])
		else:
			x, y = z
			if x != y:
				head_x = link[x - 1]
				head_y = link[y - 1]
				if len(out_link[head_x]) > len(out_link[head_y]):
					head_x, head_y = head_y, head_x
				
				for i in out_link[head_x]:
					link[i] = head_y
					out_link[head_y].append(i)
				out_link[head_x] = []
				
				w1, w2 = weights[head_x], weights[head_y]
				weights[head_y] = max([w1, w2, w1 // 2 + w1 % 2 + w2 // 2 + w2 % 2 + 1])
				weights[head_x] = 0
	

if __name__ == '__main__':
	mod = 998244353

	main()","class DisjointSet:
    def __init__(self, n):
        self.parent = list(range(n + 1))
        self.rank = [1] * (n + 1)
        self.max_path_length = [0] * (n + 1)

    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]

    def union(self, x, y, added_length):
        root_x = self.find(x)
        root_y = self.find(y)
        if root_x != root_y:

            if self.rank[root_x] > self.rank[root_y]:
                self.parent[root_y] = root_x
                self.max_path_length[root_x] = max(self.max_path_length[root_x], self.max_path_length[root_y] + added_length)
            elif self.rank[root_x] < self.rank[root_y]:
                self.parent[root_x] = root_y
                self.max_path_length[root_y] = max(self.max_path_length[root_y], self.max_path_length[root_x] + added_length)
            else:
                self.parent[root_y] = root_x
                self.max_path_length[root_x] = max(self.max_path_length[root_x], self.max_path_length[root_y] + added_length)
                self.rank[root_x] += 1

def main():
    import sys
    input = sys.stdin.read
    data = input().splitlines()

    n, m, q = map(int, data[0].split())
    
    ds = DisjointSet(n)

    for i in range(m):
        a, b = map(int, data[i + 1].split())
        ds.union(a, b, 1)

    results = []

    for i in range(q):
        query = list(map(int, data[m + 1 + i].split()))
        if query[0] == 1:
            x = query[1]
            root = ds.find(x)
            results.append(ds.max_path_length[root])
        elif query[0] == 2:
            x, y = query[1], query[2]
            if ds.find(x) != ds.find(y):
                ds.union(x, y, 1)

    sys.stdout.write(""\n"".join(map(str, results)) + ""\n"")

if __name__ == ""__main__"":
    main()"
4,A,Watermelon,PROGRAMMING,"['brute force', 'math']","One hot summer day Pete and his friend Billy decided to buy a watermelon. They chose the biggest and the ripest one, in their opinion. After that the watermelon was weighed, and the scales showed *w* kilos. They rushed home, dying of thirst, and decided to divide the berry, however they faced a hard problem.

Pete and Billy are great fans of even numbers, that's why they want to divide the watermelon in such a way that each of the two parts weighs even number of kilos, at the same time it is not obligatory that the parts are equal. The boys are extremely tired and want to start their meal as soon as possible, that's why you should help them and find out, if they can divide the watermelon in the way they want. For sure, each of them should get a part of positive weight.",The first (and the only) input line contains integer number *w* (1<=≤<=*w*<=≤<=100) — the weight of the watermelon bought by the boys.,"Print YES, if the boys can divide the watermelon into two parts, each of them weighing even number of kilos; and NO in the opposite case.",['8\n'],['YES\n'],"For example, the boys can divide the watermelon into two parts of 2 and 6 kilos respectively (another variant — two parts of 4 and 4 kilos).",WRONG_ANSWER,"def watermelon(w):
    if w%2!=0:
        return ""NO""
    else:
        half=w//2
        if half%2==0:
            return ""YES""
        else:
            return ""NO""

weight=8
result=watermelon(weight)
print(result)","def can_divide_watermelon(weight):

    if weight % 2 == 0 and weight > 2:
        return ""YES""
    else:
        return ""NO""

w = int(input().strip())

print(can_divide_watermelon(w))"
591,B,Rebranding,PROGRAMMING,"['implementation', 'strings']","The name of one small but proud corporation consists of *n* lowercase English letters. The Corporation has decided to try rebranding — an active marketing strategy, that includes a set of measures to change either the brand (both for the company and the goods it produces) or its components: the name, the logo, the slogan. They decided to start with the name.

For this purpose the corporation has consecutively hired *m* designers. Once a company hires the *i*-th designer, he immediately contributes to the creation of a new corporation name as follows: he takes the newest version of the name and replaces all the letters *x**i* by *y**i*, and all the letters *y**i* by *x**i*. This results in the new version. It is possible that some of these letters do no occur in the string. It may also happen that *x**i* coincides with *y**i*. The version of the name received after the work of the last designer becomes the new name of the corporation.

Manager Arkady has recently got a job in this company, but is already soaked in the spirit of teamwork and is very worried about the success of the rebranding. Naturally, he can't wait to find out what is the new name the Corporation will receive.

Satisfy Arkady's curiosity and tell him the final version of the name.","The first line of the input contains two integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=200<=000) — the length of the initial name and the number of designers hired, respectively.

The second line consists of *n* lowercase English letters and represents the original name of the corporation.

Next *m* lines contain the descriptions of the designers' actions: the *i*-th of them contains two space-separated lowercase English letters *x**i* and *y**i*.",Print the new name of the corporation.,"['6 1\npolice\np m\n', '11 6\nabacabadaba\na b\nb c\na d\ne g\nf a\nb b\n']","['molice\n', 'cdcbcdcfcdc\n']","In the second sample the name of the corporation consecutively changes as follows:

<img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/c7648432f7138ca53234357d7e08d1d119166055.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

<img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/de89ad7bc7f27c46ec34f5e66ce0dc23bd5bc90a.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

<img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/812e653c8d7ff496e6a0f04c676423806751531e.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

<img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/19c564fcefb8dde36256240a8b877bb6a4792bfe.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

<img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/e1cafd93792430ad1a49e893e04715383bdae757.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>",RUNTIME_ERROR,"def main(name, n, m):
    for i in range(m):
        name = (lambda word, x, y: (y if i == x else (x if i == y else i) for i in word))(name, *input().split())
    return """".join(name)

n, m = map(int, input().split())
name = input()
print(main(name, n, m))","def rebranding_name(n, m, original_name, actions):

    swap_mapping = {}

    for x, y in actions:
        if x in swap_mapping:
            x = swap_mapping[x]
        if y in swap_mapping:
            y = swap_mapping[y]

        swap_mapping[x] = y
        swap_mapping[y] = x

    new_name = []

    for char in original_name:
        if char in swap_mapping:
            new_name.append(swap_mapping[char])
        else:
            new_name.append(char)

    return ''.join(new_name)

import sys
input = sys.stdin.read
data = input().strip().split('\n')

n, m = map(int, data[0].split())

original_name = data[1].strip()

actions = [line.strip().split() for line in data[2:m+2]]

final_name = rebranding_name(n, m, original_name, actions)

print(final_name)"
820,B,Mister B and Angle in Polygon,PROGRAMMING,"['constructive algorithms', 'geometry', 'math']","On one quiet day all of sudden Mister B decided to draw angle *a* on his field. Aliens have already visited his field and left many different geometric figures on it. One of the figures is regular convex *n*-gon (regular convex polygon with *n* sides).

That's why Mister B decided to use this polygon. Now Mister B must find three distinct vertices *v*1, *v*2, *v*3 such that the angle  (where *v*2 is the vertex of the angle, and *v*1 and *v*3 lie on its sides) is as close as possible to *a*. In other words, the value  should be minimum possible.

If there are many optimal solutions, Mister B should be satisfied with any of them.","First and only line contains two space-separated integers *n* and *a* (3<=≤<=*n*<=≤<=105, 1<=≤<=*a*<=≤<=180) — the number of vertices in the polygon and the needed angle, in degrees.","Print three space-separated integers: the vertices *v*1, *v*2, *v*3, which form . If there are multiple optimal solutions, print any of them. The vertices are numbered from 1 to *n* in clockwise order.","['3 15\n', '4 67\n', '4 68\n']","['1 2 3\n', '2 1 3\n', '4 1 2\n']","In first sample test vertices of regular triangle can create only angle of 60 degrees, that's why every possible angle is correct.

Vertices of square can create 45 or 90 degrees angles only. That's why in second sample test the angle of 45 degrees was chosen, since |45 - 67| &lt; |90 - 67|. Other correct answers are: ""3 1 2"", ""3 2 4"", ""4 2 3"", ""4 3 1"", ""1 3 4"", ""1 4 2"", ""2 4 1"", ""4 1 3"", ""3 1 4"", ""3 4 2"", ""2 4 3"", ""2 3 1"", ""1 3 2"", ""1 2 4"", ""4 2 1"".

In third sample test, on the contrary, the angle of 90 degrees was chosen, since |90 - 68| &lt; |45 - 68|. Other correct answers are: ""2 1 4"", ""3 2 1"", ""1 2 3"", ""4 3 2"", ""2 3 4"", ""1 4 3"", ""3 4 1"".",WRONG_ANSWER,"""""""
	Author		: Arif Ahmad
	Date  		: 
	Algo  		: 
	Difficulty	: 
""""""
from sys import stdin, stdout

def main():
	n, a = [int(_) for _ in stdin.readline().strip().split()]

	if n == 3:
		stdout.write('1 2 3\n')
		return

	smallest = 180 / n
	required = a // smallest
	if required == 0: ans = 3
	else:
		x = smallest * required
		y = smallest * (required + 1)
		if abs(a - x) < abs(a - y):
			ans = 2 + required
		else:
			ans = 3 + required

	stdout.write('2 1 ' + str(int(ans)) + '\n')	

if __name__ == '__main__':
    main()","import sys
import math

n, a = map(int, input().split())

polygon_angle = 180 * (n - 2) / n

best_diff = float('inf')
best_indices = (1, 2, 3)
for i in range(1, n + 1):
    angle = polygon_angle if (i + 1) % n != 0 else polygon_angle
    for j in range(1, n + 1):
        if j == i:
            continue
        v1 = (j - i + n - 1) % n + 1
        v3 = (j - i + 1) % n + 1
        current_angle = abs(v3 - v1) * polygon_angle / 180
        diff = abs(current_angle - a)

        if diff < best_diff:
            best_diff = diff
            best_indices = (v1, i, v3)

print(*best_indices)"
44,H,Phone Number,PROGRAMMING,['dp'],"Alas, finding one's true love is not easy. Masha has been unsuccessful in that yet. Her friend Dasha told Masha about a way to determine the phone number of one's Prince Charming through arithmancy. 

The phone number is divined like that. First one needs to write down one's own phone numbers. For example, let's suppose that Masha's phone number is 12345. After that one should write her favorite digit from 0 to 9 under the first digit of her number. That will be the first digit of the needed number. For example, Masha's favorite digit is 9. The second digit is determined as a half sum of the second digit of Masha's number and the already written down first digit from her beloved one's number. In this case the arithmetic average equals to (2<=+<=9)<=/<=2<==<=5.5. Masha can round the number up or down, depending on her wishes. For example, she chooses the digit 5. Having written down the resulting digit under the second digit of her number, Masha moves to finding the third digit in the same way, i.e. finding the half sum the the third digit of her number and the second digit of the new number. The result is (5<=+<=3)<=/<=2<==<=4. In this case the answer is unique. Thus, every *i*-th digit is determined as an arithmetic average of the *i*-th digit of Masha's number and the *i*<=-<=1-th digit of her true love's number. If needed, the digit can be rounded up or down. For example, Masha can get:",The first line contains nonempty sequence consisting of digits from 0 to 9 — Masha's phone number. The sequence length does not exceed 50.,Output the single number — the number of phone numbers Masha will dial.,"['12345\n', '09\n']","['48\n', '15\n']",none,OK,"import os
import sys
from math import floor, ceil

if os.getenv('LOCALCFTEST'):
    sys.stdin = open('cfinput.txt')
MOD = 998244353

def solve(s):
    s = list(map(int, s))
    n = len(s)
    dp = [[0] * 10 for _ in range(n)]
    dp[0] = [1] * 10
    flag = True
    for i in range(n - 1):
        t = (s[i] + s[i + 1]) / 2
        if s[i + 1] != ceil(t) and s[i + 1] != floor(t):
            flag = False
        for j in range(10):
            a, b = divmod(j + s[i + 1], 2)
            dp[i + 1][a] += dp[i][j]

            if b == 1:
                dp[i + 1][a + 1] += dp[i][j]

    print(sum(dp[-1]) - flag)

if __name__ == '__main__':
    s = input()
    solve(s)","def divine_phone_number(masha_number, favorite_digit):

    if not masha_number.isdigit() or len(masha_number) > 50:
        raise ValueError(""Invalid phone number."")
    
    if not (0 <= int(favorite_digit) <= 9):
        raise ValueError(""Favorite digit must be between 0 and 9."")

    new_number = [favorite_digit]

    for i in range(len(masha_number)):
        masha_digit = int(masha_number[i])
        if i == 0:
            continue
        
        previous_digit = int(new_number[i - 1])

        new_digit = (masha_digit + previous_digit) / 2

        new_digit_rounded = round(new_digit)
        new_number.append(str(new_digit_rounded))

    return ''.join(new_number)

masha_phone_number = '12345'
favorite_digit = '9'
result = divine_phone_number(masha_phone_number, favorite_digit)
print(result)"
6,D,Lizards and Basements 2,PROGRAMMING,"['brute force', 'dp']","This is simplified version of the problem used on the original contest. The original problem seems to have too difiicult solution. The constraints for input data have been reduced.

Polycarp likes to play computer role-playing game «Lizards and Basements». At the moment he is playing it as a magician. At one of the last levels he has to fight the line of archers. The only spell with which he can damage them is a fire ball. If Polycarp hits the *i*-th archer with his fire ball (they are numbered from left to right), the archer loses *a* health points. At the same time the spell damages the archers adjacent to the *i*-th (if any) — they lose *b* (1<=≤<=*b*<=&lt;<=*a*<=≤<=10) health points each.

As the extreme archers (i.e. archers numbered 1 and *n*) are very far, the fire ball cannot reach them. Polycarp can hit any other archer with his fire ball.

The amount of health points for each archer is known. An archer will be killed when this amount is less than 0. What is the minimum amount of spells Polycarp can use to kill all the enemies?

Polycarp can throw his fire ball into an archer if the latter is already killed.","The first line of the input contains three integers *n*,<=*a*,<=*b* (3<=≤<=*n*<=≤<=10; 1<=≤<=*b*<=&lt;<=*a*<=≤<=10). The second line contains a sequence of *n* integers — *h*1,<=*h*2,<=...,<=*h**n* (1<=≤<=*h**i*<=≤<=15), where *h**i* is the amount of health points the *i*-th archer has.","In the first line print *t* — the required minimum amount of fire balls.

In the second line print *t* numbers — indexes of the archers that Polycarp should hit to kill all the archers in *t* shots. All these numbers should be between 2 and *n*<=-<=1. Separate numbers with spaces. If there are several solutions, output any of them. Print numbers in any order.","['3 2 1\n2 2 2\n', '4 3 1\n1 4 1 1\n']","['3\n2 2 2 ', '4\n2 2 3 3 ']",none,OK,"__author__ = 'Darren'

def solve():
    n, a, b = map(int, input().split())
    h = [0]
    h.extend(map(int, input().split()))

    fires = []
    count = h[1] // b + 1 if h[1] >= 0 else 0
    fires.extend([2 for i in range(count)])
    h[1] -= b * count
    h[2] -= a * count
    h[3] -= b * count
    count = h[n] // b + 1 if h[n] >= 0 else 0
    fires.extend([n-1 for i in range(count)])
    h[n] -= b * count
    h[n-1] -= a * count
    h[n-2] -= b * count

    temp = fires.copy()
    for i in range(2, n):
        count = h[i] // a + 1
        fires.extend([i for j in range(count)])

    def search(pos):
        nonlocal n, a, b, h, fires, temp
        if pos == n and h[pos-1] < 0:
            if len(fires) > len(temp):
                fires = temp.copy()
            return
        balls = 0
        count = h[pos-1] // b + 1 if h[pos-1] >= 0 else 0
        temp.extend([pos for i in range(count)])
        h[pos-1] -= b * count
        h[pos] -= a * count
        h[pos+1] -= b * count
        balls += count

        while h[pos] >= 0:
            search(pos+1)
            temp.append(pos)
            h[pos-1] -= b
            h[pos] -= a
            h[pos+1] -= b
            balls += 1
        search(pos+1)

        h[pos-1] += b * balls
        h[pos] += a * balls
        h[pos+1] += b * balls
        for i in range(balls):
            temp.pop()

    search(2)
    print(len(fires))
    print(' '.join(map(str, fires)))

if __name__ == '__main__':
    solve()","def min_fireballs_to_kill_archers(n, a, b, health):
    fireballs = []

    while any(h > 0 for h in health[1:-1]):
        for i in range(1, n - 1):
            if health[i] > 0:
                fireballs.append(i + 1)
                health[i] -= a
                if i > 1:
                    health[i - 1] -= b
                if i < n - 1:
                    health[i + 1] -= b
                break
        
    return len(fireballs), fireballs

input_data = input().strip().split('\n')
n, a, b = map(int, input_data[0].split())
health = list(map(int, input_data[1].split()))

t, fireball_indices = min_fireballs_to_kill_archers(n, a, b, health)

print(t)
print("" "".join(map(str, fireball_indices)))"
285,B,Find Marble,PROGRAMMING,['implementation'],"Petya and Vasya are playing a game. Petya's got *n* non-transparent glasses, standing in a row. The glasses' positions are indexed with integers from 1 to *n* from left to right. Note that the positions are indexed but the glasses are not.

First Petya puts a marble under the glass in position *s*. Then he performs some (possibly zero) shuffling operations. One shuffling operation means moving the glass from the first position to position *p*1, the glass from the second position to position *p*2 and so on. That is, a glass goes from position *i* to position *p**i*. Consider all glasses are moving simultaneously during one shuffling operation. When the glasses are shuffled, the marble doesn't travel from one glass to another: it moves together with the glass it was initially been put in.

After all shuffling operations Petya shows Vasya that the ball has moved to position *t*. Vasya's task is to say what minimum number of shuffling operations Petya has performed or determine that Petya has made a mistake and the marble could not have got from position *s* to position *t*.","The first line contains three integers: *n*,<=*s*,<=*t* (1<=≤<=*n*<=≤<=105; 1<=≤<=*s*,<=*t*<=≤<=*n*) — the number of glasses, the ball's initial and final position. The second line contains *n* space-separated integers: *p*1,<=*p*2,<=...,<=*p**n* (1<=≤<=*p**i*<=≤<=*n*) — the shuffling operation parameters. It is guaranteed that all *p**i*'s are distinct.

Note that *s* can equal *t*.","If the marble can move from position *s* to position *t*, then print on a single line a non-negative integer — the minimum number of shuffling operations, needed to get the marble to position *t*. If it is impossible, print number -1.","['4 2 1\n2 3 4 1\n', '4 3 3\n4 1 3 2\n', '4 3 4\n1 2 3 4\n', '3 1 3\n2 1 3\n']","['3\n', '0\n', '-1\n', '-1\n']",none,TIME_LIMIT_EXCEEDED,"def main():
    n,s,t = map(int,input().split())
    li=[-1]+list(map(int,input().split()))
    cnt=0
    found=1
    mov=[]
    while(s!=t):
        mov.append(s)
        s=li[s]
        cnt=cnt+1
        if(s in mov):
            found=0
            break
    if(found==1):
        print(cnt)
    else:
        print(""-1"")
main()","def min_shuffles(n, s, t, p):

    visited = [False] * (n + 1)
    visited[s] = True
    
    current_position = s
    shuffles = 0

    while current_position != t:
        current_position = p[current_position - 1]
        shuffles += 1

        if visited[current_position]:
            return -1
        visited[current_position] = True

    return shuffles

import sys
input = sys.stdin.read
data = input().strip().split('\n')

results = []

for i in range(0, len(data), 2):
    n, s, t = map(int, data[i].split())
    p = list(map(int, data[i + 1].split()))

    results.append(min_shuffles(n, s, t, p))

for result in results:
    print(result)"
501,B,Misha and Changing Handles,PROGRAMMING,"['data structures', 'dsu', 'strings']","Misha hacked the Codeforces site. Then he decided to let all the users change their handles. A user can now change his handle any number of times. But each new handle must not be equal to any handle that is already used or that was used at some point.

Misha has a list of handle change requests. After completing the requests he wants to understand the relation between the original and the new handles of the users. Help him to do that.","The first line contains integer *q* (1<=≤<=*q*<=≤<=1000), the number of handle change requests.

Next *q* lines contain the descriptions of the requests, one per line.

Each query consists of two non-empty strings *old* and *new*, separated by a space. The strings consist of lowercase and uppercase Latin letters and digits. Strings *old* and *new* are distinct. The lengths of the strings do not exceed 20.

The requests are given chronologically. In other words, by the moment of a query there is a single person with handle *old*, and handle *new* is not used and has not been used by anyone.","In the first line output the integer *n* — the number of users that changed their handles at least once.

In the next *n* lines print the mapping between the old and the new handles of the users. Each of them must contain two strings, *old* and *new*, separated by a space, meaning that before the user had handle *old*, and after all the requests are completed, his handle is *new*. You may output lines in any order.

Each user who changes the handle must occur exactly once in this description.",['5\nMisha ILoveCodeforces\nVasya Petrov\nPetrov VasyaPetrov123\nILoveCodeforces MikeMirzayanov\nPetya Ivanov\n'],['3\nPetya Ivanov\nMisha MikeMirzayanov\nVasya VasyaPetrov123\n'],none,OK,"def find(x):
    if a[x] not in a.keys():
        return a[x]
    else:
        return find(a[x])

n=int(input())
a={}
d={}
for i in range(n):
    b,c=input().split()
    a[b]=c
    d[c]=b
e=[]
for i in a:
    if i not in d.keys():
        e.append([i,find(i)])
print(len(e))
for i in range(len(e)):
    print(*e[i])","q = int(input())

handle_map = {}

current_handle = {}

for _ in range(q):
    old, new = input().split()

    if old in current_handle:
        original_handle = current_handle[old]
    else:
        original_handle = old

    handle_map[original_handle] = new

    current_handle[new] = original_handle

    if old in current_handle:
        del current_handle[old]

print(len(handle_map))
for old_handle, new_handle in handle_map.items():
    print(old_handle, new_handle)"
689,C,Mike and Chocolate Thieves,PROGRAMMING,"['binary search', 'combinatorics', 'math']","Bad news came to Mike's village, some thieves stole a bunch of chocolates from the local factory! Horrible! 

Aside from loving sweet things, thieves from this area are known to be very greedy. So after a thief takes his number of chocolates for himself, the next thief will take exactly *k* times more than the previous one. The value of *k* (*k*<=&gt;<=1) is a secret integer known only to them. It is also known that each thief's bag can carry at most *n* chocolates (if they intend to take more, the deal is cancelled) and that there were exactly four thieves involved. 

Sadly, only the thieves know the value of *n*, but rumours say that the numbers of ways they could have taken the chocolates (for a fixed *n*, but not fixed *k*) is *m*. Two ways are considered different if one of the thieves (they should be numbered in the order they take chocolates) took different number of chocolates in them.

Mike want to track the thieves down, so he wants to know what their bags are and value of *n* will help him in that. Please find the smallest possible value of *n* or tell him that the rumors are false and there is no such *n*.","The single line of input contains the integer *m* (1<=≤<=*m*<=≤<=1015) — the number of ways the thieves might steal the chocolates, as rumours say.","Print the only integer *n* — the maximum amount of chocolates that thieves' bags can carry. If there are more than one *n* satisfying the rumors, print the smallest one.

If there is no such *n* for a false-rumoured *m*, print <=-<=1.","['1\n', '8\n', '10\n']","['8\n', '54\n', '-1\n']","In the first sample case the smallest *n* that leads to exactly one way of stealing chocolates is *n* = 8, whereas the amounts of stealed chocolates are (1, 2, 4, 8) (the number of chocolates stolen by each of the thieves).

In the second sample case the smallest *n* that leads to exactly 8 ways is *n* = 54 with the possibilities: (1, 2, 4, 8),  (1, 3, 9, 27),  (2, 4, 8, 16),  (2, 6, 18, 54),  (3, 6, 12, 24),  (4, 8, 16, 32),  (5, 10, 20, 40),  (6, 12, 24, 48).

There is no *n* leading to exactly 10 ways of stealing chocolates in the third sample case.",OK,"def solution(m):
    def check(mid):
        ans = 0
        i = 2
        while i * i * i <= mid:
            ans += mid // (i * i * i)
            i += 1
        return ans
        
    n = -1
    low = 0
    high = 5e15

    while low < high:
        mid = int(low + ((high-low) // 2))
        if check(mid) < m:
            low = mid + 1
        else:
            high = mid
    
    if check(low) == m:
        n = low
    
    return int(n)

if __name__ == '__main__':
    m = int(input())
    ans = solution(m)
    print(ans)","def find_minimum_n(m):

    for n in range(1, 101):
        count = 0
        for x in range(1, n + 1):
            temp_count = 1
            current = x

            while current <= n:
                current *= 2
                if current <= n:
                    temp_count += 1
                else:
                    break

            if temp_count >= 4:
                count += 1
        if count == m:
            return n
    return -1

inputs = ['1\n', '8\n', '10\n']
outputs = []

for input_str in inputs:
    m = int(input_str.strip())
    result = find_minimum_n(m)
    outputs.append(result)

for output in outputs:
    print(output)"
664,A,Complicated GCD,PROGRAMMING,"['math', 'number theory']","Greatest common divisor *GCD*(*a*,<=*b*) of two positive integers *a* and *b* is equal to the biggest integer *d* such that both integers *a* and *b* are divisible by *d*. There are many efficient algorithms to find greatest common divisor *GCD*(*a*,<=*b*), for example, Euclid algorithm. 

Formally, find the biggest integer *d*, such that all integers *a*,<=*a*<=+<=1,<=*a*<=+<=2,<=...,<=*b* are divisible by *d*. To make the problem even more complicated we allow *a* and *b* to be up to googol, 10100 — such number do not fit even in 64-bit integer type!",The only line of the input contains two integers *a* and *b* (1<=≤<=*a*<=≤<=*b*<=≤<=10100).,Output one integer — greatest common divisor of all integers from *a* to *b* inclusive.,"['1 2\n', '61803398874989484820458683436563811772030917980576 61803398874989484820458683436563811772030917980576\n']","['1\n', '61803398874989484820458683436563811772030917980576\n']",none,OK,"a ,b = list(map(int , input().split()))

def GCD(a , b):

    if b == 0 :
        return a
    return GCD(b , a % b)

if b - a >= 1:
    print(1)
else:
    print(GCD(a , b))","def gcd_of_range(a, b):

    if a == b:
        return a
    else:

        return 1

def main():
    import sys

    input_line = sys.stdin.read().strip()
    a, b = map(int, input_line.split())

    result = gcd_of_range(a, b)

    print(result)

if __name__ == ""__main__"":
    main()"
687,A,NP-Hard Problem,PROGRAMMING,"['dfs and similar', 'graphs']","Recently, Pari and Arya did some research about NP-Hard problems and they found the minimum vertex cover problem very interesting.

Suppose the graph *G* is given. Subset *A* of its vertices is called a vertex cover of this graph, if for each edge *uv* there is at least one endpoint of it in this set, i.e.  or  (or both).

Pari and Arya have won a great undirected graph as an award in a team contest. Now they have to split it in two parts, but both of them want their parts of the graph to be a vertex cover.

They have agreed to give you their graph and you need to find two disjoint subsets of its vertices *A* and *B*, such that both *A* and *B* are vertex cover or claim it's impossible. Each vertex should be given to no more than one of the friends (or you can even keep it for yourself).","The first line of the input contains two integers *n* and *m* (2<=≤<=*n*<=≤<=100<=000, 1<=≤<=*m*<=≤<=100<=000) — the number of vertices and the number of edges in the prize graph, respectively.

Each of the next *m* lines contains a pair of integers *u**i* and *v**i* (1<=<=≤<=<=*u**i*,<=<=*v**i*<=<=≤<=<=*n*), denoting an undirected edge between *u**i* and *v**i*. It's guaranteed the graph won't contain any self-loops or multiple edges.","If it's impossible to split the graph between Pari and Arya as they expect, print ""-1"" (without quotes).

If there are two disjoint sets of vertices, such that both sets are vertex cover, print their descriptions. Each description must contain two lines. The first line contains a single integer *k* denoting the number of vertices in that vertex cover, and the second line contains *k* integers — the indices of vertices. Note that because of *m*<=≥<=1, vertex cover cannot be empty.","['4 2\n1 2\n2 3\n', '3 3\n1 2\n2 3\n1 3\n']","['1\n2 \n2\n1 3 \n', '-1\n']","In the first sample, you can give the vertex number 2 to Arya and vertices numbered 1 and 3 to Pari and keep vertex number 4 for yourself (or give it someone, if you wish).

In the second sample, there is no way to satisfy both Pari and Arya.",WRONG_ANSWER,"from collections import deque , defaultdict

vx  = 0
e = 0
def bfs(node):
    global vx , e

    q = deque()
    q.append(node)
    while q :
        s = q.popleft()
        if not visited[s]:
            vx += 1
            visited[s] = True
            for i in g[s]:
                e +=1
                q.append(i)

n , m = map(int,input().split())

g = defaultdict(list)
c = set()

for i in range(m):
    u , v = map(int,input().split())
    g[u].append(v)
    g[v].append(u)
    c.add(u)
    c.add(v)

visited = [False] * (n + 1)
flag = True

for i in c :
    vx = e = 0
    r  = bfs(i)
    e //= 2

    if e != 0 and vx != 0 :
        if e == vx * (vx - 1) //2:
            flag = False

if flag == False:
    print('-1')
    exit(0)

st = set()

f = deque()
t = deque()
for i in range(1 , n + 1):
    if visited[i]:
        f.append(i)

    else:
        t.append(i)

print(len(f))
print(*f)
print(len(t))
print(*t)","def min_vertex_cover(test_cases):
    results = []
    
    for case in test_cases:

        lines = case.strip().split('\n')
        n, m = map(int, lines[0].split())
        edges = [tuple(map(int, line.split())) for line in lines[1:m + 1]]

        adj = [[] for _ in range(n + 1)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)

        color = [-1] * (n + 1)
        
        def dfs(node, c):
            color[node] = c
            for neighbor in adj[node]:
                if color[neighbor] == -1:
                    if not dfs(neighbor, 1 - c):
                        return False
                elif color[neighbor] == color[node]:
                    return False
            return True

        possible = True
        for i in range(1, n + 1):
            if color[i] == -1:
                if not dfs(i, 0):
                    possible = False
                    break
        
        if not possible:
            results.append(""-1"")
            continue

        A = [i for i in range(1, n + 1) if color[i] == 0]
        B = [i for i in range(1, n + 1) if color[i] == 1]

        results.append(f""{len(A)}\n{' '.join(map(str, A))}"")
        results.append(f""{len(B)}\n{' '.join(map(str, B))}"")

    return results

demo_input = ['4 2\n1 2\n2 3\n', '3 3\n1 2\n2 3\n1 3\n']
result = min_vertex_cover(demo_input)
for res in result:
    print(res)"
185,A,Plant,PROGRAMMING,['math'],"Dwarfs have planted a very interesting plant, which is a triangle directed ""upwards"". This plant has an amusing feature. After one year a triangle plant directed ""upwards"" divides into four triangle plants: three of them will point ""upwards"" and one will point ""downwards"". After another year, each triangle plant divides into four triangle plants: three of them will be directed in the same direction as the parent plant, and one of them will be directed in the opposite direction. Then each year the process repeats. The figure below illustrates this process.

Help the dwarfs find out how many triangle plants that point ""upwards"" will be in *n* years.","The first line contains a single integer *n* (0<=≤<=*n*<=≤<=1018) — the number of full years when the plant grew.

Please do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use cin, cout streams or the %I64d specifier.","Print a single integer — the remainder of dividing the number of plants that will point ""upwards"" in *n* years by 1000000007 (109<=+<=7).","['1\n', '2\n']","['3\n', '10\n']",The first test sample corresponds to the second triangle on the figure in the statement. The second test sample corresponds to the third one.,WRONG_ANSWER,"n = int(input())
a = [1, 0]
matrix = [[3, 1],[1,3]]
res = [[1,0],[0,1]]
modulo = 1e9+7
def matmul(a,b):
    ans = [[1,0],[0,1]]
    ans[0][0] = (a[0][0]*b[0][0] + a[0][1]*b[1][0])%modulo
    ans[0][1] = (a[0][0]*b[1][0] + a[0][1]*b[1][1])%modulo
    ans[1][0] = (a[1][0]*b[0][0] + a[1][1]*b[1][0])%modulo
    ans[1][1] = (a[1][0]*b[1][0] + a[1][1]*b[1][1])%modulo
    return ans
while(n!=0):
    if n%2 == 0:
        matrix = matmul(matrix,matrix)
        n //= 2
    else:
        res = matmul(res,matrix)
        n-=1

print(int(res[0][0]%modulo))","def upward_triangles(n):

    if n == 0:
        return 1

    MOD = 1000000007

    upward = 1
    downward = 0

    for _ in range(n):

        new_upward = (3 * upward + downward) % MOD
        new_downward = (upward + 3 * downward) % MOD

        upward, downward = new_upward, new_downward
    
    return upward

import sys
input = sys.stdin.read
data = input().splitlines()

results = []
for line in data:
    n = int(line.strip())
    results.append(upward_triangles(n))

for result in results:
    print(result)"
660,A,Co-prime Array,PROGRAMMING,"['greedy', 'implementation', 'math', 'number theory']","You are given an array of *n* elements, you must make it a co-prime array in as few moves as possible.

In each move you can insert any positive integral number you want not greater than 109 in any place in the array.

An array is co-prime if any two adjacent numbers of it are co-prime.

In the number theory, two integers *a* and *b* are said to be co-prime if the only positive integer that divides both of them is 1.","The first line contains integer *n* (1<=≤<=*n*<=≤<=1000) — the number of elements in the given array.

The second line contains *n* integers *a**i* (1<=≤<=*a**i*<=≤<=109) — the elements of the array *a*.","Print integer *k* on the first line — the least number of elements needed to add to the array *a* to make it co-prime.

The second line should contain *n*<=+<=*k* integers *a**j* — the elements of the array *a* after adding *k* elements to it. Note that the new array should be co-prime, so any two adjacent values should be co-prime. Also the new array should be got from the original array *a* by adding *k* elements to it.

If there are multiple answers you can print any one of them.",['3\n2 7 28\n'],['1\n2 7 9 28\n'],none,OK,"def primeFactors(n):
    factors = []
    i = 2
    while n > 1:
        while n % i == 0:
            factors.append(i)
            n //= i 
        i += 1
        if i * i  > n : break
    if n > 1:
        factors.append(n)
    return factors

def areCoprime(n1,n2):
    n1Factors = primeFactors(n1)
    areCoprime = True
    for f in n1Factors:
        if n2 % f == 0:
            areCoprime = False
            break
    return areCoprime

def sieve(n):
    primes = [True for i in range(n+1)]
    primeNums = []
    p = 2
    while p * p <= n:
        if primes[p]:
            for i in range(p*p,n+1,p):
                primes[i] = False
        p += 1
    for i in range(2,n+1):
        if primes[i]:
            primeNums.append(i)
    return primeNums

n = int(input())
A = list(map(int,input().split()))
k = 0
added = {}
primes = sieve(10**5)
for i in range(1,len(A)):
    checkCoprime = areCoprime(A[i],A[i-1])
    factor = -1
    if not checkCoprime:
        k += 1
        for p in primes:
            if A[i] % p != 0 and A[i-1] % p != 0:
                factor = p
                break
        added[i] = factor
print(k)
out = f""{A[0]} ""
for i in range(1,len(A)):
    if i in added:
        out += f""{str(added[i])} ""
    out += str(A[i])
    if i < len(A) - 1:
        out += "" ""
print(out)","import math

def are_coprime(x, y):

    return math.gcd(x, y) == 1

def make_coprime_array(n, a):

    result = []
    added_count = 0

    for i in range(n):
        if i > 0:

            if not are_coprime(result[-1], a[i]):

                result.append(1)
                added_count += 1
        
        result.append(a[i])
    
    return added_count, result

n = int(input().strip())
a = list(map(int, input().strip().split()))

added_count, new_array = make_coprime_array(n, a)

print(added_count)
print(' '.join(map(str, new_array)))"
386,C,Diverse Substrings,PROGRAMMING,"['dp', 'strings', 'two pointers']","String diversity is the number of symbols that occur in the string at least once. Diversity of *s* will be denoted by *d*(*s*). For example , *d*(""aaa"")=1, *d*(""abacaba"")=3.

Given a string *s*, consisting of lowercase Latin letters. Consider all its substrings. Obviously, any substring diversity is a number from 1 to *d*(*s*). Find statistics about substrings diversity: for each *k* from 1 to *d*(*s*), find how many substrings of *s* has a diversity of exactly *k*.","The input consists of a single line containing *s*. It contains only lowercase Latin letters, the length of *s* is from 1 to 3·105.","Print to the first line the value *d*(*s*). Print sequence *t*1,<=*t*2,<=...,<=*t**d*(*s*) to the following lines, where *t**i* is the number of substrings of *s* having diversity of exactly *i*.","['abca\n', 'aabacaabbad\n']","['3\n4\n3\n3\n', '4\n14\n19\n28\n5\n']","Consider the first example.

We denote by *s*(*i*, *j*) a substring of ""abca"" with the indices in the segment [*i*, *j*].
 -  *s*(1, 1) =  ""a"", *d*(""a"") = 1 -  *s*(2, 2) =  ""b"", *d*(""b"") = 1 -  *s*(3, 3) =  ""c"", *d*(""c"") = 1 -  *s*(4, 4) =  ""a"", *d*(""a"") = 1 -  *s*(1, 2) =  ""ab"", *d*(""ab"") = 2 -  *s*(2, 3) =  ""bc"", *d*(""bc"") = 2 -  *s*(3, 4) =  ""ca"", *d*(""ca"") = 2 -  *s*(1, 3) =  ""abc"", *d*(""abc"") = 3 -  *s*(2, 4) =  ""bca"", *d*(""bca"") = 3 -  *s*(1, 4) =  ""abca"", *d*(""abca"") = 3 
Total number of substring with diversity 1 is 4, with diversity 2 equals 3, 3 diversity is 3.",COMPILATION_ERROR,"typedef long long ll;

using namespace std;

int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);

    string s;
    set<char> st;
    vector<int> vec[26];
    int it[26] = {0};
    ll ans[26] = {0};
 
    cin >> s;
 
	int n = (int)s.size();
 
	for(int i=0;i<n;i++){
		st.insert(s[i]);
		vec[s[i]-'a'].push_back(i);
	}
 
	for(int i=0;i<n;i++){
		vector<int> vec2;
		for(int j=0;j<26;j++){
			if(it[j] < (int)vec[j].size()){
				vec2.push_back(vec[j][it[j]]);
			}
		}
		sort(vec2.begin(), vec2.end());
		vec2.push_back(n);
		int cur = 0;
		int pos = i;
		for(auto v : vec2){
			ans[cur] += v-pos;
			pos = v;
			cur++;
		}
		it[s[i]-'a']++;
	}
 
	cout << st.size() << ""\n"";
 
	for(int i=1;i<=(int)st.size();i++){
		cout << ans[i] << ""\n"";
	}
 
	return 0;
}","def substring_diversity(s):
    n = len(s)
    unique_chars = set(s)
    d = len(unique_chars)
    counts = [0] * (d + 1)

    last_seen = {}

    current_count = 0

    left = 0
    for right in range(n):
        char = s[right]
        if char not in last_seen:
            current_count += 1
        last_seen[char] = right

        while left <= right and current_count > d:
            left_char = s[left]
            if last_seen[left_char] == left:
                current_count -= 1
            left += 1

        for k in range(1, current_count + 1):

            counts[k] += (right - left + 1)

    print(d)
    for i in range(1, d + 1):
        print(counts[i])

s_list = ['abca', 'aabacaabbad']
for s in s_list:
    substring_diversity(s)"
349,A,Cinema Line,PROGRAMMING,"['greedy', 'implementation']","The new ""Die Hard"" movie has just been released! There are *n* people at the cinema box office standing in a huge line. Each of them has a single 100, 50 or 25 ruble bill. A ""Die Hard"" ticket costs 25 rubles. Can the booking clerk sell a ticket to each person and give the change if he initially has no money and sells the tickets strictly in the order people follow in the line?","The first line contains integer *n* (1<=≤<=*n*<=≤<=105) — the number of people in the line. The next line contains *n* integers, each of them equals 25, 50 or 100 — the values of the bills the people have. The numbers are given in the order from the beginning of the line (at the box office) to the end of the line.","Print ""YES"" (without the quotes) if the booking clerk can sell a ticket to each person and give the change. Otherwise print ""NO"".","['4\n25 25 50 50\n', '2\n25 100\n', '4\n50 50 25 25\n']","['YES\n', 'NO\n', 'NO\n']",none,RUNTIME_ERROR,"def cinemaLine():
    n = int(input())
    cincuenta = 0
    veinCinco = 0
    cien = 0
    flag = True
    for i in range(n):
        aux = int(input())
        if i == 0 and (aux == 50 or aux == 100):
            flag = False
            break
        if aux == 25:
            veinCinco += 1
        elif aux == 50:
            veinCinco -= 1
            cincuenta += 1
        else:
            if cincuenta:
                veinCinco -= 1
                cincuenta -= 1

            else:
                veinCinco -= 3
        if veinCinco < 0 and cincuenta < 0:
            flag = False
    if flag:
        print(""YES"")
    else:
        print(""NO"")

def main():
    cinemaLine()
    
main()","def can_sell_tickets(n, bills):

    change_25 = 0
    change_50 = 0

    for bill in bills:
        if bill == 25:
            change_25 += 1
        elif bill == 50:
            if change_25 > 0:
                change_25 -= 1
                change_50 += 1
            else:
                return ""NO""
        elif bill == 100:

            if change_50 > 0 and change_25 > 0:
                change_50 -= 1
                change_25 -= 1
            elif change_25 >= 3:
                change_25 -= 3
            else:
                return ""NO""

    return ""YES""

n = int(input())
bills = list(map(int, input().split()))

print(can_sell_tickets(n, bills))"
989,A,A Blend of Springtime,PROGRAMMING,"['implementation', 'strings']","""What a pity it's already late spring,"" sighs Mino with regret, ""one more drizzling night and they'd be gone.""

""But these blends are at their best, aren't they?"" Absorbed in the landscape, Kanno remains optimistic. 

The landscape can be expressed as a row of consecutive cells, each of which either contains a flower of colour amber or buff or canary yellow, or is empty.

When a flower withers, it disappears from the cell that it originally belonged to, and it spreads petals of its colour in its two neighbouring cells (or outside the field if the cell is on the side of the landscape). In case petals fall outside the given cells, they simply become invisible.

You are to help Kanno determine whether it's possible that after some (possibly none or all) flowers shed their petals, at least one of the cells contains all three colours, considering both petals and flowers. Note that flowers can wither in arbitrary order.","The first and only line of input contains a non-empty string $s$ consisting of uppercase English letters 'A', 'B', 'C' and characters '.' (dots) only ($\lvert s \rvert \leq 100$) — denoting cells containing an amber flower, a buff one, a canary yellow one, and no flowers, respectively.","Output ""Yes"" if it's possible that all three colours appear in some cell, and ""No"" otherwise.

You can print each letter in any case (upper or lower).","['.BAC.\n', 'AA..CB\n']","['Yes\n', 'No\n']","In the first example, the buff and canary yellow flowers can leave their petals in the central cell, blending all three colours in it.

In the second example, it's impossible to satisfy the requirement because there is no way that amber and buff meet in any cell.",OK,"s=input()
l=['ABC', 'ACB', 'BAC', 'BCA', 'CAB', 'CBA']
def f(l,s):
	for i in l:
		if i in s:
			return ""Yes""
	return ""No""
print(f(l,s))","def can_all_colors_meet(s):

    n = len(s)

    for i in range(n):

        colors = set()

        if s[i] != '.':
            colors.add(s[i])

        if i > 0 and s[i - 1] != '.':
            colors.add(s[i - 1])

        if i < n - 1 and s[i + 1] != '.':
            colors.add(s[i + 1])

        if len(colors) == 3:
            return ""Yes""
    
    return ""No""

input_data = input().strip().split('\n')
results = []

for s in input_data:
    results.append(can_all_colors_meet(s))

for result in results:
    print(result)"
0,none,none,none,['none'],"Polycarp has interviewed Oleg and has written the interview down without punctuation marks and spaces to save time. Thus, the interview is now a string *s* consisting of *n* lowercase English letters.

There is a filler word ogo in Oleg's speech. All words that can be obtained from ogo by adding go several times to the end of it are also considered to be fillers. For example, the words ogo, ogogo, ogogogo are fillers, but the words go, og, ogog, ogogog and oggo are not fillers.

The fillers have maximal size, for example, for ogogoo speech we can't consider ogo a filler and goo as a normal phrase. We should consider ogogo as a filler here.

To print the interview, Polycarp has to replace each of the fillers with three asterisks. Note that a filler word is replaced with exactly three asterisks regardless of its length.

Polycarp has dealt with this problem in no time. Can you do the same? The clock is ticking!","The first line contains a positive integer *n* (1<=≤<=*n*<=≤<=100) — the length of the interview.

The second line contains the string *s* of length *n*, consisting of lowercase English letters.","Print the interview text after the replacement of each of the fillers with ""***"". It is allowed for the substring ""***"" to have several consecutive occurences.","['7\naogogob\n', '13\nogogmgogogogo\n', '9\nogoogoogo\n']","['a***b\n', '***gmg***\n', '*********\n']","The first sample contains one filler word ogogo, so the interview for printing is ""a***b"".

The second sample contains two fillers ogo and ogogogo. Thus, the interview is transformed to ""***gmg***"".",OK,"from sys import stdin
import re

def main():
    n, = stdin_get_ints_from_line()
    s = stdin_get_string_from_line()

    print(re.sub(r'(ogo((go)+)?)', '***', s))

def stdin_get_ints_from_line():
    return (int(x) for x in stdin.readline().strip().split(' '))

def stdin_get_ints_list_from_line():
    return list(int(x) for x in stdin.readline().strip().split(' '))

def stdin_get_string_from_line():
    return stdin.readline().strip()

if __name__ == '__main__':
    main()","import re

def replace_fillers(n, s):

    pattern = r'ogo(go)*'

    result = re.sub(pattern, '***', s)
    return result

n = int(input().strip())
s = input().strip()

modified_interview = replace_fillers(n, s)

print(modified_interview)"
1000,B,Light It Up,PROGRAMMING,['greedy'],"Recently, you bought a brand new smart lamp with programming features. At first, you set up a schedule to the lamp. Every day it will turn power on at moment $0$ and turn power off at moment $M$. Moreover, the lamp allows you to set a program of switching its state (states are ""lights on"" and ""lights off""). Unfortunately, some program is already installed into the lamp.

The lamp allows only good programs. Good program can be represented as a non-empty array $a$, where $0 &lt; a_1 &lt; a_2 &lt; \dots &lt; a_{|a|} &lt; M$. All $a_i$ must be integers. Of course, preinstalled program is a good program.

The lamp follows program $a$ in next manner: at moment $0$ turns power and light on. Then at moment $a_i$ the lamp flips its state to opposite (if it was lit, it turns off, and vice versa). The state of the lamp flips instantly: for example, if you turn the light off at moment $1$ and then do nothing, the total time when the lamp is lit will be $1$. Finally, at moment $M$ the lamp is turning its power off regardless of its state.

Since you are not among those people who read instructions, and you don't understand the language it's written in, you realize (after some testing) the only possible way to alter the preinstalled program. You can insert at most one element into the program $a$, so it still should be a good program after alteration. Insertion can be done between any pair of consecutive elements of $a$, or even at the begining or at the end of $a$.

Find such a way to alter the program that the total time when the lamp is lit is maximum possible. Maybe you should leave program untouched. If the lamp is lit from $x$ till moment $y$, then its lit for $y - x$ units of time. Segments of time when the lamp is lit are summed up.","First line contains two space separated integers $n$ and $M$ ($1 \le n \le 10^5$, $2 \le M \le 10^9$) — the length of program $a$ and the moment when power turns off.

Second line contains $n$ space separated integers $a_1, a_2, \dots, a_n$ ($0 &lt; a_1 &lt; a_2 &lt; \dots &lt; a_n &lt; M$) — initially installed program $a$.",Print the only integer — maximum possible total time when the lamp is lit.,"['3 10\n4 6 7\n', '2 12\n1 10\n', '2 7\n3 4\n']","['8\n', '9\n', '6\n']","In the first example, one of possible optimal solutions is to insert value $x = 3$ before $a_1$, so program will be $[3, 4, 6, 7]$ and time of lamp being lit equals $(3 - 0) + (6 - 4) + (10 - 7) = 8$. Other possible solution is to insert $x = 5$ in appropriate place.

In the second example, there is only one optimal solution: to insert $x = 2$ between $a_1$ and $a_2$. Program will become $[1, 2, 10]$, and answer will be $(1 - 0) + (10 - 2) = 9$.

In the third example, optimal answer is to leave program untouched, so answer will be $(3 - 0) + (7 - 4) = 6$.",WRONG_ANSWER,"import enum
from io import BytesIO, IOBase
from mimetypes import suffix_map
import sys
import math
import os
import heapq
from collections import defaultdict, deque
from math import ceil
from bisect import bisect_left, bisect_right
from time import perf_counter

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
def input(): return sys.stdin.readline().rstrip(""\r\n"")
def mint(): return map(int, input().split())
def mfloat(): return map(float, input().split())
def intin(): return int(input())

def one_less(x):
    return x-1 if x > 0 else x + 1

def solve():
    n, m = map(int, input().split())
    *a, = map(int, input().split())
    times = [0]*(n+1)
    factor = 1
    prev = 0
    for idx, i in enumerate(a):
        times[idx] = (i - prev) * factor
        factor = factor * -1
        prev = i
    times[-1] = (m - prev) * factor

    suffix_pos = [0]*(n+1)
    suffix_neg = [0]*(n+1)
    suffix_pos[-1] = times[-1] if times[-1] > 0 else 0
    suffix_neg[-1] = times[-1] if times[-1] < 0 else 0
    for i in range(n-1, -1, -1):
        suffix_pos[i] = suffix_pos[i+1] + (times[i] if times[i] > 0 else 0)
        suffix_neg[i] = suffix_neg[i+1] + (times[i] if times[i] < 0 else 0)

    ans = suffix_pos[0]
    if a[i] != 1:

        current = -suffix_pos[0] - suffix_neg[0]
        if times[0] > 0:
            current -= 1
        ans = max(ans, current)
    start = suffix_pos[0]

    for idx, i in enumerate(a):

        if i > 1 and (idx == 0 or a[idx-1] < i-1):
            current = start
            current = (current - times[idx] + one_less(times[idx]))
            current -= suffix_pos[idx+1] + suffix_neg[idx+1]
            ans = max(ans, current)
        current = start
        current -= times[idx+1] if times[idx+1] > 0 else 0

        if times[idx+1] > 0:
            current += 1
        else:
            current += -times[idx+1] - 1

        if idx+2 <= n:
            current -= suffix_pos[idx+2] + suffix_neg[idx+2]
        ans = max(ans, current)

    print(ans)

def main():
    t = 1

    for _ in range(t):
        solve()

if __name__ == ""__main__"":
    start_time = perf_counter()
    main()
    print(perf_counter()-start_time, file=sys.stderr)","def maximum_lit_time(n, M, a):

    total_lit_time = 0

    prev_time = 0

    for time in a:
        total_lit_time += time - prev_time
        prev_time = time

    total_lit_time += M - prev_time

    max_lit_time = total_lit_time

    if n > 0:
        max_lit_time = max(max_lit_time, a[0])

    for i in range(n - 1):

        potential_lit_time = (a[i + 1] - a[i]) + (a[i] - prev_time)
        max_lit_time = max(max_lit_time, potential_lit_time)

    if n > 0:
        insertion_time = M - a[-1]
        max_lit_time = max(max_lit_time, insertion_time)
    
    return max_lit_time

n, M = map(int, input().strip().split())
a = list(map(int, input().strip().split()))

print(maximum_lit_time(n, M, a))"
46,A,Ball Game,PROGRAMMING,"['brute force', 'implementation']","A kindergarten teacher Natalia Pavlovna has invented a new ball game. This game not only develops the children's physique, but also teaches them how to count. 

The game goes as follows. Kids stand in circle. Let's agree to think of the children as numbered with numbers from 1 to *n* clockwise and the child number 1 is holding the ball. First the first child throws the ball to the next one clockwise, i.e. to the child number 2. Then the child number 2 throws the ball to the next but one child, i.e. to the child number 4, then the fourth child throws the ball to the child that stands two children away from him, i.e. to the child number 7, then the ball is thrown to the child who stands 3 children away from the child number 7, then the ball is thrown to the child who stands 4 children away from the last one, and so on. It should be mentioned that when a ball is thrown it may pass the beginning of the circle. For example, if *n*<==<=5, then after the third throw the child number 2 has the ball again. Overall, *n*<=-<=1 throws are made, and the game ends.

The problem is that not all the children get the ball during the game. If a child doesn't get the ball, he gets very upset and cries until Natalia Pavlovna gives him a candy. That's why Natalia Pavlovna asks you to help her to identify the numbers of the children who will get the ball after each throw.",The first line contains integer *n* (2<=≤<=*n*<=≤<=100) which indicates the number of kids in the circle.,In the single line print *n*<=-<=1 numbers which are the numbers of children who will get the ball after each throw. Separate the numbers by spaces.,"['10\n', '3\n']","['2 4 7 1 6 2 9 7 6\n', '2 1\n']",none,WRONG_ANSWER,"def main():
    n=int(input())
    i=1
    j=1
    L=[]
    for _ in range(1,n):
        L.append((i+j)%n)
        i+=(j%n)
        j+=1%n
    for k in L:
        print(k,end="" "")

main()","def ball_game(n):
    throws = []
    current_position = 1

    for throw in range(1, n + 1):
        current_position = (current_position + throw) % n
        if current_position == 0:
            current_position = n
        throws.append(current_position)

    return throws

n = int(input().strip())
result = ball_game(n)
print("" "".join(map(str, result)))"
817,C,Really Big Numbers,PROGRAMMING,"['binary search', 'brute force', 'dp', 'math']","Ivan likes to learn different things about numbers, but he is especially interested in really big numbers. Ivan thinks that a positive integer number *x* is really big if the difference between *x* and the sum of its digits (in decimal representation) is not less than *s*. To prove that these numbers may have different special properties, he wants to know how rare (or not rare) they are — in fact, he needs to calculate the quantity of really big numbers that are not greater than *n*.

Ivan tried to do the calculations himself, but soon realized that it's too difficult for him. So he asked you to help him in calculations.","The first (and the only) line contains two integers *n* and *s* (1<=≤<=*n*,<=*s*<=≤<=1018).",Print one integer — the quantity of really big numbers that are not greater than *n*.,"['12 1\n', '25 20\n', '10 9\n']","['3\n', '0\n', '1\n']","In the first example numbers 10, 11 and 12 are really big.

In the second example there are no really big numbers that are not greater than 25 (in fact, the first really big number is 30: 30 - 3 ≥ 20).

In the third example 10 is the only really big number (10 - 1 ≥ 9).",WRONG_ANSWER,"def nine(p) :
    
    s=''
    for i in range(p) :
        s+='9'
    return int(s)
n,k=map(int,input().split())
l=[0]*19
for i in range(18) :
    e=nine(18-i)
    l[i]=int(k/e)
    
    k-=l[i]*e
    if k==0 :
        break
    if i==17  or k%e>nine(18-i-1)*9 :
        
        l[i]+=1
        break
otv=0
for i in range(18) :
    
    otv+=10**(18-i)*l[i]
print(max(n-otv+1,0))","def sum_of_digits(x):
    """"""Return the sum of the digits of x.""""""
    return sum(int(d) for d in str(x))

def is_really_big_number(x, s):
    """"""Check if the number x is really big according to the condition.""""""
    return x - sum_of_digits(x) >= s

def count_really_big_numbers(n, s):
    """"""Count the number of really big numbers not greater than n.""""""
    count = 0
    for x in range(1, n + 1):
        if is_really_big_number(x, s):
            count += 1
    return count

input_data = input().strip()
n, s = map(int, input_data.split())

result = count_really_big_numbers(n, s)
print(result)"
2,A,Winner,PROGRAMMING,"['hashing', 'implementation']","The winner of the card game popular in Berland ""Berlogging"" is determined according to the following rules. If at the end of the game there is only one player with the maximum number of points, he is the winner. The situation becomes more difficult if the number of such players is more than one. During each round a player gains or loses a particular number of points. In the course of the game the number of points is registered in the line ""name score"", where name is a player's name, and score is the number of points gained in this round, which is an integer number. If score is negative, this means that the player has lost in the round. So, if two or more players have the maximum number of points (say, it equals to *m*) at the end of the game, than wins the one of them who scored at least *m* points first. Initially each player has 0 points. It's guaranteed that at the end of the game at least one player has a positive number of points.","The first line contains an integer number *n* (1<=<=≤<=<=*n*<=<=≤<=<=1000), *n* is the number of rounds played. Then follow *n* lines, containing the information about the rounds in ""name score"" format in chronological order, where name is a string of lower-case Latin letters with the length from 1 to 32, and score is an integer number between -1000 and 1000, inclusive.",Print the name of the winner.,"['3\nmike 3\nandrew 5\nmike 2\n', '3\nandrew 3\nandrew 2\nmike 5\n']","['andrew\n', 'andrew\n']",none,WRONG_ANSWER,"players = int(input())

def get_max_value(d: dict) -> int:
    return max(list(d.values()))

d = {}
l = []
for i in range(players):
    player, value = input().split()
    value = int(value)
    l.append((player, value))
    d[player] = d.get(player, 0) + value

max_value = get_max_value(d)
d.clear()
for t in l:
    player, value = t
    d[player] = d.get(player, 0) + value
    if d[player] == max_value:
        print(player)
        break","def determine_winner(n, rounds):
    scores = {}
    max_score = float('-inf')

    score_history = {}
    
    for entry in rounds:
        name, score = entry.split()
        score = int(score)

        if name not in scores:
            scores[name] = 0
            score_history[name] = 0
            
        scores[name] += score
        score_history[name] += score

        max_score = max(max_score, scores[name])

    potential_winners = [name for name, score in scores.items() if score == max_score]
    
    if len(potential_winners) == 1:

        return potential_winners[0]

    first_to_reach_max = None
    for entry in rounds:
        name, score = entry.split()
        score = int(score)
        
        if name in potential_winners and first_to_reach_max is None:

            score_history[name] += score
            
            if score_history[name] >= max_score:
                first_to_reach_max = name
                break
    
    return first_to_reach_max

input_data = [
    '3\nmike 3\nandrew 5\nmike 2\n', 
    '3\nandrew 3\nandrew 2\nmike 5\n'
]

outputs = []

for data in input_data:
    lines = data.strip().splitlines()
    n = int(lines[0])
    rounds = lines[1:]
    winner = determine_winner(n, rounds)
    outputs.append(winner)

print(outputs)"
32,B,Borze,PROGRAMMING,"['expression parsing', 'implementation']","Ternary numeric notation is quite popular in Berland. To telegraph the ternary number the Borze alphabet is used. Digit 0 is transmitted as «.», 1 as «-.» and 2 as «--». You are to decode the Borze code, i.e. to find out the ternary number given its representation in Borze alphabet.",The first line contains a number in Borze code. The length of the string is between 1 and 200 characters. It's guaranteed that the given string is a valid Borze code of some ternary number (this number can have leading zeroes).,Output the decoded ternary number. It can have leading zeroes.,"['.-.--\n', '--.\n', '-..-.--\n']","['012', '20', '1012']",none,OK,"s=input()
ls=[]
def b(s):
    if len(s)==0:
        return ''
    if s[0]=='.':
        return '0'+ b(s[1:])
    if s[0]=='-' and s[1]=='.':
        return '1'+ b(s[2:])
    if s[0]=='-' and s[1]=='-':
        return '2'+ b(s[2:])
print(b(s))","def decode_borze(borze_code):

    result = """"
    i = 0
    while i < len(borze_code):
        if borze_code[i] == '.':
            result += '0'
            i += 1
        elif borze_code[i] == '-':
            if i + 1 < len(borze_code) and borze_code[i + 1] == '.':
                result += '1'
                i += 2
            elif i + 1 < len(borze_code) and borze_code[i + 1] == '-':
                result += '2'
                i += 2
    return result

input_strings = ['.-.--\n', '--.\n', '-..-.--\n']

output_results = [decode_borze(borze.strip()) for borze in input_strings]

for result in output_results:
    print(result)"
96,A,Football,PROGRAMMING,"['implementation', 'strings']","Petya loves football very much. One day, as he was watching a football match, he was writing the players' current positions on a piece of paper. To simplify the situation he depicted it as a string consisting of zeroes and ones. A zero corresponds to players of one team; a one corresponds to players of another team. If there are at least 7 players of some team standing one after another, then the situation is considered dangerous. For example, the situation 00100110111111101 is dangerous and 11110111011101 is not. You are given the current situation. Determine whether it is dangerous or not.","The first input line contains a non-empty string consisting of characters ""0"" and ""1"", which represents players. The length of the string does not exceed 100 characters. There's at least one player from each team present on the field.","Print ""YES"" if the situation is dangerous. Otherwise, print ""NO"".","['001001\n', '1000000001\n']","['NO\n', 'YES\n']",none,OK,"def dangerous(word):
    zero=0
    ones=0
    for i in range(0, len(word)):
        if word[i]=='1':
            zero=0
            ones+=1
            if ones>=7:
                return True
        else:
            ones=0
            zero+=1
            if zero>=7:
                return True
    return False

def main():
    word = input()
    if dangerous(word):
        print(""YES"")
    else:
        print(""NO"")

if __name__ == ""__main__"":
    main()","current_position = input().strip()

if '0000000' in current_position or '1111111' in current_position:
    print(""YES"")
else:
    print(""NO"")"
604,B,More Cowbell,PROGRAMMING,"['binary search', 'greedy']","Kevin Sun wants to move his precious collection of *n* cowbells from Naperthrill to Exeter, where there is actually grass instead of corn. Before moving, he must pack his cowbells into *k* boxes of a fixed size. In order to keep his collection safe during transportation, he won't place more than two cowbells into a single box. Since Kevin wishes to minimize expenses, he is curious about the smallest size box he can use to pack his entire collection. 

Kevin is a meticulous cowbell collector and knows that the size of his *i*-th (1<=≤<=*i*<=≤<=*n*) cowbell is an integer *s**i*. In fact, he keeps his cowbells sorted by size, so *s**i*<=-<=1<=≤<=*s**i* for any *i*<=&gt;<=1. Also an expert packer, Kevin can fit one or two cowbells into a box of size *s* if and only if the sum of their sizes does not exceed *s*. Given this information, help Kevin determine the smallest *s* for which it is possible to put all of his cowbells into *k* boxes of size *s*.","The first line of the input contains two space-separated integers *n* and *k* (1<=≤<=*n*<=≤<=2·*k*<=≤<=100<=000), denoting the number of cowbells and the number of boxes, respectively.

The next line contains *n* space-separated integers *s*1,<=*s*2,<=...,<=*s**n* (1<=≤<=*s*1<=≤<=*s*2<=≤<=...<=≤<=*s**n*<=≤<=1<=000<=000), the sizes of Kevin's cowbells. It is guaranteed that the sizes *s**i* are given in non-decreasing order.","Print a single integer, the smallest *s* for which it is possible for Kevin to put all of his cowbells into *k* boxes of size *s*.","['2 1\n2 5\n', '4 3\n2 3 5 9\n', '3 2\n3 5 7\n']","['7\n', '9\n', '8\n']","In the first sample, Kevin must pack his two cowbells into the same box. 

In the second sample, Kevin can pack together the following sets of cowbells: {2, 3}, {5} and {9}.

In the third sample, the optimal solution is {3, 5} and {7}.",OK,"import math
import time
from collections import defaultdict,deque
from sys import stdin,stdout
from bisect import bisect_left,bisect_right
n,k=map(int,stdin.readline().split())
a=list(map(int,stdin.readline().split()))
double=n-k
ans=0
for i in range(double):
    ans=max(ans,a[i]+a[2*double-1-i])
temp=-math.inf
if(k+k!=n):
    temp=max(a[2*double:])
ans=max(ans,temp)
print(ans)","def min_box_size(n, k, sizes):

    if k >= n:
        return sizes[-1]

    sizes.sort()

    max_size = 0

    for i in range(k):
        if i < n - k:

            combined_size = sizes[i] + sizes[n - 1 - i]
            max_size = max(max_size, combined_size)
        else:

            max_size = max(max_size, sizes[n - 1 - i])

    return max_size

n, k = map(int, input().split())
sizes = list(map(int, input().split()))

result = min_box_size(n, k, sizes)
print(result)"
6,B,President's Office,PROGRAMMING,['implementation'],"President of Berland has a very vast office-room, where, apart from him, work his subordinates. Each subordinate, as well as President himself, has his own desk of a unique colour. Each desk is rectangular, and its sides are parallel to the office walls. One day President decided to establish an assembly, of which all his deputies will be members. Unfortunately, he does not remember the exact amount of his deputies, but he remembers that the desk of each his deputy is adjacent to his own desk, that is to say, the two desks (President's and each deputy's) have a common side of a positive length.

The office-room plan can be viewed as a matrix with *n* rows and *m* columns. Each cell of this matrix is either empty, or contains a part of a desk. An uppercase Latin letter stands for each desk colour. The «period» character («.») stands for an empty cell.","The first line contains two separated by a space integer numbers *n*, *m* (1<=≤<=*n*,<=*m*<=≤<=100) — the length and the width of the office-room, and *c* character — the President's desk colour. The following *n* lines contain *m* characters each — the office-room description. It is guaranteed that the colour of each desk is unique, and each desk represents a continuous subrectangle of the given matrix. All colours are marked by uppercase Latin letters.",Print the only number — the amount of President's deputies.,"['3 4 R\nG.B.\n.RR.\nTTT.\n', '3 3 Z\n...\n.H.\n..Z\n']","['2\n', '0\n']",none,OK,"def checa(x, y):
    if x < 0 or x >= n or y < 0 or y >= m or matrix[x][y] == c or matrix[x][y] == '.':
        return False
    return True
n, m, c = input().split()
n, m = int(n), int(m)

matrix = []
for k in range(n):
    matrix.append(input())

x = [-1, 0, 0, 1]
y = [0, 1, -1, 0]

m7 = set([])

for i in range(n):
    for j in range(m):
        if matrix[i][j] == c:
            for k in range(4):
                if checa(i + x[k], j + y[k]):
                    m7.add(matrix[i + x[k]][ j + y[k]])
print(len(m7))","def count_deputies(office_description):

    first_line, *office_lines = office_description.strip().splitlines()
    n, m, president_desk_color = first_line.split()
    
    n, m = int(n), int(m)
    office_matrix = [list(line) for line in office_lines]

    def is_adjacent_to_president(x, y):
        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            nx, ny = x + dx, y + dy
            if 0 <= nx < n and 0 <= ny < m and office_matrix[nx][ny] == president_desk_color:
                return True
        return False

    deputy_colors = set()

    for i in range(n):
        for j in range(m):
            if office_matrix[i][j] != '.' and office_matrix[i][j] != president_desk_color:

                if is_adjacent_to_president(i, j):
                    deputy_colors.add(office_matrix[i][j])

    return len(deputy_colors)

input_data = [
    '3 4 R\nG.B.\n.RR.\nTTT.\n',
    '3 3 Z\n...\n.H.\n..Z\n'
]

results = [f""{count_deputies(data)}\n"" for data in input_data]
print(''.join(results))"
991,E,Bus Number,PROGRAMMING,"['brute force', 'combinatorics', 'math']","This night wasn't easy on Vasya. His favorite team lost, and he didn't find himself victorious either — although he played perfectly, his teammates let him down every time. He had to win at least one more time, but the losestreak only grew longer and longer... It's no wonder he didn't get any sleep this night at all.

In the morning, Vasya was waiting the bus to the university on the bus stop. Vasya's thoughts were hazy and so he couldn't remember the right bus' number quite right and got onto the bus with the number $n$.

In the bus, Vasya thought that he could get the order of the digits in the number of the bus wrong. Futhermore, he could ""see"" some digits several times, but the digits he saw were definitely in the real number of the bus. For example, if Vasya saw the number 2028, it could mean that the real bus number could be 2028, 8022, 2820 or just 820. However, numbers 80, 22208, 52 definitely couldn't be the number of the bus. Also, real bus number couldn't start with the digit 0, this meaning that, for example, number 082 couldn't be the real bus number too.

Given $n$, determine the total number of possible bus number variants.",The first line contains one integer $n$ ($1 \leq n \leq 10^{18}$) — the number of the bus that was seen by Vasya. It is guaranteed that this number does not start with $0$.,Output a single integer — the amount of possible variants of the real bus number.,"['97\n', '2028\n']","['2\n', '13\n']","In the first sample, only variants $97$ and $79$ are possible.

In the second sample, the variants (in the increasing order) are the following: $208$, $280$, $802$, $820$, $2028$, $2082$, $2208$, $2280$, $2802$, $2820$, $8022$, $8202$, $8220$.",OK,"fact = [0 for _ in range(35)]
fact[0] = 1
for q in range(1,35):
    fact[q] = fact[q-1]*q
amts = []
ans = 0
def multinom():
    tot = 0
    for i in amts:
        tot = tot + i
    ret = fact[tot]
    for i in amts:
        ret = ret / fact[i]
    return ret

t = int(input())
digct = []
for i in range(10):
    digct.append(0)
tcpy = t
while tcpy > 0:
    digct[int(tcpy%10)] = digct[int(tcpy%10)]+1
    tcpy = tcpy // 10
def dfs(place):
    global ans
    if place == 10:
        ans = ans + multinom()
        if amts[0] > 0:
            amts[0] = amts[0]-1
            ans = ans - multinom()
            amts[0] = amts[0]+1
        return
    if digct[place] == 0:
        amts.append(0)
        dfs(place+1)
        amts.pop()
    else:
        for q in range(1, digct[place]+1):
            amts.append(q)
            dfs(place+1)
            amts.pop()

dfs(0)
print(int(ans))","from itertools import permutations

def count_bus_variants(n):

    str_n = str(n)

    unique_variants = set()

    for perm in permutations(str_n):

        perm_str = ''.join(perm)

        if perm_str[0] != '0':
            unique_variants.add(perm_str)

    return len(unique_variants)

if __name__ == ""__main__"":
    import sys
    
    input_data = sys.stdin.read().strip().split()
    results = []
    
    for line in input_data:
        n = int(line)
        result = count_bus_variants(n)
        results.append(result)

    for res in results:
        print(res)"
938,C,Constructing Tests,PROGRAMMING,"['binary search', 'brute force', 'constructive algorithms']","Let's denote a *m*-free matrix as a binary (that is, consisting of only 1's and 0's) matrix such that every square submatrix of size *m*<=×<=*m* of this matrix contains at least one zero. 

Consider the following problem:

You are given two integers *n* and *m*. You have to construct an *m*-free square matrix of size *n*<=×<=*n* such that the number of 1's in this matrix is maximum possible. Print the maximum possible number of 1's in such matrix.

You don't have to solve this problem. Instead, you have to construct a few tests for it.

You will be given *t* numbers *x*1, *x*2, ..., *x**t*. For every , find two integers *n**i* and *m**i* (*n**i*<=≥<=*m**i*) such that the answer for the aforementioned problem is exactly *x**i* if we set *n*<==<=*n**i* and *m*<==<=*m**i*.","The first line contains one integer *t* (1<=≤<=*t*<=≤<=100) — the number of tests you have to construct.

Then *t* lines follow, *i*-th line containing one integer *x**i* (0<=≤<=*x**i*<=≤<=109).

Note that in hacks you have to set *t*<==<=1.","For each test you have to construct, output two positive numbers *n**i* and *m**i* (1<=≤<=*m**i*<=≤<=*n**i*<=≤<=109) such that the maximum number of 1's in a *m**i*-free *n**i*<=×<=*n**i* matrix is exactly *x**i*. If there are multiple solutions, you may output any of them; and if this is impossible to construct a test, output a single integer <=-<=1.",['3\n21\n0\n1\n'],['5 2\n1 1\n-1\n'],none,WRONG_ANSWER,"def make_divisors(n):
    divisors = []
    for i in range(1, int(n**0.5)+1):
        if n % i == 0:
            divisors.append(i)
            if i != n // i:
                divisors.append(n//i)

    return divisors

t = int(input())
for i in range(t):
    x = int(input())
    if x == 0:
        print(1, 1)
        continue
    d = make_divisors(x)
    for a in d:
        b = x//a
        if b >= a:
            continue
        if a%2 == b%2:
            n = (a+b)//2
            m = (a-b)//2
            print(n, m)
            break
    else:
        print(-1)","def construct_tests(t, x_list):
    results = []
    for x in x_list:
        if x == 0:
            results.append(""1 1"")
        elif x == 1:
            results.append(""1 1"")
        else:

            n = x + 1
            m = 2
            results.append(f""{n} {m}"")
    
    return results

t = int(input().strip())
x_list = [int(input().strip()) for _ in range(t)]

results = construct_tests(t, x_list)
for result in results:
    print(result)"
546,A,Soldier and Bananas,PROGRAMMING,"['brute force', 'implementation', 'math']","A soldier wants to buy *w* bananas in the shop. He has to pay *k* dollars for the first banana, 2*k* dollars for the second one and so on (in other words, he has to pay *i*·*k* dollars for the *i*-th banana). 

He has *n* dollars. How many dollars does he have to borrow from his friend soldier to buy *w* bananas?","The first line contains three positive integers *k*,<=*n*,<=*w* (1<=<=≤<=<=*k*,<=*w*<=<=≤<=<=1000, 0<=≤<=*n*<=≤<=109), the cost of the first banana, initial number of dollars the soldier has and number of bananas he wants.","Output one integer — the amount of dollars that the soldier must borrow from his friend. If he doesn't have to borrow money, output 0.",['3 17 4\n'],['13'],none,COMPILATION_ERROR,"/**
 *  author: Ratem
 *  created: 12.10.2023 12:58:39
**/

using namespace std;
typedef long long ll;

int main()
{
    ll k, n, w;
    cin >> k >> n >> w;

    for (int i = 1; i <= w; i++)
    	n -= i * k;

    printf(""%d\n"", abs(n));
    return 0;
}","def calculate_borrowed(k, n, w):

    total_cost = k * (w * (w + 1)) // 2

    amount_to_borrow = total_cost - n

    return max(amount_to_borrow, 0)

k, n, w = map(int, input().strip().split())

print(calculate_borrowed(k, n, w))"
793,B,Igor and his way to work,PROGRAMMING,"['dfs and similar', 'graphs', 'implementation', 'shortest paths']","Woken up by the alarm clock Igor the financial analyst hurried up to the work. He ate his breakfast and sat in his car. Sadly, when he opened his GPS navigator, he found that some of the roads in Bankopolis, the city where he lives, are closed due to road works. Moreover, Igor has some problems with the steering wheel, so he can make no more than two turns on his way to his office in bank.

Bankopolis looks like a grid of *n* rows and *m* columns. Igor should find a way from his home to the bank that has no more than two turns and doesn't contain cells with road works, or determine that it is impossible and he should work from home. A turn is a change in movement direction. Igor's car can only move to the left, to the right, upwards and downwards. Initially Igor can choose any direction. Igor is still sleepy, so you should help him.","The first line contains two integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=1000) — the number of rows and the number of columns in the grid.

Each of the next *n* lines contains *m* characters denoting the corresponding row of the grid. The following characters can occur: 
 -  ""."" — an empty cell; -  ""*"" — a cell with road works; -  ""S"" — the cell where Igor's home is located; -  ""T"" — the cell where Igor's office is located. 
It is guaranteed that ""S"" and ""T"" appear exactly once each.","In the only line print ""YES"" if there is a path between Igor's home and Igor's office with no more than two turns, and ""NO"" otherwise.","['5 5\n..S..\n****.\nT....\n****.\n.....\n', '5 5\nS....\n****.\n.....\n.****\n..T..\n']","['YES', 'NO']","The first sample is shown on the following picture:

In the second sample it is impossible to reach Igor's office using less that 4 turns, thus there exists no path using no more than 2 turns. The path using exactly 4 turns is shown on this picture:",RUNTIME_ERROR,"def maze(a , r , c , t ,dir ,lastDir ,turnCount):
    if r==t[0] and c==t[1]:
        return True
    if r==-1 or r>n-1 or c>m-1 or c==-1:
        return False
    if dir not in lastDir and lastDir is not ""0"":
        turnCount+=1
        if turnCount>2:
            return False
    if a[r][c] is ""*"":
        return False
    if maze(a,r+1,c,t,""U"",dir,turnCount) or maze(a,r-1,c,t,""D"",dir,turnCount) or maze(a,r,c-1,t,""L"",dir,turnCount) or maze(a,r,c+1,t,""R"",dir,turnCount):
        return True
    return False

n,m=tuple(input().split("" ""))
n=int(n)
m=int(m)
a=[]
s=(-1,-1)
t=(-1,-1)
for x in range(n):
    a.append(list(input()))
    if ""S"" in a[x]:
        s=(x,a[x].index(""S""))
    if ""T"" in a[x]:
        t = (x, a[x].index(""T""))
if maze(a,s[0],s[1],t,""0"",""0"",0):
    print(""YES"")
    exit(0)
else:
    print(""NO"")
    exit(0)","def can_reach_office(n, m, grid):

    start = None
    target = None
    
    for i in range(n):
        for j in range(m):
            if grid[i][j] == 'S':
                start = (i, j)
            elif grid[i][j] == 'T':
                target = (i, j)

    def is_path_possible(x_start, y_start, x_target, y_target):

        if x_start == x_target:

            if all(grid[x_start][j] != '*' for j in range(min(y_start, y_target), max(y_start, y_target) + 1)):
                return True
        if y_start == y_target:

            if all(grid[i][y_start] != '*' for i in range(min(x_start, x_target), max(x_start, x_target) + 1)):
                return True
        return False

    if is_path_possible(start[0], start[1], target[0], target[1]):
        return ""YES""

    for i in range(n):
        if grid[i][start[1]] != '*':
            if is_path_possible(i, start[1], target[0], target[1]):
                return ""YES""

    for j in range(m):
        if grid[start[0]][j] != '*':
            if is_path_possible(start[0], j, target[0], target[1]):
                return ""YES""

    return ""NO""

import sys

input_data = sys.stdin.read().strip().split('\n')
n, m = map(int, input_data[0].split())
grid = input_data[1:]

print(can_reach_office(n, m, grid))"
180,F,Mathematical Analysis Rocks!,PROGRAMMING,"['constructive algorithms', 'implementation', 'math']","Students of group 199 have written their lectures dismally. Now an exam on Mathematical Analysis is approaching and something has to be done asap (that is, quickly). Let's number the students of the group from 1 to *n*. Each student *i* (1<=≤<=*i*<=≤<=*n*) has a best friend *p*[*i*] (1<=≤<=*p*[*i*]<=≤<=*n*). In fact, each student is a best friend of exactly one student. In other words, all *p*[*i*] are different. It is possible that the group also has some really ""special individuals"" for who *i*<==<=*p*[*i*].

Each student wrote exactly one notebook of lecture notes. We know that the students agreed to act by the following algorithm: 
 -  on the first day of revising each student studies his own Mathematical Analysis notes, -  in the morning of each following day each student gives the notebook to his best friend and takes a notebook from the student who calls him the best friend. 
Thus, on the second day the student *p*[*i*] (1<=≤<=*i*<=≤<=*n*) studies the *i*-th student's notes, on the third day the notes go to student *p*[*p*[*i*]] and so on. Due to some characteristics of the boys' friendship (see paragraph 1), each day each student has exactly one notebook to study.

You are given two sequences that describe the situation on the third and fourth days of revising:
 -  *a*1,<=*a*2,<=...,<=*a**n*, where *a**i* means the student who gets the *i*-th student's notebook on the third day of revising; -  *b*1,<=*b*2,<=...,<=*b**n*, where *b**i* means the student who gets the *i*-th student's notebook on the fourth day of revising. 
You do not know array *p*, that is you do not know who is the best friend to who. Write a program that finds *p* by the given sequences *a* and *b*.","The first line contains integer *n* (1<=≤<=*n*<=≤<=105) — the number of students in the group. The second line contains sequence of different integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=*n*). The third line contains the sequence of different integers *b*1,<=*b*2,<=...,<=*b**n* (1<=≤<=*b**i*<=≤<=*n*).","Print sequence *n* of different integers *p*[1],<=*p*[2],<=...,<=*p*[*n*] (1<=≤<=*p*[*i*]<=≤<=*n*). It is guaranteed that the solution exists and that it is unique.","['4\n2 1 4 3\n3 4 2 1\n', '5\n5 2 3 1 4\n1 3 2 4 5\n', '2\n1 2\n2 1\n']","['4 3 1 2 ', '4 3 2 5 1 ', '2 1 ']",none,OK,"import string

def main_function():
    n = int(input())
    a = [int(i) for i in input().split("" "")]
    b = [int(i) for i in input().split("" "")]
    hash_a = [0 for i in range(n + 1)]
    hash_b = [0 for i in range(n + 1)]
    for i in range(len(a)):
        hash_a[a[i]] = i + 1
        hash_b[b[i]] = i + 1
    collector = []
    for i in b:
        collector.append(hash_a[i])
    print("" "".join([str(u) for u in collector]))

if __name__ == '__main__':
    main_function()","def find_best_friends(n, a, b):

    p = [0] * n

    for i in range(n):

        p[a[i] - 1] = b[i]

    return p

import sys

input = sys.stdin.read
data = input().strip().split('\n')
results = []

for i in range(0, len(data), 3):
    n = int(data[i])
    a = list(map(int, data[i + 1].split()))
    b = list(map(int, data[i + 2].split()))

    p = find_best_friends(n, a, b)

    results.append(' '.join(map(str, p)))

print('\n'.join(results))"
597,C,Subsequences,PROGRAMMING,"['data structures', 'dp']",For the given sequence with *n* different elements find the number of increasing subsequences with *k*<=+<=1 elements. It is guaranteed that the answer is not greater than 8·1018.,"First line contain two integer values *n* and *k* (1<=≤<=*n*<=≤<=105,<=0<=≤<=*k*<=≤<=10) — the length of sequence and the number of elements in increasing subsequences.

Next *n* lines contains one integer *a**i* (1<=≤<=*a**i*<=≤<=*n*) each — elements of sequence. All values *a**i* are different.",Print one integer — the answer to the problem.,['5 2\n1\n2\n3\n5\n4\n'],['7\n'],none,WRONG_ANSWER,"import sys

def input():
    return sys.stdin.readline().rstrip(""\r\n"")

def getsum(BITTree, i):

    s = 0

    i = i + 1

    while i > 0:

        s += BITTree[i]

        i -= i & (-i)
    return s

def updatebit(BITTree, n, i, v):

    i += 1

    while i <= n:

        BITTree[i] += v

        i += i & (-i)

def construct(arr, n, dummy=True):

    BITTree = [0] * (n + 1)

    if not dummy:
        for i in range(n):
            updatebit(BITTree, n, i, arr[i])

    return BITTree

lens, kis = input().split()
lens, kis = int(lens), int(kis)
trees = [construct([0] * lens, lens) for _ in range(kis+1)]

for i in range(1, lens+1):
    arr_num = int(input())
    for k in range(kis+1):

        if k == 0:
            value = 1
        else:
            value = getsum(trees[k-1], i=arr_num - 1) + 1
        updatebit(trees[k], n=lens, i=arr_num, v=value)

print(trees[kis][-1])","from bisect import bisect_left

def count_increasing_subsequences(n, k, sequence):

    dp = [[0] * (k + 1) for _ in range(n + 1)]
    dp[0][0] = 1

    for i in range(1, n + 1):
        a_i = sequence[i - 1]

        for length in range(k, 0, -1):
            count = 0

            for j in range(i - 1, -1, -1):
                if j == 0 or sequence[j - 1] < a_i:
                    count += dp[j][length - 1]
                    
            dp[i][length] = count

    return sum(dp[i][length] for i in range(n + 1) for length in range(1, k + 1))

n, k = map(int, input().split())
sequence = [int(input()) for _ in range(n)]

result = count_increasing_subsequences(n, k, sequence)

print(result)"
875,A,Classroom Watch,PROGRAMMING,"['brute force', 'math']","Eighth-grader Vova is on duty today in the class. After classes, he went into the office to wash the board, and found on it the number *n*. He asked what is this number and the teacher of mathematics Inna Petrovna answered Vova that *n* is the answer to the arithmetic task for first-graders. In the textbook, a certain positive integer *x* was given. The task was to add *x* to the sum of the digits of the number *x* written in decimal numeral system.

Since the number *n* on the board was small, Vova quickly guessed which *x* could be in the textbook. Now he wants to get a program which will search for arbitrary values of the number *n* for all suitable values of *x* or determine that such *x* does not exist. Write such a program for Vova.",The first line contains integer *n* (1<=≤<=*n*<=≤<=109).,"In the first line print one integer *k* — number of different values of *x* satisfying the condition. 

In next *k* lines print these values in ascending order.","['21\n', '20\n']","['1\n15\n', '0\n']","In the first test case *x* = 15 there is only one variant: 15 + 1 + 5 = 21.

In the second test case there are no such *x*.",WRONG_ANSWER,"def getSum(n):
    sum = 0
    while(n > 0):
        sum += int(n % 10)
        n = int(n/10)
    return sum
    

t=int(input())
c=0
l=[]
for i in range(10,t):
    s=t
    s=s-getSum(i)
    if s==i:
        l.append(i)
        c+=1
if c==0:
    print(c)
else:
    print(c)
    for i in l:
        print(i,end=""\n"")","def sum_of_digits(x):
    """"""Calculate the sum of digits of the number x.""""""
    return sum(int(digit) for digit in str(x))

def find_valid_x(n):
    """"""Find all values of x that satisfy the condition x + sum_of_digits(x) = n.""""""
    valid_x = []

    for x in range(max(1, n - 9 * len(str(n))), n):
        if x + sum_of_digits(x) == n:
            valid_x.append(x)
    return valid_x

if __name__ == ""__main__"":
    n = int(input().strip())
    results = find_valid_x(n)
    print(len(results))
    for x in results:
        print(x)"
224,A,Parallelepiped,PROGRAMMING,"['brute force', 'geometry', 'math']",You've got a rectangular parallelepiped with integer edge lengths. You know the areas of its three faces that have a common vertex. Your task is to find the sum of lengths of all 12 edges of this parallelepiped.,The first and the single line contains three space-separated integers — the areas of the parallelepiped's faces. The area's values are positive (<=&gt;<=0) and do not exceed 104. It is guaranteed that there exists at least one parallelepiped that satisfies the problem statement.,Print a single number — the sum of all edges of the parallelepiped.,"['1 1 1\n', '4 6 6\n']","['12\n', '28\n']","In the first sample the parallelepiped has sizes 1 × 1 × 1, in the second one — 2 × 2 × 3.",WRONG_ANSWER,"from math import sqrt,gcd,ceil,floor,log,factorial
from itertools import permutations,combinations
from collections import Counter, defaultdict
import collections,sys,threading
import collections,sys,threading
from bisect import *
from heapq import *

def ii(): return int(input())
def si(): return input()
def mi(): return map(int,input().split())
def msi(): return map(str,input().split())
def li(): return list(mi())

a1,a2,a3=mi()

h = sqrt((a2*a3)/a1)
l = a2/h
b = a1/l

print(4*(l+b+h))","import sys

areas = list(map(int, sys.stdin.readline().strip().split()))

A, B, C = areas

x = (A * C) ** 0.5 / (B ** 0.5)
y = (A * B) ** 0.5 / (C ** 0.5)
z = (B * C) ** 0.5 / (A ** 0.5)

edge_sum = 4 * (x + y + z)

print(int(edge_sum))"
50,A,Domino piling,PROGRAMMING,"['greedy', 'math']","You are given a rectangular board of *M*<=×<=*N* squares. Also you are given an unlimited number of standard domino pieces of 2<=×<=1 squares. You are allowed to rotate the pieces. You are asked to place as many dominoes as possible on the board so as to meet the following conditions:

1. Each domino completely covers two squares.

2. No two dominoes overlap.

3. Each domino lies entirely inside the board. It is allowed to touch the edges of the board.

Find the maximum number of dominoes, which can be placed under these restrictions.",In a single line you are given two integers *M* and *N* — board sizes in squares (1<=≤<=*M*<=≤<=*N*<=≤<=16).,"Output one number — the maximal number of dominoes, which can be placed.","['2 4\n', '3 3\n']","['4\n', '4\n']",none,OK,"import sys
import bisect

input = sys.stdin.readline

def yes():
    print(""YES"")

def no():
    print(""NO"")

m, n = map(int, input().split())
s = m * n
print(s // 2)","def max_dominoes(M, N):

    return (M * N) // 2

import sys

input_data = sys.stdin.read().strip().split('\n')
results = []

for line in input_data:
    M, N = map(int, line.split())
    results.append(max_dominoes(M, N))

for result in results:
    print(result)"
919,B,Perfect Number,PROGRAMMING,"['binary search', 'brute force', 'dp', 'implementation', 'number theory']","We consider a positive integer perfect, if and only if the sum of its digits is exactly $10$. Given a positive integer $k$, your task is to find the $k$-th smallest perfect positive integer.","A single line with a positive integer $k$ ($1 \leq k \leq 10\,000$).","A single number, denoting the $k$-th smallest perfect integer.","['1\n', '2\n']","['19\n', '28\n']",The first perfect integer is $19$ and the second one is $28$.,OK,"import sys
def input(): return sys.stdin.readline().strip()
def getints(): return map(int,sys.stdin.readline().strip().split())

n = int(input())
ans = 19
i = 1

while i < n:
    ans += 9
    if sum(map(int,str(ans))) == 10: i+= 1
print(ans)","def digit_sum(n):
    """"""Calculate the sum of the digits of the number n.""""""
    return sum(int(digit) for digit in str(n))

def find_kth_perfect_integer(k):
    """"""Find the k-th smallest perfect integer where the sum of its digits is 10.""""""
    count = 0
    num = 18

    while count < k:
        num += 1
        if digit_sum(num) == 10:
            count += 1

    return num

k = int(input().strip())

print(find_kth_perfect_integer(k))"
476,C,Dreamoon and Sums,PROGRAMMING,['math'],"Dreamoon loves summing up something for no reason. One day he obtains two integers *a* and *b* occasionally. He wants to calculate the sum of all nice integers. Positive integer *x* is called nice if  and , where *k* is some integer number in range [1,<=*a*].

By  we denote the quotient of integer division of *x* and *y*. By  we denote the remainder of integer division of *x* and *y*. You can read more about these operations here: http://goo.gl/AcsXhT.

The answer may be large, so please print its remainder modulo 1<=000<=000<=007 (109<=+<=7). Can you compute it faster than Dreamoon?","The single line of the input contains two integers *a*, *b* (1<=≤<=*a*,<=*b*<=≤<=107).",Print a single integer representing the answer modulo 1<=000<=000<=007 (109<=+<=7).,"['1 1\n', '2 2\n']","['0\n', '8\n']","For the first sample, there are no nice integers because <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/03b1dc6bae5180f8a2d8eb85789e8b393e585970.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> is always zero.

For the second sample, the set of nice integers is {3, 5}.",TIME_LIMIT_EXCEEDED,"a, b = list(map(int, input().split()))
def check(x):
    if x % b != 0:
        k = (x // b)/(x % b)
        if k >= 1 and k <= a:
            return True
    return False
s = 0
for i in range(1,10**7+1):
    
    if check(i):
        print(i)
        s += i
print(s)","def sum_nice_integers(a, b):
    MOD = 1000000007
    total_sum = 0

    for k in range(1, a + 1):

        x_start = k * (b + 1)
        x_end = k * (b + 1) + b

        for x in range(x_start, x_end + 1):
            if x > 0:
                total_sum = (total_sum + x) % MOD
    
    return total_sum

a, b = map(int, input().split())

print(sum_nice_integers(a, b))"
960,A,Check the string,PROGRAMMING,['implementation'],"A has a string consisting of some number of lowercase English letters 'a'. He gives it to his friend B who appends some number of letters 'b' to the end of this string. Since both A and B like the characters 'a' and 'b', they have made sure that at this point, at least one 'a' and one 'b' exist in the string.

B now gives this string to C and he appends some number of letters 'c' to the end of the string. However, since C is a good friend of A and B, the number of letters 'c' he appends is equal to the number of 'a' or to the number of 'b' in the string. It is also possible that the number of letters 'c' equals both to the number of letters 'a' and to the number of letters 'b' at the same time.

You have a string in your hands, and you want to check if it is possible to obtain the string in this way or not. If it is possible to obtain the string, print ""YES"", otherwise print ""NO"" (without the quotes).","The first and only line consists of a string $S$ ($ 1 \le |S| \le 5\,000 $). It is guaranteed that the string will only consist of the lowercase English letters 'a', 'b', 'c'.","Print ""YES"" or ""NO"", according to the condition.","['aaabccc\n', 'bbacc\n', 'aabc\n']","['YES\n', 'NO\n', 'YES\n']","Consider first example: the number of 'c' is equal to the number of 'a'. 

Consider second example: although the number of 'c' is equal to the number of the 'b', the order is not correct.

Consider third example: the number of 'c' is equal to the number of 'b'.",WRONG_ANSWER,"def check (y):
    if y.count('a') >= 1:
        if y.count('b') >= 1:
            if y[0]=='a':
                if y.count('a') == y.count('c') or y.count('b') == y. count('c'):
                    return 'YES'
                else:
                    return 'NO'
            else:
                return 'NO'
        else:
            return 'NO'
    else:
        return 'NO'

inp = input()
print( check(inp) )","def is_possible_string(S):

    count_a = S.count('a')
    count_b = S.count('b')
    count_c = S.count('c')

    if 'c' in S and 'b' not in S[S.index('c'):]:
        return ""NO""

    if count_c == count_a or count_c == count_b:
        return ""YES""
    
    return ""NO""

input_strings = ['aaabccc\n', 'bbacc\n', 'aabc\n']
output_results = []

for s in input_strings:
    result = is_possible_string(s.strip())
    output_results.append(result)

print(output_results)"
99,A,Help Far Away Kingdom,PROGRAMMING,['strings'],"In a far away kingdom lived the King, the Prince, the Shoemaker, the Dressmaker and many other citizens. They lived happily until great trouble came into the Kingdom. The ACMers settled there.

Most damage those strange creatures inflicted upon the kingdom was that they loved high precision numbers. As a result, the Kingdom healers had already had three appointments with the merchants who were asked to sell, say, exactly 0.273549107 beer barrels. To deal with the problem somehow, the King issued an order obliging rounding up all numbers to the closest integer to simplify calculations. Specifically, the order went like this:
-  If a number's integer part does not end with digit 9 and its fractional part is strictly less than 0.5, then the rounded up number coincides with the number’s integer part. -  If a number's integer part does not end with digit 9 and its fractional part is not less than 0.5, the rounded up number is obtained if we add 1 to the last digit of the number’s integer part.-  If the number’s integer part ends with digit 9, to round up the numbers one should go to Vasilisa the Wise. In the whole Kingdom she is the only one who can perform the tricky operation of carrying into the next position. 
Merchants found the algorithm very sophisticated and they asked you (the ACMers) to help them. Can you write a program that would perform the rounding according to the King’s order?","The first line contains a single number to round up — the integer part (a non-empty set of decimal digits that do not start with 0 — with the exception of a case when the set consists of a single digit — in this case 0 can go first), then follows character «.» (a dot), and then follows the fractional part (any non-empty set of decimal digits). The number's length does not exceed 1000 characters, including the dot. There are no other characters in the input data.","If the last number of the integer part is not equal to 9, print the rounded-up number without leading zeroes. Otherwise, print the message ""GOTO Vasilisa."" (without the quotes).","['0.0\n', '1.49\n', '1.50\n', '2.71828182845904523536\n', '3.14159265358979323846\n', '12345678901234567890.1\n', '123456789123456789.999\n']","['0', '1', '2', '3', '3', '12345678901234567890', 'GOTO Vasilisa.']",none,OK,"def round_number(num_str):
    integer_part, fractional_part = num_str.split('.')
    last_digit = int(integer_part[-1])

    if last_digit != 9:
        if int(fractional_part[0]) < 5:
            return integer_part
        else:
            return str(int(integer_part) + 1)
    else:
        return ""GOTO Vasilisa.""

num_str = input().strip()

result = round_number(num_str)
print(result)","def round_number(number: str) -> str:

    int_part, frac_part = number.split('.')

    if int_part[-1] == '9':
        return ""GOTO Vasilisa.""

    frac_value = float('0.' + frac_part)

    if frac_value < 0.5:
        return int_part
    else:

        rounded_int_part = str(int(int_part) + 1)
        return rounded_int_part

inputs = ['0.0\n', '1.49\n', '1.50\n', '2.71828182845904523536\n', 
          '3.14159265358979323846\n', '12345678901234567890.1\n', 
          '123456789123456789.999\n']

outputs = [round_number(number.strip()) for number in inputs]

for output in outputs:
    print(output)"
459,A,Pashmak and Garden,PROGRAMMING,['implementation'],"Pashmak has fallen in love with an attractive girl called Parmida since one year ago...

Today, Pashmak set up a meeting with his partner in a romantic garden. Unfortunately, Pashmak has forgotten where the garden is. But he remembers that the garden looks like a square with sides parallel to the coordinate axes. He also remembers that there is exactly one tree on each vertex of the square. Now, Pashmak knows the position of only two of the trees. Help him to find the position of two remaining ones.","The first line contains four space-separated *x*1,<=*y*1,<=*x*2,<=*y*2 (<=-<=100<=≤<=*x*1,<=*y*1,<=*x*2,<=*y*2<=≤<=100) integers, where *x*1 and *y*1 are coordinates of the first tree and *x*2 and *y*2 are coordinates of the second tree. It's guaranteed that the given points are distinct.","If there is no solution to the problem, print -1. Otherwise print four space-separated integers *x*3,<=*y*3,<=*x*4,<=*y*4 that correspond to the coordinates of the two other trees. If there are several solutions you can output any of them. 

Note that *x*3,<=*y*3,<=*x*4,<=*y*4 must be in the range (<=-<=1000<=≤<=*x*3,<=*y*3,<=*x*4,<=*y*4<=≤<=1000).","['0 0 0 1\n', '0 0 1 1\n', '0 0 1 2\n']","['1 0 1 1\n', '0 1 1 0\n', '-1\n']",none,OK,"x1,y1,x2,y2 = [int(elem) for elem in input().split()]

if y1 == y2:
    print(x1, y1+(x2-x1), x2, y2+(x2-x1))
elif x1 == x2:
    print(x1+(y2-y1), y1, x2+(y2-y1), y2)
elif abs(y2 - y1) != abs(x2 - x1):
    print(-1)
else:
    print(x1,y2,x2,y1)","def find_other_trees(x1, y1, x2, y2):

    if x1 == x2:

        side_length = abs(y2 - y1)
        return (x1 + side_length, y1, x2 + side_length, y2)

    elif y1 == y2:

        side_length = abs(x2 - x1)
        return (x1, y1 + side_length, x2, y2 + side_length)

    elif abs(x2 - x1) == abs(y2 - y1):

        return (x1, y2, x2, y1)

    return -1

x1, y1, x2, y2 = map(int, input().split())

result = find_other_trees(x1, y1, x2, y2)

if result == -1:
    print(result)
else:
    print(' '.join(map(str, result)))"
650,A,Watchmen,PROGRAMMING,"['data structures', 'geometry', 'math']","Watchmen are in a danger and Doctor Manhattan together with his friend Daniel Dreiberg should warn them as soon as possible. There are *n* watchmen on a plane, the *i*-th watchman is located at point (*x**i*,<=*y**i*).

They need to arrange a plan, but there are some difficulties on their way. As you know, Doctor Manhattan considers the distance between watchmen *i* and *j* to be |*x**i*<=-<=*x**j*|<=+<=|*y**i*<=-<=*y**j*|. Daniel, as an ordinary person, calculates the distance using the formula .

The success of the operation relies on the number of pairs (*i*,<=*j*) (1<=≤<=*i*<=&lt;<=*j*<=≤<=*n*), such that the distance between watchman *i* and watchmen *j* calculated by Doctor Manhattan is equal to the distance between them calculated by Daniel. You were asked to compute the number of such pairs.","The first line of the input contains the single integer *n* (1<=≤<=*n*<=≤<=200<=000) — the number of watchmen.

Each of the following *n* lines contains two integers *x**i* and *y**i* (|*x**i*|,<=|*y**i*|<=≤<=109).

Some positions may coincide.",Print the number of pairs of watchmen such that the distance between them calculated by Doctor Manhattan is equal to the distance calculated by Daniel.,"['3\n1 1\n7 5\n1 5\n', '6\n0 0\n0 1\n0 2\n-1 1\n0 1\n1 1\n']","['2\n', '11\n']","In the first sample, the distance between watchman 1 and watchman 2 is equal to |1 - 7| + |1 - 5| = 10 for Doctor Manhattan and <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/bcb5b7064b5f02088da0fdcf677e6fda495dd0df.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> for Daniel. For pairs (1, 1), (1, 5) and (7, 5), (1, 5) Doctor Manhattan and Daniel will calculate the same distances.",WRONG_ANSWER,"from sys import stdin,stdout
from collections import deque
input = stdin.readline
 
def main():

    t=1
    for i in range(t):
        n = int(input())

        ans = 0
        d1 = {}
        d2 = {}
        d3 = {}
        for i in range(n):
            x,y = map(int,input().split())
            num = x*1000000001+y
            if num in d3:
                d3[num] += 1
            else:
                d3[num] = 1
            if x in d1:
                d1[x] += 1
            else:
                d1[x] = 1
            if y in d2:
                d2[y] += 1
            else:
                d2[y] = 1
        ans = 0
        for i in d1:
            ans += d1[i]*(d1[i]-1)//2
        for i in d2:
            ans += d2[i]*(d2[i]-1)//2
        for i in d3:
            ans -= d3[i]*(d3[i]-1)//2
        print(ans)
main()","def count_pairs(watchmen):
    count = 0
    n = len(watchmen)

    for i in range(n):
        for j in range(i, n):

            x1, y1 = watchmen[i]
            x2, y2 = watchmen[j]

            manhattan_distance = abs(x1 - x2) + abs(y1 - y2)
            euclidean_distance = ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5

            if manhattan_distance == euclidean_distance:
                count += 1

    return count

if __name__ == ""__main__"":
    import sys
    input = sys.stdin.read
    data = input().splitlines()
    
    n = int(data[0])
    watchmen = [tuple(map(int, line.split())) for line in data[1:n+1]]

    result = count_pairs(watchmen)
    
    print(result)"
246,D,Colorful Graph,PROGRAMMING,"['brute force', 'dfs and similar', 'graphs']","You've got an undirected graph, consisting of *n* vertices and *m* edges. We will consider the graph's vertices numbered with integers from 1 to *n*. Each vertex of the graph has a color. The color of the *i*-th vertex is an integer *c**i*.

Let's consider all vertices of the graph, that are painted some color *k*. Let's denote a set of such as *V*(*k*). Let's denote the value of the neighbouring color diversity for color *k* as the cardinality of the set *Q*(*k*)<==<={*c**u* :<= *c**u*<=≠<=*k* and there is vertex *v* belonging to set *V*(*k*) such that nodes *v* and *u* are connected by an edge of the graph}.

Your task is to find such color *k*, which makes the cardinality of set *Q*(*k*) maximum. In other words, you want to find the color that has the most diverse neighbours. Please note, that you want to find such color *k*, that the graph has at least one vertex with such color.","The first line contains two space-separated integers *n*,<=*m* (1<=≤<=*n*,<=*m*<=≤<=105) — the number of vertices end edges of the graph, correspondingly. The second line contains a sequence of integers *c*1,<=*c*2,<=...,<=*c**n* (1<=≤<=*c**i*<=≤<=105) — the colors of the graph vertices. The numbers on the line are separated by spaces.

Next *m* lines contain the description of the edges: the *i*-th line contains two space-separated integers *a**i*,<=*b**i* (1<=≤<=*a**i*,<=*b**i*<=≤<=*n*; *a**i*<=≠<=*b**i*) — the numbers of the vertices, connected by the *i*-th edge. 

It is guaranteed that the given graph has no self-loops or multiple edges.","Print the number of the color which has the set of neighbours with the maximum cardinality. It there are multiple optimal colors, print the color with the minimum number. Please note, that you want to find such color, that the graph has at least one vertex with such color.","['6 6\n1 1 2 3 5 8\n1 2\n3 2\n1 4\n4 3\n4 5\n4 6\n', '5 6\n4 2 5 2 4\n1 2\n2 3\n3 1\n5 3\n5 4\n3 4\n']","['3\n', '2\n']",none,WRONG_ANSWER,"from queue import Queue

def solve():
	n,m = map(int,input().split())
	color = list(map(int,input().split()))
	cc = [set()for i in range(n+5)]
	for i in range(m):
		a,b = map(int,input().split())
		if color[a-1]!=color[b-1]:
			cc[color[a-1]].add(color[b-1])
			cc[color[b-1]].add(color[a-1])
	ma = 1
	mac = len(cc[1])
	for i in range(2,n+1):
		if len(cc[i])>mac:
			ma = len(cc[i])
			mac = i
	print(mac)

t = 1

for i in range(t):
	solve()","def max_neighbour_color_diversity(n, m, colors, edges):
    from collections import defaultdict

    graph = defaultdict(list)
    for u, v in edges:
        graph[u].append(v)
        graph[v].append(u)

    color_diversity = defaultdict(set)

    for vertex in range(1, n + 1):
        current_color = colors[vertex - 1]
        for neighbor in graph[vertex]:
            neighbor_color = colors[neighbor - 1]

            if neighbor_color != current_color:
                color_diversity[current_color].add(neighbor_color)

    max_diversity = -1
    result_color = None
    
    for color, neighbors in color_diversity.items():
        diversity_count = len(neighbors)

        if (diversity_count > max_diversity) or (diversity_count == max_diversity and color < result_color):
            max_diversity = diversity_count
            result_color = color
    
    return result_color

def main():
    import sys
    input_data = sys.stdin.read().strip().split('\n')

    n, m = map(int, input_data[0].split())

    colors = list(map(int, input_data[1].split()))

    edges = [tuple(map(int, line.split())) for line in input_data[2:]]

    result = max_neighbour_color_diversity(n, m, colors, edges)
    print(result)

if __name__ == ""__main__"":
    main()"
837,D,Round Subset,PROGRAMMING,"['dp', 'math']","Let's call the roundness of the number the number of zeros to which it ends.

You have an array of *n* numbers. You need to choose a subset of exactly *k* numbers so that the roundness of the product of the selected numbers will be maximum possible.","The first line contains two integer numbers *n* and *k* (1<=≤<=*n*<=≤<=200,<=1<=≤<=*k*<=≤<=*n*).

The second line contains *n* space-separated integer numbers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=1018).",Print maximal roundness of product of the chosen subset of length *k*.,"['3 2\n50 4 20\n', '5 3\n15 16 3 25 9\n', '3 3\n9 77 13\n']","['3\n', '3\n', '0\n']","In the first example there are 3 subsets of 2 numbers. [50, 4] has product 200 with roundness 2, [4, 20] — product 80, roundness 1, [50, 20] — product 1000, roundness 3.

In the second example subset [15, 16, 25] has product 6000, roundness 3.

In the third example all subsets has product with roundness 0.",TIME_LIMIT_EXCEEDED,"from sys import stdin
input = stdin.buffer.readline

def main():
    MAX = 3000
    n, k = map(int,input().split())
    a = list(map(int,input().split()))

    pw2, pw5 = [], []
    for i in a:
        p2, p5 = 0, 0
        while i % 2 == 0:
            p2 += 1
            i //= 2
        while i % 5 == 0:
            p5 += 1
            i //= 5
        pw2.append(p2)
        pw5.append(p5)

    prev = [[-1] * MAX for _ in range(n + 1)]
    cur = [[-1] * MAX for _ in range(n + 1)]
    prev[0][0] = 0
    ans = 0

    for i in range(1, n + 1):
        for j in range(k + 1):
            for l in range(MAX):
                cur[j][l] = prev[j][l]
                if j > 0 and j - pw5[i - 1] >= 0:
                    cur[j][l] = max(cur[j][l], prev[j - 1][l - pw5[i - 1]] + pw2[i - 1])
                if j == k:
                    ans = max(ans, min(cur[j][l], l))
        cur, prev = prev, cur

    print(ans)

main()","def count_trailing_zeros(x):

    count = 0
    while x % 10 == 0:
        count += 1
        x //= 10
    return count

def max_roundness(n, k, arr):

    factors = []

    for number in arr:
        count_2 = 0
        count_5 = 0
        
        while number % 2 == 0:
            count_2 += 1
            number //= 2
        while number % 5 == 0:
            count_5 += 1
            number //= 5
        
        factors.append((count_2, count_5))

    factors.sort(key=lambda x: (x[0], x[1]))

    max_zeros = 0

    from itertools import combinations
    
    for combo in combinations(factors, k):
        total_2 = sum(x[0] for x in combo)
        total_5 = sum(x[1] for x in combo)

        max_zeros = max(max_zeros, min(total_2, total_5))
    
    return max_zeros

if __name__ == ""__main__"":
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))

    print(max_roundness(n, k, arr))"
2,A,Winner,PROGRAMMING,"['hashing', 'implementation']","The winner of the card game popular in Berland ""Berlogging"" is determined according to the following rules. If at the end of the game there is only one player with the maximum number of points, he is the winner. The situation becomes more difficult if the number of such players is more than one. During each round a player gains or loses a particular number of points. In the course of the game the number of points is registered in the line ""name score"", where name is a player's name, and score is the number of points gained in this round, which is an integer number. If score is negative, this means that the player has lost in the round. So, if two or more players have the maximum number of points (say, it equals to *m*) at the end of the game, than wins the one of them who scored at least *m* points first. Initially each player has 0 points. It's guaranteed that at the end of the game at least one player has a positive number of points.","The first line contains an integer number *n* (1<=<=≤<=<=*n*<=<=≤<=<=1000), *n* is the number of rounds played. Then follow *n* lines, containing the information about the rounds in ""name score"" format in chronological order, where name is a string of lower-case Latin letters with the length from 1 to 32, and score is an integer number between -1000 and 1000, inclusive.",Print the name of the winner.,"['3\nmike 3\nandrew 5\nmike 2\n', '3\nandrew 3\nandrew 2\nmike 5\n']","['andrew\n', 'andrew\n']",none,WRONG_ANSWER,"from math import inf

def solve(n, lines):
    members = {}
    now = 0
    for line in lines:
        line_sp = line.split()
        try:
            members[line_sp[0]] += int(line_sp[1]) - now
        except:
             members[line_sp[0]] = int(line_sp[1]) - now
        now += 1
    max = -inf
    max_mem = ''
    for k,v in members.items():
        if v > max:
            max = v
            max_mem = k
    return max_mem

if __name__ == '__main__':
    n = int(input())
    people = []
    for _ in range(n):
        people.append(input())
    print(solve(n, people))","def berlogging_winner(rounds):
    score_map = {}
    order_map = {}

    for round_info in rounds:
        name, score = round_info.split()
        score = int(score)

        if name not in score_map:
            score_map[name] = 0
            order_map[name] = []

        score_map[name] += score
        order_map[name].append(score_map[name])

    max_score = max(score_map.values())
    candidates = [name for name, score in score_map.items() if score == max_score]
    
    if len(candidates) == 1:
        return candidates[0]

    for cumulative_score in zip(*[order_map[name] for name in candidates]):
        for idx, score in enumerate(cumulative_score):
            if score >= max_score:
                return candidates[idx]

inputs = [['3\nmike 3\nandrew 5\nmike 2\n'], ['3\nandrew 3\nandrew 2\nmike 5\n']]
outputs = []
for input_data in inputs:
    n = int(input_data[0].strip())
    rounds = input_data[1:n + 1]
    winner = berlogging_winner(rounds)
    outputs.append(winner + '\n')

print(outputs)"
755,A,PolandBall and Hypothesis,PROGRAMMING,"['brute force', 'graphs', 'math', 'number theory']","PolandBall is a young, clever Ball. He is interested in prime numbers. He has stated a following hypothesis: ""There exists such a positive integer *n* that for each positive integer *m* number *n*·*m*<=+<=1 is a prime number"".

Unfortunately, PolandBall is not experienced yet and doesn't know that his hypothesis is incorrect. Could you prove it wrong? Write a program that finds a counterexample for any *n*.",The only number in the input is *n* (1<=≤<=*n*<=≤<=1000) — number from the PolandBall's hypothesis.,Output such *m* that *n*·*m*<=+<=1 is not a prime number. Your answer will be considered correct if you output any suitable *m* such that 1<=≤<=*m*<=≤<=103. It is guaranteed the the answer exists.,"['3\n', '4\n']","['1', '2']","A prime number (or a prime) is a natural number greater than 1 that has no positive divisors other than 1 and itself.

For the first sample testcase, 3·1 + 1 = 4. We can output 1.

In the second sample testcase, 4·1 + 1 = 5. We cannot output 1 because 5 is prime. However, *m* = 2 is okay since 4·2 + 1 = 9, which is not a prime number.",RUNTIME_ERROR,"def primo(a):
    for j in range(0, a):
        if a%j == 0:
            return False
    return True

n = int(input())

if n%2 == 1:
    print(""1"")
else:
    for i in 1000:
        a = (n*i)+1
        vf = primo(a)
        if vf == False:
            print(i)
            break","def is_prime(num):
    """"""Check if a number is prime.""""""
    if num <= 1:
        return False
    for i in range(2, int(num ** 0.5) + 1):
        if num % i == 0:
            return False
    return True

def find_counterexample(n):
    """"""Find an integer m such that n * m + 1 is not a prime number.""""""
    for m in range(1, 1001):
        if not is_prime(n * m + 1):
            return m
    return None

n = int(input().strip())

print(find_counterexample(n))"
322,A,Ciel and Dancing,PROGRAMMING,['greedy'],"Fox Ciel and her friends are in a dancing room. There are *n* boys and *m* girls here, and they never danced before. There will be some songs, during each song, there must be exactly one boy and one girl are dancing. Besides, there is a special rule:
 -  either the boy in the dancing pair must dance for the first time (so, he didn't dance with anyone before); -  or the girl in the dancing pair must dance for the first time. 
Help Fox Ciel to make a schedule that they can dance as many songs as possible.","The first line contains two integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=100) — the number of boys and girls in the dancing room.","In the first line print *k* — the number of songs during which they can dance. Then in the following *k* lines, print the indexes of boys and girls dancing during songs chronologically. You can assume that the boys are indexed from 1 to *n*, and the girls are indexed from 1 to *m*.","['2 1\n', '2 2\n']","['2\n1 1\n2 1\n', '3\n1 1\n1 2\n2 2\n']","In test case 1, there are 2 boys and 1 girl. We can have 2 dances: the 1st boy and 1st girl (during the first song), the 2nd boy and 1st girl (during the second song).

And in test case 2, we have 2 boys with 2 girls, the answer is 3.",WRONG_ANSWER,"def solve(n,m):
  max_val = max(n,m)
  min_val = min(n,m)
  count = max_val+min_val-1
  print(count)
  for i in range(1,max_val+1):
    print(i,1)
  for j in range(2,min_val+1):
    print(1,j)
  

def main() :

  arr = list(map(int, input().split(' ')))

  solve(*arr)
main()","def generate_dance_schedule(n, m):
    schedule = []

    for boy in range(1, n + 1):
        schedule.append((boy, 1))

    for girl in range(2, m + 1):
        schedule.append((1, girl))
    
    return schedule

input_data = input().strip().split('\n')
output_data = []

for line in input_data:
    n, m = map(int, line.split())
    schedule = generate_dance_schedule(n, m)

    output_data.append(str(len(schedule)))
    for boy, girl in schedule:
        output_data.append(f""{boy} {girl}"")

print('\n'.join(output_data))"
169,A,Chores,PROGRAMMING,['sortings'],"Petya and Vasya are brothers. Today is a special day for them as their parents left them home alone and commissioned them to do *n* chores. Each chore is characterized by a single parameter — its complexity. The complexity of the *i*-th chore equals *h**i*.

As Petya is older, he wants to take the chores with complexity larger than some value *x* (*h**i*<=&gt;<=*x*) to leave to Vasya the chores with complexity less than or equal to *x* (*h**i*<=≤<=*x*). The brothers have already decided that Petya will do exactly *a* chores and Vasya will do exactly *b* chores (*a*<=+<=*b*<==<=*n*).

In how many ways can they choose an integer *x* so that Petya got exactly *a* chores and Vasya got exactly *b* chores?","The first input line contains three integers *n*,<=*a* and *b* (2<=≤<=*n*<=≤<=2000; *a*,<=*b*<=≥<=1; *a*<=+<=*b*<==<=*n*) — the total number of chores, the number of Petya's chores and the number of Vasya's chores.

The next line contains a sequence of integers *h*1,<=*h*2,<=...,<=*h**n* (1<=≤<=*h**i*<=≤<=109), *h**i* is the complexity of the *i*-th chore. The numbers in the given sequence are not necessarily different.

All numbers on the lines are separated by single spaces.","Print the required number of ways to choose an integer value of *x*. If there are no such ways, print 0.","['5 2 3\n6 2 3 100 1\n', '7 3 4\n1 1 9 1 1 1 1\n']","['3\n', '0\n']","In the first sample the possible values of *x* are 3, 4 or 5.

In the second sample it is impossible to find such *x*, that Petya got 3 chores and Vasya got 4.",MEMORY_LIMIT_EXCEEDED,"def findX(list_chores, a, b):
  first = list_chores[b -1]
  second = list_chores[-a]
  result = []
  for i in range(first, second):
    result.append(i)
  return len(result)
  

n, a, b = list(map(int, input().split()))

list_chores =  list(map(int, input().split()))
list_chores.sort()

print(findX(list_chores, a, b))","def count_ways(n, a, b, h):

    h.sort()

    count = 0

    for i in range(n - 1):

        if (i + 1) == a and (n - (i + 1)) == b:
            count += 1

    return count

input_lines = input().splitlines()
n, a, b = map(int, input_lines[0].split())
h = list(map(int, input_lines[1].split()))

result = count_ways(n, a, b, h)

print(result)"
0,none,none,none,['none'],"There are *n* people and *k* keys on a straight line. Every person wants to get to the office which is located on the line as well. To do that, he needs to reach some point with a key, take the key and then go to the office. Once a key is taken by somebody, it couldn't be taken by anybody else.

You are to determine the minimum time needed for all *n* people to get to the office with keys. Assume that people move a unit distance per 1 second. If two people reach a key at the same time, only one of them can take the key. A person can pass through a point with a key without taking it.","The first line contains three integers *n*, *k* and *p* (1<=≤<=*n*<=≤<=1<=000, *n*<=≤<=*k*<=≤<=2<=000, 1<=≤<=*p*<=≤<=109) — the number of people, the number of keys and the office location.

The second line contains *n* distinct integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=109) — positions in which people are located initially. The positions are given in arbitrary order.

The third line contains *k* distinct integers *b*1,<=*b*2,<=...,<=*b**k* (1<=≤<=*b**j*<=≤<=109) — positions of the keys. The positions are given in arbitrary order.

Note that there can't be more than one person or more than one key in the same point. A person and a key can be located in the same point.",Print the minimum time (in seconds) needed for all *n* to reach the office with keys.,"['2 4 50\n20 100\n60 10 40 80\n', '1 2 10\n11\n15 7\n']","['50\n', '7\n']","In the first example the person located at point 20 should take the key located at point 40 and go with it to the office located at point 50. He spends 30 seconds. The person located at point 100 can take the key located at point 80 and go to the office with it. He spends 50 seconds. Thus, after 50 seconds everybody is in office with keys.",RUNTIME_ERROR,"*_, office = map(int, input().split())
people = list(map(int, input().split()))
keys = list(map(int, input().split()))

def solve(office, people, key):
    dists = []

    for i in range(len(people)):
        for keyidx in range(len(key)):
            dists.append((abs(people[i]-key)+abs(key-office), i, keyidx))

    dists.sort()
    visited = [0]*len(people)
    visited_key = [0]*len(key)

    time = 0
    for dist, i, keyidx in dists:
        if visited[i] or visited_key[keyidx]:
            continue
        visited[i] = True
        visited_key[keyidx] = True
        time = max(time, dist)

    return time

print(solve(office, people, keys))","def min_time_to_office(n, k, p, people, keys):
    import heapq

    tasks = []
    
    for person in people:
        for key in keys:

            time = abs(person - key) + abs(key - p)
            tasks.append(time)

    tasks.sort()

    return tasks[n - 1]

def main():
    import sys

    input_data = sys.stdin.read().splitlines()
    first_line = list(map(int, input_data[0].split()))
    n, k, p = first_line[0], first_line[1], first_line[2]
    
    people = list(map(int, input_data[1].split()))
    keys = list(map(int, input_data[2].split()))

    result = min_time_to_office(n, k, p, people, keys)

    print(result)

if __name__ == ""__main__"":
    main()"
899,C,Dividing the numbers,PROGRAMMING,"['constructive algorithms', 'graphs', 'math']","Petya has *n* integers: 1,<=2,<=3,<=...,<=*n*. He wants to split these integers in two non-empty groups in such a way that the absolute difference of sums of integers in each group is as small as possible. 

Help Petya to split the integers. Each of *n* integers should be exactly in one group.",The first line contains a single integer *n* (2<=≤<=*n*<=≤<=60<=000) — the number of integers Petya has.,"Print the smallest possible absolute difference in the first line.

In the second line print the size of the first group, followed by the integers in that group. You can print these integers in arbitrary order. If there are multiple answers, print any of them.","['4\n', '2\n']","['0\n2 1 4 \n', '1\n1 1 \n']","In the first example you have to put integers 1 and 4 in the first group, and 2 and 3 in the second. This way the sum in each group is 5, and the absolute difference is 0.

In the second example there are only two integers, and since both groups should be non-empty, you have to put one integer in the first group and one in the second. This way the absolute difference of sums of integers in each group is 1.",OK,"def solve():
	n = int(input())
	if n==1:
		print(1)
		print(1,1)
		return
	gsum = n*(n+1)//2
	tt = gsum
	gsum/=2
	t = gsum
	g1 = []
	for i in range(n,0,-1):
		if gsum-i>=0:
			gsum-=i
			g1.append(i)
	gsum = t-gsum
	ts = tt-gsum
	print(abs(int(ts-gsum)))
	print(len(g1),*g1)

t = 1
for i in range(t):
	solve()","def split_integers(n):

    total_sum = n * (n + 1) // 2

    min_diff = total_sum
    group1 = []
    group2 = []

    max_sum = total_sum // 2
    dp = [False] * (max_sum + 1)
    dp[0] = True

    for i in range(1, n + 1):
        for j in range(max_sum, i - 1, -1):
            if dp[j - i]:
                dp[j] = True

    for s in range(max_sum, -1, -1):
        if dp[s]:
            first_group_sum = s
            second_group_sum = total_sum - s
            min_diff = abs(first_group_sum - second_group_sum)
            break

    for i in range(n, 0, -1):
        if first_group_sum >= i and dp[first_group_sum - i]:
            group1.append(i)
            first_group_sum -= i
        else:
            group2.append(i)

    print(min_diff)
    print(len(group1), ' '.join(map(str, group1)))

n = int(input().strip())
split_integers(n)"
120,F,Spiders,PROGRAMMING,"['dp', 'greedy', 'trees']","One day mum asked Petya to sort his toys and get rid of some of them. Petya found a whole box of toy spiders. They were quite dear to him and the boy didn't want to throw them away. Petya conjured a cunning plan: he will glue all the spiders together and attach them to the ceiling. Besides, Petya knows that the lower the spiders will hang, the more mum is going to like it and then she won't throw his favourite toys away. Help Petya carry out the plan.

A spider consists of *k* beads tied together by *k*<=-<=1 threads. Each thread connects two different beads, at that any pair of beads that make up a spider is either directly connected by a thread, or is connected via some chain of threads and beads.

Petya may glue spiders together directly gluing their beads. The length of each thread equals 1. The sizes of the beads can be neglected. That's why we can consider that gluing spiders happens by identifying some of the beads (see the picture). Besides, the construction resulting from the gluing process should also represent a spider, that is, it should have the given features. 

After Petya glues all spiders together, he measures the length of the resulting toy. The distance between a pair of beads is identified as the total length of the threads that connect these two beads. The length of the resulting construction is the largest distance between all pairs of beads. Petya wants to make the spider whose length is as much as possible.

The picture two shows two spiders from the second sample. We can glue to the bead number 2 of the first spider the bead number 1 of the second spider. The threads in the spiders that form the sequence of threads of maximum lengths are highlighted on the picture.","The first input file line contains one integer *n* (1<=≤<=*n*<=≤<=100) — the number of spiders. Next *n* lines contain the descriptions of each spider: integer *n**i* (2<=≤<=*n**i*<=≤<=100) — the number of beads, then *n**i*<=-<=1 pairs of numbers denoting the numbers of the beads connected by threads. The beads that make up each spider are numbered from 1 to *n**i*.",Print a single number — the length of the required construction.,"['1\n3 1 2 2 3\n', '2\n3 1 2 1 3\n4 1 2 2 3 2 4\n', '2\n5 1 2 2 3 3 4 3 5\n7 3 4 1 2 2 4 4 6 2 7 6 5\n']","['2\n', '4\n', '7\n']",none,OK,"import math
import sys
from bisect import bisect_right, bisect_left, insort_right
from collections import Counter, defaultdict
from heapq import heappop, heappush
from itertools import accumulate
from sys import stdout

R = lambda: map(int, input().split())
sys.stdin = open('input.txt', 'r')
sys.stdout = open('output.txt', 'w')
def dfs(tree, curr, parent):
    fn, fd = curr, 0
    for ch in tree[curr]:
        if ch != parent:
            nn, dd = dfs(tree, ch, curr)
            if dd + 1 > fd:
                fn, fd = nn, dd + 1
    return fn, fd
res = 0
for t in range(int(input())):
    arr = list(map(int, input().split()))
    tree = [[] for i in range(arr[0] + 1)]
    for i in range(1, len(arr), 2):
        tree[arr[i]].append(arr[i + 1])
        tree[arr[i + 1]].append(arr[i])
    node = dfs(tree, 1, 1)[0]
    res += dfs(tree, node, node)[1]
print(res)","def bfs(graph, start):
    visited = set()
    queue = [(start, 0)]
    max_distance = 0

    while queue:
        node, dist = queue.pop(0)
        visited.add(node)
        max_distance = max(max_distance, dist)
        
        for neighbor in graph[node]:
            if neighbor not in visited:
                queue.append((neighbor, dist + 1))
    
    return max_distance

def max_spider_length(spiders):

    max_length = 0

    for spider in spiders:
        n_i = spider[0]
        edges = spider[1:]
        graph = {i: [] for i in range(1, n_i + 1)}

        for i in range(0, len(edges), 2):
            a, b = edges[i], edges[i + 1]
            graph[a].append(b)
            graph[b].append(a)

        for bead in range(1, n_i + 1):
            max_length = max(max_length, bfs(graph, bead))

    return max_length

if __name__ == ""__main__"":
    import sys
    input_data = sys.stdin.read().strip().splitlines()
    n = int(input_data[0])
    spiders = []

    idx = 1
    for _ in range(n):
        line = list(map(int, input_data[idx].split()))
        spiders.append(line)
        idx += 1

    result = max_spider_length(spiders)
    print(result)"
43,A,Football,PROGRAMMING,['strings'],"One day Vasya decided to have a look at the results of Berland 1910 Football Championship’s finals. Unfortunately he didn't find the overall score of the match; however, he got hold of a profound description of the match's process. On the whole there are *n* lines in that description each of which described one goal. Every goal was marked with the name of the team that had scored it. Help Vasya, learn the name of the team that won the finals. It is guaranteed that the match did not end in a tie.",The first line contains an integer *n* (1<=≤<=*n*<=≤<=100) — the number of lines in the description. Then follow *n* lines — for each goal the names of the teams that scored it. The names are non-empty lines consisting of uppercase Latin letters whose lengths do not exceed 10 symbols. It is guaranteed that the match did not end in a tie and the description contains no more than two different teams.,Print the name of the winning team. We remind you that in football the team that scores more goals is considered the winner.,"['1\nABC\n', '5\nA\nABA\nABA\nA\nA\n']","['ABC\n', 'A\n']",none,WRONG_ANSWER,"def main():
	n=int(input())
	d=dict()
	for i in range(n):
		a=input()
		if(a in d):
			d[a]+=1
		else:
			d[a]=1
	val=0
	for key,value in d.items():
		if(val<value):
			ans=key

	print(ans)

if __name__=='__main__':
	main()","def find_winner(goals):

    score = {}

    for goal in goals:
        if goal in score:
            score[goal] += 1
        else:
            score[goal] = 1

    winner = max(score, key=score.get)
    return winner

n = int(input().strip())

goals = [input().strip() for _ in range(n)]

print(find_winner(goals))"
372,A,Counting Kangaroos is Fun,PROGRAMMING,"['binary search', 'greedy', 'sortings', 'two pointers']","There are *n* kangaroos with pockets. Each kangaroo has a size (integer number). A kangaroo can go into another kangaroo's pocket if and only if the size of kangaroo who hold the kangaroo is at least twice as large as the size of kangaroo who is held.

Each kangaroo can hold at most one kangaroo, and the kangaroo who is held by another kangaroo cannot hold any kangaroos.

The kangaroo who is held by another kangaroo cannot be visible from outside. Please, find a plan of holding kangaroos with the minimal number of kangaroos who is visible.",The first line contains a single integer — *n* (1<=≤<=*n*<=≤<=5·105). Each of the next *n* lines contains an integer *s**i* — the size of the *i*-th kangaroo (1<=≤<=*s**i*<=≤<=105).,Output a single integer — the optimal number of visible kangaroos.,"['8\n2\n5\n7\n6\n9\n8\n4\n2\n', '8\n9\n1\n6\n2\n6\n5\n8\n3\n']","['5\n', '5\n']",none,RUNTIME_ERROR,"import math
import sys
import collections
import heapq
import itertools

def main():
    N = 100001
    a = [0] * (N * 5)
    vis = [False] * (N * 5)

    n = int(input())
    a = [int(x) for x in input().split()]

    vis = [False] * len(vis)

    a.sort()
    k, m = n - 1, 0
    for i in range(k - 1, -1, -1):
        if a[k] >= a[i] * 2:
            m += 1
            k -= 1

    if n % 2:
        if m > n // 2:
            print(n // 2 + 1)
        else:
            print(n - m)
    else:
        if m > n // 2:
            print(n // 2)
        else:
            print(n - m)

if __name__ == ""__main__"":
    main()","def minimal_visible_kangaroos(n, sizes):
    sizes.sort()
    visible_count = 0
    i = 0

    for j in range(n):
        if i < n and sizes[i] * 2 <= sizes[j]:
            i += 1
        visible_count += 1

    return visible_count

import sys

input = sys.stdin.read
data = input().strip().split('\n')
n = int(data[0].strip())
sizes = [int(data[i].strip()) for i in range(1, n + 1)]

result = minimal_visible_kangaroos(n, sizes)
print(result)"
4,A,Watermelon,PROGRAMMING,"['brute force', 'math']","One hot summer day Pete and his friend Billy decided to buy a watermelon. They chose the biggest and the ripest one, in their opinion. After that the watermelon was weighed, and the scales showed *w* kilos. They rushed home, dying of thirst, and decided to divide the berry, however they faced a hard problem.

Pete and Billy are great fans of even numbers, that's why they want to divide the watermelon in such a way that each of the two parts weighs even number of kilos, at the same time it is not obligatory that the parts are equal. The boys are extremely tired and want to start their meal as soon as possible, that's why you should help them and find out, if they can divide the watermelon in the way they want. For sure, each of them should get a part of positive weight.",The first (and the only) input line contains integer number *w* (1<=≤<=*w*<=≤<=100) — the weight of the watermelon bought by the boys.,"Print YES, if the boys can divide the watermelon into two parts, each of them weighing even number of kilos; and NO in the opposite case.",['8\n'],['YES\n'],"For example, the boys can divide the watermelon into two parts of 2 and 6 kilos respectively (another variant — two parts of 4 and 4 kilos).",OK,"def check(i):
    if i%2 == 0:
        return ""YES""
    else:
        return ""NO""
i=int(input())
if i>3:
    print(check(i))
else:
    print(""NO"")","def can_divide_watermelon(w):

    if w % 2 == 0 and w > 2:
        return ""YES""
    else:
        return ""NO""

w = int(input().strip())

print(can_divide_watermelon(w))"
300,A,Array,PROGRAMMING,"['brute force', 'constructive algorithms', 'implementation']","Vitaly has an array of *n* distinct integers. Vitaly wants to divide this array into three non-empty sets so as the following conditions hold: 
 1.  The product of all numbers in the first set is less than zero (<=&lt;<=0). 1.  The product of all numbers in the second set is greater than zero (<=&gt;<=0). 1.  The product of all numbers in the third set is equal to zero. 1.  Each number from the initial array must occur in exactly one set. 
Help Vitaly. Divide the given array.","The first line of the input contains integer *n* (3<=≤<=*n*<=≤<=100). The second line contains *n* space-separated distinct integers *a*1,<=*a*2,<=...,<=*a**n* (|*a**i*|<=≤<=103) — the array elements.","In the first line print integer *n*1 (*n*1<=&gt;<=0) — the number of elements in the first set. Then print *n*1 numbers — the elements that got to the first set.

In the next line print integer *n*2 (*n*2<=&gt;<=0) — the number of elements in the second set. Then print *n*2 numbers — the elements that got to the second set.

In the next line print integer *n*3 (*n*3<=&gt;<=0) — the number of elements in the third set. Then print *n*3 numbers — the elements that got to the third set.

The printed sets must meet the described conditions. It is guaranteed that the solution exists. If there are several solutions, you are allowed to print any of them.","['3\n-1 2 0\n', '4\n-1 -2 -3 0\n']","['1 -1\n1 2\n1 0\n', '1 -1\n2 -3 -2\n1 0\n']",none,WRONG_ANSWER,"def divide_array(n, arr):
    positive_nums = []
    negative_nums = []
    zero_nums = []

    for num in arr:
        if num < 0:
            negative_nums.append(num)
        elif num > 0:
            positive_nums.append(num)
        else:
            zero_nums.append(num)

    if len(negative_nums) % 2 == 0:
        set1 = [negative_nums.pop()]
    else:
        set1 = [negative_nums.pop(0)]

    print(len(set1), *set1)
    print(len(positive_nums), *positive_nums)
    print(len(negative_nums) + len(zero_nums), *(negative_nums + zero_nums))

n = int(input())
arr = list(map(int, input().split()))

divide_array(n, arr)","def divide_array(arr):
    negative = []
    positive = []
    zero = []

    for number in arr:
        if number < 0:
            negative.append(number)
        elif number > 0:
            positive.append(number)
        else:
            zero.append(number)

    first_set = []
    if negative:
        first_set.append(negative.pop())

    second_set = positive[:]

    if len(negative) >= 1 and len(first_set) == 1:

        if len(second_set) == 0 and len(negative) > 0:
            first_set.append(negative.pop())

    third_set = zero[:]

    while negative:
        second_set.append(negative.pop())

    print(len(first_set), *first_set)
    print(len(second_set), *second_set)
    print(len(third_set), *third_set)

n = int(input().strip())
arr = list(map(int, input().strip().split()))

divide_array(arr)"
895,B,XK Segments,PROGRAMMING,"['binary search', 'math', 'sortings', 'two pointers']","While Vasya finished eating his piece of pizza, the lesson has already started. For being late for the lesson, the teacher suggested Vasya to solve one interesting problem. Vasya has an array *a* and integer *x*. He should find the number of different ordered pairs of indexes (*i*,<=*j*) such that *a**i*<=≤<=*a**j* and there are exactly *k* integers *y* such that *a**i*<=≤<=*y*<=≤<=*a**j* and *y* is divisible by *x*.

In this problem it is meant that pair (*i*,<=*j*) is equal to (*j*,<=*i*) only if *i* is equal to *j*. For example pair (1,<=2) is not the same as (2,<=1).","The first line contains 3 integers *n*,<=*x*,<=*k* (1<=≤<=*n*<=≤<=105,<=1<=≤<=*x*<=≤<=109,<=0<=≤<=*k*<=≤<=109), where *n* is the size of the array *a* and *x* and *k* are numbers from the statement.

The second line contains *n* integers *a**i* (1<=≤<=*a**i*<=≤<=109) — the elements of the array *a*.",Print one integer — the answer to the problem.,"['4 2 1\n1 3 5 7\n', '4 2 0\n5 3 1 7\n', '5 3 1\n3 3 3 3 3\n']","['3\n', '4\n', '25\n']","In first sample there are only three suitable pairs of indexes — (1, 2), (2, 3), (3, 4).

In second sample there are four suitable pairs of indexes(1, 1), (2, 2), (3, 3), (4, 4).

In third sample every pair (*i*, *j*) is suitable, so the answer is 5 * 5 = 25.",WRONG_ANSWER,"n, x, k = map(int, input().split())
a = list(map(int, input().split()))
ans = 0
a.sort()
def upper_bound( key):
    left = -1
    right = len(a)
    while right > left + 1:
        middle = (left + right ) // 2
        if a[middle] > key + x * k:
            right = middle
        else:
            left = middle
    return right

def lower_bound(key):
    left = -1
    right = len(a)
    while right > left + 1:
        middle = (left + right ) // 2
        if a[middle] >= key + x * k or (x * k != 0 and a[middle] % (x * k) == 0):
            right = middle
        else:
            left = middle
    return right
    
for i in range(len(a)):

    ans += upper_bound(a[i]) - lower_bound(a[i])

print(ans)","def count_pairs(n, x, k, a):
    count = 0

    divisible_counts = []
    for num in a:
        divisible_counts.append(num // x)
    
    for i in range(n):
        for j in range(i, n):
            count_of_y = (divisible_counts[j] - (divisible_counts[i-1] if i > 0 else 0))
            if count_of_y == k:
                count += 1
                
    return count

n, x, k = map(int, input().split())
a = list(map(int, input().split()))

result = count_pairs(n, x, k, a)

print(result)"
713,C,Sonya and Problem Wihtout a Legend,PROGRAMMING,"['dp', 'sortings']","Sonya was unable to think of a story for this problem, so here comes the formal description.

You are given the array containing *n* positive integers. At one turn you can pick any element and increase or decrease it by 1. The goal is the make the array strictly increasing by making the minimum possible number of operations. You are allowed to change elements in any way, they can become negative or equal to 0.","The first line of the input contains a single integer *n* (1<=≤<=*n*<=≤<=3000) — the length of the array.

Next line contains *n* integer *a**i* (1<=≤<=*a**i*<=≤<=109).",Print the minimum number of operation required to make the array strictly increasing.,"['7\n2 1 5 11 5 9 11\n', '5\n5 4 3 2 1\n']","['9\n', '12\n']","In the first sample, the array is going to look as follows:

2 3 5 6 7 9 11

|2 - 2| + |1 - 3| + |5 - 5| + |11 - 6| + |5 - 7| + |9 - 9| + |11 - 11| = 9

And for the second sample:

1 2 3 4 5

|5 - 1| + |4 - 2| + |3 - 3| + |2 - 4| + |1 - 5| = 12",OK,"import sys
inp = sys.stdin.readline

n = int(inp())
a = [int(x) for x in inp().split()]

a = [x - i for i, x in enumerate(a)]

s = sorted(a)

M = [[0 for _ in a] for _ in a]
for i in range(n):
    for j in range(n):
        if i == 0:
            M[i][j] = abs(a[0] - s[j])
        elif j == 0:
            M[i][j] = M[i-1][0] + abs(a[i] - s[0])
        else:
            M[i][j] = min(M[i-1][j], M[i][j-1] - abs(a[i] - s[j-1]))+ abs(a[i] - s[j])

print(min(M[-1]))","def min_operations_to_increasing(n, a):

    operations = 0

    prev = float('-inf')
    
    for i in range(n):

        if a[i] <= prev:

            operations += prev + 1 - a[i]

            a[i] = prev + 1

        prev = a[i]
    
    return operations

n = int(input())
a = list(map(int, input().split()))

result = min_operations_to_increasing(n, a)

print(result)"
892,B,Wrath,PROGRAMMING,"['greedy', 'implementation', 'two pointers']","Hands that shed innocent blood!

There are *n* guilty people in a line, the *i*-th of them holds a claw with length *L**i*. The bell rings and every person kills some of people in front of him. All people kill others at the same time. Namely, the *i*-th person kills the *j*-th person if and only if *j*<=&lt;<=*i* and *j*<=≥<=*i*<=-<=*L**i*.

You are given lengths of the claws. You need to find the total number of alive people after the bell rings.","The first line contains one integer *n* (1<=≤<=*n*<=≤<=106) — the number of guilty people.

Second line contains *n* space-separated integers *L*1,<=*L*2,<=...,<=*L**n* (0<=≤<=*L**i*<=≤<=109), where *L**i* is the length of the *i*-th person's claw.",Print one integer — the total number of alive people after the bell rings.,"['4\n0 1 0 10\n', '2\n0 0\n', '10\n1 1 3 0 0 0 2 1 0 3\n']","['1\n', '2\n', '3\n']",In first sample the last person kills everyone in front of him.,TIME_LIMIT_EXCEEDED,"n = int(input())
l = [int(i) for i in input().split(' ')]
dead = []
for i in range(n-1, -1, -1):
    for j in range(i-1, -1, -1):
        if j in dead:
            continue
        if j + l[i] >= i:
            dead.append(j)
print(n - len(set(dead)))","def count_alive_people(n, claws):

    alive = [True] * n

    for i in range(n - 1, -1, -1):

        if alive[i]:

            kill_range = min(i - 1, i - claws[i])

            for j in range(kill_range, -1, -1):
                if alive[j]:
                    alive[j] = False

    return sum(alive)

if __name__ == ""__main__"":
    import sys
    input = sys.stdin.read
    data = input().splitlines()

    n = int(data[0])

    claws = list(map(int, data[1].split()))

    result = count_alive_people(n, claws)

    print(result)"
656,A,Da Vinci Powers,PROGRAMMING,['*special'],"The input contains a single integer *a* (0<=≤<=*a*<=≤<=35).

Output a single integer.",The input contains a single integer *a* (0<=≤<=*a*<=≤<=35).,Output a single integer.,"['3\n', '10\n']","['8\n', '1024\n']",none,OK,"import math
import sys
import collections
import bisect
import time
def get_ints():return map(int, sys.stdin.readline().strip().split())
def get_list():return list(map(int, sys.stdin.readline().strip().split()))
def get_string():return sys.stdin.readline().strip()
for t in range(1):
    n=int(input())
    arr=[1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8092, 16184, 32368, 64736, 129472, 258944, 517888, 1035776, 2071552, 4143104, 8286208, 16572416, 33144832, 66289664, 132579328, 265158656, 530317312, 1060634624, 2121269248, 4242538496, 8485076992, 16970153984, 33940307968]
    print(arr[n])","a = int(input().strip())

result = 2 ** a

print(result)"
205,A,Little Elephant and Rozdil,PROGRAMMING,"['brute force', 'implementation']","The Little Elephant loves Ukraine very much. Most of all he loves town Rozdol (ukr. ""Rozdil"").

However, Rozdil is dangerous to settle, so the Little Elephant wants to go to some other town. The Little Elephant doesn't like to spend much time on travelling, so for his journey he will choose a town that needs minimum time to travel to. If there are multiple such cities, then the Little Elephant won't go anywhere.

For each town except for Rozdil you know the time needed to travel to this town. Find the town the Little Elephant will go to or print ""Still Rozdil"", if he stays in Rozdil.","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=105) — the number of cities. The next line contains *n* integers, separated by single spaces: the *i*-th integer represents the time needed to go from town Rozdil to the *i*-th town. The time values are positive integers, not exceeding 109.

You can consider the cities numbered from 1 to *n*, inclusive. Rozdil is not among the numbered cities.","Print the answer on a single line — the number of the town the Little Elephant will go to. If there are multiple cities with minimum travel time, print ""Still Rozdil"" (without the quotes).","['2\n7 4\n', '7\n7 4 47 100 4 9 12\n']","['2\n', 'Still Rozdil\n']","In the first sample there are only two cities where the Little Elephant can go. The travel time for the first town equals 7, to the second one — 4. The town which is closest to Rodzil (the only one) is the second one, so the answer is 2.

In the second sample the closest cities are cities two and five, the travelling time to both of them equals 4, so the answer is ""Still Rozdil"".",OK,"def main():
    num_towns = int(input())
    time_per_town = input().split()
    minimum = int(time_per_town[0])
    for i in range(len(time_per_town)):
        time_per_town[i] = int(time_per_town[i])
        if time_per_town[i] < minimum:
            minimum = time_per_town[i]
    count = 0
    index = 0
    for i in range(len(time_per_town)):
        if time_per_town[i] == minimum:
            count += 1
            index = i
    if count == 1:
        print(index + 1)
    else:
        print(""Still Rozdil"")
main()","n = int(input())

travel_times = list(map(int, input().split()))

min_time = min(travel_times)
min_count = travel_times.count(min_time)

if min_count > 1:
    print(""Still Rozdil"")
else:

    min_index = travel_times.index(min_time) + 1
    print(min_index)"
552,D,Vanya and Triangles,PROGRAMMING,"['brute force', 'combinatorics', 'data structures', 'geometry', 'math', 'sortings']",Vanya got bored and he painted *n* distinct points on the plane. After that he connected all the points pairwise and saw that as a result many triangles were formed with vertices in the painted points. He asks you to count the number of the formed triangles with the non-zero area.,"The first line contains integer *n* (1<=≤<=*n*<=≤<=2000) — the number of the points painted on the plane. 

Next *n* lines contain two integers each *x**i*,<=*y**i* (<=-<=100<=≤<=*x**i*,<=*y**i*<=≤<=100) — the coordinates of the *i*-th point. It is guaranteed that no two given points coincide.",In the first line print an integer — the number of triangles with the non-zero area among the painted points.,"['4\n0 0\n1 1\n2 0\n2 2\n', '3\n0 0\n1 1\n2 0\n', '1\n1 1\n']","['3\n', '1\n', '0\n']","Note to the first sample test. There are 3 triangles formed: (0, 0) - (1, 1) - (2, 0); (0, 0) - (2, 2) - (2, 0); (1, 1) - (2, 2) - (2, 0).

Note to the second sample test. There is 1 triangle formed: (0, 0) - (1, 1) - (2, 0).

Note to the third sample test. A single point doesn't form a single triangle.",TIME_LIMIT_EXCEEDED,"import math
import random

n = int(input())

def equa(a, b):
    if a[0] == b[0]:
        return math.inf, a[0]
    return (math.floor(1000000000*(b[1] - a[1]) / (b[0] - a[0])))/1000000000, math.floor(1000000000*(a[1] - a[0] * ((b[1] - a[1]) / (b[0] - a[0]))))

pontos = [[int(x) for x in input().split()] for _ in range(n)]

def main(n, pontos):
    pares = dict()

    for pri in range(n):
        for seg in range(pri+1, n):
            if equa(pontos[pri], pontos[seg]) in pares.keys():
                pares[equa(pontos[pri], pontos[seg])] += 1
            else:
                pares[equa(pontos[pri], pontos[seg])] = 1

    ans = n*(n-1)*(n-2)/6

    for resposta in pares.keys():

        resposta = (-1 + math.sqrt(1 + 8 * pares[resposta]))/2 + 1

        if resposta >= 3:

            ans -= resposta*(resposta-1)*(resposta-2)/6

    return(int(ans))

def slow(n, pontos):
    ans = 0
    for prim in range(n):
        for seg in range(prim + 1, n):
            for terc in range(seg + 1, n):
                if equa(pontos[prim], pontos[seg]) != equa(pontos[terc], pontos[seg]):
                    ans += 1
    return ans

print(main(n, pontos))","def count_non_zero_area_triangles(n, points):

    count = 0

    for i in range(n):
        for j in range(i + 1, n):
            for k in range(j + 1, n):

                area = (points[i][0] * (points[j][1] - points[k][1]) +
                        points[j][0] * (points[k][1] - points[i][1]) +
                        points[k][0] * (points[i][1] - points[j][1]))

                if area != 0:
                    count += 1
    
    return count

n = int(input())
points = [tuple(map(int, input().split())) for _ in range(n)]

result = count_non_zero_area_triangles(n, points)

print(result)"
198,B,Jumping on Walls,PROGRAMMING,['shortest paths'],"Vasya plays a computer game with ninjas. At this stage Vasya's ninja should get out of a deep canyon.

The canyon consists of two vertical parallel walls, their height is *n* meters. Let's imagine that we split these walls into 1 meter-long areas and number them with positive integers from 1 to *n* from bottom to top. Some areas are safe and the ninja can climb them. Others are spiky and ninja can't be there. Let's call such areas dangerous.

Initially the ninja is on the lower area of the left wall. He can use each second to perform one of the following actions: 
 -  climb one area up; -  climb one area down; -  jump to the opposite wall. That gets the ninja to the area that is exactly *k* meters higher than the area he jumped from. More formally, if before the jump the ninja is located at area *x* of one wall, then after the jump he is located at area *x*<=+<=*k* of the other wall. 
If at some point of time the ninja tries to get to an area with a number larger than *n*, then we can assume that the ninja got out of the canyon.

The canyon gets flooded and each second the water level raises one meter. Initially the water level is at the lower border of the first area. Ninja cannot be on the area covered by water. We can assume that the ninja and the water ""move in turns"" — first the ninja performs some action, then the water raises for one meter, then the ninja performs one more action and so on.

The level is considered completed if the ninja manages to get out of the canyon.

After several failed attempts Vasya started to doubt whether it is possible to complete the level at all. Help him answer the question.","The first line contains two integers *n* and *k* (1<=≤<=*n*,<=*k*<=≤<=105) — the height of the canyon and the height of ninja's jump, correspondingly.

The second line contains the description of the left wall — a string with the length of *n* characters. The *i*-th character represents the state of the *i*-th wall area: character ""X"" represents a dangerous area and character ""-"" represents a safe area.

The third line describes the right wall in the same format.

It is guaranteed that the first area of the left wall is not dangerous.","Print ""YES"" (without the quotes) if the ninja can get out from the canyon, otherwise, print ""NO"" (without the quotes).","['7 3\n---X--X\n-X--XX-\n', '6 2\n--X-X-\nX--XX-\n']","['YES\n', 'NO\n']","In the first sample the ninja should first jump to the right wall, then go one meter down along the right wall, then jump to the left wall. The next jump can get the ninja from the canyon. 

In the second sample there's no way the ninja can get out of the canyon.",IDLENESS_LIMIT_EXCEEDED,"from queue import Queue
import sys

input = sys.stdin.readline

amn = 10**5+5
mp = [[0] * amn for _ in range(5)]
hm = [[0] * amn for _ in range(5)]
valid = False
idx = [[False] * amn for _ in range(5)]

class pii:
    def __init__(self, f, s, hh):
        self.first = f
        self.second = s
        self.h = hh

def bfs():
    global valid
    global idx
    idx[0][1] = True
    q = Queue()
    q.put(pii(0, 1, 0))
    while not q.empty():
        x, y, h = q.get().first, q.get().second, q.get().h
        if y + k > n:
            valid = True
            return
        if y <= h:
            continue
        if not idx[x][y+1] and mp[x][y+1]:
            idx[x][y+1] = True
            q.put(pii(x, y+1, h+1))
        if not idx[x][y-1] and mp[x][y-1]:
            idx[x][y-1] = True
            q.put(pii(x, y-1, h+1))
        if not idx[x^1][y+k] and mp[x^1][y+k]:
            idx[x^1][y+k] = True
            q.put(pii(x^1, y+k, h+1))

if __name__ == ""__main__"":
    n, k = map(int, input().split())
    for i in range(2):
        s = input().strip()
        for j in range(1, n+1):
            if s[j-1] == '-':
                mp[i][j] = 1
            else:
                mp[i][j] = 0
    valid = False
    bfs()
    if valid:
        print(""YES"")
    else:
        print(""NO"")","def can_ninja_escape(n, k, left_wall, right_wall):

    left_pos = 0
    right_pos = -1

    water_level = 0

    while water_level < n:

        if left_pos >= n or right_pos >= n:
            return ""YES""

        left_can_climb_up = left_pos + 1 < n and left_wall[left_pos + 1] == '-' and left_pos + 1 > water_level
        left_can_climb_down = left_pos - 1 >= 0 and left_wall[left_pos - 1] == '-' and left_pos - 1 > water_level
        right_can_climb_up = right_pos + 1 < n and right_wall[right_pos + 1] == '-' and right_pos + 1 > water_level
        right_can_climb_down = right_pos - 1 >= 0 and right_wall[right_pos - 1] == '-' and right_pos - 1 > water_level

        if right_pos == -1:

            if left_pos + k < n and right_wall[left_pos + k] == '-' and left_pos + k > water_level:
                right_pos = left_pos + k
            elif left_can_climb_up:
                left_pos += 1
            elif left_can_climb_down:
                left_pos -= 1
            else:
                return ""NO""

        else:

            if right_pos - k >= 0 and left_wall[right_pos - k] == '-' and right_pos - k > water_level:
                left_pos = right_pos - k
            elif right_can_climb_up:
                right_pos += 1
            elif right_can_climb_down:
                right_pos -= 1
            else:
                return ""NO""

        water_level += 1

    return ""NO""

input_data = [
    ""7 3\n---X--X\n-X--XX-\n"",
    ""6 2\n--X-X-\nX--XX-\n""
]

for data in input_data:
    n, k, left_wall, right_wall = data.strip().split(""\n"")
    n, k = map(int, n.split())
    result = can_ninja_escape(n, k, left_wall, right_wall)
    print(result)"
424,B,Megacity,PROGRAMMING,"['binary search', 'greedy', 'implementation', 'sortings']","The administration of the Tomsk Region firmly believes that it's time to become a megacity (that is, get population of one million). Instead of improving the demographic situation, they decided to achieve its goal by expanding the boundaries of the city.

The city of Tomsk can be represented as point on the plane with coordinates (0; 0). The city is surrounded with *n* other locations, the *i*-th one has coordinates (*x**i*, *y**i*) with the population of *k**i* people. You can widen the city boundaries to a circle of radius *r*. In such case all locations inside the circle and on its border are included into the city.

Your goal is to write a program that will determine the minimum radius *r*, to which is necessary to expand the boundaries of Tomsk, so that it becomes a megacity.","The first line of the input contains two integers *n* and *s* (1<=≤<=*n*<=≤<=103; 1<=≤<=*s*<=&lt;<=106) — the number of locatons around Tomsk city and the population of the city. Then *n* lines follow. The *i*-th line contains three integers — the *x**i* and *y**i* coordinate values of the *i*-th location and the number *k**i* of people in it (1<=≤<=*k**i*<=&lt;<=106). Each coordinate is an integer and doesn't exceed 104 in its absolute value.

It is guaranteed that no two locations are at the same point and no location is at point (0; 0).","In the output, print ""-1"" (without the quotes), if Tomsk won't be able to become a megacity. Otherwise, in the first line print a single real number — the minimum radius of the circle that the city needs to expand to in order to become a megacity.

The answer is considered correct if the absolute or relative error don't exceed 10<=-<=6.","['4 999998\n1 1 1\n2 2 1\n3 3 1\n2 -2 1\n', '4 999998\n1 1 2\n2 2 1\n3 3 1\n2 -2 1\n', '2 1\n1 1 999997\n2 2 1\n']","['2.8284271\n', '1.4142136\n', '-1']",none,WRONG_ANSWER,"import math
def prsum(r):
    p = [0]
    for t in range(len(r)):
        p.append(int(r[t])+p[-1])
    return(p)

def sufsum(a):
    pr = [0]
    for t in range(1,len(a)+1):
        pr.append(int(a[-t])+pr[-1])
    return(pr)

def bl(x):
    L = 0
    R = x+1
    while R-L > 1:
        m = (L + R)//2
        if m**3 <= x:
            L = m
        else:
            R = m
    return L

def bll(a,b):
    L = 0
    R = len(a)+1
    while R-L>1:
        M = (R+L)//2
        if a[M]<b:
            L = M
        else:
            R = M
    return(L)

n, m = map(int, input().split())
a = []
g = []
for _ in range(n):
    k = []
    r = []
    b, c, d = map(int, input().split())
    g.append(math.sqrt(b**2+c**2))
    a.append(math.sqrt(b**2+c**2))
    a.append(d)
g = sorted(g)
for elem in g:
    for i in range(a.count(elem)):
        k.append(a[a.index(elem)+1])
        a.pop(a.index(elem))
    k = sorted(k)
    for el in k:
        r.append(el)
    k = []
r = prsum(r)
if r[-1]<10**6-m:
    print(-1)
else:
    print(g[bll(r,10**6-m)])","import math

def minimum_radius_to_megacity(n, s, locations):

    total_population = s

    distances = []

    for x, y, k in locations:
        distance = math.sqrt(x**2 + y**2)
        distances.append((distance, k))

    distances.sort()

    for distance, k in distances:
        total_population += k
        if total_population >= 1_000_000:
            return distance

    return -1

input_data = [
    (4, 999998, [(1, 1, 1), (2, 2, 1), (3, 3, 1), (2, -2, 1)]),
    (4, 999998, [(1, 1, 2), (2, 2, 1), (3, 3, 1), (2, -2, 1)]),
    (2, 1, [(1, 1, 999997), (2, 2, 1)]),
]

for n, s, locations in input_data:
    result = minimum_radius_to_megacity(n, s, locations)
    if result == -1:
        print(""-1"")
    else:
        print(f""{result:.7f}"")"
567,A,Lineland Mail,PROGRAMMING,"['greedy', 'implementation']","All cities of Lineland are located on the *Ox* coordinate axis. Thus, each city is associated with its position *x**i* — a coordinate on the *Ox* axis. No two cities are located at a single point.

Lineland residents love to send letters to each other. A person may send a letter only if the recipient lives in another city (because if they live in the same city, then it is easier to drop in).

Strange but true, the cost of sending the letter is exactly equal to the distance between the sender's city and the recipient's city.

For each city calculate two values ​​*min**i* and *max**i*, where *min**i* is the minimum cost of sending a letter from the *i*-th city to some other city, and *max**i* is the the maximum cost of sending a letter from the *i*-th city to some other city","The first line of the input contains integer *n* (2<=≤<=*n*<=≤<=105) — the number of cities in Lineland. The second line contains the sequence of *n* distinct integers *x*1,<=*x*2,<=...,<=*x**n* (<=-<=109<=≤<=*x**i*<=≤<=109), where *x**i* is the *x*-coordinate of the *i*-th city. All the *x**i*'s are distinct and follow in ascending order.","Print *n* lines, the *i*-th line must contain two integers *min**i*,<=*max**i*, separated by a space, where *min**i* is the minimum cost of sending a letter from the *i*-th city, and *max**i* is the maximum cost of sending a letter from the *i*-th city.","['4\n-5 -2 2 7\n', '2\n-1 1\n']","['3 12\n3 9\n4 7\n5 12\n', '2 2\n2 2\n']",none,RUNTIME_ERROR,"import io
import sys
import csv

from PyQt5 import uic
from PyQt5.QtWidgets import *

tmp = '''<?xml version=""1.0"" encoding=""UTF-8""?>
<ui version=""4.0"">
 <class>MainWindow</class>
 <widget class=""QMainWindow"" name=""MainWindow"">
  <property name=""geometry"">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>564</width>
    <height>455</height>
   </rect>
  </property>
  <property name=""windowTitle"">
   <string>Интерактивный чек</string>
  </property>
  <widget class=""QWidget"" name=""centralwidget"">
   <widget class=""QTableWidget"" name=""tableWidget"">
    <property name=""geometry"">
     <rect>
      <x>10</x>
      <y>10</y>
      <width>541</width>
      <height>391</height>
     </rect>
    </property>
    <property name=""sizePolicy"">
     <sizepolicy hsizetype=""Expanding"" vsizetype=""Expanding"">
      <horstretch>0</horstretch>
      <verstretch>0</verstretch>
     </sizepolicy>
    </property>
   </widget>
   <widget class=""QLineEdit"" name=""lineEdit"">
    <property name=""enabled"">
     <bool>false</bool>
    </property>
    <property name=""geometry"">
     <rect>
      <x>250</x>
      <y>410</y>
      <width>291</width>
      <height>22</height>
     </rect>
    </property>
   </widget>
   <widget class=""QLabel"" name=""label"">
    <property name=""geometry"">
     <rect>
      <x>200</x>
      <y>410</y>
      <width>91</width>
      <height>16</height>
     </rect>
    </property>
    <property name=""text"">
     <string>Итого :</string>
    </property>
   </widget>
  </widget>
 </widget>
 <resources/>
 <connections/>
</ui>
'''

class Window(QMainWindow):
    def __init__(self):
        super(Window, self).__init__()
        f = io.StringIO(tmp)
        uic.loadUi(f, self)
        self.load_table()

    def load_table(self):
        with open('price.csv', encoding='utf-8') as csvFile:
            reader = csv.reader(csvFile, delimiter=';', quotechar='""')
            title = next(reader)
            title += ['Количество']
            self.tableWidget.setColumnCount(len(title))
            self.tableWidget.setHorizontalHeaderLabels(title)
            self.tableWidget.setRowCount(0)

            for i, row in enumerate(reader):
                self.tableWidget.setRowCount(self.tableWidget.rowCount() + 1)
                for j, elem in enumerate(row):
                    if not j:
                        elem += ' ' * 70
                    self.tableWidget.setItem(i, j, QTableWidgetItem(elem))
                    self.tableWidget.setItem(i, j + 1, QTableWidgetItem('0'))
            self.tableWidget.resizeColumnsToContents()
            self.tableWidget.itemChanged.connect(self.operations)

    def operations(self):
        try:
            result = 0
            for i in range(self.tableWidget.rowCount()):
                value = self.tableWidget.item(i, 2).text()
                if int(value) >= 1:
                    result += int(value) * int(self.tableWidget.item(i, 1).text())
            self.lineEdit.setText(str(result))
        except:
            self.lineEdit.setText('Ошибка')

if __name__ == '__main__':
    app = QApplication(sys.argv)
    wnd = Window()
    wnd.show()
    sys.exit(app.exec())","def calculate_min_max(n, cities):
    results = []
    for i in range(n):

        if i == 0:
            min_cost = abs(cities[i] - cities[i + 1])
        elif i == n - 1:
            min_cost = abs(cities[i] - cities[i - 1])
        else:
            min_cost = min(abs(cities[i] - cities[i - 1]), abs(cities[i] - cities[i + 1]))

        max_cost = max(abs(cities[i] - cities[0]), abs(cities[i] - cities[n - 1]))

        results.append((min_cost, max_cost))
    
    return results

n = int(input().strip())
cities = list(map(int, input().strip().split()))

results = calculate_min_max(n, cities)

for min_cost, max_cost in results:
    print(min_cost, max_cost)"
255,A,Greg's Workout,PROGRAMMING,['implementation'],"Greg is a beginner bodybuilder. Today the gym coach gave him the training plan. All it had was *n* integers *a*1,<=*a*2,<=...,<=*a**n*. These numbers mean that Greg needs to do exactly *n* exercises today. Besides, Greg should repeat the *i*-th in order exercise *a**i* times.

Greg now only does three types of exercises: ""chest"" exercises, ""biceps"" exercises and ""back"" exercises. Besides, his training is cyclic, that is, the first exercise he does is a ""chest"" one, the second one is ""biceps"", the third one is ""back"", the fourth one is ""chest"", the fifth one is ""biceps"", and so on to the *n*-th exercise.

Now Greg wonders, which muscle will get the most exercise during his training. We know that the exercise Greg repeats the maximum number of times, trains the corresponding muscle the most. Help Greg, determine which muscle will get the most training.","The first line contains integer *n* (1<=≤<=*n*<=≤<=20). The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=25) — the number of times Greg repeats the exercises.","Print word ""chest"" (without the quotes), if the chest gets the most exercise, ""biceps"" (without the quotes), if the biceps gets the most exercise and print ""back"" (without the quotes) if the back gets the most exercise.

It is guaranteed that the input is such that the answer to the problem is unambiguous.","['2\n2 8\n', '3\n5 1 10\n', '7\n3 3 2 7 9 6 8\n']","['biceps\n', 'back\n', 'chest\n']","In the first sample Greg does 2 chest, 8 biceps and zero back exercises, so the biceps gets the most exercises.

In the second sample Greg does 5 chest, 1 biceps and 10 back exercises, so the back gets the most exercises.

In the third sample Greg does 18 chest, 12 biceps and 8 back exercises, so the chest gets the most exercise.",OK,"n = int(input())
s = [""c"", ""bi"", ""ba""]
d = {}
ans = [0, 0, 0]
for ind, i in enumerate(map(int, input().split())):
    d.setdefault(s[(ind % 3)], [0])[0] += i
for i in d:
    if i == 'c':
        ans[0] = d[i][0]
    elif i == 'bi':
        ans[1] = d[i][0]
    else:
        ans[2] = d[i][0]

if ans[0] > ans[1] and ans[0] > ans[2]:
    print(""chest"")
elif ans[1] > ans[0] and ans[1] > ans[2]:
    print(""biceps"")
else:
    print(""back"")","n = int(input())

a = list(map(int, input().split()))

chest = 0
biceps = 0
back = 0

for i in range(n):
    if i % 3 == 0:
        chest += a[i]
    elif i % 3 == 1:
        biceps += a[i]
    else:
        back += a[i]

if chest > biceps and chest > back:
    print(""chest"")
elif biceps > chest and biceps > back:
    print(""biceps"")
else:
    print(""back"")"
608,B,Hamming Distance Sum,PROGRAMMING,"['combinatorics', 'strings']","Genos needs your help. He was asked to solve the following programming problem by Saitama:

The length of some string *s* is denoted |*s*|. The Hamming distance between two strings *s* and *t* of equal length is defined as , where *s**i* is the *i*-th character of *s* and *t**i* is the *i*-th character of *t*. For example, the Hamming distance between string ""0011"" and string ""0110"" is |0<=-<=0|<=+<=|0<=-<=1|<=+<=|1<=-<=1|<=+<=|1<=-<=0|<==<=0<=+<=1<=+<=0<=+<=1<==<=2.

Given two binary strings *a* and *b*, find the sum of the Hamming distances between *a* and all contiguous substrings of *b* of length |*a*|.","The first line of the input contains binary string *a* (1<=≤<=|*a*|<=≤<=200<=000).

The second line of the input contains binary string *b* (|*a*|<=≤<=|*b*|<=≤<=200<=000).

Both strings are guaranteed to consist of characters '0' and '1' only.",Print a single integer — the sum of Hamming distances between *a* and all contiguous substrings of *b* of length |*a*|.,"['01\n00111\n', '0011\n0110\n']","['3\n', '2\n']","For the first sample case, there are four contiguous substrings of *b* of length |*a*|: ""00"", ""01"", ""11"", and ""11"". The distance between ""01"" and ""00"" is |0 - 0| + |1 - 0| = 1. The distance between ""01"" and ""01"" is |0 - 0| + |1 - 1| = 0. The distance between ""01"" and ""11"" is |0 - 1| + |1 - 1| = 1. Last distance counts twice, as there are two occurrences of string ""11"". The sum of these edit distances is 1 + 0 + 1 + 1 = 3.

The second sample case is described in the statement.",TIME_LIMIT_EXCEEDED,"def sub(a, b):
    sum = 0
    for i in range(len(a)):
        c = int(a[i])-int(b[i])
        if c < 0:
            c = -c
        sum += c
    return sum

pattern = input()
string = input()
sumt = 0

for i in range(len(string) - len(pattern) + 1):
    sumt += sub(pattern, string[i:i+len(pattern)])

print(sumt)","def hamming_distance(a, b):
    """"""Calculate the Hamming distance between two binary strings of equal length.""""""
    return sum(ch1 != ch2 for ch1, ch2 in zip(a, b))

def total_hamming_distance(a, b):
    """"""Calculate the total Hamming distance between a and all contiguous substrings of b of length |a|.""""""
    len_a = len(a)
    total_distance = 0

    for i in range(len(b) - len_a + 1):
        substring = b[i:i + len_a]
        total_distance += hamming_distance(a, substring)
    
    return total_distance

if __name__ == ""__main__"":

    a = input().strip()
    b = input().strip()

    result = total_hamming_distance(a, b)
    print(result)"
180,C,Letter,PROGRAMMING,['dp'],"Patrick has just finished writing a message to his sweetheart Stacey when he noticed that the message didn't look fancy. Patrick was nervous while writing the message, so some of the letters there were lowercase and some of them were uppercase.

Patrick believes that a message is fancy if any uppercase letter stands to the left of any lowercase one. In other words, this rule describes the strings where first go zero or more uppercase letters, and then — zero or more lowercase letters.

To make the message fancy, Patrick can erase some letter and add the same letter in the same place in the opposite case (that is, he can replace an uppercase letter with the lowercase one and vice versa). Patrick got interested in the following question: what minimum number of actions do we need to make a message fancy? Changing a letter's case in the message counts as one action. Patrick cannot perform any other actions.",The only line of the input contains a non-empty string consisting of uppercase and lowercase letters. The string's length does not exceed 105.,Print a single number — the least number of actions needed to make the message fancy.,"['PRuvetSTAaYA\n', 'OYPROSTIYAOPECHATALSYAPRIVETSTASYA\n', 'helloworld\n']","['5\n', '0\n', '0\n']",none,OK,"def min_count(q: str) -> int:
    w = len(q)
    lower = [0] * (w + 1)
    upper = [0] * (w + 1)
    for n in range(1, w + 1):
        lower[n] = lower[n - 1] + q[n - 1].islower()
        upper[n] = upper[n - 1] + q[n - 1].isupper()
    ans = float('inf')
    for n in range(w + 1):
        ans = min(ans, lower[n] + upper[w] - upper[n])
    return ans

a = input()
print(min_count(a))","def min_actions_to_fancy(message):

    lower_count = 0
    upper_count = 0

    for char in message:
        if char.islower():
            lower_count += 1
        else:
            upper_count += 1

    changes_needed = [0] * (len(message) + 1)

    for i in range(len(message) - 1, -1, -1):
        changes_needed[i] = changes_needed[i + 1] + (1 if message[i].islower() else 0)

    min_changes = float('inf')
    for i in range(len(message) + 1):

        changes = i - (lower_count - changes_needed[i]) + changes_needed[i]
        min_changes = min(min_changes, changes)

    return min_changes

import sys
input_strings = sys.stdin.read().strip().splitlines()

for msg in input_strings:
    result = min_actions_to_fancy(msg)
    print(result)"
794,A,Bank Robbery,PROGRAMMING,"['brute force', 'implementation']","A robber has attempted to rob a bank but failed to complete his task. However, he had managed to open all the safes.

Oleg the bank client loves money (who doesn't), and decides to take advantage of this failed robbery and steal some money from the safes. There are many safes arranged in a line, where the *i*-th safe from the left is called safe *i*. There are *n* banknotes left in all the safes in total. The *i*-th banknote is in safe *x**i*. Oleg is now at safe *a*. There are two security guards, one of which guards the safe *b* such that *b*<=&lt;<=*a*, i.e. the first guard is to the left of Oleg. The other guard guards the safe *c* so that *c*<=&gt;<=*a*, i.e. he is to the right of Oleg.

The two guards are very lazy, so they do not move. In every second, Oleg can either take all the banknotes from the current safe or move to any of the neighboring safes. However, he cannot visit any safe that is guarded by security guards at any time, becaues he might be charged for stealing. Determine the maximum amount of banknotes Oleg can gather.","The first line of input contains three space-separated integers, *a*, *b* and *c* (1<=≤<=*b*<=&lt;<=*a*<=&lt;<=*c*<=≤<=109), denoting the positions of Oleg, the first security guard and the second security guard, respectively.

The next line of input contains a single integer *n* (1<=≤<=*n*<=≤<=105), denoting the number of banknotes.

The next line of input contains *n* space-separated integers *x*1,<=*x*2,<=...,<=*x**n* (1<=≤<=*x**i*<=≤<=109), denoting that the *i*-th banknote is located in the *x**i*-th safe. Note that *x**i* are not guaranteed to be distinct.",Output a single integer: the maximum number of banknotes Oleg can take.,"['5 3 7\n8\n4 7 5 5 3 6 2 8\n', '6 5 7\n5\n1 5 7 92 3\n']","['4\n', '0\n']","In the first example Oleg can take the banknotes in positions 4, 5, 6 (note that there are 2 banknotes at position 5). Oleg can't take the banknotes in safes 7 and 8 because he can't run into the second security guard. Similarly, Oleg cannot take the banknotes at positions 3 and 2 because he can't run into the first security guard. Thus, he can take a maximum of 4 banknotes.

For the second sample, Oleg can't take any banknotes without bumping into any of the security guards.",TIME_LIMIT_EXCEEDED,"def solution(l1,v2,l3):
    oleg = l1[0]
    l1.remove(oleg)
    security1 = min(l1)
    security2 = max(l1)
    ans=0
    if oleg<security1:
        i=1
        while i<security1:
            for x in l3:
                if i==x:
                    ans+=1
            i+=1
    elif oleg>security1 and oleg<security2:
        i=security1+1
        while i<security2:
            for x in l3:
                if i==x:
                    ans+=1
            i+=1
    else:
        i=security2+1
        while i<v2:
            for x in l3:
                if i==x:
                    ans+=1
            i+=1
    return ans
def answer():
    l1 = [ int(x) for x in input().split() ]
    v2 = int(input())
    l3 = [ int(x) for x in input().split() ]
    print(solution(l1,v2,l3))
answer()","a, b, c = map(int, input().split())
n = int(input())
banknote_positions = list(map(int, input().split()))

left_limit = b + 1
right_limit = c - 1

max_banknotes = 0

for position in banknote_positions:
    if left_limit <= position <= right_limit:
        max_banknotes += 1

print(max_banknotes)"
997,A,Convert to Ones,PROGRAMMING,"['brute force', 'greedy', 'implementation', 'math']","You've got a string $a_1, a_2, \dots, a_n$, consisting of zeros and ones.

Let's call a sequence of consecutive elements $a_i, a_{i<=+<=1}, \ldots,<=a_j$ ($1\leq<=i\leq<=j\leq<=n$) a substring of string $a$. 

You can apply the following operations any number of times:
 -  Choose some substring of string $a$ (for example, you can choose entire string) and reverse it, paying $x$ coins for it (for example, «0101101» $\to$ «0111001»); -  Choose some substring of string $a$ (for example, you can choose entire string or just one symbol) and replace each symbol to the opposite one (zeros are replaced by ones, and ones — by zeros), paying $y$ coins for it (for example, «0101101» $\to$ «0110001»). 
You can apply these operations in any order. It is allowed to apply the operations multiple times to the same substring.

What is the minimum number of coins you need to spend to get a string consisting only of ones?","The first line of input contains integers $n$, $x$ and $y$ ($1<=\leq<=n<=\leq<=300\,000, 0 \leq x, y \leq 10^9$) — length of the string, cost of the first operation (substring reverse) and cost of the second operation (inverting all elements of substring).

The second line contains the string $a$ of length $n$, consisting of zeros and ones.","Print a single integer — the minimum total cost of operations you need to spend to get a string consisting only of ones. Print $0$, if you do not need to perform any operations.","['5 1 10\n01000\n', '5 10 1\n01000\n', '7 2 3\n1111111\n']","['11\n', '2\n', '0\n']","In the first sample, at first you need to reverse substring $[1 \dots 2]$, and then you need to invert substring $[2 \dots 5]$. 

Then the string was changed as follows:

«01000» $\to$ «10000» $\to$ «11111».

The total cost of operations is $1 + 10 = 11$.

In the second sample, at first you need to invert substring $[1 \dots 1]$, and then you need to invert substring $[3 \dots 5]$. 

Then the string was changed as follows:

«01000» $\to$ «11000» $\to$ «11111».

The overall cost is $1 + 1 = 2$.

In the third example, string already consists only of ones, so the answer is $0$.",OK,"import math
import sys
import queue

def solve():
    n, x, y = map(int, input().split())
    s = str(input())

    subsq = 1
    zeros = int(s[0] == ""0"")
    for i in range(1, n):
        if s[i] != s[i - 1]:
            subsq += 1
            if s[i] == ""0"":
                zeros += 1

    res = 0

    if subsq == 1:
        if s[0] == ""0"":
            res = y
        else:
            res = 0
    elif subsq == 2:
        res = y
    else:
        if s[0] == ""0"":
            res = ((subsq - 1) // 2 * x + y)
        else:
            if subsq == 3:
                res = (x + y)
            else:
                res = ((subsq - 2) // 2 * x + y)

    res = min(res, zeros * y)
    print(res)

if __name__ == '__main__':
    multi_test = 0

    if multi_test:
        t = int(input())
        for _ in range(t):
            solve()
    else:
        solve()","def min_cost_to_all_ones(n, x, y, a):

    segments = 0
    i = 0
    while i < n:
        if a[i] == '0':
            segments += 1

            while i < n and a[i] == '0':
                i += 1
        else:
            i += 1

    if segments == 0:
        return 0

    cost_invert_segments = segments * y

    cost_reverse_segments = x + (segments - 1) * y if segments > 1 else float('inf')

    return min(cost_invert_segments, cost_reverse_segments)

n, x, y = map(int, input().split())
a = input().strip()

result = min_cost_to_all_ones(n, x, y, a)
print(result)"
11,A,Increasing Sequence,PROGRAMMING,"['constructive algorithms', 'implementation', 'math']","A sequence *a*0,<=*a*1,<=...,<=*a**t*<=-<=1 is called increasing if *a**i*<=-<=1<=&lt;<=*a**i* for each *i*:<=0<=&lt;<=*i*<=&lt;<=*t*.

You are given a sequence *b*0,<=*b*1,<=...,<=*b**n*<=-<=1 and a positive integer *d*. In each move you may choose one element of the given sequence and add *d* to it. What is the least number of moves required to make the given sequence increasing?","The first line of the input contains two integer numbers *n* and *d* (2<=≤<=*n*<=≤<=2000,<=1<=≤<=*d*<=≤<=106). The second line contains space separated sequence *b*0,<=*b*1,<=...,<=*b**n*<=-<=1 (1<=≤<=*b**i*<=≤<=106).",Output the minimal number of moves needed to make the sequence increasing.,['4 2\n1 3 3 2\n'],['3\n'],none,COMPILATION_ERROR,"using namespace std;
/*
         _____                   _                   __  __                 ____
        / ___/____ _____  ____ _(_)___  ____ _   __  \ \/ /_  _________  __/ __/
        \__ \/ __ `/ __ \/ __ `/ / __ \/ __ \ | / /   \  / / / / ___/ / / / /_
       ___/ / /_/ / / / / /_/ / / / / / /_/ / |/ /    / / /_/ (__  ) /_/ / __/
 _____/____/\__,_/_/ /_/\__, /_/_/ /_/\____/|___/____/_/\__,_/____/\__,_/_/_____
/_____/                /____/                  /_____/                   /_____/
*/
long long i , n , t , k , p;
int main()
{
    FAST
    cin >> n >> k;
    long long a[n + 1] = {};
    for (i = 1 ; i <= n ; i ++)
    {
        cin >> a[i];
    }
    for (i = 2 ; i <= n ; i ++)
    {
        if (a[i] <= a[i - 1])
        {
            a[i] += (a[i - 1] - a[i] + k - 1) / k;
            t += (a[i - 1] - a[i] + k - 1) / k;
            t ++;
            a[i] ++;
        }
    }
    cout << t;
}","def min_moves_to_increasing_sequence(n, d, b):
    moves = 0

    for i in range(1, n):

        if b[i] <= b[i - 1]:

            diff = b[i - 1] - b[i] + 1

            moves_needed = (diff + d - 1) // d
            moves += moves_needed

            b[i] += moves_needed * d

    return moves

input_data = input().strip().split('\n')
n, d = map(int, input_data[0].split())
b = list(map(int, input_data[1].split()))

result = min_moves_to_increasing_sequence(n, d, b)
print(result)"
772,A,Voltage Keepsake,PROGRAMMING,"['binary search', 'math']","You have *n* devices that you want to use simultaneously.

The *i*-th device uses *a**i* units of power per second. This usage is continuous. That is, in λ seconds, the device will use λ·*a**i* units of power. The *i*-th device currently has *b**i* units of power stored. All devices can store an arbitrary amount of power.

You have a single charger that can plug to any single device. The charger will add *p* units of power per second to a device. This charging is continuous. That is, if you plug in a device for λ seconds, it will gain λ·*p* units of power. You can switch which device is charging at any arbitrary unit of time (including real numbers), and the time it takes to switch is negligible.

You are wondering, what is the maximum amount of time you can use the devices until one of them hits 0 units of power.

If you can use the devices indefinitely, print -1. Otherwise, print the maximum amount of time before any one device hits 0 power.","The first line contains two integers, *n* and *p* (1<=≤<=*n*<=≤<=100<=000, 1<=≤<=*p*<=≤<=109) — the number of devices and the power of the charger.

This is followed by *n* lines which contain two integers each. Line *i* contains the integers *a**i* and *b**i* (1<=≤<=*a**i*,<=*b**i*<=≤<=100<=000) — the power of the device and the amount of power stored in the device in the beginning.","If you can use the devices indefinitely, print -1. Otherwise, print the maximum amount of time before any one device hits 0 power.

Your answer will be considered correct if its absolute or relative error does not exceed 10<=-<=4.

Namely, let's assume that your answer is *a* and the answer of the jury is *b*. The checker program will consider your answer correct if .","['2 1\n2 2\n2 1000\n', '1 100\n1 1\n', '3 5\n4 3\n5 2\n6 1\n']","['2.0000000000', '-1\n', '0.5000000000']","In sample test 1, you can charge the first device for the entire time until it hits zero power. The second device has enough power to last this time without being charged.

In sample test 2, you can use the device indefinitely.

In sample test 3, we can charge the third device for 2 / 5 of a second, then switch to charge the second device for a 1 / 10 of a second.",WRONG_ANSWER,"def can_use_indefinitely(n, p, devices):
    low = 0.0
    high = float(""inf"")

    while high - low > 1e-6:
        mid = (low + high) / 2.0
        total_power_needed = 0

        for a, b in devices:
            power_needed = max(0, mid * a - b)
            total_power_needed += power_needed

        if total_power_needed > mid * p:
            high = mid
        else:
            low = mid

    if low == float(""inf""):
        return -1
    return low

n, p = map(int, input().split())
devices = []

for _ in range(n):
    a, b = map(int, input().split())
    devices.append((a, b))

result = can_use_indefinitely(n, p, devices)
print(""{:.9f}"".format(result))","def max_time_until_zero_power(n, p, devices):

    if p >= max(ai for ai, _ in devices):
        return -1

    max_time = float('inf')
    
    for ai, bi in devices:
        time_until_zero = bi / (ai - p)
        max_time = min(max_time, time_until_zero)

    return max_time

input_data = input().strip().split('\n')
n, p = map(int, input_data[0].split())
devices = [tuple(map(int, line.split())) for line in input_data[1:n + 1]]

result = max_time_until_zero_power(n, p, devices)

print(f'{result:.10f}')"
363,B,Fence,PROGRAMMING,"['brute force', 'dp']","There is a fence in front of Polycarpus's home. The fence consists of *n* planks of the same width which go one after another from left to right. The height of the *i*-th plank is *h**i* meters, distinct planks can have distinct heights.

Polycarpus has bought a posh piano and is thinking about how to get it into the house. In order to carry out his plan, he needs to take exactly *k* consecutive planks from the fence. Higher planks are harder to tear off the fence, so Polycarpus wants to find such *k* consecutive planks that the sum of their heights is minimal possible.

Write the program that finds the indexes of *k* consecutive planks with minimal total height. Pay attention, the fence is not around Polycarpus's home, it is in front of home (in other words, the fence isn't cyclic).","The first line of the input contains integers *n* and *k* (1<=≤<=*n*<=≤<=1.5·105,<=1<=≤<=*k*<=≤<=*n*) — the number of planks in the fence and the width of the hole for the piano. The second line contains the sequence of integers *h*1,<=*h*2,<=...,<=*h**n* (1<=≤<=*h**i*<=≤<=100), where *h**i* is the height of the *i*-th plank of the fence.","Print such integer *j* that the sum of the heights of planks *j*, *j*<=+<=1, ..., *j*<=+<=*k*<=-<=1 is the minimum possible. If there are multiple such *j*'s, print any of them.",['7 3\n1 2 6 1 1 7 1\n'],['3\n'],"In the sample, your task is to find three consecutive planks with the minimum sum of heights. In the given case three planks with indexes 3, 4 and 5 have the required attribute, their total height is 8.",RUNTIME_ERROR,"def read_numbers() -> list[int]:
    return [int(n) for n in input().split()]

n, k = read_numbers()
j = read_numbers()

new_sum = None
new_index = None

for a in range(n - k + 1):
    s = 0
    for b in range(k):
        s += j[a + b]
    if new_sum is None or s < new_sum:
        new_sum = s
        new_index = a +1
print(new_index)","n, k = map(int, input().split())
heights = list(map(int, input().split()))

min_sum = float('inf')
min_index = 0

for i in range(n - k + 1):
    current_sum = sum(heights[i:i + k])
    if current_sum < min_sum:
        min_sum = current_sum
        min_index = i + 1

print(min_index)"
834,B,The Festive Evening,PROGRAMMING,"['data structures', 'implementation']","It's the end of July – the time when a festive evening is held at Jelly Castle! Guests from all over the kingdom gather here to discuss new trends in the world of confectionery. Yet some of the things discussed here are not supposed to be disclosed to the general public: the information can cause discord in the kingdom of Sweetland in case it turns out to reach the wrong hands. So it's a necessity to not let any uninvited guests in.

There are 26 entrances in Jelly Castle, enumerated with uppercase English letters from A to Z. Because of security measures, each guest is known to be assigned an entrance he should enter the castle through. The door of each entrance is opened right before the first guest's arrival and closed right after the arrival of the last guest that should enter the castle through this entrance. No two guests can enter the castle simultaneously.

For an entrance to be protected from possible intrusion, a candy guard should be assigned to it. There are *k* such guards in the castle, so if there are more than *k* opened doors, one of them is going to be left unguarded! Notice that a guard can't leave his post until the door he is assigned to is closed.

Slastyona had a suspicion that there could be uninvited guests at the evening. She knows the order in which the invited guests entered the castle, and wants you to help her check whether there was a moment when more than *k* doors were opened.","Two integers are given in the first string: the number of guests *n* and the number of guards *k* (1<=≤<=*n*<=≤<=106, 1<=≤<=*k*<=≤<=26).

In the second string, *n* uppercase English letters *s*1*s*2... *s**n* are given, where *s**i* is the entrance used by the *i*-th guest.","Output «YES» if at least one door was unguarded during some time, and «NO» otherwise.

You can output each letter in arbitrary case (upper or lower).","['5 1\nAABBB\n', '5 1\nABABB\n']","['NO\n', 'YES\n']","In the first sample case, the door A is opened right before the first guest's arrival and closed when the second guest enters the castle. The door B is opened right before the arrival of the third guest, and closed after the fifth one arrives. One guard can handle both doors, as the first one is closed before the second one is opened.

In the second sample case, the door B is opened before the second guest's arrival, but the only guard can't leave the door A unattended, as there is still one more guest that should enter the castle through this door.",WRONG_ANSWER,"def ri(): return int(input())
def rli(): return list(map(int, input().split()))
def rls(): return list(input())
def pli(a): return """".join(list(map(str, a)))
def plis(a): return "" "".join(list(map(str, a)))

alf = ""A B C D E F G H I J K L M N O P Q R S T U V W X Y Z"".split()

n, guard = rli()
s = rls()
check = [0 for i in range(n)]
for k in range(26):
    for j in range(n):
        if(s[j] == alf[k]):
            check[j] += 1
            break
    for j in range(1, n+1):
        if(s[-j] == alf[k]):
            check[-j] -= 1
            break

for i in range(1, n):
    check[i] = check[i-1] + check[i]
print(""YES"" if max(check) > guard else ""NO"")","def can_guard_all_doors(n, k, entrances):

    opened_doors = set()

    last_position = {}

    for i, entrance in enumerate(entrances):
        last_position[entrance] = i

    for i, entrance in enumerate(entrances):

        if entrance not in opened_doors:
            opened_doors.add(entrance)

        if len(opened_doors) > k:
            return ""YES""

        if i == last_position[entrance]:
            opened_doors.remove(entrance)
    
    return ""NO""

demo_inputs = ['5 1\nAABBB\n', '5 1\nABABB\n']
results = []

for demo_input in demo_inputs:
    n, k_and_entrances = demo_input.split('\n')[:2]
    n, k = map(int, n.split())
    entrances = k_and_entrances.strip()

    result = can_guard_all_doors(n, k, entrances)
    results.append(result)

for res in results:
    print(res)"
776,C,Molly's Chemicals,PROGRAMMING,"['binary search', 'brute force', 'data structures', 'implementation', 'math']","Molly Hooper has *n* different kinds of chemicals arranged in a line. Each of the chemicals has an affection value, The *i*-th of them has affection value *a**i*.

Molly wants Sherlock to fall in love with her. She intends to do this by mixing a contiguous segment of chemicals together to make a love potion with total affection value as a non-negative integer power of *k*. Total affection value of a continuous segment of chemicals is the sum of affection values of each chemical in that segment.

Help her to do so in finding the total number of such segments.","The first line of input contains two integers, *n* and *k*, the number of chemicals and the number, such that the total affection value is a non-negative power of this number *k*. (1<=≤<=*n*<=≤<=105, 1<=≤<=|*k*|<=≤<=10).

Next line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (<=-<=109<=≤<=*a**i*<=≤<=109) — affection values of chemicals.",Output a single integer — the number of valid segments.,"['4 2\n2 2 2 2\n', '4 -3\n3 -6 -3 12\n']","['8\n', '3\n']","Do keep in mind that *k*<sup class=""upper-index"">0</sup> = 1.

In the first sample, Molly can get following different affection values: 
 - 2: segments [1, 1], [2, 2], [3, 3], [4, 4]; - 4: segments [1, 2], [2, 3], [3, 4]; - 6: segments [1, 3], [2, 4]; - 8: segments [1, 4]. 
Out of these, 2, 4 and 8 are powers of *k* = 2. Therefore, the answer is 8.

In the second sample, Molly can choose segments [1, 2], [3, 3], [3, 4].",TIME_LIMIT_EXCEEDED,"def solve(v, a):
    mp = {}
    mp[0]=1
    tmp=0
    ans=0
    for i in v:
        tmp+=i
        if a==1:
            if tmp-1 in mp:
                ans+=mp[tmp-1]
            else:
                ans+=0
                mp[tmp-1]=0
        elif a==-1:
            if tmp-1 in mp:
                ans+=mp[tmp-1]
            else:
                ans+=0
                mp[tmp-1]=0
            if tmp+1 in mp:
                ans+=mp[tmp+1]
            else:
                ans+=0
                mp[tmp+1]=0
        else:
            cur=1
            while True:
                if tmp-cur in mp:
                    ans+=mp[tmp-cur]
                else:
                    mp[tmp-cur]=0
                cur*=a
                if cur>10**15 or -cur>10**15:
                    break
        if tmp in mp:
            mp[tmp]+=1
        else:
            mp[tmp]=1
    return ans

n,a=map(int,input().split())
v=list(map(int,input().split()))
print(solve(v,a))","def count_segments(n, k, affection_values):

    powers_of_k = set()
    current_power = 1

    if k == 1:
        powers_of_k.add(1)
    else:
        while abs(current_power) <= n * 10**9:
            powers_of_k.add(current_power)
            current_power *= k

    count = 0
    prefix_sum = 0
    prefix_counts = {0: 1}

    for value in affection_values:
        prefix_sum += value

        for power in powers_of_k:
            if (prefix_sum - power) in prefix_counts:
                count += prefix_counts[prefix_sum - power]

        if prefix_sum in prefix_counts:
            prefix_counts[prefix_sum] += 1
        else:
            prefix_counts[prefix_sum] = 1
            
    return count

if __name__ == ""__main__"":
    import sys
    input_data = sys.stdin.read().strip().splitlines()
    
    n, k = map(int, input_data[0].split())
    affection_values = list(map(int, input_data[1].split()))

    result = count_segments(n, k, affection_values)

    print(result)"
102,B,Sum of Digits,PROGRAMMING,['implementation'],"Having watched the last Harry Potter film, little Gerald also decided to practice magic. He found in his father's magical book a spell that turns any number in the sum of its digits. At the moment Gerald learned that, he came across a number *n*. How many times can Gerald put a spell on it until the number becomes one-digit?",The first line contains the only integer *n* (0<=≤<=*n*<=≤<=10100000). It is guaranteed that *n* doesn't contain any leading zeroes.,Print the number of times a number can be replaced by the sum of its digits until it only contains one digit.,"['0\n', '10\n', '991\n']","['0\n', '1\n', '3\n']","In the first sample the number already is one-digit — Herald can't cast a spell.

The second test contains number 10. After one casting of a spell it becomes 1, and here the process is completed. Thus, Gerald can only cast the spell once.

The third test contains number 991. As one casts a spell the following transformations take place: 991 → 19 → 10 → 1. After three transformations the number becomes one-digit.",TIME_LIMIT_EXCEEDED,"def sumdigits(n):
    s = 0
    while(n):
        s += n%10
        n = n//10
    return s

n = int(input())
c = 0
while(n//10):
    c += 1
    n = sumdigits(n)

print(c)","def count_digit_sum_transformations(n):

    count = 0

    while len(n) > 1:

        n = str(sum(int(digit) for digit in n))

        count += 1
    
    return count

input_numbers = ['0', '10', '991']

output = []
for number in input_numbers:
    result = count_digit_sum_transformations(number.strip())
    output.append(str(result))

print('\n'.join(output))"
475,B,Strongly Connected City,PROGRAMMING,"['brute force', 'dfs and similar', 'graphs', 'implementation']","Imagine a city with *n* horizontal streets crossing *m* vertical streets, forming an (*n*<=-<=1)<=×<=(*m*<=-<=1) grid. In order to increase the traffic flow, mayor of the city has decided to make each street one way. This means in each horizontal street, the traffic moves only from west to east or only from east to west. Also, traffic moves only from north to south or only from south to north in each vertical street. It is possible to enter a horizontal street from a vertical street, or vice versa, at their intersection.

The mayor has received some street direction patterns. Your task is to check whether it is possible to reach any junction from any other junction in the proposed street direction pattern.","The first line of input contains two integers *n* and *m*, (2<=≤<=*n*,<=*m*<=≤<=20), denoting the number of horizontal streets and the number of vertical streets.

The second line contains a string of length *n*, made of characters '&lt;' and '&gt;', denoting direction of each horizontal street. If the *i*-th character is equal to '&lt;', the street is directed from east to west otherwise, the street is directed from west to east. Streets are listed in order from north to south.

The third line contains a string of length *m*, made of characters '^' and 'v', denoting direction of each vertical street. If the *i*-th character is equal to '^', the street is directed from south to north, otherwise the street is directed from north to south. Streets are listed in order from west to east.","If the given pattern meets the mayor's criteria, print a single line containing ""YES"", otherwise print a single line containing ""NO"".","['3 3\n&gt;&lt;&gt;\nv^v\n', '4 6\n&lt;&gt;&lt;&gt;\nv^v^v^\n']","['NO\n', 'YES\n']",The figure above shows street directions in the second sample test case.,OK,"n, m = map(int, input("""").split())
row_order = [ char  for char in input("""")]
col_order = [char for char in input("""")]

class Node():
    def __init__(self, id):
        self.row_id, self.col_id = id
        self.children = []

    def add_child(self, child_node_id):
        self.children.append(child_node_id)

def add_horizontal_edge(row_dir, row_id, col_id):
    if row_dir == '>' and col_id < m-1:
        matrix[row_id][col_id].add_child((row_id ,col_id+1))
    elif row_dir == '<' and col_id > 0:
        matrix[row_id][col_id].add_child((row_id, col_id-1))

def add_vertical_edge(col_dir, row_id, col_id):
    if col_dir == '^' and row_id > 0:
        matrix[row_id][col_id].add_child((row_id-1, col_id))
    elif col_dir == 'v'and row_id < n-1:
        matrix[row_id][col_id].add_child((row_id+1, col_id))

matrix = [[Node((row_id, col_id)) for col_id in range(m)] for row_id in range(n)]
for row_id in range(n):
    row_dir = row_order[row_id]
    for col_id in range(m):
        col_dir = col_order[col_id]
        add_horizontal_edge(row_dir, row_id, col_id)
        add_vertical_edge(col_dir, row_id, col_id)

def explore(row_id, col_id, visited):
    if visited[row_id][col_id] == 'true':
        return
    else:
        visited[row_id][col_id] ='true'
        for child_row_id, child_col_id in matrix[row_id][col_id].children:
            explore(child_row_id, child_col_id, visited)

    return

answer = 'YES'

def dfs(answer):
    for row_id in range(n):
        for col_id in range(m):
            visited = [['false' for col_id in range(m)] for row_id in range(n)]
            explore(row_id, col_id, visited)
            for i in range(n):
                for j in range(m):
                    if visited[i][j] == 'false':
                        answer = 'NO'
                        return answer

    return answer
answer = dfs(answer)
print(answer)","def can_reach_every_junction(n, m, horizontal, vertical):

    reachable = [[False] * m for _ in range(n)]

    reachable[0][0] = True

    queue = [(0, 0)]

    horizontal_moves = [(-1, 0), (1, 0)]
    vertical_moves = [(0, -1), (0, 1)]
    
    while queue:
        x, y = queue.pop(0)

        if horizontal[x] == '>':
            if y + 1 < m and not reachable[x][y + 1]:
                reachable[x][y + 1] = True
                queue.append((x, y + 1))
        else:
            if y - 1 >= 0 and not reachable[x][y - 1]:
                reachable[x][y - 1] = True
                queue.append((x, y - 1))

        if vertical[y] == 'v':
            if x + 1 < n and not reachable[x + 1][y]:
                reachable[x + 1][y] = True
                queue.append((x + 1, y))
        else:
            if x - 1 >= 0 and not reachable[x - 1][y]:
                reachable[x - 1][y] = True
                queue.append((x - 1, y))

    for i in range(n):
        for j in range(m):
            if not reachable[i][j]:
                return 'NO'
    
    return 'YES'

input_data = ['3 3\n&gt;&lt;&gt;\nv^v\n', '4 6\n&lt;&gt;&lt;&gt;\nv^v^v^\n']
results = []

for data in input_data:
    lines = data.split('\n')
    n, m = map(int, lines[0].split())
    horizontal = lines[1].replace('&gt;', '>').replace('&lt;', '<')
    vertical = lines[2].replace('v', 'v').replace('^', '^')
    
    results.append(can_reach_every_junction(n, m, horizontal, vertical))

for result in results:
    print(result)"
102,B,Sum of Digits,PROGRAMMING,['implementation'],"Having watched the last Harry Potter film, little Gerald also decided to practice magic. He found in his father's magical book a spell that turns any number in the sum of its digits. At the moment Gerald learned that, he came across a number *n*. How many times can Gerald put a spell on it until the number becomes one-digit?",The first line contains the only integer *n* (0<=≤<=*n*<=≤<=10100000). It is guaranteed that *n* doesn't contain any leading zeroes.,Print the number of times a number can be replaced by the sum of its digits until it only contains one digit.,"['0\n', '10\n', '991\n']","['0\n', '1\n', '3\n']","In the first sample the number already is one-digit — Herald can't cast a spell.

The second test contains number 10. After one casting of a spell it becomes 1, and here the process is completed. Thus, Gerald can only cast the spell once.

The third test contains number 991. As one casts a spell the following transformations take place: 991 → 19 → 10 → 1. After three transformations the number becomes one-digit.",OK,"from collections import Counter
def transform(s):
    c = Counter(s)
    val = 0
    for k in c:
        val += (ord(k)-ord('0'))*c[k]
    return str(val)

s = input()
count = 0
while(len(s)>=2):
    s = transform(s)
    count+=1
print(count)","def count_spell_casts(n):

    count = 0

    while len(n) > 1:

        n = str(sum(int(digit) for digit in n))

        count += 1
    
    return count

input_data = input().strip()

print(count_spell_casts(input_data))"
510,A,Fox And Snake,PROGRAMMING,['implementation'],"Fox Ciel starts to learn programming. The first task is drawing a fox! However, that turns out to be too hard for a beginner, so she decides to draw a snake instead.

A snake is a pattern on a *n* by *m* table. Denote *c*-th cell of *r*-th row as (*r*,<=*c*). The tail of the snake is located at (1,<=1), then it's body extends to (1,<=*m*), then goes down 2 rows to (3,<=*m*), then goes left to (3,<=1) and so on.

Your task is to draw this snake for Fox Ciel: the empty cells should be represented as dot characters ('.') and the snake cells should be filled with number signs ('#').

Consider sample tests in order to understand the snake pattern.","The only line contains two integers: *n* and *m* (3<=≤<=*n*,<=*m*<=≤<=50). 

*n* is an odd number.",Output *n* lines. Each line should contain a string consisting of *m* characters. Do not output spaces.,"['3 3\n', '3 4\n', '5 3\n', '9 9\n']","['###\n..#\n###\n', '####\n...#\n####\n', '###\n..#\n###\n#..\n###\n', '#########\n........#\n#########\n#........\n#########\n........#\n#########\n#........\n#########\n']",none,OK,"def f(n,m):
    snake = """"
    for i in range(1,n+1):
        if i%2 != 0:
            snake += ""
        elif i%4 == 0:
            snake += ""
        else:
            snake += (m-1)*"".""+""
    return snake

ai = input()
ai = [int(i) for i in ai.split("" "")]
print(f(ai[0],ai[1]))","def draw_snake(n, m):

    table = [['.' for _ in range(m)] for _ in range(n)]

    for i in range(n):
        if i % 2 == 0:

            for j in range(m):
                table[i][j] = '
        else:

            if (i // 2) % 2 == 0:
                table[i][m - 1] = '
            else:
                table[i][0] = '

    for row in table:
        print(''.join(row))

inputs = [(3, 3), (3, 4), (5, 3), (9, 9)]
for n, m in inputs:
    draw_snake(n, m)"
14,A,Letter,PROGRAMMING,['implementation'],"A boy Bob likes to draw. Not long ago he bought a rectangular graph (checked) sheet with *n* rows and *m* columns. Bob shaded some of the squares on the sheet. Having seen his masterpiece, he decided to share it with his elder brother, who lives in Flatland. Now Bob has to send his picture by post, but because of the world economic crisis and high oil prices, he wants to send his creation, but to spend as little money as possible. For each sent square of paper (no matter whether it is shaded or not) Bob has to pay 3.14 burles. Please, help Bob cut out of his masterpiece a rectangle of the minimum cost, that will contain all the shaded squares. The rectangle's sides should be parallel to the sheet's sides.","The first line of the input data contains numbers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=50), *n* — amount of lines, and *m* — amount of columns on Bob's sheet. The following *n* lines contain *m* characters each. Character «.» stands for a non-shaded square on the sheet, and «*» — for a shaded square. It is guaranteed that Bob has shaded at least one square.",Output the required rectangle of the minimum cost. Study the output data in the sample tests to understand the output format better.,"['6 7\n.......\n..***..\n..*....\n..***..\n..*....\n..***..\n', '3 3\n***\n*.*\n***\n']","['***\n*..\n***\n*..\n***\n', '***\n*.*\n***\n']",none,OK,"def main():
    n, m = list(map(int, input().split()))
    arr = []
    for _ in range(n):
        arr.append(input())

    mn_i, mx_i, mx_j, mn_j = n, -1, -1, m
    for i in range(n):
        for j in range(m):
            if arr[i][j] == ""*"":
                mn_i = min(mn_i, i)
                mx_i = max(mx_i, i)
                mn_j = min(mn_j, j)
                mx_j = max(mx_j, j)
    for i in range(mn_i, mx_i + 1):
        print(arr[i][mn_j : mx_j + 1])

if __name__ == ""__main__"":
    main()","def find_bounding_box(n, m, grid):

    top = n
    bottom = -1
    left = m
    right = -1

    for i in range(n):
        for j in range(m):
            if grid[i][j] == '*':
                if i < top:
                    top = i
                if i > bottom:
                    bottom = i
                if j < left:
                    left = j
                if j > right:
                    right = j

    result = []
    for i in range(top, bottom + 1):
        result.append(grid[i][left:right + 1])

    return result

def main():
    import sys
    input = sys.stdin.read
    data = input().strip().split('\n')

    n, m = map(int, data[0].split())

    grid = data[1:n + 1]

    result = find_bounding_box(n, m, grid)

    for line in result:
        print(line)

if __name__ == ""__main__"":
    main()"
686,A,Free Ice Cream,PROGRAMMING,"['constructive algorithms', 'implementation']","After their adventure with the magic mirror Kay and Gerda have returned home and sometimes give free ice cream to kids in the summer.

At the start of the day they have *x* ice cream packs. Since the ice cream is free, people start standing in the queue before Kay and Gerda's house even in the night. Each person in the queue wants either to take several ice cream packs for himself and his friends or to give several ice cream packs to Kay and Gerda (carriers that bring ice cream have to stand in the same queue).

If a carrier with *d* ice cream packs comes to the house, then Kay and Gerda take all his packs. If a child who wants to take *d* ice cream packs comes to the house, then Kay and Gerda will give him *d* packs if they have enough ice cream, otherwise the child will get no ice cream at all and will leave in distress.

Kay wants to find the amount of ice cream they will have after all people will leave from the queue, and Gerda wants to find the number of distressed kids.","The first line contains two space-separated integers *n* and *x* (1<=≤<=*n*<=≤<=1000, 0<=≤<=*x*<=≤<=109).

Each of the next *n* lines contains a character '+' or '-', and an integer *d**i*, separated by a space (1<=≤<=*d**i*<=≤<=109). Record ""+ *d**i*"" in *i*-th line means that a carrier with *d**i* ice cream packs occupies *i*-th place from the start of the queue, and record ""- *d**i*"" means that a child who wants to take *d**i* packs stands in *i*-th place.","Print two space-separated integers — number of ice cream packs left after all operations, and number of kids that left the house in distress.","['5 7\n+ 5\n- 10\n- 20\n+ 40\n- 20\n', '5 17\n- 16\n- 2\n- 98\n+ 100\n- 98\n']","['22 1\n', '3 2\n']","Consider the first sample.
 1.  Initially Kay and Gerda have 7 packs of ice cream. 1.  Carrier brings 5 more, so now they have 12 packs. 1.  A kid asks for 10 packs and receives them. There are only 2 packs remaining. 1.  Another kid asks for 20 packs. Kay and Gerda do not have them, so the kid goes away distressed. 1.  Carrier bring 40 packs, now Kay and Gerda have 42 packs. 1.  Kid asks for 20 packs and receives them. There are 22 packs remaining.",OK,"def free_ice_cream():

    n,ice_cream = map(int,input().split())

    num_distressed = 0
    for _ in range(n):
        operation,amount = input().split()
        amount = int(amount)

        if operation == '+':
            ice_cream += amount
        else:
            if amount > ice_cream:
                num_distressed += 1
            else:
                ice_cream -= amount

    print(ice_cream,num_distressed)

free_ice_cream()","def ice_cream_distribution(queue_info):
    results = []
    
    for info in queue_info:
        lines = info.strip().split('\n')
        n, x = map(int, lines[0].split())
        ice_cream_stock = x
        distressed_kids = 0
        
        for i in range(1, n + 1):
            operation = lines[i].split()
            action = operation[0]
            d = int(operation[1])
            
            if action == '+':
                ice_cream_stock += d
            elif action == '-':
                if ice_cream_stock >= d:
                    ice_cream_stock -= d
                else:
                    distressed_kids += 1
        
        results.append(f""{ice_cream_stock} {distressed_kids}"")
    
    return results

demo_inputs = ['5 7\n+ 5\n- 10\n- 20\n+ 40\n- 20\n', '5 17\n- 16\n- 2\n- 98\n+ 100\n- 98\n']
output = ice_cream_distribution(demo_inputs)
print(output)"
7,A,Kalevitch and Chess,PROGRAMMING,"['brute force', 'constructive algorithms']","A famous Berland's painter Kalevitch likes to shock the public. One of his last obsessions is chess. For more than a thousand years people have been playing this old game on uninteresting, monotonous boards. Kalevitch decided to put an end to this tradition and to introduce a new attitude to chessboards.

As before, the chessboard is a square-checkered board with the squares arranged in a 8<=×<=8 grid, each square is painted black or white. Kalevitch suggests that chessboards should be painted in the following manner: there should be chosen a horizontal or a vertical line of 8 squares (i.e. a row or a column), and painted black. Initially the whole chessboard is white, and it can be painted in the above described way one or more times. It is allowed to paint a square many times, but after the first time it does not change its colour any more and remains black. Kalevitch paints chessboards neatly, and it is impossible to judge by an individual square if it was painted with a vertical or a horizontal stroke.

Kalevitch hopes that such chessboards will gain popularity, and he will be commissioned to paint chessboards, which will help him ensure a comfortable old age. The clients will inform him what chessboard they want to have, and the painter will paint a white chessboard meeting the client's requirements.

It goes without saying that in such business one should economize on everything — for each commission he wants to know the minimum amount of strokes that he has to paint to fulfill the client's needs. You are asked to help Kalevitch with this task.","The input file contains 8 lines, each of the lines contains 8 characters. The given matrix describes the client's requirements, W character stands for a white square, and B character — for a square painted black.

It is guaranteed that client's requirments can be fulfilled with a sequence of allowed strokes (vertical/column or horizontal/row).",Output the only number — the minimum amount of rows and columns that Kalevitch has to paint on the white chessboard to meet the client's requirements.,"['WWWBWWBW\nBBBBBBBB\nWWWBWWBW\nWWWBWWBW\nWWWBWWBW\nWWWBWWBW\nWWWBWWBW\nWWWBWWBW\n', 'WWWWWWWW\nBBBBBBBB\nWWWWWWWW\nWWWWWWWW\nWWWWWWWW\nWWWWWWWW\nWWWWWWWW\nWWWWWWWW\n']","['3\n', '1\n']",none,COMPILATION_ERROR,"using namespace std;
//------------------ The code has been written by Tashvik Srivastava ------------------// 

const int  MAX = 1e5 + 5;
const ll MOD = 1e9 + 7;
const ll INF = 1e9;
const ld EPS = 1e-9;
int t,n,m,q,u,v,T,a,i[200200];
//______________________________________________________________________________________________

//____________________________________________________________________________________________
int remove0(int n);
int ispalin(string S);
//first try (time taken about 15 min)
//best case complexity of O(n)
int findd(std::vector<int> v , int  n , int x);
//------------------------------------------------------------------------------------------------------------------
//to find if given sum is sum of pairs in an array      
int FindPairSum(std::vector<int> A, int N, int SUM)
{
    int i = 0;int j = N - 1;
    while (i < j) {if (A[i] + A[j] == SUM)      return 1;
                   else if (A[i] + A[j] < SUM)  i++;
                   else                         j--;
                  }
                   return 0;                    
}
//-------------------------------------------------------------------------------------------------------------------
//to find sum of all vectors in an array
int vecsum(std::vector<int> v , int n)
{
    int sum = 0;
    forn(i,0,n)
    {
        sum+=v[i];
    }
    return sum;
}
//------------------------------------------------------------------------------------------------------------------
//tpix sum vector
vector<int> tpixsum(std::vector<int> v , int n)
{
    std::vector<int> r;
    r[0]=v[0];
    for (int i = 1; i < n; ++i)
    {
        /* code */
        r[i]=r[i-1]+v[i];
    }
    return r;
}
//------------------------------------------------------------------------------------------------------------------
//returns gcd
ll gcd(ll a, ll b)
{
  if (b == 0)
    return a;
  return gcd(b, a % b);
}
//------------------------------------------------------------------------------------------------------------------
//returns lcm
long long lcm(int a, int b)
{
    return (a / gcd(a, b)) * b;
}
//------------------------------------------------------------------------------------------------------------------
ll isSorted(vector<ll> A)
{

    ll n = A.size();
    forn(i, 0, n - 1)
    {
        if (A[i] > A[i + 1])
            return 0;
    }
    return 1;
}
//------------------------------------------------------------------------------------------------------------------
long long int printPair(std::vector<ll> arr, ll n, ll sum) 
{ 
    ll cnt = 0; // Initialize result 
  
    // Consider all possible pairs and check 
    // their sums 
    bool *visited=new bool[n]();
    for (ll i = 0; i < n; i++){ 
         if(visited[i]) continue;
        for (ll j = i + 1; j < n; j++){ 
               if(visited[j]) continue;
            if (arr[i] + arr[j] == sum){
                   cnt++;
                   visited[j]=true;
                   break;
                } 
         }     
   }       
 
     return cnt;           
} 
//------------------------------------------------------------------------------------------------------------------
set<long long> prim(int n)
{
    n++;
    bool *arr=new bool[n];
    for(int i=0;i<n;i++)
        arr[i]=true;
    set<long long> se;
    for(int i=2;i*i<n;i++)
        if(arr[i])
            for(int k=i*i;k<n;k+=i)
                arr[k]=false;
    for(int i=2;i<n;i++)
        if(arr[i])
            se.insert(i);
    return se;
}
//------------------------------------------------------------------------------------------------------------------
bool check_eqvec(std::vector<int> arr, int n)
{   
    bool flag = false;

    for(int i = 0; i < n - 1; i++)      
    {         
        if(arr[i] != arr[i + 1])
            flag = true;
    }

    return flag;
}
//------------------------------------------------------------------------------------------------------------------
void remove(std::vector<ll> v)
{
    auto end = v.end();
    for (auto it = v.begin(); it != end; ++it) {
        end = std::remove(it + 1, end, *it);
    }
 
    v.erase(end, v.end());
}
//------------------------------------------------------------------------------------------------------------------
//RETURNS A SET OF DIVISORS OF N
set<int64_t> printDivisors(int64_t n)
{
    // Vector to store half of the divisors
    set<int64_t> v;
    for (int i = 1; i <= sqrt(n); i++)
    {
        if (n % i == 0)
        {
 
            // check if divisors are equal
            if (n / i == i)
            {
                // printf(""%d "", i);
                v.insert(i);
            }
            else
            {
                // printf(""%d "", i);
                v.insert(i);
                // push the second divisor in the vector
                v.insert(n / i);
            }
        }
    }
    return v;
    // // The vector will be printed in reverse
    // for (int i = v.size() - 1; i >= 0; i--)
    //     printf(""%d "", v[i]);
}
//------------------------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------------------------
struct hashFunction
{
  size_t operator()(const pair<int , 
                    int> &x) const
  {
    return x.first ^ x.second;
  }
};

//------------------------------------------------------------------------------------------------------------------
 
   int cntdig(int n)
   {
    int cnt = 0 ;

    while(n!=0)
    {
        n/=10;
        cnt++;
    }

    return cnt;
   }

//------------------------------------------------------------------------------------------------------------------
bool isPowerOfTwo(int n)
{
   if(n==0)
   return false;
 
   return (ceil(log2(n)) == floor(log2(n)));
}
//-------------------------------------------------------------------------------------
int Search(int arr[], int l, int r, int x)
{
    if (r >= l) 
    {
       int mid = l + (r - l) / 2;
        if (arr[mid] == x)
            return mid;
        if (arr[mid] > x)
            return Search(arr, l, mid - 1, x);
        return Search(arr, mid + 1, r, x);
    }
    return -1;
}
//-------------------------------------------------------------------------------------
ll sum_nat(int n)
{
    return n * 1ll * (n + 1) / 2;
}
//-------------------------------------------------------------------------------------
bool check_sqr(long double x)
{
    if(x>=0)
    {
    ll sr = sqrt(x);
    return(sr*sr==x);
    }
    return false;

}
//-------------------------------------------------------------------------------------
bool check_even(int n)
{
    if(n & 1)
        return 0;
    else 
        return 1;
}
//-------------------------------------------------------------------------------------
int count1bits(uint32_t n) 
{                               // counts number of ones in a bitmask
   return bitset < 32 > (n).count();
}
//-------------------------------------------------------------------------------------
double getroot(int n , int m )
{
    /* 

     // Using Binary Search

    double low = 1 , high = m, eps = 1e-6;

    while((high - low)>eps)
    {
        double mid = (low+high)/2;
        if(pow(mid , n)<m) low = mid;
        else high = mid;
    }

    */
    return pow(m , (double)(1.0/(double)n));

}
//-------------------------------------------------------------------------------------
 int factorial( int n)
{
    if (n == 0 || n == 1)
        return 1;
    return n * factorial(n - 1);
}
//-------------------------------------------------------------------------------------
int f(int x){
    cin>>u>>v;
    u=min(u,v);
    a+=!(i[u]+=x)-(i[u]==1&x==1);
}

//-------------------------------------------------------------------------------------
bool isPrime(int n)
{
    if (n <= 1)
        return false;
    for (int i = 2; i < n; i++)
        if (n % i == 0)
            return false;
    return true;
}

//-------------------------------------------------------------------------------------
//solve function
bool helper(deque<int> &a,int k)
{
    int i=1;
    while(i<=k)
    {
        sort(a.begin(),a.end());
        if(a[0]>k-i+1)
        {
            return false;
        }
        int ind=a.size();
        for(int j=a.size()-1;j>=0;--j)
        {
            if(a[j]<=k-i+1)
            {
                ind=j;
                break;
            }
        }
        a.erase(a.begin()+ind);
        a[0]+=k-i+1;
        i++;
    }
    return true;
}

void solve()
{
   /* ll n;
    cin>>n;

    string str;
    cin>>str;

    int cnt = 0;

    for(auto &it : str)
    {
        if(it == 'Q')
            cnt++;
        else
            cnt--;

        if(cnt < 0)
            cnt = 0;
       }

       if(cnt == 0)
        cout<<""Yes""<<endl;
        else 
            cout<<""No""<<endl;
       */

// ll a , k;
// cin>>a>>k;
// vector<int> v;
//  for (int i = 2; i <= n; i++) {

//         bool flag = 1;
//         for (int j = 2; j <= i / 2; ++j) {
//             if (i % j == 0) {
//                 flag = 0;
//                 break;
//             }
//         }
//         if (flag == 1)
//             v.push_back(i);
//     }

//     for(int i = 0;i<v.size()-1;i++)
//     {
//         if( (v[i]+v[i+1]+1)%2 == 0 )
//         {
//             cout<<""YES""<<endl;
//             return;
//         }
//     }

//     cout<<""NO""<<endl;

string s;

int r = 0 , c = 0;
int x = 8;

int res = 0 , tmp = INT_MAX;
while(x--)
{
    cin>>s;

    int cnt = 0;
    for(auto &it : s)
        if(it == 'B')
            cnt++;

        if(cnt == 8)
            res++;

        tmp = min(cnt , tmp);
}

if(res == 8)
    cout<<8<<endl;
else
    cout<<res+tmp<<endl;

}

//------------------------------------------------------------------------------------------------------------------  
int main()
{
    GODSPEED
    NoTEST
    solve();
}","def min_strokes(board):

    row_count = sum(1 for row in board if 'B' in row)

    col_count = sum(1 for col in range(8) if any(board[row][col] == 'B' for row in range(8)))

    return min(row_count, col_count)

def main():
    import sys
    input_data = sys.stdin.read().strip().splitlines()

    result = min_strokes(input_data)

    print(result)

if __name__ == ""__main__"":
    main()"
1006,C,Three Parts of the Array,PROGRAMMING,"['binary search', 'data structures', 'two pointers']","You are given an array $d_1, d_2, \dots, d_n$ consisting of $n$ integer numbers.

Your task is to split this array into three parts (some of which may be empty) in such a way that each element of the array belongs to exactly one of the three parts, and each of the parts forms a consecutive contiguous subsegment (possibly, empty) of the original array. 

Let the sum of elements of the first part be $sum_1$, the sum of elements of the second part be $sum_2$ and the sum of elements of the third part be $sum_3$. Among all possible ways to split the array you have to choose a way such that $sum_1 = sum_3$ and $sum_1$ is maximum possible.

More formally, if the first part of the array contains $a$ elements, the second part of the array contains $b$ elements and the third part contains $c$ elements, then:

$$sum_1 = \sum\limits_{1 \le i \le a}d_i,$$ $$sum_2 = \sum\limits_{a + 1 \le i \le a + b}d_i,$$ $$sum_3 = \sum\limits_{a + b + 1 \le i \le a + b + c}d_i.$$

The sum of an empty array is $0$.

Your task is to find a way to split the array such that $sum_1 = sum_3$ and $sum_1$ is maximum possible.","The first line of the input contains one integer $n$ ($1 \le n \le 2 \cdot 10^5$) — the number of elements in the array $d$.

The second line of the input contains $n$ integers $d_1, d_2, \dots, d_n$ ($1 \le d_i \le 10^9$) — the elements of the array $d$.","Print a single integer — the maximum possible value of $sum_1$, considering that the condition $sum_1 = sum_3$ must be met.

Obviously, at least one valid way to split the array exists (use $a=c=0$ and $b=n$).","['5\n1 3 1 1 4\n', '5\n1 3 2 1 4\n', '3\n4 1 2\n']","['5\n', '4\n', '0\n']","In the first example there is only one possible splitting which maximizes $sum_1$: $[1, 3, 1], [~], [1, 4]$.

In the second example the only way to have $sum_1=4$ is: $[1, 3], [2, 1], [4]$.

In the third example there is only one way to split the array: $[~], [4, 1, 2], [~]$.",OK,"import math
def binarySearch (arr, l, r, x):

    if r >= l:
 
        mid = l + (r - l) // 2

        if arr[mid] == x:
            return mid

        elif arr[mid] > x:
            return binarySearch(arr, l, mid-1, x)

        else:
            return binarySearch(arr, mid + 1, r, x)
 
    else:

        return -1

n=int(input())
arr=list(map(int,input().split()))
i=-1
s=0
back=[0]
while i>-n:
    s+=arr[i]
    back.append(s)
    i-=1
i=0
s=0
front=[0]
while i<n-1:
    s+=arr[i]
    front.append(s)
    i+=1
ans=0
for i in range(n):
    if binarySearch(back,0,n-1,front[i])!=-1 and binarySearch(back,0,n-1,front[i])+i<=n:
        ans=front[i]
print(ans)","def max_sum_split(n, d):
    total_sum = sum(d)

    prefix_sums = {}
    current_sum = 0

    for i in range(n):
        current_sum += d[i]
        if current_sum not in prefix_sums:
            prefix_sums[current_sum] = 0
        prefix_sums[current_sum] += 1

    max_sum1 = 0
    current_sum = 0

    for j in range(n - 1, -1, -1):
        current_sum += d[j]

        if current_sum in prefix_sums:

            max_sum1 = max(max_sum1, current_sum)

        prefix_sums[current_sum] -= 1
        if prefix_sums[current_sum] == 0:
            del prefix_sums[current_sum]

    return max_sum1

if __name__ == ""__main__"":
    n = int(input())
    d = list(map(int, input().split()))
    result = max_sum_split(n, d)
    print(result)"
755,B,PolandBall and Game,PROGRAMMING,"['binary search', 'data structures', 'games', 'greedy', 'sortings', 'strings']","PolandBall is playing a game with EnemyBall. The rules are simple. Players have to say words in turns. You cannot say a word which was already said. PolandBall starts. The Ball which can't say a new word loses.

You're given two lists of words familiar to PolandBall and EnemyBall. Can you determine who wins the game, if both play optimally?","The first input line contains two integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=103) — number of words PolandBall and EnemyBall know, respectively.

Then *n* strings follow, one per line — words familiar to PolandBall.

Then *m* strings follow, one per line — words familiar to EnemyBall.

Note that one Ball cannot know a word more than once (strings are unique), but some words can be known by both players.

Each word is non-empty and consists of no more than 500 lowercase English alphabet letters.","In a single line of print the answer — ""YES"" if PolandBall wins and ""NO"" otherwise. Both Balls play optimally.","['5 1\npolandball\nis\na\ncool\ncharacter\nnope\n', '2 2\nkremowka\nwadowicka\nkremowka\nwiedenska\n', '1 2\na\na\nb\n']","['YES', 'YES', 'NO']","In the first example PolandBall knows much more words and wins effortlessly.

In the second example if PolandBall says kremowka first, then EnemyBall cannot use that word anymore. EnemyBall can only say wiedenska. PolandBall says wadowicka and wins.",RUNTIME_ERROR,"from collections import defaultdict
def solve(poland, enemy):
    n = len(poland)
    m = len(enemy)
    if n < m:
        print(""NO"")
        return
    if n > m:
        print(""YES"")
        return
    d = defaultdict(int)

    for word in poland:
        d[word] += 1
    for word in enemy:
        d[word] += 1

    intersection = [word for word in d if d[word] == 2]
    
    for idx, word in enumerate(intersection):
        if idx % 2 == 0:
            enemy.remove(word)
        else:
            poland.remove(word)

    if len(poland) > len(enemy):
        print(""YES"")
    else:
        print(""NO"")
    return 

if __name__ == '__main__':
    enemy = set()
    n, m = list(map(lambda x: int(x), input().split()))

    poland = {input() for _ in range(n)}
    enemy = {input() for _ in range(n)}
    solve(poland, enemy)","def determine_winner(words_polandball, words_enemyball):

    set_polandball = set(words_polandball)
    set_enemyball = set(words_enemyball)

    unique_polandball = len(set_polandball - set_enemyball)
    unique_enemyball = len(set_enemyball - set_polandball)
    common_words = len(set_polandball & set_enemyball)

    if unique_polandball + common_words > unique_enemyball:
        return ""YES""
    else:
        return ""NO""

def main():
    import sys
    input = sys.stdin.read
    data = input().strip().splitlines()

    n, m = map(int, data[0].split())

    words_polandball = [data[i + 1] for i in range(n)]

    words_enemyball = [data[n + 1 + i] for i in range(m)]

    result = determine_winner(words_polandball, words_enemyball)
    print(result)"
279,B,Books,PROGRAMMING,"['binary search', 'brute force', 'implementation', 'two pointers']","When Valera has got some free time, he goes to the library to read some books. Today he's got *t* free minutes to read. That's why Valera took *n* books in the library and for each book he estimated the time he is going to need to read it. Let's number the books by integers from 1 to *n*. Valera needs *a**i* minutes to read the *i*-th book.

Valera decided to choose an arbitrary book with number *i* and read the books one by one, starting from this book. In other words, he will first read book number *i*, then book number *i*<=+<=1, then book number *i*<=+<=2 and so on. He continues the process until he either runs out of the free time or finishes reading the *n*-th book. Valera reads each book up to the end, that is, he doesn't start reading the book if he doesn't have enough free time to finish reading it. 

Print the maximum number of books Valera can read.","The first line contains two integers *n* and *t* (1<=≤<=*n*<=≤<=105; 1<=≤<=*t*<=≤<=109) — the number of books and the number of free minutes Valera's got. The second line contains a sequence of *n* integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=104), where number *a**i* shows the number of minutes that the boy needs to read the *i*-th book.",Print a single integer — the maximum number of books Valera can read.,"['4 5\n3 1 2 1\n', '3 3\n2 2 3\n']","['3\n', '1\n']",none,WRONG_ANSWER,"def main():
    N, M = map(int, input().split())
    hotel_values = list(map(int, input().split()))

    max_total_value = 0
    current_total_value = 0
    left_pointer = 0

    for right_pointer in range(N):
        current_total_value += hotel_values[right_pointer]

        while current_total_value > M:
            current_total_value -= hotel_values[left_pointer]
            left_pointer += 1

        if current_total_value > max_total_value:
            max_total_value = current_total_value

    print(max_total_value)

if __name__ == ""__main__"":
    main()","def max_books(n, t, reading_times):
    max_books_read = 0
    current_time = 0
    start = 0

    for end in range(n):
        current_time += reading_times[end]

        while current_time > t:
            current_time -= reading_times[start]
            start += 1

        max_books_read = max(max_books_read, end - start + 1)
    
    return max_books_read

input_data = input().splitlines()
n, t = map(int, input_data[0].split())
reading_times = list(map(int, input_data[1].split()))

print(max_books(n, t, reading_times))"
962,C,Make a Square,PROGRAMMING,"['brute force', 'implementation', 'math']","You are given a positive integer $n$, written without leading zeroes (for example, the number 04 is incorrect). 

In one operation you can delete any digit of the given integer so that the result remains a positive integer without leading zeros.

Determine the minimum number of operations that you need to consistently apply to the given integer $n$ to make from it the square of some positive integer or report that it is impossible.

An integer $x$ is the square of some positive integer if and only if $x=y^2$ for some positive integer $y$.",The first line contains a single integer $n$ ($1 \le n \le 2 \cdot 10^{9}$). The number is given without leading zeroes.,"If it is impossible to make the square of some positive integer from $n$, print -1. In the other case, print the minimal number of operations required to do it.","['8314\n', '625\n', '333\n']","['2\n', '0\n', '-1\n']","In the first example we should delete from $8314$ the digits $3$ and $4$. After that $8314$ become equals to $81$, which is the square of the integer $9$.

In the second example the given $625$ is the square of the integer $25$, so you should not delete anything. 

In the third example it is impossible to make the square from $333$, so the answer is -1.",WRONG_ANSWER,"def get_list(func=None):
    if not func:
        return input().split()
    return list(map(func, input().split()))

def edit_dist(A, a):
    """""" Calculate the edit distance from A to a. """"""
    if len(A) < len(a):
        return -1

    if len(a) == 1:
        if a in A:
            return len(A) - 1
        else:
            return -1

    mind = float('inf')
    for i, ch in enumerate(A):
        if ch == a[0]:
            d = edit_dist(A[i+1:], a[1:])
            if d != -1:
                mind = min(mind, d)

    return mind

n = input()
mind = float('inf')

for i in range(1, int(10**4.5)):
    s = str(i**2)
    d = edit_dist(n, s)
    if d != -1:
        mind = min(mind, d)

if mind > 100:
    print(-1)
else:
    print(mind)","def min_operations_to_square(n):

    str_n = str(n)
    max_square_root = int(n**0.5) + 1
    squares = {str(i**2) for i in range(1, max_square_root)}
    
    def min_operations_to_form_square(square):

        m, k = len(str_n), len(square)
        i, j = 0, 0

        while i < m and j < k:
            if str_n[i] == square[j]:
                j += 1
            i += 1

        if j == k:
            return m - k
        return float('inf')
    
    min_operations = float('inf')
    for square in squares:
        operations = min_operations_to_form_square(square)
        min_operations = min(min_operations, operations)
    
    return min_operations if min_operations != float('inf') else -1

import sys
input = sys.stdin.read

data = input().strip().split()
results = []

for line in data:
    n = int(line)
    result = min_operations_to_square(n)
    results.append(str(result))

print(""\n"".join(results))"
1,A,Theatre Square,PROGRAMMING,['math'],"Theatre Square in the capital city of Berland has a rectangular shape with the size *n*<=×<=*m* meters. On the occasion of the city's anniversary, a decision was taken to pave the Square with square granite flagstones. Each flagstone is of the size *a*<=×<=*a*.

What is the least number of flagstones needed to pave the Square? It's allowed to cover the surface larger than the Theatre Square, but the Square has to be covered. It's not allowed to break the flagstones. The sides of flagstones should be parallel to the sides of the Square.","The input contains three positive integer numbers in the first line: *n*,<=<=*m* and *a* (1<=≤<=<=*n*,<=*m*,<=*a*<=≤<=109).",Write the needed number of flagstones.,['6 6 4\n'],['4\n'],none,OK,"import math

def calculate_flagstones(n, m, a):
    length_flagstones = math.ceil(n / a)
    width_flagstones = math.ceil(m / a)
    total_flagstones = length_flagstones * width_flagstones
    return total_flagstones

n, m, a = map(int, input().split())
print(calculate_flagstones(n, m, a))","import math

n, m, a = map(int, input().split())

flagstones_length = math.ceil(n / a)
flagstones_width = math.ceil(m / a)

total_flagstones = flagstones_length * flagstones_width

print(total_flagstones)"
331,C1,The Great Julya Calendar,PROGRAMMING,['dp'],"Yet another Armageddon is coming! This time the culprit is the Julya tribe calendar. 

The beavers in this tribe knew math very well. Smart Beaver, an archaeologist, got a sacred plate with a magic integer on it. The translation from Old Beaverish is as follows: 

""May the Great Beaver bless you! May your chacres open and may your third eye never turn blind from beholding the Truth! Take the magic number, subtract a digit from it (the digit must occur in the number) and get a new magic number. Repeat this operation until a magic number equals zero. The Earth will stand on Three Beavers for the time, equal to the number of subtractions you perform!""

Distinct subtraction sequences can obviously get you different number of operations. But the Smart Beaver is ready to face the worst and is asking you to count the minimum number of operations he needs to reduce the magic number to zero.","The single line contains the magic integer *n*, 0<=≤<=*n*.
 -  to get 20 points, you need to solve the problem with constraints: *n*<=≤<=106 (subproblem C1); -  to get 40 points, you need to solve the problem with constraints: *n*<=≤<=1012 (subproblems C1+C2); -  to get 100 points, you need to solve the problem with constraints: *n*<=≤<=1018 (subproblems C1+C2+C3).",Print a single integer — the minimum number of subtractions that turns the magic number to a zero.,['24\n'],['5'],In the first test sample the minimum number of operations can be reached by the following sequence of subtractions:,TIME_LIMIT_EXCEEDED,"n=int(input())
def ispres(x,num):
 dig={i:0 for i in range(10)}
 m=num
 while m>0:
    d=m%10
    dig[d]+=1
    m=m//10
 if dig[x]!=0:
     return True
 return False
dp=[999999 for _ in range(n+1)]
for j in range(1,10):
    if ispres(j,n):
        dp[n-j]=1
for i in range(n,-1,-1):
    for k in range(1,10):

        if i+k<=n and ispres(k,i+k):
           dp[i]=min(dp[i],dp[i+k]+1)
if dp[0]==999999:
    print(0)
    exit(0)
print(dp[0])","def minimum_operations_to_zero(n):

    operations = 0
    
    while n > 0:

        digits = [int(d) for d in str(n)]

        max_digit = max(digits)

        n -= max_digit

        operations += 1
    
    return operations

n = int(input().strip())

result = minimum_operations_to_zero(n)

print(result)"
69,A,Young Physicist,PROGRAMMING,"['implementation', 'math']","A guy named Vasya attends the final grade of a high school. One day Vasya decided to watch a match of his favorite hockey team. And, as the boy loves hockey very much, even more than physics, he forgot to do the homework. Specifically, he forgot to complete his physics tasks. Next day the teacher got very angry at Vasya and decided to teach him a lesson. He gave the lazy student a seemingly easy task: You are given an idle body in space and the forces that affect it. The body can be considered as a material point with coordinates (0; 0; 0). Vasya had only to answer whether it is in equilibrium. ""Piece of cake"" — thought Vasya, we need only to check if the sum of all vectors is equal to 0. So, Vasya began to solve the problem. But later it turned out that there can be lots and lots of these forces, and Vasya can not cope without your help. Help him. Write a program that determines whether a body is idle or is moving by the given vectors of forces.","The first line contains a positive integer *n* (1<=≤<=*n*<=≤<=100), then follow *n* lines containing three integers each: the *x**i* coordinate, the *y**i* coordinate and the *z**i* coordinate of the force vector, applied to the body (<=-<=100<=≤<=*x**i*,<=*y**i*,<=*z**i*<=≤<=100).","Print the word ""YES"" if the body is in equilibrium, or the word ""NO"" if it is not.","['3\n4 1 7\n-2 4 -1\n1 -5 -3\n', '3\n3 -1 7\n-5 2 -4\n2 -1 -3\n']","['NO', 'YES']",none,OK,"import fileinput
import operator
from itertools import islice, starmap

def main() -> None:
    """"""Main function""""""
    with fileinput.input() as f:
        n = int(next(f))
        v = (0, 0, 0)
        for line in islice(f, n):
            w = tuple(map(int, line.split()))
            v = tuple(starmap(operator.add, zip(v, w)))
        print(""YES"" if v == (0, 0, 0) else ""NO"")

if __name__ == ""__main__"":
    main()","def is_equilibrium(n, forces):

    sum_x = sum_y = sum_z = 0

    for force in forces:
        x, y, z = force
        sum_x += x
        sum_y += y
        sum_z += z

    if sum_x == 0 and sum_y == 0 and sum_z == 0:
        return ""YES""
    else:
        return ""NO""

if __name__ == ""__main__"":
    n = int(input())
    forces = []

    for _ in range(n):
        force = tuple(map(int, input().split()))
        forces.append(force)

    result = is_equilibrium(n, forces)
    print(result)"
4,A,Watermelon,PROGRAMMING,"['brute force', 'math']","One hot summer day Pete and his friend Billy decided to buy a watermelon. They chose the biggest and the ripest one, in their opinion. After that the watermelon was weighed, and the scales showed *w* kilos. They rushed home, dying of thirst, and decided to divide the berry, however they faced a hard problem.

Pete and Billy are great fans of even numbers, that's why they want to divide the watermelon in such a way that each of the two parts weighs even number of kilos, at the same time it is not obligatory that the parts are equal. The boys are extremely tired and want to start their meal as soon as possible, that's why you should help them and find out, if they can divide the watermelon in the way they want. For sure, each of them should get a part of positive weight.",The first (and the only) input line contains integer number *w* (1<=≤<=*w*<=≤<=100) — the weight of the watermelon bought by the boys.,"Print YES, if the boys can divide the watermelon into two parts, each of them weighing even number of kilos; and NO in the opposite case.",['8\n'],['YES\n'],"For example, the boys can divide the watermelon into two parts of 2 and 6 kilos respectively (another variant — two parts of 4 and 4 kilos).",WRONG_ANSWER,"def can_divide_watermelon(w):
    if w % 2 == 0 and w > 2:
        return ""YES""  
    else:
        return ""NO""

weight = int(input(""Enter the weight of the watermelon: ""))

print(can_divide_watermelon(weight))","def can_divide_watermelon(weight):

    if weight > 2 and weight % 2 == 0:
        return ""YES""
    else:
        return ""NO""

w = int(input().strip())

print(can_divide_watermelon(w))"
224,A,Parallelepiped,PROGRAMMING,"['brute force', 'geometry', 'math']",You've got a rectangular parallelepiped with integer edge lengths. You know the areas of its three faces that have a common vertex. Your task is to find the sum of lengths of all 12 edges of this parallelepiped.,The first and the single line contains three space-separated integers — the areas of the parallelepiped's faces. The area's values are positive (<=&gt;<=0) and do not exceed 104. It is guaranteed that there exists at least one parallelepiped that satisfies the problem statement.,Print a single number — the sum of all edges of the parallelepiped.,"['1 1 1\n', '4 6 6\n']","['12\n', '28\n']","In the first sample the parallelepiped has sizes 1 × 1 × 1, in the second one — 2 × 2 × 3.",OK,"from itertools import permutations 

def solve(arr):
    perm = permutations(arr)
    for i in list(perm):
        v = (i[1]*i[2]/i[0])**.5
        if v.is_integer() :
            return int(4*v + 4*i[1]//v + 4*i[2]//v) 

def main():
    arr = list(map(int, input().split("" "")))
    print(solve(arr))

main()","import math

areas = list(map(int, input().strip().split()))

A = areas[0]
B = areas[1]
C = areas[2]

a = math.sqrt(A * C / B)
b = math.sqrt(A * B / C)
c = math.sqrt(B * C / A)

sum_of_edges = 4 * (a + b + c)

print(int(sum_of_edges))"
285,C,Building Permutation,PROGRAMMING,"['greedy', 'implementation', 'sortings']","Permutation *p* is an ordered set of integers *p*1,<=<=*p*2,<=<=...,<=<=*p**n*, consisting of *n* distinct positive integers, each of them doesn't exceed *n*. We'll denote the *i*-th element of permutation *p* as *p**i*. We'll call number *n* the size or the length of permutation *p*1,<=<=*p*2,<=<=...,<=<=*p**n*.

You have a sequence of integers *a*1,<=*a*2,<=...,<=*a**n*. In one move, you are allowed to decrease or increase any number by one. Count the minimum number of moves, needed to build a permutation from this sequence.","The first line contains integer *n* (1<=≤<=*n*<=≤<=3·105) — the size of the sought permutation. The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (<=-<=109<=≤<=*a**i*<=≤<=109).","Print a single number — the minimum number of moves.

Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.","['2\n3 0\n', '3\n-1 -1 2\n']","['2\n', '6\n']","In the first sample you should decrease the first number by one and then increase the second number by one. The resulting permutation is (2, 1).

In the second sample you need 6 moves to build permutation (1, 3, 2).",OK,"def solve (n,seq) :
    seq.sort()
    start = 1
    moves = 0
    while start <= n :
        if seq[start-1] != start :
            moves += abs(seq[start-1] - start)
        start += 1
        
        
    return moves
    
    
n = int(input())
seq = list(map(int,input().split()))

print (solve(n,seq))","def min_moves_to_permutation(n, a):

    target = list(range(1, n + 1))

    a.sort()

    total_moves = 0

    for i in range(n):
        total_moves += abs(a[i] - target[i])
    
    return total_moves

n = int(input().strip())
a = list(map(int, input().strip().split()))

result = min_moves_to_permutation(n, a)
print(result)"
318,A,Even Odds,PROGRAMMING,['math'],"Being a nonconformist, Volodya is displeased with the current state of things, particularly with the order of natural numbers (natural number is positive integer number). He is determined to rearrange them. But there are too many natural numbers, so Volodya decided to start with the first *n*. He writes down the following sequence of numbers: firstly all odd integers from 1 to *n* (in ascending order), then all even integers from 1 to *n* (also in ascending order). Help our hero to find out which number will stand at the position number *k*.","The only line of input contains integers *n* and *k* (1<=≤<=*k*<=≤<=*n*<=≤<=1012).

Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.",Print the number that will stand at the position number *k* after Volodya's manipulations.,"['10 3\n', '7 7\n']","['5', '6']","In the first sample Volodya's sequence will look like this: {1, 3, 5, 7, 9, 2, 4, 6, 8, 10}. The third place in the sequence is therefore occupied by the number 5.",RUNTIME_ERROR,"def odd_even(n, k):
    if n%2 == 0:
        if k <= n//2:
            res = 2*k - 1
        else:
            res = 2*(k - n//2)
    else:
        if k <= n//2 + 1:
            res = 2*k - 1
        else:
            res = 2*(k - n//2 - 1)
    return res
    
n, k = map(int, input().split())
print(even_odd(n, k))","n, k = map(int, input().split())

odd_count = (n + 1) // 2

if k <= odd_count:

    result = 2 * k - 1
else:

    even_position = k - odd_count
    result = 2 * even_position

print(result)"
118,A,String Task,PROGRAMMING,"['implementation', 'strings']","Petya started to attend programming lessons. On the first lesson his task was to write a simple program. The program was supposed to do the following: in the given string, consisting if uppercase and lowercase Latin letters, it: 
 -  deletes all the vowels, -  inserts a character ""."" before each consonant, -  replaces all uppercase consonants with corresponding lowercase ones. 
Vowels are letters ""A"", ""O"", ""Y"", ""E"", ""U"", ""I"", and the rest are consonants. The program's input is exactly one string, it should return the output as a single string, resulting after the program's processing the initial string.

Help Petya cope with this easy task.","The first line represents input string of Petya's program. This string only consists of uppercase and lowercase Latin letters and its length is from 1 to 100, inclusive.",Print the resulting string. It is guaranteed that this string is not empty.,"['tour\n', 'Codeforces\n', 'aBAcAba\n']","['.t.r\n', '.c.d.f.r.c.s\n', '.b.c.b\n']",none,RUNTIME_ERROR,"def main():
    n = int(input())
    s = input()
    cnt = 0
    for i in range(1, len(s)):
        pre = s[i - 1]
        if pre == s[i]:
            cnt += 1

    print(cnt)

if __name__ == '__main__':
    main()","def process_string(input_string):

    vowels = ""aoyeuiAOYEUI""
    result = []

    for char in input_string:

        if char not in vowels:

            result.append(""."" + char.lower())

    return ''.join(result)

if __name__ == ""__main__"":

    input_string = input().strip()

    output_string = process_string(input_string)
    print(output_string)"
559,A,Gerald's Hexagon,PROGRAMMING,"['brute force', 'geometry', 'math']","Gerald got a very curious hexagon for his birthday. The boy found out that all the angles of the hexagon are equal to . Then he measured the length of its sides, and found that each of them is equal to an integer number of centimeters. There the properties of the hexagon ended and Gerald decided to draw on it.

He painted a few lines, parallel to the sides of the hexagon. The lines split the hexagon into regular triangles with sides of 1 centimeter. Now Gerald wonders how many triangles he has got. But there were so many of them that Gerald lost the track of his counting. Help the boy count the triangles.","The first and the single line of the input contains 6 space-separated integers *a*1,<=*a*2,<=*a*3,<=*a*4,<=*a*5 and *a*6 (1<=≤<=*a**i*<=≤<=1000) — the lengths of the sides of the hexagons in centimeters in the clockwise order. It is guaranteed that the hexagon with the indicated properties and the exactly such sides exists.","Print a single integer — the number of triangles with the sides of one 1 centimeter, into which the hexagon is split.","['1 1 1 1 1 1\n', '1 2 1 2 1 2\n']","['6\n', '13\n']","This is what Gerald's hexagon looks like in the first sample:

<img class=""tex-graphics"" src=""https://espresso.codeforces.com/84d193e27b02c38eb1eadc536602a2ec0b9f9519.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

And that's what it looks like in the second sample:

<img class=""tex-graphics"" src=""https://espresso.codeforces.com/e29076a96da8ca864654cc6195654d9bf07d31ce.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>",OK,"def input_ints():
    return list(map(int, input().split()))

def output_list(v):
    print(' '.join(str(x) for x in v))

def main():
    a = input_ints()
    ans = 0
    x = a[0]
    for i in range(a[1] + a[2]):
        d = 0
        d += (1 if i < a[1] else -1)
        d += (1 if i < a[5] else -1)
        d //= 2
        ans += 2 * x + d
        x += d
    print(ans)

if __name__ == '__main__':
    main()","def count_triangles(a1, a2, a3, a4, a5, a6):

    area = (3 * (a1 + a4) * (a2 + a5)) // 2

    return area * 2

def main():

    sides = list(map(int, input().strip().split()))

    a1, a2, a3, a4, a5, a6 = sides

    result = count_triangles(a1, a2, a3, a4, a5, a6)

    print(result)

if __name__ == ""__main__"":
    main()"
650,A,Watchmen,PROGRAMMING,"['data structures', 'geometry', 'math']","Watchmen are in a danger and Doctor Manhattan together with his friend Daniel Dreiberg should warn them as soon as possible. There are *n* watchmen on a plane, the *i*-th watchman is located at point (*x**i*,<=*y**i*).

They need to arrange a plan, but there are some difficulties on their way. As you know, Doctor Manhattan considers the distance between watchmen *i* and *j* to be |*x**i*<=-<=*x**j*|<=+<=|*y**i*<=-<=*y**j*|. Daniel, as an ordinary person, calculates the distance using the formula .

The success of the operation relies on the number of pairs (*i*,<=*j*) (1<=≤<=*i*<=&lt;<=*j*<=≤<=*n*), such that the distance between watchman *i* and watchmen *j* calculated by Doctor Manhattan is equal to the distance between them calculated by Daniel. You were asked to compute the number of such pairs.","The first line of the input contains the single integer *n* (1<=≤<=*n*<=≤<=200<=000) — the number of watchmen.

Each of the following *n* lines contains two integers *x**i* and *y**i* (|*x**i*|,<=|*y**i*|<=≤<=109).

Some positions may coincide.",Print the number of pairs of watchmen such that the distance between them calculated by Doctor Manhattan is equal to the distance calculated by Daniel.,"['3\n1 1\n7 5\n1 5\n', '6\n0 0\n0 1\n0 2\n-1 1\n0 1\n1 1\n']","['2\n', '11\n']","In the first sample, the distance between watchman 1 and watchman 2 is equal to |1 - 7| + |1 - 5| = 10 for Doctor Manhattan and <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/bcb5b7064b5f02088da0fdcf677e6fda495dd0df.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> for Daniel. For pairs (1, 1), (1, 5) and (7, 5), (1, 5) Doctor Manhattan and Daniel will calculate the same distances.",WRONG_ANSWER,"def choose2(n):
	return n*(n-1)//2

xs = set()
ys = set()
ps = set()

n = int(input())
p = []
for _ in range(n):
	x, y = [int(x) for x in input().split()]
	xs.add(x)
	ys.add(y)
	ps.add((x,y))
rep_x = (n-len(xs)+1)
rep_y = (n-len(ys)+1)
rep_p = (n-len(ps)+1)
n_rep = choose2(rep_x)+choose2(rep_y)-choose2(rep_p)
print(n_rep)","def count_matching_pairs(n, watchmen):
    count = 0

    for i in range(n):
        for j in range(i, n):

            x_i, y_i = watchmen[i]
            x_j, y_j = watchmen[j]

            manhattan_distance = abs(x_i - x_j) + abs(y_i - y_j)
            euclidean_distance = ((x_i - x_j) ** 2 + (y_i - y_j) ** 2) ** 0.5

            if manhattan_distance == euclidean_distance:
                count += 1
    return count

n = int(input())
watchmen = [tuple(map(int, input().split())) for _ in range(n)]

result = count_matching_pairs(n, watchmen)
print(result)"
275,B,Convex Shape,PROGRAMMING,"['constructive algorithms', 'implementation']","Consider an *n*<=×<=*m* grid. Initially all the cells of the grid are colored white. Lenny has painted some of the cells (at least one) black. We call a painted grid convex if one can walk from any black cell to any another black cell using a path of side-adjacent black cells changing his direction at most once during the path. In the figure below, the left grid is convex while the right one is not convex, because there exist two cells which need more than one time to change direction in their path.

You're given a painted grid in the input. Tell Lenny if the grid is convex or not.","The first line of the input contains two integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=50) — the size of the grid. Each of the next *n* lines contains *m* characters ""B"" or ""W"". Character ""B"" denotes a black cell of the grid and ""W"" denotes a white cell of the grid.

It's guaranteed that the grid has at least one black cell.","On the only line of the output print ""YES"" if the grid is convex, otherwise print ""NO"". Do not print quotes.","['3 4\nWWBW\nBWWW\nWWWB\n', '3 1\nB\nB\nW\n']","['NO\n', 'YES\n']",none,RUNTIME_ERROR,"import abc
import itertools
import math
from math import gcd as gcd
import sys
import queue
import itertools
from heapq import heappop, heappush
import random

def solve():
    def line_sum(y1, x1, y2, x2):
        if x1 == x2:
            s = d[max(y1, y2)][x1] - d[max(y1, y2)][x1 - 1] - d[min(y1, y2) - 1][x1] + d[min(y1, y2) - 1][x1 - 1]
            return s
        elif y1 == y2:
            s = d[y1][max(x1, x2)] - d[y1][min(x1, x2) - 1] - d[y1 - 1][max(x1, x2)] + d[y1 - 1][min(x1, x2) - 1]
            return s
        else:
            print(""Ti durak"")
            print(""Oshibka :////"")

    def check(y1, x1, y2, x2):

        if x1 == x2:
            s = line_sum(y1, x1, y2, x2)
            if s != abs(y1 - y2) + 1:
                return False
            return True
        elif y1 == y2:
            s = line_sum(x1, y1, x2, y2)
            if s != abs(x1 - x2) + 1:
                return False
            return True
        else:
            for xp in [x1, x2]:
                for yp in [y1, y2]:
                    if [xp, yp] not in [[x1, y1], [x2, y2]]:
                        s1 = line_sum(y1, x1, yp, xp)
                        s2 = line_sum(y2, x2, yp, xp)

                        need = abs(x1 - x2) + abs(y1 - y2) + 1
                        if s1 + s2 - 1 == need:
                            return True

            return False

    n, m = map(int, input().split())

    f = []
    pos = []
    for i in range(n):
        s = str(input())
        for j in range(m):
            if s[j] == ""B"":
                pos.append([i + 1, j + 1])
        f.append(s)

    d = [[0 for i in range(m + 1)]]
    for i in range(n):
        d.append([0])
        for j in range(m):
            d[-1].append(int(f[i][j] == ""B"") + d[i][j + 1] + d[i + 1][j] - d[i][j])

    for first in range(len(pos)):
        y1, x1 = pos[first]
        for second in range(first + 1, len(pos)):
            y2, x2 = pos[second]

            if not check(y1, x1, y2, x2):
                print(""NO"")
                return

    print(""YES"")

if __name__ == '__main__':
    multi_test = 0

    if multi_test == 1:
        t = int(sys.stdin.readline())
        for _ in range(t):
            solve()
    else:
        solve()","def is_convex(grid, n, m):

    min_row, max_row = n, -1
    min_col, max_col = m, -1
    
    for i in range(n):
        for j in range(m):
            if grid[i][j] == 'B':
                min_row = min(min_row, i)
                max_row = max(max_row, i)
                min_col = min(min_col, j)
                max_col = max(max_col, j)

    for i in range(min_row, max_row + 1):
        for j in range(min_col, max_col + 1):
            if grid[i][j] != 'B':
                return ""NO""
    
    return ""YES""

n, m = map(int, input().split())
grid = [input().strip() for _ in range(n)]

result = is_convex(grid, n, m)

print(result)"
472,A,Design Tutorial: Learn from Math,PROGRAMMING,"['math', 'number theory']","One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.

For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.

You are given an integer *n* no less than 12, express it as a sum of two composite numbers.",The only line contains an integer *n* (12<=≤<=*n*<=≤<=106).,"Output two composite integers *x* and *y* (1<=&lt;<=*x*,<=*y*<=&lt;<=*n*) such that *x*<=+<=*y*<==<=*n*. If there are multiple solutions, you can output any of them.","['12\n', '15\n', '23\n', '1000000\n']","['4 8\n', '6 9\n', '8 15\n', '500000 500000\n']","In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output ""6 6"" or ""8 4"" as well.

In the second example, 15 = 6 + 9. Note that you can't output ""1 14"" because 1 is not a composite number.",OK,"def prime(n):
    d = 2
    while d * d <= n and n % d != 0:
        d += 1
    return d * d > n

n = int(input())
a = 0
b = 0
for i in range(4, n):
    if prime(i) is not True and prime(n - i) is not True:
        a = i
        b = n - i
        break
print(a, b)","def is_composite(num):
    """"""Check if a number is composite.""""""
    if num < 4:
        return False
    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            return True
    return False

def find_composite_sum(n):
    """"""Find two composite numbers that sum up to n.""""""
    for x in range(4, n // 2 + 1):
        if is_composite(x) and is_composite(n - x):
            return x, n - x
    return None

def main():
    """"""Main function to handle input and output.""""""
    test_cases = [12, 15, 23, 1000000]
    results = []
    
    for n in test_cases:
        x, y = find_composite_sum(n)
        results.append(f""{x} {y}"")

    for result in results:
        print(result)

if __name__ == ""__main__"":
    main()"
26,A,Almost Prime,PROGRAMMING,['number theory'],"A number is called almost prime if it has exactly two distinct prime divisors. For example, numbers 6, 18, 24 are almost prime, while 4, 8, 9, 42 are not. Find the amount of almost prime numbers which are between 1 and *n*, inclusive.",Input contains one integer number *n* (1<=≤<=*n*<=≤<=3000).,"Output the amount of almost prime numbers between 1 and *n*, inclusive.","['10\n', '21\n']","['2\n', '8\n']",none,OK,"def is_prime(n):
    c = 0
    if n == 1:
        return False
    for k in range(2,n):
        if n % k == 0:
            c = 1
            return False
    if c == 0:
        return True
r = 0
n = int(input())
for i in range(1, n + 1):
    c = 0
    for j in range(1, i):
        if i % j == 0:
            if is_prime(j):
                c += 1
    
    if c == 2:
        r += 1
print(r)","def is_prime(num):
    """"""Check if a number is prime.""""""
    if num <= 1:
        return False
    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            return False
    return True

def count_distinct_prime_factors(num):
    """"""Count distinct prime factors of a number.""""""
    distinct_primes = set()
    for i in range(2, num + 1):
        if is_prime(i) and num % i == 0:
            distinct_primes.add(i)
    return len(distinct_primes)

def count_almost_primes(n):
    """"""Count almost prime numbers up to n.""""""
    almost_prime_count = 0
    for i in range(2, n + 1):
        if count_distinct_prime_factors(i) == 2:
            almost_prime_count += 1
    return almost_prime_count

inputs = ['10\n', '21\n']
results = []

for input_str in inputs:
    n = int(input_str.strip())
    result = count_almost_primes(n)
    results.append(f""{result}\n"")

print(''.join(results))"
518,A,Vitaly and Strings,PROGRAMMING,"['constructive algorithms', 'strings']","Vitaly is a diligent student who never missed a lesson in his five years of studying in the university. He always does his homework on time and passes his exams in time. 

During the last lesson the teacher has provided two strings *s* and *t* to Vitaly. The strings have the same length, they consist of lowercase English letters, string *s* is lexicographically smaller than string *t*. Vitaly wondered if there is such string that is lexicographically larger than string *s* and at the same is lexicographically smaller than string *t*. This string should also consist of lowercase English letters and have the length equal to the lengths of strings *s* and *t*. 

Let's help Vitaly solve this easy problem!","The first line contains string *s* (1<=≤<=|*s*|<=≤<=100), consisting of lowercase English letters. Here, |*s*| denotes the length of the string.

The second line contains string *t* (|*t*|<==<=|*s*|), consisting of lowercase English letters.

It is guaranteed that the lengths of strings *s* and *t* are the same and string *s* is lexicographically less than string *t*.","If the string that meets the given requirements doesn't exist, print a single string ""No such string"" (without the quotes).

If such string exists, print it. If there are multiple valid strings, you may print any of them.","['a\nc\n', 'aaa\nzzz\n', 'abcdefg\nabcdefh\n']","['b\n', 'kkk\n', 'No such string\n']","String *s* = *s*<sub class=""lower-index"">1</sub>*s*<sub class=""lower-index"">2</sub>... *s*<sub class=""lower-index"">*n*</sub> is said to be lexicographically smaller than *t* = *t*<sub class=""lower-index"">1</sub>*t*<sub class=""lower-index"">2</sub>... *t*<sub class=""lower-index"">*n*</sub>, if there exists such *i*, that *s*<sub class=""lower-index"">1</sub> = *t*<sub class=""lower-index"">1</sub>, *s*<sub class=""lower-index"">2</sub> = *t*<sub class=""lower-index"">2</sub>, ... *s*<sub class=""lower-index"">*i* - 1</sub> = *t*<sub class=""lower-index"">*i* - 1</sub>, *s*<sub class=""lower-index"">*i*</sub> &lt; *t*<sub class=""lower-index"">*i*</sub>.",OK,"from bisect import bisect_left, bisect_right
from collections import Counter, deque
from functools import lru_cache
from math import factorial, comb, sqrt, gcd, lcm
from copy import deepcopy
import heapq

def num_to_str(n):
    chushu = (n - 1) // 26
    yushu = (n - 1) % 26
    if chushu == 0:
        return chr(yushu + ord(""a""))
    else:
        return num_to_str(chushu) + chr(yushu + ord(""a""))

def main():
    t = input()
    s = input()
    t_num = 0
    s_num = 0
    index = 0
    for i in range(len(t) - 1, -1, -1):
        t_num += (ord(t[i]) - ord(""a"") + 1) * 26**index
        s_num += (ord(s[i]) - ord(""a"") + 1) * 26**index
        index += 1
    if s_num > t_num + 1:
        print(num_to_str(t_num + 1))
    else:
        print(""No such string"")

if __name__ == ""__main__"":
    main()","def find_between_strings(s, t):

    s_list = list(s)

    for i in range(len(s) - 1, -1, -1):

        if s_list[i] < 'z':
            s_list[i] = chr(ord(s_list[i]) + 1)

            candidate = ''.join(s_list)

            if candidate < t:
                return candidate
            else:
                break
        else:
            s_list[i] = 'a'
        
    return ""No such string""

import sys
input_lines = sys.stdin.read().strip().split('\n')

outputs = []
for i in range(0, len(input_lines), 2):
    s = input_lines[i].strip()
    t = input_lines[i + 1].strip()
    result = find_between_strings(s, t)
    outputs.append(result)

for output in outputs:
    print(output)"
600,B,Queries about less or equal elements,PROGRAMMING,"['binary search', 'data structures', 'sortings', 'two pointers']",You are given two arrays of integers *a* and *b*. For each element of the second array *b**j* you should find the number of elements in array *a* that are less than or equal to the value *b**j*.,"The first line contains two integers *n*,<=*m* (1<=≤<=*n*,<=*m*<=≤<=2·105) — the sizes of arrays *a* and *b*.

The second line contains *n* integers — the elements of array *a* (<=-<=109<=≤<=*a**i*<=≤<=109).

The third line contains *m* integers — the elements of array *b* (<=-<=109<=≤<=*b**j*<=≤<=109).","Print *m* integers, separated by spaces: the *j*-th of which is equal to the number of such elements in array *a* that are less than or equal to the value *b**j*.","['5 4\n1 3 5 7 9\n6 4 2 8\n', '5 5\n1 2 1 2 5\n3 1 4 1 5\n']","['3 2 1 4\n', '4 2 4 2 5\n']",none,TIME_LIMIT_EXCEEDED,"def qu(a,b):
    l=[]
    for i in b:
        c=0
        for j in a:
            if j<=i:
                c+=1
        l.append(c)
    return l

a,b=map(int,input().split())
p=list(map(int,input().split()))
q=list(map(int,input().split()))
ans=qu(p,q)
for i in ans:
    print(i,end="" "")","def count_less_equal(n, m, a, b):

    a.sort()
    results = []
    
    for value in b:

        count = binary_search_count(a, value)
        results.append(count)
    
    return results

def binary_search_count(a, value):

    left, right = 0, len(a)
    while left < right:
        mid = (left + right) // 2
        if a[mid] <= value:
            left = mid + 1
        else:
            right = mid
    return left

n, m = map(int, input().split())
a = list(map(int, input().split()))
b = list(map(int, input().split()))

results = count_less_equal(n, m, a, b)

print("" "".join(map(str, results)))"
180,C,Letter,PROGRAMMING,['dp'],"Patrick has just finished writing a message to his sweetheart Stacey when he noticed that the message didn't look fancy. Patrick was nervous while writing the message, so some of the letters there were lowercase and some of them were uppercase.

Patrick believes that a message is fancy if any uppercase letter stands to the left of any lowercase one. In other words, this rule describes the strings where first go zero or more uppercase letters, and then — zero or more lowercase letters.

To make the message fancy, Patrick can erase some letter and add the same letter in the same place in the opposite case (that is, he can replace an uppercase letter with the lowercase one and vice versa). Patrick got interested in the following question: what minimum number of actions do we need to make a message fancy? Changing a letter's case in the message counts as one action. Patrick cannot perform any other actions.",The only line of the input contains a non-empty string consisting of uppercase and lowercase letters. The string's length does not exceed 105.,Print a single number — the least number of actions needed to make the message fancy.,"['PRuvetSTAaYA\n', 'OYPROSTIYAOPECHATALSYAPRIVETSTASYA\n', 'helloworld\n']","['5\n', '0\n', '0\n']",none,COMPILATION_ERROR,"s = input()
n = len(s)

p, q = 0, n-1

p_u, p_l, q_u, q_l = 0, 0, 0, 0

ans = 0

def check():
return (p_u == p_l or p_u == p_l+1) and (q_u == q_l or q_u == q_l+1)

while p <= q:
c1, c2 = s[p], s[q]

if c1.isalpha() and c1.isupper() and c2.isalpha() and c2.islower():
    p_u += 1
    q_l += 1
    ans += 1

elif c1.isalpha() and c1.islower() and c2.isalpha() and c2.isupper():
    p_l += 1
    q_u += 1
    ans += 1

if not c1.isupper():
    p += 1
if not c2.islower():
    q -= 1

if not check():
    ans += 1

    if p_l < p_u:
        p_l += 1
    else:
        p_u += 1

    if q_l < q_u:
        q_u -= 1
    else:
        q_l -= 1
print(ans)

u","def min_actions_to_fancy_message(s):

    upper_count = 0
    lower_count = 0

    for char in s:
        if char.isupper():
            upper_count += 1
        else:
            lower_count += 1

    return min(upper_count, lower_count)

messages = ['PRuvetSTAaYA', 'OYPROSTIYAOPECHATALSYAPRIVETSTASYA', 'helloworld']

results = [min_actions_to_fancy_message(message) for message in messages]
print([f""{result}\n"" for result in results])"
59,A,Word,PROGRAMMING,"['implementation', 'strings']","Vasya is very upset that many people on the Net mix uppercase and lowercase letters in one word. That's why he decided to invent an extension for his favorite browser that would change the letters' register in every word so that it either only consisted of lowercase letters or, vice versa, only of uppercase ones. At that as little as possible letters should be changed in the word. For example, the word HoUse must be replaced with house, and the word ViP — with VIP. If a word contains an equal number of uppercase and lowercase letters, you should replace all the letters with lowercase ones. For example, maTRIx should be replaced by matrix. Your task is to use the given method on one given word.",The first line contains a word *s* — it consists of uppercase and lowercase Latin letters and possesses the length from 1 to 100.,"Print the corrected word *s*. If the given word *s* has strictly more uppercase letters, make the word written in the uppercase register, otherwise - in the lowercase one.","['HoUse\n', 'ViP\n', 'maTRIx\n']","['house\n', 'VIP\n', 'matrix\n']",none,WRONG_ANSWER,"def fix_case(s):
    uppercase_count = sum(1 for c in s if c.isupper())

    if uppercase_count > len(s) // 2:
        s = s.upper()
    else:
        s = s.lower()

    return s

word = input(""Введите слово: "")

print(fix_case(word))","def correct_case(word):

    upper_count = sum(1 for c in word if c.isupper())
    lower_count = len(word) - upper_count

    if upper_count > lower_count:
        return word.upper()
    else:
        return word.lower()

input_words = ['HoUse', 'ViP', 'maTRIx']

output_words = [correct_case(word) for word in input_words]

for word in output_words:
    print(word)"
177,E1,Space Voyage,PROGRAMMING,['binary search'],"The Smart Beaver from ABBYY plans a space travel on an ultramodern spaceship. During the voyage he plans to visit *n* planets. For planet *i* *a**i* is the maximum number of suitcases that an alien tourist is allowed to bring to the planet, and *b**i* is the number of citizens on the planet.

The Smart Beaver is going to bring some presents from ABBYY to the planets he will be visiting. The presents are packed in suitcases, *x* presents in each. The Beaver will take to the ship exactly *a*1<=+<=...<=+<=*a**n* suitcases.

As the Beaver lands on the *i*-th planet, he takes *a**i* suitcases and goes out. On the first day on the planet the Beaver takes a walk and gets to know the citizens. On the second and all subsequent days the Beaver gives presents to the citizens — each of the *b**i* citizens gets one present per day. The Beaver leaves the planet in the evening of the day when the number of presents left is strictly less than the number of citizens (i.e. as soon as he won't be able to give away the proper number of presents the next day). He leaves the remaining presents at the hotel.

The Beaver is going to spend exactly *c* days traveling. The time spent on flights between the planets is considered to be zero. In how many ways can one choose the positive integer *x* so that the planned voyage will take exactly *c* days?","The first input line contains space-separated integers *n* and *c* — the number of planets that the Beaver is going to visit and the number of days he is going to spend traveling, correspondingly.

The next *n* lines contain pairs of space-separated integers *a**i*,<=*b**i* (1<=≤<=*i*<=≤<=*n*) — the number of suitcases he can bring to the *i*-th planet and the number of citizens of the *i*-th planet, correspondingly.

The input limitations for getting 30 points are: 
 -  1<=≤<=*n*<=≤<=100 -  1<=≤<=*a**i*<=≤<=100 -  1<=≤<=*b**i*<=≤<=100 -  1<=≤<=*c*<=≤<=100 
The input limitations for getting 100 points are: 
 -  1<=≤<=*n*<=≤<=104 -  0<=≤<=*a**i*<=≤<=109 -  1<=≤<=*b**i*<=≤<=109 -  1<=≤<=*c*<=≤<=109 
Due to possible overflow, it is recommended to use the 64-bit arithmetic. In some solutions even the 64-bit arithmetic can overflow. So be careful in calculations!","Print a single number *k* — the number of ways to choose *x* so as to travel for exactly *c* days. If there are infinitely many possible values of *x*, print -1.

Please do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use cin, cout streams or the %I64d specifier.",['2 5\n1 5\n2 4\n'],['1\n'],"In the first example there is only one suitable value *x* = 5. Then the Beaver takes 1 suitcase with 5 presents to the first planet. Here he spends 2 days: he hangs around on the first day, and he gives away five presents on the second day. He takes 2 suitcases with 10 presents to the second planet. Here he spends 3 days — he gives away 4 presents on the second and the third days and leaves the remaining 2 presents at the hotel. In total, the Beaver spends 5 days traveling.

For *x* = 4 or less the Beaver won't have enough presents for the second day on the first planet, so the voyage will end too soon. For *x* = 6 and more the Beaver will spend at least one more day on the second planet, and the voyage will take too long.",WRONG_ANSWER,"n,c=list(map(int,input().split()))
d,lis,m=c-n,[],0
def check(x):
    days=0
    for ele in lis:
        y=(x*ele[0])//ele[1]
        if(y>d or days>d):
            return days+y
        days+=y
    return days
for _ in range(n):
    lis.append(list(map(int,input().split())))
low,high=0,1000000000    
while low<=high:
    mid=low+(high-low)//2
    c=check(mid)
    if(c>d):
        high=mid-1
    elif(c<d):
        low=mid+1
    else:
        mn=mid
        high=mid-1
low,high=0,1000000000
while low<=high:
    mid=low+(high-low)//2
    c=check(mid)
    if(c>d):
        high=mid-1
    elif(c<d):
        low=mid+1
    else:
        mx=mid
        low=mid+1
print(mx-mn+1)","def calculate_days(a, b, x):
    total_days = 0
    for ai, bi in zip(a, b):
        total_days += 1
        presents = ai * x

        if presents < bi:
            return float('inf')
        total_days += presents // bi
        if presents % bi > 0:
            total_days += 1
    return total_days

def find_ways(n, c, a, b):
    low, high = 1, 10**18
    while low < high:
        mid = (low + high) // 2
        days = calculate_days(a, b, mid)
        if days < c:
            low = mid + 1
        else:
            high = mid

    if calculate_days(a, b, low) == c:

        if calculate_days(a, b, low + 1) == c:
            return -1
        return 1
    return 0

import sys

input_data = sys.stdin.read().strip().split('\n')
n, c = map(int, input_data[0].split())
a = []
b = []

for i in range(1, n + 1):
    ai, bi = map(int, input_data[i].split())
    a.append(ai)
    b.append(bi)

result = find_ways(n, c, a, b)
print(result)"
0,none,none,none,['none'],"Eighth-grader Vova is on duty today in the class. After classes, he went into the office to wash the board, and found on it the number *n*. He asked what is this number and the teacher of mathematics Inna Petrovna answered Vova that *n* is the answer to the arithmetic task for first-graders. In the textbook, a certain positive integer *x* was given. The task was to add *x* to the sum of the digits of the number *x* written in decimal numeral system.

Since the number *n* on the board was small, Vova quickly guessed which *x* could be in the textbook. Now he wants to get a program which will search for arbitrary values of the number *n* for all suitable values of *x* or determine that such *x* does not exist. Write such a program for Vova.",The first line contains integer *n* (1<=≤<=*n*<=≤<=109).,"In the first line print one integer *k* — number of different values of *x* satisfying the condition. 

In next *k* lines print these values in ascending order.","['21\n', '20\n']","['1\n15\n', '0\n']","In the first test case *x* = 15 there is only one variant: 15 + 1 + 5 = 21.

In the second test case there are no such *x*.",TIME_LIMIT_EXCEEDED,"def f(n):
    ans = n
    while n:
        ans += n % 10
        n //= 10
    return ans
n = int(input())
a = []
for i in range(max(1, n - 100, n)):
    if f(i) == n:
        a.append(i)
print(len(a))
for item in a:
    print(item, end = ' ')","def sum_of_digits(x):

    return sum(int(digit) for digit in str(x))

def find_possible_x(n):

    possible_x = []

    for x in range(max(1, n - 100), n + 1):
        if n == x + sum_of_digits(x):
            possible_x.append(x)

    return possible_x

n = int(input().strip())

result = find_possible_x(n)

print(len(result))
for x in result:
    print(x)"
457,A,Golden System,PROGRAMMING,"['math', 'meet-in-the-middle']","Piegirl got bored with binary, decimal and other integer based counting systems. Recently she discovered some interesting properties about number , in particular that *q*2<==<=*q*<=+<=1, and she thinks it would make a good base for her new unique system. She called it ""golden system"". In golden system the number is a non-empty string containing 0's and 1's as digits. The decimal value of expression *a*0*a*1...*a**n* equals to .

Soon Piegirl found out that this system doesn't have same properties that integer base systems do and some operations can not be performed on it. She wasn't able to come up with a fast way of comparing two numbers. She is asking for your help.

Given two numbers written in golden system notation, determine which of them has larger decimal value.",Input consists of two lines — one for each number. Each line contains non-empty string consisting of '0' and '1' characters. The length of each string does not exceed 100000.,"Print ""&gt;"" if the first number is larger, ""&lt;"" if it is smaller and ""="" if they are equal.","['1000\n111\n', '00100\n11\n', '110\n101\n']","['&lt;\n', '=\n', '&gt;\n']","In the first example first number equals to <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/9c955eec678d6e7dcdc7c94fb203e922d2ad19ad.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>, while second number is approximately 1.618033988<sup class=""upper-index"">2</sup> + 1.618033988 + 1 ≈ 5.236, which is clearly a bigger number.

In the second example numbers are equal. Each of them is  ≈ 2.618.",RUNTIME_ERROR,"from itertools import dropwhile, chain

def main():
    zeroes = lambda a: not a
    a, b = [list(chain([0, 0], dropwhile(zeroes, map(int, input()))))
            for _ in range(2)]

    def tofib(l):
        i = 0
        while i < len(l):
            if l[i] > 0 and l[i + 1] > 0:
                l[i] -= 1
                l[i + 1] -= 1
                l[i - 1] += 1
                i -= 3
            i += 1
        return l

    a = list(dropwhile(zeroes, tofib(a)))
    b = list(dropwhile(zeroes, tofib(b)))

    if len(a) < len(b):
        print('<')
        return
    if len(a) > len(b):
        print('>')
        return
    for i in range(len(a)):
        if a[i] < b[i]:
            print('<')
            return
        if a[i] > b[i]:
            print('>')
            return
    print('=')

if __name__ == '__main__':
    main()","def golden_to_decimal(golden_num):
    """"""Convert a golden system number to its decimal value.""""""
    decimal_value = 0.0
    golden_ratio = (1 + 5 ** 0.5) / 2
    for index, digit in enumerate(reversed(golden_num)):
        if digit == '1':
            decimal_value += golden_ratio ** index
    return decimal_value

def compare_golden_numbers(num1, num2):
    """"""Compare two numbers in golden system notation.""""""
    decimal1 = golden_to_decimal(num1)
    decimal2 = golden_to_decimal(num2)
    
    if decimal1 > decimal2:
        return "">""
    elif decimal1 < decimal2:
        return ""<""
    else:
        return ""=""

if __name__ == ""__main__"":

    num1 = input().strip()
    num2 = input().strip()

    result = compare_golden_numbers(num1, num2)
    print(result)"
275,A,Lights Out,PROGRAMMING,['implementation'],"Lenny is playing a game on a 3<=×<=3 grid of lights. In the beginning of the game all lights are switched on. Pressing any of the lights will toggle it and all side-adjacent lights. The goal of the game is to switch all the lights off. We consider the toggling as follows: if the light was switched on then it will be switched off, if it was switched off then it will be switched on.

Lenny has spent some time playing with the grid and by now he has pressed each light a certain number of times. Given the number of times each light is pressed, you have to print the current state of each light.",The input consists of three rows. Each row contains three integers each between 0 to 100 inclusive. The *j*-th number in the *i*-th row is the number of times the *j*-th light of the *i*-th row of the grid is pressed.,"Print three lines, each containing three characters. The *j*-th character of the *i*-th line is ""1"" if and only if the corresponding light is switched on, otherwise it's ""0"".","['1 0 0\n0 0 0\n0 0 1\n', '1 0 1\n8 8 8\n2 0 3\n']","['001\n010\n100\n', '010\n011\n100\n']",none,OK,"def final_state(lights) :
    state = [[1 for i in range(3)]for j in range(3)]
    drow,dcol = [-1,0,1,0],[0,-1,0,1]

    for i in range(3) :
        for j in range(3) :
            time = lights[i][j]
            for t in range(time) :
                state[i][j] = 1 - state[i][j]
                for k in range(4) :
                    nrow,ncol = drow[k] + i, dcol[k] + j
                    if nrow >= 0 and ncol >= 0 and nrow < 3 and ncol < 3 :
                        state[nrow][ncol] = 1 - state[nrow][ncol]

    return state

def get_input() :
    lights = []
    for i in range(3) :
        x,y,z = map(int,input().split())
        lights.append([x,y,z])
    return lights

def print_output(op) :
    for i in range(3) :
        for j in range(3) :
            print(op[i][j],end = '')
        print()

print_output(final_state(get_input()))","def toggle_lights(grid):

    state = [[1 for _ in range(3)] for _ in range(3)]

    directions = [(0, 0), (0, 1), (1, 0), (0, -1), (-1, 0)]

    for i in range(3):
        for j in range(3):
            presses = grid[i][j]

            if presses % 2 == 1:
                for dx, dy in directions:
                    ni, nj = i + dx, j + dy

                    if 0 <= ni < 3 and 0 <= nj < 3:
                        state[ni][nj] = 1 - state[ni][nj]
    
    return state

def print_state(state):

    for row in state:
        print(''.join(str(light) for light in row))

input_lines = [input().strip() for _ in range(3)]
grid = [[int(num) for num in line.split()] for line in input_lines]

result_state = toggle_lights(grid)

print_state(result_state)"
115,A,Party,PROGRAMMING,"['dfs and similar', 'graphs', 'trees']","A company has *n* employees numbered from 1 to *n*. Each employee either has no immediate manager or exactly one immediate manager, who is another employee with a different number. An employee *A* is said to be the superior of another employee *B* if at least one of the following is true:
 -  Employee *A* is the immediate manager of employee *B* -  Employee *B* has an immediate manager employee *C* such that employee *A* is the superior of employee *C*. 
The company will not have a managerial cycle. That is, there will not exist an employee who is the superior of his/her own immediate manager.

Today the company is going to arrange a party. This involves dividing all *n* employees into several groups: every employee must belong to exactly one group. Furthermore, within any single group, there must not be two employees *A* and *B* such that *A* is the superior of *B*.

What is the minimum number of groups that must be formed?","The first line contains integer *n* (1<=≤<=*n*<=≤<=2000) — the number of employees.

The next *n* lines contain the integers *p**i* (1<=≤<=*p**i*<=≤<=*n* or *p**i*<==<=-1). Every *p**i* denotes the immediate manager for the *i*-th employee. If *p**i* is -1, that means that the *i*-th employee does not have an immediate manager. 

It is guaranteed, that no employee will be the immediate manager of him/herself (*p**i*<=≠<=*i*). Also, there will be no managerial cycles.",Print a single integer denoting the minimum number of groups that will be formed in the party.,['5\n-1\n1\n2\n1\n-1\n'],['3\n'],"For the first example, three groups are sufficient, for example: 
 -  Employee 1 -  Employees 2 and 4 -  Employees 3 and 5",OK,"from collections import defaultdict,deque

n = int(input())
adj_list = defaultdict(list)

for i in range(1,n+1):
    adj_list[int(input())].append(i)

def bfs(queue):
    depth = 0

    while queue:
        depth += 1
        k = len(queue)

        for j in range(k):
            temp = queue.popleft()

            for child in adj_list[temp]:
                queue.append(child)

    return depth

print(bfs(deque(adj_list[-1])))","def minimum_groups(n, managers):
    from collections import defaultdict, deque

    graph = defaultdict(list)
    roots = []
    for i in range(n):
        if managers[i] == -1:
            roots.append(i + 1)
        else:
            graph[managers[i]].append(i + 1)

    def bfs_depth(start):
        queue = deque([start])
        depth = 0
        while queue:
            size = len(queue)
            for _ in range(size):
                current = queue.popleft()
                for neighbor in graph[current]:
                    queue.append(neighbor)
            depth += 1
        return depth

    max_depth = 0
    for root in roots:
        max_depth = max(max_depth, bfs_depth(root))

    return max_depth

n = int(input().strip())
managers = [int(input().strip()) for _ in range(n)]

print(minimum_groups(n, managers))"
520,B,Two Buttons,PROGRAMMING,"['dfs and similar', 'graphs', 'greedy', 'implementation', 'math', 'shortest paths']","Vasya has found a strange device. On the front panel of a device there are: a red button, a blue button and a display showing some positive integer. After clicking the red button, device multiplies the displayed number by two. After clicking the blue button, device subtracts one from the number on the display. If at some point the number stops being positive, the device breaks down. The display can show arbitrarily large numbers. Initially, the display shows number *n*.

Bob wants to get number *m* on the display. What minimum number of clicks he has to make in order to achieve this result?","The first and the only line of the input contains two distinct integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=104), separated by a space .",Print a single number — the minimum number of times one needs to push the button required to get the number *m* out of number *n*.,"['4 6\n', '10 1\n']","['2\n', '9\n']","In the first example you need to push the blue button once, and then push the red button once.

In the second example, doubling the number is unnecessary, so we need to push the blue button nine times.",OK,"def Two_Buttons(n, m):
    if n >= m:
        return n - m
    elif m % 2 == 0:
        return 1 + Two_Buttons(n, m // 2)
    else:
        return 1 + Two_Buttons(n, m + 1)

n, m = map(int, input().split())
print(Two_Buttons(n, m))","def min_clicks(n, m):
    clicks = 0

    if n >= m:
        return n - m

    while m > n:

        if m % 2 == 1:
            m += 1
        else:
            m //= 2
        clicks += 1

    clicks += n - m
    return clicks

input_line = input().strip()
n, m = map(int, input_line.split())

result = min_clicks(n, m)
print(result)"
847,E,Packmen,PROGRAMMING,"['binary search', 'dp']","A game field is a strip of 1<=×<=*n* square cells. In some cells there are Packmen, in some cells — asterisks, other cells are empty.

Packman can move to neighboring cell in 1 time unit. If there is an asterisk in the target cell then Packman eats it. Packman doesn't spend any time to eat an asterisk.

In the initial moment of time all Packmen begin to move. Each Packman can change direction of its move unlimited number of times, but it is not allowed to go beyond the boundaries of the game field. Packmen do not interfere with the movement of other packmen; in one cell there can be any number of packmen moving in any directions.

Your task is to determine minimum possible time after which Packmen can eat all the asterisks.","The first line contains a single integer *n* (2<=≤<=*n*<=≤<=105) — the length of the game field.

The second line contains the description of the game field consisting of *n* symbols. If there is symbol '.' in position *i* — the cell *i* is empty. If there is symbol '*' in position *i* — in the cell *i* contains an asterisk. If there is symbol 'P' in position *i* — Packman is in the cell *i*.

It is guaranteed that on the game field there is at least one Packman and at least one asterisk.",Print minimum possible time after which Packmen can eat all asterisks.,"['7\n*..P*P*\n', '10\n.**PP.*P.*\n']","['3\n', '2\n']","In the first example Packman in position 4 will move to the left and will eat asterisk in position 1. He will spend 3 time units on it. During the same 3 time units Packman in position 6 will eat both of neighboring with it asterisks. For example, it can move to the left and eat asterisk in position 5 (in 1 time unit) and then move from the position 5 to the right and eat asterisk in the position 7 (in 2 time units). So in 3 time units Packmen will eat all asterisks on the game field.

In the second example Packman in the position 4 will move to the left and after 2 time units will eat asterisks in positions 3 and 2. Packmen in positions 5 and 8 will move to the right and in 2 time units will eat asterisks in positions 7 and 10, respectively. So 2 time units is enough for Packmen to eat all asterisks on the game field.",RUNTIME_ERROR,"import sys

sys.setrecursionlimit(2 * 10 ** 6)

def test():
    pass

def main():
    N = int(input())
    for _ in range(N):
        n = int(input())
        par = list(map(int, input().split()))
        lrs = []
        for _ in range(n):
            l, r = map(int, input().split())
            lrs.append((l, r))
        chs = [[] for _ in range(n)]
        for i, p in enumerate(par):
            chs[p - 1].append(i + 1)

        def dfs(i):
            if chs[i]:
                ans = 0
                ms = 0
                for j in chs[i]:
                    c, m = dfs(j)
                    ms += m
                    ans += c
                if ms < lrs[i][0]:
                    ans += 1
                    ms = lrs[i][1]
                ms = min(ms, lrs[i][1])
                return ans, ms
            else:
                return 1, lrs[i][1]

        print(dfs(0)[0])

def init():
    import sys
    import os
    if 'CP_LOCAL_ENV' in os.environ:
        test()
        sys.stdin = open('test.txt')

if __name__ == '__main__':
    init()
    main()","def min_time_to_eat_asterisks(n, field):
    packmen_positions = []
    asterisk_positions = []

    for i in range(n):
        if field[i] == 'P':
            packmen_positions.append(i)
        elif field[i] == '*':
            asterisk_positions.append(i)

    max_time = 0

    for asterisk in asterisk_positions:

        closest_time = min(abs(asterisk - packman) for packman in packmen_positions)
        max_time = max(max_time, closest_time)

    return max_time

if __name__ == ""__main__"":
    import sys
    input_data = sys.stdin.read().strip().split('\n')
    n = int(input_data[0])
    field = input_data[1]
    
    result = min_time_to_eat_asterisks(n, field)
    print(result)"
870,C,Maximum splitting,PROGRAMMING,"['dp', 'greedy', 'math', 'number theory']","You are given several queries. In the *i*-th query you are given a single positive integer *n**i*. You are to represent *n**i* as a sum of maximum possible number of composite summands and print this maximum number, or print -1, if there are no such splittings.

An integer greater than 1 is composite, if it is not prime, i.e. if it has positive divisors not equal to 1 and the integer itself.","The first line contains single integer *q* (1<=≤<=*q*<=≤<=105) — the number of queries.

*q* lines follow. The (*i*<=+<=1)-th line contains single integer *n**i* (1<=≤<=*n**i*<=≤<=109) — the *i*-th query.","For each query print the maximum possible number of summands in a valid splitting to composite summands, or -1, if there are no such splittings.","['1\n12\n', '2\n6\n8\n', '3\n1\n2\n3\n']","['3\n', '1\n2\n', '-1\n-1\n-1\n']","12 = 4 + 4 + 4 = 4 + 8 = 6 + 6 = 12, but the first splitting has the maximum possible number of summands.

8 = 4 + 4, 6 can't be split into several composite summands.

1, 2, 3 are less than any composite number, so they do not have valid splittings.",WRONG_ANSWER,"def isComposite(n):
    if (n <= 1):
        return False
    if (n <= 3):
        return False
    if (n % 2 == 0 or n % 3 == 0):
        return True
    i = 5
    while(i * i <= n):
         
        if (n % i == 0 or n % (i + 2) == 0):
            return True
        i = i + 6
         
    return False
for i in range(int(input())):
    n=int(input())
    u=[]
    for i in range(1,n+1):
        if n%i==0 and isComposite(i)==True:
            u.append(i)
    if len(u)==0:
        print(-1)
    else:
        print(n//u[0])","def is_composite(n):
    """"""Check if a number is composite.""""""
    if n < 4:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return True
    return False

def max_composite_summands(n):
    """"""Return the maximum number of composite summands that sum to n.""""""
    if n < 4:
        return -1
    if n % 2 == 0:
        return n // 4
    elif n >= 9:
        return (n - 9) // 4 + 1
    return -1

import sys

input = sys.stdin.read
data = input().strip().split('\n')
q = int(data[0])

results = []
for i in range(1, q + 1):
    n = int(data[i])
    results.append(str(max_composite_summands(n)))

print(""\n"".join(results))"
593,A,2Char,PROGRAMMING,"['brute force', 'implementation']","Andrew often reads articles in his favorite magazine 2Char. The main feature of these articles is that each of them uses at most two distinct letters. Andrew decided to send an article to the magazine, but as he hasn't written any article, he just decided to take a random one from magazine 26Char. However, before sending it to the magazine 2Char, he needs to adapt the text to the format of the journal. To do so, he removes some words from the chosen article, in such a way that the remaining text can be written using no more than two distinct letters.

Since the payment depends from the number of non-space characters in the article, Andrew wants to keep the words with the maximum total length.","The first line of the input contains number *n* (1<=≤<=*n*<=≤<=100) — the number of words in the article chosen by Andrew. Following are *n* lines, each of them contains one word. All the words consist only of small English letters and their total length doesn't exceed 1000. The words are not guaranteed to be distinct, in this case you are allowed to use a word in the article as many times as it appears in the input.",Print a single integer — the maximum possible total length of words in Andrew's article.,"['4\nabb\ncacc\naaa\nbbb\n', '5\na\na\nbcbcb\ncdecdecdecdecdecde\naaaa\n']","['9', '6']","In the first sample the optimal way to choose words is {'abb', 'aaa', 'bbb'}.

In the second sample the word 'cdecdecdecdecdecde' consists of three distinct letters, and thus cannot be used in the article. The optimal answer is {'a', 'a', 'aaaa'}.",OK,"n = int(input())
words = [input().strip() for _ in range(n)]

max_length = 0

for char1 in 'abcdefghijklmnopqrstuvwxyz':
    for char2 in 'abcdefghijklmnopqrstuvwxyz':
        current_length = 0
        for word in words:
            valid = True
            for letter in word:
                if letter != char1 and letter != char2:
                    valid = False
                    break
            if valid:
                current_length += len(word)
        max_length = max(max_length, current_length)

print(max_length)","def max_length_two_distinct_letters(n, words):
    from collections import defaultdict

    def valid_words(letter1, letter2):
        total_length = 0
        for word in words:

            if all(c in (letter1, letter2) for c in word):
                total_length += len(word)
        return total_length

    unique_letters = set()

    for word in words:
        unique_letters.update(word)
    
    max_length = 0

    unique_letters = list(unique_letters)
    for i in range(len(unique_letters)):
        for j in range(i, len(unique_letters)):
            letter1 = unique_letters[i]
            letter2 = unique_letters[j]

            current_length = valid_words(letter1, letter2)
            max_length = max(max_length, current_length)

    return max_length

n = int(input())
words = [input().strip() for _ in range(n)]

print(max_length_two_distinct_letters(n, words))"
359,C,Prime Number,PROGRAMMING,"['math', 'number theory']","Simon has a prime number *x* and an array of non-negative integers *a*1,<=*a*2,<=...,<=*a**n*.

Simon loves fractions very much. Today he wrote out number  on a piece of paper. After Simon led all fractions to a common denominator and summed them up, he got a fraction: , where number *t* equals *x**a*1<=+<=*a*2<=+<=...<=+<=*a**n*. Now Simon wants to reduce the resulting fraction. 

Help him, find the greatest common divisor of numbers *s* and *t*. As GCD can be rather large, print it as a remainder after dividing it by number 1000000007 (109<=+<=7).","The first line contains two positive integers *n* and *x* (1<=≤<=*n*<=≤<=105, 2<=≤<=*x*<=≤<=109) — the size of the array and the prime number.

The second line contains *n* space-separated integers *a*1,<=*a*2,<=...,<=*a**n* (0<=≤<=*a*1<=≤<=*a*2<=≤<=...<=≤<=*a**n*<=≤<=109).",Print a single number — the answer to the problem modulo 1000000007 (109<=+<=7).,"['2 2\n2 2\n', '3 3\n1 2 3\n', '2 2\n29 29\n', '4 5\n0 0 0 0\n']","['8\n', '27\n', '73741817\n', '1\n']","In the first sample <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/7745f7cc87c6c5f753e3414fad9baa3b1e3fea48.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>. Thus, the answer to the problem is 8.

In the second sample, <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/acb3d7990f024100be499bcb59828fa6e23a867d.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>. The answer to the problem is 27, as 351 = 13·27, 729 = 27·27.

In the third sample the answer to the problem is 1073741824 *mod* 1000000007 = 73741817.

In the fourth sample <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/05a5fca3fb4690369838ff6dfeda521c959aa937.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>. Thus, the answer to the problem is 1.",WRONG_ANSWER,"MOD = 1000000007

def power(x, y, mod):
    result = 1
    while y:
        if y & 1:
            result = (result * x) % mod
        x = (x * x) % mod
        y >>= 1
    return result

n, x = map(int, input().split())
a = list(map(int, input().split()))

t = sum(a)
numerator = power(x, t, MOD)
denominator = 1
for ai in a:
    denominator = (denominator * power(ai + 1, MOD - 2, MOD)) % MOD

result = (numerator * denominator) % MOD
print(result)","import sys
from math import gcd

MOD = 1000000007

def main():

    n, x = map(int, sys.stdin.readline().strip().split())
    a = list(map(int, sys.stdin.readline().strip().split()))

    sum_a = sum(a)
    t = pow(x, sum_a, MOD)

    s = pow(x, n, MOD)

    gcd_value = gcd(s, t)

    print(gcd_value % MOD)

if __name__ == ""__main__"":
    main()"
958,E1,Guard Duty (easy),PROGRAMMING,"['brute force', 'geometry', 'greedy', 'math']","The Rebel fleet is afraid that the Empire might want to strike back again. Princess Heidi needs to know if it is possible to assign *R* Rebel spaceships to guard *B* bases so that every base has exactly one guardian and each spaceship has exactly one assigned base (in other words, the assignment is a perfect matching). Since she knows how reckless her pilots are, she wants to be sure that any two (straight) paths – from a base to its assigned spaceship – do not intersect in the galaxy plane (that is, in 2D), and so there is no risk of collision.","The first line contains two space-separated integers *R*,<=*B*(1<=≤<=*R*,<=*B*<=≤<=10). For 1<=≤<=*i*<=≤<=*R*, the *i*<=+<=1-th line contains two space-separated integers *x**i* and *y**i* (|*x**i*|,<=|*y**i*|<=≤<=10000) denoting the coordinates of the *i*-th Rebel spaceship. The following *B* lines have the same format, denoting the position of bases. It is guaranteed that no two points coincide and that no three points are on the same line.","If it is possible to connect Rebel spaceships and bases so as satisfy the constraint, output Yes, otherwise output No (without quote).","['3 3\n0 0\n2 0\n3 1\n-2 1\n0 3\n2 2\n', '2 1\n1 0\n2 2\n3 1\n']","['Yes\n', 'No\n']","For the first example, one possible way is to connect the Rebels and bases in order.

For the second example, there is no perfect matching between Rebels and bases.",OK,"def ccw(A, B, C):
    return (C[1] - A[1]) * (B[0] - A[0]) > (B[1] - A[1]) * (C[0] - A[0])

def intersect(A, B, C, D):
    return ccw(A, C, D) != ccw(B, C, D) and ccw(A, B, C) != ccw(A, B, D)

R, B = map(int, input().split())

rs = []
bs = []
for r in range(R):
    rs.append(list(map(int, input().split())))
for r in range(B):
    bs.append(list(map(int, input().split())))

if R != B:
    print('No')
else:
    def rec(at, done, remain):
        if at >= B:
            return True
        for b in remain:
            for r, d in zip(rs, done):
                if intersect(r, bs[d], rs[at], bs[b]):
                    break
            else:
                ok = rec(at + 1, done + [b], remain - {b})
                if ok:
                    return True
        return False

    print(['NO', 'YES'][rec(0, [], set(range(B)))])","def ccw(A, B, C):

    return (C[1] - A[1]) * (B[0] - A[0]) > (B[1] - A[1]) * (C[0] - A[0])

def intersects(A, B, C, D):

    return ccw(A, C, D) != ccw(B, C, D) and ccw(A, B, C) != ccw(A, B, D)

def can_assign_spaceships(R, B, rebels, bases):

    from itertools import permutations
    
    for perm in permutations(rebels):

        collision = False
        for i in range(B):
            for j in range(i + 1, B):
                if intersects(rebels[perm[i]], bases[i], rebels[perm[j]], bases[j]):
                    collision = True
                    break
            if collision:
                break
        if not collision:
            return ""Yes""
    return ""No""

import sys
input_data = sys.stdin.read().strip().split('\n')

R, B = map(int, input_data[0].split())
rebels = [tuple(map(int, input_data[i + 1].split())) for i in range(R)]
bases = [tuple(map(int, input_data[i + R + 1].split())) for i in range(B)]

result = can_assign_spaceships(R, B, rebels, bases)
print(result)"
767,A,Snacktower,PROGRAMMING,"['data structures', 'implementation']","According to an old legeng, a long time ago Ankh-Morpork residents did something wrong to miss Fortune, and she cursed them. She said that at some time *n* snacks of distinct sizes will fall on the city, and the residents should build a Snacktower of them by placing snacks one on another. Of course, big snacks should be at the bottom of the tower, while small snacks should be at the top.

Years passed, and once different snacks started to fall onto the city, and the residents began to build the Snacktower.

However, they faced some troubles. Each day exactly one snack fell onto the city, but their order was strange. So, at some days the residents weren't able to put the new stack on the top of the Snacktower: they had to wait until all the bigger snacks fell. Of course, in order to not to anger miss Fortune again, the residents placed each snack on the top of the tower immediately as they could do it.

Write a program that models the behavior of Ankh-Morpork residents.","The first line contains single integer *n* (1<=≤<=*n*<=≤<=100<=000) — the total number of snacks.

The second line contains *n* integers, the *i*-th of them equals the size of the snack which fell on the *i*-th day. Sizes are distinct integers from 1 to *n*.","Print *n* lines. On the *i*-th of them print the sizes of the snacks which the residents placed on the top of the Snacktower on the *i*-th day in the order they will do that. If no snack is placed on some day, leave the corresponding line empty.","['3\n3 1 2\n', '5\n4 5 1 2 3\n']","['3\n\xa0\n2 1', '5 4\n\xa0\n\xa0\n3 2 1\n']","In the example a snack of size 3 fell on the first day, and the residents immediately placed it. On the second day a snack of size 1 fell, and the residents weren't able to place it because they were missing the snack of size 2. On the third day a snack of size 2 fell, and the residents immediately placed it. Right after that they placed the snack of size 1 which had fallen before.",OK,"import sys
import heapq

def main(arr):
    visited = [False] * len(arr)
    last = len(visited) - 1

    for n in arr:
        visited[n - 1] = True
        doing = []
        while last >= 0 and visited[last]:
            doing.append(last + 1)
            last -= 1

        print("" "".join(str(d) for d in doing))

if __name__ == ""__main__"":
    for e, line in enumerate(sys.stdin.readlines()):
        if e == 0:
            continue
        else:
            arr = list(map(int, line.strip().split()))

    main(arr)","n = int(input().strip())

snacks = list(map(int, input().strip().split()))

placed = set()

next_snack = n

for snack in snacks:

    placed.add(snack)

    current_placed = []

    while next_snack in placed:
        current_placed.append(next_snack)
        next_snack -= 1

    print("" "".join(map(str, current_placed)))"
614,A,Link/Cut Tree,PROGRAMMING,"['brute force', 'implementation']","Programmer Rostislav got seriously interested in the Link/Cut Tree data structure, which is based on Splay trees. Specifically, he is now studying the *expose* procedure.

Unfortunately, Rostislav is unable to understand the definition of this procedure, so he decided to ask programmer Serezha to help him. Serezha agreed to help if Rostislav solves a simple task (and if he doesn't, then why would he need Splay trees anyway?)

Given integers *l*, *r* and *k*, you need to print all powers of number *k* within range from *l* to *r* inclusive. However, Rostislav doesn't want to spent time doing this, as he got interested in playing a network game called Agar with Gleb. Help him!","The first line of the input contains three space-separated integers *l*, *r* and *k* (1<=≤<=*l*<=≤<=*r*<=≤<=1018, 2<=≤<=*k*<=≤<=109).","Print all powers of number *k*, that lie within range from *l* to *r* in the increasing order. If there are no such numbers, print ""-1"" (without the quotes).","['1 10 2\n', '2 4 5\n']","['1 2 4 8 ', '-1']","Note to the first sample: numbers 2<sup class=""upper-index"">0</sup> = 1, 2<sup class=""upper-index"">1</sup> = 2, 2<sup class=""upper-index"">2</sup> = 4, 2<sup class=""upper-index"">3</sup> = 8 lie within the specified range. The number 2<sup class=""upper-index"">4</sup> = 16 is greater then 10, thus it shouldn't be printed.",OK,"def x():
    l, r, k = [int(s) for s in input().split()]
    res = k
    if l == 1:
        yield 1
    while k<=r:
        if l <= k <= r:
            yield k
        k*=res
        if k>r:
            break
d = [i for i in x()]
if len(d):
    print(*d)
else:
    print(-1)","def find_powers_in_range(l, r, k):
    powers = []
    power = 1
    while power <= r:
        if l <= power <= r:
            powers.append(power)
        power *= k
    
    if powers:
        print("" "".join(map(str, powers)))
    else:
        print(""-1"")

l, r, k = map(int, input().split())
find_powers_in_range(l, r, k)"
429,A,Xor-tree,PROGRAMMING,"['dfs and similar', 'trees']","Iahub is very proud of his recent discovery, propagating trees. Right now, he invented a new tree, called xor-tree. After this new revolutionary discovery, he invented a game for kids which uses xor-trees.

The game is played on a tree having *n* nodes, numbered from 1 to *n*. Each node *i* has an initial value *init**i*, which is either 0 or 1. The root of the tree is node 1.

One can perform several (possibly, zero) operations on the tree during the game. The only available type of operation is to pick a node *x*. Right after someone has picked node *x*, the value of node *x* flips, the values of sons of *x* remain the same, the values of sons of sons of *x* flips, the values of sons of sons of sons of *x* remain the same and so on.

The goal of the game is to get each node *i* to have value *goal**i*, which can also be only 0 or 1. You need to reach the goal of the game by using minimum number of operations.","The first line contains an integer *n* (1<=≤<=*n*<=≤<=105). Each of the next *n*<=-<=1 lines contains two integers *u**i* and *v**i* (1<=≤<=*u**i*,<=*v**i*<=≤<=*n*; *u**i*<=≠<=*v**i*) meaning there is an edge between nodes *u**i* and *v**i*. 

The next line contains *n* integer numbers, the *i*-th of them corresponds to *init**i* (*init**i* is either 0 or 1). The following line also contains *n* integer numbers, the *i*-th number corresponds to *goal**i* (*goal**i* is either 0 or 1).","In the first line output an integer number *cnt*, representing the minimal number of operations you perform. Each of the next *cnt* lines should contain an integer *x**i*, representing that you pick a node *x**i*.",['10\n2 1\n3 1\n4 2\n5 1\n6 2\n7 5\n8 6\n9 8\n10 5\n1 0 1 1 0 1 0 1 0 1\n1 0 1 0 0 1 1 1 0 1\n'],['2\n4\n7\n'],none,RUNTIME_ERROR,"from collections import defaultdict, deque, Counter, OrderedDict
from bisect import insort, bisect_right, bisect_left
import threading, sys

def main():
    n = int(input())
    adj = [[] for i in range(n + 1)]
    for i in range(n - 1):
        a, b = map(int, input().split())
        a, b = a - 1, b - 1
        adj[a].append(b)
        adj[b].append(a)
    init = [int(i) for i in input().split()]
    goal = [int(i) for i in input().split()]
    visited = [0] * n
    par = [[] for i in range(n)]

    def dfs(s, p):
        if visited[s]: return
        visited[s] = 1
        par[p].append(s)
        for i in adj[s]:
            dfs(i, s)

    dfs(0, 0)
    par[0] = par[0][1:]
    ans = []

    def dfs2(s, l, fo, fe):
        if l % 2 == 0:
            if fe % 2 == 1:
                init[s] = 1 - init[s]
        else:
            if fo % 2 == 1:
                init[s] = 1 - init[s]
        if init[s] != goal[s]:
            ans.append(s + 1)
            if l % 2:
                fo += 1
            else:
                fe += 1
        for j in par[s]:
            dfs2(j, l + 1, fo, fe)

    dfs2(0, 0, 0, 0)

    print(len(ans))
    print(""\n"".join(map(str, ans)))

if __name__ == ""__main__"":
    sys.setrecursionlimit(200000)
    threading.stack_size(10240000)
    thread = threading.Thread(target=main)
    thread.start()","def xor_tree(n, edges, init, goal):
    from collections import defaultdict

    tree = defaultdict(list)
    for u, v in edges:
        tree[u].append(v)
        tree[v].append(u)

    operations = []

    def dfs(node, parent, flip):
        current_value = init[node - 1] ^ flip
        target_value = goal[node - 1]
        
        if current_value != target_value:
            operations.append(node)
            flip ^= 1
        
        for neighbor in tree[node]:
            if neighbor != parent:
                dfs(neighbor, node, flip)

    dfs(1, -1, 0)

    print(len(operations))
    for op in operations:
        print(op)

n = 10
edges = [(2, 1), (3, 1), (4, 2), (5, 1), (6, 2), (7, 5), (8, 6), (9, 8), (10, 5)]
init = [0, 1, 1, 0, 1, 0, 1, 0, 1, 1]
goal = [1, 0, 1, 0, 0, 1, 1, 1, 0, 1]

xor_tree(n, edges, init, goal)"
887,B,Cubes for Masha,PROGRAMMING,"['brute force', 'implementation']","Absent-minded Masha got set of *n* cubes for her birthday.

At each of 6 faces of each cube, there is exactly one digit from 0 to 9. Masha became interested what is the largest natural *x* such she can make using her new cubes all integers from 1 to *x*.

To make a number Masha can rotate her cubes and put them in a row. After that, she looks at upper faces of cubes from left to right and reads the number.

The number can't contain leading zeros. It's not required to use all cubes to build a number.

Pay attention: Masha can't make digit 6 from digit 9 and vice-versa using cube rotations.","In first line integer *n* is given (1<=≤<=*n*<=≤<=3) — the number of cubes, Masha got for her birthday.

Each of next *n* lines contains 6 integers *a**i**j* (0<=≤<=*a**i**j*<=≤<=9) — number on *j*-th face of *i*-th cube.",Print single integer — maximum number *x* such Masha can make any integers from 1 to *x* using her cubes or 0 if Masha can't make even 1.,"['3\n0 1 2 3 4 5\n6 7 8 9 0 1\n2 3 4 5 6 7\n', '3\n0 1 3 5 6 8\n1 2 4 5 7 8\n2 3 4 6 7 9\n']","['87', '98']","In the first test case, Masha can build all numbers from 1 to 87, but she can't make 88 because there are no two cubes with digit 8.",OK,"def list_input():
    return list(map(int, input().split()))

n = int(input())
c = list()
for i in range(n):
    c.append(list_input())

s = set()
for i in range(n):
    for x in c[i]:
        s.add(x)
if n >= 2:
    for i in range(n):
        for j in range(n):
            if i == j:
                continue
            for x in c[i]:
                for y in c[j]:
                    if x != 0:
                        s.add(x*10+y)
if n >= 3:
    for i in range(n):
        for j in range(n):
            if i == j:
                continue
            for k in range(n):
                if i == k or j == k:
                    continue
                for x in c[i]:
                    for y in c[j]:
                        for z in c[k]:
                            if x != 0:
                                s.add(x*100+y*10+z)
if 0 in s:
    s.remove(0)
res = 0
for x in s:
    if x == res+1:
        res += 1
    else:
        print(res)
        exit(0)
print(res)","def can_form_number(cubes, number):

    str_num = str(number)
    used = [False] * len(cubes)
    
    for digit in str_num:
        found = False
        for i, cube in enumerate(cubes):
            if not used[i] and int(digit) in cube:
                used[i] = True
                found = True
                break
        if not found:
            return False
    return True

def max_number(n, cubes):

    max_number_possible = 10 ** n - 1
    for number in range(max_number_possible, 0, -1):
        if can_form_number(cubes, number):
            return number
    return 0

if __name__ == ""__main__"":
    import sys
    
    input_data = sys.stdin.read().strip().split('\n')
    n = int(input_data[0])
    cubes = [list(map(int, input_data[i + 1].split())) for i in range(n)]
    
    result = max_number(n, cubes)
    print(result)"
224,A,Parallelepiped,PROGRAMMING,"['brute force', 'geometry', 'math']",You've got a rectangular parallelepiped with integer edge lengths. You know the areas of its three faces that have a common vertex. Your task is to find the sum of lengths of all 12 edges of this parallelepiped.,The first and the single line contains three space-separated integers — the areas of the parallelepiped's faces. The area's values are positive (<=&gt;<=0) and do not exceed 104. It is guaranteed that there exists at least one parallelepiped that satisfies the problem statement.,Print a single number — the sum of all edges of the parallelepiped.,"['1 1 1\n', '4 6 6\n']","['12\n', '28\n']","In the first sample the parallelepiped has sizes 1 × 1 × 1, in the second one — 2 × 2 × 3.",OK,"import sys,os,io,time,copy
if os.path.exists('input.txt'):
    sys.stdin = open('input.txt', 'r')
    sys.stdout = open('output.txt', 'w')

import math

def is_int(n):
    if n//1==n/1:
        return True
    else:
        return False

def main():

    a,b,c=map(int,input().split())
    for i in range(1,10001):
        x=i
        y=a/i
        z=c/i
        if is_int(x) and is_int(y) and is_int(z) and y*z==b:
            print(4*int(x+y+z))
            break

main()","a, b, c = map(int, input().split())

import math

x = math.sqrt(a * b / c)
y = math.sqrt(a * c / b)
z = math.sqrt(b * c / a)

sum_of_edges = 4 * (x + y + z)

print(int(sum_of_edges))"
772,B,Volatile Kite,PROGRAMMING,['geometry'],"You are given a convex polygon *P* with *n* distinct vertices *p*1,<=*p*2,<=...,<=*p**n*. Vertex *p**i* has coordinates (*x**i*,<=*y**i*) in the 2D plane. These vertices are listed in clockwise order.

You can choose a real number *D* and move each vertex of the polygon a distance of at most *D* from their original positions.

Find the maximum value of *D* such that no matter how you move the vertices, the polygon does not intersect itself and stays convex.","The first line has one integer *n* (4<=≤<=*n*<=≤<=1<=000) — the number of vertices.

The next *n* lines contain the coordinates of the vertices. Line *i* contains two integers *x**i* and *y**i* (<=-<=109<=≤<=*x**i*,<=*y**i*<=≤<=109) — the coordinates of the *i*-th vertex. These points are guaranteed to be given in clockwise order, and will form a strictly convex polygon (in particular, no three consecutive points lie on the same straight line).","Print one real number *D*, which is the maximum real number such that no matter how you move the vertices, the polygon stays convex.

Your answer will be considered correct if its absolute or relative error does not exceed 10<=-<=6.

Namely, let's assume that your answer is *a* and the answer of the jury is *b*. The checker program will consider your answer correct if .","['4\n0 0\n0 1\n1 1\n1 0\n', '6\n5 0\n10 0\n12 -4\n10 -8\n5 -8\n3 -4\n']","['0.3535533906\n', '1.0000000000\n']","Here is a picture of the first sample

<img class=""tex-graphics"" src=""https://espresso.codeforces.com/f83aa076d2f437f9bb785cae769c3ae310eff351.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

Here is an example of making the polygon non-convex.

<img class=""tex-graphics"" src=""https://espresso.codeforces.com/fbadb81630251ca642bd4ddf9088876ade761630.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

This is not an optimal solution, since the maximum distance we moved one point is  ≈ 0.4242640687, whereas we can make it non-convex by only moving each point a distance of at most  ≈ 0.3535533906.",OK,"from math import inf

def vect(x, y):
    return abs(sum([x[i]*(y[(i+1)%3]-y[(i+2)%3]) for i in range(3)]))
def l(x, y):
    return ((x[0]-x[2])**2 + (y[0]-y[2])**2)**0.5
def h(x, y):
    return vect(x, y) / l(x, y)

n = int(input())
x = []
y = []
for i in range(n):
    a, b = [int(x) for x in input().split()]
    x.append(a)
    y.append(b)
x += x[:2]
y += y[:2]

dmin = inf
for i in range(n):
    d = h(x[i:i+3], y[i:i+3])/2
    if dmin > d:
        dmin = d

print(dmin)","import sys
import math

def distance(p1, p2):
    return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)

def check(D, points):
    n = len(points)
    for i in range(n):

        j = (i + 1) % n

        p1, p2 = points[i], points[j]

        ax, ay = p1[0] - D, p1[1] - D
        bx, by = p1[0] + D, p1[1] + D
        cx, cy = p2[0] - D, p2[1] - D
        dx, dy = p2[0] + D, p2[1] + D

        for k in range(n):
            if k != i and k != j:
                p3, p4 = points[k], points[(k + 1) % n]
                if segments_intersect((ax, ay), (bx, by), p3, p4) or segments_intersect((ax, ay), (by, dy), p3, p4):
                    return False
                if segments_intersect((cx, cy), (dx, dy), p3, p4) or segments_intersect((cx, cy), (dy, dx), p3, p4):
                    return False
    return True

def segments_intersect(p1, p2, p3, p4):

    def ccw(a, b, c):
        return (c[1] - a[1]) * (b[0] - a[0]) < (b[1] - a[1]) * (c[0] - a[0])

    return ccw(p1, p3, p4) != ccw(p2, p3, p4) and ccw(p1, p2, p3) != ccw(p1, p2, p4)

def binary_search(points):
    low, high = 0.0, 2 * 10**9
    while high - low > 1e-7:
        mid = (low + high) / 2.0
        if check(mid, points):
            low = mid
        else:
            high = mid
    return low

def main():
    input_data = sys.stdin.read().strip().split('\n')
    n = int(input_data[0])
    points = [tuple(map(int, line.split())) for line in input_data[1:n+1]]
    
    result = binary_search(points)
    print(f""{result:.10f}"")

if __name__ == ""__main__"":
    main()"
369,A,Valera and Plates,PROGRAMMING,"['greedy', 'implementation']","Valera is a lazy student. He has *m* clean bowls and *k* clean plates. 

Valera has made an eating plan for the next *n* days. As Valera is lazy, he will eat exactly one dish per day. At that, in order to eat a dish, he needs exactly one clean plate or bowl. We know that Valera can cook only two types of dishes. He can eat dishes of the first type from bowls and dishes of the second type from either bowls or plates. 

When Valera finishes eating, he leaves a dirty plate/bowl behind. His life philosophy doesn't let him eat from dirty kitchenware. So sometimes he needs to wash his plate/bowl before eating. Find the minimum number of times Valera will need to wash a plate/bowl, if he acts optimally.","The first line of the input contains three integers *n*, *m*, *k* (1<=≤<=*n*,<=*m*,<=*k*<=≤<=1000) — the number of the planned days, the number of clean bowls and the number of clean plates.

The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=2). If *a**i* equals one, then on day *i* Valera will eat a first type dish. If *a**i* equals two, then on day *i* Valera will eat a second type dish.",Print a single integer — the minimum number of times Valera will need to wash a plate/bowl.,"['3 1 1\n1 2 1\n', '4 3 1\n1 1 1 1\n', '3 1 2\n2 2 2\n', '8 2 2\n1 2 1 2 1 2 1 2\n']","['1\n', '1\n', '0\n', '4\n']","In the first sample Valera will wash a bowl only on the third day, so the answer is one.

In the second sample, Valera will have the first type of the dish during all four days, and since there are only three bowls, he will wash a bowl exactly once.

In the third sample, Valera will have the second type of dish for all three days, and as they can be eaten from either a plate or a bowl, he will never need to wash a plate/bowl.",OK,"n, m, k = list(map(int, input().split()))
a = list(map(int, input().split()))

def solve(n, m, k, a):
    cnt = 0

    for dish in a:
        if dish == 1:
            if m > 0:
                m -= 1
            else:
                cnt += 1
        else:
            if m == 0 and k == 0:
                cnt += 1
            elif k > 0:
                k -= 1
            else:
                m -= 1

    return cnt

print(solve(n, m, k, a))","n, m, k = map(int, input().split())
dishes = list(map(int, input().split()))

bowls_used = 0
plates_used = 0

for dish in dishes:
    if dish == 1:

        if bowls_used < m:
            bowls_used += 1
        else:

            bowls_used += 1
    else:

        if plates_used < k:
            plates_used += 1
        elif bowls_used < m:
            bowls_used += 1
        else:

            plates_used += 1

washes = max(0, bowls_used - m) + max(0, plates_used - k)

print(washes)"
4,A,Watermelon,PROGRAMMING,"['brute force', 'math']","One hot summer day Pete and his friend Billy decided to buy a watermelon. They chose the biggest and the ripest one, in their opinion. After that the watermelon was weighed, and the scales showed *w* kilos. They rushed home, dying of thirst, and decided to divide the berry, however they faced a hard problem.

Pete and Billy are great fans of even numbers, that's why they want to divide the watermelon in such a way that each of the two parts weighs even number of kilos, at the same time it is not obligatory that the parts are equal. The boys are extremely tired and want to start their meal as soon as possible, that's why you should help them and find out, if they can divide the watermelon in the way they want. For sure, each of them should get a part of positive weight.",The first (and the only) input line contains integer number *w* (1<=≤<=*w*<=≤<=100) — the weight of the watermelon bought by the boys.,"Print YES, if the boys can divide the watermelon into two parts, each of them weighing even number of kilos; and NO in the opposite case.",['8\n'],['YES\n'],"For example, the boys can divide the watermelon into two parts of 2 and 6 kilos respectively (another variant — two parts of 4 and 4 kilos).",OK,"def can_divide_watermelon(w):

    if w < 4:
        return ""NO""

    if w % 2 == 0:
        return ""YES""
    
    return ""NO""

w = int(input())

print(can_divide_watermelon(w))","def can_divide_watermelon(weight):

    if weight % 2 == 0 and weight > 2:
        return ""YES""
    else:
        return ""NO""

w = int(input().strip())

print(can_divide_watermelon(w))"
919,B,Perfect Number,PROGRAMMING,"['binary search', 'brute force', 'dp', 'implementation', 'number theory']","We consider a positive integer perfect, if and only if the sum of its digits is exactly $10$. Given a positive integer $k$, your task is to find the $k$-th smallest perfect positive integer.","A single line with a positive integer $k$ ($1 \leq k \leq 10\,000$).","A single number, denoting the $k$-th smallest perfect integer.","['1\n', '2\n']","['19\n', '28\n']",The first perfect integer is $19$ and the second one is $28$.,TIME_LIMIT_EXCEEDED,"n=int(input())
i=0
k=0
def s(x):
    x=list(str(x))
    x=list(map(int,x))
    return sum(x)
while(s(i)!=10 or k!=n):
    i=i+1
    if(s(i)==10):
        k=k+1
print(i)","def is_perfect(n):

    return sum(int(digit) for digit in str(n)) == 10

def find_kth_perfect(k):
    count = 0
    number = 0
    
    while count < k:
        number += 1
        if is_perfect(number):
            count += 1
    
    return number

k = int(input().strip())

print(find_kth_perfect(k))"
387,B,George and Round,PROGRAMMING,"['brute force', 'greedy', 'two pointers']","George decided to prepare a Codesecrof round, so he has prepared *m* problems for the round. Let's number the problems with integers 1 through *m*. George estimates the *i*-th problem's complexity by integer *b**i*.

To make the round good, he needs to put at least *n* problems there. Besides, he needs to have at least one problem with complexity exactly *a*1, at least one with complexity exactly *a*2, ..., and at least one with complexity exactly *a**n*. Of course, the round can also have problems with other complexities.

George has a poor imagination. It's easier for him to make some already prepared problem simpler than to come up with a new one and prepare it. George is magnificent at simplifying problems. He can simplify any already prepared problem with complexity *c* to any positive integer complexity *d* (*c*<=≥<=*d*), by changing limits on the input data.

However, nothing is so simple. George understood that even if he simplifies some problems, he can run out of problems for a good round. That's why he decided to find out the minimum number of problems he needs to come up with in addition to the *m* he's prepared in order to make a good round. Note that George can come up with a new problem of any complexity.","The first line contains two integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=3000) — the minimal number of problems in a good round and the number of problems George's prepared. The second line contains space-separated integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a*1<=&lt;<=*a*2<=&lt;<=...<=&lt;<=*a**n*<=≤<=106) — the requirements for the complexity of the problems in a good round. The third line contains space-separated integers *b*1,<=*b*2,<=...,<=*b**m* (1<=≤<=*b*1<=≤<=*b*2...<=≤<=*b**m*<=≤<=106) — the complexities of the problems prepared by George.",Print a single integer — the answer to the problem.,"['3 5\n1 2 3\n1 2 2 3 3\n', '3 5\n1 2 3\n1 1 1 1 1\n', '3 1\n2 3 4\n1\n']","['0\n', '2\n', '3\n']","In the first sample the set of the prepared problems meets the requirements for a good round.

In the second sample, it is enough to come up with and prepare two problems with complexities 2 and 3 to get a good round.

In the third sample it is very easy to get a good round if come up with and prepare extra problems with complexities: 2, 3, 4.",OK,"def main():
    nm=input().split(' ')
    s1=input().split(' ')
    s2=input().split(' ')
    n=int(nm[0])
    m=int(nm[1])
    j=0
    for i in range(len(s1)):
        while j<m and int(s2[j])<int(s1[i]):
           j+=1
        if j<m:
            n-=1
            j+=1
        else:
            break
    print(n)
if __name__ == ""__main__"":
    main()","def minimum_problems_needed(n, m, required_complexities, prepared_complexities):

    prepared_count = {}
    for b in prepared_complexities:
        if b in prepared_count:
            prepared_count[b] += 1
        else:
            prepared_count[b] = 1

    additional_problems = 0
    
    for a in required_complexities:
        if a not in prepared_count or prepared_count[a] == 0:

            additional_problems += 1
        else:

            prepared_count[a] -= 1

    total_problems = m + additional_problems
    if total_problems < n:

        additional_problems += n - total_problems

    return additional_problems

n, m = map(int, input().split())
required_complexities = list(map(int, input().split()))
prepared_complexities = list(map(int, input().split()))

result = minimum_problems_needed(n, m, required_complexities, prepared_complexities)
print(result)"
59,A,Word,PROGRAMMING,"['implementation', 'strings']","Vasya is very upset that many people on the Net mix uppercase and lowercase letters in one word. That's why he decided to invent an extension for his favorite browser that would change the letters' register in every word so that it either only consisted of lowercase letters or, vice versa, only of uppercase ones. At that as little as possible letters should be changed in the word. For example, the word HoUse must be replaced with house, and the word ViP — with VIP. If a word contains an equal number of uppercase and lowercase letters, you should replace all the letters with lowercase ones. For example, maTRIx should be replaced by matrix. Your task is to use the given method on one given word.",The first line contains a word *s* — it consists of uppercase and lowercase Latin letters and possesses the length from 1 to 100.,"Print the corrected word *s*. If the given word *s* has strictly more uppercase letters, make the word written in the uppercase register, otherwise - in the lowercase one.","['HoUse\n', 'ViP\n', 'maTRIx\n']","['house\n', 'VIP\n', 'matrix\n']",none,OK,"n =input()
up = 0 ; low = 0
for i in n:
    if i.isupper():
        up+=1
    else:
        low+=1
if up > low:
    print(n.upper())
elif up < low:
    print(n.lower())
else: print(n.lower())","def correct_case(word):

    upper_count = sum(1 for c in word if c.isupper())
    lower_count = len(word) - upper_count

    if upper_count > lower_count:
        return word.upper()
    else:
        return word.lower()

words = ['HoUse', 'ViP', 'maTRIx']

corrected_words = [correct_case(word) for word in words]
for corrected_word in corrected_words:
    print(corrected_word)"
887,A,Div. 64,PROGRAMMING,['implementation'],"Top-model Izabella participates in the competition. She wants to impress judges and show her mathematical skills.

Her problem is following: for given string, consisting of only 0 and 1, tell if it's possible to remove some digits in such a way, that remaining number is a representation of some positive integer, divisible by 64, in the binary numerical system.",In the only line given a non-empty binary string *s* with length up to 100.,Print «yes» (without quotes) if it's possible to remove digits required way and «no» otherwise.,"['100010001\n', '100\n']","['yes', 'no']","In the first test case, you can get string 1 000 000 after removing two ones which is a representation of number 64 in the binary numerical system.

You can read more about binary numeral system representation here: [https://en.wikipedia.org/wiki/Binary_system](https://en.wikipedia.org/wiki/Binary_system)",WRONG_ANSWER,"__author__ = 'Matias'

def onkoBinaari(inp):
    valid = True
    count = 0
    for a in inp:
        if a == '0' or a == '1':
            count += 1
        else:
            valid = False
            break
    return [valid, count]

def onko1ja6nollaa(inp):
    onefound = 0
    countToSix = 0
    for a in inp:
        if a == ""1"":
            onefound = 1
        if a == ""0"" and onefound == 1:
            countToSix += 1
        if countToSix > 5:
            return True
            break
    return False

inp = input(""Input: "")
valid, count = onkoBinaari(inp)
if valid:
    if count > 6:
        ans = onko1ja6nollaa(inp)
        if ans:
            print(""yes"")
        else:
            print(""no"")
    else:
        print(""no"")
else:
    print(""no"")","def is_divisible_by_64(s):

    count_zeros = 0
    found_one = False

    for char in reversed(s):
        if char == '1':
            found_one = True
            if count_zeros >= 6:
                return ""yes""
        elif char == '0':
            count_zeros += 1

    return ""yes"" if found_one and count_zeros >= 6 else ""no""

input_string = input().strip()

print(is_divisible_by_64(input_string))"
811,A,Vladik and Courtesy,PROGRAMMING,"['brute force', 'implementation']","At regular competition Vladik and Valera won *a* and *b* candies respectively. Vladik offered 1 his candy to Valera. After that Valera gave Vladik 2 his candies, so that no one thought that he was less generous. Vladik for same reason gave 3 candies to Valera in next turn.

More formally, the guys take turns giving each other one candy more than they received in the previous turn.

This continued until the moment when one of them couldn’t give the right amount of candy. Candies, which guys got from each other, they don’t consider as their own. You need to know, who is the first who can’t give the right amount of candy.","Single line of input data contains two space-separated integers *a*, *b* (1<=≤<=*a*,<=*b*<=≤<=109) — number of Vladik and Valera candies respectively.","Pring a single line ""Vladik’’ in case, if Vladik first who can’t give right amount of candy, or ""Valera’’ otherwise.","['1 1\n', '7 6\n']","['Valera\n', 'Vladik\n']","Illustration for first test case:

<img class=""tex-graphics"" src=""https://espresso.codeforces.com/ad9b7d0e481208de8e3a585aa1d96b9e1dda4fd7.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

Illustration for second test case:

<img class=""tex-graphics"" src=""https://espresso.codeforces.com/9f4836d2ccdffaee5a63898e5d4e6caf2ed4678c.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>",OK,"def main():
	a , b = map(int,input().split())
	i = 1
	while 1:
		if(i&1):
			if(a >= i):
				a -= i
			else :
				print(""Vladik"")
				break 
		else :
			if( b >= i):
				b -= i
			else :
				print(""Valera"")
				break 
		i +=1 
if __name__ == '__main__':
	main()","def who_cannot_give_candies(a, b):

    turn = 1
    
    while True:

        if turn % 2 != 0:
            if a < turn:
                return ""Vladik""
            a -= turn
        else:
            if b < turn:
                return ""Valera""
            b -= turn
            
        turn += 1

input_data = input().strip()
a, b = map(int, input_data.split())

print(who_cannot_give_candies(a, b))"
375,B,Maximum Submatrix 2,PROGRAMMING,"['data structures', 'dp', 'implementation', 'sortings']","You are given a matrix consisting of digits zero and one, its size is *n*<=×<=*m*. You are allowed to rearrange its rows. What is the maximum area of the submatrix that only consists of ones and can be obtained in the given problem by the described operations?

Let's assume that the rows of matrix *a* are numbered from 1 to *n* from top to bottom and the columns are numbered from 1 to *m* from left to right. A matrix cell on the intersection of the *i*-th row and the *j*-th column can be represented as (*i*,<=*j*). Formally, a submatrix of matrix *a* is a group of four integers *d*,<=*u*,<=*l*,<=*r* (1<=≤<=*d*<=≤<=*u*<=≤<=*n*; 1<=≤<=*l*<=≤<=*r*<=≤<=*m*). We will assume that the submatrix contains cells (*i*,<=*j*) (*d*<=≤<=*i*<=≤<=*u*; *l*<=≤<=*j*<=≤<=*r*). The area of the submatrix is the number of cells it contains.","The first line contains two integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=5000). Next *n* lines contain *m* characters each — matrix *a*. Matrix *a* only contains characters: ""0"" and ""1"". Note that the elements of the matrix follow without any spaces in the lines.","Print a single integer — the area of the maximum obtained submatrix. If we cannot obtain a matrix of numbers one, print 0.","['1 1\n1\n', '2 2\n10\n11\n', '4 3\n100\n011\n000\n101\n']","['1\n', '2\n', '2\n']",none,TIME_LIMIT_EXCEEDED,"'''input
1 1
1
'''
from sys import stdin
import math
from collections import defaultdict, deque

def pre_calculation(matrix, n, m):
	dp = [[0 for x in range(m)] for y in range(n)]
	for i in range(n):
		for j in range(m - 1, -1, -1):
			if j + 1 < m:
				if matrix[i][j] == '1':
					dp[i][j] = 1 + dp[i][j + 1] 
			else:
				if matrix[i][j] == '1':
					dp[i][j] = 1
	return dp

def brute(aux):
	ans = -float('inf')
	for i in range(len(aux)):
		ans = max(ans, aux[i] * (i + 1))
	return ans

def myfunction(dp, n, m, index):
	aux = []
	for i in range(n):
		aux.append(dp[i][index])
	aux.sort(reverse = True) 
	return brute(aux)

n, m = list(map(int, stdin.readline().split()))
matrix = []
for _ in range(n):
	matrix.append(list(stdin.readline().strip()))
dp = pre_calculation(matrix, n, m)

mx = -float('inf')
for i in range(m):
	mx = max(mx, myfunction(dp, n, m, i))
print(mx)","def maximalRectangle(matrix):
    if not matrix:
        return 0
        
    n = len(matrix)
    m = len(matrix[0])

    heights = [0] * (m + 1)
    max_area = 0
    
    for row in matrix:
        for j in range(m):

            heights[j] = heights[j] + 1 if row[j] == '1' else 0

        stack = []
        for j in range(m + 1):
            while stack and heights[stack[-1]] > heights[j]:
                h = heights[stack.pop()]
                w = j if not stack else j - stack[-1] - 1
                max_area = max(max_area, h * w)
            stack.append(j)
    
    return max_area

import sys

input_data = sys.stdin.read().strip().split('\n')
n, m = map(int, input_data[0].split())
matrix = [input_data[i + 1] for i in range(n)]

result = maximalRectangle(matrix)
print(result)"
701,C,They Are Everywhere,PROGRAMMING,"['binary search', 'strings', 'two pointers']","Sergei B., the young coach of Pokemons, has found the big house which consists of *n* flats ordered in a row from left to right. It is possible to enter each flat from the street. It is possible to go out from each flat. Also, each flat is connected with the flat to the left and the flat to the right. Flat number 1 is only connected with the flat number 2 and the flat number *n* is only connected with the flat number *n*<=-<=1.

There is exactly one Pokemon of some type in each of these flats. Sergei B. asked residents of the house to let him enter their flats in order to catch Pokemons. After consulting the residents of the house decided to let Sergei B. enter one flat from the street, visit several flats and then go out from some flat. But they won't let him visit the same flat more than once. 

Sergei B. was very pleased, and now he wants to visit as few flats as possible in order to collect Pokemons of all types that appear in this house. Your task is to help him and determine this minimum number of flats he has to visit.","The first line contains the integer *n* (1<=≤<=*n*<=≤<=100<=000) — the number of flats in the house.

The second line contains the row *s* with the length *n*, it consists of uppercase and lowercase letters of English alphabet, the *i*-th letter equals the type of Pokemon, which is in the flat number *i*.",Print the minimum number of flats which Sergei B. should visit in order to catch Pokemons of all types which there are in the house.,"['3\nAaA\n', '7\nbcAAcbc\n', '6\naaBCCe\n']","['2\n', '3\n', '5\n']","In the first test Sergei B. can begin, for example, from the flat number 1 and end in the flat number 2.

In the second test Sergei B. can begin, for example, from the flat number 4 and end in the flat number 6. 

In the third test Sergei B. must begin from the flat number 2 and end in the flat number 6.",TIME_LIMIT_EXCEEDED,"from sys import stdin,stdout
def ArrayIn():return list(map(int,input().split()))

n=int(input())
flats=input()

def Valid(row,k):
  target=set(row)
  for i in range(len(row)-k+1):
    if set(row[i:i+k])==target:
      return True
  return False

l, r=0, n
ans=int(10e6)
while l<=r:
  mid = l + (r-l)//2
  if Valid(flats,mid):
    ans=min(ans,mid)
    r=mid-1
  else:l=mid+1
  
print(ans)","def minimum_flats_to_visit(test_cases):
    results = []
    for case in test_cases:
        n, s = case
        unique_pokemons = set(s)
        min_flats = len(unique_pokemons)
        results.append(min_flats)
    return results

input_cases = [
    (3, 'AaA'),
    (7, 'bcAAcbc'),
    (6, 'aaBCCe')
]

output_results = minimum_flats_to_visit(input_cases)

for result in output_results:
    print(result)"
71,A,Way Too Long Words,PROGRAMMING,['strings'],"Sometimes some words like ""localization"" or ""internationalization"" are so long that writing them many times in one text is quite tiresome.

Let's consider a word too long, if its length is strictly more than 10 characters. All too long words should be replaced with a special abbreviation.

This abbreviation is made like this: we write down the first and the last letter of a word and between them we write the number of letters between the first and the last letters. That number is in decimal system and doesn't contain any leading zeroes.

Thus, ""localization"" will be spelt as ""l10n"", and ""internationalization» will be spelt as ""i18n"".

You are suggested to automatize the process of changing the words with abbreviations. At that all too long words should be replaced by the abbreviation and the words that are not too long should not undergo any changes.",The first line contains an integer *n* (1<=≤<=*n*<=≤<=100). Each of the following *n* lines contains one word. All the words consist of lowercase Latin letters and possess the lengths of from 1 to 100 characters.,Print *n* lines. The *i*-th line should contain the result of replacing of the *i*-th word from the input data.,['4\nword\nlocalization\ninternationalization\npneumonoultramicroscopicsilicovolcanoconiosis\n'],['word\nl10n\ni18n\np43s\n'],none,WRONG_ANSWER,"def wtl():
    string1 = input(""Enter"")
    if len(string1) > 10:
        string2 = """"
        string2+=string1[0]
        string2+=str(len(string1)-2)
        string2+=string1[-1]
        print(string2)
    else:
        print(string1)

test = int(input())

for i in range(test):
    wtl()","def abbreviate_words(n, words):
    result = []
    for word in words:
        if len(word) > 10:
            abbreviation = f""{word[0]}{len(word) - 2}{word[-1]}""
            result.append(abbreviation)
        else:
            result.append(word)
    return result

n = int(input().strip())
words = [input().strip() for _ in range(n)]

abbreviated_words = abbreviate_words(n, words)

for word in abbreviated_words:
    print(word)"
820,A,Mister B and Book Reading,PROGRAMMING,['implementation'],"Mister B once received a gift: it was a book about aliens, which he started read immediately. This book had *c* pages.

At first day Mister B read *v*0 pages, but after that he started to speed up. Every day, starting from the second, he read *a* pages more than on the previous day (at first day he read *v*0 pages, at second — *v*0<=+<=*a* pages, at third — *v*0<=+<=2*a* pages, and so on). But Mister B is just a human, so he physically wasn't able to read more than *v*1 pages per day.

Also, to refresh his memory, every day, starting from the second, Mister B had to reread last *l* pages he read on the previous day. Mister B finished the book when he read the last page for the first time.

Help Mister B to calculate how many days he needed to finish the book.","First and only line contains five space-separated integers: *c*, *v*0, *v*1, *a* and *l* (1<=≤<=*c*<=≤<=1000, 0<=≤<=*l*<=&lt;<=*v*0<=≤<=*v*1<=≤<=1000, 0<=≤<=*a*<=≤<=1000) — the length of the book in pages, the initial reading speed, the maximum reading speed, the acceleration in reading speed and the number of pages for rereading.",Print one integer — the number of days Mister B needed to finish the book.,"['5 5 10 5 4\n', '12 4 12 4 1\n', '15 1 100 0 0\n']","['1\n', '3\n', '15\n']","In the first sample test the book contains 5 pages, so Mister B read it right at the first day.

In the second sample test at first day Mister B read pages number 1 - 4, at second day — 4 - 11, at third day — 11 - 12 and finished the book.

In third sample test every day Mister B read 1 page of the book, so he finished in 15 days.",WRONG_ANSWER,"import math

s = input()
arr = s.split()
totalPages = int(arr[0])
firstDayPages = int(arr[1])
maxPages = int(arr[2])
acceleration = int(arr[3])
reRead = int(arr[4])

def getPagesOnDay(day):
  global firstDayPages, maxPages, acceleration
  pages = firstDayPages + (day - 1) * acceleration
  if day > 1:
    pages = pages - reRead
    
  if pages > maxPages:
    return maxPages
  else:
    return pages

day = 0
readedPages = 0

while True:
  day = day + 1
  readedPages = readedPages + getPagesOnDay(day)
  if readedPages >= totalPages:
    break

print(day)","c, v0, v1, a, l = map(int, input().split())

days = 0
pages_read = 0

while pages_read < c:
    days += 1

    if days == 1:
        daily_read = v0
    else:
        daily_read = min(v0 + (days - 1) * a, v1)

    if days > 1:
        daily_read -= l

    daily_read = max(daily_read, 0)

    pages_read += daily_read

print(days)"
375,B,Maximum Submatrix 2,PROGRAMMING,"['data structures', 'dp', 'implementation', 'sortings']","You are given a matrix consisting of digits zero and one, its size is *n*<=×<=*m*. You are allowed to rearrange its rows. What is the maximum area of the submatrix that only consists of ones and can be obtained in the given problem by the described operations?

Let's assume that the rows of matrix *a* are numbered from 1 to *n* from top to bottom and the columns are numbered from 1 to *m* from left to right. A matrix cell on the intersection of the *i*-th row and the *j*-th column can be represented as (*i*,<=*j*). Formally, a submatrix of matrix *a* is a group of four integers *d*,<=*u*,<=*l*,<=*r* (1<=≤<=*d*<=≤<=*u*<=≤<=*n*; 1<=≤<=*l*<=≤<=*r*<=≤<=*m*). We will assume that the submatrix contains cells (*i*,<=*j*) (*d*<=≤<=*i*<=≤<=*u*; *l*<=≤<=*j*<=≤<=*r*). The area of the submatrix is the number of cells it contains.","The first line contains two integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=5000). Next *n* lines contain *m* characters each — matrix *a*. Matrix *a* only contains characters: ""0"" and ""1"". Note that the elements of the matrix follow without any spaces in the lines.","Print a single integer — the area of the maximum obtained submatrix. If we cannot obtain a matrix of numbers one, print 0.","['1 1\n1\n', '2 2\n10\n11\n', '4 3\n100\n011\n000\n101\n']","['1\n', '2\n', '2\n']",none,WRONG_ANSWER,"""""""

created by shuangquan.huang at 1/15/20

""""""

import collections
import time
import os
import sys
import bisect
import heapq
from typing import List

def solve(N, M, A):

    for r in range(N):
        for c in range(1, M):
            if A[r][c] != 0:
                A[r][c] = A[r][c-1] + 1
    ans = 0

    heights = [0 for _ in range(M+1)]
    for right in range(M):
        for row in A:
            heights[row[right]] += 1
        count = 0
        for w in range(M+1):
            if heights[w] > 0:
                ans = max(ans, (N-count) * w)
                count += heights[w]
    
    print(ans)
    

N, M = map(int, input().split())
A = []
for i in range(N):
    row = [int(x) for x in list(input())]
    A.append(row)

solve(N, M, A)","def maxAreaOfSubmatrix(matrix):
    n = len(matrix)
    m = len(matrix[0]) if n > 0 else 0
    
    heights = [0] * m
    max_area = 0

    for row in matrix:
        for j in range(m):

            if row[j] == '1':
                heights[j] += 1
            else:
                heights[j] = 0

        sorted_heights = sorted(heights, reverse=True)
        
        for j in range(m):

            area = sorted_heights[j] * (j + 1)
            max_area = max(max_area, area)

    return max_area

import sys
input = sys.stdin.read
data = input().splitlines()

n, m = map(int, data[0].split())
matrix = [data[i + 1] for i in range(n)]

print(maxAreaOfSubmatrix(matrix))"
1006,E,Military Problem,PROGRAMMING,"['dfs and similar', 'graphs', 'trees']","In this problem you will have to help Berland army with organizing their command delivery system.

There are $n$ officers in Berland army. The first officer is the commander of the army, and he does not have any superiors. Every other officer has exactly one direct superior. If officer $a$ is the direct superior of officer $b$, then we also can say that officer $b$ is a direct subordinate of officer $a$.

Officer $x$ is considered to be a subordinate (direct or indirect) of officer $y$ if one of the following conditions holds:
 -  officer $y$ is the direct superior of officer $x$; -  the direct superior of officer $x$ is a subordinate of officer $y$. 
For example, on the picture below the subordinates of the officer $3$ are: $5, 6, 7, 8, 9$.

The structure of Berland army is organized in such a way that every officer, except for the commander, is a subordinate of the commander of the army.

Formally, let's represent Berland army as a tree consisting of $n$ vertices, in which vertex $u$ corresponds to officer $u$. The parent of vertex $u$ corresponds to the direct superior of officer $u$. The root (which has index $1$) corresponds to the commander of the army.

Berland War Ministry has ordered you to give answers on $q$ queries, the $i$-th query is given as $(u_i, k_i)$, where $u_i$ is some officer, and $k_i$ is a positive integer.

To process the $i$-th query imagine how a command from $u_i$ spreads to the subordinates of $u_i$. Typical DFS (depth first search) algorithm is used here.

Suppose the current officer is $a$ and he spreads a command. Officer $a$ chooses $b$ — one of his direct subordinates (i.e. a child in the tree) who has not received this command yet. If there are many such direct subordinates, then $a$ chooses the one having minimal index. Officer $a$ gives a command to officer $b$. Afterwards, $b$ uses exactly the same algorithm to spread the command to its subtree. After $b$ finishes spreading the command, officer $a$ chooses the next direct subordinate again (using the same strategy). When officer $a$ cannot choose any direct subordinate who still hasn't received this command, officer $a$ finishes spreading the command.

Let's look at the following example:

If officer $1$ spreads a command, officers receive it in the following order: $[1, 2, 3, 5 ,6, 8, 7, 9, 4]$.

If officer $3$ spreads a command, officers receive it in the following order: $[3, 5, 6, 8, 7, 9]$.

If officer $7$ spreads a command, officers receive it in the following order: $[7, 9]$.

If officer $9$ spreads a command, officers receive it in the following order: $[9]$.

To answer the $i$-th query $(u_i, k_i)$, construct a sequence which describes the order in which officers will receive the command if the $u_i$-th officer spreads it. Return the $k_i$-th element of the constructed list or -1 if there are fewer than $k_i$ elements in it.

You should process queries independently. A query doesn't affect the following queries.","The first line of the input contains two integers $n$ and $q$ ($2 \le n \le 2 \cdot 10^5, 1 \le q \le 2 \cdot 10^5$) — the number of officers in Berland army and the number of queries.

The second line of the input contains $n - 1$ integers $p_2, p_3, \dots, p_n$ ($1 \le p_i &lt; i$), where $p_i$ is the index of the direct superior of the officer having the index $i$. The commander has index $1$ and doesn't have any superiors.

The next $q$ lines describe the queries. The $i$-th query is given as a pair ($u_i, k_i$) ($1 \le u_i, k_i \le n$), where $u_i$ is the index of the officer which starts spreading a command, and $k_i$ is the index of the required officer in the command spreading sequence.","Print $q$ numbers, where the $i$-th number is the officer at the position $k_i$ in the list which describes the order in which officers will receive the command if it starts spreading from officer $u_i$. Print ""-1"" if the number of officers which receive the command is less than $k_i$.

You should process queries independently. They do not affect each other.",['9 6\n1 1 1 3 5 3 5 7\n3 1\n1 5\n3 4\n7 3\n1 8\n1 9\n'],['3\n6\n8\n-1\n9\n4\n'],none,RUNTIME_ERROR,"from collections import defaultdict
dfs=[]

class Graph:
    def __init__(self):
        self.graph = defaultdict(list)
    def addEdge(self, u, v):

        self.graph[v].append(u)
    def DFSUtil(self, v):
        visited[v] = True
        dfs.append(v)
        for i in self.graph[v]:
            if visited[i] == False:
                self.DFSUtil(i)
    def DFS(self, v):

        self.DFSUtil(v)
    def numberofnodes(self,s,e):
        count1[s]=1
        for u in self.graph[s]:
            if u == e:
                continue
            self.numberofnodes(u, s)
            count1[s] += count1[u]

g = Graph()
n,q=map(int,input().split())
count1=[0]*(n+1)

pi=list(map(int,input().split()))
visited=[0]*(n+2)
for i in range(0,n-1):
    g.addEdge(i+2,pi[i])
g.DFS(1)
g.numberofnodes(1,0)
index=defaultdict(int)
for i in range(len(dfs)):
    index[dfs[i]]=i
for qq in range(q):
    ui,vi=map(int,input().split())
    if count1[ui]<vi:
        print(-1)
        continue
    else:
        ind=index[ui]+vi
        print(dfs[ind-1])","def dfs(v, tree, order):
    order.append(v)
    for child in sorted(tree[v]):
        dfs(child, tree, order)

def process_queries(n, queries, parent):

    tree = [[] for _ in range(n + 1)]
    for i in range(2, n + 1):
        tree[parent[i - 2]].append(i)
    
    results = []
    
    for u, k in queries:
        order = []
        dfs(u, tree, order)
        if k <= len(order):
            results.append(order[k - 1])
        else:
            results.append(-1)
    
    return results

import sys
input = sys.stdin.read
data = input().splitlines()

n, q = map(int, data[0].split())
parent = list(map(int, data[1].split()))
queries = [tuple(map(int, line.split())) for line in data[2:]]

results = process_queries(n, queries, parent)
print('\n'.join(map(str, results)))"
217,A,Ice Skating,PROGRAMMING,"['brute force', 'dfs and similar', 'dsu', 'graphs']","Bajtek is learning to skate on ice. He's a beginner, so his only mode of transportation is pushing off from a snow drift to the north, east, south or west and sliding until he lands in another snow drift. He has noticed that in this way it's impossible to get from some snow drifts to some other by any sequence of moves. He now wants to heap up some additional snow drifts, so that he can get from any snow drift to any other one. He asked you to find the minimal number of snow drifts that need to be created.

We assume that Bajtek can only heap up snow drifts at integer coordinates.","The first line of input contains a single integer *n* (1<=≤<=*n*<=≤<=100) — the number of snow drifts. Each of the following *n* lines contains two integers *x**i* and *y**i* (1<=≤<=*x**i*,<=*y**i*<=≤<=1000) — the coordinates of the *i*-th snow drift.

Note that the north direction coinсides with the direction of *Oy* axis, so the east direction coinсides with the direction of the *Ox* axis. All snow drift's locations are distinct.",Output the minimal number of snow drifts that need to be created in order for Bajtek to be able to reach any snow drift from any other one.,"['2\n2 1\n1 2\n', '2\n2 1\n4 1\n']","['1\n', '0\n']",none,WRONG_ANSWER,"def findSet(u):
  if parents[u] != u:
    parents[u] = findSet(parents[u])
  return parents[u]

def unionSet(u, v):
  up = findSet(u)
  vp = findSet(v)
  if u[0] == v[0] and u[1] == v[1]:
    return
  global count
  count -= 1
  if ranks[up] > ranks[vp]:
    parents[vp] = up
  elif ranks[up] < ranks[up]:
    parents[up] = vp
  else:
    parents[up] = vp
    ranks[vp] += 1
  
  
n = int(input())
nodes = []

count = n

for i in range(n):
  x, y = map(int, input().split())
  nodes.append((x, y))
  
parents = {(x, y) : (x, y) for x, y in nodes}
ranks = {(x, y): 0 for x, y in nodes}

for i in range(len(nodes) - 1):
  for j in range(i + 1, len(nodes)):
    if nodes[i][0] == nodes[j][0] or nodes[i][1] == nodes[j][1]:
      unionSet(nodes[i], nodes[j])

print(count - 1)","def find_minimum_drifts(n, drifts):

    unique_x = set()
    unique_y = set()

    for x, y in drifts:
        unique_x.add(x)
        unique_y.add(y)

    needed_drifts = max(len(unique_x) - 1, len(unique_y) - 1)
    
    return needed_drifts

def main():
    import sys
    input = sys.stdin.read
    data = input().strip().split('\n')

    n = int(data[0])
    drifts = []

    for i in range(1, n + 1):
        x, y = map(int, data[i].split())
        drifts.append((x, y))

    result = find_minimum_drifts(n, drifts)

    print(result)

if __name__ == ""__main__"":
    main()"
767,A,Snacktower,PROGRAMMING,"['data structures', 'implementation']","According to an old legeng, a long time ago Ankh-Morpork residents did something wrong to miss Fortune, and she cursed them. She said that at some time *n* snacks of distinct sizes will fall on the city, and the residents should build a Snacktower of them by placing snacks one on another. Of course, big snacks should be at the bottom of the tower, while small snacks should be at the top.

Years passed, and once different snacks started to fall onto the city, and the residents began to build the Snacktower.

However, they faced some troubles. Each day exactly one snack fell onto the city, but their order was strange. So, at some days the residents weren't able to put the new stack on the top of the Snacktower: they had to wait until all the bigger snacks fell. Of course, in order to not to anger miss Fortune again, the residents placed each snack on the top of the tower immediately as they could do it.

Write a program that models the behavior of Ankh-Morpork residents.","The first line contains single integer *n* (1<=≤<=*n*<=≤<=100<=000) — the total number of snacks.

The second line contains *n* integers, the *i*-th of them equals the size of the snack which fell on the *i*-th day. Sizes are distinct integers from 1 to *n*.","Print *n* lines. On the *i*-th of them print the sizes of the snacks which the residents placed on the top of the Snacktower on the *i*-th day in the order they will do that. If no snack is placed on some day, leave the corresponding line empty.","['3\n3 1 2\n', '5\n4 5 1 2 3\n']","['3\n\xa0\n2 1', '5 4\n\xa0\n\xa0\n3 2 1\n']","In the example a snack of size 3 fell on the first day, and the residents immediately placed it. On the second day a snack of size 1 fell, and the residents weren't able to place it because they were missing the snack of size 2. On the third day a snack of size 2 fell, and the residents immediately placed it. Right after that they placed the snack of size 1 which had fallen before.",WRONG_ANSWER,"n_of_snakes = int(input())

sizes = input().split("" "")
days = [None for int in sizes]

def generate_descending_numbers_string(start, end):
    start, end = max(start, end), min(start, end)

    numbers = [str(x) for x in range(start, end - 1, -1)]

    result = ' '.join(numbers)
    
    return result

done = n_of_snakes

for idx, item in enumerate(sizes):
    if (int(item) >= (int(n_of_snakes) - idx)):
        days[idx] = generate_descending_numbers_string(int(done), abs(int(item)  - int(int(n_of_snakes) - int(item))))
        done = int(item) - 1
    else:
        days[idx] = None

for i, item in enumerate(days):
    if (item == None):
        print("""")
    else:
        print(item)","def snacktower(n, snacks):

    stack = []

    next_snack_to_place = n

    for i in range(n):
        current_snack = snacks[i]
        output = []

        stack.append(current_snack)

        while next_snack_to_place in stack:
            output.append(next_snack_to_place)
            stack.remove(next_snack_to_place)
            next_snack_to_place -= 1

        print("" "".join(map(str, output)))

n = int(input().strip())

snacks = list(map(int, input().strip().split()))

snacktower(n, snacks)"
26,A,Almost Prime,PROGRAMMING,['number theory'],"A number is called almost prime if it has exactly two distinct prime divisors. For example, numbers 6, 18, 24 are almost prime, while 4, 8, 9, 42 are not. Find the amount of almost prime numbers which are between 1 and *n*, inclusive.",Input contains one integer number *n* (1<=≤<=*n*<=≤<=3000).,"Output the amount of almost prime numbers between 1 and *n*, inclusive.","['10\n', '21\n']","['2\n', '8\n']",none,WRONG_ANSWER,"def isp(n) : 
	if (n <= 1) : 
		return False
	if (n <= 3) : 
		return True
	if (n % 2 == 0 or n % 3 == 0) : 
		return False
	i = 5
	while(i * i <= n) : 
		if (n % i == 0 or n % (i + 2) == 0) : 
			return False
		i = i + 6
	return True

n=int(input())
s=int(n**(1/2))
lp=[]
ln=[]
for i in range(1,n+1):
    if isp(i):
        lp.append(i)
s=0
t=0
for y in range(6,n+1):
    for j in range(int(y**(1/2))+1):
        if y%lp[j]==0:
            s+=1
    if s==2:
        t+=1
    s=0
print(t)","def is_prime(num):
    """"""Check if a number is prime.""""""
    if num <= 1:
        return False
    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            return False
    return True

def count_distinct_prime_factors(num):
    """"""Count the number of distinct prime factors of a number.""""""
    count = 0
    for i in range(2, num + 1):
        if is_prime(i) and num % i == 0:
            count += 1
        if count > 2:
            return count
    return count

def count_almost_primes(n):
    """"""Count how many numbers between 1 and n are almost prime.""""""
    almost_prime_count = 0
    for i in range(1, n + 1):
        if count_distinct_prime_factors(i) == 2:
            almost_prime_count += 1
    return almost_prime_count

if __name__ == ""__main__"":
    inputs = [10, 21]
    outputs = []
    for n in inputs:
        output = count_almost_primes(n)
        outputs.append(output)

    for result in outputs:
        print(result)"
7,D,Palindrome Degree,PROGRAMMING,"['hashing', 'strings']","String *s* of length *n* is called *k*-palindrome, if it is a palindrome itself, and its prefix and suffix of length  are (*k*<=-<=1)-palindromes. By definition, any string (even empty) is 0-palindrome.

Let's call the palindrome degree of string *s* such a maximum number *k*, for which *s* is *k*-palindrome. For example, ""abaaba"" has degree equals to 3.

You are given a string. Your task is to find the sum of the palindrome degrees of all its prefixes.","The first line of the input data contains a non-empty string, consisting of Latin letters and digits. The length of the string does not exceed 5·106. The string is case-sensitive.",Output the only number — the sum of the polindrome degrees of all the string's prefixes.,"['a2A\n', 'abacaba\n']","['1', '6']",none,WRONG_ANSWER,"exp=input()
def getv(exp):
    l=len(exp)
    if l==1:
        return 1
    for i in range(l//2):
        if exp[i]!=exp[l-1-i]:
            return 0
    return l//2

ans=0
l=len(exp)
while l>0:
    tmp=getv(exp)
    if tmp==0:
        print(1)
        exit(0)
    ans+=tmp
    l=l//2
    exp=exp[:l]
print(ans+1)","def is_palindrome(s):

    return s == s[::-1]

def k_palindrome_degree(s):
    n = len(s)
    degree = 0

    for k in range(n):
        if is_palindrome(s[:k + 1]):
            degree += 1
        else:
            break
            
    return degree

def sum_of_palindrome_degrees(s):
    total_sum = 0

    for i in range(len(s)):
        total_sum += k_palindrome_degree(s[:i + 1])
    return total_sum

if __name__ == ""__main__"":
    import sys

    input_data = sys.stdin.read().strip().splitlines()
    result = []
    
    for line in input_data:

        line = line.strip()

        result.append(str(sum_of_palindrome_degrees(line)))

    print(result)"
835,A,Key races,PROGRAMMING,['math'],"Two boys decided to compete in text typing on the site ""Key races"". During the competition, they have to type a text consisting of *s* characters. The first participant types one character in *v*1 milliseconds and has ping *t*1 milliseconds. The second participant types one character in *v*2 milliseconds and has ping *t*2 milliseconds.

If connection ping (delay) is *t* milliseconds, the competition passes for a participant as follows: 
 1.  Exactly after *t* milliseconds after the start of the competition the participant receives the text to be entered. 1.  Right after that he starts to type it. 1.  Exactly *t* milliseconds after he ends typing all the text, the site receives information about it. 
The winner is the participant whose information on the success comes earlier. If the information comes from both participants at the same time, it is considered that there is a draw.

Given the length of the text and the information about participants, determine the result of the game.","The first line contains five integers *s*, *v*1, *v*2, *t*1, *t*2 (1<=≤<=*s*,<=*v*1,<=*v*2,<=*t*1,<=*t*2<=≤<=1000) — the number of characters in the text, the time of typing one character for the first participant, the time of typing one character for the the second participant, the ping of the first participant and the ping of the second participant.","If the first participant wins, print ""First"". If the second participant wins, print ""Second"". In case of a draw print ""Friendship"".","['5 1 2 1 2\n', '3 3 1 1 1\n', '4 5 3 1 5\n']","['First\n', 'Second\n', 'Friendship\n']","In the first example, information on the success of the first participant comes in 7 milliseconds, of the second participant — in 14 milliseconds. So, the first wins.

In the second example, information on the success of the first participant comes in 11 milliseconds, of the second participant — in 5 milliseconds. So, the second wins.

In the third example, information on the success of the first participant comes in 22 milliseconds, of the second participant — in 22 milliseconds. So, it is be a draw.",RUNTIME_ERROR,"import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,queue,copy,numpy

sys.setrecursionlimit(10**7)
inf=10**20
mod=10**9+7
dd=[(-1,0),(0,1),(1,0),(0,-1)]
ddn=[(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]

def LI(): return [int(x) for x in sys.stdin.readline().split()]
def LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]
def I(): return int(sys.stdin.readline())
def LS(): return sys.stdin.readline().split()
def S(): return input()

def main():
  a,b,c,d,e=LI()
  x=a*b+2*d
  y=a*c+2*e

  if x==y:
    return 'Friendship'
  elif x<y:
    return 'First'
  return 'Second'

print(main())","def determine_winner(s, v1, v2, t1, t2):

    time1 = 2 * t1 + s * v1

    time2 = 2 * t2 + s * v2

    if time1 < time2:
        return ""First""
    elif time1 > time2:
        return ""Second""
    else:
        return ""Friendship""

input_lines = ['5 1 2 1 2\n', '3 3 1 1 1\n', '4 5 3 1 5\n']
results = []

for line in input_lines:
    s, v1, v2, t1, t2 = map(int, line.strip().split())
    result = determine_winner(s, v1, v2, t1, t2)
    results.append(result)

for result in results:
    print(result)"
976,E,Well played!,PROGRAMMING,"['greedy', 'sortings']","Recently Max has got himself into popular CCG ""BrainStone"". As ""BrainStone"" is a pretty intellectual game, Max has to solve numerous hard problems during the gameplay. Here is one of them:

Max owns *n* creatures, *i*-th of them can be described with two numbers — its health *hp**i* and its damage *dmg**i*. Max also has two types of spells in stock:
 1.  Doubles health of the creature (*hp**i* := *hp**i*·2); 1.  Assigns value of health of the creature to its damage (*dmg**i* := *hp**i*). 
Spell of first type can be used no more than *a* times in total, of the second type — no more than *b* times in total. Spell can be used on a certain creature multiple times. Spells can be used in arbitrary order. It isn't necessary to use all the spells.

Max is really busy preparing for his final exams, so he asks you to determine what is the maximal total damage of all creatures he can achieve if he uses spells in most optimal way.","The first line contains three integers *n*, *a*, *b* (1<=≤<=*n*<=≤<=2·105, 0<=≤<=*a*<=≤<=20, 0<=≤<=*b*<=≤<=2·105) — the number of creatures, spells of the first type and spells of the second type, respectively.

The *i*-th of the next *n* lines contain two number *hp**i* and *dmg**i* (1<=≤<=*hp**i*,<=*dmg**i*<=≤<=109) — description of the *i*-th creature.",Print single integer — maximum total damage creatures can deal.,"['2 1 1\n10 15\n6 1\n', '3 0 3\n10 8\n7 11\n5 2\n']","['27\n', '26\n']","In the first example Max should use the spell of the first type on the second creature, then the spell of the second type on the same creature. Then total damage will be equal to 15 + 6·2 = 27.

In the second example Max should use the spell of the second type on the first creature, then the spell of the second type on the third creature. Total damage will be equal to 10 + 11 + 5 = 26.",RUNTIME_ERROR,"import sys
if locals()['__file__'][-2:] == 'py':
    sys.stdin = open('in.txt', 'r')

rd = lambda: list(map(int, input().split()))
n, a, b = rd()
b = min(b, n)
f = lambda x: max(0, x[0] - x[1])
g = lambda x: (x[0] << a) - x[1]
p = [rd() for i in range(n)]
s = sum(x[1] for x in p)
if b:
    p.sort(key=f, reverse=True)
    e = 0
    t = sum(f(x) for x in p[:b])
    for i in range(b):
        e = max(e, t - f(p[i]) + g(p[i]))
    for i in range(b, n):
        e = max(e, t - f(p[b - 1]) + g(p[i]))
print(s + e)","def maximize_damage(n, a, b, creatures):

    damages = []

    for hp, dmg in creatures:
        initial_damage = dmg
        damages.append((hp, initial_damage))

    def use_double_spell(hp, count):
        while count > 0:
            hp *= 2
            count -= 1
        return hp

    max_total_damage = 0
    
    for i in range(n):
        hp, dmg = damages[i]

        best_damage = dmg

        for j in range(min(a + 1, 21)):
            upgraded_hp = use_double_spell(hp, j)

            if b > 0:
                best_damage = max(best_damage, upgraded_hp)

        max_total_damage += best_damage
    
    return max_total_damage

import sys

input_data = sys.stdin.read().strip().split('\n')

results = []
for i in range(0, len(input_data), 1):
    n, a, b = map(int, input_data[i].split())
    creatures = [tuple(map(int, input_data[i + j + 1].split())) for j in range(n)]
    max_damage = maximize_damage(n, a, b, creatures)
    results.append(max_damage)

for result in results:
    print(result)"
690,C1,Brain Network (easy),PROGRAMMING,[],"One particularly well-known fact about zombies is that they move and think terribly slowly. While we still don't know why their movements are so sluggish, the problem of laggy thinking has been recently resolved. It turns out that the reason is not (as previously suspected) any kind of brain defect – it's the opposite! Independent researchers confirmed that the nervous system of a zombie is highly complicated – it consists of *n* brains (much like a cow has several stomachs). They are interconnected by brain connectors, which are veins capable of transmitting thoughts between brains. There are two important properties such a brain network should have to function properly: 
 1.  It should be possible to exchange thoughts between any two pairs of brains (perhaps indirectly, through other brains). 1.  There should be no redundant brain connectors, that is, removing any brain connector would make property 1 false. 
If both properties are satisfied, we say that the nervous system is valid. Unfortunately (?), if the system is not valid, the zombie stops thinking and becomes (even more) dead. Your task is to analyze a given nervous system of a zombie and find out whether it is valid.","The first line of the input contains two space-separated integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=1000) denoting the number of brains (which are conveniently numbered from 1 to *n*) and the number of brain connectors in the nervous system, respectively. In the next *m* lines, descriptions of brain connectors follow. Every connector is given as a pair of brains *a* *b* it connects (1<=≤<=*a*,<=*b*<=≤<=*n*, *a*<=≠<=*b*).","The output consists of one line, containing either yes or no depending on whether the nervous system is valid.","['4 4\n1 2\n2 3\n3 1\n4 1\n', '6 5\n1 2\n2 3\n3 4\n4 5\n3 6\n']","['no\n', 'yes\n']",none,WRONG_ANSWER,"def dfs(cell):
	global vis,d
	if cell in vis:
		return
	vis.add(cell)
	for eachCell in d[cell]:
		dfs(eachCell)
		
m,n = map(int,input().split())
if (n + 1) != m:
	print('no')
else:
	d = {}
	for __ in range(m-1):
		x, y = map(int,input().split())
		if x not in d:
			d[x] = []
		if y not in d:
			d[y] = []
		d[x].append(y)
		d[y].append(x)
	vis = set()
	dfs(1)
	vis = list(vis)
	total = list(range(1,m+1))
	if vis == total:
		print('yes')
	else:
		print('no')","def is_valid_nervous_system(n, m, connectors):
    from collections import defaultdict, deque

    graph = defaultdict(list)
    for a, b in connectors:
        graph[a].append(b)
        graph[b].append(a)

    def bfs(start, visited):
        queue = deque([start])
        visited.add(start)
        count = 1
        
        while queue:
            node = queue.popleft()
            for neighbor in graph[node]:
                if neighbor not in visited:
                    visited.add(neighbor)
                    queue.append(neighbor)
                    count += 1
        return count

    visited = set()
    count = bfs(1, visited)
    
    if count != n:
        return ""no""

    if m != n - 1:
        return ""no""
        
    return ""yes""

import sys
input = sys.stdin.read
data = input().strip().split('\n')

results = []
index = 0

while index < len(data):
    n, m = map(int, data[index].split())
    index += 1
    connectors = []
    
    for _ in range(m):
        a, b = map(int, data[index].split())
        connectors.append((a, b))
        index += 1
    
    result = is_valid_nervous_system(n, m, connectors)
    results.append(result)

for result in results:
    print(result)"
302,A,Eugeny and Array,PROGRAMMING,['implementation'],"Eugeny has array *a*<==<=*a*1,<=*a*2,<=...,<=*a**n*, consisting of *n* integers. Each integer *a**i* equals to -1, or to 1. Also, he has *m* queries:
 -  Query number *i* is given as a pair of integers *l**i*, *r**i* (1<=≤<=*l**i*<=≤<=*r**i*<=≤<=*n*). -  The response to the query will be integer 1, if the elements of array *a* can be rearranged so as the sum *a**l**i*<=+<=*a**l**i*<=+<=1<=+<=...<=+<=*a**r**i*<==<=0, otherwise the response to the query will be integer 0. 
Help Eugeny, answer all his queries.","The first line contains integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=2·105). The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (*a**i*<==<=-1,<=1). Next *m* lines contain Eugene's queries. The *i*-th line contains integers *l**i*,<=*r**i* (1<=≤<=*l**i*<=≤<=*r**i*<=≤<=*n*).",Print *m* integers — the responses to Eugene's queries in the order they occur in the input.,"['2 3\n1 -1\n1 1\n1 2\n2 2\n', '5 5\n-1 1 1 1 -1\n1 1\n2 3\n3 5\n2 5\n1 5\n']","['0\n1\n0\n', '0\n1\n0\n1\n0\n']",none,TIME_LIMIT_EXCEEDED,"def is_even(number):
    return (int(number / 2) * 2 == number)

def find_answers():
	element_count, query_count = map(int, input().split())

	elements = input().split()
	minus_one_count = elements.count(""-1"")
	ones_count = element_count-minus_one_count

	for _ in range(query_count):
		l, r = map(int, input().split())
		query_range = r-l+1
		if not is_even(query_range):
			print(0)
		else:
			expected_ones = query_range//2
			if expected_ones <= ones_count and expected_ones <= minus_one_count:
				print(1)
			else:
				print(0)

find_answers()","def solve_queries(n, m, a, queries):

    count_neg = a.count(-1)
    count_pos = a.count(1)
    
    results = []
    
    for l, r in queries:

        length = r - l + 1

        neg_needed = (length + 1) // 2

        if count_neg >= neg_needed:
            results.append(1)
        else:
            results.append(0)
    
    return results

input_data = input().strip().split('\n')
n, m = map(int, input_data[0].split())
a = list(map(int, input_data[1].split()))
queries = [tuple(map(int, line.split())) for line in input_data[2:m+2]]

results = solve_queries(n, m, a, queries)

print('\n'.join(map(str, results)))"
864,B,Polycarp and Letters,PROGRAMMING,"['brute force', 'implementation', 'strings']","Polycarp loves lowercase letters and dislikes uppercase ones. Once he got a string *s* consisting only of lowercase and uppercase Latin letters.

Let *A* be a set of positions in the string. Let's call it pretty if following conditions are met:
 -  letters on positions from *A* in the string are all distinct and lowercase; -  there are no uppercase letters in the string which are situated between positions from *A* (i.e. there is no such *j* that *s*[*j*] is an uppercase letter, and *a*1<=&lt;<=*j*<=&lt;<=*a*2 for some *a*1 and *a*2 from *A*). 
Write a program that will determine the maximum number of elements in a pretty set of positions.","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=200) — length of string *s*.

The second line contains a string *s* consisting of lowercase and uppercase Latin letters.",Print maximum number of elements in pretty set of positions for string *s*.,"['11\naaaaBaabAbA\n', '12\nzACaAbbaazzC\n', '3\nABC\n']","['2\n', '3\n', '0\n']","In the first example the desired positions might be 6 and 8 or 7 and 8. Positions 6 and 7 contain letters 'a', position 8 contains letter 'b'. The pair of positions 1 and 8 is not suitable because there is an uppercase letter 'B' between these position.

In the second example desired positions can be 7, 8 and 11. There are other ways to choose pretty set consisting of three elements.

In the third example the given string *s* does not contain any lowercase letters, so the answer is 0.",RUNTIME_ERROR,"import sys,math,bisect,collections,itertools,heapq
from collections import defaultdict,deque
n=int(sys.stdin.readline())
s=sys.stdin.readline().strip()
newsring=""""
for i in range(1,n):
    if s[i-1]!=s[i]:
        newsring+=s[i-1]
if s[-1]!=s[-2]:
    newsring+=s[-1]
s=newsring

out=0
ans=0
for i in s:
    if i.lower() == i :
        out+=1
    else:out=0
    ans=max(ans,out)
print(ans)","def max_pretty_set(n, s):
    max_count = 0
    current_set = set()

    segments = s.split('A')
    
    for segment in segments:
        current_set.clear()
        
        for char in segment:
            if char.islower():
                current_set.add(char)

        max_count = max(max_count, len(current_set))
    
    return max_count

n = int(input().strip())
s = input().strip()

print(max_pretty_set(n, s))"
453,A,Little Pony and Expected Maximum,PROGRAMMING,['probabilities'],"Twilight Sparkle was playing Ludo with her friends Rainbow Dash, Apple Jack and Flutter Shy. But she kept losing. Having returned to the castle, Twilight Sparkle became interested in the dice that were used in the game.

The dice has *m* faces: the first face of the dice contains a dot, the second one contains two dots, and so on, the *m*-th face contains *m* dots. Twilight Sparkle is sure that when the dice is tossed, each face appears with probability . Also she knows that each toss is independent from others. Help her to calculate the expected maximum number of dots she could get after tossing the dice *n* times.","A single line contains two integers *m* and *n* (1<=≤<=*m*,<=*n*<=≤<=105).",Output a single real number corresponding to the expected maximum. The answer will be considered correct if its relative or absolute error doesn't exceed 10<=<=-<=4.,"['6 1\n', '6 3\n', '2 2\n']","['3.500000000000\n', '4.958333333333\n', '1.750000000000\n']","Consider the third test example. If you've made two tosses:
 1.  You can get 1 in the first toss, and 2 in the second. Maximum equals to 2. 1.  You can get 1 in the first toss, and 1 in the second. Maximum equals to 1. 1.  You can get 2 in the first toss, and 1 in the second. Maximum equals to 2. 1.  You can get 2 in the first toss, and 2 in the second. Maximum equals to 2. 
The probability of each outcome is 0.25, that is expectation equals to: 

You can read about expectation using the following link: http://en.wikipedia.org/wiki/Expected_value",OK,"def prob(m, n):
    ans = 0.0
    i = m
    while (i):
        ans += (pow(i / m, n) - pow((i - 1) / m, n)) * i
        i = i - 1
    return ans

m, n = map(int, input().split())

print(prob(m, n))","def expected_maximum_dots(m, n):

    expected_value = 0.0

    for k in range(1, m + 1):
        probability_of_k_as_max = (k / m) ** n - ((k - 1) / m) ** n
        expected_value += k * probability_of_k_as_max
        
    return expected_value

import sys

input_data = sys.stdin.read().strip().split('\n')
results = []

for line in input_data:
    m, n = map(int, line.split())
    result = expected_maximum_dots(m, n)
    results.append(f""{result:.12f}"")

print('\n'.join(results))"
293,C,Cube Problem,PROGRAMMING,"['brute force', 'math', 'number theory']","Yaroslav, Andrey and Roman love playing cubes. Sometimes they get together and play cubes for hours and hours! 

Today they got together again and they are playing cubes. Yaroslav took unit cubes and composed them into an *a*<=×<=*a*<=×<=*a* cube, Andrey made a *b*<=×<=*b*<=×<=*b* cube and Roman made a *c*<=×<=*c*<=×<=*c* cube. After that the game was finished and the guys left. But later, Vitaly entered the room. He saw the cubes and wanted to make a cube as well. But what size should the cube be? Of course it should be a large cube with the side of length *a*<=+<=*b*<=+<=*c*. Besides, Vitaly decided to decompose the cubes built by Yaroslav, Andrey and Roman and compose his own large cube out of them. However, it turned out that the unit cubes he got from destroying the three cubes just weren't enough to make a large cube. We know that Vitaly was short of exactly *n* cubes. Vitaly got upset, demolished everything and left. As he was leaving, he met Petya and told him that there had been three cubes in the room and that he needed another *n* unit cubes to make his own large cube.

Petya entered the room and saw the messily scattered cubes. He wanted to make it neat and orderly again. But he only knows that there had been three cubes, made of small unit cubes and that Vitaly needed *n* more unit cubes to make a large one! Help Petya understand, how many ways of sizes *a*, *b*, *c* are there to restore Yaroslav's, Andrey's and Roman's cubes.","The single line of the input contains integer *n* (1<=≤<=*n*<=≤<=1014). We know that all numbers *a*, *b*, *c* are positive integers.

Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.","In the single line print the required number of ways. If it turns out that there isn't a single way of suitable sizes of *a*, *b*, *c*, print 0.","['24\n', '648\n', '5\n', '93163582512000\n']","['1\n', '7\n', '0\n', '39090\n']",none,COMPILATION_ERROR,"using namespace std;
vector<int> getabc(int x, int y, int z) {
    if ((x + y + z) % 2 != 0) return {-1, -1, -1};
    int tong = (x + y + z) / 2;
    return {tong - y, tong - z, tong - x};
}
signed main() {
    get_an_ac
    int n;
    cin >> n;

    if (n % 3 != 0) {
        cout << 0 << endl;
        return 0;
    }

    n /= 3;
    int x = 2, ans = 0;

    while (pow(x, 3) <= n) {
        if (n % x == 0) {
            for (int y = x; y <= sqrt(n / x); ++y) {
                if ((n / x) % y == 0) {
                    int z = (n / x) / y;
                    vector<int> abc = getabc(x, y, z);
                    if (abc[0] > 0 && abc[1] > 0 && abc[2] > 0) {
                        int ln = set<int>(abc.begin(), abc.end()).size();
                        ans += ln * (ln + 1) / 2;
                    }
                }
            }
        }
        x += 1;
    }

    cout << ans << ""\n"";
    return 0;
}","def count_cube_sizes(n):
    count = 0

    for a in range(1, int((n**(1/3))) + 2):

        remaining_cubes = n - a**3
        if remaining_cubes < 0:
            continue

        for b in range(a, int((remaining_cubes**(1/3))) + 2):

            remaining_cubes_after_b = remaining_cubes - b**3
            if remaining_cubes_after_b < 0:
                continue

            c_cubed = remaining_cubes_after_b
            if c_cubed >= 0:
                c = int(c_cubed**(1/3))
                if c >= b and c**3 == c_cubed:
                    count += 1
    return count

import sys

input_data = sys.stdin.read().strip().split()
results = []
for line in input_data:
    n = int(line)
    results.append(count_cube_sizes(n))

for result in results:
    print(result)"
996,A,Hit the Lottery,PROGRAMMING,"['dp', 'greedy']","Allen has a LOT of money. He has $n$ dollars in the bank. For security reasons, he wants to withdraw it in cash (we will not disclose the reasons here). The denominations for dollar bills are $1$, $5$, $10$, $20$, $100$. What is the minimum number of bills Allen could receive after withdrawing his entire balance?",The first and only line of input contains a single integer $n$ ($1 \le n \le 10^9$).,Output the minimum number of bills that Allen could receive.,"['125\n', '43\n', '1000000000\n']","['3\n', '5\n', '10000000\n']","In the first sample case, Allen can withdraw this with a $100$ dollar bill, a $20$ dollar bill, and a $5$ dollar bill. There is no way for Allen to receive $125$ dollars in one or two bills.

In the second sample case, Allen can withdraw two $20$ dollar bills and three $1$ dollar bills.

In the third sample case, Allen can withdraw $100000000$ (ten million!) $100$ dollar bills.",TIME_LIMIT_EXCEEDED,"n = int(input())

bills = [100, 20, 10, 5, 1]
i = 0
c = 0

while i < len(bills) and n > 0:
    bill = bills[i]
    while n >= bill:
        n -= bill
        c += 1
    i += 1

print(c)","def minimum_bills(n):

    denominations = [100, 20, 10, 5, 1]
    count = 0

    for denom in denominations:
        if n == 0:
            break

        count += n // denom
        n %= denom

    return count

if __name__ == ""__main__"":
    import sys
    input_data = sys.stdin.read().strip()
    n = int(input_data)
    result = minimum_bills(n)
    print(result)"
275,A,Lights Out,PROGRAMMING,['implementation'],"Lenny is playing a game on a 3<=×<=3 grid of lights. In the beginning of the game all lights are switched on. Pressing any of the lights will toggle it and all side-adjacent lights. The goal of the game is to switch all the lights off. We consider the toggling as follows: if the light was switched on then it will be switched off, if it was switched off then it will be switched on.

Lenny has spent some time playing with the grid and by now he has pressed each light a certain number of times. Given the number of times each light is pressed, you have to print the current state of each light.",The input consists of three rows. Each row contains three integers each between 0 to 100 inclusive. The *j*-th number in the *i*-th row is the number of times the *j*-th light of the *i*-th row of the grid is pressed.,"Print three lines, each containing three characters. The *j*-th character of the *i*-th line is ""1"" if and only if the corresponding light is switched on, otherwise it's ""0"".","['1 0 0\n0 0 0\n0 0 1\n', '1 0 1\n8 8 8\n2 0 3\n']","['001\n010\n100\n', '010\n011\n100\n']",none,OK,"from sys import stdin, stdout
def read():
	return stdin.readline().rstrip()

def read_int():
	return int(read())
 
def read_ints():
	return list(map(int, read().split()))
 
def solve():
	a=[[1,1,1],[1,1,1],[1,1,1]]
	for i in range(3):
		v=read_ints()
		for j in range(3):
			if v[j]%2==1:
				for (nx, ny) in [(i,j),(i-1,j),(i+1,j),(i,j-1),(i,j+1)]:
					if nx>=0 and ny>=0 and nx<3 and ny<3:
						a[nx][ny]=1-a[nx][ny]
	print(""\n"".join("""".join(str(x) for x in v) for v in a))

solve()","def toggle_lights(press_counts):

    grid = [[1 for _ in range(3)] for _ in range(3)]

    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]

    for i in range(3):
        for j in range(3):

            presses = press_counts[i][j]

            for _ in range(presses):
                grid[i][j] = 1 - grid[i][j]

                for di, dj in directions:
                    ni, nj = i + di, j + dj
                    if 0 <= ni < 3 and 0 <= nj < 3:
                        grid[ni][nj] = 1 - grid[ni][nj]

    output = []
    for row in grid:
        output.append(''.join(map(str, row)))

    return output

input_data = [
    list(map(int, input().split())) for _ in range(3)
]

result = toggle_lights(input_data)

for line in result:
    print(line)"
990,D,Graph And Its Complement,PROGRAMMING,"['constructive algorithms', 'graphs', 'implementation']","Given three numbers $n, a, b$. You need to find an adjacency matrix of such an undirected graph that the number of components in it is equal to $a$, and the number of components in its complement is $b$. The matrix must be symmetric, and all digits on the main diagonal must be zeroes.

In an undirected graph loops (edges from a vertex to itself) are not allowed. It can be at most one edge between a pair of vertices.

The adjacency matrix of an undirected graph is a square matrix of size $n$ consisting only of ""0"" and ""1"", where $n$ is the number of vertices of the graph and the $i$-th row and the $i$-th column correspond to the $i$-th vertex of the graph. The cell $(i,j)$ of the adjacency matrix contains $1$ if and only if the $i$-th and $j$-th vertices in the graph are connected by an edge.

A connected component is a set of vertices $X$ such that for every two vertices from this set there exists at least one path in the graph connecting this pair of vertices, but adding any other vertex to $X$ violates this rule.

The complement or inverse of a graph $G$ is a graph $H$ on the same vertices such that two distinct vertices of $H$ are adjacent if and only if they are not adjacent in $G$.","In a single line, three numbers are given $n, a, b \,(1 \le n \le 1000, 1 \le a, b \le n)$: is the number of vertexes of the graph, the required number of connectivity components in it, and the required amount of the connectivity component in it's complement.","If there is no graph that satisfies these constraints on a single line, print ""NO"" (without quotes).

Otherwise, on the first line, print ""YES""(without quotes). In each of the next $n$ lines, output $n$ digits such that $j$-th digit of $i$-th line must be $1$ if and only if there is an edge between vertices $i$ and $j$ in $G$ (and $0$ otherwise). Note that the matrix must be symmetric, and all digits on the main diagonal must be zeroes. 

If there are several matrices that satisfy the conditions — output any of them.","['3 1 2\n', '3 3 3\n']","['YES\n001\n001\n110\n', 'NO\n']",none,COMPILATION_ERROR,"using namespace std;

// int                      -10**9  to 10**9        4 byte       -2**31 to +2**31    -2147483647 to +2147483648
// long long int            -10**19 to 10**19       8 byte       -2**63 to +2**63
// unsigned long long int   -0      to 10**20       8 byte          0   to +2**64
// log(10 ** 5)             16.60
// log(10 ** 6)             19.93
// log(10 ** 9)             29.89
// INT_MAX                  0x7fffffff 2147483647
const int M1  = 1000000007;
const int M2  = 998244353;
const int N = 1005;

int mat[N][N];

int main(){
    fast;
    int n,m,k,a,b,temp;
    bool ok = true;
    cin>>n>>a>>b;
    if(a==1){
        if(b==1){
            int i = 1;
            fr1(j,2,n+1){
                mat[i][j] = mat[j][i] = 1;
                i++;
            }
        }
        else{
            int i = 1;
            int j = 2;
            while(b!=1){
                int jj = j;
                fr1(x,jj,n+1){
                    mat[i][x] = mat[x][i] = 1;
                }
                j++;
                i++;
                b--;
            }
        }
    }
    else{
        if(b==1){
            int i = 1;
            fr1(j,2,a+1){
                mat[i][j] = mat[j][i] = 1;
                i++;
            }
        }
        else{
            ok = false;
        }
    }
    if(ok){
        cout<<""YES""<<nl;
        fr1(i,1,n+1){
            fr1(j,1,n+1){
                cout<<mat[i][j];
            }
            cout<<nl;
        }
    }
    else{
        cout<<""NO""<<nl;
    }
    

}","def create_adjacency_matrix(n, a, b):

    if a + b - 1 > n or a > n or b > n:
        return ""NO""

    matrix = [[0] * n for _ in range(n)]

    for i in range(a):
        for j in range(i + 1, a):
            matrix[i][j] = 1
            matrix[j][i] = 1

    start = a
    for i in range(start, n):
        for j in range(i + 1, n):
            if (i < start + b) or (j < start + b):
                continue
            matrix[i][j] = 1
            matrix[j][i] = 1

    return ""YES"", matrix

n, a, b = map(int, input().strip().split())

result = create_adjacency_matrix(n, a, b)

if result == ""NO"":
    print(result)
else:
    print(result[0])
    for row in result[1]:
        print("""".join(map(str, row)))"
779,C,Dishonest Sellers,PROGRAMMING,"['constructive algorithms', 'greedy', 'sortings']","Igor found out discounts in a shop and decided to buy *n* items. Discounts at the store will last for a week and Igor knows about each item that its price now is *a**i*, and after a week of discounts its price will be *b**i*.

Not all of sellers are honest, so now some products could be more expensive than after a week of discounts.

Igor decided that buy at least *k* of items now, but wait with the rest of the week in order to save money as much as possible. Your task is to determine the minimum money that Igor can spend to buy all *n* items.","In the first line there are two positive integer numbers *n* and *k* (1<=≤<=*n*<=≤<=2·105, 0<=≤<=*k*<=≤<=*n*) — total number of items to buy and minimal number of items Igor wants to by right now.

The second line contains sequence of integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=104) — prices of items during discounts (i.e. right now).

The third line contains sequence of integers *b*1,<=*b*2,<=...,<=*b**n* (1<=≤<=*b**i*<=≤<=104) — prices of items after discounts (i.e. after a week).","Print the minimal amount of money Igor will spend to buy all *n* items. Remember, he should buy at least *k* items right now.","['3 1\n5 4 6\n3 1 5\n', '5 3\n3 4 7 10 3\n4 5 5 12 5\n']","['10\n', '25\n']","In the first example Igor should buy item 3 paying 6. But items 1 and 2 he should buy after a week. He will pay 3 and 1 for them. So in total he will pay 6 + 3 + 1 = 10.

In the second example Igor should buy right now items 1, 2, 4 and 5, paying for them 3, 4, 10 and 3, respectively. Item 3 he should buy after a week of discounts, he will pay 5 for it. In total he will spend 3 + 4 + 10 + 3 + 5 = 25.",OK,"import sys
from os import path
if (path.exists('input.txt') and path.exists('output.txt')):
    sys.stdout = open('output.txt', 'w')
    sys.stdin = open('input.txt', 'r')

def main():
    n, k = (int(i) for i in input().split())
    a = [int(i) for i in input().split()]
    b = [int(i) for i in input().split()]
    diffs = sorted([a[i] - b[i] for i in range(n)])
    ans = sum(a)
    for diff in diffs:
        if diff < 0 or k > 0:
            k -= 1
        else:
            ans -= diff
    print(ans)
                
main()","def min_cost_to_buy_items(n, k, a, b):

    difference = [a[i] - b[i] for i in range(n)]

    indices = sorted(range(n), key=lambda x: difference[x])

    total_cost = 0

    for i in range(k):
        total_cost += a[indices[i]]

    for i in range(k, n):
        total_cost += min(a[indices[i]], b[indices[i]])

    return total_cost

input_data = input().strip().split('\n')
n, k = map(int, input_data[0].split())
a = list(map(int, input_data[1].split()))
b = list(map(int, input_data[2].split()))

result = min_cost_to_buy_items(n, k, a, b)
print(result)"
8,A,Train and Peter,PROGRAMMING,['strings'],"Peter likes to travel by train. He likes it so much that on the train he falls asleep. 

Once in summer Peter was going by train from city A to city B, and as usual, was sleeping. Then he woke up, started to look through the window and noticed that every railway station has a flag of a particular colour.

The boy started to memorize the order of the flags' colours that he had seen. But soon he fell asleep again. Unfortunately, he didn't sleep long, he woke up and went on memorizing the colours. Then he fell asleep again, and that time he slept till the end of the journey.

At the station he told his parents about what he was doing, and wrote two sequences of the colours that he had seen before and after his sleep, respectively.

Peter's parents know that their son likes to fantasize. They give you the list of the flags' colours at the stations that the train passes sequentially on the way from A to B, and ask you to find out if Peter could see those sequences on the way from A to B, or from B to A. Remember, please, that Peter had two periods of wakefulness.

Peter's parents put lowercase Latin letters for colours. The same letter stands for the same colour, different letters — for different colours.","The input data contains three lines. The first line contains a non-empty string, whose length does not exceed 105, the string consists of lowercase Latin letters — the flags' colours at the stations on the way from A to B. On the way from B to A the train passes the same stations, but in reverse order. 

The second line contains the sequence, written by Peter during the first period of wakefulness. The third line contains the sequence, written during the second period of wakefulness. Both sequences are non-empty, consist of lowercase Latin letters, and the length of each does not exceed 100 letters. Each of the sequences is written in chronological order.","Output one of the four words without inverted commas: 
 -  «forward» — if Peter could see such sequences only on the way from A to B; -  «backward» — if Peter could see such sequences on the way from B to A; -  «both» — if Peter could see such sequences both on the way from A to B, and on the way from B to A; -  «fantasy» — if Peter could not see such sequences.","['atob\na\nb\n', 'aaacaaa\naca\naa\n']","['forward\n', 'both\n']","It is assumed that the train moves all the time, so one flag cannot be seen twice. There are no flags at stations A and B.",WRONG_ANSWER,"from pprint import pprint

def LCS(a, b):

    a, b = a + [], b + []
    while len(a) > 0 and len(b) > 0:
        if b[0] == a[0]: del(b[0])
        del(a[0])
        print(b)

    return True if len(b) == 0 else False 

s, a, b = list(input()), list(input()), list(input())
forward = LCS(s, a + b)
backward = LCS(s[::-1], a + b)
print(
    ""both"" if forward and backward 
    else ""forward"" if forward
    else ""backward"" if backward
    else ""fantasy""
)","def can_see_sequences(flags, first_sequence, second_sequence):

    forward_start = flags.find(first_sequence)
    if forward_start == -1:
        return 'fantasy'
    forward_end = flags.find(second_sequence, forward_start + len(first_sequence))
    if forward_end == -1:
        return 'fantasy'

    reversed_flags = flags[::-1]
    backward_start = reversed_flags.find(second_sequence)
    if backward_start == -1:
        return 'fantasy'
    backward_end = reversed_flags.find(first_sequence, backward_start + len(second_sequence))
    if backward_end == -1:
        return 'fantasy'

    forward = forward_start != -1 and forward_end != -1
    backward = backward_start != -1 and backward_end != -1

    if forward and backward:
        return 'both'
    elif forward:
        return 'forward'
    elif backward:
        return 'backward'
    else:
        return 'fantasy'

flags = input().strip()
first_sequence = input().strip()
second_sequence = input().strip()

result = can_see_sequences(flags, first_sequence, second_sequence)

print(result)"
59,A,Word,PROGRAMMING,"['implementation', 'strings']","Vasya is very upset that many people on the Net mix uppercase and lowercase letters in one word. That's why he decided to invent an extension for his favorite browser that would change the letters' register in every word so that it either only consisted of lowercase letters or, vice versa, only of uppercase ones. At that as little as possible letters should be changed in the word. For example, the word HoUse must be replaced with house, and the word ViP — with VIP. If a word contains an equal number of uppercase and lowercase letters, you should replace all the letters with lowercase ones. For example, maTRIx should be replaced by matrix. Your task is to use the given method on one given word.",The first line contains a word *s* — it consists of uppercase and lowercase Latin letters and possesses the length from 1 to 100.,"Print the corrected word *s*. If the given word *s* has strictly more uppercase letters, make the word written in the uppercase register, otherwise - in the lowercase one.","['HoUse\n', 'ViP\n', 'maTRIx\n']","['house\n', 'VIP\n', 'matrix\n']",none,OK,"import sys

user_input = sys.stdin.readline().strip()

lowercase_letters = list('abcdefghijklmnopqrstuvwxyz')
uppercase_letters = list('ABCDEFGHIJKLMNOPQRSTUVWXYZ')

sum_low = 0
sum_high = 0

for i in user_input:
    if i in lowercase_letters:
        sum_low += 1
    elif i in uppercase_letters:
        sum_high += 1

if sum_low > sum_high:
    a = user_input.lower()
    print(a)
elif sum_low < sum_high:
    a = user_input.upper()
    print(a)
else:
    a = user_input.lower()
    print(a)","def correct_word_case(s):

    upper_count = sum(1 for c in s if c.isupper())
    lower_count = len(s) - upper_count

    if upper_count > lower_count:
        return s.upper()
    else:
        return s.lower()

input_words = ['HoUse', 'ViP', 'maTRIx']

output_words = [correct_word_case(word) for word in input_words]
for word in output_words:
    print(word)"
1000,C,Covered Points Count,PROGRAMMING,"['data structures', 'implementation', 'sortings']","You are given $n$ segments on a coordinate line; each endpoint of every segment has integer coordinates. Some segments can degenerate to points. Segments can intersect with each other, be nested in each other or even coincide.

Your task is the following: for every $k \in [1..n]$, calculate the number of points with integer coordinates such that the number of segments that cover these points equals $k$. A segment with endpoints $l_i$ and $r_i$ covers point $x$ if and only if $l_i \le x \le r_i$.","The first line of the input contains one integer $n$ ($1 \le n \le 2 \cdot 10^5$) — the number of segments.

The next $n$ lines contain segments. The $i$-th line contains a pair of integers $l_i, r_i$ ($0 \le l_i \le r_i \le 10^{18}$) — the endpoints of the $i$-th segment.","Print $n$ space separated integers $cnt_1, cnt_2, \dots, cnt_n$, where $cnt_i$ is equal to the number of points such that the number of segments that cover these points equals to $i$.","['3\n0 3\n1 3\n3 8\n', '3\n1 3\n2 4\n5 7\n']","['6 2 1 \n', '5 2 0 \n']","The picture describing the first example:

<img class=""tex-graphics"" src=""https://espresso.codeforces.com/f76b3fe547bff6be5b14de76c8b78ba3efecc744.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

Points with coordinates $[0, 4, 5, 6, 7, 8]$ are covered by one segment, points $[1, 2]$ are covered by two segments and point $[3]$ is covered by three segments.

The picture describing the second example:

<img class=""tex-graphics"" src=""https://espresso.codeforces.com/6e9332c303e1bc5d6cf34c2d6c5e2a19c9417289.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

Points $[1, 4, 5, 6, 7]$ are covered by one segment, points $[2, 3]$ are covered by two segments and there are no points covered by three segments.",OK,"import collections

if __name__ == '__main__':
    n = int(input())
    ans = collections.defaultdict(int)
    for i in range(n):
        l, r = list(map(int, input().strip().split()))
        ans[l] += 1; ans[r + 1] -= 1
    ans = dict(sorted(ans.items(), key=lambda k: k[0]))
    keys = list(ans.keys())
    tot = len(keys)
    for i in range(1, tot):
        ans[keys[i]] += ans[keys[i - 1]]
    res = [0] * (n + 1)
    for i in range(tot - 1):
        res[ans[keys[i]]] += keys[i + 1] - keys[i]
    for i in range(1, n):
        print(res[i], end="" "")
    print(res[n])","def count_segment_points(n, segments):
    events = []

    for l, r in segments:
        events.append((l, 1))
        events.append((r + 1, -1))

    events.sort()

    count = [0] * (n + 1)
    current_coverage = 0
    last_position = None
    
    for position, event in events:
        if last_position is not None and position != last_position:

            covered_points = position - last_position
            if current_coverage > 0:
                count[current_coverage] += covered_points

        current_coverage += event
        last_position = position
    
    return count[1:]

import sys

input = sys.stdin.read
data = input().splitlines()

n = int(data[0])
segments = [tuple(map(int, line.split())) for line in data[1:n+1]]

result = count_segment_points(n, segments)
print("" "".join(map(str, result)))"
768,B,Code For 1,PROGRAMMING,"['constructive algorithms', 'dfs and similar', 'divide and conquer']","Jon fought bravely to rescue the wildlings who were attacked by the white-walkers at Hardhome. On his arrival, Sam tells him that he wants to go to Oldtown to train at the Citadel to become a maester, so he can return and take the deceased Aemon's place as maester of Castle Black. Jon agrees to Sam's proposal and Sam sets off his journey to the Citadel. However becoming a trainee at the Citadel is not a cakewalk and hence the maesters at the Citadel gave Sam a problem to test his eligibility. 

Initially Sam has a list with a single element *n*. Then he has to perform certain operations on this list. In each operation Sam must remove any element *x*, such that *x*<=&gt;<=1, from the list and insert at the same position , ,  sequentially. He must continue with these operations until all the elements in the list are either 0 or 1.

Now the masters want the total number of 1s in the range *l* to *r* (1-indexed). Sam wants to become a maester but unfortunately he cannot solve this problem. Can you help Sam to pass the eligibility test?","The first line contains three integers *n*, *l*, *r* (0<=≤<=*n*<=&lt;<=250, 0<=≤<=*r*<=-<=*l*<=≤<=105, *r*<=≥<=1, *l*<=≥<=1) – initial element and the range *l* to *r*.

It is guaranteed that *r* is not greater than the length of the final list.",Output the total number of 1s in the range *l* to *r* in the final sequence.,"['7 2 5\n', '10 3 10\n']","['4\n', '5\n']","Consider first example:

<img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/288fbb682a6fa1934a47b763d6851f9d32a06150.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

Elements on positions from 2-nd to 5-th in list is [1, 1, 1, 1]. The number of ones is 4.

For the second example:

<img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/52e9bc51ef858cacc27fc274c7ba9419d5c1ded9.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

Elements on positions from 3-rd to 10-th in list is [1, 1, 1, 0, 1, 0, 1, 0]. The number of ones is 5.",WRONG_ANSWER,"from math import floor, log2

import sys
sys.setrecursionlimit(10**4)

def numOfChildren(x):
    n = floor(log2(x))
    res = 0
    for i in range(n - 1):
        res += 2**i
    return res + (3 * (2**(n-1)))

n, l, r = map(int, input().split())

def dfs(node, i, j):

    if j < l or r < i:
        return 0

    if node == 0 or node == 1:
        return node

    m = l + numOfChildren(node//2)

    res = 0

    if i <= m <= j:
        res += node % 2

    res += dfs(node//2, i, m - 1)
    res += dfs(node//2, m + 1, j)

    return res

print(dfs(n, 1, numOfChildren(n)))","def count_ones_in_range(n, l, r):

    sequence = [n]
    
    while any(x > 1 for x in sequence):
        new_sequence = []
        for x in sequence:
            if x > 1:

                new_sequence.append(x // 2)
                new_sequence.append(x - x // 2)
            else:
                new_sequence.append(x)
        sequence = new_sequence

    return sequence[l-1:r].count(1)

import sys
input_data = sys.stdin.read().strip().splitlines()

for line in input_data:
    n, l, r = map(int, line.split())
    result = count_ones_in_range(n, l, r)
    print(result)"
73,D,FreeDiv,PROGRAMMING,"['dfs and similar', 'graphs', 'greedy']","Vasya plays FreeDiv. In this game he manages a huge state, which has *n* cities and *m* two-way roads between them. Unfortunately, not from every city you can reach any other one moving along these roads. Therefore Vasya decided to divide the state into provinces so that in every province, one could reach from every city all the cities of the province, but there are no roads between provinces. 

Unlike other turn-based strategies, in FreeDiv a player has the opportunity to build tunnels between cities. The tunnels are two-way roads along which one can move armies undetected by the enemy. However, no more than one tunnel can be connected to each city. As for Vasya, he wants to build a network of tunnels so that any pair of cities in his state were reachable by some path consisting of roads and a tunnels. But at that no more than *k* tunnels are connected to each province (otherwise, the province will be difficult to keep in case other provinces are captured by enemy armies).

Vasya discovered that maybe he will not be able to build such a network for the current condition of the state. Maybe he'll have first to build several roads between cities in different provinces to merge the provinces. Your task is to determine the minimum number of roads Vasya needs to build so that it was possible to build the required network of tunnels in the resulting state.","The first line contains three integers *n*, *m* and *k* (1<=≤<=*n*,<=*k*<=≤<=106,<=0<=≤<=*m*<=≤<=106). Each of the next *m* lines contains two integers. They are the numbers of cities connected by a corresponding road. No road connects city to itself and there is at most one road between each pair of cities.","Print a single number, the minimum number of additional roads.","['3 3 2\n1 2\n2 3\n3 1\n', '4 2 2\n1 2\n3 4\n', '4 0 2\n']","['0', '0', '1']","In the first example only one province exists, so it is not necessary to build any tunnels or roads.

In the second example two provinces exist. It is possible to merge the provinces by building a tunnel between cities 1 and 3.

In the third example at least one additional road is necessary. For example it is possible to build additional road between cities 1 and 2 and build two tunnels between cities 1 and 3, 2 and 4 after that.",WRONG_ANSWER,"import sys

class UnionFind:
    def __init__(self, n: int):
        self.data = list(range(n))
        self.rank = [1] * n
        self.size = [1] * n
        self.count = n
    
    def find(self, x: int) -> int:
        y = x
        while self.data[y] != y:
            y = self.data[y]
        while self.data[x] != y:
            x, self.data[x] = self.data[x], y
        return y

    def union(self, x: int, y: int):
        x, y = self.find(x), self.find(y)
        if x == y:
            return
        if self.rank[x] == self.rank[y]:
            self.rank[x] += 1
        if self.rank[x] > self.rank[y]:
            self.data[y] = x
            self.size[x] += self.size[y]
        else:
            self.data[x] = y
            self.size[y] += self.size[x]
        self.count -= 1

N, K = 0, 0
edges = []

result = 0

def read_input():
    global N, K
    readline = sys.stdin.readline
    N, M, K = [int(w) for w in readline().split()]
    for _ in range(M):
        edges.append([int(w) - 1 for w in readline().split()])

def solve():
    global result
    uf = UnionFind(N)
    for u, v in edges:
        uf.union(u, v)
    if K == 1:
        result = max(0, uf.count - 2)
        return
    max_tunnel_cap = 0
    seen = set()
    for i in range(N):
        x = uf.find(i)
        if x in seen:
            continue
        seen.add(x)
        max_tunnel_cap += min(K, uf.size[x])
    result = max(0, N - (max_tunnel_cap // 2) - 1)

def write_output():
    print(result)

read_input()
solve()
write_output()","def find_provinces(n, roads):
    from collections import defaultdict, deque

    graph = defaultdict(list)
    for u, v in roads:
        graph[u].append(v)
        graph[v].append(u)

    visited = [False] * (n + 1)
    provinces = 0

    for city in range(1, n + 1):
        if not visited[city]:
            provinces += 1
            queue = deque([city])
            while queue:
                current = queue.popleft()
                visited[current] = True
                for neighbor in graph[current]:
                    if not visited[neighbor]:
                        queue.append(neighbor)

    return provinces

def minimum_roads(n, m, k, roads):
    provinces = find_provinces(n, roads)

    return max(0, provinces - 1 if k > 0 else provinces)

if __name__ == ""__main__"":
    import sys
    input_data = sys.stdin.read().strip().split('\n')
    results = []

    for i in range(len(input_data)):
        if i == 0:
            n, m, k = map(int, input_data[i].split())
        else:
            u, v = map(int, input_data[i].split())
            if i-1 < m:
                roads.append((u, v))

    roads = []
    result = minimum_roads(n, m, k, roads)
    results.append(str(result))

    print('\n'.join(results))"
448,B,Suffix Structures,PROGRAMMING,"['implementation', 'strings']","Bizon the Champion isn't just a bison. He also is a favorite of the ""Bizons"" team.

At a competition the ""Bizons"" got the following problem: ""You are given two distinct words (strings of English letters), *s* and *t*. You need to transform word *s* into word *t*"". The task looked simple to the guys because they know the suffix data structures well. Bizon Senior loves suffix automaton. By applying it once to a string, he can remove from this string any single character. Bizon Middle knows suffix array well. By applying it once to a string, he can swap any two characters of this string. The guys do not know anything about the suffix tree, but it can help them do much more. 

Bizon the Champion wonders whether the ""Bizons"" can solve the problem. Perhaps, the solution do not require both data structures. Find out whether the guys can solve the problem and if they can, how do they do it? Can they solve it either only with use of suffix automaton or only with use of suffix array or they need both structures? Note that any structure may be used an unlimited number of times, the structures may be used in any order.",The first line contains a non-empty word *s*. The second line contains a non-empty word *t*. Words *s* and *t* are different. Each word consists only of lowercase English letters. Each word contains at most 100 letters.,"In the single line print the answer to the problem. Print ""need tree"" (without the quotes) if word *s* cannot be transformed into word *t* even with use of both suffix array and suffix automaton. Print ""automaton"" (without the quotes) if you need only the suffix automaton to solve the problem. Print ""array"" (without the quotes) if you need only the suffix array to solve the problem. Print ""both"" (without the quotes), if you need both data structures to solve the problem.

It's guaranteed that if you can solve the problem only with use of suffix array, then it is impossible to solve it only with use of suffix automaton. This is also true for suffix automaton.","['automaton\ntomat\n', 'array\narary\n', 'both\nhot\n', 'need\ntree\n']","['automaton\n', 'array\n', 'both\n', 'need tree\n']","In the third sample you can act like that: first transform ""both"" into ""oth"" by removing the first character using the suffix automaton and then make two swaps of the string using the suffix array and get ""hot"".",OK,"def main():
	s = input()
	t = input()
	lent, lens = len(t), len(s)
	def is_in(s, t):
		i, j = 0, 0
		while i < lens and j < lent:
			if s[i] == t[j]:
				j += 1
			i += 1
		return j == lent
	tmps = ''.join(sorted(s))
	tmpt = ''.join(sorted(t))
	msg = 'automaton' if is_in(s, t) else 'array' if is_in(tmps, tmpt) and lent == lens else 'both' if is_in(tmps, tmpt) else 'need tree'
	print(msg)
	return

if __name__ == ""__main__"":
	main()","def transform_possible(s, t):

    if is_subsequence(s, t):
        return ""automaton""

    if can_form_with_array(s, t):
        return ""array""

    if can_transform_with_both(s, t):
        return ""both""

    return ""need tree""

def is_subsequence(s, t):

    it = iter(s)
    return all(char in it for char in t)

def can_form_with_array(s, t):

    from collections import Counter
    return Counter(s) == Counter(t)

def can_transform_with_both(s, t):

    from collections import Counter
    count_s = Counter(s)
    count_t = Counter(t)

    for char in count_t:
        if count_t[char] > count_s.get(char, 0):
            return False
    return True

input_data = [
    'automaton\ntomat\n', 
    'array\narary\n', 
    'both\nhot\n', 
    'need\ntree\n'
]

output = []
for case in input_data:
    s, t = case.strip().split('\n')
    result = transform_possible(s, t)
    output.append(result)

for res in output:
    print(res)"
747,A,Display Size,PROGRAMMING,"['brute force', 'math']","A big company decided to launch a new series of rectangular displays, and decided that the display must have exactly *n* pixels. 

Your task is to determine the size of the rectangular display — the number of lines (rows) of pixels *a* and the number of columns of pixels *b*, so that:
 -  there are exactly *n* pixels on the display; -  the number of rows does not exceed the number of columns, it means *a*<=≤<=*b*; -  the difference *b*<=-<=*a* is as small as possible.",The first line contains the positive integer *n* (1<=≤<=*n*<=≤<=106) — the number of pixels display should have.,Print two integers — the number of rows and columns on the display.,"['8\n', '64\n', '5\n', '999999\n']","['2 4\n', '8 8\n', '1 5\n', '999 1001\n']","In the first example the minimum possible difference equals 2, so on the display should be 2 rows of 4 pixels.

In the second example the minimum possible difference equals 0, so on the display should be 8 rows of 8 pixels.

In the third example the minimum possible difference equals 4, so on the display should be 1 row of 5 pixels.",WRONG_ANSWER,"from math import sqrt
def find_factors(number):
    factors = []
    for i in range(1, (number + 1)):
        if number % i == 0:
            factors.append(i)
    return factors
c=int(input())
v=find_factors(c);len=len(v)

if len==2:
    print(*v)
elif sqrt(c)==int(sqrt(c)):print(int(sqrt(c)),int(sqrt(c)))
else:
    aa=v[(len+1)//2]

    if aa*aa==c:
        print(aa,aa)
    else:

        if abs(v[(len+1)//2]-v[((len+1)//2-1)])>abs(v[(len+1)//2]-v[(len+1)//2+1]):print(min(v[(len+1)//2],v[(len+1)//2+1]),max(v[(len+1)//2],v[(len+1)//2+1]))
        else:print(min(v[(len+1)//2],v[(len+1)//2-1]),max(v[(len+1)//2],v[(len+1)//2-1]))","def find_display_dimensions(n):

    a, b = 1, n

    for i in range(1, int(n**0.5) + 1):
        if n % i == 0:

            j = n // i

            if i <= j and (j - i < b - a):
                a, b = i, j

    return a, b

inputs = ['8', '64', '5', '999999']
output = []

for item in inputs:
    n = int(item)
    a, b = find_display_dimensions(n)
    output.append(f""{a} {b}"")

print(""\n"".join(output))"
841,A,Generous Kefa,PROGRAMMING,"['brute force', 'implementation']","One day Kefa found *n* baloons. For convenience, we denote color of *i*-th baloon as *s**i* — lowercase letter of the Latin alphabet. Also Kefa has *k* friends. Friend will be upset, If he get two baloons of the same color. Kefa want to give out all baloons to his friends. Help Kefa to find out, can he give out all his baloons, such that no one of his friens will be upset — print «YES», if he can, and «NO», otherwise. Note, that Kefa's friend will not upset, if he doesn't get baloons at all.","The first line contains two integers *n* and *k* (1<=≤<=*n*,<=*k*<=≤<=100) — the number of baloons and friends.

Next line contains string *s* — colors of baloons.","Answer to the task — «YES» or «NO» in a single line.

You can choose the case (lower or upper) for each letter arbitrary.","['4 2\naabb\n', '6 3\naacaab\n']","['YES\n', 'NO\n']","In the first sample Kefa can give 1-st and 3-rd baloon to the first friend, and 2-nd and 4-th to the second.

In the second sample Kefa needs to give to all his friends baloons of color a, but one baloon will stay, thats why answer is «NO».",OK,"def balloons(s, k):
    for i in s:
        x = s.count(i)
        if x > k:
            return ""NO""
    return ""YES""

n, k = list(map(int, input().split()))
s = input()
print(balloons(s, k))","n, k = map(int, input().split())

s = input().strip()

color_count = {}
for color in s:
    if color in color_count:
        color_count[color] += 1
    else:
        color_count[color] = 1

can_distribute = True
for count in color_count.values():
    if count > k:
        can_distribute = False
        break

print(""YES"" if can_distribute else ""NO"")"
0,none,none,none,['none'],"Limak is a little bear who loves to play. Today he is playing by destroying block towers. He built *n* towers in a row. The *i*-th tower is made of *h**i* identical blocks. For clarification see picture for the first sample.

Limak will repeat the following operation till everything is destroyed.

Block is called internal if it has all four neighbors, i.e. it has each side (top, left, down and right) adjacent to other block or to the floor. Otherwise, block is boundary. In one operation Limak destroys all boundary blocks. His paws are very fast and he destroys all those blocks at the same time.

Limak is ready to start. You task is to count how many operations will it take him to destroy all towers.","The first line contains single integer *n* (1<=≤<=*n*<=≤<=105).

The second line contains *n* space-separated integers *h*1,<=*h*2,<=...,<=*h**n* (1<=≤<=*h**i*<=≤<=109) — sizes of towers.",Print the number of operations needed to destroy all towers.,"['6\n2 1 4 6 2 2\n', '7\n3 3 3 1 3 3 3\n']","['3\n', '2\n']",The picture below shows all three operations for the first sample test. Each time boundary blocks are marked with red color.,OK,"def main():
    n = int(input())
    a = [int(i) for i in input().split()]
    dpl = [1] * n
    dpr = [1] * n
    for i in range(1, n):
        dpl[i] = min(dpl[i - 1] + 1, a[i])
    for i in range(n - 2, -1, -1):
        dpr[i] = min(dpr[i + 1] + 1, a[i])
    ans = 0
    for i in range(n):
        ans = max(ans, min(dpl[i], dpr[i]))
    print(ans)
main()","def count_operations(n, heights):
    operations = 0

    while True:

        boundary_found = False
        for i in range(n):
            if (i == 0 or heights[i] > heights[i - 1]) or (i == n - 1 or heights[i] > heights[i + 1]):
                boundary_found = True
                heights[i] -= 1
        
        if not boundary_found:
            break
        
        operations += 1

    return operations

n = int(input())
heights = list(map(int, input().split()))

result = count_operations(n, heights)

print(result)"
47,B,Coins,PROGRAMMING,['implementation'],"One day Vasya came across three Berland coins. They didn't have any numbers that's why Vasya didn't understand how their denominations differ. He supposed that if one coin is heavier than the other one, then it should be worth more. Vasya weighed all the three pairs of coins on pan balance scales and told you the results. Find out how the deminations of the coins differ or if Vasya has a mistake in the weighting results. No two coins are equal.","The input data contains the results of all the weighting, one result on each line. It is guaranteed that every coin pair was weighted exactly once. Vasya labelled the coins with letters «A», «B» and «C». Each result is a line that appears as (letter)(&gt; or &lt; sign)(letter). For example, if coin ""A"" proved lighter than coin ""B"", the result of the weighting is A&lt;B.","It the results are contradictory, print Impossible. Otherwise, print without spaces the rearrangement of letters «A», «B» and «C» which represent the coins in the increasing order of their weights.","['A&gt;B\nC&lt;B\nA&gt;C\n', 'A&lt;B\nB&gt;C\nC&gt;A\n']","['CBA', 'ACB']",none,WRONG_ANSWER,"def Coins():
    a ,b, c= 0,0,0
    d = {""A"":0 , ""B"":0 , ""C"":0}
    for _ in range(3):
        data = input()
        if data == ""A>B"" or data == ""B<A"" :
            d[""A""] += 1
            d[""B""] -= 1

        elif data == ""A<B"" or data == ""B>A"":
            d[""A""] -= 1
            d[""B""] += 1
        elif data == ""B>C"" or data == ""C<B"":
            d[""B""] += 1
            d[""C""] -= 1
        elif data == ""B<C"" or data == ""C>B"":
            d[""C""] += 1
            d[""B""] -= 1
        elif data == ""A>C"" or data == ""C<A"":
            d[""A""] += 1
            d[""C""] -= 1
        elif data == ""A<C"" or data == ""C>A"":
            d[""A""] -= 1
            d[""C""] += 1
    sort_d = dict(sorted(d.items(), key=lambda x: x[1], reverse=False))
    final = """"
    for i in sort_d.keys():
        final += i
    return final

print(Coins())","def determine_coin_order(weighting_results):
    results = []
    
    for weights in weighting_results:
        count = {'A': 0, 'B': 0, 'C': 0}

        for result in weights.strip().split('\n'):
            left, relation, right = result[0], result[1], result[2]

            if relation == '>':
                count[left] += 1
            else:
                count[right] += 1

        if len(set(count.values())) == 3:
            order = sorted(count.items(), key=lambda x: x[1])
            results.append(''.join([x[0] for x in order]))
        else:
            results.append(""Impossible"")
    
    return results

demo_input = ['A>B\nC<B\nA>C\n', 'A<B\nB>C\nC>A\n']

output = determine_coin_order(demo_input)
print(output)"
664,A,Complicated GCD,PROGRAMMING,"['math', 'number theory']","Greatest common divisor *GCD*(*a*,<=*b*) of two positive integers *a* and *b* is equal to the biggest integer *d* such that both integers *a* and *b* are divisible by *d*. There are many efficient algorithms to find greatest common divisor *GCD*(*a*,<=*b*), for example, Euclid algorithm. 

Formally, find the biggest integer *d*, such that all integers *a*,<=*a*<=+<=1,<=*a*<=+<=2,<=...,<=*b* are divisible by *d*. To make the problem even more complicated we allow *a* and *b* to be up to googol, 10100 — such number do not fit even in 64-bit integer type!",The only line of the input contains two integers *a* and *b* (1<=≤<=*a*<=≤<=*b*<=≤<=10100).,Output one integer — greatest common divisor of all integers from *a* to *b* inclusive.,"['1 2\n', '61803398874989484820458683436563811772030917980576 61803398874989484820458683436563811772030917980576\n']","['1\n', '61803398874989484820458683436563811772030917980576\n']",none,TIME_LIMIT_EXCEEDED,"def gcd(a,b):
    while b!=0:
        a, b = b, a%b
    return a
 
a, b = map(int, input().split())
c=0
k=0
numb=[]
for i in range(a, b+1):
    for j in range(a, b+1):
        numb.append(gcd(i,j))
for elem in numb:
    for i in range(a, b+1):
        if i%elem!=0:
            numb = list(filter((elem).__ne__, numb))
print(*list(set(numb)))","def gcd_range(a, b):

    if a == b:
        return a
    else:
        return 1

input_data = input().strip()
a_str, b_str = input_data.split()

a = int(a_str)
b = int(b_str)

result = gcd_range(a, b)

print(result)"
577,B,Modulo Sum,PROGRAMMING,"['combinatorics', 'data structures', 'dp', 'two pointers']","You are given a sequence of numbers *a*1,<=*a*2,<=...,<=*a**n*, and a number *m*.

Check if it is possible to choose a non-empty subsequence *a**i**j* such that the sum of numbers in this subsequence is divisible by *m*.","The first line contains two numbers, *n* and *m* (1<=≤<=*n*<=≤<=106, 2<=≤<=*m*<=≤<=103) — the size of the original sequence and the number such that sum should be divisible by it.

The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (0<=≤<=*a**i*<=≤<=109).","In the single line print either ""YES"" (without the quotes) if there exists the sought subsequence, or ""NO"" (without the quotes), if such subsequence doesn't exist.","['3 5\n1 2 3\n', '1 6\n5\n', '4 6\n3 1 1 3\n', '6 6\n5 5 5 5 5 5\n']","['YES\n', 'NO\n', 'YES\n', 'YES\n']","In the first sample test you can choose numbers 2 and 3, the sum of which is divisible by 5.

In the second sample test the single non-empty subsequence of numbers is a single number 5. Number 5 is not divisible by 6, that is, the sought subsequence doesn't exist.

In the third sample test you need to choose two numbers 3 on the ends.

In the fourth sample test you can take the whole subsequence.",RUNTIME_ERROR,"def subset_sum(nums, total):
    dp = [False] * (total + 1)
    dp[0] = True
    n = len(nums)

    for i in range(1, n + 1):
        for j in range(total, -1, -1):
            if j - nums[i - 1] >= 0:
                dp[j] |= dp[j - nums[i - 1]]

    return dp[total]

def solve(tc):
    n, m = map(int, input().split())
    v = list(map(int, input().split()))

    def sum_vector(vec):
        return sum(vec)

    sum_val = sum_vector(v)
    ans = False
    v.sort()
    if v[0] == 0:
        print(""yes"")
        return

    subset_sum(v, m * (sum_val // m))
    for i in range(1, (sum_val // m) + 1):
        if i * m < sum_val:
            ans |= dp[i * m]

    if ans:
        print(""yes"")
    else:
        print(""no"")

def main():
    t = 1

    for i in range(1, t + 1):
        solve(i)

if __name__ == ""__main__"":
    main()","def is_divisible_subsequence(n, m, a):

    if n >= m:
        return ""YES""

    remainders = set()
    
    for number in a:

        remainder = number % m

        if remainder == 0 or remainder in remainders:
            return ""YES""

        remainders.add(remainder)
    
    return ""NO""

input_data = input().strip().split('\n')
n, m = map(int, input_data[0].split())
a = list(map(int, input_data[1].split()))

print(is_divisible_subsequence(n, m, a))"
522,A,Reposts,PROGRAMMING,"['*special', 'dfs and similar', 'dp', 'graphs', 'trees']","One day Polycarp published a funny picture in a social network making a poll about the color of his handle. Many of his friends started reposting Polycarp's joke to their news feed. Some of them reposted the reposts and so on.

These events are given as a sequence of strings ""name1 reposted name2"", where name1 is the name of the person who reposted the joke, and name2 is the name of the person from whose news feed the joke was reposted. It is guaranteed that for each string ""name1 reposted name2"" user ""name1"" didn't have the joke in his feed yet, and ""name2"" already had it in his feed by the moment of repost. Polycarp was registered as ""Polycarp"" and initially the joke was only in his feed.

Polycarp measures the popularity of the joke as the length of the largest repost chain. Print the popularity of Polycarp's joke.","The first line of the input contains integer *n* (1<=≤<=*n*<=≤<=200) — the number of reposts. Next follow the reposts in the order they were made. Each of them is written on a single line and looks as ""name1 reposted name2"". All the names in the input consist of lowercase or uppercase English letters and/or digits and have lengths from 2 to 24 characters, inclusive.

We know that the user names are case-insensitive, that is, two names that only differ in the letter case correspond to the same social network user.",Print a single integer — the maximum length of a repost chain.,"['5\ntourist reposted Polycarp\nPetr reposted Tourist\nWJMZBMR reposted Petr\nsdya reposted wjmzbmr\nvepifanov reposted sdya\n', '6\nMike reposted Polycarp\nMax reposted Polycarp\nEveryOne reposted Polycarp\n111 reposted Polycarp\nVkCup reposted Polycarp\nCodeforces reposted Polycarp\n', '1\nSoMeStRaNgEgUe reposted PoLyCaRp\n']","['6\n', '2\n', '2\n']",none,WRONG_ANSWER,"from collections import defaultdict, deque
n = int(input())
g = {}
for _ in range(n):
    p = input().split()
    g[p[2].lower()] = g.get(p[0].lower(),[]) + [p[0].lower()]
ans = -float('inf')
elem = g.keys()

dp = 0
que = deque(['polycarp'])
while que:
    l = len(que)
    for _ in range(l):
        temp = que.popleft()
        
        if temp in g:
            for nb in g[temp]:
                que.append(nb)
    dp+=1
print(dp)","def max_repost_chain(n, reposts):

    repost_depth = {'Polycarp': 1}
    max_depth = 1

    for repost in reposts:

        parts = repost.lower().split()
        name1 = parts[0]
        name2 = parts[2]

        if name2 in repost_depth:
            repost_depth[name1] = repost_depth[name2] + 1
            max_depth = max(max_depth, repost_depth[name1])

    return max_depth

n = int(input())
reposts = [input().strip() for _ in range(n)]

print(max_repost_chain(n, reposts))"
0,none,none,none,['none'],"Astronaut Natasha arrived on Mars. She knows that the Martians are very poor aliens. To ensure a better life for the Mars citizens, their emperor decided to take tax from every tourist who visited the planet. Natasha is the inhabitant of Earth, therefore she had to pay the tax to enter the territory of Mars.

There are $n$ banknote denominations on Mars: the value of $i$-th banknote is $a_i$. Natasha has an infinite number of banknotes of each denomination.

Martians have $k$ fingers on their hands, so they use a number system with base $k$. In addition, the Martians consider the digit $d$ (in the number system with base $k$) divine. Thus, if the last digit in Natasha's tax amount written in the number system with the base $k$ is $d$, the Martians will be happy. Unfortunately, Natasha does not know the Martians' divine digit yet.

Determine for which values $d$ Natasha can make the Martians happy.

Natasha can use only her banknotes. Martians don't give her change.","The first line contains two integers $n$ and $k$ ($1 \le n \le 100\,000$, $2 \le k \le 100\,000$) — the number of denominations of banknotes and the base of the number system on Mars.

The second line contains $n$ integers $a_1, a_2, \ldots, a_n$ ($1 \le a_i \le 10^9$) — denominations of banknotes on Mars.

All numbers are given in decimal notation.","On the first line output the number of values $d$ for which Natasha can make the Martians happy.

In the second line, output all these values in increasing order.

Print all numbers in decimal notation.","['2 8\n12 20\n', '3 10\n10 20 30\n']","['2\n0 4 ', '1\n0 ']","Consider the first test case. It uses the octal number system.

If you take one banknote with the value of $12$, you will get $14_8$ in octal system. The last digit is $4_8$.

If you take one banknote with the value of $12$ and one banknote with the value of $20$, the total value will be $32$. In the octal system, it is $40_8$. The last digit is $0_8$.

If you take two banknotes with the value of $20$, the total value will be $40$, this is $50_8$ in the octal system. The last digit is $0_8$.

No other digits other than $0_8$ and $4_8$ can be obtained. Digits $0_8$ and $4_8$ could also be obtained in other ways.

The second test case uses the decimal number system. The nominals of all banknotes end with zero, so Natasha can give the Martians only the amount whose decimal notation also ends with zero.",WRONG_ANSWER,"def hcfnaive(a,b): 
    if(b==0): 
        return a 
    else: 
        return hcfnaive(b,a%b) 
n,k=map(int,input().split())
a=input().split()
ls=[]
for i in range(n):
    ls.append(int(a[i])%k)
ls=list(set(ls))
if(len(ls)==1):
    if(ls[0]==0):
        print(1)
        print(0)
    else:    
        ans=[]
        for i in range(k):
            if(i%ls[0]==0):
                ans.append(i)
        print(len(ans))
        print(*ans)
else:
    gcd=hcfnaive(ls[0],ls[1])
    for i in range(2,len(ls)):
        gcd=hcfnaive(gcd,ls[i])
    ans=[]
    for i in range(k):
        if(i%gcd==0):
            ans.append(i)
    print(len(ans))
    print(*ans)","def possible_divine_digits(n, k, denominations):

    last_digits = set()

    for a in denominations:

        last_digit = a % k
        last_digits.add(last_digit)

    result_digits = set()
    for d in last_digits:

        current = d
        while current < k:
            result_digits.add(current)
            current += k

    result_digits = sorted(result_digits)

    print(len(result_digits))
    print("" "".join(map(str, result_digits)))

input_lines = input().strip().split('\n')
n, k = map(int, input_lines[0].strip().split())
denominations = list(map(int, input_lines[1].strip().split()))

possible_divine_digits(n, k, denominations)"
598,D,Igor In the Museum,PROGRAMMING,"['dfs and similar', 'graphs', 'shortest paths']","Igor is in the museum and he wants to see as many pictures as possible.

Museum can be represented as a rectangular field of *n*<=×<=*m* cells. Each cell is either empty or impassable. Empty cells are marked with '.', impassable cells are marked with '*'. Every two adjacent cells of different types (one empty and one impassable) are divided by a wall containing one picture.

At the beginning Igor is in some empty cell. At every moment he can move to any empty cell that share a side with the current one.

For several starting positions you should calculate the maximum number of pictures that Igor can see. Igor is able to see the picture only if he is in the cell adjacent to the wall with this picture. Igor have a lot of time, so he will examine every picture he can see.","First line of the input contains three integers *n*, *m* and *k* (3<=≤<=*n*,<=*m*<=≤<=1000,<=1<=≤<=*k*<=≤<=*min*(*n*·*m*,<=100<=000)) — the museum dimensions and the number of starting positions to process.

Each of the next *n* lines contains *m* symbols '.', '*' — the description of the museum. It is guaranteed that all border cells are impassable, so Igor can't go out from the museum.

Each of the last *k* lines contains two integers *x* and *y* (1<=≤<=*x*<=≤<=*n*,<=1<=≤<=*y*<=≤<=*m*) — the row and the column of one of Igor's starting positions respectively. Rows are numbered from top to bottom, columns — from left to right. It is guaranteed that all starting positions are empty cells.","Print *k* integers — the maximum number of pictures, that Igor can see if he starts in corresponding position.","['5 6 3\n******\n*..*.*\n******\n*....*\n******\n2 2\n2 5\n4 3\n', '4 4 1\n****\n*..*\n*.**\n****\n3 2\n']","['6\n4\n10\n', '8\n']",none,RUNTIME_ERROR,"import sys, collections, numpy

m,n,k = map(int, sys.stdin.readline().split())
grid = []

for i in range(m):
    s = sys.stdin.readline()
    grid.append(list(s))

counts = {}

def bfs(r, c, cId):
    Q = collections.deque()
    Q.append((r,c))
    grid[r][c] = cId
    picture = 0

    while Q:
        r,c = Q.pop()

        for nr, nc in (r-1, c), (r+1,c), (r, c-1), (r, c+1):            
            if grid[nr][nc] == '*':
                picture += 1
                continue
            elif grid[nr][nc] == '.':              
                grid[nr][nc] = cId
                Q.appendleft((nr,nc))

    counts[cId] = picture

compNum = 0

for _ in range(k):
    r,c = map(int, sys.stdin.readline().split())
    r -= 1
    c -= 1

    if grid[r][c] == '.':
        bfs(r,c, compNum)
        compNum += 1
    
    compId = grid[r][c]
    print(counts[compId])","def count_pictures(n, m, museum, starting_positions):

    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]

    pictures_count = [[0] * m for _ in range(n)]
    
    def dfs(x, y, visited):
        stack = [(x, y)]
        local_pictures = 0
        
        while stack:
            cx, cy = stack.pop()
            if visited[cx][cy]:
                continue
            visited[cx][cy] = True

            for dx, dy in directions:
                nx, ny = cx + dx, cy + dy
                if 0 <= nx < n and 0 <= ny < m:
                    if museum[nx][ny] == '*':
                        local_pictures += 1
                    elif museum[nx][ny] == '.' and not visited[nx][ny]:
                        stack.append((nx, ny))
        
        return local_pictures
    
    visited = [[False] * m for _ in range(n)]
    results = []

    for i in range(n):
        for j in range(m):
            if museum[i][j] == '.' and not visited[i][j]:

                picture_count = dfs(i, j, visited)

                stack = [(i, j)]
                component_cells = []
                
                while stack:
                    cx, cy = stack.pop()
                    if pictures_count[cx][cy] != 0:
                        continue
                    pictures_count[cx][cy] = picture_count
                    component_cells.append((cx, cy))
                    
                    for dx, dy in directions:
                        nx, ny = cx + dx, cy + dy
                        if 0 <= nx < n and 0 <= ny < m and museum[nx][ny] == '.' and pictures_count[nx][ny] == 0:
                            stack.append((nx, ny))

    for x, y in starting_positions:
        results.append(pictures_count[x-1][y-1])
    
    return results

import sys
input = sys.stdin.read
data = input().split('\n')

n, m, k = map(int, data[0].strip().split())
museum = []
for i in range(1, n + 1):
    museum.append(data[i].strip())
starting_positions = []
for i in range(n + 1, n + k + 1):
    x, y = map(int, data[i].strip().split())
    starting_positions.append((x, y))

results = count_pictures(n, m, museum, starting_positions)
for result in results:
    print(result)"
71,A,Way Too Long Words,PROGRAMMING,['strings'],"Sometimes some words like ""localization"" or ""internationalization"" are so long that writing them many times in one text is quite tiresome.

Let's consider a word too long, if its length is strictly more than 10 characters. All too long words should be replaced with a special abbreviation.

This abbreviation is made like this: we write down the first and the last letter of a word and between them we write the number of letters between the first and the last letters. That number is in decimal system and doesn't contain any leading zeroes.

Thus, ""localization"" will be spelt as ""l10n"", and ""internationalization» will be spelt as ""i18n"".

You are suggested to automatize the process of changing the words with abbreviations. At that all too long words should be replaced by the abbreviation and the words that are not too long should not undergo any changes.",The first line contains an integer *n* (1<=≤<=*n*<=≤<=100). Each of the following *n* lines contains one word. All the words consist of lowercase Latin letters and possess the lengths of from 1 to 100 characters.,Print *n* lines. The *i*-th line should contain the result of replacing of the *i*-th word from the input data.,['4\nword\nlocalization\ninternationalization\npneumonoultramicroscopicsilicovolcanoconiosis\n'],['word\nl10n\ni18n\np43s\n'],none,WRONG_ANSWER,"def l_string(string):
    if len(string)<=2:
        return string
    count=len(string)-2
    s=string[0]+str(count)+string[-1]
    return s
t=int(input())
for i in range(t):
    string=input()
    a_string=l_string(string)
    print(a_string)","def abbreviate_word(word):

    if len(word) > 10:

        abbreviation = f""{word[0]}{len(word) - 2}{word[-1]}""
        return abbreviation

    return word

n = int(input().strip())

for _ in range(n):

    word = input().strip()

    print(abbreviate_word(word))"
203,C,Photographer,PROGRAMMING,"['greedy', 'sortings']","Valera's lifelong ambition was to be a photographer, so he bought a new camera. Every day he got more and more clients asking for photos, and one day Valera needed a program that would determine the maximum number of people he can serve.

The camera's memory is *d* megabytes. Valera's camera can take photos of high and low quality. One low quality photo takes *a* megabytes of memory, one high quality photo take *b* megabytes of memory. For unknown reasons, each client asks him to make several low quality photos and several high quality photos. More formally, the *i*-th client asks to make *x**i* low quality photos and *y**i* high quality photos.

Valera wants to serve as many clients per day as possible, provided that they will be pleased with his work. To please the *i*-th client, Valera needs to give him everything he wants, that is, to make *x**i* low quality photos and *y**i* high quality photos. To make one low quality photo, the camera must have at least *a* megabytes of free memory space. Similarly, to make one high quality photo, the camera must have at least *b* megabytes of free memory space. Initially the camera's memory is empty. Valera also does not delete photos from the camera so that the camera's memory gradually fills up.

Calculate the maximum number of clients Valera can successfully serve and print the numbers of these clients.","The first line contains two integers *n* and *d* (1<=≤<=*n*<=≤<=105,<=1<=≤<=*d*<=≤<=109) — the number of clients and the camera memory size, correspondingly. The second line contains two integers *a* and *b* (1<=≤<=*a*<=≤<=*b*<=≤<=104) — the size of one low quality photo and of one high quality photo, correspondingly. 

Next *n* lines describe the clients. The *i*-th line contains two integers *x**i* and *y**i* (0<=≤<=*x**i*,<=*y**i*<=≤<=105) — the number of low quality photos and high quality photos the *i*-th client wants, correspondingly. 

All numbers on all lines are separated by single spaces.","On the first line print the answer to the problem — the maximum number of clients that Valera can successfully serve. Print on the second line the numbers of the client in any order. All numbers must be distinct. If there are multiple answers, print any of them. The clients are numbered starting with 1 in the order in which they are defined in the input data.","['3 10\n2 3\n1 4\n2 1\n1 0\n', '3 6\n6 6\n1 1\n1 0\n1 0\n']","['2\n3 2 ', '1\n2 ']",none,TIME_LIMIT_EXCEEDED,"class Pair:
    def __init__(self,sumOfNumber,index):
        self.sumOfNumber=sumOfNumber
        self.index=index
    def __lt__(self, other):
        return self.sumOfNumber < other.sumOfNumber

n,d=map(int,input().split())
a,b=map(int,input().split())
s=[None]*n
for i in range(n):
    x,y=map(int,input().split())
    cur=Pair(0,0)
    cur.sumOfNumber=(a*x)+(b*y)
    cur.index=i+1
    s[i]=cur
s.sort()
cur=0
while cur<n and d-s[cur].sumOfNumber >= 0:
    d-=s[cur].sumOfNumber
    cur+=1
print(cur)
for i in range(cur):
    print(s[i].index,end="" "")","n, d = map(int, input().split())

a, b = map(int, input().split())

clients = []

for i in range(n):
    x, y = map(int, input().split())
    clients.append((x, y, i + 1))

clients.sort(key=lambda client: client[0] * a + client[1] * b)

total_memory_used = 0
max_clients = []
client_indices = []

for low, high, index in clients:
    required_memory = low * a + high * b
    if total_memory_used + required_memory <= d:
        total_memory_used += required_memory
        max_clients.append(index)

print(len(max_clients))
print(' '.join(map(str, max_clients)))"
687,A,NP-Hard Problem,PROGRAMMING,"['dfs and similar', 'graphs']","Recently, Pari and Arya did some research about NP-Hard problems and they found the minimum vertex cover problem very interesting.

Suppose the graph *G* is given. Subset *A* of its vertices is called a vertex cover of this graph, if for each edge *uv* there is at least one endpoint of it in this set, i.e.  or  (or both).

Pari and Arya have won a great undirected graph as an award in a team contest. Now they have to split it in two parts, but both of them want their parts of the graph to be a vertex cover.

They have agreed to give you their graph and you need to find two disjoint subsets of its vertices *A* and *B*, such that both *A* and *B* are vertex cover or claim it's impossible. Each vertex should be given to no more than one of the friends (or you can even keep it for yourself).","The first line of the input contains two integers *n* and *m* (2<=≤<=*n*<=≤<=100<=000, 1<=≤<=*m*<=≤<=100<=000) — the number of vertices and the number of edges in the prize graph, respectively.

Each of the next *m* lines contains a pair of integers *u**i* and *v**i* (1<=<=≤<=<=*u**i*,<=<=*v**i*<=<=≤<=<=*n*), denoting an undirected edge between *u**i* and *v**i*. It's guaranteed the graph won't contain any self-loops or multiple edges.","If it's impossible to split the graph between Pari and Arya as they expect, print ""-1"" (without quotes).

If there are two disjoint sets of vertices, such that both sets are vertex cover, print their descriptions. Each description must contain two lines. The first line contains a single integer *k* denoting the number of vertices in that vertex cover, and the second line contains *k* integers — the indices of vertices. Note that because of *m*<=≥<=1, vertex cover cannot be empty.","['4 2\n1 2\n2 3\n', '3 3\n1 2\n2 3\n1 3\n']","['1\n2 \n2\n1 3 \n', '-1\n']","In the first sample, you can give the vertex number 2 to Arya and vertices numbered 1 and 3 to Pari and keep vertex number 4 for yourself (or give it someone, if you wish).

In the second sample, there is no way to satisfy both Pari and Arya.",RUNTIME_ERROR,"from re import I
import sys
input = sys.stdin.readline
from math import *
def mrd(): return [int(x) for x in input().split()]
def rd(): return int(input())
MAXN = 2 * 10**5 + 5
INF = 10**16 * 2
mod = 10**9 + 7

def solve():
    n,m = mrd()
    adj = [[] for _ in range(n + 1)]
    for _ in range(m):
        u,v = mrd()
        adj[u].append(v)
        adj[v].append(u)
    
    col = [0 for _ in range(n + 1)]
    def chk(u,c):
        col[u] = c
        for v in adj[u]:
            if col[u] == col[v]:
                return False
            if not col[v] and not chk(v,3 - c):
                return False 
        return True
    for i in range(1,n + 1):
        if not col[i]:
            if not chk(i,1):
                print(-1)
                return

    def wr(c):    
        ans = [i for i in range(1,n + 1) if col[i] == c]
        print(len(ans))
        for x in ans:
            print(x,end="" "")
        print("""")
    
    wr(1)
    wr(2)

if __name__ == ""__main__"":
    solve()","def find_vertex_cover(n, m, edges):
    from collections import defaultdict

    graph = defaultdict(set)
    for u, v in edges:
        graph[u].add(v)
        graph[v].add(u)

    A, B = set(), set()

    visited = set()

    def dfs(node, color):
        if node in visited:
            return
        visited.add(node)

        if color == 0:
            A.add(node)
        else:
            B.add(node)

        for neighbor in graph[node]:
            if neighbor not in visited:
                dfs(neighbor, 1 - color)

    for vertex in range(1, n + 1):
        if vertex not in visited:
            dfs(vertex, 0)

    def is_vertex_cover(cover):
        covered_edges = set()
        for u in cover:
            for v in graph[u]:
                covered_edges.add((min(u, v), max(u, v)))
        return len(covered_edges) == m
    
    if is_vertex_cover(A) and is_vertex_cover(B):
        output = []
        output.append(f""{len(A)}"")
        output.append("" "".join(map(str, A)))
        output.append(f""{len(B)}"")
        output.append("" "".join(map(str, B)))
        return ""\n"".join(output)
    else:
        return ""-1""

inputs = ['4 2\n1 2\n2 3\n', '3 3\n1 2\n2 3\n1 3\n']
results = []

for input_str in inputs:
    lines = input_str.strip().split('\n')
    n, m = map(int, lines[0].split())
    edges = [tuple(map(int, line.split())) for line in lines[1:]]
    results.append(find_vertex_cover(n, m, edges))

print(""\n"".join(results))"
716,B,Complete the Word,PROGRAMMING,"['greedy', 'two pointers']","ZS the Coder loves to read the dictionary. He thinks that a word is nice if there exists a substring (contiguous segment of letters) of it of length 26 where each letter of English alphabet appears exactly once. In particular, if the string has length strictly less than 26, no such substring exists and thus it is not nice.

Now, ZS the Coder tells you a word, where some of its letters are missing as he forgot them. He wants to determine if it is possible to fill in the missing letters so that the resulting word is nice. If it is possible, he needs you to find an example of such a word as well. Can you help him?","The first and only line of the input contains a single string *s* (1<=≤<=|*s*|<=≤<=50<=000), the word that ZS the Coder remembers. Each character of the string is the uppercase letter of English alphabet ('A'-'Z') or is a question mark ('?'), where the question marks denotes the letters that ZS the Coder can't remember.","If there is no way to replace all the question marks with uppercase letters such that the resulting word is nice, then print <=-<=1 in the only line.

Otherwise, print a string which denotes a possible nice word that ZS the Coder learned. This string should match the string from the input, except for the question marks replaced with uppercase English letters.

If there are multiple solutions, you may print any of them.","['ABC??FGHIJK???OPQR?TUVWXY?\n', 'WELCOMETOCODEFORCESROUNDTHREEHUNDREDANDSEVENTYTWO\n', '??????????????????????????\n', 'AABCDEFGHIJKLMNOPQRSTUVW??M\n']","['ABCDEFGHIJKLMNOPQRZTUVWXYS', '-1', 'MNBVCXZLKJHGFDSAQPWOEIRUYT', '-1']","In the first sample case, ABCDEFGHIJKLMNOPQRZTUVWXYS is a valid answer beacuse it contains a substring of length 26 (the whole string in this case) which contains all the letters of the English alphabet exactly once. Note that there are many possible solutions, such as ABCDEFGHIJKLMNOPQRSTUVWXYZ or ABCEDFGHIJKLMNOPQRZTUVWXYS.

In the second sample case, there are no missing letters. In addition, the given string does not have a substring of length 26 that contains all the letters of the alphabet, so the answer is  - 1.

In the third sample case, any string of length 26 that contains all letters of the English alphabet fits as an answer.",WRONG_ANSWER,"def st(i) :
    chk = [chr(i+65) for i in range(26)]; chk.sort()
    alph = [chr(i+65) for i in range(26)]; ss = list(s[i:i+27]); j= 0
    for x in ss : 
        if x in alph: alph.remove(x)
    for x in range(26) :  
        if ss[x] == '?' : ss[x] = alph[j]; j+=1 
    ss.sort()
    if ss == chk : return ''.join(ss)
    else : return 0

s=input(); n=len(s) 
for i in range(n-25) :
    n=st(i)
    if n : print(n); break
else : print(-1)","def is_nice_possible(s):

    s = list(s)
    n = len(s)
    alphabet_set = set(""ABCDEFGHIJKLMNOPQRSTUVWXYZ"")

    for i in range(n - 25):
        substring = s[i:i + 26]
        present_letters = set(c for c in substring if c != '?')

        question_marks_count = substring.count('?')

        missing_letters = alphabet_set - present_letters

        if len(missing_letters) > question_marks_count:
            continue

        it = iter(missing_letters)
        for j in range(26):
            if substring[j] == '?':
                substring[j] = next(it, '?')

        s[i:i + 26] = substring

        for k in range(n):
            if s[k] == '?':
                s[k] = 'A'
        
        return ''.join(s)

    return '-1'

inputs = [
    'ABC??FGHIJK???OPQR?TUVWXY?\n',
    'WELCOMETOCODEFORCESROUNDTHREEHUNDREDANDSEVENTYTWO\n',
    '??????????????????????????\n',
    'AABCDEFGHIJKLMNOPQRSTUVW??M\n'
]

outputs = []
for inp in inputs:
    result = is_nice_possible(inp.strip())
    outputs.append(result)

for output in outputs:
    print(output)"
61,A,Ultra-Fast Mathematician,PROGRAMMING,['implementation'],"Shapur was an extremely gifted student. He was great at everything including Combinatorics, Algebra, Number Theory, Geometry, Calculus, etc. He was not only smart but extraordinarily fast! He could manage to sum 1018 numbers in a single second.

One day in 230 AD Shapur was trying to find out if any one can possibly do calculations faster than him. As a result he made a very great contest and asked every one to come and take part.

In his contest he gave the contestants many different pairs of numbers. Each number is made from digits 0 or 1. The contestants should write a new number corresponding to the given pair of numbers. The rule is simple: The *i*-th digit of the answer is 1 if and only if the *i*-th digit of the two given numbers differ. In the other case the *i*-th digit of the answer is 0.

Shapur made many numbers and first tried his own speed. He saw that he can perform these operations on numbers of length ∞ (length of a number is number of digits in it) in a glance! He always gives correct answers so he expects the contestants to give correct answers, too. He is a good fellow so he won't give anyone very big numbers and he always gives one person numbers of same length.

Now you are going to take part in Shapur's contest. See if you are faster and more accurate.",There are two lines in each input. Each of them contains a single number. It is guaranteed that the numbers are made from 0 and 1 only and that their length is same. The numbers may start with 0. The length of each number doesn't exceed 100.,Write one line — the corresponding answer. Do not omit the leading 0s.,"['1010100\n0100101\n', '000\n111\n', '1110\n1010\n', '01110\n01100\n']","['1110001\n', '111\n', '0100\n', '00010\n']",none,OK,"def xr(f,s):
	return int(f)^int(s)

def nn(v):
	f,s=v
	n=len(f)
	for x in range(n):
		yield(xr(f[x],s[x]))

v=[input() for _ in range(2)]
for x in nn(v):
	print(x,end='')","def calculate_differences(pairs):
    results = []
    for a, b in pairs:

        result = ''.join('1' if x != y else '0' for x, y in zip(a, b))
        results.append(result)
    return results

inputs = ['1010100\n0100101\n', '000\n111\n', '1110\n1010\n', '01110\n01100\n']
pairs = [pair.split() for pair in inputs]

output = calculate_differences(pairs)

for result in output:
    print(result)"
883,F,Lost in Transliteration,PROGRAMMING,['implementation'],"There are some ambiguities when one writes Berland names with the letters of the Latin alphabet.

For example, the Berland sound u can be written in the Latin alphabet as ""u"", and can be written as ""oo"". For this reason, two words ""ulyana"" and ""oolyana"" denote the same name.

The second ambiguity is about the Berland sound h: one can use both ""h"" and ""kh"" to write it. For example, the words ""mihail"" and ""mikhail"" denote the same name.

There are *n* users registered on the Polycarp's website. Each of them indicated a name represented by the Latin letters. How many distinct names are there among them, if two ambiguities described above are taken into account?

Formally, we assume that two words denote the same name, if using the replacements ""u""  ""oo"" and ""h""  ""kh"", you can make the words equal. One can make replacements in both directions, in any of the two words an arbitrary number of times. A letter that resulted from the previous replacement can participate in the next replacements.

For example, the following pairs of words denote the same name:
 -  ""koouper"" and ""kuooper"". Making the replacements described above, you can make both words to be equal: ""koouper""  ""kuuper"" and ""kuooper""  ""kuuper"". -  ""khun"" and ""kkkhoon"". With the replacements described above you can make both words to be equal: ""khun""  ""khoon"" and ""kkkhoon""  ""kkhoon""  ""khoon"". 
For a given list of words, find the minimal number of groups where the words in each group denote the same name.","The first line contains integer number *n* (2<=≤<=*n*<=≤<=400) — number of the words in the list.

The following *n* lines contain words, one word per line. Each word consists of only lowercase Latin letters. The length of each word is between 1 and 20 letters inclusive.",Print the minimal number of groups where the words in each group denote the same name.,"['10\nmihail\noolyana\nkooooper\nhoon\nulyana\nkoouper\nmikhail\nkhun\nkuooper\nkkkhoon\n', '9\nhariton\nhkariton\nbuoi\nkkkhariton\nboooi\nbui\nkhariton\nboui\nboi\n', '2\nalex\nalex\n']","['4\n', '5\n', '1\n']","There are four groups of words in the first example. Words in each group denote same name:
 1.  ""mihail"", ""mikhail"" 1.  ""oolyana"", ""ulyana"" 1.  ""kooooper"", ""koouper"" 1.  ""hoon"", ""khun"", ""kkkhoon"" 
There are five groups of words in the second example. Words in each group denote same name:
 1.  ""hariton"", ""kkkhariton"", ""khariton"" 1.  ""hkariton"" 1.  ""buoi"", ""boooi"", ""boui"" 1.  ""bui"" 1.  ""boi"" 
In the third example the words are equal, so they denote the same name.",RUNTIME_ERROR,"def k(s):
    a = ''
    for i in range(len(s)):
        if s[i] == 'k' and s[i-1] != 'k':
            temp = i
        elif s[i] == 'k' and s[i-1] == 'k':
            continue
        elif s[i] == 'h' and s[i-1] == 'k':
            a += s[i]
        elif s[i] != 'h' and s[i-1] == 'k':
            a += s[temp:i+1]
        else:
            a += s[i]
    return a
def u(s):
    a = ''
    for i in s:
        if i == 'u':
            a += 'oo'
        else:
            a += i
    return a
n = int(input())
s = set()
for i in range(n):
    temp = input()
    s.add(u(k(temp)))
print(len(s))","def normalize_name(name):

    name = name.replace('oo', 'u').replace('kh', 'h')
    return name

def find_distinct_names(user_names):
    normalized_set = set()
    
    for name in user_names:

        normalized_set.add(normalize_name(name))
    
    return len(normalized_set)

def main():
    import sys
    input = sys.stdin.read
    data = input().strip().split('\n')
    
    n = int(data[0])
    user_names = data[1:n + 1]

    distinct_count = find_distinct_names(user_names)

    print(distinct_count)

if __name__ == ""__main__"":
    main()"
835,A,Key races,PROGRAMMING,['math'],"Two boys decided to compete in text typing on the site ""Key races"". During the competition, they have to type a text consisting of *s* characters. The first participant types one character in *v*1 milliseconds and has ping *t*1 milliseconds. The second participant types one character in *v*2 milliseconds and has ping *t*2 milliseconds.

If connection ping (delay) is *t* milliseconds, the competition passes for a participant as follows: 
 1.  Exactly after *t* milliseconds after the start of the competition the participant receives the text to be entered. 1.  Right after that he starts to type it. 1.  Exactly *t* milliseconds after he ends typing all the text, the site receives information about it. 
The winner is the participant whose information on the success comes earlier. If the information comes from both participants at the same time, it is considered that there is a draw.

Given the length of the text and the information about participants, determine the result of the game.","The first line contains five integers *s*, *v*1, *v*2, *t*1, *t*2 (1<=≤<=*s*,<=*v*1,<=*v*2,<=*t*1,<=*t*2<=≤<=1000) — the number of characters in the text, the time of typing one character for the first participant, the time of typing one character for the the second participant, the ping of the first participant and the ping of the second participant.","If the first participant wins, print ""First"". If the second participant wins, print ""Second"". In case of a draw print ""Friendship"".","['5 1 2 1 2\n', '3 3 1 1 1\n', '4 5 3 1 5\n']","['First\n', 'Second\n', 'Friendship\n']","In the first example, information on the success of the first participant comes in 7 milliseconds, of the second participant — in 14 milliseconds. So, the first wins.

In the second example, information on the success of the first participant comes in 11 milliseconds, of the second participant — in 5 milliseconds. So, the second wins.

In the third example, information on the success of the first participant comes in 22 milliseconds, of the second participant — in 22 milliseconds. So, it is be a draw.",WRONG_ANSWER,"s, v1, v2, t1, t2 = list(map(int, input().split()))
print(s,v1,v2,t1,t2)

def calc(s, t, v):
    result = s * v + 2 * t 
    return result

first = calc(s, t1, v1)
second = calc(s, t2, v2)

if first > second:
    print('Second')
elif second > first:
    print('First')
else:
    print('Friendship')","def typing_competition(s, v1, v2, t1, t2):

    time_first = 2 * t1 + s * v1

    time_second = 2 * t2 + s * v2

    if time_first < time_second:
        return ""First""
    elif time_first > time_second:
        return ""Second""
    else:
        return ""Friendship""

inputs = [
    (5, 1, 2, 1, 2),
    (3, 3, 1, 1, 1),
    (4, 5, 3, 1, 5)
]

results = [typing_competition(*input_data) for input_data in inputs]

for result in results:
    print(result)"
916,C,Jamie and Interesting Graph,PROGRAMMING,"['constructive algorithms', 'graphs', 'shortest paths']","Jamie has recently found undirected weighted graphs with the following properties very interesting:
 -  The graph is connected and contains exactly *n* vertices and *m* edges. -  All edge weights are integers and are in range [1,<=109] inclusive. -  The length of shortest path from 1 to *n* is a prime number. -  The sum of edges' weights in the minimum spanning tree (MST) of the graph is a prime number. -  The graph contains no loops or multi-edges. 
If you are not familiar with some terms from the statement you can find definitions of them in notes section. 

Help Jamie construct any graph with given number of vertices and edges that is interesting!","First line of input contains 2 integers *n*, *m*  — the required number of vertices and edges.","In the first line output 2 integers *sp*, *mstw* (1<=≤<=*sp*,<=*mstw*<=≤<=1014) — the length of the shortest path and the sum of edges' weights in the minimum spanning tree.

In the next *m* lines output the edges of the graph. In each line output 3 integers *u*, *v*, *w* (1<=≤<=*u*,<=*v*<=≤<=*n*,<=1<=≤<=*w*<=≤<=109) describing the edge connecting *u* and *v* and having weight *w*.","['4 4\n', '5 4\n']","['7 7\n1 2 3\n2 3 2\n3 4 2\n2 4 4\n', '7 13\n1 2 2\n1 3 4\n1 4 3\n4 5 4\n']","The graph of sample 1: <img class=""tex-graphics"" src=""https://espresso.codeforces.com/42f9750de41b0d9a6b21e8615170113cfe19b0f2.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> Shortest path sequence: {1, 2, 3, 4}. MST edges are marked with an asterisk (*).

Definition of terms used in the problem statement:

A shortest path in an undirected graph is a sequence of vertices (*v*<sub class=""lower-index"">1</sub>, *v*<sub class=""lower-index"">2</sub>, ... , *v*<sub class=""lower-index"">*k*</sub>) such that *v*<sub class=""lower-index"">*i*</sub> is adjacent to *v*<sub class=""lower-index"">*i* + 1</sub> 1 ≤ *i* &lt; *k* and the sum of weight <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/e7f62cfd5c2c3b81dc80aaf2f512898495354f03.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> is minimized where *w*(*i*, *j*) is the edge weight between *i* and *j*. ([https://en.wikipedia.org/wiki/Shortest_path_problem](https://en.wikipedia.org/wiki/Shortest_path_problem))

A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. ([https://en.wikipedia.org/wiki/Prime_number](https://en.wikipedia.org/wiki/Prime_number))

A minimum spanning tree (MST) is a subset of the edges of a connected, edge-weighted undirected graph that connects all the vertices together, without any cycles and with the minimum possible total edge weight. ([https://en.wikipedia.org/wiki/Minimum_spanning_tree](https://en.wikipedia.org/wiki/Minimum_spanning_tree))

[https://en.wikipedia.org/wiki/Multiple_edges](https://en.wikipedia.org/wiki/Multiple_edges)",OK,"def doit(n, m):
    if (n == 2):
        print(2, 2)
        print(1, 2, 2)
        return
    sp = 2
    mstw = 100003
    print(sp, mstw)
    print(1, n, sp)
    print(2, n, mstw - n + 3 - sp)
    for i in range(3, n):
        print(i, n, 1)
    for i in range(2, n):
        for j in range(1, i):
            if (m == n - 1):
                return
            print(i, j, mstw)
            m -= 1

n, m = input().split()
doit(int(n), int(m))","import random
import sys
from math import isqrt

def is_prime(num):
    """"""Check if a number is prime.""""""
    if num <= 1:
        return False
    if num <= 3:
        return True
    if num % 2 == 0 or num % 3 == 0:
        return False
    for i in range(5, isqrt(num) + 1, 6):
        if num % i == 0 or num % (i + 2) == 0:
            return False
    return True

def generate_graph(n, m):
    edges = []
    total_weight = 0

    for i in range(1, n):
        weight = random.randint(1, 10**9)
        edges.append((i, i + 1, weight))
        total_weight += weight

    while len(edges) < m:
        u = random.randint(1, n)
        v = random.randint(1, n)
        if u != v and not any((u == a and v == b) or (v == a and u == b) for a, b, _ in edges):
            weight = random.randint(1, 10**9)
            edges.append((u, v, weight))
    
    sp = 0
    for (u, v, w) in edges:
        if (u == 1 and v == n) or (v == 1 and u == n):
            sp += w

    while not is_prime(sp):
        sp += 1
    while not is_prime(total_weight):
        total_weight += 1
    
    return sp, total_weight, edges

def main():
    input_data = sys.stdin.read().strip().split(""\n"")
    n, m = map(int, input_data[0].split())
    
    sp, mstw, edges = generate_graph(n, m)
    
    print(sp, mstw)
    for u, v, w in edges:
        print(u, v, w)

if __name__ == ""__main__"":
    main()"
585,D,Lizard Era: Beginning,PROGRAMMING,['meet-in-the-middle'],"In the game Lizard Era: Beginning the protagonist will travel with three companions: Lynn, Meliana and Worrigan. Overall the game has *n* mandatory quests. To perform each of them, you need to take exactly two companions.

The attitude of each of the companions to the hero is an integer. Initially, the attitude of each of them to the hero of neutral and equal to 0. As the hero completes quests, he makes actions that change the attitude of the companions, whom he took to perform this task, in positive or negative direction.

Tell us what companions the hero needs to choose to make their attitude equal after completing all the quests. If this can be done in several ways, choose the one in which the value of resulting attitude is greatest possible.","The first line contains positive integer *n* (1<=≤<=*n*<=≤<=25) — the number of important tasks. 

Next *n* lines contain the descriptions of the tasks — the *i*-th line contains three integers *l**i*,<=*m**i*,<=*w**i* — the values by which the attitude of Lynn, Meliana and Worrigan respectively will change towards the hero if the hero takes them on the *i*-th task. All the numbers in the input are integers and do not exceed 107 in absolute value.","If there is no solution, print in the first line ""Impossible"".

Otherwise, print *n* lines, two characters is each line — in the *i*-th line print the first letters of the companions' names that hero should take to complete the *i*-th task ('L' for Lynn, 'M' for Meliana, 'W' for Worrigan). Print the letters in any order, if there are multiple solutions, print any of them.","['3\n1 0 0\n0 1 0\n0 0 1\n', '7\n0 8 9\n5 9 -2\n6 -8 -7\n9 4 5\n-4 -9 9\n-4 5 2\n-6 8 -7\n', '2\n1 0 0\n1 1 0\n']","['LM\nMW\nMW\n', 'LM\nMW\nLM\nLW\nMW\nLM\nLW\n', 'Impossible\n']",none,TIME_LIMIT_EXCEEDED,"from itertools import combinations
def solve():
    for I in range(N // 2 + 2):
        X[I] = list(combinations(RX, I))
    for I in range(N - N // 2):
        Z[I] = list(combinations(RZ, I))
    LX = []
    LY = []
    MX = []
    MY = []
    for I in range(len(X)):
        for J in range(len(X[I])):
            XL = XM = 0
            for A in X[I][J]:
                XL += L[A]
                XM += M[A]
            LX.append([XL, I, J])
            MX.append([XM, I, J])
    for I in range(len(Z)):
        for J in range(len(Z[I])):
            YL = YM = 0
            for B in Z[I][J]:
                YL += L[B]
                YM += M[B]
            LY.append([YL, I, J])
            MY.append([YM, I, J])
    LXY = []
    MXY = []
    PS = set()
    MS = set()
    for I in range(len(LX)):
        for J in range(len(LY)):
            if I | J:
                P = LX[I][0] + LY[J][0]
                LXY.append([P, I, J])
                PS.add(P)
    for I in range(len(MX)):
        for J in range(len(MY)):
            if I | J:
                P = MX[I][0] + MY[J][0]
                if P in PS:
                    MXY.append([P, I, J])
                    MS.add(P)
    DS = ''
    MAX = -10**10
    for I in LXY:
        for J in MXY:
            if I[0] == J[0]:
                S1 = set(X[LX[I[1]][1]][LX[I[1]][2]]+Z[LY[I[2]][1]][LY[I[2]][2]])
                S2 = set(X[MX[J[1]][1]][MX[J[1]][2]]+Z[MY[J[2]][1]][MY[J[2]][2]])
                S3 = (S1-S2).union(S2-S1)
                S3S = 0
                for U in S3:
                    S3S+=W[U]
                if S3S == I[0]:
                    if S1.intersection(S2).union(S2.intersection(S3)).union(S3.intersection(S1)) == S:
                        D = ''
                        T = 0
                        for Q in range(N):
                            if Q in S1:
                                D+='L'
                                T+=L[Q]
                            if Q in S2:
                                D+='M'
                                T+=M[Q]
                            if Q in S3:
                                D+='W'
                                T+=W[Q]
                            D+='\n'
                        if T > MAX:
                            DS = D
                            MAX = T
    if DS:
        print(DS)
    else:
        print('Impossible')
N = int(input())
L = list(range(N))
M = list(range(N))
W = list(range(N))
S = set(L)
X = list(range(N//2+2))
Z = list(range(N-N//2))
RX = list(range(N//2+1))
RZ = list(range(N//2+1, N))
for I in range(N):
    L[I], M[I], W[I] = map(int, input().split())
solve()","def can_balance_attitudes(n, quests):

    lynn_attitude = 0
    meliana_attitude = 0
    worrigan_attitude = 0

    choices = []

    for i in range(n):
        l, m, w = quests[i]

        if (lynn_attitude + lynn_attitude + l) == (meliana_attitude + meliana_attitude + m):
            choices.append(""LM"")
            lynn_attitude += l
            meliana_attitude += m
        elif (lynn_attitude + lynn_attitude + l) == (worrigan_attitude + worrigan_attitude + w):
            choices.append(""LW"")
            lynn_attitude += l
            worrigan_attitude += w
        elif (meliana_attitude + meliana_attitude + m) == (worrigan_attitude + worrigan_attitude + w):
            choices.append(""MW"")
            meliana_attitude += m
            worrigan_attitude += w
        else:

            return ""Impossible""

    if lynn_attitude == meliana_attitude == worrigan_attitude:
        return choices

    return ""Impossible""

n = int(input())
quests = [tuple(map(int, input().split())) for _ in range(n)]

result = can_balance_attitudes(n, quests)

if result == ""Impossible"":
    print(result)
else:
    for choice in result:
        print(choice)"
501,B,Misha and Changing Handles,PROGRAMMING,"['data structures', 'dsu', 'strings']","Misha hacked the Codeforces site. Then he decided to let all the users change their handles. A user can now change his handle any number of times. But each new handle must not be equal to any handle that is already used or that was used at some point.

Misha has a list of handle change requests. After completing the requests he wants to understand the relation between the original and the new handles of the users. Help him to do that.","The first line contains integer *q* (1<=≤<=*q*<=≤<=1000), the number of handle change requests.

Next *q* lines contain the descriptions of the requests, one per line.

Each query consists of two non-empty strings *old* and *new*, separated by a space. The strings consist of lowercase and uppercase Latin letters and digits. Strings *old* and *new* are distinct. The lengths of the strings do not exceed 20.

The requests are given chronologically. In other words, by the moment of a query there is a single person with handle *old*, and handle *new* is not used and has not been used by anyone.","In the first line output the integer *n* — the number of users that changed their handles at least once.

In the next *n* lines print the mapping between the old and the new handles of the users. Each of them must contain two strings, *old* and *new*, separated by a space, meaning that before the user had handle *old*, and after all the requests are completed, his handle is *new*. You may output lines in any order.

Each user who changes the handle must occur exactly once in this description.",['5\nMisha ILoveCodeforces\nVasya Petrov\nPetrov VasyaPetrov123\nILoveCodeforces MikeMirzayanov\nPetya Ivanov\n'],['3\nPetya Ivanov\nMisha MikeMirzayanov\nVasya VasyaPetrov123\n'],none,WRONG_ANSWER,"def add_cconnection(new_change, data):
    old, new = new_change.split("" "")
    value = data.get(old)
    if value:
        del data[old]
        data[new] = value
    else:
        data[new] = old
num = int(input())
data = {}
_input = input().split(""\n"")
print(_input)
for line in _input:
    add_cconnection(line, data)
results = list(data.items())
results.reverse()
for new, old in results:
    print(old, new)","q = int(input())

original_to_new = {}

current_to_original = {}

for _ in range(q):

    old, new = input().split()

    if old in current_to_original:
        original_handle = current_to_original[old]
    else:
        original_handle = old

    original_to_new[original_handle] = new

    current_to_original[new] = original_handle
    del current_to_original[old]

print(len(original_to_new))

for old, new in original_to_new.items():
    print(old, new)"
614,B,Gena's Code,PROGRAMMING,"['implementation', 'math']","It's the year 4527 and the tanks game that we all know and love still exists. There also exists Great Gena's code, written in 2016. The problem this code solves is: given the number of tanks that go into the battle from each country, find their product. If it is turns to be too large, then the servers might have not enough time to assign tanks into teams and the whole game will collapse!

There are exactly *n* distinct countries in the world and the *i*-th country added *a**i* tanks to the game. As the developers of the game are perfectionists, the number of tanks from each country is beautiful. A beautiful number, according to the developers, is such number that its decimal representation consists only of digits '1' and '0', moreover it contains at most one digit '1'. However, due to complaints from players, some number of tanks of one country was removed from the game, hence the number of tanks of this country may not remain beautiful.

Your task is to write the program that solves exactly the same problem in order to verify Gena's code correctness. Just in case.","The first line of the input contains the number of countries *n* (1<=≤<=*n*<=≤<=100<=000). The second line contains *n* non-negative integers *a**i* without leading zeroes — the number of tanks of the *i*-th country.

It is guaranteed that the second line contains at least *n*<=-<=1 beautiful numbers and the total length of all these number's representations doesn't exceed 100<=000.",Print a single number without leading zeroes — the product of the number of tanks presented by each country.,"['3\n5 10 1\n', '4\n1 1 10 11\n', '5\n0 3 1 100 1\n']","['50', '110', '0']","In sample 1 numbers 10 and 1 are beautiful, number 5 is not not.

In sample 2 number 11 is not beautiful (contains two '1's), all others are beautiful.

In sample 3 number 3 is not beautiful, all others are beautiful.",WRONG_ANSWER,"from sys import stdin

def isBad(s):
    if s[0] != '1':
        return 1
    for i in s[1:]:
        if i != '0':
            return 1 
    return 0

def getBad(a):
    for i in a:
        if isBad(i):
            return i 
    return None

def getPowerOfTen(a):
    res = 0
    for i in a:
        if not isBad(i) and not i == '0':
            res += len(i) - 1
    return res
            

n = int(stdin.readline().strip())
a = stdin.readline().strip().split(' ')

b = getBad(a)

if b is None:
    print('1' + '0' * getPowerOfTen(a))
elif b == '0':
    print('0')
else:
    print(b + '0' * getPowerOfTen(a))","n = int(input().strip())

tanks = list(map(int, input().strip().split()))

product = 1

for tank in tanks:

    if tank == 0:

        product = 0
        break
    elif tank == 1 or (tank > 1 and (tank & (tank - 1)) == 0):

        continue
    else:

        product *= tank

print(product)"
991,C,Candies,PROGRAMMING,"['binary search', 'implementation']","After passing a test, Vasya got himself a box of $n$ candies. He decided to eat an equal amount of candies each morning until there are no more candies. However, Petya also noticed the box and decided to get some candies for himself.

This means the process of eating candies is the following: in the beginning Vasya chooses a single integer $k$, same for all days. After that, in the morning he eats $k$ candies from the box (if there are less than $k$ candies in the box, he eats them all), then in the evening Petya eats $10\%$ of the candies remaining in the box. If there are still candies left in the box, the process repeats — next day Vasya eats $k$ candies again, and Petya — $10\%$ of the candies left in a box, and so on.

If the amount of candies in the box is not divisible by $10$, Petya rounds the amount he takes from the box down. For example, if there were $97$ candies in the box, Petya would eat only $9$ of them. In particular, if there are less than $10$ candies in a box, Petya won't eat any at all.

Your task is to find out the minimal amount of $k$ that can be chosen by Vasya so that he would eat at least half of the $n$ candies he initially got. Note that the number $k$ must be integer.",The first line contains a single integer $n$ ($1 \leq n \leq 10^{18}$) — the initial amount of candies in the box.,Output a single integer — the minimal amount of $k$ that would allow Vasya to eat at least half of candies he got.,['68\n'],['3\n'],"In the sample, the amount of candies, with $k=3$, would change in the following way (Vasya eats first):

$68 \to 65 \to 59 \to 56 \to 51 \to 48 \to 44 \to 41 \\ \to 37 \to 34 \to 31 \to 28 \to 26 \to 23 \to 21 \to 18 \to 17 \to 14 \\ \to 13 \to 10 \to 9 \to 6 \to 6 \to 3 \to 3 \to 0$.

In total, Vasya would eat $39$ candies, while Petya — $29$.",TIME_LIMIT_EXCEEDED,"n=int(input())
def w(k):
    s=n
    p=0
    while s>0:
        p+=min(s,k)
        s=max(0,s-k)
        s-=s//10
    if p>=n/2:
        return True
    return False

l,r=0,n
while l<r:
    m=(l+r)//2
    if w(m):
        r=m
    else:
        l=m+1
print(r)","def total_candies_eaten(n, k):
    vasya_eaten = 0
    remaining_candies = n
    
    while remaining_candies > 0:

        vasya_eaten += min(k, remaining_candies)
        remaining_candies -= min(k, remaining_candies)

        petya_eaten = remaining_candies // 10
        remaining_candies -= petya_eaten
        
    return vasya_eaten

def find_min_k(n):
    left, right = 1, n
    
    while left < right:
        mid = (left + right) // 2

        if total_candies_eaten(n, mid) * 2 >= n:
            right = mid
        else:
            left = mid + 1
    
    return left

n = int(input().strip())

print(find_min_k(n))"
987,C,Three displays,PROGRAMMING,"['brute force', 'dp', 'implementation']","It is the middle of 2018 and Maria Stepanovna, who lives outside Krasnokamensk (a town in Zabaikalsky region), wants to rent three displays to highlight an important problem.

There are $n$ displays placed along a road, and the $i$-th of them can display a text with font size $s_i$ only. Maria Stepanovna wants to rent such three displays with indices $i &lt; j &lt; k$ that the font size increases if you move along the road in a particular direction. Namely, the condition $s_i &lt; s_j &lt; s_k$ should be held.

The rent cost is for the $i$-th display is $c_i$. Please determine the smallest cost Maria Stepanovna should pay.","The first line contains a single integer $n$ ($3 \le n \le 3\,000$) — the number of displays.

The second line contains $n$ integers $s_1, s_2, \ldots, s_n$ ($1 \le s_i \le 10^9$) — the font sizes on the displays in the order they stand along the road.

The third line contains $n$ integers $c_1, c_2, \ldots, c_n$ ($1 \le c_i \le 10^8$) — the rent costs for each display.","If there are no three displays that satisfy the criteria, print -1. Otherwise print a single integer — the minimum total rent cost of three displays with indices $i &lt; j &lt; k$ such that $s_i &lt; s_j &lt; s_k$.","['5\n2 4 5 4 10\n40 30 20 10 40\n', '3\n100 101 100\n2 4 5\n', '10\n1 2 3 4 5 6 7 8 9 10\n10 13 11 14 15 12 13 13 18 13\n']","['90\n', '-1\n', '33\n']","In the first example you can, for example, choose displays $1$, $4$ and $5$, because $s_1 &lt; s_4 &lt; s_5$ ($2 &lt; 4 &lt; 10$), and the rent cost is $40 + 10 + 40 = 90$.

In the second example you can't select a valid triple of indices, so the answer is -1.",RUNTIME_ERROR,"n = int(input())
s = [int(x) for x in input().strip().split()]
c = [int(x) for x in input().strip().split()]
from functools import lru_cache
@lru_cache(None)
def helper(i, last, nums):
    if nums==3:
        return 0
        
    if i==len(s):
        return float('inf')
    
    ans = helper(i+1, last, nums)
    
    if last==None:
        ans = min(ans, helper(i+1, i, nums+1)+c[i])
    else:
        if s[i]>s[last]:
            ans = min(ans, helper(i+1, i, nums+1)+c[i])
    
    return ans
    
val = helper(0, None, 0)
print(val if val!=float('inf') else -1)","def min_rent_for_displays(n, sizes, costs):

    min_cost = float('inf')
    found = False

    for j in range(1, n - 1):

        min_left_cost = float('inf')
        min_right_cost = float('inf')

        for i in range(j):
            if sizes[i] < sizes[j]:
                min_left_cost = min(min_left_cost, costs[i])

        for k in range(j + 1, n):
            if sizes[j] < sizes[k]:
                min_right_cost = min(min_right_cost, costs[k])

        if min_left_cost < float('inf') and min_right_cost < float('inf'):
            found = True
            min_cost = min(min_cost, min_left_cost + costs[j] + min_right_cost)

    return min_cost if found else -1

n = int(input())
sizes = list(map(int, input().split()))
costs = list(map(int, input().split()))

result = min_rent_for_displays(n, sizes, costs)
print(result)"
255,C,Almost Arithmetical Progression,PROGRAMMING,"['brute force', 'dp']","Gena loves sequences of numbers. Recently, he has discovered a new type of sequences which he called an almost arithmetical progression. A sequence is an almost arithmetical progression, if its elements can be represented as:
 -  *a*1<==<=*p*, where *p* is some integer; -  *a**i*<==<=*a**i*<=-<=1<=+<=(<=-<=1)*i*<=+<=1·*q* (*i*<=&gt;<=1), where *q* is some integer. 
Right now Gena has a piece of paper with sequence *b*, consisting of *n* integers. Help Gena, find there the longest subsequence of integers that is an almost arithmetical progression.

Sequence *s*1,<=<=*s*2,<=<=...,<=<=*s**k* is a subsequence of sequence *b*1,<=<=*b*2,<=<=...,<=<=*b**n*, if there is such increasing sequence of indexes *i*1,<=*i*2,<=...,<=*i**k* (1<=<=≤<=<=*i*1<=<=&lt;<=<=*i*2<=<=&lt;<=... <=<=&lt;<=<=*i**k*<=<=≤<=<=*n*), that *b**i**j*<=<==<=<=*s**j*. In other words, sequence *s* can be obtained from *b* by crossing out some elements.","The first line contains integer *n* (1<=≤<=*n*<=≤<=4000). The next line contains *n* integers *b*1,<=*b*2,<=...,<=*b**n* (1<=≤<=*b**i*<=≤<=106).",Print a single integer — the length of the required longest subsequence.,"['2\n3 5\n', '4\n10 20 10 30\n']","['2\n', '3\n']","In the first test the sequence actually is the suitable subsequence. 

In the second test the following subsequence fits: 10, 20, 10.",WRONG_ANSWER,"from sys import stdin
from bisect import bisect_left

def solve(tc):
    n = int(stdin.readline().strip())
    seq = list(map(int, stdin.readline().split()))

    elems = []
    idxcnt = 0
    idx = dict()
    for i in range(n):
        if seq[i] not in idx:
            idx[seq[i]] = idxcnt
            idxcnt += 1
            elems.append([])
        elems[idx[seq[i]]].append(i)

    ans = 1
    m = len(elems)
    for i in range(m):
        for j in range(m):
            if i == j:
                continue
            cur = -1
            cnt = 0
            leni, lenj = len(elems[i]), len(elems[j])
            pi, pj = 0, 0
            while True:
                k = bisect_left(elems[i], cur, pi, leni)
                if k == leni:
                    break
                pi = k+1
                cur = elems[i][k]
                cnt += 1

                k = bisect_left(elems[j], cur, pj, lenj)
                if k == lenj:
                    break
                pj = k+1
                cur = elems[j][k]
                cnt += 1
            ans = max(ans, cnt)

    print(ans)

tc = 1
solve(tc)","def longest_almost_arithmetical_progression(n, b):

    dp = [1] * n
    longest_length = 1

    for i in range(n):
        for j in range(i + 1, n):

            diff = b[j] - b[i]

            next_val = b[j] + diff

            count = 0
            for k in range(j + 1, n):
                if b[k] == next_val:
                    count += 1

            dp[j] = max(dp[j], dp[i] + count)
            longest_length = max(longest_length, dp[j])

    return longest_length

n = int(input())
b = list(map(int, input().split()))

result = longest_almost_arithmetical_progression(n, b)

print(result)"
999,E,Reachability from the Capital,PROGRAMMING,"['dfs and similar', 'graphs', 'greedy']","There are $n$ cities and $m$ roads in Berland. Each road connects a pair of cities. The roads in Berland are one-way.

What is the minimum number of new roads that need to be built to make all the cities reachable from the capital?

New roads will also be one-way.","The first line of input consists of three integers $n$, $m$ and $s$ ($1 \le n \le 5000, 0 \le m \le 5000, 1 \le s \le n$) — the number of cities, the number of roads and the index of the capital. Cities are indexed from $1$ to $n$.

The following $m$ lines contain roads: road $i$ is given as a pair of cities $u_i$, $v_i$ ($1 \le u_i, v_i \le n$, $u_i \ne v_i$). For each pair of cities $(u, v)$, there can be at most one road from $u$ to $v$. Roads in opposite directions between a pair of cities are allowed (i.e. from $u$ to $v$ and from $v$ to $u$).","Print one integer — the minimum number of extra roads needed to make all the cities reachable from city $s$. If all the cities are already reachable from $s$, print 0.","['9 9 1\n1 2\n1 3\n2 3\n1 5\n5 6\n6 1\n1 8\n9 8\n7 1\n', '5 4 5\n1 2\n2 3\n3 4\n4 1\n']","['3\n', '1\n']","The first example is illustrated by the following:

For example, you can add roads ($6, 4$), ($7, 9$), ($1, 7$) to make all the cities reachable from $s = 1$.

The second example is illustrated by the following:

In this example, you can add any one of the roads ($5, 1$), ($5, 2$), ($5, 3$), ($5, 4$) to make all the cities reachable from $s = 5$.",WRONG_ANSWER,"import sys
import math
import random
def II():
	return int(sys.stdin.readline())
 
def LI():
	return list(map(int, sys.stdin.readline().split()))
 
def MI():
	return map(int, sys.stdin.readline().split())
 
def SI():
	return sys.stdin.readline().strip()

def FACT(n, mod):
    s = 1
    facts = [1]
    for i in range(1,n+1):
        s*=i
        s%=mod
        facts.append(s)
    return facts[n]

def C(n, k, mod):
    return (FACT(n,mod) * pow((FACT(k,mod)*FACT(n-k,mod))%mod,mod-2, mod))%mod

n,m,s = MI()
d = [[] for i in range(n+1)]
d1 = [[] for i in range(n+1)]
for i in range(m):
    u,v = MI()
    d[u].append(v)
    d1[v].append(u)
count = 0
v = [0 for i in range(n+1)]
def dfs(i, isD1 = False):
    global v
    global d
    v[i] = 1
    if isD1:
        for x in d1[i]:
            if v[x] == 0:
                dfs(x, isD1)
    else:
        for x in d[i]:
            if v[x] == 0:
                dfs(x,isD1)
dfs(s)
for i in range(1,n+1):
    if v[i] == 0:
        count+=1
        dfs(i, True)
print(count)","from collections import defaultdict, deque

def min_new_roads(n, m, s, roads):

    graph = defaultdict(list)
    for u, v in roads:
        graph[u].append(v)

    def bfs(start):
        reachable = set()
        queue = deque([start])
        while queue:
            node = queue.popleft()
            if node not in reachable:
                reachable.add(node)
                for neighbor in graph[node]:
                    if neighbor not in reachable:
                        queue.append(neighbor)
        return reachable

    reachable_from_s = bfs(s)

    reverse_graph = defaultdict(list)
    for u in graph:
        for v in graph[u]:
            reverse_graph[v].append(u)

    reachable_to_s = bfs(s)

    not_reachable = set(range(1, n + 1)) - reachable_from_s
    not_reachable_from_s = set(range(1, n + 1)) - reachable_to_s

    return len(not_reachable) + len(not_reachable_from_s)

import sys
input = sys.stdin.read
data = input().splitlines()

results = []
for i in range(0, len(data), 2):
    n, m, s = map(int, data[i].split())
    roads = [tuple(map(int, data[j].split())) for j in range(i + 1, i + 1 + m)]
    result = min_new_roads(n, m, s, roads)
    results.append(f""{result}\n"")

print("""".join(results))"
513,B1,Permutations,PROGRAMMING,['brute force'],"You are given a permutation *p* of numbers 1,<=2,<=...,<=*n*. Let's define *f*(*p*) as the following sum:

Find the lexicographically *m*-th permutation of length *n* in the set of permutations having the maximum possible value of *f*(*p*).","The single line of input contains two integers *n* and *m* (1<=≤<=*m*<=≤<=*cnt**n*), where *cnt**n* is the number of permutations of length *n* with maximum possible value of *f*(*p*).

The problem consists of two subproblems. The subproblems have different constraints on the input. You will get some score for the correct submission of the subproblem. The description of the subproblems follows.
 -  In subproblem B1 (3 points), the constraint 1<=≤<=*n*<=≤<=8 will hold. -  In subproblem B2 (4 points), the constraint 1<=≤<=*n*<=≤<=50 will hold.",Output *n* number forming the required permutation.,"['2 2\n', '3 2\n']","['2 1 \n', '1 3 2 \n']","In the first example, both permutations of numbers {1, 2} yield maximum possible *f*(*p*) which is equal to 4. Among them, (2, 1) comes second in lexicographical order.",OK,"import itertools
n, m = tuple(int(x) for x in input().split())
lstN = [x for x in range(1,n+1)]

def funcP(seq):
	res = 0
	for i in range(len(seq)):
		for j in range(i, len(seq)):
			res += min(seq[i:j+1])
	return res

allPerm = [(perm,funcP(perm)) for perm in itertools.permutations(lstN)]
allPerm.sort(key = lambda x: x[1], reverse = True)
print("" "".join(str(x) for x in allPerm[m-1][0]))","from itertools import permutations

def max_f_permutations(n):

    perms = list(permutations(range(1, n + 1)))
    max_value = 0
    max_perms = []

    def f(p):
        return sum((i + 1) * p[i] for i in range(n))

    for p in perms:
        current_value = f(p)
        if current_value > max_value:
            max_value = current_value
            max_perms = [p]
        elif current_value == max_value:
            max_perms.append(p)

    return max_perms

def lexicographic_mth_permutation(n, m):
    max_perms = max_f_permutations(n)

    max_perms.sort()
    return max_perms[m - 1]

n, m = map(int, input().split())

result = lexicographic_mth_permutation(n, m)

print(' '.join(map(str, result)))"
0,none,none,none,['none'],"Vasya the programmer lives in the middle of the Programming subway branch. He has two girlfriends: Dasha and Masha, who live at the different ends of the branch, each one is unaware of the other one's existence.

When Vasya has some free time, he goes to one of his girlfriends. He descends into the subway at some time, waits the first train to come and rides on it to the end of the branch to the corresponding girl. However, the trains run with different frequencies: a train goes to Dasha's direction every *a* minutes, but a train goes to Masha's direction every *b* minutes. If two trains approach at the same time, Vasya goes toward the direction with the lower frequency of going trains, that is, to the girl, to whose directions the trains go less frequently (see the note to the third sample).

We know that the trains begin to go simultaneously before Vasya appears. That is the train schedule is such that there exists a moment of time when the two trains arrive simultaneously.

Help Vasya count to which girlfriend he will go more often.","The first line contains two integers *a* and *b* (*a*<=≠<=*b*,<=1<=≤<=*a*,<=*b*<=≤<=106).","Print ""Dasha"" if Vasya will go to Dasha more frequently, ""Masha"" if he will go to Masha more frequently, or ""Equal"" if he will go to both girlfriends with the same frequency.","['3 7\n', '5 3\n', '2 3\n']","['Dasha\n', 'Masha\n', 'Equal\n']","Let's take a look at the third sample. Let the trains start to go at the zero moment of time. It is clear that the moments of the trains' arrival will be periodic with period 6. That's why it is enough to show that if Vasya descends to the subway at a moment of time inside the interval (0, 6], he will go to both girls equally often. 

If he descends to the subway at a moment of time from 0 to 2, he leaves for Dasha on the train that arrives by the second minute.

If he descends to the subway at a moment of time from 2 to 3, he leaves for Masha on the train that arrives by the third minute.

If he descends to the subway at a moment of time from 3 to 4, he leaves for Dasha on the train that arrives by the fourth minute.

If he descends to the subway at a moment of time from 4 to 6, he waits for both trains to arrive by the sixth minute and goes to Masha as trains go less often in Masha's direction.

In sum Masha and Dasha get equal time — three minutes for each one, thus, Vasya will go to both girlfriends equally often.",RUNTIME_ERROR,"def gcd(a, b):
    if a == b:
        return a
    
    if a > b:
        return gcd(a-b, b)
    else:
        return gcd(a, b-a)
        
def lcm(a, b):
    return a/gcd(a, b) * b
    
def findGF(a, b):
    mult = lcm(a, b)
    a = mult//a
    b = mult//b
    
    if abs(a-b) < 2:
        return 'Equal'
    return 'Dasha' if a > b else 'Masha'

a, b = list(map(int, input().split(' ')))
print(findGF(a, b))","def determine_girlfriend(a, b):

    from math import gcd

    def lcm(x, y):
        return x * y // gcd(x, y)

    period = lcm(a, b)

    dasha_trains = period // a
    masha_trains = period // b

    if dasha_trains > masha_trains:
        return ""Dasha""
    elif masha_trains > dasha_trains:
        return ""Masha""
    else:
        return ""Equal""

demo_inputs = ['3 7\n', '5 3\n', '2 3\n']
results = []

for input_str in demo_inputs:
    a, b = map(int, input_str.strip().split())
    result = determine_girlfriend(a, b)
    results.append(result)

for result in results:
    print(result)"
287,A,IQ Test,PROGRAMMING,"['brute force', 'implementation']","In the city of Ultima Thule job applicants are often offered an IQ test. 

The test is as follows: the person gets a piece of squared paper with a 4<=×<=4 square painted on it. Some of the square's cells are painted black and others are painted white. Your task is to repaint at most one cell the other color so that the picture has a 2<=×<=2 square, completely consisting of cells of the same color. If the initial picture already has such a square, the person should just say so and the test will be completed. 

Your task is to write a program that determines whether it is possible to pass the test. You cannot pass the test if either repainting any cell or no action doesn't result in a 2<=×<=2 square, consisting of cells of the same color.","Four lines contain four characters each: the *j*-th character of the *i*-th line equals ""."" if the cell in the *i*-th row and the *j*-th column of the square is painted white, and ""#"", if the cell is black.","Print ""YES"" (without the quotes), if the test can be passed and ""NO"" (without the quotes) otherwise.","['####\n.#..\n####\n....\n', '####\n....\n####\n....\n']","['YES\n', 'NO\n']",In the first test sample it is enough to repaint the first cell in the second row. After such repainting the required 2 × 2 square is on the intersection of the 1-st and 2-nd row with the 1-st and 2-nd column.,OK,"from copy import deepcopy

zoz=[]

for i in range(4):
    zoz.append(list(input()))
    
def check(zoz):
    for i in range(3):
        for j in range(3):
            if zoz[i][j]==zoz[i][j+1] and zoz[i+1][j]==zoz[i+1][j+1] and zoz[i+1][j]==zoz[i][j]:
                return True
    return False

def change(z):
    if z==""
        return "".""
    else:
        return ""

verdict=""NO""

if check(zoz):
    verdict=""YES""
    
for i in range(16):
    test=deepcopy(zoz)
    test[i//4][i%4]=change(test[i//4][i%4])
    if check(test):
        verdict=""YES""
        break
print(verdict)","def can_pass_test(board):

    for i in range(3):
        for j in range(3):

            if all(board[i + k][j + l] == '
                return ""YES""
            if all(board[i + k][j + l] == '.' for k in range(2) for l in range(2)):
                return ""YES""

    for i in range(3):
        for j in range(3):
            cells = [board[i + k][j + l] for k in range(2) for l in range(2)]

            if cells.count('
                return ""YES""
            if cells.count('.') == 3 and cells.count('
                return ""YES""
    
    return ""NO""

input_board = [input().strip() for _ in range(4)]
print(can_pass_test(input_board))"
980,C,Posterized,PROGRAMMING,"['games', 'greedy']","Professor Ibrahim has prepared the final homework for his algorithm’s class. He asked his students to implement the Posterization Image Filter.

Their algorithm will be tested on an array of integers, where the $i$-th integer represents the color of the $i$-th pixel in the image. The image is in black and white, therefore the color of each pixel will be an integer between 0 and 255 (inclusive).

To implement the filter, students are required to divide the black and white color range [0, 255] into groups of consecutive colors, and select one color in each group to be the group’s key. In order to preserve image details, the size of a group must not be greater than $k$, and each color should belong to exactly one group.

Finally, the students will replace the color of each pixel in the array with that color’s assigned group key.

To better understand the effect, here is an image of a basking turtle where the Posterization Filter was applied with increasing $k$ to the right. 

To make the process of checking the final answer easier, Professor Ibrahim wants students to divide the groups and assign the keys in a way that produces the lexicographically smallest possible array.","The first line of input contains two integers $n$ and $k$ ($1 \leq n \leq 10^5$, $1 \leq k \leq 256$), the number of pixels in the image, and the maximum size of a group, respectively.

The second line contains $n$ integers $p_1, p_2, \dots, p_n$ ($0 \leq p_i \leq 255$), where $p_i$ is the color of the $i$-th pixel.",Print $n$ space-separated integers; the lexicographically smallest possible array that represents the image after applying the Posterization filter.,"['4 3\n2 14 3 4\n', '5 2\n0 2 1 255 254\n']","['0 12 3 3\n', '0 1 1 254 254\n']","One possible way to group colors and assign keys for the first sample:

Color $2$ belongs to the group $[0,2]$, with group key $0$.

Color $14$ belongs to the group $[12,14]$, with group key $12$.

Colors $3$ and $4$ belong to group $[3, 5]$, with group key $3$.

Other groups won't affect the result so they are not listed here.",RUNTIME_ERROR,"def solution(n, k, arr):
    ret = []
    pix, grp = dict(), dict()
    for i in arr:
        if i in pix:
            continue
        l = None
        for j in range(1, k):
            if i - j in pix:
                l = i - j
                break
        if l:
            g = pix[l]
        if l and grp[g][0] <= i <= grp[g][0] + k - 1:
            grp[g][1] = i
            for j in range(grp[g][0], i + 1):
                pix[j] = l
        else:
            key = max(0, i - k + 1)
            while key in pix:
                key += 1
            for j in range(key, i + 1):
                pix[j] = key
            grp[key] = [key, i]
    for i in arr:
        ret.append(grp[pix[i]][0])
    return ret

print(' '.join(solution(*map(int, input().split()), list(map(int, input().split())))))","def posterization_filter(n, k, pixels):

    output = [0] * n
    current_key = 0

    group_start = 0

    for color in range(256):
        if color in pixels:

            if color - group_start < k:

                output_indices = [i for i in range(n) if pixels[i] == color]
                for idx in output_indices:
                    output[idx] = current_key
            else:

                current_key = group_start
                output_indices = [i for i in range(n) if pixels[i] == color]
                for idx in output_indices:
                    output[idx] = current_key

            group_start = color + 1
            
    return output

n, k = map(int, input().split())
pixels = list(map(int, input().split()))

result = posterization_filter(n, k, pixels)

print(' '.join(map(str, result)))"
370,A,"Rook, Bishop and King",PROGRAMMING,"['graphs', 'math', 'shortest paths']","Little Petya is learning to play chess. He has already learned how to move a king, a rook and a bishop. Let us remind you the rules of moving chess pieces. A chessboard is 64 square fields organized into an 8<=×<=8 table. A field is represented by a pair of integers (*r*,<=*c*) — the number of the row and the number of the column (in a classical game the columns are traditionally indexed by letters). Each chess piece takes up exactly one field. To make a move is to move a chess piece, the pieces move by the following rules:
 -  A rook moves any number of fields horizontally or vertically. -  A bishop moves any number of fields diagonally. -  A king moves one field in any direction — horizontally, vertically or diagonally. 
Petya is thinking about the following problem: what minimum number of moves is needed for each of these pieces to move from field (*r*1,<=*c*1) to field (*r*2,<=*c*2)? At that, we assume that there are no more pieces besides this one on the board. Help him solve this problem.","The input contains four integers *r*1,<=*c*1,<=*r*2,<=*c*2 (1<=≤<=*r*1,<=*c*1,<=*r*2,<=*c*2<=≤<=8) — the coordinates of the starting and the final field. The starting field doesn't coincide with the final one.

You can assume that the chessboard rows are numbered from top to bottom 1 through 8, and the columns are numbered from left to right 1 through 8.","Print three space-separated integers: the minimum number of moves the rook, the bishop and the king (in this order) is needed to move from field (*r*1,<=*c*1) to field (*r*2,<=*c*2). If a piece cannot make such a move, print a 0 instead of the corresponding number.","['4 3 1 6\n', '5 5 5 6\n']","['2 1 3\n', '1 0 1\n']",none,WRONG_ANSWER,"def rook(x1, y1, x2, y2):
    if x1 == x2  or y1 == y2 :
        return 1
    else :
        return 2

def bish(x1, y1, x2, y2):
    if (x1%2==0 and y1%2==0 or x1%2!=0 and y1%2!=0) and (x2%2!=0 and y2%2==0 or x2%2==0 and y2%2!=0):
        return 0
    elif abs(x2-x1) == abs(y2-y1):
        return 1
    else :
        return 2

def king(x1, y1, x2, y2):
    if x1==x2:
        return abs(y2-y1)
    elif y1==y2:
        return abs(x2-x1)
    else :
        return max(abs(x2-x1), abs(y2-y1))

x1, y1, x2, y2 = list( int(i) for i in input().split() )

print(rook(x1, y1, x2, y2), end="" "")
print(bish(x1, y1, x2, y2), end="" "")
print(king(x1, y1, x2, y2), end="" "")","def min_moves(r1, c1, r2, c2):

    rook_moves = 0
    if r1 == r2 or c1 == c2:

        rook_moves = 1
    else:

        rook_moves = 2

    bishop_moves = 0
    if (r1 + c1) % 2 != (r2 + c2) % 2:

        bishop_moves = 0
    elif abs(r1 - r2) == abs(c1 - c2):

        bishop_moves = 1
    else:

        bishop_moves = 2

    king_moves = max(abs(r1 - r2), abs(c1 - c2))

    return rook_moves, bishop_moves, king_moves

input_data = [
    (4, 3, 1, 6),
    (5, 5, 5, 6)
]

for r1, c1, r2, c2 in input_data:
    rook, bishop, king = min_moves(r1, c1, r2, c2)
    print(rook, bishop, king)"
58,A,Chat room,PROGRAMMING,"['greedy', 'strings']","Vasya has recently learned to type and log on to the Internet. He immediately entered a chat room and decided to say hello to everybody. Vasya typed the word *s*. It is considered that Vasya managed to say hello if several letters can be deleted from the typed word so that it resulted in the word ""hello"". For example, if Vasya types the word ""ahhellllloou"", it will be considered that he said hello, and if he types ""hlelo"", it will be considered that Vasya got misunderstood and he didn't manage to say hello. Determine whether Vasya managed to say hello by the given word *s*.","The first and only line contains the word *s*, which Vasya typed. This word consisits of small Latin letters, its length is no less that 1 and no more than 100 letters.","If Vasya managed to say hello, print ""YES"", otherwise print ""NO"".","['ahhellllloou\n', 'hlelo\n']","['YES\n', 'NO\n']",none,RUNTIME_ERROR,"def can_word_be_formed(s):
    st = 'hello'
    l = list(st)
    z = []
    ctr = 0
    for i in range(len(s)):
        if s[i] == l[ctr]:
            ctr += 1
            z.append(i)
            break
    for i in range(z[-1]+1, len(s)):
        if s[i] == l[ctr]:
            ctr += 1
            z.append(i)
            break
    for i in range(z[-1]+1, len(s)):
        if s[i] == l[ctr]:
            ctr += 1
            z.append(i)
            break
    for i in range(z[-1]+1, len(s)):
        if s[i] == l[ctr]:
            ctr += 1
            z.append(i)
            break

    for i in range(z[-1]+1, len(s)):
        if s[i] == l[ctr]:
            ctr += 1
            z.append(i)
            break

    if len(z) < 5:
        print('NO')
    else:
        print('YES')

s = input()
can_word_be_formed(s)","def can_say_hello(s):
    target = ""hello""
    target_index = 0
    
    for char in s:
        if char == target[target_index]:
            target_index += 1
        if target_index == len(target):
            return ""YES""
    
    return ""NO""

if __name__ == ""__main__"":
    import sys
    input_lines = sys.stdin.read().strip().split('\n')
    results = [can_say_hello(line) for line in input_lines]
    print(""\n"".join(results))"
95,B,Lucky Numbers,PROGRAMMING,"['dp', 'greedy']","Petya loves lucky numbers. Everybody knows that positive integers are lucky if their decimal representation doesn't contain digits other than 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.

Lucky number is super lucky if it's decimal representation contains equal amount of digits 4 and 7. For example, numbers 47, 7744, 474477 are super lucky and 4, 744, 467 are not.

One day Petya came across a positive integer *n*. Help him to find the least super lucky number which is not less than *n*.",The only line contains a positive integer *n* (1<=≤<=*n*<=≤<=10100000). This number doesn't have leading zeroes.,Output the least super lucky number that is more than or equal to *n*.,"['4500\n', '47\n']","['4747\n', '47\n']",none,RUNTIME_ERROR,"import itertools
from itertools import permutations
def ans(x):
    l=['4']*(x//2)+['7']*(x//2)
    k=''.join(l)
    l=sorted(list(set(list(permutations(k)))))
    l=[int(''.join(x)) for x in l]
    return l
def binsearch(l,m):
    low=0
    high=len(l)-1
    while low<high:
        mid=(high+low)//2
        if l[mid]<m:
            low=mid+1
        elif l[mid]>m:
            high=mid
        else:
            return l[mid]
    return l[low]
    
        
n=input()
x=len(n)
if x%2!=0:
    l=['4']*(x+1)//2+['7']*(x+1)//2
    print(''.join(l))
else:
    l=['7']*(x//2)+['4']*(x//2)
    k=''.join(l)
    k=int(k)
    if int(n)>k:
        l=['4']*(x//2+1)+['7']*(x//2+1)
        print(''.join(l))
    else:
        l=ans(x)
        y=binsearch(l,int(n))
        print(y)","def is_lucky(num_str):

    return all(ch in '47' for ch in num_str)

def is_super_lucky(num_str):

    return num_str.count('4') == num_str.count('7')

def generate_super_lucky(length):

    if length % 2 != 0:
        return []

    from itertools import product
    half_length = length // 2
    super_lucky_nums = []

    for combo in product('47', repeat=half_length):
        lucky_num = ''.join(combo)
        super_lucky_num = lucky_num + lucky_num
        super_lucky_nums.append(super_lucky_num)
    
    return super_lucky_nums

def find_least_super_lucky(n):
    n_str = str(n)
    length = len(n_str)

    while True:

        candidate_found = False
        for curr_length in range(length, length + 2):
            super_lucky_nums = generate_super_lucky(curr_length)
            for lucky_num in super_lucky_nums:
                if lucky_num >= n_str:
                    return lucky_num
        length += 2

n = int(input().strip())

print(find_least_super_lucky(n))"
569,B,Inventory,PROGRAMMING,"['greedy', 'math']","Companies always have a lot of equipment, furniture and other things. All of them should be tracked. To do this, there is an inventory number assigned with each item. It is much easier to create a database by using those numbers and keep the track of everything.

During an audit, you were surprised to find out that the items are not numbered sequentially, and some items even share the same inventory number! There is an urgent need to fix it. You have chosen to make the numbers of the items sequential, starting with 1. Changing a number is quite a time-consuming process, and you would like to make maximum use of the current numbering.

You have been given information on current inventory numbers for *n* items in the company. Renumber items so that their inventory numbers form a permutation of numbers from 1 to *n* by changing the number of as few items as possible. Let us remind you that a set of *n* numbers forms a permutation if all the numbers are in the range from 1 to *n*, and no two numbers are equal.","The first line contains a single integer *n* — the number of items (1<=≤<=*n*<=≤<=105).

The second line contains *n* numbers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=105) — the initial inventory numbers of the items.","Print *n* numbers — the final inventory numbers of the items in the order they occur in the input. If there are multiple possible answers, you may print any of them.","['3\n1 3 2\n', '4\n2 2 3 3\n', '1\n2\n']","['1 3 2 \n', '2 1 3 4 \n', '1 \n']","In the first test the numeration is already a permutation, so there is no need to change anything.

In the second test there are two pairs of equal numbers, in each pair you need to replace one number.

In the third test you need to replace 2 by 1, as the numbering should start from one.",OK,"def main():
    n = int(input()) + 1
    res, fil, rest = list(map(int, input().split())), [True] * n, []
    for i, x in enumerate(res):
        if x >= n or not fil[x]:
            rest.append(i)
        else:
            fil[x] = False
    for i, x in zip(rest, filter(fil.__getitem__, range(1, n))):
        res[i] = x
    print(' '.join(map(str, res)))

if __name__ == '__main__':
    main()","def renumber_inventory(n, current_numbers):

    current_set = set(current_numbers)

    final_numbers = list(current_numbers)

    available_numbers = [i for i in range(1, n + 1) if i not in current_set]

    available_index = 0

    for i in range(n):
        if final_numbers[i] not in current_set or final_numbers.count(final_numbers[i]) > 1:

            final_numbers[i] = available_numbers[available_index]
            available_index += 1

    return final_numbers

n = int(input())
current_numbers = list(map(int, input().split()))

result = renumber_inventory(n, current_numbers)
print(' '.join(map(str, result)))"
374,A,Inna and Pink Pony,PROGRAMMING,"['greedy', 'implementation']","Dima and Inna are doing so great! At the moment, Inna is sitting on the magic lawn playing with a pink pony. Dima wanted to play too. He brought an *n*<=×<=*m* chessboard, a very tasty candy and two numbers *a* and *b*.

Dima put the chessboard in front of Inna and placed the candy in position (*i*,<=*j*) on the board. The boy said he would give the candy if it reaches one of the corner cells of the board. He's got one more condition. There can only be actions of the following types:
 -  move the candy from position (*x*,<=*y*) on the board to position (*x*<=-<=*a*,<=*y*<=-<=*b*); -  move the candy from position (*x*,<=*y*) on the board to position (*x*<=+<=*a*,<=*y*<=-<=*b*); -  move the candy from position (*x*,<=*y*) on the board to position (*x*<=-<=*a*,<=*y*<=+<=*b*); -  move the candy from position (*x*,<=*y*) on the board to position (*x*<=+<=*a*,<=*y*<=+<=*b*). 
Naturally, Dima doesn't allow to move the candy beyond the chessboard borders.

Inna and the pony started shifting the candy around the board. They wonder what is the minimum number of allowed actions that they need to perform to move the candy from the initial position (*i*,<=*j*) to one of the chessboard corners. Help them cope with the task!","The first line of the input contains six integers *n*,<=*m*,<=*i*,<=*j*,<=*a*,<=*b* (1<=≤<=*n*,<=*m*<=≤<=106; 1<=≤<=*i*<=≤<=*n*; 1<=≤<=*j*<=≤<=*m*; 1<=≤<=*a*,<=*b*<=≤<=106).

You can assume that the chessboard rows are numbered from 1 to *n* from top to bottom and the columns are numbered from 1 to *m* from left to right. Position (*i*,<=*j*) in the statement is a chessboard cell on the intersection of the *i*-th row and the *j*-th column. You can consider that the corners are: (1,<=*m*), (*n*,<=1), (*n*,<=*m*), (1,<=1).","In a single line print a single integer — the minimum number of moves needed to get the candy.

If Inna and the pony cannot get the candy playing by Dima's rules, print on a single line ""Poor Inna and pony!"" without the quotes.","['5 7 1 3 2 2\n', '5 5 2 3 1 1\n']","['2\n', 'Poor Inna and pony!\n']","Note to sample 1:

Inna and the pony can move the candy to position (1 + 2, 3 + 2) = (3, 5), from there they can move it to positions (3 - 2, 5 + 2) = (1, 7) and (3 + 2, 5 + 2) = (5, 7). These positions correspond to the corner squares of the chess board. Thus, the answer to the test sample equals two.",RUNTIME_ERROR,"{
 ""cells"": [
  {
   ""cell_type"": ""code"",
   ""execution_count"": null,
   ""id"": ""6d4e03b7-0200-4344-9401-52f6cf714db5"",
   ""metadata"": {},
   ""outputs"": [],
   ""source"": [
    ""n,m,i,j,a,b=map(int,input.split())   \n"",
    ""inf=10**7\n"",
    ""def nstep(x,y):\n"",
    ""    global alx,aly\n"",
    ""    if x%a!=0 or y%b!=0:\n"",
    ""        return inf   \n"",
    ""    k,l=x/2,y/2\n"",
    ""    if k%2!=l%2 :\n"",
    ""        return inf\n"",
    ""    if k==0 and l>0 and not alx: \n"",
    ""        return inf\n"",
    ""    if l==0 and k>0 and not aly:\n"",
    ""        return inf  \n"",
    ""    return max(k,l)  \n"",
    ""alx,aly=a<n,b<m\n"",
    ""A=[0]*4\n"",
    ""A[0]=nstep(i-1,j-1)\n"",
    ""A[1]=nstep(n-i,j-1)\n"",
    ""A[2]=nstep(i-1,m-j)\n"",
    ""A[3]=nstep(n-i,m-j)\n"",
    ""res=min(A)\n"",
    ""if(res<inf):\n"",
    ""    print(res)\n"",
    ""else ""
   ]
  }
 ],
 ""metadata"": {
  ""kernelspec"": {
   ""display_name"": ""Python 3 (ipykernel)"",
   ""language"": ""python"",
   ""name"": ""python3""
  },
  ""language_info"": {
   ""codemirror_mode"": {
    ""name"": ""ipython"",
    ""version"": 3
   },
   ""file_extension"": "".py"",
   ""mimetype"": ""text/x-python"",
   ""name"": ""python"",
   ""nbconvert_exporter"": ""python"",
   ""pygments_lexer"": ""ipython3"",
   ""version"": ""3.9.7""
  }
 },
 ""nbformat"": 4,
 ""nbformat_minor"": 5
}","def min_moves_to_corners(n, m, i, j, a, b):

    corners = [(1, 1), (1, m), (n, 1), (n, m)]

    def is_accessible(x, y):
        return 1 <= x <= n and 1 <= y <= m

    min_moves = float('inf')
    for corner_x, corner_y in corners:
        x, y = i, j
        moves = 0
        
        while True:
            if x == corner_x and y == corner_y:
                min_moves = min(min_moves, moves)
                break

            if x < corner_x:
                x_new = min(x + a, n)
            else:
                x_new = max(x - a, 1)
            
            if y < corner_y:
                y_new = min(y + b, m)
            else:
                y_new = max(y - b, 1)

            x, y = x_new, y_new
            moves += 1

            if x == i and y == j:
                break
                
    return min_moves if min_moves != float('inf') else ""Poor Inna and pony!""

input_data = [
    '5 7 1 3 2 2\n',
    '5 5 2 3 1 1\n'
]

for line in input_data:
    n, m, i, j, a, b = map(int, line.strip().split())
    result = min_moves_to_corners(n, m, i, j, a, b)
    print(result)"
69,A,Young Physicist,PROGRAMMING,"['implementation', 'math']","A guy named Vasya attends the final grade of a high school. One day Vasya decided to watch a match of his favorite hockey team. And, as the boy loves hockey very much, even more than physics, he forgot to do the homework. Specifically, he forgot to complete his physics tasks. Next day the teacher got very angry at Vasya and decided to teach him a lesson. He gave the lazy student a seemingly easy task: You are given an idle body in space and the forces that affect it. The body can be considered as a material point with coordinates (0; 0; 0). Vasya had only to answer whether it is in equilibrium. ""Piece of cake"" — thought Vasya, we need only to check if the sum of all vectors is equal to 0. So, Vasya began to solve the problem. But later it turned out that there can be lots and lots of these forces, and Vasya can not cope without your help. Help him. Write a program that determines whether a body is idle or is moving by the given vectors of forces.","The first line contains a positive integer *n* (1<=≤<=*n*<=≤<=100), then follow *n* lines containing three integers each: the *x**i* coordinate, the *y**i* coordinate and the *z**i* coordinate of the force vector, applied to the body (<=-<=100<=≤<=*x**i*,<=*y**i*,<=*z**i*<=≤<=100).","Print the word ""YES"" if the body is in equilibrium, or the word ""NO"" if it is not.","['3\n4 1 7\n-2 4 -1\n1 -5 -3\n', '3\n3 -1 7\n-5 2 -4\n2 -1 -3\n']","['NO', 'YES']",none,OK,"def check_equilibrium(n, vectors):
    total_x = 0
    total_y = 0
    total_z = 0

    for vector in vectors:
        x, y, z = vector
        total_x += x
        total_y += y
        total_z += z

    if total_x == 0 and total_y == 0 and total_z == 0:
        return ""YES""
    else:
        return ""NO""

n = int(input())
vectors = []
for _ in range(n):
    x, y, z = map(int, input().split())
    vectors.append((x, y, z))

result = check_equilibrium(n, vectors)
print(result)","n = int(input().strip())
sum_x, sum_y, sum_z = 0, 0, 0

for _ in range(n):

    x, y, z = map(int, input().strip().split())

    sum_x += x
    sum_y += y
    sum_z += z

if sum_x == 0 and sum_y == 0 and sum_z == 0:
    print(""YES"")
else:
    print(""NO"")"
426,B,Sereja and Mirroring,PROGRAMMING,['implementation'],"Let's assume that we are given a matrix *b* of size *x*<=×<=*y*, let's determine the operation of mirroring matrix *b*. The mirroring of matrix *b* is a 2*x*<=×<=*y* matrix *c* which has the following properties:
 -  the upper half of matrix *c* (rows with numbers from 1 to *x*) exactly matches *b*; -  the lower half of matrix *c* (rows with numbers from *x*<=+<=1 to 2*x*) is symmetric to the upper one; the symmetry line is the line that separates two halves (the line that goes in the middle, between rows *x* and *x*<=+<=1). 
Sereja has an *n*<=×<=*m* matrix *a*. He wants to find such matrix *b*, that it can be transformed into matrix *a*, if we'll perform on it several (possibly zero) mirrorings. What minimum number of rows can such matrix contain?","The first line contains two integers, *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=100). Each of the next *n* lines contains *m* integers — the elements of matrix *a*. The *i*-th line contains integers *a**i*1,<=*a**i*2,<=...,<=*a**im* (0<=≤<=*a**ij*<=≤<=1) — the *i*-th row of the matrix *a*.","In the single line, print the answer to the problem — the minimum number of rows of matrix *b*.","['4 3\n0 0 1\n1 1 0\n1 1 0\n0 0 1\n', '3 3\n0 0 0\n0 0 0\n0 0 0\n', '8 1\n0\n1\n1\n0\n0\n1\n1\n0\n']","['2\n', '3\n', '2\n']","In the first test sample the answer is a 2 × 3 matrix *b*:

If we perform a mirroring operation with this matrix, we get the matrix *a* that is given in the input:",WRONG_ANSWER,"import fileinput

def check_matrix(m):
    first_half = []
    second_half = []
    for i in range(len(m) // 2):
        first_half.append(m[i])
    for j in range(len(m), len(m) // 2, -1):
        second_half.append(m[j-1])

    if (first_half == second_half):
        return first_half
    else:
        return -1;

if __name__ == '__main__':
    n,m = map(int, input().split())

    matrix = []
    for arg in range(n):
        matrix.append(input().split())

    if len(matrix) % 2 == 0:
        result = matrix
        num_rows = 0
        while(result != -1):
            result = check_matrix(result)
            if result != -1:
                num_rows = len(result)
        print(num_rows)
    else:
        print(n)","def min_rows_matrix_b(n, m, a):

    min_rows = n

    for x in range(1, n // 2 + 1):
        valid = True

        for i in range(x):
            if a[i] != a[2*x - 1 - i]:
                valid = False
                break
        
        if valid:
            min_rows = min(min_rows, x)

    if n % 2 == 0 and all(a[i] == a[n - 1 - i] for i in range(n // 2)):
        min_rows = min(min_rows, n // 2)
    
    return min_rows

import sys
input = sys.stdin.read
data = input().splitlines()

n, m = map(int, data[0].split())

a = [list(map(int, line.split())) for line in data[1:n + 1]]

result = min_rows_matrix_b(n, m, a)
print(result)"
846,A,Curriculum Vitae,PROGRAMMING,"['brute force', 'implementation']","Hideo Kojima has just quit his job at Konami. Now he is going to find a new place to work. Despite being such a well-known person, he still needs a CV to apply for a job.

During all his career Hideo has produced *n* games. Some of them were successful, some were not. Hideo wants to remove several of them (possibly zero) from his CV to make a better impression on employers. As a result there should be no unsuccessful game which comes right after successful one in his CV.

More formally, you are given an array *s*1,<=*s*2,<=...,<=*s**n* of zeros and ones. Zero corresponds to an unsuccessful game, one — to a successful one. Games are given in order they were produced, and Hideo can't swap these values. He should remove some elements from this array in such a way that no zero comes right after one.

Besides that, Hideo still wants to mention as much games in his CV as possible. Help this genius of a man determine the maximum number of games he can leave in his CV.","The first line contains one integer number *n* (1<=≤<=*n*<=≤<=100).

The second line contains *n* space-separated integer numbers *s*1,<=*s*2,<=...,<=*s**n* (0<=≤<=*s**i*<=≤<=1). 0 corresponds to an unsuccessful game, 1 — to a successful one.",Print one integer — the maximum number of games Hideo can leave in his CV so that no unsuccessful game comes after a successful one.,"['4\n1 1 0 1\n', '6\n0 1 0 0 1 0\n', '1\n0\n']","['3\n', '4\n', '1\n']",none,WRONG_ANSWER,"def main():
    n = int(input())
    a = map(int, input().split())
    s = sum(a)
    ans = max(s, n - s)

    zeros = 0
    for i, x in enumerate(a):
        if x == 0:
            zeros += 1
        else: 
            ans = max(ans, zeros + sum(a[i:]))

    print(ans)

main()","def max_games_in_cv(n, games):

    count = 0

    previous_game = None
    
    for game in games:

        if game == 1 or (game == 0 and previous_game != 1):
            count += 1
            previous_game = game
    
    return count

n = int(input())
games = list(map(int, input().split()))

result = max_games_in_cv(n, games)

print(result)"
20,C,Dijkstra?,PROGRAMMING,"['graphs', 'shortest paths']",You are given a weighted undirected graph. The vertices are enumerated from 1 to *n*. Your task is to find the shortest path between the vertex 1 and the vertex *n*.,"The first line contains two integers *n* and *m* (2<=≤<=*n*<=≤<=105,<=0<=≤<=*m*<=≤<=105), where *n* is the number of vertices and *m* is the number of edges. Following *m* lines contain one edge each in form *a**i*, *b**i* and *w**i* (1<=≤<=*a**i*,<=*b**i*<=≤<=*n*,<=1<=≤<=*w**i*<=≤<=106), where *a**i*,<=*b**i* are edge endpoints and *w**i* is the length of the edge.

It is possible that the graph has loops and multiple edges between pair of vertices.","Write the only integer -1 in case of no path. Write the shortest path in opposite case. If there are many solutions, print any of them.","['5 6\n1 2 2\n2 5 5\n2 3 4\n1 4 1\n4 3 3\n3 5 1\n', '5 6\n1 2 2\n2 5 5\n2 3 4\n1 4 1\n4 3 3\n3 5 1\n']","['1 4 3 5 ', '1 4 3 5 ']",none,WRONG_ANSWER,"import heapq
import sys
import math

class priority_queue:
    def __init__(self):
        self.pq = []

    def push(self, item):
        heapq.heappush(self.pq, item)

    def pop(self):
        return heapq.heappop(self.pq)

    def empty(self):
        return len(self.pq) == 0

class DijkstraGraph:

    def __init__(self, n):
        self.adj = [[] for _ in range(n)]
        self.n = n

    def add_edge(self, u, v, w):
        self.adj[u-1].append((v-1, w))

    def dijkstra(self, source):
        s = source-1
        dist = [math.inf] * self.n
        pred = [None] * self.n
        dist[s] = 0
        remaining = priority_queue()
        remaining.push((0, s))

        while not remaining.empty():
            d, u = remaining.pop()
            if d > dist[u]:
                continue
            for v, w in self.adj[u]:
                new_dist = d + w
                if new_dist < dist[v]:
                    dist[v] = new_dist
                    pred[v] = u
                    remaining.push((new_dist, v))

        return dist, pred

    def get_path(self, u, pred):
        v = u-1
        path = [v]
        if pred[v] is None:
            return [-1]
        while pred[v] != 0:
            path.append(pred[v])
            v = pred[v]
        path.append(pred[v])
        path = [x+1 for x in path]
        return path[::-1]

n, m = map(int, input().split())
dijkstra = DijkstraGraph(n)
for i in range(m):
    u, v, w = map(int, input().split())
    dijkstra.add_edge(u, v, w)

dist, pred = dijkstra.dijkstra(1)
path = dijkstra.get_path(n, pred)
for node in path:
    print(node, end="" "")","import sys
import heapq
from collections import defaultdict

def dijkstra(n, graph):

    distances = {i: float('inf') for i in range(1, n + 1)}
    distances[1] = 0
    priority_queue = [(0, 1)]
    previous_nodes = {i: None for i in range(1, n + 1)}

    while priority_queue:
        current_distance, current_vertex = heapq.heappop(priority_queue)

        if current_vertex == n:
            break

        if current_distance > distances[current_vertex]:
            continue

        for neighbor, weight in graph[current_vertex]:
            distance = current_distance + weight

            if distance < distances[neighbor]:
                distances[neighbor] = distance
                previous_nodes[neighbor] = current_vertex
                heapq.heappush(priority_queue, (distance, neighbor))

    path = []
    current_node = n
    while current_node is not None:
        path.append(current_node)
        current_node = previous_nodes[current_node]

    path.reverse()

    return path if distances[n] != float('inf') else [-1]

def main():
    input_data = sys.stdin.read().strip().splitlines()

    n, m = map(int, input_data[0].split())

    graph = defaultdict(list)
    for i in range(1, m + 1):
        a, b, w = map(int, input_data[i].split())
        graph[a].append((b, w))
        graph[b].append((a, w))

    shortest_path = dijkstra(n, graph)

    if shortest_path == [-1]:
        print(-1)
    else:
        print(' '.join(map(str, shortest_path)))

if __name__ == ""__main__"":
    main()"
53,D,Physical Education,PROGRAMMING,['sortings'],"Vasya is a school PE teacher. Unlike other PE teachers, Vasya doesn't like it when the students stand in line according to their height. Instead, he demands that the children stand in the following order: *a*1,<=*a*2,<=...,<=*a**n*, where *a**i* is the height of the *i*-th student in the line and *n* is the number of students in the line. The children find it hard to keep in mind this strange arrangement, and today they formed the line in the following order: *b*1,<=*b*2,<=...,<=*b**n*, which upset Vasya immensely. Now Vasya wants to rearrange the children so that the resulting order is like this: *a*1,<=*a*2,<=...,<=*a**n*. During each move Vasya can swap two people who stand next to each other in the line. Help Vasya, find the sequence of swaps leading to the arrangement Vasya needs. It is not required to minimize the number of moves.","The first line contains an integer *n* (1<=≤<=*n*<=≤<=300) which is the number of students. The second line contains *n* space-separated integers *a**i* (1<=≤<=*a**i*<=≤<=109) which represent the height of the student occupying the *i*-th place must possess. The third line contains *n* space-separated integers *b**i* (1<=≤<=*b**i*<=≤<=109) which represent the height of the student occupying the *i*-th place in the initial arrangement. It is possible that some students possess similar heights. It is guaranteed that it is possible to arrange the children in the required order, i.e. *a* and *b* coincide as multisets.","In the first line print an integer *k* (0<=≤<=*k*<=≤<=106) which is the number of moves. It is not required to minimize *k* but it must not exceed 106. Then print *k* lines each containing two space-separated integers. Line *p**i*, *p**i*<=+<=1 (1<=≤<=*p**i*<=≤<=*n*<=-<=1) means that Vasya should swap students occupying places *p**i* and *p**i*<=+<=1.","['4\n1 2 3 2\n3 2 1 2\n', '2\n1 100500\n1 100500\n']","['4\n2 3\n1 2\n3 4\n2 3\n', '0\n']",none,OK,"def vasya_and_physcult(count, a_str, b_str):
    size = int(count)
    a = list(map(int, a_str.split()))
    b = list(map(int, b_str.split()))
    changes_count = 0
    result = """"
    for i in range(size):
        current_index = i
        for j in range(i,size):
            if b[j] == a[i]:
               current_index = j
               break
        while current_index>i:
            b[current_index], b[current_index-1] = b[current_index-1], b[current_index-1]
            result += ""\n"" + f""{current_index} {current_index+1}""
            changes_count+=1
            current_index-=1
    return str(changes_count) + result

count = input()
a = input()
b = input()

print(vasya_and_physcult(count, a, b))","n = int(input())

a = list(map(int, input().split()))

b = list(map(int, input().split()))

swaps = []

index_map = {value: [] for value in b}
for index, value in enumerate(b):
    index_map[value].append(index)

for expected_height in a:

    current_pos = index_map[expected_height].pop()

    while current_pos > len(swaps):

        if current_pos > 0:

            b[current_pos], b[current_pos - 1] = b[current_pos - 1], b[current_pos]
            swaps.append((current_pos, current_pos + 1))
            current_pos -= 1

print(len(swaps))
for swap in swaps:
    print(swap[0], swap[1])"
276,A,Lunch Rush,PROGRAMMING,['implementation'],"Having written another programming contest, three Rabbits decided to grab some lunch. The coach gave the team exactly *k* time units for the lunch break.

The Rabbits have a list of *n* restaurants to lunch in: the *i*-th restaurant is characterized by two integers *f**i* and *t**i*. Value *t**i* shows the time the Rabbits need to lunch in the *i*-th restaurant. If time *t**i* exceeds the time *k* that the coach has given for the lunch break, then the Rabbits' joy from lunching in this restaurant will equal *f**i*<=-<=(*t**i*<=-<=*k*). Otherwise, the Rabbits get exactly *f**i* units of joy.

Your task is to find the value of the maximum joy the Rabbits can get from the lunch, depending on the restaurant. The Rabbits must choose exactly one restaurant to lunch in. Note that the joy value isn't necessarily a positive value.","The first line contains two space-separated integers — *n* (1<=≤<=*n*<=≤<=104) and *k* (1<=≤<=*k*<=≤<=109) — the number of restaurants in the Rabbits' list and the time the coach has given them to lunch, correspondingly. Each of the next *n* lines contains two space-separated integers — *f**i* (1<=≤<=*f**i*<=≤<=109) and *t**i* (1<=≤<=*t**i*<=≤<=109) — the characteristics of the *i*-th restaurant.",In a single line print a single integer — the maximum joy value that the Rabbits will get from the lunch.,"['2 5\n3 3\n4 5\n', '4 6\n5 8\n3 6\n2 3\n2 2\n', '1 5\n1 7\n']","['4\n', '3\n', '-1\n']",none,OK,"import sys
input=sys.stdin.readline
def exe():
    
    return max(l)
n,k=map(int,input().split())
l=[]
for i in range(n):
    f,t=map(int,input().split())
    if(t>k):
        a=f-(t-k)
    else:
        a=f
    l.append(a)
print(exe())","def max_joy(n, k, restaurants):
    max_joy_value = float('-inf')

    for f, t in restaurants:
        if t <= k:
            max_joy_value = max(max_joy_value, f)
        else:
            max_joy_value = max(max_joy_value, f - (t - k))

    return max_joy_value

import sys

def main():
    input_data = sys.stdin.read().strip().splitlines()
    n, k = map(int, input_data[0].split())
    restaurants = []

    for i in range(1, n + 1):
        f, t = map(int, input_data[i].split())
        restaurants.append((f, t))

    result = max_joy(n, k, restaurants)
    print(result)

if __name__ == ""__main__"":
    main()"
910,A,The Way to Home,PROGRAMMING,"['dfs and similar', 'dp', 'greedy', 'implementation']","A frog lives on the axis *Ox* and needs to reach home which is in the point *n*. She starts from the point 1. The frog can jump to the right at a distance not more than *d*. So, after she jumped from the point *x* she can reach the point *x*<=+<=*a*, where *a* is an integer from 1 to *d*.

For each point from 1 to *n* is known if there is a lily flower in it. The frog can jump only in points with a lilies. Guaranteed that there are lilies in the points 1 and *n*.

Determine the minimal number of jumps that the frog needs to reach home which is in the point *n* from the point 1. Consider that initially the frog is in the point 1. If the frog can not reach home, print -1.","The first line contains two integers *n* and *d* (2<=≤<=*n*<=≤<=100, 1<=≤<=*d*<=≤<=*n*<=-<=1) — the point, which the frog wants to reach, and the maximal length of the frog jump.

The second line contains a string *s* of length *n*, consisting of zeros and ones. If a character of the string *s* equals to zero, then in the corresponding point there is no lily flower. In the other case, in the corresponding point there is a lily flower. Guaranteed that the first and the last characters of the string *s* equal to one.","If the frog can not reach the home, print -1.

In the other case, print the minimal number of jumps that the frog needs to reach the home which is in the point *n* from the point 1.","['8 4\n10010101\n', '4 2\n1001\n', '8 4\n11100101\n', '12 3\n101111100101\n']","['2\n', '-1\n', '3\n', '4\n']","In the first example the from can reach home in two jumps: the first jump from the point 1 to the point 4 (the length of the jump is three), and the second jump from the point 4 to the point 8 (the length of the jump is four).

In the second example the frog can not reach home, because to make it she need to jump on a distance three, but the maximum length of her jump equals to two.",OK,"def jumps(t, s, a):
    p=1
    j=0
    i=0
    while i < s:
        if p+s-i<=t and int(a[p+s-i-1])==1:
            p=p+s-i
            j+=1
            i=-1
            if p==t:
                print(j)
                return

        i+=1
    print(-1)

def main():
    try:
        k=[int(x) for x in input().split(' ')]
        t=k[0]
        s=k[1]
        a=input()
        jumps(t, s, a)
        main()
    except:
        print()
main()","def minimal_jumps(n, d, s):

    current_position = 1
    jumps = 0

    while current_position < n:

        farthest_jump = min(n, current_position + d)

        next_position = -1
        
        for pos in range(farthest_jump, current_position, -1):
            if s[pos - 1] == '1':
                next_position = pos
                break

        if next_position == -1:
            return -1

        current_position = next_position
        jumps += 1
    
    return jumps

import sys
input_data = sys.stdin.read().strip().split('\n')
results = []

for line in input_data:
    n, d = map(int, line.split())
    s = input_data.pop(0)
    result = minimal_jumps(n, d, s)
    results.append(str(result))

print(""\n"".join(results))"
379,A,New Year Candles,PROGRAMMING,['implementation'],"Vasily the Programmer loves romance, so this year he decided to illuminate his room with candles.

Vasily has *a* candles.When Vasily lights up a new candle, it first burns for an hour and then it goes out. Vasily is smart, so he can make *b* went out candles into a new candle. As a result, this new candle can be used like any other new candle.

Now Vasily wonders: for how many hours can his candles light up the room if he acts optimally well? Help him find this number.","The single line contains two integers, *a* and *b* (1<=≤<=*a*<=≤<=1000; 2<=≤<=*b*<=≤<=1000).",Print a single integer — the number of hours Vasily can light up the room for.,"['4 2\n', '6 3\n']","['7\n', '8\n']","Consider the first sample. For the first four hours Vasily lights up new candles, then he uses four burned out candles to make two new ones and lights them up. When these candles go out (stop burning), Vasily can make another candle. Overall, Vasily can light up the room for 7 hours.",WRONG_ANSWER,"import math

def candle(a, b):
    k = a % b
    l = a // b
    if(a < b):
        return a
    else:
        return a + candle(k + l, b)

if __name__ == '__main__':
    _ = input().split()
    a = int(_[0])
    b = int(_[1])
    print(candle(a, b))","def max_light_hours(a, b):
    total_hours = a
    burned_out = a

    while burned_out >= b:
        new_candles = burned_out // b
        total_hours += new_candles
        burned_out = burned_out % b + new_candles
    
    return total_hours

input_data = input().strip()
a, b = map(int, input_data.split())

print(max_light_hours(a, b))"
357,B,Flag Day,PROGRAMMING,"['constructive algorithms', 'implementation']","In Berland, there is the national holiday coming — the Flag Day. In the honor of this event the president of the country decided to make a big dance party and asked your agency to organize it. He has several conditions:
 -  overall, there must be *m* dances;-  exactly three people must take part in each dance;-  each dance must have one dancer in white clothes, one dancer in red clothes and one dancer in blue clothes (these are the colors of the national flag of Berland). 
The agency has *n* dancers, and their number can be less than 3*m*. That is, some dancers will probably have to dance in more than one dance. All of your dancers must dance on the party. However, if some dance has two or more dancers from a previous dance, then the current dance stops being spectacular. Your agency cannot allow that to happen, so each dance has at most one dancer who has danced in some previous dance. 

You considered all the criteria and made the plan for the *m* dances: each dance had three dancers participating in it. Your task is to determine the clothes color for each of the *n* dancers so that the President's third condition fulfilled: each dance must have a dancer in white, a dancer in red and a dancer in blue. The dancers cannot change clothes between the dances.","The first line contains two space-separated integers *n* (3<=≤<=*n*<=≤<=105) and *m* (1<=≤<=*m*<=≤<=105) — the number of dancers and the number of dances, correspondingly. Then *m* lines follow, describing the dances in the order of dancing them. The *i*-th line contains three distinct integers — the numbers of the dancers that take part in the *i*-th dance. The dancers are numbered from 1 to *n*. Each dancer takes part in at least one dance.","Print *n* space-separated integers: the *i*-th number must represent the color of the *i*-th dancer's clothes (1 for white, 2 for red, 3 for blue). If there are multiple valid solutions, print any of them. It is guaranteed that at least one solution exists.","['7 3\n1 2 3\n1 4 5\n4 6 7\n', '9 3\n3 6 9\n2 5 8\n1 4 7\n', '5 2\n4 1 5\n3 1 2\n']","['1 2 3 3 2 2 1 \n', '1 1 1 2 2 2 3 3 3 \n', '2 3 1 1 3 \n']",none,WRONG_ANSWER,"data = input().split("" "")
dances = int(data[1])
totalDancers = int(data[0])

dict = {}
for d in range(dances):
	dancers = input().split("" "")
	dancers = [int(x) for x in dancers]
	i = 0
	while i<3:
		dict.setdefault(dancers[i], i)
		if dancers[i] in dict:
			if dict[dancers[i]] != i:
				print(dancers[i])
				print(dancers[dict[dancers[i]]])
				dancers[dict[dancers[i]]], dancers[i] = dancers[i], dancers[dict[dancers[i]]]
				i = -1
		else:
			dict.setdefault(dancers[i], i)
		i += 1
ans = """"
for i in range(1, totalDancers+1):
	ans = ans + str(dict[i]+1) + "" ""
print(ans)","def assign_colors(n, m, dances):

    colors = [0] * (n + 1)

    for dance in dances:
        dancer1, dancer2, dancer3 = dance

        color1 = colors[dancer1]
        color2 = colors[dancer2]
        color3 = colors[dancer3]

        if color1 == 0:
            colors[dancer1] = 1
        if color2 == 0:
            colors[dancer2] = 2
        if color3 == 0:
            colors[dancer3] = 3

    for i in range(1, n + 1):
        if colors[i] == 0:

            used_colors = {colors[dancer] for dancer in dances[i-1] if colors[dancer] != 0}
            for color in range(1, 4):
                if color not in used_colors:
                    colors[i] = color
                    break

    return colors[1:]

import sys

def main():
    input_data = sys.stdin.read().strip().splitlines()
    index = 0
    results = []
    
    while index < len(input_data):

        n, m = map(int, input_data[index].split())
        index += 1
        
        dances = []
        for _ in range(m):
            dancers = list(map(int, input_data[index].split()))
            dances.append(dancers)
            index += 1

        colors = assign_colors(n, m, dances)
        results.append("" "".join(map(str, colors)))

    print(""\n"".join(results))

if __name__ == ""__main__"":
    main()"
977,C,Less or Equal,PROGRAMMING,['sortings'],"You are given a sequence of integers of length $n$ and integer number $k$. You should print any integer number $x$ in the range of $[1; 10^9]$ (i.e. $1 \le x \le 10^9$) such that exactly $k$ elements of given sequence are less than or equal to $x$.

Note that the sequence can contain equal elements.

If there is no such $x$, print ""-1"" (without quotes).","The first line of the input contains integer numbers $n$ and $k$ ($1 \le n \le 2 \cdot 10^5$, $0 \le k \le n$). The second line of the input contains $n$ integer numbers $a_1, a_2, \dots, a_n$ ($1 \le a_i \le 10^9$) — the sequence itself.","Print any integer number $x$ from range $[1; 10^9]$ such that exactly $k$ elements of given sequence is less or equal to $x$.

If there is no such $x$, print ""-1"" (without quotes).","['7 4\n3 7 5 1 10 3 20\n', '7 2\n3 7 5 1 10 3 20\n']","['6', '-1\n']","In the first example $5$ is also a valid answer because the elements with indices $[1, 3, 4, 6]$ is less than or equal to $5$ and obviously less than or equal to $6$.

In the second example you cannot choose any number that only $2$ elements of the given sequence will be less than or equal to this number because $3$ elements of the given sequence will be also less than or equal to this number.",WRONG_ANSWER,"il = lambda: map(int, input().split())

def f(n, k, l):
	return -1 if l[k-1] == l[k] else l[k-1]

print(f(*il(), sorted(il())))","def find_x(n, k, a):

    a.sort()

    if k == 0:
        if a[0] > 1:
            print(1)
        else:
            print(-1)
        return

    if k > n:
        print(-1)
        return
    elif k == n:
        print(a[-1])
        return

    x = a[k - 1]
    if k < n and x == a[k]:
        print(-1)
    else:
        print(x)

input_data = '7 4\n3 7 5 1 10 3 20\n'
n, k = map(int, input_data.split()[0:2])
a = list(map(int, input_data.split()[2:]))
find_x(n, k, a)

input_data = '7 2\n3 7 5 1 10 3 20\n'
n, k = map(int, input_data.split()[0:2])
a = list(map(int, input_data.split()[2:]))
find_x(n, k, a)"
526,D,Om Nom and Necklace,PROGRAMMING,"['hashing', 'string suffix structures', 'strings']","One day Om Nom found a thread with *n* beads of different colors. He decided to cut the first several beads from this thread to make a bead necklace and present it to his girlfriend Om Nelly.

Om Nom knows that his girlfriend loves beautiful patterns. That's why he wants the beads on the necklace to form a regular pattern. A sequence of beads *S* is regular if it can be represented as *S*<==<=*A*<=+<=*B*<=+<=*A*<=+<=*B*<=+<=*A*<=+<=...<=+<=*A*<=+<=*B*<=+<=*A*, where *A* and *B* are some bead sequences, ""<=+<="" is the concatenation of sequences, there are exactly 2*k*<=+<=1 summands in this sum, among which there are *k*<=+<=1 ""*A*"" summands and *k* ""*B*"" summands that follow in alternating order. Om Nelly knows that her friend is an eager mathematician, so she doesn't mind if *A* or *B* is an empty sequence.

Help Om Nom determine in which ways he can cut off the first several beads from the found thread (at least one; probably, all) so that they form a regular pattern. When Om Nom cuts off the beads, he doesn't change their order.","The first line contains two integers *n*, *k* (1<=≤<=*n*,<=*k*<=≤<=1<=000<=000) — the number of beads on the thread that Om Nom found and number *k* from the definition of the regular sequence above.

The second line contains the sequence of *n* lowercase Latin letters that represent the colors of the beads. Each color corresponds to a single letter.","Print a string consisting of *n* zeroes and ones. Position *i* (1<=≤<=*i*<=≤<=*n*) must contain either number one if the first *i* beads on the thread form a regular sequence, or a zero otherwise.","['7 2\nbcabcab\n', '21 2\nababaababaababaababaa\n']","['0000011', '000110000111111000011']","In the first sample test a regular sequence is both a sequence of the first 6 beads (we can take *A* = """", *B* = ""bca""), and a sequence of the first 7 beads (we can take *A* = ""b"", *B* = ""ca"").

In the second sample test, for example, a sequence of the first 13 beads is regular, if we take *A* = ""aba"", *B* = ""ba"".",OK,"def prefix_function(s: str):
  n = len(s)
  pi = [0] * n
  k = 0
  for i in range(1, n):
    while k > 0 and s[i] != s[k]:
      k = pi[k - 1]
    if s[i] == s[k]:
      k += 1
    pi[i] = k
  return pi

def z_function(s: str):
  n = len(s)
  z = [0] * n
  l, r = 0, 0
  for i in range(1, n):
    z[i] = 0 if i >= r else min(r - i, z[i - l])
    while i + z[i] < n and s[z[i]] == s[i + z[i]]:
      z[i] += 1
    if i + z[i] > r:
      l, r = i, i + z[i]
  return z

n, k = map(int, input().split())
s = input()
pi = prefix_function(s)

ans = [0] * n
for i in range(n):
  L = i + 1
  T = L - pi[i]
  have, remain = divmod(L, T)

  len_ab = have // k * T
  len_a = (have % k) * T + remain
  if len_ab >= len_a:
    ans[i] = 1
print("""".join(map(str, ans)))","def is_regular_pattern(n, k, beads):
    result = []

    for i in range(1, n + 1):
        found = False

        for len_a in range((i // (2 * k + 1)) + 1):
            for len_b in range((i // (2 * k + 1)) + 1):
                if len_a + len_b == 0:
                    continue

                pattern = ''
                for j in range(k):
                    pattern += beads[:len_a]
                    pattern += beads[len_a:len_a + len_b]

                if pattern[:i] == beads[:i]:
                    found = True
                    break
            
            if found:
                break

        result.append('1' if found else '0')
    
    return ''.join(result)

inputs = ['7 2\nbcabcab\n', '21 2\nababaababaababaababaa\n']
outputs = []

for input_str in inputs:
    n, k, beads = input_str.split()
    n, k = int(n), int(k)
    outputs.append(is_regular_pattern(n, k, beads.strip()))

print(outputs)"
780,A,Andryusha and Socks,PROGRAMMING,['implementation'],"Andryusha is an orderly boy and likes to keep things in their place.

Today he faced a problem to put his socks in the wardrobe. He has *n* distinct pairs of socks which are initially in a bag. The pairs are numbered from 1 to *n*. Andryusha wants to put paired socks together and put them in the wardrobe. He takes the socks one by one from the bag, and for each sock he looks whether the pair of this sock has been already took out of the bag, or not. If not (that means the pair of this sock is still in the bag), he puts the current socks on the table in front of him. Otherwise, he puts both socks from the pair to the wardrobe.

Andryusha remembers the order in which he took the socks from the bag. Can you tell him what is the maximum number of socks that were on the table at the same time?","The first line contains the single integer *n* (1<=≤<=*n*<=≤<=105) — the number of sock pairs.

The second line contains 2*n* integers *x*1,<=*x*2,<=...,<=*x*2*n* (1<=≤<=*x**i*<=≤<=*n*), which describe the order in which Andryusha took the socks from the bag. More precisely, *x**i* means that the *i*-th sock Andryusha took out was from pair *x**i*.

It is guaranteed that Andryusha took exactly two socks of each pair.",Print single integer — the maximum number of socks that were on the table at the same time.,"['1\n1 1\n', '3\n2 1 1 3 2 3\n']","['1\n', '2\n']","In the first example Andryusha took a sock from the first pair and put it on the table. Then he took the next sock which is from the first pair as well, so he immediately puts both socks to the wardrobe. Thus, at most one sock was on the table at the same time.

In the second example Andryusha behaved as follows: 
 -  Initially the table was empty, he took out a sock from pair 2 and put it on the table. -  Sock (2) was on the table. Andryusha took out a sock from pair 1 and put it on the table. -  Socks (1, 2) were on the table. Andryusha took out a sock from pair 1, and put this pair into the wardrobe. -  Sock (2) was on the table. Andryusha took out a sock from pair 3 and put it on the table. -  Socks (2, 3) were on the table. Andryusha took out a sock from pair 2, and put this pair into the wardrobe. -  Sock (3) was on the table. Andryusha took out a sock from pair 3 and put this pair into the wardrobe.",WRONG_ANSWER,"import math
import os
import random
import re
import sys
from math import gcd
from math import sqrt
from collections import Counter

n = int(input())
arr = list(map(int,input().split()))
print(len(set(arr)))","def max_socks_on_table(n, socks):

    sock_count = {}
    max_on_table = 0
    
    for sock in socks:

        if sock in sock_count and sock_count[sock] > 0:
            sock_count[sock] -= 1
            if sock_count[sock] == 0:
                del sock_count[sock]
        else:

            if sock in sock_count:
                sock_count[sock] += 1
            else:
                sock_count[sock] = 1

        current_on_table = sum(sock_count.values())
        max_on_table = max(max_on_table, current_on_table)
    
    return max_on_table

if __name__ == ""__main__"":
    import sys
    
    input = sys.stdin.read
    data = input().splitlines()
    
    n = int(data[0])
    socks = list(map(int, data[1].split()))
    
    result = max_socks_on_table(n, socks)
    print(result)"
59,A,Word,PROGRAMMING,"['implementation', 'strings']","Vasya is very upset that many people on the Net mix uppercase and lowercase letters in one word. That's why he decided to invent an extension for his favorite browser that would change the letters' register in every word so that it either only consisted of lowercase letters or, vice versa, only of uppercase ones. At that as little as possible letters should be changed in the word. For example, the word HoUse must be replaced with house, and the word ViP — with VIP. If a word contains an equal number of uppercase and lowercase letters, you should replace all the letters with lowercase ones. For example, maTRIx should be replaced by matrix. Your task is to use the given method on one given word.",The first line contains a word *s* — it consists of uppercase and lowercase Latin letters and possesses the length from 1 to 100.,"Print the corrected word *s*. If the given word *s* has strictly more uppercase letters, make the word written in the uppercase register, otherwise - in the lowercase one.","['HoUse\n', 'ViP\n', 'maTRIx\n']","['house\n', 'VIP\n', 'matrix\n']",none,WRONG_ANSWER,"alphabet = ""abcdefghijklmnopqrstuvwxyz""
word = str(input())
if sum([c in alphabet for c in word]) < (len(word)+1) / 2:
    print(word.upper())
else:
    print(word.lower())","def correct_word(word):

    lowercase_count = sum(1 for char in word if char.islower())
    uppercase_count = sum(1 for char in word if char.isupper())

    if uppercase_count > lowercase_count:
        return word.upper()
    else:
        return word.lower()

input_word = input().strip()

output_word = correct_word(input_word)
print(output_word)"
450,B,Jzzhu and Sequences,PROGRAMMING,"['implementation', 'math']","Jzzhu has invented a kind of sequences, they meet the following property:

You are given *x* and *y*, please calculate *f**n* modulo 1000000007 (109<=+<=7).","The first line contains two integers *x* and *y* (|*x*|,<=|*y*|<=≤<=109). The second line contains a single integer *n* (1<=≤<=*n*<=≤<=2·109).",Output a single integer representing *f**n* modulo 1000000007 (109<=+<=7).,"['2 3\n3\n', '0 -1\n2\n']","['1\n', '1000000006\n']","In the first sample, *f*<sub class=""lower-index"">2</sub> = *f*<sub class=""lower-index"">1</sub> + *f*<sub class=""lower-index"">3</sub>, 3 = 2 + *f*<sub class=""lower-index"">3</sub>, *f*<sub class=""lower-index"">3</sub> = 1.

In the second sample, *f*<sub class=""lower-index"">2</sub> =  - 1;  - 1 modulo (10<sup class=""upper-index"">9</sup> + 7) equals (10<sup class=""upper-index"">9</sup> + 6).",WRONG_ANSWER,"def f(n,x,y):
    if n%6==1:
        return(x)
    if n%6==2:
        return(y)
    if n%6==3:
        return(y-x)
    if n%6==4:
        return(-x)
    if n%6==5:
        return(-y)
    if n%6==0:
        return(x-y)
x,y=map(int,input().split())
n=int(input())
print(f(n,x,y%1000000007))","def calculate_sequence(x, y, n):
    MOD = 1000000007
    
    if n == 0:
        return (x % MOD + MOD) % MOD
    elif n == 1:
        return (y % MOD + MOD) % MOD

    def matrix_mult(A, B):

        return [
            [(A[0][0] * B[0][0] + A[0][1] * B[1][0]) % MOD, 
              (A[0][0] * B[0][1] + A[0][1] * B[1][1]) % MOD],
            [(A[1][0] * B[0][0] + A[1][1] * B[1][0]) % MOD, 
              (A[1][0] * B[0][1] + A[1][1] * B[1][1]) % MOD]
        ]

    def matrix_pow(mat, p):

        res = [[1, 0], [0, 1]]
        while p:
            if p % 2:
                res = matrix_mult(res, mat)
            mat = matrix_mult(mat, mat)
            p //= 2
        return res

    transformation_matrix = [[0, 1], [1, 1]]
    result_matrix = matrix_pow(transformation_matrix, n - 1)

    fn = (result_matrix[0][0] * x + result_matrix[0][1] * y) % MOD
    return (fn + MOD) % MOD

import sys
input = sys.stdin.read
data = input().splitlines()

x, y = map(int, data[0].split())
n = int(data[1])
print(calculate_sequence(x, y, n))"
58,A,Chat room,PROGRAMMING,"['greedy', 'strings']","Vasya has recently learned to type and log on to the Internet. He immediately entered a chat room and decided to say hello to everybody. Vasya typed the word *s*. It is considered that Vasya managed to say hello if several letters can be deleted from the typed word so that it resulted in the word ""hello"". For example, if Vasya types the word ""ahhellllloou"", it will be considered that he said hello, and if he types ""hlelo"", it will be considered that Vasya got misunderstood and he didn't manage to say hello. Determine whether Vasya managed to say hello by the given word *s*.","The first and only line contains the word *s*, which Vasya typed. This word consisits of small Latin letters, its length is no less that 1 and no more than 100 letters.","If Vasya managed to say hello, print ""YES"", otherwise print ""NO"".","['ahhellllloou\n', 'hlelo\n']","['YES\n', 'NO\n']",none,OK,"def find(needle, haystack):
    if not needle: return True
    
    if needle[0] not in haystack:
        return False
    
    return find(needle[1:], haystack[haystack.find(needle[0])+1:])

if find(""hello"", input()):
    print(""YES"")
else:
    print(""NO"")","def can_say_hello(s):
    target = ""hello""
    index = 0
    for char in s:
        if char == target[index]:
            index += 1
        if index == len(target):
            return ""YES""
    return ""NO""

s = input().strip()

print(can_say_hello(s))"
633,C,Spy Syndrome 2,PROGRAMMING,"['data structures', 'dp', 'hashing', 'implementation', 'sortings', 'string suffix structures', 'strings']","After observing the results of Spy Syndrome, Yash realised the errors of his ways. He now believes that a super spy such as Siddhant can't use a cipher as basic and ancient as Caesar cipher. After many weeks of observation of Siddhant’s sentences, Yash determined a new cipher technique.

For a given sentence, the cipher is processed as: 
 1.  Convert all letters of the sentence to lowercase. 1.  Reverse each of the words of the sentence individually. 1.  Remove all the spaces in the sentence. 
For example, when this cipher is applied to the sentence

Kira is childish and he hates losing

the resulting string is

ariksihsidlihcdnaehsetahgnisol

Now Yash is given some ciphered string and a list of words. Help him to find out any original sentence composed using only words from the list. Note, that any of the given words could be used in the sentence multiple times.","The first line of the input contains a single integer *n* (1<=≤<=*n*<=≤<=10<=000) — the length of the ciphered text. The second line consists of *n* lowercase English letters — the ciphered text *t*.

The third line contains a single integer *m* (1<=≤<=*m*<=≤<=100<=000) — the number of words which will be considered while deciphering the text. Each of the next *m* lines contains a non-empty word *w**i* (|*w**i*|<=≤<=1<=000) consisting of uppercase and lowercase English letters only. It's guaranteed that the total length of all words doesn't exceed 1<=000<=000.","Print one line — the original sentence. It is guaranteed that at least one solution exists. If there are multiple solutions, you may output any of those.","['30\nariksihsidlihcdnaehsetahgnisol\n10\nKira\nhates\nis\nhe\nlosing\ndeath\nchildish\nL\nand\nNote\n', '12\niherehtolleh\n5\nHI\nHo\nthere\nHeLLo\nhello\n']","['Kira is childish and he hates losing \n', 'HI there HeLLo \n']","In sample case 2 there may be multiple accepted outputs, ""HI there HeLLo"" and ""HI there hello"" you may output any of them.",RUNTIME_ERROR,"import heapq
import math
import collections
import bisect
mod=10**9+7
maxi=10**3
ppow=[0]*maxi
p=31
ppow[0]=1
for i in range(1,maxi):
    ppow[i]=(ppow[i-1]*p)%mod
def hash(st):
    st=st.lower()
    hash1=0
    for i in range(len(st)):
        hash1=(hash1+(ord(st[i])-96)*ppow[i])%mod
    return hash1    
def solve(n,s,d):
    res=[]
    def findall(ind,curr,li):
        if ind==n:
            if curr==0:
                res.append(li)
                return True
            return False
                

        curr=(curr*p+ord(s[ind])-96)%mod
        if curr in d:
            if findall(ind+1,0,li+d[curr]+"" ""):
                return True
        return findall(ind+1,curr,li)        
    findall(0,0,"""")
    return res[0]

n=int(input())
s=input()
m=int(input())
d={}
for i in range(m):
    name=input()
    val=hash(name)
    d[val]=name

print(solve(n,s,d))","from collections import defaultdict

def reverse_word(word):
    return word[::-1]

def can_form_sentence(ciphered_text, words):
    word_set = set(word.lower() for word in words)
    n = len(ciphered_text)
    dp = [None] * (n + 1)

    dp[0] = """"

    for i in range(1, n + 1):
        for word in word_set:
            word_length = len(word)
            if i >= word_length and dp[i - word_length] is not None:

                if ciphered_text[i - word_length:i] == reverse_word(word):
                    dp[i] = (dp[i - word_length] + ' ' + word).strip()
                    break

    return dp[n]

n = int(input().strip())
ciphered_text = input().strip()
m = int(input().strip())
words = [input().strip() for _ in range(m)]

result_sentence = can_form_sentence(ciphered_text, words)

print(result_sentence)"
653,A,Bear and Three Balls,PROGRAMMING,"['brute force', 'implementation', 'sortings']","Limak is a little polar bear. He has *n* balls, the *i*-th ball has size *t**i*.

Limak wants to give one ball to each of his three friends. Giving gifts isn't easy — there are two rules Limak must obey to make friends happy:
 -  No two friends can get balls of the same size. -  No two friends can get balls of sizes that differ by more than 2. 
For example, Limak can choose balls with sizes 4, 5 and 3, or balls with sizes 90, 91 and 92. But he can't choose balls with sizes 5, 5 and 6 (two friends would get balls of the same size), and he can't choose balls with sizes 30, 31 and 33 (because sizes 30 and 33 differ by more than 2).

Your task is to check whether Limak can choose three balls that satisfy conditions above.","The first line of the input contains one integer *n* (3<=≤<=*n*<=≤<=50) — the number of balls Limak has.

The second line contains *n* integers *t*1,<=*t*2,<=...,<=*t**n* (1<=≤<=*t**i*<=≤<=1000) where *t**i* denotes the size of the *i*-th ball.","Print ""YES"" (without quotes) if Limak can choose three balls of distinct sizes, such that any two of them differ by no more than 2. Otherwise, print ""NO"" (without quotes).","['4\n18 55 16 17\n', '6\n40 41 43 44 44 44\n', '8\n5 972 3 4 1 4 970 971\n']","['YES\n', 'NO\n', 'YES\n']","In the first sample, there are 4 balls and Limak is able to choose three of them to satisfy the rules. He must must choose balls with sizes 18, 16 and 17.

In the second sample, there is no way to give gifts to three friends without breaking the rules.

In the third sample, there is even more than one way to choose balls:
 1.  Choose balls with sizes 3, 4 and 5. 1.  Choose balls with sizes 972, 970, 971.",WRONG_ANSWER,"def insertionSort(arr):

    for i in range(1, len(arr)):
 
        key = arr[i]

        j = i-1
        while j >= 0 and key < arr[j] :
                arr[j + 1] = arr[j]
                j -= 1
        arr[j + 1] = key

a = int(input())
b = str(input())
n = b.split()
for i in range (a):
  n[i] = int(n[i])

insertionSort(n)
encontrado =0
if (a<3):
  print(""NO"")
else:
  for i in range (a-2):
    c = n[i]
    d = n[i+1]
    e = n[i+2]
    if (e-d == 1 and d-c == 1):
      encontrado =1
if (encontrado == 0):
  print(""NO"")
else:
  print(""YES"")","def can_give_balls(n, sizes):

    sizes.sort()

    for i in range(n - 2):

        if sizes[i+1] == sizes[i] or sizes[i+2] == sizes[i]:
            continue
        
        if sizes[i+2] - sizes[i] <= 2:

            return ""YES""

    return ""NO""

n = int(input())
sizes = list(map(int, input().split()))

print(can_give_balls(n, sizes))"
617,A,Elephant,PROGRAMMING,['math'],"An elephant decided to visit his friend. It turned out that the elephant's house is located at point 0 and his friend's house is located at point *x*(*x*<=&gt;<=0) of the coordinate line. In one step the elephant can move 1, 2, 3, 4 or 5 positions forward. Determine, what is the minimum number of steps he need to make in order to get to his friend's house.",The first line of the input contains an integer *x* (1<=≤<=*x*<=≤<=1<=000<=000) — The coordinate of the friend's house.,Print the minimum number of steps that elephant needs to make to get from point 0 to point *x*.,"['5\n', '12\n']","['1\n', '3\n']","In the first sample the elephant needs to make one step of length 5 to reach the point *x*.

In the second sample the elephant can get to point *x* if he moves by 3, 5 and 4. There are other ways to get the optimal answer but the elephant cannot reach *x* in less than three moves.",OK,"def min_steps_to_reach(x):
    steps = x // 5
    if x % 5 != 0:
        steps += 1
    return steps

x = int(input())

result = min_steps_to_reach(x)
print(result)","def min_steps_to_friend_house(x):

    steps = x // 5
    if x % 5 != 0:
        steps += 1
    return steps

inputs = ['5', '12']
outputs = []

for x in inputs:
    x = int(x.strip())
    result = min_steps_to_friend_house(x)
    outputs.append(result)

for output in outputs:
    print(output)"
813,B,The Golden Age,PROGRAMMING,"['brute force', 'math']","Unlucky year in Berland is such a year that its number *n* can be represented as *n*<==<=*x**a*<=+<=*y**b*, where *a* and *b* are non-negative integer numbers. 

For example, if *x*<==<=2 and *y*<==<=3 then the years 4 and 17 are unlucky (4<==<=20<=+<=31, 17<==<=23<=+<=32<==<=24<=+<=30) and year 18 isn't unlucky as there is no such representation for it.

Such interval of years that there are no unlucky years in it is called The Golden Age.

You should write a program which will find maximum length of The Golden Age which starts no earlier than the year *l* and ends no later than the year *r*. If all years in the interval [*l*,<=*r*] are unlucky then the answer is 0.","The first line contains four integer numbers *x*, *y*, *l* and *r* (2<=≤<=*x*,<=*y*<=≤<=1018, 1<=≤<=*l*<=≤<=*r*<=≤<=1018).","Print the maximum length of The Golden Age within the interval [*l*,<=*r*].

If all years in the interval [*l*,<=*r*] are unlucky then print 0.","['2 3 1 10\n', '3 5 10 22\n', '2 3 3 5\n']","['1\n', '8\n', '0\n']","In the first example the unlucky years are 2, 3, 4, 5, 7, 9 and 10. So maximum length of The Golden Age is achived in the intervals [1, 1], [6, 6] and [8, 8].

In the second example the longest Golden Age is the interval [15, 22].",OK,"def parser():
    while 1:
        data = list(input().split(' '))
        for number in data:
            if len(number) > 0:
                yield(number)   

input_parser = parser()

def get_word():
    global input_parser
    return next(input_parser)

def get_number():
    data = get_word()
    try:
        return int(data)
    except ValueError:
        return float(data)

x = get_number()
y = get_number()
l = get_number()
r = get_number()
n1 = 1;
a = list()
a.append(l - 1)
for i in range(0, 300):
    if n1 > r:
        break
    n2 = 1 
    for j in range(0, 300):
        if n1 + n2 > r:
            break
        if n1 + n2 >= l and n1 + n2 <= r:
            a.append(n1 + n2)
        n2 = n2 * y
    n1 = n1 * x
    
a.append(r + 1)
a.sort()
ans = 0
for i in range(0, len(a) - 1):
    ans = max(ans, a[i + 1] - a[i] - 1)
print(ans)","def find_golden_age(x, y, l, r):
    unlucky_years = set()

    a = 0
    while True:
        power_x = x ** a
        if power_x > r:
            break
        b = 0
        while True:
            power_y = y ** b
            if power_x + power_y > r:
                break
            unlucky_year = power_x + power_y
            if l <= unlucky_year <= r:
                unlucky_years.add(unlucky_year)
            b += 1
        a += 1

    max_length = 0
    current_length = 0
    for year in range(l, r + 1):
        if year not in unlucky_years:
            current_length += 1
            max_length = max(max_length, current_length)
        else:
            current_length = 0

    return max_length

if __name__ == ""__main__"":
    import sys
    input_data = sys.stdin.read().strip().split('\n')
    results = []

    for line in input_data:
        x, y, l, r = map(int, line.split())
        result = find_golden_age(x, y, l, r)
        results.append(f""{result}\n"")

    sys.stdout.write(''.join(results))"
593,B,Anton and Lines,PROGRAMMING,"['geometry', 'sortings']","The teacher gave Anton a large geometry homework, but he didn't do it (as usual) as he participated in a regular round on Codeforces. In the task he was given a set of *n* lines defined by the equations *y*<==<=*k**i*·*x*<=+<=*b**i*. It was necessary to determine whether there is at least one point of intersection of two of these lines, that lays strictly inside the strip between *x*1<=&lt;<=*x*2. In other words, is it true that there are 1<=≤<=*i*<=&lt;<=*j*<=≤<=*n* and *x*',<=*y*', such that: 
 -  *y*'<==<=*k**i*<=*<=*x*'<=+<=*b**i*, that is, point (*x*',<=*y*') belongs to the line number *i*; -  *y*'<==<=*k**j*<=*<=*x*'<=+<=*b**j*, that is, point (*x*',<=*y*') belongs to the line number *j*; -  *x*1<=&lt;<=*x*'<=&lt;<=*x*2, that is, point (*x*',<=*y*') lies inside the strip bounded by *x*1<=&lt;<=*x*2. 
You can't leave Anton in trouble, can you? Write a program that solves the given task.","The first line of the input contains an integer *n* (2<=≤<=*n*<=≤<=100<=000) — the number of lines in the task given to Anton. The second line contains integers *x*1 and *x*2 (<=-<=1<=000<=000<=≤<=*x*1<=&lt;<=*x*2<=≤<=1<=000<=000) defining the strip inside which you need to find a point of intersection of at least two lines.

The following *n* lines contain integers *k**i*, *b**i* (<=-<=1<=000<=000<=≤<=*k**i*,<=*b**i*<=≤<=1<=000<=000) — the descriptions of the lines. It is guaranteed that all lines are pairwise distinct, that is, for any two *i*<=≠<=*j* it is true that either *k**i*<=≠<=*k**j*, or *b**i*<=≠<=*b**j*.","Print ""Yes"" (without quotes), if there is at least one intersection of two distinct lines, located strictly inside the strip. Otherwise print ""No"" (without quotes).","['4\n1 2\n1 2\n1 0\n0 1\n0 2\n', '2\n1 3\n1 0\n-1 3\n', '2\n1 3\n1 0\n0 2\n', '2\n1 3\n1 0\n0 3\n']","['NO', 'YES', 'YES', 'NO']","In the first sample there are intersections located on the border of the strip, but there are no intersections located strictly inside it.",TIME_LIMIT_EXCEEDED,"import sys
def log(*args,**kwargs):
    kwargs[""file""] = kwargs.get(""file"",sys.stderr)
    print(*args,**kwargs)

n = int(input())
x1,x2 = map(int,input().strip().split())

y1s = []
y2s = []

for i in range(n):
    m,c = map(int,input().strip().split())
    y1s.append(m*x1+c)
    y2s.append(m*x2+c)

hmm = sorted(range(n),key=lambda x: y1s[x])

for i,j in zip(hmm,hmm[1:]):
    if y1s[i] != y1s[j] and y2s[i] > y2s[j]:
        print(""YES"")
        exit()
print(""NO"")","def can_intersect_lines(n, x1, x2, lines):

    lines.sort()

    prev_k, prev_b = lines[0]

    for i in range(1, n):
        k_i, b_i = lines[i]
        
        if prev_k != k_i:

            x_intersection = (b_i - prev_b) / (prev_k - k_i)

            if x1 < x_intersection < x2:
                return ""Yes""

        prev_k, prev_b = k_i, b_i

    return ""No""

n = int(input().strip())
x1, x2 = map(int, input().strip().split())
lines = [tuple(map(int, input().strip().split())) for _ in range(n)]

print(can_intersect_lines(n, x1, x2, lines))"
0,none,none,none,['none'],"Two participants are each given a pair of distinct numbers from 1 to 9 such that there's exactly one number that is present in both pairs. They want to figure out the number that matches by using a communication channel you have access to without revealing it to you.

Both participants communicated to each other a set of pairs of numbers, that includes the pair given to them. Each pair in the communicated sets comprises two different numbers.

Determine if you can with certainty deduce the common number, or if you can determine with certainty that both participants know the number but you do not.","The first line contains two integers $n$ and $m$ ($1 \le n, m \le 12$) — the number of pairs the first participant communicated to the second and vice versa.

The second line contains $n$ pairs of integers, each between $1$ and $9$, — pairs of numbers communicated from first participant to the second.

The third line contains $m$ pairs of integers, each between $1$ and $9$, — pairs of numbers communicated from the second participant to the first.

All pairs within each set are distinct (in particular, if there is a pair $(1,2)$, there will be no pair $(2,1)$ within the same set), and no pair contains the same number twice.

It is guaranteed that the two sets do not contradict the statements, in other words, there is pair from the first set and a pair from the second set that share exactly one number.","If you can deduce the shared number with certainty, print that number.

If you can with certainty deduce that both participants know the shared number, but you do not know it, print $0$.

Otherwise print $-1$.","['2 2\n1 2 3 4\n1 5 3 4\n', '2 2\n1 2 3 4\n1 5 6 4\n', '2 3\n1 2 4 5\n1 2 1 3 2 3\n']","['1\n', '0\n', '-1\n']","In the first example the first participant communicated pairs $(1,2)$ and $(3,4)$, and the second communicated $(1,5)$, $(3,4)$. Since we know that the actual pairs they received share exactly one number, it can't be that they both have $(3,4)$. Thus, the first participant has $(1,2)$ and the second has $(1,5)$, and at this point you already know the shared number is $1$.

In the second example either the first participant has $(1,2)$ and the second has $(1,5)$, or the first has $(3,4)$ and the second has $(6,4)$. In the first case both of them know the shared number is $1$, in the second case both of them know the shared number is $4$. You don't have enough information to tell $1$ and $4$ apart.

In the third case if the first participant was given $(1,2)$, they don't know what the shared number is, since from their perspective the second participant might have been given either $(1,3)$, in which case the shared number is $1$, or $(2,3)$, in which case the shared number is $2$. While the second participant does know the number with certainty, neither you nor the first participant do, so the output is $-1$.",WRONG_ANSWER,"n , m = map(int,input().split())
l = [int(x) for x in input().split()]
k = [int(x) for x in input().split()]
o = 0
d = []
def divide_chunks(l, n):
    for i in range(0, len(l), n): 
        yield l[i:i + n]
x = list(divide_chunks(l, 2))
y = list(divide_chunks(k, 2))
for i in x:
    if i in y:
        x.remove(i)
        y.remove(i)
o = ( ', '.join(str(u) for u in x))
p = (', '.join(str(u) for u in y))
if  o!=p:
    for i in o:
        if i in p and i!='[' and i!=']' and i!=',' and i!=' ':
            d.append(i)
if len(d)>=2:
    print('0')
elif len(o)!=len(p):
    print('-1')
elif len(d)==1:
    print(' '.join(d))","def find_shared_number(n, m, pairs_a, pairs_b):
    possible_shared_numbers = set()
    known_by_first = set()
    known_by_second = set()

    for a1, a2 in pairs_a:
        for b1, b2 in pairs_b:

            shared = {a1, a2}.intersection({b1, b2})
            if len(shared) == 1:

                possible_shared_numbers.update(shared)
                known_by_first.add((a1, a2, b1, b2))

    if len(possible_shared_numbers) == 1:
        return possible_shared_numbers.pop()

    for a1, a2 in pairs_a:
        number_known_by_first = {b1 if b1 in {a1, a2} else b2 for b1, b2 in pairs_b}
        if len(number_known_by_first) == 1:

            known_by_first.add(next(iter(number_known_by_first)))

    for b1, b2 in pairs_b:
        number_known_by_second = {a1 if a1 in {b1, b2} else a2 for a1, a2 in pairs_a}
        if len(number_known_by_second) == 1:

            known_by_second.add(next(iter(number_known_by_second)))

    if known_by_first == known_by_second:
        return 0
    else:
        return -1

if __name__ == ""__main__"":
    import sys
    input_data = sys.stdin.read().strip().split('\n')
    
    for i in range(0, len(input_data), 3):
        n, m = map(int, input_data[i].split())
        pairs_a = [tuple(map(int, input_data[i + 1].split()[j:j + 2])) for j in range(0, 2 * n, 2)]
        pairs_b = [tuple(map(int, input_data[i + 2].split()[j:j + 2])) for j in range(0, 2 * m, 2)]
        
        result = find_shared_number(n, m, pairs_a, pairs_b)
        print(result)"
182,B,Vasya's Calendar,PROGRAMMING,['implementation'],"Vasya lives in a strange world. The year has *n* months and the *i*-th month has *a**i* days. Vasya got a New Year present — the clock that shows not only the time, but also the date.

The clock's face can display any number from 1 to *d*. It is guaranteed that *a**i*<=≤<=*d* for all *i* from 1 to *n*. The clock does not keep information about the current month, so when a new day comes, it simply increases the current day number by one. The clock cannot display number *d*<=+<=1, so after day number *d* it shows day 1 (the current day counter resets). The mechanism of the clock allows you to increase the day number by one manually. When you execute this operation, day *d* is also followed by day 1.

Vasya begins each day checking the day number on the clock. If the day number on the clock does not match the actual day number in the current month, then Vasya manually increases it by one. Vasya is persistent and repeats this operation until the day number on the clock matches the actual number of the current day in the current month.

A year passed and Vasya wonders how many times he manually increased the day number by one, from the first day of the first month to the last day of the *n*-th month inclusive, considering that on the first day of the first month the clock display showed day 1.","The first line contains the single number *d* — the maximum number of the day that Vasya's clock can show (1<=≤<=*d*<=≤<=106).

The second line contains a single integer *n* — the number of months in the year (1<=≤<=*n*<=≤<=2000).

The third line contains *n* space-separated integers: *a**i* (1<=≤<=*a**i*<=≤<=*d*) — the number of days in each month in the order in which they follow, starting from the first one.",Print a single number — the number of times Vasya manually increased the day number by one throughout the last year.,"['4\n2\n2 2\n', '5\n3\n3 4 3\n', '31\n12\n31 28 31 30 31 30 31 31 30 31 30 31\n']","['2\n', '3\n', '7\n']","In the first sample the situation is like this: 
 -  Day 1. Month 1. The clock shows 1. Vasya changes nothing. -  Day 2. Month 1. The clock shows 2. Vasya changes nothing. -  Day 1. Month 2. The clock shows 3. Vasya manually increases the day number by 1. After that the clock shows 4. Vasya increases the day number by 1 manually. After that the clock shows 1. -  Day 2. Month 2. The clock shows 2. Vasya changes nothing.",OK,"def solve() :
    c=0
    for i in arr[:-1]:
        c+= d - i
    return c

d=int(input())
n=int(input())
arr=[int(x) for x in input().split()]
print(solve())

'''

t=int(input())
for i in range(t) :
    print(solve())

n,m= [int(x) for x in input().split()]

n=int(input())
arr=[]
for i in range(n):
    arr.append([int(x) for x in input().split()])

n=int(input())
arr=[int(x) for x in input().split()]
'''","d = int(input().strip())

n = int(input().strip())

a = list(map(int, input().strip().split()))

current_clock_day = 1
manual_changes = 0

for month_days in a:
    for day in range(1, month_days + 1):

        while current_clock_day != day:
            manual_changes += 1
            current_clock_day += 1
            if current_clock_day > d:
                current_clock_day = 1

        current_clock_day += 1
        if current_clock_day > d:
            current_clock_day = 1

print(manual_changes)"
197,B,Limit,PROGRAMMING,['math'],"You are given two polynomials:
 -  *P*(*x*)<==<=*a*0·*x**n*<=+<=*a*1·*x**n*<=-<=1<=+<=...<=+<=*a**n*<=-<=1·*x*<=+<=*a**n* and -  *Q*(*x*)<==<=*b*0·*x**m*<=+<=*b*1·*x**m*<=-<=1<=+<=...<=+<=*b**m*<=-<=1·*x*<=+<=*b**m*. 
Calculate limit .","The first line contains two space-separated integers *n* and *m* (0<=≤<=*n*,<=*m*<=≤<=100) — degrees of polynomials *P*(*x*) and *Q*(*x*) correspondingly.

The second line contains *n*<=+<=1 space-separated integers — the factors of polynomial *P*(*x*): *a*0, *a*1, ..., *a**n*<=-<=1, *a**n* (<=-<=100<=≤<=*a**i*<=≤<=100,<=*a*0<=≠<=0).

The third line contains *m*<=+<=1 space-separated integers — the factors of polynomial *Q*(*x*): *b*0, *b*1, ..., *b**m*<=-<=1, *b**m* (<=-<=100<=≤<=*b**i*<=≤<=100,<=*b*0<=≠<=0).","If the limit equals <=+<=∞, print ""Infinity"" (without quotes). If the limit equals <=-<=∞, print ""-Infinity"" (without the quotes).

If the value of the limit equals zero, print ""0/1"" (without the quotes).

Otherwise, print an irreducible fraction — the value of limit , in the format ""p/q"" (without the quotes), where *p* is the — numerator, *q* (*q*<=&gt;<=0) is the denominator of the fraction.","['2 1\n1 1 1\n2 5\n', '1 0\n-1 3\n2\n', '0 1\n1\n1 0\n', '2 2\n2 1 6\n4 5 -7\n', '1 1\n9 0\n-5 2\n']","['Infinity\n', '-Infinity\n', '0/1\n', '1/2\n', '-9/5\n']","Let's consider all samples:
 1.  <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/c28febca257452afdfcbd6984ba8623911f9bdbc.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> 1.  <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/1e55ecd04e54a45e5e0092ec9a5c1ea03bb29255.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> 1.  <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/2c95fb684d373fcc1a481cfabeda4d5c2f3673ee.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> 1.  <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/4dc40cb8b3cd6375c42445366e50369649a2801a.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> 1.  <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/c6455aba35cfb3c4397505121d1f77afcd17c98e.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> 
You can learn more about the definition and properties of limits if you follow the link: http://en.wikipedia.org/wiki/Limit_of_a_function",RUNTIME_ERROR,"import sys
import math
from sys import stdin, stdout

def get_ints_in_variables():
    return map(int, sys.stdin.readline().strip().split())
def get_int(): return int(input())
def get_ints_in_list(): return list(
    map(int, sys.stdin.readline().strip().split()))
def get_list_of_list(n): return [list(
    map(int, sys.stdin.readline().strip().split())) for _ in range(n)]
def get_string(): return sys.stdin.readline().strip()
 
def main():

    n, m = get_ints_in_variables()
    px = get_ints_in_list()
    qx = get_ints_in_list()

    if n > m:
        if (qx[0] > 0 and px[0] > 0) or (qx[0] < 0 and px < 0):
            print(""Infinity"")
        else:
            print(""-Infinity"")
    elif m > n:
        print(""0/1"")
    else:
        tmp = math.gcd(px[0], qx[0])
        px[0] //= tmp
        qx[0] //= tmp
        if (qx[0] > 0 and px[0] > 0) or (qx[0] < 0 and px[0] < 0):
            res = """"
            res += str(px[0])
            res += ""/""
            res += str(qx[0])
            print(res)
        else:
            res = ""-""
            res += str(abs(px[0]))
            res += ""/""
            res += str(abs(qx[0]))
            print(res)

if __name__ == ""__main__"":
    main()","from fractions import Fraction
import sys

def polynomial_limit(n, m, a, b):

    leading_a = a[0]
    leading_b = b[0]
    
    if n > m:

        return ""Infinity""
    elif n < m:

        return ""0/1""
    else:

        if leading_a > leading_b:
            return ""Infinity""
        elif leading_a < leading_b:
            return ""-Infinity""
        else:

            limit_value = Fraction(leading_a, leading_b)
            return f""{limit_value.numerator}/{limit_value.denominator}""

if __name__ == ""__main__"":
    input_data = sys.stdin.read().strip().split('\n')
    
    n, m = map(int, input_data[0].split())
    a = list(map(int, input_data[1].split()))
    b = list(map(int, input_data[2].split()))
    
    result = polynomial_limit(n, m, a, b)
    print(result)"
772,B,Volatile Kite,PROGRAMMING,['geometry'],"You are given a convex polygon *P* with *n* distinct vertices *p*1,<=*p*2,<=...,<=*p**n*. Vertex *p**i* has coordinates (*x**i*,<=*y**i*) in the 2D plane. These vertices are listed in clockwise order.

You can choose a real number *D* and move each vertex of the polygon a distance of at most *D* from their original positions.

Find the maximum value of *D* such that no matter how you move the vertices, the polygon does not intersect itself and stays convex.","The first line has one integer *n* (4<=≤<=*n*<=≤<=1<=000) — the number of vertices.

The next *n* lines contain the coordinates of the vertices. Line *i* contains two integers *x**i* and *y**i* (<=-<=109<=≤<=*x**i*,<=*y**i*<=≤<=109) — the coordinates of the *i*-th vertex. These points are guaranteed to be given in clockwise order, and will form a strictly convex polygon (in particular, no three consecutive points lie on the same straight line).","Print one real number *D*, which is the maximum real number such that no matter how you move the vertices, the polygon stays convex.

Your answer will be considered correct if its absolute or relative error does not exceed 10<=-<=6.

Namely, let's assume that your answer is *a* and the answer of the jury is *b*. The checker program will consider your answer correct if .","['4\n0 0\n0 1\n1 1\n1 0\n', '6\n5 0\n10 0\n12 -4\n10 -8\n5 -8\n3 -4\n']","['0.3535533906\n', '1.0000000000\n']","Here is a picture of the first sample

<img class=""tex-graphics"" src=""https://espresso.codeforces.com/f83aa076d2f437f9bb785cae769c3ae310eff351.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

Here is an example of making the polygon non-convex.

<img class=""tex-graphics"" src=""https://espresso.codeforces.com/fbadb81630251ca642bd4ddf9088876ade761630.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

This is not an optimal solution, since the maximum distance we moved one point is  ≈ 0.4242640687, whereas we can make it non-convex by only moving each point a distance of at most  ≈ 0.3535533906.",WRONG_ANSWER,"import math
from decimal import Decimal
n = int(input())
d = [[0,0] for i in range(n)]
for i in range(n):
    d[i] = list(map(int,input().split()))
def cnt(m):
    l = m - 1;
    if (l < 0): l = n - 1;
    r = (m + 1) % n
    a = math.sqrt((d[l][0] - d[m][0])**2 + (d[l][1] - d[m][1]) ** 2)
    b = math.sqrt((d[m][0] - d[r][0]) ** 2 + (d[m][1] - d[r][1]) ** 2)
    c = math.sqrt((d[l][0] - d[r][0]) ** 2 + (d[l][1] - d[r][1]) ** 2)
    p = (a + b + c) / 2
    s = math.sqrt(p * (p - a) * (p - b) * (p - c))
    return s / c

ans = cnt(0)
for i in range(1,n):
    ans = min(ans, cnt(i))
print(ans)","import math

def max_distance_to_keep_convex(n, vertices):

    def distance_point_to_segment(px, py, ax, ay, bx, by):
        abx = bx - ax
        aby = by - ay
        apx = px - ax
        apy = py - ay
        bpx = px - bx
        bpy = py - by

        ab_sq = abx * abx + aby * aby
        if ab_sq == 0:
            return math.hypot(apx, apy)

        t = (apx * abx + apy * aby) / ab_sq

        if t < 0.0:

            return math.hypot(apx, apy)
        elif t > 1.0:

            return math.hypot(bpx, bpy)

        projection_x = ax + t * abx
        projection_y = ay + t * aby
        return math.hypot(px - projection_x, py - projection_y)

    min_distance = float('inf')

    for i in range(n):
        ax, ay = vertices[i]
        bx, by = vertices[(i + 1) % n]
        opposite_distances = []

        for j in range(n):
            if j != i and j != (i + 1) % n:
                px, py = vertices[j]
                distance = distance_point_to_segment(px, py, ax, ay, bx, by)
                opposite_distances.append(distance)

        if opposite_distances:
            min_distance = min(min_distance, min(opposite_distances))

    return min_distance / math.sqrt(2)

input_data = input().strip().splitlines()
n = int(input_data[0])
vertices = [tuple(map(int, line.split())) for line in input_data[1:n + 1]]

result = max_distance_to_keep_convex(n, vertices)
print(f""{result:.10f}"")"
80,A,Panoramix's Prediction,PROGRAMMING,['brute force'],"A prime number is a number which has exactly two distinct divisors: one and itself. For example, numbers 2, 7, 3 are prime, and 1, 6, 4 are not.

The next prime number after *x* is the smallest prime number greater than *x*. For example, the next prime number after 2 is 3, and the next prime number after 3 is 5. Note that there is exactly one next prime number after each number. So 5 is not the next prime number for 2.

One cold April morning Panoramix predicted that soon Kakofonix will break free from his straitjacket, and this will be a black day for the residents of the Gallic countryside.

Panoramix's prophecy tells that if some day Asterix and Obelix beat exactly *x* Roman soldiers, where *x* is a prime number, and next day they beat exactly *y* Roman soldiers, where *y* is the next prime number after *x*, then it's time to wait for Armageddon, for nothing can shut Kakofonix up while he sings his infernal song.

Yesterday the Gauls beat *n* Roman soldiers and it turned out that the number *n* was prime! Today their victims were a troop of *m* Romans (*m*<=&gt;<=*n*). Determine whether the Gauls should wait for the black day after today's victory of Asterix and Obelix?","The first and only input line contains two positive integers — *n* and *m* (2<=≤<=*n*<=&lt;<=*m*<=≤<=50). It is guaranteed that *n* is prime.

Pretests contain all the cases with restrictions 2<=≤<=*n*<=&lt;<=*m*<=≤<=4.","Print YES, if *m* is the next prime number after *n*, or NO otherwise.","['3 5\n', '7 11\n', '7 9\n']","['YES', 'YES', 'NO']",none,OK,"a,b = map(int,input().split("" ""))
status = True

def isPrime(num):
    i =2 
    while i <=num//2:
        if num%i ==0:
            return False
        i+=1  
    return True

i =a 
while i <=b:
    if not isPrime(i) and (i ==a or i ==b):
        status = False
        break
    if isPrime(i) and i != a and i !=b:
        status = False
        break
        
    i+=1 
if status:
    print('YES')
else:
    print('NO')","def is_prime(num):
    """"""Check if a number is prime.""""""
    if num < 2:
        return False
    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            return False
    return True

def next_prime(num):
    """"""Find the next prime number after the given number.""""""
    candidate = num + 1
    while not is_prime(candidate):
        candidate += 1
    return candidate

input_data = input().strip()
n, m = map(int, input_data.split())

if m == next_prime(n):
    print(""YES"")
else:
    print(""NO"")"
622,B,The Time,PROGRAMMING,['implementation'],"You are given the current time in 24-hour format hh:mm. Find and print the time after *a* minutes.

Note that you should find only the time after *a* minutes, see the examples to clarify the problem statement.

You can read more about 24-hour format here [https://en.wikipedia.org/wiki/24-hour_clock](https://en.wikipedia.org/wiki/24-hour_clock).","The first line contains the current time in the format hh:mm (0<=≤<=*hh*<=&lt;<=24,<=0<=≤<=*mm*<=&lt;<=60). The hours and the minutes are given with two digits (the hours or the minutes less than 10 are given with the leading zeroes).

The second line contains integer *a* (0<=≤<=*a*<=≤<=104) — the number of the minutes passed.","The only line should contain the time after *a* minutes in the format described in the input. Note that you should print exactly two digits for the hours and the minutes (add leading zeroes to the numbers if needed).

See the examples to check the input/output format.","['23:59\n10\n', '20:20\n121\n', '10:10\n0\n']","['00:09\n', '22:21\n', '10:10\n']",none,OK,"""""""codeforces 622B

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fnRVrX6kGGXBPnaZduqeU_eo6w87jUi5
""""""

T=input() 
a=int(input())
h=int(T[ :-3])
m=int(T[-2: ])

x=a//60
y=a%60 

hour=h+x
min=m+y

if min>=60:
   min=min-60
   hour=hour+1

z=hour//24 

if hour>=24:
   hour=hour-(24*z)  

if len(str(hour))==2 and len(str(min))==1:
  print(f""{hour}:0{min}"")
elif len(str(hour))==1 and len(str(min))==2:
  print(f""0{hour}:{min}"")
elif len(str(hour))==1 and len(str(min))==1:
  print(f""0{hour}:0{min}"")
     
else:  
  print(f""{hour}:{min}"")","def calculate_future_time(current_time, minutes_to_add):

    hours, minutes = map(int, current_time.split(':'))

    total_minutes = hours * 60 + minutes + minutes_to_add

    new_hours = (total_minutes // 60) % 24
    new_minutes = total_minutes % 60

    return f""{new_hours:02}:{new_minutes:02}""

current_time = input().strip()
minutes_to_add = int(input().strip())

print(calculate_future_time(current_time, minutes_to_add))"
26,A,Almost Prime,PROGRAMMING,['number theory'],"A number is called almost prime if it has exactly two distinct prime divisors. For example, numbers 6, 18, 24 are almost prime, while 4, 8, 9, 42 are not. Find the amount of almost prime numbers which are between 1 and *n*, inclusive.",Input contains one integer number *n* (1<=≤<=*n*<=≤<=3000).,"Output the amount of almost prime numbers between 1 and *n*, inclusive.","['10\n', '21\n']","['2\n', '8\n']",none,OK,"def prime(n):
    factor = set()
    d = 2
    
    while d * d <= n:
        while n % d == 0:
            factor.add(d)
            n //= d
        d += 1
    if n >1:
        factor.add(n)
    
    return factor

n = int(input())

count = 0

for i in range(2, n+1):
    ans = prime(i)
    if len(ans) == 2:
        count += 1

print(count)","def is_prime(num):
    """"""Check if a number is prime.""""""
    if num <= 1:
        return False
    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            return False
    return True

def count_distinct_prime_factors(num):
    """"""Count distinct prime factors of a number.""""""
    count = 0
    for i in range(2, num + 1):
        if num % i == 0 and is_prime(i):
            count += 1
        if count > 2:
            break
    return count

def count_almost_primes(n):
    """"""Count numbers with exactly two distinct prime divisors between 1 and n.""""""
    almost_prime_count = 0
    for i in range(1, n + 1):
        if count_distinct_prime_factors(i) == 2:
            almost_prime_count += 1
    return almost_prime_count

import sys
input_data = sys.stdin.read().splitlines()

results = []
for line in input_data:
    n = int(line)
    result = count_almost_primes(n)
    results.append(result)

for res in results:
    print(res)"
938,B,Run For Your Prize,PROGRAMMING,"['brute force', 'greedy']","You and your friend are participating in a TV show ""Run For Your Prize"".

At the start of the show *n* prizes are located on a straight line. *i*-th prize is located at position *a**i*. Positions of all prizes are distinct. You start at position 1, your friend — at position 106 (and there is no prize in any of these two positions). You have to work as a team and collect all prizes in minimum possible time, in any order.

You know that it takes exactly 1 second to move from position *x* to position *x*<=+<=1 or *x*<=-<=1, both for you and your friend. You also have trained enough to instantly pick up any prize, if its position is equal to your current position (and the same is true for your friend). Carrying prizes does not affect your speed (or your friend's speed) at all.

Now you may discuss your strategy with your friend and decide who will pick up each prize. Remember that every prize must be picked up, either by you or by your friend.

What is the minimum number of seconds it will take to pick up all the prizes?","The first line contains one integer *n* (1<=≤<=*n*<=≤<=105) — the number of prizes.

The second line contains *n* integers *a*1, *a*2, ..., *a**n* (2<=≤<=*a**i*<=≤<=106<=-<=1) — the positions of the prizes. No two prizes are located at the same position. Positions are given in ascending order.",Print one integer — the minimum number of seconds it will take to collect all prizes.,"['3\n2 3 9\n', '2\n2 999995\n']","['8\n', '5\n']","In the first example you take all the prizes: take the first at 1, the second at 2 and the third at 8.

In the second example you take the first prize in 1 second and your friend takes the other in 5 seconds, you do this simultaneously, so the total time is 5.",OK,"import sys,math,itertools
from collections import Counter,deque,defaultdict
from bisect import bisect_left,bisect_right 
from heapq import heappop,heappush,heapify, nlargest
from copy import deepcopy
mod = 10**9+7
INF = float('inf')
def inp(): return int(sys.stdin.readline())
def inpl(): return list(map(int, sys.stdin.readline().split()))
def inpl_1(): return list(map(lambda x:int(x)-1, sys.stdin.readline().split()))
def inps(): return sys.stdin.readline()
def inpsl(x): tmp = sys.stdin.readline(); return list(tmp[:x])
def err(x): print(x); exit()

n = inp()
a = [0] + inpl() + [10**6]
res = INF
for i in range(n+1):
    res = min(res, max(a[i]-1,10**6-a[i+1]))
print(res)","def min_time_to_collect_prizes(n, positions):

    you_position = 1
    friend_position = 106

    max_time = 0

    for prize in positions:

        time_you = abs(prize - you_position)

        time_friend = abs(prize - friend_position)

        max_time = max(max_time, min(time_you, time_friend))

    return max_time

n = int(input().strip())
positions = list(map(int, input().strip().split()))

print(min_time_to_collect_prizes(n, positions))"
590,C,Three States,PROGRAMMING,"['dfs and similar', 'graphs', 'shortest paths']","The famous global economic crisis is approaching rapidly, so the states of Berman, Berance and Bertaly formed an alliance and allowed the residents of all member states to freely pass through the territory of any of them. In addition, it was decided that a road between the states should be built to guarantee so that one could any point of any country can be reached from any point of any other State.

Since roads are always expensive, the governments of the states of the newly formed alliance asked you to help them assess the costs. To do this, you have been issued a map that can be represented as a rectangle table consisting of *n* rows and *m* columns. Any cell of the map either belongs to one of three states, or is an area where it is allowed to build a road, or is an area where the construction of the road is not allowed. A cell is called passable, if it belongs to one of the states, or the road was built in this cell. From any passable cells you can move up, down, right and left, if the cell that corresponds to the movement exists and is passable.

Your task is to construct a road inside a minimum number of cells, so that it would be possible to get from any cell of any state to any cell of any other state using only passable cells.

It is guaranteed that initially it is possible to reach any cell of any state from any cell of this state, moving only along its cells. It is also guaranteed that for any state there is at least one cell that belongs to it.","The first line of the input contains the dimensions of the map *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=1000) — the number of rows and columns respectively.

Each of the next *n* lines contain *m* characters, describing the rows of the map. Digits from 1 to 3 represent the accessory to the corresponding state. The character '.' corresponds to the cell where it is allowed to build a road and the character '#' means no construction is allowed in this cell.","Print a single integer — the minimum number of cells you need to build a road inside in order to connect all the cells of all states. If such a goal is unachievable, print -1.","['4 5\n11..2\n#..22\n#.323\n.#333', '1 5\n1#2#3\n']","['2', '-1\n']",none,WRONG_ANSWER,"from collections import deque

r, c = tuple(map(int, input().replace(""\n"","""").split()))

land_map = [[0]*c for _ in range(r)]
for i in range(r):
    line = input().rstrip(""\n"")
    for j in range(c):
        if line[j] == '.' or line[j] == '
            land_map[i][j] = line[j]
        else:
            land_map[i][j] = int(line[j])

direc = [-1, 0, 1, 0, -1]

def find_road():
    accessories = 0
    start = (0, 0)
    for i in range(r):
        for j in range(c):
            if land_map[i][j] != '.' and land_map[i][j] != '
                accessories += 1
                if land_map[start[0]][start[1]] == '.' or land_map[start[0]][start[1]] == '
                    start = (i, j)

    dq = deque()
    dq.append([0, start])
    vis = set()

    while dq:
        dis, points = dq.pop()
        if points in vis:
            continue
        if len(vis) == accessories:
            return dis
        vis.add(points)
        x, y = points

        for i in range(4):
            dr, dc = x + direc[i], y + direc[i + 1]
            if 0 <= dr < r and 0 <= dc < c:
                if land_map[dr][dc] == '.':
                    dq.appendleft([dis+1, (dr, dc)])
                elif land_map[dr][dc] != '
                    dq.append([dis, (dr, dc)])
    return -1

print(find_road())","from collections import deque

def bfs(start, n, m, map_grid, visited):
    queue = deque([start])
    component = []
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    
    while queue:
        x, y = queue.popleft()
        component.append((x, y))
        for dx, dy in directions:
            nx, ny = x + dx, y + dy
            if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and map_grid[nx][ny] in '123.':
                visited[nx][ny] = True
                queue.append((nx, ny))
    
    return component

def find_components(n, m, map_grid):
    visited = [[False] * m for _ in range(n)]
    components = []
    
    for i in range(n):
        for j in range(m):
            if not visited[i][j] and map_grid[i][j] in '123':
                visited[i][j] = True
                components.append(bfs((i, j), n, m, map_grid, visited))
    
    return components

def min_road_to_connect_components(n, m, map_grid):
    components = find_components(n, m, map_grid)
    k = len(components)
    if k == 0 or k == 1:
        return 0

    reachable = set()
    for component in components:
        for (x, y) in component:
            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                nx, ny = x + dx, y + dy
                if 0 <= nx < n and 0 <= ny < m and map_grid[nx][ny] == '.':
                    reachable.add((nx, ny))

    if not reachable:
        return -1

    from itertools import combinations
    edges = []
    for i, comp1 in enumerate(components):
        for j, comp2 in enumerate(components):
            if i < j:
                for x1, y1 in comp1:
                    for x2, y2 in comp2:
                        if abs(x1 - x2) + abs(y1 - y2) == 1:
                            edges.append((i, j, 1))

    parent = list(range(k))
    rank = [0] * k

    def find(u):
        if parent[u] != u:
            parent[u] = find(parent[u])
        return parent[u]

    def union(u, v):
        rootU = find(u)
        rootV = find(v)
        if rootU != rootV:
            if rank[rootU] > rank[rootV]:
                parent[rootV] = rootU
            elif rank[rootU] < rank[rootV]:
                parent[rootU] = rootV
            else:
                parent[rootV] = rootU
                rank[rootU] += 1
            return True
        return False

    edges.sort(key=lambda x: x[2])
    total_cost = 0
    edges_used = 0

    for u, v, cost in edges:
        if union(u, v):
            total_cost += cost
            edges_used += 1

    if edges_used == k - 1:
        return total_cost
    return -1

def main():
    import sys
    input = sys.stdin.read
    data = input().splitlines()
    
    n, m = map(int, data[0].split())
    map_grid = data[1:n + 1]
    
    result = min_road_to_connect_components(n, m, map_grid)
    print(result)

if __name__ == ""__main__"":
    main()"
591,B,Rebranding,PROGRAMMING,"['implementation', 'strings']","The name of one small but proud corporation consists of *n* lowercase English letters. The Corporation has decided to try rebranding — an active marketing strategy, that includes a set of measures to change either the brand (both for the company and the goods it produces) or its components: the name, the logo, the slogan. They decided to start with the name.

For this purpose the corporation has consecutively hired *m* designers. Once a company hires the *i*-th designer, he immediately contributes to the creation of a new corporation name as follows: he takes the newest version of the name and replaces all the letters *x**i* by *y**i*, and all the letters *y**i* by *x**i*. This results in the new version. It is possible that some of these letters do no occur in the string. It may also happen that *x**i* coincides with *y**i*. The version of the name received after the work of the last designer becomes the new name of the corporation.

Manager Arkady has recently got a job in this company, but is already soaked in the spirit of teamwork and is very worried about the success of the rebranding. Naturally, he can't wait to find out what is the new name the Corporation will receive.

Satisfy Arkady's curiosity and tell him the final version of the name.","The first line of the input contains two integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=200<=000) — the length of the initial name and the number of designers hired, respectively.

The second line consists of *n* lowercase English letters and represents the original name of the corporation.

Next *m* lines contain the descriptions of the designers' actions: the *i*-th of them contains two space-separated lowercase English letters *x**i* and *y**i*.",Print the new name of the corporation.,"['6 1\npolice\np m\n', '11 6\nabacabadaba\na b\nb c\na d\ne g\nf a\nb b\n']","['molice\n', 'cdcbcdcfcdc\n']","In the second sample the name of the corporation consecutively changes as follows:

<img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/c7648432f7138ca53234357d7e08d1d119166055.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

<img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/de89ad7bc7f27c46ec34f5e66ce0dc23bd5bc90a.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

<img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/812e653c8d7ff496e6a0f04c676423806751531e.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

<img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/19c564fcefb8dde36256240a8b877bb6a4792bfe.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

<img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/e1cafd93792430ad1a49e893e04715383bdae757.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>",OK,"def solve():
    N, M = map(int, input().split())
    name = input()

    td = {}
    for c in 'abcdefghijklmnopqrstuvwxyz':
        td[c] = c

    for i in range(M):
        p, m = input().split()
        if p == m:
            continue
        pt = td[p]
        mt = td[m]
        del td[p]
        del td[m]
        td[m] = pt
        td[p] = mt

    nd = {f: t for t, f in td.items()}

    ans = ''.join([nd[c] for c in name])

    print(ans)

if __name__ == '__main__':
    solve()","def rebrand_corporation(n, m, original_name, transformations):
    name = list(original_name)

    for x, y in transformations:

        for i in range(len(name)):
            if name[i] == x:
                name[i] = '
            elif name[i] == y:
                name[i] = x

        for i in range(len(name)):
            if name[i] == '
                name[i] = y

    return ''.join(name)

import sys
input = sys.stdin.read
data = input().splitlines()

n, m = map(int, data[0].split())

original_name = data[1]

transformations = [tuple(line.split()) for line in data[2:m + 2]]

new_name = rebrand_corporation(n, m, original_name, transformations)

print(new_name)"
577,A,Multiplication Table,PROGRAMMING,"['implementation', 'number theory']","Let's consider a table consisting of *n* rows and *n* columns. The cell located at the intersection of *i*-th row and *j*-th column contains number *i*<=×<=*j*. The rows and columns are numbered starting from 1.

You are given a positive integer *x*. Your task is to count the number of cells in a table that contain number *x*.","The single line contains numbers *n* and *x* (1<=≤<=*n*<=≤<=105, 1<=≤<=*x*<=≤<=109) — the size of the table and the number that we are looking for in the table.",Print a single number: the number of times *x* occurs in the table.,"['10 5\n', '6 12\n', '5 13\n']","['2\n', '4\n', '0\n']",A table for the second sample test is given below. The occurrences of number 12 are marked bold.,TIME_LIMIT_EXCEEDED,"""""""https://codeforces.com/problemset/problem/577/A""""""
rows, num = [int(x) for x in input().split()]
times = 0

for row in range(rows):
    for column in range(rows):
        if (row + 1) * (column + 1) == num:
            times += 1

print(times)","def count_cells(n, x):

    min_row = x

    max_row = n - x + 1

    if min_row > n or max_row < 1:
        return 0

    min_row = max(min_row, 1)
    max_row = min(max_row, n)

    return max_row - min_row + 1

if __name__ == ""__main__"":
    import sys
    input_data = sys.stdin.read().strip().split('\n')
    
    results = []
    for line in input_data:
        n, x = map(int, line.split())
        result = count_cells(n, x)
        results.append(str(result))

    print('\n'.join(results))"
522,A,Reposts,PROGRAMMING,"['*special', 'dfs and similar', 'dp', 'graphs', 'trees']","One day Polycarp published a funny picture in a social network making a poll about the color of his handle. Many of his friends started reposting Polycarp's joke to their news feed. Some of them reposted the reposts and so on.

These events are given as a sequence of strings ""name1 reposted name2"", where name1 is the name of the person who reposted the joke, and name2 is the name of the person from whose news feed the joke was reposted. It is guaranteed that for each string ""name1 reposted name2"" user ""name1"" didn't have the joke in his feed yet, and ""name2"" already had it in his feed by the moment of repost. Polycarp was registered as ""Polycarp"" and initially the joke was only in his feed.

Polycarp measures the popularity of the joke as the length of the largest repost chain. Print the popularity of Polycarp's joke.","The first line of the input contains integer *n* (1<=≤<=*n*<=≤<=200) — the number of reposts. Next follow the reposts in the order they were made. Each of them is written on a single line and looks as ""name1 reposted name2"". All the names in the input consist of lowercase or uppercase English letters and/or digits and have lengths from 2 to 24 characters, inclusive.

We know that the user names are case-insensitive, that is, two names that only differ in the letter case correspond to the same social network user.",Print a single integer — the maximum length of a repost chain.,"['5\ntourist reposted Polycarp\nPetr reposted Tourist\nWJMZBMR reposted Petr\nsdya reposted wjmzbmr\nvepifanov reposted sdya\n', '6\nMike reposted Polycarp\nMax reposted Polycarp\nEveryOne reposted Polycarp\n111 reposted Polycarp\nVkCup reposted Polycarp\nCodeforces reposted Polycarp\n', '1\nSoMeStRaNgEgUe reposted PoLyCaRp\n']","['6\n', '2\n', '2\n']",none,OK,"import sys
input = sys.stdin.readline
from collections import defaultdict

n = int(input())
g = [input()[:-1].lower().split(' reposted ') for _ in range(n)]
d = defaultdict(int)
d['polycarp'] = 1
for i in range(n):
    d[g[i][0]] += d[g[i][1]] + 1
print(max(d.values()))","def max_repost_chain(n, reposts):

    repost_depth = {}
    repost_depth['Polycarp'] = 1

    for repost in reposts:
        name1, _, name2 = repost.partition(' reposted ')
        name1 = name1.lower()
        name2 = name2.lower()

        repost_depth[name1] = repost_depth.get(name2, 0) + 1

    return max(repost_depth.values())

if __name__ == ""__main__"":
    import sys
    
    input_data = sys.stdin.read().strip().splitlines()
    n = int(input_data[0])
    reposts = input_data[1:n + 1]

    result = max_repost_chain(n, reposts)
    print(result)"
267,A,Subtractions,PROGRAMMING,"['math', 'number theory']","You've got two numbers. As long as they are both larger than zero, they go through the same operation: subtract the lesser number from the larger one. If they equal substract one number from the another. For example, one operation transforms pair (4,17) to pair (4,13), it transforms (5,5) to (0,5).

You've got some number of pairs (*a**i*,<=*b**i*). How many operations will be performed for each of them?","The first line contains the number of pairs *n* (1<=<=≤<=<=*n*<=<=≤<=<=1000). Then follow *n* lines, each line contains a pair of positive integers *a**i*,<=*b**i* (1<=<=≤<=<=*a**i*,<=<=*b**i*<=<=≤<=<=109).",Print the sought number of operations for each pair on a single line.,['2\n4 17\n7 987654321\n'],['8\n141093479\n'],none,OK,"n = int(input())

def compute(a, b):
    iters = 0
    while a > 0 and b > 0:
        if a > b:
            iters += a // b
            a %= b
        else:
            iters += b // a
            b %= a
    return iters

for _ in range(n):
    a, b = tuple(map(int, input().split()))
    print(compute(a, b))","def count_operations(a, b):
    operations = 0
    while a > 0 and b > 0:
        if a < b:
            b -= a
        else:
            a -= b
        operations += 1
    return operations

n = int(input().strip())
results = []

for _ in range(n):
    a, b = map(int, input().strip().split())
    results.append(count_operations(a, b))

for result in results:
    print(result)"
507,A,Amr and Music,PROGRAMMING,"['greedy', 'implementation', 'sortings']","Amr is a young coder who likes music a lot. He always wanted to learn how to play music but he was busy coding so he got an idea.

Amr has *n* instruments, it takes *a**i* days to learn *i*-th instrument. Being busy, Amr dedicated *k* days to learn how to play the maximum possible number of instruments.

Amr asked for your help to distribute his free days between instruments so that he can achieve his goal.","The first line contains two numbers *n*, *k* (1<=≤<=*n*<=≤<=100, 0<=≤<=*k*<=≤<=10<=000), the number of instruments and number of days respectively.

The second line contains *n* integers *a**i* (1<=≤<=*a**i*<=≤<=100), representing number of days required to learn the *i*-th instrument.","In the first line output one integer *m* representing the maximum number of instruments Amr can learn.

In the second line output *m* space-separated integers: the indices of instruments to be learnt. You may output indices in any order.

if there are multiple optimal solutions output any. It is not necessary to use all days for studying.","['4 10\n4 3 1 2\n', '5 6\n4 3 1 1 2\n', '1 3\n4\n']","['4\n1 2 3 4', '3\n1 3 4', '0\n']","In the first test Amr can learn all 4 instruments.

In the second test other possible solutions are: {2, 3, 5} or {3, 4, 5}.

In the third test Amr doesn't have enough time to learn the only presented instrument.",WRONG_ANSWER,"from collections import defaultdict
n, k = map(int,input().split())
arr = list(map(int,input().split()))
index = defaultdict(list)
for i,n in enumerate(arr):
    index[n].append(i)

ans = []

for n in sorted(set(arr)):
    i = 0
    while k-n>=0 and i<len(index[n]):
        k-=n
        ans.append(str(index[n][i]+1))
        i += 1
        
print(len(arr))
print("" "".join(ans))","def learn_instruments(n, k, days):

    sorted_days = sorted((days[i], i + 1) for i in range(n))
    
    total_days = 0
    instruments_learned = []

    for days_needed, index in sorted_days:
        if total_days + days_needed <= k:
            total_days += days_needed
            instruments_learned.append(index)
        else:
            break

    print(len(instruments_learned))
    print("" "".join(map(str, instruments_learned)))

inputs = [
    (4, 10, [4, 3, 1, 2]),
    (5, 6, [4, 3, 1, 1, 2]),
    (1, 3, [4])
]

for n, k, days in inputs:
    learn_instruments(n, k, days)"
678,A,Johny Likes Numbers,PROGRAMMING,"['implementation', 'math']","Johny likes numbers *n* and *k* very much. Now Johny wants to find the smallest integer *x* greater than *n*, so it is divisible by the number *k*.","The only line contains two integers *n* and *k* (1<=≤<=*n*,<=*k*<=≤<=109).","Print the smallest integer *x*<=&gt;<=*n*, so it is divisible by the number *k*.","['5 3\n', '25 13\n', '26 13\n']","['6\n', '26\n', '39\n']",none,OK,"def solve():
    n, k = [int(x) for x in input().split()]

    print((n + k) - (n % k))

solve()","def smallest_divisible(n, k):

    x = (n // k + 1) * k
    return x

input_values = input().strip().split()
n, k = map(int, input_values)

result = smallest_divisible(n, k)

print(result)"
839,C,Journey,PROGRAMMING,"['dfs and similar', 'dp', 'graphs', 'probabilities', 'trees']","There are *n* cities and *n*<=-<=1 roads in the Seven Kingdoms, each road connects two cities and we can reach any city from any other by the roads.

Theon and Yara Greyjoy are on a horse in the first city, they are starting traveling through the roads. But the weather is foggy, so they can’t see where the horse brings them. When the horse reaches a city (including the first one), it goes to one of the cities connected to the current city. But it is a strange horse, it only goes to cities in which they weren't before. In each such city, the horse goes with equal probabilities and it stops when there are no such cities. 

Let the length of each road be 1. The journey starts in the city 1. What is the expected length (expected value of length) of their journey? You can read about expected (average) value by the link [https://en.wikipedia.org/wiki/Expected_value](https://en.wikipedia.org/wiki/Expected_value).","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=100000) — number of cities.

Then *n*<=-<=1 lines follow. The *i*-th line of these lines contains two integers *u**i* and *v**i* (1<=≤<=*u**i*,<=*v**i*<=≤<=*n*, *u**i*<=≠<=*v**i*) — the cities connected by the *i*-th road.

It is guaranteed that one can reach any city from any other by the roads.","Print a number — the expected length of their journey. The journey starts in the city 1.

Your answer will be considered correct if its absolute or relative error does not exceed 10<=-<=6.

Namely: let's assume that your answer is *a*, and the answer of the jury is *b*. The checker program will consider your answer correct, if .","['4\n1 2\n1 3\n2 4\n', '5\n1 2\n1 3\n3 4\n2 5\n']","['1.500000000000000\n', '2.000000000000000\n']","In the first sample, their journey may end in cities 3 or 4 with equal probability. The distance to city 3 is 1 and to city 4 is 2, so the expected length is 1.5.

In the second sample, their journey may end in city 4 or 5. The distance to the both cities is 2, so the expected length is 2.",RUNTIME_ERROR,"def dfs(x,p):
    if x==1:
        l[x]=0
        prob[x]=1
    else:
        l[x]=l[p]+1
        prob[x]=1/(len(graph[p])-1)*prob[p]
        if p==1:
            prob[x]=1/(len(graph[p]))*prob[p]
    for k in graph[x]:
        if k!=p:
            dfs(k,x)
    if len(graph[x])==1 and x!=1:
        leaf.append(x)
    

n = int(input())
graph = [[]]

for i in range(n+1):
    graph.append([])

for i in range(n-1):
    x,y=list(map(int,input().split(' ')))
    graph[x].append(y)
    graph[y].append(x)
l=[0 for i in range(n+1)]
prob=[0 for i in range(n+1)]
ans=0;
leaf =[]
dfs(1,0)
for i in leaf:
    ans+=prob[i]*l[i]
if n==1:
    print(1)
else:
    print(ans)","from collections import defaultdict
import sys

def expected_length(n, roads):

    graph = defaultdict(list)
    for u, v in roads:
        graph[u].append(v)
        graph[v].append(u)

    expected_lengths = [0] * (n + 1)
    visited = [False] * (n + 1)

    def dfs(city):
        visited[city] = True
        neighbors = [neighbor for neighbor in graph[city] if not visited[neighbor]]
        total_length = 0
        count = len(neighbors)

        for neighbor in neighbors:
            total_length += 1 + dfs(neighbor)

        if count > 0:
            expected_lengths[city] = total_length / count
        return expected_lengths[city]

    dfs(1)
    return expected_lengths[1]

n = int(sys.stdin.readline().strip())
roads = [tuple(map(int, sys.stdin.readline().strip().split())) for _ in range(n - 1)]

result = expected_length(n, roads)

print(f""{result:.12f}"")"
58,A,Chat room,PROGRAMMING,"['greedy', 'strings']","Vasya has recently learned to type and log on to the Internet. He immediately entered a chat room and decided to say hello to everybody. Vasya typed the word *s*. It is considered that Vasya managed to say hello if several letters can be deleted from the typed word so that it resulted in the word ""hello"". For example, if Vasya types the word ""ahhellllloou"", it will be considered that he said hello, and if he types ""hlelo"", it will be considered that Vasya got misunderstood and he didn't manage to say hello. Determine whether Vasya managed to say hello by the given word *s*.","The first and only line contains the word *s*, which Vasya typed. This word consisits of small Latin letters, its length is no less that 1 and no more than 100 letters.","If Vasya managed to say hello, print ""YES"", otherwise print ""NO"".","['ahhellllloou\n', 'hlelo\n']","['YES\n', 'NO\n']",none,RUNTIME_ERROR,"def main():
    char_in_hello = [char for char in 'hello']

    message = input()
    chars_to_remove = [char for char in message if char not in char_in_hello]
    final_word = message
    for char in chars_to_remove:
        final_word = final_word.replace(char, '')

    word_list = [char for char in final_word]

    for char in char_in_hello:
        num = 0
        if char in 'heo':
            num = 1
        elif char == 'l':
            num = 2
        while word_list.count(char) != num:
            if word_list.count(char) == 0:
                break
            if num == 1:
                first_instance_index = word_list.index('char')
                remove_index = word_list[first_instance_index+1:].index('char')
                word_list.remove(remove_index)
            elif num == 2:
                first_instance_index = word_list.index('char')
                second_instance = word_list[first_instance_index + 1:].index('char')
                remove_index = word_list[second_instance + 1:].index('char')
                word_list.remove(remove_index)

    if word_list == char_in_hello:
        print('YES')
    else:
        print('NO')

if __name__ == '__main__':
    main()","def can_say_hello(s):

    target = ""hello""
    j = 0

    for char in s:

        if char == target[j]:
            j += 1

        if j == len(target):
            return ""YES""

    return ""NO""

input_string = input().strip()

print(can_say_hello(input_string))"
651,B,Beautiful Paintings,PROGRAMMING,"['greedy', 'sortings']","There are *n* pictures delivered for the new exhibition. The *i*-th painting has beauty *a**i*. We know that a visitor becomes happy every time he passes from a painting to a more beautiful one.

We are allowed to arranged pictures in any order. What is the maximum possible number of times the visitor may become happy while passing all pictures from first to last? In other words, we are allowed to rearrange elements of *a* in any order. What is the maximum possible number of indices *i* (1<=≤<=*i*<=≤<=*n*<=-<=1), such that *a**i*<=+<=1<=&gt;<=*a**i*.","The first line of the input contains integer *n* (1<=≤<=*n*<=≤<=1000) — the number of painting.

The second line contains the sequence *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=1000), where *a**i* means the beauty of the *i*-th painting.","Print one integer — the maximum possible number of neighbouring pairs, such that *a**i*<=+<=1<=&gt;<=*a**i*, after the optimal rearrangement.","['5\n20 30 10 50 40\n', '4\n200 100 100 200\n']","['4\n', '2\n']","In the first sample, the optimal order is: 10, 20, 30, 40, 50.

In the second sample, the optimal order is: 100, 200, 100, 200.",WRONG_ANSWER,"def main_function():
    n = int(input())
    a = sorted([int(i) for i in input().split("" "")])
    hash_a = {}
    for i in a:
        if i in hash_a:
            hash_a[i] += 1
        else:
            hash_a[i] = 1
    counter = 0
    is_there_non_zero = True
    while is_there_non_zero:
        internal_counter = -1
        for i in hash_a:
            if hash_a[i] > 0:
                internal_counter += 1
                hash_a[i] -= 1
        counter += internal_counter

        for i in hash_a:
            if hash_a[i] == 0:
                is_there_non_zero = False
                break
    print(counter)

main_function()","def max_happy_pairs(n, beauties):

    beauties.sort()

    happy_count = 0

    for i in range(1, n):
        if beauties[i] > beauties[i - 1]:
            happy_count += 1

    return happy_count

n = int(input().strip())
beauties = list(map(int, input().strip().split()))

result = max_happy_pairs(n, beauties)
print(result)"
205,A,Little Elephant and Rozdil,PROGRAMMING,"['brute force', 'implementation']","The Little Elephant loves Ukraine very much. Most of all he loves town Rozdol (ukr. ""Rozdil"").

However, Rozdil is dangerous to settle, so the Little Elephant wants to go to some other town. The Little Elephant doesn't like to spend much time on travelling, so for his journey he will choose a town that needs minimum time to travel to. If there are multiple such cities, then the Little Elephant won't go anywhere.

For each town except for Rozdil you know the time needed to travel to this town. Find the town the Little Elephant will go to or print ""Still Rozdil"", if he stays in Rozdil.","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=105) — the number of cities. The next line contains *n* integers, separated by single spaces: the *i*-th integer represents the time needed to go from town Rozdil to the *i*-th town. The time values are positive integers, not exceeding 109.

You can consider the cities numbered from 1 to *n*, inclusive. Rozdil is not among the numbered cities.","Print the answer on a single line — the number of the town the Little Elephant will go to. If there are multiple cities with minimum travel time, print ""Still Rozdil"" (without the quotes).","['2\n7 4\n', '7\n7 4 47 100 4 9 12\n']","['2\n', 'Still Rozdil\n']","In the first sample there are only two cities where the Little Elephant can go. The travel time for the first town equals 7, to the second one — 4. The town which is closest to Rodzil (the only one) is the second one, so the answer is 2.

In the second sample the closest cities are cities two and five, the travelling time to both of them equals 4, so the answer is ""Still Rozdil"".",WRONG_ANSWER,"def solve():
    size = input()
    numbers = sorted(map(int, input().split()))
    
    if numbers[0] == numbers[1]:
        print(""Still Rozdil"")
    else:
        print(numbers[0])
    
    
if __name__ == ""__main__"":
    solve()","def find_town(n, travel_times):

    min_time = min(travel_times)
    min_indices = [i + 1 for i, time in enumerate(travel_times) if time == min_time]

    if len(min_indices) == 1:
        return min_indices[0]
    else:
        return ""Still Rozdil""

n = int(input())
travel_times = list(map(int, input().split()))

result = find_town(n, travel_times)
print(result)"
559,B,Equivalent Strings,PROGRAMMING,"['divide and conquer', 'hashing', 'sortings', 'strings']","Today on a lecture about strings Gerald learned a new definition of string equivalency. Two strings *a* and *b* of equal length are called equivalent in one of the two cases: 
 1.  They are equal. 1.  If we split string *a* into two halves of the same size *a*1 and *a*2, and string *b* into two halves of the same size *b*1 and *b*2, then one of the following is correct:   *a*1 is equivalent to *b*1, and *a*2 is equivalent to *b*2 1.  *a*1 is equivalent to *b*2, and *a*2 is equivalent to *b*1 
As a home task, the teacher gave two strings to his students and asked to determine if they are equivalent.

Gerald has already completed this home task. Now it's your turn!",The first two lines of the input contain two strings given by the teacher. Each of them has the length from 1 to 200<=000 and consists of lowercase English letters. The strings have the same length.,"Print ""YES"" (without the quotes), if these two strings are equivalent, and ""NO"" (without the quotes) otherwise.","['aaba\nabaa\n', 'aabb\nabab\n']","['YES\n', 'NO\n']","In the first sample you should split the first string into strings ""aa"" and ""ba"", the second one — into strings ""ab"" and ""aa"". ""aa"" is equivalent to ""aa""; ""ab"" is equivalent to ""ba"" as ""ab"" = ""a"" + ""b"", ""ba"" = ""b"" + ""a"".

In the second sample the first string can be splitted into strings ""aa"" and ""bb"", that are equivalent only to themselves. That's why string ""aabb"" is equivalent only to itself and to string ""bbaa"".",TIME_LIMIT_EXCEEDED,"def recursion(a, b):
	if len(a) != len(b):
		return False
	elif len(a) == 0:
		return True
	elif len(a) % 2 == 0:
		e = a[:len(a)//2]
		f = a[len(a)//2:]
		g = b[:len(a)//2]
		h = b[len(a)//2:]
		return a == b or (recursion(e, g) and recursion(f, h)) or (recursion(e, h) and recursion(f, g))
	return a == b
if recursion(input(), input()):
	print(""YES"")
else:
	print(""NO"")","def are_equivalent(a, b):

    if a == b:
        return True

    if len(a) % 2 == 1:
        return False

    mid = len(a) // 2
    a1, a2 = a[:mid], a[mid:]
    b1, b2 = b[:mid], b[mid:]

    return (are_equivalent(a1, b1) and are_equivalent(a2, b2)) or \
           (are_equivalent(a1, b2) and are_equivalent(a2, b1))

strings = [input().strip() for _ in range(2)]
a, b = strings[0], strings[1]

if are_equivalent(a, b):
    print(""YES"")
else:
    print(""NO"")"
580,C,Kefa and Park,PROGRAMMING,"['dfs and similar', 'graphs', 'trees']","Kefa decided to celebrate his first big salary by going to the restaurant. 

He lives by an unusual park. The park is a rooted tree consisting of *n* vertices with the root at vertex 1. Vertex 1 also contains Kefa's house. Unfortunaely for our hero, the park also contains cats. Kefa has already found out what are the vertices with cats in them.

The leaf vertices of the park contain restaurants. Kefa wants to choose a restaurant where he will go, but unfortunately he is very afraid of cats, so there is no way he will go to the restaurant if the path from the restaurant to his house contains more than *m* consecutive vertices with cats. 

Your task is to help Kefa count the number of restaurants where he can go.","The first line contains two integers, *n* and *m* (2<=≤<=*n*<=≤<=105, 1<=≤<=*m*<=≤<=*n*) — the number of vertices of the tree and the maximum number of consecutive vertices with cats that is still ok for Kefa.

The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n*, where each *a**i* either equals to 0 (then vertex *i* has no cat), or equals to 1 (then vertex *i* has a cat).

Next *n*<=-<=1 lines contains the edges of the tree in the format ""*x**i* *y**i*"" (without the quotes) (1<=≤<=*x**i*,<=*y**i*<=≤<=*n*, *x**i*<=≠<=*y**i*), where *x**i* and *y**i* are the vertices of the tree, connected by an edge. 

It is guaranteed that the given set of edges specifies a tree.",A single integer — the number of distinct leaves of a tree the path to which from Kefa's home contains at most *m* consecutive vertices with cats.,"['4 1\n1 1 0 0\n1 2\n1 3\n1 4\n', '7 1\n1 0 1 1 0 0 0\n1 2\n1 3\n2 4\n2 5\n3 6\n3 7\n']","['2\n', '2\n']","Let us remind you that a tree is a connected graph on *n* vertices and *n* - 1 edge. A rooted tree is a tree with a special vertex called root. In a rooted tree among any two vertices connected by an edge, one vertex is a parent (the one closer to the root), and the other one is a child. A vertex is called a leaf, if it has no children.

Note to the first sample test: <img class=""tex-graphics"" src=""https://espresso.codeforces.com/785114b4b3f5336f02078c25750f87c5a1d0b4be.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> The vertices containing cats are marked red. The restaurants are at vertices 2, 3, 4. Kefa can't go only to the restaurant located at vertex 2.

Note to the second sample test: <img class=""tex-graphics"" src=""https://espresso.codeforces.com/e5c07640680c837aec99126d94287872e69aa09a.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> The restaurants are located at vertices 4, 5, 6, 7. Kefa can't go to restaurants 6, 7.",WRONG_ANSWER,"from collections import defaultdict
n, m = map(int, input().split())
arr = list(map(int, input().split()))
adj_list = defaultdict(set)
for _ in range(n-1):
    a, b = map(int, input().split())
    adj_list[a].add(b)

def dfs(node, i):
    if i < 0:
        return 0
    if node not in adj_list:
        return 1
    curr = 0
    for child in adj_list[node]:
        if arr[node-1] == 1:
            if arr[child-1] == 1:
                curr += dfs(child, i-1)
            else:
                curr += dfs(child, m-1)
        else:
            if arr[child-1] == 1:
                curr += dfs(child, m-1)
            else:
                curr += dfs(child, m)
    return curr
if arr[0] == 1:
    print(dfs(1, m-1))
else:
    print(dfs(1, m))","def count_restaurants(n, m, cats, edges):
    from collections import defaultdict, deque

    tree = defaultdict(list)
    for x, y in edges:
        tree[x].append(y)
        tree[y].append(x)

    count = 0
    queue = deque([(1, 0, -1)])

    while queue:
        current, cat_count, parent = queue.popleft()

        if cats[current - 1] == 1:
            cat_count += 1
        else:
            cat_count = 0

        if cat_count > m:
            continue

        is_leaf = True
        for neighbor in tree[current]:
            if neighbor != parent:
                is_leaf = False
                queue.append((neighbor, cat_count, current))

        if is_leaf:
            count += 1

    return count

import sys

def main():
    input_data = sys.stdin.read().strip().split('\n')
    n, m = map(int, input_data[0].split())
    cats = list(map(int, input_data[1].split()))
    
    edges = []
    for i in range(2, 2 + n - 1):
        edges.append(tuple(map(int, input_data[i].split())))

    result = count_restaurants(n, m, cats, edges)
    print(result)

if __name__ == ""__main__"":
    main()"
33,B,String Problem,PROGRAMMING,['shortest paths'],"Boy Valera likes strings. And even more he likes them, when they are identical. That's why in his spare time Valera plays the following game. He takes any two strings, consisting of lower case Latin letters, and tries to make them identical. According to the game rules, with each move Valera can change one arbitrary character *A**i* in one of the strings into arbitrary character *B**i*, but he has to pay for every move a particular sum of money, equal to *W**i*. He is allowed to make as many moves as he needs. Since Valera is a very economical boy and never wastes his money, he asked you, an experienced programmer, to help him answer the question: what minimum amount of money should Valera have to get identical strings.","The first input line contains two initial non-empty strings *s* and *t*, consisting of lower case Latin letters. The length of each string doesn't exceed 105. The following line contains integer *n* (0<=≤<=*n*<=≤<=500) — amount of possible changings. Then follow *n* lines, each containing characters *A**i* and *B**i* (lower case Latin letters) and integer *W**i* (0<=≤<=*W**i*<=≤<=100), saying that it's allowed to change character *A**i* into character *B**i* in any of the strings and spend sum of money *W**i*.","If the answer exists, output the answer to the problem, and the resulting string. Otherwise output -1 in the only line. If the answer is not unique, output any.","['uayd\nuxxd\n3\na x 8\nx y 13\nd c 3\n', 'a\nb\n3\na b 2\na b 3\nb a 5\n', 'abc\nab\n6\na b 4\na b 7\nb a 8\nc b 11\nc a 3\na c 0\n']","['21\nuxyd\n', '2\nb\n', '-1\n']",none,OK,"import math
import random 
import time
from decimal import *
from collections import defaultdict
from bisect import bisect_left as lower_bound
from bisect import bisect_right as upper_bound

import sys,threading

alfabet = {'a': 1, 'b': 2,'c': 3,'d': 4,'e': 5,'f': 6,'g': 7,'h': 8,'i': 9,'j': 10,'k': 11,'l': 12,'m': 13,'n': 14,'o': 15,'p': 16,'q': 17,'r': 18,'s': 19,'t': 20,'u': 21,'v': 22,'w': 23,'x': 24,'y': 25,'z': 26}
alfabet_2={'1':""a"", '2':""b"", '3':""c"", '4':""d"", '5':""e"", '6':""f"", '7':""g"", '8':""h"", '9':""i"", '10':""j"", '11':""k"", '12':""l"", '13':""m"", '14':""n"", '15':""o"", '16':""p"", '17':""q"", '18':""r"", '19':""s"", '20':""t"", '21':""u"", '22':""v"", '23':""w"", '24':""x"", '25':""y"", '26':""z""}
 
 
class FenwickTree:
    def __init__(self, x):
        bit = self.bit = list(x)
        size = self.size = len(bit)
        for i in range(size):
            j = i | (i + 1)
            if j < size:
                bit[j] += bit[i]
 
    def update(self, idx, x):
        """"""updates bit[idx] += x""""""
        while idx < self.size:
            self.bit[idx] += x
            idx |= idx + 1
 
    def __call__(self, end):
        """"""calc sum(bit[:end])""""""
        x = 0
        while end:
            x += self.bit[end - 1]
            end &= end - 1
        return x
 
    def find_kth(self, k):
        """"""Find largest idx such that sum(bit[:idx]) <= k""""""
        idx = -1
        for d in reversed(range(self.size.bit_length())):
            right_idx = idx + (1 << d)
            if right_idx < self.size and self.bit[right_idx] <= k:
                idx = right_idx
                k -= self.bit[idx]
        return idx + 1, k
 
 
class SortedList:
    block_size = 700
 
    def __init__(self, iterable=()):
        self.macro = []
        self.micros = [[]]
        self.micro_size = [0]
        self.fenwick = FenwickTree([0])
        self.size = 0
        for item in iterable:
            self.insert(item)
 
    def insert(self, x):
        i = lower_bound(self.macro, x)
        j = upper_bound(self.micros[i], x)
        self.micros[i].insert(j, x)
        self.size += 1
        self.micro_size[i] += 1
        self.fenwick.update(i, 1)
        if len(self.micros[i]) >= self.block_size:
            self.micros[i:i + 1] = self.micros[i][:self.block_size >> 1], self.micros[i][self.block_size >> 1:]
            self.micro_size[i:i + 1] = self.block_size >> 1, self.block_size >> 1
            self.fenwick = FenwickTree(self.micro_size)
            self.macro.insert(i, self.micros[i + 1][0])
 
    def pop(self, k=-1):
        i, j = self._find_kth(k)
        self.size -= 1
        self.micro_size[i] -= 1
        self.fenwick.update(i, -1)
        return self.micros[i].pop(j)
 
    def __getitem__(self, k):
        i, j = self._find_kth(k)
        return self.micros[i][j]
 
    def count(self, x):
        return self.upper_bound(x) - self.lower_bound(x)
 
    def __contains__(self, x):
        return self.count(x) > 0
 
    def lower_bound(self, x):
        i = lower_bound(self.macro, x)
        return self.fenwick(i) + lower_bound(self.micros[i], x)
 
    def upper_bound(self, x):
        i = upper_bound(self.macro, x)
        return self.fenwick(i) + upper_bound(self.micros[i], x)
 
    def _find_kth(self, k):
        return self.fenwick.find_kth(k + self.size if k < 0 else k)
 
    def __len__(self):
        return self.size
 
    def __iter__(self):
        return (x for micro in self.micros for x in micro)
 
    def __repr__(self):
        return str(list(self))

def binary_search(vector,valoarea):
 
 left=0
 right=len(vector)-1
 
 while left<=right:
  
  
  centru=(left+right)//2

  if vector[centru]<=valoarea:
    left=centru+1
  else:
    right=centru-1

 return left
 
def functie(element,dist,full,graph,vizitat,partial,initialul):
  initial=alfabet[element]
  vizitat[initial]=1
  
  for elemente in graph[element]:
   pozitie=alfabet[elemente]
   
   if vizitat[pozitie]==0:
    
    partial[pozitie]=min(partial[pozitie],partial[initial]+dist[(element,elemente)])
    
    val_partiala=min(partial[pozitie],partial[initial]+dist[(element,elemente)])

  minimul=10**18
  target=''
  
  for i in range(1,27):
   new_element=alfabet_2[str(i)]
   
   
   if vizitat[i]==0:
    
    if minimul>partial[i]:
     minimul=partial[i]
     target=new_element
     
  vizitat[initial]=1
  
  if target!='':

   functie(target,dist,full,graph,vizitat,partial,initialul)
  else:

   for dd in range(1,27):
    if partial[dd]<10**18:
     full[(initialul,alfabet_2[str(dd)])]=partial[dd]
    
 
 
   
   
   
def functie_nod(nodul,oprire,distantele,graficul,vizitatul,rezultatul,initial): 
 
 
 pp=10**18
 partial=pp
 
 gasit=0

 ex=0
 for vecini in graficul[nodul]:
  if vizitatul[vecini]==0:
   ex=1

   rezultatul[vecini]=min(rezultatul[vecini],rezultatul[nodul]+distantele[(nodul,vecini)])

   if partial>=rezultatul[vecini]:
    next_one=vecini
    partial=rezultatul[vecini]

 vizitatul[nodul]=1
 
  
 
 if ex==0:

  return rezultatul[oprire]
 
 else:

  functie(next_one,oprire,distantele,graficul,vizitatul,rezultatul)  
  
  
 
 
 
 
 
def main():

 pp=10**18
 restul=998244353

 printare=[]
 
 
 for gg in range(1):

  cate=0
  string_unu=input()
  string_doi=input()
  
  
  n=int(input())
  
  distante={}
  full_distante={}
  sume=0
  graficul=defaultdict(list)
  
  
  
  for i in range(n):
   lista=list(map(str,input().split()))
   
   if (lista[0],lista[1]) not in distante:
    distante[(lista[0],lista[1])]=int(lista[2])
    graficul[lista[0]].append(lista[1])
   else:
    distante[(lista[0],lista[1])]=min(distante[(lista[0],lista[1])],int(lista[2]))

  for i in range(1,27):
   
   vizitatul=[0] *27
   partialul=[pp] *27
   partialul[i]=0
   
   functie(alfabet_2[str(i)],distante,full_distante,graficul,vizitatul,partialul,alfabet_2[str(i)])

  great_book={}
  results={}
  
  for i in range(1,27):
   for j in range(1,27):
    minimul=pp
    targetul=''
    
    for c in range(1,27):
     
     unu=alfabet_2[str(i)]
     doi=alfabet_2[str(j)]
     trei=alfabet_2[str(c)]
     
     
     if (unu,trei) in full_distante and (doi,trei) in full_distante:
      if full_distante[(unu,trei)]+full_distante[(doi,trei)]<minimul:
       minimul=full_distante[(unu,trei)]+full_distante[(doi,trei)]
       targetul=trei
     
    if targetul!='':
     great_book[(unu,doi)]=targetul
     results[(unu,doi)]=minimul

  sume=0
  adev=1
  answer=''
  
  if len(string_unu)!=len(string_doi):
   adev=0

  else: 
   for i in range(len(string_unu)):
    unu=string_unu[i]
    doi=string_doi[i]
   
    if unu!=doi:
     if (unu,doi) not in great_book:
      adev=0
      break
     else:
      sume+=results[(unu,doi)]
      answer+=great_book[(unu,doi)]
     
    else:
     answer+=unu

  if adev==1:
   print(sume)
   print(answer)
  else:
   print(-1)
   
main()","import sys
import heapq

s = input().strip()
t = input().strip()

n = int(input().strip())

cost = {chr(i): {} for i in range(ord('a'), ord('z') + 1)}

for _ in range(n):
    a, b, w = input().strip().split()
    w = int(w)
    if b not in cost[a] or cost[a][b] > w:
        cost[a][b] = w

def dijkstra(source):
    min_cost = {chr(i): float('inf') for i in range(ord('a'), ord('z') + 1)}
    min_cost[source] = 0
    pq = [(0, source)]
    while pq:
        current_cost, current_char = heapq.heappop(pq)
        if current_cost > min_cost[current_char]:
            continue
        for neighbor, change_cost in cost[current_char].items():
            new_cost = current_cost + change_cost
            if new_cost < min_cost[neighbor]:
                min_cost[neighbor] = new_cost
                heapq.heappush(pq, (new_cost, neighbor))
    return min_cost

min_costs = {}
for char in set(s + t):
    min_costs[char] = dijkstra(char)

total_cost = 0
result_string = []

for cs, ct in zip(s, t):
    if cs == ct:
        result_string.append(cs)
        continue

    cost_to_convert = min_costs[cs].get(ct, float('inf')) + min_costs[ct].get(cs, float('inf'))
    
    if cost_to_convert == float('inf'):
        print(-1)
        sys.exit(0)
    
    total_cost += cost_to_convert

    result_string.append(ct)

print(total_cost)
print(''.join(result_string))"
237,B,Young Table,PROGRAMMING,"['implementation', 'sortings']","You've got table *a*, consisting of *n* rows, numbered from 1 to *n*. The *i*-th line of table *a* contains *c**i* cells, at that for all *i* (1<=&lt;<=*i*<=≤<=*n*) holds *c**i*<=≤<=*c**i*<=-<=1. 

Let's denote *s* as the total number of cells of table *a*, that is, . We know that each cell of the table contains a single integer from 1 to *s*, at that all written integers are distinct. 

Let's assume that the cells of the *i*-th row of table *a* are numbered from 1 to *c**i*, then let's denote the number written in the *j*-th cell of the *i*-th row as *a**i*,<=*j*. Your task is to perform several swap operations to rearrange the numbers in the table so as to fulfill the following conditions:
 1.  for all *i*,<=*j* (1<=&lt;<=*i*<=≤<=*n*; 1<=≤<=*j*<=≤<=*c**i*) holds *a**i*,<=*j*<=&gt;<=*a**i*<=-<=1,<=*j*; 1.  for all *i*,<=*j* (1<=≤<=*i*<=≤<=*n*; 1<=&lt;<=*j*<=≤<=*c**i*) holds *a**i*,<=*j*<=&gt;<=*a**i*,<=*j*<=-<=1. 
In one swap operation you are allowed to choose two different cells of the table and swap the recorded there numbers, that is the number that was recorded in the first of the selected cells before the swap, is written in the second cell after it. Similarly, the number that was recorded in the second of the selected cells, is written in the first cell after the swap.

Rearrange the numbers in the required manner. Note that you are allowed to perform any number of operations, but not more than *s*. You do not have to minimize the number of operations.","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=50) that shows the number of rows in the table. The second line contains *n* space-separated integers *c**i* (1<=≤<=*c**i*<=≤<=50; *c**i*<=≤<=*c**i*<=-<=1) — the numbers of cells on the corresponding rows.

Next *n* lines contain table *а*. The *i*-th of them contains *c**i* space-separated integers: the *j*-th integer in this line represents *a**i*,<=*j*.

It is guaranteed that all the given numbers *a**i*,<=*j* are positive and do not exceed *s*. It is guaranteed that all *a**i*,<=*j* are distinct.","In the first line print a single integer *m* (0<=≤<=*m*<=≤<=*s*), representing the number of performed swaps.

In the next *m* lines print the description of these swap operations. In the *i*-th line print four space-separated integers *x**i*,<=*y**i*,<=*p**i*,<=*q**i* (1<=≤<=*x**i*,<=*p**i*<=≤<=*n*; 1<=≤<=*y**i*<=≤<=*c**x**i*; 1<=≤<=*q**i*<=≤<=*c**p**i*). The printed numbers denote swapping the contents of cells *a**x**i*,<=*y**i* and *a**p**i*,<=*q**i*. Note that a swap operation can change the contents of distinct table cells. Print the swaps in the order, in which they should be executed.","['3\n3 2 1\n4 3 5\n6 1\n2\n', '1\n4\n4 3 2 1\n']","['2\n1 1 2 2\n2 1 3 1\n', '2\n1 1 1 4\n1 2 1 3\n']",none,WRONG_ANSWER,"import math
import sys

def solve():
    n = int(input())
    rows = list(map(int, input().split()))

    r = []
    cords = {}

    for i in range(n):
        r.append(list(map(int, input().split())))
        for j in range(rows[i]):
            cords[r[i][j]] = [i, j]

    it = 1
    ans = []

    for i in range(n):
        for j in range(rows[i]):
            if r[i][j] != it:
                r[i][j], r[cords[it][0]][cords[it][1]] = r[cords[it][0]][cords[it][1]], r[i][j]
                ans.append([i, j, cords[it][0], cords[it][1]])
            it += 1

    print(len(ans))
    for i in ans:
        for j in i:
            print(j + 1, end="" "")
        print()

if __name__ == '__main__':
    solve()","def rearrange_table(n, c, a):
    swaps = []
    s = sum(c)
    pos = {}

    index = 0
    for i in range(n):
        for j in range(c[i]):
            pos[a[i][j]] = (i + 1, j + 1)

    target = []
    for i in range(n):
        target.extend(range(1 + sum(c[:i]), sum(c[:i + 1]) + 1))

    current = []
    for i in range(n):
        current.extend(a[i])

    for i in range(s):
        if current[i] != target[i]:

            to_swap = target[i]
            current_pos = pos[current[i]]
            to_swap_pos = pos[to_swap]

            swaps.append((current_pos[0], current_pos[1], to_swap_pos[0], to_swap_pos[1]))

            pos[current[i]], pos[to_swap] = to_swap_pos, current_pos
            current[current_pos[0] - 1] = to_swap
            current[to_swap_pos[0] - 1] = current[i]

    print(len(swaps))
    for swap in swaps:
        print(*swap)

inputs = [
    (3, [3, 2, 1], [[4, 3, 5], [6, 1], [2]]),
    (1, [4], [[4, 3, 2, 1]])
]

for n, c, a in inputs:
    rearrange_table(n, c, a)"
859,B,Lazy Security Guard,PROGRAMMING,"['brute force', 'geometry', 'math']","Your security guard friend recently got a new job at a new security company. The company requires him to patrol an area of the city encompassing exactly *N* city blocks, but they let him choose which blocks. That is, your friend must walk the perimeter of a region whose area is exactly *N* blocks. Your friend is quite lazy and would like your help to find the shortest possible route that meets the requirements. The city is laid out in a square grid pattern, and is large enough that for the sake of the problem it can be considered infinite.","Input will consist of a single integer *N* (1<=≤<=*N*<=≤<=106), the number of city blocks that must be enclosed by the route.",Print the minimum perimeter that can be achieved.,"['4\n', '11\n', '22\n']","['8\n', '14\n', '20\n']","Here are some possible shapes for the examples:

<img class=""tex-graphics"" src=""https://espresso.codeforces.com/e11bef2cf82b55dd583cfc97d12b5aee5e483a65.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>",WRONG_ANSWER,"import math

def GCD(a,b):

    if a < b:
        a, b = b, a
    if a%b == 0:
        return b
    else:
        return GCD(b,a%b)

def minLengthsCall(n):
    RA = minLengths(n)

    return RA

def minLengths(n):

    if n <= 0:
        return []
    has = n
    while has > n//2:
        if math.sqrt(has)%1 == 0:
            if has == n:
                return [int(math.sqrt(has)),int(math.sqrt(has))]
            else:
                return [int(math.sqrt(has)),int(math.sqrt(has))]+minLengths(n-has)
        has -= 1
    else:
        maxVol = 1*n
        pos = [1,n]

        for i in range(1,n+1):
            if i*(n-i) > maxVol:

                maxVol = i*(n-i)
                pos = [i,n-i]
        return pos

        x = 0

def minStreets(n):
    lengths = minLengthsCall(n)
    streets = []
    i = 0
    while i < len(lengths):

        streets.append(2*lengths[i]+2*lengths[i+1])
        i += 2
    i = 0
    j = 2
    total = 0
    if len(streets) == 1:
        return streets[0]
    currentStreets = 2*lengths[0]+2*lengths[1]
    if streets[0] > streets[1]:
        maxW = streets[0]
    else:
        maxW = streets[1]

    del lengths[0]
    del lengths[0]
    currentW = 0
    while len(lengths) > 0:
        if lengths[0] > lengths[1]:
            addW = lengths[0]
            width = lengths[0]
            height = lengths[1]
        else:
            addW = lengths[1]
            width = lengths[1]
            height = lengths[0]

        if currentW == 0:
            currentStreets += 2*height
            currentW = addW
        elif addW + currentW <= maxW:
            currentStreets += 0
            currentW += addW
            if currentW > maxW:
                currentW = 0
        else:
            currentStreets += height
            currentW += addW
            if currentW > maxWL:
                currentW = 0
        del lengths[0]
        del lengths[0]
    return currentStreets
    
while True:
    try:
        case = input()
        temp = int(case)
        print(minStreets(temp))
    except EOFError:
        break","def minimum_perimeter(N):

    min_perimeter = float('inf')
    
    for width in range(1, int(N**0.5) + 1):
        if N % width == 0:
            height = N // width

            perimeter = 2 * (width + height)
            min_perimeter = min(min_perimeter, perimeter)
    
    return min_perimeter

def main():
    import sys
    input_data = sys.stdin.read().strip().split()
    results = []
    
    for line in input_data:
        N = int(line)
        results.append(f""{minimum_perimeter(N)}"")
    
    print(""\n"".join(results))

if __name__ == ""__main__"":
    main()"
217,A,Ice Skating,PROGRAMMING,"['brute force', 'dfs and similar', 'dsu', 'graphs']","Bajtek is learning to skate on ice. He's a beginner, so his only mode of transportation is pushing off from a snow drift to the north, east, south or west and sliding until he lands in another snow drift. He has noticed that in this way it's impossible to get from some snow drifts to some other by any sequence of moves. He now wants to heap up some additional snow drifts, so that he can get from any snow drift to any other one. He asked you to find the minimal number of snow drifts that need to be created.

We assume that Bajtek can only heap up snow drifts at integer coordinates.","The first line of input contains a single integer *n* (1<=≤<=*n*<=≤<=100) — the number of snow drifts. Each of the following *n* lines contains two integers *x**i* and *y**i* (1<=≤<=*x**i*,<=*y**i*<=≤<=1000) — the coordinates of the *i*-th snow drift.

Note that the north direction coinсides with the direction of *Oy* axis, so the east direction coinсides with the direction of the *Ox* axis. All snow drift's locations are distinct.",Output the minimal number of snow drifts that need to be created in order for Bajtek to be able to reach any snow drift from any other one.,"['2\n2 1\n1 2\n', '2\n2 1\n4 1\n']","['1\n', '0\n']",none,OK,"n=int(input())
q={}
l=[]
r=[]
def f(a):
    while q[a]!=a:
        a=q[a]
    return a
for i in range(n):
    a,b=map(str,input().split())
    o,p=""x""+a,""y""+b
    l+=[[o,p]]
    r+=[o,p]
    q[o]=o
    q[p]=p
for i in range(n):
    l[i][0]=f(l[i][0])
    l[i][1]=f(l[i][1])
    q[l[i][1]]=q[l[i][0]]
for i in r:
    q[i]=f(i)
print(len(set(q.values()))-1)","def find_min_snow_drifts(n, drifts):

    unique_x = set()
    unique_y = set()

    for x, y in drifts:
        unique_x.add(x)
        unique_y.add(y)

    additional_drifts = max(0, len(unique_x) - 1) + max(0, len(unique_y) - 1)

    return additional_drifts

def main():
    import sys

    input_data = sys.stdin.read().strip().split('\n')
    n = int(input_data[0])
    drifts = [tuple(map(int, line.split())) for line in input_data[1:n+1]]

    result = find_min_snow_drifts(n, drifts)
    print(result)

if __name__ == ""__main__"":
    main()"
217,A,Ice Skating,PROGRAMMING,"['brute force', 'dfs and similar', 'dsu', 'graphs']","Bajtek is learning to skate on ice. He's a beginner, so his only mode of transportation is pushing off from a snow drift to the north, east, south or west and sliding until he lands in another snow drift. He has noticed that in this way it's impossible to get from some snow drifts to some other by any sequence of moves. He now wants to heap up some additional snow drifts, so that he can get from any snow drift to any other one. He asked you to find the minimal number of snow drifts that need to be created.

We assume that Bajtek can only heap up snow drifts at integer coordinates.","The first line of input contains a single integer *n* (1<=≤<=*n*<=≤<=100) — the number of snow drifts. Each of the following *n* lines contains two integers *x**i* and *y**i* (1<=≤<=*x**i*,<=*y**i*<=≤<=1000) — the coordinates of the *i*-th snow drift.

Note that the north direction coinсides with the direction of *Oy* axis, so the east direction coinсides with the direction of the *Ox* axis. All snow drift's locations are distinct.",Output the minimal number of snow drifts that need to be created in order for Bajtek to be able to reach any snow drift from any other one.,"['2\n2 1\n1 2\n', '2\n2 1\n4 1\n']","['1\n', '0\n']",none,OK,"nodes = []
n = int(input().strip())
for _ in range(n):
	nodes.append(tuple(map(int, input().strip().split())))

visited = [False]*n

def dfs(node):
	visited[node] = True
	for i in range(n):
		if not visited[i] and (nodes[node][0] == nodes[i][0] or nodes[node][1] == nodes[i][1]):
			dfs(i)

ans = 0
for i in range(n):
	if not visited[i]:
		dfs(i)
		ans += 1

print(ans-1)","def find_min_snow_drifts(n, coordinates):

    unique_coordinates = set(coordinates)

    parent = {}
    
    def find(x):
        if parent[x] != x:
            parent[x] = find(parent[x])
        return parent[x]

    def union(x, y):
        rootX = find(x)
        rootY = find(y)
        if rootX != rootY:
            parent[rootY] = rootX

    for coord in unique_coordinates:
        parent[coord] = coord

    for coord in unique_coordinates:
        x, y = coord
        for other in unique_coordinates:
            if other != coord:
                other_x, other_y = other

                if x == other_x or y == other_y:
                    union(coord, other)

    component_roots = set(find(coord) for coord in unique_coordinates)

    return len(component_roots) - 1

input_data = [
    '2\n2 1\n1 2\n',
    '2\n2 1\n4 1\n'
]

results = []
for data in input_data:
    lines = data.strip().split('\n')
    n = int(lines[0])
    coordinates = [tuple(map(int, line.split())) for line in lines[1:n + 1]]
    min_snow_drifts = find_min_snow_drifts(n, coordinates)
    results.append(f""{min_snow_drifts}\n"")

for result in results:
    print(result, end="""")"
544,B,Sea and Islands,PROGRAMMING,"['constructive algorithms', 'implementation']","A map of some object is a rectangular field consisting of *n* rows and *n* columns. Each cell is initially occupied by the sea but you can cover some some cells of the map with sand so that exactly *k* islands appear on the map. We will call a set of sand cells to be island if it is possible to get from each of them to each of them by moving only through sand cells and by moving from a cell only to a side-adjacent cell. The cells are called to be side-adjacent if they share a vertical or horizontal side. It is easy to see that islands do not share cells (otherwise they together form a bigger island).

Find a way to cover some cells with sand so that exactly *k* islands appear on the *n*<=×<=*n* map, or determine that no such way exists.","The single line contains two positive integers *n*, *k* (1<=≤<=*n*<=≤<=100, 0<=≤<=*k*<=≤<=*n*2) — the size of the map and the number of islands you should form.","If the answer doesn't exist, print ""NO"" (without the quotes) in a single line.

Otherwise, print ""YES"" in the first line. In the next *n* lines print the description of the map. Each of the lines of the description must consist only of characters 'S' and 'L', where 'S' is a cell that is occupied by the sea and 'L' is the cell covered with sand. The length of each line of the description must equal *n*.

If there are multiple answers, you may print any of them.

You should not maximize the sizes of islands.","['5 2\n', '5 25\n']","['YES\nSSSSS\nLLLLL\nSSSSS\nLLLLL\nSSSSS\n', 'NO\n']",none,WRONG_ANSWER,"import sys
import string
from collections import defaultdict
from functools import lru_cache
from collections import Counter

def mi(s):
    return map(int, s.strip().split())

def lmi(s):
    return list(mi(s))

def mf(f, s):
    return map(f, s)

def lmf(f, s):
    return list(mf(f, s))

def main(n, k):
    mat = [['S' for _ in range(n)] for _ in range(n)]

    s = 0
    even = True
    for i in range(len(mat)):
        for j in range(len(mat[i])):
            if even and j % 2 == 0:
                mat[i][j] = 'L'
                s += 1
            if not even and j % 2 == 1:
                mat[i][j] == 'L'
                s += 1

            if s == k:
                print(""YES"")
                for r in mat:
                    print("""".join(r))
                return
        even = not even
    print(""NO"")

if __name__ == ""__main__"":
    for e, line in enumerate(sys.stdin.readlines()):
        n, k = mi(line)
    main(n, k)","def create_islands(n, k):

    map_grid = [['S'] * n for _ in range(n)]

    islands_placed = 0

    for i in range(n):
        for j in range(n):

            if islands_placed < k and (i + j) % 2 == 0:
                map_grid[i][j] = 'L'
                islands_placed += 1

            if islands_placed == k:
                break
        if islands_placed == k:
            break

    if islands_placed == k:
        print(""YES"")
        for row in map_grid:
            print(''.join(row))
    else:
        print(""NO"")

input_data = ['5 2\n', '5 25\n']
for test in input_data:
    n, k = map(int, test.strip().split())
    create_islands(n, k)"
277,A,Learning Languages,PROGRAMMING,"['dfs and similar', 'dsu']","The ""BerCorp"" company has got *n* employees. These employees can use *m* approved official languages for the formal correspondence. The languages are numbered with integers from 1 to *m*. For each employee we have the list of languages, which he knows. This list could be empty, i. e. an employee may know no official languages. But the employees are willing to learn any number of official languages, as long as the company pays their lessons. A study course in one language for one employee costs 1 berdollar.

Find the minimum sum of money the company needs to spend so as any employee could correspond to any other one (their correspondence can be indirect, i. e. other employees can help out translating).","The first line contains two integers *n* and *m* (2<=≤<=*n*,<=*m*<=≤<=100) — the number of employees and the number of languages.

Then *n* lines follow — each employee's language list. At the beginning of the *i*-th line is integer *k**i* (0<=≤<=*k**i*<=≤<=*m*) — the number of languages the *i*-th employee knows. Next, the *i*-th line contains *k**i* integers — *a**ij* (1<=≤<=*a**ij*<=≤<=*m*) — the identifiers of languages the *i*-th employee knows. It is guaranteed that all the identifiers in one list are distinct. Note that an employee may know zero languages.

The numbers in the lines are separated by single spaces.",Print a single integer — the minimum amount of money to pay so that in the end every employee could write a letter to every other one (other employees can help out translating).,"['5 5\n1 2\n2 2 3\n2 3 4\n2 4 5\n1 5\n', '8 7\n0\n3 1 2 3\n1 1\n2 5 4\n2 6 7\n1 3\n2 7 4\n1 1\n', '2 2\n1 2\n0\n']","['0\n', '2\n', '1\n']","In the second sample the employee 1 can learn language 2, and employee 8 can learn language 4.

In the third sample employee 2 must learn language 2.",WRONG_ANSWER,"def isCommon(l1,l2):
	for i in l1:
		if i in l2:
			return True
	return False

def BFS(V,E,start,visited):
	q = []
	q.append(start)
	vis[start] = True

	while len(q)!=0:
		v = q.pop(0)
		for i in E[v]:
			if not vis[i]:
				vis[i] = True
				q.append(i)

	return vis

n,m =map(int,input().split())
lang = []
k = [0]*n
for i in range(n):
	ls = list(map(int,input().split()))
	k[i] = ls.pop(0)
	lang.append(ls)

v=[]

for i in range(n):
	v.append(i)

adj =[0]*n
for i in range(n):
	adj[i] = []	
for i in range(n):
	for j in range(n):
		if isCommon(lang[i],lang[j]):
			adj[i].append(j)
			adj[j].append(i)
vis = [False]*n
vis = BFS(v,adj,0,vis)
count = 0
while False in vis:
	ind = vis.index(False)
	vis = BFS(v,adj,ind,vis)
	count+=1
print(count)","def min_cost_to_connect_employees(n, m, language_data):

    languages = [[] for _ in range(m + 1)]

    for i in range(n):

        emp_languages = language_data[i][1:]
        for lang in emp_languages:
            languages[lang].append(i)

    parent = list(range(n))
    
    def find(x):
        if parent[x] != x:
            parent[x] = find(parent[x])
        return parent[x]
    
    def union(x, y):
        rootX = find(x)
        rootY = find(y)
        if rootX != rootY:
            parent[rootY] = rootX

    for lang, emp_list in enumerate(languages):
        for i in range(len(emp_list) - 1):
            union(emp_list[i], emp_list[i + 1])

    roots = set(find(i) for i in range(n))

    no_language_employees = sum(1 for lang_list in language_data if lang_list[0] == 0)

    return len(roots) - 1 + no_language_employees

def main():
    import sys
    input = sys.stdin.read
    data = input().splitlines()
    
    results = []
    index = 0
    while index < len(data):
        n, m = map(int, data[index].split())
        index += 1
        language_data = []
        
        for _ in range(n):
            line = list(map(int, data[index].split()))
            language_data.append(line)
            index += 1

        result = min_cost_to_connect_employees(n, m, language_data)
        results.append(result)

    for res in results:
        print(res)

if __name__ == ""__main__"":
    main()"
233,A,Perfect Permutation,PROGRAMMING,"['implementation', 'math']","A permutation is a sequence of integers *p*1,<=*p*2,<=...,<=*p**n*, consisting of *n* distinct positive integers, each of them doesn't exceed *n*. Let's denote the *i*-th element of permutation *p* as *p**i*. We'll call number *n* the size of permutation *p*1,<=*p*2,<=...,<=*p**n*.

Nickolas adores permutations. He likes some permutations more than the others. He calls such permutations perfect. A perfect permutation is such permutation *p* that for any *i* (1<=≤<=*i*<=≤<=*n*) (*n* is the permutation size) the following equations hold *p**p**i*<==<=*i* and *p**i*<=≠<=*i*. Nickolas asks you to print any perfect permutation of size *n* for the given *n*.",A single line contains a single integer *n* (1<=≤<=*n*<=≤<=100) — the permutation size.,"If a perfect permutation of size *n* doesn't exist, print a single integer -1. Otherwise print *n* distinct integers from 1 to *n*, *p*1,<=*p*2,<=...,<=*p**n* — permutation *p*, that is perfect. Separate printed numbers by whitespaces.","['1\n', '2\n', '4\n']","['-1\n', '2 1 \n', '2 1 4 3 \n']",none,TIME_LIMIT_EXCEEDED,"def permutations(ch, curr_index=0):
    if curr_index == len(ch) - 1:
        pr = True
        for i in range(1, len(ch) + 1):
            if ch[ch[i - 1] - 1] != i or ch[i - 1] == i:
                pr = False
        if pr:
            print("" "".join([str(i) for i in ch]))
            exit()

    for i in range(curr_index, len(ch)):
        ch[curr_index], ch[i] = ch[i], ch[curr_index]
        permutations(ch, curr_index + 1)
        ch[curr_index], ch[i] = ch[i], ch[curr_index]

n = int(input())
permutations(list(range(1, n+1)))
print(-1)","def perfect_permutation(n):
    if n % 2 != 0:
        return -1
    else:

        permutation = []
        for i in range(1, n + 1, 2):
            permutation.append(i + 1)
            permutation.append(i)
        return ' '.join(map(str, permutation))

n = int(input().strip())

result = perfect_permutation(n)

print(result)"
845,C,Two TVs,PROGRAMMING,"['data structures', 'greedy', 'sortings']","Polycarp is a great fan of television.

He wrote down all the TV programs he is interested in for today. His list contains *n* shows, *i*-th of them starts at moment *l**i* and ends at moment *r**i*.

Polycarp owns two TVs. He can watch two different shows simultaneously with two TVs but he can only watch one show at any given moment on a single TV. If one show ends at the same moment some other show starts then you can't watch them on a single TV.

Polycarp wants to check out all *n* shows. Are two TVs enough to do so?","The first line contains one integer *n* (1<=≤<=*n*<=≤<=2·105) — the number of shows.

Each of the next *n* lines contains two integers *l**i* and *r**i* (0<=≤<=*l**i*<=&lt;<=*r**i*<=≤<=109) — starting and ending time of *i*-th show.","If Polycarp is able to check out all the shows using only two TVs then print ""YES"" (without quotes). Otherwise, print ""NO"" (without quotes).","['3\n1 2\n2 3\n4 5\n', '4\n1 2\n2 3\n2 3\n1 2\n']","['YES\n', 'NO\n']",none,WRONG_ANSWER,"def can_all_shows_be_watched (show_times, n):
    reserved_before = 0
    show_times.sort(key=lambda elem: elem[0])
    for i in range(n):
        current_show_time = show_times[i]
        if current_show_time [0] < reserved_before:
            return ""NO""
        reserved_before = current_show_time[1]

    return ""YES""

n_shows_input = int(input())
show_times_input = []

for i_input in range(n_shows_input):
    l_curr_input, r_curr_input = input().split("" "")
    show_times_input.append((int(l_curr_input), int(r_curr_input)))

print(can_all_shows_be_watched(show_times_input, n_shows_input))","def can_watch_all_shows(n, shows):
    events = []

    for l, r in shows:
        events.append((l, 1))
        events.append((r, -1))

    events.sort(key=lambda x: (x[0], x[1]))

    current_shows = 0

    for time, event_type in events:
        current_shows += event_type
        if current_shows > 2:
            return ""NO""

    return ""YES""

n = int(input())
shows = [tuple(map(int, input().split())) for _ in range(n)]

result = can_watch_all_shows(n, shows)
print(result)"
573,A,Bear and Poker,PROGRAMMING,"['implementation', 'math', 'number theory']","Limak is an old brown bear. He often plays poker with his friends. Today they went to a casino. There are *n* players (including Limak himself) and right now all of them have bids on the table. *i*-th of them has bid with size *a**i* dollars.

Each player can double his bid any number of times and triple his bid any number of times. The casino has a great jackpot for making all bids equal. Is it possible that Limak and his friends will win a jackpot?","First line of input contains an integer *n* (2<=≤<=*n*<=≤<=105), the number of players.

The second line contains *n* integer numbers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=109) — the bids of players.","Print ""Yes"" (without the quotes) if players can make their bids become equal, or ""No"" otherwise.","['4\n75 150 75 50\n', '3\n100 150 250\n']","['Yes\n', 'No\n']","In the first sample test first and third players should double their bids twice, second player should double his bid once and fourth player should both double and triple his bid.

It can be shown that in the second sample test there is no way to make all bids equal.",OK,"from collections import Counter,defaultdict,deque
import heapq as hq
from itertools import count, islice

import math
import sys
input=sys.stdin.readline
n = int(input())
arr = [int(x) for x in input().split()]
for i in range(n):
    while (arr[i]%3)==0:
        arr[i]//=3
    while (arr[i]%2)==0:
        arr[i]//=2

q = arr[0]
for i in range(1,n):
    if arr[i]!=q:
        print('No')
        exit()
print('Yes')","def can_make_equal_bids(n, bids):

    def normalize(bid):
        while bid % 2 == 0:
            bid //= 2
        while bid % 3 == 0:
            bid //= 3
        return bid

    normalized = normalize(bids[0])

    for bid in bids:
        if normalize(bid) != normalized:
            return ""No""
    
    return ""Yes""

n = int(input().strip())
bids = list(map(int, input().strip().split()))

result = can_make_equal_bids(n, bids)
print(result)"
0,none,none,none,['none'],"One day, Hongcow goes to the store and sees a brand new deck of *n* special cards. Each individual card is either red or blue. He decides he wants to buy them immediately. To do this, he needs to play a game with the owner of the store.

This game takes some number of turns to complete. On a turn, Hongcow may do one of two things: 
 -  Collect tokens. Hongcow collects 1 red token and 1 blue token by choosing this option (thus, 2 tokens in total per one operation). -  Buy a card. Hongcow chooses some card and spends tokens to purchase it as specified below. 
The *i*-th card requires *r**i* red resources and *b**i* blue resources. Suppose Hongcow currently has *A* red cards and *B* blue cards. Then, the *i*-th card will require Hongcow to spend *max*(*r**i*<=-<=*A*,<=0) red tokens, and *max*(*b**i*<=-<=*B*,<=0) blue tokens. Note, only tokens disappear, but the cards stay with Hongcow forever. Each card can be bought only once.

Given a description of the cards and their costs determine the minimum number of turns Hongcow needs to purchase all cards.","The first line of input will contain a single integer *n* (1<=≤<=*n*<=≤<=16).

The next *n* lines of input will contain three tokens *c**i*, *r**i* and *b**i*. *c**i* will be 'R' or 'B', denoting the color of the card as red or blue. *r**i* will be an integer denoting the amount of red resources required to obtain the card, and *b**i* will be an integer denoting the amount of blue resources required to obtain the card (0<=≤<=*r**i*,<=*b**i*<=≤<=107).","Output a single integer, denoting the minimum number of turns needed to acquire all the cards.","['3\nR 0 1\nB 1 0\nR 1 1\n', '3\nR 3 0\nR 2 0\nR 1 0\n']","['4\n', '6\n']","For the first sample, Hongcow's four moves are as follows: 
 1.  Collect tokens 1.  Buy card 1 1.  Buy card 2 1.  Buy card 3 
For the second sample, one optimal strategy is as follows: 
 1.  Collect tokens 1.  Collect tokens 1.  Buy card 2 1.  Collect tokens 1.  Buy card 3 1.  Buy card 1",WRONG_ANSWER,"import math
def sum_num(n):
	sum = 0
	for i in range(1,n+1):
		sum += i
	return sum

def edit(l):
	global red_card, blue_card
	print(""edit %d %d %d %d"" % (red,blue,red_card,blue_card))
	return l[0], l[1]-red_card, l[2]-blue_card

def get(n):
	global red, blue, count
	print(""get %d %d %d %d"" % (red,blue,red_card,blue_card))
	red += n
	blue += n
	count += n
	print(""after get %d %d %d %d"" % (red,blue,red_card,blue_card))

def buy(card):
	global red,blue, red_card, blue_card, count
	print(""buy %d %d %d %d"" % (red,blue,red_card,blue_card))
	if card[0] == 'R':
		red -= card[1]
		blue -= card[2]
		red_card += 1
	elif card[0] == 'B':
		red -= card[1]
		blue -= card[2]
		blue_card += 1
	count += 1
	print(""after buy %d %d %d %d"" % (red,blue,red_card,blue_card))
n = int(input())
ori_cards = dict()
blue = 0
red = 0
red_card = 0
blue_card = 0
string_card = """"
count = 0

for i in range(n):
	s, r, b = input().split()
	blue += int(b)
	red += int(r)
	string_card += s
	
red_card = string_card.count('R')
blue_card = string_card.count('B')
count_1 = max(red-sum_num(red_card-1), blue-sum_num(blue_card))
count_2 = max(red-sum_num(red_card), blue-sum_num(blue_card-1))
if blue_card == 0:
	count_2 = 10**10
elif red_card == 0:
	count_1 = 10**10
count = min(count_1,count_2)
count += red_card + blue_card
print(count)","def minimum_turns_to_collect_cards(n, cards):

    dp = {}
    
    def dfs(owned_r, owned_b, index):

        if index == n:
            return 0

        if (owned_r, owned_b, index) in dp:
            return dp[(owned_r, owned_b, index)]

        color, r_needed, b_needed = cards[index]

        r_to_pay = max(r_needed - owned_r, 0)
        b_to_pay = max(b_needed - owned_b, 0)

        purchase_turns = float('inf')
        if r_to_pay + b_to_pay <= owned_r + owned_b:
            purchase_turns = dfs(owned_r + (1 if color == 'R' else 0), 
                                  owned_b + (1 if color == 'B' else 0), 
                                  index + 1)

        collect_turns = 1 + dfs(owned_r, owned_b, index)

        dp[(owned_r, owned_b, index)] = min(purchase_turns + (1 if r_to_pay + b_to_pay > 0 else 0), 
                                             collect_turns)
        return dp[(owned_r, owned_b, index)]
    
    return dfs(0, 0, 0)

if __name__ == ""__main__"":
    import sys
    input_data = sys.stdin.read().strip().splitlines()
    
    n = int(input_data[0])
    cards = [tuple(input_data[i + 1].split()) for i in range(n)]
    cards = [(color, int(r), int(b)) for color, r, b in cards]

    result = minimum_turns_to_collect_cards(n, cards)
    print(result)"
920,B,Tea Queue,PROGRAMMING,['implementation'],"Recently *n* students from city S moved to city P to attend a programming camp.

They moved there by train. In the evening, all students in the train decided that they want to drink some tea. Of course, no two people can use the same teapot simultaneously, so the students had to form a queue to get their tea.

*i*-th student comes to the end of the queue at the beginning of *l**i*-th second. If there are multiple students coming to the queue in the same moment, then the student with greater index comes after the student with lesser index. Students in the queue behave as follows: if there is nobody in the queue before the student, then he uses the teapot for exactly one second and leaves the queue with his tea; otherwise the student waits for the people before him to get their tea. If at the beginning of *r**i*-th second student *i* still cannot get his tea (there is someone before him in the queue), then he leaves the queue without getting any tea. 

For each student determine the second he will use the teapot and get his tea (if he actually gets it).","The first line contains one integer *t* — the number of test cases to solve (1<=≤<=*t*<=≤<=1000).

Then *t* test cases follow. The first line of each test case contains one integer *n* (1<=≤<=*n*<=≤<=1000) — the number of students.

Then *n* lines follow. Each line contains two integer *l**i*, *r**i* (1<=≤<=*l**i*<=≤<=*r**i*<=≤<=5000) — the second *i*-th student comes to the end of the queue, and the second he leaves the queue if he still cannot get his tea.

It is guaranteed that for every  condition *l**i*<=-<=1<=≤<=*l**i* holds.

The sum of *n* over all test cases doesn't exceed 1000.

Note that in hacks you have to set *t*<==<=1.","For each test case print *n* integers. *i*-th of them must be equal to the second when *i*-th student gets his tea, or 0 if he leaves without tea.",['2\n2\n1 3\n1 4\n3\n1 5\n1 1\n2 3\n'],['1 2 \n1 0 2 \n'],"The example contains 2 tests:
 1.  During 1-st second, students 1 and 2 come to the queue, and student 1 gets his tea. Student 2 gets his tea during 2-nd second. 1.  During 1-st second, students 1 and 2 come to the queue, student 1 gets his tea, and student 2 leaves without tea. During 2-nd second, student 3 comes and gets his tea.",OK,"from sys import stdin, stdout

def rint():
    return map(int, stdin.readline().split())

t = int(input())

for _ in range(t):
    n = int(input())
    lb, rb = 0, 0
    ct = 0
    ans = []
    for __ in range(n):
        lc, rc = rint()
        if lc >= ct:
            ans.append(lc)
            ct = lc+1
        elif ct <= rc:
            ans.append(ct)
            ct += 1
        else:
            ans.append(0)

    print(*ans)","def tea_queue(test_cases):
    results = []
    
    for case in test_cases:
        n = case[0]
        students = case[1]

        queue = []
        time = 1
        current_results = []
        
        for i in range(n):
            l_i, r_i = students[i]

            while queue and time < l_i:
                time += 1
            
            if time < l_i:

                time = l_i

            if time <= r_i:
                current_results.append(time)
                time += 1
            else:
                current_results.append(0)

            queue.append((l_i, r_i))
        
        results.append(current_results)
    
    return results

input_data = ['2\n2\n1 3\n1 4\n3\n1 5\n1 1\n2 3\n']
output_results = []

for test in input_data:
    if test.strip():
        lines = test.strip().split('\n')
        t = int(lines[0])
        idx = 1
        test_cases = []
        
        for _ in range(t):
            n = int(lines[idx])
            idx += 1
            students = []
            for __ in range(n):
                l_i, r_i = map(int, lines[idx].split())
                students.append((l_i, r_i))
                idx += 1
            test_cases.append((n, students))

        results = tea_queue(test_cases)

        for result in results:
            output_results.append("" "".join(map(str, result)))

print(""\n"".join(output_results))"
48,A,Rock-paper-scissors,PROGRAMMING,"['implementation', 'schedules']","Uncle Fyodor, Matroskin the Cat and Sharic the Dog live their simple but happy lives in Prostokvashino. Sometimes they receive parcels from Uncle Fyodor’s parents and sometimes from anonymous benefactors, in which case it is hard to determine to which one of them the package has been sent. A photographic rifle is obviously for Sharic who loves hunting and fish is for Matroskin, but for whom was a new video game console meant? Every one of the three friends claimed that the present is for him and nearly quarreled. Uncle Fyodor had an idea how to solve the problem justly: they should suppose that the console was sent to all three of them and play it in turns. Everybody got relieved but then yet another burning problem popped up — who will play first? This time Matroskin came up with a brilliant solution, suggesting the most fair way to find it out: play rock-paper-scissors together. The rules of the game are very simple. On the count of three every player shows a combination with his hand (or paw). The combination corresponds to one of three things: a rock, scissors or paper. Some of the gestures win over some other ones according to well-known rules: the rock breaks the scissors, the scissors cut the paper, and the paper gets wrapped over the stone. Usually there are two players. Yet there are three friends, that’s why they decided to choose the winner like that: If someone shows the gesture that wins over the other two players, then that player wins. Otherwise, another game round is required. Write a program that will determine the winner by the gestures they have shown.","The first input line contains the name of the gesture that Uncle Fyodor showed, the second line shows which gesture Matroskin showed and the third line shows Sharic’s gesture.","Print ""F"" (without quotes) if Uncle Fyodor wins. Print ""M"" if Matroskin wins and ""S"" if Sharic wins. If it is impossible to find the winner, print ""?"".","['rock\nrock\nrock\n', 'paper\nrock\nrock\n', 'scissors\nrock\nrock\n', 'scissors\npaper\nrock\n']","['?\n', 'F\n', '?\n', '?\n']",none,WRONG_ANSWER,"def rpc(f,m,s):
    if f == ""cisors"" and m == s == ""paper"":
        return f
    elif s == ""cisors"" and m == f == ""paper"":
        return s
    elif m == ""cisors"" and f == s == ""paper"":
        return m
    elif f==""rock"" and m==s==""cisors"":
        return f
    elif s==""rock"" and m==f==""cisors"":
        return s
    elif m==""rock"" and f==s==""cisors"":
        return m
    elif f==""paper"" and m==s==""rock"":
        return f
    elif f==""paper"" and m==s==""rock"":
        return s
    elif f==""paper"" and m==s==""rock"":
        return m
    return ""?""","def determine_winner(gestures):

    uncle_fyodor = gestures[0]
    matroskin = gestures[1]
    sharic = gestures[2]

    rules = {
        'rock': 'scissors',
        'scissors': 'paper',
        'paper': 'rock'
    }

    gesture_count = {
        uncle_fyodor: 0,
        matroskin: 0,
        sharic: 0
    }

    gesture_count[uncle_fyodor] += 1
    gesture_count[matroskin] += 1
    gesture_count[sharic] += 1

    for gesture in gesture_count:
        if gesture_count[gesture] == 1:

            if all(rules[gesture] == g for g in gesture_count if g != gesture):
                if gesture == uncle_fyodor:
                    return 'F'
                elif gesture == matroskin:
                    return 'M'
                elif gesture == sharic:
                    return 'S'

    return '?'

inputs = [
    ['rock', 'rock', 'rock'],
    ['paper', 'rock', 'rock'],
    ['scissors', 'rock', 'rock'],
    ['scissors', 'paper', 'rock']
]

results = [determine_winner(input_data) for input_data in inputs]

print([result + '\n' for result in results])"
285,B,Find Marble,PROGRAMMING,['implementation'],"Petya and Vasya are playing a game. Petya's got *n* non-transparent glasses, standing in a row. The glasses' positions are indexed with integers from 1 to *n* from left to right. Note that the positions are indexed but the glasses are not.

First Petya puts a marble under the glass in position *s*. Then he performs some (possibly zero) shuffling operations. One shuffling operation means moving the glass from the first position to position *p*1, the glass from the second position to position *p*2 and so on. That is, a glass goes from position *i* to position *p**i*. Consider all glasses are moving simultaneously during one shuffling operation. When the glasses are shuffled, the marble doesn't travel from one glass to another: it moves together with the glass it was initially been put in.

After all shuffling operations Petya shows Vasya that the ball has moved to position *t*. Vasya's task is to say what minimum number of shuffling operations Petya has performed or determine that Petya has made a mistake and the marble could not have got from position *s* to position *t*.","The first line contains three integers: *n*,<=*s*,<=*t* (1<=≤<=*n*<=≤<=105; 1<=≤<=*s*,<=*t*<=≤<=*n*) — the number of glasses, the ball's initial and final position. The second line contains *n* space-separated integers: *p*1,<=*p*2,<=...,<=*p**n* (1<=≤<=*p**i*<=≤<=*n*) — the shuffling operation parameters. It is guaranteed that all *p**i*'s are distinct.

Note that *s* can equal *t*.","If the marble can move from position *s* to position *t*, then print on a single line a non-negative integer — the minimum number of shuffling operations, needed to get the marble to position *t*. If it is impossible, print number -1.","['4 2 1\n2 3 4 1\n', '4 3 3\n4 1 3 2\n', '4 3 4\n1 2 3 4\n', '3 1 3\n2 1 3\n']","['3\n', '0\n', '-1\n', '-1\n']",none,WRONG_ANSWER,"from sys import stdin, stdout
from collections import OrderedDict

def solve(n, s, t, positions):
    count = 0
    while count < n:
        if positions[s-1] == t:
            return count +1
        if positions[s-1] == s:
            return -1
        s = positions[s-1]
        count += 1
    if count == n:
        count = -1
    return count

if __name__ == ""__main__"":
    n, s, t = list(map(int, stdin.readline().rstrip().split()))
    positions = list(map(int, stdin.readline().rstrip().split()))
    stdout.write(str(solve(n, s, t, positions)))","def min_shuffles(n, s, t, p):
    visited = [False] * (n + 1)
    queue = [(s, 0)]
    
    while queue:
        current_pos, shuffles = queue.pop(0)

        if current_pos == t:
            return shuffles
        
        next_pos = p[current_pos - 1]

        if not visited[next_pos]:
            visited[next_pos] = True
            queue.append((next_pos, shuffles + 1))

    return -1

input_data = ['4 2 1\n2 3 4 1\n', '4 3 3\n4 1 3 2\n', '4 3 4\n1 2 3 4\n', '3 1 3\n2 1 3\n']
for data in input_data:
    lines = data.splitlines()
    n, s, t = map(int, lines[0].split())
    p = list(map(int, lines[1].split()))
    
    result = min_shuffles(n, s, t, p)
    print(result)"
831,B,Keyboard Layouts,PROGRAMMING,"['implementation', 'strings']","There are two popular keyboard layouts in Berland, they differ only in letters positions. All the other keys are the same. In Berland they use alphabet with 26 letters which coincides with English alphabet.

You are given two strings consisting of 26 distinct letters each: all keys of the first and the second layouts in the same order. 

You are also given some text consisting of small and capital English letters and digits. It is known that it was typed in the first layout, but the writer intended to type it in the second layout. Print the text if the same keys were pressed in the second layout.

Since all keys but letters are the same in both layouts, the capitalization of the letters should remain the same, as well as all other characters.","The first line contains a string of length 26 consisting of distinct lowercase English letters. This is the first layout.

The second line contains a string of length 26 consisting of distinct lowercase English letters. This is the second layout.

The third line contains a non-empty string *s* consisting of lowercase and uppercase English letters and digits. This is the text typed in the first layout. The length of *s* does not exceed 1000.",Print the text if the same keys were pressed in the second layout.,"['qwertyuiopasdfghjklzxcvbnm\nveamhjsgqocnrbfxdtwkylupzi\nTwccpQZAvb2017\n', 'mnbvcxzlkjhgfdsapoiuytrewq\nasdfghjklqwertyuiopzxcvbnm\n7abaCABAABAcaba7\n']","['HelloVKCup2017\n', '7uduGUDUUDUgudu7\n']",none,OK,"from sys import stdin; inp = stdin.readline
from math import dist, ceil, floor, sqrt, log
from collections import defaultdict, Counter, deque
def IA(sep=' '): return list(map(int, inp().split(sep)))
def FA(): return list(map(float, inp().split()))
def SA(): return inp().split()
def I(): return int(inp())
def F(): return float(inp())
def S(): return input()
def O(l:list): return ' '.join(map(str, l))

def main():
    a = S()
    b = S()
    s = S()
    caps = [c.isupper() for c in s]
    s = s.lower()
    d = {}
    for i in range(26):
        d[a[i]] = b[i]
    res = ''
    for i in range(len(s)):
        char = s[i]
        if char in d:
            char = d[s[i]]
            if caps[i]:
                char = char.upper()
        res += char 
    return res 
        
if __name__ == '__main__':
    print(main())","def convert_text(layout1, layout2, text):

    translation_table = str.maketrans(layout1, layout2)

    translated_text = text.translate(translation_table)
    return translated_text

layout1 = input().strip()
layout2 = input().strip()
text = input()

result = convert_text(layout1, layout2, text)

print(result)"
758,A,Holiday Of Equality,PROGRAMMING,"['implementation', 'math']","In Berland it is the holiday of equality. In honor of the holiday the king decided to equalize the welfare of all citizens in Berland by the expense of the state treasury. 

Totally in Berland there are *n* citizens, the welfare of each of them is estimated as the integer in *a**i* burles (burle is the currency in Berland).

You are the royal treasurer, which needs to count the minimum charges of the kingdom on the king's present. The king can only give money, he hasn't a power to take away them.","The first line contains the integer *n* (1<=≤<=*n*<=≤<=100) — the number of citizens in the kingdom.

The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n*, where *a**i* (0<=≤<=*a**i*<=≤<=106) — the welfare of the *i*-th citizen.",In the only line print the integer *S* — the minimum number of burles which are had to spend.,"['5\n0 1 2 3 4\n', '5\n1 1 0 1 1\n', '3\n1 3 1\n', '1\n12\n']","['10', '1', '4', '0']","In the first example if we add to the first citizen 4 burles, to the second 3, to the third 2 and to the fourth 1, then the welfare of all citizens will equal 4.

In the second example it is enough to give one burle to the third citizen. 

In the third example it is necessary to give two burles to the first and the third citizens to make the welfare of citizens equal 3.

In the fourth example it is possible to give nothing to everyone because all citizens have 12 burles.",OK,"def solve():
    n = int(input())
    numbers = input().split()

    numbers = [int(x) for x in numbers]

    biggest = max(numbers)
    equality = n * biggest
    print(equality - sum(numbers))

def main():
    solve()

main()","def min_charges_to_equalize_welfare(n, a):

    max_welfare = max(a)

    total_charges = sum(max_welfare - welfare for welfare in a)
    return total_charges

n = int(input())
a = list(map(int, input().split()))

result = min_charges_to_equalize_welfare(n, a)

print(result)"
260,A,Adding Digits,PROGRAMMING,"['implementation', 'math']","Vasya has got two number: *a* and *b*. However, Vasya finds number *a* too short. So he decided to repeat the operation of lengthening number *a* *n* times.

One operation of lengthening a number means adding exactly one digit to the number (in the decimal notation) to the right provided that the resulting number is divisible by Vasya's number *b*. If it is impossible to obtain the number which is divisible by *b*, then the lengthening operation cannot be performed.

Your task is to help Vasya and print the number he can get after applying the lengthening operation to number *a* *n* times.","The first line contains three integers: *a*,<=*b*,<=*n* (1<=≤<=*a*,<=*b*,<=*n*<=≤<=105).","In a single line print the integer without leading zeros, which Vasya can get when he applies the lengthening operations to number *a* *n* times. If no such number exists, then print number -1. If there are multiple possible answers, print any of them.","['5 4 5\n', '12 11 1\n', '260 150 10\n']","['524848\n', '121\n', '-1\n']",none,OK,"""""""
Two numbers a and b

You can perform an operation of lengthening by:
    * adding one digit to the number to the right. The new number must be divisible by 5.

Determine whether it is possible to lengthen a n times. If yes print any lengthening.
If not print -1.

Try adding digits from 0 to 9. If none of those work then it is impossible.
After that just chuck in a load of zeros as those don't change divisibility.
""""""

a, b, n = map(int, input().split())

flag = 0
for i in range(10):
    if int(str(a) + str(i)) % b == 0:
        flag = 1
        break

if flag:
    print(str(a) + str(i) + '0'*(n-1))
else:
    print(-1)","def lengthen_number(a, b, n):
    a_str = str(a)
    
    for _ in range(n):
        found = False
        for i in range(10):
            new_number = int(a_str + str(i))
            if new_number % b == 0:
                a_str += str(i)
                found = True
                break
        
        if not found:
            return -1

    return int(a_str)

inputs = ['5 4 5', '12 11 1', '260 150 10']

results = []
for inp in inputs:
    a, b, n = map(int, inp.split())
    result = lengthen_number(a, b, n)
    results.append(result)

for res in results:
    print(res)"
515,A,Drazil and Date,PROGRAMMING,['math'],"Someday, Drazil wanted to go on date with Varda. Drazil and Varda live on Cartesian plane. Drazil's home is located in point (0,<=0) and Varda's home is located in point (*a*,<=*b*). In each step, he can move in a unit distance in horizontal or vertical direction. In other words, from position (*x*,<=*y*) he can go to positions (*x*<=+<=1,<=*y*), (*x*<=-<=1,<=*y*), (*x*,<=*y*<=+<=1) or (*x*,<=*y*<=-<=1). 

Unfortunately, Drazil doesn't have sense of direction. So he randomly chooses the direction he will go to in each step. He may accidentally return back to his house during his travel. Drazil may even not notice that he has arrived to (*a*,<=*b*) and continue travelling. 

Luckily, Drazil arrived to the position (*a*,<=*b*) successfully. Drazil said to Varda: ""It took me exactly *s* steps to travel from my house to yours"". But Varda is confused about his words, she is not sure that it is possible to get from (0,<=0) to (*a*,<=*b*) in exactly *s* steps. Can you find out if it is possible for Varda?","You are given three integers *a*, *b*, and *s* (<=-<=109<=≤<=*a*,<=*b*<=≤<=109, 1<=≤<=*s*<=≤<=2·109) in a single line.","If you think Drazil made a mistake and it is impossible to take exactly *s* steps and get from his home to Varda's home, print ""No"" (without quotes).

Otherwise, print ""Yes"".","['5 5 11\n', '10 15 25\n', '0 5 1\n', '0 0 2\n']","['No\n', 'Yes\n', 'No\n', 'Yes\n']","In fourth sample case one possible route is: <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/0d30660ddf6eb6c64ffd071055a4e8ddd016cde5.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>.",WRONG_ANSWER,"def dist(x1, y1, x2, y2):
    return abs(x1 - x2) + abs(y1 - y2)

a, b, s = map(int, input().split())
if dist(0, 0, a, b) <= s:
    print('Yes')
else:
    print('No')","def can_reach_destination(a, b, s):

    min_steps = abs(a) + abs(b)

    if s < min_steps or (s - min_steps) % 2 != 0:
        return ""No""
    return ""Yes""

input_data = ['5 5 11', '10 15 25', '0 5 1', '0 0 2']
results = []

for data in input_data:
    a, b, s = map(int, data.split())
    results.append(can_reach_destination(a, b, s))

for result in results:
    print(result)"
41,A,Translation,PROGRAMMING,"['implementation', 'strings']","The translation from the Berland language into the Birland language is not an easy task. Those languages are very similar: a berlandish word differs from a birlandish word with the same meaning a little: it is spelled (and pronounced) reversely. For example, a Berlandish word code corresponds to a Birlandish word edoc. However, it's easy to make a mistake during the «translation». Vasya translated word *s* from Berlandish into Birlandish as *t*. Help him: find out if he translated the word correctly.","The first line contains word *s*, the second line contains word *t*. The words consist of lowercase Latin letters. The input data do not consist unnecessary spaces. The words are not empty and their lengths do not exceed 100 symbols.","If the word *t* is a word *s*, written reversely, print YES, otherwise print NO.","['code\nedoc\n', 'abb\naba\n', 'code\ncode\n']","['YES\n', 'NO\n', 'NO\n']",none,OK,"a = input()
b = input()

def reverse(s):
    return s[::-1]

if b == reverse(a):
    print('YES')
else:
    print('NO')","def check_translation(s, t):

    if s[::-1] == t:
        return ""YES""
    else:
        return ""NO""

words = []
for _ in range(2):
    words.append(input().strip())

s, t = words

result = check_translation(s, t)
print(result)"
628,B,New Skateboard,PROGRAMMING,['dp'],"Max wants to buy a new skateboard. He has calculated the amount of money that is needed to buy a new skateboard. He left a calculator on the floor and went to ask some money from his parents. Meanwhile his little brother Yusuf came and started to press the keys randomly. Unfortunately Max has forgotten the number which he had calculated. The only thing he knows is that the number is divisible by 4.

You are given a string *s* consisting of digits (the number on the display of the calculator after Yusuf randomly pressed the keys). Your task is to find the number of substrings which are divisible by 4. A substring can start with a zero.

A substring of a string is a nonempty sequence of consecutive characters.

For example if string *s* is 124 then we have four substrings that are divisible by 4: 12, 4, 24 and 124. For the string 04 the answer is three: 0, 4, 04.

As input/output can reach huge size it is recommended to use fast input/output methods: for example, prefer to use gets/scanf/printf instead of getline/cin/cout in C++, prefer to use BufferedReader/PrintWriter instead of Scanner/System.out in Java.",The only line contains string *s* (1<=≤<=|*s*|<=≤<=3·105). The string *s* contains only digits from 0 to 9.,"Print integer *a* — the number of substrings of the string *s* that are divisible by 4.

Note that the answer can be huge, so you should use 64-bit integer type to store it. In C++ you can use the long long integer type and in Java you can use long integer type.","['124\n', '04\n', '5810438174\n']","['4\n', '3\n', '9\n']",none,OK,"import sys
import os
import math
import copy
from bisect import bisect
from io import BytesIO, IOBase
from math import sqrt,floor,factorial,gcd,log,ceil
from collections import deque,Counter,defaultdict
from itertools import permutations,combinations,accumulate

def Int():               return int(sys.stdin.readline())
def Mint():              return map(int,sys.stdin.readline().split())
def Lstr():              return list(sys.stdin.readline().strip())
def Str():               return sys.stdin.readline().strip()
def Mstr():              return map(str,sys.stdin.readline().strip().split())
def List():              return list(map(int,sys.stdin.readline().split()))
def Hash():              return dict()
def Mod():               return 1000000007
def Mat2x2(n):           return [List() for _ in range(n)]
def Lcm(x,y):            return (x*y)//gcd(x,y)
def dtob(n):             return bin(n).replace(""0b"","""")
def btod(n):             return int(n,2) 
def watch(x):            return print(x)
def common(l1, l2):      return set(l1).intersection(l2)
def Most_frequent(list): return max(set(list), key = list.count)
   
def solution():

          s=Str()
          ans=0
          for i in range(len(s)):
               if(int(s[i])%4==0):
                    ans+=1
          for i in range(len(s)-1):
               if(int(s[i]+s[i+1])%4==0):
                    ans+=(i+1)
          print(ans)          
          
          
          
          
if __name__ == ""__main__"":
     solution()","def count_divisible_by_4_substrings(s):
    count = 0
    n = len(s)

    for i in range(n):

        if int(s[i]) % 4 == 0:
            count += 1

        if i > 0:
            two_digit_substring = s[i-1:i+1]
            if int(two_digit_substring) % 4 == 0:
                count += 1

    return count

s = input().strip()

result = count_divisible_by_4_substrings(s)
print(result)"
519,B,A and B and Compilation Errors,PROGRAMMING,"['data structures', 'implementation', 'sortings']","A and B are preparing themselves for programming contests.

B loves to debug his code. But before he runs the solution and starts debugging, he has to first compile the code.

Initially, the compiler displayed *n* compilation errors, each of them is represented as a positive integer. After some effort, B managed to fix some mistake and then another one mistake.

However, despite the fact that B is sure that he corrected the two errors, he can not understand exactly what compilation errors disappeared — the compiler of the language which B uses shows errors in the new order every time! B is sure that unlike many other programming languages, compilation errors for his programming language do not depend on each other, that is, if you correct one error, the set of other error does not change.

Can you help B find out exactly what two errors he corrected?","The first line of the input contains integer *n* (3<=≤<=*n*<=≤<=105) — the initial number of compilation errors.

The second line contains *n* space-separated integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=109) — the errors the compiler displayed for the first time. 

The third line contains *n*<=-<=1 space-separated integers *b*1,<=*b*2,<=...,<=*b**n*<=-<=1 — the errors displayed at the second compilation. It is guaranteed that the sequence in the third line contains all numbers of the second string except for exactly one. 

The fourth line contains *n*<=-<=2 space-separated integers *с*1,<=*с*2,<=...,<=*с**n*<=-<=2 — the errors displayed at the third compilation. It is guaranteed that the sequence in the fourth line contains all numbers of the third line except for exactly one.","Print two numbers on a single line: the numbers of the compilation errors that disappeared after B made the first and the second correction, respectively.","['5\n1 5 8 123 7\n123 7 5 1\n5 1 7\n', '6\n1 4 3 3 5 7\n3 7 5 4 3\n4 3 7 5\n']","['8\n123\n', '1\n3\n']","In the first test sample B first corrects the error number 8, then the error number 123.

In the second test sample B first corrects the error number 1, then the error number 3. Note that if there are multiple errors with the same number, B can correct only one of them in one step.",TIME_LIMIT_EXCEEDED,"n = int(input())

a = list(map(int, input().split()))
b = list(map(int, input().split()))
c = list(map(int, input().split()))

def insertion(data):
	for i in range(len(data)):
		j = i - 1 
		key = data[i]
		while data[j] > key and j >= 0:
			data[j + 1] = data[j]
			j -= 1
		data[j + 1] = key
	return data
a = insertion(a)
b = insertion(b)
c = insertion(c)

def razn(a, b):
    n = len(a)
    t = -1
    index = 0
    while index < n-1:
        if a[index] != b[index]:
            break
        index += 1
    return a[index]

print(razn(a, b), '\n', razn(b, c), sep = '')","def find_corrected_errors(n, errors_first, errors_second, errors_third):

    missing_first = sum(errors_first) - sum(errors_second)

    missing_second = sum(errors_second) - sum(errors_third)
    return missing_first, missing_second

n = int(input())
errors_first = list(map(int, input().split()))
errors_second = list(map(int, input().split()))
errors_third = list(map(int, input().split()))

corrected_errors = find_corrected_errors(n, errors_first, errors_second, errors_third)

print(corrected_errors[0])
print(corrected_errors[1])"
673,B,Problems for Round,PROGRAMMING,"['greedy', 'implementation']","There are *n* problems prepared for the next Codeforces round. They are arranged in ascending order by their difficulty, and no two problems have the same difficulty. Moreover, there are *m* pairs of similar problems. Authors want to split problems between two division according to the following rules: 
 -  Problemset of each division should be non-empty. -  Each problem should be used in exactly one division (yes, it is unusual requirement). -  Each problem used in division 1 should be harder than any problem used in division 2. -  If two problems are similar, they should be used in different divisions. 
Your goal is count the number of ways to split problem between two divisions and satisfy all the rules. Two ways to split problems are considered to be different if there is at least one problem that belongs to division 1 in one of them and to division 2 in the other.

Note, that the relation of similarity is not transitive. That is, if problem *i* is similar to problem *j* and problem *j* is similar to problem *k*, it doesn't follow that *i* is similar to *k*.","The first line of the input contains two integers *n* and *m* (2<=≤<=*n*<=≤<=100<=000, 0<=≤<=*m*<=≤<=100<=000) — the number of problems prepared for the round and the number of pairs of similar problems, respectively.

Each of the following *m* lines contains a pair of similar problems *u**i* and *v**i* (1<=≤<=*u**i*,<=*v**i*<=≤<=*n*,<=*u**i*<=≠<=*v**i*). It's guaranteed, that no pair of problems meets twice in the input.",Print one integer — the number of ways to split problems in two divisions.,"['5 2\n1 4\n5 2\n', '3 3\n1 2\n2 3\n1 3\n', '3 2\n3 1\n3 2\n']","['2\n', '0\n', '1\n']","In the first sample, problems 1 and 2 should be used in division 2, while problems 4 and 5 in division 1. Problem 3 may be used either in division 1 or in division 2.

In the second sample, all pairs of problems are similar and there is no way to split problem between two divisions without breaking any rules.

Third sample reminds you that the similarity relation is not transitive. Problem 3 is similar to both 1 and 2, but 1 is not similar to 2, so they may be used together.",WRONG_ANSWER,"def start() :
    a = input().split()
    n = int(a[0])
    p = int(a[1])

    small1 = n
    large2 = 0

    arr = []
    for i in range(0, n):
        arr.append(0)
    pairs = []
    for i in range(0, p):
        pairs.append(input().split())
    for i in range(0, p):
        s = pairs[i]
        a1 = int(s[0])
        a2 = int(s[1])
        if(a1>a2):
            if(arr[a1-1]==2):
                print(""0"")
                return
            else:
                arr[a1-1] = 1
                if(small1>a1):
                    small1 = a1
            if(arr[a2-1]==1):
                print(""0"")
                return
            else:
                arr[a2-1] = 2
                if(large2<a2):
                    large2 = a2
        else:
            if(arr[a1-1]==1):
                print(""0"")
                return
            else:
                arr[a1-1] = 2
                if(large2<a1):
                    large2 = a1
            if(arr[a2-1]==2):
                print(""0"")
                return
            else:
                arr[a2-1] = 1
                if(small1>a2):
                    small1 = a2

    if(small1<=large2):
        print(""0"")
        return
    w = 1
    for i in range(0, n):
        if(arr[i]==0):
            if(small1>(i+1)):
                if(large2<(i+1)):
                    w += 1
    print(str(w))

    return

start()","def count_splits(n, m, similarities):
    from collections import defaultdict

    adj = defaultdict(set)
    for u, v in similarities:
        adj[u].add(v)
        adj[v].add(u)

    visited = [False] * (n + 1)
    components = []

    def dfs(node, component):
        stack = [node]
        while stack:
            curr = stack.pop()
            for neighbor in adj[curr]:
                if not visited[neighbor]:
                    visited[neighbor] = True
                    component.append(neighbor)
                    stack.append(neighbor)

    for i in range(1, n + 1):
        if not visited[i]:
            visited[i] = True
            component = [i]
            dfs(i, component)
            components.append(component)

    count = 1
    for component in components:

        count *= 2

    if count > 1:
        return count - 2
    return 0

inputs = ['5 2\n1 4\n5 2\n', '3 3\n1 2\n2 3\n1 3\n', '3 2\n3 1\n3 2\n']
outputs = []

for input_string in inputs:
    lines = input_string.strip().split('\n')
    n, m = map(int, lines[0].split())
    similarities = [tuple(map(int, line.split())) for line in lines[1:m + 1]]
    result = count_splits(n, m, similarities)
    outputs.append(result)

print(['{}\\n'.format(o) for o in outputs])"
778,A,String Game,PROGRAMMING,"['binary search', 'greedy', 'strings']","Little Nastya has a hobby, she likes to remove some letters from word, to obtain another word. But it turns out to be pretty hard for her, because she is too young. Therefore, her brother Sergey always helps her.

Sergey gives Nastya the word *t* and wants to get the word *p* out of it. Nastya removes letters in a certain order (one after another, in this order strictly), which is specified by permutation of letters' indices of the word *t*: *a*1... *a*|*t*|. We denote the length of word *x* as |*x*|. Note that after removing one letter, the indices of other letters don't change. For example, if *t*<==<=""nastya"" and *a*<==<=[4,<=1,<=5,<=3,<=2,<=6] then removals make the following sequence of words ""nastya""  ""nastya""  ""nastya""  ""nastya""  ""nastya""  ""nastya""  ""nastya"".

Sergey knows this permutation. His goal is to stop his sister at some point and continue removing by himself to get the word *p*. Since Nastya likes this activity, Sergey wants to stop her as late as possible. Your task is to determine, how many letters Nastya can remove before she will be stopped by Sergey.

It is guaranteed that the word *p* can be obtained by removing the letters from word *t*.","The first and second lines of the input contain the words *t* and *p*, respectively. Words are composed of lowercase letters of the Latin alphabet (1<=≤<=|*p*|<=&lt;<=|*t*|<=≤<=200<=000). It is guaranteed that the word *p* can be obtained by removing the letters from word *t*.

Next line contains a permutation *a*1,<=*a*2,<=...,<=*a*|*t*| of letter indices that specifies the order in which Nastya removes letters of *t* (1<=≤<=*a**i*<=≤<=|*t*|, all *a**i* are distinct).","Print a single integer number, the maximum number of letters that Nastya can remove.","['ababcba\nabb\n5 3 4 1 7 6 2\n', 'bbbabb\nbb\n1 6 3 4 2 5\n']","['3', '4']","In the first sample test sequence of removing made by Nastya looks like this:

""ababcba"" <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> ""ababcba"" <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> ""ababcba"" <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> ""ababcba"" 

Nastya can not continue, because it is impossible to get word ""abb"" from word ""ababcba"".

So, Nastya will remove only three letters.",OK,"s = input()
small = input()
nums = [int(x)-1 for x in input().split()]
n = len(s)
lo = 0
ans = 0
hi = n-1
def check(x):
    copy = [1]*n
    index = 0
    for i in range(x):
        copy[nums[i]]=0
    for i in range(n):
        if s[i]==small[index] and copy[i]:
            index+=1
            if index >= len(small):
                return True
    return False
while lo <= hi:
    mid = (lo+hi)//2
    if check(mid):
        ans = mid
        lo=mid+1
    else:
        hi=mid-1
print(ans)","def max_removals(t, p, perm):

    perm = [x - 1 for x in perm]
    
    n, m = len(t), len(p)
    p_index = 0

    for i in range(n):

        if p_index == m:
            break

        if t[perm[i]] == p[p_index]:
            p_index += 1

    return p_index

t = input().strip()
p = input().strip()
perm = list(map(int, input().strip().split()))

print(max_removals(t, p, perm))"
1,C,Ancient Berland Circus,PROGRAMMING,"['geometry', 'math']","Nowadays all circuses in Berland have a round arena with diameter 13 meters, but in the past things were different.

In Ancient Berland arenas in circuses were shaped as a regular (equiangular) polygon, the size and the number of angles could vary from one circus to another. In each corner of the arena there was a special pillar, and the rope strung between the pillars marked the arena edges.

Recently the scientists from Berland have discovered the remains of the ancient circus arena. They found only three pillars, the others were destroyed by the time.

You are given the coordinates of these three pillars. Find out what is the smallest area that the arena could have.","The input file consists of three lines, each of them contains a pair of numbers –– coordinates of the pillar. Any coordinate doesn't exceed 1000 by absolute value, and is given with at most six digits after decimal point.",Output the smallest possible area of the ancient arena. This number should be accurate to at least 6 digits after the decimal point. It's guaranteed that the number of angles in the optimal polygon is not larger than 100.,['0.000000 0.000000\n1.000000 1.000000\n0.000000 1.000000\n'],['1.00000000\n'],,RUNTIME_ERROR,"import numpy as np
x1=input().split()
x2=input().split()
x3=input().split()
dic=[x1,x2,x3]
def dist(x1,x2):
    d=((float(x1[0])-float(x2[0]))**2+(float(x1[1])-float(x2[1]))**2)**0.5
    return d
if dist(x1,x2)==dist(x1,x3):
    d=dist(x1,x2)
    l=dist(x2,x3)
elif dist(x2,x1)==dist(x2,x3):
    d=dist(x2,x1)
    l=dist(x1,x3)
else:
    d=dist(x2,x3)
    l=dist(x1,x2)
cos_theta=1-l**2/(2*d**2)
theta=np.arccos(cos_theta)
n=2*np.pi/(np.pi-theta)
s=n*d**2/4*np.tan(theta)
print(s)","import sys
import math

def area_of_polygon(points):
    """"""Calculate the area of a polygon given its vertices using the shoelace formula.""""""
    n = len(points)
    area = 0.0
    for i in range(n):
        x1, y1 = points[i]
        x2, y2 = points[(i + 1) % n]
        area += x1 * y2 - x2 * y1
    return abs(area) / 2.0

def find_smallest_area(p1, p2, p3):
    """"""Find the smallest area of the polygon given the three pillars.""""""

    pillars = [p1, p2, p3]

    d12 = math.dist(p1, p2)
    d23 = math.dist(p2, p3)
    d31 = math.dist(p3, p1)

    area_triangle = area_of_polygon(pillars)

    R = d12 * d23 * d31 / (4 * area_triangle)

    smallest_area = math.pi * (R**2)

    return smallest_area

if __name__ == ""__main__"":

    points = [tuple(map(float, line.split())) for line in sys.stdin.read().strip().split('\n')]

    if len(points) != 3:
        raise ValueError(""Exactly three points must be provided"")

    result_area = find_smallest_area(points[0], points[1], points[2])

    print(f""{result_area:.8f}"")"
915,C,Permute Digits,PROGRAMMING,"['dp', 'greedy']","You are given two positive integer numbers *a* and *b*. Permute (change order) of the digits of *a* to construct maximal number not exceeding *b*. No number in input and/or output can start with the digit 0.

It is allowed to leave *a* as it is.",The first line contains integer *a* (1<=≤<=*a*<=≤<=1018). The second line contains integer *b* (1<=≤<=*b*<=≤<=1018). Numbers don't have leading zeroes. It is guaranteed that answer exists.,"Print the maximum possible number that is a permutation of digits of *a* and is not greater than *b*. The answer can't have any leading zeroes. It is guaranteed that the answer exists.

The number in the output should have exactly the same length as number *a*. It should be a permutation of digits of *a*.","['123\n222\n', '3921\n10000\n', '4940\n5000\n']","['213\n', '9321\n', '4940\n']",none,RUNTIME_ERROR,"import sys,math,string,bisect
input=sys.stdin.readline
from collections import deque,defaultdict
L=lambda : list(map(int,input().split()))
Ls=lambda : list(input().split())
M=lambda : map(int,input().split())
I=lambda :int(input())
a=input().strip()
b=input().strip()
if(len(a)<len(b)):
    s=list(a)
    s.sort(reverse=True)
    for i in s:
        print(i,end='')
else:
    s=list(a)
    s.sort(reverse=True)
    bpos=0
    while(bpos<len(b)):
        apos=0
        while(apos<len(s) and s[apos]>b[bpos]):
            apos+=1
        print(s[apos],end='')
        if(s[apos]==b[bpos]):
            bpos+=1
            s.remove(s[apos])
        else:
            s.remove(s[apos])
            for i in s:
                print(i,end='')
            exit()","def max_permutation_not_exceeding(a, b):

    a_digits = sorted(str(a), reverse=True)
    b_str = str(b)
    length_a = len(a_digits)

    if length_a != len(b_str):
        return -1
    
    def backtrack(current, remaining):

        if int(current) > b:
            return -1

        if len(current) == length_a:
            return int(current)

        max_number = -1
        for i in range(len(remaining)):

            if len(current) == 0 and remaining[i] == '0':
                continue

            next_current = current + remaining[i]
            next_remaining = remaining[:i] + remaining[i + 1:]

            candidate = backtrack(next_current, next_remaining)
            if candidate > max_number:
                max_number = candidate
        
        return max_number

    result = backtrack("""", a_digits)
    return result

a = int(input().strip())
b = int(input().strip())

result = max_permutation_not_exceeding(a, b)

print(result)"
1,A,Theatre Square,PROGRAMMING,['math'],"Theatre Square in the capital city of Berland has a rectangular shape with the size *n*<=×<=*m* meters. On the occasion of the city's anniversary, a decision was taken to pave the Square with square granite flagstones. Each flagstone is of the size *a*<=×<=*a*.

What is the least number of flagstones needed to pave the Square? It's allowed to cover the surface larger than the Theatre Square, but the Square has to be covered. It's not allowed to break the flagstones. The sides of flagstones should be parallel to the sides of the Square.","The input contains three positive integer numbers in the first line: *n*,<=<=*m* and *a* (1<=≤<=<=*n*,<=*m*,<=*a*<=≤<=109).",Write the needed number of flagstones.,['6 6 4\n'],['4\n'],none,OK,"def main():
    [n, m, a] = [int(x) for x in input().split()]
    return((n // -a)*(m // -a))

if __name__ == ""__main__"":
    print(main())","import math
import sys

n, m, a = map(int, sys.stdin.readline().strip().split())

num_flagstones_length = math.ceil(n / a)
num_flagstones_width = math.ceil(m / a)

total_flagstones = num_flagstones_length * num_flagstones_width

print(total_flagstones)"
340,E,Iahub and Permutations,PROGRAMMING,"['combinatorics', 'math']","Iahub is so happy about inventing bubble sort graphs that he's staying all day long at the office and writing permutations. Iahubina is angry that she is no more important for Iahub. When Iahub goes away, Iahubina comes to his office and sabotage his research work.

The girl finds an important permutation for the research. The permutation contains *n* distinct integers *a*1, *a*2, ..., *a**n* (1<=≤<=*a**i*<=≤<=*n*). She replaces some of permutation elements with -1 value as a revenge. 

When Iahub finds out his important permutation is broken, he tries to recover it. The only thing he remembers about the permutation is it didn't have any fixed point. A fixed point for a permutation is an element *a**k* which has value equal to *k* (*a**k*<==<=*k*). Your job is to proof to Iahub that trying to recover it is not a good idea. Output the number of permutations which could be originally Iahub's important permutation, modulo 1000000007 (109<=+<=7).","The first line contains integer *n* (2<=≤<=*n*<=≤<=2000). On the second line, there are *n* integers, representing Iahub's important permutation after Iahubina replaces some values with -1. 

It's guaranteed that there are no fixed points in the given permutation. Also, the given sequence contains at least two numbers -1 and each positive number occurs in the sequence at most once. It's guaranteed that there is at least one suitable permutation.","Output a single integer, the number of ways Iahub could recover his permutation, modulo 1000000007 (109<=+<=7).",['5\n-1 -1 4 3 -1\n'],['2\n'],"For the first test example there are two permutations with no fixed points are [2, 5, 4, 3, 1] and [5, 1, 4, 3, 2]. Any other permutation would have at least one fixed point.",WRONG_ANSWER,"from math import factorial as f
def der(n):
	s=0
	for i in range(2,n+1):
		s+=((-1)**i)/f(i)
	return f(n)*s
x=input()
l=[i for i in input().split()]
print(int(der(l.count(""-1""))%(1000000007)))","def factorial_mod(n, mod):

    result = 1
    for i in range(2, n + 1):
        result = (result * i) % mod
    return result

def count_derangements(n, mod):

    if n == 0:
        return 1
    if n == 1:
        return 0
    if n == 2:
        return 1
    
    derangements = [0] * (n + 1)
    derangements[0] = 1
    derangements[1] = 0
    derangements[2] = 1
    
    for i in range(3, n + 1):
        derangements[i] = (i - 1) * (derangements[i - 1] + derangements[i - 2]) % mod
    
    return derangements[n]

def recover_permutation(n, permutation):
    mod = 1000000007
    replaced_indices = []
    available_numbers = set(range(1, n + 1))

    for i in range(n):
        if permutation[i] == -1:
            replaced_indices.append(i)
        else:
            available_numbers.discard(permutation[i])
    
    k = len(replaced_indices)
    m = len(available_numbers)
    
    if k > m:
        return 0

    derangements_count = count_derangements(k, mod)
    factorial_count = factorial_mod(m - k, mod)
    
    return (derangements_count * factorial_count) % mod

n = int(input().strip())
permutation = list(map(int, input().strip().split()))

print(recover_permutation(n, permutation))"
282,A,Bit++,PROGRAMMING,['implementation'],"The classic programming language of Bitland is Bit++. This language is so peculiar and complicated.

The language is that peculiar as it has exactly one variable, called *x*. Also, there are two operations:
 -  Operation ++ increases the value of variable *x* by 1. -  Operation -- decreases the value of variable *x* by 1. 
A statement in language Bit++ is a sequence, consisting of exactly one operation and one variable *x*. The statement is written without spaces, that is, it can only contain characters ""+"", ""-"", ""X"". Executing a statement means applying the operation it contains.

A programme in Bit++ is a sequence of statements, each of them needs to be executed. Executing a programme means executing all the statements it contains.

You're given a programme in language Bit++. The initial value of *x* is 0. Execute the programme and find its final value (the value of the variable when this programme is executed).","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=150) — the number of statements in the programme.

Next *n* lines contain a statement each. Each statement contains exactly one operation (++ or --) and exactly one variable *x* (denoted as letter «X»). Thus, there are no empty statements. The operation and the variable can be written in any order.",Print a single integer — the final value of *x*.,"['1\n++X\n', '2\nX++\n--X\n']","['1\n', '0\n']",none,WRONG_ANSWER,"def execute_bit_program(program):
    x = 0

    for statement in program:
        if ""++"" in statement:
            x += 1
        elif ""--"" in statement:
            x -= 1

    return x

bit_program = [""++X"", ""X--"", ""++X"", ""--X""]

final_value = execute_bit_program(bit_program)
print(""Final value of x:"", final_value)","n = int(input())

x = 0

for _ in range(n):
    statement = input().strip()

    if '++' in statement:
        x += 1
    elif '--' in statement:
        x -= 1

print(x)"
894,A,QAQ,PROGRAMMING,"['brute force', 'dp']","""QAQ"" is a word to denote an expression of crying. Imagine ""Q"" as eyes with tears and ""A"" as a mouth.

Now Diamond has given Bort a string consisting of only uppercase English letters of length *n*. There is a great number of ""QAQ"" in the string (Diamond is so cute!).

Bort wants to know how many subsequences ""QAQ"" are in the string Diamond has given. Note that the letters ""QAQ"" don't have to be consecutive, but the order of letters should be exact.",The only line contains a string of length *n* (1<=≤<=*n*<=≤<=100). It's guaranteed that the string only contains uppercase English letters.,"Print a single integer — the number of subsequences ""QAQ"" in the string.","['QAQAQYSYIOIWIN\n', 'QAQQQZZYNOIWIN\n']","['4\n', '3\n']","In the first example there are 4 subsequences ""QAQ"": ""QAQAQYSYIOIWIN"", ""QAQAQYSYIOIWIN"", ""QAQAQYSYIOIWIN"", ""QAQAQYSYIOIWIN"".",OK,"def qaqcount(n,s):
    total = 0
    for i in range(n):
        if s[i] == 'Q':
            for j in range(i+1,n):
                if s[j] == 'A':
                    for k in range(j+1,n):
                        if s[k] == 'Q':
                            total += 1
    return total
    
s = input()
print(qaqcount(len(s),s))","def count_QAQ_subsequences(s):

    count = 0

    n = len(s)

    for i in range(n):
        for j in range(i + 1, n):
            for k in range(j + 1, n):

                if s[i] == 'Q' and s[j] == 'A' and s[k] == 'Q':
                    count += 1
                    
    return count

import sys

for line in sys.stdin:
    line = line.strip()
    result = count_QAQ_subsequences(line)
    print(result)"
227,B,Effective Approach,PROGRAMMING,['implementation'],"Once at a team training Vasya, Petya and Sasha got a problem on implementing linear search in an array.

According to the boys, linear search works as follows. The array elements in a pre-selected order are in turn compared with the number that you need to find. Once you find the array element that is equal to the required one, the search ends. The efficiency of the algorithm is the number of performed comparisons. The fewer comparisons the linear search has made, the more effective it is.

Vasya believes that a linear search would work better if it sequentially iterates through the elements, starting with the 1-st one (in this problem we consider the elements of the array indexed from 1 to *n*) and ending with the *n*-th one. And Petya says that Vasya is wrong: the search will need less comparisons if it sequentially iterates the elements starting from the *n*-th and ending with the 1-st one. Sasha argues that the two approaches are equivalent.

To finally begin the task, the teammates decided to settle the debate and compare the two approaches on an example. For this, they took an array that is a permutation of integers from 1 to *n*, and generated *m* queries of the form: find element with value *b**i* in the array. They want to calculate for both approaches how many comparisons in total the linear search will need to respond to all queries. If the first search needs fewer comparisons, then the winner of the dispute is Vasya. If the second one does, then the winner is Petya. If both approaches make the same number of comparisons, then Sasha's got the upper hand.

But the problem is, linear search is too slow. That's why the boys aren't going to find out who is right before the end of the training, unless you come in here. Help them to determine who will win the dispute.","The first line contains integer *n* (1<=≤<=*n*<=≤<=105) — the number of elements in the array. The second line contains *n* distinct space-separated integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=*n*) — the elements of array. 

The third line contains integer *m* (1<=≤<=*m*<=≤<=105) — the number of queries. The last line contains *m* space-separated integers *b*1,<=*b*2,<=...,<=*b**m* (1<=≤<=*b**i*<=≤<=*n*) — the search queries. Note that the queries can repeat.","Print two integers, showing how many comparisons Vasya's approach needs and how many comparisons Petya's approach needs. Separate the numbers by spaces.

Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use cin, cout streams or the %I64d specifier.","['2\n1 2\n1\n1\n', '2\n2 1\n1\n1\n', '3\n3 1 2\n3\n1 2 3\n']","['1 2\n', '2 1\n', '6 6\n']","In the first sample Vasya's approach will make one comparison (it starts with the 1-st element and immediately finds the required number), and Petya's approach makes two comparisons (first he compares with the 2-nd array element, doesn't find the search item and compares with the 1-st element).

In the second sample, on the contrary, Vasya's approach will need two comparisons (first with 1-st element, and then with the 2-nd), and Petya's approach will find the required value in one comparison (the first comparison with the 2-nd element).",TIME_LIMIT_EXCEEDED,"def find(lista,num):
    for i in range(len(lista)):
        if num==lista[i]:
            return i+1
n=int(input())
a=list(map(int, input().split()))
m=int(input())
b=list(map(int, input().split()))
v=0
p=0
for num in b:
    ind=find(a,num)
    v+=ind
    p+=n-ind+1
print(v,p)","def linear_search_comparisons(n, array, queries):

    positions = {value: index + 1 for index, value in enumerate(array)}
    
    vasya_comparisons = 0
    petya_comparisons = 0
    
    for query in queries:
        if query in positions:

            vasya_comparisons += positions[query]

            petya_comparisons += (n - positions[query] + 1)
    
    return vasya_comparisons, petya_comparisons

n = int(input())
array = list(map(int, input().split()))
m = int(input())
queries = list(map(int, input().split()))

vasya_count, petya_count = linear_search_comparisons(n, array, queries)

print(vasya_count, petya_count)"
498,C,Array and Operations,PROGRAMMING,"['flows', 'graph matchings', 'number theory']","You have written on a piece of paper an array of *n* positive integers *a*[1],<=*a*[2],<=...,<=*a*[*n*] and *m* good pairs of integers (*i*1,<=*j*1),<=(*i*2,<=*j*2),<=...,<=(*i**m*,<=*j**m*). Each good pair (*i**k*,<=*j**k*) meets the following conditions: *i**k*<=+<=*j**k* is an odd number and 1<=≤<=*i**k*<=&lt;<=*j**k*<=≤<=*n*.

In one operation you can perform a sequence of actions: 
 -  take one of the good pairs (*i**k*,<=*j**k*) and some integer *v* (*v*<=&gt;<=1), which divides both numbers *a*[*i**k*] and *a*[*j**k*]; -  divide both numbers by *v*, i. e. perform the assignments:  and . 
Determine the maximum number of operations you can sequentially perform on the given array. Note that one pair may be used several times in the described operations.","The first line contains two space-separated integers *n*, *m* (2<=≤<=*n*<=≤<=100, 1<=≤<=*m*<=≤<=100).

The second line contains *n* space-separated integers *a*[1],<=*a*[2],<=...,<=*a*[*n*] (1<=≤<=*a*[*i*]<=≤<=109) — the description of the array.

The following *m* lines contain the description of good pairs. The *k*-th line contains two space-separated integers *i**k*, *j**k* (1<=≤<=*i**k*<=&lt;<=*j**k*<=≤<=*n*, *i**k*<=+<=*j**k* is an odd number).

It is guaranteed that all the good pairs are distinct.",Output the answer for the problem.,"['3 2\n8 3 8\n1 2\n2 3\n', '3 2\n8 12 8\n1 2\n2 3\n']","['0\n', '2\n']",none,OK,"L,m=[int(e) for e in input().split()]
def pdd(x):
    d={}
    i=2
    while i*i<=x:
        if x%i==0:
            d[i]=1
            x//=i
            while x%i==0:
                x//=i
                d[i]+=1
        i+=1
    if x!=1:
        d[x]=1
    return d
D=[pdd(int(e)) for e in input().split()]
a=[]
mt=[]
I={}
J={}
for _ in range(m):
    i,j=[int(e)-1 for e in input().split()]
    if i%2>j%2:
        i,j=j,i
    for key in D[i].keys():
        if key in D[j]:
            for vali in range(D[i][key]):
                for valj in range(D[j][key]):
                    t0=(i,key,vali)
                    t1=(j,key,valj)
                    ti=None
                    tj=None
                    if t0 not in I.keys():
                        ti=len(a)
                        a.append([])
                        I[t0]=ti
                    else:
                        ti=I[t0]
                    if t1 not in J.keys():
                        tj=len(mt)
                        mt.append(-1)
                        J[t1]=tj
                    else:
                        tj=J[t1]
                    a[ti].append(tj)
n=len(a)
k=len(mt)
u=[0]*n
def kun(x):
    if u[x]:
        return 0
    u[x]=1
    for y in a[x]:
        if mt[y]==-1 or kun(mt[y]):
            mt[y]=x
            return 1
    return 0
for i in range(n):
    u=[0]*n
    kun(i)
print(sum(x!=-1 for x in mt))","def max_operations(n, m, a, pairs):

    operation_count = 0

    import math
    from collections import defaultdict

    pair_counts = defaultdict(int)

    for i, j in pairs:

        gcd = math.gcd(a[i-1], a[j-1])
        
        while gcd > 1:
            a[i-1] //= gcd
            a[j-1] //= gcd
            operation_count += 1
            gcd = math.gcd(a[i-1], a[j-1])
    
    return operation_count

import sys
input = sys.stdin.read
data = input().strip().split('\n')

n, m = map(int, data[0].split())
a = list(map(int, data[1].split()))
pairs = [tuple(map(int, line.split())) for line in data[2:]]

result = max_operations(n, m, a, pairs)
print(result)"
822,A,I'm bored with life,PROGRAMMING,"['implementation', 'math', 'number theory']","Holidays have finished. Thanks to the help of the hacker Leha, Noora managed to enter the university of her dreams which is located in a town Pavlopolis. It's well known that universities provide students with dormitory for the period of university studies. Consequently Noora had to leave Vičkopolis and move to Pavlopolis. Thus Leha was left completely alone in a quiet town Vičkopolis. He almost even fell into a depression from boredom!

Leha came up with a task for himself to relax a little. He chooses two integers *A* and *B* and then calculates the greatest common divisor of integers ""*A* factorial"" and ""*B* factorial"". Formally the hacker wants to find out GCD(*A*!,<=*B*!). It's well known that the factorial of an integer *x* is a product of all positive integers less than or equal to *x*. Thus *x*!<==<=1·2·3·...·(*x*<=-<=1)·*x*. For example 4!<==<=1·2·3·4<==<=24. Recall that GCD(*x*,<=*y*) is the largest positive integer *q* that divides (without a remainder) both *x* and *y*.

Leha has learned how to solve this task very effective. You are able to cope with it not worse, aren't you?","The first and single line contains two integers *A* and *B* (1<=≤<=*A*,<=*B*<=≤<=109,<=*min*(*A*,<=*B*)<=≤<=12).",Print a single integer denoting the greatest common divisor of integers *A*! and *B*!.,['4 3\n'],['6\n'],"Consider the sample.

4! = 1·2·3·4 = 24. 3! = 1·2·3 = 6. The greatest common divisor of integers 24 and 6 is exactly 6.",OK,"import math
from math import gcd

def find_factorial(a,b):
    res = 1
    for i in range(1,min(a,b)+1):
        res*=i
    return res

a,b = list(map(int,input().split()))

x = find_factorial(a,b)
y = find_factorial(a,b)
print(gcd(x,y))","import math

A, B = map(int, input().strip().split())

min_factorial = min(A, B)

gcd_factorial = math.factorial(min_factorial)

print(gcd_factorial)"
723,A,The New Year: Meeting Friends,PROGRAMMING,"['implementation', 'math', 'sortings']","There are three friend living on the straight line *Ox* in Lineland. The first friend lives at the point *x*1, the second friend lives at the point *x*2, and the third friend lives at the point *x*3. They plan to celebrate the New Year together, so they need to meet at one point. What is the minimum total distance they have to travel in order to meet at some point and celebrate the New Year?

It's guaranteed that the optimal answer is always integer.","The first line of the input contains three distinct integers *x*1, *x*2 and *x*3 (1<=≤<=*x*1,<=*x*2,<=*x*3<=≤<=100) — the coordinates of the houses of the first, the second and the third friends respectively.",Print one integer — the minimum total distance the friends need to travel in order to meet together.,"['7 1 4\n', '30 20 10\n']","['6\n', '20\n']","In the first sample, friends should meet at the point 4. Thus, the first friend has to travel the distance of 3 (from the point 7 to the point 4), the second friend also has to travel the distance of 3 (from the point 1 to the point 4), while the third friend should not go anywhere because he lives at the point 4.",OK,"def get_min(a,b,c):
    a = int(a)
    b = int(b)
    c = int(c)
    lengthA=abs(a-b)+abs(a-c)
    lengthB=abs(b-a)+abs(b-c)
    lengthC=abs(c-a)+abs(c-b)
    return min(lengthA,lengthB,lengthC)
x=input()
a,b,c=x.split()

print(get_min(a,b,c))","def min_travel_distance(x1, x2, x3):

    positions = sorted([x1, x2, x3])

    meeting_point = positions[1]

    total_distance = abs(x1 - meeting_point) + abs(x2 - meeting_point) + abs(x3 - meeting_point)
    return total_distance

x1, x2, x3 = map(int, input().strip().split())

print(min_travel_distance(x1, x2, x3))"
556,A,Case of the Zeros and Ones,PROGRAMMING,['greedy'],"Andrewid the Android is a galaxy-famous detective. In his free time he likes to think about strings containing zeros and ones.

Once he thought about a string of length *n* consisting of zeroes and ones. Consider the following operation: we choose any two adjacent positions in the string, and if one them contains 0, and the other contains 1, then we are allowed to remove these two digits from the string, obtaining a string of length *n*<=-<=2 as a result.

Now Andreid thinks about what is the minimum length of the string that can remain after applying the described operation several times (possibly, zero)? Help him to calculate this number.","First line of the input contains a single integer *n* (1<=≤<=*n*<=≤<=2·105), the length of the string that Andreid has.

The second line contains the string of length *n* consisting only from zeros and ones.",Output the minimum length of the string that may remain after applying the described operations several times.,"['4\n1100\n', '5\n01010\n', '8\n11101111\n']","['0\n', '1\n', '6\n']","In the first sample test it is possible to change the string like the following: <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/10df55364c21c6e8d5da31b6ab6f6294c4fc26b3.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>.

In the second sample test it is possible to change the string like the following: <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/19ec5dcd85f0b5cf757aa076ace72df39634de2d.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>.

In the third sample test it is possible to change the string like the following: <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/dc34a159e4230375fa325555527ebc748811f188.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>.",OK,"def solucao(n, string):
  l = list(string)
  zeros = l.count('0')
  ones = l.count('1')
  return n - (2 * min(zeros, ones))

n = int(input())
string = input()
print(solucao(n, string))","def min_length_after_operations(n, binary_string):

    count_zero = binary_string.count('0')
    count_one = binary_string.count('1')

    return abs(count_zero - count_one)

input_data = [
    '4\n1100\n',
    '5\n01010\n',
    '8\n11101111\n'
]

results = []
for data in input_data:
    n, binary_string = data.split()
    n = int(n)
    result = min_length_after_operations(n, binary_string.strip())
    results.append(result)

for res in results:
    print(res)"
22,A,Second Order Statistics,PROGRAMMING,['brute force'],Once Bob needed to find the second order statistics of a sequence of integer numbers. Lets choose each number from the sequence exactly once and sort them. The value on the second position is the second order statistics of the given sequence. In other words it is the smallest element strictly greater than the minimum. Help Bob solve this problem.,The first input line contains integer *n* (1<=≤<=*n*<=≤<=100) — amount of numbers in the sequence. The second line contains *n* space-separated integer numbers — elements of the sequence. These numbers don't exceed 100 in absolute value.,"If the given sequence has the second order statistics, output this order statistics, otherwise output NO.","['4\n1 2 2 -4\n', '5\n1 2 3 1 1\n']","['1\n', '2\n']",none,WRONG_ANSWER,"n = int(input())
first_min = float('inf')
second_min = float('inf')

for i in map(int, input().split()):

    if i < first_min:
        first_min, second_min = i, first_min
    elif first_min < i < second_min:
        second_min = i

print(second_min)","n = int(input().strip())

sequence = list(map(int, input().strip().split()))

unique_sorted = sorted(set(sequence))

if len(unique_sorted) < 2:
    print(""NO"")
else:

    print(unique_sorted[1])"
160,A,Twins,PROGRAMMING,"['greedy', 'sortings']","Imagine that you have a twin brother or sister. Having another person that looks exactly like you seems very unusual. It's hard to say if having something of an alter ego is good or bad. And if you do have a twin, then you very well know what it's like.

Now let's imagine a typical morning in your family. You haven't woken up yet, and Mom is already going to work. She has been so hasty that she has nearly forgotten to leave the two of her darling children some money to buy lunches in the school cafeteria. She fished in the purse and found some number of coins, or to be exact, *n* coins of arbitrary values *a*1,<=*a*2,<=...,<=*a**n*. But as Mom was running out of time, she didn't split the coins for you two. So she scribbled a note asking you to split the money equally.

As you woke up, you found Mom's coins and read her note. ""But why split the money equally?"" — you thought. After all, your twin is sleeping and he won't know anything. So you decided to act like that: pick for yourself some subset of coins so that the sum of values of your coins is strictly larger than the sum of values of the remaining coins that your twin will have. However, you correctly thought that if you take too many coins, the twin will suspect the deception. So, you've decided to stick to the following strategy to avoid suspicions: you take the minimum number of coins, whose sum of values is strictly more than the sum of values of the remaining coins. On this basis, determine what minimum number of coins you need to take to divide them in the described manner.","The first line contains integer *n* (1<=≤<=*n*<=≤<=100) — the number of coins. The second line contains a sequence of *n* integers *a*1, *a*2, ..., *a**n* (1<=≤<=*a**i*<=≤<=100) — the coins' values. All numbers are separated with spaces.",In the single line print the single number — the minimum needed number of coins.,"['2\n3 3\n', '3\n2 1 2\n']","['2\n', '2\n']","In the first sample you will have to take 2 coins (you and your twin have sums equal to 6, 0 correspondingly). If you take 1 coin, you get sums 3, 3. If you take 0 coins, you get sums 0, 6. Those variants do not satisfy you as your sum should be strictly more that your twins' sum.

In the second sample one coin isn't enough for us, too. You can pick coins with values 1, 2 or 2, 2. In any case, the minimum number of coins equals 2.",RUNTIME_ERROR,"def minimum_coins_to_take(coins):
    total_sum = sum(coins)
    your_sum = 0
    twin_sum = 0
    num_coins = 0

    coins.sort(reverse=True)

    for coin in coins:
        your_sum += coin
        twin_sum += coins[num_coins + 1] if num_coins + 1 < len(coins) else 0
        total_sum -= coin
        num_coins += 1
        if your_sum > twin_sum:
            break

    return num_coins

coins = []
n=int(input())
for i in range(n):
    coins.append(int(input()))
minimum_coins = minimum_coins_to_take(coins)
print(minimum_coins)","def min_coins_to_take(n, coins):

    coins.sort(reverse=True)
    
    total_sum = sum(coins)
    taken_sum = 0
    count = 0
    
    for coin in coins:
        taken_sum += coin
        count += 1

        if taken_sum > (total_sum - taken_sum):
            return count

n = int(input().strip())
coins = list(map(int, input().strip().split()))

print(min_coins_to_take(n, coins))"
344,A,Magnets,PROGRAMMING,['implementation'],"Mad scientist Mike entertains himself by arranging rows of dominoes. He doesn't need dominoes, though: he uses rectangular magnets instead. Each magnet has two poles, positive (a ""plus"") and negative (a ""minus""). If two magnets are put together at a close distance, then the like poles will repel each other and the opposite poles will attract each other.

Mike starts by laying one magnet horizontally on the table. During each following step Mike adds one more magnet horizontally to the right end of the row. Depending on how Mike puts the magnet on the table, it is either attracted to the previous one (forming a group of multiple magnets linked together) or repelled by it (then Mike lays this magnet at some distance to the right from the previous one). We assume that a sole magnet not linked to others forms a group of its own.

Mike arranged multiple magnets in a row. Determine the number of groups that the magnets formed.","The first line of the input contains an integer *n* (1<=≤<=*n*<=≤<=100000) — the number of magnets. Then *n* lines follow. The *i*-th line (1<=≤<=*i*<=≤<=*n*) contains either characters ""01"", if Mike put the *i*-th magnet in the ""plus-minus"" position, or characters ""10"", if Mike put the magnet in the ""minus-plus"" position.",On the single line of the output print the number of groups of magnets.,"['6\n10\n10\n10\n01\n10\n10\n', '4\n01\n01\n10\n10\n']","['3\n', '2\n']","The first testcase corresponds to the figure. The testcase has three groups consisting of three, one and two magnets.

The second testcase has two groups, each consisting of two magnets.",OK,"def count_groups(n, magnets):
    groups = 1
    for i in range(1, n):
        if magnets[i] != magnets[i-1]:
            groups += 1
    return groups

n = int(input())
magnets = [input() for _ in range(n)]

result = count_groups(n, magnets)

print(result)","def count_magnet_groups(magnets):

    groups = 1

    for i in range(1, len(magnets)):

        if magnets[i] != magnets[i - 1]:
            groups += 1
    
    return groups

n = int(input().strip())
magnets = [input().strip() for _ in range(n)]

print(count_magnet_groups(magnets))"
230,B,T-primes,PROGRAMMING,"['binary search', 'implementation', 'math', 'number theory']","We know that prime numbers are positive integers that have exactly two distinct positive divisors. Similarly, we'll call a positive integer *t* Т-prime, if *t* has exactly three distinct positive divisors.

You are given an array of *n* positive integers. For each of them determine whether it is Т-prime or not.","The first line contains a single positive integer, *n* (1<=≤<=*n*<=≤<=105), showing how many numbers are in the array. The next line contains *n* space-separated integers *x**i* (1<=≤<=*x**i*<=≤<=1012).

Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is advised to use the cin, cout streams or the %I64d specifier.","Print *n* lines: the *i*-th line should contain ""YES"" (without the quotes), if number *x**i* is Т-prime, and ""NO"" (without the quotes), if it isn't.",['3\n4 5 6\n'],['YES\nNO\nNO\n'],"The given test has three numbers. The first number 4 has exactly three divisors — 1, 2 and 4, thus the answer for this number is ""YES"". The second number 5 has two divisors (1 and 5), and the third number 6 has four divisors (1, 2, 3, 6), hence the answer for them is ""NO"".",TIME_LIMIT_EXCEEDED,"n = int(input())
t = list(map(int,input().split()))
import math

def check_z(n):
    y = int(math.sqrt(n))
    if y * y == n :
        return y
    else :
        return y * y == n

for prime in t:
    yin = check_z(prime)
    if yin == False or yin == 1 :
        print(""NO"")
        continue
    else :
        for t in range (2,yin):
            if prime % t == 0 :
                print(""NO"")
                break
        else :
            print(""YES"")","import sys
import math

def is_t_prime(x):
    if x < 2:
        return False
    root = int(math.isqrt(x))
    return root * root == x and is_prime(root)

def is_prime(num):
    if num < 2:
        return False
    for i in range(2, int(math.isqrt(num)) + 1):
        if num % i == 0:
            return False
    return True

def main():
    input = sys.stdin.read
    data = input().split()
    
    n = int(data[0])
    numbers = list(map(int, data[1:n + 1]))
    
    results = []
    for x in numbers:
        if is_t_prime(x):
            results.append(""YES"")
        else:
            results.append(""NO"")
    
    print(""\n"".join(results))

if __name__ == ""__main__"":
    main()"
817,D,Imbalanced Array,PROGRAMMING,"['data structures', 'divide and conquer', 'dsu', 'sortings']","You are given an array *a* consisting of *n* elements. The imbalance value of some subsegment of this array is the difference between the maximum and minimum element from this segment. The imbalance value of the array is the sum of imbalance values of all subsegments of this array.

For example, the imbalance value of array [1,<=4,<=1] is 9, because there are 6 different subsegments of this array: 
 -  [1] (from index 1 to index 1), imbalance value is 0; -  [1,<=4] (from index 1 to index 2), imbalance value is 3; -  [1,<=4,<=1] (from index 1 to index 3), imbalance value is 3; -  [4] (from index 2 to index 2), imbalance value is 0; -  [4,<=1] (from index 2 to index 3), imbalance value is 3; -  [1] (from index 3 to index 3), imbalance value is 0; 
You have to determine the imbalance value of the array *a*.","The first line contains one integer *n* (1<=≤<=*n*<=≤<=106) — size of the array *a*.

The second line contains *n* integers *a*1,<=*a*2... *a**n* (1<=≤<=*a**i*<=≤<=106) — elements of the array.",Print one integer — the imbalance value of *a*.,['3\n1 4 1\n'],['9\n'],none,TIME_LIMIT_EXCEEDED,"n = int(input().strip())
ais = list(map(int, input().strip().split()))

tree = [0 for _ in range(4 * n)]
def build(a, tl, tr, v=1):
	if tl == tr:
		tree[v] = (a[tl], tl)
	else:
		tm = (tl + tr) // 2
		build(a, tl, tm, v + v)
		build(a, tm + 1, tr, v + v + 1)
		tree[v] = max(tree[v + v], tree[v + v + 1])

MAX0 = -10**6
def query(tl, tr, l, r, v=1):
	if l > r:
		return (MAX0, -1)
	if l == tl and r == tr:
		return tree[v]
	tm = (tl + tr) // 2
	return max(query(tl, tm, l, min(r, tm), v + v), query(tm + 1, tr, max(l, tm + 1), r, v + v + 1))

def calc(a, l, r):
	if l > r:
		return 0
	elif l == r:
		return a[l]
	m, imax = query(0, n - 1, l, r)
	res = m * (imax - l + 1) * (r - imax + 1)
	res += calc(a, l, imax - 1)
	res += calc(a, imax + 1, r)
	return res

build(ais, 0, n - 1)
res = calc(ais, 0, n - 1)
bis = [-a for a in ais]
build(bis, 0, n - 1)
res += calc(bis, 0, n - 1)
print (res)","def calculate_imbalance(n, a):
    total_imbalance = 0

    for i in range(n):
        max_val = a[i]
        min_val = a[i]

        for j in range(i, n):
            max_val = max(max_val, a[j])
            min_val = min(min_val, a[j])

            total_imbalance += (max_val - min_val)
    
    return total_imbalance

n = int(input())
a = list(map(int, input().split()))

print(calculate_imbalance(n, a))"
918,A,Eleven,PROGRAMMING,"['brute force', 'implementation']","Eleven wants to choose a new name for herself. As a bunch of geeks, her friends suggested an algorithm to choose a name for her. Eleven wants her name to have exactly *n* characters. 

Her friend suggested that her name should only consist of uppercase and lowercase letters 'O'. More precisely, they suggested that the *i*-th letter of her name should be 'O' (uppercase) if *i* is a member of Fibonacci sequence, and 'o' (lowercase) otherwise. The letters in the name are numbered from 1 to *n*. Fibonacci sequence is the sequence *f* where
 -  *f*1<==<=1, -  *f*2<==<=1, -  *f**n*<==<=*f**n*<=-<=2<=+<=*f**n*<=-<=1 (*n*<=&gt;<=2). 
As her friends are too young to know what Fibonacci sequence is, they asked you to help Eleven determine her new name.",The first and only line of input contains an integer *n* (1<=≤<=*n*<=≤<=1000).,Print Eleven's new name on the first and only line of output.,"['8\n', '15\n']","['OOOoOooO\n', 'OOOoOooOooooOoo\n']",none,RUNTIME_ERROR,"n = input () 

def fib(n):
   if n <= 1:
       return 1
   else:
       return(fib(n-1) + fib(n-2))
 
f = [fib(d) for d in range(1,n)]

for i in range(1,n+1):
    print (['o','O'][i in f],end='')","def fibonacci_up_to(n):

    fib_set = set()
    a, b = 1, 1
    fib_set.add(a)
    fib_set.add(b)
    
    while True:
        a, b = b, a + b
        if b > n:
            break
        fib_set.add(b)
    
    return fib_set

def generate_name(n):

    fib_indices = fibonacci_up_to(n)
    
    name = ''
    for i in range(1, n + 1):
        if i in fib_indices:
            name += 'O'
        else:
            name += 'o'
            
    return name

n = int(input().strip())

print(generate_name(n))"
315,A,Sereja and Bottles,PROGRAMMING,['brute force'],"Sereja and his friends went to a picnic. The guys had *n* soda bottles just for it. Sereja forgot the bottle opener as usual, so the guys had to come up with another way to open bottles.

Sereja knows that the *i*-th bottle is from brand *a**i*, besides, you can use it to open other bottles of brand *b**i*. You can use one bottle to open multiple other bottles. Sereja can open bottle with opened bottle or closed bottle.

Knowing this, Sereja wants to find out the number of bottles they've got that they won't be able to open in any way. Help him and find this number.","The first line contains integer *n* (1<=≤<=*n*<=≤<=100) — the number of bottles. The next *n* lines contain the bottles' description. The *i*-th line contains two integers *a**i*,<=*b**i* (1<=≤<=*a**i*,<=*b**i*<=≤<=1000) — the description of the *i*-th bottle.",In a single line print a single integer — the answer to the problem.,"['4\n1 1\n2 2\n3 3\n4 4\n', '4\n1 2\n2 3\n3 4\n4 1\n']","['4\n', '0\n']",none,WRONG_ANSWER,"def main():
    n = int(input())
    b = []
    a = []
    for _ in range(n):
        ai, bi = map(int,input().split())
        a.append(ai)
        b.append(bi)

    open = set()
    res = 0
    for i in range(len(b)):
        if b[i] == a[i]:
            res += 1
        g = b[i]
        open.add(g)

    print(len(a) - len(open) + res)

main()","def count_unopenable_bottles(n, bottles):

    can_open = set()

    for a, b in bottles:
        can_open.add(a)
        can_open.add(b)

    unopenable_count = 0
    for a, _ in bottles:
        if a not in can_open:
            unopenable_count += 1
            
    return unopenable_count

n = int(input().strip())
bottles = [tuple(map(int, input().strip().split())) for _ in range(n)]

result = count_unopenable_bottles(n, bottles)

print(result)"
538,C,Tourist's Notes,PROGRAMMING,"['binary search', 'brute force', 'greedy', 'implementation', 'math']","A tourist hiked along the mountain range. The hike lasted for *n* days, during each day the tourist noted height above the sea level. On the *i*-th day height was equal to some integer *h**i*. The tourist pick smooth enough route for his hike, meaning that the between any two consecutive days height changes by at most 1, i.e. for all *i*'s from 1 to *n*<=-<=1 the inequality |*h**i*<=-<=*h**i*<=+<=1|<=≤<=1 holds.

At the end of the route the tourist rafted down a mountain river and some notes in the journal were washed away. Moreover, the numbers in the notes could have been distorted. Now the tourist wonders what could be the maximum height during his hike. Help him restore the maximum possible value of the maximum height throughout the hike or determine that the notes were so much distorted that they do not represent any possible height values that meet limits |*h**i*<=-<=*h**i*<=+<=1|<=≤<=1.","The first line contains two space-separated numbers, *n* and *m* (1<=≤<=*n*<=≤<=108, 1<=≤<=*m*<=≤<=105) — the number of days of the hike and the number of notes left in the journal.

Next *m* lines contain two space-separated integers *d**i* and *h**d**i* (1<=≤<=*d**i*<=≤<=*n*, 0<=≤<=*h**d**i*<=≤<=108) — the number of the day when the *i*-th note was made and height on the *d**i*-th day. It is guaranteed that the notes are given in the chronological order, i.e. for all *i* from 1 to *m*<=-<=1 the following condition holds: *d**i*<=&lt;<=*d**i*<=+<=1.","If the notes aren't contradictory, print a single integer — the maximum possible height value throughout the whole route.

If the notes do not correspond to any set of heights, print a single word 'IMPOSSIBLE' (without the quotes).","['8 2\n2 0\n7 0\n', '8 3\n2 0\n7 0\n8 3\n']","['2\n', 'IMPOSSIBLE\n']","For the first sample, an example of a correct height sequence with a maximum of 2: (0, 0, 1, 2, 1, 1, 0, 1).

In the second sample the inequality between *h*<sub class=""lower-index"">7</sub> and *h*<sub class=""lower-index"">8</sub> does not hold, thus the information is inconsistent.",WRONG_ANSWER,"from re import L
from sys import stdin
input=stdin.readline

j=[]

res=-1e9

n,m=map(int,input().split())
for _ in range(m):
    d,h=map(int,input().split())
    res=max(res,h)
    j.append([d,h])

def solve(c,n):
    l,r=0,1e8
    ad=abs(c[0]-n[0])-abs(c[1]-n[1])
    while l<r:
        mid=(l+r)//2
        if ad//2>mid:
            l=mid+1
        else:
            r=mid
    return int(l)
    pass

for i in range(m-1):
    next=j[i+1];curr=j[i]
    if abs(curr[1]-next[1])>abs(curr[0]-next[0]):print('IMPOSSIBLE');exit()
    else:
        res=max(res,solve(curr,next))
print(res)","def max_height(n, m, notes):

    height = [None] * (n + 1)

    for day, h in notes:
        height[day] = h

    for i in range(1, n + 1):
        if height[i] is not None:

            if i > 1 and height[i - 1] is not None:

                height[i] = min(height[i], height[i - 1] + 1)
            if i < n and height[i + 1] is not None:

                height[i] = min(height[i], height[i + 1] + 1)

    for i in range(n, 0, -1):
        if height[i] is not None:
            if i < n and height[i + 1] is not None:
                height[i] = min(height[i], height[i + 1] + 1)

    max_height_value = 0
    for i in range(1, n + 1):
        if height[i] is None:

            height[i] = min(
                (height[i - 1] + 1 if i > 1 else float('inf')),
                (height[i + 1] + 1 if i < n else float('inf'))
            )

        if i > 1 and height[i] < height[i - 1] - 1:
            return ""IMPOSSIBLE""
        if i < n and height[i] < height[i + 1] - 1:
            return ""IMPOSSIBLE""

        max_height_value = max(max_height_value, height[i])

    return max_height_value

import sys
input = sys.stdin.read
data = input().strip().split('\n')

results = []
index = 0

while index < len(data):
    n, m = map(int, data[index].split())
    index += 1
    notes = []
    for _ in range(m):
        d_i, h_d_i = map(int, data[index].split())
        notes.append((d_i, h_d_i))
        index += 1

    result = max_height(n, m, notes)
    results.append(result)

for res in results:
    print(res)"
129,B,Students and Shoelaces,PROGRAMMING,"['brute force', 'dfs and similar', 'graphs', 'implementation']","Anna and Maria are in charge of the math club for junior students. When the club gathers together, the students behave badly. They've brought lots of shoe laces to the club and got tied with each other. Specifically, each string ties together two students. Besides, if two students are tied, then the lace connects the first student with the second one as well as the second student with the first one.

To restore order, Anna and Maria do the following. First, for each student Anna finds out what other students he is tied to. If a student is tied to exactly one other student, Anna reprimands him. Then Maria gathers in a single group all the students who have been just reprimanded. She kicks them out from the club. This group of students immediately leaves the club. These students takes with them the laces that used to tie them. Then again for every student Anna finds out how many other students he is tied to and so on. And they do so until Anna can reprimand at least one student.

Determine how many groups of students will be kicked out of the club.","The first line contains two integers *n* and *m* — the initial number of students and laces (). The students are numbered from 1 to *n*, and the laces are numbered from 1 to *m*. Next *m* lines each contain two integers *a* and *b* — the numbers of students tied by the *i*-th lace (1<=≤<=*a*,<=*b*<=≤<=*n*,<=*a*<=≠<=*b*). It is guaranteed that no two students are tied with more than one lace. No lace ties a student to himself.",Print the single number — the number of groups of students that will be kicked out from the club.,"['3 3\n1 2\n2 3\n3 1\n', '6 3\n1 2\n2 3\n3 4\n', '6 5\n1 4\n2 4\n3 4\n5 4\n6 4\n']","['0\n', '2\n', '1\n']","In the first sample Anna and Maria won't kick out any group of students — in the initial position every student is tied to two other students and Anna won't be able to reprimand anyone.

In the second sample four students are tied in a chain and two more are running by themselves. First Anna and Maria kick out the two students from both ends of the chain (1 and 4), then — two other students from the chain (2 and 3). At that the students who are running by themselves will stay in the club.

In the third sample Anna and Maria will momentarily kick out all students except for the fourth one and the process stops at that point. The correct answer is one.",OK,"from collections import defaultdict
n,m=map(int,input().split())
dic=defaultdict(list)
li=[0]*n
for i in range(m):
    u,v=list(map(int,input().split()))
    u=u-1
    v=v-1
    li[u]+=1
    li[v]+=1
    dic[u].append(v)
    dic[v].append(u)
r=0
for i in range(n):
    res=[]
    for i in range(n):
        if li[i]==1:
            res.append(i)
            li[i]=0

    if len(res)==0:
        break

    r+=1
    for j in res:
        for k in dic[j]:
            li[k]-=1

print(r)","def kick_out_students(n, m, laces):
    from collections import defaultdict

    connections = defaultdict(set)

    for a, b in laces:
        connections[a].add(b)
        connections[b].add(a)

    groups_kicked_out = 0

    while True:

        reprimanded_students = [student for student in connections if len(connections[student]) == 1]

        if not reprimanded_students:
            break

        groups_kicked_out += 1

        for student in reprimanded_students:
            for neighbor in connections[student]:
                connections[neighbor].remove(student)
            connections.pop(student)

    return groups_kicked_out

input_data = [
    (3, 3, [(1, 2), (2, 3), (3, 1)]),
    (6, 3, [(1, 2), (2, 3), (3, 4)]),
    (6, 5, [(1, 4), (2, 4), (3, 4), (5, 4), (6, 4)])
]

for n, m, laces in input_data:
    print(kick_out_students(n, m, laces))"
493,B,Vasya and Wrestling,PROGRAMMING,['implementation'],"Vasya has become interested in wrestling. In wrestling wrestlers use techniques for which they are awarded points by judges. The wrestler who gets the most points wins.

When the numbers of points of both wrestlers are equal, the wrestler whose sequence of points is lexicographically greater, wins.

If the sequences of the awarded points coincide, the wrestler who performed the last technique wins. Your task is to determine which wrestler won.","The first line contains number *n* — the number of techniques that the wrestlers have used (1<=≤<=*n*<=≤<=2·105). 

The following *n* lines contain integer numbers *a**i* (|*a**i*|<=≤<=109, *a**i*<=≠<=0). If *a**i* is positive, that means that the first wrestler performed the technique that was awarded with *a**i* points. And if *a**i* is negative, that means that the second wrestler performed the technique that was awarded with (<=-<=*a**i*) points.

The techniques are given in chronological order.","If the first wrestler wins, print string ""first"", otherwise print ""second""","['5\n1\n2\n-3\n-4\n3\n', '3\n-1\n-2\n3\n', '2\n4\n-4\n']","['second\n', 'first\n', 'second\n']","Sequence *x*  =  *x*<sub class=""lower-index"">1</sub>*x*<sub class=""lower-index"">2</sub>... *x*<sub class=""lower-index"">|*x*|</sub> is lexicographically larger than sequence *y*  =  *y*<sub class=""lower-index"">1</sub>*y*<sub class=""lower-index"">2</sub>... *y*<sub class=""lower-index"">|*y*|</sub>, if either |*x*|  &gt;  |*y*| and *x*<sub class=""lower-index"">1</sub>  =  *y*<sub class=""lower-index"">1</sub>,  *x*<sub class=""lower-index"">2</sub>  =  *y*<sub class=""lower-index"">2</sub>, ... ,  *x*<sub class=""lower-index"">|*y*|</sub>  =  *y*<sub class=""lower-index"">|*y*|</sub>, or there is such number *r* (*r*  &lt;  |*x*|, *r*  &lt;  |*y*|), that *x*<sub class=""lower-index"">1</sub>  =  *y*<sub class=""lower-index"">1</sub>,  *x*<sub class=""lower-index"">2</sub>  =  *y*<sub class=""lower-index"">2</sub>,  ... ,  *x*<sub class=""lower-index"">*r*</sub>  =  *y*<sub class=""lower-index"">*r*</sub> and *x*<sub class=""lower-index"">*r*  +  1</sub>  &gt;  *y*<sub class=""lower-index"">*r*  +  1</sub>.

We use notation |*a*| to denote length of sequence *a*.",WRONG_ANSWER,"from collections import defaultdict
import cmath

n = int(input())
vala = []
valb = []
suma = sumb = 0
seqa = """"
seqb = """"

for i in range(n):
    val = int(input())
    if val > 0:
        vala.append(val)
        suma += val
        seqa += str(val)
    else:
        valb.append(val)
        sumb += abs(val)
        seqb += str(abs(val))

if suma > sumb :
    print(""first"")
elif sumb > suma :
    print(""second"")
else:
    if seqa > seqb:
        print(""first"")
    elif seqb > seqa:
        print(""second"")
    else:
        print(""second"")","def wrestling_winner(n, points_list):
    first_points = []
    second_points = []
    first_score = 0
    second_score = 0

    for points in points_list:
        if points > 0:
            first_points.append(points)
            first_score += points
        else:
            second_points.append(-points)
            second_score += -points

    if first_score > second_score:
        return ""first""
    elif first_score < second_score:
        return ""second""
    else:

        if first_points > second_points:
            return ""first""
        elif first_points < second_points:
            return ""second""
        else:
            return ""first"" if points_list[-1] > 0 else ""second""

input_data = ['5\n1\n2\n-3\n-4\n3\n', '3\n-1\n-2\n3\n', '2\n4\n-4\n']
output = []

for data in input_data:
    lines = list(map(int, data.split()[1:]))
    result = wrestling_winner(len(lines), lines)
    output.append(result + '\n')

print(output)"
834,A,The Useless Toy,PROGRAMMING,['implementation'],"Walking through the streets of Marshmallow City, Slastyona have spotted some merchants selling a kind of useless toy which is very popular nowadays – caramel spinner! Wanting to join the craze, she has immediately bought the strange contraption.

Spinners in Sweetland have the form of V-shaped pieces of caramel. Each spinner can, well, spin around an invisible magic axis. At a specific point in time, a spinner can take 4 positions shown below (each one rotated 90 degrees relative to the previous, with the fourth one followed by the first one):

After the spinner was spun, it starts its rotation, which is described by a following algorithm: the spinner maintains its position for a second then majestically switches to the next position in clockwise or counter-clockwise order, depending on the direction the spinner was spun in.

Slastyona managed to have spinner rotating for exactly *n* seconds. Being fascinated by elegance of the process, she completely forgot the direction the spinner was spun in! Lucky for her, she managed to recall the starting position, and wants to deduct the direction given the information she knows. Help her do this.","There are two characters in the first string – the starting and the ending position of a spinner. The position is encoded with one of the following characters: v (ASCII code 118, lowercase v), &lt; (ASCII code 60), ^ (ASCII code 94) or &gt; (ASCII code 62) (see the picture above for reference). Characters are separated by a single space.

In the second strings, a single number *n* is given (0<=≤<=*n*<=≤<=109) – the duration of the rotation.

It is guaranteed that the ending position of a spinner is a result of a *n* second spin in any of the directions, assuming the given starting position.","Output cw, if the direction is clockwise, ccw – if counter-clockwise, and undefined otherwise.","['^ &gt;\n1\n', '&lt; ^\n3\n', '^ v\n6\n']","['cw\n', 'ccw\n', 'undefined\n']",none,WRONG_ANSWER,"alph = ""v<^>""
pos = input()
n = int(input())
if n % 2 == 0:
    print(""undefined"")
else:
    if (alph.find(pos[0]) - alph.find(pos[2])) % 4 == n:
        print(""ccw"")
    else:
        print(""cw"")","def determine_direction(test_cases):
    results = []
    positions = ['v', '<', '^', '>']

    for case in test_cases:
        start_pos, end_pos, n = case
        n = int(n) % 4

        start_index = positions.index(start_pos)
        end_index = positions.index(end_pos)

        clockwise_index = (start_index + n) % 4
        counter_clockwise_index = (start_index - n) % 4

        if end_index == clockwise_index and end_index == counter_clockwise_index:
            results.append(""undefined"")
        elif end_index == clockwise_index:
            results.append(""cw"")
        elif end_index == counter_clockwise_index:
            results.append(""ccw"")
        else:
            results.append(""undefined"")

    return results

test_cases = [
    ('^', '>', 1),
    ('<', '^', 3),
    ('^', 'v', 6)
]

output = determine_direction(test_cases)
print(output)"
435,A,Queue on Bus Stop,PROGRAMMING,['implementation'],"It's that time of the year when the Russians flood their countryside summer cottages (dachas) and the bus stop has a lot of people. People rarely go to the dacha on their own, it's usually a group, so the people stand in queue by groups.

The bus stop queue has *n* groups of people. The *i*-th group from the beginning has *a**i* people. Every 30 minutes an empty bus arrives at the bus stop, it can carry at most *m* people. Naturally, the people from the first group enter the bus first. Then go the people from the second group and so on. Note that the order of groups in the queue never changes. Moreover, if some group cannot fit all of its members into the current bus, it waits for the next bus together with other groups standing after it in the queue.

Your task is to determine how many buses is needed to transport all *n* groups to the dacha countryside.","The first line contains two integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=100). The next line contains *n* integers: *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=*m*).",Print a single integer — the number of buses that is needed to transport all *n* groups to the dacha countryside.,"['4 3\n2 3 2 1\n', '3 4\n1 2 1\n']","['3\n', '1\n']",none,OK,"from sys import stdin

def main():
    n, m = map(int, stdin.readline().strip().split())
    it = iter(map(int, stdin.readline().strip().split()))
    try:
        cnt = vol = 0
        while True:
            x = next(it)
            if vol < x:
                cnt += 1
                vol = m
            vol -= x
    except StopIteration:
        return cnt

print(main())","n, m = map(int, input().split())

groups = list(map(int, input().split()))

buses_needed = 0
current_capacity = m

for group in groups:

    if group > current_capacity:
        buses_needed += 1
        current_capacity = m

    current_capacity -= group

if current_capacity < m:
    buses_needed += 1

print(buses_needed)"
604,A,Uncowed Forces,PROGRAMMING,['implementation'],"Kevin Sun has just finished competing in Codeforces Round #334! The round was 120 minutes long and featured five problems with maximum point values of 500, 1000, 1500, 2000, and 2500, respectively. Despite the challenging tasks, Kevin was uncowed and bulldozed through all of them, distinguishing himself from the herd as the best cowmputer scientist in all of Bovinia. Kevin knows his submission time for each problem, the number of wrong submissions that he made on each problem, and his total numbers of successful and unsuccessful hacks. Because Codeforces scoring is complicated, Kevin wants you to write a program to compute his final score.

Codeforces scores are computed as follows: If the maximum point value of a problem is *x*, and Kevin submitted correctly at minute *m* but made *w* wrong submissions, then his score on that problem is . His total score is equal to the sum of his scores for each problem. In addition, Kevin's total score gets increased by 100 points for each successful hack, but gets decreased by 50 points for each unsuccessful hack.

All arithmetic operations are performed with absolute precision and no rounding. It is guaranteed that Kevin's final score is an integer.","The first line of the input contains five space-separated integers *m*1, *m*2, *m*3, *m*4, *m*5, where *m**i* (0<=≤<=*m**i*<=≤<=119) is the time of Kevin's last submission for problem *i*. His last submission is always correct and gets accepted.

The second line contains five space-separated integers *w*1, *w*2, *w*3, *w*4, *w*5, where *w**i* (0<=≤<=*w**i*<=≤<=10) is Kevin's number of wrong submissions on problem *i*.

The last line contains two space-separated integers *h**s* and *h**u* (0<=≤<=*h**s*,<=*h**u*<=≤<=20), denoting the Kevin's numbers of successful and unsuccessful hacks, respectively.","Print a single integer, the value of Kevin's final score.","['20 40 60 80 100\n0 1 2 3 4\n1 0\n', '119 119 119 119 119\n0 0 0 0 0\n10 0\n']","['4900\n', '4930\n']","In the second sample, Kevin takes 119 minutes on all of the problems. Therefore, he gets <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/42158dc2bc78cd21fa679530ae9ef8b9ea298d15.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> of the points on each problem. So his score from solving problems is <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/fdf392d8508500b57f8057ac0c4c892ab5f925a2.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>. Adding in 10·100 = 1000 points from hacks, his total score becomes 3930 + 1000 = 4930.",WRONG_ANSWER,"def calc(x, m, w):
    score = max(0.3*x, ((1 - m/250 )*x - 50*w));
    return score;

m1, m2, m3, m4, m5 = map(int, input().split("" ""))
w1, w2, w3, w4, w5 = map(int, input().split("" ""))
h1, h2 = map(int, input().split("" ""))

score = calc(500, m1, w1) + calc(1000, m2, w2) + calc(1500, m3, w3) + calc(2000, m4, w4) + calc(2500, m5, w5)

score += h1*100
score-=h2*50

print(score)","max_points = [500, 1000, 1500, 2000, 2500]

m = list(map(int, input().split()))
w = list(map(int, input().split()))
h_s, h_u = map(int, input().split())

total_score = 0

for i in range(5):
    penalty = 50 * w[i]
    score = max(0, max_points[i] - ((m[i] * max_points[i]) // 120) - penalty)
    total_score += score

total_score += 100 * h_s
total_score -= 50 * h_u

print(total_score)"
126,B,Password,PROGRAMMING,"['binary search', 'dp', 'hashing', 'string suffix structures', 'strings']","Asterix, Obelix and their temporary buddies Suffix and Prefix has finally found the Harmony temple. However, its doors were firmly locked and even Obelix had no luck opening them.

A little later they found a string *s*, carved on a rock below the temple's gates. Asterix supposed that that's the password that opens the temple and read the string aloud. However, nothing happened. Then Asterix supposed that a password is some substring *t* of the string *s*.

Prefix supposed that the substring *t* is the beginning of the string *s*; Suffix supposed that the substring *t* should be the end of the string *s*; and Obelix supposed that *t* should be located somewhere inside the string *s*, that is, *t* is neither its beginning, nor its end.

Asterix chose the substring *t* so as to please all his companions. Besides, from all acceptable variants Asterix chose the longest one (as Asterix loves long strings). When Asterix read the substring *t* aloud, the temple doors opened. 

You know the string *s*. Find the substring *t* or determine that such substring does not exist and all that's been written above is just a nice legend.","You are given the string *s* whose length can vary from 1 to 106 (inclusive), consisting of small Latin letters.","Print the string *t*. If a suitable *t* string does not exist, then print ""Just a legend"" without the quotes.","['fixprefixsuffix\n', 'abcdabc\n']","['fix', 'Just a legend']",none,WRONG_ANSWER,"def lps(s):
    n=len(s)
    for i in range(n//2,0,-1):
        pre=s[0:i]
        suff=s[n-i:n]
        if pre==suff:
            return pre,i
    return 0

s=str(input())
prefix,index=lps(s)
temp=s[index+1:len(s)-index]
if prefix in temp:
    print(prefix)
else:
    print(""Just a legend"")","def find_longest_substring(s):
    n = len(s)

    suffix_set = set()
    prefix_set = set()

    for i in range(1, n):
        prefix_set.add(s[:i])
        suffix_set.add(s[-i:])

    common_substrings = prefix_set.intersection(suffix_set)

    valid_substrings = [t for t in common_substrings if t != s[:1] and t != s[-1:]] 

    if valid_substrings:

        return max(valid_substrings, key=len)
    else:
        return ""Just a legend""

input_strings = ['fixprefixsuffix', 'abcdabc']
output_strings = [find_longest_substring(s) for s in input_strings]

for result in output_strings:
    print(result)"
318,A,Even Odds,PROGRAMMING,['math'],"Being a nonconformist, Volodya is displeased with the current state of things, particularly with the order of natural numbers (natural number is positive integer number). He is determined to rearrange them. But there are too many natural numbers, so Volodya decided to start with the first *n*. He writes down the following sequence of numbers: firstly all odd integers from 1 to *n* (in ascending order), then all even integers from 1 to *n* (also in ascending order). Help our hero to find out which number will stand at the position number *k*.","The only line of input contains integers *n* and *k* (1<=≤<=*k*<=≤<=*n*<=≤<=1012).

Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.",Print the number that will stand at the position number *k* after Volodya's manipulations.,"['10 3\n', '7 7\n']","['5', '6']","In the first sample Volodya's sequence will look like this: {1, 3, 5, 7, 9, 2, 4, 6, 8, 10}. The third place in the sequence is therefore occupied by the number 5.",TIME_LIMIT_EXCEEDED,"def even_odd():
    n, k = map(int, input().split())
    arrEven=[]
    arrOdd=[]
    for x in range(n+1):
        if not x:
            continue
        if x%2==0:
            arrEven.append(x)
        else:
            arrOdd.append(x)
    totAll = [*arrOdd, *arrEven]
    print(totAll[k-1])
even_odd()","n, k = map(int, input().split())

odd_count = (n + 1) // 2
even_count = n // 2

if k <= odd_count:

    result = 2 * k - 1
else:

    result = 2 * (k - odd_count)

print(result)"
483,A,Counterexample ,PROGRAMMING,"['brute force', 'implementation', 'math', 'number theory']","Your friend has recently learned about coprime numbers. A pair of numbers {*a*,<=*b*} is called coprime if the maximum number that divides both *a* and *b* is equal to one. 

Your friend often comes up with different statements. He has recently supposed that if the pair (*a*,<=*b*) is coprime and the pair (*b*,<=*c*) is coprime, then the pair (*a*,<=*c*) is coprime. 

You want to find a counterexample for your friend's statement. Therefore, your task is to find three distinct numbers (*a*,<=*b*,<=*c*), for which the statement is false, and the numbers meet the condition *l*<=≤<=*a*<=&lt;<=*b*<=&lt;<=*c*<=≤<=*r*. 

More specifically, you need to find three numbers (*a*,<=*b*,<=*c*), such that *l*<=≤<=*a*<=&lt;<=*b*<=&lt;<=*c*<=≤<=*r*, pairs (*a*,<=*b*) and (*b*,<=*c*) are coprime, and pair (*a*,<=*c*) is not coprime.","The single line contains two positive space-separated integers *l*, *r* (1<=≤<=*l*<=≤<=*r*<=≤<=1018; *r*<=-<=*l*<=≤<=50).","Print three positive space-separated integers *a*, *b*, *c* — three distinct numbers (*a*,<=*b*,<=*c*) that form the counterexample. If there are several solutions, you are allowed to print any of them. The numbers must be printed in ascending order. 

If the counterexample does not exist, print the single number -1.","['2 4\n', '10 11\n', '900000000000000009 900000000000000029\n']","['2 3 4\n', '-1\n', '900000000000000009 900000000000000010 900000000000000021\n']","In the first sample pair (2, 4) is not coprime and pairs (2, 3) and (3, 4) are. 

In the second sample you cannot form a group of three distinct integers, so the answer is -1. 

In the third sample it is easy to see that numbers 900000000000000009 and 900000000000000021 are divisible by three.",WRONG_ANSWER,"import sys
input = lambda: sys.stdin.readline().rstrip()

def main():
    l,r = [int(item) for item in input().split("" "")]
    if(r-l<2):
        print(-1)
    elif(r-l>2):
        print(l+1,l+2,l+3)
    elif(l%2==0):
        print(l,l+1,l+2)
    else:
        print(-1)
   

if __name__ == '__main__':
    main()","from math import gcd

def find_coprime_counterexample(l, r):

    if r - l < 2:
        return -1

    for a in range(l, r - 1):
        b = a + 1
        c = b + 1

        if gcd(a, b) == 1 and gcd(b, c) == 1 and gcd(a, c) != 1:
            return f""{a} {b} {c}""
    
    return -1

inputs = [
    (2, 4),
    (10, 11),
    (900000000000000009, 900000000000000029)
]

results = []
for l, r in inputs:
    result = find_coprime_counterexample(l, r)
    results.append(result)

for res in results:
    print(res)"
471,A,MUH and Sticks,PROGRAMMING,['implementation'],"Two polar bears Menshykov and Uslada from the St.Petersburg zoo and elephant Horace from the Kiev zoo got six sticks to play with and assess the animals' creativity. Menshykov, Uslada and Horace decided to make either an elephant or a bear from those sticks. They can make an animal from sticks in the following way: 
 -  Four sticks represent the animal's legs, these sticks should have the same length. -  Two remaining sticks represent the animal's head and body. The bear's head stick must be shorter than the body stick. The elephant, however, has a long trunk, so his head stick must be as long as the body stick. Note that there are no limits on the relations between the leg sticks and the head and body sticks. 
Your task is to find out which animal can be made from the given stick set. The zoo keeper wants the sticks back after the game, so they must never be broken, even bears understand it.",The single line contains six space-separated integers *l**i* (1<=≤<=*l**i*<=≤<=9) — the lengths of the six sticks. It is guaranteed that the input is such that you cannot make both animals from the sticks.,"If you can make a bear from the given set, print string ""Bear"" (without the quotes). If you can make an elephant, print string ""Elephant"" (wıthout the quotes). If you can make neither a bear nor an elephant, print string ""Alien"" (without the quotes).","['4 2 5 4 4 4\n', '4 4 5 4 4 5\n', '1 2 3 4 5 6\n']","['Bear', 'Elephant', 'Alien']","If you're out of creative ideas, see instructions below which show how to make a bear and an elephant in the first two samples. The stick of length 2 is in red, the sticks of length 4 are in green, the sticks of length 5 are in blue.",WRONG_ANSWER,"A = []
def plz_del(x):
    for i in range(len(A)):
        if A[i] == x:
            A[i] = -1
for i in input().split(' '):
    A.append(int(i))
ok = False
for i in range(len(A)):
    if A.count(i) >= 4:
        plz_del(i)
        ok = True
if ok:
    e1 = -1
    e2 = -1
    for i in A:
        if i != -1:
            if e1 == -1:
                e1 = i
            else:
                e2 = i
    if e1 == e2:
        print(""Elephant"")
    else:
        print(""Bear"")
else:
    print(""Alien"")","def determine_animal(stick_lengths):

    length_count = {}
    for length in stick_lengths:
        if length in length_count:
            length_count[length] += 1
        else:
            length_count[length] = 1

    leg_length = None
    for length, count in length_count.items():
        if count >= 4:
            leg_length = length
            break

    if leg_length is None:
        return ""Alien""

    length_count[leg_length] -= 4
    if length_count[leg_length] == 0:
        del length_count[leg_length]

    remaining_sticks = []
    for length, count in length_count.items():
        remaining_sticks.extend([length] * count)

    if len(remaining_sticks) != 2:
        return ""Alien""

    head, body = remaining_sticks

    if head == body:
        return ""Elephant""
    elif head < body:
        return ""Bear""
    else:
        return ""Alien""

input_data = ""4 4 5 4 4 5\n""
stick_lengths = list(map(int, input_data.strip().split()))
result = determine_animal(stick_lengths)
print(result)"
548,A,Mike and Fax,PROGRAMMING,"['brute force', 'implementation', 'strings']","While Mike was walking in the subway, all the stuff in his back-bag dropped on the ground. There were several fax messages among them. He concatenated these strings in some order and now he has string *s*.

He is not sure if this is his own back-bag or someone else's. He remembered that there were exactly *k* messages in his own bag, each was a palindrome string and all those strings had the same length.

He asked you to help him and tell him if he has worn his own back-bag. Check if the given string *s* is a concatenation of *k* palindromes of the same length.","The first line of input contains string *s* containing lowercase English letters (1<=≤<=|*s*|<=≤<=1000).

The second line contains integer *k* (1<=≤<=*k*<=≤<=1000).","Print ""YES""(without quotes) if he has worn his own back-bag or ""NO""(without quotes) otherwise.","['saba\n2\n', 'saddastavvat\n2\n']","['NO\n', 'YES\n']","Palindrome is a string reading the same forward and backward.

In the second sample, the faxes in his back-bag can be ""saddas"" and ""tavvat"".",WRONG_ANSWER,"def polindrom(word):
    if word[0:int(len(word)/2)] == word[-1:int((len(word) - 1)/2 ):-1]:
        return True
    return False

string = input()
k = int(input())
len_palindrom = int(len(string)/k)
words = []
notfound = False
for i in range(k):
    words.append(string[len_palindrom * i:(i+1)*len_palindrom])
for i in range(k):
    if not polindrom(words[i]):
        print ('NO')
        notfound = True
        break
if not notfound:
    print ('YES')","def is_palindrome(s):

    return s == s[::-1]

def main():

    s = input().strip()
    k = int(input().strip())

    n = len(s)

    if n % k != 0:
        print(""NO"")
        return

    m = n // k

    for i in range(0, n, m):
        substring = s[i:i + m]
        if not is_palindrome(substring):
            print(""NO"")
            return

    print(""YES"")

if __name__ == ""__main__"":
    main()"
1003,B,Binary String Constructing,PROGRAMMING,['constructive algorithms'],"You are given three integers $a$, $b$ and $x$. Your task is to construct a binary string $s$ of length $n = a + b$ such that there are exactly $a$ zeroes, exactly $b$ ones and exactly $x$ indices $i$ (where $1 \le i &lt; n$) such that $s_i \ne s_{i + 1}$. It is guaranteed that the answer always exists.

For example, for the string ""01010"" there are four indices $i$ such that $1 \le i &lt; n$ and $s_i \ne s_{i + 1}$ ($i = 1, 2, 3, 4$). For the string ""111001"" there are two such indices $i$ ($i = 3, 5$).

Recall that binary string is a non-empty sequence of characters where each character is either 0 or 1.","The first line of the input contains three integers $a$, $b$ and $x$ ($1 \le a, b \le 100, 1 \le x &lt; a + b)$.","Print only one string $s$, where $s$ is any binary string satisfying conditions described above. It is guaranteed that the answer always exists.","['2 2 1\n', '3 3 3\n', '5 3 6\n']","['1100\n', '101100\n', '01010100\n']","All possible answers for the first example: 
 -  1100; -  0011. 
All possible answers for the second example: 
 -  110100; -  101100; -  110010; -  100110; -  011001; -  001101; -  010011; -  001011.",WRONG_ANSWER,"import os
import sys
import math
import heapq
from decimal import *
from io import BytesIO, IOBase
from collections import defaultdict, deque

def r():
    return int(input())
def rm():
    return map(int,input().split())
def rl():
    return list(map(int,input().split()))

'''b Binary string construction'''
a,b,x=rm()
c=(x+1)//2
s='01'*c
a-=c;b-=c
print('0'*a+s+'1'*b+'0'*(1 if x%2==0 else 0))","def construct_binary_string(a, b, x):

    result = []

    start_with_zero = a >= b
    if start_with_zero:
        result.append('0')
        a -= 1
    else:
        result.append('1')
        b -= 1

    for _ in range(x):
        if start_with_zero:
            result.append('1')
            b -= 1
        else:
            result.append('0')
            a -= 1

        start_with_zero = not start_with_zero

    result.append('0' * a)
    result.append('1' * b)

    return ''.join(result)

a, b, x = map(int, input().split())

print(construct_binary_string(a, b, x))"
217,A,Ice Skating,PROGRAMMING,"['brute force', 'dfs and similar', 'dsu', 'graphs']","Bajtek is learning to skate on ice. He's a beginner, so his only mode of transportation is pushing off from a snow drift to the north, east, south or west and sliding until he lands in another snow drift. He has noticed that in this way it's impossible to get from some snow drifts to some other by any sequence of moves. He now wants to heap up some additional snow drifts, so that he can get from any snow drift to any other one. He asked you to find the minimal number of snow drifts that need to be created.

We assume that Bajtek can only heap up snow drifts at integer coordinates.","The first line of input contains a single integer *n* (1<=≤<=*n*<=≤<=100) — the number of snow drifts. Each of the following *n* lines contains two integers *x**i* and *y**i* (1<=≤<=*x**i*,<=*y**i*<=≤<=1000) — the coordinates of the *i*-th snow drift.

Note that the north direction coinсides with the direction of *Oy* axis, so the east direction coinсides with the direction of the *Ox* axis. All snow drift's locations are distinct.",Output the minimal number of snow drifts that need to be created in order for Bajtek to be able to reach any snow drift from any other one.,"['2\n2 1\n1 2\n', '2\n2 1\n4 1\n']","['1\n', '0\n']",none,WRONG_ANSWER,"def dfs(v):
    global marked, g
    marked[v]  = True
    for nv in g[v]:
        if not marked[nv]:
            dfs(nv)
n = int(input())
g = [[] for _ in range(n+1)]
x  = [0 for _ in range(n+1)]
y  = [0 for _ in range(n+1)]
marked = [False for _ in range(n+1)]
for i in range(1, n+1):
    x[i], y[i] = map(int, input().split())
    for j in range(1, i):
        if (x[j] == x[i] and y[j] == y[i]):
            g[i].append(j)
            g[j].append(i)
cnt = 0
for i in range(1, n+1):
    if not marked[i]:
        dfs(i)
        cnt+=1
print(cnt-1)","def find_min_snow_drifts(n, coordinates):

    unique_x = set()
    unique_y = set()
    
    for x, y in coordinates:
        unique_x.add(x)
        unique_y.add(y)

    min_needed = max(0, len(unique_x) - 1) + max(0, len(unique_y) - 1)
    return min_needed

n = int(input().strip())
coordinates = [tuple(map(int, input().strip().split())) for _ in range(n)]

result = find_min_snow_drifts(n, coordinates)

print(result)"
909,B,Segments,PROGRAMMING,"['constructive algorithms', 'math']","You are given an integer *N*. Consider all possible segments on the coordinate axis with endpoints at integer points with coordinates between 0 and *N*, inclusive; there will be  of them.

You want to draw these segments in several layers so that in each layer the segments don't overlap (they might touch at the endpoints though). You can not move the segments to a different location on the coordinate axis. 

Find the minimal number of layers you have to use for the given *N*.",The only input line contains a single integer *N* (1<=≤<=*N*<=≤<=100).,Output a single integer - the minimal number of layers required to draw the segments for the given *N*.,"['2\n', '3\n', '4\n']","['2\n', '4\n', '6\n']","As an example, here are the segments and their optimal arrangement into layers for *N* = 4.",OK,"def process(n):
    if n % 2==1:
        return ((n+1)//2)**2
    return (n//2)*(n//2+1)

n = int(input())
print(process(n))","def minimal_layers(N):

    segments = (N * (N + 1)) // 2

    layers = (segments + N - 1) // N
    
    return layers

N = int(input().strip())

print(minimal_layers(N))"
452,C,Magic Trick,PROGRAMMING,"['combinatorics', 'math', 'probabilities']","Alex enjoys performing magic tricks. He has a trick that requires a deck of *n* cards. He has *m* identical decks of *n* different cards each, which have been mixed together. When Alex wishes to perform the trick, he grabs *n* cards at random and performs the trick with those. The resulting deck looks like a normal deck, but may have duplicates of some cards.

The trick itself is performed as follows: first Alex allows you to choose a random card from the deck. You memorize the card and put it back in the deck. Then Alex shuffles the deck, and pulls out a card. If the card matches the one you memorized, the trick is successful.

You don't think Alex is a very good magician, and that he just pulls a card randomly from the deck. Determine the probability of the trick being successful if this is the case.","First line of the input consists of two integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=1000), separated by space — number of cards in each deck, and number of decks.",On the only line of the output print one floating point number – probability of Alex successfully performing the trick. Relative or absolute error of your answer should not be higher than 10<=-<=6.,"['2 2\n', '4 4\n', '1 2\n']","['0.6666666666666666\n', '0.4000000000000000\n', '1.0000000000000000\n']","In the first sample, with probability <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/64c94d13eeb330b494061e86538db66574ad0f7d.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> Alex will perform the trick with two cards with the same value from two different decks. In this case the trick is guaranteed to succeed.

With the remaining <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/14b21b617fcd2e25700376368355f7bbf975d8de.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> probability he took two different cards, and the probability of pulling off the trick is <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/eb946338365d9781f7d2e9ec692c26702d0ae3a7.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>.

The resulting probability is <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/f54a03c9fa9df64ba08161730756d50b780a5f43.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>",OK,"def cal(m,n,i):
    tot=1
    for j in range(1,n-i+1):
        tot=tot*(n*m-m-n+i+j)/(n*m-n+i+j)
    for j in range(1,i+1):
        tot=tot*(m-i+j)/(n*m-n+j)
    for j in range(1,i+1):
        tot=tot/j*(n-i+j)
    return tot

n,m = input().split()
n = int(n)
m = int(m)
ans = 0

for i in range(1, min(n,m)+1):
    ans += i * i /n * cal(m,n,i)

print(ans)","def calculate_probability(n, m):

    identical_probability = (m / (m + (n - 1))) ** 2

    different_probability = (n - 1) / (m + (n - 1))

    success_probability = identical_probability + different_probability * (1 / n)
    
    return success_probability

input_data = input().strip().splitlines()
results = []

for line in input_data:
    n, m = map(int, line.split())
    probability = calculate_probability(n, m)
    results.append(f""{probability:.10f}"")

print(""\n"".join(results))"
957,A,Tritonic Iridescence,PROGRAMMING,['implementation'],"Overlooking the captivating blend of myriads of vernal hues, Arkady the painter lays out a long, long canvas.

Arkady has a sufficiently large amount of paint of three colours: cyan, magenta, and yellow. On the one-dimensional canvas split into *n* consecutive segments, each segment needs to be painted in one of the colours.

Arkady has already painted some (possibly none or all) segments and passes the paintbrush to you. You are to determine whether there are at least two ways of colouring all the unpainted segments so that no two adjacent segments are of the same colour. Two ways are considered different if and only if a segment is painted in different colours in them.","The first line contains a single positive integer *n* (1<=≤<=*n*<=≤<=100) — the length of the canvas.

The second line contains a string *s* of *n* characters, the *i*-th of which is either 'C' (denoting a segment painted in cyan), 'M' (denoting one painted in magenta), 'Y' (one painted in yellow), or '?' (an unpainted one).","If there are at least two different ways of painting, output ""Yes""; otherwise output ""No"" (both without quotes).

You can print each character in any case (upper or lower).","['5\nCY??Y\n', '5\nC?C?Y\n', '5\n?CYC?\n', '5\nC??MM\n', '3\nMMY\n']","['Yes\n', 'Yes\n', 'Yes\n', 'No\n', 'No\n']","For the first example, there are exactly two different ways of colouring: CYCMY and CYMCY.

For the second example, there are also exactly two different ways of colouring: CMCMY and CYCMY.

For the third example, there are four ways of colouring: MCYCM, MCYCY, YCYCM, and YCYCY.

For the fourth example, no matter how the unpainted segments are coloured, the existing magenta segments will prevent the painting from satisfying the requirements. The similar is true for the fifth example.",WRONG_ANSWER,"def solve():
    n = int(input())
    x = input()
    if 'CC' in x:
        return 'No'
    if 'MM' in x:
        return 'No'
    if 'YY' in x:
        return 'No'
    
    for i in range(n):
        if i > 0 and i < n - 1:
            if x[i] == '?':
                left = x[i-1]
                right = x[i+1]
                if left == right:
                    return 'Yes'
    return 'No'

print(solve())","def is_valid_painting(n, s):

    ways = 1
    for i in range(n):
        if s[i] == '?':

            left_color = s[i - 1] if i > 0 else None
            right_color = s[i + 1] if i < n - 1 else None

            possible_colors = set(['C', 'M', 'Y'])
            if left_color in possible_colors:
                possible_colors.remove(left_color)
            if right_color in possible_colors:
                possible_colors.remove(right_color)

            if len(possible_colors) >= 2:
                ways *= len(possible_colors)
            elif len(possible_colors) == 1:
                ways *= 1
            else:
                return ""No""
    
    return ""Yes"" if ways >= 2 else ""No""

input_data = ['5\nCY??Y\n', '5\nC?C?Y\n', '5\n?CYC?\n', '5\nC??MM\n', '3\nMMY\n']
output_data = []

for data in input_data:
    n, s = data.split()
    n = int(n)
    result = is_valid_painting(n, s.strip())
    output_data.append(result)

for result in output_data:
    print(result)"
678,D,Iterated Linear Function,PROGRAMMING,"['math', 'number theory']","Consider a linear function *f*(*x*)<==<=*Ax*<=+<=*B*. Let's define *g*(0)(*x*)<==<=*x* and *g*(*n*)(*x*)<==<=*f*(*g*(*n*<=-<=1)(*x*)) for *n*<=&gt;<=0. For the given integer values *A*, *B*, *n* and *x* find the value of *g*(*n*)(*x*) modulo 109<=+<=7.","The only line contains four integers *A*, *B*, *n* and *x* (1<=≤<=*A*,<=*B*,<=*x*<=≤<=109,<=1<=≤<=*n*<=≤<=1018) — the parameters from the problem statement.

Note that the given value *n* can be too large, so you should use 64-bit integer type to store it. In C++ you can use the long long integer type and in Java you can use long integer type.",Print the only integer *s* — the value *g*(*n*)(*x*) modulo 109<=+<=7.,"['3 4 1 1\n', '3 4 2 1\n', '3 4 3 1\n']","['7\n', '25\n', '79\n']",none,OK,"mod = 7+10**9
def matmul(a, b):
    c = [[0,0],[0,0]]
    for i in range(2):
        for j in range(2):
            for k in range(2):
                c[i][j] += a[i][k] * b[k][j]
            c[i][j] %= mod

    return c 

def binpow(a, n):
    c = [[1,0],[0,1]]
    while n != 0:
        if (n&1):
            c = matmul(a,c) 
        a = matmul(a,a)
        n//=2
    return c

A,B,n,x = [int(i) for i in input().split("" "")]

matDef = [[A,B],[0,1]]
matDef = binpow(matDef,n)

print((matDef[0][0] * x + matDef[0][1]) % mod)","def f(x, A, B):
    return A * x + B

def g(n, x, A, B):
    if n == 0:
        return x
    else:
        return f(g(n - 1, x, A, B), A, B)

def main():
    import sys
    input = sys.stdin.read
    data = input().strip().split('\n')

    MOD = 10**9 + 7
    results = []

    for line in data:
        A, B, n, x = map(int, line.split())

        g_n_x = g(n, x, A, B) % MOD
        results.append(g_n_x)

    for result in results:
        print(result)

if __name__ == ""__main__"":
    main()"
115,A,Party,PROGRAMMING,"['dfs and similar', 'graphs', 'trees']","A company has *n* employees numbered from 1 to *n*. Each employee either has no immediate manager or exactly one immediate manager, who is another employee with a different number. An employee *A* is said to be the superior of another employee *B* if at least one of the following is true:
 -  Employee *A* is the immediate manager of employee *B* -  Employee *B* has an immediate manager employee *C* such that employee *A* is the superior of employee *C*. 
The company will not have a managerial cycle. That is, there will not exist an employee who is the superior of his/her own immediate manager.

Today the company is going to arrange a party. This involves dividing all *n* employees into several groups: every employee must belong to exactly one group. Furthermore, within any single group, there must not be two employees *A* and *B* such that *A* is the superior of *B*.

What is the minimum number of groups that must be formed?","The first line contains integer *n* (1<=≤<=*n*<=≤<=2000) — the number of employees.

The next *n* lines contain the integers *p**i* (1<=≤<=*p**i*<=≤<=*n* or *p**i*<==<=-1). Every *p**i* denotes the immediate manager for the *i*-th employee. If *p**i* is -1, that means that the *i*-th employee does not have an immediate manager. 

It is guaranteed, that no employee will be the immediate manager of him/herself (*p**i*<=≠<=*i*). Also, there will be no managerial cycles.",Print a single integer denoting the minimum number of groups that will be formed in the party.,['5\n-1\n1\n2\n1\n-1\n'],['3\n'],"For the first example, three groups are sufficient, for example: 
 -  Employee 1 -  Employees 2 and 4 -  Employees 3 and 5",OK,"b=[]
def dfs(s):
    depth=1
    while s-1>=0:
        depth+=1
        s=b[s-1]
    return depth
n=int(input())
for i in range(n):
    b.append(int(input()))
m=1
for i in b:
     p=dfs(i)
     m=max(m,p)
print(m)","def min_groups(n, managers):
    from collections import defaultdict

    graph = defaultdict(list)
    for employee in range(n):
        manager = managers[employee]
        if manager != -1:
            graph[manager - 1].append(employee)

    def dfs(employee):
        max_depth = 0
        for subordinate in graph[employee]:
            max_depth = max(max_depth, dfs(subordinate))
        return max_depth + 1

    num_groups = 0

    for employee in range(n):
        if managers[employee] == -1:
            num_groups = max(num_groups, dfs(employee))

    return num_groups

n = int(input().strip())
managers = [int(input().strip()) for _ in range(n)]

result = min_groups(n, managers)

print(result)"
815,A,Karen and Game,PROGRAMMING,"['brute force', 'greedy', 'implementation']","On the way to school, Karen became fixated on the puzzle game on her phone!

The game is played as follows. In each level, you have a grid with *n* rows and *m* columns. Each cell originally contains the number 0.

One move consists of choosing one row or column, and adding 1 to all of the cells in that row or column.

To win the level, after all the moves, the number in the cell at the *i*-th row and *j*-th column should be equal to *g**i*,<=*j*.

Karen is stuck on one level, and wants to know a way to beat this level using the minimum number of moves. Please, help her with this task!","The first line of input contains two integers, *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=100), the number of rows and the number of columns in the grid, respectively.

The next *n* lines each contain *m* integers. In particular, the *j*-th integer in the *i*-th of these rows contains *g**i*,<=*j* (0<=≤<=*g**i*,<=*j*<=≤<=500).","If there is an error and it is actually not possible to beat the level, output a single integer -1.

Otherwise, on the first line, output a single integer *k*, the minimum number of moves necessary to beat the level.

The next *k* lines should each contain one of the following, describing the moves in the order they must be done:
 -  row *x*, (1<=≤<=*x*<=≤<=*n*) describing a move of the form ""choose the *x*-th row"". -  col *x*, (1<=≤<=*x*<=≤<=*m*) describing a move of the form ""choose the *x*-th column"". 
If there are multiple optimal solutions, output any one of them.","['3 5\n2 2 2 3 2\n0 0 0 1 0\n1 1 1 2 1\n', '3 3\n0 0 0\n0 1 0\n0 0 0\n', '3 3\n1 1 1\n1 1 1\n1 1 1\n']","['4\nrow 1\nrow 1\ncol 4\nrow 3\n', '-1\n', '3\nrow 1\nrow 2\nrow 3\n']","In the first test case, Karen has a grid with 3 rows and 5 columns. She can perform the following 4 moves to beat the level:

In the second test case, Karen has a grid with 3 rows and 3 columns. It is clear that it is impossible to beat the level; performing any move will create three 1s on the grid, but it is required to only have one 1 in the center.

In the third test case, Karen has a grid with 3 rows and 3 columns. She can perform the following 3 moves to beat the level:

Note that this is not the only solution; another solution, among others, is col 1, col 2, col 3.",OK,"from collections import defaultdict as dc
n,m=[int(x) for x in input().split()]
arr=list()
check=dc(lambda:False)
check2=dc(lambda:False)
ans,ans2=list(),list()
for _ in range(n):
    tmp=list(map(int,input().split()))
    arr.append(tmp)
pair,pair2=list(),list()
for i in range(n):
    tmp=list()
    for j in range(m):tmp.append((arr[i][j],j))
    pair.append(tmp)
for i in range(n):pair[i]=sorted(pair[i],reverse=True)
for i in range(n):
    for j in range(m):
        x=pair[i][j][0]-pair[i][-1][0]
        if x==0:break
        idx=pair[i][j][1]
        if check[idx+1]==True:continue
        while x:ans.append((""col"",idx+1)); x-=1; check[idx+1]=True
    x=pair[i][-1][0]
    if x:
        for aa in range(1,m+1):check[aa]=True
    while x:ans.append((""row"",i+1)); x-=1

Flag1=True
comp=list()
for i in range(n):
    tmp=list()
    for j in range(m):tmp.append(0)
    comp.append(tmp)
for i in ans:
    if i[0]=='row':
        for j in range(m):comp[i[1]-1][j]+=1
    else:
        for j in range(n):comp[j][i[1]-1]+=1
if comp!=arr:Flag1=False

for i in range(m):
    tmp=list()
    for j in range(n):tmp.append((arr[j][i],j))
    pair2.append(tmp)
for i in range(m):pair2[i]=sorted(pair2[i],reverse=True)

for j in range(m):
    for i in range(n):
        x=pair2[j][i][0]-pair2[j][-1][0]
        if x==0:break
        idx=pair2[j][i][1]
        if check2[idx+1]==True:continue
        while x:ans2.append((""row"",idx+1)); x-=1; check2[idx+1]=True
    x=pair2[j][-1][0]
    if x:
        for aa in range(1,m+1):check2[aa]=True
    while x:
        ans2.append((""col"",j+1)); x-=1

Flag2=True
comp=list()
for i in range(n):
    tmp=list()
    for j in range(m):tmp.append(0)
    comp.append(tmp)
for i in ans2:
    if i[0]=='row':
        for j in range(m):comp[i[1]-1][j]+=1
    else:
        for j in range(n):comp[j][i[1]-1]+=1
if comp!=arr:Flag2=False
if Flag1==Flag2 and Flag1==False:print(-1)
else:
    if len(ans)==len(ans2) or len(ans)<len(ans2) or Flag2==False:
        print(len(ans))
        for i in ans:
            print(i[0],i[1])
    else:
        print(len(ans2))
        for i in ans2:
            print(i[0],i[1])","def min_moves_to_beat_level(n, m, g):

    moves = []

    grid = [[0] * m for _ in range(n)]

    row_increases = [0] * n
    col_increases = [0] * m

    for i in range(n):
        for j in range(m):
            if g[i][j] < 0:
                return -1

            if g[i][j] > grid[i][j]:
                row_needed = g[i][j] - row_increases[i]
                if j == 0 or row_needed > g[i][0] - row_increases[i]:
                    row_needed = g[i][0] - row_increases[i]

                row_increases[i] += row_needed
                moves.extend([f""row {i + 1}""] * row_needed)

                for k in range(m):
                    if g[i][k] < row_increases[i]:
                        return -1
                    col_increases[k] = max(col_increases[k], g[i][k] - row_increases[i])

    for j in range(m):
        if col_increases[j] > 0:
            moves.extend([f""col {j + 1}""] * col_increases[j])

    num_moves = len(moves)

    return num_moves, moves

input_data = [
    ""3 5\n2 2 2 3 2\n0 0 0 1 0\n1 1 1 2 1\n"",
    ""3 3\n0 0 0\n0 1 0\n0 0 0\n"",
    ""3 3\n1 1 1\n1 1 1\n1 1 1\n"",
]

for data in input_data:

    lines = data.strip().splitlines()
    n, m = map(int, lines[0].split())

    g = [list(map(int, line.split())) for line in lines[1:n+1]]

    result = min_moves_to_beat_level(n, m, g)
    
    if result == -1:
        print(-1)
    else:
        num_moves, moves = result
        print(num_moves)
        for move in moves:
            print(move)"
911,B,Two Cakes,PROGRAMMING,"['binary search', 'brute force', 'implementation']","It's New Year's Eve soon, so Ivan decided it's high time he started setting the table. Ivan has bought two cakes and cut them into pieces: the first cake has been cut into *a* pieces, and the second one — into *b* pieces.

Ivan knows that there will be *n* people at the celebration (including himself), so Ivan has set *n* plates for the cakes. Now he is thinking about how to distribute the cakes between the plates. Ivan wants to do it in such a way that all following conditions are met:
 1.  Each piece of each cake is put on some plate; 1.  Each plate contains at least one piece of cake; 1.  No plate contains pieces of both cakes. 
To make his guests happy, Ivan wants to distribute the cakes in such a way that the minimum number of pieces on the plate is maximized. Formally, Ivan wants to know the maximum possible number *x* such that he can distribute the cakes according to the aforementioned conditions, and each plate will contain at least *x* pieces of cake.

Help Ivan to calculate this number *x*!","The first line contains three integers *n*, *a* and *b* (1<=≤<=*a*,<=*b*<=≤<=100, 2<=≤<=*n*<=≤<=*a*<=+<=*b*) — the number of plates, the number of pieces of the first cake, and the number of pieces of the second cake, respectively.",Print the maximum possible number *x* such that Ivan can distribute the cake in such a way that each plate will contain at least *x* pieces of cake.,"['5 2 3\n', '4 7 10\n']","['1\n', '3\n']","In the first example there is only one way to distribute cakes to plates, all of them will have 1 cake on it.

In the second example you can have two plates with 3 and 4 pieces of the first cake and two plates both with 5 pieces of the second cake. Minimal number of pieces is 3.",OK,"import sys,math

def solve():
    n,a,b=map(int,input().split())
    ans=0
    for i in range(1,n):
        mina=a//i
        minb=b//(n-i)
        ans1=min(mina,minb)
        ans=max(ans,ans1)
    print(ans)

solve()","def can_distribute(x, n, a, b):

    plates_from_a = a // x
    plates_from_b = b // x

    return plates_from_a + plates_from_b >= n

def max_min_pieces(n, a, b):
    low, high = 1, min(a, b)
    answer = 0

    while low <= high:
        mid = (low + high) // 2
        if can_distribute(mid, n, a, b):
            answer = mid
            low = mid + 1
        else:
            high = mid - 1

    return answer

inputs = ['5 2 3', '4 7 10']
results = []

for input_str in inputs:
    n, a, b = map(int, input_str.split())
    results.append(max_min_pieces(n, a, b))

for result in results:
    print(result)"
570,A,Elections,PROGRAMMING,['implementation'],"The country of Byalechinsk is running elections involving *n* candidates. The country consists of *m* cities. We know how many people in each city voted for each candidate.

The electoral system in the country is pretty unusual. At the first stage of elections the votes are counted for each city: it is assumed that in each city won the candidate who got the highest number of votes in this city, and if several candidates got the maximum number of votes, then the winner is the one with a smaller index.

At the second stage of elections the winner is determined by the same principle over the cities: the winner of the elections is the candidate who won in the maximum number of cities, and among those who got the maximum number of cities the winner is the one with a smaller index.

Determine who will win the elections.","The first line of the input contains two integers *n*, *m* (1<=≤<=*n*,<=*m*<=≤<=100) — the number of candidates and of cities, respectively.

Each of the next *m* lines contains *n* non-negative integers, the *j*-th number in the *i*-th line *a**ij* (1<=≤<=*j*<=≤<=*n*, 1<=≤<=*i*<=≤<=*m*, 0<=≤<=*a**ij*<=≤<=109) denotes the number of votes for candidate *j* in city *i*.

It is guaranteed that the total number of people in all the cities does not exceed 109.",Print a single number — the index of the candidate who won the elections. The candidates are indexed starting from one.,"['3 3\n1 2 3\n2 3 1\n1 2 1\n', '3 4\n10 10 3\n5 1 6\n2 2 2\n1 5 7\n']","['2', '1']","Note to the first sample test. At the first stage city 1 chosen candidate 3, city 2 chosen candidate 2, city 3 chosen candidate 2. The winner is candidate 2, he gained 2 votes.

Note to the second sample test. At the first stage in city 1 candidates 1 and 2 got the same maximum number of votes, but candidate 1 has a smaller index, so the city chose candidate 1. City 2 chosen candidate 3. City 3 chosen candidate 1, due to the fact that everyone has the same number of votes, and 1 has the smallest index. City 4 chosen the candidate 3. On the second stage the same number of cities chose candidates 1 and 3. The winner is candidate 1, the one with the smaller index.",COMPILATION_ERROR,"typedef long long int ll;
typedef unsigned long long int ull;
using namespace std;
const int N = 101000;

ll ar[101][101], ar2[101];
int main()
{
    int t = 1;
    while(t--)
    {
        ll n, m;
        cin >> n >> m;

        ll p = 0;
        for(int i = 0; i < m; i++)
        {
            ll mx = 0;
            for(int j = 0; j < n; j++)
            {
                cin >> ar[i][j];
                if(mx < ar[i][j])
                {
                    mx = ar[i][j];
                         p = j;
                }
            }
            ar2[p]++;
        }

        ll mx = 0, ans = 0, i;
        for(i = 0; i < n; i++)
        {
            if(mx < ar2[i])
            {
                mx = ar2[i];
                ans = i;
            }
        }
        cout << ans + 1 << endl;
    }

    return 0;

}","def determine_winner(input_data):
    lines = input_data.strip().split('\n')
    n, m = map(int, lines[0].split())

    candidate_wins = [0] * n
    
    for i in range(1, m + 1):
        votes = list(map(int, lines[i].split()))
        max_votes = max(votes)

        for j in range(n):
            if votes[j] == max_votes:
                candidate_wins[j] += 1
                break

    max_city_wins = max(candidate_wins)
    for k in range(n):
        if candidate_wins[k] == max_city_wins:
            return str(k + 1)

inputs = ['3 3\n1 2 3\n2 3 1\n1 2 1\n', '3 4\n10 10 3\n5 1 6\n2 2 2\n1 5 7\n']
outputs = [determine_winner(input_data) for input_data in inputs]

print(outputs)"
915,C,Permute Digits,PROGRAMMING,"['dp', 'greedy']","You are given two positive integer numbers *a* and *b*. Permute (change order) of the digits of *a* to construct maximal number not exceeding *b*. No number in input and/or output can start with the digit 0.

It is allowed to leave *a* as it is.",The first line contains integer *a* (1<=≤<=*a*<=≤<=1018). The second line contains integer *b* (1<=≤<=*b*<=≤<=1018). Numbers don't have leading zeroes. It is guaranteed that answer exists.,"Print the maximum possible number that is a permutation of digits of *a* and is not greater than *b*. The answer can't have any leading zeroes. It is guaranteed that the answer exists.

The number in the output should have exactly the same length as number *a*. It should be a permutation of digits of *a*.","['123\n222\n', '3921\n10000\n', '4940\n5000\n']","['213\n', '9321\n', '4940\n']",none,WRONG_ANSWER,"def swap_n_sort(X, i, j):
    X = X[0:i] + X[j] + X[i+1:j] + X[i] + X[j+1:]
    X = X[:i+1] + ''.join(reversed(sorted(X[i+1:])))
    return X

X = ''.join(reversed(sorted(input())))
Y = input()

if len(X) < len(Y):
    print(X)
else:
    eq = True
    i = 0
    while i < len(X):
        print(i, "" "", X)
        x = int(X[i])
        y = int(Y[i])
        if x < y:
            break
        if x == y and eq == True:
            i += 1
        if x > y or (x == y and eq == False):
            nx = -1
            nj = -1
            for j in range(i+1, len(X)):
                xx = int(X[j])
                if ((xx <= y and eq == True) or (xx < y and eq == False)) and xx > nx: 
                    nj = j
                    nx = int(X[j])
            if nx > -1:
                X = swap_n_sort(X, i, nj)
                i += 1
            else:
                i -= 1
                eq = False
                
    print(X)","from itertools import permutations

def max_permutation_not_exceeding(a, b):

    a_str = str(a)
    b_str = str(b)

    all_perms = sorted(set(int(''.join(p)) for p in permutations(a_str)), reverse=True)

    for perm in all_perms:
        if perm <= b:
            return perm

a = int(input().strip())
b = int(input().strip())

result = max_permutation_not_exceeding(a, b)

print(result)"
115,A,Party,PROGRAMMING,"['dfs and similar', 'graphs', 'trees']","A company has *n* employees numbered from 1 to *n*. Each employee either has no immediate manager or exactly one immediate manager, who is another employee with a different number. An employee *A* is said to be the superior of another employee *B* if at least one of the following is true:
 -  Employee *A* is the immediate manager of employee *B* -  Employee *B* has an immediate manager employee *C* such that employee *A* is the superior of employee *C*. 
The company will not have a managerial cycle. That is, there will not exist an employee who is the superior of his/her own immediate manager.

Today the company is going to arrange a party. This involves dividing all *n* employees into several groups: every employee must belong to exactly one group. Furthermore, within any single group, there must not be two employees *A* and *B* such that *A* is the superior of *B*.

What is the minimum number of groups that must be formed?","The first line contains integer *n* (1<=≤<=*n*<=≤<=2000) — the number of employees.

The next *n* lines contain the integers *p**i* (1<=≤<=*p**i*<=≤<=*n* or *p**i*<==<=-1). Every *p**i* denotes the immediate manager for the *i*-th employee. If *p**i* is -1, that means that the *i*-th employee does not have an immediate manager. 

It is guaranteed, that no employee will be the immediate manager of him/herself (*p**i*<=≠<=*i*). Also, there will be no managerial cycles.",Print a single integer denoting the minimum number of groups that will be formed in the party.,['5\n-1\n1\n2\n1\n-1\n'],['3\n'],"For the first example, three groups are sufficient, for example: 
 -  Employee 1 -  Employees 2 and 4 -  Employees 3 and 5",WRONG_ANSWER,"import sys
def input(): return sys.stdin.readline().strip()
def getints(): return map(int,sys.stdin.readline().strip().split())

q = int(input())
l = [0]*(q+1)
for x in range(1,q+1):
    n = int(input())
    if n == -1: l[x] = 1
    else: l[x] = l[n]+1
print(max(l))","def min_groups(n, managers):
    from collections import defaultdict

    tree = defaultdict(list)
    for employee in range(n):
        manager = managers[employee]
        if manager != -1:
            tree[manager - 1].append(employee)

    def max_depth(employee):
        if employee not in tree:
            return 1
        return 1 + max(max_depth(subordinate) for subordinate in tree[employee])

    depth = 0
    for employee in range(n):
        if managers[employee] == -1:
            depth = max(depth, max_depth(employee))

    return depth

n = int(input().strip())
managers = [int(input().strip()) for _ in range(n)]

result = min_groups(n, managers)
print(result)"
811,B,Vladik and Complicated Book,PROGRAMMING,"['implementation', 'sortings']","Vladik had started reading a complicated book about algorithms containing *n* pages. To improve understanding of what is written, his friends advised him to read pages in some order given by permutation *P*<==<=[*p*1,<=*p*2,<=...,<=*p**n*], where *p**i* denotes the number of page that should be read *i*-th in turn.

Sometimes Vladik’s mom sorted some subsegment of permutation *P* from position *l* to position *r* inclusive, because she loves the order. For every of such sorting Vladik knows number *x* — what index of page in permutation he should read. He is wondered if the page, which he will read after sorting, has changed. In other words, has *p**x* changed? After every sorting Vladik return permutation to initial state, so you can assume that each sorting is independent from each other.","First line contains two space-separated integers *n*, *m* (1<=≤<=*n*,<=*m*<=≤<=104) — length of permutation and number of times Vladik's mom sorted some subsegment of the book.

Second line contains *n* space-separated integers *p*1,<=*p*2,<=...,<=*p**n* (1<=≤<=*p**i*<=≤<=*n*) — permutation *P*. Note that elements in permutation are distinct.

Each of the next *m* lines contains three space-separated integers *l**i*, *r**i*, *x**i* (1<=≤<=*l**i*<=≤<=*x**i*<=≤<=*r**i*<=≤<=*n*) — left and right borders of sorted subsegment in *i*-th sorting and position that is interesting to Vladik.","For each mom’s sorting on it’s own line print ""Yes"", if page which is interesting to Vladik hasn't changed, or ""No"" otherwise.","['5 5\n5 4 3 2 1\n1 5 3\n1 3 1\n2 4 3\n4 4 4\n2 5 3\n', '6 5\n1 4 3 2 5 6\n2 4 3\n1 6 2\n4 5 4\n1 3 3\n2 6 3\n']","['Yes\nNo\nYes\nYes\nNo\n', 'Yes\nNo\nYes\nNo\nYes\n']","Explanation of first test case: 
 1.  [1, 2, 3, 4, 5] — permutation after sorting, 3-rd element hasn’t changed, so answer is ""Yes"". 1.  [3, 4, 5, 2, 1] — permutation after sorting, 1-st element has changed, so answer is ""No"". 1.  [5, 2, 3, 4, 1] — permutation after sorting, 3-rd element hasn’t changed, so answer is ""Yes"". 1.  [5, 4, 3, 2, 1] — permutation after sorting, 4-th element hasn’t changed, so answer is ""Yes"". 1.  [5, 1, 2, 3, 4] — permutation after sorting, 3-rd element has changed, so answer is ""No"".",TIME_LIMIT_EXCEEDED,"import sys
def func(l,r,x):
    count = 0
    for i in range(l,r+1):
        if a[x]>a[i]:
            count += 1
    return count
n,m = map(int,sys.stdin.readline().split())
a = [int(x) for x in sys.stdin.readline().split()]
for i in range(m):
    l,r,x = [int(v)-1 for v in sys.stdin.readline().split()]
    if x==func(l,r,x)+l:
        sys.stdout.write('Yes\n')
    else:
        sys.stdout.write('No\n')","n, m = map(int, input().split())
p = list(map(int, input().split()))

results = []
for _ in range(m):
    l, r, x = map(int, input().split())

    l -= 1
    r -= 1
    x -= 1

    subsegment = p[l:r+1]
    subsegment.sort()

    if p[x] == subsegment[x - l]:
        results.append(""Yes"")
    else:
        results.append(""No"")

print(""\n"".join(results))"
955,A,Feed the cat,PROGRAMMING,"['greedy', 'math']","After waking up at *hh*:*mm*, Andrew realised that he had forgotten to feed his only cat for yet another time (guess why there's only one cat). The cat's current hunger level is *H* points, moreover each minute without food increases his hunger by *D* points.

At any time Andrew can visit the store where tasty buns are sold (you can assume that is doesn't take time to get to the store and back). One such bun costs *C* roubles and decreases hunger by *N* points. Since the demand for bakery drops heavily in the evening, there is a special 20% discount for buns starting from 20:00 (note that the cost might become rational). Of course, buns cannot be sold by parts.

Determine the minimum amount of money Andrew has to spend in order to feed his cat. The cat is considered fed if its hunger level is less than or equal to zero.","The first line contains two integers *hh* and *mm* (00<=≤<=*hh*<=≤<=23,<=00<=≤<=*mm*<=≤<=59) — the time of Andrew's awakening.

The second line contains four integers *H*, *D*, *C* and *N* (1<=≤<=*H*<=≤<=105,<=1<=≤<=*D*,<=*C*,<=*N*<=≤<=102).","Output the minimum amount of money to within three decimal digits. You answer is considered correct, if its absolute or relative error does not exceed 10<=-<=4.

Formally, let your answer be *a*, and the jury's answer be *b*. Your answer is considered correct if .","['19 00\n255 1 100 1\n', '17 41\n1000 6 15 11\n']","['25200.0000\n', '1365.0000\n']","In the first sample Andrew can visit the store at exactly 20:00. The cat's hunger will be equal to 315, hence it will be necessary to purchase 315 buns. The discount makes the final answer 25200 roubles.

In the second sample it's optimal to visit the store right after he wakes up. Then he'll have to buy 91 bins per 15 roubles each and spend a total of 1365 roubles.",RUNTIME_ERROR,"def main():
    print(sqrt(2))
    hh, mm = map(int, input().split())
    h, d, c, n = map(int, input().split())
    needTime = max(0, 1200 - (60 * hh + mm))
    needCnt = (h + n - 1) // n
    res = min(needCnt * c, (needCnt + needTime * d) * 0.8 * c)
    print(res)

main()","def min_spending(hh, mm, H, D, C, N):

    minutes_until_discount = max(0, (20 * 60) - (hh * 60 + mm))

    hunger_after_wait = H + minutes_until_discount * D

    buns_needed_now = (H + N - 1) // N
    cost_now = buns_needed_now * C

    buns_needed_discount = (hunger_after_wait + N - 1) // N
    discounted_cost = buns_needed_discount * (C * 0.8)

    min_cost = min(cost_now, discounted_cost)

    return f""{min_cost:.4f}""

input_data = input().strip().split('\n')
hh, mm = map(int, input_data[0].split())
H, D, C, N = map(int, input_data[1].split())

print(min_spending(hh, mm, H, D, C, N))"
233,A,Perfect Permutation,PROGRAMMING,"['implementation', 'math']","A permutation is a sequence of integers *p*1,<=*p*2,<=...,<=*p**n*, consisting of *n* distinct positive integers, each of them doesn't exceed *n*. Let's denote the *i*-th element of permutation *p* as *p**i*. We'll call number *n* the size of permutation *p*1,<=*p*2,<=...,<=*p**n*.

Nickolas adores permutations. He likes some permutations more than the others. He calls such permutations perfect. A perfect permutation is such permutation *p* that for any *i* (1<=≤<=*i*<=≤<=*n*) (*n* is the permutation size) the following equations hold *p**p**i*<==<=*i* and *p**i*<=≠<=*i*. Nickolas asks you to print any perfect permutation of size *n* for the given *n*.",A single line contains a single integer *n* (1<=≤<=*n*<=≤<=100) — the permutation size.,"If a perfect permutation of size *n* doesn't exist, print a single integer -1. Otherwise print *n* distinct integers from 1 to *n*, *p*1,<=*p*2,<=...,<=*p**n* — permutation *p*, that is perfect. Separate printed numbers by whitespaces.","['1\n', '2\n', '4\n']","['-1\n', '2 1 \n', '2 1 4 3 \n']",none,WRONG_ANSWER,"import os, sys, math, heapq, itertools, bisect
from collections import deque,defaultdict, OrderedDict
ii  = lambda : int(input())                           
si  = lambda : input()                               
mi  = lambda : map(int,input().strip().split("" ""))   
msi = lambda : map(str,input().strip().split("" ""))   
li  = lambda : list(mi())                            
lsi = lambda : list(msi())                           
iseven = lambda num : num%2==0                       
isodd = lambda num : num%2==1                        
lower_alphabets = ""abcdefghijklmnopqrstuvwxyz""
upper_alphabets = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
store,dick,c,s,flag = [],{},0,0,False
postive_inf = math.inf    
negative_inf = -math.inf
isint = lambda num : isinstance(num, int)
isfloat = lambda num : isinstance(num, float)
def swap(array,a,b)->None:temp=array[b];array[b]=array[a];array[a]=temp
def flush()->None:
    global store,dick,c,s,flag
    store,dick,c,s,flag = [],{},0,0,False
def debug(*var) -> None:
    try: import master; master.debug(*var)
    except (ModuleNotFoundError,FileNotFoundError): pass    
try: import master; master.read()
except (ModuleNotFoundError,FileNotFoundError): pass

n = ii()
if n==1:
    print(-1)
else:
    l = [i for i in range(1,n+1)]
    first = l[0]
    idx = 1
    while idx < n:
        try:
            l[idx-1]=l[idx]
            idx+=1
        except IndexError: break
    l[-1] = first
    print(*l)","def perfect_permutation(n):

    if n % 2 == 1:
        return -1

    permutation = []
    for i in range(1, n + 1, 2):

        permutation.append(i + 1)
        permutation.append(i)
    
    return permutation

n = int(input().strip())

result = perfect_permutation(n)

if result == -1:
    print(result)
else:
    print(' '.join(map(str, result)))"
989,A,A Blend of Springtime,PROGRAMMING,"['implementation', 'strings']","""What a pity it's already late spring,"" sighs Mino with regret, ""one more drizzling night and they'd be gone.""

""But these blends are at their best, aren't they?"" Absorbed in the landscape, Kanno remains optimistic. 

The landscape can be expressed as a row of consecutive cells, each of which either contains a flower of colour amber or buff or canary yellow, or is empty.

When a flower withers, it disappears from the cell that it originally belonged to, and it spreads petals of its colour in its two neighbouring cells (or outside the field if the cell is on the side of the landscape). In case petals fall outside the given cells, they simply become invisible.

You are to help Kanno determine whether it's possible that after some (possibly none or all) flowers shed their petals, at least one of the cells contains all three colours, considering both petals and flowers. Note that flowers can wither in arbitrary order.","The first and only line of input contains a non-empty string $s$ consisting of uppercase English letters 'A', 'B', 'C' and characters '.' (dots) only ($\lvert s \rvert \leq 100$) — denoting cells containing an amber flower, a buff one, a canary yellow one, and no flowers, respectively.","Output ""Yes"" if it's possible that all three colours appear in some cell, and ""No"" otherwise.

You can print each letter in any case (upper or lower).","['.BAC.\n', 'AA..CB\n']","['Yes\n', 'No\n']","In the first example, the buff and canary yellow flowers can leave their petals in the central cell, blending all three colours in it.

In the second example, it's impossible to satisfy the requirement because there is no way that amber and buff meet in any cell.",OK,"def process(S):
    n = len(S)
    for i in range(n-2):
        if S[i] != '.' and S[i+1] != '.' and S[i+2] != '.' and S[i] != S[i+1] and S[i] != S[i+2] and S[i+1] != S[i+2]:
            print('Yes')
            return
    print('No')
    
S = input()
process(S)","def can_have_all_colors(s):

    n = len(s)

    for i in range(n):

        colors = set()

        if s[i] in 'ABC':
            colors.add(s[i])

        if i > 0 and s[i - 1] in 'ABC':
            colors.add(s[i - 1])

        if i < n - 1 and s[i + 1] in 'ABC':
            colors.add(s[i + 1])

        if len(colors) == 3:
            return ""Yes""

    return ""No""

import sys

input_data = sys.stdin.read().strip().split('\n')

for line in input_data:
    result = can_have_all_colors(line)
    print(result)"
955,A,Feed the cat,PROGRAMMING,"['greedy', 'math']","After waking up at *hh*:*mm*, Andrew realised that he had forgotten to feed his only cat for yet another time (guess why there's only one cat). The cat's current hunger level is *H* points, moreover each minute without food increases his hunger by *D* points.

At any time Andrew can visit the store where tasty buns are sold (you can assume that is doesn't take time to get to the store and back). One such bun costs *C* roubles and decreases hunger by *N* points. Since the demand for bakery drops heavily in the evening, there is a special 20% discount for buns starting from 20:00 (note that the cost might become rational). Of course, buns cannot be sold by parts.

Determine the minimum amount of money Andrew has to spend in order to feed his cat. The cat is considered fed if its hunger level is less than or equal to zero.","The first line contains two integers *hh* and *mm* (00<=≤<=*hh*<=≤<=23,<=00<=≤<=*mm*<=≤<=59) — the time of Andrew's awakening.

The second line contains four integers *H*, *D*, *C* and *N* (1<=≤<=*H*<=≤<=105,<=1<=≤<=*D*,<=*C*,<=*N*<=≤<=102).","Output the minimum amount of money to within three decimal digits. You answer is considered correct, if its absolute or relative error does not exceed 10<=-<=4.

Formally, let your answer be *a*, and the jury's answer be *b*. Your answer is considered correct if .","['19 00\n255 1 100 1\n', '17 41\n1000 6 15 11\n']","['25200.0000\n', '1365.0000\n']","In the first sample Andrew can visit the store at exactly 20:00. The cat's hunger will be equal to 315, hence it will be necessary to purchase 315 buns. The discount makes the final answer 25200 roubles.

In the second sample it's optimal to visit the store right after he wakes up. Then he'll have to buy 91 bins per 15 roubles each and spend a total of 1365 roubles.",WRONG_ANSWER,"import math

numbers = list(map(int, input().split()))

hh = numbers[0]
mm = numbers[1]

numbers = list(map(int, input().split()))
H = numbers[0]
D = numbers[1]
C = numbers[2]
N = numbers[3]

def func(hh, mm, H, D, C, N):
	minute = hh * 60 + mm
	if minute >= 1200:
		return C * math.ceil(H / N) * 0.8
	else:
		t = 1200 - H / (4 * D)
		if minute <= t:
			return C * math.ceil(H / N)
		else:
			return C * math.ceil((H + (1200 - minute) * D) / N) * 0.8

z = func(hh, mm, H, D, C, N)
print(""%.4f"" % z)","import math

hh, mm = map(int, input().split())

H, D, C, N = map(int, input().split())

current_hunger = H + D * (hh * 60 + mm)

def calculate_cost(hunger):
    if hunger <= 0:
        return 0
    buns_needed = math.ceil(hunger / N)
    return buns_needed * C

immediate_cost = calculate_cost(current_hunger)

discount_time = 20 * 60
current_time = hh * 60 + mm

if current_time < discount_time:

    hungry_after_wait = H + D * (discount_time)
    discounted_cost = calculate_cost(hungry_after_wait * (current_time < discount_time))

    result = min(immediate_cost, discounted_cost * 0.8)
else:
    result = immediate_cost

print(f""{result:.4f}"")"
318,A,Even Odds,PROGRAMMING,['math'],"Being a nonconformist, Volodya is displeased with the current state of things, particularly with the order of natural numbers (natural number is positive integer number). He is determined to rearrange them. But there are too many natural numbers, so Volodya decided to start with the first *n*. He writes down the following sequence of numbers: firstly all odd integers from 1 to *n* (in ascending order), then all even integers from 1 to *n* (also in ascending order). Help our hero to find out which number will stand at the position number *k*.","The only line of input contains integers *n* and *k* (1<=≤<=*k*<=≤<=*n*<=≤<=1012).

Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.",Print the number that will stand at the position number *k* after Volodya's manipulations.,"['10 3\n', '7 7\n']","['5', '6']","In the first sample Volodya's sequence will look like this: {1, 3, 5, 7, 9, 2, 4, 6, 8, 10}. The third place in the sequence is therefore occupied by the number 5.",WRONG_ANSWER,"z = list(map(int, input().split()))
n = z[0]
a = z[1]

def calculate_value(position):
    if position % 2 == 1:
        return position
    else:
        return position - 1

answer = calculate_value(a)
print(answer)","def find_number(n, k):

    odd_count = (n + 1) // 2

    if k <= odd_count:

        return 2 * k - 1
    else:

        even_index = k - odd_count

        return 2 * even_index

input_data = input().strip()
n, k = map(int, input_data.split())

result = find_number(n, k)
print(result)"
295,B,Greg and Graph,PROGRAMMING,"['dp', 'graphs', 'shortest paths']","Greg has a weighed directed graph, consisting of *n* vertices. In this graph any pair of distinct vertices has an edge between them in both directions. Greg loves playing with the graph and now he has invented a new game:
 -  The game consists of *n* steps. -  On the *i*-th step Greg removes vertex number *x**i* from the graph. As Greg removes a vertex, he also removes all the edges that go in and out of this vertex. -  Before executing each step, Greg wants to know the sum of lengths of the shortest paths between all pairs of the remaining vertices. The shortest path can go through any remaining vertex. In other words, if we assume that *d*(*i*,<=*v*,<=*u*) is the shortest path between vertices *v* and *u* in the graph that formed before deleting vertex *x**i*, then Greg wants to know the value of the following sum: . 
Help Greg, print the value of the required sum before each step.","The first line contains integer *n* (1<=≤<=*n*<=≤<=500) — the number of vertices in the graph.

Next *n* lines contain *n* integers each — the graph adjacency matrix: the *j*-th number in the *i*-th line *a**ij* (1<=≤<=*a**ij*<=≤<=105,<=*a**ii*<==<=0) represents the weight of the edge that goes from vertex *i* to vertex *j*.

The next line contains *n* distinct integers: *x*1,<=*x*2,<=...,<=*x**n* (1<=≤<=*x**i*<=≤<=*n*) — the vertices that Greg deletes.","Print *n* integers — the *i*-th number equals the required sum before the *i*-th step.

Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams of the %I64d specifier.","['1\n0\n1\n', '2\n0 5\n4 0\n1 2\n', '4\n0 3 1 1\n6 0 400 1\n2 4 0 1\n1 1 1 0\n4 1 2 3\n']","['0 ', '9 0 ', '17 23 404 0 ']",none,WRONG_ANSWER,"INF = 10**18

def floyd_warshall(matrix):
    n = len(matrix)
    dist = [[INF]*n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            if matrix[i][j] != 0:
                dist[i][j] = matrix[i][j]
            elif i == j:
                dist[i][j] = 0
    for k in range(n):
        for i in range(n):
            for j in range(n):
                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])
    return dist

n = int(input())
matrix = []
for i in range(n):
    linha = list(map(int, input().split()))
    matrix.append(linha)

dist = floyd_warshall(matrix)

removidos = list(map(int, input().split()))

resultado = []
for k in range(n-1, -1, -1):
    r = removidos[k]-1
    for i in range(n):
        for j in range(n):

            if dist[i][r] != INF and dist[r][j] != INF and dist[i][r] + dist[r][j] == dist[i][j]:
                matrix[i][j] = 0
    dist = floyd_warshall(matrix)
    s = 0
    for i in range(n):
        for j in range(i+1, n):
            s += dist[i][j]
    resultado.append(s)

for r in reversed(resultado):
    print(r, end=' ')
print()","def floyd_warshall(graph):
    """"""Run Floyd-Warshall algorithm to find shortest paths between all pairs.""""""
    n = len(graph)
    dist = [[float('inf')] * n for _ in range(n)]
    
    for i in range(n):
        for j in range(n):
            dist[i][j] = graph[i][j]
    
    for k in range(n):
        for i in range(n):
            for j in range(n):
                if dist[i][j] > dist[i][k] + dist[k][j]:
                    dist[i][j] = dist[i][k] + dist[k][j]
    
    return dist

def sum_of_shortest_paths(graph, removal_order):
    """"""Calculate the sum of shortest paths before each vertex removal.""""""
    n = len(graph)
    results = []

    dist = floyd_warshall(graph)
    
    for step in range(n):
        total_sum = sum(dist[i][j] for i in range(n) for j in range(n) if i != j)
        results.append(total_sum)

        removed_vertex = removal_order[step] - 1

        for i in range(n):
            dist[i][removed_vertex] = float('inf')
            dist[removed_vertex][i] = float('inf')

        for k in range(n):
            for i in range(n):
                for j in range(n):
                    if dist[i][j] > dist[i][k] + dist[k][j]:
                        dist[i][j] = dist[i][k] + dist[k][j]

    return results

n = int(input())
graph = [list(map(int, input().split())) for _ in range(n)]
removal_order = list(map(int, input().split()))

result = sum_of_shortest_paths(graph, removal_order)

print("" "".join(map(str, result)))"
580,C,Kefa and Park,PROGRAMMING,"['dfs and similar', 'graphs', 'trees']","Kefa decided to celebrate his first big salary by going to the restaurant. 

He lives by an unusual park. The park is a rooted tree consisting of *n* vertices with the root at vertex 1. Vertex 1 also contains Kefa's house. Unfortunaely for our hero, the park also contains cats. Kefa has already found out what are the vertices with cats in them.

The leaf vertices of the park contain restaurants. Kefa wants to choose a restaurant where he will go, but unfortunately he is very afraid of cats, so there is no way he will go to the restaurant if the path from the restaurant to his house contains more than *m* consecutive vertices with cats. 

Your task is to help Kefa count the number of restaurants where he can go.","The first line contains two integers, *n* and *m* (2<=≤<=*n*<=≤<=105, 1<=≤<=*m*<=≤<=*n*) — the number of vertices of the tree and the maximum number of consecutive vertices with cats that is still ok for Kefa.

The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n*, where each *a**i* either equals to 0 (then vertex *i* has no cat), or equals to 1 (then vertex *i* has a cat).

Next *n*<=-<=1 lines contains the edges of the tree in the format ""*x**i* *y**i*"" (without the quotes) (1<=≤<=*x**i*,<=*y**i*<=≤<=*n*, *x**i*<=≠<=*y**i*), where *x**i* and *y**i* are the vertices of the tree, connected by an edge. 

It is guaranteed that the given set of edges specifies a tree.",A single integer — the number of distinct leaves of a tree the path to which from Kefa's home contains at most *m* consecutive vertices with cats.,"['4 1\n1 1 0 0\n1 2\n1 3\n1 4\n', '7 1\n1 0 1 1 0 0 0\n1 2\n1 3\n2 4\n2 5\n3 6\n3 7\n']","['2\n', '2\n']","Let us remind you that a tree is a connected graph on *n* vertices and *n* - 1 edge. A rooted tree is a tree with a special vertex called root. In a rooted tree among any two vertices connected by an edge, one vertex is a parent (the one closer to the root), and the other one is a child. A vertex is called a leaf, if it has no children.

Note to the first sample test: <img class=""tex-graphics"" src=""https://espresso.codeforces.com/785114b4b3f5336f02078c25750f87c5a1d0b4be.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> The vertices containing cats are marked red. The restaurants are at vertices 2, 3, 4. Kefa can't go only to the restaurant located at vertex 2.

Note to the second sample test: <img class=""tex-graphics"" src=""https://espresso.codeforces.com/e5c07640680c837aec99126d94287872e69aa09a.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> The restaurants are located at vertices 4, 5, 6, 7. Kefa can't go to restaurants 6, 7.",OK,"n, m = map(int, input().split())
a = list(map(int, input().split()))

adjlist = [[] for _ in range(n)]
for i in range(n-1):
	x, y = map(int, input().split())
	adjlist[x-1] += [y-1]
	adjlist[y-1] += [x-1]

def dfs(node: int) ->int:
	seen = [0]*n
	ret = 0
	s = [(node, 0)]
	seen[node] = 1
	while s:
		cur, cat = s.pop()
		if a[cur]: cat += 1
		else: cat = 0
		if cat > m: continue
		isLeaf = True
		
		for nb in adjlist[cur]:
			if not seen[nb]:
				seen[nb] = 1
				s.append((nb, cat))
				isLeaf = False
		
		if isLeaf: ret += 1

	return ret

ans = dfs(0)

print(ans)","def count_accessible_restaurants(n, m, cats, edges):
    from collections import defaultdict, deque

    tree = defaultdict(list)
    for x, y in edges:
        tree[x].append(y)
        tree[y].append(x)

    accessible_leaves_count = 0
    visited = [False] * (n + 1)
    queue = deque([(1, 0)])

    while queue:
        vertex, consecutive_cats = queue.popleft()
        visited[vertex] = True

        if cats[vertex - 1] == 1:
            consecutive_cats += 1
        else:
            consecutive_cats = 0

        if consecutive_cats > m:
            continue

        is_leaf = True
        for neighbor in tree[vertex]:
            if not visited[neighbor]:
                is_leaf = False
                queue.append((neighbor, consecutive_cats))

        if is_leaf:
            accessible_leaves_count += 1

    return accessible_leaves_count

if __name__ == ""__main__"":
    import sys
    input_data = sys.stdin.read().strip().split('\n')

    n, m = map(int, input_data[0].split())

    cats = list(map(int, input_data[1].split()))
    edges = [tuple(map(int, line.split())) for line in input_data[2:n + 1]]

    result = count_accessible_restaurants(n, m, cats, edges)
    print(result)"
980,E,The Number Games,PROGRAMMING,"['data structures', 'greedy', 'trees']","The nation of Panel holds an annual show called The Number Games, where each district in the nation will be represented by one contestant.

The nation has $n$ districts numbered from $1$ to $n$, each district has exactly one path connecting it to every other district. The number of fans of a contestant from district $i$ is equal to $2^i$.

This year, the president decided to reduce the costs. He wants to remove $k$ contestants from the games. However, the districts of the removed contestants will be furious and will not allow anyone to cross through their districts. 

The president wants to ensure that all remaining contestants are from districts that can be reached from one another. He also wishes to maximize the total number of fans of the participating contestants.

Which contestants should the president remove?","The first line of input contains two integers $n$ and $k$ ($1 \leq k &lt; n \leq 10^6$) — the number of districts in Panel, and the number of contestants the president wishes to remove, respectively.

The next $n-1$ lines each contains two integers $a$ and $b$ ($1 \leq a, b \leq n$, $a \ne b$), that describe a road that connects two different districts $a$ and $b$ in the nation. It is guaranteed that there is exactly one path between every two districts.","Print $k$ space-separated integers: the numbers of the districts of which the contestants should be removed, in increasing order of district number.","['6 3\n2 1\n2 6\n4 2\n5 6\n2 3\n', '8 4\n2 6\n2 7\n7 8\n1 2\n3 1\n2 4\n7 5\n']","['1 3 4\n', '1 3 4 5\n']","In the first sample, the maximum possible total number of fans is $2^2 + 2^5 + 2^6 = 100$. We can achieve it by removing the contestants of the districts 1, 3, and 4.",WRONG_ANSWER,"import sys
import heapq as hp
input = sys.stdin.readline
I = lambda : list(map(int,input().split()))

n,k=I()
g=[[] for i in range(n)]
for i in range(n-1):
	a,b=I()
	g[a-1].append(b-1)
	g[b-1].append(a-1)
p=[i for i in range(n)]
def dfs(i,v):
	p[i]=v
	for x in g[i]:
		if x!=v:
			dfs(x,i)
dfs(0,0)
deg=[0]*n
for i in range(n):
	deg[i]=len(g[i])
he=[i for i in range(n) if deg[i]==1]
hp.heapify(he)
an=[]
while len(an)<k:
	x=hp.heappop(he)
	an.append(x+1)
	deg[p[x]]-=1
	if deg[p[x]]==1:
		hp.heappush(he,p[x])
an.sort()
print(*an)","def remove_contestants(n, k, connections):
    from collections import defaultdict, deque

    graph = defaultdict(list)
    for a, b in connections:
        graph[a].append(b)
        graph[b].append(a)

    fans = [2 ** i for i in range(1, n + 1)]

    visited = [False] * (n + 1)
    
    def bfs(start):
        queue = deque([start])
        component = []
        while queue:
            node = queue.popleft()
            if not visited[node]:
                visited[node] = True
                component.append(node)
                for neighbor in graph[node]:
                    if not visited[neighbor]:
                        queue.append(neighbor)
        return component

    components = []
    for i in range(1, n + 1):
        if not visited[i]:
            component = bfs(i)
            components.append(component)

    component_fans = []
    for component in components:
        total_fans = sum(fans[i - 1] for i in component)
        component_fans.append((total_fans, sorted(component)))

    component_fans.sort(reverse=True, key=lambda x: x[0])

    to_remove = []
    remaining_districts = set(range(1, n + 1))

    for i in range(len(component_fans)):
        if len(to_remove) < k:
            component = component_fans[i][1]

            if len(to_remove) + len(component) <= k:
                to_remove.extend(component)
            else:

                to_remove.extend(component[:k - len(to_remove)])
        else:
            break

    to_remove = sorted(to_remove)[:k]
    
    return to_remove

import sys
input_data = sys.stdin.read().strip().split('\n')
n, k = map(int, input_data[0].split())
connections = [tuple(map(int, line.split())) for line in input_data[1:]]

districts_to_remove = remove_contestants(n, k, connections)
print("" "".join(map(str, districts_to_remove)))"
59,A,Word,PROGRAMMING,"['implementation', 'strings']","Vasya is very upset that many people on the Net mix uppercase and lowercase letters in one word. That's why he decided to invent an extension for his favorite browser that would change the letters' register in every word so that it either only consisted of lowercase letters or, vice versa, only of uppercase ones. At that as little as possible letters should be changed in the word. For example, the word HoUse must be replaced with house, and the word ViP — with VIP. If a word contains an equal number of uppercase and lowercase letters, you should replace all the letters with lowercase ones. For example, maTRIx should be replaced by matrix. Your task is to use the given method on one given word.",The first line contains a word *s* — it consists of uppercase and lowercase Latin letters and possesses the length from 1 to 100.,"Print the corrected word *s*. If the given word *s* has strictly more uppercase letters, make the word written in the uppercase register, otherwise - in the lowercase one.","['HoUse\n', 'ViP\n', 'maTRIx\n']","['house\n', 'VIP\n', 'matrix\n']",none,OK,"def bandwagons(s):
    low=[i for i in s if i in ""abcdefghijklmnopqrstuvwxyz""]
    high=[i for i in s if i in ""ABCDEFGHIJKLMNOPQRSTUVWXYZ""]
    if len(low)>=len(high):

        return s.lower()
    else:

        return s.upper()

s=input()
print(bandwagons(s))","def correct_word_case(s):

    upper_count = sum(1 for c in s if c.isupper())
    lower_count = len(s) - upper_count

    if upper_count > lower_count:
        return s.upper()
    else:
        return s.lower()

input_words = ['HoUse\n', 'ViP\n', 'maTRIx\n']
output_words = []

for word in input_words:
    corrected_word = correct_word_case(word.strip())
    output_words.append(corrected_word + '\n')

print(output_words)"
811,B,Vladik and Complicated Book,PROGRAMMING,"['implementation', 'sortings']","Vladik had started reading a complicated book about algorithms containing *n* pages. To improve understanding of what is written, his friends advised him to read pages in some order given by permutation *P*<==<=[*p*1,<=*p*2,<=...,<=*p**n*], where *p**i* denotes the number of page that should be read *i*-th in turn.

Sometimes Vladik’s mom sorted some subsegment of permutation *P* from position *l* to position *r* inclusive, because she loves the order. For every of such sorting Vladik knows number *x* — what index of page in permutation he should read. He is wondered if the page, which he will read after sorting, has changed. In other words, has *p**x* changed? After every sorting Vladik return permutation to initial state, so you can assume that each sorting is independent from each other.","First line contains two space-separated integers *n*, *m* (1<=≤<=*n*,<=*m*<=≤<=104) — length of permutation and number of times Vladik's mom sorted some subsegment of the book.

Second line contains *n* space-separated integers *p*1,<=*p*2,<=...,<=*p**n* (1<=≤<=*p**i*<=≤<=*n*) — permutation *P*. Note that elements in permutation are distinct.

Each of the next *m* lines contains three space-separated integers *l**i*, *r**i*, *x**i* (1<=≤<=*l**i*<=≤<=*x**i*<=≤<=*r**i*<=≤<=*n*) — left and right borders of sorted subsegment in *i*-th sorting and position that is interesting to Vladik.","For each mom’s sorting on it’s own line print ""Yes"", if page which is interesting to Vladik hasn't changed, or ""No"" otherwise.","['5 5\n5 4 3 2 1\n1 5 3\n1 3 1\n2 4 3\n4 4 4\n2 5 3\n', '6 5\n1 4 3 2 5 6\n2 4 3\n1 6 2\n4 5 4\n1 3 3\n2 6 3\n']","['Yes\nNo\nYes\nYes\nNo\n', 'Yes\nNo\nYes\nNo\nYes\n']","Explanation of first test case: 
 1.  [1, 2, 3, 4, 5] — permutation after sorting, 3-rd element hasn’t changed, so answer is ""Yes"". 1.  [3, 4, 5, 2, 1] — permutation after sorting, 1-st element has changed, so answer is ""No"". 1.  [5, 2, 3, 4, 1] — permutation after sorting, 3-rd element hasn’t changed, so answer is ""Yes"". 1.  [5, 4, 3, 2, 1] — permutation after sorting, 4-th element hasn’t changed, so answer is ""Yes"". 1.  [5, 1, 2, 3, 4] — permutation after sorting, 3-rd element has changed, so answer is ""No"".",TIME_LIMIT_EXCEEDED,"def main():
    N, M = map(int, input().split())

    P = list(map(int, input().split()))

    for m in range(M):
        l,r,x = map(lambda x:int(x)-1, input().split())
        if not (l <= x <= r):
            print(""Yes"")
            continue

        ix = x - l

        rank = 0
        for p in P[l:r+1]:
            if P[x] == p:
                continue
            if p < P[x]:
                rank += 1
                if rank > ix:
                    break

        if rank == ix:
            print(""Yes"")
        else:
            print(""No"")

if __name__ == ""__main__"":

    main()","def check_permutation_change(n, m, p, operations):
    results = []
    for l, r, x in operations:

        subsegment = p[l-1:r]
        sorted_subsegment = sorted(subsegment)

        new_permutation = p[:l-1] + sorted_subsegment + p[r:]

        if new_permutation[x-1] == p[x-1]:
            results.append(""Yes"")
        else:
            results.append(""No"")
    
    return results

def main():
    import sys
    
    input_data = sys.stdin.read().strip().split('\n')

    n, m = map(int, input_data[0].split())

    p = list(map(int, input_data[1].split()))
    
    operations = []
    for i in range(2, 2 + m):
        l, r, x = map(int, input_data[i].split())
        operations.append((l, r, x))

    results = check_permutation_change(n, m, p, operations)

    print('\n'.join(results))

if __name__ == ""__main__"":
    main()"
9,A,Die Roll,PROGRAMMING,"['math', 'probabilities']","Yakko, Wakko and Dot, world-famous animaniacs, decided to rest from acting in cartoons, and take a leave to travel a bit. Yakko dreamt to go to Pennsylvania, his Motherland and the Motherland of his ancestors. Wakko thought about Tasmania, its beaches, sun and sea. Dot chose Transylvania as the most mysterious and unpredictable place.

But to their great regret, the leave turned to be very short, so it will be enough to visit one of the three above named places. That's why Yakko, as the cleverest, came up with a truly genius idea: let each of the three roll an ordinary six-sided die, and the one with the highest amount of points will be the winner, and will take the other two to the place of his/her dreams.

Yakko thrown a die and got Y points, Wakko — W points. It was Dot's turn. But she didn't hurry. Dot wanted to know for sure what were her chances to visit Transylvania.

It is known that Yakko and Wakko are true gentlemen, that's why if they have the same amount of points with Dot, they will let Dot win.",The only line of the input file contains two natural numbers Y and W — the results of Yakko's and Wakko's die rolls.,"Output the required probability in the form of irreducible fraction in format «A/B», where A — the numerator, and B — the denominator. If the required probability equals to zero, output «0/1». If the required probability equals to 1, output «1/1».",['4 2\n'],['1/2\n'],"Dot will go to Transylvania, if she is lucky to roll 4, 5 or 6 points.",WRONG_ANSWER,"def find_greatest(arr):
    gr = arr[0]
    gr_index = 0

    for i in range(len(arr)):
        if arr[i] > gr:
            gr = arr[i]
            gr_index = i

    return gr_index

def cut(a, b):

    if b % a == 0:
        b /= a
        a /= a
    elif (b % 2 and a % 2) == 0:
        b /= 2
        a /= 2
    elif (b % 3 and a % 3) == 0:
        b /= 3
        a /= 3

    return (""{}/{}"".format(int(a), int(b)))

throws = list(map(int, input().split("" "")))

big = throws[find_greatest(throws)]

need_cnt = 7 - big

print(cut(need_cnt, 6))","from math import gcd

def calculate_probability(y, w):

    max_roll = max(y, w)

    successful_outcomes = 6 - max_roll + 1

    total_outcomes = 6

    if successful_outcomes == 0:
        return ""0/1""

    elif successful_outcomes == total_outcomes:
        return ""1/1""

    numerator = successful_outcomes
    denominator = total_outcomes
    common_divisor = gcd(numerator, denominator)

    return f""{numerator // common_divisor}/{denominator // common_divisor}""

input_data = input().strip()
y, w = map(int, input_data.split())

result = calculate_probability(y, w)
print(result)"
858,A,k-rounding,PROGRAMMING,"['brute force', 'math', 'number theory']","For a given positive integer *n* denote its *k*-rounding as the minimum positive integer *x*, such that *x* ends with *k* or more zeros in base 10 and is divisible by *n*.

For example, 4-rounding of 375 is 375·80<==<=30000. 30000 is the minimum integer such that it ends with 4 or more zeros and is divisible by 375.

Write a program that will perform the *k*-rounding of *n*.","The only line contains two integers *n* and *k* (1<=≤<=*n*<=≤<=109, 0<=≤<=*k*<=≤<=8).",Print the *k*-rounding of *n*.,"['375 4\n', '10000 1\n', '38101 0\n', '123456789 8\n']","['30000\n', '10000\n', '38101\n', '12345678900000000\n']",none,WRONG_ANSWER,"import math
def function(n, k):
    multi=[]
    zero_count=[]
    for i in range(1, 11):
        total=0
        multi.append(n*i)
        c=str(n*i)
        l=list(c)
        l1=l[::-1]
        for j in l1:
            if j=='0':
                total+=1
            if j!='0':
                break
        zero_count.append(total)

    if k in zero_count:
        print(multi[zero_count.index(k)])
    if k not in zero_count:
        if k<min(zero_count):
            print(multi[0])
        if k>min(zero_count):
            c=multi[zero_count.index(max(zero_count))]
            s=str(c)

            for k in range(abs(max(zero_count)-k)):
                s+='0'
            print(s)
if __name__==""__main__"":
    n, k=map(int, input().rstrip().split())
    function(n, k)","def k_rounding(n, k):

    factor = 10 ** k

    x = n
    while x % factor != 0:
        x += n
    
    return x

if __name__ == ""__main__"":
    import sys

    input_lines = sys.stdin.read().strip().split(""\n"")

    results = []
    for line in input_lines:
        n, k = map(int, line.split())
        result = k_rounding(n, k)
        results.append(f""{result}\n"")

    print(''.join(results))"
908,E,New Year and Entity Enumeration,PROGRAMMING,"['bitmasks', 'combinatorics', 'dp', 'math']","You are given an integer *m*.

Let *M*<==<=2*m*<=-<=1.

You are also given a set of *n* integers denoted as the set *T*. The integers will be provided in base 2 as *n* binary strings of length *m*.

A set of integers *S* is called ""good"" if the following hold. 
 1.  If , then . 1.  If , then  1.   1.  All elements of *S* are less than or equal to *M*. 
Here,  and  refer to the bitwise XOR and bitwise AND operators, respectively.

Count the number of good sets *S*, modulo 109<=+<=7.","The first line will contain two integers *m* and *n* (1<=≤<=*m*<=≤<=1<=000, 1<=≤<=*n*<=≤<=*min*(2*m*,<=50)).

The next *n* lines will contain the elements of *T*. Each line will contain exactly *m* zeros and ones. Elements of *T* will be distinct.","Print a single integer, the number of good sets modulo 109<=+<=7.","['5 3\n11010\n00101\n11000\n', '30 2\n010101010101010010101010101010\n110110110110110011011011011011\n']","['4\n', '860616440\n']","An example of a valid set *S* is {00000, 00101, 00010, 00111, 11000, 11010, 11101, 11111}.",OK,"from collections import defaultdict

def E1():

    mod = 10 ** 9 + 7

    comb = [[1]]
    for i in range(1, 1010):
        x = [1]
        for j in range(1, i):
            x.append((comb[i - 1][j - 1] + comb[i - 1][j]) % mod)
        x.append(1)
        comb.append(x)

    dp = [1]
    for i in range(1, 1010):
        r = 0
        for k in range(i):
            r += dp[k] * comb[i - 1][k]
            r %= mod
        dp.append(r)

    m, n = map(int, input().split())

    ns = [0 for __ in range(m)]
    for j in range(n):
        temp = input()
        s = [int(i) for i in temp]
        for i in range(m):
            ns[i] |= s[i] << j

    dd = defaultdict(int)
    for e in ns:
        dd[e] += 1

    ans = 1
    for b in dd.values():
        ans = ans * dp[b] % mod

    print(ans)

if __name__=='__main__':
    E1()","def count_good_sets(m, n, T):

    T_set = {int(t, 2) for t in T}

    M = (1 << m) - 1

    def is_good(S):

        for a in S:
            for b in S:
                if a == b:
                    continue
                if (a ^ b) in S or (a & b) in S:
                    return False
        return all(x <= M for x in S)

    good_set_count = 0

    from itertools import combinations

    for r in range(len(T_set) + 1):
        for subset in combinations(T_set, r):
            if is_good(subset):
                good_set_count += 1

    return good_set_count % (10**9 + 7)

import sys

input_data = sys.stdin.read().strip().splitlines()
first_line = input_data[0].split()
m, n = int(first_line[0]), int(first_line[1])
T = input_data[1:]

result = count_good_sets(m, n, T)
print(result)"
313,B,Ilya and Queries,PROGRAMMING,"['dp', 'implementation']","Ilya the Lion wants to help all his friends with passing exams. They need to solve the following problem to pass the IT exam.

You've got string *s*<==<=*s*1*s*2... *s**n* (*n* is the length of the string), consisting only of characters ""."" and ""#"" and *m* queries. Each query is described by a pair of integers *l**i*,<=*r**i* (1<=≤<=*l**i*<=&lt;<=*r**i*<=≤<=*n*). The answer to the query *l**i*,<=*r**i* is the number of such integers *i* (*l**i*<=≤<=*i*<=&lt;<=*r**i*), that *s**i*<==<=*s**i*<=+<=1.

Ilya the Lion wants to help his friends but is there anyone to help him? Help Ilya, solve the problem.","The first line contains string *s* of length *n* (2<=≤<=*n*<=≤<=105). It is guaranteed that the given string only consists of characters ""."" and ""#"".

The next line contains integer *m* (1<=≤<=*m*<=≤<=105) — the number of queries. Each of the next *m* lines contains the description of the corresponding query. The *i*-th line contains integers *l**i*,<=*r**i* (1<=≤<=*l**i*<=&lt;<=*r**i*<=≤<=*n*).",Print *m* integers — the answers to the queries in the order in which they are given in the input.,"['......\n4\n3 4\n2 3\n1 6\n2 6\n', '#..###\n5\n1 3\n5 6\n1 5\n3 6\n3 4\n']","['1\n1\n5\n4\n', '1\n1\n2\n2\n0\n']",none,WRONG_ANSWER,"def solve(n, m):
    
    
    return m-n

s = input()
t = int(input())
while t:
    n, m = map(int, input().split())
    print(solve(n, m))
    t-=1","def count_dots(s, queries):
    n = len(s)
    results = []

    prefix = [0] * (n + 1)
    for i in range(1, n + 1):
        prefix[i] = prefix[i - 1] + (1 if s[i - 1] == '.' else 0)

    for l, r in queries:

        results.append(prefix[r] - prefix[l - 1])
    
    return results

def main():
    import sys
    input_data = sys.stdin.read().strip().split('\n')
    
    s = input_data[0]
    m = int(input_data[1])
    queries = [tuple(map(int, line.split())) for line in input_data[2:2 + m]]
    
    results = count_dots(s, queries)

    print('\n'.join(map(str, results)))

if __name__ == ""__main__"":
    main()"
891,A,Pride,PROGRAMMING,"['brute force', 'dp', 'greedy', 'math', 'number theory']","You have an array *a* with length *n*, you can perform operations. Each operation is like this: choose two adjacent elements from *a*, say *x* and *y*, and replace one of them with *gcd*(*x*,<=*y*), where *gcd* denotes the [greatest common divisor](https://en.wikipedia.org/wiki/Greatest_common_divisor).

What is the minimum number of operations you need to make all of the elements equal to 1?","The first line of the input contains one integer *n* (1<=≤<=*n*<=≤<=2000) — the number of elements in the array.

The second line contains *n* space separated integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=109) — the elements of the array.","Print -1, if it is impossible to turn all numbers to 1. Otherwise, print the minimum number of operations needed to make all numbers equal to 1.","['5\n2 2 3 4 6\n', '4\n2 4 6 8\n', '3\n2 6 9\n']","['5\n', '-1\n', '4\n']","In the first sample you can turn all numbers to 1 using the following 5 moves:
 -  [2, 2, 3, 4, 6]. -  [2, 1, 3, 4, 6] -  [2, 1, 3, 1, 6] -  [2, 1, 1, 1, 6] -  [1, 1, 1, 1, 6] -  [1, 1, 1, 1, 1] 
We can prove that in this case it is not possible to make all numbers one using less than 5 moves.",WRONG_ANSWER,"n = int(input())
a = list(map(int,input().split()))

def computeGCD(x, y):
   while(y): 
       x, y = y, x % y
   return x

gcd = []

for i in range(n-1):
    gcd.append(computeGCD(a[i],a[i+1]))

z = len(set(gcd))

if z==1:
    print(-1)
elif (1 in gcd):
    print(n)
elif z==2:
    print(n+1)
else:
    counters = []
    temp_count = 1
    for i in range(1,len(gcd)):
        if gcd[i]!=gcd[i-1]:
            counters.append(temp_count)
            temp_count = 1
        else:
            temp_count +=1
    counters.append(temp_count)
    print(min(counters[1::2])+n+1)","import math
from sys import stdin, stdout
from collections import deque

n = int(stdin.readline().strip())
a = list(map(int, stdin.readline().strip().split()))

def can_make_one(arr):
    for num in arr:
        if math.gcd(num, 1) != 1:
            return False
    return True

if not can_make_one(a):
    stdout.write('-1\n')
else:
    operations = 0
    found_one = False

    for i in range(n - 1):
        if a[i] == 1 or a[i + 1] == 1:
            found_one = True
            break
        while a[i] != 1 and a[i + 1] != 1:

            if a[i] > a[i + 1]:
                a[i] = math.gcd(a[i], a[i + 1])
            else:
                a[i + 1] = math.gcd(a[i], a[i + 1])
            operations += 1

    if found_one:
        while any(x != 1 for x in a):
            for j in range(n - 1):
                if a[j] != 1 and a[j + 1] == 1:
                    operations += 1
                    a[j] = 1

    stdout.write(f'{operations}\n')"
448,B,Suffix Structures,PROGRAMMING,"['implementation', 'strings']","Bizon the Champion isn't just a bison. He also is a favorite of the ""Bizons"" team.

At a competition the ""Bizons"" got the following problem: ""You are given two distinct words (strings of English letters), *s* and *t*. You need to transform word *s* into word *t*"". The task looked simple to the guys because they know the suffix data structures well. Bizon Senior loves suffix automaton. By applying it once to a string, he can remove from this string any single character. Bizon Middle knows suffix array well. By applying it once to a string, he can swap any two characters of this string. The guys do not know anything about the suffix tree, but it can help them do much more. 

Bizon the Champion wonders whether the ""Bizons"" can solve the problem. Perhaps, the solution do not require both data structures. Find out whether the guys can solve the problem and if they can, how do they do it? Can they solve it either only with use of suffix automaton or only with use of suffix array or they need both structures? Note that any structure may be used an unlimited number of times, the structures may be used in any order.",The first line contains a non-empty word *s*. The second line contains a non-empty word *t*. Words *s* and *t* are different. Each word consists only of lowercase English letters. Each word contains at most 100 letters.,"In the single line print the answer to the problem. Print ""need tree"" (without the quotes) if word *s* cannot be transformed into word *t* even with use of both suffix array and suffix automaton. Print ""automaton"" (without the quotes) if you need only the suffix automaton to solve the problem. Print ""array"" (without the quotes) if you need only the suffix array to solve the problem. Print ""both"" (without the quotes), if you need both data structures to solve the problem.

It's guaranteed that if you can solve the problem only with use of suffix array, then it is impossible to solve it only with use of suffix automaton. This is also true for suffix automaton.","['automaton\ntomat\n', 'array\narary\n', 'both\nhot\n', 'need\ntree\n']","['automaton\n', 'array\n', 'both\n', 'need tree\n']","In the third sample you can act like that: first transform ""both"" into ""oth"" by removing the first character using the suffix automaton and then make two swaps of the string using the suffix array and get ""hot"".",WRONG_ANSWER,"def automaton(palavra, alvo):
    
    index = palavra.find(alvo)
    if index == -1:
        return False
    else:
        return True
    
def array(palavra, alvo):
    
    if len(palavra) != len(alvo):
        return False

    nPalavra = {}
    for w in palavra:
        if w not in nPalavra:
            nPalavra[w] = 1
        else:
            nPalavra[w] += 1
            
    nAlvo = {}
    for w in alvo: 
        if w not in nAlvo:
            nAlvo[w] = 1
        else:
            nAlvo[w] += 1
            
    if nAlvo == nPalavra:
        return True
    
    return False
    
def both(palavra, alvo):
    
    aux = list(palavra)
    alvoSet = set(alvo)
    
    for w in palavra:
        if w not in alvoSet:
            
            while w in aux:
                aux.remove(w)
                
    if array(''.join(aux), alvo):
        return True
    
    return False

palavra = input()
alvo = input()

if automaton(palavra, alvo):
    print(""automaton"")
    
elif array(palavra, alvo):
    print(""array"")

elif both(palavra, alvo):
    print(""both"")
    
else:
    print(""need tree"")","def can_transform(s, t):

    it = iter(s)
    if all(char in it for char in t:
        return ""automaton""

    from collections import Counter
    count_s = Counter(s)
    count_t = Counter(t)

    for char in count_t:
        if count_t[char] > count_s.get(char, 0):
            return ""need tree""

    if len(s) == len(t) and sorted(s) == sorted(t):
        return ""array""
    
    return ""both""

input_data = ['automaton\ntomat\n', 'array\narary\n', 'both\nhot\n', 'need\ntree\n']
output = []

for case in input_data:
    s, t = case.split()
    output.append(can_transform(s, t))

for result in output:
    print(result)"
131,B,Opposites Attract,PROGRAMMING,"['implementation', 'math']","Everybody knows that opposites attract. That is the key principle of the ""Perfect Matching"" dating agency. The ""Perfect Matching"" matchmakers have classified each registered customer by his interests and assigned to the *i*-th client number *t**i* (<=-<=10<=≤<=*t**i*<=≤<=10). Of course, one number can be assigned to any number of customers.

""Perfect Matching"" wants to advertise its services and publish the number of opposite couples, that is, the couples who have opposite values of *t*. Each couple consists of exactly two clients. The customer can be included in a couple an arbitrary number of times. Help the agency and write the program that will find the sought number by the given sequence *t*1,<=*t*2,<=...,<=*t**n*. For example, if *t*<==<=(1,<=<=-<=1,<=1,<=<=-<=1), then any two elements *t**i* and *t**j* form a couple if *i* and *j* have different parity. Consequently, in this case the sought number equals 4.

Of course, a client can't form a couple with him/herself.","The first line of the input data contains an integer *n* (1<=≤<=*n*<=≤<=105) which represents the number of registered clients of the ""Couple Matching"". The second line contains a sequence of integers *t*1,<=*t*2,<=...,<=*t**n* (<=-<=10<=≤<=*t**i*<=≤<=10), *t**i* — is the parameter of the *i*-th customer that has been assigned to the customer by the result of the analysis of his interests.","Print the number of couples of customs with opposite *t*. The opposite number for *x* is number <=-<=*x* (0 is opposite to itself). Couples that only differ in the clients' order are considered the same.

Note that the answer to the problem can be large enough, so you must use the 64-bit integer type for calculations. Please, do not use the %lld specificator to read or write 64-bit integers in С++. It is preferred to use cin, cout streams or the %I64d specificator.","['5\n-3 3 0 0 3\n', '3\n0 0 0\n']","['3\n', '3\n']","In the first sample the couples of opposite clients are: (1,2), (1,5) и (3,4).

In the second sample any couple of clients is opposite.",WRONG_ANSWER,"import collections
import math
sums = lambda n: int(n * (n + 1) / 2)
sumsqur = lambda n: int( (n) * (n + 1) * (2*n +1)/6)

def im(): return map(int, input().split())
def il(): return list(map(int, input().split()))
def ii(): return int(input())

def isPalindrom(a):
    return True if a[::-1] == a else False

def solve():
    n=ii()
    s=il()
    a=[0]*11
    b=[0]*11
    for i in s:
        if i>=0:
            a[i]+=1
        else:
            b[-i]+=1
    count=a[0]
    for i in range(1,11):
        count+=min(a[i],b[i])
    return count

if __name__ == '__main__':

    print(solve())","def count_opposite_couples(n, interests):
    from collections import Counter

    counts = Counter(interests)
    total_couples = 0

    for num in counts:
        opposite_num = -num
        if opposite_num in counts:

            total_couples += counts[num] * counts[opposite_num]

    return total_couples

n = int(input().strip())
interests = list(map(int, input().strip().split()))

result = count_opposite_couples(n, interests)

print(result)"
520,A,Pangram,PROGRAMMING,"['implementation', 'strings']","A word or a sentence in some language is called a pangram if all the characters of the alphabet of this language appear in it at least once. Pangrams are often used to demonstrate fonts in printing or test the output devices.

You are given a string consisting of lowercase and uppercase Latin letters. Check whether this string is a pangram. We say that the string contains a letter of the Latin alphabet if this letter occurs in the string in uppercase or lowercase.","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=100) — the number of characters in the string.

The second line contains the string. The string consists only of uppercase and lowercase Latin letters.","Output ""YES"", if the string is a pangram and ""NO"" otherwise.","['12\ntoosmallword\n', '35\nTheQuickBrownFoxJumpsOverTheLazyDog\n']","['NO\n', 'YES\n']",none,OK,"str = ""abcdefghijklmnopqrstuvwxyz""
list = list(str)
dicList = []
freq = {}

n = int(input())
s = input().lower()

for char in s:
    if char in freq:
        freq[char] += 1

    else:
        freq[char] = 1

for key in freq.keys():
    dicList.append(key)

if sorted(list) == sorted(dicList):
    print(""YES"")
else:
    print(""NO"")","def is_pangram(n, s):

    alphabet_set = set('abcdefghijklmnopqrstuvwxyz')

    input_set = set(s.lower())

    return alphabet_set.issubset(input_set)

n = int(input().strip())
s = input().strip()

if is_pangram(n, s):
    print(""YES"")
else:
    print(""NO"")"
304,B,Calendar,PROGRAMMING,"['brute force', 'implementation']","Calendars in widespread use today include the Gregorian calendar, which is the de facto international standard, and is used almost everywhere in the world for civil purposes. The Gregorian reform modified the Julian calendar's scheme of leap years as follows:

 Every year that is exactly divisible by four is a leap year, except for years that are exactly divisible by 100; the centurial years that are exactly divisible by 400 are still leap years. For example, the year 1900 is not a leap year; the year 2000 is a leap year. 

In this problem, you have been given two dates and your task is to calculate how many days are between them. Note, that leap years have unusual number of days in February.

Look at the sample to understand what borders are included in the aswer.","The first two lines contain two dates, each date is in the format yyyy:mm:dd (1900<=≤<=*yyyy*<=≤<=2038 and yyyy:mm:dd is a legal date).",Print a single integer — the answer to the problem.,"['1900:01:01\n2038:12:31\n', '1996:03:09\n1991:11:12\n']","['50768\n', '1579\n']",none,WRONG_ANSWER,"from sys import stdin
def input(): return stdin.readline()[:-1]
def ili(): return list(map(int, input().split()))

y1,m1,d1=map(int, input().split(':'))
y2,m2,d2=map(int, input().split(':'))
days = 0
if y1*100000+m1*100+d1 > y2*100000+m2*100+d2:

    y1, y2 = y2, y1
    m1, m2 = m2, m1
    d1, d2 = d2, d1
for i in range(y1+1,y2):
    if (i%4 == 0 and i%100 != 0) or i%400 == 0:
        days += 366
        continue
    days += 365
for l in range(1, m2+1):
    if l == m2:

        days += d2
        break
    if l == 1 or l == 3 or l == 5 or l == 7 or l == 8 or l == 10 or l == 12:
        days += 31
    elif l == 4 or l == 6 or l == 9 or l == 11:
        days += 30
    elif l == 2:
        days += 28
        if (y2%4 == 0 and y2%100 != 0) or y2%400 == 0:
            days += 1
days += 365
if (y1%4 == 0 and y1%100 != 0) or y1%400 == 0:
    days += 1

for l in range(1, m1+1):
    if l == m1:
        days -= d1
        break
    if l == 1 or l == 3 or l == 5 or l == 7 or l == 8 or l == 10 or l == 12:
        days -= 31
    elif l == 4 or l == 6 or l == 9 or l == 11:
        days -= 30
    elif l == 2:
        days -= 28
        if (y1%4 == 0 and y1%100 != 0) or y1%400 == 0:

            days -= 1
print(days)","from datetime import datetime

def days_between_dates(date1: str, date2: str) -> int:

    date_format = ""%Y:%m:%d""

    start_date = datetime.strptime(date1.strip(), date_format)
    end_date = datetime.strptime(date2.strip(), date_format)

    delta = abs((end_date - start_date).days)
    
    return delta

date1 = input().strip()
date2 = input().strip()

print(days_between_dates(date1, date2))"
0,none,none,none,['none'],"Bear Limak examines a social network. Its main functionality is that two members can become friends (then they can talk with each other and share funny pictures).

There are *n* members, numbered 1 through *n*. *m* pairs of members are friends. Of course, a member can't be a friend with themselves.

Let A-B denote that members A and B are friends. Limak thinks that a network is reasonable if and only if the following condition is satisfied: For every three distinct members (X, Y, Z), if X-Y and Y-Z then also X-Z.

For example: if Alan and Bob are friends, and Bob and Ciri are friends, then Alan and Ciri should be friends as well.

Can you help Limak and check if the network is reasonable? Print ""YES"" or ""NO"" accordingly, without the quotes.","The first line of the input contain two integers *n* and *m* (3<=≤<=*n*<=≤<=150<=000, ) — the number of members and the number of pairs of members that are friends.

The *i*-th of the next *m* lines contains two distinct integers *a**i* and *b**i* (1<=≤<=*a**i*,<=*b**i*<=≤<=*n*,<=*a**i*<=≠<=*b**i*). Members *a**i* and *b**i* are friends with each other. No pair of members will appear more than once in the input.","If the given network is reasonable, print ""YES"" in a single line (without the quotes). Otherwise, print ""NO"" in a single line (without the quotes).","['4 3\n1 3\n3 4\n1 4\n', '4 4\n3 1\n2 3\n3 4\n1 2\n', '10 4\n4 3\n5 10\n8 9\n1 2\n', '3 2\n1 2\n2 3\n']","['YES\n', 'NO\n', 'YES\n', 'NO\n']","The drawings below show the situation in the first sample (on the left) and in the second sample (on the right). Each edge represents two members that are friends. The answer is ""NO"" in the second sample because members (2, 3) are friends and members (3, 4) are friends, while members (2, 4) are not.",WRONG_ANSWER,"def dfs(ver, par, amigos, visitados):
    visitados[ver] = True
    for vecino in amigos[ver]:
        if not visitados[vecino]:
            dfs(vecino, par, amigos, visitados)
        else:
            if par != vecino:
                return False
    return True

def es_red_racional(n, m, relaciones):
    amigos = [[] for _ in range(n)]
    for a, b in relaciones:
        amigos[a - 1].append(b - 1)
        amigos[b - 1].append(a - 1)

    visitados = [False] * n

    for i in range(n):
        if not visitados[i]:
            if not dfs(i, -1, amigos, visitados):
                return ""NO""

    return ""YES""

n, m = map(int, input().split())
relaciones = []
for _ in range(m):
    a, b = map(int, input().split())
    relaciones.append((a, b))

resultado = es_red_racional(n, m, relaciones)
print(resultado)","def is_network_reasonable(n, m, friendships):

    adjacency_list = {i: set() for i in range(1, n + 1)}

    for a, b in friendships:
        adjacency_list[a].add(b)
        adjacency_list[b].add(a)

    for y in range(1, n + 1):
        friends_of_y = list(adjacency_list[y])
        k = len(friends_of_y)

        for i in range(k):
            for j in range(i + 1, k):
                x = friends_of_y[i]
                z = friends_of_y[j]

                if z not in adjacency_list[x]:
                    return ""NO""
    
    return ""YES""

def main():
    import sys
    input = sys.stdin.read
    data = input().splitlines()

    n, m = map(int, data[0].split())
    
    friendships = []
    for i in range(1, m + 1):
        a, b = map(int, data[i].split())
        friendships.append((a, b))

    result = is_network_reasonable(n, m, friendships)
    print(result)

if __name__ == ""__main__"":
    main()"
522,D,Closest Equals,PROGRAMMING,"['*special', 'data structures']","You are given sequence *a*1,<=*a*2,<=...,<=*a**n* and *m* queries *l**j*,<=*r**j* (1<=≤<=*l**j*<=≤<=*r**j*<=≤<=*n*). For each query you need to print the minimum distance between such pair of elements *a**x* and *a**y* (*x*<=≠<=*y*), that:
 -  both indexes of the elements lie within range [*l**j*,<=*r**j*], that is, *l**j*<=≤<=*x*,<=*y*<=≤<=*r**j*; -  the values of the elements are equal, that is *a**x*<==<=*a**y*. 
The text above understands distance as |*x*<=-<=*y*|.","The first line of the input contains a pair of integers *n*, *m* (1<=≤<=*n*,<=*m*<=≤<=5·105) — the length of the sequence and the number of queries, correspondingly. 

The second line contains the sequence of integers *a*1,<=*a*2,<=...,<=*a**n* (<=-<=109<=≤<=*a**i*<=≤<=109). 

Next *m* lines contain the queries, one per line. Each query is given by a pair of numbers *l**j*,<=*r**j* (1<=≤<=*l**j*<=≤<=*r**j*<=≤<=*n*) — the indexes of the query range limits.","Print *m* integers — the answers to each query. If there is no valid match for some query, please print -1 as an answer to this query.","['5 3\n1 1 2 3 2\n1 5\n2 4\n3 5\n', '6 5\n1 2 1 3 2 3\n4 6\n1 3\n2 5\n2 4\n1 6\n']","['1\n-1\n2\n', '2\n2\n3\n-1\n2\n']",none,WRONG_ANSWER,"def find1(X, l, r):
    m = len(X)
    if r < X[0]:
        return float('inf')
    if X[-1] < l:
        return float('inf')
    if l <= X[0]:
        left_point = 0
    else:
        s = 0
        e = m-1
        while s+1 < e:
            mid = (s+e)//2
            if X[mid] > l:
                s, e = mid, e
            else:
                s, e = s, mid
        left_point = e
    if X[-1] <= r:
        right_point = m-1
    else:
        s = 0
        e = m-1
        while s+1 < e:
            mid = (s+e)//2
            if X[mid] <= r:
                s, e = mid, e
            else:
                s, e = s, mid
        right_point = s
    if left_point==right_point:
        return float('inf')
    return X[right_point]-X[left_point]

def process(A, Q):
    d = {}
    n = len(A)
    answer = []
    for i in range(n):
        x = A[i]
        if x not in d:
            d[x] = []
        d[x].append(i)
    for l, r in Q:
        my_min = float('inf')
        for x in d:
            my_min = min(my_min, find1(d[x], l-1, r-1))
        if my_min==float('inf'):
            answer.append(-1)
        else:
            answer.append(my_min)
    return answer

n, m = [int(x) for x in input().split()]
A = [int(x) for x in input().split()]
Q = []
for i in range(m):
    l, r = [int(x) for x in input().split()]
    Q.append([l, r])
answer = process(A, Q)
for x in answer:
    print(x)","def minimum_distance(n, m, sequence, queries):
    from collections import defaultdict

    indices = defaultdict(list)

    for i in range(n):
        indices[sequence[i]].append(i + 1)

    results = []

    for l, r in queries:
        min_distance = float('inf')
        found = False

        for value in indices:
            positions = indices[value]

            filtered_positions = [pos for pos in positions if l <= pos <= r]

            if len(filtered_positions) > 1:
                for i in range(len(filtered_positions) - 1):

                    distance = filtered_positions[i + 1] - filtered_positions[i]
                    if distance < min_distance:
                        min_distance = distance
                        found = True

        if found:
            results.append(min_distance)
        else:
            results.append(-1)

    return results

input_data = ['5 3\n1 1 2 3 2\n1 5\n2 4\n3 5\n', '6 5\n1 2 1 3 2 3\n4 6\n1 3\n2 5\n2 4\n1 6\n']
outputs = []

for data in input_data:
    n, m_and_sequence = data.split('\n', 1)
    n, m = map(int, n.split())
    sequence_and_queries = m_and_sequence.strip().split('\n')
    sequence = list(map(int, sequence_and_queries[0].split()))
    queries = [tuple(map(int, query.split())) for query in sequence_and_queries[1:m + 1]]
    
    result = minimum_distance(n, m, sequence, queries)
    outputs.append('\n'.join(map(str, result)))

print('\n\n'.join(outputs))"
678,C,Joty and Chocolate,PROGRAMMING,"['implementation', 'math', 'number theory']","Little Joty has got a task to do. She has a line of *n* tiles indexed from 1 to *n*. She has to paint them in a strange pattern.

An unpainted tile should be painted Red if it's index is divisible by *a* and an unpainted tile should be painted Blue if it's index is divisible by *b*. So the tile with the number divisible by *a* and *b* can be either painted Red or Blue.

After her painting is done, she will get *p* chocolates for each tile that is painted Red and *q* chocolates for each tile that is painted Blue.

Note that she can paint tiles in any order she wants.

Given the required information, find the maximum number of chocolates Joty can get.","The only line contains five integers *n*, *a*, *b*, *p* and *q* (1<=≤<=*n*,<=*a*,<=*b*,<=*p*,<=*q*<=≤<=109).","Print the only integer *s* — the maximum number of chocolates Joty can get.

Note that the answer can be too large, so you should use 64-bit integer type to store it. In C++ you can use the long long integer type and in Java you can use long integer type.","['5 2 3 12 15\n', '20 2 3 3 5\n']","['39\n', '51\n']",none,OK,"from sys import stdin, stdout
def read():
	return stdin.readline().rstrip()

def read_int():
	return int(read())

def read_ints():
	return list(map(int, read().split()))

def gcd(x,y):
	while y>0:
		x,y=y,x%y
	return x

def solve():
	n,a,b,p,q=read_ints()
	print((n//a)*p + (n//b)*q - (n//(a*b//gcd(a,b)))*min(p,q))

solve()","def max_chocolates(n, a, b, p, q):

    red_tiles = n // a

    blue_tiles = n // b

    both_tiles = n // (a * b)

    effective_red = red_tiles - both_tiles
    effective_blue = blue_tiles - both_tiles

    total_chocolates = effective_red * p + effective_blue * q + both_tiles * max(p, q)
    
    return total_chocolates

n, a, b, p, q = map(int, input().split())

result = max_chocolates(n, a, b, p, q)

print(result)"
769,D,k-Interesting Pairs Of Integers,PROGRAMMING,"['*special', 'bitmasks', 'brute force', 'meet-in-the-middle']","Vasya has the sequence consisting of *n* integers. Vasya consider the pair of integers *x* and *y* k-interesting, if their binary representation differs from each other exactly in *k* bits. For example, if *k*<==<=2, the pair of integers *x*<==<=5 and *y*<==<=3 is k-interesting, because their binary representation *x*=101 and *y*=011 differs exactly in two bits.

Vasya wants to know how many pairs of indexes (*i*, *j*) are in his sequence so that *i*<=&lt;<=*j* and the pair of integers *a**i* and *a**j* is k-interesting. Your task is to help Vasya and determine this number.","The first line contains two integers *n* and *k* (2<=≤<=*n*<=≤<=105, 0<=≤<=*k*<=≤<=14) — the number of integers in Vasya's sequence and the number of bits in which integers in k-interesting pair should differ.

The second line contains the sequence *a*1,<=*a*2,<=...,<=*a**n* (0<=≤<=*a**i*<=≤<=104), which Vasya has.","Print the number of pairs (*i*, *j*) so that *i*<=&lt;<=*j* and the pair of integers *a**i* and *a**j* is k-interesting.","['4 1\n0 3 2 1\n', '6 0\n200 100 100 100 200 200\n']","['4\n', '6\n']","In the first test there are 4 k-interesting pairs:
 -  (1, 3), -  (1, 4), -  (2, 3), -  (2, 4). 
In the second test *k* = 0. Consequently, integers in any k-interesting pair should be equal to themselves. Thus, for the second test there are 6 k-interesting pairs:
 -  (1, 5), -  (1, 6), -  (2, 3), -  (2, 4), -  (3, 4), -  (5, 6).",WRONG_ANSWER,"def pr(a,b):
    a = str(a)
    b = str(b)
    if len(a)>len(b):
        k = len(a) - len(b)
        for i in range(len(b),0):
            for j in range(len(a),0):
                if a-b == j-i and b[i] != a[j]:
                    k+=1
    else:
        k = len(b) - len(a)
        for i in range(len(a),0):
            for j in range(len(b),0):
                if b-a == j-i and a[i] != b[j]:
                    k+=1        
    return k
    
def main():
    n,m = map(int,input().split())
    arr = list(map(int,input().split()))
    for i in range(n):
        k = 1
        b = 0
        while (arr[i]!=0):
            b += arr[i] % 2 * k
            arr[i] //= 2
            k *= 10
        arr[i] = b
    q = 0
    for i in range(n):
        for j in range(i+1,n):
            p = pr(arr[i],arr[j])
            if p == m:
                q+=1;
    print(q)   
main()","from collections import defaultdict

def count_k_interesting_pairs(n, k, a):

    def hamming_distance(x, y):
        return bin(x ^ y).count('1')
    
    count = 0
    freq = defaultdict(int)
    
    for j in range(n):

        for i in range(j):
            if hamming_distance(a[i], a[j]) == k:
                count += 1

        freq[a[j]] += 1
        
    return count

if __name__ == ""__main__"":
    import sys
    input_data = sys.stdin.read().splitlines()
    n, k = map(int, input_data[0].split())
    a = list(map(int, input_data[1].split()))

    result = count_k_interesting_pairs(n, k, a)
    print(result)"
363,B,Fence,PROGRAMMING,"['brute force', 'dp']","There is a fence in front of Polycarpus's home. The fence consists of *n* planks of the same width which go one after another from left to right. The height of the *i*-th plank is *h**i* meters, distinct planks can have distinct heights.

Polycarpus has bought a posh piano and is thinking about how to get it into the house. In order to carry out his plan, he needs to take exactly *k* consecutive planks from the fence. Higher planks are harder to tear off the fence, so Polycarpus wants to find such *k* consecutive planks that the sum of their heights is minimal possible.

Write the program that finds the indexes of *k* consecutive planks with minimal total height. Pay attention, the fence is not around Polycarpus's home, it is in front of home (in other words, the fence isn't cyclic).","The first line of the input contains integers *n* and *k* (1<=≤<=*n*<=≤<=1.5·105,<=1<=≤<=*k*<=≤<=*n*) — the number of planks in the fence and the width of the hole for the piano. The second line contains the sequence of integers *h*1,<=*h*2,<=...,<=*h**n* (1<=≤<=*h**i*<=≤<=100), where *h**i* is the height of the *i*-th plank of the fence.","Print such integer *j* that the sum of the heights of planks *j*, *j*<=+<=1, ..., *j*<=+<=*k*<=-<=1 is the minimum possible. If there are multiple such *j*'s, print any of them.",['7 3\n1 2 6 1 1 7 1\n'],['3\n'],"In the sample, your task is to find three consecutive planks with the minimum sum of heights. In the given case three planks with indexes 3, 4 and 5 have the required attribute, their total height is 8.",OK,"from sys import stdin, stdout

def input():
    return stdin.readline().strip()

def print(string):
    return stdout.write(str(string) + ""\n"")

def main():
    n, k = map(int, input().split())
    h = [int(x) for x in input().split()]
    dp = [None] * n
    dp[0] = sum(h[:k])
    smallest_i = 0
    for i in range(n-k):
        dp[i+1] = dp[i] - h[i] + h[i+k]
        if dp[i+1] < dp[smallest_i]:
            smallest_i = i+1
    print(smallest_i+1)

if __name__ == ""__main__"":
    main()","n, k = map(int, input().split())

heights = list(map(int, input().split()))

min_sum = float('inf')
min_index = 0

current_sum = sum(heights[:k])
min_sum = current_sum

for i in range(1, n - k + 1):

    current_sum = current_sum - heights[i - 1] + heights[i + k - 1]

    if current_sum < min_sum:
        min_sum = current_sum
        min_index = i

print(min_index + 1)"
770,A,New Password,PROGRAMMING,"['*special', 'implementation']","Innokentiy decides to change the password in the social net ""Contact!"", but he is too lazy to invent a new password by himself. That is why he needs your help. 

Innokentiy decides that new password should satisfy the following conditions:
 -  the length of the password must be equal to *n*, -  the password should consist only of lowercase Latin letters, -  the number of distinct symbols in the password must be equal to *k*, -  any two consecutive symbols in the password must be distinct. 
Your task is to help Innokentiy and to invent a new password which will satisfy all given conditions.","The first line contains two positive integers *n* and *k* (2<=≤<=*n*<=≤<=100, 2<=≤<=*k*<=≤<=*min*(*n*,<=26)) — the length of the password and the number of distinct symbols in it. 

Pay attention that a desired new password always exists.",Print any password which satisfies all conditions given by Innokentiy.,"['4 3\n', '6 6\n', '5 2\n']","['java\n', 'python\n', 'phphp\n']","In the first test there is one of the appropriate new passwords — java, because its length is equal to 4 and 3 distinct lowercase letters a, j and v are used in it.

In the second test there is one of the appropriate new passwords — python, because its length is equal to 6 and it consists of 6 distinct lowercase letters.

In the third test there is one of the appropriate new passwords — phphp, because its length is equal to 5 and 2 distinct lowercase letters p and h are used in it.

Pay attention the condition that no two identical symbols are consecutive is correct for all appropriate passwords in tests.",RUNTIME_ERROR,"import random
import string
alpha ='abcdefghijklmnopqrstuvwxyz'
x = int(input())
c = int(input())
password = ''
for i in range(0,c):
    password +=alpha[i] 
for i in range(c,x):
    password+= password[i-c]
print(password)","def generate_password(n, k):

    base_chars = [chr(ord('a') + i) for i in range(k)]
    password = []

    for i in range(n):
        password.append(base_chars[i % k])

    for i in range(1, n):
        if password[i] == password[i - 1]:
            password[i] = base_chars[(i + 1) % k]
    
    return ''.join(password)

if __name__ == ""__main__"":
    input_data = ['4 3\n', '6 6\n', '5 2\n']
    for data in input_data:
        n, k = map(int, data.strip().split())
        print(generate_password(n, k))"
515,C,Drazil and Factorial,PROGRAMMING,"['greedy', 'math', 'sortings']","Drazil is playing a math game with Varda.

Let's define  for positive integer *x* as a product of factorials of its digits. For example, .

First, they choose a decimal number *a* consisting of *n* digits that contains at least one digit larger than 1. This number may possibly start with leading zeroes. Then they should find maximum positive number *x* satisfying following two conditions:

1. *x* doesn't contain neither digit 0 nor digit 1.

2.  = .

Help friends find such number.","The first line contains an integer *n* (1<=≤<=*n*<=≤<=15) — the number of digits in *a*.

The second line contains *n* digits of *a*. There is at least one digit in *a* that is larger than 1. Number *a* may possibly contain leading zeroes.",Output a maximum possible integer satisfying the conditions above. There should be no zeroes and ones in this number decimal representation.,"['4\n1234\n', '3\n555\n']","['33222\n', '555\n']","In the first case, <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/f5a4207f23215fddce977ab5ea9e9d2e7578fb52.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>",WRONG_ANSWER,"n=int(input())
digits=list(map(int,input()))
print(digits)
countfact={2:0,3:0,5:0,7:0}
def fact(n):
    mydict={2:0,3:0,5:0,7:0}
    factor=[i for i in range(1,n+1)]
    for val in factor:
        if val==2:
            mydict[2]+=1
        elif val==3:
            mydict[3]+=1
        elif val==4:
            mydict[2]+=2
        elif val==5:
            mydict[5]+=1
        elif val==6:
            mydict[3]+=1
            mydict[2]+=1
        elif val==7:
            mydict[7]+=1
        elif val==8:
            mydict[2]+=3
        elif val==9:
            mydict[3]+=2
    return mydict
      
            
for digit in digits:
    tmp=fact(digit)
    
    for key in tmp.keys():
        countfact[key]+=tmp[key]

while countfact[2]!=0:
    if countfact[7]!=0:
        tmp=fact(7)
        print(""7"",end="""")
        for key in tmp.keys():
            countfact[key]-=tmp[key]
    elif countfact[5]!=0:
        tmp=fact(5)
        print(""5"",end="""")
        for key in tmp.keys():
            countfact[key]-=tmp[key]
    elif countfact[3]!=0:
        tmp=fact(3)
        print(""3"",end="""")
        for key in tmp.keys():
            countfact[key]-=tmp[key]
    elif countfact[2]!=0:
        tmp=fact(2)
        print(""2"",end="""")
        for key in tmp.keys():
            countfact[key]-=tmp[key]","def factorial_product_representation(n, digits):

    factor_map = {
        '0': '',
        '1': '',
        '2': '2', 
        '3': '3', 
        '4': '322',
        '5': '5', 
        '6': '53',
        '7': '7', 
        '8': '7222',
        '9': '7332'
    }
    
    result = []

    for digit in digits:
        result.append(factor_map[digit])

    final_number = ''.join(result)
    sorted_number = ''.join(sorted(final_number, reverse=True))
    
    return sorted_number

n = int(input().strip())
digits = input().strip()

output = factorial_product_representation(n, digits)

print(output)"
19,D,Points,PROGRAMMING,['data structures'],"Pete and Bob invented a new interesting game. Bob takes a sheet of paper and locates a Cartesian coordinate system on it as follows: point (0,<=0) is located in the bottom-left corner, *Ox* axis is directed right, *Oy* axis is directed up. Pete gives Bob requests of three types: 
 -  add x y — on the sheet of paper Bob marks a point with coordinates (*x*,<=*y*). For each request of this type it's guaranteed that point (*x*,<=*y*) is not yet marked on Bob's sheet at the time of the request. -  remove x y — on the sheet of paper Bob erases the previously marked point with coordinates (*x*,<=*y*). For each request of this type it's guaranteed that point (*x*,<=*y*) is already marked on Bob's sheet at the time of the request. -  find x y — on the sheet of paper Bob finds all the marked points, lying strictly above and strictly to the right of point (*x*,<=*y*). Among these points Bob chooses the leftmost one, if it is not unique, he chooses the bottommost one, and gives its coordinates to Pete. 
Bob managed to answer the requests, when they were 10, 100 or 1000, but when their amount grew up to 2·105, Bob failed to cope. Now he needs a program that will answer all Pete's requests. Help Bob, please!","The first input line contains number *n* (1<=≤<=*n*<=≤<=2·105) — amount of requests. Then there follow *n* lines — descriptions of the requests. add x y describes the request to add a point, remove x y — the request to erase a point, find x y — the request to find the bottom-left point. All the coordinates in the input file are non-negative and don't exceed 109.","For each request of type find x y output in a separate line the answer to it — coordinates of the bottommost among the leftmost marked points, lying strictly above and to the right of point (*x*,<=*y*). If there are no points strictly above and to the right of point (*x*,<=*y*), output -1.","['7\nadd 1 1\nadd 3 4\nfind 0 0\nremove 1 1\nfind 0 0\nadd 1 1\nfind 0 0\n', '13\nadd 5 5\nadd 5 6\nadd 5 7\nadd 6 5\nadd 6 6\nadd 6 7\nadd 7 5\nadd 7 6\nadd 7 7\nfind 6 6\nremove 7 7\nfind 6 6\nfind 4 4\n']","['1 1\n3 4\n1 1\n', '7 7\n-1\n5 5\n']",none,TIME_LIMIT_EXCEEDED,"def DPoints2_find(s,sk,l):
    find_x=-1
    find_y=-1
    for i in sk:
        if i>l[0]:
            for j in s[i]:
                if j>l[1]:
                    find_y=j
                    find_x=i
                    break
        if find_y!=-1:
            break
    if find_y==-1:
        return -1
    else:
        return [find_x,find_y]
        
sheet={}
sheet_k=[]
result=[]
n=int(input())
for _ in range(0,n):
    oper=input()
    oper=oper.split()
    if oper[0]==""add"":
        if int(oper[1]) in sheet.keys():
            sheet[int(oper[1])].append(int(oper[2]))
            sheet[int(oper[1])]=sorted(sheet[int(oper[1])])
        else:
            sheet[int(oper[1])]=[]
            sheet[int(oper[1])].append(int(oper[2]))
            sheet[int(oper[1])]=sorted(sheet[int(oper[1])])
            sheet_k=sorted(sheet.keys())
    elif oper[0]==""remove"":
        sheet[int(oper[1])].remove(int(oper[2]))
        if len(sheet[int(oper[1])])==0:
                del sheet[int(oper[1])]
                sheet_k.remove(int(oper[1]))
    else:
        result.append(DPoints2_find(sheet,sheet_k,[int(oper[1]),int(oper[2])]))
for i in result:
    if i==-1:
        print(i)
    else:
        print(*i)","class PointManager:
    def __init__(self):
        self.points = set()
        self.sorted_points = []

    def add(self, x, y):
        self.points.add((x, y))
        self.sorted_points.append((x, y))
        self.sorted_points.sort()

    def remove(self, x, y):
        self.points.remove((x, y))
        self.sorted_points.remove((x, y))

    def find(self, x, y):

        candidates = [(px, py) for px, py in self.sorted_points if px > x and py > y]
        if not candidates:
            return -1

        best_point = min(candidates)
        return best_point

def process_requests(requests):
    manager = PointManager()
    results = []

    for request in requests:
        parts = request.split()
        command = parts[0]
        x, y = int(parts[1]), int(parts[2])

        if command == ""add"":
            manager.add(x, y)
        elif command == ""remove"":
            manager.remove(x, y)
        elif command == ""find"":
            result = manager.find(x, y)
            if result == -1:
                results.append(""-1"")
            else:
                results.append(f""{result[0]} {result[1]}"")

    return results

input_data1 = [""add 1 1"", ""add 3 4"", ""find 0 0"", ""remove 1 1"", ""find 0 0"", ""add 1 1"", ""find 0 0""]
input_data2 = [
    ""add 5 5"", ""add 5 6"", ""add 5 7"",
    ""add 6 5"", ""add 6 6"", ""add 6 7"",
    ""add 7 5"", ""add 7 6"", ""add 7 7"",
    ""find 6 6"", ""remove 7 7"", ""find 6 6"", ""find 4 4""
]

output1 = process_requests(input_data1)
output2 = process_requests(input_data2)

print(""\n"".join(output1))
print(""\n"".join(output2))"
858,A,k-rounding,PROGRAMMING,"['brute force', 'math', 'number theory']","For a given positive integer *n* denote its *k*-rounding as the minimum positive integer *x*, such that *x* ends with *k* or more zeros in base 10 and is divisible by *n*.

For example, 4-rounding of 375 is 375·80<==<=30000. 30000 is the minimum integer such that it ends with 4 or more zeros and is divisible by 375.

Write a program that will perform the *k*-rounding of *n*.","The only line contains two integers *n* and *k* (1<=≤<=*n*<=≤<=109, 0<=≤<=*k*<=≤<=8).",Print the *k*-rounding of *n*.,"['375 4\n', '10000 1\n', '38101 0\n', '123456789 8\n']","['30000\n', '10000\n', '38101\n', '12345678900000000\n']",none,OK,"def gcd(a, b):
    if a == 0:
        return b
    return gcd(b % a, a)

def nok(a, b):
    return a // gcd(a, b) * b

n, k = map(int, input().split())
print(nok(n, 10 ** k))","def k_rounding(n, k):

    factor = 10 ** k

    x = factor
    while x % n != 0:
        x += factor
    
    return x

input_data = ['375 4\n', '10000 1\n', '38101 0\n', '123456789 8\n']
output_data = []

for line in input_data:
    n, k = map(int, line.strip().split())
    result = k_rounding(n, k)
    output_data.append(f'{result}\n')

print(''.join(output_data))"
127,A,Wasted Time,PROGRAMMING,['geometry'],"Mr. Scrooge, a very busy man, decided to count the time he wastes on all sorts of useless stuff to evaluate the lost profit. He has already counted the time he wastes sleeping and eating. And now Mr. Scrooge wants to count the time he has wasted signing papers.

Mr. Scrooge's signature can be represented as a polyline *A*1*A*2... *A**n*. Scrooge signs like that: first it places a pen at the point *A*1, then draws a segment from point *A*1 to point *A*2, then he draws a segment from point *A*2 to point *A*3 and so on to point *A**n*, where he stops signing and takes the pen off the paper. At that the resulting line can intersect with itself and partially repeat itself but Scrooge pays no attention to it and never changes his signing style. As Scrooge makes the signature, he never takes the pen off the paper and his writing speed is constant — 50 millimeters per second.

Scrooge signed exactly *k* papers throughout his life and all those signatures look the same.

Find the total time Scrooge wasted signing the papers.","The first line contains two integers *n* and *k* (2<=≤<=*n*<=≤<=100, 1<=≤<=*k*<=≤<=1000). Each of the following *n* lines contains the coordinates of the polyline's endpoints. The *i*-th one contains coordinates of the point *A**i* — integers *x**i* and *y**i*, separated by a space.

All points *A**i* are different. The absolute value of all coordinates does not exceed 20. The coordinates are measured in millimeters.",Print one real number — the total time Scrooges wastes on signing the papers in seconds. The absolute or relative error should not exceed 10<=-<=6.,"['2 1\n0 0\n10 0\n', '5 10\n3 1\n-5 6\n-2 -1\n3 2\n10 0\n', '6 10\n5 0\n4 0\n6 0\n3 0\n7 0\n2 0\n']","['0.200000000', '6.032163204', '3.000000000']",none,OK,"from collections import deque, Counter, OrderedDict
from heapq import nsmallest, nlargest
from math import ceil,floor,log,log2,sqrt,gcd,factorial,pow
def binNumber(n,size=4):
    return bin(n)[2:].zfill(size)

def iar():
    return list(map(int,input().split()))

def ini():
    return int(input())

def isp():
    return map(int,input().split())

def sti():
    return str(input())

def par(a):
    print(' '.join(list(map(str,a))))

def tdl(outerListSize,innerListSize,defaultValue = 0):
    return [[defaultValue]*innerListSize for i in range(outerListSize)]

class pair:
    def __init__(self,f,s):
        self.fi = f
        self.se = s
    def __lt__(self,other):
        return (self.fi,self.se) < (other.fi,other.se)

def dist(x1,y1,x2,y2):
    return sqrt((x2-x1)**2 + (y2-y1)**2)
if __name__ == ""__main__"":
    n,k = isp()
    s = 0
    p = []
    for _ in range(n):
        x,y = isp()
        p.append(pair(x,y))
    for i in range(1,n):
        s += dist(p[i].fi,p[i].se,p[i-1].fi,p[i-1].se)
    s *= k
    print(s/50)","import math

def calculate_signing_time(n, k, points):
    total_distance = 0.0

    for i in range(n - 1):
        x1, y1 = points[i]
        x2, y2 = points[i + 1]

        distance = math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)
        total_distance += distance

    speed = 50.0

    time_for_one_signature = total_distance / speed

    total_time = time_for_one_signature * k
    
    return total_time

if __name__ == ""__main__"":
    import sys
    input_data = sys.stdin.read().strip().split('\n')

    n, k = map(int, input_data[0].split())
    points = []

    for i in range(1, n + 1):
        x, y = map(int, input_data[i].split())
        points.append((x, y))

    result = calculate_signing_time(n, k, points)
    print(f""{result:.9f}"")"
653,B,Bear and Compressing,PROGRAMMING,"['brute force', 'dfs and similar', 'dp', 'strings']","Limak is a little polar bear. Polar bears hate long strings and thus they like to compress them. You should also know that Limak is so young that he knows only first six letters of the English alphabet: 'a', 'b', 'c', 'd', 'e' and 'f'.

You are given a set of *q* possible operations. Limak can perform them in any order, any operation may be applied any number of times. The *i*-th operation is described by a string *a**i* of length two and a string *b**i* of length one. No two of *q* possible operations have the same string *a**i*.

When Limak has a string *s* he can perform the *i*-th operation on *s* if the first two letters of *s* match a two-letter string *a**i*. Performing the *i*-th operation removes first two letters of *s* and inserts there a string *b**i*. See the notes section for further clarification.

You may note that performing an operation decreases the length of a string *s* exactly by 1. Also, for some sets of operations there may be a string that cannot be compressed any further, because the first two letters don't match any *a**i*.

Limak wants to start with a string of length *n* and perform *n*<=-<=1 operations to finally get a one-letter string ""a"". In how many ways can he choose the starting string to be able to get ""a""? Remember that Limak can use only letters he knows.","The first line contains two integers *n* and *q* (2<=≤<=*n*<=≤<=6, 1<=≤<=*q*<=≤<=36) — the length of the initial string and the number of available operations.

The next *q* lines describe the possible operations. The *i*-th of them contains two strings *a**i* and *b**i* (|*a**i*|<==<=2,<=|*b**i*|<==<=1). It's guaranteed that *a**i*<=≠<=*a**j* for *i*<=≠<=*j* and that all *a**i* and *b**i* consist of only first six lowercase English letters.","Print the number of strings of length *n* that Limak will be able to transform to string ""a"" by applying only operations given in the input.","['3 5\nab a\ncc c\nca a\nee c\nff d\n', '2 8\naf e\ndc d\ncc f\nbc b\nda b\neb a\nbb b\nff c\n', '6 2\nbb a\nba a\n']","['4\n', '1\n', '0\n']","In the first sample, we count initial strings of length 3 from which Limak can get a required string ""a"". There are 4 such strings: ""abb"", ""cab"", ""cca"", ""eea"". The first one Limak can compress using operation 1 two times (changing ""ab"" to a single ""a""). The first operation would change ""abb"" to ""ab"" and the second operation would change ""ab"" to ""a"".

Other three strings may be compressed as follows: 
 -  ""cab"" <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> ""ab"" <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> ""a"" -  ""cca"" <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> ""ca"" <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> ""a"" -  ""eea"" <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> ""ca"" <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/70a0795f45d32287dba0eb83fc4a3f470c6e5537.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> ""a"" 
In the second sample, the only correct initial string is ""eb"" because it can be immediately compressed to ""a"".",OK,"import collections

n, q = map(int, input().split())
d = collections.defaultdict(list)
cnt, t = [0] * 6, [0] * 6
for i in range(q):
    s1, s2 = input().split()
    d[s2].append(s1)
    cnt[ord(s2) - ord('a')] += 1
for s in d['a']:
    t[ord(s[0]) - ord('a')] += 1
for i in range(n - 2):
    p = [0] * 6
    for j in range(6):
        if t[j] == 0:
            continue
        for s in d[chr(j + 97)]:
            p[ord(s[0]) - ord('a')] += t[j]
    t = p
print(sum(t))","def count_strings(n, q, operations):
    from itertools import product

    operations_map = {}
    for a_i, b_i in operations:
        operations_map[a_i] = b_i

    valid_letters = 'abcdef'

    count = 0

    for s in product(valid_letters, repeat=n):
        s = ''.join(s)
        current_string = s

        while len(current_string) > 1:
            first_two = current_string[:2]
            if first_two in operations_map:

                current_string = operations_map[first_two] + current_string[2:]
            else:
                break

        if current_string == ""a"":
            count += 1
    
    return count

demo_inputs = [
    (3, 5, [('ab', 'a'), ('cc', 'c'), ('ca', 'a'), ('ee', 'c'), ('ff', 'd')]),
    (2, 8, [('af', 'e'), ('dc', 'd'), ('cc', 'f'), ('bc', 'b'), ('da', 'b'), ('eb', 'a'), ('bb', 'b'), ('ff', 'c')]),
    (6, 2, [('bb', 'a'), ('ba', 'a')])
]

results = [count_strings(n, q, ops) for n, q, ops in demo_inputs]
print(results)"
963,A,Alternating Sum,PROGRAMMING,"['math', 'number theory']","You are given two integers $a$ and $b$. Moreover, you are given a sequence $s_0, s_1, \dots, s_{n}$. All values in $s$ are integers $1$ or $-1$. It's known that sequence is $k$-periodic and $k$ divides $n+1$. In other words, for each $k \leq i \leq n$ it's satisfied that $s_{i} = s_{i - k}$.

Find out the non-negative remainder of division of $\sum \limits_{i=0}^{n} s_{i} a^{n - i} b^{i}$ by $10^{9} + 9$.

Note that the modulo is unusual!","The first line contains four integers $n, a, b$ and $k$ $(1 \leq n \leq 10^{9}, 1 \leq a, b \leq 10^{9}, 1 \leq k \leq 10^{5})$.

The second line contains a sequence of length $k$ consisting of characters '+' and '-'. 

If the $i$-th character (0-indexed) is '+', then $s_{i} = 1$, otherwise $s_{i} = -1$.

Note that only the first $k$ members of the sequence are given, the rest can be obtained using the periodicity property.",Output a single integer — value of given expression modulo $10^{9} + 9$.,"['2 2 3 3\n+-+\n', '4 1 5 1\n-\n']","['7\n', '999999228\n']","In the first example:

$(\sum \limits_{i=0}^{n} s_{i} a^{n - i} b^{i})$ = $2^{2} 3^{0} - 2^{1} 3^{1} + 2^{0} 3^{2}$ = 7

In the second example:

$(\sum \limits_{i=0}^{n} s_{i} a^{n - i} b^{i}) = -1^{4} 5^{0} - 1^{3} 5^{1} - 1^{2} 5^{2} - 1^{1} 5^{3} - 1^{0} 5^{4} = -781 \equiv 999999228 \pmod{10^{9} + 9}$.",COMPILATION_ERROR,"using namespace std;
long long int puiss(long long int x,long long int y){long long int res=1;for(i,0,y){res=res*x;}return res;}
long long int reste(long long int x,long long int y){long long int q=abs(x/y);return x+(q+1)*y;}

int main()
{
    //cout << puiss(5,3) << endl;
    long long int n,a,b,k;
    cin >> n >> a >>b >> k;

    string ch;
    cin >> ch;
    long long int s=0;
    for(i,0,n+1){
        if (ch[i%k]=='+'){s=s+puiss(a,n-i)*puiss(b,i);}
        else{s=s-puiss(a,n-i)*puiss(b,i);}
    }

    long long int v;
    v=puiss(10,9)+9;
    v=reste(s,v);
    cout << v << endl;
    //long long int j=423834578;
    //cout << j << endl;
    return 0;
}","def mod_exp(base, exp, mod):
    """"""Compute (base ** exp) % mod using iterative exponentiation""""""
    res = 1
    while exp > 0:
        if exp % 2 == 1:
            res = (res * base) % mod
        base = (base * base) % mod
        exp //= 2
    return res

def main():
    import sys

    input_data = sys.stdin.read().strip().split('\n')
    n, a, b, k = map(int, input_data[0].split())
    seq = input_data[1].strip()

    s = [1 if ch == '+' else -1 for ch in seq]

    MOD = 10**9 + 9

    total_sum = 0

    repeats = (n + 1) // k
    remainder = (n + 1) % k
    
    for i in range(k):
        if i < remainder:

            exp_a = n - i
            exp_b = i
            total_sum += s[i] * mod_exp(a, exp_a, MOD) * mod_exp(b, exp_b, MOD)
        else:

            total_sum += s[i] * mod_exp(a, n - i, MOD) * mod_exp(b, i, MOD)

    total_sum *= repeats

    result = total_sum % MOD
    print(result)

if __name__ == ""__main__"":
    main()"
404,A,Valera and X,PROGRAMMING,['implementation'],"Valera is a little boy. Yesterday he got a huge Math hometask at school, so Valera didn't have enough time to properly learn the English alphabet for his English lesson. Unfortunately, the English teacher decided to have a test on alphabet today. At the test Valera got a square piece of squared paper. The length of the side equals *n* squares (*n* is an odd number) and each unit square contains some small letter of the English alphabet.

Valera needs to know if the letters written on the square piece of paper form letter ""X"". Valera's teacher thinks that the letters on the piece of paper form an ""X"", if:
 -  on both diagonals of the square paper all letters are the same; -  all other squares of the paper (they are not on the diagonals) contain the same letter that is different from the letters on the diagonals. 
Help Valera, write the program that completes the described task for him.",The first line contains integer *n* (3<=≤<=*n*<=&lt;<=300; *n* is odd). Each of the next *n* lines contains *n* small English letters — the description of Valera's paper.,"Print string ""YES"", if the letters on the paper form letter ""X"". Otherwise, print string ""NO"". Print the strings without quotes.","['5\nxooox\noxoxo\nsoxoo\noxoxo\nxooox\n', '3\nwsw\nsws\nwsw\n', '3\nxpx\npxp\nxpe\n']","['NO\n', 'YES\n', 'NO\n']",none,COMPILATION_ERROR,"using namespace std;

typedef long long ll;

struct interval
{
    int s,e;
};

bool sortthis(interval i1, interval i2)
{

            return i1.s<i2.s;
}

void solve()
{

    ll n;cin>>n;char arr[n][n];

    for(int i=0;i<n;i++)
    {
        for(int j=0;j<n;j++)
        {
            cin>>arr[i][j];
        }
    }

    char a=arr[0][0];
    char b=arr[0][1];

    for(int i=0;i<n;i++)
    {
        for(int j=0;j<n;j++)
        {
            if(i==j)
            {
                if(arr[i][j] != a)
                {
                    NO
                    return;
                }
            }
            else if (i == n-1-j)
            {
                if(arr[i][n-1-j] != a)
                {
                    NO
                    return;
                }
            }
            else
                if(arr[i][j] != b)
                {
                    NO
                    return;
                }
        }
    }

    YES

}

int main()
{

    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

        freopen(""input.txt"", ""r"", stdin);
        //freopen(""output.txt"", ""w"", stdout);

    ll t=1;

    //cin>>t;

    while(t--)
    {
        solve();
    }

    return 0;
}","def is_x_shape(n, paper):

    diagonal_char = paper[0][0]
    other_char = None

    for i in range(n):
        for j in range(n):
            if i == j or i + j == n - 1:
                if paper[i][j] != diagonal_char:
                    return ""NO""
            else:
                if other_char is None:
                    other_char = paper[i][j]
                elif paper[i][j] != other_char:
                    return ""NO""

    if other_char == diagonal_char:
        return ""NO""
    
    return ""YES""

n = int(input().strip())
paper = [input().strip() for _ in range(n)]

result = is_x_shape(n, paper)
print(result)"
427,A,Police Recruits,PROGRAMMING,['implementation'],"The police department of your city has just started its journey. Initially, they don’t have any manpower. So, they started hiring new recruits in groups.

Meanwhile, crimes keeps occurring within the city. One member of the police force can investigate only one crime during his/her lifetime.

If there is no police officer free (isn't busy with crime) during the occurrence of a crime, it will go untreated.

Given the chronological order of crime occurrences and recruit hirings, find the number of crimes which will go untreated.","The first line of input will contain an integer *n* (1<=≤<=*n*<=≤<=105), the number of events. The next line will contain *n* space-separated integers.

If the integer is -1 then it means a crime has occurred. Otherwise, the integer will be positive, the number of officers recruited together at that time. No more than 10 officers will be recruited at a time.","Print a single integer, the number of crimes which will go untreated.","['3\n-1 -1 1\n', '8\n1 -1 1 -1 -1 1 1 1\n', '11\n-1 -1 2 -1 -1 -1 -1 -1 -1 -1 -1\n']","['2\n', '1\n', '8\n']","Lets consider the second example:
 1.  Firstly one person is hired. 1.  Then crime appears, the last hired person will investigate this crime. 1.  One more person is hired. 1.  One more crime appears, the last hired person will investigate this crime. 1.  Crime appears. There is no free policeman at the time, so this crime will go untreated. 1.  One more person is hired. 1.  One more person is hired. 1.  One more person is hired. 
The answer is one, as one crime (on step 5) will go untreated.",OK,"import sys
import math

def main():

    t = int(input())
    a = [int(x) for x in sys.stdin.readline().split()]
    crimes=0
    soldiers=0
    for x in a:
        if x >= 1:
            soldiers += x
        if x == -1:
            if soldiers>0:

                soldiers -=1
            else:
                crimes += 1
    
    print(crimes)
main()","def untreated_crimes(n, events):
    officers = 0
    untreated_count = 0

    for event in events:
        if event == -1:
            if officers > 0:
                officers -= 1
            else:
                untreated_count += 1
        else:
            officers += event

    return untreated_count

if __name__ == ""__main__"":
    n = int(input())
    events = list(map(int, input().split()))
    result = untreated_crimes(n, events)
    print(result)"
180,A,Defragmentation,PROGRAMMING,['implementation'],"In this problem you have to implement an algorithm to defragment your hard disk. The hard disk consists of a sequence of clusters, numbered by integers from 1 to *n*. The disk has *m* recorded files, the *i*-th file occupies clusters with numbers *a**i*,<=1, *a**i*,<=2, ..., *a**i*,<=*n**i*. These clusters are not necessarily located consecutively on the disk, but the order in which they are given corresponds to their sequence in the file (cluster *a**i*,<=1 contains the first fragment of the *i*-th file, cluster *a**i*,<=2 has the second fragment, etc.). Also the disc must have one or several clusters which are free from files.

You are permitted to perform operations of copying the contents of cluster number *i* to cluster number *j* (*i* and *j* must be different). Moreover, if the cluster number *j* used to keep some information, it is lost forever. Clusters are not cleaned, but after the defragmentation is complete, some of them are simply declared unusable (although they may possibly still contain some fragments of files).

Your task is to use a sequence of copy operations to ensure that each file occupies a contiguous area of memory. Each file should occupy a consecutive cluster section, the files must follow one after another from the beginning of the hard disk. After defragmentation all free (unused) clusters should be at the end of the hard disk. After defragmenting files can be placed in an arbitrary order. Clusters of each file should go consecutively from first to last. See explanatory examples in the notes.

Print the sequence of operations leading to the disk defragmentation. Note that you do not have to minimize the number of operations, but it should not exceed 2*n*.","The first line contains two integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=200) — the number of clusters and the number of files, correspondingly. Next *m* lines contain descriptions of the files. The first number in the line is *n**i* (*n**i*<=≥<=1), the number of clusters occupied by the *i*-th file. Then follow *n**i* numbers *a**i*,<=1, *a**i*,<=2, ..., *a**i*,<=*n**i* (1<=≤<=*a**i*,<=*j*<=≤<=*n*). It is guaranteed that each cluster number occurs not more than once and , that is, there exists at least one unused cluster. Numbers on each line are separated by spaces.","In the first line print a single integer *k* (0<=≤<=*k*<=≤<=2*n*) — the number of operations needed to defragment the disk. Next *k* lines should contain the operations' descriptions as ""*i* *j*"" (copy the contents of the cluster number *i* to the cluster number *j*).","['7 2\n2 1 2\n3 3 4 5\n', '7 2\n2 1 3\n3 2 4 5\n']","['0\n', '3\n2 6\n3 2\n6 3\n']","Let's say that a disk consists of 8 clusters and contains two files. The first file occupies two clusters and the second file occupies three clusters. Let's look at examples of correct and incorrect positions of files after defragmentation. 

Example 2: each file must occupy a contiguous area of memory.

Example 3: the order of files to each other is not important, at first the second file can be written, and then — the first one.

Example 4: violating the order of file fragments to each other is not allowed.

Example 5: unused clusters should be located at the end, and in this example the unused clusters are 3, 7, 8.",OK,"import sys
n, m, *inp = map(int, sys.stdin.read().split())

inp.reverse()
f = [[0 for x in range(201)] for y in range(201)]
c = [(0,0)]*201
f_size = [0]*201

def putData(f_id, s_id, c_id):
    global f, c
    f[f_id][s_id] = c_id
    c[c_id] = (f_id, s_id)

for f_id in range(1, m+1):
    f_size[f_id] = inp.pop()
    for s_id in range(1, f_size[f_id]+1):
        c_id = inp.pop()
        putData(f_id, s_id, c_id)

e_id = c[1:].index((0,0))+1
next_id = 1
op = []

for f_id in range(1, m+1):
    for s_id in range(1, f_size[f_id]+1):
        if c[next_id]==(f_id, s_id):
            next_id += 1
            continue
        if c[next_id] != (0, 0):
            op.append((next_id, e_id))
            putData(c[next_id][0], c[next_id][1], e_id)
        e_id = f[f_id][s_id]
        c[e_id] = (0,0)
        op.append((e_id, next_id))
        putData(f_id, s_id, next_id)
        next_id += 1

print(len(op))
for p in op:
    print(""%d %d"" % p)","n, m = map(int, input().split())
files = []
free_clusters = set(range(1, n + 1))

for i in range(m):
    data = list(map(int, input().split()))
    ni = data[0]
    clusters = data[1:1 + ni]
    files.append(clusters)
    free_clusters.difference_update(clusters)

free_clusters = sorted(free_clusters)
operations = []
current_position = 1

for file in files:
    for cluster in file:
        if current_position != cluster:

            operations.append(f""{cluster} {current_position}"")
        current_position += 1

for fc in free_clusters:
    if current_position <= n:
        current_position += 1

print(len(operations))
for op in operations:
    print(op)"
25,C,Roads in Berland,PROGRAMMING,"['graphs', 'shortest paths']","There are *n* cities numbered from 1 to *n* in Berland. Some of them are connected by two-way roads. Each road has its own length — an integer number from 1 to 1000. It is known that from each city it is possible to get to any other city by existing roads. Also for each pair of cities it is known the shortest distance between them. Berland Government plans to build *k* new roads. For each of the planned road it is known its length, and what cities it will connect. To control the correctness of the construction of new roads, after the opening of another road Berland government wants to check the sum of the shortest distances between all pairs of cities. Help them — for a given matrix of shortest distances on the old roads and plans of all new roads, find out how the sum of the shortest distances between all pairs of cities changes after construction of each road.","The first line contains integer *n* (2<=≤<=*n*<=≤<=300) — amount of cities in Berland. Then there follow *n* lines with *n* integer numbers each — the matrix of shortest distances. *j*-th integer in the *i*-th row — *d**i*,<=*j*, the shortest distance between cities *i* and *j*. It is guaranteed that *d**i*,<=*i*<==<=0,<=*d**i*,<=*j*<==<=*d**j*,<=*i*, and a given matrix is a matrix of shortest distances for some set of two-way roads with integer lengths from 1 to 1000, such that from each city it is possible to get to any other city using these roads.

Next line contains integer *k* (1<=≤<=*k*<=≤<=300) — amount of planned roads. Following *k* lines contain the description of the planned roads. Each road is described by three space-separated integers *a**i*, *b**i*, *c**i* (1<=≤<=*a**i*,<=*b**i*<=≤<=*n*,<=*a**i*<=≠<=*b**i*,<=1<=≤<=*c**i*<=≤<=1000) — *a**i* and *b**i* — pair of cities, which the road connects, *c**i* — the length of the road. It can be several roads between a pair of cities, but no road connects the city with itself.","Output *k* space-separated integers *q**i* (1<=≤<=*i*<=≤<=*k*). *q**i* should be equal to the sum of shortest distances between all pairs of cities after the construction of roads with indexes from 1 to *i*. Roads are numbered from 1 in the input order. Each pair of cities should be taken into account in the sum exactly once, i. e. we count unordered pairs.","['2\n0 5\n5 0\n1\n1 2 3\n', '3\n0 4 5\n4 0 9\n5 9 0\n2\n2 3 8\n1 2 1\n']","['3 ', '17 12 ']",none,TIME_LIMIT_EXCEEDED,"from collections import defaultdict

def dijkstra(graph, start, end):

    import heapq

    heap = [(0, start)]
    visited = set()
    while heap:
        (cost, u) = heapq.heappop(heap)
        if u in visited:
            continue
        visited.add(u)
        if u == end:
            return cost
        for v, c in graph[u]:
            if v in visited:
                continue
            next_item = cost + c
            heapq.heappush(heap, (next_item, v))
    return -1

def main():
    
    n = int(input())

    graph = defaultdict(list)

    for i in range(n):
        row = list(map(int, input().split()))
        for j in range(n):
            graph[i].append((j, row[j]))
            graph[j].append((i, row[j]))

    ans = []

    k = int(input())

    for _ in range(k):
        a,b,c = map(int, input().split())

        a-=1
        b-=1

        graph[a].append((b, c))
        graph[b].append((a, c))

        tot = 0
        for u in range(n):
            for v in range(u):
                cur = dijkstra(graph, u, v)
                tot += cur
        
        ans.append(tot)

    print(*ans)

main()","import sys
import itertools

def read_input():
    n = int(sys.stdin.readline().strip())
    dist = [list(map(int, sys.stdin.readline().strip().split())) for _ in range(n)]
    k = int(sys.stdin.readline().strip())
    roads = [tuple(map(int, sys.stdin.readline().strip().split())) for _ in range(k)]
    return n, dist, roads

def calculate_initial_sum(dist):
    total_distance_sum = sum(dist[i][j] for i in range(len(dist)) for j in range(i + 1, len(dist)))
    return total_distance_sum

def floyd_warshall(dist):
    """"""Use Floyd-Warshall to update distances after adding a new road.""""""
    for k in range(len(dist)):
        for i in range(len(dist)):
            for j in range(len(dist)):
                if dist[i][j] > dist[i][k] + dist[k][j]:
                    dist[i][j] = dist[i][k] + dist[k][j]

def update_distances_and_sum(n, dist, roads):
    results = []
    total_distance_sum = calculate_initial_sum(dist)

    for a, b, c in roads:
        a -= 1
        b -= 1

        if dist[a][b] > c:

            dist[a][b] = c
            dist[b][a] = c

            floyd_warshall(dist)

        total_distance_sum = calculate_initial_sum(dist)
        results.append(total_distance_sum)

    return results

def main():
    n, dist, roads = read_input()
    results = update_distances_and_sum(n, dist, roads)
    print("" "".join(map(str, results)))

if __name__ == ""__main__"":
    main()"
896,A,Nephren gives a riddle,PROGRAMMING,"['binary search', 'dfs and similar']","

Nephren is playing a game with little leprechauns.

She gives them an infinite array of strings, *f*0... ∞.

*f*0 is ""What are you doing at the end of the world? Are you busy? Will you save us?"".

She wants to let more people know about it, so she defines *f**i*<==<= ""What are you doing while sending ""*f**i*<=-<=1""? Are you busy? Will you send ""*f**i*<=-<=1""?"" for all *i*<=≥<=1.

For example, *f*1 is

""What are you doing while sending ""What are you doing at the end of the world? Are you busy? Will you save us?""? Are you busy? Will you send ""What are you doing at the end of the world? Are you busy? Will you save us?""?"". Note that the quotes in the very beginning and in the very end are for clarity and are not a part of *f*1.

It can be seen that the characters in *f**i* are letters, question marks, (possibly) quotation marks and spaces.

Nephren will ask the little leprechauns *q* times. Each time she will let them find the *k*-th character of *f**n*. The characters are indexed starting from 1. If *f**n* consists of less than *k* characters, output '.' (without quotes).

Can you answer her queries?","The first line contains one integer *q* (1<=≤<=*q*<=≤<=10) — the number of Nephren's questions.

Each of the next *q* lines describes Nephren's question and contains two integers *n* and *k* (0<=≤<=*n*<=≤<=105,<=1<=≤<=*k*<=≤<=1018).",One line containing *q* characters. The *i*-th character in it should be the answer for the *i*-th query.,"['3\n1 1\n1 2\n1 111111111111\n', '5\n0 69\n1 194\n1 139\n0 47\n1 66\n', '10\n4 1825\n3 75\n3 530\n4 1829\n4 1651\n3 187\n4 584\n4 255\n4 774\n2 474\n']","['Wh.', 'abdef', 'Areyoubusy']","For the first two examples, refer to *f*<sub class=""lower-index"">0</sub> and *f*<sub class=""lower-index"">1</sub> given in the legend.",RUNTIME_ERROR,"from functools import cache
import sys
sys.setrecursionlimit(100004)
input=sys.stdin.readline

if __name__=='__main__':
    s0=""What are you doing at the end of the world? Are you busy? Will you save us?""

    head='What are you doing while sending ""'

    mid='""? Are you busy? Will you send ""'

    tail='""?'

    @cache
    def length(n):
        return 75 if n==0 else length(n-1)+34+32+2
    def found(n,k):
        if n==0:
            return s0[k] if k<=75 else '.'
        pre,now=length(n-1),length(n)
        s1,s2,s3,s4=34,34+pre,34+pre+32,34+pre+32+pre

        if k<s1:
            return head[k]
        elif s1<=k<s2:
            return found(n-1,k-s1)
        elif s2<=k<s3:
            return mid[k-s2]
        elif s3<=k<s4:
            return found(n-1,k-s3)
        elif s4<=k<now:
            return tail[k-s4]
        else:
            return '.'

    t=int(input())
    for _ in range(t):
        n,k=map(int,input().split())
        print(found(n,k-1),end='')","def generate_length(n):

    base = ""What are you doing at the end of the world? Are you busy? Will you save us?""
    lengths = [len(base)]

    for i in range(1, n + 1):

        lengths.append(len(f""What are you doing while sending \""{lengths[i-1]}\""? Are you busy? Will you send \""{lengths[i-1]}\""?""))

    return lengths

def find_kth_character(n, k, lengths):

    base = ""What are you doing at the end of the world? Are you busy? Will you save us?""
    
    if n == 0:
        return base[k - 1] if k <= len(base) else '.'
    
    while n > 0:
        length_of_fn_minus_1 = lengths[n - 1]
        length_of_fn = lengths[n]

        if k <= 39:
            return ""What are you doing while sending \""""[k - 1]
        elif k <= 39 + length_of_fn_minus_1:
            return find_kth_character(n - 1, k - 39, lengths)
        elif k <= 39 + length_of_fn_minus_1 + 43:
            return ""Are you busy? Will you send \""""[k - 1 - (39 + length_of_fn_minus_1)]
        else:
            return '.'

def main():
    import sys

    input_data = sys.stdin.read().strip().split('\n')
    q = int(input_data[0])

    queries = []
    for i in range(1, q + 1):
        n, k = map(int, input_data[i].split())
        queries.append((n, k))

    max_n = max(n for n, k in queries)
    lengths = generate_length(max_n)

    result = []
    for n, k in queries:
        result.append(find_kth_character(n, k, lengths))

    print(''.join(result))

if __name__ == ""__main__"":
    main()"
979,C,Kuro and Walking Route,PROGRAMMING,"['dfs and similar', 'trees']","Kuro is living in a country called Uberland, consisting of $n$ towns, numbered from $1$ to $n$, and $n - 1$ bidirectional roads connecting these towns. It is possible to reach each town from any other. Each road connects two towns $a$ and $b$. Kuro loves walking and he is planning to take a walking marathon, in which he will choose a pair of towns $(u, v)$ ($u \neq v$) and walk from $u$ using the shortest path to $v$ (note that $(u, v)$ is considered to be different from $(v, u)$).

Oddly, there are 2 special towns in Uberland named Flowrisa (denoted with the index $x$) and Beetopia (denoted with the index $y$). Flowrisa is a town where there are many strong-scent flowers, and Beetopia is another town where many bees live. In particular, Kuro will avoid any pair of towns $(u, v)$ if on the path from $u$ to $v$, he reaches Beetopia after he reached Flowrisa, since the bees will be attracted with the flower smell on Kuro’s body and sting him.

Kuro wants to know how many pair of city $(u, v)$ he can take as his route. Since he’s not really bright, he asked you to help him with this problem.","The first line contains three integers $n$, $x$ and $y$ ($1 \leq n \leq 3 \cdot 10^5$, $1 \leq x, y \leq n$, $x \ne y$) - the number of towns, index of the town Flowrisa and index of the town Beetopia, respectively.

$n - 1$ lines follow, each line contains two integers $a$ and $b$ ($1 \leq a, b \leq n$, $a \ne b$), describes a road connecting two towns $a$ and $b$.

It is guaranteed that from each town, we can reach every other town in the city using the given roads. That is, the given map of towns and roads is a tree.","A single integer resembles the number of pair of towns $(u, v)$ that Kuro can use as his walking route.","['3 1 3\n1 2\n2 3\n', '3 1 3\n1 2\n1 3\n']","['5', '4']","On the first example, Kuro can choose these pairs: 
 -  $(1, 2)$: his route would be $1 \rightarrow 2$, -  $(2, 3)$: his route would be $2 \rightarrow 3$, -  $(3, 2)$: his route would be $3 \rightarrow 2$, -  $(2, 1)$: his route would be $2 \rightarrow 1$, -  $(3, 1)$: his route would be $3 \rightarrow 2 \rightarrow 1$. 
Kuro can't choose pair $(1, 3)$ since his walking route would be $1 \rightarrow 2 \rightarrow 3$, in which Kuro visits town $1$ (Flowrisa) and then visits town $3$ (Beetopia), which is not allowed (note that pair $(3, 1)$ is still allowed because although Kuro visited Flowrisa and Beetopia, he did not visit them in that order).

On the second example, Kuro can choose the following pairs: 
 -  $(1, 2)$: his route would be $1 \rightarrow 2$, -  $(2, 1)$: his route would be $2 \rightarrow 1$, -  $(3, 2)$: his route would be $3 \rightarrow 1 \rightarrow 2$, -  $(3, 1)$: his route would be $3 \rightarrow 1$.",TIME_LIMIT_EXCEEDED,"n,x,y=[int(x)for x in input().split()]

adj=[[]for i in range(n+1)]
for i in range(n-1):
    a,b = [int(x) for x in input().split()]
    adj[a].append(b)
    adj[b].append(a)

v=[0]*(n+1)
ph=[]
def dfs(i=x):
    ph.append(i)
    if i==y:
        return True
    v[i]=1
    for ss in adj[i]:
        if v[ss]==0:
            if dfs(ss):
                return True
    ph.pop()
    return False
dfs()

def get_num(r,ex):
    visit=[0]*(n+1)
    visit[ex]=1
    visit[r]=1
    next=[r]
    i=0
    while i<len(next):
        for ss in adj[next[i]]:
            if visit[ss]==0:
                next.append(ss)
                visit[ss]=1
        i+=1
    return len(next)
xx=get_num(x,ph[1])
yy=get_num(y,ph[-2])
print(n*n-n-xx*yy)","def count_valid_pairs(n, x, y, roads):
    from collections import defaultdict, deque

    graph = defaultdict(list)
    for a, b in roads:
        graph[a].append(b)
        graph[b].append(a)

    def bfs_count(start):
        visited = [False] * (n + 1)
        queue = deque([start])
        visited[start] = True
        count = 0

        while queue:
            node = queue.popleft()
            count += 1
            for neighbor in graph[node]:
                if not visited[neighbor]:
                    visited[neighbor] = True
                    queue.append(neighbor)
        return count

    bfs_count_x = bfs_count(x) - 1
    bfs_count_y = bfs_count(y) - 1

    total_pairs = n * (n - 1)

    invalid_pairs = bfs_count_x * bfs_count_y

    valid_pairs = total_pairs - invalid_pairs
    return valid_pairs

def main():
    import sys
    input = sys.stdin.read
    data = input().strip().split('\n')

    n, x, y = map(int, data[0].split())
    roads = [tuple(map(int, line.split())) for line in data[1:]]

    result = count_valid_pairs(n, x, y, roads)

    print(result)

if __name__ == ""__main__"":
    main()"
835,A,Key races,PROGRAMMING,['math'],"Two boys decided to compete in text typing on the site ""Key races"". During the competition, they have to type a text consisting of *s* characters. The first participant types one character in *v*1 milliseconds and has ping *t*1 milliseconds. The second participant types one character in *v*2 milliseconds and has ping *t*2 milliseconds.

If connection ping (delay) is *t* milliseconds, the competition passes for a participant as follows: 
 1.  Exactly after *t* milliseconds after the start of the competition the participant receives the text to be entered. 1.  Right after that he starts to type it. 1.  Exactly *t* milliseconds after he ends typing all the text, the site receives information about it. 
The winner is the participant whose information on the success comes earlier. If the information comes from both participants at the same time, it is considered that there is a draw.

Given the length of the text and the information about participants, determine the result of the game.","The first line contains five integers *s*, *v*1, *v*2, *t*1, *t*2 (1<=≤<=*s*,<=*v*1,<=*v*2,<=*t*1,<=*t*2<=≤<=1000) — the number of characters in the text, the time of typing one character for the first participant, the time of typing one character for the the second participant, the ping of the first participant and the ping of the second participant.","If the first participant wins, print ""First"". If the second participant wins, print ""Second"". In case of a draw print ""Friendship"".","['5 1 2 1 2\n', '3 3 1 1 1\n', '4 5 3 1 5\n']","['First\n', 'Second\n', 'Friendship\n']","In the first example, information on the success of the first participant comes in 7 milliseconds, of the second participant — in 14 milliseconds. So, the first wins.

In the second example, information on the success of the first participant comes in 11 milliseconds, of the second participant — in 5 milliseconds. So, the second wins.

In the third example, information on the success of the first participant comes in 22 milliseconds, of the second participant — in 22 milliseconds. So, it is be a draw.",OK,"from sys import stdin, stdout
def read():
	return stdin.readline().rstrip()

def read_int():
	return int(read())
 
def read_ints():
	return list(map(int, read().split()))
 
def solve():
	s,v1,v2,t1,t2 = read_ints()
	if v1*s+2*t1 < v2*s+2*t2:
		print(""First"")
	elif v1*s+2*t1 > v2*s+2*t2:
		print(""Second"")
	else:
		print(""Friendship"")

solve()","def competition_result(s, v1, v2, t1, t2):

    time1 = 2 * t1 + s * v1

    time2 = 2 * t2 + s * v2

    if time1 < time2:
        return ""First""
    elif time1 > time2:
        return ""Second""
    else:
        return ""Friendship""

test_cases = [
    (5, 1, 2, 1, 2),
    (3, 3, 1, 1, 1),
    (4, 5, 3, 1, 5)
]

results = [competition_result(*case) for case in test_cases]
for result in results:
    print(result)"
560,A,Currency System in Geraldion,PROGRAMMING,"['implementation', 'sortings']","A magic island Geraldion, where Gerald lives, has its own currency system. It uses banknotes of several values. But the problem is, the system is not perfect and sometimes it happens that Geraldionians cannot express a certain sum of money with any set of banknotes. Of course, they can use any number of banknotes of each value. Such sum is called unfortunate. Gerald wondered: what is the minimum unfortunate sum?","The first line contains number *n* (1<=≤<=*n*<=≤<=1000) — the number of values of the banknotes that used in Geraldion. 

The second line contains *n* distinct space-separated numbers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=106) — the values of the banknotes.","Print a single line — the minimum unfortunate sum. If there are no unfortunate sums, print <=-<=1.",['5\n1 2 3 4 5\n'],['-1\n'],none,RUNTIME_ERROR,"def prost(n):
    a = 2
    while n % a != 0 and n**0.5 > a :
            a += 1  
    if n % a == 0 and n != 2:
        return 0
    else:
        return 1    
n = int(input())
ai = list(map(int,input().split()))
nums = [0]*1000000
answer = -1
for i in range(n):
    nums[ai[i]] = 1
if nums[1] != 1:
    answer = 1
print(answer)","def minimum_unfortunate_sum():
    import sys

    input = sys.stdin.read
    data = input().splitlines()

    n = int(data[0])
    banknotes = list(map(int, data[1].split()))

    if banknotes[0] > 1:
        print(1)
        return

    max_sum = sum(banknotes)
    can_make = [False] * (max_sum + 1)
    can_make[0] = True

    for note in banknotes:
        for j in range(note, max_sum + 1):
            if can_make[j - note]:
                can_make[j] = True

    for i in range(1, len(can_make)):
        if not can_make[i]:
            print(i)
            return

    print(-1)

if __name__ == ""__main__"":
    minimum_unfortunate_sum()"
437,C,The Child and Toy,PROGRAMMING,"['graphs', 'greedy', 'sortings']","On Children's Day, the child got a toy from Delayyy as a present. However, the child is so naughty that he can't wait to destroy the toy.

The toy consists of *n* parts and *m* ropes. Each rope links two parts, but every pair of parts is linked by at most one rope. To split the toy, the child must remove all its parts. The child can remove a single part at a time, and each remove consume an energy. Let's define an energy value of part *i* as *v**i*. The child spend *v**f*1<=+<=*v**f*2<=+<=...<=+<=*v**f**k* energy for removing part *i* where *f*1,<=*f*2,<=...,<=*f**k* are the parts that are directly connected to the *i*-th and haven't been removed.

Help the child to find out, what is the minimum total energy he should spend to remove all *n* parts.","The first line contains two integers *n* and *m* (1<=≤<=*n*<=≤<=1000; 0<=≤<=*m*<=≤<=2000). The second line contains *n* integers: *v*1,<=*v*2,<=...,<=*v**n* (0<=≤<=*v**i*<=≤<=105). Then followed *m* lines, each line contains two integers *x**i* and *y**i*, representing a rope from part *x**i* to part *y**i* (1<=≤<=*x**i*,<=*y**i*<=≤<=*n*; *x**i*<=≠<=*y**i*).

Consider all the parts are numbered from 1 to *n*.",Output the minimum total energy the child should spend to remove all *n* parts of the toy.,"['4 3\n10 20 30 40\n1 4\n1 2\n2 3\n', '4 4\n100 100 100 100\n1 2\n2 3\n2 4\n3 4\n', '7 10\n40 10 20 10 20 80 40\n1 5\n4 7\n4 5\n5 2\n5 7\n6 4\n1 6\n1 3\n4 3\n1 4\n']","['40\n', '400\n', '160\n']","One of the optimal sequence of actions in the first sample is:
 -  First, remove part 3, cost of the action is 20. -  Then, remove part 2, cost of the action is 10. -  Next, remove part 4, cost of the action is 10. -  At last, remove part 1, cost of the action is 0. 
So the total energy the child paid is 20 + 10 + 10 + 0 = 40, which is the minimum.

In the second sample, the child will spend 400 no matter in what order he will remove the parts.",OK,"from collections import defaultdict
n,m = map(int,input().split())
A = list(map(int,input().split()))
d = defaultdict(list)
ans = 0
for i in range(m):
    a,b = map(int,input().split())
    ans += min(A[a-1],A[b-1])
    
print(ans)","def min_energy_to_remove_parts(n, m, energy_values, connections):
    from collections import defaultdict, deque

    graph = defaultdict(list)
    for x, y in connections:
        graph[x].append(y)
        graph[y].append(x)

    total_energy = 0
    parts_removed = set()

    def calculate_removal_cost(part):
        cost = 0
        for neighbor in graph[part]:
            if neighbor not in parts_removed:
                cost += energy_values[neighbor - 1]
        return cost

    for part in range(1, n + 1):
        removal_cost = calculate_removal_cost(part)
        total_energy += removal_cost
        parts_removed.add(part)

    return total_energy

def main():
    import sys
    input = sys.stdin.read
    data = input().strip().split('\n')
    
    index = 0
    results = []
    while index < len(data):
        n, m = map(int, data[index].split())
        index += 1
        energy_values = list(map(int, data[index].split()))
        index += 1
        
        connections = []
        for _ in range(m):
            x, y = map(int, data[index].split())
            connections.append((x, y))
            index += 1

        min_energy = min_energy_to_remove_parts(n, m, energy_values, connections)
        results.append(min_energy)

    for result in results:
        print(result)

if __name__ == ""__main__"":
    main()"
148,A,Insomnia cure,PROGRAMMING,"['constructive algorithms', 'implementation', 'math']","«One dragon. Two dragon. Three dragon», — the princess was counting. She had trouble falling asleep, and she got bored of counting lambs when she was nine.

However, just counting dragons was boring as well, so she entertained herself at best she could. Tonight she imagined that all dragons were here to steal her, and she was fighting them off. Every *k*-th dragon got punched in the face with a frying pan. Every *l*-th dragon got his tail shut into the balcony door. Every *m*-th dragon got his paws trampled with sharp heels. Finally, she threatened every *n*-th dragon to call her mom, and he withdrew in panic.

How many imaginary dragons suffered moral or physical damage tonight, if the princess counted a total of *d* dragons?","Input data contains integer numbers *k*,<=*l*,<=*m*,<=*n* and *d*, each number in a separate line (1<=≤<=*k*,<=*l*,<=*m*,<=*n*<=≤<=10, 1<=≤<=*d*<=≤<=105).",Output the number of damaged dragons.,"['1\n2\n3\n4\n12\n', '2\n3\n4\n5\n24\n']","['12\n', '17\n']","In the first case every first dragon got punched with a frying pan. Some of the dragons suffered from other reasons as well, but the pan alone would be enough.

In the second case dragons 1, 7, 11, 13, 17, 19 and 23 escaped unharmed.",OK,"def lcm(l):
    if len(l)==2:
        for i in range(1,l[0]*l[1]+1):
            if i%l[0]==0 and i%l[1]==0:
                return i
    if len(l)==3:
        for i in range(1,l[0]*l[1]*l[2]+1):
            if i%l[0]==0 and i%l[1]==0 and i%l[2]==0:
                return i
    if len(l)==4:
         for i in range(1,l[0]*l[1]*l[2]*l[3]+1):
            if i%l[0]==0 and i%l[1]==0 and i%l[2]==0 and i%l[3]==0:
                return i

a=int(input())
b=int(input())
c=int(input())
d=int(input())
n=int(input())
lcm_ab=n//lcm([a,b])
lcm_ac=n//lcm([a,c])
lcm_ad=n//lcm([a,d])
lcm_bc=n//lcm([b,c])
lcm_bd=n//lcm([b,d])
lcm_cd=n//lcm([c,d])
lcm_abc=n//lcm([a,b,c])
lcm_abd=n//lcm([a,b,d])
lcm_acd=n//lcm([a,c,d])
lcm_bcd=n//lcm([b,c,d])
lcm_abcd=n//lcm([a,b,c,d])
dragons=(n//a+n//b+n//c+n//d)-(lcm_ab+lcm_ac+lcm_ad+lcm_bc+lcm_bd+lcm_cd)+(lcm_abc+lcm_abd+lcm_acd+lcm_bcd)-lcm_abcd
print(dragons)

'''a=int(input())
b=int(input())
c=int(input())
d=int(input())
n=int(input())
l=[]

if a==1 or b==1 or c==1 or d==1:
    print(n)

elif a>n and b>n and c>n and d>n:

    print(0)
    
else:
    for i in range(1,n+1):
        l.append(i)
    damaged=[]
    for i in range(1,n+1,a):
        if i not in damaged:
            damaged.append(i)
    for i in range(1,n+1,b):
        if i not in damaged:
            damaged.append(i)
    for i in range(1,n+1,c):
        if i not in damaged:
            damaged.append(i)
    for i in range(1,n+1,d):
        if i not in damaged:
            damaged.append(i)
    print(len(damaged))'''","def count_damaged_dragons(k, l, m, n, d):
    damaged_dragons = 0

    for dragon in range(1, d + 1):

        if dragon % k == 0 or dragon % l == 0 or dragon % m == 0 or dragon % n == 0:
            damaged_dragons += 1
            
    return damaged_dragons

k = int(input())
l = int(input())
m = int(input())
n = int(input())
d = int(input())

print(count_damaged_dragons(k, l, m, n, d))"
1,A,Theatre Square,PROGRAMMING,['math'],"Theatre Square in the capital city of Berland has a rectangular shape with the size *n*<=×<=*m* meters. On the occasion of the city's anniversary, a decision was taken to pave the Square with square granite flagstones. Each flagstone is of the size *a*<=×<=*a*.

What is the least number of flagstones needed to pave the Square? It's allowed to cover the surface larger than the Theatre Square, but the Square has to be covered. It's not allowed to break the flagstones. The sides of flagstones should be parallel to the sides of the Square.","The input contains three positive integer numbers in the first line: *n*,<=<=*m* and *a* (1<=≤<=<=*n*,<=*m*,<=*a*<=≤<=109).",Write the needed number of flagstones.,['6 6 4\n'],['4\n'],none,OK,"def tiles(size, length):
	reqd = size // length
	rem = size % length
	return reqd if rem == 0 else reqd + 1

n, m, a = (int(i) for i in input().split())
print(tiles(n, a) * tiles(m, a))","import math

n, m, a = map(int, input().split())

flagstones_length = math.ceil(n / a)
flagstones_width = math.ceil(m / a)

total_flagstones = flagstones_length * flagstones_width

print(total_flagstones)"
337,D,Book of Evil,PROGRAMMING,"['dfs and similar', 'divide and conquer', 'dp', 'trees']","Paladin Manao caught the trail of the ancient Book of Evil in a swampy area. This area contains *n* settlements numbered from 1 to *n*. Moving through the swamp is very difficult, so people tramped exactly *n*<=-<=1 paths. Each of these paths connects some pair of settlements and is bidirectional. Moreover, it is possible to reach any settlement from any other one by traversing one or several paths.

The distance between two settlements is the minimum number of paths that have to be crossed to get from one settlement to the other one. Manao knows that the Book of Evil has got a damage range *d*. This means that if the Book of Evil is located in some settlement, its damage (for example, emergence of ghosts and werewolves) affects other settlements at distance *d* or less from the settlement where the Book resides.

Manao has heard of *m* settlements affected by the Book of Evil. Their numbers are *p*1,<=*p*2,<=...,<=*p**m*. Note that the Book may be affecting other settlements as well, but this has not been detected yet. Manao wants to determine which settlements may contain the Book. Help him with this difficult task.","The first line contains three space-separated integers *n*, *m* and *d* (1<=≤<=*m*<=≤<=*n*<=≤<=100000; 0<=≤<=*d*<=≤<=*n*<=-<=1). The second line contains *m* distinct space-separated integers *p*1,<=*p*2,<=...,<=*p**m* (1<=≤<=*p**i*<=≤<=*n*). Then *n*<=-<=1 lines follow, each line describes a path made in the area. A path is described by a pair of space-separated integers *a**i* and *b**i* representing the ends of this path.","Print a single number — the number of settlements that may contain the Book of Evil. It is possible that Manao received some controversial information and there is no settlement that may contain the Book. In such case, print 0.",['6 2 3\n1 2\n1 5\n2 3\n3 4\n4 5\n5 6\n'],['3\n'],"Sample 1. The damage range of the Book of Evil equals 3 and its effects have been noticed in settlements 1 and 2. Thus, it can be in settlements 3, 4 or 5.",MEMORY_LIMIT_EXCEEDED,"import sys

sys.setrecursionlimit(10000000)

n, m, d = [int(i) for i in input().split()]
exist = [False] * (n + 1)
for i in input().split():
    exist[int(i)] = True
dest = [[] for _ in range(n + 1)]
for _ in range(n - 1):
    a, b = [int(i) for i in input().split()]
    dest[a].append(b)
    dest[b].append(a)

d_subtree = [-10000000] * (n + 1)

def dfs1(x, p):
    if exist[x]:
        d_subtree[x] = 0
    for to in dest[x]:
        if to != p:
            dfs1(to, x)
            d_subtree[x] = max(d_subtree[x], d_subtree[to] + 1)

dfs1(1, -1)
d_else = [-10000000] * (n + 1)

def dfs2(x, p):
    max1 = -10000000
    max2 = -10000000
    if exist[x]:
        d_else[x] = max(0, d_else[x])
    for to in dest[x]:
        if to == p:
            continue
        if d_subtree[to] > max1:
            max2 = max1
            max1 = d_subtree[to]
        elif d_subtree[to] > max2:
            max2 = d_subtree[to]
    for to in dest[x]:
        if to == p:
            continue
        sDist = max2 if d_subtree[to] == max1 else max1
        if sDist >= 0:
            sDist += 2
        d_else[to] = max(sDist, d_else[x] + 1)
        dfs2(to, x)

dfs2(1, -1)
print(sum([(d_subtree[i] <= d and d_else[i] <= d) for i in range(1, 1 + n)]))","import sys
from collections import deque, defaultdict

def bfs(start_nodes, graph, d):
    visited = set(start_nodes)
    queue = deque(start_nodes)
    distance = 0
    
    while queue and distance < d:
        level_size = len(queue)
        for _ in range(level_size):
            current = queue.popleft()
            for neighbor in graph[current]:
                if neighbor not in visited:
                    visited.add(neighbor)
                    queue.append(neighbor)
        distance += 1

    return visited

def main():

    input_data = sys.stdin.read().strip().split('\n')
    n, m, d = map(int, input_data[0].split())
    affected_settlements = list(map(int, input_data[1].split()))

    graph = defaultdict(list)
    for i in range(2, 2 + (n - 1)):
        a, b = map(int, input_data[i].split())
        graph[a].append(b)
        graph[b].append(a)

    settlements_with_book = bfs(affected_settlements, graph, d)

    result = len(settlements_with_book) - len(affected_settlements)
    print(result)

if __name__ == ""__main__"":
    main()"
0,none,none,none,['none'],"Limak is an old brown bear. He often plays poker with his friends. Today they went to a casino. There are *n* players (including Limak himself) and right now all of them have bids on the table. *i*-th of them has bid with size *a**i* dollars.

Each player can double his bid any number of times and triple his bid any number of times. The casino has a great jackpot for making all bids equal. Is it possible that Limak and his friends will win a jackpot?","First line of input contains an integer *n* (2<=≤<=*n*<=≤<=105), the number of players.

The second line contains *n* integer numbers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=109) — the bids of players.","Print ""Yes"" (without the quotes) if players can make their bids become equal, or ""No"" otherwise.","['4\n75 150 75 50\n', '3\n100 150 250\n']","['Yes\n', 'No\n']","In the first sample test first and third players should double their bids twice, second player should double his bid once and fourth player should both double and triple his bid.

It can be shown that in the second sample test there is no way to make all bids equal.",WRONG_ANSWER,"n = int(input())
numbers = list(map(int, input().split()))

MAX = 32000
bs = [True] * MAX
primes = []

def sieve():
    bs[0] = False
    bs[1] = False
    for i in range(2, MAX):
        if bs[i]:
            for j in range(i * i, MAX, i):
                bs[j] = False
            primes.append(i)

def num_pfs(number):
    num_pfs = 0
    for p in primes:
        if p * p > number:
            break

        while number % p == 0:
            if p > 3:
                num_pfs += 1

            number //= p

    if number > 1:
        if number > 3:
            num_pfs += 1

    return num_pfs

sieve()
pfs = num_pfs(numbers[0])
possible = True
for i in range(1, len(numbers)):
    if num_pfs(numbers[i]) != pfs:
        possible = False
        break

if possible:
    print(""Yes"")
else:
    print(""No"")","def can_make_equal_bids(n, bids):

    def normalize(x):
        while x % 2 == 0:
            x //= 2
        while x % 3 == 0:
            x //= 3
        return x

    normalized_bids = [normalize(bid) for bid in bids]

    if all(x == normalized_bids[0] for x in normalized_bids):
        return ""Yes""
    else:
        return ""No""

n = int(input().strip())
bids = list(map(int, input().strip().split()))

result = can_make_equal_bids(n, bids)
print(result)"
592,C,The Big Race,PROGRAMMING,['math'],"Vector Willman and Array Bolt are the two most famous athletes of Byteforces. They are going to compete in a race with a distance of *L* meters today.

Willman and Bolt have exactly the same speed, so when they compete the result is always a tie. That is a problem for the organizers because they want a winner. 

While watching previous races the organizers have noticed that Willman can perform only steps of length equal to *w* meters, and Bolt can perform only steps of length equal to *b* meters. Organizers decided to slightly change the rules of the race. Now, at the end of the racetrack there will be an abyss, and the winner will be declared the athlete, who manages to run farther from the starting point of the the racetrack (which is not the subject to change by any of the athletes). 

Note that none of the athletes can run infinitely far, as they both will at some moment of time face the point, such that only one step further will cause them to fall in the abyss. In other words, the athlete will not fall into the abyss if the total length of all his steps will be less or equal to the chosen distance *L*.

Since the organizers are very fair, the are going to set the length of the racetrack as an integer chosen randomly and uniformly in range from 1 to *t* (both are included). What is the probability that Willman and Bolt tie again today?","The first line of the input contains three integers *t*, *w* and *b* (1<=≤<=*t*,<=*w*,<=*b*<=≤<=5·1018) — the maximum possible length of the racetrack, the length of Willman's steps and the length of Bolt's steps respectively.","Print the answer to the problem as an irreducible fraction . Follow the format of the samples output.

The fraction  (*p* and *q* are integers, and both *p*<=≥<=0 and *q*<=&gt;<=0 holds) is called irreducible, if there is no such integer *d*<=&gt;<=1, that both *p* and *q* are divisible by *d*.","['10 3 2\n', '7 1 2\n']","['3/10\n', '3/7\n']","In the first sample Willman and Bolt will tie in case 1, 6 or 7 are chosen as the length of the racetrack.",WRONG_ANSWER,"def lcm(a,b):
    m = a*b
    while a != 0 and b != 0:
        if a > b:
            a %= b
        else:
            b %= a
    return m // (a+b)
t,w,b = map(int,input().split())
if (t % 3 == 0):
    print('1/',end ='')
    print(t/3)
else:
    print('3/',end='')
    print(t)","from math import gcd

def probability_of_tie(t, w, b):

    def max_steps(length, step_size):
        return length // step_size

    tie_count = 0
    
    for L in range(1, t + 1):
        if max_steps(L, w) == max_steps(L, b):
            tie_count += 1

    p = tie_count
    q = t

    common_divisor = gcd(p, q)
    p //= common_divisor
    q //= common_divisor

    return f""{p}/{q}""

input_data = ['10 3 2', '7 1 2']
results = []

for data in input_data:
    t, w, b = map(int, data.split())
    results.append(probability_of_tie(t, w, b))

for result in results:
    print(result)"
377,A,Maze,PROGRAMMING,['dfs and similar'],"Pavel loves grid mazes. A grid maze is an *n*<=×<=*m* rectangle maze where each cell is either empty, or is a wall. You can go from one cell to another only if both cells are empty and have a common side.

Pavel drew a grid maze with all empty cells forming a connected area. That is, you can go from any empty cell to any other one. Pavel doesn't like it when his maze has too little walls. He wants to turn exactly *k* empty cells into walls so that all the remaining cells still formed a connected area. Help him.","The first line contains three integers *n*, *m*, *k* (1<=≤<=*n*,<=*m*<=≤<=500, 0<=≤<=*k*<=&lt;<=*s*), where *n* and *m* are the maze's height and width, correspondingly, *k* is the number of walls Pavel wants to add and letter *s* represents the number of empty cells in the original maze.

Each of the next *n* lines contains *m* characters. They describe the original maze. If a character on a line equals ""."", then the corresponding cell is empty and if the character equals ""#"", then the cell is a wall.","Print *n* lines containing *m* characters each: the new maze that fits Pavel's requirements. Mark the empty cells that you transformed into walls as ""X"", the other cells must be left without changes (that is, ""."" and ""#"").

It is guaranteed that a solution exists. If there are multiple solutions you can output any of them.","['3 4 2\n#..#\n..#.\n#...\n', '5 4 5\n#...\n#.#.\n.#..\n...#\n.#.#\n']","['#.X#\nX.#.\n#...\n', '#XXX\n#X#.\nX#..\n...#\n.#.#\n']",none,WRONG_ANSWER,"def main():
    n, m, k = (int(value) for value in input().split(' '))
    array = [list(input()) for _ in range(n)]

    for i in range(n):
        for j in range(m):
            if k > 0:
                if array[i][j] == '.':
                    array[i][j] = 'X'
                    k -= 1
            else:
                for i in range(n):
                    for j in range(m):
                        print(array[i][j], end='')
                    print()
                return
        

if __name__ == ""__main__"":
    main()","def can_form_connected_area(maze, n, m):
    visited = [[False] * m for _ in range(n)]

    def dfs(x, y):
        stack = [(x, y)]
        while stack:
            cx, cy = stack.pop()
            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                nx, ny = cx + dx, cy + dy
                if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and maze[nx][ny] == ""."":
                    visited[nx][ny] = True
                    stack.append((nx, ny))

    for i in range(n):
        for j in range(m):
            if maze[i][j] == ""."":
                visited[i][j] = True
                dfs(i, j)
                break
    return visited

def transform_maze(n, m, k, maze):

    empty_cells = [(i, j) for i in range(n) for j in range(m) if maze[i][j] == "".""]

    walls_added = 0
    for x, y in empty_cells:
        if walls_added < k:
            maze[x] = maze[x][:y] + ""X"" + maze[x][y + 1:]
            walls_added += 1
        else:
            break

    visited = can_form_connected_area(maze, n, m)

    for x in range(n):
        for y in range(m):
            if maze[x][y] == ""X"" and not visited[x][y]:
                maze[x] = maze[x][:y] + ""."" + maze[x][y + 1:]
                walls_added -= 1
                if walls_added < k:
                    break

    return maze

import sys
input = sys.stdin.read
data = input().splitlines()

n, m, k = map(int, data[0].split())
maze = data[1:n + 1]

new_maze = transform_maze(n, m, k, maze)
for line in new_maze:
    print(line)"
743,C,Vladik and fractions,PROGRAMMING,"['brute force', 'constructive algorithms', 'math', 'number theory']","Vladik and Chloe decided to determine who of them is better at math. Vladik claimed that for any positive integer *n* he can represent fraction  as a sum of three distinct positive fractions in form .

Help Vladik with that, i.e for a given *n* find three distinct positive integers *x*, *y* and *z* such that . Because Chloe can't check Vladik's answer if the numbers are large, he asks you to print numbers not exceeding 109.

If there is no such answer, print -1.",The single line contains single integer *n* (1<=≤<=*n*<=≤<=104).,"If the answer exists, print 3 distinct numbers *x*, *y* and *z* (1<=≤<=*x*,<=*y*,<=*z*<=≤<=109, *x*<=≠<=*y*, *x*<=≠<=*z*, *y*<=≠<=*z*). Otherwise print -1.

If there are multiple answers, print any of them.","['3\n', '7\n']","['2 7 42\n', '7 8 56\n']",none,OK,"for _ in range(1):
    n = int(input())
    ans = -1
    if n != 1:
        a = n 
        b = n + 1
        c = b * a
        if a!=b and b!=c and a!=c:
            print(a,b,c)
        else: print(ans)
    else:            
        print(ans)","def find_distinct_fractions(n):

    if n < 3:
        return -1

    x = n
    y = n + 1
    z = n * (n + 1)

    if x <= 10**9 and y <= 10**9 and z <= 10**9:
        return x, y, z
    
    return -1

n_values = list(map(int, input().strip().split()))

results = []
for n in n_values:
    result = find_distinct_fractions(n)
    if result == -1:
        results.append(""-1"")
    else:
        results.append(f""{result[0]} {result[1]} {result[2]}"")

print(""\n"".join(results))"
600,B,Queries about less or equal elements,PROGRAMMING,"['binary search', 'data structures', 'sortings', 'two pointers']",You are given two arrays of integers *a* and *b*. For each element of the second array *b**j* you should find the number of elements in array *a* that are less than or equal to the value *b**j*.,"The first line contains two integers *n*,<=*m* (1<=≤<=*n*,<=*m*<=≤<=2·105) — the sizes of arrays *a* and *b*.

The second line contains *n* integers — the elements of array *a* (<=-<=109<=≤<=*a**i*<=≤<=109).

The third line contains *m* integers — the elements of array *b* (<=-<=109<=≤<=*b**j*<=≤<=109).","Print *m* integers, separated by spaces: the *j*-th of which is equal to the number of such elements in array *a* that are less than or equal to the value *b**j*.","['5 4\n1 3 5 7 9\n6 4 2 8\n', '5 5\n1 2 1 2 5\n3 1 4 1 5\n']","['3 2 1 4\n', '4 2 4 2 5\n']",none,WRONG_ANSWER,"def search(a,k):
    l,r = 0,len(a)-1
    while l<=r:
        m = l + (r-l)//2
        if a[m] == k:
            l=m+1
        elif a[m]>k:
        	r = m-1
        else:
        	l = m+1
    return l

m,n=map(int,input().split())
a,b=list(map(int,input().split())),list(map(int,input().split()))
a=sorted(a)
print(a,b)
for i in b:
    print(search(a,i),end=' ')","def count_elements_less_equal(n, m, a, b):

    a.sort()
    result = []

    for bj in b:

        count = upper_bound(a, bj)
        result.append(count)
    
    return result

def upper_bound(a, key):

    left, right = 0, len(a)
    while left < right:
        mid = (left + right) // 2
        if a[mid] <= key:
            left = mid + 1
        else:
            right = mid
    return left

if __name__ == ""__main__"":
    import sys
    input = sys.stdin.read
    data = input().splitlines()

    n, m = map(int, data[0].split())

    a = list(map(int, data[1].split()))
    b = list(map(int, data[2].split()))

    result = count_elements_less_equal(n, m, a, b)
    print(' '.join(map(str, result)))"
653,A,Bear and Three Balls,PROGRAMMING,"['brute force', 'implementation', 'sortings']","Limak is a little polar bear. He has *n* balls, the *i*-th ball has size *t**i*.

Limak wants to give one ball to each of his three friends. Giving gifts isn't easy — there are two rules Limak must obey to make friends happy:
 -  No two friends can get balls of the same size. -  No two friends can get balls of sizes that differ by more than 2. 
For example, Limak can choose balls with sizes 4, 5 and 3, or balls with sizes 90, 91 and 92. But he can't choose balls with sizes 5, 5 and 6 (two friends would get balls of the same size), and he can't choose balls with sizes 30, 31 and 33 (because sizes 30 and 33 differ by more than 2).

Your task is to check whether Limak can choose three balls that satisfy conditions above.","The first line of the input contains one integer *n* (3<=≤<=*n*<=≤<=50) — the number of balls Limak has.

The second line contains *n* integers *t*1,<=*t*2,<=...,<=*t**n* (1<=≤<=*t**i*<=≤<=1000) where *t**i* denotes the size of the *i*-th ball.","Print ""YES"" (without quotes) if Limak can choose three balls of distinct sizes, such that any two of them differ by no more than 2. Otherwise, print ""NO"" (without quotes).","['4\n18 55 16 17\n', '6\n40 41 43 44 44 44\n', '8\n5 972 3 4 1 4 970 971\n']","['YES\n', 'NO\n', 'YES\n']","In the first sample, there are 4 balls and Limak is able to choose three of them to satisfy the rules. He must must choose balls with sizes 18, 16 and 17.

In the second sample, there is no way to give gifts to three friends without breaking the rules.

In the third sample, there is even more than one way to choose balls:
 1.  Choose balls with sizes 3, 4 and 5. 1.  Choose balls with sizes 972, 970, 971.",OK,"def optimal_size (t):
    if len(t) <= 2:
        return ""NO""
    for x in range(len(t)-2):
        if abs(t[x+1] - t[x]) <= 2 and abs(t[x+2] - t[x]) <= 2 and abs(t[x+2] - t[x+1]) <= 2:
            return ""YES""
    return ""NO""

n = int(input())
t = list(map(int,input().split()))
t = list(set(t))
t = sorted(t)

print (optimal_size(t))","def can_choose_balls(n, sizes):

    sizes = sorted(set(sizes))

    if len(sizes) < 3:
        return ""NO""

    for i in range(len(sizes) - 2):

        if sizes[i+2] - sizes[i] <= 2:
            return ""YES""
    
    return ""NO""

n = int(input())
sizes = list(map(int, input().split()))

result = can_choose_balls(n, sizes)
print(result)"
334,A,Candy Bags,PROGRAMMING,['implementation'],"Gerald has *n* younger brothers and their number happens to be even. One day he bought *n*2 candy bags. One bag has one candy, one bag has two candies, one bag has three candies and so on. In fact, for each integer *k* from 1 to *n*2 he has exactly one bag with *k* candies. 

Help him give *n* bags of candies to each brother so that all brothers got the same number of candies.","The single line contains a single integer *n* (*n* is even, 2<=≤<=*n*<=≤<=100) — the number of Gerald's brothers.","Let's assume that Gerald indexes his brothers with numbers from 1 to *n*. You need to print *n* lines, on the *i*-th line print *n* integers — the numbers of candies in the bags for the *i*-th brother. Naturally, all these numbers should be distinct and be within limits from 1 to *n*2. You can print the numbers in the lines in any order. 

It is guaranteed that the solution exists at the given limits.",['2\n'],['1 4\n2 3\n'],"The sample shows Gerald's actions if he has two brothers. In this case, his bags contain 1, 2, 3 and 4 candies. He can give the bags with 1 and 4 candies to one brother and the bags with 2 and 3 to the other brother.",WRONG_ANSWER,"def main():
    n = int(input())
    ans = {i:[] for i in range(n)}
    for i in range(n):
        ans[i] = [j+1 for j in range(2*i, 2*i+n//2, 1)] + [n**2-k for k in range(2*i, 2*i+n//2, 1)]

    for i in range(n):
        print(*ans[i])

if __name__ == ""__main__"":
    main()","def distribute_candies(n):

    candies = list(range(1, n * 2 + 1))

    distribution = [[] for _ in range(n)]

    for i in range(n):

        distribution[i].append(candies[i])
        distribution[i].append(candies[n * 2 - 1 - i])

    for bags in distribution:
        print(' '.join(map(str, bags)))

n = int(input().strip())
distribute_candies(n)"
312,B,Archer,PROGRAMMING,"['math', 'probabilities']","SmallR is an archer. SmallR is taking a match of archer with Zanoes. They try to shoot in the target in turns, and SmallR shoots first. The probability of shooting the target each time is  for SmallR while  for Zanoes. The one who shoots in the target first should be the winner.

Output the probability that SmallR will win the match.",A single line contains four integers .,"Print a single real number, the probability that SmallR will win the match.

The answer will be considered correct if the absolute or relative error doesn't exceed 10<=-<=6.",['1 2 1 2\n'],['0.666666666667'],none,OK,"import sys
input=sys.stdin.readline
from collections import defaultdict as dc
from collections import Counter
from bisect import bisect_right, bisect_left
import math
from operator import itemgetter
from heapq import heapify, heappop, heappush
from queue import PriorityQueue as pq
a,b,c,d=map(int,input().split())
x,y=a/b,c/d
z=(1-x)*(1-y)
s=1/(1-z)
print(x*s)","def probability_smallr_wins(p_s, p_z):

    win_probability = p_s / (p_s + p_z - (p_s * p_z))
    return win_probability

if __name__ == ""__main__"":

    input_data = input().strip()
    a, b, c, d = map(int, input_data.split())

    p_s = a / b
    p_z = c / d

    result = probability_smallr_wins(p_s, p_z)

    print(f""{result:.12f}"")"
731,A,Night at the Museum,PROGRAMMING,"['implementation', 'strings']","Grigoriy, like the hero of one famous comedy film, found a job as a night security guard at the museum. At first night he received embosser and was to take stock of the whole exposition.

Embosser is a special devise that allows to ""print"" the text of a plastic tape. Text is printed sequentially, character by character. The device consists of a wheel with a lowercase English letters written in a circle, static pointer to the current letter and a button that print the chosen letter. At one move it's allowed to rotate the alphabetic wheel one step clockwise or counterclockwise. Initially, static pointer points to letter 'a'. Other letters are located as shown on the picture:

After Grigoriy add new item to the base he has to print its name on the plastic tape and attach it to the corresponding exhibit. It's not required to return the wheel to its initial position with pointer on the letter 'a'.

Our hero is afraid that some exhibits may become alive and start to attack him, so he wants to print the names as fast as possible. Help him, for the given string find the minimum number of rotations of the wheel required to print it.",The only line of input contains the name of some exhibit — the non-empty string consisting of no more than 100 characters. It's guaranteed that the string consists of only lowercase English letters.,"Print one integer — the minimum number of rotations of the wheel, required to print the name given in the input.","['zeus\n', 'map\n', 'ares\n']","['18\n', '35\n', '34\n']","To print the string from the first sample it would be optimal to perform the following sequence of rotations: 
 1.  from 'a' to 'z' (1 rotation counterclockwise), 1.  from 'z' to 'e' (5 clockwise rotations), 1.  from 'e' to 'u' (10 rotations counterclockwise), 1.  from 'u' to 's' (2 counterclockwise rotations).",OK,"word = input()
sum = 0
table = 'abcdefghijklmnopqrstuvwxyz'

bias = 0
for step in word:
    num = abs(bias - table.find(step))
    bias = table.find(step)
    if num <= (26-num):
        sum += num
    else:
        sum += 26-num

print(sum)","def min_rotations_to_print(exhibit_name):

    current_position = 'a'
    total_rotations = 0

    for char in exhibit_name:

        forward_steps = (ord(char) - ord(current_position)) % 26
        backward_steps = (ord(current_position) - ord(char)) % 26

        total_rotations += min(forward_steps, backward_steps)

        current_position = char
    
    return total_rotations

exhibits = input().strip().split()
for exhibit in exhibits:

    print(min_rotations_to_print(exhibit))"
706,B,Interesting drink,PROGRAMMING,"['binary search', 'dp', 'implementation']","Vasiliy likes to rest after a hard work, so you may often meet him in some bar nearby. As all programmers do, he loves the famous drink ""Beecola"", which can be bought in *n* different shops in the city. It's known that the price of one bottle in the shop *i* is equal to *x**i* coins.

Vasiliy plans to buy his favorite drink for *q* consecutive days. He knows, that on the *i*-th day he will be able to spent *m**i* coins. Now, for each of the days he want to know in how many different shops he can buy a bottle of ""Beecola"".","The first line of the input contains a single integer *n* (1<=≤<=*n*<=≤<=100<=000) — the number of shops in the city that sell Vasiliy's favourite drink.

The second line contains *n* integers *x**i* (1<=≤<=*x**i*<=≤<=100<=000) — prices of the bottles of the drink in the *i*-th shop.

The third line contains a single integer *q* (1<=≤<=*q*<=≤<=100<=000) — the number of days Vasiliy plans to buy the drink.

Then follow *q* lines each containing one integer *m**i* (1<=≤<=*m**i*<=≤<=109) — the number of coins Vasiliy can spent on the *i*-th day.",Print *q* integers. The *i*-th of them should be equal to the number of shops where Vasiliy will be able to buy a bottle of the drink on the *i*-th day.,['5\n3 10 8 6 11\n4\n1\n10\n3\n11\n'],['0\n4\n1\n5\n'],"On the first day, Vasiliy won't be able to buy a drink in any of the shops.

On the second day, Vasiliy can buy a drink in the shops 1, 2, 3 and 4.

On the third day, Vasiliy can buy a drink only in the shop number 1.

Finally, on the last day Vasiliy can buy a drink in any shop.",TIME_LIMIT_EXCEEDED,"def binary_search(ls,target):
    ls.sort()
    low=0
    high=len(ls)-1
    while low<=high:
        mid=(low+high)//2
        if ls[mid]<=target:
            low=mid+1
        else:
            high=mid-1
    return high
t=int(input())
ls=list(map(int,input().split()))
q=int(input())
for i in range(q):
    key=int(input())
    print(binary_search(ls,key)+1)","n = int(input())

prices = list(map(int, input().split()))

q = int(input())

results = []
for _ in range(q):
    m = int(input())
    count = sum(1 for price in prices if price <= m)
    results.append(count)

print('\n'.join(map(str, results)))"
746,B,Decoding,PROGRAMMING,"['implementation', 'strings']","Polycarp is mad about coding, that is why he writes Sveta encoded messages. He calls the median letter in a word the letter which is in the middle of the word. If the word's length is even, the median letter is the left of the two middle letters. In the following examples, the median letter is highlighted: contest, info. If the word consists of single letter, then according to above definition this letter is the median letter. 

Polycarp encodes each word in the following way: he writes down the median letter of the word, then deletes it and repeats the process until there are no letters left. For example, he encodes the word volga as logva.

You are given an encoding *s* of some word, your task is to decode it.","The first line contains a positive integer *n* (1<=≤<=*n*<=≤<=2000) — the length of the encoded word.

The second line contains the string *s* of length *n* consisting of lowercase English letters — the encoding.",Print the word that Polycarp encoded.,"['5\nlogva\n', '2\nno\n', '4\nabba\n']","['volga\n', 'no\n', 'baba\n']","In the first example Polycarp encoded the word volga. At first, he wrote down the letter l from the position 3, after that his word looked like voga. After that Polycarp wrote down the letter o from the position 2, his word became vga. Then Polycarp wrote down the letter g which was at the second position, the word became va. Then he wrote down the letter v, then the letter a. Thus, the encoding looked like logva.

In the second example Polycarp encoded the word no. He wrote down the letter n, the word became o, and he wrote down the letter o. Thus, in this example, the word and its encoding are the same.

In the third example Polycarp encoded the word baba. At first, he wrote down the letter a, which was at the position 2, after that the word looked like bba. Then he wrote down the letter b, which was at the position 2, his word looked like ba. After that he wrote down the letter b, which was at the position 1, the word looked like a, and he wrote down that letter a. Thus, the encoding is abba.",OK,"def main():

  length = int(input())

  source = input()

  direction = 'r' if (length % 2 == 0) else 'l'
  out = []
  out.append(source[0])
  source = source[1:]

  for c in source:
    if direction == 'l':
      out.insert(0, c)
    else:
	 	  out.append(c)

    direction = 'l' if direction == 'r' else 'r'

  for p in out:
    print(p, end='')

if __name__ == '__main__':
    main()","def decode_polycarp(encoded: str) -> str:

    decoded = []
    length = len(encoded)

    for i in range(length):

        if length % 2 == 1:
            median_index = length // 2
        else:
            median_index = (length // 2) - 1

        decoded.insert(median_index, encoded[i])
        length += 1

    return ''.join(decoded)

n = int(input().strip())
s = input().strip()

print(decode_polycarp(s))"
912,A,Tricky Alchemy,PROGRAMMING,['implementation'],"During the winter holidays, the demand for Christmas balls is exceptionally high. Since it's already 2018, the advances in alchemy allow easy and efficient ball creation by utilizing magic crystals.

Grisha needs to obtain some yellow, green and blue balls. It's known that to produce a yellow ball one needs two yellow crystals, green — one yellow and one blue, and for a blue ball, three blue crystals are enough.

Right now there are *A* yellow and *B* blue crystals in Grisha's disposal. Find out how many additional crystals he should acquire in order to produce the required number of balls.","The first line features two integers *A* and *B* (0<=≤<=*A*,<=*B*<=≤<=109), denoting the number of yellow and blue crystals respectively at Grisha's disposal.

The next line contains three integers *x*, *y* and *z* (0<=≤<=*x*,<=*y*,<=*z*<=≤<=109) — the respective amounts of yellow, green and blue balls to be obtained.",Print a single integer — the minimum number of crystals that Grisha should acquire in addition.,"['4 3\n2 1 1\n', '3 9\n1 1 3\n', '12345678 87654321\n43043751 1000000000 53798715\n']","['2\n', '1\n', '2147483648\n']","In the first sample case, Grisha needs five yellow and four blue crystals to create two yellow balls, one green ball, and one blue ball. To do that, Grisha needs to obtain two additional crystals: one yellow and one blue.",OK,"import sys
import math
import bisect
import itertools

def main():
    A = list(map(int, input().split()))
    B = list(map(int, input().split()))

    yellow = B[0] * 2 + B[1] * 1
    blue = B[1] * 1 + B[2] * 3
    ans = 0

    if A[0] < yellow:
        ans += yellow - A[0]
    if A[1] < blue:
        ans += blue - A[1]
    print(ans)

if __name__ == ""__main__"":
    main()","A, B = map(int, input().split())

x, y, z = map(int, input().split())

yellow_needed = 2 * x + y
blue_needed = 3 * z + y

additional_yellow = max(0, yellow_needed - A)
additional_blue = max(0, blue_needed - B)

total_additional = additional_yellow + additional_blue

print(total_additional)"
834,A,The Useless Toy,PROGRAMMING,['implementation'],"Walking through the streets of Marshmallow City, Slastyona have spotted some merchants selling a kind of useless toy which is very popular nowadays – caramel spinner! Wanting to join the craze, she has immediately bought the strange contraption.

Spinners in Sweetland have the form of V-shaped pieces of caramel. Each spinner can, well, spin around an invisible magic axis. At a specific point in time, a spinner can take 4 positions shown below (each one rotated 90 degrees relative to the previous, with the fourth one followed by the first one):

After the spinner was spun, it starts its rotation, which is described by a following algorithm: the spinner maintains its position for a second then majestically switches to the next position in clockwise or counter-clockwise order, depending on the direction the spinner was spun in.

Slastyona managed to have spinner rotating for exactly *n* seconds. Being fascinated by elegance of the process, she completely forgot the direction the spinner was spun in! Lucky for her, she managed to recall the starting position, and wants to deduct the direction given the information she knows. Help her do this.","There are two characters in the first string – the starting and the ending position of a spinner. The position is encoded with one of the following characters: v (ASCII code 118, lowercase v), &lt; (ASCII code 60), ^ (ASCII code 94) or &gt; (ASCII code 62) (see the picture above for reference). Characters are separated by a single space.

In the second strings, a single number *n* is given (0<=≤<=*n*<=≤<=109) – the duration of the rotation.

It is guaranteed that the ending position of a spinner is a result of a *n* second spin in any of the directions, assuming the given starting position.","Output cw, if the direction is clockwise, ccw – if counter-clockwise, and undefined otherwise.","['^ &gt;\n1\n', '&lt; ^\n3\n', '^ v\n6\n']","['cw\n', 'ccw\n', 'undefined\n']",none,OK,"d = {""v"":  0, ""<"": 1, ""^"": 2, "">"": 3}
f1, f2 = input().split()
s = int(input())

x1 = (d[f1] + s) % 4 == d[f2]
x2 = (d[f1] - s) % 4 == d[f2]
if x1 and x2:
    print(""undefined"")
elif x1:
    print(""cw"")
else:
    print(""ccw"")","def spinner_direction(input_data):

    positions = ['v', '<', '^', '>']
    
    results = []
    
    for data in input_data:

        lines = data.strip().split('\n')
        start_position, end_position = lines[0].split()
        n = int(lines[1])

        start_index = positions.index(start_position)
        end_index = positions.index(end_position)

        cw_position = (start_index + n) % 4
        ccw_position = (start_index - n) % 4

        if cw_position == end_index and ccw_position == end_index:
            results.append('undefined\n')
        elif cw_position == end_index:
            results.append('cw\n')
        elif ccw_position == end_index:
            results.append('ccw\n')
        else:
            results.append('undefined\n')
    
    return results

input_data = [
    '^ >\n1\n', 
    '< ^\n3\n', 
    '^ v\n6\n'
]

output_data = spinner_direction(input_data)
print(output_data)"
902,A,Visiting a Friend,PROGRAMMING,"['greedy', 'implementation']","Pig is visiting a friend.

Pig's house is located at point 0, and his friend's house is located at point *m* on an axis.

Pig can use teleports to move along the axis.

To use a teleport, Pig should come to a certain point (where the teleport is located) and choose where to move: for each teleport there is the rightmost point it can move Pig to, this point is known as the limit of the teleport.

Formally, a teleport located at point *x* with limit *y* can move Pig from point *x* to any point within the segment [*x*;<=*y*], including the bounds.

Determine if Pig can visit the friend using teleports only, or he should use his car.","The first line contains two integers *n* and *m* (1<=≤<=*n*<=≤<=100,<=1<=≤<=*m*<=≤<=100) — the number of teleports and the location of the friend's house.

The next *n* lines contain information about teleports.

The *i*-th of these lines contains two integers *a**i* and *b**i* (0<=≤<=*a**i*<=≤<=*b**i*<=≤<=*m*), where *a**i* is the location of the *i*-th teleport, and *b**i* is its limit.

It is guaranteed that *a**i*<=≥<=*a**i*<=-<=1 for every *i* (2<=≤<=*i*<=≤<=*n*).","Print ""YES"" if there is a path from Pig's house to his friend's house that uses only teleports, and ""NO"" otherwise.

You can print each letter in arbitrary case (upper or lower).","['3 5\n0 2\n2 4\n3 5\n', '3 7\n0 4\n2 5\n6 7\n']","['YES\n', 'NO\n']","The first example is shown on the picture below:

Pig can use the first teleport from his house (point 0) to reach point 2, then using the second teleport go from point 2 to point 3, then using the third teleport go from point 3 to point 5, where his friend lives.

The second example is shown on the picture below:

You can see that there is no path from Pig's house to his friend's house that uses only teleports.",OK,"def can_visit_friend(n, m, teleports):
    current_pos = 0  
    for i in range(n):
        ai, bi = teleports[i]
        
        
        if ai > current_pos:
            return ""NO"" 
            
    
        current_pos = max(current_pos, bi)

        if current_pos >= m:
            return ""YES"" 

    return ""YES"" if current_pos >= m else ""NO""

n, m = map(int, input().split())
teleports = []
for _ in range(n):
    ai, bi = map(int, input().split())
    teleports.append((ai, bi))

result = can_visit_friend(n, m, teleports)

print(result)","def can_visit_friend(n, m, teleports):

    teleports.sort()

    current_position = 0
    max_reachable = 0
    
    while max_reachable < m:

        for a, b in teleports:
            if a > max_reachable:
                break

            if a <= current_position <= b:
                max_reachable = max(max_reachable, b)

        if max_reachable == current_position:
            break

        current_position = max_reachable
        
    return ""YES"" if max_reachable >= m else ""NO""

input_data = [
    '3 5\n0 2\n2 4\n3 5\n',
    '3 7\n0 4\n2 5\n6 7\n'
]

for data in input_data:
    lines = data.strip().split('\n')
    n, m = map(int, lines[0].split())
    teleports = [tuple(map(int, line.split())) for line in lines[1:n + 1]]

    result = can_visit_friend(n, m, teleports)
    print(result)"
181,B,Number of Triplets,PROGRAMMING,"['binary search', 'brute force']","You are given *n* points on a plane. All points are different.

Find the number of different groups of three points (*A*,<=*B*,<=*C*) such that point *B* is the middle of segment *AC*. 

The groups of three points are considered unordered, that is, if point *B* is the middle of segment *AC*, then groups (*A*,<=*B*,<=*C*) and (*C*,<=*B*,<=*A*) are considered the same.","The first line contains a single integer *n* (3<=≤<=*n*<=≤<=3000) — the number of points. 

Next *n* lines contain the points. The *i*-th line contains coordinates of the *i*-th point: two space-separated integers *x**i*,<=*y**i* (<=-<=1000<=≤<=*x**i*,<=*y**i*<=≤<=1000).

It is guaranteed that all given points are different.",Print the single number — the answer to the problem.,"['3\n1 1\n2 2\n3 3\n', '3\n0 0\n-1 0\n0 1\n']","['1\n', '0\n']",none,WRONG_ANSWER,"import sys
import fractions
def solve():
    n = int(input())
    xs, ys = list(), list()
    for i in range(n):
        x, y = map(int, input().split())
        xs.append(x)
        ys.append(y)
    count = [0] * (n + 1)
    for i in range(n):
        slopes = dict()
        x, y = xs[i], ys[i]
        for o in range(n):
            if i != o:
                xdiff, ydiff = x - xs[o], y - ys[o]
                div = fractions.gcd(xdiff, ydiff)
                xdiff /= div
                ydiff /= div
                if (xdiff, ydiff) in slopes:
                    slopes[(xdiff, ydiff)] += 1
                else: slopes[(xdiff, ydiff)] = 2
        for key in slopes:
            count[slopes[key]] += 1
    for i in range(1, len(count)): count[i] //= i
    res = 0
    for i in range(3, len(count)):
        res += (count[i]) * (i - 2)
    print(res)

if sys.hexversion == 50594544 : sys.stdin = open(""test.txt"")
solve()","def count_triplets(points):
    n = len(points)
    count = 0

    for i in range(n):
        xB, yB = points[i]
        points_set = set(points)

        for j in range(n):
            if j == i:
                continue
            
            xA, yA = points[j]

            xC = 2 * xB - xA
            yC = 2 * yB - yA

            if (xC, yC) in points_set and (xC, yC) != (xA, yA) and (xC, yC) != (xB, yB):
                count += 1

    return count // 2

if __name__ == ""__main__"":
    import sys
    
    input = sys.stdin.read
    data = input().splitlines()
    
    n = int(data[0])
    points = [tuple(map(int, line.split())) for line in data[1:n+1]]
    
    result = count_triplets(points)
    print(result)"
609,A,USB Flash Drives,PROGRAMMING,"['greedy', 'implementation', 'sortings']","Sean is trying to save a large file to a USB flash drive. He has *n* USB flash drives with capacities equal to *a*1,<=*a*2,<=...,<=*a**n* megabytes. The file size is equal to *m* megabytes. 

Find the minimum number of USB flash drives needed to write Sean's file, if he can split the file between drives.","The first line contains positive integer *n* (1<=≤<=*n*<=≤<=100) — the number of USB flash drives.

The second line contains positive integer *m* (1<=≤<=*m*<=≤<=105) — the size of Sean's file.

Each of the next *n* lines contains positive integer *a**i* (1<=≤<=*a**i*<=≤<=1000) — the sizes of USB flash drives in megabytes.

It is guaranteed that the answer exists, i. e. the sum of all *a**i* is not less than *m*.","Print the minimum number of USB flash drives to write Sean's file, if he can split the file between drives.","['3\n5\n2\n1\n3\n', '3\n6\n2\n3\n2\n', '2\n5\n5\n10\n']","['2\n', '3\n', '1\n']","In the first example Sean needs only two USB flash drives — the first and the third.

In the second example Sean needs all three USB flash drives.

In the third example Sean needs only one USB flash drive and he can use any available USB flash drive — the first or the second.",OK,"def main():
    n = int(input())
    m = int(input())
    arr = [int(input()) for i in range(n)]
    arr.sort(reverse=True)
    sum = 0
    res = 0
    for i in arr:
        sum += i
        res += 1
        if sum >= m:
            break
    print(res)

main()","def min_usb_drives(n, m, capacities):

    capacities.sort(reverse=True)
    
    total_capacity = 0
    count = 0

    for capacity in capacities:
        total_capacity += capacity
        count += 1
        if total_capacity >= m:
            return count

if __name__ == ""__main__"":
    import sys
    
    input_data = sys.stdin.read().strip().split('\n')
    
    n = int(input_data[0])
    m = int(input_data[1])
    capacities = [int(input_data[i]) for i in range(2, n + 2)]
    
    result = min_usb_drives(n, m, capacities)
    print(result)"
340,A,The Wall,PROGRAMMING,['math'],"Iahub and his friend Floyd have started painting a wall. Iahub is painting the wall red and Floyd is painting it pink. You can consider the wall being made of a very large number of bricks, numbered 1, 2, 3 and so on. 

Iahub has the following scheme of painting: he skips *x*<=-<=1 consecutive bricks, then he paints the *x*-th one. That is, he'll paint bricks *x*, 2·*x*, 3·*x* and so on red. Similarly, Floyd skips *y*<=-<=1 consecutive bricks, then he paints the *y*-th one. Hence he'll paint bricks *y*, 2·*y*, 3·*y* and so on pink.

After painting the wall all day, the boys observed that some bricks are painted both red and pink. Iahub has a lucky number *a* and Floyd has a lucky number *b*. Boys wonder how many bricks numbered no less than *a* and no greater than *b* are painted both red and pink. This is exactly your task: compute and print the answer to the question.","The input will have a single line containing four integers in this order: *x*, *y*, *a*, *b*. (1<=≤<=*x*,<=*y*<=≤<=1000, 1<=≤<=*a*,<=*b*<=≤<=2·109, *a*<=≤<=*b*).",Output a single integer — the number of bricks numbered no less than *a* and no greater than *b* that are painted both red and pink.,['2 3 6 18\n'],['3'],"Let's look at the bricks from *a* to *b* (*a* = 6, *b* = 18). The bricks colored in red are numbered 6, 8, 10, 12, 14, 16, 18. The bricks colored in pink are numbered 6, 9, 12, 15, 18. The bricks colored in both red and pink are numbered with 6, 12 and 18.",WRONG_ANSWER,"x,y,a,b=map(int,input().split())

def gcd(x,y):
    if (x%y==0):
        return y
    else:
        return(gcd(y,x%y))

n=gcd(x,y)
t=x*y/n
s=0
u=((a/t)+1)*t
if(u<b):s=int((b-u)/t)+1
if a%t==0:s+=1

print(s)","x, y, a, b = map(int, input().split())

def count_common_bricks(x, y, a, b):

    from math import gcd
    lcm = (x * y) // gcd(x, y)

    count = b // lcm - (a - 1) // lcm
    return count

result = count_common_bricks(x, y, a, b)
print(result)"
959,A,Mahmoud and Ehab and the even-odd game,PROGRAMMING,"['games', 'math']","Mahmoud and Ehab play a game called the even-odd game. Ehab chooses his favorite integer *n* and then they take turns, starting from Mahmoud. In each player's turn, he has to choose an integer *a* and subtract it from *n* such that:
 -  1<=≤<=*a*<=≤<=*n*. -  If it's Mahmoud's turn, *a* has to be even, but if it's Ehab's turn, *a* has to be odd. 
If the current player can't choose any number satisfying the conditions, he loses. Can you determine the winner if they both play optimally?","The only line contains an integer *n* (1<=≤<=*n*<=≤<=109), the number at the beginning of the game.","Output ""Mahmoud"" (without quotes) if Mahmoud wins and ""Ehab"" (without quotes) otherwise.","['1\n', '2\n']","['Ehab', 'Mahmoud']","In the first sample, Mahmoud can't choose any integer *a* initially because there is no positive even integer less than or equal to 1 so Ehab wins.

In the second sample, Mahmoud has to choose *a* = 2 and subtract it from *n*. It's Ehab's turn and *n* = 0. There is no positive odd integer less than or equal to 0 so Mahmoud wins.",COMPILATION_ERROR,"using namespace std;

int main()
{
    ll n;
    cin>>n;
    if (n % 2 == 0){
        cout<<""Mahmoud"";
    }
    else{
        cout<<""Ehab"";
    }
    return 0;
}","def determine_winner(n):

    if n % 2 == 0:
        return ""Mahmoud""
    else:
        return ""Ehab""

n = int(input().strip())

winner = determine_winner(n)

print(winner)"
252,A,Little Xor,PROGRAMMING,"['brute force', 'implementation']","Little Petya likes arrays that consist of non-negative integers a lot. Recently his mom has presented him one such array consisting of *n* elements. Petya immediately decided to find there a segment of consecutive elements, such that the *xor* of all numbers from this segment was maximal possible. Help him with that.

The *xor* operation is the bitwise exclusive ""OR"", that is denoted as ""xor"" in Pascal and ""^"" in C/C++/Java.",The first line contains integer *n* (1<=≤<=*n*<=≤<=100) — the number of elements in the array. The second line contains the space-separated integers from the array. All numbers are non-negative integers strictly less than 230.,Print a single integer — the required maximal *xor* of a segment of consecutive elements.,"['5\n1 2 1 1 2\n', '3\n1 2 7\n', '4\n4 2 4 8\n']","['3\n', '7\n', '14\n']","In the first sample one of the optimal segments is the segment that consists of the first and the second array elements, if we consider the array elements indexed starting from one.

The second sample contains only one optimal segment, which contains exactly one array element (element with index three).",WRONG_ANSWER,"import sys

def func_1(num, pos):
    pos[0] = int(input())
    num = list(map(int, input().split()))

def func_3(num):
    max_xor = num[0]
    xor = num[0]
    l = 0
    for r in range(1,len(num)):
        xor = xor ^ num[r]
        while (xor < num[r]):
            xor ^= num[l]
            l +=1
        if xor > max_xor:
            max_xor = xor
    return max_xor

pos = int(input())
num = list(map(int, input().split()))
print(func_3(num))","def max_xor_segment(arr):
    n = len(arr)
    max_xor = 0

    for i in range(n):
        current_xor = 0
        for j in range(i, n):
            current_xor ^= arr[j]
            max_xor = max(max_xor, current_xor)
    
    return max_xor

if __name__ == ""__main__"":
    n = int(input())
    arr = list(map(int, input().split()))

    print(max_xor_segment(arr))"
0,none,none,none,['none'],"Gerald got a very curious hexagon for his birthday. The boy found out that all the angles of the hexagon are equal to . Then he measured the length of its sides, and found that each of them is equal to an integer number of centimeters. There the properties of the hexagon ended and Gerald decided to draw on it.

He painted a few lines, parallel to the sides of the hexagon. The lines split the hexagon into regular triangles with sides of 1 centimeter. Now Gerald wonders how many triangles he has got. But there were so many of them that Gerald lost the track of his counting. Help the boy count the triangles.","The first and the single line of the input contains 6 space-separated integers *a*1,<=*a*2,<=*a*3,<=*a*4,<=*a*5 and *a*6 (1<=≤<=*a**i*<=≤<=1000) — the lengths of the sides of the hexagons in centimeters in the clockwise order. It is guaranteed that the hexagon with the indicated properties and the exactly such sides exists.","Print a single integer — the number of triangles with the sides of one 1 centimeter, into which the hexagon is split.","['1 1 1 1 1 1\n', '1 2 1 2 1 2\n']","['6\n', '13\n']","This is what Gerald's hexagon looks like in the first sample:

<img class=""tex-graphics"" src=""https://espresso.codeforces.com/84d193e27b02c38eb1eadc536602a2ec0b9f9519.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

And that's what it looks like in the second sample:

<img class=""tex-graphics"" src=""https://espresso.codeforces.com/e29076a96da8ca864654cc6195654d9bf07d31ce.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>",WRONG_ANSWER,"def triang(n):
    a = 0
    i = 1
    while i <= n:
        a += (2 * i - 1)
        i += 1
    return a

a = input().split()
for i in range(len(a)):
    a[i] = int(a[i])
c = a[0] + a[1] + a[5]
print(c)
print(triang(c) - triang(a[1]) - triang(a[3]) - triang(a[5]))","def count_triangles(sides):

    a1, a2, a3, a4, a5, a6 = sides

    min_side = min(sides)

    total_length = sum(sides)

    triangles = (total_length - min_side) * min_side + (min_side * (min_side - 1)) // 2
    
    return triangles

input_sides = list(map(int, input().strip().split()))

print(count_triangles(input_sides))"
235,A,LCM Challenge,PROGRAMMING,['number theory'],"Some days ago, I learned the concept of LCM (least common multiple). I've played with it for several times and I want to make a big number with it.

But I also don't want to use many numbers, so I'll choose three positive integers (they don't have to be distinct) which are not greater than *n*. Can you help me to find the maximum possible least common multiple of these three integers?",The first line contains an integer *n* (1<=≤<=*n*<=≤<=106) — the *n* mentioned in the statement.,Print a single integer — the maximum possible LCM of three not necessarily distinct positive integers that are not greater than *n*.,"['9\n', '7\n']","['504\n', '210\n']","The least common multiple of some positive integers is the least positive integer which is multiple for each of them.

The result may become very large, 32-bit integer won't be enough. So using 64-bit integers is recommended.

For the last example, we can chose numbers 7, 6, 5 and the LCM of them is 7·6·5 = 210. It is the maximum value we can get.",WRONG_ANSWER,"n=int(input())
def gcd(a,b):
    maxi=max(a,b)
    mini=min(a,b)
    if(mini==0):
        return maxi
    while(maxi%mini):
        tmp=maxi
        maxi=mini
        mini=tmp%mini
    return mini
tmp=n
gc=n
cnt=1
    
for i in range(n-1,0,-1):
    tp=gcd(n,i)
    if(cnt==3):
        break
    if(tp==1):
        
        tmp*=i
        cnt+=1
print(tmp)","import math
from functools import reduce

def lcm(a, b):
    return abs(a * b) // math.gcd(a, b)

def max_lcm(n):

    if n < 3:
        return n

    candidates = [n, n-1, n-2]
    max_value = 0

    for i in range(n, n - 3, -1):
        for j in range(n, n - 3, -1):
            for k in range(n, n - 3, -1):
                current_lcm = lcm(lcm(i, j), k)
                max_value = max(max_value, current_lcm)

    return max_value

n = int(input().strip())
print(max_lcm(n))"
817,A,Treasure Hunt,PROGRAMMING,"['implementation', 'math', 'number theory']","Captain Bill the Hummingbird and his crew recieved an interesting challenge offer. Some stranger gave them a map, potion of teleportation and said that only this potion might help them to reach the treasure. 

Bottle with potion has two values *x* and *y* written on it. These values define four moves which can be performed using the potion:
 -   -   -   -   
Map shows that the position of Captain Bill the Hummingbird is (*x*1,<=*y*1) and the position of the treasure is (*x*2,<=*y*2).

You task is to tell Captain Bill the Hummingbird whether he should accept this challenge or decline. If it is possible for Captain to reach the treasure using the potion then output ""YES"", otherwise ""NO"" (without quotes).

The potion can be used infinite amount of times.","The first line contains four integer numbers *x*1,<=*y*1,<=*x*2,<=*y*2 (<=-<=105<=≤<=*x*1,<=*y*1,<=*x*2,<=*y*2<=≤<=105) — positions of Captain Bill the Hummingbird and treasure respectively.

The second line contains two integer numbers *x*,<=*y* (1<=≤<=*x*,<=*y*<=≤<=105) — values on the potion bottle.","Print ""YES"" if it is possible for Captain to reach the treasure using the potion, otherwise print ""NO"" (without quotes).","['0 0 0 6\n2 3\n', '1 1 3 6\n1 5\n']","['YES\n', 'NO\n']","In the first example there exists such sequence of moves:
 1.  <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/7c939890fb4ed35688177327dac981bfa9216c00.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> — the first type of move 1.  <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/afbfa42fbac4e0641e7466e3aac74cbbb08ed597.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> — the third type of move",OK,"import sys
input=sys.stdin.readline
from collections import defaultdict as dc
from collections import Counter
from bisect import bisect_right, bisect_left,bisect
import math
from operator import itemgetter
from heapq import heapify, heappop, heappush
x1,y1,x2,y2=map(int,input().split())
x,y=map(int,input().split())
if abs(x2-x1)%x==0 and abs(y2-y1)%y==0 and (abs(x2-x1)//x)%2==(abs(y2-y1)//y)%2:
    print(""YES"")
else:
    print(""NO"")","def can_reach_treasure(position, potion):
    x1, y1, x2, y2 = position
    x, y = potion

    can_reach_x = (x2 - x1) % x == 0
    can_reach_y = (y2 - y1) % y == 0

    if can_reach_x and can_reach_y:
        return ""YES""
    else:
        return ""NO""

position = list(map(int, input().strip().split()))
potion = list(map(int, input().strip().split()))

print(can_reach_treasure(position, potion))"
276,B,Little Girl and Game,PROGRAMMING,"['games', 'greedy']","The Little Girl loves problems on games very much. Here's one of them.

Two players have got a string *s*, consisting of lowercase English letters. They play a game that is described by the following rules:
 -  The players move in turns; In one move the player can remove an arbitrary letter from string *s*. -  If the player before his turn can reorder the letters in string *s* so as to get a palindrome, this player wins. A palindrome is a string that reads the same both ways (from left to right, and vice versa). For example, string ""abba"" is a palindrome and string ""abc"" isn't. 
Determine which player will win, provided that both sides play optimally well — the one who moves first or the one who moves second.","The input contains a single line, containing string *s* (1<=≤<=|*s*|<=<=≤<=<=103). String *s* consists of lowercase English letters.","In a single line print word ""First"" if the first player wins (provided that both players play optimally well). Otherwise, print word ""Second"". Print the words without the quotes.","['aba\n', 'abca\n']","['First\n', 'Second\n']",none,OK,"from sys import stdin, stdout
input, print = stdin.readline, stdout.write

def str_input():
    s = input()
    return s[:len(s)-1]

def main():
    s = str_input()
    cnt = [0 for _ in range(26)]
    for ch in s:
        cnt[ord(ch)-ord('a')] += 1
    odd = 0
    for i in range(26):
        odd += cnt[i] & 1
    if odd == 0:
        print(""First\n"")
    elif len(s) & 1:
        print(""First\n"")
    else:
        print(""Second\n"")

if __name__ == ""__main__"":
    main()","def can_form_palindrome(s):

    from collections import Counter
    count = Counter(s)

    odd_count = sum(1 for c in count if count[c] % 2 != 0)

    return odd_count <= 1

def game_winner(s):

    if can_form_palindrome(s):
        return ""First""
    else:
        return ""Second""

if __name__ == ""__main__"":
    import sys
    input_data = sys.stdin.read().strip().split('\n')
    results = [game_winner(s) for s in input_data]
    print(""\n"".join(results))"
380,C,Sereja and Brackets,PROGRAMMING,"['data structures', 'schedules']","Sereja has a bracket sequence *s*1,<=*s*2,<=...,<=*s**n*, or, in other words, a string *s* of length *n*, consisting of characters ""("" and "")"".

Sereja needs to answer *m* queries, each of them is described by two integers *l**i*,<=*r**i* (1<=≤<=*l**i*<=≤<=*r**i*<=≤<=*n*). The answer to the *i*-th query is the length of the maximum correct bracket subsequence of sequence *s**l**i*,<=*s**l**i*<=+<=1,<=...,<=*s**r**i*. Help Sereja answer all queries.

You can find the definitions for a subsequence and a correct bracket sequence in the notes.","The first line contains a sequence of characters *s*1,<=*s*2,<=...,<=*s**n* (1<=≤<=*n*<=≤<=106) without any spaces. Each character is either a ""("" or a "")"". The second line contains integer *m* (1<=≤<=*m*<=≤<=105) — the number of queries. Each of the next *m* lines contains a pair of integers. The *i*-th line contains integers *l**i*,<=*r**i* (1<=≤<=*l**i*<=≤<=*r**i*<=≤<=*n*) — the description of the *i*-th query.",Print the answer to each question on a single line. Print the answers in the order they go in the input.,['())(())(())(\n7\n1 1\n2 3\n1 2\n1 12\n8 12\n5 11\n2 10\n'],['0\n0\n2\n10\n4\n6\n6\n'],"A subsequence of length |*x*| of string *s* = *s*<sub class=""lower-index"">1</sub>*s*<sub class=""lower-index"">2</sub>... *s*<sub class=""lower-index"">|*s*|</sub> (where |*s*| is the length of string *s*) is string *x* = *s*<sub class=""lower-index"">*k*<sub class=""lower-index"">1</sub></sub>*s*<sub class=""lower-index"">*k*<sub class=""lower-index"">2</sub></sub>... *s*<sub class=""lower-index"">*k*<sub class=""lower-index"">|*x*|</sub></sub> (1 ≤ *k*<sub class=""lower-index"">1</sub> &lt; *k*<sub class=""lower-index"">2</sub> &lt; ... &lt; *k*<sub class=""lower-index"">|*x*|</sub> ≤ |*s*|).

A correct bracket sequence is a bracket sequence that can be transformed into a correct aryphmetic expression by inserting characters ""1"" and ""+"" between the characters of the string. For example, bracket sequences ""()()"", ""(())"" are correct (the resulting expressions ""(1)+(1)"", ""((1+1)+1)""), and "")("" and ""("" are not.

For the third query required sequence will be «()».

For the fourth query required sequence will be «()(())(())».",TIME_LIMIT_EXCEEDED,"import os
import sys
from io import BytesIO, IOBase

BUFSIZE = 8192

class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = ""x"" in file.mode or ""r"" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b""\n"") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)

class IOWrapper(IOBase):

    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode(""ascii""))
        self.read = lambda: self.buffer.read().decode(""ascii"")
        self.readline = lambda: self.buffer.readline().decode(""ascii"")

sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip(""\r\n"")

def func_add(a, b):
    t = min(a[1], b[2])
    return [a[0]+b[0]+t, a[1]+b[1]-t, a[2]+b[2]-t]
    
class SegmentTree:
    def __init__(self, data, default=0, func=func_add):
        """"""initialize the segment tree with data""""""
        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        for i in reversed(range(_size)):
            self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, idx):
        return self.data[idx + self._size]

    def __setitem__(self, idx, value):
        idx += self._size
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        """"""func of data[start, stop)""""""
        start += self._size
        stop += self._size

        res_left = res_right = self._default
        while start < stop:
            if start & 1:
                res_left = self._func(res_left, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res_right = self._func(self.data[stop], res_right)
            start >>= 1
            stop >>= 1

        return self._func(res_left, res_right)

    def __repr__(self):
        return ""SegmentTree({0})"".format(self.data)
    
    
def solve(s, q, m):
    n = len(s)
    data = list()
    for c in s:
        if c == '(':
            data.append([0, 1, 0])
        else:
            data.append([0, 0, 1])
    sgt = SegmentTree(data, default=[0, 0, 0])
    for l, r in q:
        print(sgt.query(l-1, r)[0] * 2)
    return

s = input()
m = int(input())
q = list()
for i in range(m):
    q.append(list(map(int, input().split(' '))))

solve(s, q, m)","def max_correct_bracket_length(s, queries):

    results = []

    for l, r in queries:

        l -= 1
        r -= 1

        left_count = 0
        right_count = 0

        for i in range(l, r + 1):
            if s[i] == '(':
                left_count += 1
            elif s[i] == ')':
                right_count += 1

        max_length = 2 * min(left_count, right_count)
        results.append(max_length)
    
    return results

s = input().strip()
m = int(input().strip())
queries = [tuple(map(int, input().strip().split())) for _ in range(m)]

results = max_correct_bracket_length(s, queries)

print('\n'.join(map(str, results)))"
237,C,Primes on Interval,PROGRAMMING,"['binary search', 'number theory', 'two pointers']","You've decided to carry out a survey in the theory of prime numbers. Let us remind you that a prime number is a positive integer that has exactly two distinct positive integer divisors.

Consider positive integers *a*, *a*<=+<=1, ..., *b* (*a*<=≤<=*b*). You want to find the minimum integer *l* (1<=≤<=*l*<=≤<=*b*<=-<=*a*<=+<=1) such that for any integer *x* (*a*<=≤<=*x*<=≤<=*b*<=-<=*l*<=+<=1) among *l* integers *x*, *x*<=+<=1, ..., *x*<=+<=*l*<=-<=1 there are at least *k* prime numbers. 

Find and print the required minimum *l*. If no value *l* meets the described limitations, print -1.","A single line contains three space-separated integers *a*,<=*b*,<=*k* (1<=≤<=*a*,<=*b*,<=*k*<=≤<=106; *a*<=≤<=*b*).","In a single line print a single integer — the required minimum *l*. If there's no solution, print -1.","['2 4 2\n', '6 13 1\n', '1 4 3\n']","['3\n', '4\n', '-1\n']",none,WRONG_ANSWER,"def main():
    l=0
    list=input().split(' ')
    for i in range(int(list[0]),int(list[1])+1):
        c=0
        for j in range(1,i+1):
            if i%j==0:
                c+=1
        if c==2:
            l+=1
    if l>=int(list[2]):
        print(int(list[1])-int(list[0])+1)
    else:
        print(-1)
main()","def is_prime(n):
    """"""Check if a number is prime.""""""
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def minimum_l(a, b, k):
    """"""Find the minimum l such that there are at least k primes in the range [a, l].""""""

    prime_count = sum(1 for x in range(a, b + 1) if is_prime(x))

    if prime_count < k:
        return -1

    for l in range(a, b + 1):
        if sum(1 for x in range(a, l + 1) if is_prime(x)) >= k:
            return l
    
    return -1

inputs = [
    ""2 4 2"",
    ""6 13 1"",
    ""1 4 3""
]

results = []
for input_case in inputs:
    a, b, k = map(int, input_case.split())
    result = minimum_l(a, b, k)
    results.append(result)

for res in results:
    print(res)"
548,B,Mike and Fun,PROGRAMMING,"['brute force', 'dp', 'greedy', 'implementation']","Mike and some bears are playing a game just for fun. Mike is the judge. All bears except Mike are standing in an *n*<=×<=*m* grid, there's exactly one bear in each cell. We denote the bear standing in column number *j* of row number *i* by (*i*,<=*j*). Mike's hands are on his ears (since he's the judge) and each bear standing in the grid has hands either on his mouth or his eyes.

They play for *q* rounds. In each round, Mike chooses a bear (*i*,<=*j*) and tells him to change his state i. e. if his hands are on his mouth, then he'll put his hands on his eyes or he'll put his hands on his mouth otherwise. After that, Mike wants to know the score of the bears.

Score of the bears is the maximum over all rows of number of consecutive bears with hands on their eyes in that row.

Since bears are lazy, Mike asked you for help. For each round, tell him the score of these bears after changing the state of a bear selected in that round.","The first line of input contains three integers *n*, *m* and *q* (1<=≤<=*n*,<=*m*<=≤<=500 and 1<=≤<=*q*<=≤<=5000).

The next *n* lines contain the grid description. There are *m* integers separated by spaces in each line. Each of these numbers is either 0 (for mouth) or 1 (for eyes).

The next *q* lines contain the information about the rounds. Each of them contains two integers *i* and *j* (1<=≤<=*i*<=≤<=*n* and 1<=≤<=*j*<=≤<=*m*), the row number and the column number of the bear changing his state.","After each round, print the current score of the bears.",['5 4 5\n0 1 1 0\n1 0 0 1\n0 1 1 0\n1 0 0 1\n0 0 0 0\n1 1\n1 4\n1 1\n4 2\n4 3\n'],['3\n4\n3\n3\n4\n'],none,WRONG_ANSWER,"import re

def maxString(a,n):
	y = 0
	c = 0
	for i in range(n):
		s2 = ''.join(a[i])
		if '1' not in s2:
			r = 0
		else:
			r = len(max(re.findall(""1+"",s2),key=len))
		if(r > y):
			y = r
			c = i
	return [y,c]

def flip(x):
	if(x == '1'):
		return '0'
	else:
		return '1'

n,m,q = map(int,input().split())

a = []
x = []

for i in range(n):
	x = list(input().split())
	a.append(x)

y = maxString(a,n)

for i in range(q):
	p,q = map(int,input().split())
	d = a[p-1][q-1]
	a[p-1][q-1] = flip(a[p-1][q-1])
	if(p-1 == y[1]):
		if(d == '0'):
			y[0] += 1
		else:
			y = maxString(a,n)
	print(y[0])","def main():
    import sys
    input = sys.stdin.read
    data = input().splitlines()

    n, m, q = map(int, data[0].split())

    grid = []
    for i in range(1, n + 1):
        grid.append(list(map(int, data[i].split())))

    def calculate_max_consecutive_eyes():
        max_score = 0
        for row in grid:
            count = 0
            for bear in row:
                if bear == 1:
                    count += 1
                    max_score = max(max_score, count)
                else:
                    count = 0
        return max_score

    current_score = calculate_max_consecutive_eyes()
    
    output = []

    for i in range(q):
        x, y = map(int, data[n + 1 + i].split())
        x -= 1
        y -= 1

        grid[x][y] = 1 - grid[x][y]

        current_score = calculate_max_consecutive_eyes()
        output.append(str(current_score))

    print(""\n"".join(output))

if __name__ == ""__main__"":
    main()"
833,A,The Meaningless Game,PROGRAMMING,"['math', 'number theory']","Slastyona and her loyal dog Pushok are playing a meaningless game that is indeed very interesting.

The game consists of multiple rounds. Its rules are very simple: in each round, a natural number *k* is chosen. Then, the one who says (or barks) it faster than the other wins the round. After that, the winner's score is multiplied by *k*2, and the loser's score is multiplied by *k*. In the beginning of the game, both Slastyona and Pushok have scores equal to one.

Unfortunately, Slastyona had lost her notepad where the history of all *n* games was recorded. She managed to recall the final results for each games, though, but all of her memories of them are vague. Help Slastyona verify their correctness, or, to put it another way, for each given pair of scores determine whether it was possible for a game to finish with such result or not.","In the first string, the number of games *n* (1<=≤<=*n*<=≤<=350000) is given.

Each game is represented by a pair of scores *a*, *b* (1<=≤<=*a*,<=*b*<=≤<=109) – the results of Slastyona and Pushok, correspondingly.","For each pair of scores, answer ""Yes"" if it's possible for a game to finish with given score, and ""No"" otherwise.

You can output each letter in arbitrary case (upper or lower).",['6\n2 4\n75 45\n8 8\n16 16\n247 994\n1000000000 1000000\n'],['Yes\nYes\nYes\nNo\nNo\nYes\n'],"First game might have been consisted of one round, in which the number 2 would have been chosen and Pushok would have won.

The second game needs exactly two rounds to finish with such result: in the first one, Slastyona would have said the number 5, and in the second one, Pushok would have barked the number 3.",TIME_LIMIT_EXCEEDED,"def GCD(a,b):
    if a<b:
        a,b=b,a 
    
    if b==0:
        return a 
    return GCD(b,a%b)

def isCube(x):
    i=1 
    j=5000
    while i<=j:
        m=(i+j)//2 

        t=m*m*m
        if t==x:
            return ""Yes""
        if t>x:
            j=m-1 
        else:
            i=m+1 
    return ""No""

def ss(a,b):
    l=GCD(a,b)
    r=(a//l)*(b//l)
    x=l//r 
    return isCube(x)
    

for _ in range(int(input())):
    a,b=map(int, input().split())
    
    print(ss(a,b))","def can_finish_games(game_results):
    results = []
    for a, b in game_results:

        while a > 1 and b > 1:
            if a > b:
                a //= 2
            else:
                b //= 2

        if (a == 1 and (b & (b - 1)) == 0) or (b == 1 and (a & (a - 1)) == 0):
            results.append(""Yes"")
        else:
            results.append(""No"")
    return results

import sys
input = sys.stdin.read

data = input().splitlines()
n = int(data[0])
games = [tuple(map(int, line.split())) for line in data[1:n + 1]]

results = can_finish_games(games)

print(""\n"".join(results))"
363,B,Fence,PROGRAMMING,"['brute force', 'dp']","There is a fence in front of Polycarpus's home. The fence consists of *n* planks of the same width which go one after another from left to right. The height of the *i*-th plank is *h**i* meters, distinct planks can have distinct heights.

Polycarpus has bought a posh piano and is thinking about how to get it into the house. In order to carry out his plan, he needs to take exactly *k* consecutive planks from the fence. Higher planks are harder to tear off the fence, so Polycarpus wants to find such *k* consecutive planks that the sum of their heights is minimal possible.

Write the program that finds the indexes of *k* consecutive planks with minimal total height. Pay attention, the fence is not around Polycarpus's home, it is in front of home (in other words, the fence isn't cyclic).","The first line of the input contains integers *n* and *k* (1<=≤<=*n*<=≤<=1.5·105,<=1<=≤<=*k*<=≤<=*n*) — the number of planks in the fence and the width of the hole for the piano. The second line contains the sequence of integers *h*1,<=*h*2,<=...,<=*h**n* (1<=≤<=*h**i*<=≤<=100), where *h**i* is the height of the *i*-th plank of the fence.","Print such integer *j* that the sum of the heights of planks *j*, *j*<=+<=1, ..., *j*<=+<=*k*<=-<=1 is the minimum possible. If there are multiple such *j*'s, print any of them.",['7 3\n1 2 6 1 1 7 1\n'],['3\n'],"In the sample, your task is to find three consecutive planks with the minimum sum of heights. In the given case three planks with indexes 3, 4 and 5 have the required attribute, their total height is 8.",OK,"def fence(data, k):
    prev=sum(data[:k])
    index=1
    total=prev
    for i in range(k,len(data)):
        total-=data[i-k]
        total+=data[i]
        if total<prev:
            prev=total
            index=i-k+2
    return index
def main():
    n, k = list(map(int, input().split()))
    data = list(map(int, input().split()))
    print(fence(data,k))
if __name__ == ""__main__"":
    main()","n, k = map(int, input().split())
heights = list(map(int, input().split()))

min_sum = float('inf')
min_index = 0

current_sum = sum(heights[:k])

if current_sum < min_sum:
    min_sum = current_sum
    min_index = 0

for i in range(1, n - k + 1):

    current_sum = current_sum - heights[i - 1] + heights[i + k - 1]

    if current_sum < min_sum:
        min_sum = current_sum
        min_index = i

print(min_index + 1)"
121,A,Lucky Sum,PROGRAMMING,['implementation'],"Petya loves lucky numbers. Everybody knows that lucky numbers are positive integers whose decimal representation contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.

Let *next*(*x*) be the minimum lucky number which is larger than or equals *x*. Petya is interested what is the value of the expression *next*(*l*)<=+<=*next*(*l*<=+<=1)<=+<=...<=+<=*next*(*r*<=-<=1)<=+<=*next*(*r*). Help him solve this problem.",The single line contains two integers *l* and *r* (1<=≤<=*l*<=≤<=*r*<=≤<=109) — the left and right interval limits.,"In the single line print the only number — the sum *next*(*l*)<=+<=*next*(*l*<=+<=1)<=+<=...<=+<=*next*(*r*<=-<=1)<=+<=*next*(*r*).

Please do not use the %lld specificator to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specificator.","['2 7\n', '7 7\n']","['33\n', '7\n']","In the first sample: *next*(2) + *next*(3) + *next*(4) + *next*(5) + *next*(6) + *next*(7) = 4 + 4 + 4 + 7 + 7 + 7 = 33

In the second sample: *next*(7) = 7",OK,"import sys
import math
import bisect
import heapq
from bisect import bisect_right
from sys import stdin, stdout

def get_ints_in_variables(): return map(
    int, sys.stdin.readline().strip().split())

def get_int(): return int(sys.stdin.readline())

def get_ints_in_list(): return list(
    map(int, sys.stdin.readline().strip().split()))
def get_list_of_list(n): return [list(
    map(int, sys.stdin.readline().strip().split())) for _ in range(n)]

def get_string(): return sys.stdin.readline().strip()

def myceil(x, y): return (x + y - 1) // y

def luckyNumbers(n, r, lucky_nums):
    lucky_nums.append(n)
    if n > r*10:
        return
    luckyNumbers((10*n)+4, r, lucky_nums)
    luckyNumbers((10*n)+7, r, lucky_nums)

def helper(n, res):
    ans = 0
    for i in range(1, len(res)):
        ans += (res[i]*(min(res[i], n)-min(res[i-1], n)))
    return ans

def Solution(l, r):

    luckyNums = []
    luckyNumbers(0, r, luckyNums)
    luckyNums = sorted(luckyNums)

    print(helper(r, luckyNums)-helper(l-1, luckyNums))

def main():

    l, r = get_ints_in_variables()
    Solution(l, r)

if __name__ == '__main__':
    main()","def is_lucky(num):

    return all(digit in '47' for digit in str(num))

def next_lucky(x):

    while not is_lucky(x):
        x += 1
    return x

def sum_of_lucky_numbers(l, r):
    lucky_sum = 0
    for i in range(l, r + 1):
        lucky_sum += next_lucky(i)
    return lucky_sum

l, r = map(int, input().strip().split())

print(sum_of_lucky_numbers(l, r))"
652,B,z-sort,PROGRAMMING,['sortings'],"A student of *z*-school found a kind of sorting called *z*-sort. The array *a* with *n* elements are *z*-sorted if two conditions hold:
 1.  *a**i*<=≥<=*a**i*<=-<=1 for all even *i*, 1.  *a**i*<=≤<=*a**i*<=-<=1 for all odd *i*<=&gt;<=1. 
For example the arrays [1,2,1,2] and [1,1,1,1] are *z*-sorted while the array [1,2,3,4] isn’t *z*-sorted.

Can you make the array *z*-sorted?","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=1000) — the number of elements in the array *a*.

The second line contains *n* integers *a**i* (1<=≤<=*a**i*<=≤<=109) — the elements of the array *a*.","If it's possible to make the array *a* *z*-sorted print *n* space separated integers *a**i* — the elements after *z*-sort. Otherwise print the only word ""Impossible"".","['4\n1 2 2 1\n', '5\n1 3 2 2 5\n']","['1 2 1 2\n', '1 5 2 3 2\n']",none,WRONG_ANSWER,"def check_sorting(array):
    for i in range(len(array)):
        if (i + 1) % 2 == 0:
            if arr[i] < arr[i - 1]:
                return False
        else:
            if arr[i] > arr[i - 1] and i > 1:
                return False
    return True

n = int(input())
arr = list(map(int, input().split()))
flag = False
for _ in range(10000):
    for i in range(len(arr)):
        if (i + 1) % 2 == 0:
            if arr[i] < arr[i - 1]:
                arr[i], arr[i - 1] = arr[i - 1], arr[i]
        else:
            if arr[i] > arr[i - 1] and i > 1:
                arr[i], arr[i - 1] = arr[i - 1], arr[i]
    if check_sorting(arr):
        flag = True
        print(arr)
        break
if not flag:
    print('Impossible')","def z_sort(n, a):

    a.sort()

    z_sorted = [0] * n

    z_sorted[::2] = a[:(n+1)//2]

    z_sorted[1::2] = a[(n+1)//2:]

    for i in range(n):
        if i % 2 == 0 and i + 1 < n and z_sorted[i] > z_sorted[i + 1]:
            return ""Impossible""
        if i % 2 == 1 and i + 1 < n and z_sorted[i] < z_sorted[i + 1]:
            return ""Impossible""
    
    return ' '.join(map(str, z_sorted))

n = int(input().strip())
a = list(map(int, input().strip().split()))

result = z_sort(n, a)

print(result)"
916,A,Jamie and Alarm Snooze,PROGRAMMING,"['brute force', 'implementation', 'math']","Jamie loves sleeping. One day, he decides that he needs to wake up at exactly *hh*:<=*mm*. However, he hates waking up, so he wants to make waking up less painful by setting the alarm at a lucky time. He will then press the snooze button every *x* minutes until *hh*:<=*mm* is reached, and only then he will wake up. He wants to know what is the smallest number of times he needs to press the snooze button.

A time is considered lucky if it contains a digit '7'. For example, 13:<=07 and 17:<=27 are lucky, while 00:<=48 and 21:<=34 are not lucky.

Note that it is not necessary that the time set for the alarm and the wake-up time are on the same day. It is guaranteed that there is a lucky time Jamie can set so that he can wake at *hh*:<=*mm*.

Formally, find the smallest possible non-negative integer *y* such that the time representation of the time *x*·*y* minutes before *hh*:<=*mm* contains the digit '7'.

Jamie uses 24-hours clock, so after 23:<=59 comes 00:<=00.","The first line contains a single integer *x* (1<=≤<=*x*<=≤<=60).

The second line contains two two-digit integers, *hh* and *mm* (00<=≤<=*hh*<=≤<=23,<=00<=≤<=*mm*<=≤<=59).",Print the minimum number of times he needs to press the button.,"['3\n11 23\n', '5\n01 07\n']","['2\n', '0\n']","In the first sample, Jamie needs to wake up at 11:23. So, he can set his alarm at 11:17. He would press the snooze button when the alarm rings at 11:17 and at 11:20.

In the second sample, Jamie can set his alarm at exactly at 01:07 which is lucky.",COMPILATION_ERROR,"using namespace std;

void solve(){
	int x, h, m; cin >> x >> h >> m;
	int ans = 0;
	while (m % 10 != 7 && (m/10)%10 != 7) {
		m = (m-x)%60;
		ans++;
	}
	cout << ans << endl;

}

int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);

	//int t; cin >> t;
	//while(t--){
		solve();
	//}
}","def is_lucky(hh, mm):
    """"""Check if the time contains the digit '7'.""""""
    return '7' in f""{hh:02d}:{mm:02d}""

def find_snooze_count(x, hh, mm):
    """"""Find the minimum number of snooze presses needed to find a lucky time.""""""

    wake_up_time = hh * 60 + mm

    snooze_count = 0
    while True:

        current_time = wake_up_time - snooze_count * x

        if current_time < 0:
            current_time += 1440

        current_hh = current_time // 60
        current_mm = current_time % 60

        if is_lucky(current_hh, current_mm):
            return snooze_count

        snooze_count += 1

x = int(input().strip())
hh, mm = map(int, input().strip().split())

result = find_snooze_count(x, hh, mm)
print(result)"
204,A,Little Elephant and Interval,PROGRAMMING,"['binary search', 'combinatorics', 'dp']","The Little Elephant very much loves sums on intervals.

This time he has a pair of integers *l* and *r* (*l*<=≤<=*r*). The Little Elephant has to find the number of such integers *x* (*l*<=≤<=*x*<=≤<=*r*), that the first digit of integer *x* equals the last one (in decimal notation). For example, such numbers as 101, 477474 or 9 will be included in the answer and 47, 253 or 1020 will not.

Help him and count the number of described numbers *x* for a given pair *l* and *r*.","The single line contains a pair of integers *l* and *r* (1<=≤<=*l*<=≤<=*r*<=≤<=1018) — the boundaries of the interval.

Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use cin, cout streams or the %I64d specifier.",On a single line print a single integer — the answer to the problem.,"['2 47\n', '47 1024\n']","['12\n', '98\n']","In the first sample the answer includes integers 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44.",WRONG_ANSWER,"p = [0, 1, 1]
p.extend([10 ** x for x in range(1,16)])

def get_count(num):
	if len(num) == 1:
		return int(num)
	elif len(num) == 2:
		return int(num[0]) + 8 if num[0] > num[1] else int(num[0]) + 9
	else:
		result = 18
		for i in range(3, len(num)):
			result += p[i] * 9
		firstDig = int(num[0])
		lastDig = int(num[-1])
		result += (firstDig - 1) * (10 ** (len(num) - 2) )
		if firstDig <= lastDig:
			result += int(num[1:-1]) + 1

		return result

a, b = input().split()
ca = (get_count(a))
cb = (get_count(b))
print(cb - ca + 1 if a[0] == a[-1] else cb - ca  )","def count_matching_first_last_digit(l, r):
    count = 0
    for x in range(l, r + 1):
        str_x = str(x)
        if str_x[0] == str_x[-1]:
            count += 1
    return count

input_data = input().strip()
l, r = map(int, input_data.split())

result = count_matching_first_last_digit(l, r)

print(result)"
999,E,Reachability from the Capital,PROGRAMMING,"['dfs and similar', 'graphs', 'greedy']","There are $n$ cities and $m$ roads in Berland. Each road connects a pair of cities. The roads in Berland are one-way.

What is the minimum number of new roads that need to be built to make all the cities reachable from the capital?

New roads will also be one-way.","The first line of input consists of three integers $n$, $m$ and $s$ ($1 \le n \le 5000, 0 \le m \le 5000, 1 \le s \le n$) — the number of cities, the number of roads and the index of the capital. Cities are indexed from $1$ to $n$.

The following $m$ lines contain roads: road $i$ is given as a pair of cities $u_i$, $v_i$ ($1 \le u_i, v_i \le n$, $u_i \ne v_i$). For each pair of cities $(u, v)$, there can be at most one road from $u$ to $v$. Roads in opposite directions between a pair of cities are allowed (i.e. from $u$ to $v$ and from $v$ to $u$).","Print one integer — the minimum number of extra roads needed to make all the cities reachable from city $s$. If all the cities are already reachable from $s$, print 0.","['9 9 1\n1 2\n1 3\n2 3\n1 5\n5 6\n6 1\n1 8\n9 8\n7 1\n', '5 4 5\n1 2\n2 3\n3 4\n4 1\n']","['3\n', '1\n']","The first example is illustrated by the following:

For example, you can add roads ($6, 4$), ($7, 9$), ($1, 7$) to make all the cities reachable from $s = 1$.

The second example is illustrated by the following:

In this example, you can add any one of the roads ($5, 1$), ($5, 2$), ($5, 3$), ($5, 4$) to make all the cities reachable from $s = 5$.",COMPILATION_ERROR,"using namespace std;

typedef vector<int> vi;
typedef vector<vi> vii;

void dfs(int i, vi& order, vi& vis, vii& g)
{
    if (vis[i])
        return;
    vis[i] = 1;
    for (int ot : g[i])
        dfs(ot, order, vis, g);
    order.push_back(i);
}

void grp(int i, int gn, vi& vis, vii& g)
{
    if (vis[i])
        return;
    vis[i] = gn;
    for (int ot : g[i])
        grp(ot, gn, vis, g);
}

signed main()
{
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    int n, m;
    cin >> n >> m;
    vii g(n);
    vii inv(n);
    vector<pair<int, int>> edg(m);
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        u--;
        v--;
        g[u].push_back(v);
        inv[v].push_back(u);
        edg[i] = { u, v };
    }
    vi order, vis(n);
    for (int i = 0; i < n; i++)
        dfs(i, order, vis, g);
    reverse(order.begin(), order.end());
    int gn = 0;
    vi ngrp(n);
    for (int i = 0; i < n; i++)
        if (!ngrp[order[i]]) {
            grp(order[i], gn, ngrp, inv);
            gn++;
        }
    vi ent(gn);
    for (auto p : edg) {
        ent[ngrp[p.S]]++;
    }
    int cnt = 0;
    for (int i = 0; i < n; i++) {
        if (i == ngrp[0])
            continue;
        if (!ent[i])
            cnt++;
    }
    cout << cnt << endl;
}","def minimum_new_roads(n, m, s, roads):
    from collections import defaultdict, deque

    graph = defaultdict(list)
    for u, v in roads:
        graph[u].append(v)

    def bfs(start):
        reachable = set()
        queue = deque([start])
        while queue:
            city = queue.popleft()
            if city not in reachable:
                reachable.add(city)
                for neighbor in graph[city]:
                    if neighbor not in reachable:
                        queue.append(neighbor)
        return reachable

    reachable_from_s = bfs(s)

    reverse_graph = defaultdict(list)
    for u, v in roads:
        reverse_graph[v].append(u)

    def bfs_reverse(start):
        reachable = set()
        queue = deque([start])
        while queue:
            city = queue.popleft()
            if city not in reachable:
                reachable.add(city)
                for neighbor in reverse_graph[city]:
                    if neighbor not in reachable:
                        queue.append(neighbor)
        return reachable

    reachable_to_s = bfs_reverse(s)

    non_reachable_cities = n - len(reachable_from_s) + n - len(reachable_to_s)

    min_new_roads = max(len(non_reachable_cities - reachable_to_s), len(reachable_from_s - non_reachable_cities))

    return min_new_roads

def process_input(input_data):
    lines = input_data.strip().split('\n')
    n, m, s = map(int, lines[0].split())
    roads = [tuple(map(int, line.split())) for line in lines[1:m + 1]]
    return n, m, s, roads

demo_inputs = [
    '9 9 1\n1 2\n1 3\n2 3\n1 5\n5 6\n6 1\n1 8\n9 8\n7 1\n',
    '5 4 5\n1 2\n2 3\n3 4\n4 1\n'
]

for demo_input in demo_inputs:
    n, m, s, roads = process_input(demo_input)
    print(minimum_new_roads(n, m, s, roads))"
25,B,Phone numbers,PROGRAMMING,['implementation'],"Phone number in Berland is a sequence of *n* digits. Often, to make it easier to memorize the number, it is divided into groups of two or three digits. For example, the phone number 1198733 is easier to remember as 11-987-33. Your task is to find for a given phone number any of its divisions into groups of two or three digits.",The first line contains integer *n* (2<=≤<=*n*<=≤<=100) — amount of digits in the phone number. The second line contains *n* digits — the phone number to divide into groups.,"Output any of divisions of the given phone number into groups of two or three digits. Separate groups by single character -. If the answer is not unique, output any.","['6\n549871\n', '7\n1198733\n']","['54-98-71', '11-987-33\n']",none,WRONG_ANSWER,"def solve():
    n=int(input())
    s=input()
    if n==2:
        print(s[0]+""-""+s[1])
        return 
    else:
        print(s[0]+""-""+s[1]+""-""+s[2:])
        return 

solve();","def divide_phone_number(n, phone_number):
    result = []
    i = 0
    
    while i < n:

        if n - i > 4 and (n - i) % 2 == 1:
            result.append(phone_number[i:i+3])
            i += 3
        else:
            result.append(phone_number[i:i+2])
            i += 2

    return '-'.join(result)

input_data = input().splitlines()
n = int(input_data[0])
phone_number = input_data[1]

output = divide_phone_number(n, phone_number)

print(output)"
847,G,University Classes,PROGRAMMING,['implementation'],"There are *n* student groups at the university. During the study day, each group can take no more than 7 classes. Seven time slots numbered from 1 to 7 are allocated for the classes.

The schedule on Monday is known for each group, i. e. time slots when group will have classes are known.

Your task is to determine the minimum number of rooms needed to hold classes for all groups on Monday. Note that one room can hold at most one group class in a single time slot.","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=1000) — the number of groups. 

Each of the following *n* lines contains a sequence consisting of 7 zeroes and ones — the schedule of classes on Monday for a group. If the symbol in a position equals to 1 then the group has class in the corresponding time slot. In the other case, the group has no class in the corresponding time slot.",Print minimum number of rooms needed to hold all groups classes on Monday.,"['2\n0101010\n1010101\n', '3\n0101011\n0011001\n0110111\n']","['1\n', '3\n']","In the first example one room is enough. It will be occupied in each of the seven time slot by the first group or by the second group.

In the second example three rooms is enough, because in the seventh time slot all three groups have classes.",OK,"import sys, io, os
import math
import bisect
import heapq
import string
from collections import defaultdict,Counter,deque
input = sys.stdin.readline
 
def I():
    return input()
 
def II():
    return int(input())
 
def MII():
    return map(int, input().split())
 
def LI():
    return list(input().split())
 
def LII():
    return list(map(int, input().split()))
 
def GMI():
    return map(lambda x: int(x) - 1, input().split())
 
def LGMI():
    return list(map(lambda x: int(x) - 1, input().split()))
 
def WRITE(out):
  return print('\n'.join(map(str, out)))
 
def WS(out):
  return print(' '.join(map(str, out)))
 
def WNS(out):
  return print(''.join(map(str, out)))

'''
n%4 == 0 and all_cnts <= n//4
'''

def solve():
  n = II()
  ans = [0] * 7
  for _ in range(n):
    for i, c in enumerate(I().strip()):
      ans[i] += int(c)
  print(max(ans))

solve()","def min_rooms_needed(schedules):

    time_slots = [0] * 7

    for schedule in schedules:
        for i in range(7):
            if schedule[i] == '1':
                time_slots[i] += 1

    return max(time_slots)

n = int(input())
schedules = [input().strip() for _ in range(n)]

print(min_rooms_needed(schedules))"
913,B,Christmas Spruce,PROGRAMMING,"['implementation', 'trees']","Consider a rooted tree. A rooted tree has one special vertex called the root. All edges are directed from the root. Vertex *u* is called a child of vertex *v* and vertex *v* is called a parent of vertex *u* if there exists a directed edge from *v* to *u*. A vertex is called a leaf if it doesn't have children and has a parent.

Let's call a rooted tree a spruce if its every non-leaf vertex has at least 3 leaf children. You are given a rooted tree, check whether it's a spruce.

The definition of a rooted tree can be found [here](https://goo.gl/1dqvzz).","The first line contains one integer *n* — the number of vertices in the tree (3<=≤<=*n*<=≤<=1<=000). Each of the next *n*<=-<=1 lines contains one integer *p**i* (1<=≤<=*i*<=≤<=*n*<=-<=1) — the index of the parent of the *i*<=+<=1-th vertex (1<=≤<=*p**i*<=≤<=*i*).

Vertex 1 is the root. It's guaranteed that the root has at least 2 children.","Print ""Yes"" if the tree is a spruce and ""No"" otherwise.","['4\n1\n1\n1\n', '7\n1\n1\n1\n2\n2\n2\n', '8\n1\n1\n1\n1\n3\n3\n3\n']","['Yes\n', 'No\n', 'Yes\n']","The first example:

<img class=""tex-graphics"" src=""https://espresso.codeforces.com/8dd976913226df83d535dfa66193f5525f8471bc.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

The second example:

<img class=""tex-graphics"" src=""https://espresso.codeforces.com/44dad5804f5290a2e026c9c41a15151562df8682.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

It is not a spruce, because the non-leaf vertex 1 has only 2 leaf children.

The third example:

<img class=""tex-graphics"" src=""https://espresso.codeforces.com/cf84a9e1585707f4ab06eff8eb1120a49b5e1ef7.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>",OK,"n = int(input())
nodes = {1: []}
yes_or_no = ""Yes""
for i in range(2,n+1):
    p = int(input())
    nodes[p].append(i)
    nodes[i] = []
    
for i in nodes:
    no_of_leaves = 0
    for child in nodes[i]:
        if len(nodes[child]) == 0:
            no_of_leaves += 1
    if 0 < no_of_leaves < 3 or (len(nodes[i]) > 0 and no_of_leaves == 0):
        yes_or_no = ""No""
        break
            
def dfs(tree: dict) -> dict:
    pass
    
print(f""{yes_or_no}"")

'''
Faulty test case result
13
---
1
2
2
2
1
6
6
6
1
10
10
10
'''","def is_spruce(n, parent):

    children_count = [0] * (n + 1)

    is_leaf = [True] * (n + 1)

    for i in range(2, n + 1):
        p = parent[i - 2]
        children_count[p] += 1
        is_leaf[p] = False

    for i in range(1, n + 1):
        if not is_leaf[i]:

            leaf_children = 0
            for j in range(2, n + 1):
                if parent[j - 2] == i:
                    if is_leaf[j]:
                        leaf_children += 1

            if leaf_children < 3:
                return ""No""
    
    return ""Yes""

def main():
    import sys
    input = sys.stdin.read
    data = input().strip().split('\n')

    results = []
    index = 0
    while index < len(data):
        n = int(data[index])
        index += 1
        parent = []
        for i in range(n - 1):
            parent.append(int(data[index]))
            index += 1
        results.append(is_spruce(n, parent))

    print(""\n"".join(results))

if __name__ == ""__main__"":
    main()"
124,B,Permutations,PROGRAMMING,"['brute force', 'combinatorics', 'implementation']",You are given *n* *k*-digit integers. You have to rearrange the digits in the integers so that the difference between the largest and the smallest number was minimum. Digits should be rearranged by the same rule in all integers.,"The first line contains integers *n* and *k* — the number and digit capacity of numbers correspondingly (1<=≤<=*n*,<=*k*<=≤<=8). Next *n* lines contain *k*-digit positive integers. Leading zeroes are allowed both in the initial integers and the integers resulting from the rearranging of digits.",Print a single number: the minimally possible difference between the largest and the smallest number after the digits are rearranged in all integers by the same rule.,"['6 4\n5237\n2753\n7523\n5723\n5327\n2537\n', '3 3\n010\n909\n012\n', '7 5\n50808\n36603\n37198\n44911\n29994\n42543\n50156\n']","['2700\n', '3\n', '20522\n']","In the first sample, if we rearrange the digits in numbers as (3,1,4,2), then the 2-nd and the 4-th numbers will equal 5237 and 2537 correspondingly (they will be maximum and minimum for such order of digits).

In the second sample, if we swap the second digits and the first ones, we get integers 100, 99 and 102.",RUNTIME_ERROR,"def permute(vis,ds):
    if len(ds)==k:
        result.append(ds[:])
    else:    
        for i in nums:
            if (not vis[i]):
                ds.append(i)
                vis[i]=True
                permute(vis,ds)
                vis[i]=False
                ds.pop()

n,k = list(map(int,input().split()))
nums = []
result = []
for i in range(k):
    nums.append(i)
val = []
for i in range(n):
    x = input()
    val.append(x)
vis = [False]*n
permute(vis,ds=[])
ans = float('inf')
for i in result:
    m = 0; mi = float('inf')
    for j in val:
        num = j[i[0]]+j[i[1]]+j[i[2]]+j[i[3]]
        m = max(m,int(num))
        mi = min(mi,int(num))
    ans = min(ans,m-mi)

print(ans)","from itertools import permutations

def min_difference(n, k, numbers):

    indices = list(range(k))
    perms = list(permutations(indices))
    
    min_diff = float('inf')

    for perm in perms:
        transformed_numbers = []

        for number in numbers:
            transformed_number = ''.join(number[i] for i in perm)
            transformed_numbers.append(int(transformed_number))

        current_diff = max(transformed_numbers) - min(transformed_numbers)
        min_diff = min(min_diff, current_diff)
    
    return min_diff

for line in input().strip().split('\n'):
    if line.strip():
        params = list(map(int, line.split()))
        n, k = params[0], params[1]
        numbers = [input().strip() for _ in range(n)]
        result = min_difference(n, k, numbers)
        print(result)"
704,B,Ant Man,PROGRAMMING,"['dp', 'graphs', 'greedy']","Scott Lang is at war with Darren Cross. There are *n* chairs in a hall where they are, numbered with 1,<=2,<=...,<=*n* from left to right. The *i*-th chair is located at coordinate *x**i*. Scott is on chair number *s* and Cross is on chair number *e*. Scott can jump to all other chairs (not only neighboring chairs). He wants to start at his position (chair number *s*), visit each chair exactly once and end up on chair number *e* with Cross. 

As we all know, Scott can shrink or grow big (grow big only to his normal size), so at any moment of time he can be either small or large (normal). The thing is, he can only shrink or grow big while being on a chair (not in the air while jumping to another chair). Jumping takes time, but shrinking and growing big takes no time. Jumping from chair number *i* to chair number *j* takes |*x**i*<=-<=*x**j*| seconds. Also, jumping off a chair and landing on a chair takes extra amount of time. 

If Scott wants to jump to a chair on his left, he can only be small, and if he wants to jump to a chair on his right he should be large.

Jumping off the *i*-th chair takes:
 -  *c**i* extra seconds if he's small. -  *d**i* extra seconds otherwise (he's large). 
Also, landing on *i*-th chair takes:
 -  *b**i* extra seconds if he's small. -  *a**i* extra seconds otherwise (he's large). 
In simpler words, jumping from *i*-th chair to *j*-th chair takes exactly:
 -  |*x**i*<=-<=*x**j*|<=+<=*c**i*<=+<=*b**j* seconds if *j*<=&lt;<=*i*. -  |*x**i*<=-<=*x**j*|<=+<=*d**i*<=+<=*a**j* seconds otherwise (*j*<=&gt;<=*i*). 
Given values of *x*, *a*, *b*, *c*, *d* find the minimum time Scott can get to Cross, assuming he wants to visit each chair exactly once.","The first line of the input contains three integers *n*,<=*s* and *e* (2<=≤<=*n*<=≤<=5000,<=1<=≤<=*s*,<=*e*<=≤<=*n*,<=*s*<=≠<=*e*) — the total number of chairs, starting and ending positions of Scott.

The second line contains *n* integers *x*1,<=*x*2,<=...,<=*x**n* (1<=≤<=*x*1<=&lt;<=*x*2<=&lt;<=...<=&lt;<=*x**n*<=≤<=109).

The third line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a*1,<=*a*2,<=...,<=*a**n*<=≤<=109).

The fourth line contains *n* integers *b*1,<=*b*2,<=...,<=*b**n* (1<=≤<=*b*1,<=*b*2,<=...,<=*b**n*<=≤<=109).

The fifth line contains *n* integers *c*1,<=*c*2,<=...,<=*c**n* (1<=≤<=*c*1,<=*c*2,<=...,<=*c**n*<=≤<=109).

The sixth line contains *n* integers *d*1,<=*d*2,<=...,<=*d**n* (1<=≤<=*d*1,<=*d*2,<=...,<=*d**n*<=≤<=109).",Print the minimum amount of time Scott needs to get to the Cross while visiting each chair exactly once.,['7 4 3\n8 11 12 16 17 18 20\n17 16 20 2 20 5 13\n17 8 8 16 12 15 13\n12 4 16 4 15 7 6\n8 14 2 11 17 12 8\n'],['139\n'],"In the sample testcase, an optimal solution would be <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/5bbd3e094ffa5a72e263dfaec7aeaff795bc22a3.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>. Spent time would be 17 + 24 + 23 + 20 + 33 + 22 = 139.",WRONG_ANSWER,"import sys,math
from bisect import bisect_left , bisect_right 

def rd(): return sys.stdin.readline().strip()
def rdl(typ,sep="" ""): return list(map(typ, rd().split(sep)))
def wt(x,sep=""\n"") : sys.stdout.write(str(x) + sep)
def wtBoolUp(x): wt(""YES"" if x==True else ""NO"")
def wtBoolLow(x): wt(""Yes"" if x==True else ""No"")
def wtlArr(arr,sep="" ""): sys.stdout.write(sep.join(map(str,arr)) + ""\n"") if arr else None
def wtlsArr(arr): sys.stdout.write(""\n"".join(map(str,arr)) + ""\n"") if arr else None
def wtlsArrArr(arr):
    for a in arr: wtlArr(a)

from types import GeneratorType
def bootstrap(f, stack=[]):              
    def wrappedfunc(*args, **kwargs):
        if stack:
            return f(*args, **kwargs)
        else:
            to = f(*args, **kwargs)
            while True:
                if type(to) is GeneratorType:
                    stack.append(to)
                    to = next(to)
                else:
                    stack.pop()
                    if not stack:
                        break
                    to = stack[-1].send(to)
            return to
    return wrappedfunc

INF = float(""inf"") 
mod = 10**9 + 7    

def binPow(a,b,mod) :
    res = 1
    while b :
        if b % 2: 
            res = res * a % mod
        a = a * a % mod
        b //= 2
    return res

def invMod(x,mod): return pow(x,mod-2,mod)      

def getFacts(n,mod):
    fact = [1]*(n+1)
    for i in range(2,n+1): fact[i] = (i*fact[i-1])%mod
    return fact

def nCr(n, r, fact, mod) :
    num = fact[n]
    den = (fact[r] * fact[n - r]) % mod
    return (num * invMod(den, mod)) % mod

def lcm(num1,num2):
    hcf = math.gcd(num1,num2)
    lcm_ = (num1*num2)//hcf
    return lcm_

def sqrtFloat(num):
    l, r = 0 , num
    res = 0
    while l <= r :
        mid = (l+r)//2
        if mid*mid <= num :
            res = mid
            l = mid + 1
        else :
            r = mid-1
    
    return res + 0.1*(res*res != num)

def prefixSum(arr):
    pref = [0]*(len(arr)+1)
    for i in range(len(arr)): pref[i] = arr[i] + pref[i-1]
    return pref

def prefixXor(arr):
    pref = [0]*(len(arr)+1)
    for i in range(len(arr)): pref[i] = arr[i] ^ pref[i-1]
    return pref

def apSum(n):  return n*(n+1)//2
def apSumRange(l,r) : return apSum(r)-apSum(l-1)

def hypot(p1,p2):
    return ((p2[0]-p1[0])**2 + (p2[1]-p1[1])**2)**0.5
def manhat(p1,p2):
    return abs(p2[0]-p1[0]) + abs(p2[1]-p1[1])

def comb(n,r):
    res = 1
    for i in range(r) : res = res*(n-i)//(i+1)
    return res

def powerArr(base,n,mod):
    pwr = [1]*n
    for i in range(1,n):
        pwr[i] = (base*pwr[i-1]) % mod
    return pwr

def getClosest(num,sortArr,notTake=-INF,notTakeCnt=1):
    idx = bisect_left(sortArr,num)
    closeArr = []
    for i in range(max(0,idx-2),min(len(sortArr),idx+3)) :
        if notTakeCnt>0 and sortArr[i] == notTake:
            notTakeCnt -= 1
            continue
        closeArr.append(sortArr[i])
    return min(closeArr, key=lambda x:abs(x-num),default=-INF)

def group(arr, notTake=INF):
    n = len(arr)
    res = []
    i = 0
    while i < n:
        st = i
        while i+1 <n and arr[i] == arr[i+1] :
            i += 1
        if arr[st] != notTake:
            res.append([arr[st],st,i,i-st+1])
        i += 1
    return res

def dirnsRD() : return [(0,1),(1,0)]
def dirnsLU() : return [(0,-1),(-1,0)]
def dirns(): return dirnsRD() + dirnsLU()
def dirnsDiag(): return dirns() + [(1,1),(1,-1),(-1,1),(-1,-1)]
def chessDirns(): return [(-2,-1),(-1,-2),(1,-2),(2,-1),(2,1),(1,2),(-1,2),(-2,1)]

def cntBits(n): return bin(n).count(""1"")
def isRepSumP2(num, x): return cntBits(num) <= x <= num
def binry(decimal): return bin(decimal).replace('0b', '')
def deciml(binary): return int(str(binary),2)
def printAllBin(arr):
    maxLen = len(binry(max(arr)))
    for x in arr:
        curr = binry(x)
        res = "" "".join(list(""0""*(maxLen-len(curr))+curr))
        wt( res + f""   <- {x}"")

def c2i(ch,up=0): return ord(ch) - ord('A' if up else 'a')
def i2c(n,up=0): return chr(ord('A' if up else 'a') + n)

def setPrec(num, cnt): return round(num, cnt)
def flush(): sys.stdout.flush()
def clearCache(func): func.cache_clear()

''' ॐॐ _/\_ हर हर महादेव _/\_ ॐॐ '''

def solve():
    n,s,e = rdl(int)
    X = rdl(int)
    A = rdl(int)
    B = rdl(int)
    C = rdl(int)
    D = rdl(int)

    dp = [[INF]*(n+10) for _ in range(n+10)]
    dp[0][0] = 0

    for i in range(n):
        for comp in range(i+1):
            if i+1 == s:

                dp[i+1][comp+1] = min(dp[i+1][comp+1], dp[i][comp] - X[i] + D[i] )

                dp[i+1][comp] = min(dp[i+1][comp], dp[i][comp] + X[i] + C[i] )

                continue

            if i+1 == e:

                dp[i+1][comp+1] = min(dp[i+1][comp+1], dp[i][comp] - X[i] + B[i] )

                dp[i+1][comp] = min(dp[i+1][comp], dp[i][comp] + X[i] + A[i] )

                continue

            places = comp - (i+1 >s) - (i+1 >e)
            if places >=0 :
                dp[i+1][comp+1] = min(dp[i+1][comp+1], dp[i][comp] - 2*X[i] + D[i] + B[i] )

            places = comp - (i+1 >s)
            if places>0:
                dp[i+1][comp] = min(dp[i+1][comp], dp[i][comp] + C[i]+B[i] )

            places = comp - (i+1 >e)
            if places>0:
                dp[i+1][comp] = min(dp[i+1][comp], dp[i][comp] + A[i]+D[i] )

            dp[i+1][comp-1] = min(dp[i+1][comp-1], dp[i][comp] + 2*X[i] + A[i] + C[i])
    
    return dp[n][1]

wt(solve())","def min_time_to_reach_cross(n, s, e, x, a, b, c, d):
    from itertools import permutations

    s -= 1
    e -= 1

    def jump_time(i, j, is_large):
        jump_distance = abs(x[i] - x[j])
        if j < i:
            return jump_distance + c[i] + b[j]
        else:
            return jump_distance + d[i] + a[j]

    chairs = list(range(n))
    chairs.remove(s)
    chairs.remove(e)

    min_time = float('inf')

    for order in permutations(chairs):

        current_time = 0
        current_chair = s
        is_large = False

        for next_chair in order:
            current_time += jump_time(current_chair, next_chair, is_large)
            current_chair = next_chair
            is_large = True

        current_time += jump_time(current_chair, e, is_large)

        min_time = min(min_time, current_time)

    return min_time

n, s, e = map(int, input().split())
x = list(map(int, input().split()))
a = list(map(int, input().split()))
b = list(map(int, input().split()))
c = list(map(int, input().split()))
d = list(map(int, input().split()))

print(min_time_to_reach_cross(n, s, e, x, a, b, c, d))"
580,C,Kefa and Park,PROGRAMMING,"['dfs and similar', 'graphs', 'trees']","Kefa decided to celebrate his first big salary by going to the restaurant. 

He lives by an unusual park. The park is a rooted tree consisting of *n* vertices with the root at vertex 1. Vertex 1 also contains Kefa's house. Unfortunaely for our hero, the park also contains cats. Kefa has already found out what are the vertices with cats in them.

The leaf vertices of the park contain restaurants. Kefa wants to choose a restaurant where he will go, but unfortunately he is very afraid of cats, so there is no way he will go to the restaurant if the path from the restaurant to his house contains more than *m* consecutive vertices with cats. 

Your task is to help Kefa count the number of restaurants where he can go.","The first line contains two integers, *n* and *m* (2<=≤<=*n*<=≤<=105, 1<=≤<=*m*<=≤<=*n*) — the number of vertices of the tree and the maximum number of consecutive vertices with cats that is still ok for Kefa.

The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n*, where each *a**i* either equals to 0 (then vertex *i* has no cat), or equals to 1 (then vertex *i* has a cat).

Next *n*<=-<=1 lines contains the edges of the tree in the format ""*x**i* *y**i*"" (without the quotes) (1<=≤<=*x**i*,<=*y**i*<=≤<=*n*, *x**i*<=≠<=*y**i*), where *x**i* and *y**i* are the vertices of the tree, connected by an edge. 

It is guaranteed that the given set of edges specifies a tree.",A single integer — the number of distinct leaves of a tree the path to which from Kefa's home contains at most *m* consecutive vertices with cats.,"['4 1\n1 1 0 0\n1 2\n1 3\n1 4\n', '7 1\n1 0 1 1 0 0 0\n1 2\n1 3\n2 4\n2 5\n3 6\n3 7\n']","['2\n', '2\n']","Let us remind you that a tree is a connected graph on *n* vertices and *n* - 1 edge. A rooted tree is a tree with a special vertex called root. In a rooted tree among any two vertices connected by an edge, one vertex is a parent (the one closer to the root), and the other one is a child. A vertex is called a leaf, if it has no children.

Note to the first sample test: <img class=""tex-graphics"" src=""https://espresso.codeforces.com/785114b4b3f5336f02078c25750f87c5a1d0b4be.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> The vertices containing cats are marked red. The restaurants are at vertices 2, 3, 4. Kefa can't go only to the restaurant located at vertex 2.

Note to the second sample test: <img class=""tex-graphics"" src=""https://espresso.codeforces.com/e5c07640680c837aec99126d94287872e69aa09a.png"" style=""max-width: 100.0%;max-height: 100.0%;""/> The restaurants are located at vertices 4, 5, 6, 7. Kefa can't go to restaurants 6, 7.",OK,"import sys
import math
from collections import Counter, defaultdict, deque
from functools import cmp_to_key

def inp():
    return(int(input()))
def inlt():
    return(list(map(int,input().split())))
def insr():
    s = input()
    return(list(s[:len(s)]))
def invr():
    return(map(int,input().split()))

n,m=invr()
nodes=inlt()
adjlist=[[] for _ in range(n)]
for i in range(n-1):
    x,v = invr()
    adjlist[x-1].append(v-1)
    adjlist[v-1].append(x-1)
visited=[False]*n
visited[0]=True
stack=[]
stack.append((0,0))
count=0
while stack:
    u,cats=stack.pop()
    if nodes[u]==1:cats+=1
    else:cats=0
    if cats>m:
        continue
    isLeaf=True
    for v in adjlist[u]:
        if not visited[v]:
            isLeaf=False
            visited[v]=True
            stack.append((v,cats))
    if isLeaf:count+=1
print(count)","def dfs(node, parent, consecutive_cats):

    if cats[node - 1] == 1:
        consecutive_cats += 1
    else:
        consecutive_cats = 0

    if consecutive_cats > m:
        return 0

    is_leaf = True
    count = 0

    for neighbor in graph[node]:
        if neighbor != parent:
            is_leaf = False
            count += dfs(neighbor, node, consecutive_cats)

    if is_leaf:
        return 1
    return count

n, m = map(int, input().split())
cats = list(map(int, input().split()))
graph = [[] for _ in range(n + 1)]

for _ in range(n - 1):
    x, y = map(int, input().split())
    graph[x].append(y)
    graph[y].append(x)

result = dfs(1, -1, 0)
print(result)"
0,none,none,none,['none'],"For a given positive integer *n* denote its *k*-rounding as the minimum positive integer *x*, such that *x* ends with *k* or more zeros in base 10 and is divisible by *n*.

For example, 4-rounding of 375 is 375·80<==<=30000. 30000 is the minimum integer such that it ends with 4 or more zeros and is divisible by 375.

Write a program that will perform the *k*-rounding of *n*.","The only line contains two integers *n* and *k* (1<=≤<=*n*<=≤<=109, 0<=≤<=*k*<=≤<=8).",Print the *k*-rounding of *n*.,"['375 4\n', '10000 1\n', '38101 0\n', '123456789 8\n']","['30000\n', '10000\n', '38101\n', '12345678900000000\n']",none,OK,"def gcd(a,b):
    if b==0:
        return a
    return gcd(b,a%b)
def lcm(a,b):
    return a*b//gcd(a,b)
n,k=map(int,input().split())
print(lcm(n,10**k))","def k_rounding(n, k):

    factor = 10 ** k

    x = (factor + n - 1) // n * n

    while x % factor != 0:
        x += n

    return x

def main():
    import sys

    for line in sys.stdin:
        n, k = map(int, line.split())

        print(k_rounding(n, k))

if __name__ == ""__main__"":
    main()"
822,A,I'm bored with life,PROGRAMMING,"['implementation', 'math', 'number theory']","Holidays have finished. Thanks to the help of the hacker Leha, Noora managed to enter the university of her dreams which is located in a town Pavlopolis. It's well known that universities provide students with dormitory for the period of university studies. Consequently Noora had to leave Vičkopolis and move to Pavlopolis. Thus Leha was left completely alone in a quiet town Vičkopolis. He almost even fell into a depression from boredom!

Leha came up with a task for himself to relax a little. He chooses two integers *A* and *B* and then calculates the greatest common divisor of integers ""*A* factorial"" and ""*B* factorial"". Formally the hacker wants to find out GCD(*A*!,<=*B*!). It's well known that the factorial of an integer *x* is a product of all positive integers less than or equal to *x*. Thus *x*!<==<=1·2·3·...·(*x*<=-<=1)·*x*. For example 4!<==<=1·2·3·4<==<=24. Recall that GCD(*x*,<=*y*) is the largest positive integer *q* that divides (without a remainder) both *x* and *y*.

Leha has learned how to solve this task very effective. You are able to cope with it not worse, aren't you?","The first and single line contains two integers *A* and *B* (1<=≤<=*A*,<=*B*<=≤<=109,<=*min*(*A*,<=*B*)<=≤<=12).",Print a single integer denoting the greatest common divisor of integers *A*! and *B*!.,['4 3\n'],['6\n'],"Consider the sample.

4! = 1·2·3·4 = 24. 3! = 1·2·3 = 6. The greatest common divisor of integers 24 and 6 is exactly 6.",COMPILATION_ERROR,"import math
def GCD(A,B):
    while B:
        A,B = B,A % B
    return A

def factorial(A,B):
    return factorial_gcd(min(A,B)
    
def factorial_gcd(N):
    if(N == 0):
        return 1
    return N * factorial_gcd(N -1)

A,B = map(int,input().split())
result = factorial(A,B)
print(result)","import math

A, B = map(int, input().split())

min_ab = min(A, B)

gcd_factorial = math.factorial(min_ab)

print(gcd_factorial)"
895,D,String Mark,PROGRAMMING,"['combinatorics', 'math', 'strings']","At the Byteland State University marks are strings of the same length. Mark *x* is considered better than *y* if string *y* is lexicographically smaller than *x*.

Recently at the BSU was an important test work on which Vasya recived the mark *a*. It is very hard for the teacher to remember the exact mark of every student, but he knows the mark *b*, such that every student recieved mark strictly smaller than *b*.

Vasya isn't satisfied with his mark so he decided to improve it. He can swap characters in the string corresponding to his mark as many times as he like. Now he want to know only the number of different ways to improve his mark so that his teacher didn't notice something suspicious.

More formally: you are given two strings *a*, *b* of the same length and you need to figure out the number of different strings *c* such that:

1) *c* can be obtained from *a* by swapping some characters, in other words *c* is a permutation of *a*.

2) String *a* is lexicographically smaller than *c*.

3) String *c* is lexicographically smaller than *b*.

For two strings *x* and *y* of the same length it is true that *x* is lexicographically smaller than *y* if there exists such *i*, that *x*1<==<=*y*1,<=*x*2<==<=*y*2,<=...,<=*x**i*<=-<=1<==<=*y**i*<=-<=1,<=*x**i*<=&lt;<=*y**i*.

Since the answer can be very large, you need to find answer modulo 109<=+<=7.","First line contains string *a*, second line contains string *b*. Strings *a*,<=*b* consist of lowercase English letters. Their lengths are equal and don't exceed 106.

It is guaranteed that *a* is lexicographically smaller than *b*.",Print one integer  — the number of different strings satisfying the condition of the problem modulo 109<=+<=7.,"['abc\nddd\n', 'abcdef\nabcdeg\n', 'abacaba\nubuduba\n']","['5\n', '0\n', '64\n']","In first sample from string *abc* can be obtained strings *acb*, *bac*, *bca*, *cab*, *cba*, all of them are larger than *abc*, but smaller than *ddd*. So the answer is 5.

In second sample any string obtained from *abcdef* is larger than *abcdeg*. So the answer is 0.",TIME_LIMIT_EXCEEDED,"import itertools
A = str(input())
b = str(input())
arr = []
def toString(List):
    return ''.join(List)

def permute(a, l, r):
    if l == r:
        if b > toString(a) > A:
            arr.append(toString(a))
    else:
        for i in range(l, r + 1):
            a[l], a[i] = a[i], a[l]
            permute(a, l + 1, r)
            a[l], a[i] = a[i], a[l]

permute(list(A), 0, len(A) - 1)
print(len(set(arr)))","from collections import Counter
from math import factorial

def factorial_memo(n, memo):
    if n in memo:
        return memo[n]
    if n == 0 or n == 1:
        return 1
    memo[n] = n * factorial_memo(n - 1, memo) % MOD
    return memo[n]

def count_permutations(a, b):
    n = len(a)
    MOD = 10**9 + 7

    count_a = Counter(a)
    count_b = Counter(b)

    factorial_memo_cache = {}

    total_count = 0

    for i in range(n):
        for char in sorted(count_a):
            if char > a[i]:
                count_a[char] -= 1
                if count_a[char] == 0:
                    del count_a[char]

                denominator = 1
                for c in count_a.values():
                    denominator *= factorial_memo(c, factorial_memo_cache)
                    denominator %= MOD

                permutations_count = factorial_memo(sum(count_a.values()), factorial_memo_cache) * pow(denominator, MOD - 2, MOD) % MOD
                total_count += permutations_count
                total_count %= MOD
                count_a[char] += 1

            if char == a[i]:
                break

        if a[i] >= b[i]:
            break
        
        count_a[a[i]] -= 1
        if count_a[a[i]] == 0:
            del count_a[a[i]]
    
    return total_count

if __name__ == ""__main__"":
    import sys
    input = sys.stdin.read
    data = input().strip().splitlines()
    
    results = []
    for i in range(0, len(data), 2):
        a = data[i].strip()
        b = data[i+1].strip()
        result = count_permutations(a, b)
        results.append(result)

    sys.stdout.write(""\n"".join(map(str, results)) + ""\n"")"
822,A,I'm bored with life,PROGRAMMING,"['implementation', 'math', 'number theory']","Holidays have finished. Thanks to the help of the hacker Leha, Noora managed to enter the university of her dreams which is located in a town Pavlopolis. It's well known that universities provide students with dormitory for the period of university studies. Consequently Noora had to leave Vičkopolis and move to Pavlopolis. Thus Leha was left completely alone in a quiet town Vičkopolis. He almost even fell into a depression from boredom!

Leha came up with a task for himself to relax a little. He chooses two integers *A* and *B* and then calculates the greatest common divisor of integers ""*A* factorial"" and ""*B* factorial"". Formally the hacker wants to find out GCD(*A*!,<=*B*!). It's well known that the factorial of an integer *x* is a product of all positive integers less than or equal to *x*. Thus *x*!<==<=1·2·3·...·(*x*<=-<=1)·*x*. For example 4!<==<=1·2·3·4<==<=24. Recall that GCD(*x*,<=*y*) is the largest positive integer *q* that divides (without a remainder) both *x* and *y*.

Leha has learned how to solve this task very effective. You are able to cope with it not worse, aren't you?","The first and single line contains two integers *A* and *B* (1<=≤<=*A*,<=*B*<=≤<=109,<=*min*(*A*,<=*B*)<=≤<=12).",Print a single integer denoting the greatest common divisor of integers *A*! and *B*!.,['4 3\n'],['6\n'],"Consider the sample.

4! = 1·2·3·4 = 24. 3! = 1·2·3 = 6. The greatest common divisor of integers 24 and 6 is exactly 6.",OK,"def minfact(j,k):
    n=min(j,k)
    fact=1
    for i in range(1,n+1):
        fact*=i
    print(fact)
j,k=[int(item) for item in input().split(' ')]
minfact(j,k)","import math

A, B = map(int, input().split())

factorial_A = math.factorial(A)
factorial_B = math.factorial(B)

gcd_value = math.gcd(factorial_A, factorial_B)

print(gcd_value)"
807,A,Is it rated?,PROGRAMMING,"['implementation', 'sortings']","Is it rated?

Here it is. The Ultimate Question of Competitive Programming, Codeforces, and Everything. And you are here to answer it.

Another Codeforces round has been conducted. No two participants have the same number of points. For each participant, from the top to the bottom of the standings, their rating before and after the round is known.

It's known that if at least one participant's rating has changed, then the round was rated for sure.

It's also known that if the round was rated and a participant with lower rating took a better place in the standings than a participant with higher rating, then at least one round participant's rating has changed.

In this problem, you should not make any other assumptions about the rating system.

Determine if the current round is rated, unrated, or it's impossible to determine whether it is rated of not.","The first line contains a single integer *n* (2<=≤<=*n*<=≤<=1000) — the number of round participants.

Each of the next *n* lines contains two integers *a**i* and *b**i* (1<=≤<=*a**i*,<=*b**i*<=≤<=4126) — the rating of the *i*-th participant before and after the round, respectively. The participants are listed in order from the top to the bottom of the standings.","If the round is rated for sure, print ""rated"". If the round is unrated for sure, print ""unrated"". If it's impossible to determine whether the round is rated or not, print ""maybe"".","['6\n3060 3060\n2194 2194\n2876 2903\n2624 2624\n3007 2991\n2884 2884\n', '4\n1500 1500\n1300 1300\n1200 1200\n1400 1400\n', '5\n3123 3123\n2777 2777\n2246 2246\n2246 2246\n1699 1699\n']","['rated\n', 'unrated\n', 'maybe\n']","In the first example, the ratings of the participants in the third and fifth places have changed, therefore, the round was rated.

In the second example, no one's rating has changed, but the participant in the second place has lower rating than the participant in the fourth place. Therefore, if the round was rated, someone's rating would've changed for sure.

In the third example, no one's rating has changed, and the participants took places in non-increasing order of their rating. Therefore, it's impossible to determine whether the round is rated or not.",OK,"def inp():
    return map(int, input().split())

def arr_inp():
    return [int(x) for x in input().split()]

def print_arr(arr):
    print(*arr, sep=' ')

n = int(input())
count, max = 0, 4127
for i in range(n):
    a, b = inp()
    if (a == b):
        if(a<=max):
            count += 1
            max=a
    else:
        print('rated')
        exit()
if(count==n):
    print('maybe')
else:
    print('unrated')","n = int(input())

ratings = []

for _ in range(n):
    a, b = map(int, input().split())
    ratings.append((a, b))

rated = any(a != b for a, b in ratings)

if rated:

    print(""rated"")
else:

    for i in range(n - 1):
        if ratings[i][0] < ratings[i + 1][0]:
            print(""unrated"")
            break
    else:

        print(""maybe"")"
768,A,Oath of the Night's Watch,PROGRAMMING,"['constructive algorithms', 'sortings']","""Night gathers, and now my watch begins. It shall not end until my death. I shall take no wife, hold no lands, father no children. I shall wear no crowns and win no glory. I shall live and die at my post. I am the sword in the darkness. I am the watcher on the walls. I am the shield that guards the realms of men. I pledge my life and honor to the Night's Watch, for this night and all the nights to come."" — The Night's Watch oath.

With that begins the watch of Jon Snow. He is assigned the task to support the stewards.

This time he has *n* stewards with him whom he has to provide support. Each steward has his own strength. Jon Snow likes to support a steward only if there exists at least one steward who has strength strictly less than him and at least one steward who has strength strictly greater than him.

Can you find how many stewards will Jon support?","First line consists of a single integer *n* (1<=≤<=*n*<=≤<=105) — the number of stewards with Jon Snow.

Second line consists of *n* space separated integers *a*1,<=*a*2,<=...,<=*a**n* (0<=≤<=*a**i*<=≤<=109) representing the values assigned to the stewards.",Output a single integer representing the number of stewards which Jon will feed.,"['2\n1 5\n', '3\n1 2 5\n']","['0', '1']","In the first sample, Jon Snow cannot support steward with strength 1 because there is no steward with strength less than 1 and he cannot support steward with strength 5 because there is no steward with strength greater than 5.

In the second sample, Jon Snow can support steward with strength 2 because there are stewards with strength less than 2 and greater than 2.",OK,"n = int(input())
arr = list(map(int, input().split()))
def count(nums):
    if len(nums) <= 2:
        print(0)
        return
    less = nums[0]
    large = nums[0]
    res = 0
    for index in range(len(nums)):
        cur = nums[index]
        less = min(less, cur)
        large = max(large, cur)
    for index in range(len(nums)):
        cur = nums[index]
        if cur > less and cur < large:
            res += 1
    print(res)
    return
count(arr)","def count_supported_stewards(n, strengths):

    if n < 3:
        return 0

    min_strength = min(strengths)
    max_strength = max(strengths)

    count = 0
    for strength in strengths:
        if min_strength < strength < max_strength:
            count += 1

    return count

n = int(input())
strengths = list(map(int, input().split()))

print(count_supported_stewards(n, strengths))"
959,B,Mahmoud and Ehab and the message,PROGRAMMING,"['dsu', 'greedy', 'implementation']","Mahmoud wants to send a message to his friend Ehab. Their language consists of *n* words numbered from 1 to *n*. Some words have the same meaning so there are *k* groups of words such that all the words in some group have the same meaning.

Mahmoud knows that the *i*-th word can be sent with cost *a**i*. For each word in his message, Mahmoud can either replace it with another word of the same meaning or leave it as it is. Can you help Mahmoud determine the minimum cost of sending the message?

The cost of sending the message is the sum of the costs of sending every word in it.","The first line of input contains integers *n*, *k* and *m* (1<=≤<=*k*<=≤<=*n*<=≤<=105,<=1<=≤<=*m*<=≤<=105) — the number of words in their language, the number of groups of words, and the number of words in Mahmoud's message respectively.

The second line contains *n* strings consisting of lowercase English letters of length not exceeding 20 which represent the words. It's guaranteed that the words are distinct.

The third line contains *n* integers *a*1, *a*2, ..., *a**n* (1<=≤<=*a**i*<=≤<=109) where *a**i* is the cost of sending the *i*-th word.

The next *k* lines describe the groups of words of same meaning. The next *k* lines each start with an integer *x* (1<=≤<=*x*<=≤<=*n*) which means that there are *x* words in this group, followed by *x* integers which represent the indices of words in this group. It's guaranteed that each word appears in exactly one group.

The next line contains *m* space-separated words which represent Mahmoud's message. Each of these words appears in the list of language's words.",The only line should contain the minimum cost to send the message after replacing some words (maybe none) with some words of the same meaning.,"['5 4 4\ni loser am the second\n100 1 1 5 10\n1 1\n1 3\n2 2 5\n1 4\ni am the second\n', '5 4 4\ni loser am the second\n100 20 1 5 10\n1 1\n1 3\n2 2 5\n1 4\ni am the second\n']","['107', '116']","In the first sample, Mahmoud should replace the word ""second"" with the word ""loser"" because it has less cost so the cost will be 100+1+5+1=107.

In the second sample, Mahmoud shouldn't do any replacement so the cost will be 100+1+5+10=116.",WRONG_ANSWER,"def find(dd,a):
	if dd[a]==a:
		return dd[a]
	dd[a]=find(dd,dd[a])
	return dd[a]
	
def union(dd,l,d,a,b,i,j):
	x=find(dd,a)
	y=find(dd,b)
	if x!=y:
		if l[i]<l[j]:
			dd[y]=x
		else:
			dd[x]=y
			
n,k,m=map(int,input().split())
s=input().split()
d={}
dd={}
e={}
for i in range(n):
	d[i+1]=s[i]
	dd[s[i]]=s[i]

l=list(map(int,input().split()))
for i in range(n):
	e[s[i]]=l[i]
for _ in range(k):
	x=list(map(int,input().split()))
	st=d[x[1]]
	val=l[x[1]-1]
	for i in range(2,len(x)):
		union(dd,l,d,d[x[i]],d[x[i-1]],i,i-1)
ss=input().split()

ans=0

for i in ss:
	ans+=e[dd[i]]
print(ans)","n, k, m = map(int, input().split())
words = input().split()
costs = list(map(int, input().split()))

min_cost = [float('inf')] * n

for _ in range(k):
    group_info = list(map(int, input().split()))
    x = group_info[0]
    indices = group_info[1:x + 1]

    group_min_cost = min(costs[i - 1] for i in indices)

    for index in indices:
        min_cost[index - 1] = group_min_cost

message = input().split()
total_cost = sum(min_cost[words.index(word)] for word in message)

print(total_cost)"
55,B,Smallest number,PROGRAMMING,['brute force'],"Recently, Vladimir got bad mark in algebra again. To avoid such unpleasant events in future he decided to train his arithmetic skills. He wrote four integer numbers *a*, *b*, *c*, *d* on the blackboard. During each of the next three minutes he took two numbers from the blackboard (not necessarily adjacent) and replaced them with their sum or their product. In the end he got one number. Unfortunately, due to the awful memory he forgot that number, but he remembers four original numbers, sequence of the operations and his surprise because of the very small result. Help Vladimir remember the forgotten number: find the smallest number that can be obtained from the original numbers by the given sequence of operations.","First line contains four integers separated by space: 0<=≤<=*a*,<=*b*,<=*c*,<=*d*<=≤<=1000 — the original numbers. Second line contains three signs ('+' or '*' each) separated by space — the sequence of the operations in the order of performing. ('+' stands for addition, '*' — multiplication)","Output one integer number — the minimal result which can be obtained.

Please, do not use %lld specificator to read or write 64-bit integers in C++. It is preffered to use cin (also you may use %I64d).","['1 1 1 1\n+ + *\n', '2 2 2 2\n* * +\n', '1 2 3 4\n* + +\n']","['3\n', '8\n', '9\n']",none,OK,"def solve(index):
    if index==3:
        for x in arr:
            if x>=0:
                ans[0]=min(ans[0],x)
        return 
    for i in range(4):
        if arr[i] !=-1:
            for j in range(4):
                if i==j or arr[j]==-1:
                    continue
                a,b=arr[i],arr[j]
                if s[index]=='+':
                    arr[j]=a+b
                    arr[i]=-1
                    solve(index+1)
                    arr[j]=b
                    arr[i]=a
                elif s[index]=='*':
                    arr[j]=a*b
                    arr[i]=-1
                    solve(index+1)
                    arr[j]=b
                    arr[i]=a
        else:
            continue
        
ans=[float('inf')]
arr=list(map(int,input().split()))
s=input().split()
solve(0)
print(*ans)","from itertools import permutations

def apply_operation(x, y, operation):
    if operation == '+':
        return x + y
    elif operation == '*':
        return x * y

def calculate_minimum_result(numbers, operations):
    min_result = float('inf')

    for perm in permutations(numbers):

        result = apply_operation(perm[0], perm[1], operations[0])
        result = apply_operation(result, perm[2], operations[1])
        result = apply_operation(result, perm[3], operations[2])
        min_result = min(min_result, result)

    return min_result

original_numbers = list(map(int, input().strip().split()))
operations = input().strip().split()

result = calculate_minimum_result(original_numbers, operations)

print(result)"
701,A,Cards,PROGRAMMING,"['greedy', 'implementation']","There are *n* cards (*n* is even) in the deck. Each card has a positive integer written on it. *n*<=/<=2 people will play new card game. At the beginning of the game each player gets two cards, each card is given to exactly one player. 

Find the way to distribute cards such that the sum of values written of the cards will be equal for each player. It is guaranteed that it is always possible.","The first line of the input contains integer *n* (2<=≤<=*n*<=≤<=100) — the number of cards in the deck. It is guaranteed that *n* is even.

The second line contains the sequence of *n* positive integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=100), where *a**i* is equal to the number written on the *i*-th card.","Print *n*<=/<=2 pairs of integers, the *i*-th pair denote the cards that should be given to the *i*-th player. Each card should be given to exactly one player. Cards are numbered in the order they appear in the input.

It is guaranteed that solution exists. If there are several correct answers, you are allowed to print any of them.","['6\n1 5 7 4 4 3\n', '4\n10 10 10 10\n']","['1 3\n6 2\n4 5\n', '1 2\n3 4\n']","In the first sample, cards are distributed in such a way that each player has the sum of numbers written on his cards equal to 8. 

In the second sample, all values *a*<sub class=""lower-index"">*i*</sub> are equal. Thus, any distribution is acceptable.",OK,"def swap(seq,i,j):
	temp=seq[i]
	seq[i]=seq[j]
	seq[j]=temp

def argsort(n,seq):
	i=1
	indices=[]
	while i<=n:
		indices.append(i)
		i+=1
	i=0
	while i<n-1:
		j=i+1
		while j<n:
			if(seq[j]<seq[i]):
				swap(seq,i,j)
				swap(indices,i,j)
			j+=1
		i+=1

	return indices

def Cards(n, seq):
	argSorted= argsort(n,seq)
	i=1
	j=n
	while(i<=n/2):
		print(str(argSorted[i-1])+"" ""+str(argSorted[j-1]))
		i+=1
		j-=1

n = int(input())
seq = [int(x) for x in input().split()]

Cards(n,seq)","def distribute_cards(n, cards):

    indexed_cards = list(enumerate(cards, start=1))

    indexed_cards.sort(key=lambda x: x[1])

    output_pairs = []

    for i in range(n // 2):

        output_pairs.append((indexed_cards[i][0], indexed_cards[n - 1 - i][0]))
    
    return output_pairs

n = int(input())
cards = list(map(int, input().split()))

pairs = distribute_cards(n, cards)

for pair in pairs:
    print(pair[0], pair[1])"
415,B,Mashmokh and Tokens,PROGRAMMING,"['binary search', 'greedy', 'implementation', 'math']","Bimokh is Mashmokh's boss. For the following *n* days he decided to pay to his workers in a new way. At the beginning of each day he will give each worker a certain amount of tokens. Then at the end of each day each worker can give some of his tokens back to get a certain amount of money. The worker can save the rest of tokens but he can't use it in any other day to get more money. If a worker gives back *w* tokens then he'll get  dollars. 

Mashmokh likes the tokens however he likes money more. That's why he wants to save as many tokens as possible so that the amount of money he gets is maximal possible each day. He has *n* numbers *x*1,<=*x*2,<=...,<=*x**n*. Number *x**i* is the number of tokens given to each worker on the *i*-th day. Help him calculate for each of *n* days the number of tokens he can save.","The first line of input contains three space-separated integers *n*,<=*a*,<=*b* (1<=≤<=*n*<=≤<=105; 1<=≤<=*a*,<=*b*<=≤<=109). The second line of input contains *n* space-separated integers *x*1,<=*x*2,<=...,<=*x**n* (1<=≤<=*x**i*<=≤<=109).",Output *n* space-separated integers. The *i*-th of them is the number of tokens Mashmokh can save on the *i*-th day.,"['5 1 4\n12 6 11 9 1\n', '3 1 2\n1 2 3\n', '1 1 1\n1\n']","['0 2 3 1 1 ', '1 0 1 ', '0 ']",none,OK,"""""""
Codeforces Round 240 Div 1 Problem B

Author  : chaotic_iak
Language: Python 3.3.4
""""""

class InputHandlerObject(object):
    inputs = []

    def getInput(self, n = 0):
        res = """"
        inputs = self.inputs
        if not inputs: inputs.extend(input().split("" ""))
        if n == 0:
            res = inputs[:]
            inputs[:] = []
        while n > len(inputs):
            inputs.extend(input().split("" ""))
        if n > 0:
            res = inputs[:n]
            inputs[:n] = []
        return res
InputHandler = InputHandlerObject()
g = InputHandler.getInput

n,a,b = g()
n,a,b = int(n),int(a),int(b)
c = [int(x) for x in g()]
r = []
for i in c:
    r.append(str(((i*a) % b) // a))
print("" "".join(r))","def calculate_saved_tokens(n, a, b, tokens):
    saved_tokens = []
    
    for x in tokens:

        money_gained = min(x // a, b)

        tokens_returned = money_gained * a

        saved_tokens.append(x - tokens_returned)
    
    return saved_tokens

if __name__ == ""__main__"":

    n, a, b = map(int, input().split())

    tokens = list(map(int, input().split()))

    result = calculate_saved_tokens(n, a, b, tokens)

    print(' '.join(map(str, result)))"
217,A,Ice Skating,PROGRAMMING,"['brute force', 'dfs and similar', 'dsu', 'graphs']","Bajtek is learning to skate on ice. He's a beginner, so his only mode of transportation is pushing off from a snow drift to the north, east, south or west and sliding until he lands in another snow drift. He has noticed that in this way it's impossible to get from some snow drifts to some other by any sequence of moves. He now wants to heap up some additional snow drifts, so that he can get from any snow drift to any other one. He asked you to find the minimal number of snow drifts that need to be created.

We assume that Bajtek can only heap up snow drifts at integer coordinates.","The first line of input contains a single integer *n* (1<=≤<=*n*<=≤<=100) — the number of snow drifts. Each of the following *n* lines contains two integers *x**i* and *y**i* (1<=≤<=*x**i*,<=*y**i*<=≤<=1000) — the coordinates of the *i*-th snow drift.

Note that the north direction coinсides with the direction of *Oy* axis, so the east direction coinсides with the direction of the *Ox* axis. All snow drift's locations are distinct.",Output the minimal number of snow drifts that need to be created in order for Bajtek to be able to reach any snow drift from any other one.,"['2\n2 1\n1 2\n', '2\n2 1\n4 1\n']","['1\n', '0\n']",none,RUNTIME_ERROR,"def find_best_snow_drifts(snow_drifts, point):
  snow_drifts.remove(point)
  if len(snow_drifts) > 0:
    same_line_snow_drifts = get_points_same_line(snow_drifts, point)
    for p in same_line_snow_drifts:
      find_best_snow_drifts(snow_drifts, p)

def is_same_line(point1, point2):
  return point1[0] == point2[0] or point1[1] == point2[1]

def get_points_same_line(snow_drifts, point):
  points = []
  for p in snow_drifts:
    if (p != point and is_same_line(point, p)):
      points.append(p)
  return points

if __name__ == ""__main__"":
  n = int(input())
  snow_drifts = []
  solution = 0

  for i in range(n):
    coordinates = [int(n) for n in input().split(' ')]
    snow_drifts.append(coordinates)

  G_SNOW_DRIFTS = snow_drifts.copy()

  for point in G_SNOW_DRIFTS:
    if point in snow_drifts:
      find_best_snow_drifts(snow_drifts, point)
      solution += 1

  print(solution - 1)","def min_snow_drifts_to_create(n, coordinates):

    unique_x = set()
    unique_y = set()

    for x, y in coordinates:
        unique_x.add(x)
        unique_y.add(y)

    min_drifts_needed = max(0, (len(unique_x) - 1) + (len(unique_y) - 1))
    
    return min_drifts_needed

if __name__ == ""__main__"":
    import sys
    input = sys.stdin.read
    data = input().splitlines()

    n = int(data[0])
    coordinates = []

    for i in range(1, n + 1):
        x, y = map(int, data[i].split())
        coordinates.append((x, y))

    result = min_snow_drifts_to_create(n, coordinates)

    print(result)"
519,B,A and B and Compilation Errors,PROGRAMMING,"['data structures', 'implementation', 'sortings']","A and B are preparing themselves for programming contests.

B loves to debug his code. But before he runs the solution and starts debugging, he has to first compile the code.

Initially, the compiler displayed *n* compilation errors, each of them is represented as a positive integer. After some effort, B managed to fix some mistake and then another one mistake.

However, despite the fact that B is sure that he corrected the two errors, he can not understand exactly what compilation errors disappeared — the compiler of the language which B uses shows errors in the new order every time! B is sure that unlike many other programming languages, compilation errors for his programming language do not depend on each other, that is, if you correct one error, the set of other error does not change.

Can you help B find out exactly what two errors he corrected?","The first line of the input contains integer *n* (3<=≤<=*n*<=≤<=105) — the initial number of compilation errors.

The second line contains *n* space-separated integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=109) — the errors the compiler displayed for the first time. 

The third line contains *n*<=-<=1 space-separated integers *b*1,<=*b*2,<=...,<=*b**n*<=-<=1 — the errors displayed at the second compilation. It is guaranteed that the sequence in the third line contains all numbers of the second string except for exactly one. 

The fourth line contains *n*<=-<=2 space-separated integers *с*1,<=*с*2,<=...,<=*с**n*<=-<=2 — the errors displayed at the third compilation. It is guaranteed that the sequence in the fourth line contains all numbers of the third line except for exactly one.","Print two numbers on a single line: the numbers of the compilation errors that disappeared after B made the first and the second correction, respectively.","['5\n1 5 8 123 7\n123 7 5 1\n5 1 7\n', '6\n1 4 3 3 5 7\n3 7 5 4 3\n4 3 7 5\n']","['8\n123\n', '1\n3\n']","In the first test sample B first corrects the error number 8, then the error number 123.

In the second test sample B first corrects the error number 1, then the error number 3. Note that if there are multiple errors with the same number, B can correct only one of them in one step.",OK,"from sys import stdin
def input(): return stdin.readline()[:-1]
n=int(input())
a=list(map(int,input().split()))
b=list(map(int,input().split()))
c=list(map(int,input().split()))
l=a+b
ans=l[0]
for i in range(1,2*n-1):
	ans^=l[i]
print(ans)
l=b+c
ans=l[0]
for i in range(1,2*n-3):
	ans^=l[i]
print(ans)","def find_disappeared_errors(n, first, second, third):

    from collections import Counter

    count_first = Counter(first)
    count_second = Counter(second)
    count_third = Counter(third)

    for error in count_first:
        if count_first[error] > count_second[error]:
            first_missing = error
            break

    for error in count_second:
        if count_second[error] > count_third[error]:
            second_missing = error
            break

    return first_missing, second_missing

n = int(input().strip())
first = list(map(int, input().strip().split()))
second = list(map(int, input().strip().split()))
third = list(map(int, input().strip().split()))

disappeared_errors = find_disappeared_errors(n, first, second, third)

print(disappeared_errors[0])
print(disappeared_errors[1])"
464,E,The Classic Problem,PROGRAMMING,"['data structures', 'graphs', 'shortest paths']",You are given a weighted undirected graph on *n* vertices and *m* edges. Find the shortest path from vertex *s* to vertex *t* or else state that such path doesn't exist.,"The first line of the input contains two space-separated integers — *n* and *m* (1<=≤<=*n*<=≤<=105; 0<=≤<=*m*<=≤<=105).

Next *m* lines contain the description of the graph edges. The *i*-th line contains three space-separated integers — *u**i*, *v**i*, *x**i* (1<=≤<=*u**i*,<=*v**i*<=≤<=*n*; 0<=≤<=*x**i*<=≤<=105). That means that vertices with numbers *u**i* and *v**i* are connected by edge of length 2*x**i* (2 to the power of *x**i*).

The last line contains two space-separated integers — the numbers of vertices *s* and *t*.

The vertices are numbered from 1 to *n*. The graph contains no multiple edges and self-loops.","In the first line print the remainder after dividing the length of the shortest path by 1000000007 (109<=+<=7) if the path exists, and -1 if the path doesn't exist.

If the path exists print in the second line integer *k* — the number of vertices in the shortest path from vertex *s* to vertex *t*; in the third line print *k* space-separated integers — the vertices of the shortest path in the visiting order. The first vertex should be vertex *s*, the last vertex should be vertex *t*. If there are multiple shortest paths, print any of them.","['4 4\n1 4 2\n1 2 0\n2 3 0\n3 4 0\n1 4\n', '4 3\n1 2 4\n2 3 5\n3 4 6\n1 4\n', '4 2\n1 2 0\n3 4 1\n1 4\n']","['3\n4\n1 2 3 4 \n', '112\n4\n1 2 3 4 \n', '-1\n']","A path from vertex *s* to vertex *t* is a sequence *v*<sub class=""lower-index"">0</sub>, ..., *v*<sub class=""lower-index"">*k*</sub>, such that *v*<sub class=""lower-index"">0</sub> = *s*, *v*<sub class=""lower-index"">*k*</sub> = *t*, and for any *i* from 0 to *k* - 1 vertices *v*<sub class=""lower-index"">*i*</sub> and *v*<sub class=""lower-index"">*i* + 1</sub> are connected by an edge. 

The length of the path is the sum of weights of edges between *v*<sub class=""lower-index"">*i*</sub> and *v*<sub class=""lower-index"">*i* + 1</sub> for all *i* from 0 to *k* - 1. 

The shortest path from *s* to *t* is the path which length is minimum among all possible paths from *s* to *t*.",TIME_LIMIT_EXCEEDED,"import sys

def solve():
    n,m = [int(x) for x in input().split()]
    n = n+1
    neighbours = [[] for i in range(n)]
    for i in range(m):
        a,b, dist = [int(x) for x in input().split()]

        neighbours[a].append([b,dist])
        neighbours[b].append([a,dist])

    start, end = [int(x) for x in input().split()]

    dist = [sys.maxsize] * n
    dist[start] = 0
    visited = [False] * n
    prev = [None]* n
    
    for step in range(n):
        nextNode = 0
        minDist = sys.maxsize

        for i,v in enumerate(visited):
            if v:
                continue
            if dist[i] < minDist:
                minDist = dist[i]
                nextNode = i
                
        if minDist == sys.maxsize:
            break
        visited[nextNode] = True

        for neighbour in neighbours[nextNode]:
            node, cost = neighbour
            cost = 2 ** cost
            tmp = dist[nextNode] + cost
            if tmp < dist[node]:
                prev[node] = nextNode
                dist[node] = dist[nextNode] + cost

    path = [end]
    if dist[end] == sys.maxsize:
        print(-1)
        return
    shortestPath = dist[end] % 1000000007 
    while True:
        end = prev[end]
        path.append(end)
        if end == start:
            break
    
    print(shortestPath)
    print(len(path))
    print("" "".join([ str(x) for x in path[::-1] ]))

solve()","import sys
import heapq

MOD = 1000000007

def dijkstra(n, graph, start, end):

    dist = [float('inf')] * (n + 1)
    dist[start] = 0

    prev = [-1] * (n + 1)

    pq = [(0, start)]
    
    while pq:
        current_dist, current_vertex = heapq.heappop(pq)

        if current_vertex == end:
            break

        if current_dist > dist[current_vertex]:
            continue

        for neighbor, weight in graph[current_vertex]:
            distance = current_dist + weight

            if distance < dist[neighbor]:
                dist[neighbor] = distance
                prev[neighbor] = current_vertex
                heapq.heappush(pq, (distance, neighbor))
    
    return dist, prev

def reconstruct_path(prev, start, end):
    path = []
    current = end
    while current != -1:
        path.append(current)
        current = prev[current]
    
    path.reverse()
    
    if path[0] == start:
        return path
    return []

def main():
    input = sys.stdin.read
    data = input().splitlines()

    n, m = map(int, data[0].split())

    graph = [[] for _ in range(n + 1)]

    for i in range(1, m + 1):
        u, v, x = map(int, data[i].split())
        weight = 2 ** x
        graph[u].append((v, weight))
        graph[v].append((u, weight))

    s, t = map(int, data[m + 1].split())

    dist, prev = dijkstra(n, graph, s, t)
    
    if dist[t] == float('inf'):
        print(-1)
    else:

        print(dist[t] % MOD)

        path = reconstruct_path(prev, s, t)
        print(len(path))
        print(' '.join(map(str, path)))

if __name__ == ""__main__"":
    main()"
253,C,Text Editor,PROGRAMMING,"['data structures', 'dfs and similar', 'graphs', 'greedy', 'shortest paths']","Vasya is pressing the keys on the keyboard reluctantly, squeezing out his ideas on the classical epos depicted in Homer's Odysseus... How can he explain to his literature teacher that he isn't going to become a writer? In fact, he is going to become a programmer. So, he would take great pleasure in writing a program, but none — in writing a composition.

As Vasya was fishing for a sentence in the dark pond of his imagination, he suddenly wondered: what is the least number of times he should push a key to shift the cursor from one position to another one?

Let's describe his question more formally: to type a text, Vasya is using the text editor. He has already written *n* lines, the *i*-th line contains *a**i* characters (including spaces). If some line contains *k* characters, then this line overall contains (*k*<=+<=1) positions where the cursor can stand: before some character or after all characters (at the end of the line). Thus, the cursor's position is determined by a pair of integers (*r*,<=*c*), where *r* is the number of the line and *c* is the cursor's position in the line (the positions are indexed starting from one from the beginning of the line).

Vasya doesn't use the mouse to move the cursor. He uses keys ""Up"", ""Down"", ""Right"" and ""Left"". When he pushes each of these keys, the cursor shifts in the needed direction. Let's assume that before the corresponding key is pressed, the cursor was located in the position (*r*,<=*c*), then Vasya pushed key:
-  ""Up"": if the cursor was located in the first line (*r*<==<=1), then it does not move. Otherwise, it moves to the previous line (with number *r*<=-<=1), to the same position. At that, if the previous line was short, that is, the cursor couldn't occupy position *c* there, the cursor moves to the last position of the line with number *r*<=-<=1;-  ""Down"": if the cursor was located in the last line (*r*<==<=*n*), then it does not move. Otherwise, it moves to the next line (with number *r*<=+<=1), to the same position. At that, if the next line was short, that is, the cursor couldn't occupy position *c* there, the cursor moves to the last position of the line with number *r*<=+<=1;-  ""Right"": if the cursor can move to the right in this line (*c*<=&lt;<=*a**r*<=+<=1), then it moves to the right (to position *c*<=+<=1). Otherwise, it is located at the end of the line and doesn't move anywhere when Vasya presses the ""Right"" key;-  ""Left"": if the cursor can move to the left in this line (*c*<=&gt;<=1), then it moves to the left (to position *c*<=-<=1). Otherwise, it is located at the beginning of the line and doesn't move anywhere when Vasya presses the ""Left"" key.
You've got the number of lines in the text file and the number of characters, written in each line of this file. Find the least number of times Vasya should push the keys, described above, to shift the cursor from position (*r*1,<=*c*1) to position (*r*2,<=*c*2).","The first line of the input contains an integer *n* (1<=≤<=*n*<=≤<=100) — the number of lines in the file. The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (0<=≤<=*a**i*<=≤<=105), separated by single spaces. The third line contains four integers *r*1,<=*c*1,<=*r*2,<=*c*2 (1<=≤<=*r*1,<=*r*2<=≤<=*n*,<=1<=≤<=*c*1<=≤<=*a**r*1<=+<=1,<=1<=≤<=*c*2<=≤<=*a**r*2<=+<=1).","Print a single integer — the minimum number of times Vasya should push a key to move the cursor from position (*r*1,<=*c*1) to position (*r*2,<=*c*2).","['4\n2 1 6 4\n3 4 4 2\n', '4\n10 5 6 4\n1 11 4 2\n', '3\n10 1 10\n1 10 1 1\n']","['3\n', '6\n', '3\n']","In the first sample the editor contains four lines. Let's represent the cursor's possible positions in the line as numbers. Letter *s* represents the cursor's initial position, letter *t* represents the last one. Then all possible positions of the cursor in the text editor are described by the following table.

123

12

123s567

1t345

One of the possible answers in the given sample is: ""Left"", ""Down"", ""Left"".",WRONG_ANSWER,"from collections import *
import sys

import heapq
import sys
def inpu(): return int(input())
def sep(): return map(int,input().split())
def lis(): return list(sep())
""""""
def main():
    f = open('input.txt','r')
    o = open('output.txt','w')
    b,g = map(int,f.readline().split())
    ans=""""
    if b>=g:
        i,j,k=0,0,0
        while(True):
            if i<b and j<g:
                ans+=""BG""
                i+=1
                j+=1
            elif i<b and j>=g:
                ans+=""B""
                i+=1
            else:
                break
    elif g>=b:
        i,j,k=0,0,0
        while(True):
            if i<b and j<g:
                ans+=""GB""
                i+=1
                j+=1
            elif i>=b and j<g:
                ans+=""G""
                j+=1
            else:
                break

    o.write(ans)
    o.close()
if __name__ == '__main__':
    main()
""""""
""""""
import sys
def main():
    sys.stdin = open(""input.txt"")
    sys.stdout = open(""output.txt"", 'w')
    b, g = map(int, input().split())
    ans = """"
    if b >= g:
        i, j, k = 0, 0, 0
        while (True):
            if i < b and j < g:
                ans += ""BG""
                i += 1
                j += 1
            elif i < b and j >= g:
                ans += ""B""
                i += 1
            else:
                break
    elif g >= b:
        i, j, k = 0, 0, 0
        while (True):
            if i < b and j < g:
                ans += ""GB""
                i += 1
                j += 1
            elif i >= b and j < g:
                ans += ""G""
                j += 1
            else:
                break
    print(ans)
if __name__ == '__main__':
    main()
""""""
def main():
    sys.stdin = open(""input.txt"")
    sys.stdout = open(""output.txt"", 'w')
    t = 1

    for _ in range(t):
        n=inpu()
        arr=lis()
        arr=[arr[i]+1 for i in range(n)]
        r1,c1,r2,c2=sep()
        ans=0
        if r1<r2:
            ans = 0
            while (r1<r2):

                if c1>arr[r1]:
                    ans+=1
                    c1=arr[r1]
                else:
                    ans+=1
                r1+=1
        elif r2<r1:
            ans = 0
            while(r1>r2):
                if c1-1>arr[r1-2]:
                    ans+=1
                    c1 = arr[r1-2]
                else:
                    ans+=1
                r1-=1
        if c1>c2:
            c1,c2 = c2,c1
        p,q = c1,c2
        rem = abs(p-q)
        stair = 0

        while(r1>1):

            stair+=1
            prev = min(arr[r1-1],c2)
            rem = min(rem,abs(prev-c1)+stair*2)
            c2=prev
            r1-=1
        stair=0
        c1,c2=p,q
        while(r2<n):

            stair+=1
            nex = min(arr[r2],c2)
            rem = min(rem,abs(nex-c1)+stair*2)
            c2=nex
            r2+=1

        print(ans+rem)
if __name__ == '__main__':
    main()","def min_key_presses(n, line_lengths, r1, c1, r2, c2):

    vertical_moves = abs(r2 - r1)

    if r2 <= n:
        target_length = line_lengths[r2 - 1]

        horizontal_moves = abs(c2 - min(c1, target_length))
    else:

        horizontal_moves = 0

    return vertical_moves + horizontal_moves

def main():
    import sys
    
    input_data = sys.stdin.read().strip().split('\n')
    
    n = int(input_data[0])
    line_lengths = list(map(int, input_data[1].split()))
    r1, c1, r2, c2 = map(int, input_data[2].split())

    result = min_key_presses(n, line_lengths, r1, c1, r2, c2)
    print(result)

if __name__ == ""__main__"":
    main()"
676,C,Vasya and String,PROGRAMMING,"['binary search', 'dp', 'strings', 'two pointers']","High school student Vasya got a string of length *n* as a birthday present. This string consists of letters 'a' and 'b' only. Vasya denotes beauty of the string as the maximum length of a substring (consecutive subsequence) consisting of equal letters.

Vasya can change no more than *k* characters of the original string. What is the maximum beauty of the string he can achieve?","The first line of the input contains two integers *n* and *k* (1<=≤<=*n*<=≤<=100<=000,<=0<=≤<=*k*<=≤<=*n*) — the length of the string and the maximum number of characters to change.

The second line contains the string, consisting of letters 'a' and 'b' only.",Print the only integer — the maximum beauty of the string Vasya can achieve by changing no more than *k* characters.,"['4 2\nabba\n', '8 1\naabaabaa\n']","['4\n', '5\n']","In the first sample, Vasya can obtain both strings ""aaaa"" and ""bbbb"".

In the second sample, the optimal answer is obtained with the string ""aaaaabaa"" or with the string ""aabaaaaa"".",RUNTIME_ERROR,"import sys

def solve(ch, subsequences):
	if len(subsequences[ch]) == 0:
		return 0
	start_i, end_i = subsequences[ch][0][0], subsequences[ch][0][1]
	max_len = end_i - start_i + k
	current_len = end_i - start_i 
	used_k = 0
	k_list = []
	ends = [end_i]
	for i in range(1, len(subsequences[ch])):
		next_start_i, next_end_i = subsequences[ch][i][0], subsequences[ch][i][1]
		distance = next_start_i - end_i
		used_k += distance
		k_list.append(used_k)
		if used_k > k:
			while used_k > k:
				used_k -= k_list.pop(0)
				start_i += ends.pop(0) + distance
		end_i = next_end_i
		current_len = end_i - start_i + (k - used_k)
		max_len = max(max_len , current_len)
	return max_len

in_f = sys.stdin.read(-1).replace(""\r\n"", ""\r"")
in_f = in_f.split()

n, k = int(in_f[0]), int(in_f[1])
s = in_f[2]
last_ch = s[0]
current_subsequence = [0, 0]
subsequences = {""a"": [], ""b"": []}
if n == 1:
	subsequences[s[0]].append([0, n])
else:
	for i in range(1, len(s)):
		current_ch = s[i]
		if current_ch != last_ch:
			current_subsequence[1] = i
			subsequences[last_ch].append(current_subsequence)
			last_ch = current_ch
			current_subsequence = [i, 0]
		if i == len(s) - 1:
			current_subsequence[1] = len(s)
			subsequences[current_ch].append(current_subsequence)
print(min(max(solve(""a"", subsequences), solve(""b"", subsequences)), n))","def max_beauty(n, k, s):
    max_length = 0

    for char in ('a', 'b'):
        left = 0
        count = 0
        
        for right in range(n):
            if s[right] != char:
                count += 1
            
            while count > k:
                if s[left] != char:
                    count -= 1
                left += 1
            
            max_length = max(max_length, right - left + 1)
        
    return max_length

n, k = map(int, input().split())
s = input().strip()

result = max_beauty(n, k, s)

print(result)"
557,C,Arthur and Table,PROGRAMMING,"['brute force', 'data structures', 'dp', 'greedy', 'math', 'sortings']","Arthur has bought a beautiful big table into his new flat. When he came home, Arthur noticed that the new table is unstable.

In total the table Arthur bought has *n* legs, the length of the *i*-th leg is *l**i*.

Arthur decided to make the table stable and remove some legs. For each of them Arthur determined number *d**i* — the amount of energy that he spends to remove the *i*-th leg.

A table with *k* legs is assumed to be stable if there are more than half legs of the maximum length. For example, to make a table with 5 legs stable, you need to make sure it has at least three (out of these five) legs of the maximum length. Also, a table with one leg is always stable and a table with two legs is stable if and only if they have the same lengths.

Your task is to help Arthur and count the minimum number of energy units Arthur should spend on making the table stable.","The first line of the input contains integer *n* (1<=≤<=*n*<=≤<=105) — the initial number of legs in the table Arthur bought.

The second line of the input contains a sequence of *n* integers *l**i* (1<=≤<=*l**i*<=≤<=105), where *l**i* is equal to the length of the *i*-th leg of the table.

The third line of the input contains a sequence of *n* integers *d**i* (1<=≤<=*d**i*<=≤<=200), where *d**i* is the number of energy units that Arthur spends on removing the *i*-th leg off the table.",Print a single integer — the minimum number of energy units that Arthur needs to spend in order to make the table stable.,"['2\n1 5\n3 2\n', '3\n2 4 4\n1 1 1\n', '6\n2 2 1 1 3 3\n4 3 5 5 2 1\n']","['2\n', '0\n', '8\n']",none,WRONG_ANSWER,"t = int(input())
inp_arr = []
for _ in range(t):
    inp_arr.append(input().split(' '))
multiset = {}
pattern_set = {}
odd = set(['1','3','5','7','9'])
even = set(['2','4','6','8','0'])
def add_value_to_multiset(val):
    num = str(val)
    curr = ''
    for i in num:
        curr += '1' if i in odd else '0'
    curr = '0'*(18-len(curr)) + curr
    if curr in multiset:
        if val in multiset[curr]:
            multiset[curr][val] += 1
        else:
            multiset[curr][val] = 1
    else:
        multiset[curr] = {val:1}

def remove_value_from_multiset(val):
    num = str(val)
    curr = ''
    for i in num:
        curr += '1' if i in odd else '0'
    curr = '0'*(18-len(curr)) + curr
    multiset[curr][val] -= 1

def count_value_from_multiset(pattern):
    count = 0
    pattern = '0'*(18-len(pattern)) + pattern

    if pattern in multiset:
        for val in multiset[pattern]:
            count += multiset[pattern][val]
    return count

for inp in inp_arr:

    if inp[0] == '+':
        add_value_to_multiset(int(inp[1]))
    elif inp[0] == '-':
        remove_value_from_multiset(int(inp[1]))
    else:
        print(count_value_from_multiset(inp[1]))","def min_energy_to_stabilize_table(n, lengths, energies):
    from collections import Counter

    length_counter = Counter(lengths)
    max_length = max(lengths)
    max_length_count = length_counter[max_length]

    required_count = (n // 2) + 1

    if max_length_count >= required_count:
        return 0

    legs_to_remove = required_count - max_length_count

    removal_options = []
    for i in range(n):
        if lengths[i] != max_length:
            removal_options.append((energies[i], lengths[i]))

    removal_options.sort()

    total_energy = 0
    for i in range(legs_to_remove):
        total_energy += removal_options[i][0]

    return total_energy

import sys

input_data = sys.stdin.read().strip().split('\n')
n = int(input_data[0])
lengths = list(map(int, input_data[1].split()))
energies = list(map(int, input_data[2].split()))

result = min_energy_to_stabilize_table(n, lengths, energies)
print(result)"
652,A,Gabriel and Caterpillar,PROGRAMMING,"['implementation', 'math']","The 9-th grade student Gabriel noticed a caterpillar on a tree when walking around in a forest after the classes. The caterpillar was on the height *h*1 cm from the ground. On the height *h*2 cm (*h*2<=&gt;<=*h*1) on the same tree hung an apple and the caterpillar was crawling to the apple.

Gabriel is interested when the caterpillar gets the apple. He noted that the caterpillar goes up by *a* cm per hour by day and slips down by *b* cm per hour by night.

In how many days Gabriel should return to the forest to see the caterpillar get the apple. You can consider that the day starts at 10 am and finishes at 10 pm. Gabriel's classes finish at 2 pm. You can consider that Gabriel noticed the caterpillar just after the classes at 2 pm.

Note that the forest is magic so the caterpillar can slip down under the ground and then lift to the apple.","The first line contains two integers *h*1,<=*h*2 (1<=≤<=*h*1<=&lt;<=*h*2<=≤<=105) — the heights of the position of the caterpillar and the apple in centimeters.

The second line contains two integers *a*,<=*b* (1<=≤<=*a*,<=*b*<=≤<=105) — the distance the caterpillar goes up by day and slips down by night, in centimeters per hour.","Print the only integer *k* — the number of days Gabriel should wait to return to the forest and see the caterpillar getting the apple.

If the caterpillar can't get the apple print the only integer <=-<=1.","['10 30\n2 1\n', '10 13\n1 1\n', '10 19\n1 2\n', '1 50\n5 4\n']","['1\n', '0\n', '-1\n', '1\n']","In the first example at 10 pm of the first day the caterpillar gets the height 26. At 10 am of the next day it slips down to the height 14. And finally at 6 pm of the same day the caterpillar gets the apple.

Note that in the last example the caterpillar was slipping down under the ground and getting the apple on the next day.",OK,"def solve(h1, h2, a, b):
    d = max(h2 - a * 8 - h1, 0)
    if d and a <= b:
        return -1
    x = max(1, (a - b) * 12)
    return (d + x - 1) // x

h1, h2 = map(int, input().split())
a, b = map(int, input().split())
print(solve(h1, h2, a, b))","def caterpillar_apple_days(h1, h2, a, b):

    effective_gain = a * 12 - b * 12

    if effective_gain <= 0:
        if h1 >= h2:
            return 0
        else:
            return -1
    
    days = 0
    current_height = h1

    while current_height < h2:
        days += 1

        current_height += a * 12

        if current_height >= h2:
            return days

        current_height -= b * 12
    
    return days

import sys
input = sys.stdin.read
data = input().strip().split('\n')

h1, h2 = map(int, data[0].split())

a, b = map(int, data[1].split())

result = caterpillar_apple_days(h1, h2, a, b)

print(result)"
496,B,Secret Combination,PROGRAMMING,"['brute force', 'constructive algorithms', 'implementation']","You got a box with a combination lock. The lock has a display showing *n* digits. There are two buttons on the box, each button changes digits on the display. You have quickly discovered that the first button adds 1 to all the digits (all digits 9 become digits 0), and the second button shifts all the digits on the display one position to the right (the last digit becomes the first one). For example, if the display is currently showing number 579, then if we push the first button, the display will show 680, and if after that we push the second button, the display will show 068.

You know that the lock will open if the display is showing the smallest possible number that can be obtained by pushing the buttons in some order. The leading zeros are ignored while comparing numbers. Now your task is to find the desired number.","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=1000) — the number of digits on the display.

The second line contains *n* digits — the initial state of the display.",Print a single line containing *n* digits — the desired state of the display containing the smallest possible number.,"['3\n579\n', '4\n2014\n']","['024\n', '0142\n']",none,WRONG_ANSWER,"length = int(input()) 
number = input() 
 
def add(n):
    num = str(n)
    s = """" 
    for i in num:
        ad = int(i) + 1  
        if(ad>9):
            ad = 0 
        s = s + str(ad)
    return s
    
def reverse(num):
    return num[-1] + num[:-1] 
    
dict_map ={} 
 
def recursion(num,height):
    if(height == 10):
        return num
    return min( min( int(add(num)),int(recursion(add(num) ,height+1)) )  , min(int(reverse(num))     ,int( recursion(reverse(num),height+1) ) ) ) 
    
    
ans = str(recursion(number,1))   
 
for each in range(len(ans) , length):
    ans = ""0"" + ans 
print(ans)","def get_smallest_number(n, digits):

    def press_first_button(num):
        return ''.join(str((int(d) + 1) % 10) for d in num)

    def press_second_button(num):
        return num[-1] + num[:-1]

    combinations = set()
    current_state = digits

    for _ in range(n):

        combinations.add(current_state)

        current_state = press_first_button(current_state)

        combinations.add(current_state)

        current_state = press_second_button(current_state)

    smallest_number = min(combinations)

    print(smallest_number)

n = int(input().strip())
digits = input().strip()

get_smallest_number(n, digits)"
629,C,Famil Door and Brackets,PROGRAMMING,"['dp', 'strings']","As Famil Door’s birthday is coming, some of his friends (like Gabi) decided to buy a present for him. His friends are going to buy a string consisted of round brackets since Famil Door loves string of brackets of length *n* more than any other strings!

The sequence of round brackets is called valid if and only if: 
 1.  the total number of opening brackets is equal to the total number of closing brackets; 1.  for any prefix of the sequence, the number of opening brackets is greater or equal than the number of closing brackets. 
Gabi bought a string *s* of length *m* (*m*<=≤<=*n*) and want to complete it to obtain a valid sequence of brackets of length *n*. He is going to pick some strings *p* and *q* consisting of round brackets and merge them in a string *p*<=+<=*s*<=+<=*q*, that is add the string *p* at the beginning of the string *s* and string *q* at the end of the string *s*.

Now he wonders, how many pairs of strings *p* and *q* exists, such that the string *p*<=+<=*s*<=+<=*q* is a valid sequence of round brackets. As this number may be pretty large, he wants to calculate it modulo 109<=+<=7.","First line contains *n* and *m* (1<=≤<=*m*<=≤<=*n*<=≤<=100<=000,<=*n*<=-<=*m*<=≤<=2000) — the desired length of the string and the length of the string bought by Gabi, respectively.

The second line contains string *s* of length *m* consisting of characters '(' and ')' only.",Print the number of pairs of string *p* and *q* such that *p*<=+<=*s*<=+<=*q* is a valid sequence of round brackets modulo 109<=+<=7.,"['4 1\n(\n', '4 4\n(())\n', '4 3\n(((\n']","['4\n', '1\n', '0\n']","In the first sample there are four different valid pairs: 
 1.  *p* = ""("", *q* = ""))"" 1.  *p* = ""()"", *q* = "")"" 1.  *p* = """", *q* = ""())"" 1.  *p* = """", *q* = "")()"" 
In the second sample the only way to obtain a desired string is choose empty *p* and *q*.

In the third sample there is no way to get a valid sequence of brackets.",WRONG_ANSWER,"import string
import sys
from sys import stdin, setrecursionlimit

input = stdin.readline
rd = lambda: map(lambda s: int(s), input().strip().split())
rdone = lambda: map(lambda s: int(s) - 1, input().strip().split())
ri = lambda: int(input())
rs = lambda: input().strip()
from collections import defaultdict as unsafedict, deque, Counter as unsafecounter
from bisect import bisect_left as bl, bisect_right as br

n,m=rd()
s=rs()
pref,mn=0,float(""inf"")
for i in s:
    pref+=[-1,1][i==""(""]
    mn=min(mn,pref)
dp=unsafedict(lambda :-1)
mod=10**9+7
dif=n-m
def rec(i,type,bal):
    if bal>2000 or bal<0 or i>dif:
        return 0
    if i==dif and type==1:
        return bal==0

    if dp[(i,type,bal)]!=-1:
        return dp[(i,type,bal)]
    ans=0
    if type==0:
        if mn>=0:
            ans=rec(i,1,bal+pref)
        elif mn<0 and (bal>abs(mn)):
            ans=rec(i,1,bal+pref)
        ans+=rec(i+1,0,bal-1)+rec(i+1,0,bal+1)
    else:
        ans+=rec(i+1,1,bal+1)+rec(i+1,1,bal-1)
    ans%=mod
    dp[(i,type,bal)]=ans
    return ans

print(rec(0,0,0))","def count_valid_pairs(n, m, s):
    MOD = 10**9 + 7

    open_count = s.count('(')
    close_count = s.count(')')

    required_open = (n - m) // 2
    required_close = (n - m) // 2

    if (n - m) % 2 != 0 or required_open < 0 or required_close < 0:
        return 0

    balance = open_count - close_count

    if balance + required_open < 0 or balance + required_close < 0:
        return 0

    total_pairs = 0
    for p in range(required_open + 1):
        q = (required_close + balance) - p
        if q >= 0 and q <= required_close:
            total_pairs += 1

    return total_pairs % MOD

import sys
input = sys.stdin.read
data = input().strip().split('\n')
results = []

for i in range(0, len(data), 2):
    n, m = map(int, data[i].split())
    s = data[i + 1]
    result = count_valid_pairs(n, m, s)
    results.append(str(result))

print(""\n"".join(results))"
98,B,Help King,PROGRAMMING,"['implementation', 'probabilities', 'trees']","This is the modification of the problem used during the official round. Unfortunately, author's solution of the original problem appeared wrong, so the problem was changed specially for the archive.

Once upon a time in a far away kingdom lived the King. The King had a beautiful daughter, Victoria. They lived happily, but not happily ever after: one day a vicious dragon attacked the kingdom and stole Victoria. The King was full of grief, yet he gathered his noble knights and promised half of his kingdom and Victoria's hand in marriage to the one who will save the girl from the infernal beast.

Having travelled for some time, the knights found the dragon's lair and all of them rushed there to save Victoria. Each knight spat on the dragon once and, as the dragon had quite a fragile and frail heart, his heart broke and poor beast died. As for the noble knights, they got Victoria right to the King and started brawling as each one wanted the girl's hand in marriage.

The problem was that all the noble knights were equally noble and equally handsome, and Victoria didn't want to marry any of them anyway. Then the King (and he was a very wise man and didn't want to hurt anybody's feelings) decided to find out who will get his daughter randomly, i.e. tossing a coin. However, there turned out to be *n* noble knights and the coin only has two sides. The good thing is that when a coin is tossed, the coin falls on each side with equal probability. The King got interested how to pick one noble knight using this coin so that all knights had equal probability of being chosen (the probability in that case should always be equal to 1<=/<=*n*). First the King wants to know the expected number of times he will need to toss a coin to determine the winner. Besides, while tossing the coin, the King should follow the optimal tossing strategy (i.e. the strategy that minimizes the expected number of tosses). Help the King in this challenging task.",The first line contains a single integer *n* from the problem's statement (1<=≤<=*n*<=≤<=10000).,"Print the sought expected number of tosses as an irreducible fraction in the following form: ""*a*/*b*"" (without the quotes) without leading zeroes.","['2\n', '3\n', '4\n']","['1/1\n', '8/3\n', '2/1\n']",none,COMPILATION_ERROR,"import math
from fractions import Fraction

knights = int(raw_input())

def ev(n):
    num_flips = int(math.ceil(math.log(n, 2)))
    num_states = 2**num_flips
    free_states = num_states - n
    if (free_states != 0) and (free_states != 1) and (n % free_states == 0):
        return ev(n / free_states) + Fraction(num_flips, 1)
    else:
        return Fraction(num_states * num_flips, num_states - free_states)
        
ans = ev(knights)
if len(str(ans)) == 1:
    print ans + '/1'
else:
    print ans","from math import gcd

def expected_tosses(n):

    if n == 1:
        return 1, 1

    dp = [0] * (n + 1)
    dp[1] = 1
    
    for i in range(2, n + 1):

        dp[i] = 2 * dp[i // 2] + (i % 2) * dp[i // 2 + 1] + 1

    numerator = dp[n]
    denominator = 1

    common_divisor = gcd(numerator, denominator)
    numerator //= common_divisor
    denominator //= common_divisor
    
    return numerator, denominator

if __name__ == ""__main__"":
    import sys
    input_data = sys.stdin.read().strip().split()
    
    results = []
    for line in input_data:
        n = int(line)
        a, b = expected_tosses(n)
        results.append(f""{a}/{b}"")
    
    print('\n'.join(results))"
190,D,Non-Secret Cypher,PROGRAMMING,['two pointers'],"Berland starts to seize the initiative on the war with Flatland. To drive the enemy from their native land, the berlanders need to know exactly how many more flatland soldiers are left in the enemy's reserve. Fortunately, the scouts captured an enemy in the morning, who had a secret encrypted message with the information the berlanders needed so much.

The captured enemy had an array of positive integers. Berland intelligence have long been aware of the flatland code: to convey the message, which contained a number *m*, the enemies use an array of integers *a*. The number of its subarrays, in which there are at least *k* equal numbers, equals *m*. The number *k* has long been known in the Berland army so General Touristov has once again asked Corporal Vasya to perform a simple task: to decipher the flatlanders' message.

Help Vasya, given an array of integers *a* and number *k*, find the number of subarrays of the array of numbers *a*, which has at least *k* equal numbers.

Subarray *a*[*i*... *j*] (1<=≤<=*i*<=≤<=*j*<=≤<=*n*) of array *a*<==<=(*a*1,<=*a*2,<=...,<=*a**n*) is an array, made from its consecutive elements, starting from the *i*-th one and ending with the *j*-th one: *a*[*i*... *j*]<==<=(*a**i*,<=*a**i*<=+<=1,<=...,<=*a**j*).","The first line contains two space-separated integers *n*, *k* (1<=≤<=*k*<=≤<=*n*<=≤<=4·105), showing how many numbers an array has and how many equal numbers the subarrays are required to have, correspondingly. 

The second line contains *n* space-separated integers *a**i* (1<=≤<=*a**i*<=≤<=109) — elements of the array.","Print the single number — the number of such subarrays of array *a*, that they have at least *k* equal integers.

Please do not use the %lld specifier to read or write 64-bit integers in С++. In is preferred to use the cin, cout streams or the %I64d specifier.","['4 2\n1 2 1 2\n', '5 3\n1 2 1 1 3\n', '3 1\n1 1 1\n']","['3', '2', '6']","In the first sample are three subarrays, containing at least two equal numbers: (1,2,1), (2,1,2) and (1,2,1,2).

In the second sample are two subarrays, containing three equal numbers: (1,2,1,1,3) and (1,2,1,1).

In the third sample any subarray contains at least one 1 number. Overall they are 6: (1), (1), (1), (1,1), (1,1) and (1,1,1).",TIME_LIMIT_EXCEEDED,"import sys 
import copy
from collections import Counter 

def n2(a, k):
    target = 0 
    valid = []
    for i in range(len(a)): 
        for j in range(i, len(a)):
            cnt = Counter(a[i:j+1])
            if max(cnt.values()) >= k: 
                target += 1 

                valid.append(f""[{i}, {j}]"")
    return target, valid 

if __name__ == ""__main__"":

    n, k = [int(x) for x in sys.stdin.readline().strip().split("" "")]
    a = [int(x) for x in sys.stdin.readline().strip().split("" "")]

    n2_target, n2_valid = n2(a, k)
    print(n2_target)","def count_subarrays_with_k_equal_numbers(n, k, a):
    from collections import defaultdict

    count = 0
    freq = defaultdict(int)
    left = 0

    for right in range(n):
        freq[a[right]] += 1

        while max(freq.values()) >= k:
            count += (n - right)
            freq[a[left]] -= 1
            left += 1

    return count

n, k = map(int, input().split())
a = list(map(int, input().split()))

result = count_subarrays_with_k_equal_numbers(n, k, a)
print(result)"
445,A,DZY Loves Chessboard,PROGRAMMING,"['dfs and similar', 'implementation']","DZY loves chessboard, and he enjoys playing with it.

He has a chessboard of *n* rows and *m* columns. Some cells of the chessboard are bad, others are good. For every good cell, DZY wants to put a chessman on it. Each chessman is either white or black. After putting all chessmen, DZY wants that no two chessmen with the same color are on two adjacent cells. Two cells are adjacent if and only if they share a common edge.

You task is to find any suitable placement of chessmen on the given chessboard.","The first line contains two space-separated integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=100).

Each of the next *n* lines contains a string of *m* characters: the *j*-th character of the *i*-th string is either ""."" or ""-"". A ""."" means that the corresponding cell (in the *i*-th row and the *j*-th column) is good, while a ""-"" means it is bad.","Output must contain *n* lines, each line must contain a string of *m* characters. The *j*-th character of the *i*-th string should be either ""W"", ""B"" or ""-"". Character ""W"" means the chessman on the cell is white, ""B"" means it is black, ""-"" means the cell is a bad cell.

If multiple answers exist, print any of them. It is guaranteed that at least one answer exists.","['1 1\n.\n', '2 2\n..\n..\n', '3 3\n.-.\n---\n--.']","['B\n', 'BW\nWB\n', 'B-B\n---\n--B']","In the first sample, DZY puts a single black chessman. Of course putting a white one is also OK.

In the second sample, all 4 cells are good. No two same chessmen share an edge in the sample output.

In the third sample, no good cells are adjacent. So you can just put 3 chessmen, no matter what their colors are.",WRONG_ANSWER,"def cast(cre, typ): return type(typ)(map(cre, typ));
def solution():
    n, m = cast(int, input().split());
    block = [""B"", ""W""];
    chess = [input() for i in range(n)];
    chess2 = ["""".join([block[(n+m)%2] for i in range(m)]) for i in range(n)]

    for i in range(n):
        for j in range(m):
            if chess[i][j] == ""."": print(chess2[i][j], end="""");
            else: print(""-"", end="""");
        print();
solution();","def place_chessmen(n, m, board):

    result = [['-' for _ in range(m)] for _ in range(n)]

    for i in range(n):
        for j in range(m):
            if board[i][j] == '.':

                if (i + j) % 2 == 0:
                    result[i][j] = 'B'
                else:
                    result[i][j] = 'W'

    return [''.join(row) for row in result]

inputs = [
    (1, 1, ['.']),
    (2, 2, ['..', '..']),
    (3, 3, ['.-.', '---', '--.'])
]

outputs = [place_chessmen(n, m, board) for n, m, board in inputs]

for output in outputs:
    print('\n'.join(output))"
460,B,Little Dima and Equation,PROGRAMMING,"['brute force', 'implementation', 'math', 'number theory']","Little Dima misbehaved during a math lesson a lot and the nasty teacher Mr. Pickles gave him the following problem as a punishment. 

Find all integer solutions *x* (0<=&lt;<=*x*<=&lt;<=109) of the equation:

where *a*, *b*, *c* are some predetermined constant values and function *s*(*x*) determines the sum of all digits in the decimal representation of number *x*.

The teacher gives this problem to Dima for each lesson. He changes only the parameters of the equation: *a*, *b*, *c*. Dima got sick of getting bad marks and he asks you to help him solve this challenging problem.","The first line contains three space-separated integers: *a*,<=*b*,<=*c* (1<=≤<=*a*<=≤<=5; 1<=≤<=*b*<=≤<=10000; <=-<=10000<=≤<=*c*<=≤<=10000).",Print integer *n* — the number of the solutions that you've found. Next print *n* integers in the increasing order — the solutions of the given equation. Print only integer solutions that are larger than zero and strictly less than 109.,"['3 2 8\n', '1 2 -18\n', '2 2 -1\n']","['3\n10 2008 13726 ', '0\n', '4\n1 31 337 967 ']",none,WRONG_ANSWER,"import sys
import pprint
import logging
from logging import getLogger

def input(): return sys.stdin.readline().rstrip(""\r\n"")

logging.basicConfig(format=""%(message)s"", level=logging.WARNING,)
logger = getLogger(__name__)
logger.setLevel(logging.INFO)

def debug(msg, *args):
    logger.info(f'{msg}={pprint.pformat(args)}')

def solve():
    a, b, c = inp()
    ans = []
    for i in range(1, 80):
        tobe = (b * pow(i, a)) + c
        if tobe < 0:
            continue

        if sum(map(int, str(tobe))) == i:
            ans.append(tobe)

    print(len(ans), '\n', *ans)

if __name__ == '__main__':
    multi = False
    t = 1

    def inp(): return map(int, input().split())

    if multi:
        t = int(input())

    while t:
        t -= 1
        solve()","def sum_of_digits(x):
    """"""Calculate the sum of digits of a given number x.""""""
    return sum(int(digit) for digit in str(x))

def find_solutions(a, b, c):
    """"""Find all integer solutions x that satisfy the equation x - s(x) = a * x^2 + b * x + c.""""""
    solutions = []

    for x in range(1, 10**9):
        s_x = sum_of_digits(x)
        if x - s_x == a * x**2 + b * x + c:
            solutions.append(x)

        if x > 10000:  
            break
    
    return solutions

if __name__ == ""__main__"":
    import sys
    
    input_data = sys.stdin.read().strip().splitlines()
    results = []
    
    for line in input_data:
        a, b, c = map(int, line.split())
        solutions = find_solutions(a, b, c)

        results.append(f""{len(solutions)}"")
        if solutions:
            results.append("" "".join(map(str, solutions)))
    
    print(""\n"".join(results))"
612,B,HDD is Outdated Technology,PROGRAMMING,"['implementation', 'math']","HDD hard drives group data by sectors. All files are split to fragments and each of them are written in some sector of hard drive. Note the fragments can be written in sectors in arbitrary order.

One of the problems of HDD hard drives is the following: the magnetic head should move from one sector to another to read some file.

Find the time need to read file split to *n* fragments. The *i*-th sector contains the *f**i*-th fragment of the file (1<=≤<=*f**i*<=≤<=*n*). Note different sectors contains the different fragments. At the start the magnetic head is in the position that contains the first fragment. The file are reading in the following manner: at first the first fragment is read, then the magnetic head moves to the sector that contains the second fragment, then the second fragment is read and so on until the *n*-th fragment is read. The fragments are read in the order from the first to the *n*-th.

It takes |*a*<=-<=*b*| time units to move the magnetic head from the sector *a* to the sector *b*. Reading a fragment takes no time.","The first line contains a positive integer *n* (1<=≤<=*n*<=≤<=2·105) — the number of fragments.

The second line contains *n* different integers *f**i* (1<=≤<=*f**i*<=≤<=*n*) — the number of the fragment written in the *i*-th sector.",Print the only integer — the number of time units needed to read the file.,"['3\n3 1 2\n', '5\n1 3 5 4 2\n']","['3\n', '10\n']","In the second example the head moves in the following way:
 -  1-&gt;2 means movement from the sector 1 to the sector 5, i.e. it takes 4 time units -  2-&gt;3 means movement from the sector 5 to the sector 2, i.e. it takes 3 time units -  3-&gt;4 means movement from the sector 2 to the sector 4, i.e. it takes 2 time units -  4-&gt;5 means movement from the sector 4 to the sector 3, i.e. it takes 1 time units 
So the answer to the second example is 4 + 3 + 2 + 1 = 10.",RUNTIME_ERROR,"n = int(input())
fragments = list(map(int, input().split()))

def create(dict, src, i, lim):
    dict[src[i]] = i + 1
    return create(dict, src, i + 1, lim) if i + 1 < lim else dict

fragmentsDict = create({}, fragments, 0, n)

comp = lambda res, i, d, lim: comp(res + abs(d[i] - d[i + 1]), i + 1, d, lim) if i < lim else res
print(comp(0, 1, fragmentsDict, n))","n = int(input().strip())

fragments = list(map(int, input().strip().split()))

sector_position = [0] * (n + 1)

for sector in range(n):
    fragment_number = fragments[sector]
    sector_position[fragment_number] = sector + 1

total_time = 0

for i in range(1, n):
    total_time += abs(sector_position[i] - sector_position[i + 1])

print(total_time)"
31,C,Schedule,PROGRAMMING,['implementation'],"At the beginning of the new semester there is new schedule in the Berland State University. According to this schedule, *n* groups have lessons at the room 31. For each group the starting time of the lesson and the finishing time of the lesson are known. It has turned out that it is impossible to hold all lessons, because for some groups periods of their lessons intersect. If at some moment of time one groups finishes it's lesson, and the other group starts the lesson, their lessons don't intersect.

The dean wants to cancel the lesson in one group so that no two time periods of lessons of the remaining groups intersect. You are to find all ways to do that.","The first line contains integer *n* (1<=≤<=*n*<=≤<=5000) — amount of groups, which have lessons in the room 31. Then *n* lines follow, each of them contains two integers *l**i* *r**i* (1<=≤<=*l**i*<=&lt;<=*r**i*<=≤<=106) — starting and finishing times of lesson of the *i*-th group. It is possible that initially no two lessons intersect (see sample 1).","Output integer *k* — amount of ways to cancel the lesson in exactly one group so that no two time periods of lessons of the remaining groups intersect. In the second line output *k* numbers — indexes of groups, where it is possible to cancel the lesson. Groups are numbered starting from 1 in the order that they were given in the input. Output the numbers in increasing order.","['3\n3 10\n20 30\n1 3\n', '4\n3 10\n20 30\n1 3\n1 39\n', '3\n1 5\n2 6\n3 7\n']","['3\n1 2 3 ', '1\n4 ', '0\n']",none,TIME_LIMIT_EXCEEDED,"def solution():
    def solve(people):
        n = len(people)
        
        people.sort(key=lambda x: x[1])

        res = []
        tot = 0
        for i in range(n):
            curr, interval = 0, True
            for j in range(n):
                if i != j:
                    if people[j][1] >= curr:
                        curr = people[j][2]
                    else:
                        interval = False
            if interval:
                tot += 1
                res.append(people[i][0] + 1)
        res.sort()
        print(tot)
        print(*res)
            

    t = int(input())
    people = []
    for i in range(t):
        people.append([i, *[int(x) for x in input().split()]])
    solve(people)
solution()","def can_cancel_lessons(n, schedules):

    result_indices = []

    for i in range(n):

        remaining_groups = [schedules[j] for j in range(n) if j != i]

        remaining_groups.sort()

        no_conflict = True
        current_end_time = 0
        
        for start, end in remaining_groups:
            if start < current_end_time:
                no_conflict = False
                break
            current_end_time = end
        
        if no_conflict:
            result_indices.append(i + 1)
            
    return len(result_indices), result_indices

n = int(input().strip())
schedules = [tuple(map(int, input().strip().split())) for _ in range(n)]

k, indices = can_cancel_lessons(n, schedules)

print(k)
if k > 0:
    print(' '.join(map(str, indices)))"
78,C,Beaver Game,PROGRAMMING,"['dp', 'games', 'number theory']","Two beavers, Timur and Marsel, play the following game.

There are *n* logs, each of exactly *m* meters in length. The beavers move in turns. For each move a beaver chooses a log and gnaws it into some number (more than one) of equal parts, the length of each one is expressed by an integer and is no less than *k* meters. Each resulting part is also a log which can be gnawed in future by any beaver. The beaver that can't make a move loses. Thus, the other beaver wins.

Timur makes the first move. The players play in the optimal way. Determine the winner.","The first line contains three integers *n*, *m*, *k* (1<=≤<=*n*,<=*m*,<=*k*<=≤<=109).","Print ""Timur"", if Timur wins, or ""Marsel"", if Marsel wins. You should print everything without the quotes.","['1 15 4\n', '4 9 5\n']","['Timur', 'Marsel']","In the first sample the beavers only have one log, of 15 meters in length. Timur moves first. The only move he can do is to split the log into 3 parts each 5 meters in length. Then Marsel moves but he can't split any of the resulting logs, as *k* = 4. Thus, the winner is Timur.

In the second example the beavers have 4 logs 9 meters in length. Timur can't split any of them, so that the resulting parts possessed the length of not less than 5 meters, that's why he loses instantly.",WRONG_ANSWER,"from sys import stdin, stdout

def check(m, k):
    for i in range(1, int(m ** 0.5) + 1):
        if not m % i and (i >= k or m // i >= k):
            return 1
    else:
        return 0

n, m, k = map(int, stdin.readline().split())

if m < 2 * k or not check(m, k):
    stdout.write('Marsel')
elif n % 2:
    stdout.write('Timur')
else:
    stdout.write('Marsel')","def can_gnaw(log_length, k):

    for i in range(2, log_length // k + 1):
        if log_length % i == 0:
            return True
    return False

def determine_winner(n, m, k):

    if not can_gnaw(m, k):
        return ""Marsel""

    return ""Timur""

input_data = ['1 15 4\n', '4 9 5\n']
results = []

for line in input_data:
    n, m, k = map(int, line.strip().split())
    winner = determine_winner(n, m, k)
    results.append(winner)

print(results)"
46,B,T-shirts from Sponsor,PROGRAMMING,['implementation'],"One day a well-known sponsor of a well-known contest decided to give every participant of the contest a T-shirt as a present. A natural problem occurred: on the one hand, it is not clear how many T-shirts of what sizes should be ordered, and on the other hand, one doesn't want to order too many T-shirts (and we do not exactly paper the walls with the oversupply). After considerable brain racking and some pre-estimating, the sponsor representatives ordered a certain number of T-shirts of sizes S, M, L, XL and XXL. The T-shirts turned out to bring good luck, that's why on the contest day there built up a line of *K* participants willing to get one. Every contestant is characterized by his/her desired T-shirt size (so it happens that for all the participants it is also one of the sizes S, M, L, XL and XXL). The participants come up to get a T-shirt one by one and try to choose the most suitable one, choosing it like this. If there is still a T-shirt of the optimal size left, that he/she takes it without further ado. Otherwise the contestant would prefer to choose a T-shirt with the size as close to the optimal one as possible (the distance between neighboring sizes is considered equal to one). If the variant of choice is not unique, the contestant will take a T-shirt of a bigger size (in case he/she grows more). For example, for a person whose optimal size is L the preference list looks like this: L, XL, M, XXL, S. Using the data on how many T-shirts of every size had been ordered by the organizers, on the size of contestants in the line determine who got a T-shirt of what size.","The first line contains five non-negative integers *N**S*,<=*N**M*,<=*N**L*,<=*N**XL*,<=*N**XXL* not exceeding 1000 which represent the number of T-shirts of the corresponding sizes. The second line contains an integer *K* (1<=≤<=*K*<=≤<=1000) which represents the number of participants. The next *K* lines contain the optimal T-shirt sizes for the contestants. The sizes are given in the order in which the participants stand in the line. It is guaranteed that *N**S*<=+<=*N**M*<=+<=*N**L*<=+<=*N**XL*<=+<=*N**XXL*<=≥<=*K*.","For each contestant, print a line containing the size of the T-shirt he/she got.",['1 0 2 0 1\n3\nXL\nXXL\nM\n'],['XXL\nL\nL\n'],none,OK,"import math,sys;input=sys.stdin.readline;S=lambda:input().rstrip();I=lambda:int(S());M=lambda:map(int,S().split());L=lambda:list(M());mod1=1000000007;mod2=998244353
from collections import defaultdict
d = defaultdict()
d[""S""],d[""M""],d[""L""],d[""XL""],d[""XXL""] = M()
valst = defaultdict()
valst[0],valst[1],valst[2],valst[3],valst[4] = ""S"",""M"",""L"",""XL"",""XXL""

k = I()
for i in range(k):
    p = S()
    if d[p]!=0:
        print(p)
        d[p]-=1
    else:
        if p==""S"":
            j =0
            k=0
        elif p==""M"":
            j=1
            k=1
        elif p==""L"":
            j=2
            k=2
        elif p==""XL"":
            j=3
            k=3
        elif p==""XXL"":
            j=4
            k=4

        pos = j
        
        while j<4 and d[valst[j]]==0  :
            j+=1
        while k>0 and d[valst[k]]==0  :
            k-=1
        
        if d[valst[j]]!=0 and d[valst[k]]!=0:
            if abs(pos-j)<=abs(pos-k):
                print(valst[j])
                d[valst[j]]-=1
            else:
                print(valst[k])
                d[valst[k]]-=1
        elif d[valst[j]]!=0 and d[valst[k]]==0:
            print(valst[j])
            d[valst[j]]-=1
        else:
            print(valst[k])
            d[valst[k]]-=1","sizes = ['S', 'M', 'L', 'XL', 'XXL']

stock = list(map(int, input().split()))

K = int(input())

results = []

for _ in range(K):
    desired_size = input().strip()
    preferred_index = sizes.index(desired_size)

    for offset in range(3):

        if preferred_index + offset < len(sizes) and stock[preferred_index + offset] > 0:

            results.append(sizes[preferred_index + offset])
            stock[preferred_index + offset] -= 1
            break
        elif preferred_index - offset >= 0 and stock[preferred_index - offset] > 0:

            results.append(sizes[preferred_index - offset])
            stock[preferred_index - offset] -= 1
            break

for result in results:
    print(result)"
429,B,Working out,PROGRAMMING,['dp'],"Summer is coming! It's time for Iahub and Iahubina to work out, as they both want to look hot at the beach. The gym where they go is a matrix *a* with *n* lines and *m* columns. Let number *a*[*i*][*j*] represents the calories burned by performing workout at the cell of gym in the *i*-th line and the *j*-th column.

Iahub starts with workout located at line 1 and column 1. He needs to finish with workout *a*[*n*][*m*]. After finishing workout *a*[*i*][*j*], he can go to workout *a*[*i*<=+<=1][*j*] or *a*[*i*][*j*<=+<=1]. Similarly, Iahubina starts with workout *a*[*n*][1] and she needs to finish with workout *a*[1][*m*]. After finishing workout from cell *a*[*i*][*j*], she goes to either *a*[*i*][*j*<=+<=1] or *a*[*i*<=-<=1][*j*]. 

There is one additional condition for their training. They have to meet in exactly one cell of gym. At that cell, none of them will work out. They will talk about fast exponentiation (pretty odd small talk) and then both of them will move to the next workout.

If a workout was done by either Iahub or Iahubina, it counts as total gain. Please plan a workout for Iahub and Iahubina such as total gain to be as big as possible. Note, that Iahub and Iahubina can perform workouts with different speed, so the number of cells that they use to reach meet cell may differs.","The first line of the input contains two integers *n* and *m* (3<=≤<=*n*,<=*m*<=≤<=1000). Each of the next *n* lines contains *m* integers: *j*-th number from *i*-th line denotes element *a*[*i*][*j*] (0<=≤<=*a*[*i*][*j*]<=≤<=105).",The output contains a single number — the maximum total gain possible.,['3 3\n100 100 100\n100 1 100\n100 100 100\n'],['800'],Iahub will choose exercises *a*[1][1] → *a*[1][2] → *a*[2][2] → *a*[3][2] → *a*[3][3]. Iahubina will choose exercises *a*[3][1] → *a*[2][1] → *a*[2][2] → *a*[2][3] → *a*[1][3].,RUNTIME_ERROR,"import sys
input = sys.stdin.buffer.readline 

def process(A):
    n = len(A)
    m = len(A[0])
    d = {}
    for i in range(n):
        for j in range(m):
            d[(i, j)] = [0, 0, 0, 0]
            if i > 0:
                above = d[(i-1, j)][0]
            else:
                above = 0
            if j > 0:
                left = d[(i, j-1)][0]
            else:
                left = 0
            d[(i, j)][0] = A[i][j]+max(left, above)
        for j in range(m-1, -1, -1):
            if i > 0:
                above = d[(i-1, j)][1]
            else:
                above = 0
            if j < m-1:
                right = d[(i, j+1)][1]
            else:
                right = 0
            d[(i, j)][1] = A[i][j]+max(above, right)
            
    for i in range(n-1, -1, -1):
        for j in range(m):
            if i  < n-1:
                below = d[(i+1, j)][2]
            else:
                below = 0
            if j > 0:
                left = d[(i, j-1)][2]
            else:
                left = 0
            d[(i, j)][2] = A[i][j]+max(left, below)
        for j in range(m-1, -1, -1):
            if i < n-1:
                below = d[(i+1, j)][3]
            else:
                below = 0
            if j < m-1:
                right = d[(i, j+1)][3]
            else:
                right = 0
            d[(i, j)][3] = A[i][j]+max(below, right)
    answer = -1*float('inf')
    for i in range(n):
        for j in range(m):
            answer = max(answer, sum(d[(i, j)])-4*A[i][j])
    return answer
      
n, m = [int(x) for x in input().split()]
A = []
for i in range(n):
    row = [int(x) for x in input().split()]
    A.append(row)
print(process(row))","def max_total_gain(n, m, a):

    ihub = [[0] * m for _ in range(n)]
    ihubina = [[0] * m for _ in range(n)]

    ihub[0][0] = a[0][0]

    for i in range(n):
        for j in range(m):
            if i == 0 and j == 0:
                continue
            up = ihub[i - 1][j] if i > 0 else 0
            left = ihub[i][j - 1] if j > 0 else 0
            ihub[i][j] = max(up, left) + a[i][j]

    ihubina[n-1][0] = a[n-1][0]

    for i in range(n-1, -1, -1):
        for j in range(m):
            if i == n-1 and j == 0:
                continue
            down = ihubina[i + 1][j] if i < n - 1 else 0
            left = ihubina[i][j - 1] if j > 0 else 0
            ihubina[i][j] = max(down, left) + a[i][j]

    max_gain = 0
    for i in range(n):
        for j in range(m):

            gain = ihub[i][j] + ihubina[i][j] - a[i][j]
            max_gain = max(max_gain, gain)

    return max_gain

n, m = map(int, input().split())
a = [list(map(int, input().split())) for _ in range(n)]

result = max_total_gain(n, m, a)
print(result)"
186,B,Growing Mushrooms,PROGRAMMING,"['greedy', 'sortings']","Each year in the castle of Dwarven King there is a competition in growing mushrooms among the dwarves. The competition is one of the most prestigious ones, and the winner gets a wooden salad bowl. This year's event brought together the best mushroom growers from around the world, so we had to slightly change the rules so that the event gets more interesting to watch.

Each mushroom grower has a mushroom that he will grow on the competition. Under the new rules, the competition consists of two parts. The first part lasts *t*1 seconds and the second part lasts *t*2 seconds. The first and the second part are separated by a little break.

After the starting whistle the first part of the contest starts, and all mushroom growers start growing mushrooms at once, each at his individual speed of *v**i* meters per second. After *t*1 seconds, the mushroom growers stop growing mushrooms and go to have a break. During the break, for unexplained reasons, the growth of all mushrooms is reduced by *k* percent. After the break the second part of the contest starts and all mushrooms growers at the same time continue to grow mushrooms, each at his individual speed of *u**i* meters per second. After a *t*2 seconds after the end of the break, the competition ends. Note that the speeds before and after the break may vary.

Before the match dwarf Pasha learned from all participants, what two speeds they have chosen. However, the participants did not want to disclose to him all their strategy and therefore, did not say in what order they will be using these speeds. That is, if a participant chose speeds *a**i* and *b**i*, then there are two strategies: he either uses speed *a**i* before the break and speed *b**i* after it, or vice versa.

Dwarf Pasha really wants to win the totalizer. He knows that each participant chooses the strategy that maximizes the height of the mushroom. Help Dwarf Pasha make the final table of competition results.

The participants are sorted in the result table by the mushroom height (the participants with higher mushrooms follow earlier in the table). In case of equal mushroom heights, the participants are sorted by their numbers (the participants with a smaller number follow earlier).","The first input line contains four integer numbers *n*, *t*1, *t*2, *k* (1<=≤<=*n*,<=*t*1,<=*t*2<=≤<=1000; 1<=≤<=*k*<=≤<=100) — the number of participants, the time before the break, the time after the break and the percentage, by which the mushroom growth drops during the break, correspondingly.

Each of the following *n* lines contains two integers. The *i*-th (1<=≤<=*i*<=≤<=*n*) line contains space-separated integers *a**i*, *b**i* (1<=≤<=*a**i*,<=*b**i*<=≤<=1000) — the speeds which the participant number *i* chose.","Print the final results' table: *n* lines, each line should contain the number of the corresponding dwarf and the final maximum height of his mushroom with exactly two digits after the decimal point. The answer will be considered correct if it is absolutely accurate.","['2 3 3 50\n2 4\n4 2\n', '4 1 1 1\n544 397\n280 101\n280 101\n693 970\n']","['1 15.00\n2 15.00\n', '4 1656.07\n1 937.03\n2 379.99\n3 379.99\n']","-  First example: for each contestant it is optimal to use firstly speed 2 and afterwards speed 4, because 2·3·0.5 + 4·3 &gt; 4·3·0.5 + 2·3.",OK,"def main():

    n, t1, t2, k = [int(i) for i in input().split()]

    v = []
    for i in range(n):
        a, b = [int(i) for i in input().split()]
        v.append([a, b])

    res = []
    for i in range(n):
        a, b = v[i]

        h1 = a * t1 * (1 - k / 100) + b * t2
        h2 = b * t1 * (1 - k / 100) + a * t2

        h = max(h1, h2)

        res.append([i + 1, h])

    for i, rec in sorted(res, key=lambda x: x[1], reverse=True):
        print(f'{i} {rec:.2f}')

if __name__ == '__main__':
    main()","def calculate_mushroom_height(a, b, t1, t2, k):

    reduction_factor = (100 - k) / 100
    height1 = a * t1 * reduction_factor + b * t2
    height2 = b * t1 * reduction_factor + a * t2
    return max(height1, height2)

def main():
    import sys

    input_data = sys.stdin.read().strip().split('\n')
    n, t1, t2, k = map(int, input_data[0].split())
    
    results = []
    
    for i in range(1, n + 1):
        a, b = map(int, input_data[i].split())
        max_height = calculate_mushroom_height(a, b, t1, t2, k)
        results.append((i, max_height))

    results.sort(key=lambda x: (-x[1], x[0]))

    for participant, height in results:
        print(f""{participant} {height:.2f}"")

if __name__ == ""__main__"":
    main()"
441,C,Valera and Tubes ,PROGRAMMING,"['constructive algorithms', 'dfs and similar', 'implementation']","Valera has got a rectangle table consisting of *n* rows and *m* columns. Valera numbered the table rows starting from one, from top to bottom and the columns – starting from one, from left to right. We will represent cell that is on the intersection of row *x* and column *y* by a pair of integers (*x*,<=*y*).

Valera wants to place exactly *k* tubes on his rectangle table. A tube is such sequence of table cells (*x*1,<=*y*1), (*x*2,<=*y*2), ..., (*x**r*,<=*y**r*), that: 
 -  *r*<=≥<=2; -  for any integer *i* (1<=≤<=*i*<=≤<=*r*<=-<=1) the following equation |*x**i*<=-<=*x**i*<=+<=1|<=+<=|*y**i*<=-<=*y**i*<=+<=1|<==<=1 holds; -  each table cell, which belongs to the tube, must occur exactly once in the sequence. 
Valera thinks that the tubes are arranged in a fancy manner if the following conditions are fulfilled: 
 -  no pair of tubes has common cells; -  each cell of the table belongs to some tube. 
Help Valera to arrange *k* tubes on his rectangle table in a fancy manner.","The first line contains three space-separated integers *n*,<=*m*,<=*k* (2<=≤<=*n*,<=*m*<=≤<=300; 2<=≤<=2*k*<=≤<=*n*·*m*) — the number of rows, the number of columns and the number of tubes, correspondingly.","Print *k* lines. In the *i*-th line print the description of the *i*-th tube: first print integer *r**i* (the number of tube cells), then print 2*r**i* integers *x**i*1,<=*y**i*1,<=*x**i*2,<=*y**i*2,<=...,<=*x**ir**i*,<=*y**ir**i* (the sequence of table cells).

If there are multiple solutions, you can print any of them. It is guaranteed that at least one solution exists.","['3 3 3\n', '2 3 1\n']","['3 1 1 1 2 1 3\n3 2 1 2 2 2 3\n3 3 1 3 2 3 3\n', '6 1 1 1 2 1 3 2 3 2 2 2 1\n']","Picture for the first sample: 

Picture for the second sample:",OK,"def print_tube(a):
	print(len(a),end = "" "")
	print("" "".join(map(lambda x: "" "".join(str(i) for i in x), a)))
n, m, k = map(int, input().split())
res = [(x+1,y+1) for x in range(n) for y in range(m)[::(1 if (x%2 == 0) else -1)]]
for i in range(k-1):
	print_tube(res[2*i:2*i+2])
print_tube(res[2*k-2:])","def arrange_tubes(n, m, k):

    result = []

    count = 0
    for i in range(n):
        for j in range(m):

            if count % 2 == 0:
                tube = []
                if j < m - 1:
                    tube.append((i + 1, j + 1))
                    tube.append((i + 1, j + 2))
                    count += 2
                else:
                    tube.append((i + 1, j + 1))
                    count += 1

                if len(tube) == 2:
                    result.append(tube)
            else:
                tube = []
                tube.append((i + 1, j + 1))
                count += 1
                result.append(tube)

    if len(result) > k:
        result = result[:k]

    output = []
    for tube in result:
        line = f""{len(tube)} "" + "" "".join(f""{x} {y}"" for x, y in tube)
        output.append(line)

    return output

n, m, k = map(int, input().split())

tubes = arrange_tubes(n, m, k)

for tube in tubes:
    print(tube)"
169,A,Chores,PROGRAMMING,['sortings'],"Petya and Vasya are brothers. Today is a special day for them as their parents left them home alone and commissioned them to do *n* chores. Each chore is characterized by a single parameter — its complexity. The complexity of the *i*-th chore equals *h**i*.

As Petya is older, he wants to take the chores with complexity larger than some value *x* (*h**i*<=&gt;<=*x*) to leave to Vasya the chores with complexity less than or equal to *x* (*h**i*<=≤<=*x*). The brothers have already decided that Petya will do exactly *a* chores and Vasya will do exactly *b* chores (*a*<=+<=*b*<==<=*n*).

In how many ways can they choose an integer *x* so that Petya got exactly *a* chores and Vasya got exactly *b* chores?","The first input line contains three integers *n*,<=*a* and *b* (2<=≤<=*n*<=≤<=2000; *a*,<=*b*<=≥<=1; *a*<=+<=*b*<==<=*n*) — the total number of chores, the number of Petya's chores and the number of Vasya's chores.

The next line contains a sequence of integers *h*1,<=*h*2,<=...,<=*h**n* (1<=≤<=*h**i*<=≤<=109), *h**i* is the complexity of the *i*-th chore. The numbers in the given sequence are not necessarily different.

All numbers on the lines are separated by single spaces.","Print the required number of ways to choose an integer value of *x*. If there are no such ways, print 0.","['5 2 3\n6 2 3 100 1\n', '7 3 4\n1 1 9 1 1 1 1\n']","['3\n', '0\n']","In the first sample the possible values of *x* are 3, 4 or 5.

In the second sample it is impossible to find such *x*, that Petya got 3 chores and Vasya got 4.",OK,"miLista = []
enter = input().split()
n = int(enter[0])
a = int(enter[1])
b = int(enter[2])
2<=n<=2000

def bubbleSort(tareas):
	for long in range (len(tareas) -1, 0, -1):
		for i in range (0, long):
			if tareas[i] > tareas[i + 1]:
				temp = tareas[i]
				tareas[i] = tareas[i + 1]
				tareas[i + 1] = temp

tareas = []
numbers = input().split()
for i in range (0,n):
	tareas.append(int(numbers[i]))

if (a + b == n):
    bubbleSort(tareas)
    print(tareas[b] - tareas[b-1])
else: 
    print(""Error, el numero de tareas por persona no coincide con el no de tareas totales"")","def count_ways(n, a, b, h):

    h.sort()

    if a + b > n:
        return 0

    count = 0

    for i in range(n - 1):
        if i + 1 < a or i + 1 > n - b:
            continue

        if h[i] < h[i + 1]:
            count += 1
            
    return count

import sys
input_lines = sys.stdin.read().strip().split('\n')

results = []
for i in range(0, len(input_lines), 2):

    n, a, b = map(int, input_lines[i].split())

    h = list(map(int, input_lines[i + 1].split()))

    ways = count_ways(n, a, b, h)
    results.append(f""{ways}\n"")

print(''.join(results))"
394,A,Counting Sticks,PROGRAMMING,"['brute force', 'implementation']","When new students come to the Specialized Educational and Scientific Centre (SESC) they need to start many things from the beginning. Sometimes the teachers say (not always unfairly) that we cannot even count. So our teachers decided to teach us arithmetics from the start. And what is the best way to teach students add and subtract? — That's right, using counting sticks! An here's our new task: 

An expression of counting sticks is an expression of type:

Sign + consists of two crossed sticks: one vertical and one horizontal. Sign = consists of two horizontal sticks. The expression is arithmetically correct if *A*<=+<=*B*<==<=*C*.

We've got an expression that looks like *A*<=+<=*B*<==<=*C* given by counting sticks. Our task is to shift at most one stick (or we can shift nothing) so that the expression became arithmetically correct. Note that we cannot remove the sticks from the expression, also we cannot shift the sticks from the signs + and =.

We really aren't fabulous at arithmetics. Can you help us?","The single line contains the initial expression. It is guaranteed that the expression looks like *A*<=+<=*B*<==<=*C*, where 1<=≤<=*A*,<=*B*,<=*C*<=≤<=100.","If there isn't a way to shift the stick so the expression becomes correct, print on a single line ""Impossible"" (without the quotes). If there is a way, print the resulting expression. Follow the format of the output from the test samples. Don't print extra space characters.

If there are multiple correct answers, print any of them. For clarifications, you are recommended to see the test samples.","['||+|=|||||\n', '|||||+||=||\n', '|+|=||||||\n', '||||+||=||||||\n']","['|||+|=||||\n', 'Impossible\n', 'Impossible\n', '||||+||=||||||\n']","In the first sample we can shift stick from the third group of sticks to the first one.

In the second sample we cannot shift vertical stick from + sign to the second group of sticks. So we cannot make a - sign.

There is no answer in the third sample because we cannot remove sticks from the expression.

In the forth sample the initial expression is already arithmetically correct and that is why we don't have to shift sticks.",WRONG_ANSWER,"import re
def count(x):
	return x.count(""|"")
text = input()
x=(re.split('\+|\=',text))
lst=list(map(count,x))
if x[0]+x[1]==x[2]:
	print(x[0]+""+""+x[1]+""=""+x[2])
elif (lst[0]-1)+(lst[1]+1)==lst[2]:
	print(""|""*(lst[0]-1)+""+""+""|""*(lst[1]+1)+""=""+""|""*lst[2])
elif (lst[0]+1)+(lst[1]-1)==lst[2]:
	print(""|""*(lst[0]+1)+""+""+""|""*(lst[1]-1)+""=""+""|""*lst[2])
elif (lst[0]-1)+(lst[1])==lst[2]+1:
	print(""|""*(lst[0]-1)+""+""+""|""*(lst[1])+""=""+""|""*(lst[2]+1))
elif (lst[0]+1)+(lst[1])==lst[2]-1:
	print(""|""*(lst[0]+1)+""+""+""|""*(lst[1])+""=""+""|""*(lst[2]-1))
elif (lst[0])+(lst[1]+1)==lst[2]-1:
	print(""|""*(lst[0])+""+""+""|""*(lst[1]+1)+""=""+""|""*(lst[2]-1))
elif (lst[0])+(lst[1]+1)==lst[2]+1:
	print(""|""*(lst[0])+""+""+""|""*(lst[1]-1)+""=""+""|""*(lst[2]+1))
else:
	print(""Impossible"")","def adjust_sticks(expr):

    parts = expr.strip().split('<=')
    A = len(parts[0])
    B = len(parts[1].replace('+', ''))
    C = len(parts[2].replace('=', ''))

    if A <= B <= C:
        return expr.strip()

    if A > 0:
        A -= 1
        B += 1
        if A <= B <= C:
            return f'{""|"" * A}<={""|"" * B}+{""|"" * (len(parts[1]) - 2)}<={""|"" * C}'

    if B > 0:
        B -= 1
        A += 1
        if A <= B <= C:
            return f'{""|"" * A}<={""|"" * B}+{""|"" * (len(parts[1]) - 2)}<={""|"" * C}'

    if B < C:
        B += 1
        C -= 1
        if A <= B <= C:
            return f'{""|"" * A}<={""|"" * B}+{""|"" * (len(parts[1]) - 2)}<={""|"" * C}'

    if C > 0:
        C -= 1
        B += 1
        if A <= B <= C:
            return f'{""|"" * A}<={""|"" * B}+{""|"" * (len(parts[1]) - 2)}<={""|"" * C}'

    return ""Impossible""

input_data = ['||+|=|||||\n', '|||||+||=||\n', '|+|=||||||\n', '||||+||=||||||\n']

output_data = [adjust_sticks(expr) for expr in input_data]

print(output_data)"
136,A,Presents,PROGRAMMING,['implementation'],"Little Petya very much likes gifts. Recently he has received a new laptop as a New Year gift from his mother. He immediately decided to give it to somebody else as what can be more pleasant than giving somebody gifts. And on this occasion he organized a New Year party at his place and invited *n* his friends there.

If there's one thing Petya likes more that receiving gifts, that's watching others giving gifts to somebody else. Thus, he safely hid the laptop until the next New Year and made up his mind to watch his friends exchanging gifts while he does not participate in the process. He numbered all his friends with integers from 1 to *n*. Petya remembered that a friend number *i* gave a gift to a friend number *p**i*. He also remembered that each of his friends received exactly one gift.

Now Petya wants to know for each friend *i* the number of a friend who has given him a gift.",The first line contains one integer *n* (1<=≤<=*n*<=≤<=100) — the quantity of friends Petya invited to the party. The second line contains *n* space-separated integers: the *i*-th number is *p**i* — the number of a friend who gave a gift to friend number *i*. It is guaranteed that each friend received exactly one gift. It is possible that some friends do not share Petya's ideas of giving gifts to somebody else. Those friends gave the gifts to themselves.,Print *n* space-separated integers: the *i*-th number should equal the number of the friend who gave a gift to friend number *i*.,"['4\n2 3 4 1\n', '3\n1 3 2\n', '2\n1 2\n']","['4 1 2 3\n', '1 3 2\n', '1 2\n']",none,OK,"def find_gift_givers(n, gift_receivers):
    gift_givers = [0] * t
    for i in range(t):
        gift_givers[gift_receivers[i] - 1] = i + 1
    return gift_givers
 
t = int(input())
gift_receivers = list(map(int, input().split()))
 
result = find_gift_givers(t, gift_receivers)
print(*result)","n = int(input().strip())

p = list(map(int, input().strip().split()))

gifts = [0] * n

for i in range(n):

    gifts[p[i] - 1] = i + 1

print(' '.join(map(str, gifts)))"
412,A,Poster,PROGRAMMING,"['greedy', 'implementation']","The R1 company has recently bought a high rise building in the centre of Moscow for its main office. It's time to decorate the new office, and the first thing to do is to write the company's slogan above the main entrance to the building.

The slogan of the company consists of *n* characters, so the decorators hung a large banner, *n* meters wide and 1 meter high, divided into *n* equal squares. The first character of the slogan must be in the first square (the leftmost) of the poster, the second character must be in the second square, and so on.

Of course, the R1 programmers want to write the slogan on the poster themselves. To do this, they have a large (and a very heavy) ladder which was put exactly opposite the *k*-th square of the poster. To draw the *i*-th character of the slogan on the poster, you need to climb the ladder, standing in front of the *i*-th square of the poster. This action (along with climbing up and down the ladder) takes one hour for a painter. The painter is not allowed to draw characters in the adjacent squares when the ladder is in front of the *i*-th square because the uncomfortable position of the ladder may make the characters untidy. Besides, the programmers can move the ladder. In one hour, they can move the ladder either a meter to the right or a meter to the left.

Drawing characters and moving the ladder is very tiring, so the programmers want to finish the job in as little time as possible. Develop for them an optimal poster painting plan!","The first line contains two integers, *n* and *k* (1<=≤<=*k*<=≤<=*n*<=≤<=100) — the number of characters in the slogan and the initial position of the ladder, correspondingly. The next line contains the slogan as *n* characters written without spaces. Each character of the slogan is either a large English letter, or digit, or one of the characters: '.', '!', ',', '?'.","In *t* lines, print the actions the programmers need to make. In the *i*-th line print:
 -  ""LEFT"" (without the quotes), if the *i*-th action was ""move the ladder to the left""; -  ""RIGHT"" (without the quotes), if the *i*-th action was ""move the ladder to the right""; -  ""PRINT *x*"" (without the quotes), if the *i*-th action was to ""go up the ladder, paint character *x*, go down the ladder"". 
The painting time (variable *t*) must be minimum possible. If there are multiple optimal painting plans, you can print any of them.","['2 2\nR1\n', '2 1\nR1\n', '6 4\nGO?GO!\n']","['PRINT 1\nLEFT\nPRINT R\n', 'PRINT R\nRIGHT\nPRINT 1\n', 'RIGHT\nRIGHT\nPRINT !\nLEFT\nPRINT O\nLEFT\nPRINT G\nLEFT\nPRINT ?\nLEFT\nPRINT O\nLEFT\nPRINT G\n']","Note that the ladder cannot be shifted by less than one meter. The ladder can only stand in front of some square of the poster. For example, you cannot shift a ladder by half a meter and position it between two squares. Then go up and paint the first character and the second character.",OK,"def poster(n,k,s):
    k-=1
    if n%2 == 0:
        if k < n//2:
            while k > 0:
                print(""LEFT"")
                k -= 1
            while k < n:
                print(""PRINT"", s[k])
                if k != n-1:
                    print(""RIGHT"")
                k += 1
        else:
            while k < n-1:
                print(""RIGHT"")
                k += 1
            while k > -1:
                print(""PRINT"", s[k])
                if k != 0:
                    print(""LEFT"")
                k-=1
    else:
        if k > n//2:
            while k < n-1:
                print(""RIGHT"")
                k += 1
            while k > -1:
                print(""PRINT"", s[k])
                if k != 0:
                    print(""LEFT"")
                k-=1
        else:
            while k > 0:
                print(""LEFT"")
                k -= 1
            while k < n:
                print(""PRINT"", s[k])
                if k != n-1:
                    print(""RIGHT"")
                k += 1

n,k = map(int, input().split())
s = input()

poster(n,k,s)","def paint_slogan(n, k, slogan):
    actions = []

    current_position = k - 1

    if current_position < (n - 1) / 2:

        for i in range(current_position, n):
            if i > current_position:
                actions.append(""RIGHT"")
            actions.append(f""PRINT {slogan[i]}"")
    else:

        for i in range(current_position, -1, -1):
            if i < current_position:
                actions.append(""LEFT"")
            actions.append(f""PRINT {slogan[i]}"")
    
    return actions

inputs = [
    ""2 2\nR1\n"",
    ""2 1\nR1\n"",
    ""6 4\nGO?GO!\n""
]

results = []
for input_str in inputs:
    n, k, slogan = input_str.strip().split('\n')
    n, k = map(int, n.split())
    actions = paint_slogan(n, k, slogan)
    results.append('\n'.join(actions))

print('\n'.join(results))"
127,A,Wasted Time,PROGRAMMING,['geometry'],"Mr. Scrooge, a very busy man, decided to count the time he wastes on all sorts of useless stuff to evaluate the lost profit. He has already counted the time he wastes sleeping and eating. And now Mr. Scrooge wants to count the time he has wasted signing papers.

Mr. Scrooge's signature can be represented as a polyline *A*1*A*2... *A**n*. Scrooge signs like that: first it places a pen at the point *A*1, then draws a segment from point *A*1 to point *A*2, then he draws a segment from point *A*2 to point *A*3 and so on to point *A**n*, where he stops signing and takes the pen off the paper. At that the resulting line can intersect with itself and partially repeat itself but Scrooge pays no attention to it and never changes his signing style. As Scrooge makes the signature, he never takes the pen off the paper and his writing speed is constant — 50 millimeters per second.

Scrooge signed exactly *k* papers throughout his life and all those signatures look the same.

Find the total time Scrooge wasted signing the papers.","The first line contains two integers *n* and *k* (2<=≤<=*n*<=≤<=100, 1<=≤<=*k*<=≤<=1000). Each of the following *n* lines contains the coordinates of the polyline's endpoints. The *i*-th one contains coordinates of the point *A**i* — integers *x**i* and *y**i*, separated by a space.

All points *A**i* are different. The absolute value of all coordinates does not exceed 20. The coordinates are measured in millimeters.",Print one real number — the total time Scrooges wastes on signing the papers in seconds. The absolute or relative error should not exceed 10<=-<=6.,"['2 1\n0 0\n10 0\n', '5 10\n3 1\n-5 6\n-2 -1\n3 2\n10 0\n', '6 10\n5 0\n4 0\n6 0\n3 0\n7 0\n2 0\n']","['0.200000000', '6.032163204', '3.000000000']",none,OK,"class point:
    x= 0
    y = 0
    def __init__(self,a,b):
        self.x = a
        self.y = b
def dist(a,b):
    return (((b.x-a.x)*(b.x-a.x))+((b.y-a.y)*(b.y-a.y)))**.5
arr = []
n,k = list(map(int,input().split()))
for i in range(0,n,1):
    a,b = list(map(int,input().split()))
    p = point(a,b)
    arr.append(p)
dista = 0.0 
for i in range(0, n-1,1):
    dista += (dist(arr[i],arr[(i+1)]))

print('{0:.8f}'.format((dista*k)/50))","import math

def total_signing_time(input_data):
    output = []
    
    for data in input_data:
        lines = data.strip().split('\n')
        n, k = map(int, lines[0].split())
        points = [tuple(map(int, line.split())) for line in lines[1:n+1]]

        total_length = 0.0
        for i in range(n - 1):
            x1, y1 = points[i]
            x2, y2 = points[i + 1]
            segment_length = math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)
            total_length += segment_length

        signing_speed = 50.0

        time_for_one_signature = total_length / signing_speed

        total_time = time_for_one_signature * k

        output.append(f""{total_time:.9f}"")
    
    return output

demo_input = ['2 1\n0 0\n10 0\n', '5 10\n3 1\n-5 6\n-2 -1\n3 2\n10 0\n', '6 10\n5 0\n4 0\n6 0\n3 0\n7 0\n2 0\n']
result = total_signing_time(demo_input)
print(result)"
225,C,Barcode,PROGRAMMING,"['dp', 'matrices']","You've got an *n*<=×<=*m* pixel picture. Each pixel can be white or black. Your task is to change the colors of as few pixels as possible to obtain a barcode picture.

A picture is a barcode if the following conditions are fulfilled: 
 -  All pixels in each column are of the same color. -  The width of each monochrome vertical line is at least *x* and at most *y* pixels. In other words, if we group all neighbouring columns of the pixels with equal color, the size of each group can not be less than *x* or greater than *y*.","The first line contains four space-separated integers *n*, *m*, *x* and *y* (1<=≤<=*n*,<=*m*,<=*x*,<=*y*<=≤<=1000; *x*<=≤<=*y*).

Then follow *n* lines, describing the original image. Each of these lines contains exactly *m* characters. Character ""."" represents a white pixel and ""#"" represents a black pixel. The picture description doesn't have any other characters besides ""."" and ""#"".",In the first line print the minimum number of pixels to repaint. It is guaranteed that the answer exists.,"['6 5 1 2\n##.#.\n.###.\n###..\n#...#\n.##.#\n###..\n', '2 5 1 1\n#####\n.....\n']","['11\n', '5\n']","In the first test sample the picture after changing some colors can looks as follows: 

In the second test sample the picture after changing some colors can looks as follows:",RUNTIME_ERROR,"dp = {}
h, w, x, y = 0, 0, 0, 0
a = [0] * 1000
def calc(k, s):
  if (k, s) in dp:
    return dp[(k, s)]
  if s > k:
    dp[(k, s)] = 999999999
  elif s >= 1:
    dp[(k, s)] = calc(k - 1, s - 1) + h - a[k]
  elif s == 0:
    dp[(k, 0)] = min([calc(k - 1, 0)] + [calc(k - 1, s0) for s0 in range(x, y + 1)]) + a[k]
  return dp[(k, s)]
h, w, x, y = map(int, input().split())
for i in range(h):
  st = str(input())
  a = [a[i] + (st[i] == '
dp[(0, 0)] = a[0]
dp[(0, 1)] = h - a[0]
ans = 999999999
for s in range(0, y + 1):
  g = calc(w - 1, s)
  if s == 0 or x <= s <= y:
    ans = min(ans, g)
print(ans)
dp = {}
h, w, x, y = 0, 0, 0, 0
a = [0] * 1000
def calc(k, s):
  if (k, s) in dp:
    return dp[(k, s)]
  if s > k:
    dp[(k, s)] = 999999999
  elif s >= 1:
    dp[(k, s)] = calc(k - 1, s - 1) + h - a[k]
  elif s == 0:
    dp[(k, 0)] = min([calc(k - 1, 0)] + [calc(k - 1, s0) for s0 in range(x, y + 1)]) + a[k]
  return dp[(k, s)]
h, w, x, y = map(int, input().split())
for i in range(h):
  st = str(input())
  a = [a[i] + (st[i] == '
dp[(0, 0)] = a[0]
dp[(0, 1)] = h - a[0]
ans = 999999999
for s in range(0, y + 1):
  g = calc(w - 1, s)
  if s == 0 or x <= s <= y:
    ans = min(ans, g)
print(ans)","def min_repaints_to_barcode(n, m, x, y, picture):

    black_count = [0] * m
    for row in picture:
        for j in range(m):
            if row[j] == '
                black_count[j] += 1

    white_count = [n - black_count[j] for j in range(m)]

    dp = [[float('inf')] * (m + 1) for _ in range(2)]
    dp[0][0] = 0

    for j in range(1, m + 1):

        for color in range(2):
            current_count = black_count if color == 0 else white_count

            for width in range(x, y + 1):
                if j - width >= 0:
                    dp[color][j] = min(dp[color][j], dp[1 - color][j - width] + sum(current_count[j - width:j]))

    result = min(dp[0][m], dp[1][m])
    return result

input_data = [
    '6 5 1 2\n
    '2 5 1 1\n
]

for data in input_data:

    lines = data.strip().split('\n')
    n, m, x, y = map(int, lines[0].split())
    picture = lines[1:]

    print(min_repaints_to_barcode(n, m, x, y, picture))"
676,C,Vasya and String,PROGRAMMING,"['binary search', 'dp', 'strings', 'two pointers']","High school student Vasya got a string of length *n* as a birthday present. This string consists of letters 'a' and 'b' only. Vasya denotes beauty of the string as the maximum length of a substring (consecutive subsequence) consisting of equal letters.

Vasya can change no more than *k* characters of the original string. What is the maximum beauty of the string he can achieve?","The first line of the input contains two integers *n* and *k* (1<=≤<=*n*<=≤<=100<=000,<=0<=≤<=*k*<=≤<=*n*) — the length of the string and the maximum number of characters to change.

The second line contains the string, consisting of letters 'a' and 'b' only.",Print the only integer — the maximum beauty of the string Vasya can achieve by changing no more than *k* characters.,"['4 2\nabba\n', '8 1\naabaabaa\n']","['4\n', '5\n']","In the first sample, Vasya can obtain both strings ""aaaa"" and ""bbbb"".

In the second sample, the optimal answer is obtained with the string ""aaaaabaa"" or with the string ""aabaaaaa"".",OK,"import sys
from collections import defaultdict as dd
from collections import deque
from fractions import Fraction as f
from copy import *
from bisect import *	
from heapq import *

from itertools import permutations 
 
def eprint(*args):
    print(*args, file=sys.stderr)
zz=1

if zz:
	input=sys.stdin.readline
else:	
	sys.stdin=open('input.txt', 'r')
	sys.stdout=open('all.txt','w')
def li():
	return [int(x) for x in input().split()]
def fi():
	return int(input())
def si():
	return list(input().rstrip())	
def mi():
	return 	map(int,input().split())	
def gh():
	sys.stdout.flush()
def graph(n,m):
	for i in range(m):
		x,y=mi()
		a[x].append(y)
		a[y].append(x)
def bo(i):
	return ord(i)-ord('a')

def can(mid):
	d=[0,0]
	mini=n
	for i in range(n):
		if i>=mid:
			mini=min(d[0],min(d[1],mini))
			d[bo(a[i-mid])]-=1
		d[bo(a[i])]+=1
		
	mini=min(d[0],min(d[1],mini))	
	return mini<=k		
n,k=mi()
a=si()
l=0
r=ans=n
while l<=r:
	mid=(l+r)//2
	if can(mid):
		ans=mid
		l=mid+1
	else:
		r=mid-1
print(ans)","def max_beauty(n, k, s):
    def max_length_with_char(char):
        left = 0
        max_length = 0
        changed = 0
        
        for right in range(n):
            if s[right] != char:
                changed += 1
            
            while changed > k:
                if s[left] != char:
                    changed -= 1
                left += 1
            
            max_length = max(max_length, right - left + 1)
        
        return max_length

    max_a = max_length_with_char('a')
    max_b = max_length_with_char('b')

    return max(max_a, max_b)

n, k = map(int, input().split())
s = input().strip()

result = max_beauty(n, k, s)
print(result)"
472,A,Design Tutorial: Learn from Math,PROGRAMMING,"['math', 'number theory']","One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.

For example, there is a statement called the ""Goldbach's conjecture"". It says: ""each even number no less than four can be expressed as the sum of two primes"". Let's modify it. How about a statement like that: ""each integer no less than 12 can be expressed as the sum of two composite numbers."" Not like the Goldbach's conjecture, I can prove this theorem.

You are given an integer *n* no less than 12, express it as a sum of two composite numbers.",The only line contains an integer *n* (12<=≤<=*n*<=≤<=106).,"Output two composite integers *x* and *y* (1<=&lt;<=*x*,<=*y*<=&lt;<=*n*) such that *x*<=+<=*y*<==<=*n*. If there are multiple solutions, you can output any of them.","['12\n', '15\n', '23\n', '1000000\n']","['4 8\n', '6 9\n', '8 15\n', '500000 500000\n']","In the first example, 12 = 4 + 8 and both 4, 8 are composite numbers. You can output ""6 6"" or ""8 4"" as well.

In the second example, 15 = 6 + 9. Note that you can't output ""1 14"" because 1 is not a composite number.",TIME_LIMIT_EXCEEDED,"from itertools import combinations
def check(num):
    for i in range(2, num):
        if num % i == 0:
            return True
    return False
n = int(input())
c = []
for i in range(4, n):
    if check(i):
        c.append(i)
for i in combinations(c, 2):
    if sum(i) == n:
        print(i[0], i[1])
        break","def is_composite(num):
    """"""Check if a number is composite.""""""
    if num < 4:
        return False
    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            return True
    return False

def find_composite_sum(n):
    """"""Find two composite numbers that sum up to n.""""""
    for x in range(4, n):
        y = n - x
        if is_composite(x) and is_composite(y):
            return x, y
    return None

def main():
    import sys
    input_data = sys.stdin.read().strip().split()
    
    results = []
    for line in input_data:
        n = int(line)
        if n >= 12:
            result = find_composite_sum(n)
            if result:
                results.append(f""{result[0]} {result[1]}"")

    print(""\n"".join(results))

if __name__ == ""__main__"":
    main()"
915,F,Imbalance Value of a Tree,PROGRAMMING,"['data structures', 'dsu', 'graphs', 'trees']","You are given a tree *T* consisting of *n* vertices. A number is written on each vertex; the number written on vertex *i* is *a**i*. Let's denote the function *I*(*x*,<=*y*) as the difference between maximum and minimum value of *a**i* on a simple path connecting vertices *x* and *y*.

Your task is to calculate .","The first line contains one integer number *n* (1<=≤<=*n*<=≤<=106) — the number of vertices in the tree.

The second line contains *n* integer numbers *a*1, *a*2, ..., *a**n* (1<=≤<=*a**i*<=≤<=106) — the numbers written on the vertices.

Then *n*<=-<=1 lines follow. Each line contains two integers *x* and *y* denoting an edge connecting vertex *x* and vertex *y* (1<=≤<=*x*,<=*y*<=≤<=*n*, *x*<=≠<=*y*). It is guaranteed that these edges denote a tree.",Print one number equal to .,['4\n2 2 3 1\n1 2\n1 3\n1 4\n'],['6\n'],none,WRONG_ANSWER,"import sys
import bisect
import random
import io, os
from bisect import *
from collections import *
from contextlib import redirect_stdout
from itertools import *
from array import *
from functools import lru_cache, reduce
from types import GeneratorType
from heapq import *
from math import sqrt, gcd, inf

if sys.version >= '3.8':
    from math import comb

RI = lambda: map(int, sys.stdin.buffer.readline().split())
RS = lambda: map(bytes.decode, sys.stdin.buffer.readline().strip().split())
RILST = lambda: list(RI())
DEBUG = lambda *x: sys.stderr.write(f'{str(x)}\n')

MOD = 10 ** 9 + 7
PROBLEM = """"""https://codeforces.com/problemset/problem/915/F

输入 n (1≤n≤1e6) 和长为 n 的数组 a(1≤a[i]≤1e6)，下标从 1 开始。
然后输入一棵树的 n-1 条边，节点编号从 1 开始。

定义 Δ(x,y) 表示从 x 到 y 的简单路径上的 a[i] 的最大值与最小值的差。
输出所有 Δ(i,j) 的和，其中 1≤i≤j≤n。
输入
4
2 2 3 1
1 2
1 3
1 4
输出 6
""""""

class DSU:
    def __init__(self, n):
        self.fathers = list(range(n))
        self.size = [1] * n
        self.edge_size = [0] * n
        self.n = n
        self.setCount = n

    def find_fa(self, x):
        fs = self.fathers
        t = x
        while fs[x] != x:
            x = fs[x]
        while t != x:
            fs[t], t = x, fs[t]
        return x

    def union(self, x: int, y: int) -> bool:
        x = self.find_fa(x)
        y = self.find_fa(y)

        if x == y:
            self.edge_size[y] += 1
            return False

        self.fathers[x] = y
        self.size[y] += self.size[x]
        self.edge_size[y] += 1 + self.edge_size[x]
        self.setCount -= 1
        return True

def solve():
    n, = RI()
    a = RILST()
    es = []
    for _ in range(n - 1):
        u, v = RI()
        u -= 1
        v -= 1
        if a[u] > a[v]:
            u, v = v, u
        es.append((u, v))
    ans = 0

    es.sort(key=lambda x: a[x[1]])
    dsu = DSU(n)
    for u, v in es:
        u, v = dsu.find_fa(u), dsu.find_fa(v)
        ans += a[v] * dsu.size[u] * dsu.size[v]
        dsu.union(u, v)
    es.sort(key=lambda x: a[x[0]], reverse=True)
    dsu = DSU(n)
    for u, v in es:
        u, v = dsu.find_fa(u), dsu.find_fa(v)
        ans -= a[u] * dsu.size[u] * dsu.size[v]
        dsu.union(u, v)
    print(ans)

if __name__ == '__main__':
    solve()","import sys
from collections import defaultdict
import itertools

input = sys.stdin.read

def dfs(node, parent):
    min_val = max_val = values[node]
    for neighbor in tree[node]:
        if neighbor != parent:
            child_min, child_max = dfs(neighbor, node)
            min_val = min(min_val, child_min)
            max_val = max(max_val, child_max)
    return min_val, max_val

def main():
    data = input().splitlines()
    n = int(data[0])
    global values
    values = list(map(int, data[1].split()))
    
    global tree
    tree = defaultdict(list)
    
    for i in range(2, n + 1):
        x, y = map(int, data[i].split())
        tree[x - 1].append(y - 1)
        tree[y - 1].append(x - 1)

    result = 0

    for x, y in itertools.combinations(range(n), 2):
        min_in_path = min(values[x], values[y])
        max_in_path = max(values[x], values[y])

        path_min, path_max = dfs(x, -1)
        result += (path_max - path_min)

    print(result)

if __name__ == ""__main__"":
    main()"
304,A,Pythagorean Theorem II,PROGRAMMING,"['brute force', 'math']","In mathematics, the Pythagorean theorem — is a relation in Euclidean geometry among the three sides of a right-angled triangle. In terms of areas, it states:

 In any right-angled triangle, the area of the square whose side is the hypotenuse (the side opposite the right angle) is equal to the sum of the areas of the squares whose sides are the two legs (the two sides that meet at a right angle). 

The theorem can be written as an equation relating the lengths of the sides *a*, *b* and *c*, often called the Pythagorean equation:

where *c* represents the length of the hypotenuse, and *a* and *b* represent the lengths of the other two sides.

Given *n*, your task is to count how many right-angled triangles with side-lengths *a*, *b* and *c* that satisfied an inequality 1<=≤<=*a*<=≤<=*b*<=≤<=*c*<=≤<=*n*.",The only line contains one integer *n* (1<=≤<=*n*<=≤<=104) as we mentioned above.,Print a single integer — the answer to the problem.,"['5\n', '74\n']","['1\n', '35\n']",none,WRONG_ANSWER,"'''
    Auther: ghoshashis545 Ashis Ghosh
    college: jalpaiguri Govt Enggineering College
    Date:07/03/2020
'''
from math import ceil,sqrt,gcd,log,floor
from collections import deque
def ii(): return int(input())
def si(): return input()
def mi(): return map(int,input().strip().split("" ""))
def li(): return list(mi())

n=ii()
ans=0
for i in range(1,n-1):
    for j in range(i+1,n-1):
        c=(i*i)+(j*j)
        x=sqrt(c)
        x=int(x)
        if(x*x==c and x<=n):

            ans+=1
print(ans)","def count_right_triangles(n):
    count = 0

    for a in range(1, n + 1):
        for b in range(a, n + 1):
            for c in range(b, n + 1):

                if a * a + b * b == c * c:
                    count += 1
    return count

n = int(input().strip())

result = count_right_triangles(n)

print(result)"
148,A,Insomnia cure,PROGRAMMING,"['constructive algorithms', 'implementation', 'math']","«One dragon. Two dragon. Three dragon», — the princess was counting. She had trouble falling asleep, and she got bored of counting lambs when she was nine.

However, just counting dragons was boring as well, so she entertained herself at best she could. Tonight she imagined that all dragons were here to steal her, and she was fighting them off. Every *k*-th dragon got punched in the face with a frying pan. Every *l*-th dragon got his tail shut into the balcony door. Every *m*-th dragon got his paws trampled with sharp heels. Finally, she threatened every *n*-th dragon to call her mom, and he withdrew in panic.

How many imaginary dragons suffered moral or physical damage tonight, if the princess counted a total of *d* dragons?","Input data contains integer numbers *k*,<=*l*,<=*m*,<=*n* and *d*, each number in a separate line (1<=≤<=*k*,<=*l*,<=*m*,<=*n*<=≤<=10, 1<=≤<=*d*<=≤<=105).",Output the number of damaged dragons.,"['1\n2\n3\n4\n12\n', '2\n3\n4\n5\n24\n']","['12\n', '17\n']","In the first case every first dragon got punched with a frying pan. Some of the dragons suffered from other reasons as well, but the pan alone would be enough.

In the second case dragons 1, 7, 11, 13, 17, 19 and 23 escaped unharmed.",OK,"def ok(ak, d):
    for k in ak:
        if d < k:
            continue
        if d % k == 0:
            return True
    return False

ak = [int(input()), int(input()), int(input()), int(input())]
d = int(input())
s = 0
for i in range(1, d + 1):
    if ok(ak, i):
        s += 1
print(s)","def count_damaged_dragons(k, l, m, n, d):
    damaged_dragons = 0
    for dragon in range(1, d + 1):

        if dragon % k == 0 or dragon % l == 0 or dragon % m == 0 or dragon % n == 0:
            damaged_dragons += 1
    return damaged_dragons

k = int(input().strip())
l = int(input().strip())
m = int(input().strip())
n = int(input().strip())
d = int(input().strip())

result = count_damaged_dragons(k, l, m, n, d)

print(result)"
676,C,Vasya and String,PROGRAMMING,"['binary search', 'dp', 'strings', 'two pointers']","High school student Vasya got a string of length *n* as a birthday present. This string consists of letters 'a' and 'b' only. Vasya denotes beauty of the string as the maximum length of a substring (consecutive subsequence) consisting of equal letters.

Vasya can change no more than *k* characters of the original string. What is the maximum beauty of the string he can achieve?","The first line of the input contains two integers *n* and *k* (1<=≤<=*n*<=≤<=100<=000,<=0<=≤<=*k*<=≤<=*n*) — the length of the string and the maximum number of characters to change.

The second line contains the string, consisting of letters 'a' and 'b' only.",Print the only integer — the maximum beauty of the string Vasya can achieve by changing no more than *k* characters.,"['4 2\nabba\n', '8 1\naabaabaa\n']","['4\n', '5\n']","In the first sample, Vasya can obtain both strings ""aaaa"" and ""bbbb"".

In the second sample, the optimal answer is obtained with the string ""aaaaabaa"" or with the string ""aabaaaaa"".",OK,"def max_beauty(n, k, s):
    max_beauty = 0
    window_start = 0
    a_count = 0
    b_count = 0

    for window_end in range(n):
        if s[window_end] == 'a':
            a_count += 1
        else:
            b_count += 1

        window_length = window_end - window_start + 1

        to_change = min(a_count, b_count)

        while to_change > k:
            if s[window_start] == 'a':
                a_count -= 1
            else:
                b_count -= 1
            window_start += 1
            window_length -= 1
            to_change = min(a_count, b_count)

        max_beauty = max(max_beauty, window_length)
    
    return max_beauty

n, k = map(int, input().split())
s = input()

result = max_beauty(n, k, s)
print(result)","def max_beauty(n, k, s):

    def max_length_with_char(char):
        left = 0
        max_len = 0
        count_changes = 0
        
        for right in range(n):

            if s[right] != char:
                count_changes += 1

            while count_changes > k:
                if s[left] != char:
                    count_changes -= 1
                left += 1

            max_len = max(max_len, right - left + 1)
        
        return max_len

    return max(max_length_with_char('a'), max_length_with_char('b'))

input_str = input().splitlines()
n, k = map(int, input_str[0].split())
s = input_str[1]

result = max_beauty(n, k, s)
print(result)"
0,none,none,none,['none'],"Vasya and Petya are playing a simple game. Vasya thought of number *x* between 1 and *n*, and Petya tries to guess the number.

Petya can ask questions like: ""Is the unknown number divisible by number *y*?"".

The game is played by the following rules: first Petya asks all the questions that interest him (also, he can ask no questions), and then Vasya responds to each question with a 'yes' or a 'no'. After receiving all the answers Petya should determine the number that Vasya thought of.

Unfortunately, Petya is not familiar with the number theory. Help him find the minimum number of questions he should ask to make a guaranteed guess of Vasya's number, and the numbers *y**i*, he should ask the questions about.",A single line contains number *n* (1<=≤<=*n*<=≤<=103).,"Print the length of the sequence of questions *k* (0<=≤<=*k*<=≤<=*n*), followed by *k* numbers — the questions *y**i* (1<=≤<=*y**i*<=≤<=*n*).

If there are several correct sequences of questions of the minimum length, you are allowed to print any of them.","['4\n', '6\n']","['3\n2 4 3 \n', '4\n2 4 3 5 \n']","The sequence from the answer to the first sample test is actually correct.

If the unknown number is not divisible by one of the sequence numbers, it is equal to 1.

If the unknown number is divisible by 4, it is 4.

If the unknown number is divisible by 3, then the unknown number is 3.

Otherwise, it is equal to 2. Therefore, the sequence of questions allows you to guess the unknown number. It can be shown that there is no correct sequence of questions of length 2 or shorter.",WRONG_ANSWER,"import sys
import math
def get_sieve(n):

    primes = set()
    sieve = [1] * (n + 1)
    sieve[0] = sieve[1] = 0
    for i in range(2, n + 1):
        if sieve[i]:
            for j in range(i * i, n + 1, i):
                sieve[j] = 0
            primes.add(i)
    return primes

def main():
    read = sys.stdin.readline
    n = int(read())
    primes = get_sieve(n)
    result = ['2', '4', '3']
    if n > 4:
        for i in range(5, n + 1):
            if i in primes:
                result.append(str(i))
            if math.sqrt(i) in primes:
                result.append(str(i))
    print(len(result))
    print(' '.join(result))

if __name__ == '__main__':
    main()","def find_questions(n):
    questions = []

    y = 1
    while y <= n:
        questions.append(y)
        y *= 2

    k = len(questions)

    print(k)
    print("" "".join(map(str, questions)))

inputs = ['4', '6']
for n_str in inputs:
    n = int(n_str.strip())
    find_questions(n)"
278,B,New Problem,PROGRAMMING,"['brute force', 'strings']","Coming up with a new problem isn't as easy as many people think. Sometimes it is hard enough to name it. We'll consider a title original if it doesn't occur as a substring in any titles of recent Codeforces problems. 

You've got the titles of *n* last problems — the strings, consisting of lowercase English letters. Your task is to find the shortest original title for the new problem. If there are multiple such titles, choose the lexicographically minimum one. Note, that title of the problem can't be an empty string.

A substring *s*[*l*... *r*] (1<=≤<=*l*<=≤<=*r*<=≤<=|*s*|) of string *s*<==<=*s*1*s*2... *s*|*s*| (where |*s*| is the length of string *s*) is string *s**l**s**l*<=+<=1... *s**r*.

String *x*<==<=*x*1*x*2... *x**p* is lexicographically smaller than string *y*<==<=*y*1*y*2... *y**q*, if either *p*<=&lt;<=*q* and *x*1<==<=*y*1,<=*x*2<==<=*y*2,<=... ,<=*x**p*<==<=*y**p*, or there exists such number *r* (*r*<=&lt;<=*p*,<=*r*<=&lt;<=*q*), that *x*1<==<=*y*1,<=*x*2<==<=*y*2,<=... ,<=*x**r*<==<=*y**r* and *x**r*<=+<=1<=&lt;<=*y**r*<=+<=1. The string characters are compared by their ASCII codes.","The first line contains integer *n* (1<=≤<=*n*<=≤<=30) — the number of titles you've got to consider. Then follow *n* problem titles, one per line. Each title only consists of lowercase English letters (specifically, it doesn't contain any spaces) and has the length from 1 to 20, inclusive.","Print a string, consisting of lowercase English letters — the lexicographically minimum shortest original title.","['5\nthreehorses\ngoodsubstrings\nsecret\nprimematrix\nbeautifulyear\n', '4\naa\nbdefghijklmn\nopqrstuvwxyz\nc\n']","['j\n', 'ab\n']","In the first sample the first 9 letters of the English alphabet (a, b, c, d, e, f, g, h, i) occur in the problem titles, so the answer is letter j.

In the second sample the titles contain 26 English letters, so the shortest original title cannot have length 1. Title aa occurs as a substring in the first title.",OK,"import math
 
 
def functie_divizori(numar):
 
 
 dictionar={}
 
 matrice=[]
 if numar==1:
  a=[1]*2
  a.append(0)
  a.append(0)
  matrice.append(a)
 else: 
  for j in range(1,math.floor(numar**(1/2))+1):

   if numar%j==0:
    tupleta=[]

    tupleta.append(j)
    tupleta.append(numar//j)
    tupleta.append(0)
    tupleta.append(0)
    matrice.append(tupleta)
    tupleta=[]
    
    if numar//j!=j:
     tupleta=[]
     tupleta.append(numar//j)
     tupleta.append(j)
     tupleta.append(0)
     tupleta.append(0)
   
  
     matrice.append(tupleta)
 return matrice

alfabet = {'a': 1, 'b': 2,'c': 3,'d': 4,'e': 5,'f': 6,'g': 7,'h': 8,'i': 9,'j': 10,'k': 11,'l': 12,'m': 13,'n': 14,'o': 15,'p': 16,'q': 17,'r': 18,'s': 19,'t': 20,'u': 21,'v': 22,'w': 23,'x': 24,'y': 25,'z': 26}
alfabet_2={'1':""a"", '2':""b"", '3':""c"", '4':""d"", '5':""e"", '6':""f"", '7':""g"", '8':""h"", '9':""i"", '10':""j"", '11':""k"", '12':""l"", '13':""m"", '14':""n"", '15':""o"", '16':""p"", '17':""q"", '18':""r"", '19':""s"", '20':""t"", '21':""u"", '22':""v"", '23':""w"", '24':""x"", '25':""y"", '26':""z""} 

dictionar_1={}
dictionar_2={}

dictionar_1=alfabet

for i in range(1,27):
 for j in range(1,27):
  element=alfabet_2[str(i)] + alfabet_2[str(j)]
  dictionar_2[element]=(i-1)*26+j
  
dictionar_unu=dict(dictionar_1)
dictionar_doi=dict(dictionar_2)

cazuri=int(input())

for tt in range(cazuri):

 s=input()
 for i in dictionar_1:
  if i in s:
   if i in dictionar_unu:
    del dictionar_unu[i]
 
    
 for x in dictionar_2:
  if x in s:
   if x in dictionar_doi:
    del dictionar_doi[x]
    
maximul=1000    
answ=''
if len(dictionar_unu)>0:
 for j in dictionar_unu:
  if dictionar_unu[j]<maximul:
   maximul=dictionar_unu[j]
   answ=j
   
else:
 for j in dictionar_doi:
  if dictionar_doi[j]<maximul:
   maximul=dictionar_doi[j]
   answ=j
   
print(answ)","def find_shortest_original_title(n, titles):

    substrings = set()

    for title in titles:
        length = len(title)
        for start in range(length):
            for end in range(start + 1, length + 1):
                substrings.add(title[start:end])

    def is_original(title):
        return title not in substrings

    from itertools import product
    import string

    for c in string.ascii_lowercase:
        if is_original(c):
            return c

    for c1, c2 in product(string.ascii_lowercase, repeat=2):
        title = c1 + c2
        if is_original(title):
            return title

    for c1, c2, c3 in product(string.ascii_lowercase, repeat=3):
        title = c1 + c2 + c3
        if is_original(title):
            return title

import sys
input_data = sys.stdin.read().strip().split('\n')
n = int(input_data[0])
titles = input_data[1:n + 1]

result = find_shortest_original_title(n, titles)
print(result)"
368,B,Sereja and Suffixes,PROGRAMMING,"['data structures', 'dp']","Sereja has an array *a*, consisting of *n* integers *a*1, *a*2, ..., *a**n*. The boy cannot sit and do nothing, he decided to study an array. Sereja took a piece of paper and wrote out *m* integers *l*1,<=*l*2,<=...,<=*l**m* (1<=≤<=*l**i*<=≤<=*n*). For each number *l**i* he wants to know how many distinct numbers are staying on the positions *l**i*, *l**i*<=+<=1, ..., *n*. Formally, he want to find the number of distinct numbers among *a**l**i*,<=*a**l**i*<=+<=1,<=...,<=*a**n*.?

Sereja wrote out the necessary array elements but the array was so large and the boy was so pressed for time. Help him, find the answer for the described question for each *l**i*.","The first line contains two integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=105). The second line contains *n* integers *a*1, *a*2, ..., *a**n* (1<=≤<=*a**i*<=≤<=105) — the array elements.

Next *m* lines contain integers *l*1,<=*l*2,<=...,<=*l**m*. The *i*-th line contains integer *l**i* (1<=≤<=*l**i*<=≤<=*n*).",Print *m* lines — on the *i*-th line print the answer to the number *l**i*.,['10 10\n1 2 3 4 1 2 3 4 100000 99999\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n'],['6\n6\n6\n6\n6\n5\n4\n3\n2\n1\n'],none,RUNTIME_ERROR,"n, m = map(int, input().split())
a = list(map(int, input().split()))
buf = {1: len(set(a))}

def func(i: int) -> int:
    if i in buf:
        return buf[i]
    pre = func(i-1)
    try:
        a.index(a[i-2], i-1)
    except ValueError:
        pre -= 1
    buf[i] = pre
    return pre

for _ in range(m):
    print(func(int(input())))","n, m = map(int, input().split())
a = list(map(int, input().split()))

distinct_counts = [0] * n
seen = set()

for i in range(n - 1, -1, -1):
    seen.add(a[i])
    distinct_counts[i] = len(seen)

for _ in range(m):
    l_i = int(input()) - 1
    print(distinct_counts[l_i])"
124,A,The number of positions,PROGRAMMING,['math'],"Petr stands in line of *n* people, but he doesn't know exactly which position he occupies. He can say that there are no less than *a* people standing in front of him and no more than *b* people standing behind him. Find the number of different positions Petr can occupy.","The only line contains three integers *n*, *a* and *b* (0<=≤<=*a*,<=*b*<=&lt;<=*n*<=≤<=100).",Print the single number — the number of the sought positions.,"['3 1 1\n', '5 2 3\n']","['2\n', '3\n']","The possible positions in the first sample are: 2 and 3 (if we number the positions starting with 1).

In the second sample they are 3, 4 and 5.",OK,"def pos(n,f,d):
    return n-max(f+1,n-b)+1;
n,f,b=map(int,input().split(' '))
print(pos(n,f,b))","def calculate_positions(n, a, b):

    min_position = a + 1

    max_position = n - b

    if min_position > max_position:
        return 0
    else:
        return max_position - min_position + 1

n, a, b = map(int, input().strip().split())

result = calculate_positions(n, a, b)
print(result)"
900,B,Position in Fraction,PROGRAMMING,"['math', 'number theory']",You have a fraction . You need to find the first occurrence of digit *c* into decimal notation of the fraction after decimal point.,"The first contains three single positive integers *a*, *b*, *c* (1<=≤<=*a*<=&lt;<=*b*<=≤<=105, 0<=≤<=*c*<=≤<=9).","Print position of the first occurrence of digit *c* into the fraction. Positions are numbered from 1 after decimal point. It there is no such position, print -1.","['1 2 0\n', '2 3 7\n']","['2', '-1']","The fraction in the first example has the following decimal notation: <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/896357459a466614a0542f34c9cfb0cef1afc9ed.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>. The first zero stands on second position.

The fraction in the second example has the following decimal notation: <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/130ba579a8276fc53a1917606eee9db58817f28d.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>. There is no digit 7 in decimal notation of the fraction.",WRONG_ANSWER,"def calculateFraction(num, den) :

	if (num == 0):
		return ""0""

	sign = -1 if (num < 0) ^ (den < 0) else 1

	num = abs(num)
	den = abs(den)

	initial = num // den

	res = """"

	if (sign == -1):
		res += ""-""

	res += str(initial)

	if (num % den == 0):
		return res

	res += "".""

	rem = num % den
	mp = {}

	index = 0
	repeating = False
	while (rem > 0 and not repeating) :

		if ( rem in mp):

			index = mp[rem]
			repeating = True
			break
		
		else:
			mp[rem] = len(res)

		rem = rem * 10

		temp = rem // den
		res += str(temp )
		rem = rem % den

	if (repeating) :
		res += "")""
		x = res[:index]
		x += ""(""
		x += res[index:]
		res = x

	return res

def searchDigit(a,b,c):
    decimal = calculateFraction(a,b)
    try:

        decimal.index(')')
            
    except:

        decimal += ""000""
        
    decimal = decimal[2:]
    try:
        print(decimal.index(str(c))+1)
    except:
        print(-1)","def find_digit_in_fraction(a, b, c):

    position = 0
    remainder = a % b

    seen_remainders = {}

    while True:

        position += 1

        if remainder == 0:
            return -1

        if remainder in seen_remainders:
            return -1

        seen_remainders[remainder] = position

        remainder *= 10
        digit = remainder // b

        if digit == c:
            return position

        remainder = remainder % b

def main(inputs):
    results = []
    for line in inputs:
        a, b, c = map(int, line.strip().split())
        result = find_digit_in_fraction(a, b, c)
        results.append(str(result))
    return results

demo_input = ['1 2 0\n', '2 3 7\n']
print(main(demo_input))"
895,B,XK Segments,PROGRAMMING,"['binary search', 'math', 'sortings', 'two pointers']","While Vasya finished eating his piece of pizza, the lesson has already started. For being late for the lesson, the teacher suggested Vasya to solve one interesting problem. Vasya has an array *a* and integer *x*. He should find the number of different ordered pairs of indexes (*i*,<=*j*) such that *a**i*<=≤<=*a**j* and there are exactly *k* integers *y* such that *a**i*<=≤<=*y*<=≤<=*a**j* and *y* is divisible by *x*.

In this problem it is meant that pair (*i*,<=*j*) is equal to (*j*,<=*i*) only if *i* is equal to *j*. For example pair (1,<=2) is not the same as (2,<=1).","The first line contains 3 integers *n*,<=*x*,<=*k* (1<=≤<=*n*<=≤<=105,<=1<=≤<=*x*<=≤<=109,<=0<=≤<=*k*<=≤<=109), where *n* is the size of the array *a* and *x* and *k* are numbers from the statement.

The second line contains *n* integers *a**i* (1<=≤<=*a**i*<=≤<=109) — the elements of the array *a*.",Print one integer — the answer to the problem.,"['4 2 1\n1 3 5 7\n', '4 2 0\n5 3 1 7\n', '5 3 1\n3 3 3 3 3\n']","['3\n', '4\n', '25\n']","In first sample there are only three suitable pairs of indexes — (1, 2), (2, 3), (3, 4).

In second sample there are four suitable pairs of indexes(1, 1), (2, 2), (3, 3), (4, 4).

In third sample every pair (*i*, *j*) is suitable, so the answer is 5 * 5 = 25.",WRONG_ANSWER,"from bisect import bisect_left
from bisect import bisect_right
from math import ceil

def next_line(a, x):
    return x * ceil(a / x)

def num_of(arr, a, x, k):
    return bisect_left(arr, next_line(a, x) + k * x) - bisect_left(arr, a)

def find(arr, a, x, k):
    return num_of(arr, a, x, k) - num_of(arr, a, x, k-1)

n, x, k = input().split(' ')
n, x, k = int(n), int(x), int(k)

t = input().split(' ')
t = [int(a) for a in t]
t.sort()

sum = 0

for a in t:
    sum += find(t, a, x, k)

print(sum)","def count_pairs(n, x, k, a):
    result = 0
    a.sort()

    for i in range(n):

        y_min = (a[i] // x) * x
        y_max = y_min + x * (k + 1) - 1

        j_start = i
        j_end = n - 1
        
        while j_start <= j_end:
            mid = (j_start + j_end) // 2
            if a[mid] > y_max:
                j_end = mid - 1
            else:
                j_start = mid + 1
        
        j_count = j_start - i
        if j_count > 0:

            total_y = (y_max // x) - (y_min // x)
            if total_y == k:
                result += j_count
                
    return result

if __name__ == ""__main__"":
    import sys
    
    input_data = sys.stdin.read().splitlines()
    n, x, k = map(int, input_data[0].split())
    a = list(map(int, input_data[1].split()))
    
    print(count_pairs(n, x, k, a))"
165,B,Burning Midnight Oil,PROGRAMMING,"['binary search', 'implementation']","One day a highly important task was commissioned to Vasya — writing a program in a night. The program consists of *n* lines of code. Vasya is already exhausted, so he works like that: first he writes *v* lines of code, drinks a cup of tea, then he writes as much as  lines, drinks another cup of tea, then he writes  lines and so on: , , , ...

The expression  is regarded as the integral part from dividing number *a* by number *b*.

The moment the current value  equals 0, Vasya immediately falls asleep and he wakes up only in the morning, when the program should already be finished.

Vasya is wondering, what minimum allowable value *v* can take to let him write not less than *n* lines of code before he falls asleep.","The input consists of two integers *n* and *k*, separated by spaces — the size of the program in lines and the productivity reduction coefficient, 1<=≤<=*n*<=≤<=109, 2<=≤<=*k*<=≤<=10.",Print the only integer — the minimum value of *v* that lets Vasya write the program in one night.,"['7 2\n', '59 9\n']","['4\n', '54\n']","In the first sample the answer is *v* = 4. Vasya writes the code in the following portions: first 4 lines, then 2, then 1, and then Vasya falls asleep. Thus, he manages to write 4 + 2 + 1 = 7 lines in a night and complete the task.

In the second sample the answer is *v* = 54. Vasya writes the code in the following portions: 54, 6. The total sum is 54 + 6 = 60, that's even more than *n* = 59.",RUNTIME_ERROR,"import math;

def process(guess, n, k):
    denom = k
    totalLines = guess
    while (math.floor(guess / denom) > 0):

        totalLines += math.floor(guess / denom)
        denom *= k

    return totalLines
    
def main():
    n = int(input())
    k = int(input())

    res = -1

    low = 0
    high = math.pow(10, 3)

    while low <= high:
        guess = math.floor((low + high) / 2)
        temp = process(guess, n, k)

        if temp < n: 

            low = guess + 1
        elif temp >= n:
            high = guess - 1
            res = guess
            
    print(res)

main()","def minimum_v(n, k):
    def total_lines_written(v):
        total = 0
        current = v
        while current > 0:
            total += current
            current //= k
        return total

    left, right = 1, n
    while left < right:
        mid = (left + right) // 2
        if total_lines_written(mid) >= n:
            right = mid
        else:
            left = mid + 1
    return left

input_data = ['7 2\n', '59 9\n']
results = []

for data in input_data:
    n, k = map(int, data.strip().split())
    results.append(minimum_v(n, k))

for result in results:
    print(result)"
553,A,Kyoya and Colored Balls,PROGRAMMING,"['combinatorics', 'dp', 'math']",Kyoya Ootori has a bag with *n* colored balls that are colored with *k* different colors. The colors are labeled from 1 to *k*. Balls of the same color are indistinguishable. He draws balls from the bag one by one until the bag is empty. He noticed that he drew the last ball of color *i* before drawing the last ball of color *i*<=+<=1 for all *i* from 1 to *k*<=-<=1. Now he wonders how many different ways this can happen.,"The first line of input will have one integer *k* (1<=≤<=*k*<=≤<=1000) the number of colors.

Then, *k* lines will follow. The *i*-th line will contain *c**i*, the number of balls of the *i*-th color (1<=≤<=*c**i*<=≤<=1000).

The total number of balls doesn't exceed 1000.","A single integer, the number of ways that Kyoya can draw the balls from the bag as described in the statement, modulo 1<=000<=000<=007.","['3\n2\n2\n1\n', '4\n1\n2\n3\n4\n']","['3\n', '1680\n']","In the first sample, we have 2 balls of color 1, 2 balls of color 2, and 1 ball of color 3. The three ways for Kyoya are:",WRONG_ANSWER,"def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n-1)

def nCr(n, r):
    return int(factorial(n)/(factorial(r)*factorial(n-r)))

def orden(b, pos):
    if pos == 0:
        return nCr(b[pos+1]+b[pos]-1, b[pos])
    else:
        sum = 0
        for i in range(0, pos+2):
            sum += b[i]
        return nCr(sum-1-b[pos-1], b[pos])

colors = int(input())
b = [0]*colors
for i in range(0, colors):
    b[i] = int(input())

mult = 1
for i in range(0, colors):
    if i != colors-1:
        mult *= orden(b, i)
    else:
        mult *= b[colors-1]

print(mult)","def factorial(n):

    result = 1
    for i in range(2, n + 1):
        result *= i
    return result

def count_ways(k, c):

    total_balls = sum(c)

    MOD = 1000000007

    ways = factorial(total_balls)

    for count in c:
        ways = (ways * pow(factorial(count), MOD - 2, MOD)) % MOD

    for i in range(k - 1):
        ways = (ways * (c[i] - i)) % MOD
    
    return ways

import sys
input = sys.stdin.read
data = input().splitlines()

k = int(data[0])
c = [int(data[i]) for i in range(1, k + 1)]

result = count_ways(k, c)
print(result)"
0,none,none,none,['none'],"Today on a lecture about strings Gerald learned a new definition of string equivalency. Two strings *a* and *b* of equal length are called equivalent in one of the two cases: 
 1.  They are equal. 1.  If we split string *a* into two halves of the same size *a*1 and *a*2, and string *b* into two halves of the same size *b*1 and *b*2, then one of the following is correct:   *a*1 is equivalent to *b*1, and *a*2 is equivalent to *b*2 1.  *a*1 is equivalent to *b*2, and *a*2 is equivalent to *b*1 
As a home task, the teacher gave two strings to his students and asked to determine if they are equivalent.

Gerald has already completed this home task. Now it's your turn!",The first two lines of the input contain two strings given by the teacher. Each of them has the length from 1 to 200<=000 and consists of lowercase English letters. The strings have the same length.,"Print ""YES"" (without the quotes), if these two strings are equivalent, and ""NO"" (without the quotes) otherwise.","['aaba\nabaa\n', 'aabb\nabab\n']","['YES\n', 'NO\n']","In the first sample you should split the first string into strings ""aa"" and ""ba"", the second one — into strings ""ab"" and ""aa"". ""aa"" is equivalent to ""aa""; ""ab"" is equivalent to ""ba"" as ""ab"" = ""a"" + ""b"", ""ba"" = ""b"" + ""a"".

In the second sample the first string can be splitted into strings ""aa"" and ""bb"", that are equivalent only to themselves. That's why string ""aabb"" is equivalent only to itself and to string ""bbaa"".",WRONG_ANSWER,"def streq(a, ai, af, b, bi, bf, l):
    eq = True
    for i in range(l):
        if a[ai+i] != b[bi+i]:
            eq = False
    if eq:
        return True
    
    if l % 2 != 0:
        return False
    half = l//2
     
    return (streq(a, ai, half, b, bi, half, half) and streq(a, half, af, b, half, bf, half)) or (streq(a, ai, half, b, half, bf, half) and streq(a, half, af, b, bi, half, half))

a = input()
b = input()
l = len(a)

if streq(a, 0, l, b, 0, l, l):
    print(""YES"")
else:
    print(""NO"")","def are_equivalent(a, b):

    if a == b:
        return True

    if len(a) % 2 != 0:
        return False

    mid = len(a) // 2
    a1, a2 = a[:mid], a[mid:]
    b1, b2 = b[:mid], b[mid:]

    return (are_equivalent(a1, b1) and are_equivalent(a2, b2)) or \
           (are_equivalent(a1, b2) and are_equivalent(a2, b1))

a = input().strip()
b = input().strip()

print(""YES"" if are_equivalent(a, b) else ""NO"")"
331,A2,Oh Sweet Beaverette,PROGRAMMING,"['data structures', 'sortings']","— Oh my sweet Beaverette, would you fancy a walk along a wonderful woodland belt with me?  

 — Of course, my Smart Beaver! Let us enjoy the splendid view together. How about Friday night? 

At this point the Smart Beaver got rushing. Everything should be perfect by Friday, so he needed to prepare the belt to the upcoming walk. He needed to cut down several trees.

Let's consider the woodland belt as a sequence of trees. Each tree *i* is described by the esthetic appeal *a**i* — some trees are very esthetically pleasing, others are 'so-so', and some trees are positively ugly!

The Smart Beaver calculated that he needed the following effects to win the Beaverette's heart: 
 -  The first objective is to please the Beaverette: the sum of esthetic appeal of the remaining trees must be maximum possible; -  the second objective is to surprise the Beaverette: the esthetic appeal of the first and the last trees in the resulting belt must be the same; -  and of course, the walk should be successful: there must be at least two trees in the woodland belt left. 
Now help the Smart Beaver! Which trees does he need to cut down to win the Beaverette's heart?","The first line contains a single integer *n* — the initial number of trees in the woodland belt, 2<=≤<=*n*. The second line contains space-separated integers *a**i* — the esthetic appeals of each tree. All esthetic appeals do not exceed 109 in their absolute value.
 -  to get 30 points, you need to solve the problem with constraints: *n*<=≤<=100 (subproblem A1); -  to get 100 points, you need to solve the problem with constraints: *n*<=≤<=3·105 (subproblems A1+A2).","In the first line print two integers — the total esthetic appeal of the woodland belt after the Smart Beaver's intervention and the number of the cut down trees *k*.

In the next line print *k* integers — the numbers of the trees the Beaver needs to cut down. Assume that the trees are numbered from 1 to *n* from left to right.

If there are multiple solutions, print any of them. It is guaranteed that at least two trees have equal esthetic appeal.","['5\n1 2 3 1 2\n', '5\n1 -2 3 1 -2\n']","['8 1\n1 ', '5 2\n2 5 ']",none,WRONG_ANSWER,"from math import inf

def solve_task5():
    n = int(input())
    trees = tuple(map(int, input().split("" "")))
    d = {}
    max_rating = -1 * inf
    begin_tree = 0
    end_tree = 0
    current_sum = 0
    for i in range(n):
        if trees[i] in d:
            d[trees[i]][1], d[trees[i]][2] = i, current_sum - d[trees[i]][2]
        else:
            d[trees[i]] = [i, -1, current_sum]
        if trees[i] > 0:
            current_sum += trees[i]
    for key in d.keys():
        if d[key][1] == -1:
            continue
        if key > 0:
            temp_sum = d[key][2] + key
        else:
            temp_sum = d[key][2] + (key * 2)
        if temp_sum > max_rating:
            max_rating, begin_tree, end_tree = temp_sum, d[key][0], d[key][1]
    deleted_trees = list(range(begin_tree)) + list(range(end_tree + 1, n))
    for i in range(begin_tree + 1, end_tree):
        if trees[i] < 0:
            deleted_trees.append(i)
    deleted_trees.sort()
    deleted_trees = [el + 1 for el in deleted_trees]
    k = len(deleted_trees)
    return "" "".join([str(max_rating), str(k)]) + ""\n"" + "" "".join([str(el) for el in deleted_trees])

result = solve_task5()
print(result)","def max_aesthetic_belt(trees):
    n = len(trees)

    appeal_indices = {}
    
    for i in range(n):
        if trees[i] in appeal_indices:
            appeal_indices[trees[i]].append(i + 1)
        else:
            appeal_indices[trees[i]] = [i + 1]

    max_sum = float('-inf')
    best_first, best_last = -1, -1
    cut_indices = []

    for appeal, indices in appeal_indices.items():
        if len(indices) < 2:
            continue

        first = indices[0]
        last = indices[-1]

        current_sum = sum(trees[i - 1] for i in range(first, last + 1))

        if current_sum > max_sum:
            max_sum = current_sum
            best_first = first
            best_last = last
            cut_indices = [i for i in range(1, n + 1) if i < first or i > last]

    return max_sum, len(cut_indices), cut_indices

n = int(input().strip())
trees = list(map(int, input().strip().split()))

total_aesthetic, cut_count, cut_indices = max_aesthetic_belt(trees)

print(total_aesthetic, cut_count)
if cut_count > 0:
    print(' '.join(map(str, cut_indices)))"
919,B,Perfect Number,PROGRAMMING,"['binary search', 'brute force', 'dp', 'implementation', 'number theory']","We consider a positive integer perfect, if and only if the sum of its digits is exactly $10$. Given a positive integer $k$, your task is to find the $k$-th smallest perfect positive integer.","A single line with a positive integer $k$ ($1 \leq k \leq 10\,000$).","A single number, denoting the $k$-th smallest perfect integer.","['1\n', '2\n']","['19\n', '28\n']",The first perfect integer is $19$ and the second one is $28$.,TIME_LIMIT_EXCEEDED,"def sum_digits(n):
    if n == 0:
        return 0
    else:
        return n % 10 + sum_digits(n // 10)

perfect_numbers = []

MAX = 15000000
for i in range(MAX):
    if sum_digits(i) == 10:
        perfect_numbers.append(i)

print(perfect_numbers[int(input()) - 1])","def sum_of_digits(n):
    """"""Returns the sum of the digits of the number n.""""""
    return sum(int(digit) for digit in str(n))

def find_kth_perfect_integer(k):
    """"""Finds the k-th smallest perfect positive integer.""""""
    perfect_integers = []
    current_number = 19

    while len(perfect_integers) < k:
        if sum_of_digits(current_number) == 10:
            perfect_integers.append(current_number)
        current_number += 1

    return perfect_integers[-1]

k = int(input().strip())

print(find_kth_perfect_integer(k))"
757,B,Bash's Big Day,PROGRAMMING,"['greedy', 'math', 'number theory']","Bash has set out on a journey to become the greatest Pokemon master. To get his first Pokemon, he went to Professor Zulu's Lab. Since Bash is Professor Zulu's favourite student, Zulu allows him to take as many Pokemon from his lab as he pleases.

But Zulu warns him that a group of *k*<=&gt;<=1 Pokemon with strengths {*s*1,<=*s*2,<=*s*3,<=...,<=*s**k*} tend to fight among each other if *gcd*(*s*1,<=*s*2,<=*s*3,<=...,<=*s**k*)<==<=1 (see notes for *gcd* definition).

Bash, being smart, does not want his Pokemon to fight among each other. However, he also wants to maximize the number of Pokemon he takes from the lab. Can you help Bash find out the maximum number of Pokemon he can take? 

Note: A Pokemon cannot fight with itself.","The input consists of two lines.

The first line contains an integer *n* (1<=≤<=*n*<=≤<=105), the number of Pokemon in the lab.

The next line contains *n* space separated integers, where the *i*-th of them denotes *s**i* (1<=≤<=*s**i*<=≤<=105), the strength of the *i*-th Pokemon.",Print single integer — the maximum number of Pokemons Bash can take.,"['3\n2 3 4\n', '5\n2 3 4 6 7\n']","['2\n', '3\n']","*gcd* (greatest common divisor) of positive integers set {*a*<sub class=""lower-index"">1</sub>, *a*<sub class=""lower-index"">2</sub>, ..., *a*<sub class=""lower-index"">*n*</sub>} is the maximum positive integer that divides all the integers {*a*<sub class=""lower-index"">1</sub>, *a*<sub class=""lower-index"">2</sub>, ..., *a*<sub class=""lower-index"">*n*</sub>}.

In the first sample, we can take Pokemons with strengths {2, 4} since *gcd*(2, 4) = 2.

In the second sample, we can take Pokemons with strengths {2, 4, 6}, and there is no larger group with *gcd* ≠ 1.",COMPILATION_ERROR,"using namespace std;
/*-------------------------------------------------------------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------------------------------------------------------------*/
const int imax=2147483647;
const int imin=-2147483648;
const int mod=1e9+7;
const int N=1e5+10;
bool prime[N];
int factorials[N];
/*-------------------------------------------------------------------------------------------------------------------------------------*/
typedef priority_queue<int> maxheap;
typedef priority_queue<int,vector<int>,greater<int>> minheap;
/*-------------------------------------------------------------------------------------------------------------------------------------*/
void _print(int t) {cerr << t;}
void _print(unsigned int t) {cerr << t;}
void _print(string t) {cerr << t;}
void _print(char t) {cerr << t;}
void _print(long double t) {cerr << t;}
void _print(double t) {cerr << t;}
template <class T, class V> void _print(pair <T, V> p);
template <class T> void _print(vector <T> v);
template <class T> void _print(set <T> v);
template <class T, class V> void _print(map <T, V> v);
template <class T> void _print(multiset <T> v);
template <class T, class V> void _print(pair <T, V> p) {cerr << ""{""; _print(p.first); cerr << "",""; _print(p.second); cerr << ""}"";}
template <class T> void _print(vector <T> v) {cerr << ""[ ""; for (T i : v) {_print(i); cerr << "" "";} cerr << ""]"";}
template <class T> void _print(set <T> v) {cerr << ""[ ""; for (T i : v) {_print(i); cerr << "" "";} cerr << ""]"";}
template <class T> void _print(multiset <T> v) {cerr << ""[ ""; for (T i : v) {_print(i); cerr << "" "";} cerr << ""]"";}
template <class T, class V> void _print(map <T, V> v) {cerr << ""[ ""; for (auto i : v) {_print(i); cerr << "" "";} cerr << ""]"";}
template <class T, class V> void _print(unordered_map <T, V> v) {cerr << ""[ ""; for (auto i : v) {_print(i); cerr << "" "";} cerr << ""]"";}
/*-------------------------------------------------------------------------------------------------------------------------------------*/
void IO(){
    ios_base::sync_with_stdio(false);cin.tie(NULL);

        freopen(""input.txt"", ""r"", stdin);freopen(""uttar.txt"", ""w"", stdout);freopen(""error.txt"", ""w"", stderr);

}
/*-------------------------------------------------------------------------------------------------------------------------------------*/
void seive(){memset(prime,true,sizeof(prime));for(int p=2;p*p<=N;p++){if (prime[p] == true){for(int j=p*p;j<=N;j+=p){prime[j]=false;}}}}
void factorial(){factorials[0]=factorials[1]=1;for(int i=2;i<N;i++){factorials[i]=factorials[i-1]*i;}}
int set_bits(int n){if(n==0){return 0;}return (n&1) + set_bits(n>>1);}
void swap(auto &a, auto &b){a^=b;b^=a;a^=b;}
unordered_map<int,int> Counter(vector<int> &a){unordered_map<int,int> mp;for(auto &i : a){mp[i]++;}return mp;}
void input(vector<int> &arr){for(int &i : arr){cin>>i;}}
/*-------------------------------------------------------------------------------------------------------------------------------------*/
void solve(){
    int n;
    cin>>n;
    unordered_map<int,int> mp;
    vector<int> arr(n);
    for(int &i : arr){
        cin>>i;
        mp[i]++;
    }
    int res = 1;
    for(int i = 2; i < 100001;i++){
        int sum = 0;
        for(int j = i;j < 100001;j+=i){
            sum += mp[j];
        }
        res = max(res, sum);
    }
    cout<<res<<endl;
}
int32_t main(){
    IO();
    int t;t=1;
    //cin>>t;
    while(t--){
        solve();
    }
    return 0;
}
/*-------------------------------------------------------------------------------------------------------------------------------------*/","from math import gcd
from functools import reduce
from collections import Counter

def max_pokemons(n, strengths):

    count = Counter(strengths)
    max_count = 0

    for strength in count:
        current_group = []

        for s in count:
            if gcd(strength, s) > 1:
                current_group.append(s)

        max_count = max(max_count, sum(count[s] for s in current_group))

    return max_count

n = int(input())
strengths = list(map(int, input().split()))

result = max_pokemons(n, strengths)
print(result)"
109,A,Lucky Sum of Digits,PROGRAMMING,"['brute force', 'implementation']","Petya loves lucky numbers. We all know that lucky numbers are the positive integers whose decimal representations contain only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.

Petya wonders eagerly what minimum lucky number has the sum of digits equal to *n*. Help him cope with the task.",The single line contains an integer *n* (1<=≤<=*n*<=≤<=106) — the sum of digits of the required lucky number.,"Print on the single line the result — the minimum lucky number, whose sum of digits equals *n*. If such number does not exist, print -1.","['11\n', '10\n']","['47\n', '-1\n']",none,WRONG_ANSWER,"import sys
coins=[4,7]
sum=int(input())

def minCoins(coins, m, V):

    if (V == 0):
        return 0

    res = sys.maxsize

    for i in range(0, m):
        if (coins[i] <= V):
            sub_res = minCoins(coins, m, V - coins[i])

            if (sub_res != sys.maxsize and sub_res + 1 < res):
                res = sub_res + 1
    return res
a=minCoins(coins,2,sum)
if a<sum:
    for i in range(a):
        if 4*i+7*(a-1)==sum:
            print(""4""*i+""7""*(a-1))
            break
else:
    print(-1)","def minimum_lucky_number(n):

    if n < 4:
        return -1

    lucky_number = []

    while n >= 7:
        lucky_number.append(7)
        n -= 7

    if n > 0:
        lucky_number.append(n)

    if all(d in [4, 7] for d in lucky_number):

        lucky_number.sort()
        return ''.join(map(str, lucky_number))
    return -1

n_values = [int(line.strip()) for line in input().strip().split()]

results = [minimum_lucky_number(n) for n in n_values]
print('\n'.join(map(str, results)))"
320,B,Ping-Pong (Easy Version),PROGRAMMING,"['dfs and similar', 'graphs']","In this problem at each moment you have a set of intervals. You can move from interval (*a*,<=*b*) from our set to interval (*c*,<=*d*) from our set if and only if *c*<=&lt;<=*a*<=&lt;<=*d* or *c*<=&lt;<=*b*<=&lt;<=*d*. Also there is a path from interval *I*1 from our set to interval *I*2 from our set if there is a sequence of successive moves starting from *I*1 so that we can reach *I*2.

Your program should handle the queries of the following two types:
 1.  ""1 x y"" (*x*<=&lt;<=*y*) — add the new interval (*x*,<=*y*) to the set of intervals. The length of the new interval is guaranteed to be strictly greater than all the previous intervals.1.  ""2 a b"" (*a*<=≠<=*b*) — answer the question: is there a path from *a*-th (one-based) added interval to *b*-th (one-based) added interval? 
Answer all the queries. Note, that initially you have an empty set of intervals.","The first line of the input contains integer *n* denoting the number of queries, (1<=≤<=*n*<=≤<=100). Each of the following lines contains a query as described above. All numbers in the input are integers and don't exceed 109 by their absolute value.

It's guaranteed that all queries are correct.","For each query of the second type print ""YES"" or ""NO"" on a separate line depending on the answer.",['5\n1 1 5\n1 5 11\n2 1 2\n1 2 9\n2 1 2\n'],['NO\nYES\n'],none,WRONG_ANSWER,"import sys
input = lambda: sys.stdin.readline().rstrip()

class UnionFind:
	def __init__(self, n):
		self.parent = list(range(n))
 
	def find(self, a):
		acopy = a
		while a != self.parent[a]:
			a = self.parent[a]
		while acopy != a:
			self.parent[acopy], acopy = a, self.parent[acopy]
		return a
 
	def merge(self, a, b):
		self.parent[self.find(b)] = self.find(a)

N = int(input())
uni = UnionFind(N)
A = []
for _ in range(N):
    t,x,y = map(int, input().split())
    if t==1:
        m = len(A)
        for i,(a,b) in enumerate(A):
            if a<x<b or a<y<b:
                uni.merge(i,m)
        A.append((x,y))
    else:
        if uni.find(x-1)==uni.find(y-1):
            print('YES')
        else:
            print('NO')","def can_move(interval1, interval2):

    a, b = interval1
    c, d = interval2
    return (c <= a <= d) or (c <= b <= d)

def dfs(start_index, target_index, visited, intervals):

    if start_index == target_index:
        return True
    visited.add(start_index)
    for next_index in range(len(intervals)):
        if next_index not in visited and can_move(intervals[start_index], intervals[next_index]):
            if dfs(next_index, target_index, visited, intervals):
                return True
    return False

def main(queries):
    intervals = []
    results = []
    for query in queries:
        parts = list(map(int, query.split()))
        if parts[0] == 1:

            intervals.append((parts[1], parts[2]))
        elif parts[0] == 2:

            a, b = parts[1] - 1, parts[2] - 1
            visited = set()
            if dfs(a, b, visited, intervals):
                results.append(""YES"")
            else:
                results.append(""NO"")
    return results

input_data = ['5', '1 1 5', '1 5 11', '2 1 2', '1 2 9', '2 1 2']
n = int(input_data[0])
queries = input_data[1:n + 1]
output = main(queries)
print('\n'.join(output))"
851,B,Arpa and an exam about geometry,PROGRAMMING,"['geometry', 'math']","Arpa is taking a geometry exam. Here is the last problem of the exam.

You are given three points *a*,<=*b*,<=*c*.

Find a point and an angle such that if we rotate the page around the point by the angle, the new position of *a* is the same as the old position of *b*, and the new position of *b* is the same as the old position of *c*.

Arpa is doubting if the problem has a solution or not (i.e. if there exists a point and an angle satisfying the condition). Help Arpa determine if the question has a solution or not.","The only line contains six integers *a**x*,<=*a**y*,<=*b**x*,<=*b**y*,<=*c**x*,<=*c**y* (|*a**x*|,<=|*a**y*|,<=|*b**x*|,<=|*b**y*|,<=|*c**x*|,<=|*c**y*|<=≤<=109). It's guaranteed that the points are distinct.","Print ""Yes"" if the problem has a solution, ""No"" otherwise.

You can print each letter in any case (upper or lower).","['0 1 1 1 1 0\n', '1 1 0 0 1000 1000\n']","['Yes\n', 'No\n']","In the first sample test, rotate the page around (0.5, 0.5) by <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/9d845923f4d356a48d8ede337db0303821311f0c.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>.

In the second sample test, you can't find any solution.",RUNTIME_ERROR,"from math import asin
from math import sqrt
from math import fabs
def solution():
    ax, ay, bx, by, cx, cy = map(int, input().split())
    
    k = 0
    if ax - bx != 0:
        k = (ay - by)/(ax - bx)
    b = by - k*bx
    if cy == k*cx + b:
        print('No')
        return
    
    d = 2*(ax*(by - cy) + bx*(cy - ay) + cx*(ay - by))
    x = ((ax**2 + ay**2)*(by - cy) + (bx**2 + by**2)*(cy - ay) + (cx**2 + cy**2)*(ay - by))/d
    y = ((ax**2 + ay**2)*(cx - bx) + (bx**2 + by**2)*(ax - cx) + (cx**2 + cy**2)*(bx - ax))/d
    
    a = sqrt((bx - ax)**2 + (by - ay)**2)
    b = sqrt((cx - bx)**2 + (cy - by)**2)
    r = sqrt((ax - x)**2 + (ay - y)**2)
    if asin(fabs(a)/(2*r)) != asin(fabs(b)/(2*r)):
        print('No')
        return
    
    print('Yes')
    
solution()","import math

def can_rotate_points(ax, ay, bx, by, cx, cy):

    ab = math.sqrt((bx - ax) ** 2 + (by - ay) ** 2)
    bc = math.sqrt((cx - bx) ** 2 + (cy - by) ** 2)

    return math.isclose(ab, bc)

input_data = input().strip().split()
ax, ay, bx, by, cx, cy = map(int, input_data)

if can_rotate_points(ax, ay, bx, by, cx, cy):
    print(""Yes"")
else:
    print(""No"")"
0,none,none,none,['none'],"As we all know Barney's job is ""PLEASE"" and he has not much to do at work. That's why he started playing ""cups and key"". In this game there are three identical cups arranged in a line from left to right. Initially key to Barney's heart is under the middle cup.

Then at one turn Barney swaps the cup in the middle with any of other two cups randomly (he choses each with equal probability), so the chosen cup becomes the middle one. Game lasts *n* turns and Barney independently choses a cup to swap with the middle one within each turn, and the key always remains in the cup it was at the start.

After *n*-th turn Barney asks a girl to guess which cup contains the key. The girl points to the middle one but Barney was distracted while making turns and doesn't know if the key is under the middle cup. That's why he asked you to tell him the probability that girl guessed right.

Number *n* of game turns can be extremely large, that's why Barney did not give it to you. Instead he gave you an array *a*1,<=*a*2,<=...,<=*a**k* such that 

in other words, *n* is multiplication of all elements of the given array.

Because of precision difficulties, Barney asked you to tell him the answer as an irreducible fraction. In other words you need to find it as a fraction *p*<=/<=*q* such that , where  is the greatest common divisor. Since *p* and *q* can be extremely large, you only need to find the remainders of dividing each of them by 109<=+<=7.

Please note that we want  of *p* and *q* to be 1, not  of their remainders after dividing by 109<=+<=7.","The first line of input contains a single integer *k* (1<=≤<=*k*<=≤<=105) — the number of elements in array Barney gave you.

The second line contains *k* integers *a*1,<=*a*2,<=...,<=*a**k* (1<=≤<=*a**i*<=≤<=1018) — the elements of the array.",In the only line of output print a single string *x*<=/<=*y* where *x* is the remainder of dividing *p* by 109<=+<=7 and *y* is the remainder of dividing *q* by 109<=+<=7.,"['1\n2\n', '3\n1 1 1\n']","['1/2\n', '0/1\n']",none,WRONG_ANSWER,"from fractions import Fraction
k=int(input(""""))
L=[int(i) for i in input("""").split()]
N=1
for i in L:
    N*=i
N=float(N)
def P(N):
    answer=float(1.00/3.00)*( (-1.00)**N*2.00**(1-N)+1.00)
    return Fraction.from_float(answer).limit_denominator()
answer=P(N)
print(str(answer.numerator)+""/""+str(answer.denominator))","from math import gcd
from functools import reduce

def cups_and_key_probability(k, a):

    n = reduce(lambda x, y: x * y, a, 1)

    if n % 2 == 0:
        p = 1
        q = 2
    else:
        p = 1
        q = 1

    common_divisor = gcd(p, q)
    p //= common_divisor
    q //= common_divisor
    
    return p, q

MOD = 10**9 + 7

import sys

input = sys.stdin.read
data = input().splitlines()

k = int(data[0])
a = list(map(int, data[1].split()))

x, y = cups_and_key_probability(k, a)

print(f""{x % MOD}/{y % MOD}"")"
799,A,Carrot Cakes,PROGRAMMING,"['brute force', 'implementation']","In some game by Playrix it takes *t* minutes for an oven to bake *k* carrot cakes, all cakes are ready at the same moment *t* minutes after they started baking. Arkady needs at least *n* cakes to complete a task, but he currently don't have any. However, he has infinitely many ingredients and one oven. Moreover, Arkady can build one more similar oven to make the process faster, it would take *d* minutes to build the oven. While the new oven is being built, only old one can bake cakes, after the new oven is built, both ovens bake simultaneously. Arkady can't build more than one oven.

Determine if it is reasonable to build the second oven, i.e. will it decrease the minimum time needed to get *n* cakes or not. If the time needed with the second oven is the same as with one oven, then it is unreasonable.","The only line contains four integers *n*, *t*, *k*, *d* (1<=≤<=*n*,<=*t*,<=*k*,<=*d*<=≤<=1<=000) — the number of cakes needed, the time needed for one oven to bake *k* cakes, the number of cakes baked at the same time, the time needed to build the second oven.","If it is reasonable to build the second oven, print ""YES"". Otherwise print ""NO"".","['8 6 4 5\n', '8 6 4 6\n', '10 3 11 4\n', '4 2 1 4\n']","['YES\n', 'NO\n', 'NO\n', 'YES\n']","In the first example it is possible to get 8 cakes in 12 minutes using one oven. The second oven can be built in 5 minutes, so after 6 minutes the first oven bakes 4 cakes, the second oven bakes 4 more ovens after 11 minutes. Thus, it is reasonable to build the second oven. 

In the second example it doesn't matter whether we build the second oven or not, thus it takes 12 minutes to bake 8 cakes in both cases. Thus, it is unreasonable to build the second oven.

In the third example the first oven bakes 11 cakes in 3 minutes, that is more than needed 10. It is unreasonable to build the second oven, because its building takes more time that baking the needed number of cakes using the only oven.",WRONG_ANSWER,"def solve():
    (n, t, k, d) = map(int ,input().split())

    T1 = t/k*n
    T2 = d + t/k*n/2

    return (T1 > T2)

t = 1
for _ in range(t):
    print(""YES"" if solve() else ""NO"")","def can_build_second_oven(n, t, k, d):

    time_with_one_oven = (n + k - 1) // k * t

    time_with_two_ovens = d + (n + k - 1) // k * t if d < time_with_one_oven else time_with_one_oven

    if time_with_two_ovens < time_with_one_oven:
        return ""YES""
    else:
        return ""NO""

inputs = [
    (8, 6, 4, 5), 
    (8, 6, 4, 6), 
    (10, 3, 11, 4), 
    (4, 2, 1, 4)
]

outputs = [can_build_second_oven(*case) for case in inputs]
print(outputs)"
255,A,Greg's Workout,PROGRAMMING,['implementation'],"Greg is a beginner bodybuilder. Today the gym coach gave him the training plan. All it had was *n* integers *a*1,<=*a*2,<=...,<=*a**n*. These numbers mean that Greg needs to do exactly *n* exercises today. Besides, Greg should repeat the *i*-th in order exercise *a**i* times.

Greg now only does three types of exercises: ""chest"" exercises, ""biceps"" exercises and ""back"" exercises. Besides, his training is cyclic, that is, the first exercise he does is a ""chest"" one, the second one is ""biceps"", the third one is ""back"", the fourth one is ""chest"", the fifth one is ""biceps"", and so on to the *n*-th exercise.

Now Greg wonders, which muscle will get the most exercise during his training. We know that the exercise Greg repeats the maximum number of times, trains the corresponding muscle the most. Help Greg, determine which muscle will get the most training.","The first line contains integer *n* (1<=≤<=*n*<=≤<=20). The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=25) — the number of times Greg repeats the exercises.","Print word ""chest"" (without the quotes), if the chest gets the most exercise, ""biceps"" (without the quotes), if the biceps gets the most exercise and print ""back"" (without the quotes) if the back gets the most exercise.

It is guaranteed that the input is such that the answer to the problem is unambiguous.","['2\n2 8\n', '3\n5 1 10\n', '7\n3 3 2 7 9 6 8\n']","['biceps\n', 'back\n', 'chest\n']","In the first sample Greg does 2 chest, 8 biceps and zero back exercises, so the biceps gets the most exercises.

In the second sample Greg does 5 chest, 1 biceps and 10 back exercises, so the back gets the most exercises.

In the third sample Greg does 18 chest, 12 biceps and 8 back exercises, so the chest gets the most exercise.",OK,"from sys import stdin, setrecursionlimit, stdout

def solve():

    n = int(stdin.readline())
    mas = [int(s) for s in stdin.readline().split()]
    k = 0
    ans = [0]*3

    for i in range(n):
        ans[k] += mas[i]
        k = (k + 1) % 3

    if ans[0] > ans[1] and ans[0] > ans[2]:
        print('chest')
    elif ans[1] > ans[0] and ans[1] > ans[2]:
        print('biceps')
    else:
        print('back')

if __name__ == '__main__':
    solve()","n = int(input())

a = list(map(int, input().split()))

chest = 0
biceps = 0
back = 0

for i in range(n):
    if i % 3 == 0:
        chest += a[i]
    elif i % 3 == 1:
        biceps += a[i]
    else:
        back += a[i]

if chest > biceps and chest > back:
    print(""chest"")
elif biceps > chest and biceps > back:
    print(""biceps"")
else:
    print(""back"")"
349,B,Color the Fence,PROGRAMMING,"['data structures', 'dp', 'greedy', 'implementation']","Igor has fallen in love with Tanya. Now Igor wants to show his feelings and write a number on the fence opposite to Tanya's house. Igor thinks that the larger the number is, the more chance to win Tanya's heart he has. 

Unfortunately, Igor could only get *v* liters of paint. He did the math and concluded that digit *d* requires *a**d* liters of paint. Besides, Igor heard that Tanya doesn't like zeroes. That's why Igor won't use them in his number.

Help Igor find the maximum number he can write on the fence.","The first line contains a positive integer *v* (0<=≤<=*v*<=≤<=106). The second line contains nine positive integers *a*1,<=*a*2,<=...,<=*a*9 (1<=≤<=*a**i*<=≤<=105).","Print the maximum number Igor can write on the fence. If he has too little paint for any digit (so, he cannot write anything), print -1.","['5\n5 4 3 2 1 2 3 4 5\n', '2\n9 11 1 12 5 8 9 10 6\n', '0\n1 1 1 1 1 1 1 1 1\n']","['55555\n', '33\n', '-1\n']",none,WRONG_ANSWER,"def main():
    v = int(input())
    aseq = read_ints()

    amin_idx = -1
    amin = float('inf')
    for i in range(9, 0, -1):
        if aseq[i-1] < amin:
            amin = aseq[i-1]
            amin_idx = i-1

    m = v // amin

    if m == 0:
        print(-1)
        return

    res = [amin_idx+1] * m
    rem = v - m * amin
    for i in range(m):
        if rem == 0:
            break
        for d in range(9, 0, -1):
            if rem + amin >= aseq[d-1] and d > amin_idx + 1:
                res[i] = d
                rem += amin
                rem -= aseq[d-1]
                break

    print(' '.join(map(str, res)))

def input(): return next(test).strip()
def read_ints(): return [int(c) for c in input().split()]
def print_lines(lst): print('\n'.join(map(str, lst)))

if __name__ == ""__main__"":
    import sys
    from os import environ as env
    if 'COMPUTERNAME' in env and 'L2A6HRI' in env['COMPUTERNAME']:
        sys.stdout = open('out.txt', 'w')
        sys.stdin = open('in.txt', 'r')

    test = iter(sys.stdin.readlines())

    main()","def max_number_with_paint(v, paint_requirements):

    paint_requirements = [0] + paint_requirements
    digits = []

    min_paint = float('inf')
    min_digit = -1
    for digit in range(1, 10):
        if paint_requirements[digit] <= v:
            if paint_requirements[digit] < min_paint:
                min_paint = paint_requirements[digit]
                min_digit = digit

    if min_digit == -1:
        return ""-1""

    max_count = v // min_paint
    remaining_paint = v % min_paint

    result = []
    
    for _ in range(max_count):

        for digit in range(9, 0, -1):
            if paint_requirements[digit] <= remaining_paint + min_paint:
                result.append(str(digit))
                remaining_paint -= (paint_requirements[digit] - min_paint)
                break

    return ''.join(result)

v = int(input().strip())
paint_requirements = list(map(int, input().strip().split()))

print(max_number_with_paint(v, paint_requirements))"
558,B,Amr and The Large Array,PROGRAMMING,['implementation'],"Amr has got a large array of size *n*. Amr doesn't like large arrays so he intends to make it smaller.

Amr doesn't care about anything in the array except the beauty of it. The beauty of the array is defined to be the maximum number of times that some number occurs in this array. He wants to choose the smallest subsegment of this array such that the beauty of it will be the same as the original array.

Help Amr by choosing the smallest subsegment possible.","The first line contains one number *n* (1<=≤<=*n*<=≤<=105), the size of the array.

The second line contains *n* integers *a**i* (1<=≤<=*a**i*<=≤<=106), representing elements of the array.","Output two integers *l*,<=*r* (1<=≤<=*l*<=≤<=*r*<=≤<=*n*), the beginning and the end of the subsegment chosen respectively.

If there are several possible answers you may output any of them.","['5\n1 1 2 2 1\n', '5\n1 2 2 3 1\n', '6\n1 2 2 1 1 2\n']","['1 5', '2 3', '1 5']","A subsegment *B* of an array *A* from *l* to *r* is an array of size *r* - *l* + 1 where *B*<sub class=""lower-index"">*i*</sub> = *A*<sub class=""lower-index"">*l* + *i* - 1</sub> for all 1 ≤ *i* ≤ *r* - *l* + 1",OK,"from sys import stdin

def main():
    n = int(stdin.readline())
    ar = list(map(int, stdin.readline().split()))
    c = [0] * (10 ** 6 + 1)
    mf = 0
    for elm in ar:
        c[elm] += 1
        if c[elm] > mf:
            mf = c[elm]
    start = 0
    end = 0
    lk = [0] * (10 ** 6 + 1)
    f = [0] * (n + 1)
    f[0] = n
    cf = 0
    ml = n + 1
    il = -1
    ir = -1
    while end < n:
        while end < n and cf < mf:
            f[lk[ar[end]]] -= 1
            lk[ar[end]] += 1
            f[lk[ar[end]]] += 1
            if lk[ar[end]] > cf:
                cf = lk[ar[end]]
            end += 1
        if cf == mf:
            if end - start < ml:
                ml = end - start
                il = start + 1
                ir = end
        while start < end and cf == mf:
            f[lk[ar[start]]] -= 1
            lk[ar[start]] -= 1
            f[lk[ar[start]]] += 1
            start += 1
            if f[cf] == 0:
                cf = cf - 1
            else:
                if end - start < ml:
                    ml = end - start
                    il = start + 1
                    ir = end
    print(il, ir)

if __name__ == ""__main__"":
    main()","from collections import defaultdict

def find_smallest_subsegment(n, array):

    frequency = defaultdict(int)
    first_pos = {}
    last_pos = {}
    
    for i in range(n):
        num = array[i]
        frequency[num] += 1
        if num not in first_pos:
            first_pos[num] = i
        last_pos[num] = i

    max_beauty = max(frequency.values())

    min_length = float('inf')
    result_l, result_r = 0, 0
    
    for num, count in frequency.items():
        if count == max_beauty:
            l = first_pos[num]
            r = last_pos[num]
            segment_length = r - l + 1
            if segment_length < min_length:
                min_length = segment_length
                result_l, result_r = l, r

    return result_l + 1, result_r + 1

n = int(input())
array = list(map(int, input().split()))

result = find_smallest_subsegment(n, array)

print(result[0], result[1])"
796,A,Buying A House,PROGRAMMING,"['brute force', 'implementation']","Zane the wizard had never loved anyone before, until he fell in love with a girl, whose name remains unknown to us.

The girl lives in house *m* of a village. There are *n* houses in that village, lining in a straight line from left to right: house 1, house 2, ..., house *n*. The village is also well-structured: house *i* and house *i*<=+<=1 (1<=≤<=*i*<=&lt;<=*n*) are exactly 10 meters away. In this village, some houses are occupied, and some are not. Indeed, unoccupied houses can be purchased.

You will be given *n* integers *a*1,<=*a*2,<=...,<=*a**n* that denote the availability and the prices of the houses. If house *i* is occupied, and therefore cannot be bought, then *a**i* equals 0. Otherwise, house *i* can be bought, and *a**i* represents the money required to buy it, in dollars.

As Zane has only *k* dollars to spare, it becomes a challenge for him to choose the house to purchase, so that he could live as near as possible to his crush. Help Zane determine the minimum distance from his crush's house to some house he can afford, to help him succeed in his love.","The first line contains three integers *n*, *m*, and *k* (2<=≤<=*n*<=≤<=100, 1<=≤<=*m*<=≤<=*n*, 1<=≤<=*k*<=≤<=100) — the number of houses in the village, the house where the girl lives, and the amount of money Zane has (in dollars), respectively.

The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (0<=≤<=*a**i*<=≤<=100) — denoting the availability and the prices of the houses.

It is guaranteed that *a**m*<==<=0 and that it is possible to purchase some house with no more than *k* dollars.","Print one integer — the minimum distance, in meters, from the house where the girl Zane likes lives to the house Zane can buy.","['5 1 20\n0 27 32 21 19\n', '7 3 50\n62 0 0 0 99 33 22\n', '10 5 100\n1 0 1 0 0 0 0 0 1 1\n']","['40', '30', '20']","In the first sample, with *k* = 20 dollars, Zane can buy only house 5. The distance from house *m* = 1 to house 5 is 10 + 10 + 10 + 10 = 40 meters.

In the second sample, Zane can buy houses 6 and 7. It is better to buy house 6 than house 7, since house *m* = 3 and house 6 are only 30 meters away, while house *m* = 3 and house 7 are 40 meters away.",OK,"__author__ = ""Daniel Mitre""

n, m, k = map(int, input().split())
prices = map(int, input().split())

def dist_to_girl(pos: int) -> int:
	return abs(pos - m)

buy = float('inf')
for idx, price in zip(range(1, n + 1), prices):
	if (price > 0) and (price <= k) and (dist_to_girl(idx) < dist_to_girl(buy)):
		buy = idx

print(dist_to_girl(buy) * 10)","n, m, k = map(int, input().split())

a = list(map(int, input().split()))

min_distance = float('inf')

for i in range(n):

    if a[i] > 0 and a[i] <= k:

        distance = abs(m - (i + 1)) * 10

        if distance < min_distance:
            min_distance = distance

print(min_distance)"
346,A,Alice and Bob,PROGRAMMING,"['games', 'math', 'number theory']","It is so boring in the summer holiday, isn't it? So Alice and Bob have invented a new game to play. The rules are as follows. First, they get a set of *n* distinct integers. And then they take turns to make the following moves. During each move, either Alice or Bob (the player whose turn is the current) can choose two distinct integers *x* and *y* from the set, such that the set doesn't contain their absolute difference |*x*<=-<=*y*|. Then this player adds integer |*x*<=-<=*y*| to the set (so, the size of the set increases by one).

If the current player has no valid move, he (or she) loses the game. The question is who will finally win the game if both players play optimally. Remember that Alice always moves first.","The first line contains an integer *n* (2<=≤<=*n*<=≤<=100) — the initial number of elements in the set. The second line contains *n* distinct space-separated integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=109) — the elements of the set.","Print a single line with the winner's name. If Alice wins print ""Alice"", otherwise print ""Bob"" (without quotes).","['2\n2 3\n', '2\n5 3\n', '3\n5 6 7\n']","['Alice\n', 'Alice\n', 'Bob\n']","Consider the first test sample. Alice moves first, and the only move she can do is to choose 2 and 3, then to add 1 to the set. Next Bob moves, there is no valid move anymore, so the winner is Alice.",WRONG_ANSWER,"len1 = int(input())
seq = list(map(int, input().split()))

def NWD(a, b):
	while b > 0:
		reszta = a % b
		a, b = b, reszta
	return a

nwd = NWD(seq[0], seq[1])

for n in range(2, len1):
	nwd = NWD(nwd, seq[n])

print(max(seq) // nwd)","def find_winner(n, elements):

    elements.sort()

    existing_numbers = set(elements)

    max_diff = 0

    for i in range(n):
        for j in range(i + 1, n):
            diff = abs(elements[j] - elements[i])
            if diff not in existing_numbers:
                max_diff += 1

    return ""Alice"" if max_diff % 2 == 1 else ""Bob""

n = int(input())
elements = list(map(int, input().split()))

print(find_winner(n, elements))"
446,A,DZY Loves Sequences,PROGRAMMING,"['dp', 'implementation', 'two pointers']","DZY has a sequence *a*, consisting of *n* integers.

We'll call a sequence *a**i*,<=*a**i*<=+<=1,<=...,<=*a**j* (1<=≤<=*i*<=≤<=*j*<=≤<=*n*) a subsegment of the sequence *a*. The value (*j*<=-<=*i*<=+<=1) denotes the length of the subsegment.

Your task is to find the longest subsegment of *a*, such that it is possible to change at most one number (change one number to any integer you want) from the subsegment to make the subsegment strictly increasing.

You only need to output the length of the subsegment you find.","The first line contains integer *n* (1<=≤<=*n*<=≤<=105). The next line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=109).",In a single line print the answer to the problem — the maximum length of the required subsegment.,['6\n7 2 3 1 5 6\n'],['5\n'],"You can choose subsegment *a*<sub class=""lower-index"">2</sub>, *a*<sub class=""lower-index"">3</sub>, *a*<sub class=""lower-index"">4</sub>, *a*<sub class=""lower-index"">5</sub>, *a*<sub class=""lower-index"">6</sub> and change its 3rd element (that is *a*<sub class=""lower-index"">4</sub>) to 4.",WRONG_ANSWER,"from collections import defaultdict as dd, deque as dq, Counter as ctr
import sys

from re import search
input = lambda: sys.stdin.readline().rstrip('\r\n')
 
from bisect import bisect_left as bl
from bisect import bisect_right as br

inp = lambda: int(sys.stdin.readline().rstrip(""\r\n""))
mi = lambda x=int : map(x, sys.stdin.readline().rstrip(""\r\n"").split())
li = lambda x=int: list(mi(x))
lb = lambda: list(map(int, sys.stdin.readline().rstrip(""\r\n"")))
ls = lambda: list(sys.stdin.readline().rstrip(""\r\n""))
bi = lambda n: bin(n).replace(""0b"", """")

def sbsq(a,s):
    i=0
    for x in s:
        if i>=len(a):
            break
        if x==a[i]:
            i+=1
    return i==len(a)

yn = ['No', 'Yes']
YN = ['NO', 'YES']
YY = ""YES""
NN = ""NO""
yy = ""Yes""
nn = ""No""
inf= sys.maxsize
mod=1e9+7

from math import log2
import heapq as hq

def main(kase):
    n=inp()
    a=li()
    if n==1:
        print(1)
        return
    elif n==2:
        print(2)
        return
    l=[0]*n
    r=[0]*n
    j=0
    for i in range(n):
        while j<n-1 and a[j+1]>a[j] or j<i:
            j+=1
        r[i]=j-i+1
    j=n-1
    for i in range(n-1,-1,-1):
        while j>0 and a[j-1]<a[j] or j>i:
            j-=1
        l[i]=i-j+1
    ans=0
    for i in range(1,n-1):
        if a[i-1]+1<a[i+1]:
            ans=max(ans,l[i-1]+1+r[i+1] )
    print(ans)

    pass
if __name__ == ""__main__"":
    test_Cases=1

    for i in range(test_Cases):
        main(i)","def longest_increasing_subsegment(n, a):

    max_length = 0

    for i in range(n):
        for j in range(i, n):

            subsegment = a[i:j+1]

            changes = 0

            for k in range(len(subsegment) - 1):
                if subsegment[k] >= subsegment[k + 1]:
                    changes += 1

            if changes <= 1:
                max_length = max(max_length, j - i + 1)

    return max_length

n = int(input().strip())
a = list(map(int, input().strip().split()))

result = longest_increasing_subsegment(n, a)
print(result)"
992,A,Nastya and an Array,PROGRAMMING,"['implementation', 'sortings']","Nastya owns too many arrays now, so she wants to delete the least important of them. However, she discovered that this array is magic! Nastya now knows that the array has the following properties:
 -  In one second we can add an arbitrary (possibly negative) integer to all elements of the array that are not equal to zero. -  When all elements of the array become equal to zero, the array explodes. 
Nastya is always busy, so she wants to explode the array as fast as possible. Compute the minimum time in which the array can be exploded.","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=105) — the size of the array.

The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (<=-<=105<=≤<=*a**i*<=≤<=105) — the elements of the array.",Print a single integer — the minimum number of seconds needed to make all elements of the array equal to zero.,"['5\n1 1 1 1 1\n', '3\n2 0 -1\n', '4\n5 -6 -5 1\n']","['1\n', '2\n', '4\n']","In the first example you can add  - 1 to all non-zero elements in one second and make them equal to zero.

In the second example you can add  - 2 on the first second, then the array becomes equal to [0, 0,  - 3]. On the second second you can add 3 to the third (the only non-zero) element.",TIME_LIMIT_EXCEEDED,"def magic_array(array):
  n = len(array)
  time = 0
  while True:
    non_zero_count = 0
    minimum = float('inf')
    for i in range(n):
      if array[i] != 0:
        non_zero_count += 1
        minimum = min(minimum, array[i])
    if non_zero_count == 0:
      return time
    for i in range(n):
      if array[i] != 0:
        array[i] += -minimum
    time += 1

if __name__ == '__main__':
  a=int(input())
  array = list(map(int,input().split()))
  
  time = magic_array(array)

  print(time)","def min_time_to_explode(n, arr):

    non_zero_elements = {x for x in arr if x != 0}

    return len(non_zero_elements)

n = int(input().strip())
arr = list(map(int, input().strip().split()))

result = min_time_to_explode(n, arr)
print(result)"
416,A,Guess a number!,PROGRAMMING,"['greedy', 'implementation', 'two pointers']","A TV show called ""Guess a number!"" is gathering popularity. The whole Berland, the old and the young, are watching the show.

The rules are simple. The host thinks of an integer *y* and the participants guess it by asking questions to the host. There are four types of acceptable questions:
 -  Is it true that *y* is strictly larger than number *x*? -  Is it true that *y* is strictly smaller than number *x*? -  Is it true that *y* is larger than or equal to number *x*? -  Is it true that *y* is smaller than or equal to number *x*? 
On each question the host answers truthfully, ""yes"" or ""no"".

Given the sequence of questions and answers, find any integer value of *y* that meets the criteria of all answers. If there isn't such value, print ""Impossible"".","The first line of the input contains a single integer *n* (1<=≤<=*n*<=≤<=10000) — the number of questions (and answers). Next *n* lines each contain one question and one answer to it. The format of each line is like that: ""sign x answer"", where the sign is:
 -  ""&gt;"" (for the first type queries), -  ""&lt;"" (for the second type queries), -  ""&gt;="" (for the third type queries), -  ""&lt;="" (for the fourth type queries). 
All values of *x* are integer and meet the inequation <=-<=109<=≤<=*x*<=≤<=109. The answer is an English letter ""Y"" (for ""yes"") or ""N"" (for ""no"").

Consequtive elements in lines are separated by a single space.","Print any of such integers *y*, that the answers to all the queries are correct. The printed number *y* must meet the inequation <=-<=2·109<=≤<=*y*<=≤<=2·109. If there are many answers, print any of them. If such value doesn't exist, print word ""Impossible"" (without the quotes).","['4\n&gt;= 1 Y\n&lt; 3 N\n&lt;= -3 N\n&gt; 55 N\n', '2\n&gt; 100 Y\n&lt; -100 Y\n']","['17\n', 'Impossible\n']",none,RUNTIME_ERROR,"def sort_list(list1, list2): 
  
    zipped_pairs = zip(list2, list1) 
  
    z = [x for _, x in sorted(zipped_pairs)] 
      
    return z 
n=int(input())
c=[0]*n
p=[0]*n
ind=[0]*n
for i in range(n):
    c[i],p[i]=map(int,input().split())
    ind[i]=i
c=sort_list(c,p)
ind=sort_list(ind,p)
ind.reverse()
p.sort(reverse=True)
c.reverse()
ans=0
cost=0
k=int(input())
l=list(map(int,input().split()))
d=dict()
for i in range(n):
    ind1=-1
    cur=999999999999999999
    for j in range(k):
        if c[i]<=l[j] and l[j]<=cur:
            ind1=j
            cur=l[j]
    if cur!=999999999999999999:
        ans+=1
        cost+=p[i]
        l[ind1]=999999999999999999999999
        d.update({ind[i]:ind1+1})
print(ans,cost)
for i in sorted(d.keys()):
    print(i+1,d[i]+1)","def guess_the_number(queries):
    min_y = -2 * (10**9)
    max_y = 2 * (10**9)

    for query in queries:
        sign, x, answer = query.split()
        x = int(x)

        if sign == '>':
            if answer == 'Y':
                min_y = max(min_y, x + 1)
            else:
                max_y = min(max_y, x)
        elif sign == '<':
            if answer == 'Y':
                max_y = min(max_y, x - 1)
            else:
                min_y = max(min_y, x)
        elif sign == '>=':
            if answer == 'Y':
                min_y = max(min_y, x)
            else:
                max_y = min(max_y, x - 1)
        elif sign == '<=':
            if answer == 'Y':
                max_y = min(max_y, x)
            else:
                min_y = max(min_y, x + 1)

    if min_y <= max_y:
        return min_y
    else:
        return ""Impossible""

n = int(input().strip())
queries = [input().strip() for _ in range(n)]

result = guess_the_number(queries)
print(result)"
264,A,Escape from Stones,PROGRAMMING,"['constructive algorithms', 'data structures', 'implementation', 'two pointers']","Squirrel Liss lived in a forest peacefully, but unexpected trouble happens. Stones fall from a mountain. Initially Squirrel Liss occupies an interval [0,<=1]. Next, *n* stones will fall and Liss will escape from the stones. The stones are numbered from 1 to *n* in order.

The stones always fall to the center of Liss's interval. When Liss occupies the interval [*k*<=-<=*d*,<=*k*<=+<=*d*] and a stone falls to *k*, she will escape to the left or to the right. If she escapes to the left, her new interval will be [*k*<=-<=*d*,<=*k*]. If she escapes to the right, her new interval will be [*k*,<=*k*<=+<=*d*].

You are given a string *s* of length *n*. If the *i*-th character of *s* is ""l"" or ""r"", when the *i*-th stone falls Liss will escape to the left or to the right, respectively. Find the sequence of stones' numbers from left to right after all the *n* stones falls.","The input consists of only one line. The only line contains the string *s* (1<=≤<=|*s*|<=≤<=106). Each character in *s* will be either ""l"" or ""r"".",Output *n* lines — on the *i*-th line you should print the *i*-th stone's number from the left.,"['llrlr\n', 'rrlll\n', 'lrlrr\n']","['3\n5\n4\n2\n1\n', '1\n2\n5\n4\n3\n', '2\n4\n5\n3\n1\n']","In the first example, the positions of stones 1, 2, 3, 4, 5 will be <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/58fdb5684df807bfcb705a9da9ce175613362b7d.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>, respectively. So you should print the sequence: 3, 5, 4, 2, 1.",OK,"def main():
    line = input()
    l = [None] * len(line)
    ptr1 = 0
    ptr2 = len(line)-1
    counter = 0
    for c in line:
        counter += 1
        if c == 'l':
            l[ptr2] = counter
            ptr2 -= 1
        else:
            l[ptr1] = counter
            ptr1 += 1
    for n in l:
        print(n)

if __name__ == ""__main__"":
    main()","def find_stone_sequence(s):
    n = len(s)
    left = []
    right = []

    for i in range(n):
        if s[i] == 'l':
            left.append(i + 1)
        else:
            right.append(i + 1)

    stone_sequence = left[::-1] + right
    
    return stone_sequence

s = input().strip()

result = find_stone_sequence(s)

for stone in result:
    print(stone)"
47,B,Coins,PROGRAMMING,['implementation'],"One day Vasya came across three Berland coins. They didn't have any numbers that's why Vasya didn't understand how their denominations differ. He supposed that if one coin is heavier than the other one, then it should be worth more. Vasya weighed all the three pairs of coins on pan balance scales and told you the results. Find out how the deminations of the coins differ or if Vasya has a mistake in the weighting results. No two coins are equal.","The input data contains the results of all the weighting, one result on each line. It is guaranteed that every coin pair was weighted exactly once. Vasya labelled the coins with letters «A», «B» and «C». Each result is a line that appears as (letter)(&gt; or &lt; sign)(letter). For example, if coin ""A"" proved lighter than coin ""B"", the result of the weighting is A&lt;B.","It the results are contradictory, print Impossible. Otherwise, print without spaces the rearrangement of letters «A», «B» and «C» which represent the coins in the increasing order of their weights.","['A&gt;B\nC&lt;B\nA&gt;C\n', 'A&lt;B\nB&gt;C\nC&gt;A\n']","['CBA', 'ACB']",none,OK,"def find_coin_order(weighing_results):
    relationships = {'A': set(), 'B': set(), 'C': set()}

    for result in weighing_results:
        coin1, sign, coin2 = result[0], result[1], result[2]
        if sign == '>':
            relationships[coin1].add(coin2)
        else:
            relationships[coin2].add(coin1)

    heaviest = [coin for coin in relationships if not relationships[coin]]
    lightest = [coin for coin in relationships if len(relationships[coin]) == 2]

    if not heaviest or not lightest:
        return ""Impossible""
    else:
        middle = list(set(relationships.keys()) - set(heaviest + lightest))[0]
        return heaviest[0] + middle + lightest[0]

weighing_results = []
for _ in range(3):
    result = input().strip()
    weighing_results.append(result)

output = find_coin_order(weighing_results)
print(output)","def determine_coin_order(weightings):
    results = []

    for weighting in weightings:

        greater_than = {'A': 0, 'B': 0, 'C': 0}

        for line in weighting.splitlines():
            if not line:
                continue

            left, operator, right = line[0], line[1], line[2]

            if operator == '>':
                greater_than[left] += 1
            elif operator == '<':
                greater_than[right] += 1

        sorted_coins = sorted(greater_than.items(), key=lambda x: x[1])

        if sorted_coins[0][1] == sorted_coins[1][1] or sorted_coins[1][1] == sorted_coins[2][1]:
            results.append(""Impossible"")
        else:
            results.append(''.join(coin[0] for coin in sorted_coins))

    return results

input_data = ['A>B\nC<B\nA>C\n', 'A<B\nB>C\nC>A\n']
output = determine_coin_order(input_data)
print(output)"
302,A,Eugeny and Array,PROGRAMMING,['implementation'],"Eugeny has array *a*<==<=*a*1,<=*a*2,<=...,<=*a**n*, consisting of *n* integers. Each integer *a**i* equals to -1, or to 1. Also, he has *m* queries:
 -  Query number *i* is given as a pair of integers *l**i*, *r**i* (1<=≤<=*l**i*<=≤<=*r**i*<=≤<=*n*). -  The response to the query will be integer 1, if the elements of array *a* can be rearranged so as the sum *a**l**i*<=+<=*a**l**i*<=+<=1<=+<=...<=+<=*a**r**i*<==<=0, otherwise the response to the query will be integer 0. 
Help Eugeny, answer all his queries.","The first line contains integers *n* and *m* (1<=≤<=*n*,<=*m*<=≤<=2·105). The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (*a**i*<==<=-1,<=1). Next *m* lines contain Eugene's queries. The *i*-th line contains integers *l**i*,<=*r**i* (1<=≤<=*l**i*<=≤<=*r**i*<=≤<=*n*).",Print *m* integers — the responses to Eugene's queries in the order they occur in the input.,"['2 3\n1 -1\n1 1\n1 2\n2 2\n', '5 5\n-1 1 1 1 -1\n1 1\n2 3\n3 5\n2 5\n1 5\n']","['0\n1\n0\n', '0\n1\n0\n1\n0\n']",none,RUNTIME_ERROR,"def rearr(a,m,l,r):
    req = abs(r-l)+1
    if(req%2 != 0):
        return 0
    pos = req//2
    neg = req//2
    for i in a:
        if(i==1):
            pos = pos-1
        else:
            neg = neg-1
        if(pos <= 0 and neg <= 0):
            return 1
    return 0

n,m = input().split()
n = int(n)
m = int(m)
for i in range(m):
    l,r = input().split()
    l = int(l)
    r = int(r)
    print(rearr(a,m,l,r))","def can_rearrange(n, m, a, queries):

    count_neg = a.count(-1)
    count_pos = a.count(1)
    result = []

    for l, r in queries:

        length = r - l + 1

        if length % 2 == 0:

            required_neg = length // 2
        else:

            required_neg = length // 2 + 1

        if required_neg <= count_neg and (length - required_neg) <= count_pos:
            result.append(1)
        else:
            result.append(0)

    return result

import sys
input = sys.stdin.read
data = input().splitlines()

n, m = map(int, data[0].split())

a = list(map(int, data[1].split()))

queries = [tuple(map(int, line.split())) for line in data[2:2 + m]]

results = can_rearrange(n, m, a, queries)

print(""\n"".join(map(str, results)))"
102,B,Sum of Digits,PROGRAMMING,['implementation'],"Having watched the last Harry Potter film, little Gerald also decided to practice magic. He found in his father's magical book a spell that turns any number in the sum of its digits. At the moment Gerald learned that, he came across a number *n*. How many times can Gerald put a spell on it until the number becomes one-digit?",The first line contains the only integer *n* (0<=≤<=*n*<=≤<=10100000). It is guaranteed that *n* doesn't contain any leading zeroes.,Print the number of times a number can be replaced by the sum of its digits until it only contains one digit.,"['0\n', '10\n', '991\n']","['0\n', '1\n', '3\n']","In the first sample the number already is one-digit — Herald can't cast a spell.

The second test contains number 10. After one casting of a spell it becomes 1, and here the process is completed. Thus, Gerald can only cast the spell once.

The third test contains number 991. As one casts a spell the following transformations take place: 991 → 19 → 10 → 1. After three transformations the number becomes one-digit.",OK,"import sys
input = sys.stdin.readline
import math

def inpit():
    return(int(input()))
def inplt():
    return(list(map(int,input().split())))
def inpstr():
    s = input()
    return(list(s[:len(s) - 1]))
def inpspit():
    return(map(int,input().split()))

n= str(inpit())
    
if(len(n) ==1):
    print(0)
else:
    t = 0
    while(True):
        n = str(sum([int(i) for i in n]))
        t = t +1 
        if(len(n)==1):
            print(t)
            break","def count_spell_casts(n):
    count = 0

    while len(n) > 1:

        n = str(sum(int(digit) for digit in n))
        count += 1
    return count

input_numbers = ['0\n', '10\n', '991\n']
outputs = []

for input_str in input_numbers:
    num = input_str.strip()
    outputs.append(count_spell_casts(num))

for result in outputs:
    print(result)"
508,A,Pasha and Pixels,PROGRAMMING,['brute force'],"Pasha loves his phone and also putting his hair up... But the hair is now irrelevant.

Pasha has installed a new game to his phone. The goal of the game is following. There is a rectangular field consisting of *n* row with *m* pixels in each row. Initially, all the pixels are colored white. In one move, Pasha can choose any pixel and color it black. In particular, he can choose the pixel that is already black, then after the boy's move the pixel does not change, that is, it remains black. Pasha loses the game when a 2<=×<=2 square consisting of black pixels is formed. 

Pasha has made a plan of *k* moves, according to which he will paint pixels. Each turn in his plan is represented as a pair of numbers *i* and *j*, denoting respectively the row and the column of the pixel to be colored on the current move.

Determine whether Pasha loses if he acts in accordance with his plan, and if he does, on what move the 2<=×<=2 square consisting of black pixels is formed.","The first line of the input contains three integers *n*,<=*m*,<=*k* (1<=≤<=*n*,<=*m*<=≤<=1000, 1<=≤<=*k*<=≤<=105) — the number of rows, the number of columns and the number of moves that Pasha is going to perform. 

The next *k* lines contain Pasha's moves in the order he makes them. Each line contains two integers *i* and *j* (1<=≤<=*i*<=≤<=*n*, 1<=≤<=*j*<=≤<=*m*), representing the row number and column number of the pixel that was painted during a move.","If Pasha loses, print the number of the move when the 2<=×<=2 square consisting of black pixels is formed.

If Pasha doesn't lose, that is, no 2<=×<=2 square consisting of black pixels is formed during the given *k* moves, print 0.","['2 2 4\n1 1\n1 2\n2 1\n2 2\n', '2 3 6\n2 3\n2 2\n1 3\n2 2\n1 2\n1 1\n', '5 3 7\n2 3\n1 2\n1 1\n4 1\n3 1\n5 3\n3 2\n']","['4\n', '5\n', '0\n']",none,WRONG_ANSWER,"n, m, k = map(int, input().split())

black_pixels = set()

def check_square(i, j):
    count = 0
    for di in range(-1, 2):
        for dj in range(-1, 2):
            if (i+di, j+dj) in black_pixels:
                count += 1
    return count == 3

for move in range(1, k+1):
    i, j = map(int, input().split())
    black_pixels.add((i-1, j-1))

    for di in range(-1, 2):
        for dj in range(-1, 2):
            if (i-1+di, j-1+dj) in black_pixels and check_square(i-1+di, j-1+dj):
                print(move)
                exit()

print(0)","def pasha_game(n, m, k, moves):

    grid = [[0] * (m + 1) for _ in range(n + 1)]

    for move_number in range(k):
        x, y = moves[move_number]

        grid[x][y] = 1

        if (grid[x][y] == 1 and grid[x][y-1] == 1 and grid[x-1][y] == 1 and grid[x-1][y-1] == 1) or \
           (grid[x][y] == 1 and grid[x][y+1] == 1 and grid[x-1][y] == 1 and grid[x-1][y+1] == 1) or \
           (grid[x][y] == 1 and grid[x][y-1] == 1 and grid[x+1][y] == 1 and grid[x+1][y-1] == 1) or \
           (grid[x][y] == 1 and grid[x][y+1] == 1 and grid[x+1][y] == 1 and grid[x+1][y+1] == 1):
            return move_number + 1

    return 0

demo_inputs = [
    (2, 2, 4, [(1, 1), (1, 2), (2, 1), (2, 2)]),
    (2, 3, 6, [(2, 3), (2, 2), (1, 3), (2, 2), (1, 2), (1, 1)]),
    (5, 3, 7, [(2, 3), (1, 2), (1, 1), (4, 1), (3, 1), (5, 3), (3, 2)])
]

for n, m, k, moves in demo_inputs:
    result = pasha_game(n, m, k, moves)
    print(result)"
664,A,Complicated GCD,PROGRAMMING,"['math', 'number theory']","Greatest common divisor *GCD*(*a*,<=*b*) of two positive integers *a* and *b* is equal to the biggest integer *d* such that both integers *a* and *b* are divisible by *d*. There are many efficient algorithms to find greatest common divisor *GCD*(*a*,<=*b*), for example, Euclid algorithm. 

Formally, find the biggest integer *d*, such that all integers *a*,<=*a*<=+<=1,<=*a*<=+<=2,<=...,<=*b* are divisible by *d*. To make the problem even more complicated we allow *a* and *b* to be up to googol, 10100 — such number do not fit even in 64-bit integer type!",The only line of the input contains two integers *a* and *b* (1<=≤<=*a*<=≤<=*b*<=≤<=10100).,Output one integer — greatest common divisor of all integers from *a* to *b* inclusive.,"['1 2\n', '61803398874989484820458683436563811772030917980576 61803398874989484820458683436563811772030917980576\n']","['1\n', '61803398874989484820458683436563811772030917980576\n']",none,OK,"def gcd(a, b):
    while b != 0:
        c = a % b
        a = b
        b = c
    return a
x, y = map(int, input().split())
ans = set()
if y - x >= 1:
    print(1)
else:
    print(gcd(x, y))","from math import gcd

def gcd_of_range(a, b):

    if a == b:
        return a
    else:

        return 1

if __name__ == ""__main__"":

    input_data = input().strip().split()
    a = int(input_data[0])
    b = int(input_data[1])

    result = gcd_of_range(a, b)

    print(result)"
414,B,Mashmokh and ACM,PROGRAMMING,"['combinatorics', 'dp', 'number theory']","Mashmokh's boss, Bimokh, didn't like Mashmokh. So he fired him. Mashmokh decided to go to university and participate in ACM instead of finding a new job. He wants to become a member of Bamokh's team. In order to join he was given some programming tasks and one week to solve them. Mashmokh is not a very experienced programmer. Actually he is not a programmer at all. So he wasn't able to solve them. That's why he asked you to help him with these tasks. One of these tasks is the following.

A sequence of *l* integers *b*1,<=*b*2,<=...,<=*b**l* (1<=≤<=*b*1<=≤<=*b*2<=≤<=...<=≤<=*b**l*<=≤<=*n*) is called good if each number divides (without a remainder) by the next number in the sequence. More formally  for all *i* (1<=≤<=*i*<=≤<=*l*<=-<=1).

Given *n* and *k* find the number of good sequences of length *k*. As the answer can be rather large print it modulo 1000000007 (109<=+<=7).","The first line of input contains two space-separated integers *n*,<=*k* (1<=≤<=*n*,<=*k*<=≤<=2000).",Output a single integer — the number of good sequences of length *k* modulo 1000000007 (109<=+<=7).,"['3 2\n', '6 4\n', '2 1\n']","['5\n', '39\n', '2\n']","In the first sample the good sequences are: [1, 1], [2, 2], [3, 3], [1, 2], [1, 3].",TIME_LIMIT_EXCEEDED,"a,b=list(map(int,input().split()))
g={}
def recr(val,ind):
  if (val,ind) in g:
    return g[(val,ind)]
  if ind==b:
    return 1
  ans=0
  for i in range(1,a+1):
    if i%val==0:
      ans=ans+recr(i,ind+1)
  g[(val,ind)]=ans
  return ans
print(recr(1,0))","MOD = 1000000007

def count_good_sequences(n, k):

    dp = [[0] * (k + 1) for _ in range(n + 1)]

    for i in range(1, n + 1):
        dp[i][1] = 1

    for length in range(2, k + 1):
        for i in range(1, n + 1):
            for j in range(i, n + 1):
                if j % i == 0:
                    dp[j][length] = (dp[j][length] + dp[i][length - 1]) % MOD

    result = 0
    for i in range(1, n + 1):
        result = (result + dp[i][k]) % MOD

    return result

import sys
input = sys.stdin.read
data = input().strip().split('\n')

results = []
for line in data:
    n, k = map(int, line.split())
    results.append(count_good_sequences(n, k))

for res in results:
    print(res)"
225,A,Dice Tower,PROGRAMMING,"['constructive algorithms', 'greedy']","A dice is a cube, its faces contain distinct integers from 1 to 6 as black points. The sum of numbers at the opposite dice faces always equals 7. Please note that there are only two dice (these dices are mirror of each other) that satisfy the given constraints (both of them are shown on the picture on the left).

Alice and Bob play dice. Alice has built a tower from *n* dice. We know that in this tower the adjacent dice contact with faces with distinct numbers. Bob wants to uniquely identify the numbers written on the faces of all dice, from which the tower is built. Unfortunately, Bob is looking at the tower from the face, and so he does not see all the numbers on the faces. Bob sees the number on the top of the tower and the numbers on the two adjacent sides (on the right side of the picture shown what Bob sees).

Help Bob, tell whether it is possible to uniquely identify the numbers on the faces of all the dice in the tower, or not.","The first line contains a single integer *n* (1<=≤<=*n*<=≤<=100) — the number of dice in the tower.

The second line contains an integer *x* (1<=≤<=*x*<=≤<=6) — the number Bob sees at the top of the tower. Next *n* lines contain two space-separated integers each: the *i*-th line contains numbers *a**i*,<=*b**i* (1<=≤<=*a**i*,<=*b**i*<=≤<=6; *a**i*<=≠<=*b**i*) — the numbers Bob sees on the two sidelong faces of the *i*-th dice in the tower.

Consider the dice in the tower indexed from top to bottom from 1 to *n*. That is, the topmost dice has index 1 (the dice whose top face Bob can see). It is guaranteed that it is possible to make a dice tower that will look as described in the input.","Print ""YES"" (without the quotes), if it is possible to to uniquely identify the numbers on the faces of all the dice in the tower. If it is impossible, print ""NO"" (without the quotes).","['3\n6\n3 2\n5 4\n2 4\n', '3\n3\n2 6\n4 1\n5 3\n']","['YES', 'NO']",none,WRONG_ANSWER,"n = int(input())
x = int(input())
faces = []
default = {1,2,3,4,5,6}
for i in range(n):
  raw = set(map(int, input().split()))
  impr = set()
  for v in raw:
    impr.add(v)
    impr.add(7-v)
  if i == 0:
    impr.add(x)
  faces.append(default - impr)

i = 1
if  n == 1:
  print(""YES"")
  exit()
faces[1] = faces[1] - faces[0]
if len(faces[1]) == 2:
  print(""NO"")
  exit()

i = 2
while i < n:
  exc = faces[i] - faces[i-1]
  if len(exc) == 0:
    print(""NO"")
    exit()
  i += 1
  
  
print(""YES"")","def can_identify_dice(n, top_num, sides):
    opposite_face = {1: 6, 2: 5, 3: 4, 4: 3, 5: 2, 6: 1}
    unique_numbers = {top_num}

    if top_num in sides[0]:
        return ""NO""
    
    unique_numbers.update(sides[0])
    
    for i in range(1, n):

        last_bottom = opposite_face[top_num]

        a, b = sides[i]

        if last_bottom in (a, b):
            return ""NO""

        top_num = opposite_face[a] if last_bottom == b else opposite_face[b]

        unique_numbers.update((a, b))

    return ""YES""

n = int(input())
top_num = int(input())
sides = [tuple(map(int, input().split())) for _ in range(n)]

result = can_identify_dice(n, top_num, sides)
print(result)"
863,C,1-2-3,PROGRAMMING,"['graphs', 'implementation']","Ilya is working for the company that constructs robots. Ilya writes programs for entertainment robots, and his current project is ""Bob"", a new-generation game robot. Ilya's boss wants to know his progress so far. Especially he is interested if Bob is better at playing different games than the previous model, ""Alice"". 

So now Ilya wants to compare his robots' performance in a simple game called ""1-2-3"". This game is similar to the ""Rock-Paper-Scissors"" game: both robots secretly choose a number from the set {1,<=2,<=3} and say it at the same moment. If both robots choose the same number, then it's a draw and noone gets any points. But if chosen numbers are different, then one of the robots gets a point: 3 beats 2, 2 beats 1 and 1 beats 3. 

Both robots' programs make them choose their numbers in such a way that their choice in (*i*<=+<=1)-th game depends only on the numbers chosen by them in *i*-th game. 

Ilya knows that the robots will play *k* games, Alice will choose number *a* in the first game, and Bob will choose *b* in the first game. He also knows both robots' programs and can tell what each robot will choose depending on their choices in previous game. Ilya doesn't want to wait until robots play all *k* games, so he asks you to predict the number of points they will have after the final game.","The first line contains three numbers *k*, *a*, *b* (1<=≤<=*k*<=≤<=1018, 1<=≤<=*a*,<=*b*<=≤<=3). 

Then 3 lines follow, *i*-th of them containing 3 numbers *A**i*,<=1, *A**i*,<=2, *A**i*,<=3, where *A**i*,<=*j* represents Alice's choice in the game if Alice chose *i* in previous game and Bob chose *j* (1<=≤<=*A**i*,<=*j*<=≤<=3). 

Then 3 lines follow, *i*-th of them containing 3 numbers *B**i*,<=1, *B**i*,<=2, *B**i*,<=3, where *B**i*,<=*j* represents Bob's choice in the game if Alice chose *i* in previous game and Bob chose *j* (1<=≤<=*B**i*,<=*j*<=≤<=3).","Print two numbers. First of them has to be equal to the number of points Alice will have, and second of them must be Bob's score after *k* games.","['10 2 1\n1 1 1\n1 1 1\n1 1 1\n2 2 2\n2 2 2\n2 2 2\n', '8 1 1\n2 2 1\n3 3 1\n3 1 3\n1 1 1\n2 1 1\n1 2 3\n', '5 1 1\n1 2 2\n2 2 2\n2 2 2\n1 2 2\n2 2 2\n2 2 2\n']","['1 9\n', '5 2\n', '0 0\n']","In the second example game goes like this:

<img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/1e21b6e200707470571d69c9946ace6b56f5279b.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>

The fourth and the seventh game are won by Bob, the first game is draw and the rest are won by Alice.",RUNTIME_ERROR,"k, a, b = [int(i) for i in input().split("" "")]
A = []
B = []
ap = 0
bp = 0
ac = a
bc = b
ah = []
bh = []
sh = []
alert = 0
for i in range(3):
    A.append(input())
for i in range(3):
    B.append(input())

def Alice_choice(i,j):
    return int((A[i-1])[2*j-2])

def Bob_choice(i,j):
    return int((B[i-1])[2*j-2])

if ac == bc + 1 or ac == bc - 2:
    ap += 1
    ah.append(ac)
    bh.append(bc)
    sh.append(1)
elif bc == ac + 1 or bc == ac - 2:
    bp += 1
    ah.append(ac)
    bh.append(bc)
    sh.append(-1)
else:
    ah.append(ac)
    bh.append(bc)
    sh.append(0)

for q in range(k-1):
    temp_a = Alice_choice(ac,bc)
    temp_b = Bob_choice(ac,bc)
    ac = temp_a
    bc = temp_b
    if ac == bc + 1 or ac == bc - 2:
        ap += 1
        ah.append(ac)
        bh.append(bc)
        sh.append(1)
    elif bc == ac + 1 or bc == ac - 2:
        bp += 1
        ah.append(ac)
        bh.append(bc)
        sh.append(-1)
    else:
        ah.append(ac)
        bh.append(bc)
        sh.append(0)
    for r in range(q + 1):
        if ac == ah[r] and bc == bh[r]:
            alert = 1
            break
    if alert == 1:
        break
q += 1
period = q - r
score_pp = sh[r:q]
end = (k - len(sh)) % period
repeat = int((k - len(sh) - end) / period)
aadd = 0
badd = 0
for i in score_pp:
    if i == 1:
        aadd += 1
    elif i == -1:
        badd += 1
ap += aadd*repeat
bp += badd*repeat
for i in score_pp[:end]:
    if i == 1:
        ap += 1
    elif i == -1:
        bp += 1

print(ap, end = ' ')
print(bp)","def game_simulation(k, a, b, alice_choices, bob_choices):

    alice_score = 0
    bob_score = 0

    for _ in range(k):

        if a == b:
            continue
        elif (a == 1 and b == 3) or (a == 2 and b == 1) or (a == 3 and b == 2):
            bob_score += 1
        else:
            alice_score += 1

        a = alice_choices[a - 1][b - 1]
        b = bob_choices[b - 1][a - 1]
    
    return alice_score, bob_score

def main():
    input_data = input().strip().split('\n')
    k, a, b = map(int, input_data[0].strip().split())

    alice_choices = [list(map(int, input_data[i + 1].strip().split())) for i in range(3)]

    bob_choices = [list(map(int, input_data[i + 4].strip().split())) for i in range(3)]

    scores = game_simulation(k, a, b, alice_choices, bob_choices)

    print(scores[0], scores[1])

if __name__ == ""__main__"":
    main()"
808,E,Selling Souvenirs,PROGRAMMING,"['binary search', 'dp', 'greedy', 'ternary search']","After several latest reforms many tourists are planning to visit Berland, and Berland people understood that it's an opportunity to earn money and changed their jobs to attract tourists. Petya, for example, left the IT corporation he had been working for and started to sell souvenirs at the market.

This morning, as usual, Petya will come to the market. Petya has *n* different souvenirs to sell; *i*th souvenir is characterised by its weight *w**i* and cost *c**i*. Petya knows that he might not be able to carry all the souvenirs to the market. So Petya wants to choose a subset of souvenirs such that its total weight is not greater than *m*, and total cost is maximum possible.

Help Petya to determine maximum possible total cost.","The first line contains two integers *n* and *m* (1<=≤<=*n*<=≤<=100000, 1<=≤<=*m*<=≤<=300000) — the number of Petya's souvenirs and total weight that he can carry to the market.

Then *n* lines follow. *i*th line contains two integers *w**i* and *c**i* (1<=≤<=*w**i*<=≤<=3, 1<=≤<=*c**i*<=≤<=109) — the weight and the cost of *i*th souvenir.",Print one number — maximum possible total cost of souvenirs that Petya can carry to the market.,"['1 1\n2 1\n', '2 2\n1 3\n2 2\n', '4 3\n3 10\n2 7\n2 8\n1 1\n']","['0\n', '3\n', '10\n']",none,TIME_LIMIT_EXCEEDED,"def cost(w,c,m,n):
    y = [[0 for i in range(m+1)]for i in range(n+1)]
    for i in range(0,n+1):
        for a in range(0,m+1):
            if i==0 or a==0:
               y[i][a] = 0
            elif w[i-1] <= a:
                y[i][a] = max(c[i-1] + y[i-1][a-w[i-1]],  y[i-1][a]);
            else:
                y[i][a] = y[i-1][a]
    return y[n][m]            

p = input()
p = p.split()
x = [int(i) for i in p]
n = x[0]
m = x[1]
w = [0 for i in range(n)]
c = [0 for i in range(n)]     
for j in range(0,n):
    p = input()
    p = p.split()
    x = [int(i) for i in p]
    w[j] = x[0]
    c[j] = x[1]

print(cost(w,c,m,n))","def knapsack(n, m, souvenirs):

    dp = [0] * (m + 1)

    for weight, cost in souvenirs:

        for j in range(m, weight - 1, -1):
            dp[j] = max(dp[j], dp[j - weight] + cost)

    return max(dp)

def main():
    import sys

    input_data = sys.stdin.read().strip().split('\n')
    n, m = map(int, input_data[0].split())
    
    souvenirs = []

    for i in range(1, n + 1):
        w, c = map(int, input_data[i].split())
        souvenirs.append((w, c))

    result = knapsack(n, m, souvenirs)

    print(result)

if __name__ == ""__main__"":
    main()"
524,A,"Возможно, вы знаете этих людей?",PROGRAMMING,['implementation'],"Основой любой социальной сети является отношение дружбы между двумя пользователями в том или ином смысле. В одной известной социальной сети дружба симметрична, то есть если *a* является другом *b*, то *b* также является другом *a*. 

В этой же сети есть функция, которая демонстрирует множество людей, имеющих высокую вероятность быть знакомыми для пользователя. Эта функция работает следующим образом. Зафиксируем пользователя *x*. Пусть некоторый другой человек *y*, не являющийся другом *x* на текущий момент, является другом не менее, чем для *k*% друзей *x*. Тогда он является предполагаемым другом для *x*.

У каждого человека в социальной сети есть свой уникальный идентификатор — это целое число от 1 до 109. Вам дан список пар пользователей, являющихся друзьями. Определите для каждого упомянутого пользователя множество его предполагаемых друзей.","В первой строке следуют два целых числа *m* и *k* (1<=≤<=*m*<=≤<=100, 0<=≤<=*k*<=≤<=100) — количество пар друзей и необходимый процент общих друзей для того, чтобы считаться предполагаемым другом.

В последующих *m* строках записано по два числа *a**i*,<=*b**i* (1<=≤<=*a**i*,<=*b**i*<=≤<=109, *a**i*<=≠<=*b**i*), обозначающих идентификаторы пользователей, являющихся друзьями. 

Гарантируется, что каждая пара людей фигурирует в списке не более одного раза.","Для всех упомянутых людей в порядке возрастания id выведите информацию о предполагаемых друзьях. Информация должна иметь вид ""*id*:<= *k* *id*1 *id*2 ... *id**k*"", где *id* — это id самого человека, *k* — количество его предполагаемых друзей, а *id*1, *id*2, ..., *id**k* — идентификаторы его предполагаемых друзей в возрастающем порядке.","['5 51\n10 23\n23 42\n39 42\n10 39\n39 58\n', '5 100\n1 2\n1 3\n1 4\n2 3\n2 4\n']","['10: 1 42\n23: 1 39\n39: 1 23\n42: 1 10\n58: 2 10 42\n', '1: 0\n2: 0\n3: 1 4\n4: 1 3\n']",none,WRONG_ANSWER,"def main():
    from collections import defaultdict
    
    m, k = [int(i) for i in input().split()]
    
    d = defaultdict(set)
    for i in range(m):
        a, b = [int(i) for i in input().split()]
        d[a].add(b)
        d[b].add(a)
    
    keys = sorted(d.keys())
    for i in keys:
        result = []
        for j in keys:
            if i != j and len(d[i] & d[j]) >= (len(d[i]) * k + 99) // 100:
                result.append(j)
        print(""{0}: {1} {2}"".format(i, len(result), ' '.join(str(i) for i in result)))
            
    
main()","def find_potential_friends(m, k, friendships):
    from collections import defaultdict

    friends = defaultdict(set)

    for a, b in friendships:
        friends[a].add(b)
        friends[b].add(a)
    
    results = {}

    for user in friends:
        potential_friends = set()
        user_friends = friends[user]
        friend_count = len(user_friends)
        
        if friend_count == 0:
            results[user] = []
            continue

        required_mutual = (k / 100) * friend_count

        for friend in user_friends:
            for possible_friend in friends[friend]:
                if possible_friend != user and possible_friend not in user_friends:
                    potential_friends.add(possible_friend)

        valid_potential_friends = []
        for potential in potential_friends:
            mutual_count = len(user_friends.intersection(friends[potential]))
            if mutual_count >= required_mutual:
                valid_potential_friends.append(potential)
        
        results[user] = sorted(valid_potential_friends)
    
    return results

def format_results(results):
    output = []
    for user in sorted(results):
        potential_friends = results[user]
        k = len(potential_friends)
        if k > 0:
            output.append(f""{user}: {k} "" + "" "".join(map(str, potential_friends)))
        else:
            output.append(f""{user}: 0"")
    return output

if __name__ == ""__main__"":
    import sys
    input_data = sys.stdin.read().strip().splitlines()

    m, k = map(int, input_data[0].split())
    friendships = [tuple(map(int, line.split())) for line in input_data[1:m+1]]

    results = find_potential_friends(m, k, friendships)
    output = format_results(results)
    
    for line in output:
        print(line)"
9,A,Die Roll,PROGRAMMING,"['math', 'probabilities']","Yakko, Wakko and Dot, world-famous animaniacs, decided to rest from acting in cartoons, and take a leave to travel a bit. Yakko dreamt to go to Pennsylvania, his Motherland and the Motherland of his ancestors. Wakko thought about Tasmania, its beaches, sun and sea. Dot chose Transylvania as the most mysterious and unpredictable place.

But to their great regret, the leave turned to be very short, so it will be enough to visit one of the three above named places. That's why Yakko, as the cleverest, came up with a truly genius idea: let each of the three roll an ordinary six-sided die, and the one with the highest amount of points will be the winner, and will take the other two to the place of his/her dreams.

Yakko thrown a die and got Y points, Wakko — W points. It was Dot's turn. But she didn't hurry. Dot wanted to know for sure what were her chances to visit Transylvania.

It is known that Yakko and Wakko are true gentlemen, that's why if they have the same amount of points with Dot, they will let Dot win.",The only line of the input file contains two natural numbers Y and W — the results of Yakko's and Wakko's die rolls.,"Output the required probability in the form of irreducible fraction in format «A/B», where A — the numerator, and B — the denominator. If the required probability equals to zero, output «0/1». If the required probability equals to 1, output «1/1».",['4 2\n'],['1/2\n'],"Dot will go to Transylvania, if she is lucky to roll 4, 5 or 6 points.",WRONG_ANSWER,"nums = list(map(int,input().split()))
maximum = max(nums)
num = 6 - maximum + 1

def gcdCalculator(a , b) :
    if a % b == 0 : return b
    return gcdCalculator(b , a % b)

gcd = gcdCalculator(6 , num)
print(gcd)
print(num // gcd , 6 // gcd)","from math import gcd

Y, W = map(int, input().strip().split())

max_roll = max(Y, W)

successful_rolls = 6 - max_roll + 1

total_outcomes = 6

if successful_rolls == 0:
    print(""0/1"")
else:

    numerator = successful_rolls
    denominator = total_outcomes
    divisor = gcd(numerator, denominator)

    numerator //= divisor
    denominator //= divisor

    print(f""{numerator}/{denominator}"")"
106,A,Card Game,PROGRAMMING,['implementation'],"There is a card game called ""Durak"", which means ""Fool"" in Russian. The game is quite popular in the countries that used to form USSR. The problem does not state all the game's rules explicitly — you can find them later yourselves if you want.

To play durak you need a pack of 36 cards. Each card has a suit (""S"", ""H"", ""D"" and ""C"") and a rank (in the increasing order ""6"", ""7"", ""8"", ""9"", ""T"", ""J"", ""Q"", ""K"" and ""A""). At the beginning of the game one suit is arbitrarily chosen as trump. 

The players move like that: one player puts one or several of his cards on the table and the other one should beat each of them with his cards.

A card beats another one if both cards have similar suits and the first card has a higher rank then the second one. Besides, a trump card can beat any non-trump card whatever the cards’ ranks are. In all other cases you can not beat the second card with the first one.

You are given the trump suit and two different cards. Determine whether the first one beats the second one or not.","The first line contains the tramp suit. It is ""S"", ""H"", ""D"" or ""C"".

The second line contains the description of the two different cards. Each card is described by one word consisting of two symbols. The first symbol stands for the rank (""6"", ""7"", ""8"", ""9"", ""T"", ""J"", ""Q"", ""K"" and ""A""), and the second one stands for the suit (""S"", ""H"", ""D"" and ""C"").","Print ""YES"" (without the quotes) if the first cards beats the second one. Otherwise, print ""NO"" (also without the quotes).","['H\nQH 9S\n', 'S\n8D 6D\n', 'C\n7H AS\n']","['YES\n', 'YES', 'NO']",none,WRONG_ANSWER,"import sys,math
sys.setrecursionlimit(10**8)
'''
def fun():
    for i in range(16):
        for j in range(4):
            if i&(1<<j):
                print(j,end='')
        print()
import binarytree
from collections import deque
bst = binarytree.tree(height=4,is_perfect=True)
print(bst)
def s(bst):
    if bst:
        bst.left,bst.right = bst.right,bst.left
        s(bst.right)
        s(bst.left)
s(bst)
print(bst)
'''
s = input()
p = input().split(' ')
c = ['6','7','8','9','T','J','Q','K','A']
print('YES' if s == p[0][1] or (p[0][1] == p[1][1] and\
    c.index(p[0][0])>c.index(p[1][0])) else 'NO')","def beats_card(trump_suit, card1, card2):

    ranks = ""6789TJQKA""
    
    rank1, suit1 = card1[0], card1[1]
    rank2, suit2 = card2[0], card2[1]

    if suit1 == trump_suit and suit2 != trump_suit:
        return ""YES""

    elif suit1 == suit2:

        if ranks.index(rank1) > ranks.index(rank2):
            return ""YES""

    return ""NO""

import sys
input_data = sys.stdin.read().strip().split('\n')
trump_suit = input_data[0].strip()
card1 = input_data[1].strip()
card2 = input_data[2].strip()

result = beats_card(trump_suit, card1, card2)
print(result)"
476,B,Dreamoon and WiFi,PROGRAMMING,"['bitmasks', 'brute force', 'combinatorics', 'dp', 'math', 'probabilities']","Dreamoon is standing at the position 0 on a number line. Drazil is sending a list of commands through Wi-Fi to Dreamoon's smartphone and Dreamoon follows them.

Each command is one of the following two types: 
 1.  Go 1 unit towards the positive direction, denoted as '+' 1.  Go 1 unit towards the negative direction, denoted as '-' 
But the Wi-Fi condition is so poor that Dreamoon's smartphone reports some of the commands can't be recognized and Dreamoon knows that some of them might even be wrong though successfully recognized. Dreamoon decides to follow every recognized command and toss a fair coin to decide those unrecognized ones (that means, he moves to the 1 unit to the negative or positive direction with the same probability 0.5). 

You are given an original list of commands sent by Drazil and list received by Dreamoon. What is the probability that Dreamoon ends in the position originally supposed to be final by Drazil's commands?","The first line contains a string *s*1 — the commands Drazil sends to Dreamoon, this string consists of only the characters in the set {'+', '-'}. 

The second line contains a string *s*2 — the commands Dreamoon's smartphone recognizes, this string consists of only the characters in the set {'+', '-', '?'}. '?' denotes an unrecognized command.

Lengths of two strings are equal and do not exceed 10.",Output a single real number corresponding to the probability. The answer will be considered correct if its relative or absolute error doesn't exceed 10<=-<=9.,"['++-+-\n+-+-+\n', '+-+-\n+-??\n', '+++\n??-\n']","['1.000000000000\n', '0.500000000000\n', '0.000000000000\n']","For the first sample, both *s*<sub class=""lower-index"">1</sub> and *s*<sub class=""lower-index"">2</sub> will lead Dreamoon to finish at the same position  + 1. 

For the second sample, *s*<sub class=""lower-index"">1</sub> will lead Dreamoon to finish at position 0, while there are four possibilites for *s*<sub class=""lower-index"">2</sub>: {""+-++"", ""+-+-"", ""+--+"", ""+---""} with ending position {+2, 0, 0, -2} respectively. So there are 2 correct cases out of 4, so the probability of finishing at the correct position is 0.5. 

For the third sample, *s*<sub class=""lower-index"">2</sub> could only lead us to finish at positions {+1, -1, -3}, so the probability to finish at the correct position  + 3 is 0.",OK,"import sys, threading
import math
import time
from os import path
from collections import defaultdict, Counter, deque
from bisect import *
from string import ascii_lowercase
from functools import cmp_to_key
import heapq

def lcm(a, b):
    return (a*b)//(math.gcd(a,b))
 
 
si= lambda:str(input())
ii = lambda: int(input())
mii = lambda: map(int, input().split())
lmii = lambda: list(map(int, input().split()))
i2c = lambda n: chr(ord('a') + n)
c2i = lambda c: ord(c) - ord('a')

def factorial(n):
    if n==1:
        return 1
    else:
        return n*factorial(n-1)
   
def solve():
    s1=si()
    s2=si()
    q=0
    final_pos=0
    till_now =0
    for i in range(len(s1)):
        if s1[i]==""+"":
            final_pos+=1
        else:
            final_pos-=1
    for i in range(len(s2)):
        if s2[i]==""+"":
            till_now+=1
        elif s2[i]==""-"":
            till_now-=1
        elif s2[i]==""?"":
            q+=1

    t=abs(final_pos-till_now)

    if t>q or (q-t)%2:
        print(0.000000000000)
    else:
        numerator = math.comb(q,t+((q-t)//2))
        denominator = pow(2,q)

        ans = (numerator*1.0)/denominator
        print(""{:.11f}"".format(ans))

def main():
    t = 1
    if path.exists(""/Users/nitishkumar/Documents/Template_Codes/Python/CP/Codeforces/input.txt""):
        sys.stdin = open(""/Users/nitishkumar/Documents/Template_Codes/Python/CP/Codeforces/input.txt"", 'r')
        sys.stdout = open(""/Users/nitishkumar/Documents/Template_Codes/Python/CP/Codeforces/output.txt"", 'w')
        start_time = time.time()
        print(""--- %s seconds ---"" % (time.time() - start_time))
 
 
    sys.setrecursionlimit(10**5)
 
 
    solve()
 
 
if __name__ == '__main__':
    main()","def calculate_probability(s1, s2):

    target_position = s1.count('+') - s1.count('-')

    recognized_position = s2.count('+') - s2.count('-')
    unknown_commands = s2.count('?')

    difference = target_position - recognized_position

    if abs(difference) > unknown_commands or (unknown_commands - abs(difference)) % 2 != 0:
        return 0.0

    from math import comb

    x = (unknown_commands + difference) // 2

    if 0 <= x <= unknown_commands:
        total_ways = 2 ** unknown_commands
        valid_ways = comb(unknown_commands, x)
        probability = valid_ways / total_ways
        return probability
    else:
        return 0.0

t = int(input())
results = []

for _ in range(t):
    s1 = input().strip()
    s2 = input().strip()
    prob = calculate_probability(s1, s2)
    results.append(f""{prob:.12f}"")

print(""\n"".join(results))"
401,C,Team,PROGRAMMING,"['constructive algorithms', 'greedy', 'implementation']","Now it's time of Olympiads. Vanya and Egor decided to make his own team to take part in a programming Olympiad. They've been best friends ever since primary school and hopefully, that can somehow help them in teamwork.

For each team Olympiad, Vanya takes his play cards with numbers. He takes only the cards containing numbers 1 and 0. The boys are very superstitious. They think that they can do well at the Olympiad if they begin with laying all the cards in a row so that:
 -  there wouldn't be a pair of any side-adjacent cards with zeroes in a row; -  there wouldn't be a group of three consecutive cards containing numbers one. 
Today Vanya brought *n* cards with zeroes and *m* cards with numbers one. The number of cards was so much that the friends do not know how to put all those cards in the described way. Help them find the required arrangement of the cards or else tell the guys that it is impossible to arrange cards in such a way.",The first line contains two integers: *n* (1<=≤<=*n*<=≤<=106) — the number of cards containing number 0; *m* (1<=≤<=*m*<=≤<=106) — the number of cards containing number 1.,"In a single line print the required sequence of zeroes and ones without any spaces. If such sequence is impossible to obtain, print -1.","['1 2\n', '4 8\n', '4 10\n', '1 5\n']","['101\n', '110110110101\n', '11011011011011\n', '-1\n']",none,TIME_LIMIT_EXCEEDED,"from time import sleep as sle
from math import *
from random import randint as ri
 
def gcd(a,b):
	if a == b:
		return a
	elif a > b:
		return gcd(a-b,b)
	else:
		return gcd(b,a)

def pr(x):
	print()
	for s in x:
		print(s)

def solve():
	n,m = map(int,input().split())
	if (n-1) <= m and (m-2) <= 2*n:
		if m == (n-1):
			print('%s0'%('01'*m))
		elif m == n:
			print('01'*m)
		else:
			L = []
			while n >= 1 and m >= 1:
				L += ['1','0']
				n,m = n-1,m-1
			L += ['1']
			m -= 1
			while m >= 1:
				L[L.index('1')] = '11'
				m -= 1
			print(''.join(L))
	else:
		print(-1)

solve()","def arrange_cards(n, m):

    if n > m + 1 or m > 2 * (n + 1):
        return ""-1""
    
    result = []
    while n > 0 or m > 0:

        if m > 0:
            result.append('1')
            m -= 1
            
        if m > 0 and m > n:
            result.append('1')
            m -= 1

        if n > 0:
            result.append('0')
            n -= 1
            
    return ''.join(result)

inputs = ['1 2', '4 8', '4 10', '1 5']
outputs = []

for input_str in inputs:
    n, m = map(int, input_str.split())
    outputs.append(arrange_cards(n, m))

for output in outputs:
    print(output)"
346,B,Lucky Common Subsequence,PROGRAMMING,"['dp', 'strings']","In mathematics, a subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements. For example, the sequence BDF is a subsequence of ABCDEF. A substring of a string is a continuous subsequence of the string. For example, BCD is a substring of ABCDEF.

You are given two strings *s*1, *s*2 and another string called *virus*. Your task is to find the longest common subsequence of *s*1 and *s*2, such that it doesn't contain *virus* as a substring.","The input contains three strings in three separate lines: *s*1, *s*2 and *virus* (1<=≤<=|*s*1|,<=|*s*2|,<=|*virus*|<=≤<=100). Each string consists only of uppercase English letters.","Output the longest common subsequence of *s*1 and *s*2 without *virus* as a substring. If there are multiple answers, any of them will be accepted. 

If there is no valid common subsequence, output 0.","['AJKEQSLOBSROFGZ\nOVGURWZLWVLUXTH\nOZ\n', 'AA\nA\nA\n']","['ORZ\n', '0\n']",none,RUNTIME_ERROR,"def cseq(n,a,b):
    for i in range(len(a)):
        if(a[i] in b):
            return a[i]
    return -1
t=int(input())
for i in range(t):
    n, m = map(int, input().split())
    a = list(map(int, input().split()))
    b = list(map(int, input().split()))
    answer = cseq(n, a, b)
    if(answer==-1):
        print(""NO"")
    else:
        print(""YES"")
        print(1, answer)","def longest_common_subsequence(s1, s2, virus):

    len1, len2 = len(s1), len(s2)
    dp = [[0] * (len2 + 1) for _ in range(len1 + 1)]

    for i in range(1, len1 + 1):
        for j in range(1, len2 + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

    lcs_length = dp[len1][len2]

    def reconstruct_lcs():
        lcs = []
        i, j = len1, len2
        
        while i > 0 and j > 0:
            if s1[i - 1] == s2[j - 1]:
                lcs.append(s1[i - 1])
                i -= 1
                j -= 1
            elif dp[i - 1][j] >= dp[i][j - 1]:
                i -= 1
            else:
                j -= 1
        
        lcs.reverse()
        return ''.join(lcs)

    lcs = reconstruct_lcs()

    if virus in lcs:
        return ""0""
    
    return lcs if lcs else ""0""

s1 = input().strip()
s2 = input().strip()
virus = input().strip()

result = longest_common_subsequence(s1, s2, virus)
print(result)"
664,A,Complicated GCD,PROGRAMMING,"['math', 'number theory']","Greatest common divisor *GCD*(*a*,<=*b*) of two positive integers *a* and *b* is equal to the biggest integer *d* such that both integers *a* and *b* are divisible by *d*. There are many efficient algorithms to find greatest common divisor *GCD*(*a*,<=*b*), for example, Euclid algorithm. 

Formally, find the biggest integer *d*, such that all integers *a*,<=*a*<=+<=1,<=*a*<=+<=2,<=...,<=*b* are divisible by *d*. To make the problem even more complicated we allow *a* and *b* to be up to googol, 10100 — such number do not fit even in 64-bit integer type!",The only line of the input contains two integers *a* and *b* (1<=≤<=*a*<=≤<=*b*<=≤<=10100).,Output one integer — greatest common divisor of all integers from *a* to *b* inclusive.,"['1 2\n', '61803398874989484820458683436563811772030917980576 61803398874989484820458683436563811772030917980576\n']","['1\n', '61803398874989484820458683436563811772030917980576\n']",none,TIME_LIMIT_EXCEEDED,"def isprime(a,b):
    flag = 1
    for j in range(a,b+1):
        for i in range(2,j//2+1):
            if j%i == 0:
                flag = 0
                break
        if flag == 1: 
            return True

def gcd(a, b):  
    if a == 0 : 
        return b  
      
    return gcd(b%a, a) 
a,b = map(int,input().split())

if isprime(a,b):
    print(1)
else:
    print(gcd(a,b))","def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

def gcd_range(a, b):

    if a == b:
        return a

    return 1

input_data = input().strip()
a, b = map(int, input_data.split())

result = gcd_range(a, b)
print(result)"
281,A,Word Capitalization,PROGRAMMING,"['implementation', 'strings']","Capitalization is writing a word with its first letter as a capital letter. Your task is to capitalize the given word.

Note, that during capitalization all the letters except the first one remains unchanged.",A single line contains a non-empty word. This word consists of lowercase and uppercase English letters. The length of the word will not exceed 103.,Output the given word after capitalization.,"['ApPLe\n', 'konjac\n']","['ApPLe\n', 'Konjac\n']",none,OK,"s=str(input())
alphabets_upper='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
alphabets_lower='abcdefghijklmnopqrstuvwxyz'
new_str=''
if s[0] in alphabets_upper:
    print(s)
else:
    index=alphabets_lower.index(s[0])
    new_=alphabets_upper[index]
    new_str = new_
    for i in range (1,len(s)):
        new_str+=s[i]
    print(new_str)","def capitalize_word(word):

    return word[0].upper() + word[1:]

def main():
    import sys

    input_words = sys.stdin.read().strip().split('\n')

    capitalized_words = [capitalize_word(word) for word in input_words]

    for word in capitalized_words:
        print(word)

if __name__ == ""__main__"":
    main()"
75,C,Modified GCD,PROGRAMMING,"['binary search', 'number theory']","Well, here is another math class task. In mathematics, GCD is the greatest common divisor, and it's an easy task to calculate the GCD between two positive integers.

A common divisor for two positive numbers is a number which both numbers are divisible by.

But your teacher wants to give you a harder task, in this task you have to find the greatest common divisor *d* between two integers *a* and *b* that is in a given range from *low* to *high* (inclusive), i.e. *low*<=≤<=*d*<=≤<=*high*. It is possible that there is no common divisor in the given range.

You will be given the two integers *a* and *b*, then *n* queries. Each query is a range from *low* to *high* and you have to answer each query.","The first line contains two integers *a* and *b*, the two integers as described above (1<=≤<=*a*,<=*b*<=≤<=109). The second line contains one integer *n*, the number of queries (1<=≤<=*n*<=≤<=104). Then *n* lines follow, each line contains one query consisting of two integers, *low* and *high* (1<=≤<=*low*<=≤<=*high*<=≤<=109).","Print *n* lines. The *i*-th of them should contain the result of the *i*-th query in the input. If there is no common divisor in the given range for any query, you should print -1 as a result for this query.",['9 27\n3\n1 5\n10 11\n9 11\n'],['3\n-1\n9\n'],none,WRONG_ANSWER,"""""""
Input
The first line contains two integers a and b, the two integers as described above (1 ≤ a, b ≤ 109). The second line contains one integer n, the number of queries (1 ≤ n ≤ 104). Then n lines follow, each line contains one query consisting of two integers, low and high (1 ≤ low ≤ high ≤ 109).

Output
Print n lines. The i-th of them should contain the result of the i-th query in the input. If there is no common divisor in the given range for any query, you should print -1 as a result for this query.

""""""
from math import gcd

a, b = map(int, input().split())
g = gcd(a, b)

def factorize(v):
    factors = []

    for i in range(3, v):
        if v % i == 0:
            factors.append(i)
    return factors

factors = factorize(g)
n = int(input())
for _ in range(n):
    low, high = map(int, input().split())

    candidates = []
    for f in factors:
        if high - low < f - 1:
            continue
        else:
            candidates.append(high // f * f)
    print(max(candidates) if candidates else -1)","from math import gcd

def find_common_divisor_in_range(a, b, queries):

    common_gcd = gcd(a, b)
    results = []

    for low, high in queries:

        if low <= common_gcd <= high:
            results.append(common_gcd)
        else:
            results.append(-1)

    return results

if __name__ == ""__main__"":

    a, b = map(int, input().strip().split())
    n = int(input().strip())
    
    queries = []
    for _ in range(n):
        low, high = map(int, input().strip().split())
        queries.append((low, high))

    results = find_common_divisor_in_range(a, b, queries)

    for result in results:
        print(result)"
25,A,IQ test,PROGRAMMING,['brute force'],"Bob is preparing to pass IQ test. The most frequent task in this test is to find out which one of the given *n* numbers differs from the others. Bob observed that one number usually differs from the others in evenness. Help Bob — to check his answers, he needs a program that among the given *n* numbers finds one that is different in evenness.","The first line contains integer *n* (3<=≤<=*n*<=≤<=100) — amount of numbers in the task. The second line contains *n* space-separated natural numbers, not exceeding 100. It is guaranteed, that exactly one of these numbers differs from the others in evenness.",Output index of number that differs from the others in evenness. Numbers are numbered from 1 in the input order.,"['5\n2 4 7 8 10\n', '4\n1 2 1 1\n']","['3\n', '2\n']",none,OK,"def find_odd_one_out(n, numbers):
    even_count = 0
    odd_count = 0
    even_index = -1
    odd_index = -1
    
    for i, num in enumerate(numbers):
        if num % 2 == 0:
            even_count += 1
            even_index = i
        else:
            odd_count += 1
            odd_index = i
        
        if even_count > 1 and odd_count == 1:
            return odd_index + 1
        elif odd_count > 1 and even_count == 1:
            return even_index + 1

n = int(input())
numbers = list(map(int, input().split()))

result = find_odd_one_out(n, numbers)

print(result)","def find_different_evenness(n, numbers):

    even_count = sum(1 for number in numbers if number % 2 == 0)
    odd_count = n - even_count

    if even_count == 1:

        for i in range(n):
            if numbers[i] % 2 == 0:
                return i + 1
    else:

        for i in range(n):
            if numbers[i] % 2 != 0:
                return i + 1

if __name__ == ""__main__"":

    n = int(input())
    numbers = list(map(int, input().split()))

    result = find_different_evenness(n, numbers)
    print(result)"
789,B,Masha and geometric depression,PROGRAMMING,"['brute force', 'implementation', 'math']","Masha really loves algebra. On the last lesson, her strict teacher Dvastan gave she new exercise.

You are given geometric progression *b* defined by two integers *b*1 and *q*. Remind that a geometric progression is a sequence of integers *b*1,<=*b*2,<=*b*3,<=..., where for each *i*<=&gt;<=1 the respective term satisfies the condition *b**i*<==<=*b**i*<=-<=1·*q*, where *q* is called the common ratio of the progression. Progressions in Uzhlyandia are unusual: both *b*1 and *q* can equal 0. Also, Dvastan gave Masha *m* ""bad"" integers *a*1,<=*a*2,<=...,<=*a**m*, and an integer *l*.

Masha writes all progression terms one by one onto the board (including repetitive) while condition |*b**i*|<=≤<=*l* is satisfied (|*x*| means absolute value of *x*). There is an exception: if a term equals one of the ""bad"" integers, Masha skips it (doesn't write onto the board) and moves forward to the next term.

But the lesson is going to end soon, so Masha has to calculate how many integers will be written on the board. In order not to get into depression, Masha asked you for help: help her calculate how many numbers she will write, or print ""inf"" in case she needs to write infinitely many integers.","The first line of input contains four integers *b*1, *q*, *l*, *m* (-109<=≤<=*b*1,<=*q*<=≤<=109, 1<=≤<=*l*<=≤<=109, 1<=≤<=*m*<=≤<=105) — the initial term and the common ratio of progression, absolute value of maximal number that can be written on the board and the number of ""bad"" integers, respectively.

The second line contains *m* distinct integers *a*1,<=*a*2,<=...,<=*a**m* (-109<=≤<=*a**i*<=≤<=109) — numbers that will never be written on the board.","Print the only integer, meaning the number of progression terms that will be written on the board if it is finite, or ""inf"" (without quotes) otherwise.","['3 2 30 4\n6 14 25 48\n', '123 1 2143435 4\n123 11 -5453 141245\n', '123 1 2143435 4\n54343 -13 6 124\n']","['3', '0', 'inf']","In the first sample case, Masha will write integers 3, 12, 24. Progression term 6 will be skipped because it is a ""bad"" integer. Terms bigger than 24 won't be written because they exceed *l* by absolute value.

In the second case, Masha won't write any number because all terms are equal 123 and this is a ""bad"" integer.

In the third case, Masha will write infinitely integers 123.",OK,"def main():
    b1, q, l, m = map(int, input().split())
    a = set(map(int, input().split()))

    if b1 == 0:
        if 0 in a:
            return 0
        else:
            return 'inf'

    if q == 0:
        if abs(b1) > l:
            return 0

        if b1 in a:
            if 0 in a:
                return 0
            else:
                return 'inf'
        else:
            if 0 in a:
                return 1
            else:
                return 'inf'

    if q == 1:
        if abs(b1) > l or b1 in a:
            return 0
        else:
            return 'inf'

    if q == -1:
        if abs(b1) > l or b1 in a and -b1 in a:
            return 0
        else:
            return 'inf'

    result = 0
    b = b1
    while True:
        if abs(b) > l:
            break

        if b not in a:
            result += 1

        b *= q

    return result

if __name__ == '__main__':

    print(main())","def count_progression_terms(b1, q, l, m, bad):

    bad_set = set(bad)

    if b1 == 0:

        if 0 in bad_set:
            return 0
        else:
            return ""inf""
        
    count = 0
    current = b1

    if q == 1:

        if abs(current) <= l:
            if current not in bad_set:
                count += 1
            return count
        else:
            return 0

    if q == 0:
        if abs(b1) <= l and b1 not in bad_set:
            count += 1
        if 0 <= l and 0 not in bad_set:
            count += 1
        return count

    while abs(current) <= l:
        if current not in bad_set:
            count += 1
        current *= q

    return count

input_data = input().split('\n')
b1, q, l, m = map(int, input_data[0].split())
bad = list(map(int, input_data[1].split()))

result = count_progression_terms(b1, q, l, m, bad)
print(result)"
41,A,Translation,PROGRAMMING,"['implementation', 'strings']","The translation from the Berland language into the Birland language is not an easy task. Those languages are very similar: a berlandish word differs from a birlandish word with the same meaning a little: it is spelled (and pronounced) reversely. For example, a Berlandish word code corresponds to a Birlandish word edoc. However, it's easy to make a mistake during the «translation». Vasya translated word *s* from Berlandish into Birlandish as *t*. Help him: find out if he translated the word correctly.","The first line contains word *s*, the second line contains word *t*. The words consist of lowercase Latin letters. The input data do not consist unnecessary spaces. The words are not empty and their lengths do not exceed 100 symbols.","If the word *t* is a word *s*, written reversely, print YES, otherwise print NO.","['code\nedoc\n', 'abb\naba\n', 'code\ncode\n']","['YES\n', 'NO\n', 'NO\n']",none,OK,"import sys

def input():    return sys.stdin.readline().strip()
def iinput():   return int(input())
def rinput():   return map(int, sys.stdin.readline().strip().split()) 
def get_list(): return list(map(int, sys.stdin.readline().strip().split())) 

n=input()
m=input()
l=list(n)
s=[]
for i in range(len(n)-1,-1,-1):
    s.append(n[i])
k="""".join(s)
if(m==k):
    print(""YES"")
else:
    print(""NO"")","def check_translation(s, t):

    if s[::-1] == t:
        return ""YES""
    else:
        return ""NO""

def process_cases(cases):
    results = []
    for s, t in cases:
        result = check_translation(s, t)
        results.append(result)
    return results

input_data = [
    ('code', 'edoc'),
    ('abb', 'aba'),
    ('code', 'code')
]

output = process_cases(input_data)

for result in output:
    print(result)"
992,D,Nastya and a Game,PROGRAMMING,"['brute force', 'implementation', 'math']","Nastya received one more array on her birthday, this array can be used to play a traditional Byteland game on it. However, to play the game the players should first select such a subsegment of the array that , where *p* is the product of all integers on the given array, *s* is their sum, and *k* is a given constant for all subsegments. 

Nastya wonders how many subsegments of the array fit the described conditions. A subsegment of an array is several consecutive integers of the array.","The first line contains two integers *n* and *k* (1<=≤<=*n*<=≤<=2·105, 1<=≤<=*k*<=≤<=105), where *n* is the length of the array and *k* is the constant described above.

The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=108) — the elements of the array.",In the only line print the number of subsegments such that the ratio between the product and the sum on them is equal to *k*.,"['1 1\n1\n', '4 2\n6 3 8 1\n']","['1\n', '2\n']","In the first example the only subsegment is [1]. The sum equals 1, the product equals 1, so it suits us because <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/627b2899a459d42fe3b2ca04fc812d4132b5f2ca.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>.

There are two suitable subsegments in the second example — [6, 3] and [3, 8, 1]. Subsegment [6, 3] has sum 9 and product 18, so it suits us because <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/107ecd38fde9817d6565e2059ccd064562470543.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>. Subsegment [3, 8, 1] has sum 12 and product 24, so it suits us because <img align=""middle"" class=""tex-formula"" src=""https://espresso.codeforces.com/8abc1793efa3061313ddd52d670a94b430133564.png"" style=""max-width: 100.0%;max-height: 100.0%;""/>.",RUNTIME_ERROR,"def process(A, k):
    n = len(A)
    S = [0]
    P = [1]
    p_index = 0
    last_one = 0
    answer = 0
    for i in range(n):
        S.append(S[-1]+A[i])

        while P[-1]*A[i] > k*S[-1]:
            last_one = p_index
            P[-1] = P[-1]//P[p_index]
            P[p_index] = 1
            p_index+=1
            
        P.append(P[-1]*A[i])
        if P[-1] % k==0:
            for j in range(last_one, len(P)):
                if (P[-1]//P[j]) % k==0:
                    target_sum = P[-1]//(k*P[j])
                    if S[-1]-S[j]==target_sum:
                        answer+=1
    return answer

n, k = [int(x) for x in input().split()]
A = [int(x) for x in input().split()]
print(process(A))","def count_subsegments(n, k, a):
    count = 0

    for start in range(n):
        product = 1
        summation = 0

        for end in range(start, n):
            product *= a[end]
            summation += a[end]

            if summation != 0 and product / summation == k:
                count += 1
                
    return count

n, k = map(int, input().split())
a = list(map(int, input().split()))

result = count_subsegments(n, k, a)

print(result)"
272,A,Dima and Friends,PROGRAMMING,"['implementation', 'math']","Dima and his friends have been playing hide and seek at Dima's place all night. As a result, Dima's place got messy. In the morning they decided that they need to clean the place.

To decide who exactly would clean the apartment, the friends want to play a counting-out game. First, all the guys stand in a circle, and then each of them shows some number of fingers on one hand (one to five), and then the boys count in a circle, starting from Dima, the number of people, respective to the total number of fingers shown. The person on who the countdown stops will clean the apartment.

For example, if Dima and one of his friends played hide and seek, and 7 fingers were shown during the counting-out, then Dima would clean the place. If there were 2 or say, 8 fingers shown, then his friend would clean the place.

Dima knows how many fingers each of his friends will show during the counting-out. Now he is interested in the number of ways to show some number of fingers on one hand (one to five), so that he did not have to clean the place. Help Dima.","The first line contains integer *n* (1<=≤<=*n*<=≤<=100) — the number of Dima's friends. Dima himself isn't considered to be his own friend. The second line contains *n* positive integers, not exceeding 5, representing, how many fingers the Dima's friends will show. 

The numbers in the lines are separated by a single space.",In a single line print the answer to the problem.,"['1\n1\n', '1\n2\n', '2\n3 5\n']","['3\n', '2\n', '3\n']","In the first sample Dima can show 1, 3 or 5 fingers. If Dima shows 3 fingers, then the counting-out will go like that: Dima, his friend, Dima, his friend.

In the second sample Dima can show 2 or 4 fingers.",WRONG_ANSWER,"def arr_inp():
    return [int(x) for x in input().split()]

import math as m
n, arr = int(input()), arr_inp()
sum = 0
for i in range(n):
    if(arr[i]%2==0):
        sum+=4//arr[i]
    else:
        sum+=m.ceil(6/(arr[i]+1))
print(sum)","n = int(input())

fingers = list(map(int, input().split()))

total_fingers = sum(fingers)

valid_ways = 0

for dima_fingers in range(1, 6):

    cleaning_position = (total_fingers + dima_fingers - 1) % (n + 1)

    if cleaning_position != 0:
        valid_ways += 1

print(valid_ways)"
801,B,Valued Keys,PROGRAMMING,"['constructive algorithms', 'greedy', 'strings']","You found a mysterious function *f*. The function takes two strings *s*1 and *s*2. These strings must consist only of lowercase English letters, and must be the same length.

The output of the function *f* is another string of the same length. The *i*-th character of the output is equal to the minimum of the *i*-th character of *s*1 and the *i*-th character of *s*2.

For example, *f*(""ab"", ""ba"") = ""aa"", and *f*(""nzwzl"", ""zizez"") = ""niwel"".

You found two strings *x* and *y* of the same length and consisting of only lowercase English letters. Find any string *z* such that *f*(*x*,<=*z*)<==<=*y*, or print -1 if no such string *z* exists.","The first line of input contains the string *x*.

The second line of input contains the string *y*.

Both *x* and *y* consist only of lowercase English letters, *x* and *y* have same length and this length is between 1 and 100.","If there is no string *z* such that *f*(*x*,<=*z*)<==<=*y*, print -1.

Otherwise, print a string *z* such that *f*(*x*,<=*z*)<==<=*y*. If there are multiple possible answers, print any of them. The string *z* should be the same length as *x* and *y* and consist only of lowercase English letters.","['ab\naa\n', 'nzwzl\nniwel\n', 'ab\nba\n']","['ba\n', 'xiyez\n', '-1\n']","The first case is from the statement.

Another solution for the second case is ""zizez""

There is no solution for the third case. That is, there is no *z* such that *f*(""ab"", *z*) =  ""ba"".",OK,"def solve(x, y):
    return -1 if any(x[i] < y[i] for i in range(len(x))) else y

def f(x, y):
    return ''.join([min(x[i], y[i]) for i in range(len(x))])

if __name__ == '__main__':
    print(solve(input(), input()))","def f(s1, s2):

    return ''.join(min(a, b) for a, b in zip(s1, s2))

def find_z(x, y):
    z = []
    for a, b in zip(x, y):

        if a > b:
            return ""-1""

        z.append(b)
    return ''.join(z)

x = input().strip()
y = input().strip()

result = find_z(x, y)

print(result)"
250,A,Paper Work,PROGRAMMING,['greedy'],"Polycarpus has been working in the analytic department of the ""F.R.A.U.D."" company for as much as *n* days. Right now his task is to make a series of reports about the company's performance for the last *n* days. We know that the main information in a day report is value *a**i*, the company's profit on the *i*-th day. If *a**i* is negative, then the company suffered losses on the *i*-th day.

Polycarpus should sort the daily reports into folders. Each folder should include data on the company's performance for several consecutive days. Of course, the information on each of the *n* days should be exactly in one folder. Thus, Polycarpus puts information on the first few days in the first folder. The information on the several following days goes to the second folder, and so on.

It is known that the boss reads one daily report folder per day. If one folder has three or more reports for the days in which the company suffered losses (*a**i*<=&lt;<=0), he loses his temper and his wrath is terrible.

Therefore, Polycarpus wants to prepare the folders so that none of them contains information on three or more days with the loss, and the number of folders is minimal.

Write a program that, given sequence *a**i*, will print the minimum number of folders.","The first line contains integer *n* (1<=≤<=*n*<=≤<=100), *n* is the number of days. The second line contains a sequence of integers *a*1,<=*a*2,<=...,<=*a**n* (|*a**i*|<=≤<=100), where *a**i* means the company profit on the *i*-th day. It is possible that the company has no days with the negative *a**i*.","Print an integer *k* — the required minimum number of folders. In the second line print a sequence of integers *b*1, *b*2, ..., *b**k*, where *b**j* is the number of day reports in the *j*-th folder.

If there are multiple ways to sort the reports into *k* days, print any of them.","['11\n1 2 3 -4 -5 -6 5 -5 -6 -7 6\n', '5\n0 -1 100 -1 0\n']","['3\n5 3 3 ', '1\n5 ']","Here goes a way to sort the reports from the first sample into three folders: 

In the second sample you can put all five reports in one folder.",WRONG_ANSWER,"import sys

input = sys.stdin.readline

def inp_int():
    return (int(input()))

def inp_int_list():
    return (list(map(int, input().split())))

def inp_str():
    s = input()
    return (list(s[:len(s) - 1]))

def invr():
    return (map(int, input().split()))

def folder_generator(_profit_list):
    folder_list = []
    threshold = 2
    cnt = 0
    for i in range(len(_profit_list)):
        if _profit_list[i]<0:
            if threshold == 0:
                folder_list.append(str(cnt))
                threshold = 2
                cnt = 0
            threshold -= 1
        cnt +=1
        if i == len(_profit_list)-1:
            folder_list.append(str(cnt))
            return folder_list

    return folder_list

if __name__ == '__main__':
    day_num = inp_int()
    profit_list = inp_int_list()
    print(profit_list)
    result = folder_generator(profit_list)
    print(len(result))
    print(' '.join(result))","def min_folders(n, profits):
    folders = []
    count_negatives = 0
    current_folder_size = 0

    for profit in profits:
        if profit <= 0:
            count_negatives += 1
        
        current_folder_size += 1

        if count_negatives == 3:
            folders.append(current_folder_size - 1)
            current_folder_size = 1
            count_negatives = 1 if profit <= 0 else 0

    if current_folder_size > 0:
        folders.append(current_folder_size)

    return len(folders), folders

input_data = ['11\n1 2 3 -4 -5 -6 5 -5 -6 -7 6\n', '5\n0 -1 100 -1 0\n']
for data in input_data:
    n, profits = data.splitlines()
    n = int(n)
    profits = list(map(int, profits.split()))

    k, folder_sizes = min_folders(n, profits)

    print(k)
    print("" "".join(map(str, folder_sizes)))"
765,A,Neverending competitions,PROGRAMMING,"['implementation', 'math']","There are literally dozens of snooker competitions held each year, and team Jinotega tries to attend them all (for some reason they prefer name ""snookah"")! When a competition takes place somewhere far from their hometown, Ivan, Artsem and Konstantin take a flight to the contest and back.

Jinotega's best friends, team Base have found a list of their itinerary receipts with information about departure and arrival airports. Now they wonder, where is Jinotega now: at home or at some competition far away? They know that: 
 -  this list contains all Jinotega's flights in this year (in arbitrary order), -  Jinotega has only flown from his hometown to a snooker contest and back, -  after each competition Jinotega flies back home (though they may attend a competition in one place several times), -  and finally, at the beginning of the year Jinotega was at home. 
Please help them to determine Jinotega's location!","In the first line of input there is a single integer *n*: the number of Jinotega's flights (1<=≤<=*n*<=≤<=100). In the second line there is a string of 3 capital Latin letters: the name of Jinotega's home airport. In the next *n* lines there is flight information, one flight per line, in form ""XXX-&gt;YYY"", where ""XXX"" is the name of departure airport ""YYY"" is the name of arrival airport. Exactly one of these airports is Jinotega's home airport.

It is guaranteed that flights information is consistent with the knowledge of Jinotega's friends, which is described in the main part of the statement.","If Jinotega is now at home, print ""home"" (without quotes), otherwise print ""contest"".","['4\nSVO\nSVO-&gt;CDG\nLHR-&gt;SVO\nSVO-&gt;LHR\nCDG-&gt;SVO\n', '3\nSVO\nSVO-&gt;HKT\nHKT-&gt;SVO\nSVO-&gt;RAP\n']","['home\n', 'contest\n']","In the first sample Jinotega might first fly from SVO to CDG and back, and then from SVO to LHR and back, so now they should be at home. In the second sample Jinotega must now be at RAP because a flight from RAP back to SVO is not on the list.",WRONG_ANSWER,"from collections import defaultdict
def solve(h,d):
    if(len(d[h])==len(d)-1):
        return ""home""
    return ""contest""
n = int(input())
h = input()
d = defaultdict(list)
for i in range(n):
    l = input().split(""->"")
    d[l[0]].append(l[-1])
print(solve(h,d))","def determine_location(flights_data):

    n, home_airport = flights_data[0], flights_data[1]
    flights = flights_data[2:]

    departures = 0
    arrivals = 0

    for flight in flights:
        departure, arrival = flight.split('->')
        departure = departure.strip()
        arrival = arrival.strip()

        if departure == home_airport:
            departures += 1

        elif arrival == home_airport:
            arrivals += 1

    if departures == arrivals:
        return ""home""
    else:
        return ""contest""

input_data_1 = [4, 'SVO', 'SVO->CDG', 'LHR->SVO', 'SVO->LHR', 'CDG->SVO']
input_data_2 = [3, 'SVO', 'SVO->HKT', 'HKT->SVO', 'SVO->RAP']

print(determine_location(input_data_1))
print(determine_location(input_data_2))"
518,B,Tanya and Postcard,PROGRAMMING,"['greedy', 'implementation', 'strings']","Little Tanya decided to present her dad a postcard on his Birthday. She has already created a message — string *s* of length *n*, consisting of uppercase and lowercase English letters. Tanya can't write yet, so she found a newspaper and decided to cut out the letters and glue them into the postcard to achieve string *s*. The newspaper contains string *t*, consisting of uppercase and lowercase English letters. We know that the length of string *t* greater or equal to the length of the string *s*.

The newspaper may possibly have too few of some letters needed to make the text and too many of some other letters. That's why Tanya wants to cut some *n* letters out of the newspaper and make a message of length exactly *n*, so that it looked as much as possible like *s*. If the letter in some position has correct value and correct letter case (in the string *s* and in the string that Tanya will make), then she shouts joyfully ""YAY!"", and if the letter in the given position has only the correct value but it is in the wrong case, then the girl says ""WHOOPS"".

Tanya wants to make such message that lets her shout ""YAY!"" as much as possible. If there are multiple ways to do this, then her second priority is to maximize the number of times she says ""WHOOPS"". Your task is to help Tanya make the message.","The first line contains line *s* (1<=≤<=|*s*|<=≤<=2·105), consisting of uppercase and lowercase English letters — the text of Tanya's message.

The second line contains line *t* (|*s*|<=≤<=|*t*|<=≤<=2·105), consisting of uppercase and lowercase English letters — the text written in the newspaper.

Here |*a*| means the length of the string *a*.","Print two integers separated by a space:
 -  the first number is the number of times Tanya shouts ""YAY!"" while making the message, -  the second number is the number of times Tanya says ""WHOOPS"" while making the message.","['AbC\nDCbA\n', 'ABC\nabc\n', 'abacaba\nAbaCaBA\n']","['3 0\n', '0 3\n', '3 4\n']",none,WRONG_ANSWER,"from collections import defaultdict

s = input()
t = input()
cntS = defaultdict(int)
for c in s:
    cntS[c] += 1
cntT = defaultdict(int)
for c in t:
    cntT[c] += 1
nHas = 0
for c in set(s):
    nHas += min(cntS[c], cntT[c])
print('%d %d' % (nHas, len(s) - nHas))","def count_shouts(s, t):

    from collections import Counter
    count_s = Counter(s)
    count_t = Counter(t)

    yay_count = 0
    whoops_count = 0

    for char in count_s:
        if char in count_t:
            matches = min(count_s[char], count_t[char])
            yay_count += matches
            count_s[char] -= matches
            count_t[char] -= matches

    for char in count_s:
        if count_s[char] > 0:

            lower_char = char.lower()
            if lower_char in count_t:
                matches = min(count_s[char], count_t[lower_char])
                whoops_count += matches

            upper_char = char.upper()
            if upper_char in count_t:
                matches = min(count_s[char], count_t[upper_char])
                whoops_count += matches

    return yay_count, whoops_count

input_strings = ['AbC\nDCbA\n', 'ABC\nabc\n', 'abacaba\nAbaCaBA\n']
output = []

for case in input_strings:
    s, t = case.strip().split('\n')
    yay, whoops = count_shouts(s, t)
    output.append(f""{yay} {whoops}"")

for result in output:
    print(result)"
914,D,Bash and a Tough Math Puzzle,PROGRAMMING,"['data structures', 'number theory']","Bash likes playing with arrays. He has an array *a*1,<=*a*2,<=... *a**n* of *n* integers. He likes to guess the greatest common divisor (gcd) of different segments of the array. Of course, sometimes the guess is not correct. However, Bash will be satisfied if his guess is almost correct.

Suppose he guesses that the gcd of the elements in the range [*l*,<=*r*] of *a* is *x*. He considers the guess to be almost correct if he can change at most one element in the segment such that the gcd of the segment is *x* after making the change. Note that when he guesses, he doesn't actually change the array — he just wonders if the gcd of the segment can be made *x*. Apart from this, he also sometimes makes changes to the array itself.

Since he can't figure it out himself, Bash wants you to tell him which of his guesses are almost correct. Formally, you have to process *q* queries of one of the following forms:
 -  1<=*l*<=*r*<=*x* — Bash guesses that the gcd of the range [*l*,<=*r*] is *x*. Report if this guess is almost correct. -  2<=*i*<=*y* — Bash sets *a**i* to *y*. 
Note: The array is 1-indexed.","The first line contains an integer *n* (1<=≤<=*n*<=≤<=5·105)  — the size of the array.

The second line contains *n* integers *a*1,<=*a*2,<=...,<=*a**n* (1<=≤<=*a**i*<=≤<=109)  — the elements of the array.

The third line contains an integer *q* (1<=≤<=*q*<=≤<=4·105)  — the number of queries.

The next *q* lines describe the queries and may have one of the following forms:
 -  1<=*l*<=*r*<=*x* (1<=≤<=*l*<=≤<=*r*<=≤<=*n*,<=1<=≤<=*x*<=≤<=109). -  2<=*i*<=*y* (1<=≤<=*i*<=≤<=*n*,<=1<=≤<=*y*<=≤<=109). 
Guaranteed, that there is at least one query of first type.","For each query of first type, output ""YES"" (without quotes) if Bash's guess is almost correct and ""NO"" (without quotes) otherwise.","['3\n2 6 3\n4\n1 1 2 2\n1 1 3 3\n2 1 9\n1 1 3 2\n', '5\n1 2 3 4 5\n6\n1 1 4 2\n2 3 6\n1 1 4 2\n1 1 5 2\n2 5 10\n1 1 5 2\n']","['YES\nYES\nNO\n', 'NO\nYES\nNO\nYES\n']","In the first sample, the array initially is {2, 6, 3}. 

For query 1, the first two numbers already have their gcd as 2.

For query 2, we can achieve a gcd of 3 by changing the first element of the array to 3. Note that the changes made during queries of type 1 are temporary and do not get reflected in the array. 

After query 3, the array is now {9, 6, 3}.

 For query 4, no matter which element you change, you cannot get the gcd of the range to be 2.",WRONG_ANSWER,"import sys
input = sys.stdin.buffer.readline

def gcd(a, b):
    while b:
        a,b = b,a%b
    return a

n = int(input())

A = [int(x) for x in input().split()]
B = [0] * n + A
for i in range(n, 2 * n):
    B[i // 2] = gcd(B[i], B[i // 2])

q = int(input())
for _ in range(q):
    S = [int(x) for x in input().split()]
    if S[0] == 1:
        _,l,r,x = S
        l -= 1
        
        count = 0
        ind = 3 * n
        
        l += n
        r += n
        while l < r:
            if l & 1 and B[l] % x:
                ind = l
                count += 1
            if r & 1 and B[r - 1] % x:
                ind = r - 1
                count += 1
            l += 1
            l //= 2
            r //= 2

        while ind < n:
            ind1 = 2 * ind
            ind2 = 2 * ind + 1

            if B[ind1] % x:
                count += B[ind2] % x
                ind = ind1
            else:
                count += B[ind1] % x
                ind = ind2
        if count <= 1:
            print('YES')
        else:
            print('NO')

    else:
        _,i,y = S
        i -= 1

        i += n
        B[i] = y
        i //= 2
        while i:
            B[i] = gcd(B[2 * i], B[2 * i + 1])
            i //= 2","import sys
from math import gcd
from sys import stdin, stdout
from functools import reduce

def gcd_of_range(arr, l, r):
    return reduce(gcd, arr[l-1:r])

def process_queries(n, arr, queries):
    output = []
    
    for query in queries:
        parts = list(map(int, query.split()))
        
        if parts[0] == 1:
            l, r, x = parts[1], parts[2], parts[3]
            current_gcd = gcd_of_range(arr, l, r)
            
            if current_gcd == x:
                output.append(""YES"")
            else:

                temp_array = arr[l-1:r]
                if x % current_gcd == 0:
                    if len(temp_array) == 1:
                        if x >= temp_array[0]:
                            output.append(""YES"")
                        else:
                            output.append(""NO"")
                    else:
                        can_change = any(gcd(x, value) == x for value in temp_array)
                        if can_change:
                            output.append(""YES"")
                        else:
                            output.append(""NO"")
                else:
                    output.append(""NO"")

        elif parts[0] == 2:
            i, y = parts[1], parts[2]
            arr[i-1] = y

    return output

def main():
    input = stdin.read
    data = input().strip().splitlines()
    
    n = int(data[0])
    arr = list(map(int, data[1].split()))
    q = int(data[2])
    queries = data[3:3+q]

    result = process_queries(n, arr, queries)
    stdout.write(""\n"".join(result) + ""\n"")

if __name__ == ""__main__"":
    main()"
509,A,Maximum in Table,PROGRAMMING,"['brute force', 'implementation']","An *n*<=×<=*n* table *a* is defined as follows:
 -  The first row and the first column contain ones, that is: *a**i*,<=1<==<=*a*1,<=*i*<==<=1 for all *i*<==<=1,<=2,<=...,<=*n*. -  Each of the remaining numbers in the table is equal to the sum of the number above it and the number to the left of it. In other words, the remaining elements are defined by the formula *a**i*,<=*j*<==<=*a**i*<=-<=1,<=*j*<=+<=*a**i*,<=*j*<=-<=1. 
These conditions define all the values in the table.

You are given a number *n*. You need to determine the maximum value in the *n*<=×<=*n* table defined by the rules above.",The only line of input contains a positive integer *n* (1<=≤<=*n*<=≤<=10) — the number of rows and columns of the table.,Print a single line containing a positive integer *m* — the maximum value in the table.,"['1\n', '5\n']","['1', '70']",In the second test the rows of the table look as follows:,OK,"def fact(n):
    if n == 0:
        return 1
    else:
        return n * fact(n-1)
n=int(input())
a=2*(n-1)
b=a//2
if n==1:
    print(1)
else:
    print(fact(a)//(fact(b)*fact(a-b)))","def max_value_in_table(n):

    table = [[0] * (n + 1) for _ in range(n + 1)]

    for i in range(1, n + 1):
        table[i][1] = 1
        table[1][i] = 1

    for i in range(2, n + 1):
        for j in range(2, n + 1):
            table[i][j] = table[i - 1][j] + table[i][j - 1]

    return table[n][n]

n = int(input().strip())

print(max_value_in_table(n))"
350,B,Resort,PROGRAMMING,['graphs'],"Valera's finally decided to go on holiday! He packed up and headed for a ski resort.

Valera's fancied a ski trip but he soon realized that he could get lost in this new place. Somebody gave him a useful hint: the resort has *n* objects (we will consider the objects indexed in some way by integers from 1 to *n*), each object is either a hotel or a mountain.

Valera has also found out that the ski resort had multiple ski tracks. Specifically, for each object *v*, the resort has at most one object *u*, such that there is a ski track built from object *u* to object *v*. We also know that no hotel has got a ski track leading from the hotel to some object.

Valera is afraid of getting lost on the resort. So he wants you to come up with a path he would walk along. The path must consist of objects *v*1,<=*v*2,<=...,<=*v**k* (*k*<=≥<=1) and meet the following conditions:
 1.  Objects with numbers *v*1,<=*v*2,<=...,<=*v**k*<=-<=1 are mountains and the object with number *v**k* is the hotel. 1.  For any integer *i* (1<=≤<=*i*<=&lt;<=*k*), there is exactly one ski track leading from object *v**i*. This track goes to object *v**i*<=+<=1. 1.  The path contains as many objects as possible (*k* is maximal). 
Help Valera. Find such path that meets all the criteria of our hero!","The first line contains integer *n* (1<=≤<=*n*<=≤<=105) — the number of objects.

The second line contains *n* space-separated integers *type*1,<=*type*2,<=...,<=*type**n* — the types of the objects. If *type**i* equals zero, then the *i*-th object is the mountain. If *type**i* equals one, then the *i*-th object is the hotel. It is guaranteed that at least one object is a hotel.

The third line of the input contains *n* space-separated integers *a*1,<=*a*2,<=...,<=*a**n* (0<=≤<=*a**i*<=≤<=*n*) — the description of the ski tracks. If number *a**i* equals zero, then there is no such object *v*, that has a ski track built from *v* to *i*. If number *a**i* doesn't equal zero, that means that there is a track built from object *a**i* to object *i*.","In the first line print *k* — the maximum possible path length for Valera. In the second line print *k* integers *v*1,<=*v*2,<=...,<=*v**k* — the path. If there are multiple solutions, you can print any of them.","['5\n0 0 0 0 1\n0 1 2 3 4\n', '5\n0 0 1 0 1\n0 1 2 2 4\n', '4\n1 0 0 0\n2 3 4 2\n']","['5\n1 2 3 4 5\n', '2\n4 5\n', '1\n1\n']",none,OK,"def solve():
	n = int(input())
	arr = list(map(int,input().split()))
	parent = list(map(int,input().split()))
	degree = [0]*n
	for i in range(n):
		parent[i] -=1
		if parent[i]!=-1:
			degree[parent[i]]+=1
	ans = []
	visited = [False]*n
	for i in range(n):
		if arr[i]==1:
			s = i
			tmp = []
			while parent[s]!=-1 and degree[parent[s]]<=1:
				tmp.append(s)
				s = parent[s]
			tmp.append(s)
			if len(tmp)>len(ans):
				ans = tmp
	ans = ans[::-1]
	print(len(ans))
	for i in ans:
		print(i+1,end=' ')

t = 1

for i in range(t):
	solve()","def find_path(n, types, tracks):

    path = []
    current = None

    for i in range(n-1, -1, -1):
        if types[i] == 1:
            current = i + 1
            break

    while current is not None and current > 0:
        path.append(current)
        current = tracks[current - 1]

    path.reverse()
    print(len(path))
    print(' '.join(map(str, path)))

import sys
input = sys.stdin.read
data = input().splitlines()
n = int(data[0])
types = list(map(int, data[1].split()))
tracks = list(map(int, data[2].split()))

find_path(n, types, tracks)"
115,A,Party,PROGRAMMING,"['dfs and similar', 'graphs', 'trees']","A company has *n* employees numbered from 1 to *n*. Each employee either has no immediate manager or exactly one immediate manager, who is another employee with a different number. An employee *A* is said to be the superior of another employee *B* if at least one of the following is true:
 -  Employee *A* is the immediate manager of employee *B* -  Employee *B* has an immediate manager employee *C* such that employee *A* is the superior of employee *C*. 
The company will not have a managerial cycle. That is, there will not exist an employee who is the superior of his/her own immediate manager.

Today the company is going to arrange a party. This involves dividing all *n* employees into several groups: every employee must belong to exactly one group. Furthermore, within any single group, there must not be two employees *A* and *B* such that *A* is the superior of *B*.

What is the minimum number of groups that must be formed?","The first line contains integer *n* (1<=≤<=*n*<=≤<=2000) — the number of employees.

The next *n* lines contain the integers *p**i* (1<=≤<=*p**i*<=≤<=*n* or *p**i*<==<=-1). Every *p**i* denotes the immediate manager for the *i*-th employee. If *p**i* is -1, that means that the *i*-th employee does not have an immediate manager. 

It is guaranteed, that no employee will be the immediate manager of him/herself (*p**i*<=≠<=*i*). Also, there will be no managerial cycles.",Print a single integer denoting the minimum number of groups that will be formed in the party.,['5\n-1\n1\n2\n1\n-1\n'],['3\n'],"For the first example, three groups are sufficient, for example: 
 -  Employee 1 -  Employees 2 and 4 -  Employees 3 and 5",WRONG_ANSWER,"n = int(input())
graph = [[] for _ in range(n+1)]
for i in range(1, n+1):
    supervisor = int(input())
    if supervisor != -1:
        graph[supervisor].append(i)
        print(graph)

def dfs(node, depth):
    max_depth = depth
    print (depth)
    for child in graph[node]:
        max_depth = max(max_depth, dfs(child, depth+1))
    return max_depth

ans = 0
for i in range(1, n+1):
    ans = max(ans, dfs(i, 1))

print(ans)","def min_groups(n, managers):

    tree = [[] for _ in range(n + 1)]
    for employee in range(1, n + 1):
        manager = managers[employee - 1]
        if manager != -1:
            tree[manager].append(employee)

    def depth(node):
        if not tree[node]:
            return 1
        return 1 + max(depth(child) for child in tree[node])

    max_depth = 0
    for employee in range(1, n + 1):
        if managers[employee - 1] == -1:
            max_depth = max(max_depth, depth(employee))
    
    return max_depth

n = int(input())
managers = [int(input()) for _ in range(n)]

print(min_groups(n, managers))"
109,A,Lucky Sum of Digits,PROGRAMMING,"['brute force', 'implementation']","Petya loves lucky numbers. We all know that lucky numbers are the positive integers whose decimal representations contain only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.

Petya wonders eagerly what minimum lucky number has the sum of digits equal to *n*. Help him cope with the task.",The single line contains an integer *n* (1<=≤<=*n*<=≤<=106) — the sum of digits of the required lucky number.,"Print on the single line the result — the minimum lucky number, whose sum of digits equals *n*. If such number does not exist, print -1.","['11\n', '10\n']","['47\n', '-1\n']",none,TIME_LIMIT_EXCEEDED,"def getSum(n):
    return 0 if n==0 else  int(n%10)+getSum(n//10)
n = int(input())
flag = 0
for i in range(10**6):
    if(getSum(i)==n):
        if i==4 or i==7 or i==47 or i==74:
            mini = i
            flag = 1
            break
        else:
            continue
if(flag):
    print(mini)
else:
    print(-1)","def find_min_lucky_number(n):

    lucky_digits = []

    while n > 0:

        if n >= 4:
            lucky_digits.append(4)
            n -= 4

        elif n >= 7:
            lucky_digits.append(7)
            n -= 7
        else:

            return -1

    lucky_digits.sort()

    return ''.join(map(str, lucky_digits))

n = int(input().strip())

result = find_min_lucky_number(n)

print(result)"
347,A,Difference Row,PROGRAMMING,"['constructive algorithms', 'implementation', 'sortings']","You want to arrange *n* integers *a*1,<=*a*2,<=...,<=*a**n* in some order in a row. Let's define the value of an arrangement as the sum of differences between all pairs of adjacent integers.

More formally, let's denote some arrangement as a sequence of integers *x*1,<=*x*2,<=...,<=*x**n*, where sequence *x* is a permutation of sequence *a*. The value of such an arrangement is (*x*1<=-<=*x*2)<=+<=(*x*2<=-<=*x*3)<=+<=...<=+<=(*x**n*<=-<=1<=-<=*x**n*).

Find the largest possible value of an arrangement. Then, output the lexicographically smallest sequence *x* that corresponds to an arrangement of the largest possible value.","The first line of the input contains integer *n* (2<=≤<=*n*<=≤<=100). The second line contains *n* space-separated integers *a*1, *a*2, ..., *a**n* (|*a**i*|<=≤<=1000).","Print the required sequence *x*1,<=*x*2,<=...,<=*x**n*. Sequence *x* should be the lexicographically smallest permutation of *a* that corresponds to an arrangement of the largest possible value.",['5\n100 -100 50 0 -50\n'],['100 -50 0 50 -100 \n'],"In the sample test case, the value of the output arrangement is (100 - ( - 50)) + (( - 50) - 0) + (0 - 50) + (50 - ( - 100)) = 200. No other arrangement has a larger value, and among all arrangements with the value of 200, the output arrangement is the lexicographically smallest one.

Sequence *x*<sub class=""lower-index"">1</sub>, *x*<sub class=""lower-index"">2</sub>, ... , *x*<sub class=""lower-index"">*p*</sub> is lexicographically smaller than sequence *y*<sub class=""lower-index"">1</sub>, *y*<sub class=""lower-index"">2</sub>, ... , *y*<sub class=""lower-index"">*p*</sub> if there exists an integer *r* (0 ≤ *r* &lt; *p*) such that *x*<sub class=""lower-index"">1</sub> = *y*<sub class=""lower-index"">1</sub>, *x*<sub class=""lower-index"">2</sub> = *y*<sub class=""lower-index"">2</sub>, ... , *x*<sub class=""lower-index"">*r*</sub> = *y*<sub class=""lower-index"">*r*</sub> and *x*<sub class=""lower-index"">*r* + 1</sub> &lt; *y*<sub class=""lower-index"">*r* + 1</sub>.",OK,"def main():
    n = int(input())
    nums = sorted(list(map(int, input().split(' '))))
    temp = nums[0]
    nums[0] = nums[-1]
    nums[-1] = temp
    print(' '.join(map(str, nums)))

main()","def largest_value_permutation(n, a):

    a.sort()

    result = []

    left, right = 0, n - 1

    while left <= right:
        if left == right:
            result.append(a[left])
            break
        result.append(a[right])
        result.append(a[left])
        left += 1
        right -= 1
        
    return result

n = int(input())
a = list(map(int, input().split()))

result = largest_value_permutation(n, a)

print("" "".join(map(str, result)))"
20,C,Dijkstra?,PROGRAMMING,"['graphs', 'shortest paths']",You are given a weighted undirected graph. The vertices are enumerated from 1 to *n*. Your task is to find the shortest path between the vertex 1 and the vertex *n*.,"The first line contains two integers *n* and *m* (2<=≤<=*n*<=≤<=105,<=0<=≤<=*m*<=≤<=105), where *n* is the number of vertices and *m* is the number of edges. Following *m* lines contain one edge each in form *a**i*, *b**i* and *w**i* (1<=≤<=*a**i*,<=*b**i*<=≤<=*n*,<=1<=≤<=*w**i*<=≤<=106), where *a**i*,<=*b**i* are edge endpoints and *w**i* is the length of the edge.

It is possible that the graph has loops and multiple edges between pair of vertices.","Write the only integer -1 in case of no path. Write the shortest path in opposite case. If there are many solutions, print any of them.","['5 6\n1 2 2\n2 5 5\n2 3 4\n1 4 1\n4 3 3\n3 5 1\n', '5 6\n1 2 2\n2 5 5\n2 3 4\n1 4 1\n4 3 3\n3 5 1\n']","['1 4 3 5 ', '1 4 3 5 ']",none,MEMORY_LIMIT_EXCEEDED,"from collections import defaultdict
from heapq import heappush, heappop

def djk(graph, start, dest, visited):
    minheap = [(0, start, -1)]
    while minheap:
        cost, cur, parent = heappop(minheap) 

        if cur in visited:
            continue

        visited[cur] = parent
        if cur == dest:
            return visited

        for w, nbr in graph[cur]:
            if nbr not in visited:
                heappush(minheap, (w+cost, nbr, cur))
    return None

def solution():
    n, m = map(int, input().split())
    graph = defaultdict(list)

    for _ in range(m):
        a,b, w = map(int, input().split())
        graph[a].append((w, b))
        graph[b].append((w, a))

    visited = djk(graph, 1, n, dict()) 
    if visited == None:
        print(-1)
        return;

    path = []
    cur = n
    while cur > -1:
        path.append(cur)
        cur = visited[cur]
    print("" "".join(map(str, path[::-1])))
        

import sys
import threading
sys.setrecursionlimit(1 << 30)
threading.stack_size(1 << 27)
thread = threading.Thread(target=solution)
thread.start(); thread.join()","import heapq
from collections import defaultdict

def dijkstra(n, edges):

    graph = defaultdict(list)
    for a, b, w in edges:
        graph[a].append((b, w))
        graph[b].append((a, w))

    pq = [(0, 1)]
    distances = {i: float('inf') for i in range(1, n + 1)}
    distances[1] = 0
    previous = {i: None for i in range(1, n + 1)}

    while pq:
        current_distance, current_vertex = heapq.heappop(pq)

        if current_vertex == n:
            break

        if current_distance > distances[current_vertex]:
            continue
            
        for neighbor, weight in graph[current_vertex]:
            distance = current_distance + weight

            if distance < distances[neighbor]:
                distances[neighbor] = distance
                previous[neighbor] = current_vertex
                heapq.heappush(pq, (distance, neighbor))

    if distances[n] == float('inf'):
        return -1

    path = []
    vertex = n
    while vertex is not None:
        path.append(vertex)
        vertex = previous[vertex]
    
    path.reverse()
    return ' '.join(map(str, path))

def main():

    import sys
    input = sys.stdin.read
    data = input().strip().splitlines()
    
    n, m = map(int, data[0].split())
    edges = []
    
    for i in range(1, m + 1):
        a, b, w = map(int, data[i].split())
        edges.append((a, b, w))

    result = dijkstra(n, edges)
    
    print(result)

if __name__ == ""__main__"":
    main()"
